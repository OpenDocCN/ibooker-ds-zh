- en: Chapter 6\. Community Detection Algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章。社区检测算法
- en: Community formation is common in all types of networks, and identifying them
    is essential for evaluating group behavior and emergent phenomena. The general
    principle in finding communities is that its members will have more relationships
    within the group than with nodes outside their group. Identifying these related
    sets reveals clusters of nodes, isolated groups, and network structure. This information
    helps infer similar behavior or preferences of peer groups, estimate resiliency,
    find nested relationships, and prepare data for other analyses. Community detection
    algorithms are also commonly used to produce network visualization for general
    inspection.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有类型的网络中，社区形成都很常见，识别它们对于评估群体行为和 emergent 现象至关重要。找到社区的一般原则是其成员在组内的关系比与组外节点的关系更多。识别这些相关集合揭示了节点的簇、孤立群体和网络结构。这些信息有助于推断同行群体的类似行为或偏好，估计稳健性，找到嵌套关系，并为其他分析准备数据。社区检测算法也常用于生成网络可视化进行常规检查。
- en: 'We’ll provide details on the most representative community detection algorithms:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细介绍最具代表性的社区检测算法：
- en: Triangle Count and Clustering Coefficient for overall relationship density
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三角形计数和聚类系数用于总体关系密度
- en: Strongly Connected Components and Connected Components for finding connected
    clusters
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于查找连接簇的强连通分量和连通分量
- en: Label Propagation for quickly inferring groups based on node labels
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签传播用于基于节点标签快速推断群组
- en: Louvain Modularity for looking at grouping quality and hierarchies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 洛夫镇模块性用于查看分组质量和层次结构
- en: We’ll explain how the algorithms work and show examples in Apache Spark and
    Neo4j. In cases where an algorithm is only available in one platform, we’ll provide
    just one example. We use weighted relationships for these algorithms because they’re
    typically used to capture the significance of different relationships.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将解释算法的工作原理，并在 Apache Spark 和 Neo4j 中展示示例。对于仅在一个平台上可用的算法，我们将仅提供一个示例。我们使用加权关系来进行这些算法，因为它们通常用于捕捉不同关系的重要性。
- en: '[Figure 6-1](#community_overview) gives an overview of the differences between
    the community detection algorithms covered here, and [Table 6-1](#communitydetection-overview-table)
    provides a quick reference as to what each algorithm calculates with example uses.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-1](#community_overview)概述了这里涵盖的社区检测算法之间的差异，而[表 6-1](#communitydetection-overview-table)则提供了每个算法计算的快速参考及其示例用法。'
- en: '![gral 0601](Images/gral_0601.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![gral 0601](Images/gral_0601.png)'
- en: Figure 6-1\. Representative community detection algorithms
  id: totrans-10
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-1\. 代表性社区检测算法
- en: Note
  id: totrans-11
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We use the terms *set*, *partition*, *cluster*, *group*, and *community* interchangeably.
    These terms are different ways to indicate that similar nodes can be grouped.
    Community detection algorithms are also called clustering and partitioning algorithms.
    In each section, we use the terms that are most prominent in the literature for
    a particular algorithm.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将术语*集合*、*分区*、*群*、*组*和*社区*互换使用。这些术语是指相似节点可以被分组的不同方式。社区检测算法也被称为聚类和分区算法。在每个部分中，我们使用文献中最突出的术语来描述特定算法。
- en: Table 6-1\. Overview of community detection algorithms
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-1\. 社区检测算法概述
- en: '| Algorithm type | What it does | Example use | Spark example | Neo4j example
    |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 算法类型 | 功能 | 示例用法 | Spark 示例 | Neo4j 示例 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '|'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[Triangle Count and Clustering Coefficient](#triangles_coefficient)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[三角形计数和聚类系数](#triangles_coefficient)'
- en: '|'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Measures how many nodes form triangles and the degree to which nodes tend to
    cluster together
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 衡量形成三角形的节点数量以及节点倾向于聚集在一起的程度
- en: '|'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Estimating group stability and whether the network might exhibit “small-world”
    behaviors seen in graphs with tightly knit clusters
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 估计组的稳定性以及网络是否可能表现出图形中紧密结合的群集小世界行为
- en: '|'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Yes'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 是的
- en: '|'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Yes'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 是的
- en: '|'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[Strongly Connected Components](#strongly_connected_components)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[强连通分量](#strongly_connected_components)'
- en: '|'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Finds groups where each node is reachable from every other node in that same
    group *following the direction* of relationships
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 查找每个节点都可以从同一组内的每个其他节点*遵循关系的方向*到达的组
- en: '|'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Making product recommendations based on group affiliation or similar items
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 根据组成员或相似项目进行产品推荐
- en: '|'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Yes'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 是的
- en: '|'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Yes'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 是的
- en: '|'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[Connected Components](#weakly_connected_components)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[连通分量](#weakly_connected_components)'
- en: '|'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Finds groups where each node is reachable from every other node in that same
    group, *regardless of the direction* of relationships
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 找到每个节点都可以从同一组中的任何其他节点访问的群组，*无论关系的方向如何*。
- en: '|'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Performing fast grouping for other algorithms and identify islands
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 快速对其他算法进行分组，并识别孤立群体
- en: '|'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Yes'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 是的
- en: '|'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Yes'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 是的
- en: '|'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[Label Propagation](#label_propagation)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[标签传播](#label_propagation)'
- en: '|'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Infers clusters by spreading labels based on neighborhood majorities
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过基于邻域多数传播标签来推断群集
- en: '|'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Understanding consensus in social communities or finding dangerous combinations
    of possible co-prescribed drugs
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 理解社区中的共识或发现可能的联合处方药物的危险组合
- en: '|'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Yes'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 是的
- en: '|'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Yes'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 是的
- en: '|'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[Louvain Modularity](#louvain)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[模块性Louvin](#louvain)'
- en: '|'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Maximizes the presumed accuracy of groupings by comparing relationship weights
    and densities to a defined estimate or average
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过比较关系权重和密度与定义的估计或平均值，最大化假设的分组准确性
- en: '|'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: In fraud analysis, evaluating whether a group has just a few discrete bad behaviors
    or is acting as a fraud ring
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在欺诈分析中，评估一个群组是否只有少量离散的不良行为，或者是否正在行动作为一个欺诈集团
- en: '|'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'No'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 否
- en: '|'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Yes'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 是的
- en: '|'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: First, we’ll describe the data for our examples and walk through importing the
    data into Spark and Neo4j. The algorithms are covered in the order listed in [Table 6-1](#communitydetection-overview-table).
    For each, you’ll find a short description and advice on when to use it. Most sections
    also include guidance on when to use related algorithms. We demonstrate example
    code using sample data at the end of each algorithm section.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将描述我们示例数据的数据，并演示将数据导入Spark和Neo4j的步骤。算法按照[表6-1](#communitydetection-overview-table)中列出的顺序进行介绍。对于每个算法，您将找到一个简短的描述，并且有关何时使用它的建议。大多数部分还包括何时使用相关算法的指导。我们在每个算法部分的末尾使用示例数据演示示例代码。
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: When using community detection algorithms, be conscious of the density of the
    relationships.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用社区检测算法时，要注意关系的密度。
- en: If the graph is very dense, you may end up with all nodes congregating in one
    or just a few clusters. You can counteract this by filtering by degree, relationship
    weights, or similarity metrics.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果图非常密集，可能会导致所有节点聚集在一个或几个簇中。您可以通过度、关系权重或相似度指标进行过滤来抵消这一点。
- en: On the other hand, if the graph is too sparse with few connected nodes, you
    may end up with each node in its own cluster. In this case, try to incorporate
    additional relationship types that carry more relevant information.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果图中连接的节点很少而稀疏，可能会导致每个节点都位于自己的簇中。在这种情况下，尝试整合更多包含更多相关信息的附加关系类型。
- en: 'Example Graph Data: The Software Dependency Graph'
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例图数据：软件依赖图
- en: Dependency graphs are particularly well suited for demonstrating the sometimes
    subtle differences between community detection algorithms because they tend to
    be more connected and hierarchical. The examples in this chapter are run against
    a graph containing dependencies between Python libraries, although dependency
    graphs are used in various fields, from software to energy grids. This kind of
    software dependency graph is used by developers to keep track of transitive interdependencies
    and conflicts in software projects. You can download the nodes and files from
    the [book’s GitHub repository](https://bit.ly/2FPgGVV).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖图在展示社区检测算法之间有时微妙差异方面特别适用，因为它们往往更连接且分层。本章节的示例是针对包含Python库依赖关系的图表运行的，尽管依赖图在软件到能源网络等各个领域都有应用。开发者使用这类软件依赖图来跟踪软件项目中的传递性依赖和冲突。你可以从[书籍的GitHub仓库](https://bit.ly/2FPgGVV)下载节点和文件。
- en: Table 6-2\. *sw-nodes.csv*
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-2\. *sw-nodes.csv*
- en: '| id |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| id |'
- en: '| --- |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| six |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| six |'
- en: '| pandas |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| pandas |'
- en: '| numpy |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| numpy |'
- en: '| python-dateutil |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| python-dateutil |'
- en: '| pytz |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| pytz |'
- en: '| pyspark |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| pyspark |'
- en: '| matplotlib |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| matplotlib |'
- en: '| spacy |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| spacy |'
- en: '| py4j |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| py4j |'
- en: '| jupyter |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| jupyter |'
- en: '| jpy-console |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| jpy-console |'
- en: '| nbconvert |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| nbconvert |'
- en: '| ipykernel |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| ipykernel |'
- en: '| jpy-client |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| jpy-client |'
- en: '| jpy-core |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| jpy-core |'
- en: '|  |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Table 6-3\. *sw-relationships.csv*
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-3\. *sw-relationships.csv*
- en: '| src | dst | relationship |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| src | dst | relationship |'
- en: '| --- | --- | --- |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| pandas | numpy | DEPENDS_ON |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| pandas | numpy | DEPENDS_ON |'
- en: '| pandas | pytz | DEPENDS_ON |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| pandas | pytz | DEPENDS_ON |'
- en: '| pandas | python-dateutil | DEPENDS_ON |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| pandas | python-dateutil | DEPENDS_ON |'
- en: '| python-dateutil | six | DEPENDS_ON |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| python-dateutil | six | DEPENDS_ON |'
- en: '| pyspark | py4j | DEPENDS_ON |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| pyspark | py4j | DEPENDS_ON |'
- en: '| matplotlib | numpy | DEPENDS_ON |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| matplotlib | numpy | DEPENDS_ON |'
- en: '| matplotlib | python-dateutil | DEPENDS_ON |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| matplotlib | python-dateutil | DEPENDS_ON |'
- en: '| matplotlib | six | DEPENDS_ON |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| matplotlib | six | DEPENDS_ON |'
- en: '| matplotlib | pytz | DEPENDS_ON |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| matplotlib | pytz | DEPENDS_ON |'
- en: '| spacy | six | DEPENDS_ON |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| spacy | six | DEPENDS_ON |'
- en: '| spacy | numpy | DEPENDS_ON |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| spacy | numpy | DEPENDS_ON |'
- en: '| jupyter | nbconvert | DEPENDS_ON |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| jupyter | nbconvert | DEPENDS_ON |'
- en: '| jupyter | ipykernel | DEPENDS_ON |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| jupyter | ipykernel | DEPENDS_ON |'
- en: '| jupyter | jpy-console | DEPENDS_ON |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| jupyter | jpy-console | DEPENDS_ON |'
- en: '| jpy-console | jpy-client | DEPENDS_ON |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| jpy-console | jpy-client | DEPENDS_ON |'
- en: '| jpy-console | ipykernel | DEPENDS_ON |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| jpy-console | ipykernel | DEPENDS_ON |'
- en: '| jpy-client | jpy-core | DEPENDS_ON |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| jpy-client | jpy-core | DEPENDS_ON |'
- en: '| nbconvert | jpy-core | DEPENDS_ON |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| nbconvert | jpy-core | DEPENDS_ON |'
- en: '[Figure 6-2](#community_detection-graph) shows the graph that we want to construct.
    Looking at this graph, we see that there are three clusters of libraries. We can
    use visualizations on smaller datasets as a tool to help validate the clusters
    derived by community detection algorithms.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-2](#community_detection-graph)显示了我们希望构建的图。查看此图，我们可以看到有三个库的聚类。我们可以使用较小数据集上的可视化作为工具，帮助验证由社区检测算法得出的聚类。'
- en: '![gral 0602](Images/gral_0602.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![gral 0602](Images/gral_0602.png)'
- en: Figure 6-2\. The graph model
  id: totrans-120
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-2\. 图模型
- en: Let’s create graphs in Spark and Neo4j from the example CSV files.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从示例CSV文件在Spark和Neo4j中创建图形。
- en: Importing the Data into Apache Spark
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据导入到Apache Spark
- en: 'We’ll first import the packages we need from Apache Spark and the GraphFrames
    package:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从Apache Spark和GraphFrames包中导入我们需要的包：
- en: '[PRE0]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following function creates a GraphFrame from the example CSV files:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的函数从示例CSV文件创建一个GraphFrame：
- en: '[PRE1]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now let’s call that function:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们调用那个函数：
- en: '[PRE2]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Importing the Data into Neo4j
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据导入到Neo4j
- en: 'Next we’ll do the same for Neo4j. The following query imports the nodes:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将为Neo4j执行相同操作。以下查询导入节点：
- en: '[PRE3]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And this imports the relationships:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 并且这导入了关系：
- en: '[PRE4]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that we’ve got our graphs loaded it’s on to the algorithms!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们加载了我们的图形，就可以运行算法了！
- en: Triangle Count and Clustering Coefficient
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三角形计数和聚类系数
- en: The Triangle Count and Clustering Coefficient algorithms are presented together
    because they are so often used together. Triangle Count determines the number
    of triangles passing through each node in the graph. A triangle is a set of three
    nodes, where each node has a relationship to all other nodes. Triangle Count can
    also be run globally for evaluating our overall dataset.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 三角形计数和聚类系数算法经常一起使用，因此它们一起呈现。三角形计数确定图中每个节点通过的三角形数量。三角形是三个节点的集合，其中每个节点与所有其他节点都有关系。可以全局运行三角形计数来评估我们的整体数据集。
- en: Note
  id: totrans-137
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: Networks with a high number of triangles are more likely to exhibit small-world
    structures and behaviors.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 具有大量三角形的网络更可能表现出小世界结构和行为。
- en: The goal of the Clustering Coefficient algorithm is to measure how tightly a
    group is clustered compared to how tightly it could be clustered. The algorithm
    uses Triangle Count in its calculations, which provides a ratio of existing triangles
    to possible relationships. A maximum value of 1 indicates a clique where every
    node is connected to every other node.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 聚类系数算法的目标是衡量一个群体相对于其可以聚集的紧密程度。该算法在计算中使用三角形计数，该计数提供了现有三角形与可能关系的比率。值为1表示一个每个节点都连接到每个其他节点的团。
- en: 'There are two types of clustering coefficients: local clustering and global
    clustering.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的聚类系数：局部聚类和全局聚类。
- en: Local Clustering Coefficient
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 局部聚类系数
- en: The local clustering coefficient of a node is the likelihood that its neighbors
    are also connected. The computation of this score involves triangle counting.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的局部聚类系数是其邻居也连接的可能性。计算此分数涉及三角形计数。
- en: The clustering coefficient of a node can be found by multiplying the number
    of triangles passing through the node by two and then diving that by the maximum
    number of relationships in the group, which is always the degree of that node,
    minus one. Examples of different triangles and clustering coefficients for a node
    with five relationships are portrayed in [Figure 6-3](#triangle-clustercoeff).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将通过节点的三角形数量乘以两倍，然后除以组中最大关系数（始终是该节点的度数减一），可以找到节点的聚类系数。一个节点有五个关系的不同三角形和聚类系数的示例在[图 6-3](#triangle-clustercoeff)中展示。
- en: '![gral 0603](Images/gral_0603.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![gral 0603](Images/gral_0603.png)'
- en: Figure 6-3\. Triangle counts and clustering coefficients for node u
  id: totrans-145
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-3\. 节点 u 的三角形计数和聚类系数
- en: Note in [Figure 6-3](#triangle-clustercoeff), we use a node with five relationships
    which makes it appear that the clustering coefficient will always equate to 10%
    of the number of triangles. We can see this is not the case when we alter the
    number of relationships. If we change the second example to have four relationships
    (and the same two triangles) then the coefficient is 0.33.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在[图6-3](#triangle-clustercoeff)中，我们使用一个具有五个关系的节点，使得聚类系数似乎总是等于三角形数量的10%。当我们改变关系的数量时，我们可以看到这并不总是成立。如果我们将第二个例子改为具有四个关系（和相同的两个三角形），那么系数为0.33。
- en: 'The clustering coefficient for a node uses the formula:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的聚类系数使用以下公式：
- en: <math display="inline"><mrow><mi>C</mi> <mi>C</mi> <mrow><mo>(</mo> <mi>u</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mfrac><mrow><mn>2</mn><msub><mi>R</mi> <mi>u</mi></msub></mrow>
    <mrow><msub><mi>k</mi> <mi>u</mi></msub> <mrow><mo>(</mo><msub><mi>k</mi> <mi>u</mi></msub>
    <mo>-</mo><mn>1</mn><mo>)</mo></mrow></mrow></mfrac></mrow></math>
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="inline"><mrow><mi>C</mi> <mi>C</mi> <mrow><mo>(</mo> <mi>u</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mfrac><mrow><mn>2</mn><msub><mi>R</mi> <mi>u</mi></msub></mrow>
    <mrow><msub><mi>k</mi> <mi>u</mi></msub> <mrow><mo>(</mo><msub><mi>k</mi> <mi>u</mi></msub>
    <mo>-</mo><mn>1</mn><mo>)</mo></mrow></mrow></mfrac></mrow></math>
- en: 'where:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: '*u* is a node.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*u*是一个节点。'
- en: '*R(u)* is the number of relationships through the neighbors of *u* (this can
    be obtained by using the number of triangles passing through *u*).'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*R(u)*是通过*u*的邻居的关系数量（可以通过通过*u*的三角形的数量来获得）。'
- en: '*k(u)* is the degree of *u*.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*k(u)*是*u*的度数。'
- en: Global Clustering Coefficient
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局聚类系数
- en: The global clustering coefficient is the normalized sum of the local clustering
    coefficients.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 全局聚类系数是局部聚类系数的归一化和。
- en: Clustering coefficients give us an effective means to find obvious groups like
    cliques, where every node has a relationship with all other nodes, but we can
    also specify thresholds to set levels (say, where nodes are 40% connected).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 聚类系数为我们提供了一种有效的方法来找到明显的群体，如圈子，其中每个节点与所有其他节点都有关系，但我们也可以指定阈值来设置级别（例如，节点之间40%连接）。
- en: When Should I Use Triangle Count and Clustering Coefficient?
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我何时应该使用三角计数和聚类系数？
- en: Use Triangle Count when you need to determine the stability of a group or as
    part of calculating other network measures such as the clustering coefficient.
    Triangle counting is popular in social network analysis, where it is used to detect
    communities.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要确定群体的稳定性或作为计算其他网络测量的一部分时，请使用三角计数。三角计数在社交网络分析中很受欢迎，用于检测社区。
- en: Clustering Coefficient can provide the probability that randomly chosen nodes
    will be connected. You can also use it to quickly evaluate the cohesiveness of
    a specific group or your overall network. Together these algorithms are used to
    estimate resiliency and look for network structures.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 聚类系数可以提供随机选择的节点连接的概率。您还可以使用它快速评估特定组或整个网络的内聚性。这些算法一起用于估计韧性并寻找网络结构。
- en: 'Example use cases include:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 示例用例包括：
- en: Identifying features for classifying a given website as spam content. This is
    described in [“Efficient Semi-Streaming Algorithms for Local Triangle Counting
    in Massive Graphs”](http://bit.ly/2ut0Lao), a paper by L. Becchetti et al.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别用于分类给定网站为垃圾内容的特征。这在[L. Becchetti等人的论文“大规模图中局部三角计数的高效半流算法”](http://bit.ly/2ut0Lao)中有描述。
- en: Investigating the community structure of Facebook’s social graph, where researchers
    found dense neighborhoods of users in an otherwise sparse global graph. Find this
    study in the paper [“The Anatomy of the Facebook Social Graph”](https://bit.ly/2TXWsTC),
    by J. Ugander et al.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查Facebook社交图的社区结构，在这里研究人员发现了用户密集的邻域，而在全球图中则较为稀疏。在J. Ugander等人的论文["Facebook社交图的解剖学"](https://bit.ly/2TXWsTC)中可以找到这项研究。
- en: Exploring the thematic structure of the web and detecting communities of pages
    with common topics based on the reciprocal links between them. For more information,
    see [“Curvature of Co-Links Uncovers Hidden Thematic Layers in the World Wide
    Web”](http://bit.ly/2YkCrFo), by J.-P. Eckmann and E. Moses.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于它们之间的相互链接，探索网络的主题结构并检测具有共同主题的页面社区。有关更多信息，请参阅[J.-P. Eckmann和E. Moses的论文“共链接的曲率揭示了全球网络中隐藏的主题层”](http://bit.ly/2YkCrFo)。
- en: Triangle Count with Apache Spark
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Apache Spark进行三角计数
- en: 'Now we’re ready to execute the Triangle Count algorithm. We can use the following
    code to do this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备执行三角计数算法。我们可以使用以下代码来执行此操作：
- en: '[PRE5]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we run that code in pyspark we’ll see this output:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在pyspark中运行该代码，我们将看到以下输出：
- en: '| count | id |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| count | id |'
- en: '| --- | --- |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | jupyter |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 1 | jupyter |'
- en: '| 1 | python-dateutil |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 1 | python-dateutil |'
- en: '| 1 | six |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 六 |'
- en: '| 1 | ipykernel |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 1 | ipykernel |'
- en: '| 1 | matplotlib |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 1 | matplotlib |'
- en: '| 1 | jpy-console |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 1 | jpy-console |'
- en: A triangle in this graph would indicate that two of a node’s neighbors are also
    neighbors. Six of our libraries participate in such triangles.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中的一个三角形表明一个节点的两个邻居也是邻居。我们的六个库都参与了这样的三角形。
- en: What if we want to know which nodes are in those triangles? That’s where a *triangle
    stream* comes in. For this, we need Neo4j.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想知道哪些节点在这些三角形中？这就是 *triangle stream* 要做的事情。为此，我们需要 Neo4j。
- en: Triangles with Neo4j
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Neo4j 进行三角形分析
- en: 'Getting a stream of the triangles isn’t available using Spark, but we can return
    it using Neo4j:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Spark 无法获取三角形流，但我们可以使用 Neo4j 返回它：
- en: '[PRE6]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Running this procedure gives the following result:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此过程将给出以下结果：
- en: '| nodeA | nodeB | nodeC |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| nodeA | nodeB | nodeC |'
- en: '| --- | --- | --- |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| matplotlib | six | python-dateutil |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| matplotlib | six | python-dateutil |'
- en: '| jupyter | jpy-console | ipykernel |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| jupyter | jpy-console | ipykernel |'
- en: We see the same six libraries as we did before, but now we know how they’re
    connected. matplotlib, six, and python-dateutil form one triangle. jupyter, jpy-console,
    and ipykernel form the other.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到与之前相同的六个库，但现在我们知道它们是如何连接的。matplotlib、six 和 python-dateutil 形成一个三角形。jupyter、jpy-console
    和 ipykernel 形成另一个三角形。
- en: We can see these triangles visually in [Figure 6-4](#triangles_image).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 [Figure 6-4](#triangles_image) 中直观地看到这些三角形。
- en: '![gral 0604](Images/gral_0604.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![gral 0604](Images/gral_0604.png)'
- en: Figure 6-4\. Triangles in the software dependency graph
  id: totrans-188
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-4\. 软件依赖图中的三角形
- en: Local Clustering Coefficient with Neo4j
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Neo4j 进行本地聚类系数
- en: 'We can also work out the local clustering coefficient. The following query
    will calculate this for each node:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以计算局部聚类系数。以下查询将为每个节点计算此系数：
- en: '[PRE7]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Running this procedure gives the following result:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此过程将给出以下结果：
- en: '| library | coefficient |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| library | coefficient |'
- en: '| --- | --- |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| ipykernel | 1.0 |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| ipykernel | 1.0 |'
- en: '| jupyter | 0.3333333333333333 |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| jupyter | 0.3333333333333333 |'
- en: '| jpy-console | 0.3333333333333333 |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| jpy-console | 0.3333333333333333 |'
- en: '| six | 0.3333333333333333 |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| six | 0.3333333333333333 |'
- en: '| python-dateutil | 0.3333333333333333 |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| python-dateutil | 0.3333333333333333 |'
- en: '| matplotlib | 0.16666666666666666 |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| matplotlib | 0.16666666666666666 |'
- en: ipykernel has a score of 1, which means that all ipykernel’s neighbors are neighbors
    of each other. We can clearly see that in [Figure 6-4](#triangles_image). This
    tells us that the community directly around ipykernel is very cohesive.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ipykernel 的分数为1，这意味着ipykernel的所有邻居彼此也是邻居。我们可以在 [Figure 6-4](#triangles_image)
    中清晰地看到这一点。这告诉我们，ipykernel 周围的社区非常紧密。
- en: We’ve filtered out nodes with a coefficient score of 0 in this code sample,
    but nodes with low coefficients may also be interesting. A low score can be an
    indicator that a node is a [*structural hole*](http://stanford.io/2UTYVex)—a node
    that is well connected to nodes in different communities that aren’t otherwise
    connected to each other. This is a method for finding *potential* bridges that
    we discussed in [Chapter 5](ch05.xhtml#centrality_algorithms).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，我们已过滤掉系数为0的节点，但低系数的节点也可能很有趣。低分数可以表明节点是 [*结构孔*](http://stanford.io/2UTYVex)
    —— 连接到不同社区的节点，这些社区彼此之间没有其他连接。这是在 [第5章](ch05.xhtml#centrality_algorithms) 中讨论过的找到
    *潜在* 桥梁的方法。
- en: Strongly Connected Components
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强连通分量
- en: The Strongly Connected Components (SCC) algorithm is one of the earliest graph
    algorithms. SCC finds sets of connected nodes in a directed graph where each node
    is reachable in both directions from any other node in the same set. Its runtime
    operations scale well, proportional to the number of nodes. In [Figure 6-5](#SCC)
    you can see that the nodes in an SCC group don’t need to be immediate neighbors,
    but there must be directional paths between all nodes in the set.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最强连通分量（SCC）算法是最早的图算法之一。SCC 在有向图中找到一组连接的节点集合，其中每个节点可以从同一集合中的任何其他节点双向到达。它的运行时间与节点数成比例，操作效率高。在
    [Figure 6-5](#SCC) 中，您可以看到SCC组中的节点不需要是直接的邻居，但集合中的所有节点之间必须存在方向路径。
- en: '![gral 0605](Images/gral_0605.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![gral 0605](Images/gral_0605.png)'
- en: Figure 6-5\. Strongly connected components
  id: totrans-206
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-5\. 强连通分量
- en: Note
  id: totrans-207
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: Decomposing a directed graph into its strongly connected components is a classic
    application of the [Depth First Search algorithm](ch04.xhtml#dfs). Neo4j uses
    DFS under the hood as part of its implementation of the SCC algorithm.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 将有向图分解为其强连通分量是 [深度优先搜索算法](ch04.xhtml#dfs) 的经典应用。Neo4j 在其实施 SCC 算法中使用了 DFS。
- en: When Should I Use Strongly Connected Components?
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么时候应该使用强连通分量？
- en: Use Strongly Connected Components as an early step in graph analysis to see
    how a graph is structured or to identify tight clusters that may warrant independent
    investigation. A component that is strongly connected can be used to profile similar
    behavior or inclinations in a group for applications such as recommendation engines.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在图分析的早期阶段使用强连通分量作为一种方法，以了解图的结构或识别可能需要独立调查的紧密群集。强连通的组件可用于分析群体内相似的行为或倾向，例如推荐引擎的应用。
- en: Many community detection algorithms like SCC are used to find and collapse clusters
    into single nodes for further intercluster analysis. You can also use SCC to visualize
    cycles for analyses like finding processes that might deadlock because each subprocess
    is waiting for another member to take action.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 许多社区检测算法如 SCC 用于查找和折叠成单节点以供进一步的跨群体分析。你也可以使用 SCC 来可视化循环，例如找出可能因为每个子进程都在等待其他成员采取行动而发生死锁的过程。
- en: 'Example use cases include:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 例如用例包括：
- en: Finding the set of firms in which every member directly and/or indirectly owns
    shares in every other member, as in [“The Network of Global Corporate Control”](http://bit.ly/2UU4EAP),
    an analysis of powerful transnational corporations by S. Vitali, J. B. Glattfelder,
    and S. Battiston.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找所有成员直接或间接拥有每个其他成员股份的企业集合，例如 [“全球企业控制网络”](http://bit.ly/2UU4EAP)，一篇由 S. Vitali,
    J. B. Glattfelder 和 S. Battiston 分析的强大跨国公司网络。
- en: Computing the connectivity of different network configurations when measuring
    routing performance in multihop wireless networks. Read more in [“Routing Performance
    in the Presence of Unidirectional Links in Multihop Wireless Networks”](https://bit.ly/2uAJs7H),
    by M. K. Marina and S. R. Das.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多跳无线网络中测量路由性能时计算不同网络配置的连通性。更多详情请见 [“在多跳无线网络中存在单向链接时的路由性能”](https://bit.ly/2uAJs7H)，作者
    M. K. Marina 和 S. R. Das。
- en: Acting as the first step in many graph algorithms that work only on strongly
    connected graphs. In social networks we find many strongly connected groups. In
    these sets people often have similar preferences, and the SCC algorithm is used
    to find such groups and suggest pages to like or products to purchase to the people
    in the group who have not yet done so.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在许多只处理强连通图的图算法中，此算法作为第一步起作用。在社交网络中，我们发现许多强连通群体。在这些集合中，人们往往有相似的偏好，而 SCC 算法用于查找这些群体并建议尚未这样做的组内成员喜欢的页面或购买产品。
- en: Tip
  id: totrans-216
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Some algorithms have strategies for escaping infinite loops, but if we’re writing
    our own algorithms or finding nonterminating processes, we can use SCC to check
    for cycles.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一些算法有逃逸无限循环的策略，但如果我们编写自己的算法或找到非终止的进程，我们可以使用 SCC 来检查循环。
- en: Strongly Connected Components with Apache Spark
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Apache Spark 进行强连通分量计算
- en: 'Starting with Apache Spark, we’ll first import the packages we need from Spark
    and the GraphFrames package:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Apache Spark 开始，我们首先从 Spark 和 GraphFrames 包导入我们需要的包：
- en: '[PRE8]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now we’re ready to execute the Strongly Connected Components algorithm. We’ll
    use it to work out whether there are any circular dependencies in our graph.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备执行强连通分量算法。我们将使用它来判断我们的图中是否存在循环依赖。
- en: Note
  id: totrans-222
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: Two nodes can only be in the same strongly connected component if there are
    paths between them in both directions.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 两个节点只有在两个方向上都存在路径时才能位于同一个强连通分量中。
- en: 'We write the following code to do this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写以下代码来实现这一点：
- en: '[PRE9]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we run that code in pyspark we’ll see this output:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 pyspark 中运行该代码，我们将看到以下输出：
- en: '| component | libraries |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 组件 | 库 |'
- en: '| --- | --- |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 180388626432 | [jpy-core] |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 180388626432 | [jpy-core] |'
- en: '| 223338299392 | [spacy] |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| 223338299392 | [spacy] |'
- en: '| 498216206336 | [numpy] |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| 498216206336 | [numpy] |'
- en: '| 523986010112 | [six] |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| 523986010112 | [six] |'
- en: '| 549755813888 | [pandas] |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 549755813888 | [pandas] |'
- en: '| 558345748480 | [nbconvert] |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| 558345748480 | [nbconvert] |'
- en: '| 661424963584 | [ipykernel] |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 661424963584 | [ipykernel] |'
- en: '| 721554505728 | [jupyter] |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| 721554505728 | [jupyter] |'
- en: '| 764504178688 | [jpy-client] |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 764504178688 | [jpy-client] |'
- en: '| 833223655424 | [pytz] |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 833223655424 | [pytz] |'
- en: '| 910533066752 | [python-dateutil] |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 910533066752 | [python-dateutil] |'
- en: '| 936302870528 | [pyspark] |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 936302870528 | [pyspark] |'
- en: '| 944892805120 | [matplotlib] |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 944892805120 | [matplotlib] |'
- en: '| 1099511627776 | [jpy-console] |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 1099511627776 | [jpy-console] |'
- en: '| 1279900254208 | [py4j] |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 1279900254208 | [py4j] |'
- en: You might notice that every library node is assigned to a unique component.
    This is the partition or subgroup it belongs to, and as we (hopefully!) expected,
    every node is in its own partition. This means our software project has no circular
    dependencies amongst these libraries.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能注意到每个库节点都被分配到一个唯一的组件中。这是它所属的分区或子组，正如我们（希望！）所预期的那样，每个节点都在自己的分区中。这意味着我们的软件项目在这些库之间没有循环依赖。
- en: Strongly Connected Components with Neo4j
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Neo4j 的强连通组件
- en: 'Let’s run the same algorithm using Neo4j. Execute the following query to run
    the algorithm:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Neo4j 再次运行相同的算法。执行以下查询来运行算法：
- en: '[PRE10]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The parameters passed to this algorithm are:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给此算法的参数如下：
- en: '`Library`'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`Library`'
- en: The node label to load from the graph
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 从图中加载的节点标签
- en: '`DEPENDS_ON`'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`DEPENDS_ON`'
- en: The relationship type to load from the graph
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 从图中加载的关系类型
- en: 'This is the output we’ll see when we run the query:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们运行查询时将看到的输出：
- en: '| partition | libraries |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| partition | libraries |'
- en: '| --- | --- |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 8 | [ipykernel] |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| 8 | [ipykernel] |'
- en: '| 11 | [six] |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| 11 | [six] |'
- en: '| 2 | [matplotlib] |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| 2 | [matplotlib] |'
- en: '| 5 | [jupyter] |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| 5 | [jupyter] |'
- en: '| 14 | [python-dateutil] |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| 14 | [python-dateutil] |'
- en: '| 13 | [numpy] |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| 13 | [numpy] |'
- en: '| 4 | [py4j] |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| 4 | [py4j] |'
- en: '| 7 | [nbconvert] |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| 7 | [nbconvert] |'
- en: '| 1 | [pyspark] |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| 1 | [pyspark] |'
- en: '| 10 | [jpy-core] |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| 10 | [jpy-core] |'
- en: '| 9 | [jpy-client] |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| 9 | [jpy-client] |'
- en: '| 3 | [spacy] |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| 3 | [spacy] |'
- en: '| 12 | [pandas] |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| 12 | [pandas] |'
- en: '| 6 | [jpy-console] |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 6 | [jpy-console] |'
- en: '| 0 | [pytz] |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| 0 | [pytz] |'
- en: As with the Spark example, every node is in its own partition.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Spark 示例一样，每个节点都在自己的分区中。
- en: So far the algorithm has only revealed that our Python libraries are very well
    behaved, but let’s create a circular dependency in the graph to make things more
    interesting. This should mean that we’ll end up with some nodes in the same partition.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，该算法只揭示了我们的 Python 库非常遵循规则，但让我们在图中创建一个循环依赖以增加趣味性。这应该意味着我们最终会得到一些节点在同一分区中。
- en: 'The following query adds an extra library that creates a circular dependency
    between py4j and pyspark:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 以下查询添加了一个额外的库，创建了 py4j 和 pyspark 之间的循环依赖：
- en: '[PRE11]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can clearly see the circular dependency that got created in [Figure 6-6](#circular_dependency_image).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以清楚地看到在 [图 6-6](#circular_dependency_image) 中创建的循环依赖。
- en: '![gral 0606](Images/gral_0606.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![图 0606](Images/gral_0606.png)'
- en: Figure 6-6\. A circular dependency between pyspark, py4j, and extra
  id: totrans-277
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-6\. pyspark、py4j 和额外内容之间的循环依赖
- en: 'Now if we run the SCC algorithm again we’ll see a slightly different result:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们再次运行 SCC 算法，我们会看到一个略有不同的结果：
- en: '| partition | libraries |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| partition | libraries |'
- en: '| --- | --- |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | [pyspark, py4j, extra] |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 1 | [pyspark, py4j, extra] |'
- en: '| 8 | [ipykernel] |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| 8 | [ipykernel] |'
- en: '| 11 | [six] |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| 11 | [six] |'
- en: '| 2 | [matplotlib] |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| 2 | [matplotlib] |'
- en: '| 5 | [jupyter] |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| 5 | [jupyter] |'
- en: '| 14 | [numpy] |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| 14 | [numpy] |'
- en: '| 13 | [pandas] |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| 13 | [pandas] |'
- en: '| 7 | [nbconvert] |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| 7 | [nbconvert] |'
- en: '| 10 | [jpy-core] |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| 10 | [jpy-core] |'
- en: '| 9 | [jpy-client] |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| 9 | [jpy-client] |'
- en: '| 3 | [spacy] |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| 3 | [spacy] |'
- en: '| 15 | [python-dateutil] |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| 15 | [python-dateutil] |'
- en: '| 6 | [jpy-console] |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| 6 | [jpy-console] |'
- en: '| 0 | [pytz] |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| 0 | [pytz] |'
- en: pyspark, py4j, and extra are all part of the same partition, and SCCs helped
    us find the circular dependency!
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: pyspark、py4j 和额外内容都属于同一分区，并且 SCCs 帮助我们找到了循环依赖！
- en: 'Before we move on to the next algorithm we’ll delete the extra library and
    its relationships from the graph:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续下一个算法之前，我们将从图中删除额外的库及其关系：
- en: '[PRE12]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Connected Components
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接组件
- en: The Connected Components algorithm (sometimes called Union Find or Weakly Connected
    Components) finds sets of connected nodes in an undirected graph where each node
    is reachable from any other node in the same set. It differs from the SCC algorithm
    because it only needs a path to exist between pairs of nodes in one direction,
    whereas SCC needs a path to exist in both directions. Bernard A. Galler and Michael
    J. Fischer first described this algorithm in their 1964 paper, [“An Improved Equivalence
    Algorithm”](https://bit.ly/2WsPNxT).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 连接组件算法（有时称为并查集或弱连接组件）在无向图中查找连接节点集，其中每个节点都可以从同一集合中的任何其他节点到达。它与 SCC 算法不同，因为它只需要在一方向上存在节点对之间的路径，而
    SCC 需要在两个方向上都存在路径。Bernard A. Galler 和 Michael J. Fischer 在他们 1964 年的论文 [“An Improved
    Equivalence Algorithm”](https://bit.ly/2WsPNxT) 中首次描述了这种算法。
- en: When Should I Use Connected Components?
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用连接组件？
- en: As with SCC, Connected Components is often used early in an analysis to understand
    a graph’s structure. Because it scales efficiently, consider this algorithm for
    graphs requiring frequent updates. It can quickly show new nodes in common between
    groups, which is useful for analysis such as fraud detection.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 与SCC一样，Connected Components通常在分析的早期用于理解图的结构。由于其高效性，对于需要频繁更新的图形考虑此算法是很有帮助的。它可以快速显示在组之间共有的新节点，这对于诸如欺诈检测等分析非常有用。
- en: Make it a habit to run Connected Components to test whether a graph is connected
    as a preparatory step for general graph analysis. Performing this quick test can
    avoid accidentally running algorithms on only one disconnected component of a
    graph and getting incorrect results.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 养成习惯，运行Connected Components来测试图形是否连接，作为一般图形分析的准备步骤。执行这个快速测试可以避免在图的一个断开的组件上意外运行算法，并得到不正确的结果。
- en: 'Example use cases include:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 示例用例包括：
- en: Keeping track of clusters of database records, as part of the deduplication
    process. Deduplication is an important task in master data management applications;
    the approach is described in more detail in [“An Efficient Domain-Independent
    Algorithm for Detecting Approximately Duplicate Database Records”](http://bit.ly/2CCNpgy),
    by A. Monge and C. Elkan.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为去重处理的一部分，跟踪数据库记录的聚类。去重是主数据管理应用中的重要任务；该方法在A. Monge和C. Elkan的[“An Efficient
    Domain-Independent Algorithm for Detecting Approximately Duplicate Database Records”](http://bit.ly/2CCNpgy)中有更详细的描述。
- en: Analyzing citation networks. One study uses Connected Components to work out
    how well connected a network is, and then to see whether the connectivity remains
    if “hub” or “authority” nodes are moved from the graph. This use case is explained
    further in [“Characterizing and Mining Citation Graph of Computer Science Literature”](https://bit.ly/2U8cfi9),
    a paper by Y. An, J. C. M. Janssen, and E. E. Milios.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析引用网络。一项研究使用Connected Components来确定网络连接的好坏，然后查看在将“中心”或“权威”节点从图中移动后连接性是否保持。这个用例在Y.
    An、J. C. M. Janssen和E. E. Milios的[“Characterizing and Mining Citation Graph of
    Computer Science Literature”](https://bit.ly/2U8cfi9)中有进一步解释。
- en: Connected Components with Apache Spark
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Apache Spark进行Connected Components
- en: 'Starting with Apache Spark, we’ll first import the packages we need from Spark
    and the GraphFrames package:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 从Apache Spark开始，我们首先从Spark和GraphFrames包中导入所需的包：
- en: '[PRE13]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now we’re ready to execute the Connected Components algorithm.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备执行Connected Components算法。
- en: Note
  id: totrans-310
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Two nodes can be in the same connected component if there is a path between
    them in either direction.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个节点之间存在双向路径，它们可以位于同一个连接的组件中。
- en: 'We write the following code to do this:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写以下代码来完成这个任务：
- en: '[PRE14]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we run that code in pyspark we’ll see this output:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在pyspark中运行该代码，将看到以下输出：
- en: '| component | libraries |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| component | libraries |'
- en: '| --- | --- |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 180388626432 | [jpy-core, nbconvert, ipykernel, jupyter, jpy-client, jpy-console]
    |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| 180388626432 | [jpy-core, nbconvert, ipykernel, jupyter, jpy-client, jpy-console]
    |'
- en: '| 223338299392 | [spacy, numpy, six, pandas, pytz, python-dateutil, matplotlib]
    |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| 223338299392 | [spacy, numpy, six, pandas, pytz, python-dateutil, matplotlib]
    |'
- en: '| 936302870528 | [pyspark, py4j] |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| 936302870528 | [pyspark, py4j] |'
- en: The results show three clusters of nodes, which can also be seen in [Figure 6-7](#unionfind-image).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示三个节点聚类，也可以在[图 6-7](#unionfind-image)中看到。
- en: '![gral 0607](Images/gral_0607.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![gral 0607](Images/gral_0607.png)'
- en: Figure 6-7\. Clusters found by the Connected Components algorithm
  id: totrans-322
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-7\. 由Connected Components算法找到的聚类
- en: In this example it’s very easy to see that there are three components just by
    visual inspection. This algorithm shows its value more on larger graphs, where
    visual inspection isn’t possible or is very time-consuming.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，通过视觉检查非常容易看到有三个组件。这种算法在更大的图中表现其价值，那里视觉检查不可能或非常耗时。
- en: Connected Components with Neo4j
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Neo4j进行Connected Components
- en: 'We can also execute this algorithm in Neo4j by running the following query:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过运行以下查询在Neo4j中执行此算法：
- en: '[PRE15]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The parameters passed to this algorithm are:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法传递的参数如下：
- en: '`Library`'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`Library`'
- en: The node label to load from the graph
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 从图中加载的节点标签
- en: '`DEPENDS_ON`'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`DEPENDS_ON`'
- en: The relationship type to load from the graph
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 从图中加载的关系类型
- en: 'Here’s the output:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '| setId | libraries |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| setId | libraries |'
- en: '| --- | --- |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 2 | [pytz, matplotlib, spacy, six, pandas, numpy, python-dateutil] |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| 2 | [pytz, matplotlib, spacy, six, pandas, numpy, python-dateutil] |'
- en: '| 5 | [jupyter, jpy-console, nbconvert, ipykernel, jpy-client, jpy-core] |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| 5 | [jupyter, jpy-console, nbconvert, ipykernel, jpy-client, jpy-core] |'
- en: '| 1 | [pyspark, py4j] |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| 1 | [pyspark, py4j] |'
- en: As expected, we get exactly the same results as we did with Spark.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，我们得到了与Spark完全相同的结果。
- en: 'Both of the community detection algorithms that we’ve covered so far are deterministic:
    they return the same results each time we run them. Our next two algorithms are
    examples of nondeterministic algorithms, where we may see different results if
    we run them multiple times, even on the same data.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们介绍的两种社区检测算法都是确定性的：每次运行它们时都会返回相同的结果。我们接下来介绍的两种算法是非确定性算法的例子，即使在相同数据上多次运行它们也可能得到不同的结果。
- en: Label Propagation
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标签传播
- en: The Label Propagation algorithm (LPA) is a fast algorithm for finding communities
    in a graph. In LPA, nodes select their group based on their direct neighbors.
    This process is well suited to networks where groupings are less clear and weights
    can be used to help a node determine which community to place itself within. It
    also lends itself well to semisupervised learning because you can seed the process
    with preassigned, indicative node labels.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 标签传播算法（LPA）是一种在图中查找社区的快速算法。在LPA中，节点根据其直接邻居选择其所属的群组。这个过程非常适合网络中群组不太清晰且可以使用权重来帮助节点确定自身所属社区的情况。此外，它也非常适合半监督学习，因为可以使用预分配的指示性节点标签来启动该过程。
- en: The intuition behind this algorithm is that a single label can quickly become
    dominant in a densely connected group of nodes, but it will have trouble crossing
    a sparsely connected region. Labels get trapped inside a densely connected group
    of nodes, and nodes that end up with the same label when the algorithm finishes
    are considered part of the same community. The algorithm resolves overlaps, where
    nodes are potentially part of multiple clusters, by assigning membership to the
    label neighborhood with the highest combined relationship and node weight.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法的直觉是，在密集连接的节点组中，一个单一标签可以迅速占据主导地位，但在稀疏连接的区域则会遇到困难。标签在密集连接的节点组中会被困住，当算法结束时具有相同标签的节点被视为属于同一社区。该算法通过将成员分配给具有最高组合关系和节点权重的标签邻域来解决重叠问题，其中节点可能属于多个群集。
- en: LPA is a relatively new algorithm proposed in 2007 by U. N. Raghavan, R. Albert,
    and S. Kumara, in a paper titled [“Near Linear Time Algorithm to Detect Community
    Structures in Large-Scale Networks”](https://bit.ly/2Frb1Fu).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: LPA是一个相对较新的算法，由U. N. Raghavan、R. Albert和S. Kumara在2007年提出，题为[“近线性时间算法用于检测大规模网络中的社区结构”](https://bit.ly/2Frb1Fu)。
- en: '[Figure 6-8](#lpa-steps) depicts two variations of Label Propagation, a simple
    push method and the more typical pull method that relies on relationship weights.
    The pull method lends itself well to parallelization.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-8](#lpa-steps)展示了标签传播的两种变体，一种是简单的推送方法，另一种是更典型的依赖关系权重的拉取方法。拉取方法非常适合并行化处理。'
- en: '![gral 0608](Images/gral_0608.png)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![gral 0608](Images/gral_0608.png)'
- en: Figure 6-8\. Two variations of Label Propagation
  id: totrans-346
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-8\. 标签传播的两种变体
- en: 'The steps often used for the Label Propagation pull method are:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 标签传播拉取方法通常使用的步骤包括：
- en: Every node is initialized with a unique label (an identifier), and, optionally
    preliminary “seed” labels can be used.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个节点都使用唯一的标签（标识符）进行初始化，并且可以选择性地使用初步的“种子”标签。
- en: These labels propagate through the network.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些标签通过网络进行传播。
- en: At every propagation iteration, each node updates its label to match the one
    with the maximum weight, which is calculated based on the weights of neighbor
    nodes *and* their relationships. Ties are broken uniformly and randomly.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每次传播迭代中，每个节点将其标签更新为具有最大权重的节点的标签，该权重基于邻居节点及其关系的权重计算而得。平局将以统一且随机的方式解决。
- en: LPA reaches convergence when each node has the majority label of its neighbors.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当每个节点的标签变为其邻居节点的大多数标签时，LPA达到收敛状态。
- en: As labels propagate, densely connected groups of nodes quickly reach a consensus
    on a unique label. At the end of the propagation, only a few labels will remain,
    and nodes that have the same label belong to the same community.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 随着标签的传播，密集连接的节点组迅速达成唯一标签的共识。在传播结束时，只会剩下少数标签，具有相同标签的节点属于同一社区。
- en: Semi-Supervised Learning and Seed Labels
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 半监督学习与种子标签
- en: In contrast to other algorithms, Label Propagation can return different community
    structures when run multiple times on the same graph. The order in which LPA evaluates
    nodes can have an influence on the final communities it returns.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他算法相比，标签传播可以在同一图上多次运行时返回不同的社区结构。LPA评估节点的顺序可以影响其返回的最终社区。
- en: The range of solutions is narrowed when some nodes are given preliminary labels
    (i.e., seed labels), while others are unlabeled. Unlabeled nodes are more likely
    to adopt the preliminary labels.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 当一些节点被赋予初步标签（即种子标签）而其他节点未被标记时，解决方案的范围会缩小。未标记的节点更有可能采纳初步标签。
- en: This use of Label Propagation can be considered a *semi-supervised learning*
    method to find communities. Semi-supervised learning is a class of machine learning
    tasks and techniques that operate on a small amount of labeled data, along with
    a larger amount of unlabeled data. We can also run the algorithm repeatedly on
    graphs as they evolve.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这种使用标签传播可以被视为*半监督学习*方法来发现社区。半监督学习是一类机器学习任务和技术，它在少量标记数据以及大量未标记数据上操作。我们还可以在图表不断演化的过程中重复运行算法。
- en: Finally, LPA sometimes doesn’t converge on a single solution. In this situation,
    our community results will continually flip between a few remarkably similar communities
    and the algorithm would never complete. Seed labels help guide it toward a solution.
    Spark and Neo4j use a set maximum number of iterations to avoid never-ending execution.
    You should test the iteration setting for your data to balance accuracy and execution
    time.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，标签传播有时无法收敛于单一解决方案。在这种情况下，我们的社区结果将在几个非常相似的社区之间不断翻转，而算法则永远不会完成。种子标签帮助指导其走向解决方案。Spark
    和 Neo4j 使用设定的最大迭代次数来避免无休止的执行。您应该为您的数据测试迭代设置，以平衡准确性和执行时间。
- en: When Should I Use Label Propagation?
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时应该使用标签传播？
- en: Use Label Propagation in large-scale networks for initial community detection,
    especially when weights are available. This algorithm can be parallelized and
    is therefore extremely fast at graph partitioning.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在大规模网络中使用标签传播进行初始社区检测，特别是当权重可用时。该算法可以并行化，因此在图分区方面非常快速。
- en: 'Example use cases include:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 示例用例包括：
- en: Assigning polarity of tweets as a part of semantic analysis. In this scenario,
    positive and negative seed labels from a classifier are used in combination with
    the Twitter follower graph. For more information, see [“Twitter Polarity Classification
    with Label Propagation over Lexical Links and the Follower Graph”](https://bit.ly/2FBq2pv),
    by M. Speriosu et al.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为语义分析的一部分，分配推文的极性。在这种情况下，来自分类器的正负种子标签与 Twitter 跟随者图结合使用。更多信息，请参见[“基于词汇链接和跟随者图的
    Twitter 极性分类的标签传播”](https://bit.ly/2FBq2pv)，一篇由 M. Speriosu 等人撰写的论文。
- en: Finding potentially dangerous combinations of possible co-prescribed drugs,
    based on the chemical similarity and side effect profiles. See [“Label Propagation
    Prediction of Drug–Drug Interactions Based on Clinical Side Effects”](https://www.nature.com/articles/srep12339),
    a paper by P. Zhang et al.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据化学相似性和副作用概况，寻找潜在危险的联合处方药组合。参见[“基于临床副作用的药物相互作用的标签传播预测”](https://www.nature.com/articles/srep12339)，一篇由
    P. Zhang 等人撰写的论文。
- en: Inferring dialogue features and user intention for a machine learning model.
    For more information, see [“Feature Inference Based on Label Propagation on Wikidata
    Graph for DST”](https://bit.ly/2FtGpTK), a paper by Y. Murase et al.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推断对话特征和用户意图用于机器学习模型。有关更多信息，请参见[“基于 Wikidata 图的标签传播进行 DST 的特征推断”](https://bit.ly/2FtGpTK)，一篇由
    Y. Murase 等人撰写的论文。
- en: Label Propagation with Apache Spark
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Apache Spark 进行标签传播
- en: 'Starting with Apache Spark, we’ll first import the packages we need from Spark
    and the GraphFrames package:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Apache Spark 开始，我们首先从 Spark 和 GraphFrames 包中导入所需的包：
- en: '[PRE16]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we’re ready to execute the Label Propagation algorithm. We write the following
    code to do this:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备执行标签传播算法。我们编写以下代码来实现这一点：
- en: '[PRE17]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we run that code in pyspark we’ll see this output:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 pyspark 中运行该代码，我们会看到以下输出：
- en: '| label | collect_list(id) |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| 标签 | collect_list(id) |'
- en: '| --- | --- |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 180388626432 | [jpy-core, jpy-console, jupyter] |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| 180388626432 | [jpy-core, jpy-console, jupyter] |'
- en: '| 223338299392 | [matplotlib, spacy] |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| 223338299392 | [matplotlib, spacy] |'
- en: '| 498216206336 | [python-dateutil, numpy, six, pytz] |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| 498216206336 | [python-dateutil, numpy, six, pytz] |'
- en: '| 549755813888 | [pandas] |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| 549755813888 | [pandas] |'
- en: '| 558345748480 | [nbconvert, ipykernel, jpy-client] |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| 558345748480 | [nbconvert, ipykernel, jpy-client] |'
- en: '| 936302870528 | [pyspark] |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| 936302870528 | [pyspark] |'
- en: '| 1279900254208 | [py4j] |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| 1279900254208 | [py4j] |'
- en: Compared to [Connected Components](#weakly_connected_components), we have more
    clusters of libraries in this example. LPA is less strict than Connected Components
    with respect to how it determines clusters. Two neighbors (directly connected
    nodes) may be found to be in different clusters using Label Propagation. However,
    using Connected Components a node would always be in the same cluster as its neighbors
    because that algorithm bases grouping strictly on relationships.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 与 [Connected Components](#weakly_connected_components) 相比，本例中的库群集更多。 LPA 比连接组件对于确定群集的方式更不严格。使用标签传播，两个邻居（直接连接的节点）可能被发现在不同的群集中。然而，使用连接组件时，节点总是与其邻居在同一个群集中，因为该算法严格基于关系进行分组。
- en: In our example, the most obvious difference is that the Jupyter libraries have
    been split into two communities—one containing the core parts of the library and
    the other the client-facing tools.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，最明显的区别是Jupyter库被分成两个社区——一个包含库的核心部分，另一个包含面向客户端的工具。
- en: Label Propagation with Neo4j
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Neo4j进行标签传播
- en: 'Now let’s try the same algorithm with Neo4j. We can execute LPA by running
    the following query:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试使用Neo4j相同的算法。我们可以通过运行以下查询来执行LPA：
- en: '[PRE18]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The parameters passed to this algorithm are:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给此算法的参数是：
- en: '`Library`'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`Library`'
- en: The node label to load from the graph
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 从图中加载的节点标签
- en: '`DEPENDS_ON`'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`DEPENDS_ON`'
- en: The relationship type to load from the graph
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 从图中加载的关系类型
- en: '`iterations: 10`'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`iterations: 10`'
- en: The maximum number of iterations to run
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 运行的最大迭代次数
- en: 'These are the results we’d see:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们会看到的结果：
- en: '| label | libraries |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| label | libraries |'
- en: '| --- | --- |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 11 | [matplotlib, spacy, six, pandas, python-dateutil] |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| 11 | [matplotlib, spacy, six, pandas, python-dateutil] |'
- en: '| 10 | [jupyter, jpy-console, nbconvert, jpy-client, jpy-core] |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| 10 | [jupyter, jpy-console, nbconvert, jpy-client, jpy-core] |'
- en: '| 4 | [pyspark, py4j] |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| 4 | [pyspark, py4j] |'
- en: '| 8 | [ipykernel] |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| 8 | [ipykernel] |'
- en: '| 13 | [numpy] |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| 13 | [numpy] |'
- en: '| 0 | [pytz] |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| 0 | [pytz] |'
- en: The results, which can also be seen visually in [Figure 6-9](#lpa-image), are
    fairly similar to those we got with Apache Spark.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，这些结果也可以在 [图 6-9](#lpa-image) 中直观地看到，与Apache Spark得到的结果非常相似。
- en: '![gral 0609](Images/gral_0609.png)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
  zh: '![gral 0609](Images/gral_0609.png)'
- en: Figure 6-9\. Clusters found by the Label Propagation algorithm
  id: totrans-402
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-9\. 标签传播算法找到的聚类
- en: We can also run the algorithm assuming that the graph is undirected, which means
    that nodes will try to adopt labels from the libraries they depend on as well
    as ones that depend on them.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以假设图是无向的运行算法，这意味着节点将尝试从它们依赖的库以及依赖它们的库那里采用标签。
- en: 'To do this, we pass the `DIRECTION:BOTH` parameter to the algorithm:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们向算法传递了 `DIRECTION:BOTH` 参数：
- en: '[PRE19]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we run that, we’ll get the following output:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行它，我们会得到以下输出：
- en: '| label | libraries |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| label | libraries |'
- en: '| --- | --- |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 11 | [pytz, matplotlib, spacy, six, pandas, numpy, python-dateutil] |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| 11 | [pytz, matplotlib, spacy, six, pandas, numpy, python-dateutil] |'
- en: '| 10 | [nbconvert, jpy-client, jpy-core] |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| 10 | [nbconvert, jpy-client, jpy-core] |'
- en: '| 6 | [jupyter, jpy-console, ipykernel] |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| 6 | [jupyter, jpy-console, ipykernel] |'
- en: '| 4 | [pyspark, py4j] |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '| 4 | [pyspark, py4j] |'
- en: The number of clusters has reduced from six to four, and all the nodes in the
    matplotlib part of the graph are now grouped together. This can be seen more clearly
    in [Figure 6-10](#lpa-undirected-image).
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 聚类数从六个减少到四个，matplotlib 部分图中的所有节点现在被分组在一起。在 [图 6-10](#lpa-undirected-image) 中可以更清楚地看到这一点。
- en: '![gral 0610](Images/gral_0610.png)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
  zh: '![gral 0610](Images/gral_0610.png)'
- en: Figure 6-10\. Clusters found by the Label Propagation algorithm, when ignoring
    relationship direction
  id: totrans-415
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-10\. 忽略关系方向时标签传播算法找到的聚类
- en: Although the results of running Label Propagation on this data are similar for
    undirected and directed calculation, on complicated graphs you will see more significant
    differences. This is because ignoring direction causes nodes to try and adopt
    more labels, regardless of the relationship source.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在此数据上运行标签传播的结果在无向和有向计算中相似，但在复杂的图形中，您会看到更显著的差异。这是因为忽略方向会导致节点尝试采用更多的标签，而不考虑关系来源。
- en: Louvain Modularity
  id: totrans-417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Louvain模块化
- en: The Louvain Modularity algorithm finds clusters by comparing community density
    as it assigns nodes to different groups. You can think of this as a “what if”
    analysis to try various groupings with the goal of reaching a global optimum.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: Louvain模块化算法通过比较社区密度来找到聚类，并将节点分配到不同的组中。您可以将其视为尝试通过不同的分组达到全局最优的“假设”分析。
- en: Proposed in 2008, the [Louvain algorithm](https://arxiv.org/pdf/0803.0476.pdf)
    is one of the fastest modularity-based algorithms. As well as detecting communities,
    it also reveals a hierarchy of communities at different scales. This is useful
    for understanding the structure of a network at different levels of granularity.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 2008年提出的[Louvain算法](https://arxiv.org/pdf/0803.0476.pdf)是速度最快的基于模块性的算法之一。除了检测社群外，它还揭示了不同尺度上的社群层次结构。这对于理解网络在不同粒度水平上的结构非常有用。
- en: Louvain quantifies how well a node is assigned to a group by looking at the
    density of connections within a cluster in comparison to an average or random
    sample. This measure of community assignment is called *modularity*.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: Louvain通过比较簇内连接密度与平均或随机样本来量化节点分配到群组的好坏程度。这种社群分配度量称为*模块性*。
- en: Quality-based grouping via modularity
  id: totrans-421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于质量的通过模块性进行分组
- en: Modularity is a technique for uncovering communities by partitioning a graph
    into more coarse-grained modules (or clusters) and then measuring the strength
    of the groupings. As opposed to just looking at the concentration of connections
    within a cluster, this method compares relationship densities in given clusters
    to densities between clusters. The measure of the quality of those groupings is
    called modularity.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 模块性是一种通过将图分区为更粗粒度的模块（或簇），然后测量群集的强度来揭示社群的技术。与仅查看簇内连接密度不同，此方法比较给定簇内的关系密度与簇间的密度。这些群集质量的度量称为模块性。
- en: 'Modularity algorithms optimize communities locally and then globally, using
    multiple iterations to test different groupings and increasing coarseness. This
    strategy identifies community hierarchies and provides a broad understanding of
    the overall structure. However, all modularity algorithms suffer from two drawbacks:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 模块性算法在局部和全局上优化社群，使用多次迭代来测试不同的分组和增加粗粒度。这种策略识别社群层次结构，并提供对整体结构的广泛理解。然而，所有的模块性算法都存在两个缺点：
- en: They merge smaller communities into larger ones.
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们将较小的社群合并为较大的社群。
- en: A plateau can occur where several partition options are present with similar
    modularity, forming local maxima and preventing progress.
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能会出现一个高原，多个具有类似模块性的分区选项形成局部极大值，并阻止进展。
- en: For more information, see the paper [“The Performance of Modularity Maximization
    in Practical Contexts”](https://arxiv.org/abs/0910.0165), by B. H. Good, Y.-A.
    de Montjoye, and A. Clauset.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请参阅B.H. Good、Y.-A. de Montjoye和A. Clauset的论文[“The Performance of Modularity
    Maximization in Practical Contexts”](https://arxiv.org/abs/0910.0165)。
- en: Initially the Louvain Modularity algorithm optimizes modularity locally on all
    nodes, which finds small communities; then each small community is grouped into
    a larger conglomerate node and the first step is repeated until we reach a global
    optimum.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，Louvain模块性算法在所有节点上局部优化模块性，找到小的社群；然后将每个小社群组合成一个更大的合并节点，并重复第一步，直到达到全局最优。
- en: The algorithm consists of repeated application of two steps, as illustrated
    in [Figure 6-12](#louvain-steps).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法由两个步骤的重复应用组成，如[Figure 6-12](#louvain-steps)所示。
- en: '![gral 0612](Images/gral_0612.png)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
  zh: '![gral 0612](Images/gral_0612.png)'
- en: Figure 6-12\. The Louvain algorithm process
  id: totrans-430
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-12\. Louvain算法过程
- en: 'The Louvain algorithm’s steps include:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: Louvain算法的步骤包括：
- en: A “greedy” assignment of nodes to communities, favoring local optimizations
    of modularity.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将节点“贪婪”分配到社群中，优先考虑模块性的局部优化。
- en: The definition of a more coarse-grained network based on the communities found
    in the first step. This coarse-grained network will be used in the next iteration
    of the algorithm.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于第一步找到的社群定义更粗粒度网络。这个粗粒度网络将在算法的下一次迭代中使用。
- en: These two steps are repeated until no further modularity-increasing reassignments
    of communities are possible.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 直到不再存在能增加模块性的重新分配社群的可能性为止，这两个步骤将被重复执行。
- en: 'Part of the first optimization step is evaluating the modularity of a group.
    Louvain uses the following formula to accomplish this:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 第一优化步骤的一部分是评估一个群体的模块性。Louvain使用以下公式来实现这一点：
- en: <math display="inline"><mrow><mi>Q</mi> <mo>=</mo> <mfrac><mn>1</mn> <mrow><mn>2</mn><mi>m</mi></mrow></mfrac>
    <munder><mo>∑</mo> <mrow><mi>u</mi><mo>,</mo><mi>v</mi></mrow></munder> <mfenced
    separators="" open="[" close="]"><msub><mi>A</mi> <mrow><mi>u</mi><mi>v</mi></mrow></msub>
    <mo>-</mo> <mfrac><mrow><msub><mi>k</mi> <mi>u</mi></msub> <msub><mi>k</mi> <mi>v</mi></msub></mrow>
    <mrow><mn>2</mn><mi>m</mi></mrow></mfrac></mfenced> <mi>δ</mi> <mrow><mo>(</mo>
    <msub><mi>c</mi> <mi>u</mi></msub> <mo>,</mo> <msub><mi>c</mi> <mi>v</mi></msub>
    <mo>)</mo></mrow></mrow></math>
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="inline"><mrow><mi>Q</mi> <mo>=</mo> <mfrac><mn>1</mn> <mrow><mn>2</mn><mi>m</mi></mrow></mfrac>
    <munder><mo>∑</mo> <mrow><mi>u</mi><mo>,</mo><mi>v</mi></mrow></munder> <mfenced
    separators="" open="[" close="]"><msub><mi>A</mi> <mrow><mi>u</mi><mi>v</mi></mrow></msub>
    <mo>-</mo> <mfrac><mrow><msub><mi>k</mi> <mi>u</mi></msub> <msub><mi>k</mi> <mi>v</mi></msub></mrow>
    <mrow><mn>2</mn><mi>m</mi></mrow></mfrac></mfenced> <mi>δ</mi> <mrow><mo>(</mo>
    <msub><mi>c</mi> <mi>u</mi></msub> <mo>,</mo> <msub><mi>c</mi> <mi>v</mi></msub>
    <mo>)</mo></mrow></mrow></math>
- en: 'where:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: '*u* and *v* are nodes.'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*u* 和 *v* 是节点。'
- en: '*m* is the total relationship weight across the entire graph (*2m* is a common
    normalization value in modularity formulas).'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*m* 是整个图中的总关系权重（*2m* 是模块性公式中常见的归一化值）。'
- en: <math display="inline"><mrow><msub><mi>A</mi> <mrow><mi>u</mi><mi>v</mi></mrow></msub>
    <mo>-</mo> <mfrac><mrow><msub><mi>k</mi> <mi>u</mi></msub> <msub><mi>k</mi> <mi>v</mi></msub></mrow>
    <mrow><mn>2</mn><mi>m</mi></mrow></mfrac></mrow></math> is the strength of the
    relationship between *u* and *v* compared to what we would expect with a random
    assignment (tends toward averages) of those nodes in the network.
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <math display="inline"><mrow><msub><mi>A</mi> <mrow><mi>u</mi><mi>v</mi></mrow></msub>
    <mo>-</mo> <mfrac><mrow><msub><mi>k</mi> <mi>u</mi></msub> <msub><mi>k</mi> <mi>v</mi></msub></mrow>
    <mrow><mn>2</mn><mi>m</mi></mrow></mfrac></mrow></math> 是*u*和*v*之间的关系强度，相比于我们预期的随机分配这些节点在网络中的情况（倾向于平均值）。
- en: <math display="inline"><msub><mi>A</mi> <mrow><mi>u</mi><mi>v</mi></mrow></msub></math>
    is the weight of the relationship between *u* and *v*.
  id: totrans-441
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <math display="inline"><msub><mi>A</mi> <mrow><mi>u</mi><mi>v</mi></mrow></msub></math>
    是*u*和*v*之间的关系权重。
- en: <math display="inline"><msub><mi>k</mi> <mi>u</mi></msub></math> is the sum
    of relationship weights for *u*.
  id: totrans-442
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <math display="inline"><msub><mi>k</mi> <mi>u</mi></msub></math> 是*u*的关系权重之和。
- en: <math display="inline"><msub><mi>k</mi> <mi>v</mi></msub></math> is the sum
    of relationship weights for *v*.
  id: totrans-443
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <math display="inline"><msub><mi>k</mi> <mi>v</mi></msub></math> 是*v*的关系权重之和。
- en: <math display="inline"><mrow><mi>δ</mi> <mo>(</mo> <msub><mi>c</mi> <mi>u</mi></msub>
    <mo>,</mo> <msub><mi>c</mi> <mi>v</mi></msub> <mo>)</mo></mrow></math> is equal
    to 1 if *u* and *v* are assigned to the same community, and 0 if they are not.
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <math display="inline"><mrow><mi>δ</mi> <mo>(</mo> <msub><mi>c</mi> <mi>u</mi></msub>
    <mo>,</mo> <msub><mi>c</mi> <mi>v</mi></msub> <mo>)</mo></mrow></math> 如果*u*和*v*被分配到相同的社区则等于1，否则为0。
- en: Another part of that first step evaluates the change in modularity if a node
    is moved to another group. Louvain uses a more complicated variation of this formula
    and then determines the best group assignment.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步的另一部分评估了如果一个节点移动到另一组会导致模块性变化。Louvain使用这个公式的一个更复杂的变体，然后确定最佳的组分配。
- en: When Should I Use Louvain?
  id: totrans-446
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用Louvain？
- en: Use Louvain Modularity to find communities in vast networks. This algorithm
    applies a heuristic, as opposed to exact, modularity, which is computationally
    expensive. Louvain can therefore be used on large graphs where standard modularity
    algorithms may struggle.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Louvain模块性在庞大的网络中查找社区。该算法应用一种启发式方法，而不是精确的模块性，这在计算上是昂贵的。因此，Louvain可以用于标准模块性算法可能遇到困难的大型图形中。
- en: Louvain is also very helpful for evaluating the structure of complex networks,
    in particular uncovering many levels of hierarchies–such as what you might find
    in a criminal organization. The algorithm can provide results where you can zoom
    in on different levels of granularity and find subcommunities within subcommunities
    within subcommunities.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: Louvain还对评估复杂网络结构非常有帮助，特别是揭示多层次的层次结构，比如在犯罪组织中可能发现的结构。该算法可以提供结果，您可以放大不同粒度的层次并找到子社区内的子社区。
- en: 'Example use cases include:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 示例用例包括：
- en: Detecting cyberattacks. The Louvain algorithm was used in [a 2016 study by S.
    V. Shanbhaq](https://bit.ly/2FAxalS) of fast community detection in large-scale
    cybernetworks for cybersecurity applications. Once these communities have been
    detected they can be used to detect cyberattacks.
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现网络安全应用中的快速社区检测的2016年研究中使用了Louvain算法，作者为S. V. Shanbhaq（链接地址见[这里](https://bit.ly/2FAxalS)）。一旦检测到这些社区，它们可以用来检测网络攻击。
- en: Extracting topics from online social platforms, like Twitter and YouTube, based
    on the co-occurence of terms in documents as part of the topic modeling process.
    This approach is described in a paper by G. S. Kido, R. A. Igawa, and S. Barbon
    Jr., [“Topic Modeling Based on Louvain Method in Online Social Networks”](http://bit.ly/2UbCCUl).
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于在线社交平台（如Twitter和YouTube）文档中术语的共现来提取主题作为主题建模过程的一部分。该方法在G. S. Kido、R. A. Igawa和S.
    Barbon Jr.的论文中有描述，链接地址见[这里](http://bit.ly/2UbCCUl)。
- en: Finding hierarchical community structures within the brain’s functional network,
    as described in [“Hierarchical Modularity in Human Brain Functional Networks”](https://bit.ly/2HFHXxu)
    by D. Meunier et al.
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在描述的“人类脑功能网络中的层次模块性”（链接地址见[这里](https://bit.ly/2HFHXxu)）中，寻找大脑功能网络内的层次社区结构。
- en: Warning
  id: totrans-453
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Modularity optimization algorithms, including Louvain, suffer from two issues.
    First, the algorithms can overlook small communities within large networks. You
    can overcome this problem by reviewing the intermediate consolidation steps. Second,
    in large graphs with overlapping communities, modularity optimizers may not correctly
    determine the global maxima. In the latter case, we recommend using any modularity
    algorithm as a guide for gross estimation but not complete accuracy.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 包括Louvain在内的模块化优化算法存在两个问题。首先，算法可能会忽视大网络中的小社区。您可以通过审查中间整合步骤来解决这个问题。其次，在具有重叠社区的大图中，模块化优化器可能无法正确确定全局最大值。在后一种情况下，我们建议使用任何模块化算法作为粗略估计的指导，而不是完全准确。
- en: Louvain with Neo4j
  id: totrans-455
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Louvain与Neo4j
- en: 'Let’s see the Louvain algorithm in action. We can execute the following query
    to run the algorithm over our graph:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Louvain算法的实际效果。我们可以执行以下查询来运行我们的图上的算法：
- en: '[PRE20]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The parameters passed to this algorithm are:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给此算法的参数如下：
- en: '`Library`'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '`Library`'
- en: The node label to load from the graph
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 从图中加载的节点标签
- en: '`DEPENDS_ON`'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '`DEPENDS_ON`'
- en: The relationship type to load from the graph
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 从图中加载的关系类型
- en: 'These are the results:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是结果：
- en: '| libraries | communities |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '| libraries | communities |'
- en: '| --- | --- |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| pytz | [0, 0] |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
  zh: '| pytz | [0, 0] |'
- en: '| pyspark | [1, 1] |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
  zh: '| pyspark | [1, 1] |'
- en: '| matplotlib | [2, 0] |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '| matplotlib | [2, 0] |'
- en: '| spacy | [2, 0] |'
  id: totrans-469
  prefs: []
  type: TYPE_TB
  zh: '| spacy | [2, 0] |'
- en: '| py4j | [1, 1] |'
  id: totrans-470
  prefs: []
  type: TYPE_TB
  zh: '| py4j | [1, 1] |'
- en: '| jupyter | [3, 2] |'
  id: totrans-471
  prefs: []
  type: TYPE_TB
  zh: '| jupyter | [3, 2] |'
- en: '| jpy-console | [3, 2] |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '| jpy-console | [3, 2] |'
- en: '| nbconvert | [4, 2] |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '| nbconvert | [4, 2] |'
- en: '| ipykernel | [3, 2] |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '| ipykernel | [3, 2] |'
- en: '| jpy-client | [4, 2] |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '| jpy-client | [4, 2] |'
- en: '| jpy-core | [4, 2] |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
  zh: '| jpy-core | [4, 2] |'
- en: '| six | [2, 0] |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
  zh: '| six | [2, 0] |'
- en: '| pandas | [0, 0] |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
  zh: '| pandas | [0, 0] |'
- en: '| numpy | [2, 0] |'
  id: totrans-479
  prefs: []
  type: TYPE_TB
  zh: '| numpy | [2, 0] |'
- en: '| python-dateutil | [2, 0] |'
  id: totrans-480
  prefs: []
  type: TYPE_TB
  zh: '| python-dateutil | [2, 0] |'
- en: The `communities` column describes the community that nodes fall into at two
    levels. The last value in the array is the final community and the other one is
    an intermediate community.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '`communities`列描述了节点在两个级别上所属的社区。数组中的最后一个值是最终社区，另一个是中间社区。'
- en: The numbers assigned to the intermediate and final communities are simply labels
    with no measurable meaning. Treat these as labels that indicate which community
    nodes belong to such as “belongs to a community labeled 0”, “a community labeled
    4”, and so forth.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 分配给中间和最终社区的数字只是没有可测量含义的标签。将其视为指示节点属于哪个社区的标签，例如“属于标记为0的社区”，“标记为4的社区”等。
- en: For example, matplotlib has a result of `[2,0]`. This means that matplotlib’s
    final community is labeled `0` and its intermediate community is labeled `2`.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，matplotlib的结果是`[2,0]`。这意味着matplotlib的最终社区标记为`0`，其中间社区标记为`2`。
- en: 'It’s easier to see how this works if we store these communities using the write
    version of the algorithm and then query it afterwards. The following query will
    run the Louvain algorithm and store the result in the `communities` property on
    each node:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用算法的写版本来存储这些社区，然后在之后查询，就能更容易地看出它是如何工作的。以下查询将运行Louvain算法，并将结果存储在每个节点的`communities`属性中：
- en: '[PRE21]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We could also store the resulting communities using the streaming version of
    the algorithm, followed by calling the `SET` clause to store the result. The following
    query shows how we could do this:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用算法的流式处理版本来存储生成的社区，然后调用`SET`子句来存储结果。以下查询显示了我们可以这样做的方式：
- en: '[PRE22]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once we’ve run either of those queries, we can write the following query to
    find the final clusters:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行了这些查询中的任何一个，我们可以编写以下查询来查找最终的聚类：
- en: '[PRE23]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`l.communities[-1]` returns the last item from the underlying array that this
    property stores.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '`l.communities[-1]`返回此属性存储的底层数组中的最后一项。'
- en: 'Running the query yields this output:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 运行查询产生以下输出：
- en: '| community | libraries |'
  id: totrans-492
  prefs: []
  type: TYPE_TB
  zh: '| community | libraries |'
- en: '| --- | --- |'
  id: totrans-493
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 | [pytz, matplotlib, spacy, six, pandas, numpy, python-dateutil] |'
  id: totrans-494
  prefs: []
  type: TYPE_TB
  zh: '| 0 | [pytz, matplotlib, spacy, six, pandas, numpy, python-dateutil] |'
- en: '| 2 | [jupyter, jpy-console, nbconvert, ipykernel, jpy-client, jpy-core] |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
  zh: '| 2 | [jupyter, jpy-console, nbconvert, ipykernel, jpy-client, jpy-core] |'
- en: '| 1 | [pyspark, py4j] |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
  zh: '| 1 | [pyspark, py4j] |'
- en: This clustering is the same as we saw with the connected components algorithm.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 这种聚类与我们在连接组件算法中看到的聚类相同。
- en: matplotlib is in a community with pytz, spacy, six, pandas, numpy, and python-dateutil.
    We can see this more clearly in [Figure 6-13](#louvain_level_2_image).
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: matplotlib与pytz、spacy、six、pandas、numpy和python-dateutil处于同一个社区。我们可以在[Figure 6-13](#louvain_level_2_image)中更清楚地看到这一点。
- en: '![gral 0613](Images/gral_0613.png)'
  id: totrans-499
  prefs: []
  type: TYPE_IMG
  zh: '![gral 0613](Images/gral_0613.png)'
- en: Figure 6-13\. Clusters found by the Louvain algorithm
  id: totrans-500
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-13。Louvain算法找到的群集
- en: 'An additional feature of the Louvain algorithm is that we can see the intermediate
    clustering as well. This will show us finer-grained clusters than the final layer
    did:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: Louvain 算法的另一个特点是我们还可以看到中间的聚类。这将展示比最终层次结构更细粒度的聚类：
- en: '[PRE24]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Running that query gives this output:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该查询会得到以下输出：
- en: '| community | libraries |'
  id: totrans-504
  prefs: []
  type: TYPE_TB
  zh: '| community | libraries |'
- en: '| --- | --- |'
  id: totrans-505
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 2 | [matplotlib, spacy, six, python-dateutil] |'
  id: totrans-506
  prefs: []
  type: TYPE_TB
  zh: '| 2 | [matplotlib, spacy, six, python-dateutil] |'
- en: '| 4 | [nbconvert, jpy-client, jpy-core] |'
  id: totrans-507
  prefs: []
  type: TYPE_TB
  zh: '| 4 | [nbconvert, jpy-client, jpy-core] |'
- en: '| 3 | [jupyter, jpy-console, ipykernel] |'
  id: totrans-508
  prefs: []
  type: TYPE_TB
  zh: '| 3 | [jupyter, jpy-console, ipykernel] |'
- en: '| 1 | [pyspark, py4j] |'
  id: totrans-509
  prefs: []
  type: TYPE_TB
  zh: '| 1 | [pyspark, py4j] |'
- en: '| 0 | [pytz, pandas] |'
  id: totrans-510
  prefs: []
  type: TYPE_TB
  zh: '| 0 | [pytz, pandas] |'
- en: '| 5 | [numpy] |'
  id: totrans-511
  prefs: []
  type: TYPE_TB
  zh: '| 5 | [numpy] |'
- en: 'The libraries in the matplotlib community have now broken down into three smaller
    communities:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: matplotlib 社区的库现在已经分解成三个较小的社区：
- en: matplotlib, spacy, six, and python-dateutil
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: matplotlib、spacy、six 和 python-dateutil
- en: pytz and pandas
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pytz 和 pandas
- en: numpy
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: numpy
- en: We can see this breakdown visually in [Figure 6-14](#louvain_level_2_image_2).
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 [图 6-14](#louvain_level_2_image_2) 中直观地看到这种分解。
- en: '![gral 0614](Images/gral_0614.png)'
  id: totrans-517
  prefs: []
  type: TYPE_IMG
  zh: '![gral 0614](Images/gral_0614.png)'
- en: Figure 6-14\. Intermediate clusters found by the Louvain algorithm
  id: totrans-518
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-14\. Louvain 算法找到的中间聚类
- en: Although this graph only showed two layers of hierarchy, if we ran this algorithm
    on a larger graph we would see a more complex hierarchy. The intermediate clusters
    that Louvain reveals can be very useful for detecting fine-grained communities
    that may not be detected by other community detection algorithms.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管此图仅显示了两层层次结构，但如果我们在更大的图上运行此算法，我们会看到一个更复杂的层次结构。Louvain 显示的中间聚类对于检测可能不会被其他社区检测算法检测到的精细社区非常有用。
- en: Validating Communities
  id: totrans-520
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证社区
- en: 'Community detection algorithms generally have the same goal: to identify groups.
    However, because different algorithms begin with different assumptions, they may
    uncover different communities. This makes choosing the right algorithm for a particular
    problem more challenging and a bit of an exploration.'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 社区检测算法通常有相同的目标：识别群体。然而，由于不同的算法从不同的假设开始，它们可能会发现不同的社区。这使得在特定问题上选择合适的算法更具挑战性，也需要进行一些探索。
- en: Most community detection algorithms do reasonably well when relationship density
    is high within groups compared to their surroundings, but real-world networks
    are often less distinct. We can validate the accuracy of the communities found
    by comparing our results to a benchmark based on data with known communities.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数社区检测算法在群体内部的关系密度较高时表现良好，但真实世界的网络通常不那么明显。通过将我们的结果与基于已知社区数据的基准进行比较，我们可以验证找到的社区的准确性。
- en: 'Two of the best-known benchmarks are the Girvan-Newman (GN) and Lancichinetti–Fortunato–Radicchi
    (LFR) algorithms. The reference networks that these algorithms generate are quite
    different: GN generates a random network which is more homogeneous, whereas LFR
    creates a more heterogeneous graph where node degrees and community size are distributed
    according to a power law.'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 最知名的两个基准测试是 Girvan-Newman（GN）和 Lancichinetti–Fortunato–Radicchi（LFR）算法。这些算法生成的参考网络非常不同：GN
    生成一个更均匀的随机网络，而 LFR 创建一个更异质的图，其中节点度和社区大小按照幂律分布。
- en: Since the accuracy of our testing depends on the benchmark used, it’s important
    to match our benchmark to our dataset. As much as possible, look for similar densities,
    relationship distributions, community definitions, and related domains.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们测试的准确性取决于使用的基准，因此将我们的基准与数据集匹配非常重要。尽可能地寻找类似的密度、关系分布、社区定义和相关领域。
- en: Summary
  id: totrans-525
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Community detection algorithms are useful for understanding the way that nodes
    are grouped together in a graph.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 社区检测算法对于理解图中节点如何分组在一起非常有用。
- en: 'In this chapter, we started by learning about the Triangle Count and Clustering
    Coefficient algorithms. We then moved on to two deterministic community detection
    algorithms: Strongly Connected Components and Connected Components. These algorithms
    have strict definitions of what constitutes a community and are very useful for
    getting a feel for the graph structure early in the graph analytics pipeline.'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先学习了关于三角计数和聚类系数算法。然后我们转向了两种确定性社区检测算法：强连通组件和连通组件。这些算法对于在图分析管道的早期阶段获取图结构的感觉非常有用，因为它们对社区的定义非常严格。
- en: We finished with Label Propagation and Louvain, two nondeterministic algorithms
    which are better able to detect finer-grained communities. Louvain also showed
    us a hierarchy of communities at different scales.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了标签传播和Louvain两个非确定性算法，它们能更好地检测更细粒度的社区。Louvain还向我们展示了不同尺度上的社区层次结构。
- en: In the next chapter, we’ll take a much larger dataset and learn how to combine
    the algorithms together to gain even more insight into our connected data.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用一个更大的数据集，学习如何将这些算法结合起来，以便更深入地理解我们的连接数据。
