- en: Part 4\. Managing authentication and user sessions
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第四部分。管理认证和用户会话
- en: The ability to identify individual users is a key piece of functionality for
    most web applications. Visitors should be able to register their details so that
    they can log back in as returning users at a later date. When users are registered
    and logged in, the application should be able to make use of the data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 识别个别用户的能力是大多数Web应用程序的关键功能之一。访客应该能够注册他们的详细信息，以便他们可以在以后日期以回头客的身份重新登录。当用户注册并登录后，应用程序应该能够利用这些数据。
- en: In [chapter 11](kindle_split_024.xhtml#ch11), you look at how authentication
    works in the MEAN stack. The focus is on creating an authentication API that you’ll
    use to power the user-centered parts of the Angular SPA.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](kindle_split_024.xhtml#ch11)中，你将了解MEAN堆栈中认证的工作方式。重点是创建一个认证API，你将使用它来为Angular
    SPA的用户中心部分提供动力。
- en: '[Chapter 12](kindle_split_025.xhtml#ch12) rounds things off by integrating
    the API you created in [chapter 11](kindle_split_024.xhtml#ch11) and updates the
    Angular application to take advantage of the new capabilities introduced. We also
    expand on some of the themes and patterns that we introduced to you in [chapter
    10](kindle_split_022.xhtml#ch10).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[第12章](kindle_split_025.xhtml#ch12)通过集成在第11章（kindle_split_024.xhtml#ch11）中创建的API，并更新Angular应用程序以利用引入的新功能来结束本章。我们还扩展了一些在第10章（kindle_split_022.xhtml#ch10）中介绍的主题和模式。'
- en: Chapter 11\. Authenticating users, managing sessions, and securing APIs
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第11章。认证用户、管理会话和确保API安全
- en: '*This chapter covers*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Adding authentication in the MEAN stack
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在MEAN堆栈中添加认证
- en: Using Passport.js to manage authentication in Express
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Passport.js在Express中管理认证
- en: Generating JSON Web Tokens in Express
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Express中生成JSON Web Tokens
- en: Registering and logging in a user
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册和登录用户
- en: Securing API endpoints in Express
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Express中保护API端点
- en: In this chapter, you’ll improve on the existing application by making users
    log in before they can leave reviews. This topic is an important one, as many
    web applications need to let users log in and manage a session.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将通过让用户在发表评论之前先登录来改进现有的应用程序。这个主题非常重要，因为许多Web应用程序需要让用户登录并管理会话。
- en: '[Figure 11.1](#ch11fig01) shows where you are in the overall plan, now working
    with the MongoDB database, Express API, and Angular single-page application (SPA).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11.1](#ch11fig01)显示了你在整体计划中的位置，现在正在与MongoDB数据库、Express API和Angular单页应用程序（SPA）一起工作。'
- en: Figure 11.1\. This chapter adds an authentication system to the application
    that touches most parts of the architecture, such as the database, API, and front-end
    SPA.
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.1。本章向应用程序添加了认证系统，该系统影响架构的大部分部分，例如数据库、API和前端SPA。
- en: '![](Images/11fig01_alt.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig01_alt.jpg)'
- en: Your first stop is an overview of how to approach authentication in a MEAN stack
    application before updating Loc8r one piece at a time, working through the architecture
    from back end to front end. You’ll update the database and data schemas before
    upgrading the API and finally modifying the front end. By the end of the chapter,
    you’ll be able to register new users, log them in, maintain a session, and perform
    actions that only logged-in users can complete.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你的第一步是概述如何在MEAN堆栈应用程序中处理认证，在更新Loc8r时，一次更新一个部分，从后端到前端逐步处理架构。你将在升级API和最终修改前端之前更新数据库和数据模式。到本章结束时，你将能够注册新用户、登录他们、维护会话，并执行只有登录用户才能完成的操作。
- en: 11.1\. How to approach authentication in the MEAN stack
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1. 如何在MEAN堆栈中处理认证
- en: How to manage authentication in a MEAN application is viewed as one of the great
    mysteries of the stack, particularly when using an SPA, largely because the entire
    application code is delivered to the browser. So how do you hide some of it? How
    do you define who can see or do what?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在MEAN应用程序中管理认证被视为堆栈中的伟大奥秘之一，尤其是在使用SPA时，这主要是因为整个应用程序代码都发送到浏览器。那么，你如何隐藏其中的一部分？你如何定义谁可以看到或做什么？
- en: 11.1.1\. Traditional server-based application approach
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.1. 传统的基于服务器的应用程序方法
- en: Much of the confusion arises because people are familiar with the traditional
    approach of application authentication and user session management.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分困惑源于人们对应用程序认证和用户会话管理的传统方法很熟悉。
- en: In a traditional setup, the application code sits and runs on the server. To
    log in, a user enters their username and password in a form that gets posted to
    the server.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的设置中，应用程序代码坐在服务器上运行。为了登录，用户在一个表单中输入他们的用户名和密码，该表单被发送到服务器。
- en: Then the server checks against a database to validate the login details. Assuming
    that the login is okay, the server sets a flag or session parameter in the user’s
    session on the server to declare that the user is logged in.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后服务器会检查数据库以验证登录详情。假设登录是正常的，服务器会在服务器上的用户会话中设置一个标志或会话参数，以声明用户已登录。
- en: The server may or may not set a cookie on a user’s browser with the session
    information. This is common but isn’t technically required to manage the authenticated
    session; it’s the server that maintains the vital session information. This flow
    is illustrated in [figure 11.2](#ch11fig02).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可能会也可能不会在用户的浏览器上设置一个包含会话信息的cookie。这是常见的，但技术上并不需要管理认证会话；维护关键会话信息的是服务器。这个流程在[图11.2](#ch11fig02)中得到了说明。
- en: Figure 11.2\. In a traditional server application, the server validates user
    credentials stored in the database and adds them to user’s session on the server.
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.2。在一个传统的服务器应用程序中，服务器验证存储在数据库中的用户凭据，并将它们添加到服务器上的用户会话中。
- en: '![](Images/11fig02_alt.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片11.2替代](Images/11fig02_alt.jpg)'
- en: After this initial handshake and with an established session, when a user requests
    a secure resource or tries to submit some data to the database, the server validates
    their session and decides whether they can continue. [Figure 11.3](#ch11fig03)
    shows how a traditional server setup manages access to secured resources by validating
    the user session, returning the requested resource when authorization status has
    been determined.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个初始握手和建立的会话之后，当用户请求安全资源或尝试向数据库提交一些数据时，服务器验证他们的会话并决定他们是否可以继续。[图11.3](#ch11fig03)
    展示了传统的服务器设置如何通过验证用户会话来管理对受保护资源的访问，当确定授权状态时返回请求的资源。
- en: Figure 11.3\. In a traditional server application, the server validates a user’s
    session before continuing with a secure request.
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.3。在一个传统的服务器应用程序中，服务器在继续进行安全请求之前验证用户的会话。
- en: '![](Images/11fig03_alt.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片11.3替代](Images/11fig03_alt.jpg)'
- en: '[Figure 11.4](#ch11fig04) continues with this theme, where the user has requested
    access to read/update/delete a resource contained within the application database,
    uses the provided data, and has a valid session.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11.4](#ch11fig04) 继续这个主题，其中用户请求访问读取/更新/删除应用程序数据库中包含的资源，使用提供的数据，并且有一个有效的会话。'
- en: Figure 11.4\. In a traditional server application, the server validates a user’s
    session before pushing data to a database.
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.4。在一个传统的服务器应用程序中，服务器在将数据推送到数据库之前验证用户的会话。
- en: '![](Images/11fig04_alt.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片11.4替代](Images/11fig04_alt.jpg)'
- en: That’s what the traditional approach looks like, but does it work for the MEAN
    stack?
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是传统方法的样子，但它适用于MEAN堆栈吗？
- en: 11.1.2\. Using the traditional approach in the MEAN stack
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.2. 在MEAN堆栈中使用传统方法
- en: This traditional approach isn’t a neat fit for the MEAN stack. The approach
    relies on the server to reserve some resources for each user so it can maintain
    the session information. You may remember from all the way back in [chapter 1](kindle_split_011.xhtml#ch01)
    that Node and Express don’t maintain sessions for each user; the entire application
    for all users runs on a single thread.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种传统的方法并不完全适合MEAN堆栈。这种方法依赖于服务器为每个用户保留一些资源，以便它可以维护会话信息。你可能还记得，从第一章开始，Node和Express不会为每个用户维护会话；所有用户的整个应用程序都在单个线程上运行。
- en: That said, you can use a version of this approach in the MEAN stack if you’re
    using a server-side application based on Express, like the one you built in [chapter
    7](kindle_split_018.xhtml#ch07). Rather than using server resources to maintain
    session information, Express can use a database to store the data. MongoDB can
    be used; another popular option is Redis, which is a lightning-fast key-value
    store.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，如果你使用基于Express的服务器端应用程序，比如你在第7章中构建的那个，你可以在MEAN堆栈中使用这种方法的版本。Express而不是使用服务器资源来维护会话信息，可以使用数据库来存储数据。MongoDB可以使用；另一个流行的选择是Redis，它是一个闪电般的键值存储。
- en: We’re not going to cover that approach in this book. Instead, we’ll look at
    the more complicated scenario of adding authentication to an SPA hitting an API
    for data.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在本书中介绍这种方法。相反，我们将探讨更复杂的场景，即在SPA中添加对数据API的认证。
- en: 11.1.3\. Full MEAN stack approach
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.3. 完整的MEAN堆栈方法
- en: In this section, you’ll see how authentication fits in the MEAN stack and how
    easy it is to use JSON Web Tokens and middleware like Passport.js.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将看到身份验证如何适应MEAN堆栈，以及使用JSON Web Tokens和Passport.js等中间件是多么容易。
- en: 'Authentication in the MEAN stack poses two problems:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: MEAN堆栈中的身份验证提出了两个问题：
- en: The API is stateless, as Express and Node have no concept of user sessions.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 是无状态的，因为 Express 和 Node 没有用户会话的概念。
- en: The application logic is already delivered to the browser, so you can’t limit
    the code that gets delivered.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序逻辑已经发送到浏览器，因此无法限制要发送的代码。
- en: The logical solution to these problems is to maintain some kind of session state
    in the browser and let the application decide what it can and can’t display to
    the current user. This is the only fundamental change in approach. A few technical
    differences remain, but this is the only major shift.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这些问题的逻辑解决方案是在浏览器中维护某种类型的会话状态，并让应用程序决定它可以向当前用户显示什么以及不可以显示什么。这是方法上的唯一基本变化。一些技术差异仍然存在，但这只是主要的转变。
- en: A great way to securely keep user data in the browser to maintain a session
    is to use a JSON Web Token (JWT). In this section, we’ll use *JWT* and *token*
    interchangeably. You’ll look at these in more detail in section [11.4](#ch11lev1sec4)
    when you start creating them, and further in [chapter 12](kindle_split_025.xhtml#ch12)
    when you consume them in your Angular application. In essence, a JWT is a JSON
    object encrypted into a string that’s meaningless to the human eye but that can
    be decoded and understood by both the application and the server.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中安全地保存用户数据以维持会话的一个好方法是使用 JSON Web Token (JWT)。在本节中，我们将使用 *JWT* 和 *token*
    互换。当您开始创建它们时，您将在第 [11.4](#ch11lev1sec4) 节中详细了解这些内容，并在第 [12](kindle_split_025.xhtml#ch12)
    章节中进一步了解，当您在 Angular 应用程序中消费它们时。本质上，JWT 是一个加密成字符串的 JSON 对象，对人类眼睛来说没有意义，但可以被应用程序和服务器解码和理解。
- en: The next section covers how this looks at a high level, starting with the login
    process.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将介绍这一过程在高级别上的表现，从登录过程开始。
- en: Managing the login process
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 管理登录过程
- en: '[Figure 11.5](#ch11fig05) illustrates the flow of a login process. A user posts
    their credentials to the server (via an API); the server validates these credentials
    by using the database and returns a token to the browser. The browser saves this
    token to reuse it later.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11.5](#ch11fig05) 展示了登录过程的流程。用户将他们的凭据发送到服务器（通过 API）；服务器通过使用数据库验证这些凭据，并将令牌返回到浏览器。浏览器将此令牌保存以供以后重用。'
- en: Figure 11.5\. The login flow in a MEAN application, returning a JSON Web Token
    to the browser after the server validates user credentials
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.5\. MEAN 应用程序中的登录流程，在服务器验证用户凭据后向浏览器返回 JSON Web Token
- en: '![](Images/11fig05_alt.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/11fig05_alt.jpg)'
- en: This approach is similar to the traditional approach, but instead of storing
    a user’s session data on the server, that data is stored in the browser.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与传统方法类似，但不同之处在于，不是将用户的会话数据存储在服务器上，而是存储在浏览器中。
- en: Changing views during an authenticated session
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在认证会话期间更改视图
- en: While a user is in a session, they’ll need to be able to change a page or view,
    and the application will need to know what they should be allowed to see. So,
    as illustrated in [figure 11.6](#ch11fig06), the application will decode the JWT
    and use the information to show the appropriate data to the user.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户处于会话中时，他们需要能够更改页面或视图，并且应用程序需要知道他们应该被允许看到什么。因此，如图 [11.6](#ch11fig06) 所示，应用程序将解码
    JWT 并使用这些信息向用户显示适当的数据。
- en: Figure 11.6\. Using data inside the JWT, the SPA can determine which resources
    a user can use or see.
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.6\. 使用 JWT 内部的数据，SPA 可以确定用户可以使用或查看哪些资源。
- en: '![](Images/11fig06_alt.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/11fig06_alt.jpg)'
- en: This is where the change from the traditional approach is obvious. The server
    is unaware that users are doing anything until they need to access the API and
    database.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是传统方法改变明显的地方。服务器在用户需要访问 API 和数据库之前，对用户的行为一无所知。
- en: Securely calling an API
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 安全地调用 API
- en: If parts of the application are restricted to authenticated users, it’s quite
    likely that some database actions can be used only by authenticated users. As
    the API is stateless, it has no idea of who’s making each call unless you tell
    it. The JWT comes back into play here. As [figure 11.7](#ch11fig07) shows, the
    token is sent to the API endpoint, which decodes the token before validating whether
    the user is permitted to make that call.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序的部分内容仅限于认证用户，那么很可能某些数据库操作只能由认证用户使用。由于 API 是无状态的，除非您告诉它，否则它不知道是谁在发起每个调用。JWT
    在这里再次发挥作用。如图 [11.7](#ch11fig07) 所示，该令牌被发送到 API 端点，该端点在验证用户是否有权进行该调用之前会解码令牌。
- en: Figure 11.7\. When calling an authenticated API endpoint, the browser sends
    the JWT along with the data; the server decodes the token to validate a user’s
    request.
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.7\. 当调用认证的API端点时，浏览器会发送JWT以及数据；服务器解码令牌以验证用户的请求。
- en: '![](Images/11fig07_alt.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/11fig07_alt.jpg)'
- en: That covers the approach at a high level, and you’ve got a good idea of what
    you’re aiming for. You’ll make the first step toward adding an authentication
    mechanism into your Loc8r application by setting up MongoDB to store user details.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这就涵盖了高层次的方法，您对目标有了很好的了解。您将通过设置MongoDB以存储用户详细信息，将第一步添加到Loc8r应用程序的认证机制中。
- en: 11.2\. Creating a user schema for MongoDB
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2\. 为MongoDB创建用户模式
- en: Usernames and passwords naturally have to be stored in the database. In your
    case, you’ll use a User collection. To do that in the MEAN stack, you need to
    create a Mongoose schema. Passwords should never—absolutely never—be stored in
    a database as plain text, as doing so presents a massive security breach if the
    database is ever compromised. You’ll have to do something else as you generate
    the schema.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 用户名和密码自然必须存储在数据库中。在您的案例中，您将使用用户集合。要在MEAN堆栈中做到这一点，您需要创建一个Mongoose模式。密码绝对不应该以纯文本形式存储在数据库中，因为这样做如果数据库遭到破坏，将呈现一个巨大的安全漏洞。在生成模式时，您必须做些其他事情。
- en: '11.2.1\. One-way password encryption: Hashes and salts'
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.1\. 单向密码加密：哈希和盐
- en: The thing to do here is run a one-way encryption on the password. One-way encryption
    prevents anyone from decrypting the password, while still making it easy to validate
    a correct password. When a user tries to log in, the application can encrypt a
    given password and see whether it matches the stored value.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要做的就是在密码上运行单向加密。单向加密可以防止任何人解密密码，同时仍然可以轻松验证正确的密码。当用户尝试登录时，应用程序可以加密一个给定的密码并查看它是否与存储的值匹配。
- en: Encrypting isn’t enough, though. If several people used the word *password*
    as their password (it happens!) the encryption for each is the same. Any hackers
    looking through the database could see this pattern and identify potentially weak
    passwords.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 加密还不够。如果几个人使用“password”作为他们的密码（这种情况确实会发生！），每个的加密都是相同的。任何查看数据库的黑客都可以看到这个模式并识别出潜在的弱密码。
- en: This is where the concept of a salt comes in. A *salt* is a random string generated
    by the application for each user that’s combined with the password before encryption.
    The resulting encrypted value is called a *hash*, as illustrated in [figure 11.8](#ch11fig08).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是盐的概念出现的地方。盐是一个由应用程序为每个用户生成的随机字符串，在加密之前与密码结合。生成的加密值称为哈希，如图11.8所示。
- en: Figure 11.8\. A hash is created by combining a user’s password with a random
    salt and encrypting them.
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.8\. 通过将用户的密码与随机盐结合并加密，创建一个哈希。
- en: '![](Images/11fig08_alt.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/11fig08_alt.jpg)'
- en: The salt and the hash are both stored in the database, rather than just a single
    password field. In this approach, all hashes should be unique, and passwords are
    well protected.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 盐和哈希都存储在数据库中，而不仅仅是单个密码字段。在这种方法中，所有哈希都应该唯一，密码得到了很好的保护。
- en: 11.2.2\. Building the Mongoose schema
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.2\. 构建 Mongoose 模式
- en: You’ll start by creating the file that will hold the schema and `require` it
    into the application. In the folder app_api/models/, create a new file called
    users.js.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您将首先创建一个将包含模式并将其`require`到应用程序中的文件。在app_api/models/文件夹中，创建一个名为users.js的新文件。
- en: 'Next, you’ll pull that file into the application by referencing it in the db.js
    file in the same folder. It should be `require`d alongside the existing line that
    brings in the locations model, as shown in the following code snippet, at the
    bottom of the file:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将通过在相同文件夹中的db.js文件中引用它，将该文件拉入应用程序。它应该与现有行一起`require`，该行引入了位置模型，如下面的代码片段所示，位于文件底部：
- en: '[PRE0]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now you’re ready to build the basic schema.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经准备好构建基本模式。
- en: 11.2.3\. Basic user schema
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.3\. 基本用户模式
- en: What do you want in the user schema? You know that you need a display name to
    show on reviews, plus a hash and a salt for the password. In this section, you’ll
    also add an email address and make it the unique identifier that a user logs in
    with.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您想在用户模式中包含什么？您知道您需要一个显示名称来显示在评论中，还需要密码的哈希和盐。在本节中，您还将添加电子邮件地址并将其作为用户登录的唯一标识符。
- en: In the new user.js file, you’ll `require` Mongoose and define a new `userSchema`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的user.js文件中，您将`require` Mongoose并定义一个新的`userSchema`。
- en: Listing 11.1\. Basic Mongoose schema for users
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.1\. 用户的基本Mongoose模式
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* Email should be required and unique.**'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 电子邮件应该是必需的且唯一的。**'
- en: '***2* Name is also required but not necessarily unique.**'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 名称也是必需的，但不一定是唯一的。**'
- en: '***3* Hash and salt are both strings.**'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 散列和盐都是字符串。**'
- en: The email and name are both set from the registration form, but the hash and
    salt are both created by the system. The hash, of course, is derived from the
    salt, and the password is supplied via the form.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件和名称都是从注册表单设置的，但散列和盐都是由系统创建的。当然，散列是从盐派生的，密码是通过表单提供的。
- en: 'Next, you’ll see how to set the salt and the hash by using a piece of Mongoose
    functionality we haven’t touched on yet: methods.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将看到如何通过使用我们尚未涉及过的Mongoose功能：方法来设置盐和散列。
- en: 11.2.4\. Setting encrypted paths using Mongoose methods
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.4\. 使用Mongoose方法设置加密路径
- en: Mongoose allows you to add methods to a schema, which get exposed as model methods.
    Such methods give the code direct access to the model attributes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose允许您向模式添加方法，这些方法作为模型方法公开。这些方法使代码能够直接访问模型属性。
- en: The ideal outcome is to be able to do something along the lines of the following
    pseudocode.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 理想的结果是能够执行以下伪代码中的操作。
- en: Listing 11.2\. Pseudocode for setting password using Mongoose
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.2\. 使用Mongoose设置密码的伪代码
- en: '[PRE2]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* Instantiates the user model**'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 实例化用户模型**'
- en: '***2* Creates a new user**'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建新用户**'
- en: '***3* Sets the name and email values**'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 设置名称和电子邮件值**'
- en: '***4* Calls a setPassword method to set the password. This method allows you
    to handle the password hashing in a controlled and secure manner.**'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 调用setPassword方法来设置密码。此方法允许您以受控和安全的方式处理密码散列。**'
- en: '***5* Saves the new user**'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 保存新用户**'
- en: Next, you see how to add a method to Mongoose to achieve this purpose.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将看到如何向Mongoose添加一个方法以实现此目的。
- en: Adding a method to a Mongoose schema
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 向Mongoose模式添加方法
- en: Methods can be added to a schema *after* the schema has been defined, *before*
    the model is compiled, because it’s regular JavaScript. In the application code,
    methods are designed to be used after the model has been instantiated.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 方法可以在定义模式后、在编译模型之前添加，因为它是常规JavaScript。在应用程序代码中，方法设计为在实例化模型后使用。
- en: 'Adding a method to a schema is achieved by chaining onto the `.methods` object
    of the schema. It’s also easy to pass in an argument. The following snippet, for
    example, is the outline for the actual `setPassword` method:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过连接到模式的`.methods`对象来向模式添加方法。传递参数也很容易。例如，以下片段是实际`setPassword`方法的轮廓：
- en: '[PRE3]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Unusually for a snippet of JavaScript, `this` in a Mongoose method refers to
    the model itself. So, in the preceding example, setting `this.salt` and `this.hash`
    in the method sets them in the model.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于JavaScript片段来说，Mongoose方法中的`this`通常指的是模型本身。因此，在上面的例子中，在方法中设置`this.salt`和`this.hash`就是在模型中设置它们。
- en: 'Before you can save anything, though, you need to generate a random salt value
    and encrypt the hash. Fortunately, a native Node module is available for that
    purpose: `crypto`.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在您能够保存任何内容之前，您需要生成一个随机的盐值并加密散列。幸运的是，有一个本地的Node模块可用于此目的：`crypto`。
- en: Using the crypto module for encryption
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用crypto模块进行加密
- en: 'Encryption is such a common requirement that Node has a built-in module called
    `crypto`. This module comes with several methods for managing the encryption of
    data. In this section, we’ll look at the following two:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 加密是一个如此常见的需求，Node有一个内置的模块叫做`crypto`。此模块包含用于管理数据加密的几个方法。在本节中，我们将查看以下两个：
- en: '`randomBytes`—To generate a cryptographically strong string of data to use
    as the salt.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`randomBytes`—用于生成一个用于盐的加密强数据字符串。'
- en: '`pbkdf2Sync`—To create the hash from the password and the salt. *pbkdf2* stands
    for *password-based key derivation function 2*, an industry standard.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pbkdf2Sync`—从密码和盐创建散列。*pbkdf2*代表*基于密码的密钥派生函数2*，这是行业标准。'
- en: 'You’ll use these methods to create a random string for the salt and for encrypting
    the password and salt into the hash. The first step is to `require crypto` at
    the top of the users.js file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用这些方法来创建用于盐的随机字符串，并将密码和盐加密到散列中。第一步是在users.js文件顶部`require crypto`：
- en: '[PRE4]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Second, update the `setPassword` method to set the salt and the hash for users.
    To set the salt, you’ll use the `randomBytes` method to generate a random 16-byte
    string. Then, you’ll use the `pbkdf2Sync` method to create the encrypted hash
    from the password and the salt. The following listing shows how to use these two
    functions in conjunction with each other.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，更新 `setPassword` 方法以设置用户的盐和哈希。要设置盐，你将使用 `randomBytes` 方法生成一个随机的 16 字节字符串。然后，你将使用
    `pbkdf2Sync` 方法从密码和盐创建加密哈希。以下列表显示了如何结合使用这两个函数。
- en: Listing 11.3\. Setting the password in the `User` model
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.3\. 在 `User` 模型中设置密码
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* Creates a random string for the salt**'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 生成一个随机字符串作为盐**'
- en: '***2* Creates an encrypted hash**'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建一个加密哈希**'
- en: Now, when the `setPassword` method is called and supplied a password, the salt
    and the hash are generated for users and added to the model instance. The password
    is never saved anywhere and not even stored in memory.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当调用 `setPassword` 方法并提供一个密码时，将为用户生成盐和哈希，并将它们添加到模型实例中。密码永远不会被保存到任何地方，甚至不会存储在内存中。
- en: 11.2.5\. Validating a submitted password
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.5\. 验证提交的密码
- en: The other aspect of storing a password is being able to retrieve it when users
    try to log in; you need to be able to validate their credentials. Having encrypted
    the password, you can’t decrypt it, so what you need to do is use the same encryption
    on the password the user is trying to log in with and see whether it matches the
    stored value.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 存储密码的另一个方面是当用户尝试登录时能够检索它；你需要能够验证他们的凭据。由于已经加密了密码，你不能解密它，所以你需要做的是使用与用户尝试登录时使用的密码相同的加密，并查看它是否与存储的值匹配。
- en: You can do the hashing and validation in a simple Mongoose method. Add the following
    method to users.js. It will be called from a controller when a user has been found
    with a given email address and return `true` or `false` depending on whether the
    hashes match.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在简单的 Mongoose 方法中执行哈希和验证。将以下方法添加到 users.js 中。它将在找到具有给定电子邮件地址的用户时从控制器中调用，并根据哈希是否匹配返回
    `true` 或 `false`。
- en: Listing 11.4\. Validating the submitted password
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.4\. 验证提交的密码
- en: '[PRE6]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* Hashes the provided password**'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 对提供的密码进行哈希处理**'
- en: '***2* Checks the password hash against the hash**'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将密码哈希与存储的哈希进行比较**'
- en: That’s it. Simple, right? You’ll see these methods in action when you generate
    the API controllers. The final thing the controller needs help to do is generate
    a JWT to include some of the model data.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。简单，对吧？当你生成 API 控制器时，你将看到这些方法在行动。控制器需要帮助做的最后一件事是生成一个 JWT 以包含一些模型数据。
- en: 11.2.6\. Generating a JSON Web Token
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.6\. 生成 JSON Web Token
- en: A JWT (pronounced *jot*) is used to pass data around, in your case between the
    API on the server and the SPA in the browser. A JWT can also be used by the server
    that generated the token to authenticate a user when it’s returned in a subsequent
    request.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: JWT（发音为 *jot*）用于在服务器上的 API 和浏览器中的 SPA 之间传递数据。生成令牌的服务器还可以使用 JWT 在后续请求中验证用户。
- en: The next section takes a quick look at the parts of a JWT.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分简要介绍了 JWT 的组成部分。
- en: Three parts of a JWT
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: JWT 的三个部分
- en: 'A JWT is comprised of three random-looking, dot-separated strings. These strings
    can be long. Here’s a real-world example:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: JWT 由三个看起来随机的、点分隔的字符串组成。这些字符串可能很长。以下是一个现实世界的例子：
- en: '[PRE7]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This string is meaningless to the human eye, but you should be able to spot
    the two dots and therefore the three separate parts. These three parts are
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字符串对人类眼睛来说没有意义，但你应该能够找到两个点，因此是三个独立的部分。这三个部分是
- en: '***Header—*** An encoded JSON object containing the type and the hashing algorithm
    used'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***头部——*** 包含类型和所使用的哈希算法的编码 JSON 对象'
- en: '***Payload—*** An encoded JSON object containing the data, the real body of
    the token'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***有效载荷——*** 包含数据的编码 JSON 对象，是令牌的真实主体'
- en: '***Signature—*** An encrypted hash of the header and payload, using a secret
    that only the originating server knows'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***签名——*** 使用只有原始服务器才知道的密钥对头部和有效载荷进行加密的哈希值'
- en: Note that the first two parts aren’t encrypted; they’re *encoded*, so it’s easy
    for the browser—or indeed, other applications—to decode them. Most modern browsers
    have a native function called `atob()` that can decode a Base64 string. A sister
    function called `btoa()` can encode *to* a Base64 string.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前两部分没有被加密；它们是*编码*的，因此浏览器——或者实际上，其他应用程序——可以轻松地解码它们。大多数现代浏览器都有一个名为 `atob()`
    的原生函数，可以解码 Base64 字符串。还有一个名为 `btoa()` 的姐妹函数，可以将数据编码为 Base64 字符串。
- en: The third part, the signature, is encrypted. To decrypt it, you need to use
    the secret that was set on the server. This secret should remain on the server
    and never be revealed in public.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分，签名是加密的。要解密它，你需要使用在服务器上设置的密钥。这个密钥应该保留在服务器上，永远不要在公共场合透露。
- en: The good news is that there are libraries to deal with all the complicated parts
    of the process. In the next section, you’ll install one of these libraries into
    your application and create a schema method to generate a JWT.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，有库可以处理这个过程中的所有复杂部分。在下一节中，你将安装其中一个库到你的应用程序中，并创建一个用于生成 JWT 的模式方法。
- en: Generating a JWT from Express
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从 Express 生成 JWT
- en: 'The first step in generating a JWT is including an npm module called `jsonweb-token`
    from the command line:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 生成 JWT 的第一步是在命令行中包含一个名为 `jsonweb-token` 的 npm 模块：
- en: '[PRE8]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, you `require` it at the top of the users.js file:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你 `require` 它在 users.js 文件的顶部：
- en: '[PRE9]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Finally, you create a schema method, which you’ll call `generateJwt`. To generate
    a JWT, you need to provide the payload—that is, the data—and a secret value. In
    the payload, you’ll send the user’s `_id`, `email`, and `name`. You should also
    set an expiry date for the token, after which the user will have to log in again
    to generate a new one. You’ll use a reserved field in a JWT payload, `exp`, which
    expects the expiry data as a UNIX number value.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你创建一个模式方法，你将调用 `generateJwt`。要生成 JWT，你需要提供有效载荷——即数据——和一个密钥值。在有效载荷中，你将发送用户的不
    `_id`、`email` 和 `name`。你还应该为令牌设置一个过期日期，在此之后，用户将不得不再次登录以生成一个新的令牌。你将使用 JWT 有效载荷中的一个保留字段，`exp`，它期望过期数据是一个
    UNIX 数字值。
- en: To generate a JWT, call a `sign` method on the `jsonwebtoken` library, sending
    the payload as a JSON object and the secret as a string. This method returns a
    token, which you can return out of the method. The next listing shows everything
    in place.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成 JWT，请在 `jsonwebtoken` 库上调用一个 `sign` 方法，将有效载荷作为 JSON 对象发送，并将密钥作为字符串发送。此方法返回一个令牌，你可以从方法中返回它。下一个列表显示了所有内容。
- en: Listing 11.5\. Creating a schema method to generate a JWT
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.5\. 创建一个用于生成 JWT 的模式方法
- en: '[PRE10]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* Creates an expiry date object, and sets it for seven days**'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个过期日期对象，并设置为七天**'
- en: '***2* Calls the jwt.sign method, and returns what it returns**'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 调用 jwt.sign 方法，并返回它返回的内容**'
- en: '***3* Passes the payload to the method**'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将有效载荷传递给方法**'
- en: '***4* Includes exp as UNIX time in seconds**'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将 exp 包含为秒的 UNIX 时间**'
- en: '***5* Sends secret for hashing algorithm to use**'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将密钥发送给散列算法使用**'
- en: When this `generateJwt` method is called, it uses the data from the current
    user model to create a unique JWT and return it, as illustrated in [figure 11.9](#ch11fig09).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用这个 `generateJwt` 方法时，它会使用当前用户模型中的数据来创建一个唯一的 JWT 并返回它，如图 11.9 所示。
- en: Figure 11.9\. A JWT is created by combining a signature object—based on the
    information you want to store—and a secret hash. The signature is created and
    returned as a JWT.
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.9\. 通过结合一个基于你想要存储的信息的签名对象和一个密钥散列来创建 JWT。签名被创建并作为 JWT 返回。
- en: '![](Images/11fig09_alt.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig09_alt.jpg)'
- en: 'There’s one problem with this code: the secret shouldn’t be visible, which
    creates security concerns. You’ll deal with that problem next.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有一个问题：密钥不应该可见，这会引发安全问题。你将在下一节中解决这个问题。
- en: Keeping the secret secret with environment variables
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用环境变量保持密钥的秘密
- en: If you’re going to be pushing your code around in version control (in GitHub,
    for example), you don’t want to have the secret published. Exposing your secret
    dramatically weakens your security model. With your secret, anybody could issue
    fake tokens that your application believes to be genuine. To keep secrets secret,
    it’s often a good idea to set them as environment variables.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算在版本控制中推送你的代码（例如在 GitHub 中），你不想将密钥发布出去。泄露你的密钥会大大削弱你的安全模型。有了你的密钥，任何人都可以发布假令牌，你的应用程序会认为它们是真实的。为了保持秘密的秘密，通常将它们设置为环境变量是一个好主意。
- en: 'Here’s an easy technique that lets you keep track of environment variables
    in the code on your machine. First, create a file in the root of the project called
    .env, and set the secret as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种简单的技术，让你可以在机器上的代码中跟踪环境变量。首先，在项目的根目录中创建一个名为 .env 的文件，并按如下设置密钥：
- en: '[PRE11]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this case, the secret is `thisIsSecret`, but it can be whatever you want
    it to be so long as it’s a string. Next, you need to make sure that this file
    isn’t included in any Git commits by adding a line to the .gitignore file in the
    project. If you’re following along with the code from GitHub, this line is already
    in place; if not, you need to add it. At a minimum, the .gitignore file should
    have the following content:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，密钥是 `thisIsSecret`，但它可以是您想要的任何字符串，只要它是一个字符串。接下来，您需要确保这个文件不会被包含在任何 Git
    提交中，通过在项目的 `.gitignore` 文件中添加一行来实现。如果您正在跟随 GitHub 上的代码，这一行已经就位；如果没有，您需要添加它。至少，`.gitignore`
    文件应该包含以下内容：
- en: '[PRE12]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To read and use this new file to set environment variables, you’ll need to
    install and use a new npm module called `dotenv`. Use the following command in
    terminal:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了读取和使用这个新文件来设置环境变量，您需要安装并使用一个名为 `dotenv` 的新 npm 模块。在终端中使用以下命令：
- en: '[PRE13]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `dotenv` module should be `require`d into the app.js file as the first
    line in the file, as shown here:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`dotenv` 模块应该作为文件的第一行被 `require` 到 `app.js` 文件中，如下所示：'
- en: '[PRE14]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now all that remains is to update the user schema to replace the hardcoded secret
    with the environment variable, highlighted in bold in the following listing.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是更新用户模式，用环境变量替换硬编码的密钥，如下列所示，并加粗显示。
- en: Listing 11.6\. Updating `generateJwt` with environment settings
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.6\. 使用环境设置更新 `generateJwt`
- en: '[PRE15]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* Don’t keep secrets in code; use environment variables instead.**'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 不要在代码中保留密钥；使用环境变量代替。**'
- en: 'Your production environment needs to know about this environment variable too.
    You may remember the command from when you set the database URI on Heroku. It’s
    the same thing here, so run the following command in terminal:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您的生产环境也需要了解这个环境变量。您可能还记得在 Heroku 上设置数据库 URI 时的命令。这里也是一样，所以在终端中运行以下命令：
- en: '[PRE16]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That’s the last step.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是最后一步。
- en: With the MongoDB and Mongoose side of things covered, next, you’ll look at using
    Passport to manage authentication.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MongoDB 和 Mongoose 方面处理完毕后，接下来您将查看如何使用 Passport 来管理身份验证。
- en: 11.3\. Creating an authentication API with Passport
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3\. 使用 Passport 创建身份验证 API
- en: Passport is a Node module by Jared Hanson that’s designed to make authentication
    in Node easy. One of its key strengths is that it can accommodate several methods
    of authentication, called *strategies*. Examples of these strategies include
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Passport 是由 Jared Hanson 开发的一个 Node 模块，旨在使 Node 中的身份验证变得简单。其关键优势之一是它可以适应多种身份验证方法，称为
    *策略*。这些策略的例子包括
- en: Facebook
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Facebook
- en: Twitter
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Twitter
- en: OAuth
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth
- en: Local username and password
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地用户名和密码
- en: You can find many more strategies by searching for *passport* on the npm website.
    With Passport, you can easily use one or more of these approaches to let users
    log in to your application. For Loc8r, you’ll use the *local* strategy, as you’re
    storing usernames and password hashes in the database. You’ll start by installing
    the modules.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 npm 网站上通过搜索 *passport* 找到更多策略。使用 Passport，您可以轻松地使用这些方法之一或多个，让用户登录到您的应用程序。对于
    Loc8r，您将使用 *local* 策略，因为您在数据库中存储用户名和密码散列。您将首先安装模块。
- en: 11.3.1\. Installing and configuring Passport
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.1\. 安装和配置 Passport
- en: 'Passport is separated out into a core module and separate modules for each
    of the strategies. You’ll install the core module and the local strategy module
    via npm, using the following commands in terminal:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Passport 被分离成一个核心模块和针对每个策略的独立模块。您将通过 npm 安装核心模块和本地策略模块，在终端中使用以下命令：
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When both of those modules are installed, you can create the configuration for
    your local strategy.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当这两个模块都安装完毕后，您可以创建本地策略的配置。
- en: Creating a Passport config file
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建 Passport 配置文件
- en: It’s the API in your application that will be using Passport, so you’ll create
    the config inside the app_api folder. Inside app_api, create a new folder called
    config, and inside that folder, create a new file named passport.js.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您应用程序中将使用 Passport 的 API，因此您将在 `app_api` 文件夹内创建配置。在 `app_api` 内，创建一个名为 `config`
    的新文件夹，并在该文件夹内创建一个名为 `passport.js` 的新文件。
- en: 'At the top of this file, `require` Passport and the local strategy module,
    as well as Mongoose and the user model:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件顶部，`require` Passport 和本地策略模块，以及 Mongoose 和用户模型：
- en: '[PRE18]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now you can configure the local strategy.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以配置本地策略了。
- en: Configuring a local strategy
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 配置本地策略
- en: 'To set a Passport strategy, you use a `passport.use` method and pass it a new
    strategy constructor. This constructor takes an options parameter and a function
    that does most of the work. The skeleton for using a Passport strategy looks like
    the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置Passport策略，您使用`passport.use`方法并传递一个新的策略构造函数。此构造函数接受一个选项参数和一个执行大部分工作的函数。使用Passport策略的骨架如下所示：
- en: '[PRE19]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'By default, a Passport local strategy expects and uses the fields `username`
    and `password`. You have `password`, so that one’s okay, but instead of `username`,
    you’re using `email`. Passport allows you to override the username field in the
    options object, as shown in the following snippet:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Passport本地策略期望并使用字段`username`和`password`。您有`password`，所以这一点没问题，但您使用的是`email`而不是`username`。Passport允许您在选项对象中覆盖用户名字段，如下面的代码片段所示：
- en: '[PRE20]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next is the main function, which is a Mongoose call to find users given the
    username and password supplied to the function. Your Mongoose function needs to
    do the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是主函数，这是一个Mongoose调用，用于根据函数中提供的用户名和密码查找用户。您的Mongoose函数需要执行以下操作：
- en: Find a user with the email address supplied.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据提供的电子邮件地址查找用户。
- en: Check whether the password is valid.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查密码是否有效。
- en: Return the user object if the user is found and the password is valid.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果找到用户且密码有效，则返回用户对象。
- en: Otherwise, return a message stating what’s wrong.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，返回一个说明错误的消息。
- en: As the email address is set to be unique in the schema, you can use the Mongoose
    `findOne` method. The other interesting point to note is that you’ll use the `validPassword`
    schema method you created earlier to check whether the supplied password is correct.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 由于电子邮件地址在模式中设置为唯一，您可以使用Mongoose的`findOne`方法。另一个需要注意的有趣点是，您将使用您之前创建的`validPassword`模式方法来检查提供的密码是否正确。
- en: The following listing shows the local strategy in its entirety.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了本地策略的完整内容。
- en: Listing 11.7\. Full Passport local strategy definition
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.7\. 完整的Passport本地策略定义
- en: '[PRE21]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***1* Searches MongoDB for a user with the supplied email address**'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在MongoDB中搜索提供的电子邮件地址的用户**'
- en: '***2* If no user is found, returns false and a message**'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 如果没有找到用户，返回false和消息**'
- en: '***3* Calls the validPassword method, passing the supplied password**'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 调用validPassword方法，传递提供的密码**'
- en: '***4* If the password is incorrect, returns false and a message**'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 如果密码不正确，返回false和消息**'
- en: '***5* If you’ve reached the end, you can return the user object.**'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 如果您已经到达了末尾，您可以返回用户对象。**'
- en: Now that you have Passport installed and a strategy configured, you need to
    register it with the application.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经安装了Passport并配置了策略，您需要将其注册到应用程序中。
- en: Adding Passport and the config to the application
  id: totrans-205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将护照和配置添加到应用程序中
- en: 'To add your Passport settings to the application, you need to do three things
    in app.js:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要将您的护照设置添加到应用程序中，您需要在app.js中执行以下三个步骤：
- en: Require Passport.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要Passport。
- en: Require the strategy config.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要策略配置。
- en: Initialize Passport.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化Passport。
- en: There’s nothing complicated about any of these things; what’s important is *where*
    they go in app.js.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事情都没有什么复杂的；重要的是它们在app.js中的位置。
- en: Passport should be required *before* the database models and the configuration
    *after* the database models. Both should be in place before the routes are defined.
    If you reorganize the top of app.js slightly, you can bring in Passport and the
    config as shown in the following listing.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Passport应该在模型定义之前需要策略，在模型定义之后配置配置。两者都应该在定义路由之前就位。如果您稍微重新组织app.js的顶部，就可以引入Passport和配置，如下面的列表所示。
- en: Listing 11.8\. Introducing Passport to Express
  id: totrans-212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.8\. 将Passport引入Express
- en: '[PRE22]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***1* Requires Passport before the model definition**'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在模型定义之前需要Passport**'
- en: '***2* Requires strategy after the model definition**'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在模型定义之后需要策略**'
- en: The strategy needs to be defined after the model definition because it needs
    the user model to exist.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 策略需要在模型定义之后定义，因为它需要用户模型存在。
- en: Passport should be initialized in app.js after the static routes have been defined
    and before the routes that are going to use authentication—in your case, the API
    routes—so that the authentication middleware can be applied by Express as required.
    The following listing shows the `passport` middleware in place.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Passport应该在定义了静态路由之后和将要使用身份验证的路由（在您的案例中是API路由）之前在app.js中初始化，以便Express可以按需应用身份验证中间件。以下列表显示了已放置的`passport`中间件。
- en: Listing 11.9\. Adding the `passport` middleware
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.9\. 添加`passport`中间件
- en: '[PRE23]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1* Initializes passport and adds it as middleware**'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 初始化 Passport 并将其添加为中间件**'
- en: One last thing you need to do is update the `Access-Control-Allow-Headers` to
    ensure that CORS functions correctly between these two parts of this application.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的最后一件事是更新 `Access-Control-Allow-Headers`，以确保应用程序这两个部分之间 CORS 正确运行。
- en: Listing 11.10\. Update to CORS settings
  id: totrans-222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.10\. 更新 CORS 设置
- en: '[PRE24]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1* Adds Authorization as an acceptable header**'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 添加授权为可接受的头信息**'
- en: With that in place, Passport is installed, configured, and initialized in your
    application. Next, you’ll create the API endpoints that let users register and
    log in.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一来，Passport 就已安装、配置并初始化在你的应用程序中。接下来，你将创建允许用户注册和登录的 API 端点。
- en: 11.3.2\. Creating API endpoints to return JWTs
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.2\. 创建返回 JWT 的 API 端点
- en: To enable users to log in and register via your API, you need two new endpoints.
    You need to add two new route definitions and two new corresponding controllers.
    When you’ve got endpoints in place, you can test them by using Postman and also
    validate that the registration endpoint worked by using the Mongo shell to look
    inside the database. First, you’ll add the routes.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用户能够通过你的 API 登录和注册，你需要两个新的端点。你需要添加两个新的路由定义和两个新的相应控制器。当你有了端点，你可以使用 Postman
    测试它们，并使用 Mongo shell 查看数据库来验证注册端点是否工作。首先，你将添加路由。
- en: Adding the authentication route definitions
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加身份验证路由定义
- en: 'The route definitions for the API are held in the index.js file in app_api/routes,
    so that’s where you’ll start. Your controllers are separated into logical collections—currently,
    Locations and Reviews. It makes sense to add a third collection for the authentication.
    The following snippet shows this collection added at the top of the file:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: API 的路由定义存储在 `app_api/routes` 目录下的 index.js 文件中，所以你将从那里开始。你的控制器被分成逻辑集合——目前是位置和评论。添加一个用于身份验证的第三个集合是有意义的。以下片段显示了在文件顶部添加了这个集合：
- en: '[PRE25]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You haven’t created this controllers/authentication file yet; you’ll do that
    when you code the related controllers.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你还没有创建这个 controllers/authentication 文件；你将在编写相关控制器时创建它。
- en: 'Next, add the route definitions themselves toward the end of the file (but
    before the `module.exports` line). You want two, one each for registration and
    login, which you’ll create at /api/register and /api/login, respectively:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将路由定义本身添加到文件的末尾（但在 `module.exports` 行之前）。你需要两个，一个用于注册，一个用于登录，分别创建在 /api/register
    和 /api/login：
- en: '[PRE26]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: These definitions need to be `post` actions, of course, as they’re accepting
    data. Also remember that you don’t need to specify the /api part of the routes,
    which is added when the routes are required inside app.js.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定义必须是 `post` 动作，因为它们正在接受数据。还请记住，你不需要指定路由中的 /api 部分，这部分是在 app.js 中引入路由时添加的。
- en: Now you need to add the controllers before you can test.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要添加控制器，然后才能进行测试。
- en: Creating the register controller
  id: totrans-236
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建注册控制器
- en: We’ll look at the `register` controller first. To start, you’ll create the file
    specified in the route definitions. In the app_api/controllers folder, create
    a new file called authentication.js, and enter the following to require the things
    you’re going to need.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先看看 `register` 控制器。首先，你将创建路由定义中指定的文件。在 `app_api/controllers` 文件夹中，创建一个名为
    authentication.js 的新文件，并输入以下内容以引入你需要的东西。
- en: Listing 11.11\. Importing requirements for the `register` controller
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.11\. 导入 `register` 控制器所需的依赖
- en: '[PRE27]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The registration process won’t use Passport at all. You can do what you need
    with Mongoose, as you’ve already set up the various helper methods on the schema.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 注册过程完全不使用 Passport。你可以使用 Mongoose 做你需要的事情，因为你已经在模式上设置了各种辅助方法。
- en: 'The `register` controller needs to do the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`register` 控制器需要执行以下操作：'
- en: Validate that the required fields have been sent.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证是否已发送所需的字段。
- en: Create a new model instance of `User`.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `User` 的新模型实例。
- en: Set the name and email address of the user.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置用户的姓名和电子邮件地址。
- en: Use the `setPassword` method to create and add the salt and the hash.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `setPassword` 方法创建并添加盐和散列。
- en: Save the user.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存用户。
- en: Return a JWT when saved.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存时返回 JWT。
- en: This list seems like a lot of things to do, but fortunately, everything is easy;
    you’ve already done the hard work by creating the Mongoose methods. Now, you need
    to tie everything together. The following listing shows the complete code for
    the `register` controller.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表看起来有很多事情要做，但幸运的是，一切都很简单；你已经通过创建 Mongoose 方法完成了艰苦的工作。现在，你需要将一切联系起来。以下列表显示了
    `register` 控制器的完整代码。
- en: Listing 11.12\. `register` controller for the API
  id: totrans-249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.12\. `register` 控制器用于API
- en: '[PRE28]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '***1* Responds with an error status if not all required fields are found**'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 如果找不到所有必需的字段，则返回错误状态**'
- en: '***2* Creates a new user instance, and sets the name and email**'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建一个新的用户实例，并设置名称和电子邮件**'
- en: '***3* Uses the setPassword method to set the salt and hash**'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用`setPassword`方法设置盐和哈希**'
- en: '***4* Saves the new user to MongoDB**'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将新用户保存到MongoDB**'
- en: '***5* Generates a JWT, using the schema method, and sends it to the browser**'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 使用模式方法生成JWT，并将其发送到浏览器**'
- en: In this piece of code, there’s nothing particularly new or complex, but it highlights
    the power of Mongoose methods. This registration controller could have been complex
    had everything been written inline, which would have been tempting if you’d started
    here instead of with Mongoose. But as it is, the controller is easy to read and
    understand, which is what you want from your code.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，没有什么特别新颖或复杂，但它突出了Mongoose方法的力量。如果所有内容都内联编写，这个注册控制器可能会很复杂，如果你从这里开始而不是从Mongoose开始，这可能会很有吸引力。但正如它现在所展示的，控制器易于阅读和理解，这正是你想要的代码。
- en: Next, you’ll create the login controller.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将创建登录控制器。
- en: Creating the login controller
  id: totrans-258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建登录控制器
- en: The `login` controller relies on Passport to do the difficult stuff. You’ll
    start by validating that the required fields have been filled, and then hand everything
    to Passport. Passport does its thing—attempting to authenticate the user, using
    the strategy you specify—and then tells you whether it was successful. If it was
    successful, you can use the `generateJwt` schema method again to create a JWT
    before sending it to the browser.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`login` 控制器依赖于Passport来完成困难的工作。你将首先验证是否已填写所有必需的字段，然后将一切交给Passport。Passport会执行其操作——尝试使用你指定的策略来验证用户，然后告诉你是否成功。如果成功，你可以再次使用`generateJwt`模式方法来创建JWT，然后再将其发送到浏览器。'
- en: All this, including the syntax required to initiate the `passport.authenticate`
    method, is shown in the next listing. This code should be added to the new authentication.js
    file.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些，包括启动`passport.authenticate`方法所需的语法，都在下一个列表中展示。这段代码应添加到新的authentication.js文件中。
- en: Listing 11.13\. `login` controller for the API
  id: totrans-261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.13\. `login` 控制器用于API
- en: '[PRE29]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '***1* Validates that the required fields have been supplied**'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 验证是否已提供所有必需的字段**'
- en: '***2* Passes the name of the strategy and a callback to authenticate method**'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将策略名称和回调传递给认证方法**'
- en: '***3* Returns an error if Passport returns an error**'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果Passport返回错误，则返回错误**'
- en: '***4* If Passport returned a user instance, generates and sends a JWT**'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 如果Passport返回了一个用户实例，则生成并发送JWT**'
- en: '***5* Otherwise, returns an info message (why authentication failed)**'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 否则，返回一个信息消息（为什么认证失败）**'
- en: '***6* Makes sure that req and res are available to Passport**'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 确保req和res对Passport可用**'
- en: 'Add the `login` function to the module exports at the bottom of the file, below
    the register function:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件的底部将`login`函数添加到模块导出中，在`register`函数下方：
- en: '[PRE30]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With the `login` controller, you see that once again, all the complicated work
    is abstracted out, this time primarily by Passport. The code is easy to read,
    follow, and understand, which should always be a goal when you’re coding. Now
    that you’ve built these two endpoints in your API, you should test them.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在`login`控制器中，你可以看到，所有复杂的工作再次被抽象出来，这次主要是通过Passport。代码易于阅读、遵循和理解，这应该是你编码时的一个目标。现在，你已经构建了API中的这两个端点，你应该测试它们。
- en: Testing the endpoints and checking the database
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 测试端点并检查数据库
- en: When you built the bulk of the API in [chapter 6](kindle_split_017.xhtml#ch06),
    you tested the endpoints with Postman. You can do the same here. [Figure 11.10](#ch11fig10)
    shows testing the register endpoint and how it returns a JWT. The URL to test
    is http://localhost:3000/api/register, creating form fields for `name`, `email`,
    and `password`. Remember to select the `x-www-form-urlencoded` form type.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在[第6章](kindle_split_017.xhtml#ch06)中构建API的大部分内容时，你使用Postman测试了端点。你在这里也可以这样做。[图11.10](#ch11fig10)显示了测试注册端点及其如何返回JWT。要测试的URL是http://localhost:3000/api/register，创建`name`、`email`和`password`的表单字段。请记住选择`x-www-form-urlencoded`表单类型。
- en: Figure 11.10\. Trying out the /api/register endpoint in Postman, returning a
    JWT when successful
  id: totrans-274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.10\. 在Postman中尝试/api/register端点，成功时返回JWT
- en: '![](Images/11fig10_alt.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig10_alt.jpg)'
- en: '[Figure 11.11](#ch11fig11) shows testing of the login endpoint, including the
    return of a Passport error message as well as a JWT when successful. The URL for
    this test is http://localhost:3000/api/login, and it requires `email` and `password`
    form fields.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11.11](#ch11fig11)显示了登录端点的测试，包括返回Passport错误消息以及成功时的JWT。此测试的URL为http://localhost:3000/api/login，需要`email`和`password`表单字段。'
- en: Figure 11.11\. Using the api/login endpoint in Postman, testing correct credentials
  id: totrans-277
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.11. 使用Postman中的api/login端点，测试正确的凭据
- en: '![](Images/11fig11_alt.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig11_alt.jpg)'
- en: 'As well as seeing in the browser that JWTs are returned when expected, you
    can take a look in the database to see whether the user has been created. You’ll
    go back to the Mongo shell, which you haven’t used for a while:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在浏览器中看到当预期时返回JWT之外，你还可以查看数据库以查看用户是否已被创建。你将回到Mongo shell，这是你一段时间没有使用过的：
- en: '[PRE31]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Or you can find a particular user by specifying the email address:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以通过指定电子邮件地址来查找特定用户：
- en: '[PRE32]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Whichever method you use, you should see one or more user documents returned
    from the database, looking something like the following listing.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用哪种方法，你都应从数据库中看到一个或多个用户文档返回，看起来像以下列表。
- en: Listing 11.14\. Possible database response
  id: totrans-284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.14. 可能的数据库响应
- en: '[PRE33]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We’ve made the path names bold to make them easier to pick out in print, but
    you should be able to see all the expected data there.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将路径名称加粗以使其在打印时更容易识别，但你应该能够看到所有预期的数据。
- en: Now that you’ve created the endpoints to enable users to register and log in,
    the next thing you’re going to look at is how to restrict certain endpoints to
    authenticated users.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了端点以使用户能够注册和登录，接下来你要查看的是如何限制某些端点只对认证用户开放。
- en: 11.4\. Securing relevant API endpoints
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4. 确保相关API端点安全
- en: 'It’s a common requirement in web applications to limit access to API endpoints
    to authenticated users only. In Loc8r, for example, you want to make sure that
    only registered users can leave reviews. This process has two parts:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序中，限制对API端点的访问仅限于认证用户是一个常见需求。例如，在Loc8r中，你想要确保只有注册用户可以留下评论。这个过程有两个部分：
- en: Allow only users who send a valid JWT with their request to call the new review
    API.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只允许发送有效JWT的用户调用新的评论API。
- en: Inside the controller, validate that the user exists and can create a review.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在控制器内部，验证用户是否存在并且可以创建评论。
- en: You’ll start by adding authentication to the routes in Express.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从向Express中的路由添加认证开始。
- en: 11.4.1\. Adding authentication middleware to Express routes
  id: totrans-293
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.4.1. 向Express路由添加认证中间件
- en: In Express, middleware can be added to routes, as you’ll see in a moment. This
    middleware gets between the route and the controller. When a route is called,
    the middleware is activated before the controller and can prevent the controller
    from running or changing the data being sent.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在Express中，你可以将中间件添加到路由中，你很快就会看到。这个中间件位于路由和控制器之间。当调用路由时，中间件在控制器之前被激活，可以阻止控制器运行或更改发送的数据。
- en: 'You want to use middleware that validates the supplied JWT and then extracts
    the payload data and adds it to the `req` object for the controller to use. It’s
    no surprise that an npm module is available for this purpose: `express-jwt`. Install
    it now with the following command in terminal:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要使用中间件来验证提供的JWT，然后提取有效载荷数据并将其添加到`req`对象中供控制器使用。不出所料，有一个npm模块可用于此目的：`express-jwt`。现在，在终端中使用以下命令安装它：
- en: '[PRE34]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now you can use this module in the routes file.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在路由文件中使用此模块。
- en: Setting up the middleware
  id: totrans-298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设置中间件
- en: To use `express-jwt`, you need to `require` it and configure it. When included,
    `express-jwt` exposes a function that can be passed an options object, which you’ll
    use to send the secret and also to specify the name of the property you want to
    add to the `req` object to hold the payload.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`express-jwt`，你需要`require`它并对其进行配置。当包含时，`express-jwt`会暴露一个函数，你可以传递一个选项对象，你将使用它来发送密钥，并指定你想要添加到`req`对象中以保存有效载荷的属性名称。
- en: The default property added to `req` is `user`, but in your code, `user` is an
    instance of the Mongoose `User` model, so set it to `payload` to prevent confusion
    and maintain consistency. `user` is what it’s called in Passport and inside the
    JWT, after all.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 默认添加到`req`的属性是`user`，但在你的代码中，`user`是Mongoose `User`模型的实例，因此将其设置为`payload`以避免混淆并保持一致性。毕竟，`user`是Passport和JWT中的称呼。
- en: Open the API routes file, app_api/routes/index.js, and add the setup to the
    top of the file, highlighted in bold in the following listing.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 打开API路由文件，app_api/routes/index.js，并将设置添加到文件顶部，如下所示，加粗显示。
- en: Listing 11.15\. Adding JWT to app_api/routes/locations.js
  id: totrans-302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.15\. 将JWT添加到app_api/routes/locations.js
- en: '[PRE35]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '***1* Requires express-jwt module**'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 需要express-jwt模块**'
- en: '***2* Sets the secret using the same environment variable as before**'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用与之前相同的环境变量设置密钥**'
- en: '***3* Defines a property on req to be the payload**'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在req上定义一个属性作为负载**'
- en: Now that the middleware is configured, you can add the authentication to the
    routes.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在中间件已配置，你可以将身份验证添加到路由中。
- en: Adding authentication middleware to specific routes
  id: totrans-308
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将身份验证中间件添加到特定路由
- en: Adding middleware to the route definitions is simple. Reference it in the router
    commands, between the route and the controller. It does go in the middle!
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 将中间件添加到路由定义中很简单。在路由和控制器之间引用路由命令。它确实位于中间！
- en: The following snippet shows how to add middleware to the `post`, `put`, and
    `delete` review method, while leaving `get` open; the reviews are supposed to
    be readable by the public.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了如何将中间件添加到`post`、`put`和`delete`评论方法中，同时保留`get`开放；评论应该对公众可读。
- en: Listing 11.16\. Updating `routing` to use the `jwt` module
  id: totrans-311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.16\. 更新`routing`以使用`jwt`模块
- en: '[PRE36]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '***1* Adds auth middleware to the routing definition**'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将身份验证中间件添加到路由定义中**'
- en: So that’s the middleware configured and applied. In a moment, you’ll see how
    to use it in the controller, but first, you’ll see how to deal with an invalid
    token that the middleware rejects.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，中间件已配置并应用。一会儿你将看到如何在控制器中使用它，但首先，你将看到如何处理中间件拒绝的无效令牌。
- en: Dealing with authentication rejection
  id: totrans-315
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 处理身份验证拒绝
- en: When the supplied token is invalid—or perhaps doesn’t exist—the middleware throws
    an error to prevent the code from continuing. You need to catch this error and
    return an unauthorized message and status (401).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 当提供的令牌无效或可能不存在时，中间件抛出错误以防止代码继续执行。你需要捕获这个错误并返回未授权消息和状态（401）。
- en: The best place to add the new error handler is with the other error handlers
    in app.js. You’ll add it as the first error handler so that generic handlers don’t
    intercept it. The following listing shows the new error handler to be added to
    app.js.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 将新错误处理器添加到app.js中的最佳位置是与其他错误处理器一起。你将将其添加为第一个错误处理器，以便通用处理器不会拦截它。以下列表显示了要添加到app.js中的新错误处理器。
- en: Listing 11.17\. Catching errors
  id: totrans-318
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.17\. 捕获错误
- en: '[PRE37]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '***1* Makes sure that you’re dealing with UnauthorizedErrors**'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 确保你正在处理未授权错误**'
- en: With that in place and the app restarted, you can test that rejection occurs
    by using Postman again, this time submitting a review. You can use the same `POST`
    request that you used when first testing the API, the result of which is shown
    in [figure 11.12](#ch11fig12).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置就绪并重新启动应用程序后，你可以再次使用Postman测试拒绝是否发生，这次提交一个评论。你可以使用首次测试API时使用的相同`POST`请求，其结果如图11.12所示。
- en: Figure 11.12\. Trying to add a review without a valid JWT now results in a 401
    response.
  id: totrans-322
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.12\. 尝试在没有有效JWT的情况下添加评论现在会导致401响应。
- en: '![](Images/11fig12_alt.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig12_alt.jpg)'
- en: As expected, trying to call the newly protected API endpoint without including
    a valid JWT in the request returns an unauthorized status and message, which is
    what you wanted. Next, you’ll move on to what happens when a request is authorized
    by the middleware and continues to the controller.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，尝试调用没有包含有效JWT的新受保护API端点将返回未授权状态和消息，这正是你想要的。接下来，你将进入当请求被中间件授权并继续到控制器时会发生什么。
- en: 11.4.2\. Using the JWT information inside a controller
  id: totrans-325
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.4.2\. 在控制器中使用JWT信息
- en: In this section, you’ll see how to use the data from the JWT that has been extracted
    by the middleware in Express and added to the `req` object. You’ll use the email
    address to get the user’s name from the database and add it to the review document.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解如何使用Express中间件提取的JWT数据，并将其添加到`req`对象中。你将使用电子邮件地址从数据库中获取用户名并将其添加到评论文档中。
- en: Running the main controller code only if the user exists
  id: totrans-327
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 只有当用户存在时才运行主控制器代码
- en: The first thing to do, as shown in [listing 11.18](#ch11ex18), is take the `reviewsCreate`
    controller and wrap the contents in a new function that you’ll call `getAuthor`.
    This new function should accept the `req` and `res` objects, with the existing
    controller code in a callback.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如[列表 11.18](#ch11ex18)所示，首先需要做的是获取`reviewsCreate`控制器，并将内容包装在一个新的函数中，你将调用它为`getAuthor`。这个新函数应该接受`req`和`res`对象，以及现有的控制器代码作为一个回调。
- en: The whole point of the `getAuthor` function is to validate that the user exists
    in the database and return the user’s name for use in the controller. So, you
    can pass this through as `userName` to the callback and, in turn, pass it through
    to the `doAddReview` function in app_api/controllers/review.js.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`getAuthor`函数的整个目的是验证用户是否存在于数据库中，并返回用户名以供控制器使用。因此，你可以将其作为`userName`传递给回调，然后将其传递给`app_api/controllers/review.js`中的`doAddReview`函数。'
- en: Listing 11.18\. Update the create review controller to get the user’s name first
  id: totrans-330
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.18\. 更新创建评论控制器以首先获取用户名
- en: '[PRE38]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '***1* Calls the getAuthor function and passes the original controller code
    in as a callback; passes the user’s name into the callback**'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 调用 getAuthor 函数，并将原始控制器代码作为回调传递；将用户名传递给回调**'
- en: '***2* Passes the user’s name into the doAddReview function**'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将用户名传递给 doAddReview 函数**'
- en: '***3* Closes the getAuthor function**'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 关闭 getAuthor 函数**'
- en: 'Looking at this listing highlights the two things you still need to do: write
    the `getAuthor` function, and update the `doAddReview` function. First, you’ll
    write the `getAuthor` function so that you can see how to get the JWT data.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 查看这个列表可以突出显示你仍然需要做的两件事：编写`getAuthor`函数，并更新`doAddReview`函数。首先，你将编写`getAuthor`函数，这样你就可以看到如何获取
    JWT 数据。
- en: Validating the user and returning the name
  id: totrans-336
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 验证用户并返回名称
- en: 'The idea of the `getAuthor` function is to validate that the email address
    is associated with a user on the system and return the name to use. It needs to
    do the following:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`getAuthor` 函数的想法是验证电子邮件地址是否与系统中的用户相关联，并返回要使用的名称。它需要执行以下操作：'
- en: Check that there’s an email address in the `req` object.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查`req`对象中是否有电子邮件地址。
- en: Use the email address to find a user.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用电子邮件地址查找用户。
- en: Send the user’s name to the callback function.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将用户名发送到回调函数。
- en: Trap errors and send appropriate messages.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获错误并发送适当的消息。
- en: The full code for the `getAuthor` function is in [listing 11.19](#ch11ex19).
    The first thing to do is check for the `payload` property on `req` and, in turn,
    check that it has an `email` property. Remember that `payload` is the property
    you specified when you added authentication to the Express routes. After that,
    use `req.payload.email` in a Mongoose query, passing the user’s name through to
    the callback if successful.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`getAuthor` 函数的完整代码在[列表 11.19](#ch11ex19)中。首先需要检查`req`上的`payload`属性，然后检查它是否具有`email`属性。记住，`payload`是你在向
    Express 路由添加身份验证时指定的属性。之后，使用`req.payload.email`在 Mongoose 查询中，如果成功，将用户名传递给回调函数。'
- en: Listing 11.19\. Use data from the JWT to query the database
  id: totrans-343
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.19\. 使用 JWT 数据查询数据库
- en: '[PRE39]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '***1* Ensures that the User model is available**'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 确保用户模型可用**'
- en: '***2* Validates that the JWT information is on the request object**'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 验证 JWT 信息是否在请求对象上**'
- en: '***3* Uses the email address to find the user**'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用电子邮件地址查找用户**'
- en: '***4* Runs the callback, passing the user’s name**'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 运行回调，传递用户名**'
- en: Now when the callback is invoked, it runs what was the original code in the
    controller, finding a location and passing the information to the `doAddReview`
    function. It’s also now passing the username to the function, so quickly update
    `doAddReview` to use the user’s name and add it to the review documents.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当回调被调用时，它运行控制器中的原始代码，找到一个位置并将信息传递给`doAddReview`函数。它现在也将用户名传递给函数，所以快速更新`doAddReview`以使用用户名并将其添加到评论文档中。
- en: Setting the user’s name on reviews
  id: totrans-350
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在评论中设置用户的名称
- en: The change to the `doAddReview` function is simple and is shown in [listing
    11.20](#ch11ex20). You were already saving the `author` of the review, getting
    the data from `req.body .author`. Now, you have another parameter being passed
    to the function and can use this parameter instead. The updates are highlighted
    in bold.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`doAddReview` 函数的更改很简单，如[列表 11.20](#ch11ex20)所示。你之前已经保存了评论的`author`，从`req.body
    .author`获取数据。现在，你有一个参数被传递给函数，可以使用这个参数。更新内容以粗体显示。'
- en: Listing 11.20\. Saving the username in the review
  id: totrans-352
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.20\. 在评论中保存用户名
- en: '[PRE40]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '***1* Adds an author parameter to the function definition**'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在函数定义中添加一个作者参数**'
- en: '***2* Author is now coming from the database rather than the form**'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 作者现在是从数据库而不是表单中获取的**'
- en: That simple change brings you to the end of the back-end work. You’ve created
    a new user schema, generated and consumed JWTs, created an authentication API,
    and secured some other API routes. That’s a lot already!
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的更改使你完成了后端工作。你已经创建了一个新的用户模式，生成和消费 JWT，创建了一个身份验证 API，并保护了一些其他 API 路由。这已经很多了！
- en: In [chapter 12](kindle_split_025.xhtml#ch12), you’ll tackle the front end and
    focus on integrating it into the Angular app.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 12 章](kindle_split_025.xhtml#ch12)中，你将处理前端并将其集成到 Angular 应用中。
- en: Summary
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了
- en: How to approach authentication in the MEAN stack
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 MEAN 栈中处理身份验证
- en: Encrypting passwords with hashes and salts
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用散列和盐加密密码
- en: Using Mongoose model methods to add functions to schemas
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Mongoose 模型方法向模式添加函数
- en: How to create a JSON Web Token with Express
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Express 创建 JSON Web Token
- en: Managing authentication on the server with Passport
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Passport 在服务器上管理身份验证
- en: Making routes in Express available to authenticated users only
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅对经过身份验证的用户在 Express 中提供路由
- en: Chapter 12\. Using an authentication API in Angular applications
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 12 章\. 在 Angular 应用中使用身份验证 API
- en: '*This chapter covers*'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Using local storage and Angular to manage a user session
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用本地存储和 Angular 管理用户会话
- en: Managing user sessions in Angular
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Angular 中管理用户会话
- en: Using JWT in Angular Applications
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Angular 应用中使用 JWT
- en: In this chapter, you’ll integrate the work that you completed in [chapter 11](kindle_split_024.xhtml#ch11)
    on authentication via API and use the API endpoints in your Angular application.
    Specifically, you’ll look at how to use the Angular HTTP client library and `localStorage`.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将集成在第 11 章（kindle_split_024.xhtml#ch11）中完成的通过 API 进行身份验证的工作，并在你的 Angular
    应用中使用 API 端点。具体来说，你将了解如何使用 Angular HTTP 客户端库和 `localStorage`。
- en: 12.1\. Creating an Angular authentication service
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1\. 创建 Angular 身份验证服务
- en: In an Angular app, as in any other application, authentication is likely to
    be needed across the board. The obvious thing to do is create an authentication
    service that can be used anywhere it’s needed. This service should be responsible
    for everything related to authentication, including saving and reading a JWT,
    returning information about the current user, and calling the login and register
    API endpoints.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 应用中，就像任何其他应用一样，很可能会在整个应用中需要身份验证。显然的做法是创建一个可以在任何需要的地方使用的身份验证服务。这个服务应该负责与身份验证相关的一切，包括保存和读取
    JWT、返回关于当前用户的信息，以及调用登录和注册 API 端点。
- en: You’ll start by looking at how to manage the user session.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从查看如何管理用户会话开始。
- en: 12.1.1\. Managing a user session in Angular
  id: totrans-375
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.1.1\. 在 Angular 中管理用户会话
- en: Assume for a moment that a user has just logged in and the API has returned
    a JWT. What should you do with the token? Because you’re running an SPA, you could
    keep it in the browser’s memory. This approach is okay unless the user decides
    to refresh the page, which reloads the application, losing everything in memory—not
    ideal.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 假设用户刚刚登录，API 返回了一个 JWT。你应该对令牌做什么？因为你正在运行一个单页应用（SPA），你可以将其保存在浏览器的内存中。这种方法是可以的，除非用户决定刷新页面，这会重新加载应用程序，丢失内存中的所有内容——这不是理想的情况。
- en: Next, you’ll look to save the token somewhere a bit more robust, allowing the
    application to read it whenever it needs to. The question is whether to use cookies
    or local storage.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将考虑将令牌保存在一个更健壮的地方，以便应用程序在需要时可以读取它。问题是是否使用 cookies 或本地存储。
- en: Cookies vs. local storage
  id: totrans-378
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Cookies 与本地存储的比较
- en: The traditional approach to saving user data in a web application is to save
    a cookie, and that’s certainly an option. But cookies are there to be used by
    server applications, with each request to the server sending the cookies along
    in the HTTP header to be read. In an SPA, you don’t need cookies; the API endpoints
    are stateless and don’t get or set cookies.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Web 应用中保存用户数据的传统方法是将 cookie 保存下来，这当然是一个选择。但 cookies 是供服务器应用使用的，每次向服务器发送请求时，都会在
    HTTP 头部发送 cookies 以供读取。在 SPA 中，你不需要 cookies；API 端点是无状态的，不会获取或设置 cookies。
- en: You need to look somewhere else, toward local storage, which is designed for
    client-side applications. With local storage, the data stays in the browser and
    doesn’t automatically get transmitted with requests, as would happen with cookies.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要另寻他处，转向本地存储，它是为客户端应用程序设计的。使用本地存储，数据会保留在浏览器中，并且不会像 cookies 那样自动与请求一起传输。
- en: 'Local storage is also easy to use with JavaScript. Look at the following snippet,
    which would set and get some data:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JavaScript，本地存储也很容易使用。看看下面的代码片段，它将设置和获取一些数据：
- en: '[PRE41]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Right, so that’s settled; you’ll use local storage in Loc8r to save the JWT.
    If `localStorage` isn’t familiar territory, head to the Mozilla developer documentation
    at [http://mng.bz/0WKz](http://mng.bz/0WKz) to find out more.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 对了，这样我们就确定了；你将在 Loc8r 中使用本地存储来保存 JWT。如果 `localStorage` 不熟悉，请访问 Mozilla 开发者文档
    [http://mng.bz/0WKz](http://mng.bz/0WKz) 以获取更多信息。
- en: To facilitate the use of `localStorage` in the Angular application, you’ll first
    create an `Injectable` called `BROWSER_STORAGE` that you can use in components.
    You’ll hook into the `localStorage`, but you’ll do so via a factory service that
    you inject into components that require access to the `localStorage`.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于在 Angular 应用程序中使用 `localStorage`，你首先创建一个名为 `BROWSER_STORAGE` 的 `Injectable`，你可以在组件中使用它。你将连接到
    `localStorage`，但你将通过一个工厂服务来实现，该服务被注入到需要访问 `localStorage` 的组件中。
- en: To start, generate the class file
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，生成类文件
- en: '[PRE42]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: and place the following code in it.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 并将以下代码放入其中。
- en: Listing 12.1\. storage.ts
  id: totrans-388
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.1\. storage.ts
- en: '[PRE43]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '***1* Uses the InjectionToken class**'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用 InjectionToken 类**'
- en: '***2* Creates a new InjectionToken**'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建新的 InjectionToken**'
- en: '***3* factory function wrapping localStorage**'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 包装 localStorage 的工厂函数**'
- en: Creating a service to save and read a JWT in local storage
  id: totrans-393
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建一个服务以在本地存储中保存和读取 JWT
- en: 'You’ll start building the authentication service by creating the methods to
    save a JWT in local storage and read it back out again. You’ve seen how easy it
    is to work with `localStorage` in JavaScript, so now you need to wrap it in an
    Angular service that exposes two methods: `saveToken()` and `getToken()`. No real
    surprises here, but the `saveToken()` method should accept a value to be saved,
    and `getToken()` should return a value.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过创建将 JWT 保存到本地存储并再次读取的方法来开始构建身份验证服务。你已经看到了在 JavaScript 中与 `localStorage`
    一起工作是多么容易，所以现在你需要将其包装在一个 Angular 服务中，该服务公开两个方法：`saveToken()` 和 `getToken()`。这里没有真正的惊喜，但
    `saveToken()` 方法应该接受要保存的值，而 `getToken()` 应该返回一个值。
- en: 'First, generate a new service called `Authentication` inside the Angular application:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 Angular 应用程序中生成一个名为 `Authentication` 的新服务：
- en: '[PRE44]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The following listing shows the contents of the new service, including the first
    two methods.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了新服务的内 容，包括前两个方法。
- en: Listing 12.2\. Creating the `authentication` service with the first two methods
  id: totrans-398
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.2\. 使用前两个方法创建 `authentication` 服务
- en: '[PRE45]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '***1* Injects the importer BROWSER_STORAGE wrapper**'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 注入 BROWSER_STORAGE 包装器**'
- en: '***2* Creates the getToken function**'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建获取令牌的函数**'
- en: '***3* Creates the saveToken function**'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 创建 saveToken 函数**'
- en: And there you have a simple service to handle saving `loc8r-token` to `localStorage`
    and reading it back out again. Next, you’ll look at logging in and registering.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 这样你就有一个简单的服务来处理将 `loc8r-token` 保存到 `localStorage` 并再次读取出来。接下来，你将查看登录和注册。
- en: 12.1.2\. Allowing users to sign up, sign in, and sign out
  id: totrans-404
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.1.2\. 允许用户注册、登录和登出
- en: To use the service to enable users to register, log in, and log out, you’ll
    need to add three more methods. Start with registering and logging in.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用该服务让用户注册、登录和登出，你需要添加三个更多的方法。从注册和登录开始。
- en: Calling the API to register and log in
  id: totrans-406
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 调用 API 进行注册和登录
- en: You’ll need two methods to register and log in, which post the form data to
    the `register` and `login` API endpoints you created earlier in this chapter.
    When successful, both these endpoints return a JWT, so you can use the `saveToken`
    method to save them.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要两个方法来注册和登录，这两个方法将表单数据发送到本章前面创建的 `register` 和 `login` API 端点。当成功时，这两个端点都返回
    JWT，因此你可以使用 `saveToken` 方法来保存它们。
- en: 'To prepare, you’ll generate two simple auxiliary classes to help manage the
    data that you need across the application—a `User` class ([listing 12.3](#ch12ex03))
    and an `AuthResponse` class ([listing 12.4](#ch12ex04)):'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备，你需要生成两个简单的辅助类来帮助管理你在应用程序中需要的数据——一个 `User` 类 ([列表 12.3](#ch12ex03)) 和一个
    `AuthResponse` 类 ([列表 12.4](#ch12ex04))：
- en: '[PRE46]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The following two listings show the simple classes that you’ll use to maintain
    the given data. [Listing 12.3](#ch12ex03) provides your `User` class definition,
    which is a simple class to hold the name and email as strings.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个列表显示了您将使用来维护给定数据的简单类。[列表 12.3](#ch12ex03) 提供了您的 `User` 类定义，这是一个简单的类，用于存储名称和电子邮件作为字符串。
- en: Listing 12.3\. user.ts
  id: totrans-411
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.3\. user.ts
- en: '[PRE47]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '***1* Tells typescript that you require strings here**'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 告诉 TypeScript 你在这里需要字符串**'
- en: '[Listing 12.4](#ch12ex04) provides the definition for your `AuthResponse` object,
    which at this time holds the token string.'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 12.4](#ch12ex04) 提供了您的 `AuthResponse` 对象的定义，此时它包含令牌字符串。'
- en: Listing 12.4\. authresponse.ts
  id: totrans-415
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.4\. authresponse.ts
- en: '[PRE48]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '***1* Sets the token to be a string**'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将令牌设置为字符串**'
- en: With these classes in place, you can add the aforementioned `register()` and
    `login()` methods to the authentication service, as shown in the next listing.
    As these methods rely on the Loc8rDataService, you’ll inject that too.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些类，您可以将前面提到的 `register()` 和 `login()` 方法添加到身份验证服务中，如下一个列表所示。由于这些方法依赖于 Loc8rDataService，您也将注入它。
- en: Listing 12.5\. authentication.service.ts
  id: totrans-419
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.5\. authentication.service.ts
- en: '[PRE49]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '***1* Imports the relevant classes and services**'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入相关类和服务**'
- en: '***2* Injects the data service**'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 注入数据服务**'
- en: '***3* The login function**'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 登录函数**'
- en: '***4* The register function**'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 注册函数**'
- en: Take a quick look at the two methods that you’ve added. What you’re doing is
    providing a wrapper for the `login()` and `register()` methods from the `Loc8rDataService`
    that you’re about to write and ensuring that a Promise gets returned so data can
    be passed back to the UI. You don’t necessarily care what’s in the Promise—only
    that it’s returned. Then the `token` from the `AuthResponse` object that the methods
    receive is saved, using the functions already in place.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 快速查看您添加的两个方法。您正在做的是为即将编写的 `login()` 和 `register()` 方法提供一个包装器，并确保返回一个 Promise，以便可以将数据传递回
    UI。您不必关心 Promise 中的内容——只需确保它被返回。然后，使用已存在的函数保存 `AuthResponse` 对象中的 `token`。
- en: Finally, you need to add the aforementioned methods to the `Loc8rDataService`
    that are required to communicate with the API endpoints. Changes are highlighted
    in bold in the next listing.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要将前面提到的、与 API 端点通信所需的方法添加到 `Loc8rDataService` 中。下一个列表中的更改以粗体显示。
- en: Listing 12.6\. Changes to `Loc8rDataService`
  id: totrans-427
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.6\. `Loc8rDataService` 的更改
- en: '[PRE50]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '***1* Imports for User and AuthResponse classes**'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* User 和 AuthResponse 类的导入**'
- en: '***2* Login method returning the AuthResponse Promise**'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 登录方法返回 AuthResponse Promise**'
- en: '***3* Register method returning the AuthResponse Promise**'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 注册方法返回 AuthResponse Promise**'
- en: '***4* The actual call. login and register are similar enough to make DRY.**'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 实际调用。登录和注册足够相似，可以做到 DRY。**'
- en: '***5* Uses the HttpClient POST request Observable that you convert to a Promise
    object**'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 使用 HttpClient POST 请求 Observable，并将其转换为 Promise 对象**'
- en: The call out to the API in both cases of `login` and `register` are essentially
    the same call; the only difference is the URL that you’re required to hit to perform
    the action you need. In [listing 12.6](#ch12ex06), you `POST` a payload containing
    the user details that you’re attempting to use and returning an `AuthResponse`
    object on success or handling the error on failure. To that end, you have a private
    method (`makeAuthApiCall()`) to manage the call and public methods `login()` and
    `register()` to handle the specific details of which API endpoint URL you want
    to call.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `login` 和 `register` 的两种情况下对 API 的调用基本上是相同的调用；唯一的区别是您需要击中的 URL 以执行所需的操作。在
    [列表 12.6](#ch12ex06) 中，您 `POST` 一个包含您尝试使用的用户详细信息的有效负载，并在成功时返回 `AuthResponse` 对象或在失败时处理错误。为此，您有一个私有方法
    (`makeAuthApiCall()`) 来管理调用，以及公共方法 `login()` 和 `register()` 来处理您想要调用的特定 API 端点
    URL 的具体细节。
- en: With these methods in place, you can address signing out.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些方法，您可以处理注销。
- en: Deleting localStorage to sign out
  id: totrans-436
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 删除 localStorage 以注销
- en: The user session in the Angular application is managed by saving the JWT in
    `localStorage`. If the token is there, is valid, and hasn’t expired, you can say
    that the user is logged in. You can’t change the expiry date of the token from
    within the Angular app; only the server can do that. What you can do is delete
    it.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 应用程序中，用户会话是通过在 `localStorage` 中保存 JWT 来管理的。如果令牌存在，有效，并且尚未过期，则可以说用户已登录。您无法从
    Angular 应用程序内部更改令牌的过期日期；只有服务器才能这样做。您可以做的只是删除它。
- en: To give users the ability to log out, you can create a new `logout` method in
    the authentication service to remove the Loc8r JWT.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让用户能够注销，您可以在认证服务中创建一个新的`logout`方法来删除Loc8r JWT。
- en: Listing 12.7\. Removing the token from location storage
  id: totrans-439
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.7\. 从位置存储中删除令牌
- en: '[PRE51]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '***1* Deletes the token from localStorage**'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从localStorage中删除令牌**'
- en: This code removes the `loc8r-token` item from the browser’s `localStorage`.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码从浏览器的`localStorage`中删除`loc8r-token`项。
- en: Now you have methods to get a JWT from the server, save it in `localStorage`,
    read it from `localStorage`, and delete it. The next question is how to use it
    in the application to see that a user is logged in and to get data out of it.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您有了从服务器获取JWT、将其保存到`localStorage`、从`localStorage`读取它以及删除它的方法。下一个问题是如何在应用程序中使用它来查看用户是否已登录以及从中获取数据。
- en: 12.1.3\. Using the JWT data in the Angular service
  id: totrans-444
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.1.3\. 在Angular服务中使用JWT数据
- en: The JWT saved in the browser’s `localStorage` is what you use to manage a user
    session. The JWT is used to validate whether a user is logged in. If a user is
    logged in, the application can also read the user information stored inside.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在浏览器`localStorage`中的JWT是您用来管理用户会话的。JWT用于验证用户是否已登录。如果用户已登录，应用程序还可以读取存储在其中的用户信息。
- en: First, add a method to check whether somebody is logged in.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，添加一个方法来检查某人是否已登录。
- en: Checking the logged-in status
  id: totrans-447
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 检查登录状态
- en: To check whether a user is currently logged in to the application, you need
    to check whether the `loc8r-token` exists in `localStorage`. You can use the `getToken()`
    method for that task. But the existence of a token isn’t enough. Remember that
    the JWT has expiry data embedded in it, so if a token exists, you’ll need to check
    that too.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查用户是否当前已登录到应用程序，您需要检查`loc8r-token`是否存在于`localStorage`中。您可以使用`getToken()`方法来完成此任务。但令牌的存在并不足够。请记住，JWT中嵌入有过期数据，所以如果令牌存在，您还需要检查它。
- en: 'The expiration date and time of the JWT is part of the payload, which is the
    second chunk of data. Remember that this part is an encoded JSON object; it’s
    encoded rather than encrypted, so you can decode it. In fact, we’ve already talked
    about the function to do this: `atob`.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: JWT的过期日期和时间是有效载荷的一部分，这是数据的第二部分。请记住，这部分是一个编码的JSON对象；它是编码而不是加密的，所以您可以解码它。实际上，我们已经讨论了执行此操作的功能：`atob`。
- en: Stitching everything together, you want to create a method that
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 将一切组合在一起，您想要创建一个方法
- en: Gets the stored token
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取存储的令牌
- en: Extracts the payload from the token
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从令牌中提取有效载荷
- en: Decodes the payload
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解码有效载荷
- en: Validates that the expiry date hasn’t passed
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证过期日期是否已过
- en: This method, added to the `AuthenticationService`, should return `true` if a
    user is logged in and `false` if not. The next listing shows this behavior in
    a method called `isLoggedIn()`.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 将此方法添加到`AuthenticationService`后，如果用户已登录则应返回`true`，如果没有则返回`false`。下一个列表显示了在名为`isLoggedIn()`的方法中的此行为。
- en: Listing 12.8\. `isLoggedIn` method for the authentication service
  id: totrans-456
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.8\. 认证服务的`isLoggedIn`方法
- en: '[PRE52]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '***1* Gets the token from storage**'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从存储中获取令牌**'
- en: '***2* If the token exists, gets the payload, decodes it, and parses it to JSON**'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 如果令牌存在，获取有效载荷，解码它并将其解析为JSON**'
- en: '***3* Validates whether expiry is passed**'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 验证过期是否已过**'
- en: That isn’t much code, but it’s doing a lot. After you’ve referenced it in the
    `return` statement in the service, the application can quickly check whether a
    user is logged in at any point.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码不多，但功能很多。在您在服务中的`return`语句中引用它之后，应用程序可以快速在任何时候检查用户是否已登录。
- en: The next and final method to add to the authentication service gets some user
    information from the JWT.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加到认证服务的下一个和最后一个方法是从JWT中获取一些用户信息。
- en: Getting user information from the JWT
  id: totrans-463
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从JWT中获取用户信息
- en: You want the application to be able to get a user’s email address and name from
    the JWT. You saw in the `isLoggedIn()` method how to extract data from the token,
    and your new method does exactly the same thing.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望应用程序能够从JWT中获取用户的电子邮件地址和姓名。您在`isLoggedIn()`方法中看到了如何从令牌中提取数据，而您的新方法正是做同样的事情。
- en: Create a new method called `getCurrentUser()`. The first thing that this method
    does is validate that a user is logged in by calling the `isLoggedIn()` method.
    If a user is logged in, it gets the token by calling the `getToken()` method before
    extracting and decoding the payload and returning the data you’re after. The following
    listing shows how this looks.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `getCurrentUser()` 的新方法。此方法首先通过调用 `isLoggedIn()` 方法验证用户是否已登录。如果用户已登录，它通过调用
    `getToken()` 方法获取令牌，然后在提取和解码有效负载后返回所需的数据。以下列表显示了其外观。
- en: Listing 12.9\. `getCurrentUser()` method (authentication.service.ts)
  id: totrans-466
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.9\. `getCurrentUser()` 方法（authentication.service.ts）
- en: '[PRE53]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '***1* Returns the type of User**'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 返回用户类型**'
- en: '***2* Ensures that the user is logged in**'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 确保用户已登录**'
- en: '***3* Typecasts object to the User type**'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将对象类型转换为 User 类型**'
- en: With that done, the Angular authentication service is complete. Looking back
    over the code, you can see that it’s generic and easy to copy from one application
    to another. All you’ll probably have to change are the name of the token and the
    API URLs, so you’ve got a nice, reusable Angular service.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，Angular 身份验证服务就完成了。回顾一下代码，您可以看到它是通用的，并且很容易从一个应用程序复制到另一个应用程序。您可能需要更改的只是令牌的名称和
    API 网址，因此您有一个很好的、可重用的 Angular 服务。
- en: Now that the service is in the application, you can use it. Keep moving forward
    by creating the Login and Register pages.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 现在服务已添加到应用程序中，您可以使用它。继续前进，创建登录和注册页面。
- en: 12.2\. Creating the Register and Login pages
  id: totrans-473
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2\. 创建注册和登录页面
- en: Everything you’ve done so far is great, but without a way for visitors to the
    website to register and log in, it would be useless. So that’s what you’ll address
    now.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 您到目前为止所做的一切都很棒，但没有一种方式让网站访客注册和登录，那就毫无用处。所以这就是您现在要解决的问题。
- en: In terms of functionality, you want a Register page where new users can set
    their details and sign up, and a Login page where users return to input their
    username and password. When users have gone through either of these processes
    and are successfully authenticated, the application should send them back to the
    page they were on when they started the process.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 在功能方面，您想要一个注册页面，新用户可以在其中设置他们的详细信息并注册，以及一个登录页面，用户可以在其中输入他们的用户名和密码。当用户完成这两个过程中的任何一个并且成功认证后，应用程序应将他们送回到他们开始过程时的页面。
- en: At the end of the following sections, you’d expect your Register page to look
    a lot like [figure 12.1](#ch12fig01).
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分的末尾，您会期望您的注册页面看起来非常像[图 12.1](#ch12fig01)。
- en: Figure 12.1\. Register page
  id: totrans-477
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.1\. 注册页面
- en: '![](Images/12fig01_alt.jpg)'
  id: totrans-478
  prefs: []
  type: TYPE_IMG
  zh: '![图片 12.1](Images/12fig01_alt.jpg)'
- en: The Login page should look like [figure 12.2](#ch12fig02). You’ll begin with
    the Register page.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 登录页面应类似于[图 12.2](#ch12fig02)。您将从注册页面开始。
- en: Figure 12.2\. Login page
  id: totrans-480
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.2\. 登录页面
- en: '![](Images/12fig02_alt.jpg)'
  id: totrans-481
  prefs: []
  type: TYPE_IMG
  zh: '![图片 12.2](Images/12fig02_alt.jpg)'
- en: 12.2.1\. Building the Register page
  id: totrans-482
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.1\. 构建注册页面
- en: 'To develop a working registration page, you have a few things to do:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开发一个可工作的注册页面，您需要做几件事情：
- en: Create the `register` component and add it to the routing.
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `register` 组件并将其添加到路由中。
- en: Build the template.
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建模板。
- en: Flesh out the component body, including redirection.
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完善组件主体，包括重定向。
- en: And, of course, you’ll want to test the page when you’re done.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您完成之后会想要测试页面。
- en: 'Step 1 is creating the component. Reach for the Angular generator:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 第 1 步是创建组件。使用 Angular 生成器：
- en: '[PRE54]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: With that done, amend the application routing by adding entries to app_routing/app_routing.module.ts.
    Point the `register` component at the /register route, as the next listing shows.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，通过向 app_routing/app_routing.module.ts 中添加条目来修改应用程序路由。如以下列表所示，将 `register`
    组件指向 /register 路由。
- en: Listing 12.10\. Registration routing
  id: totrans-491
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.10\. 注册路由
- en: '[PRE55]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '***1* Imports the newly created register component**'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入新创建的注册组件**'
- en: '***2* Adds the path information**'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 添加路径信息**'
- en: With that done, look at the details of the component template and methods that
    link this template to the services that you built earlier.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，查看组件模板的详细信息以及将此模板链接到您之前构建的服务的方法。
- en: Building the registration template
  id: totrans-496
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 构建注册模板
- en: Okay, now you’ll build the template for the registration page. Aside from the
    normal header and footer, you’ll need a few things. Primarily, you need a form
    to allow visitors to input their name, email address, and password. In this form,
    you should also have an area to display any errors. You’ll also pop in a link
    to the Login page, in case users realize that they’re already registered.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在您将构建注册页面的模板。除了正常的页眉和页脚外，您还需要一些其他东西。主要的是，您需要一个表单，允许访客输入他们的姓名、电子邮件地址和密码。在此表单中，您还应该有一个区域来显示任何错误。您还应该加入一个链接到登录页面，以防用户意识到他们已经注册了。
- en: The next listing shows the template pieced together. Notice that the input fields
    have the credentials in the view model bound to them via `ngModel`.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了拼接在一起的模板。请注意，输入字段通过 `ngModel` 绑定到视图模型中的 `credentials`。
- en: Listing 12.11\. Full template for the registration page (register/register.component.html)
  id: totrans-499
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.11\. 注册页面完整模板（register/register.component.html）
- en: '[PRE56]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '***1* Link to switch to Login page**'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 切换到登录页面的链接**'
- en: '***2* A <div> to display errors**'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 用于显示错误的 <div>**'
- en: '***3* Input for username**'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 用户名输入**'
- en: '***4* Input for email address**'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 电子邮件地址输入**'
- en: '***5* Input for password**'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 密码输入**'
- en: Again, the important thing to note is that a user’s name, email, and password
    are bound to the view model in the object `credentials`.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，需要注意的是，用户的姓名、电子邮件和密码绑定在对象 `credentials` 中的视图模型中。
- en: Next, you look at the flip side and code the component methods.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您查看另一面并编写组件方法。
- en: Creating the registration component skeleton
  id: totrans-508
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建注册组件骨架
- en: Based on the template, you’ll set up a few things in the register component.
    You’ll need the title text for the page header and an `onRegisterSubmit()` function
    to handle form submission. You’ll also give all the `credentials` properties a
    default empty string value.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 根据模板，您将在注册组件中设置一些事情。您需要页面标题的文本以及一个 `onRegisterSubmit()` 函数来处理表单提交。您还将为所有 `credentials`
    属性提供一个默认空字符串值。
- en: The next listing shows the initial setup.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了初始设置。
- en: Listing 12.12\. Starting the `register` component
  id: totrans-511
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.12\. 开始 `register` 组件
- en: '[PRE57]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '***1* Imports the services required from the Router**'
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从 Router 中导入所需的服务**'
- en: '***2* Imports the authentication service**'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 导入认证服务**'
- en: '***3* Error string initialization**'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 错误字符串初始化**'
- en: '***4* credentials object to hold model data**'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 保存模型数据的 `credentials` 对象**'
- en: '***5* Page content object for the usual page data**'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 页面内容对象，用于常规页面数据**'
- en: There’s nothing new here—a couple of public properties to manage the component’s
    internal data and injection of the services that you’ll need to use in the component.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有新的内容——几个公共属性来管理组件的内部数据，以及注入您在组件中需要使用的服务。
- en: Add the contents of the next listing to the component that you’ve created.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 将下一个列表的内容添加到您创建的组件中。
- en: Listing 12.13\. Registration submission handler
  id: totrans-520
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.13\. 注册提交处理程序
- en: '[PRE58]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '***1* Submits an event handler**'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 提交事件处理程序**'
- en: '***2* Checks that you’ve received all the relevant information**'
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 检查您是否已收到所有相关信息**'
- en: '***3* Returns messaging in case of an error**'
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 发生错误时返回消息**'
- en: '***4* Performs the registration**'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 执行注册**'
- en: With this code in place, you can try out the Register page and functionality
    by starting the application running and heading to http://localhost:4200/register.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码到位后，您可以通过启动应用程序并转到 http://localhost:4200/register 来尝试注册页面和功能。
- en: When you’ve done this and successfully registered as a user, open the browser
    development tools, and look for the resources. As illustrated in [figure 12.3](#ch12fig03),
    you should see a `loc8r-token` below the local storage folder.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 当您完成此操作并成功注册为用户后，打开浏览器开发工具，查找资源。如图 12.3 所示，您应该在本地存储文件夹下方看到 `loc8r-token`。
- en: Figure 12.3\. Finding the `loc8r-token` in the browser
  id: totrans-528
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.3\. 在浏览器中找到 `loc8r-token`
- en: '![](Images/12fig03_alt.jpg)'
  id: totrans-529
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/12fig03_alt.jpg)'
- en: You’ve added the ability for a new user to register. Next, you’ll enable a returning
    user to log in.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 您已添加了新用户注册的功能。接下来，您将启用返回用户登录。
- en: 12.2.2\. Building the Login page
  id: totrans-531
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.2\. 构建 登录 页面
- en: The approach to the Login page is similar to the approach to the Register page.
    Nothing here should be unfamiliar, so you’ll go through it quickly.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 登录页面的方法与注册页面的方法类似。这里不应该有任何不熟悉的内容，所以您会快速浏览。
- en: 'First, generate the new component:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，生成新的组件：
- en: '[PRE59]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Add the following to the routes object in the router (app-routing/app-routing.module.ts):'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到路由对象中（app-routing/app-routing.module.ts）：
- en: '[PRE60]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'With this code in place, you can build up the component template file: login/login-component.html.
    You can see from the route where you want this file to be. It’s similar to the
    `register` template, so it’s probably easiest to duplicate and edit that template.
    All you need to do is remove the name input and change a couple of pieces of text.
    The following listing highlights in bold the changes you need to make in the `login`
    template.'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码到位后，你可以构建组件模板文件：login/login-component.html。你可以从路由中看到你希望此文件所在的位置。它与 `register`
    模板类似，所以复制并编辑该模板可能最容易。你只需要删除名称输入框并更改一些文本。以下列表以粗体突出显示你需要在 `login` 模板中进行的更改。
- en: Listing 12.14\. Changes for the `login template`
  id: totrans-538
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.14\. 对 `login 模板` 的更改
- en: '[PRE61]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '***1* Changes the link to register**'
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 更改注册链接**'
- en: '***2* Updates the submit event function call**'
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 更新提交事件函数调用**'
- en: '***3* Note that the name input is removed.**'
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 注意已移除名称输入框。**'
- en: '***4* Changes the text on the button**'
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 更改按钮上的文本**'
- en: 'Finally, you make changes in the `login` component, which is similar to the
    `register` component. The changes you need to make are these:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将对 `login` 组件进行更改，这与 `register` 组件类似。你需要做的更改如下：
- en: Change the name of the component controller.
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改组件控制器的名称。
- en: Change the page title.
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改页面标题。
- en: Remove references to the name field.
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除对名称字段的引用。
- en: Rename `doRegisterSubmit()` to `doLoginSubmit`(), and `doRegister` to `doLogin`.
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `doRegisterSubmit()` 重命名为 `doLoginSubmit()`，并将 `doRegister` 更改为 `doLogin`。
- en: Call the `login()` method of the `AuthenticationService` instead of the `register()`
    method.
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `AuthenticationService` 的 `login()` 方法而不是 `register()` 方法。
- en: Copy the main body of the component class code from register/register-component.ts,
    and make the following changes. The next listing shows the content of the file
    and highlights the changes in bold.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 将组件类代码的主体从 register/register-component.ts 复制过来，并做出以下更改。下一个列表显示了文件内容，并以粗体突出显示更改。
- en: Listing 12.15\. Changes required for the `login` component
  id: totrans-551
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.15\. 对 `login` 组件所需的更改
- en: '[PRE62]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '***1* Updates the component definition block**'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 更新组件定义块**'
- en: '***2* Changes the component name**'
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 更改组件名称**'
- en: '***3* Changes the page title**'
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 更改页面标题**'
- en: '***4* Changes the submit event method**'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 更改提交事件方法**'
- en: '***5* Changes the doRegister method to doLogin and updates the authentication
    service call**'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将 doRegister 方法更改为 doLogin 并更新身份验证服务调用**'
- en: That was easy! There’s no need to dwell on this component as, functionally,
    it works like the register controller.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单！不需要在这个组件上过多停留，因为从功能上讲，它的工作方式与注册控制器相同。
- en: Now you’ll move to the final stage and use the authenticated session in the
    Angular application.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将进入最终阶段，并在 Angular 应用中使用已验证的会话。
- en: 12.3\. Working with authentication in the Angular app
  id: totrans-560
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3\. 在 Angular 应用中处理身份验证
- en: 'When you have a way to authenticate users, the next step is making use of that
    information. In Loc8r, you’ll do two things:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有验证用户的方法时，下一步是利用这些信息。在 Loc8r 中，你会做两件事：
- en: Change the navigation based on whether the visitor is logged in.
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据访客是否登录更改导航。
- en: Use the user information when creating reviews.
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建评论时使用用户信息。
- en: You’ll tackle the navigation first.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 你将首先处理导航。
- en: 12.3.1\. Updating the navigation
  id: totrans-565
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.3.1\. 更新导航
- en: 'One thing that’s currently missing from the navigation is a Sign-in link, so
    you’ll add one in the conventional place: the top-right corner of the screen.
    But when a user is logged in, you don’t want to display a sign-in message; it
    would be better to display the user’s name and give them an option to sign out.'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 当前导航中缺少一个登录链接，因此你将在传统位置添加一个：屏幕的右上角。但是，当用户登录时，你不想显示登录消息；更好的做法是显示用户的姓名，并给他们提供一个注销选项。
- en: That’s what you’ll do in this section, starting by adding a right-side section
    to the navigation bar.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你将在本节中要做的事情，首先向导航栏添加一个右侧部分。
- en: 12.3.2\. Adding a right-side section to the navigation
  id: totrans-568
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.3.2\. 向导航添加右侧部分
- en: The navigation for Loc8r is set up in the framework component that acts as a
    layout for every page. You may remember from [chapter 9](kindle_split_021.xhtml#ch09)
    that this is the root component that defines the router outlet; the files are
    in app_public/src/app/framework. The following listing highlights in bold the
    markup you need to add to the template (framework.component.html) to put a Sign-in
    link on the right side.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: Loc8r 的导航是在框架组件中设置的，该组件充当每个页面的布局。你可能记得从第 9 章 [chapter 9](kindle_split_021.xhtml#ch09)
    中，这是定义路由出口的根组件；文件位于 app_public/src/app/framework。以下列表以粗体突出显示需要添加到模板（framework.component.html）中以在右侧放置登录链接的标记。
- en: Listing 12.16\. Changes for the framework component
  id: totrans-570
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.16\. 框架组件的更改
- en: '[PRE63]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '***1* Adds a navbar to the header, and pushes it to the right**'
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在页眉中添加一个导航栏，并将其推到右侧**'
- en: '***2* The Sign-in link**'
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 登录链接**'
- en: '***3* Area for the username when logged in**'
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 登录时用户名区域**'
- en: '***4* Link for logging out**'
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 注销链接**'
- en: The `login nav` option navigates to the freshly minted `login` component you’ve
    built.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '`login nav` 选项导航到您刚刚构建的 `login` 组件。'
- en: Currently, however, an added link in the drop-down menu doesn’t work, and the
    Logout link needs to be fleshed out.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，目前下拉菜单中添加的链接不起作用，注销链接需要进一步完善。
- en: 'To make this link work, you need to inject the `Authentication` service into
    the `Framework` component. You also need to add three methods:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 要使此链接工作，你需要将 `Authentication` 服务注入到 `Framework` 组件中。你还需要添加三个方法：
- en: A click event to trigger the logout (`doLogout()`)
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发注销（`doLogout()`）的点击事件
- en: A method to check the current user login status
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查当前用户登录状态的方法
- en: A method to get the current user name
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取当前用户名的方法
- en: The following listing shows how this is done.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了如何完成此操作。
- en: Listing 12.17\. Changes to `Framework` for logout
  id: totrans-583
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.17\. 对 `Framework` 进行注销更改
- en: '[PRE64]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '***1* Imports the authentication service**'
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入认证服务**'
- en: '***2* Imports the User class for type checking**'
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 导入 User 类进行类型检查**'
- en: '***3* Injects the imported service**'
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 注入导入的服务**'
- en: '***4* doLogout wrapper for the authentication service logout method**'
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 认证服务注销方法的 doLogout 包装器**'
- en: '***5* isLoggedIn wrapper**'
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* isLoggedIn 包装器**'
- en: '***6* getUsername wrapper**'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 获取用户名包装器**'
- en: When these functions are in place, you’ll add them to the framework HTML template.
    You need to add an `*ngIf` to toggle the display of the username drop-down menu,
    depending on the result of `isLoggedIn()`. When `isLoggedIn()` returns `true`,
    you’ll want to show the user’s name in the HTML. Finally, you need to hook in
    the `doLogout()` function to the click event for the Logout link.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些功能就绪时，你将它们添加到框架 HTML 模板中。你需要添加一个 `*ngIf` 来根据 `isLoggedIn()` 的结果切换用户名下拉菜单的显示。当
    `isLoggedIn()` 返回 `true` 时，你希望在 HTML 中显示用户的姓名。最后，你需要将 `doLogout()` 函数连接到注销链接的点击事件。
- en: Listing 12.18\. Changes to the framework component template
  id: totrans-592
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.18\. 框架组件模板的更改
- en: '[PRE65]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '***1* Doesn’t show if logged in**'
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 登录时不显示**'
- en: '***2* Shows if logged in**'
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 登录时显示**'
- en: '***3* Shows username if available**'
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果可用则显示用户名**'
- en: With the logout functionality in place, now is a good time to consider a user-experience
    issue. Currently, the `login` and `register` components redirect the user to the
    homepage on a successful response, which is not a great experience for the user.
    What you’ll do is return the user back to the page that they were on before logging
    in or registering.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 由于已经实现了注销功能，现在是考虑用户体验问题的好时机。目前，`login` 和 `register` 组件在成功响应时将用户重定向到主页，这对用户来说并不是一个好的体验。你要做的是将用户返回到他们登录或注册之前所在的页面。
- en: 'To do this, create a service that takes advantage of the Angular router `events`
    property. The events property keeps a record of the routing events that occur
    while the user navigates the application. To start, generate a service called
    `history`:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，创建一个利用 Angular 路由 `events` 属性的服务。`events` 属性记录了用户在导航应用程序时发生的路由事件。首先，生成一个名为
    `history` 的服务：
- en: '[PRE66]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Add this new service to the framework component so that the reference is in
    place before you fill in body of the `history` service.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 将此新服务添加到框架组件中，以便在填充 `history` 服务的主体之前设置好引用。
- en: Listing 12.19\. Adding a history service to the framework component
  id: totrans-601
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.19\. 将历史服务添加到框架组件
- en: '[PRE67]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '***1* Imports the service**'
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入服务**'
- en: '***2* Injects it into the component**'
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将其注入到组件中**'
- en: 'With this code in place, fill in the logic for the `HistoryService`. You need
    to do several things to track a user’s navigation history:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码到位后，填写 `HistoryService` 的逻辑。您需要做几件事情来跟踪用户的导航历史：
- en: Import the Angular `Router` module.
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入 Angular `Router` 模块。
- en: Subscribe to the `events` property to track each navigation event.
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅到 `events` 属性以跟踪每个导航事件。
- en: Create a public method to get access to the navigation history.
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个公共方法以获取对导航历史的访问权限。
- en: The next listing shows this in action.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了这一操作。
- en: Listing 12.20\. Adding a history service
  id: totrans-610
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.20\. 添加历史服务
- en: '[PRE68]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '***1* Imports the Router and NavigationEnd classes**'
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入 Router 和 NavigationEnd 类**'
- en: '***2* Brings in the filter from rxjs**'
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 引入来自 rxjs 的 filter**'
- en: '***3* The events property subscription**'
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 事件属性订阅**'
- en: The functionality in the constructor function as given in [listing 12.20](#ch12ex20)
    probably needs a closer look. The router `events` property returns an Observable
    that emits several event types, but you’re interested only in the `NavigationEnd`
    event, which you imported from the `@angular/router`.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 12.20](#ch12ex20) 中给出的构造函数功能可能需要更仔细地查看。路由器的 `events` 属性返回一个 Observable，它发出多个事件类型，但您只对从
    `@angular/router` 导入的 `NavigationEnd` 事件感兴趣。
- en: To get these event types from the Observable (events stream), you need to filter
    them out, which is where the RxJS `filter` function comes into play. This function
    is piped to your events stream via the Observable `pipe` method. As we’re not
    covering RxJS in this book, we recommend *RxJS in Action* ([https://www.manning.com/books/rxjs-in-action](https://www.manning.com/books/rxjs-in-action))
    for further detail.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 要从可观察对象（事件流）获取这些事件类型，您需要过滤它们，这正是 RxJS `filter` 函数发挥作用的地方。此函数通过可观察对象的 `pipe`
    方法连接到您的事件流。由于本书不涉及 RxJS，我们建议阅读 *RxJS in Action* ([https://www.manning.com/books/rxjs-in-action](https://www.manning.com/books/rxjs-in-action))
    以获取更多详细信息。
- en: The events of this pipe after you `subscribe` to them are of type `NavigationEnd`,
    which is exactly what you need. `NavigationEnd` events have a `urlAfterRedirects`
    property, which is a string that you can push to your array of `urls` that you
    hold in your `HistoryService`.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 在您 `subscribe` 到这些事件后，该管道的事件类型为 `NavigationEnd`，这正是您所需要的。`NavigationEnd` 事件有一个
    `urlAfterRedirects` 属性，这是一个字符串，您可以将其推送到您在 `HistoryService` 中持有的 `urls` 数组。
- en: Last, you need to add a method that returns the previous URL from the collected
    URL history. Add the following method to the `HistoryService`.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要添加一个方法，该方法可以从收集到的 URL 历史中返回上一个 URL。将以下方法添加到 `HistoryService`。
- en: Listing 12.21\. `getPreviousUrl` function
  id: totrans-619
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.21\. `getPreviousUrl` 函数
- en: '[PRE69]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '***1* Returns the default location if there’s no other entry**'
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 返回默认位置，如果没有其他条目**'
- en: Now that you have a history service that keeps track of where the user was before
    login or registration, implement it as part of your `login` and `register` components.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有了跟踪用户在登录或注册之前位置的历史服务，将其作为 `login` 和 `register` 组件的一部分实现。
- en: You’ll add this to the `register` component as shown in the next listing and
    change the `login` component later as an exercise to be completed, as the operation
    is identical. The solution is available on GitHub.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 您将按照下一个列表所示将其添加到 `register` 组件中，并在稍后作为练习更改 `login` 组件，因为操作是相同的。解决方案可在 GitHub
    上找到。
- en: Listing 12.22\. Changes required in the register component
  id: totrans-624
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.22\. 在注册组件中需要更改的内容
- en: '[PRE70]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '***1* Imports the history service**'
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入历史服务**'
- en: '***2* Injects the history service into constructor**'
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在构造函数中注入历史服务**'
- en: '***3* Uses the provided getPreviousUrl function to redirect, using the router**'
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用提供的 getPreviousUrl 函数通过路由器进行重定向**'
- en: After completing this change, and maybe through a little testing, you may have
    noticed that the page that the `register` component returns you to is the Login
    page—not what you’re looking for. After registering, as a user you’d like to be
    returned to the page before Login, because that’s where you entered the login/registration
    loop. From a user perspective, it’s not a great experience.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此更改后，可能通过一些测试，您可能会注意到 `register` 组件返回您的页面是登录页面——这不是您想要的。在注册后，作为用户，您希望返回到登录之前的页面，因为那是您进入登录/注册循环的地方。从用户的角度来看，这不是一个好的体验。
- en: To avoid this experience, add a new method to the `history` service that returns
    the last URL encountered before either `login` or `register`. This way, it doesn’t
    matter whether the user travels between these two pages several times before performing
    the desired action.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种体验，向 `history` 服务添加一个新方法，该方法返回在执行所需操作之前遇到的最后一个 URL。这样，用户在执行操作之前在这两个页面之间多次往返都没有关系。
- en: You’ll achieve this by using a filter across the list of URLs already navigated,
    removing all the URLs that match in the exclusions list. Then, pick the last one,
    safe in the knowledge that you’ve removed all the register and login items.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过在已导航的 URL 列表中使用过滤器来实现这一点，移除所有与排除列表中匹配的 URL。然后选择最后一个，放心地知道你已经移除了所有注册和登录项。
- en: Listing 12.23\. `getLastNonLoginUrl()`
  id: totrans-632
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.23\. `getLastNonLoginUrl()`
- en: '[PRE71]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '***1* List of strings that you need to exclude**'
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 需要排除的字符串列表**'
- en: '***2* Filters the collected list of URLs, and returns only those not in exclude**'
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 过滤收集到的 URL 列表，并仅返回不在排除列表中的那些**'
- en: '***3* Returns the last element of the filtered array or a default value**'
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 返回过滤后的数组的最后一个元素或默认值**'
- en: Add this code the `history` service, and change the function `doLogin()` in
    login.component.ts and `doRegister()` in register.component.ts to use it instead,
    as shown in the following listing (from register.component.ts).
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码添加到`history`服务中，并将`login.component.ts`中的`doLogin()`函数和`register.component.ts`中的`doRegister()`函数更改为使用它，如下所示（来自register.component.ts）。
- en: Listing 12.24\. Updating the `doRegister` function
  id: totrans-638
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.24\. 更新 `doRegister` 函数
- en: '[PRE72]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '***1* Changes getPreviousUrl() to getLastNonLoginUrl()**'
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 getPreviousUrl() 更改为 getLastNonLoginUrl()**'
- en: Now you can reap the benefits of being logged in. You’ll inject the `authentication`
    service into location-details.component.ts so you can check to see whether a user
    is logged in and present functionality accordingly.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以享受登录的好处。你将向 location-details.component.ts 注入 `authentication` 服务，以便检查用户是否已登录并相应地提供功能。
- en: 'You’re going to do a couple of things:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要进行几件事情：
- en: Inject the authentication service into the component to check the user’s login
    state.
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将身份验证服务注入到组件中，以检查用户的登录状态。
- en: Modify the component to take advantage of the logged-in state.
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改组件以利用登录状态。
- en: First, do the necessary importing of the `AuthenticationService`, and then inject
    into the component `constructor`.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，导入必要的`AuthenticationService`，然后将其注入到组件的`constructor`中。
- en: Listing 12.25\. location-details.component.ts changes
  id: totrans-646
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.25\. location-details.component.ts 的更改
- en: '[PRE73]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '***1* Imports the AuthenticationService**'
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入 AuthenticationService**'
- en: '***2* Injects the AuthenticationService into the component**'
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将 AuthenticationService 注入到组件中**'
- en: Next, add some methods that make use of the functionality provided by the `AuthenticationService`.
    Add the two methods in [listing 12.26](#ch12ex26) to the `location-details` component.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加一些利用 `AuthenticationService` 提供的功能的方法。将 [列表 12.26](#ch12ex26) 中的两个方法添加到
    `location-details` 组件中。
- en: Listing 12.26\. Methods to add to location-details.component.ts
  id: totrans-651
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.26\. 需要添加到 location-details.component.ts 的方法
- en: '[PRE74]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '***1* Wrapper function for isLoggedIn from AuthenticationService**'
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从 AuthenticationService 获取 isLoggedIn 的包装函数**'
- en: '***2* Wrapper function for getCurrentUser from AuthenticationService**'
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从 AuthenticationService 获取 getCurrentUser 的包装函数**'
- en: '***3* If name isn’t available, returns Guest**'
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果名称不可用，则返回Guest**'
- en: To complete this part of the exercise, you need to update the template by
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个练习的部分，你需要通过更新模板来实现。
- en: Ensuring that the user is authenticated to leave a review
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保用户已验证才能留下评论
- en: Removing the need to enter the author name when writing a review
  id: totrans-658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在撰写评论时，无需输入作者名称
- en: Providing the username as the author from the authentication service when submitting
    a review and preventing validation from failing
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在提交评论时，从身份验证服务提供用户名作为作者，并防止验证失败
- en: First, change the template so that, in the logged-out state, you present a button
    inviting the user to log in to post a review. When the user is logged in, the
    page presents a button to allow them to add a review.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，更改模板，以便在注销状态下，显示一个按钮邀请用户登录以发布评论。当用户登录时，页面显示一个按钮，允许他们添加评论。
- en: Change the `location-details` template (location-details.component.html) as
    shown next.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下所示更改`location-details`模板（location-details.component.html）。
- en: Listing 12.27\. Changes to location-details.component.html
  id: totrans-662
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.27\. location-details.component.html 的更改
- en: '[PRE75]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '***1* ngSwitch around the logged-in status**'
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* ngSwitch 绕过登录状态**'
- en: '***2* Shows whether user is logged in**'
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 显示用户是否已登录**'
- en: '***3* Default state**'
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 默认状态**'
- en: The `ngSwitch` directive checks whether the user is logged in and displays the
    appropriate call to action. Both states are shown in [figure 12.4](#ch12fig04).
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngSwitch` 指令检查用户是否已登录，并显示相应的行动号召。两种状态都在 [图 12.4](#ch12fig04) 中展示。'
- en: Figure 12.4\. The two states of the Add Review button, depending on whether
    the user is logged in
  id: totrans-668
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.4\. 根据用户是否登录，添加评论按钮的两种状态
- en: '![](Images/12fig04_alt.jpg)'
  id: totrans-669
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/12fig04_alt.jpg)'
- en: Now that a user needs to be logged in to post a review, you no longer need users
    to enter their names in the review form, as this data can now be retrieved from
    the JWT. As a result, you need to delete code from the location-details.component.html
    template. See the following listing for the elements to remove.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户需要登录才能发表评论，因此不再需要用户在评论表单中输入他们的名字，因为现在可以从 JWT 中检索此数据。因此，您需要从 location-details.component.html
    模板中删除代码。请参阅以下列表以了解要删除的元素。
- en: Listing 12.28\. Code to remove from location-details.component.html
  id: totrans-671
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.28\. 从 location-details.component.html 中删除的代码
- en: '[PRE76]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Without the form field, you need to pull the author name from the `getUsername()`
    function that you conveniently created earlier. [Listing 12.29](#ch12ex29) highlights
    in bold the pieces to be changed in `onReviewSubmit()` in `location-details.component.ts`.
    [Figure 12.5](#ch12fig05) shows the final review form.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 没有表单字段时，您需要从您之前方便创建的 `getUsername()` 函数中提取作者名称。[列表 12.29](#ch12ex29) 以粗体突出显示
    `location-details.component.ts` 中的 `onReviewSubmit()` 需要更改的部分。[图 12.5](#ch12fig05)
    展示了最终的审查表单。
- en: Figure 12.5\. The final review form without a name field
  id: totrans-674
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.5\. 没有姓名字段的最终审查表单
- en: '![](Images/12fig05_alt.jpg)'
  id: totrans-675
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/12fig05_alt.jpg)'
- en: Listing 12.29\. Removing name validation from location-details.component.ts
  id: totrans-676
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.29\. 从 location-details.component.ts 中删除姓名验证
- en: '[PRE77]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '***1* Gets the username from the component**'
  id: totrans-678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从组件中获取用户名**'
- en: If you try this now, you still encounter a problem. If you check the web browser’s
    development console, you’ll see that the API returns a 401 Unauthorized response,
    because you haven’t updated the review submission API call with the JWT to allow
    the API to accept the request.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在尝试这样做，您仍然会遇到问题。如果您检查网络浏览器的开发控制台，您会看到 API 返回了 401 未授权的响应，因为您还没有更新评论提交 API
    调用以允许 API 接受请求。
- en: To make this work, you need to get access to the JWT stored in `localStorage`
    and pass it forward as a `Bearer` token in the `Authorization` request header.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这起作用，您需要获取存储在 `localStorage` 中的 JWT 访问权限，并将其作为 `Bearer` 令牌传递给 `Authorization`
    请求标头。
- en: Listing 12.30\. Adding `AuthenticationService` to loc8r-data.service.ts
  id: totrans-681
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.30\. 将 `AuthenticationService` 添加到 loc8r-data.service.ts
- en: '[PRE78]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '***1* Imports the AuthenticationService**'
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入 AuthenticationService**'
- en: '***2* Injects the imported service into the component**'
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将导入的服务注入到组件中**'
- en: Finally, you need to update the `addReviewByLocationId()` function to include
    the `Authorization` header in submissions to the API. The following listing shows
    the changes.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要更新 `addReviewByLocationId()` 函数，以便在提交到 API 的请求中包含 `Authorization` 标头。以下列表显示了更改。
- en: Listing 12.31\. Adding `Authorization` headers to API call
  id: totrans-686
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.31\. 向 API 调用添加 `Authorization` 标头
- en: '[PRE79]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '***1* Creates an httpOptions object for HttpHeaders**'
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个用于 HttpHeaders 的 httpOptions 对象**'
- en: '***2* String Template used here**'
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 这里使用的是字符串模板**'
- en: '***3* Adds httpOptions to the API call**'
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 向 API 调用添加 httpOptions**'
- en: With that update, you’ve completed the authentication section. Users must be
    logged in to add a review, and through the authentication system, the review will
    be given the correct username.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这次更新，您已经完成了身份验证部分。用户必须登录才能添加评论，并且通过身份验证系统，评论将被赋予正确的用户名。
- en: This brings you to the end of the book. By now, you should have a good idea
    of the power and capabilities of the MEAN stack and be empowered to start building
    some cool stuff!
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了本书的内容。到现在为止，您应该对 MEAN 堆栈的强大功能和能力有了很好的了解，并能够开始构建一些酷炫的东西！
- en: You have a platform to build REST APIs, server-side web applications, and browser-based
    single-page applications. You can create database-driven sites, APIs, and applications,
    and then publish them to a live URL.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 您拥有构建 REST API、服务器端 Web 应用程序和基于浏览器的单页应用程序的平台。您可以创建数据库驱动的网站、API 和应用程序，然后将它们发布到实时
    URL。
- en: When starting your next project, remember to take a little time to think about
    the best architecture and user experience. Spend a little time planning to make
    your development time more productive and enjoyable. And never be afraid to refactor
    and improve your code and application as you go.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 当开始你的下一个项目时，记得花点时间思考最佳架构和用户体验。花点时间规划，让你的开发时间更加高效和愉快。并且永远不要害怕在开发过程中重构和改进你的代码和应用程序。
- en: You’ve only scratched the surface of what these amazing technologies can offer.
    So please dive in, build things, try stuff, keep learning, and (most important)
    have fun!
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 你只是触及了这些令人惊叹的技术所能提供的表面。所以请深入探索，构建事物，尝试新事物，持续学习，并且（最重要的是）享受乐趣！
- en: Summary
  id: totrans-696
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了
- en: How to use local storage to manage a user session in the browser
  id: totrans-698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用本地存储在浏览器中管理用户会话
- en: How to use JWT data inside Angular
  id: totrans-699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Angular 中使用 JWT 数据
- en: How to pass a JWT from Angular to an API via HTTP headers
  id: totrans-700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过 HTTP 头部从 Angular 传递 JWT 到 API
