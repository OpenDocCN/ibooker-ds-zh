- en: 19 Data standardization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 19 数据标准化
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Methods of data standardization
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据标准化方法
- en: Z-score method
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Z分数法
- en: Standard deviation method
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准差法
- en: Centering method
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中心化方法
- en: Range method
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围法
- en: Coloring data frames and highlighting observations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为数据框着色并突出观察结果
- en: Comparing data sets
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较数据集
- en: It’s not often that an NBA player scores 50 or more points in a game. In fact,
    during the 2021-22 regular season (1,230 games), it happened only 12 times. The
    top five scorers in NBA history—Lebron James (still playing), Kareem Abdul-Jabbar,
    Karl Malone, Kobe Bryant, and Michael Jordan—scored at least 50 points in a regular
    season game 73 times over a grand total of 93 seasons between them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在一场NBA比赛中，球员得到50分或以上的情况并不常见。实际上，在2021-22赛季的常规赛（1,230场比赛）中，这种情况只发生了12次。NBA历史上得分最高的五位球员——仍在比赛的勒布朗·詹姆斯、卡里姆·阿卜杜尔-贾巴尔、卡尔·马龙、科比·布莱恩特和迈克尔·乔丹——在他们总共93个赛季中，至少在常规赛比赛中得到50分的有73次。
- en: But during the 1961-62 season, Wilt Chamberlain, then playing for the Philadelphia
    Warriors, *averaged* 50 points per game; he then averaged almost 45 points per
    game the very next year. No player has since come close to matching these figures.
    Sixty years later, we remain amazed at Chamberlain’s scoring prowess. However,
    many of us of have ignored the fact that rule changes and style of play transformations
    have frequently changed the pace of play. During the 1961-62 season, teams attempted
    roughly 110 shots, or field goals, per game and about 25 free throws per game;
    when Neil Johnston led the NBA in scoring during the 1952-53 season, averaging
    “just” 22.3 points per game, teams then attempted only 70 shots and 20 free throws
    per game. Nowadays, teams take about 85 shots every game and attempt about 20
    free throws. More shot attempts equals more scoring; fewer shot attempts equals
    less scoring.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 但在1961-62赛季，当时为费城勇士队效力的威尔特·张伯伦平均每场比赛得到50分；然后他在下一年平均每场比赛得到近45分。自那以后，没有球员接近这些数据。六十年后，我们仍然对张伯伦的得分能力感到惊讶。然而，许多人忽略了规则变化和比赛风格转变经常改变比赛节奏的事实。在1961-62赛季，球队每场比赛尝试大约110次投篮，即投篮，以及每场比赛大约25次罚球；当尼尔·约翰斯顿在1952-53赛季带领NBA得分时，平均“只有”每场比赛22.3分，当时球队每场比赛只尝试70次投篮和20次罚球。如今，球队每场比赛尝试大约85次投篮，并尝试大约20次罚球。更多的投篮尝试意味着更多的得分；更少的投篮尝试意味着更少的得分。
- en: You’ve probably figured out, then, that the difference between Chamberlain’s
    scoring average in 1961-62 and Johnston’s scoring average in 1952-53 might actually
    be less significant than the raw data might otherwise suggest. We sometimes standardize
    data—that is, we convert a variable from its raw format to a simple and uniform
    scale—to control for epochal changes, seasonal effects, and other external factors.
    Take gasoline prices, for instance; it’s neither fair nor accurate to outright
    compare today’s cost for a gallon of gas to, let’s say, the 1980 cost for the
    same without adjusting for inflation. As another example, consider a collections
    agent; it wouldn’t be fair to evaluate an agent’s performance in, let’s say, November
    or December, when many customers are unwilling or unable to cure their debt, versus
    March or April, when many delinquent customers are in receipt of their tax returns
    and so have disposable income.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经意识到，那么，查默林1961-62赛季的得分平均数与约翰斯顿1952-53赛季的得分平均数之间的差异实际上可能比原始数据所暗示的要小。我们有时会标准化数据——也就是说，我们将一个变量从其原始格式转换为简单和统一的尺度——以控制时代变化、季节性影响和其他外部因素。以汽油价格为例；如果不考虑通货膨胀，直接比较今天一加仑汽油的成本与1980年相同汽油的成本，既不公平也不准确。作为另一个例子，考虑一个收款代理；在许多客户不愿意或无法偿还债务的11月或12月评估代理的表现，与许多拖欠客户收到退税并因此有可支配收入的3月或4月相比，这显然是不公平的。
- en: Our purpose here is to demonstrate different standardization techniques on an
    NBA data set containing annual scoring leaders and then visualize the results
    against the raw data. By converting points per game from its raw format to its
    standardized equivalents, we eliminate the influence of rule changes, style of
    play transformations, and other external factors that, over the course of many
    generations, affect basic statistics. Depending on the method, our presumption
    is that we’re likely to see results that are very different from what has been
    reported over many decades.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里的目的在于演示在包含年度得分王的NBA数据集上使用不同的标准化技术，并针对原始数据可视化结果。通过将每场比赛得分从其原始格式转换为标准等价物，我们消除了规则变化、比赛风格转变和其他外部因素的影响，这些因素在许多代人的过程中影响了基本统计数据。根据方法的不同，我们假设我们可能会看到与过去几十年报道的非常不同的结果。
- en: Let’s go back to our collections agent and briefly discuss why standardization
    is so important to understand and appreciate. The raw performance numbers during
    the holidays compared to March and April from the same year might put the agent
    on corrective action. But the standardized performance numbers might otherwise
    show that the agent’s collections effectiveness is entirely consistent with seasonal
    ebbs and flows. Standardizing data might not only provide a fresh perspective
    but also enable best actions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的收集代理，简要讨论为什么标准化如此重要，需要理解和欣赏。与同年3月和4月相比，节假日期间的原始业绩数字可能会让代理采取纠正措施。但标准化的业绩数字可能否则会显示代理的收集效率完全符合季节性的起伏。标准化数据不仅可能提供新的视角，还可能使最佳行动成为可能。
- en: We’ll start by loading the only package we’ll need.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先加载我们需要的唯一包。
- en: 19.1 Loading a package
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.1 加载一个包
- en: 'We’ll load data with `readr`, wrangle and fetch data with `dplyr` functions
    only, and visualize the same exclusively with `ggplot2` functions; therefore,
    the `tidyverse` universe of packages will suffice:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`readr`来加载数据，使用`dplyr`函数来整理和获取数据，并仅使用`ggplot2`函数来可视化；因此，`tidyverse`包的宇宙将足够使用：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Otherwise, the remainder of our heavy lifting will be through a series of simple
    arithmetic operations to standardize our data. Next, we’ll import our data set
    and briefly explore its contents.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们剩余的繁重工作将通过一系列简单的算术运算来标准化我们的数据。接下来，我们将导入我们的数据集并简要探索其内容。
- en: 19.2 Importing and viewing data
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.2 导入和查看数据
- en: Our data set is a .csv file downloaded from Kaggle that contains scraped data
    from [www.basketball-reference.com](https://www.basketball-reference.com/); it
    specifically contains player statistics, including games played and total points
    scored, for every NBA season between 1949-50 and 2016-17\. Soon enough, we’ll
    trim the data so that the 1998-99 is the maximum season—thereby leaving us with
    50 seasons of data, still quite sufficient for our purposes. It has since been
    saved in our default working directory as season_stats.csv.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据集是一个从Kaggle下载的.csv文件，其中包含从[www.basketball-reference.com](https://www.basketball-reference.com/)抓取的数据；它具体包含了球员统计数据，包括比赛场次和总得分，涵盖了1949-50赛季至2016-17赛季的每一届NBA赛季。不久之后，我们将对数据进行裁剪，使得1998-99赛季成为最大赛季——因此我们留下了50个赛季的数据，对于我们的目的来说仍然相当充足。它已经被保存在我们的默认工作目录中，文件名为season_stats.csv。
- en: 'We make a call to the `readr read_csv()` function to import season_stats.csv
    and in the process create a data set called dat1:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`readr read_csv()`函数来导入season_stats.csv文件，并在过程中创建一个名为dat1的数据集：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we call the base R `dim()` function to return the dat1 dimension:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用基础R的`dim()`函数来返回dat1的维度：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Our data set contains 24,624 rows and 53 columns.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据集包含24,624行和53列。
- en: 'Going forward, we only need six of the 53 dat1 variables; therefore, we next
    call the `select()` function from the `dplyr` package to subset dat1 on these
    six variables. In addition, due to space considerations more than anything else,
    we’ll confine our analysis to the first 50 seasons where we have data. We then
    call the `dplyr filter()` function to subset dat1 where the variable `Year`, now
    numeric, is less than or equal to `1999`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们只需要dat1中的53个变量中的6个；因此，我们接下来调用`dplyr`包中的`select()`函数来对dat1进行子集化，基于这六个变量。此外，由于空间考虑多于其他任何原因，我们将分析限制在拥有数据的头50个赛季。然后，我们调用`dplyr
    filter()`函数来对dat1进行子集化，其中变量`Year`（现在是数值型）小于或等于`1999`：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `glimpse()` function, also from `dplyr,` prints a transposed and truncated
    snapshot of dat1\. We also get the new row and column counts after previously
    calling `select()` and `filter()`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`glimpse()` 函数，同样来自 `dplyr`，打印出 dat1 的转置和截断快照。我们在之前调用 `select()` 和 `filter()`
    之后，也得到了新的行数和列数：'
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here’s a breakdown of our six surviving variables:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的六个存活变量的分解：
- en: '`Year`—Equivalent to season where, for instance, the year 1975 is equivalent
    to the 1974-75 season; has a minimum value of 1950 (1949-50 season) and a maximum
    value of 1999 (1998-99 season). This is now an integer, but it will be converted
    to a factor variable.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Year`—相当于赛季，例如，1975 年相当于 1974-75 赛季；最小值为 1950 年（1950-51 赛季），最大值为 1999 年（1998-99
    赛季）。现在这是一个整数，但它将被转换为因子变量。'
- en: '`Player`—A player’s full name, in firstname lastname format. An asterisk beside
    a player’s name indicates he is a Hall of Famer. This is now and will remain a
    character string.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Player`—球员的全名，以名-姓格式。球员名字旁边的星号表示他是名人堂成员。现在和将来都将是一个字符字符串。'
- en: '`Pos`—A player’s position or positions where, for example, G equals Guard,
    F equals Forward, and G-F equals Guard-Forward. This is now an integer, but it
    will be converted to a factor.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pos`—球员的位置或位置，例如，G 等于后卫，F 等于前锋，G-F 等于后卫-前锋。现在这是一个整数，但它将被转换为因子。'
- en: '`Tm`—A player’s team in abbreviated format so that, for example, BOS equals
    the Boston Celtics. This is yet another character string, but it will be converted
    to a factor.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tm`—球员的队伍，以缩写格式表示，例如，BOS 等于波士顿凯尔特人队。这是一个字符字符串，但它将被转换为因子。'
- en: '`G`—The number of regular season games played by any player for any year. This
    is now an integer and will remain an integer.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`G`—任何球员在任何一年常规赛中所打的比赛数。现在这是一个整数，并将保持为整数。'
- en: '`PTS`—The total points scored in regular season games by any player for any
    year. This is another integer that will remain an integer.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PTS`—任何球员在任何一年常规赛中所得的总分。这是一个将保持为整数的另一个整数。'
- en: Our data requires further wrangling before we can create standardized variables
    and analyze the results.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建标准化变量和分析结果之前，我们的数据需要进一步整理。
- en: 19.3 Wrangling data
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.3 数据整理
- en: 'Our first order of business is fairly mundane by now—convert the variables
    `Year`, `Pos`, and `Tm` from character strings to factors by calling the `as.factor()`
    function from base R three times:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一项任务现在相当平凡——通过三次调用基础 R 的 `as.factor()` 函数，将 `Year`、`Pos` 和 `Tm` 变量从字符字符串转换为因子：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Our second order of business, however, isn’t so straightforward. Our data set
    contains duplicate records brought about by midseason trades and other transactions
    that caused some players to play for two or more teams in the same NBA season.
    These records must be treated somehow to not compromise the integrity of our standardization
    equations.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的第二项任务并不那么简单。我们的数据集包含由于赛季中期的交易和其他交易导致的重复记录，这些交易使得一些球员在同一个NBA赛季为两支或更多球队效力。这些记录必须以某种方式处理，以不损害我们标准化方程的完整性。
- en: 19.3.1 Treating duplicate records
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.3.1 处理重复记录
- en: The most significant challenge with our data set is that it contains one record
    for each unique year, player, and team combination. So someone who played for,
    let’s say, two teams during the 1949-50 season actually takes up three records
    in dat1—one for each of the two teams he played for plus one additional record
    that aggregates his statistics, where the variable `Tm` equals `TOT` (presumably
    short for `TOTAL`).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们数据集最显著的挑战是它包含每个独特的年份、球员和队伍组合的一个记录。所以，比如说，在 1949-50 赛季为两支球队效力的球员实际上在 dat1 中占据了三个记录——他效力的两支球队各一个记录，以及一个额外的记录，该记录汇总了他的统计数据，其中变量
    `Tm` 等于 `TOT`（可能是 `TOTAL` 的缩写）。
- en: 'That being said, we next call the `distinct()` function from the `dplyr` package
    to subset dat1 on every unique, or distinct, `Year`/`Player`/`Pos` combination;
    the results are then cast into a new data set called test1\. Then, we call the
    `dim()` function to return the record count; test1 contains 12,239 records, or
    2,181 fewer observations than dat1:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们接下来调用 `dplyr` 包中的 `distinct()` 函数，对 dat1 中的每个独特的或不同的 `Year`/`Player`/`Pos`
    组合进行子集化；然后，结果被转换成一个新的数据集，称为 test1。然后，我们调用 `dim()` 函数来返回记录数；test1 包含 12,239 条记录，比
    dat1 少 2,181 个观测值：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Put somewhat differently, that means dat1 contains 2,181 records (not unique
    players) where the variable `Tm` equals `TOT` or duplicate `Year`/`Player`/`Pos`
    combinations that otherwise roll up to a record where the variable `Tm` equals
    `TOT`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 换个说法，这意味着 dat1 包含 2,181 条记录（不是唯一的球员）其中变量 `Tm` 等于 `TOT` 或重复的 `Year`/`Player`/`Pos`
    组合，否则会汇总到变量 `Tm` 等于 `TOT` 的记录中。
- en: 'We then write a short chunk of `dplyr` code to pull the record count from dat1
    where the variable `Tm` equals `TOT`. We pass dat1 to the `filter()` function
    via the pipe operator and then pass the results to the `tally()` function, which
    returns the number of dat1 observations where `Tm` equals `TOT`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后编写一小段 `dplyr` 代码来从 dat1 中提取变量 `Tm` 等于 `TOT` 的记录计数。我们通过管道操作符将 dat1 传递给 `filter()`
    函数，然后将结果传递给 `tally()` 函数，该函数返回 `Tm` 等于 `TOT` 的 dat1 观察值的数量：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So we have 1,172 players in dat1 who switched teams *during* an NBA season at
    least once.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，dat1 中有 1,172 名球员在至少一个 NBA 赛季中更换过球队 *期间*。
- en: Let’s take a look at just one example. Ed Bartels was a 6-5 forward who played
    collegiately at North Carolina State. In 1950, he appeared in 13 games for the
    Denver Nuggets, scoring 59 points, plus 2 games for the New York Knicks, scoring
    4 points. His total 1950 productivity was therefore 15 games played and 63 points
    scored.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子。Ed Bartels 是一名 6-5 的前锋，他在北卡罗来纳州立大学接受过大学篮球训练。在 1950 年，他为丹佛掘金队出场 13
    场，得到 59 分，以及为纽约尼克斯队出场 2 场，得到 4 分。因此，他 1950 年的总生产力是 15 场比赛和 63 分。
- en: 'We make another call to the `filter()` function to subset dat1 where the variable
    `Year` equals `1950` and the variable `Player` equals `Ed Bartels`; our results
    are cast into a new data set called test2\. The base R `print()` function returns
    the results:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次调用 `filter()` 函数来对 dat1 进行子集化，其中变量 `Year` 等于 `1950` 且变量 `Player` 等于 `Ed
    Bartels`；我们的结果被转换成一个新的数据集，称为 test2。基本的 R `print()` 函数返回结果：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We don’t want our data to contain more than one record per unique `Year`/`Player`/`Pos`
    combination. So we’ll delete every dat1 observation where `Tm` equals `TOT` and
    then aggregate the variables games (`G`) and points (`PTS`) for every surviving
    record. This might seem counterintuitive; however, this sequence of steps is easier
    from an execution standpoint than the alternative of retaining the observations
    where `Tm` equals `TOT` and then deleting the two or more observations “beneath”
    them.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望我们的数据中包含超过一个记录，每个唯一的 `Year`/`Player`/`Pos` 组合。因此，我们将删除所有 `Tm` 等于 `TOT`
    的 dat1 观察值，然后对每个幸存记录的变量游戏 (`G`) 和得分 (`PTS`) 进行汇总。这看起来可能有些反直觉；然而，这个步骤序列从执行角度来看比保留
    `Tm` 等于 `TOT` 的观察值然后删除其下两个或更多观察值的替代方案更容易。
- en: 'Therefore, we make another call to the `filter()` function to subset dat1 where
    `Tm` equals anything other than `TOT` (note the use of the `!=` operator). The
    `dim()` function returns the row and column counts:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们再次调用 `filter()` 函数来对 dat1 进行子集化，其中 `Tm` 不等于 `TOT`（注意使用 `!=` 操作符）。`dim()`
    函数返回行和列计数：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Our data set now contains 13,248 records, which equals the 14,420 original record
    count minus the 1,172 players who changed teams midseason.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据集现在包含 13,248 条记录，这等于原始记录数 14,420 减去在中途更换球队的 1,172 名球员。
- en: 'Then, we pass dat1 to the `dplyr group_by``()` and `summarize()` functions
    to sum games and points for every `Year`/`Player`/`Pos` combination. For most
    of the dat1 records, this operation will have zero effect; however, where we have
    duplicate `Year`/`Player`/`Pos` combinations, the `group_by``()` and `summarize()`
    functions essentially consolidate the statistics from two or more records into
    just one record. These results are cast into a tibble called dat2\. Afterward,
    we call the `dim()` function to get the dat2 dimension:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将 dat1 传递给 `dplyr group_by()` 和 `summarize()` 函数，以对每个 `Year`/`Player`/`Pos`
    组合汇总游戏和得分。对于大多数 dat1 记录，此操作将没有影响；然而，当我们有重复的 `Year`/`Player`/`Pos` 组合时，`group_by()`
    和 `summarize()` 函数实际上将两个或更多记录的统计数据合并为一条记录。这些结果被转换成一个名为 dat2 的 tibble。之后，我们调用 `dim()`
    函数来获取 dat2 的维度：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that we’ve lost the variable `Tm`; dat1 contains six columns, whereas dat2
    has only five. We instructed R to summarize two of the six dat1 variables grouped
    by three of the remaining four variables; therefore, we didn’t provide R with
    any instructions with respect to `Tm`. This is okay because going forward, we
    don’t need `Tm` to drive any further data wrangling operations or to support any
    of our analysis.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经丢失了变量 `Tm`；dat1 包含六个列，而 dat2 只有五个列。我们指示 R 对 dat1 的六个变量中的两个进行分组，并按剩余四个变量中的三个进行分组；因此，我们没有向
    R 提供关于 `Tm` 的任何指令。这是可以的，因为从现在开始，我们不需要 `Tm` 来驱动任何进一步的数据整理操作或支持我们的分析。
- en: 'Now let’s run a couple more tests. First, we call the `filter()` function again
    to subset dat2 on the variable `Year` equaling `1950` and the variable `Player`
    equaling `Ed Bartels`. Our results are cast into a new data set called test3 and
    then printed:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再进行几项测试。首先，我们再次调用 `filter()` 函数，对 dat2 进行子集化，变量 `Year` 等于 `1950`，变量 `Player`
    等于 `Ed Bartels`。我们的结果被转换成一个新的数据集，称为 test3，然后打印出来：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This dat2 record resembles the dat1 equivalent where the variable `Tm` in dat1
    was equal to `TOT`; dat2, of course, doesn’t contain a variable called `Tm`, but
    more importantly, the variables `G` and `PTS` match up perfectly.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 dat2 记录类似于 dat1 的等效记录，其中 dat1 中的变量 `Tm` 等于 `TOT`；当然，dat2 中不包含名为 `Tm` 的变量，但更重要的是，变量
    `G` 和 `PTS` 完美匹配。
- en: Second, let’s confirm that the records for a player who never switched teams
    midseason, such as George Mikan, who played center for the Lakers when the team
    was based in Minneapolis, weren’t affected (more on Mikan in a bit). In the process,
    we’ll demonstrate a pair of operations we haven’t yet introduced.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，让我们确认那些在整个赛季中从未更换球队的球员的记录，例如乔治·米坎，他在球队位于明尼阿波利斯时为湖人队打中锋，没有受到影响（稍后会有更多关于米坎的介绍）。在这个过程中，我们将展示我们尚未介绍的两个操作。
- en: Take a look at the last line in the following code chunk—`colorDF` is a package
    that adds color to a returned data frame or tibble, and the `highlight()` function
    draws attention to one or more records that satisfy a given condition *when viewed
    online*. We didn’t previously load the `colorDF` package by making a call to the
    `library()` function; instead, we’re simultaneously loading the `colorDF` package
    and calling the `highlight()` function from the same by separating the two with
    a pair of colons. The `highlight()` function takes a data frame-like object as
    one argument (test4, created with the preceding `dplyr` code) and a condition
    as a second argument (where the variable `Year` from test4 equals `1962`).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面代码块中的最后一行——`colorDF` 是一个包，可以为返回的数据框或 tibble 添加颜色，而 `highlight()` 函数在在线查看时将注意力吸引到满足给定条件的一个或多个记录上。我们之前没有通过调用
    `library()` 函数来加载 `colorDF` 包；相反，我们通过在两个名称之间用一对冒号分隔来同时加载 `colorDF` 包并调用 `highlight()`
    函数。`highlight()` 函数接受一个类似于数据框的对象作为第一个参数（test4，由前面的 `dplyr` 代码创建）和一个条件作为第二个参数（test4
    中的变量 `Year` 等于 `1962`）。
- en: Note `colorDF` must first be installed before performing this operation. It’s
    still a good practice to load your packages up front, but this is a valuable technique
    to know when calling functions that cross packages (`highlight()` isn’t one of
    them). R will get confused if you fail to combine the package and function names
    in the same line of code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在执行此操作之前必须首先安装 `colorDF`。尽管在前面加载你的包仍然是一个好习惯，但当你调用跨包的函数时（`highlight()` 不是其中之一），这是一个非常有价值的技巧。如果你没有在同一行代码中将包和函数名称组合起来，R
    会感到困惑。
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we pass dat2 instead of dat1 to a similar code chunk, thereby allowing
    us to compare the outputs:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将 dat2 而不是 dat1 传递给一个类似的代码块，从而允许我们比较输出结果：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Aside from the fact that test4 includes a variable called `Tm` and test5 doesn’t—after
    all, test4 is derived from dat1, whereas test5 is derived instead from dat2—the
    outputs are similar. The `comparedf()` function from the `arsenal` package takes
    two data sets as arguments, compares the two, and returns a summary of findings.
    This is especially helpful when you need to compare two objects with dimensions
    much larger than test4 or test5:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 test4 包含名为 `Tm` 的变量而 test5 不包含之外——毕竟，test4 是从 dat1 衍生的，而 test5 是从 dat2 衍生的——输出结果相似。`arsenal`
    包中的 `comparedf()` 函数接受两个数据集作为参数，比较这两个数据集，并返回发现摘要。当你需要比较两个维度远大于 test4 或 test5 的对象时，这特别有用：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Our third and final order of data wrangling business—at least for the time being—is
    to create one new variable and then remove superfluous data (rows and columns)
    from our working data set. We’ll do that next.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们数据整理的第三和最后一项任务——至少目前是这样——是创建一个新变量，然后从我们的工作数据集中删除多余的数据（行和列）。我们将在下一部分这样做。
- en: 19.3.2 Final trimmings
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.3.2 最终修剪
- en: 'Moving forward, because our analysis will be directed at points scored per
    game, not total points scored, we call the `dplyr mutate()` function to create
    a new variable called `PPG`, which equals the quotient of the dividend `PTS` and
    the divisor `G`. The `format()` function from base R restricts `PPG` to include
    just one digit right of the decimal point. While we usually round or format our
    results to include up to two digits right of the decimal point, the NBA has historically
    recorded points per game and other metrics to include just one digit after the
    decimal point. The `head()` function returns the first six records:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续前进之前，由于我们的分析将针对每场比赛的得分点数，而不是总得分点数，我们调用`dplyr mutate()`函数创建一个名为`PPG`的新变量，该变量等于被除数`PTS`与除数`G`的商。来自基础R的`format()`函数将`PPG`限制为只包含小数点后一位数字。虽然我们通常将结果四舍五入或格式化为包含小数点后两位数字，但NBA历史上记录每场比赛的得分和其他指标时，只包含小数点后一位数字。`head()`函数返回前六条记录：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Our data set contains records for many marginal players; as previously mentioned,
    these are players at the end of the bench and quite possibly in the NBA on part-time
    contracts. By and large, they should therefore be removed from our data set to
    exclude them from our analysis. A quick and easy way of doing so is to again call
    the `filter()` function and reduce dat2 to include only players who averaged at
    least two points per game or who appeared in at least one-quarter of the games.
    It’s hardly a stretch to label any player as marginal if he’s failed to average
    at least one basket per game (a basket is the equivalent of a made shot and is
    worth at least two points) or play in more than 20 games during an 80-game or
    82-game regular season schedule:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据集包含许多边缘球员的记录；如前所述，这些球员是板凳末端的球员，很可能在NBA担任兼职合同球员。总的来说，因此应该从我们的数据集中删除他们，以排除他们从我们的分析中。一个快速简单的方法是再次调用`filter()`函数，将dat2缩减为只包含每场比赛平均至少得两分的球员或至少参加了四分之一比赛的球员。如果一个球员未能每场比赛平均至少投中一个篮筐（篮筐相当于一次有效投篮，至少值两分）或在80场或82场常规赛安排中参加了超过20场比赛，那么很难将他标记为边缘球员：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: These criteria significantly reduce the length of our data—dat2 previously contained
    12,136 records and now contains just 6,390 observations.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标准显著缩短了我们的数据长度——dat2之前包含12,136条记录，现在只包含6,390个观测值。
- en: 'At this point, we no longer need the variables `Pos`, `G`, and `PTS`; therefore,
    we next call the `select()` function from the `dplyr` package to subset dat2 on
    the variables `Year`, `Player`, and `PPG`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们不再需要变量`Pos`、`G`和`PTS`；因此，我们接下来调用`dplyr`包中的`select()`函数，对dat2进行子集化，选择变量`Year`、`Player`和`PPG`：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, we convert our derived variable `PPG` from a character string to numeric
    by calling the base R `as.numeric()` function:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过调用基础R的`as.numeric()`函数将派生变量`PPG`从字符字符串转换为数值：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the next section, we’ll create a `ggplot2` bar chart that visualizes the
    year-over-year points per game averages for the NBA’s leading scorers, demonstrate
    different methods of standardizing a numeric vector, and create like bar charts
    on the standardized data so that we can compare and contrast results across methods
    and against the raw data.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将创建一个`ggplot2`条形图，可视化NBA主要得分手每年每场比赛的平均得分，展示不同的标准化数值向量的方法，并在标准化数据上创建类似条形图，以便我们可以比较和对比不同方法的结果以及与原始数据。
- en: 19.4 Standardizing data
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.4 标准化数据
- en: No doubt, most of us have used data to challenge prior assumptions that stuck
    for years when data wasn’t accessible or analysts weren’t available to mine it.
    Standardization dares us to take different perspectives when data has, in fact,
    been stored, mined, and packaged for public consumption for a long while.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，我们中的大多数人已经使用数据来挑战那些在数据不可用或分析师无法挖掘时持续多年的先前的假设。标准化数据让我们在数据实际上已经存储、挖掘和包装供公众消费了很长时间后，敢于采取不同的视角。
- en: 'We start by making one enhancement to the dat2 data set by making a new variable
    called `Year_Player`, which is simply a concatenation of the existing variables
    `Year` and `Player`, made possible by the built-in `paste0()` function. The `paste0()`
    function takes `Year` as one argument, inserts a space, and then takes `Player`
    as a second argument. As a result, where `Year` might equal `1999` and `Player`
    might equal `Will Perdue`, our new variable `Year_Player` equals `1999 Will Perdue`.
    The base R `head``()` and `tail()` functions return the first three and last three
    observations:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过创建一个名为 `Year_Player` 的新变量来对 `dat2` 数据集进行一次改进，这个变量简单地是现有变量 `Year` 和 `Player`
    的拼接，这是通过内置的 `paste0()` 函数实现的。`paste0()` 函数将 `Year` 作为第一个参数，插入一个空格，然后将 `Player`
    作为第二个参数。因此，当 `Year` 等于 `1999` 而 `Player` 等于 `Will Perdue` 时，我们新的变量 `Year_Player`
    等于 `1999 Will Perdue`。基础 R 的 `head()` 和 `tail()` 函数返回前三个和最后三个观测值：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Our intent is to use `Year_Player`, instead of `Year` *or* `Player`, as the
    x-axis variable in our forthcoming `ggplot2` bar charts—just so that we can display
    and fit both of these variables and not have to choose between one or the other.
    This will improve both the readability and aesthetics of our visual content.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的意图是使用 `Year_Player` 而不是 `Year` 或 `Player` 作为我们即将到来的 `ggplot2` 条形图的 x 轴变量——这样我们就可以显示和拟合这两个变量，而无需在两者之间做出选择。这将提高我们视觉内容的可读性和美观性。
- en: 'Then, we pass dat2 to the `dplyr group_by``()` and `slice()` functions—the
    `slice()` function extracts the one observation for every year in dat2 where the
    variable `PPG`, points per game, is the maximum. Our intent, after all, is to
    display just the annual points per game leaders; therefore, we need a data source
    which exactly satisfies that requirement. The results are then cast to a tibble
    called dat3:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将 `dat2` 传递给 `dplyr group_by()` 和 `slice()` 函数——`slice()` 函数从 `dat2` 中提取每一年变量
    `PPG`（每场比赛得分）为最大值的观测值。毕竟，我们的意图是仅显示每年的每场比赛得分领先者；因此，我们需要一个恰好满足这一要求的数据源。结果随后被转换为一个名为
    `dat3` 的 tibble：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we create our first `ggplot2` bar chart, where dat3 is the data source,
    `Year_Player` is our x-axis variable, and `PPG` is our y-axis variable (see figure
    19.1). We are therefore visualizing the year-over-year NBA scoring leaders between
    the 1949-50 and 1998-99 seasons and their respective points per game average;
    it’s our raw data baseline by which subsequent results will be compared and contrasted:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建我们的第一个 `ggplot2` 条形图，其中 `dat3` 是数据源，`Year_Player` 是我们的 x 轴变量，而 `PPG`
    是我们的 y 轴变量（见图 19.1）。因此，我们正在可视化 1949-50 赛季至 1998-99 赛季之间每年 NBA 得分领先者及其每场比赛平均得分；这是我们后续结果将进行比较和对比的原始数据基线：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![CH19_F01_Sutton](../../OEBPS/Images/CH19_F01_Sutton.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![CH19_F01_Sutton](../../OEBPS/Images/CH19_F01_Sutton.png)'
- en: Figure 19.1 Year-over-year NBA scoring leaders and their average points scored
    per game, between the 1949-50 and 1998-99 seasons
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.1 1949-50 赛季至 1998-99 赛季每年 NBA 得分领先者及其每场比赛平均得分
- en: Wilt Chamberlain’s 50.4 points per game in 1961-62 and 44.8 average in 1962-63
    clearly stand out. Next, we’ll demonstrate various standardization techniques
    and compare the results to the year-over-year raw numbers we just displayed. If
    our original presumption is correct, one or more of the following methods should
    return very different results.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 威尔特·张伯伦在 1961-62 赛季每场比赛 50.4 分和在 1962-63 赛季的平均 44.8 分显然非常突出。接下来，我们将演示各种标准化技术，并将结果与我们刚刚显示的年度原始数值进行比较。如果我们的原始假设是正确的，那么以下方法之一应该会返回非常不同的结果。
- en: 19.4.1 Z-score method
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.4.1 z 分数法
- en: The z-score method is probably the most common or most popular way of standardizing
    data. It represents the number of standard deviations a raw number is above or
    below a population mean. The z-score is computed by subtracting the population
    mean from the raw number and then dividing the difference by the standard deviation.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: z 分数法可能是最常见或最受欢迎的数据标准化方法。它表示原始数值高于或低于总体平均值的多少个标准差。z 分数是通过从原始数值中减去总体平均值，然后将差值除以标准差来计算的。
- en: 'In the next chunk of code, we pass dat2 to the `group_by``()` and `mutate()`
    functions to compute z-scores for every dat2 record, where populations are segmented
    by the variable `Year`. For instance, George Mikan’s 1950 PPG z-score is computed
    from a different mean and standard deviation than Wilt Chamberlain’s 1962 z-score.
    The results are thrown into a tibble called dat4a. The `head``()` and `tail()`
    functions return the first three and last three records, respectively:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一块代码中，我们将 dat2 传递给 `group_by()` 和 `mutate()` 函数，以计算每个 dat2 记录的 z 分数，其中人口按变量
    `Year` 分段。例如，乔治·米坎 1950 年的 PPG z 分数是从与威尔特·张伯伦 1962 年 z 分数不同的均值和标准差计算得出的。结果被放入一个名为
    dat4a 的 tibble 中。`head()` 和 `tail()` 函数分别返回前三条和最后三条记录：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In 1950, an average of 3.8 points scored per game was 0.8 standard deviations
    below the 1950 mean, while 23.4 points per game was 5.6 standard deviations above
    the 1950 mean.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1950 年，每场比赛平均得 3.8 分低于 1950 年均值的 0.8 个标准差，而每场比赛 23.4 分高于 1950 年均值的 5.6 个标准差。
- en: 'There is a quick and easy way—actually, two quick and easy ways—of validating
    the integrity of the variable we just created, `z_ppg`. A vector of z-scores should
    have a mean equal to 0 and a variance equal to 1; we then call the base R `mean``()`
    and `var()` functions to check for these:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 验证我们刚刚创建的变量 `z_ppg` 的完整性的方法既快又简单——实际上，有两种既快又简单的方法。z 分数的向量应该具有均值为 0 和方差为 1；然后我们调用基础
    R 的 `mean()` 和 `var()` 函数来检查这些：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When rounded, the `z_ppg` mean does, in fact, equal 0, and the `z_ppg` variance,
    a measure of dispersion that equals the standard deviation squared, equals 1\.
    We should not have expected the mean to *exactly* equal 0 or for the variance
    to *exactly* equal 1 for the simple reason that we created `z_ppg` by each factor
    in the variable `Year` and not holistically.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当进行四舍五入时，`z_ppg` 的均值实际上等于 0，而 `z_ppg` 的方差，作为离散度的度量，等于标准差的平方，等于 1。我们不应该期望均值恰好等于
    0 或方差恰好等于 1，简单的理由是我们通过变量 `Year` 中的每个因子创建了 `z_ppg`，而不是整体创建。
- en: 'Then, we pass dat4a to the `group_by``()` and `slice()` functions, which cast
    the maximum `z_ppg` for each factor in the variable `Year` to a tibble called
    dat4b:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将 dat4a 传递给 `group_by()` 和 `slice()` 函数，将变量 `Year` 中每个因子的最大 `z_ppg` 转换为名为
    dat4b 的 tibble：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'What’s nice about the `slice()` function versus `summarize``()` is that `slice()`
    pulls every variable for every applicable record; had we called the `summarize()`
    function instead, dat4b would instead contain only the variables `z_ppg` and `Year`.
    It’s dat4b that we then throw into a second `ggplot2` bar chart, where `Year_Player`
    is again our x-axis variable and `z_ppg`, rather than `PPG`, is our y-axis variable
    (see figure 19.2):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `summarize()` 函数相比，`slice()` 函数的优点在于 `slice()` 会提取每个适用记录的每个变量；如果我们调用 `summarize()`
    函数，dat4b 将只包含变量 `z_ppg` 和 `Year`。然后我们将 dat4b 投入第二个 `ggplot2` 条形图，其中 `Year_Player`
    再次是我们的 x 轴变量，而 `z_ppg`（而不是 `PPG`）是我们的 y 轴变量（见图 19.2）：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![CH19_F02_Sutton](../../OEBPS/Images/CH19_F02_Sutton.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![CH19_F02_Sutton](../../OEBPS/Images/CH19_F02_Sutton.png)'
- en: Figure 19.2 Year-over-year NBA scoring leaders and their average points scored
    per game, by z-score, between the 1949-50 and 1998-99 seasons
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.2 1949-50 赛季至 1998-99 赛季 NBA 年度得分领先者和他们每场比赛平均得分的 z 分数
- en: These results shed a totally different perspective on historical points per
    game averages. Wilt Chamberlain’s 50.4 points per game average during the 1961-62
    season was “only” 4.1 standard deviations above the mean for that year. Meanwhile,
    George Mikan’s 1950 points per game average of 27.4 points was almost 7 standard
    deviations above the mean.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果对历史每场比赛平均分提供了全新的视角。威尔特·张伯伦在 1961-62 赛季每场比赛平均 50.4 分，相对于该年的均值“仅”高出 4.1 个标准差。同时，乔治·米坎
    1950 年每场比赛平均 27.4 分，几乎比均值高出 7 个标准差。
- en: 19.4.2 Standard deviation method
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.4.2 标准差方法
- en: Another method of standardizing data is the standard deviation method. Whereas
    the z-score method subtracts the population mean from the raw data and then divides
    the difference by the standard deviation, the standard deviation method excludes
    the mean and simply divides the raw data by the standard deviation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 标准化数据的另一种方法是标准差方法。与 z 分数方法从原始数据中减去总体均值然后除以标准差不同，标准差方法排除了均值，只是将原始数据除以标准差。
- en: 'We pass dat2 to the `dplyr group_by``()` and `mutate()` functions to compute
    the standard deviation method by each factor in the variable `Year` and persist
    the results in a new variable called `sd_ppg`. We get a new tibble called dat5a,
    which, of course, equals dat2 plus the variable `sd_ppg`. We get a peek at the
    first three and last three records in dat5a by calling the `head``()` and `tail()`
    functions:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将dat2传递给`dplyr group_by()`和`mutate()`函数，通过变量`Year`中的每个因素来计算标准差方法，并将结果保存在一个名为`sd_ppg`的新变量中。我们得到一个新的tibble，名为dat5a，当然，它等于dat2加上变量`sd_ppg`。通过调用`head()`和`tail()`函数，我们可以查看dat5a中的前三条和最后三条记录：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The variance for `sd_ppg`, like the variance for `z_ppg`, equals `1`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`sd_ppg`的方差，就像`z_ppg`的方差一样，等于`1`：'
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, we pass the tibble we just created, dat5a, to the `dplyr group_by``()`
    and `slice()` functions. Together, these two functions effectively reduce dat5a
    to include just the one record per year where the variable `sd_ppg` is the maximum.
    These results are cast into yet another tibble called dat5b:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将刚刚创建的tibble，dat5a，传递给`dplyr group_by()`和`slice()`函数。这两个函数结合使用，有效地将dat5a减少到只包含每年变量`sd_ppg`为最大值的单条记录。这些结果被转换成另一个名为dat5b的tibble：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Our results are then visualized with a `ggplot2` bar chart where dat5b is our
    data source, `Year_Player` is again our x-axis variable, and sd_ppg is our y-axis
    variable (see figure 19.3):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的结果随后通过一个`ggplot2`条形图进行可视化，其中dat5b是我们的数据源，`Year_Player`再次是我们的x轴变量，而sd_ppg是我们的y轴变量（见图19.3）：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![CH19_F03_Sutton](../../OEBPS/Images/CH19_F03_Sutton.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![CH19_F03_Sutton](../../OEBPS/Images/CH19_F03_Sutton.png)'
- en: Figure 19.3 Year-over-year NBA scoring leaders and their average points scored
    per game, based on the standard deviation method, between the 1949-50 and 1998-99
    seasons
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.3 基于标准差方法，1949-50赛季至1998-99赛季每年NBA得分领先者和他们每场比赛的平均得分
- en: These results look very similar to our previous results, suggesting that the
    annual mean in points scored per game, which factors into the z-score method but
    not the standard deviation method, is essentially neutral, or immaterial. When
    these results are otherwise compared with the raw data, George Mikan’s 1950 season
    again stands out. Neal Johnston’s 1954 season stands out too, and Allen Iverson’s
    1998-99 season with the Philadelphia 76ers is the most significant outlier in
    the last 45-plus NBA seasons.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果看起来与我们之前的结果非常相似，这表明每场比赛平均得分（它影响z分数方法但不影响标准差方法）基本上是中性的，或者是不相关的。当这些结果与其他原始数据进行比较时，乔治·米坎（George
    Mikan）的1950赛季再次突出。尼尔·约翰斯顿（Neal Johnston）的1954赛季也突出，而艾伦·艾弗森（Allen Iverson）在费城76人队（Philadelphia
    76ers）的1998-99赛季是过去45个NBA赛季中最显著的异常值。
- en: 19.4.3 Centering method
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.4.3 中心化方法
- en: The centering method simply subtracts some constant—such as the minimum or maximum,
    but usually the mean—from the raw data. We’ll subtract the annual mean, but if
    our prior assumption about the points per game mean is correct—that it’s neutral—our
    results should therefore resemble the raw data.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 中心化方法简单地从原始数据中减去某个常数——例如最小值或最大值，但通常是平均值。我们将减去每年的平均值，但如果我们对每场比赛平均得分的先验假设是正确的——它是中性的——那么我们的结果应该因此类似于原始数据。
- en: 'First, we pass dat2 to the `group_by``()` and `summarize()` functions to compute
    the annual points per game mean. The results are then cast into a tibble called
    dat6a. We get the first three and last three dat6a records returned by calling
    the `head()` and `tail()` functions:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将dat2传递给`group_by()`和`summarize()`函数来计算每场比赛的平均得分。然后，这些结果被转换成一个名为dat6a的tibble。我们通过调用`head()`和`tail()`函数来获取dat6a的前三条和最后三条记录：
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Second, we call the `left_join()` function from the `dplyr` package to merge,
    or join, dat3 and dat6a by the variable `Year`, which is the one variable these
    two tibbles have in common. Whereas dat3 has a 68 × 4 dimension and dat6a has
    a 68 × 2 dimension, dat6b has a 68 × 5 dimension. The `head``()` and `tail()`
    functions return the top three and bottom three dat6b observations:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们调用`dplyr`包中的`left_join()`函数，通过变量`Year`将dat3和dat6a合并或连接起来，这是这两个tibble共有的一个变量。而dat3有68
    × 4的维度，dat6a有68 × 2的维度，dat6b有68 × 5的维度。`head()`和`tail()`函数返回dat6b的前三条和最后三条观测值：
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now we have the per-year maximum PPG and the per-year population mean in a single
    object.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个单一的对象，其中包含了每年的最高PPG和每年的平均人口数。
- en: 'Third, we pass dat6b to the `mutate()` function to create a new dat6b variable
    called `c_ppg`, which equals `PPG` minus the mean. Now you know why we just performed
    a left join—we needed these two variables in the same object to derive `c_ppg`.
    To continue providing visibility into all these steps, we again call the `head``()`
    and `tail()` functions to return six records between them:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，我们将dat6b传递给`mutate()`函数，创建一个名为`c_ppg`的新dat6b变量，该变量等于`PPG`减去平均值。现在你知道为什么我们刚刚执行了左连接——我们需要这两个变量在同一对象中派生`c_ppg`。为了继续提供对这些步骤的可见性，我们再次调用`head()`和`tail()`函数，在它们之间返回六个记录：
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Fourth, we create yet another `ggplot2` bar chart as a way of visualizing outcomes
    (see figure 19.4); dat6b is our data source, `Year_Player` runs along the x-axis,
    and `c_ppg` runs along the y-axis:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第四，我们创建另一个`ggplot2`条形图，作为可视化结果的一种方式（见图19.4）；dat6b是我们的数据源，`Year_Player`沿着x轴运行，`c_ppg`沿着y轴运行：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![CH19_F04_Sutton](../../OEBPS/Images/CH19_F04_Sutton.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![CH19_F04_Sutton](../../OEBPS/Images/CH19_F04_Sutton.png)'
- en: Figure 19.4 Year-over-year NBA scoring leaders and their average points scored
    per game, based on the centering method, between the 1949-50 and 1998-99 seasons
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.4 1949-50赛季至1998-99赛季NBA年度得分领先者和他们每场比赛平均得分的年度比较，基于中心化方法
- en: It’s no surprise that these results are a near copy of the raw numbers. Yes,
    the totals affixed to the top of the bars are less, of course, than the raw numbers,
    but that’s because we subtracted the annual population mean in points scored per
    game from the variable `PPG`. More significantly, though, the year-over-year comparisons
    match perfectly with the raw data.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果几乎与原始数字相同，这并不令人惊讶。是的，附加在条形图顶部的总数当然比原始数字少，这是因为我们从`PPG`变量中减去了每年每场比赛得分的年度平均值。然而，更重要的是，年度间的比较与原始数据完全匹配。
- en: 19.4.4 Range method
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.4.4 范围法
- en: In this fourth and final method, we divide the raw numbers by the annual range,
    which is equal to the maximum points per game average minus the minimum points
    per game average for each factor in `Year`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第四和最后的方法中，我们将原始数字除以年度范围，该范围等于`Year`中每个因子的每场比赛平均得分最大值减去最小值。
- en: 'Thus, we pass dat2 to the `group_by``()` and `mutate()` functions, thereby
    creating a new variable called `r_ppg`, which is equal to `PPG` divided by the
    maximum `PPG` minus the minimum `PPG`. We then get the first three and last three
    records in dat7a, the tibble we just created, by calling the `head``()` and `tail()`
    functions:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将dat2传递给`group_by()`和`mutate()`函数，从而创建一个名为`r_ppg`的新变量，该变量等于`PPG`除以最大`PPG`减去最小`PPG`。然后，通过调用`head()`和`tail()`函数，我们获取了我们刚刚创建的tibble（dat7a）中的前三个和最后三个记录：
- en: '[PRE34]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, we cut a tibble called dat7b, which includes only those records, one
    for each `Year` factor, where our derived variable `r_ppg` is the maximum. It
    turns out that `r_ppg` equals `1.1` for every dat7b record. Rather than create
    a (rather unremarkable) bar chart, we’ll instead show the first 10 and last 10
    results:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们切割一个名为dat7b的tibble，它只包含那些记录，每个`Year`因子一个，其中我们派生的变量`r_ppg`是最大的。结果发现，对于每个dat7b记录，`r_ppg`都等于`1.1`。与其创建一个（相当不起眼的）条形图，我们不如展示前10个和最后10个结果：
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: While we have demonstrated four methods of standardizing a single variable,
    sometimes it’s necessary to standardize two or more variables where the raw numbers
    are on vastly different scales. That’s because we don’t want one variable, such
    as `transaction amounts`, which can range between hundreds or even thousands of
    dollars, to weigh more heavily in a customer segmentation or other similar analysis
    versus another variable, such as `transaction counts`, which usually ranges between
    single and double digits. The range method makes more sense when standardizing
    two or more variables, as opposed to a single variable, such as `PPG`, that spans
    decades.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经展示了四种标准化单个变量的方法，但有时有必要对两个或更多变量进行标准化，这些变量的原始数字在完全不同的尺度上。这是因为我们不想让一个变量，比如`交易金额`，其范围在数百甚至数千美元之间，在客户细分或其他类似分析中比另一个变量，比如`交易次数`，通常在个位数和两位数之间，有更大的权重。与跨越数十年的单个变量（如`PPG`）相比，范围法在标准化两个或更多变量时更有意义。
- en: Returning to our analysis, we demonstrated that standardization has the potential
    to present data in radically different ways from what we otherwise might be used
    to, and therefore challenges us to rethink prior conventions. Almost everyone
    still talks about Wilt Chamberlain, but barely anyone pays any attention to George
    Mikan’s exploits. Based on what we’ve presented here, that should definitely change.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的分析，我们展示了标准化有可能以与我们通常习惯截然不同的方式呈现数据，因此挑战我们重新思考先前的惯例。几乎每个人都还在谈论威尔特·张伯伦，但几乎没有人关注乔治·米坎的成就。根据我们在这里展示的内容，这应该肯定会有所改变。
- en: Our next and last chapter is a summarization of the first 19 chapters.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一章和最后一章是对前19章的总结。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Standardization is a critical statistical concept to know and apply when you
    have a single continuous variable, such as average points scored per game, that
    spans a long time horizon. The raw data therefore has different “meanings” over
    time because of changing external factors. Think inflation and why we convert
    older dollars to current dollars.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准化是一个关键统计概念，当你有一个单一的连续变量，如每场比赛的平均得分，跨越长时间跨度时，了解并应用它是非常重要的。因此，由于外部因素的变化，原始数据在不同时间有不同的“含义”。想想通货膨胀以及为什么我们要将旧美元转换为当前美元。
- en: When you have two or more continuous variables where the raw data is on very
    different scales, to prevent one of those variables from having undue influence,
    it’s important to convert the variables to like scales—using like methods—and
    then cast the standardized versions of your data into your analysis.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你拥有两个或更多连续变量，且原始数据处于非常不同的尺度时，为了防止其中一个变量产生不适当的影响，将变量转换为类似尺度——使用类似方法——然后将数据的标准版本纳入分析是很重要的。
- en: We demonstrated four data standardization methods because there’s no one-size-fits-all
    data standardization solution. Which of these methods might be the best for your
    use case mostly depends on your data and whether you’re standardizing just a single
    variable or multiple variables. It’s good practice to test different methods and
    not settle on a single, predefined method.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们展示了四种数据标准化方法，因为没有一种适合所有情况的数据标准化解决方案。这些方法中哪一个可能最适合你的用例主要取决于你的数据和你是标准化单个变量还是多个变量。测试不同的方法并不要仅仅依赖于一个预定义的方法是良好的实践。
- en: We also showed how you can add color to data frame-like objects and even highlight
    records that meet a logical criteria. These are good techniques to know that might
    aid your real-time analysis efforts or when you intend to inject (albeit crude)
    R outputs directly into a PowerPoint presentation, RMarkdown file, or other document
    type.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还展示了如何给数据框对象添加颜色，甚至突出满足逻辑标准的记录。这些是值得了解的好技巧，可能有助于你的实时分析工作，或者当你打算直接将（尽管是粗略的）R输出注入到PowerPoint演示文稿、RMarkdown文件或其他文档类型时。
- en: We introduced and demonstrated some different data wrangling techniques—extracting
    observations that meet a specific criterion with `slice()`, selecting only unique,
    or distinct, records from a data set with `distinct()`, comparing two objects
    and getting a report on the differences with `comparedf()`, and concatenating
    strings with `paste0()`.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们介绍了并演示了一些不同的数据处理技巧——使用 `slice()` 提取满足特定标准的观测值，使用 `distinct()` 从数据集中选择唯一或不同的记录，使用
    `comparedf()` 比较两个对象并获取差异报告，以及使用 `paste0()` 连接字符串。
- en: We also demonstrated how best to call functions that cross between packages.
    Rather than separately loading those packages and calling their functions, it’s
    actually best to load the packages and call the applicable function within the
    same line of code. There might actually be more of a need to apply this technique
    going forward as the number of R functions and packages increases every year.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还演示了如何最好地调用跨包的函数。而不是分别加载这些包并调用它们的函数，实际上最好是在同一行代码中加载包并调用相应的函数。随着每年R函数和包数量的增加，实际上可能需要更多应用这种技术。
