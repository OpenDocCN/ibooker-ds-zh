- en: 5 Structuring and sharing modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 结构化和共享模块
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Constructing module versions and tags for infrastructure changes
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建基础设施变更的模块版本和标签
- en: Choosing a single repository versus multiple repositories
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择单个仓库与多个仓库
- en: Organizing shared infrastructure modules across teams
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在团队间组织共享的基础设施模块
- en: Releasing infrastructure modules without affecting critical dependencies
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布基础设施模块而不影响关键依赖
- en: Up to this point in the book, you’ve learned practices and patterns for writing
    infrastructure as code and breaking them into groups of infrastructure components.
    However, you can write the most optimal configurations but still have trouble
    maintaining and mitigating the risk of failure to your systems. The difficulties
    happen because your team does not standardize collaboration practices when updating
    infrastructure modules.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书你已经学习了编写基础设施代码和实践以及将它们划分为基础设施组件组的模式。然而，即使你编写了最优的配置，仍然可能难以维护和减轻系统故障的风险。困难发生的原因是因为在更新基础设施模块时，你的团队没有标准化协作实践。
- en: Imagine a company, Datacenter for Veggies, starts by automating its growing
    operations for herbs. Applications in GCP monitor and adjust for optimal herb
    growth. Each team uses the singleton pattern and creates a unique infrastructure
    configuration.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一家公司，蔬菜数据中心，它从自动化草药的种植操作开始。GCP中的应用程序监控和调整以实现最佳草药生长。每个团队使用单例模式并创建独特的的基础设施配置。
- en: Over time, Datacenter for Veggies becomes more popular and wants to expand to
    all vegetables. It hires a new application development team specializing in software
    for growing various vegetables, from herbs to leafy greens to root vegetables.
    Each team creates an infrastructure configuration independent of the others.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，蔬菜数据中心变得越来越受欢迎，并希望扩展到所有蔬菜。它雇佣了一个新的应用开发团队，专门为从草药到叶类蔬菜到根茎类蔬菜的各种蔬菜的种植软件。每个团队创建了一个独立于其他团队的基础设施配置。
- en: Datacenter for Veggies hires you to develop an application to grow fruit. You
    realize you cannot reuse any infrastructure configurations because they are unique
    to each vegetable team. The company needs a consistent, reusable way to build,
    secure, and manage infrastructure.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 蔬菜数据中心雇佣你来开发一个种植水果的应用程序。你意识到你不能重用任何基础设施配置，因为它们对每个蔬菜团队都是独特的。公司需要一个一致、可重用的方式来构建、安全和管理工作基础设施。
- en: You realize that Datacenter for Veggies could use some module patterns from
    chapter 3 to organize infrastructure configuration into modules for composability.
    You sketch out a diagram, depicted in figure 5.1, to organize and coordinate groups
    of infrastructure for multiple teams. The teams for herbs, root vegetables, leafy
    green vegetables, and fruit can all use standardized configuration for networks,
    databases, and servers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你意识到蔬菜数据中心可以利用第3章中的一些模块模式来组织基础设施配置，将其划分为模块以提高可组合性。你绘制了一个图，如图5.1所示，用于组织和协调多个团队的基础设施。草药、根茎类蔬菜、叶类蔬菜和水果的团队都可以使用标准化的网络、数据库和服务器配置。
- en: '![](../../OEBPS/Images/CH05_F01_Wang.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH05_F01_Wang.png)'
- en: Figure 5.1 Datacenter for Veggies can use modules to organize and standardize
    infrastructure configuration across application teams.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 蔬菜数据中心可以使用模块来组织和标准化跨应用团队的基础设施配置。
- en: Sharing modules across teams promotes reproducibility, composability, and evolvability.
    The teams do not have to spend as much time building IaC because they reproduce
    established configurations. Team members can choose how they compose their systems
    and override the configurations for their specific needs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在团队间共享模块促进可重复性、可组合性和可扩展性。团队不需要花费太多时间构建IaC，因为他们可以复制已建立的配置。团队成员可以选择如何组合他们的系统，并覆盖特定需求的配置。
- en: To fully realize the benefit of standardized modules, you need to treat them
    with a development life cycle outside of regular infrastructure changes. This
    chapter covers practices for sharing and managing infrastructure modules. You’ll
    learn techniques and practices to release stable modules without introducing critical
    failures to higher-level dependencies.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用标准化模块的好处，你需要将它们视为一个独立于常规基础设施变更的开发生命周期。本章涵盖了共享和管理基础设施模块的实践。你将学习到如何发布稳定的模块，同时避免对高级依赖引入关键故障的技术和实践。
- en: 5.1 Repository structure
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 仓库结构
- en: Imagine that each team in Datacenter for Veggies uses a singleton pattern for
    its infrastructure. The Herbs and Leafy Greens teams realize they use similarly
    configured servers, networks, and databases. Can they merge their infrastructure
    configuration into one module?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 假设数据中心蔬菜的每个团队都为其基础设施使用单例模式。草药和叶绿蔬菜团队意识到他们使用的是类似配置的服务器、网络和数据库。他们能否将他们的基础设施配置合并到一个模块中？
- en: Rather than copy and paste each other’s configuration, the Herbs and Leafy Greens
    teams want to update it in one place and reference it in their configuration.
    Should Datacenter for Veggies put all infrastructure in one repository? Or should
    it divide its modules across multiple repositories?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与复制粘贴彼此的配置不同，草药和叶绿蔬菜团队希望在一个地方更新配置并在他们的配置中引用它。数据中心蔬菜应该将所有基础设施放在一个仓库中吗？还是应该将模块分散到多个仓库中？
- en: 5.1.1 Single repository
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.1 单一仓库
- en: At first, each Datacenter for Veggies team stores its infrastructure configuration
    in a single code repository. Each team organizes its configuration into a dedicated
    directory to avoid mixing up configurations. If a team wants to reference a module,
    the team imports the module by using a local file path.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，每个蔬菜数据中心团队都将其基础设施配置存储在单个代码仓库中。每个团队将其配置组织到一个专用目录中，以避免配置混淆。如果团队想要引用一个模块，团队将通过使用本地文件路径来导入模块。
- en: Figure 5.2 shows how Datacenter for Veggies structures its single code repository.
    The repository contains two folders at the top level, separating modules and environments.
    The company subdivides the environments directory for each team, such as the Leafy
    Greens team. The Leafy Greens team separates configurations by development and
    production environments.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2显示了蔬菜数据中心如何构建其单一代码仓库。仓库包含顶级目录中的两个文件夹，分别用于模块和环境。公司为每个团队细分环境目录，例如叶绿蔬菜团队。叶绿蔬菜团队通过开发和生产环境来分离配置。
- en: '![](../../OEBPS/Images/CH05_F02_Wang.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH05_F02_Wang.png)'
- en: Figure 5.2 The Leafy Greens team’s production and development environments use
    the directories containing server, network, and database factory modules in a
    single repository structure.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 叶绿蔬菜团队的生产和开发环境在一个单一仓库结构中使用了包含服务器、网络和数据库工厂模块的目录。
- en: When the Leafy Greens team members want to create a database, they can use a
    module in the modules folder. In their IaC, they import the module by setting
    a local path. After importing, they can use the database factory and build the
    resource in production.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当叶绿蔬菜团队成员想要创建数据库时，他们可以使用模块文件夹中的一个模块。在他们的基础设施即代码（IaC）中，他们通过设置本地路径来导入模块。导入后，他们可以使用数据库工厂并在生产环境中构建资源。
- en: Datacenter for Veggies started defining infrastructure with a *single repository*
    (also known as a *mono repository**,* or *monorepo)* to contain all configuration
    and modules for each team.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 蔬菜数据中心开始使用*单一仓库*（也称为*单仓库*，或*monorepo*）来包含每个团队的全部配置和模块。
- en: Definition A *single repository* structure (also known as *mono repository*,
    or *monorepo*) contains all IaC (configuration and modules) for a team or function.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 定义A *单一仓库*结构（也称为*单仓库*，或*monorepo*）包含一个团队或功能的全部基础设施即代码（配置和模块）。
- en: In general, the company likes the single repository structure. All teams can
    reproduce their configuration by copying and pasting, and can compose new resources
    by adding a new folder for a module. In listing 5.1, the Leafy Greens team members
    build a new database module. Using Python, they insert a local file path to modules
    by using the `sys.path` method. They use the database by importing its module
    into the codebase.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，公司喜欢使用单一仓库结构。所有团队都可以通过复制粘贴来重现他们的配置，并且可以通过为模块添加一个新的文件夹来创建新的资源。在列表5.1中，叶绿蔬菜团队成员构建了一个新的数据库模块。他们使用Python，通过`sys.path`方法将本地文件路径插入到模块中。他们通过将模块导入到代码库中来使用数据库。
- en: Listing 5.1 Referencing infrastructure modules in a different directory
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.1 在不同目录中引用基础设施模块
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Imports the directory with the modules because it exists in the same repository
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入包含模块的目录，因为它存在于同一个仓库中
- en: ❷ Imports the server, database, and network factory modules for the production
    environment
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 导入生产环境的服务器、数据库和网络工厂模块
- en: ❸ Uses the modules to create the JSON configuration for the network, server,
    and database
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用模块创建网络、服务器和数据库的JSON配置
- en: ❹ Writes the Python dictionary out to a JSON file to be executed by Terraform
    later
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将Python字典写入JSON文件，以便Terraform稍后执行
- en: 'Using local folders to store modules helps the teams reference the infrastructure
    they want. Everyone can look in the same repository for modules or examine other
    teams’ configurations. If someone on the Herbs team wants to learn about the Fruits
    team’s IaC, they can use the `tree` command to examine the directory structure:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本地文件夹存储模块有助于团队引用他们想要的工具。每个人都可以在同一个存储库中查找模块或检查其他团队的配置。如果草药团队的某个人想了解水果团队的IaC，他们可以使用`tree`命令来检查目录结构：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To better organize configurations, each team puts development and production
    environment configurations into separate folders. These directories isolate configurations
    and changes for each environment. Ideally, all environments should be the same.
    Realistically, you will have differences between environments to address cost
    or resource constraints.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地组织配置，每个团队都将开发和生产环境配置放入单独的文件夹中。这些目录隔离了每个环境的配置和更改。理想情况下，所有环境都应该是相同的。现实情况下，您将在环境之间有差异，以解决成本或资源限制。
- en: Other tools
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 其他工具
- en: A single repository structure applies to many other IaC tools. You can apply
    the single repository structure for reusing roles and playbooks to configuration
    management tools like Ansible. You can reference and build playbooks or configuration
    management modules based on each local directory in the single repository.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 单个存储库结构适用于许多其他IaC工具。您可以将单个存储库结构应用于重用角色和剧本到配置管理工具，如Ansible。您可以根据单个存储库中的每个本地目录引用和构建剧本或配置管理模块。
- en: CloudFormation works a bit differently. You can host all of your stack definition
    files in a single repository. However, you must release the child template (which
    I consider a module) into an S3 bucket and reference it with the `TemplateURL`
    parameter in the `AWS::CloudFormation::Stack` resource. Later in this chapter,
    you’ll learn how to deliver and release changes to modules.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFormation的工作方式略有不同。您可以将所有堆栈定义文件托管在单个存储库中。但是，您必须将子模板（我认为它是一个模块）发布到S3存储桶，并在`AWS::CloudFormation::Stack`资源中使用`TemplateURL`参数引用它。在本章的后面部分，您将了解如何交付和发布模块的更改。
- en: 'Datacenter for Veggies uses one infrastructure provider, GCP. In the future,
    teams can add new directories for different infrastructure tools or providers.
    These tools can update servers or networks (ansible directory), build virtual
    machine images (packer directory), or deploy the database to AWS (aws directory):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 蔬菜数据中心使用一个基础设施提供商，即GCP。未来，团队可以为不同的基础设施工具或提供商添加新的目录。这些工具可以更新服务器或网络（ansible目录），构建虚拟机镜像（packer目录），或将数据库部署到AWS（aws目录）：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You may encounter the principle of *don’t repeat yourself* (*DRY*) in other
    IaC materials. DRY promotes reuse and composability. Infrastructure modules reduce
    duplication and repetition in configuration, which conforms to DRY. If you can
    have identical development and production environments, you could omit the development
    and production directories and reference one module instead of separate environment
    files.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能在其他IaC材料中遇到“不要重复自己”的原则（*DRY*）。DRY原则促进重用和可组合性。基础设施模块减少了配置中的重复和冗余，符合DRY原则。如果您能够拥有相同的生产和开发环境，您就可以省略开发和生产目录，并引用一个模块而不是单独的环境文件。
- en: You cannot fully comply with DRY in infrastructure. Depending on the infrastructure
    or tool’s language and syntax, you will always have repetitive configuration.
    As a result, you can have occasional repetition for clearer configuration or within
    the limitations of tools or platforms.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您无法在基础设施中完全遵守DRY原则。根据基础设施或工具的语言和语法，您总会遇到重复的配置。因此，您可以在配置更清晰或工具或平台限制的范围内偶尔重复。
- en: 5.1.2 Multiple repositories
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.2 多个存储库
- en: As Datacenter for Veggies grows, its infrastructure repository has hundreds
    of folders. Each folder contains many more nested ones. Every week, you spend
    time rebasing the configuration with all the updates from every repository. You
    also wait 20 minutes each time you push to production because your CI framework
    must recursively search for changes. The security team also expresses concern
    because contractors working with the Leafy Greens team have access to all of the
    Fruits team’s infrastructure!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 随着蔬菜数据中心的发展，其基础设施存储库有数百个文件夹。每个文件夹包含更多嵌套的文件夹。每周，您都要花费时间将所有存储库的更新与配置进行合并。每次您将更改推送到生产环境时，您也要等待20分钟，因为您的CI框架必须递归地搜索更改。安全团队也表达了担忧，因为与绿叶蔬菜团队合作的承包商可以访问水果团队的整个基础设施！
- en: You divide network, tag, server, and database modules into individual repositories.
    Each repository has its workflow for building and delivering the module, which
    takes less time for the CI framework. You can control access to each repository,
    allowing contractors on the Leafy Greens team to access only the Leafy Greens
    configuration.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你将网络、标签、服务器和数据库模块分别划分到单独的仓库中。每个仓库都有自己的构建和交付模块的工作流程，这减少了CI框架的时间。你可以控制对每个仓库的访问，允许绿叶团队的外包人员只能访问绿叶配置。
- en: Different teams in Datacenter for Veggies can use the module’s repository or
    packaged version. Each team stores its configuration and modules in a separate
    repository. Anyone in the company can download and use the modules in their configurations.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 蔬菜数据中心的不同团队可以使用模块的仓库或打包版本。每个团队将其配置和模块存储在单独的仓库中。公司中的任何人都可以下载和使用配置中的模块。
- en: Figure 5.3 shows the code repositories Datacenter for Veggies uses to create
    IaC. Each team and module gets its own code repository. When the Leafy Greens
    team wants to create a database, it downloads and imports the database module
    from a GitHub repository URL instead of the local folder. If teams have multiple
    environments, they subdivide their code repository into folders.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3显示了蔬菜数据中心用于创建IaC的代码仓库。每个团队和模块都有自己的代码仓库。当绿叶团队想要创建数据库时，它会从GitHub仓库URL下载并导入数据库模块，而不是从本地文件夹中导入。如果团队有多个环境，他们可以将代码仓库细分到文件夹中。
- en: '![](../../OEBPS/Images/CH05_F03_Wang.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH05_F03_Wang.png)'
- en: Figure 5.3 In a multiple repository structure, you store each module in its
    own code repository. The configuration references the repository URL to use the
    module.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3在多仓库结构中，你将每个模块存储在其自己的代码仓库中。配置引用仓库URL以使用模块。
- en: Datacenter for Veggies has migrated from a single repository structure to a
    *multiple repository*, or *multi repo*, structure. The company separated modules
    into various repositories based on the teams.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 蔬菜数据中心已从单一仓库结构迁移到多仓库结构，或称为多仓库结构。公司根据团队将模块分离到不同的仓库中。
- en: Definition A *multiple repository* (also known as a *multi repo*) structure
    separates IaC (configuration or modules) into different repositories based on
    team or function.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 定义A多仓库结构（也称为多仓库）根据团队或功能将IaC（配置或模块）分离到不同的仓库中。
- en: Recall that a single repository pattern promotes reproducibility and composability.
    A multiple repository pattern helps improve the principle of evolvability. Separating
    the modules into their own repositories helps structure each module’s life cycle
    and management.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，单一仓库模式促进了可重复性和可组合性。多仓库模式有助于提高可进化性原则。将模块分离到各自的仓库中有助于结构化每个模块的生命周期和管理。
- en: To implement a multiple repository structure, you split the modules into their
    own version control repository. In the following listing, you configure Python’s
    package manager to download each module by adding it as a library requirement
    in requirements.txt. Each library requirement must include a URL to the version
    control repository and a specific tag to download.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现多仓库结构，你需要将模块拆分到各自的版本控制仓库中。在下面的列表中，你通过在requirements.txt文件中将每个模块添加为库依赖项来配置Python的包管理器以下载每个模块。每个库依赖项必须包含一个指向版本控制仓库的URL和一个特定的标签以下载。
- en: Listing 5.2 Python requirements.txt references module repositories
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.2 Python requirements.txt引用模块仓库
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Downloads the prototype module for tags from a GitHub repository. Picks the
    module version based on the tag.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从GitHub仓库下载标签的原型模块。根据标签选择模块版本。
- en: ❷ Downloads the factory module for the network, server, and database from a
    GitHub repository. Picks the module version based on the tag.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从GitHub仓库下载网络、服务器和数据库的工厂模块。根据标签选择模块版本。
- en: 'First, you create a repository for the production configuration of the fruit
    application’s infrastructure. After you create the repository, you add requirements.txt
    to it. Then you run Python’s package installation manager to download each module
    for the infrastructure configuration:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你为水果应用程序基础设施的生产配置创建一个仓库。创建仓库后，你将其添加到requirements.txt文件中。然后，你运行Python的包安装管理器以下载基础设施配置的每个模块：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Rather than set a local path and import the modules, you need to run Python’s
    package installation manager to download from the remote repository first. After
    downloading the modules, teams can import them in environment configurations by
    using Python in listing 5.3.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是设置本地路径并导入模块，你需要先运行Python的包安装管理器从远程仓库下载。下载模块后，团队可以使用列表5.3中的Python来在环境配置中导入它们。
- en: Listing 5.3 Importing the modules for use in infrastructure configuration
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.3 导入模块以用于基础设施配置
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Imports the modules downloaded by the package manager
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入由包管理器下载的模块
- en: ❷ Uses the modules to create the JSON configuration for the network, server,
    and database
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用模块创建网络、服务器和数据库的JSON配置
- en: ❸ Writes the Python dictionary out to a JSON file to be executed by Terraform
    later
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将Python字典写入JSON文件，以便Terraform稍后执行
- en: Recall that Datacenter for Veggies separately configures the development and
    production environments. The teams would implement code to reference the same
    factory and prototype modules hosted in version control. Consistent modules for
    development and production environments prevent drift between environments and
    help you test module changes before production. You’ll learn more about testing
    and environments in chapter 6.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Veggies数据中心分别配置开发和生产环境。团队将实现代码以引用版本控制中托管的相同工厂和原型模块。开发和生产环境的一致模块可以防止环境漂移，并帮助你在生产前测试模块更改。你将在第6章中了解更多关于测试和环境的内容。
- en: The IaC implementation for a multiple repository does not differ too much from
    a single repository. Both structures support reproducibility and composability.
    However, they differ in that you independently evolve a module in an external
    repository.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 多仓库的IaC实现与单仓库的实现差异不大。两种结构都支持可重复性和可组合性。然而，它们的不同之处在于你可以在外部仓库中独立地演进一个模块。
- en: Updating a configuration in a multiple repository structure involves re-downloading
    new modules with your package manager. Running the package manager to use a new
    module can introduce friction in your IaC workflow. Someone may update a module,
    and you won’t know unless you review its repository. Later in this chapter, you’ll
    learn about solving this problem with versioning.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在多仓库结构中更新配置涉及使用包管理器重新下载新的模块。运行包管理器以使用新模块可能会在IaC工作流程中引入摩擦。有人可能更新了一个模块，除非你审查其仓库，否则你不会知道。在本章的后面部分，你将了解如何通过版本控制来解决这个问题。
- en: Domain-specific languages
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 领域特定语言
- en: If a tool can reference modules or libraries with version control or artifact
    URLs, it can support a multiple repository structure.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个工具可以引用带有版本控制或工件URL的模块或库，它就可以支持多仓库结构。
- en: When you adopt a multiple repository structure, you must establish a few standard
    practices to share and maintain modules. First, standardize a module file structure
    and format. It helps the teams across your organization identify and filter modules
    in version control. Consistent file structures and naming for module repositories
    also help with auditing and future automation.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当你采用多仓库结构时，你必须建立一些标准实践来共享和维护模块。首先，标准化模块文件结构和格式。这有助于组织中的团队在版本控制中识别和筛选模块。模块仓库的一致文件结构和命名也有助于审计和未来的自动化。
- en: For example, infrastructure modules in Datacenter for Veggies follow the same
    pattern and file structure. Their names include *infrastructure provider, resource,*
    and *tool* or *purpose*. In figure 5.4, the `gcp-server-module` describes GCP
    as the infrastructure provider, `server` as the resource type, and `module` as
    the purpose.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Veggies数据中心的基础设施模块遵循相同的模式和文件结构。它们的名称包括*基础设施提供者、资源*和*工具*或*目的*。在图5.4中，`gcp-server-module`描述GCP作为基础设施提供者，`server`作为资源类型，`module`作为目的。
- en: '![](../../OEBPS/Images/CH05_F04_Wang.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH05_F04_Wang.png)'
- en: Figure 5.4 The repository name should include the infrastructure provider, resource
    type, and purpose.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 仓库名称应包括基础设施提供者、资源类型和目的。
- en: If your modules use a specific tool or have a unique purpose, you can append
    it to the end of the repository name. It helps to add the tool to the name to
    identify the module type. Similar to the practices outlined in chapter 2, you
    want your module name descriptive enough for a teammate to identify.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的模块使用特定的工具或具有独特目的，你可以将其附加到仓库名称的末尾。将工具添加到名称中可以帮助识别模块类型。类似于第2章中概述的实践，你希望你的模块名称足够描述性，以便团队成员可以识别。
- en: You can apply the repository naming approach to naming folders in a single repository
    as well. However, subdirectories in a single repository make it easier to nest
    and identify infrastructure provider and resource type. Depending on your organization
    and team’s preferences, you can always add more fields to a repository name.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将存储库命名方法应用于单个存储库中的文件夹命名。然而，单个存储库中的子目录使得嵌套和识别基础设施提供者和资源类型更加容易。根据您组织和团队的偏好，您始终可以向存储库名称添加更多字段。
- en: 5.1.3 Choosing a repository structure
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.3 选择存储库结构
- en: The scalability of your system and CI framework determine whether you use a
    single repository or multiple repositories. Datacenter for Veggies started with
    a single repository, which worked well because it had tens of modules and a few
    environments. Each module has two environments, for development and production.
    Each environment needs a few servers, one database, a network, and a monitoring
    system.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您的系统可扩展性和CI框架决定了您是使用单个存储库还是多个存储库。数据中心从单个存储库开始，由于它有数十个模块和几个环境，所以效果很好。每个模块有两个环境，用于开发和生产。每个环境需要几台服务器、一个数据库、一个网络和一个监控系统。
- en: Using a single repository provides a few benefits. Figure 5.5 outlines some
    of the advantages and limitations. First, anyone on your team can access modules
    and configurations in one repository. Second, you need to go to only one place
    to compare and identify differences between environments. For example, you can
    compare two files in the repository to check whether development uses three servers
    and production uses five servers.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单个存储库提供了一些好处。图5.5概述了一些优点和局限性。首先，您的团队中的任何人都可以访问一个存储库中的模块和配置。其次，您只需要去一个地方就可以比较和识别环境之间的差异。例如，您可以在存储库中比较两个文件，以检查开发是否使用三台服务器，而生产是否使用五台服务器。
- en: Drawing on the IaC principles, a single repository structure still offers composability,
    evolvability, and reproducibility. Anyone can go into a folder and evolve a module.
    You can still build modules on one another because you have a singular view of
    all infrastructure and configuration.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 借鉴IaC原则，单个存储库结构仍然提供可组合性、可扩展性和可重复性。任何人都可以进入一个文件夹并演进一个模块。您仍然可以在模块之间构建，因为您有一个对所有基础设施和配置的单一视图。
- en: '![](../../OEBPS/Images/CH05_F05_Wang.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH05_F05_Wang.png)'
- en: Figure 5.5 A single repository offers one view for all modules and configurations
    but limits CI frameworks or granular access control.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 单个存储库为所有模块和配置提供了一个视图，但限制了CI框架或细粒度访问控制。
- en: On the other hand, a single repository structure has some limitations. If anyone
    can go and change a module, it could break the IaC that depends on it! Furthermore,
    your CI system might break down as it recursively checks each directory for changes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，单个存储库结构有一些局限性。如果任何人都可以更改一个模块，它可能会破坏依赖于它的IaC！此外，您的CI系统可能会崩溃，因为它递归地检查每个目录中的更改。
- en: As a result, you need to adopt practices and tools to handle single repositories.
    These include opinionated versioning and specialized build systems. If your organization
    cannot build or adopt a tool that helps alleviate single repository management,
    you may choose a multiple repository structure.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您需要采用实践和工具来处理单个存储库。这包括有偏见的版本控制和专门的构建系统。如果您的组织无法构建或采用帮助减轻单个存储库管理的工具，您可以选择多个存储库结构。
- en: Note You will find a few tools that help with building and managing single repositories.
    They have additional code to handle nested subdirectories and individual build
    workflows. Some of them include Bazel, Pants, and Yarn.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您会发现一些有助于构建和管理单个存储库的工具。它们包含额外的代码来处理嵌套子目录和单个构建工作流程。其中一些包括Bazel、Pants和Yarn。
- en: The migration from single to multiple repository structure happens more than
    you think. I had to do it twice! One organization started with three environments
    and four modules. Over a few years, the IaC grew to hundreds of modules and environments.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 从单个存储库结构迁移到多个存储库结构的发生频率可能比你想象的要高。我不得不做两次！一个组织从三个环境和四个模块开始。几年后，IaC增长到数百个模块和环境。
- en: Unfortunately, the CI framework (Jenkins) took nearly three hours to run a standard
    change scaling up servers. The framework spent most of its time searching each
    directory and nested directory for changes! We eventually refactored the configurations
    and modules into multiple repositories.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，CI框架（Jenkins）运行标准更改以扩展服务器需要近三个小时。框架的大部分时间都花在搜索每个目录和嵌套目录中的更改上！我们最终将配置和模块重构为多个存储库。
- en: Refactoring into multiple repositories alleviated some of the problems with
    the CI framework. A multiple repository structure also provided more granular
    access control to specific modules. The security team could grant module edit
    access to specific teams. You’ll learn more about refactoring in chapter 10.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 将配置重构为多仓库结构缓解了CI框架的一些问题。多仓库结构还提供了对特定模块的更细粒度的访问控制。安全团队可以向特定团队授予模块编辑访问权限。你将在第10章中了解更多关于重构的信息。
- en: Figure 5.6 shows the benefits and limitations of multiple repositories, including
    granular access control and scalable CI workflows. However, a multiple repository
    structure reduces your singular view of modules and configurations for your organization.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6展示了多仓库的好处和局限性，包括细粒度的访问控制和可扩展的CI工作流程。然而，多仓库结构减少了你对组织模块和配置的单一视角。
- en: '![](../../OEBPS/Images/CH05_F06_Wang.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH05_F06_Wang.png)'
- en: Figure 5.6 Multiple repositories help reduce the burden of running tests and
    configurations with CI frameworks but require constant verification of conformance
    to formatting and troubleshooting.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 多仓库有助于减轻使用CI框架运行测试和配置的负担，但需要不断验证格式和故障排除的一致性。
- en: By refactoring the configuration into a multiple repository structure, you can
    isolate access to and evolve the infrastructure configuration for specific teams.
    You have greater control over the evolution and life cycle of modules. Most CI
    frameworks support multiple repositories and will run workflows in parallel when
    the framework detects changes to a given repository.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将配置重构为多仓库结构，你可以隔离对特定团队的基础设施配置的访问和演进。你对模块的演进和生命周期有更大的控制权。大多数CI框架都支持多仓库，并且当框架检测到特定仓库的更改时，将并行运行工作流程。
- en: However, multiple repositories do have some downsides. Imagine Datacenter for
    Veggies has ten or more modules in different repositories. How do you know if
    they all conform to the same file standards and naming?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，多仓库确实有一些缺点。想象一下“蔬菜数据中心”有十个或更多模块分布在不同的仓库中。你如何知道它们是否都符合相同的文件标准和命名？
- en: Figure 5.7 shows one solution to the problem of file and standard conformance.
    You can capture all of the tests for formatting and linting checks into a prototype
    module. Then, the CI framework downloads the tests and checks for README and Python
    files in the server, network, database, and DNS modules.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7展示了解决文件和标准一致性问题的一个解决方案。你可以将所有格式化和linting检查的测试捕获到一个原型模块中。然后，CI框架在服务器、网络、数据库和DNS模块中下载测试并检查README和Python文件。
- en: '![](../../OEBPS/Images/CH05_F07_Wang.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH05_F07_Wang.png)'
- en: Figure 5.7 Creating a prototype module that contains all of the checks for module
    repositoryformat will help fix older repositories that do not conform to new standards.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 创建一个包含所有模块仓库格式检查的原型模块将有助于修复不符合新标准的旧仓库。
- en: The prototype module with tests help enforce formatting for older modules that
    you don’t use as often, like DNS. If you want to add a new standard, you update
    the prototype module with a new test. The next time someone updates a module or
    configuration, they need to update their module format to conform.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 带有测试的原型模块有助于强制执行不常使用的旧模块（如DNS）的格式。如果你想添加一个新标准，你只需更新原型模块中的新测试。下次有人更新模块或配置时，他们需要更新他们的模块格式以符合标准。
- en: A standardized set of checks helps alleviate the operational burden of finding
    and replacing files in hundreds of repositories. It distributes the responsibility
    of updating the module repository to the module’s maintainers. For more on module
    conformance testing and integrating modules in your workflow, you can apply the
    practices in chapters 6, 7, and 8.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 标准化的检查集有助于减轻在数百个仓库中查找和替换文件的操作负担。它将更新模块仓库的责任分配给模块的维护者。有关模块一致性测试和将模块集成到工作流程中的更多信息，你可以在第6、7和8章中应用这些实践。
- en: A second disadvantage to a multiple repository structure involves the challenge
    of troubleshooting. When you reference a module in your configuration, you need
    to search for the module repository to identify which inputs and outputs it needs.
    The search adds extra effort and time when you debug failures in configuration.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 多仓库结构的第二个缺点涉及故障排除的挑战。当你在配置中引用一个模块时，你需要搜索模块仓库以确定它需要哪些输入和输出。在调试配置中的失败时，搜索增加了额外的努力和时间。
- en: If you have a build system that can handle single repository building requirements,
    you can use a single repository for everything. However, most build systems do
    not scale with recursive directory searching. To solve this problem, you can use
    a combination of single and multiple repositories.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个可以处理单个存储库构建要求的构建系统，你可以为所有内容使用单个存储库。然而，大多数构建系统不会随着递归目录搜索进行扩展。为了解决这个问题，你可以使用单存储库和多存储库的组合。
- en: Let’s apply this solution to Datacenter for Veggies. They separate each configuration
    for different types of fruits and vegetables. Leafy Greens uses one repository,
    while Fruits uses another. Both of them reference shared modules for network,
    tags, database, and DNS.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个解决方案应用到蔬菜数据中心。他们为不同类型的果实和蔬菜分别分离每个配置。叶菜类蔬菜使用一个存储库，而水果使用另一个。它们都引用共享的网络、标签、数据库和DNS模块。
- en: Figure 5.8 shows that the Fruits team needs a queue but the Leafy Greens team
    does not. As a result, the Fruits repository includes a local module for creating
    queues. The Fruits team uses a single repository for its unique configurations
    but references multiple repositories for common modules.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8显示，水果团队需要一个队列，而叶菜类蔬菜团队不需要。因此，水果存储库包括一个用于创建队列的本地模块。水果团队使用单个存储库进行其独特的配置，但引用多个存储库的常见模块。
- en: '![](../../OEBPS/Images/CH05_F08_Wang.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH05_F08_Wang.png)'
- en: Figure 5.8 Your organization can combine multiple repositories with a single
    repository for application or system-specific configuration.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 你的组织可以使用单个存储库来组合多个存储库，以进行应用程序或系统特定的配置。
- en: When you use this mix-and-match approach, recognize the kind of access control
    you want for individual repositories or shared configurations. If you want to
    improve composability and reproducibility for other teams, you might put a module
    in its own repository. However, if you want to maintain evolvability for a specialized
    configuration, you might manage the module locally with your configuration.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用这种混合匹配方法时，要认识到你希望为单个存储库或共享配置设置哪种访问控制。如果你想提高其他团队的组合性和可重复性，你可能将一个模块放在它自己的存储库中。然而，如果你想保持特定配置的可扩展性，你可能需要使用你的配置在本地管理该模块。
- en: As you choose your repository structure, recognize the trade-off between approaches
    and refactor as the number of modules and configurations grows. When you add more
    configuration and resources into a single repository, you need to make sure the
    tools and processes scale with it!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当你选择你的存储库结构时，要认识到方法之间的权衡，并在模块和配置数量增长时进行重构。当你将更多配置和资源添加到单个存储库中时，你需要确保工具和流程与其一起扩展！
- en: 5.2 Versioning
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 版本控制
- en: Throughout this chapter, you’ve used the practice of keeping infrastructure
    configuration or code in version control. For example, Datacenter for Veggies
    teams can always reference infrastructure based on the commit hash. One day, the
    security team for Datacenter for Veggies expressed concern about the age of usernames
    and passwords for soil-monitoring databases.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的整个过程中，你已经使用了将基础设施配置或代码保存在版本控制中的实践。例如，蔬菜数据中心团队可以始终根据提交哈希引用基础设施。有一天，蔬菜数据中心的安全团队对土壤监测数据库的用户名和密码的年龄表示了担忧。
- en: The team recommends using a secret manager to store and rotate the password
    every 30 days. Problematically, *all* teams use the soil-monitoring database module.
    Figure 5.9 shows that the application currently references the output of the database
    module. The module outputs the password for the database, which applications use
    to write and read data. The security team wants you to use a secrets manager instead.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 团队建议使用密钥管理器存储和每30天轮换密码。问题在于，*所有*团队都使用土壤监测数据库模块。图5.9显示，应用程序当前引用了土壤监测模块的输出。该模块输出数据库的密码，应用程序使用该密码来写入和读取数据。安全团队希望你使用密钥管理器。
- en: '![](../../OEBPS/Images/CH05_F09_Wang.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH05_F09_Wang.png)'
- en: Figure 5.9 The applications reference the database endpoint and password from
    the soil-monitoring module but should use the password from the secrets manager.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 应用程序引用了土壤监测模块的数据库端点和密码，但应使用密钥管理器的密码。
- en: The database module output affects the secret’s evolvability and security. How
    can we update the database to use the secrets manager without disrupting soil
    data collection? The infrastructure team at Datacenter for Veggies decides to
    add *versioning* to the database module.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库模块的输出会影响密钥的可扩展性和安全性。我们如何更新数据库以使用密钥管理器而不干扰土壤数据收集？蔬菜数据中心的基础设施团队决定向数据库模块添加*版本控制*。
- en: Definition *Versioning* is the process of assigning unique versions to iterations
    of code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *版本控制* 是将唯一版本分配给代码迭代的过程。
- en: 'Let’s examine how the Datacenter for Veggies team implements module versions.
    The team uses version control to tag the current version of the database module
    as `v1.0.0`. Version v1.0.0 will output the database password for applications:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看蔬菜数据中心团队如何实现模块版本。该团队使用版本控制来标记数据库模块的当前版本为 `v1.0.0`。版本 v1.0.0 将为应用程序输出数据库密码：
- en: '[PRE6]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'They push the tag for v1.0.0 to version control:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 他们将 v1.0.0 的标签推送到版本控制：
- en: '[PRE7]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You must refactor configurations for Fruit, Leafy Greens, Grain, and Herb growth
    to use the v1.0.0 version of the database module in a process called *version
    pinning*. Version pinning preserves idempotency. When you run the IaC, the configurations
    continue to use the database module outputs. You should not detect any drift between
    a pinned module and the existing infrastructure.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须重构水果、叶菜、谷物和香草生长的配置，以使用名为 *版本锁定* 的过程中数据库模块的 v1.0.0 版本。版本锁定保持幂等性。当你运行 IaC 时，配置将继续使用数据库模块的输出。你不应该检测到锁定模块和现有基础设施之间的任何漂移。
- en: 'After all of the teams pin the versions to v1.0.0, you can rewrite the module
    to use a secrets manager. The database module stores the password in the secrets
    manager. The team tags the new database module as `v2.0.0`, which outputs the
    database endpoint and location of the password in the secrets manager:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有团队将版本锁定到 v1.0.0 之后，你可以重写模块以使用秘密管理器。数据库模块将密码存储在秘密管理器中。团队将新的数据库模块标记为 `v2.0.0`，该版本输出数据库端点和秘密管理器中密码的位置：
- en: '[PRE8]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'They push the tag for v2.0.0 to version control:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 他们将 v2.0.0 的标签推送到版本控制：
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can examine the difference between the two versions of the module based
    on the commit history:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据提交历史来检查模块两个版本的差异：
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now that you’ve created a new version of the database factory module, you ask
    some of the teams to try it. The Fruits team bravely volunteers. The Fruits team
    currently uses version 1.0.0\. That module version outputs the database endpoint
    and password.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经创建了数据库工厂模块的新版本，你要求一些团队尝试使用它。水果团队勇敢地自告奋勇。水果团队目前使用版本 1.0.0。该模块版本输出数据库端点和密码。
- en: When updating to module version 2.0.0, as shown in figure 5.10, the Fruits team
    needs to account for changes in the module’s workflow. The team cannot use the
    database password in the module’s output. The module outputs an API path to the
    database password stored in the secrets manager. As a result, the Fruits team
    refactors its IaC to get the database password from the secrets manager before
    creating the database.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当更新到模块版本 2.0.0 时，如图 5.10 所示，水果团队需要考虑模块工作流程的变化。团队不能使用模块输出中的数据库密码。模块输出一个指向存储在秘密管理器中的数据库密码的
    API 路径。因此，水果团队重构其 IaC，在创建数据库之前从秘密管理器获取数据库密码。
- en: You’ll apply a few essential practices to module versioning. First, make sure
    you run your IaC and eliminate any drift before you update. Second, establish
    a versioning approach that *does not* reference the latest version of the module.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你将应用一些基本的模块版本控制实践。首先，确保你在更新之前运行你的 IaC 并消除任何漂移。其次，建立一个不 *引用* 模块最新版本的版本控制方法。
- en: Datacenter for Veggies follows *semantic versioning*, assigning version numbers
    that convey essential information about the configuration. You can specify module
    versions in a few ways, including tagging the commit with a number in version
    control or packaging and labeling the module in an artifact repository.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 蔬菜数据中心遵循 *语义版本控制*，分配传达配置基本信息的版本号。你可以通过几种方式指定模块版本，包括在版本控制中用数字标记提交，或在工件存储库中打包和标记模块。
- en: '![](../../OEBPS/Images/CH05_F10_Wang.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH05_F10_Wang.png)'
- en: Figure 5.10 You can refactor the Fruit application to reference version 2.0.0
    of the database module and retrieve the database password from the secrets manager.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 你可以将水果应用程序重构为引用数据库模块的版本 2.0.0 并从秘密管理器检索数据库密码。
- en: Note I often update the major version for significant updates that remove inputs,
    outputs, and resources. I usually update the minor version if I update configuration
    values, inputs, or outputs to modules that do not affect dependencies using previous
    versions. Finally, I will change the patch version for minor configuration value
    changes scoped to the module and its resources. For additional details on semantic
    versioning and its approaches, you can reference [https://semver.org/](https://semver.org/).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我经常更新主版本，以删除输入、输出和资源的重要更新。如果我只更新配置值、输入或输出到不影响依赖项的模块，我通常更新次版本。最后，我将更改补丁版本，以针对模块及其资源范围内的次要配置值更改。有关语义版本化和其方法的更多详细信息，请参考[https://semver.org/](https://semver.org/)。
- en: Using a consistent versioning approach, you can more effectively evolve downstream
    infrastructure resources without breaking upstream ones because you control their
    dependencies. Versioning also helps with the auditing of active versions. To save
    resources, reduce confusion, and promote the latest changes, versioning allows
    you to identify and deprecate older, inactive versions of the module.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一致的版本控制方法，你可以更有效地演进下游基础设施资源，而不会破坏上游资源，因为你控制了它们的依赖关系。版本控制还有助于对活跃版本进行审计。为了节省资源、减少混淆并推广最新更改，版本控制允许你识别和弃用模块的较旧、非活动版本。
- en: However, you must continuously remember and enforce certain versioning practices.
    The longer you wait to update the application to use v2.0.0 of the database, the
    higher chance it will fail. You might consider putting a timeline on how long
    you can use the module version v1.0.0\. You do not need to immediately delete
    v1.0.0 of the database module. Generally, I upgrade dependent modules within a
    few minor version changes. Trying to upgrade with a broader “jump” between versions
    increases the change’s risk and possible failure rate.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你必须持续记住并执行某些版本控制实践。你等待更新应用程序以使用数据库的v2.0.0版本的时长越长，它失败的可能性就越高。你可能需要考虑为模块版本v1.0.0的使用设定一个时间表。你不需要立即删除数据库模块的v1.0.0版本。通常，我在几个小版本更改内升级依赖模块。尝试在版本之间进行更广泛的“跳跃”升级会增加变更的风险和可能的失败率。
- en: Note If you use feature-based development or Git Flow, you can accommodate patches
    or hotfixes in the same workflow as software development. You can make a branch
    based on the version tag, update the changes, increase the patch version, and
    add a new tag for the hotfix branch. You will need to keep the branch for the
    commit history.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果你使用基于特性的开发或Git Flow，你可以在软件开发的工作流程中容纳补丁或热修复。你可以基于版本标签创建一个分支，更新更改，增加补丁版本，并为热修复分支添加一个新的标签。你需要保留分支以保留提交历史。
- en: This versioning process works well for a multiple repository structure. What
    about a single repository? You can still apply the version control tagging approach.
    You may want to add a prefix to the tag with the module name (`module-name-v2.0.0`).
    Then you can package and release your module to an artifact repository. Your build
    system packages the contents of the module subdirectory and tags the version in
    the artifact store. Your configuration references the remote modules in the artifact
    repository instead of a local file.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此版本控制过程适用于多仓库结构。那么对于单一仓库呢？你仍然可以应用版本控制标签方法。你可能想在标签前添加模块名称的前缀（`module-name-v2.0.0`）。然后你可以将模块打包并发布到工件存储库。你的构建系统将打包模块子目录的内容，并在工件存储库中标记版本。你的配置引用工件存储库中的远程模块，而不是本地文件。
- en: 5.3 Releasing
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 发布
- en: I explained the practice of module versioning to help with module evolution
    and minimize disruption to your system. However, you don’t want every team to
    update its IaC to the newest module immediately. Instead, you want to make sure
    the module works and doesn’t break your infrastructure *before* you use it in
    production.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我解释了模块版本控制的实践，以帮助模块演进并最小化对系统的干扰。然而，你不想每个团队都立即更新其IaC到最新的模块。相反，你想要确保模块在投入生产使用之前能够正常工作且不会破坏你的基础设施。
- en: Figure 5.11 shows how you evaluate your database module update before allowing
    all Datacenter for Veggies teams to use it. After you update the database module
    to store a password in the secrets manager, you push the changes to version control.
    You ask the Fruits team to *test* the module in a separate environment and confirm
    that the module works. They confirm it works correctly. You tag the release with
    a new version, 2.0.0, and update the documentation on the secrets manager.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.11展示了在允许所有蔬菜数据中心团队使用之前，你如何评估你的数据库模块更新。在你将数据库模块更新为在密钥管理器中存储密码后，你将更改推送到版本控制。你要求水果团队在一个独立的环境中**测试**该模块，并确认模块可以正常工作。他们确认它工作正确。你使用新版本2.0.0标记发布，并更新了密钥管理器上的文档。
- en: In the previous section, the Datacenter for Veggies infrastructure team updated
    the module and tested it with the Fruits team’s development environment first.
    Now that the module passed the test, other teams can use the new database module
    with a secret manager. The team followed a *release* process to certify that other
    teams can use the new module.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，蔬菜数据中心的基础设施团队更新了模块，并首先与水果团队的开发环境进行了测试。现在模块通过了测试，其他团队可以使用带有密钥管理器的新数据库模块。团队遵循了一个**发布**流程来确保其他团队可以使用新模块。
- en: Definition *Releasing* is the process of distributing software to a consumer.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 **发布** 是将软件分发给消费者的过程。
- en: '![](../../OEBPS/Images/CH05_F11_Wang.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH05_F11_Wang.png)'
- en: Figure 5.11 When you make module updates, ensure that you include a testing
    stage before releasing the module and updating its documentation.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.11 当你进行模块更新时，确保在发布模块和更新其文档之前包括一个测试阶段。
- en: A release process identifies and isolates any problems from module updates.
    You do not package a new module unless the tests certify that it works.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 发布流程识别并隔离了模块更新中可能出现的任何问题。除非测试证明新模块可以正常工作，否则你不会打包新模块。
- en: I recommend running module tests in a dedicated testing environment away from
    development and production workloads. A separate account or project for module
    testing helps you track the cost of running the tests and isolates failures away
    from active environments. You’ll learn more about testing and testing environments
    in chapter 6.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议在一个专门的测试环境中运行模块测试，远离开发和生产工作负载。为模块测试设置一个单独的账户或项目可以帮助你跟踪测试的成本，并将故障隔离在活动环境中。你将在第6章中了解更多关于测试和测试环境的内容。
- en: Note For a detailed code listing of a continuous delivery pipeline for releasing
    modules, check out [http://mng.bz/PnaR](http://mng.bz/PnaR). The GitHub Actions
    pipeline automatically builds a GitHub release when the tests succeed based on
    a commit message.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：有关发布模块的持续交付管道的详细代码列表，请参阅[http://mng.bz/PnaR](http://mng.bz/PnaR)。GitHub Actions管道在测试成功时根据提交消息自动构建GitHub发布。
- en: After testing the modules, you tag the release with a new version for your team
    to use. Datacenter for Veggies releases the database module as version v2.0.0
    and uses the Python package manager to reference the tag. Alternatively, you can
    package the module and push it to an artifact repository or storage bucket.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 测试模块后，你为团队使用的新版本标记发布。蔬菜数据中心发布数据库模块为版本v2.0.0，并使用Python包管理器引用该标记。或者，你也可以打包模块并将其推送到工件存储库或存储桶。
- en: For example, imagine Datacenter for Veggies has some teams that use CloudFormation.
    These teams prefer to reference modules (or CloudFormation stacks) stored in an
    Amazon S3 bucket. In figure 5.12, the teams add a step to their delivery pipeline
    to compress their modules and upload them to an S3 storage bucket. As a last step,
    they update documentation outlining the changes they made.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下蔬菜数据中心有一些团队使用CloudFormation。这些团队更喜欢引用存储在Amazon S3存储桶中的模块（或CloudFormation堆栈）。在图5.12中，团队在他们的交付管道中添加了一个步骤，以压缩他们的模块并将它们上传到S3存储桶。作为最后一步，他们更新了概述他们所做的更改的文档。
- en: '![](../../OEBPS/Images/CH05_F12_Wang.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH05_F12_Wang.png)'
- en: Figure 5.12 After testing, you optionally choose to package and push the module
    to an artifact repository or storage bucket.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.12 测试后，你可以选择将模块打包并推送到一个工件存储库或存储桶。
- en: Some organizations prefer packaging the artifact and storing it in a separate
    repository for additional security control. If you have a secure network that
    cannot access an external version control endpoint, you can reference the artifact
    repository instead. Just make sure to keep the tag in version control so someone
    can correlate the artifact to the correct code version.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一些组织更喜欢打包工件并将其存储在单独的存储库中，以实现额外的安全控制。如果你有一个安全的网络，无法访问外部版本控制端点，你可以引用工件存储库。只需确保将标签保留在版本控制中，以便有人可以将工件与正确的代码版本关联起来。
- en: After packaging and pushing the artifact, you should update documentation outlining
    your changes. That documentation, called *release notes*, outlines breaking changes
    to outputs and inputs. Release notes communicate a summary of changes to other
    teams.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在打包和推送工件后，你应该更新概述你更改的文档。这种文档称为*发布说明*，概述了输出和输入的破坏性更改。发布说明向其他团队传达了更改的摘要。
- en: Definition *Release notes* list changes to code for a given release. You should
    store them in a document in the repository, often called a changelog.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *发布说明* 列出了给定版本的代码更改。你应该将它们存储在存储库中的文档中，通常称为变更日志。
- en: You can manually update the release notes, but I prefer an automated semantic
    release tool (such as semantic-release) to examine the commit history and build
    release notes for me. Make sure that you use the correct commit message format
    for the tool to match and parse changes. Chapter 2 emphasized the importance of
    writing descriptive commit messages. You’ll also find them helpful for an automated
    release tool.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以手动更新发布说明，但我更喜欢使用自动语义发布工具（如semantic-release）来检查提交历史并为我构建发布说明。确保你使用正确的提交信息格式，以便工具能够匹配和解析更改。第2章强调了编写描述性提交信息的重要性。你也会发现它们对自动发布工具很有帮助。
- en: 'For example, the database module stores the password in a secret manager. Datacenter
    for Veggies considers this a major feature, so you prefix the commit message with
    `feat`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，数据库模块将密码存储在密钥管理器中。对于蔬菜数据中心来说，这是一个主要特性，因此你在提交信息前加上`feat`前缀：
- en: '[PRE11]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A commit analyzer in an automated release tool automatically updates the major
    version of the tag to v2.0.0 based on this commit.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 自动发布工具中的提交分析器会根据这个提交自动更新标签的主版本号为v2.0.0。
- en: Image building
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图像构建
- en: You might encounter the practice of using image-building tools to build immutable
    server or container images. By baking the packages you want into a server or container
    image, you can create new servers with updates without the problems of in-place
    updates. When you release immutable images, use a workflow to create a test server
    based on the image, check that it runs correctly, and update the version of the
    image tag. Chapter 7 covers some of these workflows.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到使用图像构建工具来构建不可变服务器或容器镜像的做法。通过将你想要的软件包烘焙到服务器或容器镜像中，你可以创建带有更新的新服务器，而无需担心就地更新问题。当你发布不可变镜像时，使用工作流程基于该镜像创建测试服务器，检查其是否正常运行，并更新镜像标签的版本。第7章涵盖了这些工作流程的一些内容。
- en: Besides updating release notes, make sure you update commonly used files and
    documentation. Common files help your teammates use the module. For instance,
    Datacenter for Veggies agrees that teams must always include a README file. A
    README documents the purpose, inputs, and outputs of each module.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更新发布说明外，确保你更新常用文件和文档。常用文件有助于你的队友使用该模块。例如，蔬菜数据中心同意团队必须始终包含一个README文件。README记录了每个模块的目的、输入和输出。
- en: Definition A *README* is a document in a repository that explains usage and
    contribution instructions for code. For IaC, use it to document a module’s purpose,
    inputs, and outputs.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *README* 是存储库中的一个文档，它解释了代码的使用和贡献说明。对于IaC，使用它来记录模块的目的、输入和输出。
- en: Use a linting rule to check for the existence of a README file. In chapter 2,
    I discussed some linting practices to ensure clean IaC. Applying the pattern to
    commonly used files and documentation helps you format and organize large amounts
    of IaC.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代码检查规则来检查README文件的存在。在第2章中，我讨论了一些代码检查实践，以确保干净的IaC。将此模式应用于常用文件和文档有助于你格式化和组织大量的IaC。
- en: In the Python examples, the modules include common files like `__init__.py`
    for identifying the package and `setup.py` for module configuration. I often refer
    to files with configuration or metadata that help specific tools or languages
    as *helper files*. They change depending on the tool and platform you use. You
    will want to standardize them across your organization so you can change or search
    them in parallel by using automation.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python示例中，模块包括常见的文件，如用于识别包的`__init__.py`和用于模块配置的`setup.py`。我经常将具有配置或元数据、有助于特定工具或语言的文件称为**辅助文件**。它们会根据你使用的工具和平台而变化。你希望在整个组织中标准化它们，以便可以通过自动化并行更改或搜索它们。
- en: 5.4 Sharing modules
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 分享模块
- en: As Datacenter for Veggies grows more produce, it adds *new teams* that automate
    the growth of grains, tea, coffee, and beans. The company also creates a new team
    for researching wild strains of produce. Each team needs to be able to expand
    the existing modules but also create new ones.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 随着数据中心为蔬菜生产更多产品，它增加了自动化谷物、茶叶、咖啡和豆类生长的**新团队**。公司还创建了一个研究野生蔬菜品种的新团队。每个团队都需要能够扩展现有模块并创建新的模块。
- en: For example, the Beans team needs to change a database module to use PostgreSQL
    version 12\. Should those team members be able to edit the module with the version
    update? Or should they file a ticket with you, the infrastructure team, to update
    it?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，豆类团队需要更改数据库模块以使用PostgreSQL版本12。那些团队成员是否应该能够编辑模块并更新版本？或者他们应该向你，基础设施团队，提交工单以更新它？
- en: You need to empower different teams to create and update modules with IaC. However,
    you want to make sure that teams do not change an attribute and compromise security
    or functionality. You’ll find a few practices that can help you share modules
    across your organization.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要授权不同的团队使用IaC（基础设施即代码）创建和更新模块。然而，你想要确保团队不会更改属性而损害安全性或功能性。你将发现一些可以帮助你在组织中共享模块的实践。
- en: Imagine that all teams in Datacenter for Veggies need a database. You create
    a new, opinionated database module that establishes a default set of parameters
    to provide security and functionality. The database module uses embedded defaults
    for module inputs to cover many Datacenter for Veggies use cases. Even if the
    Coffee team doesn’t know how to create a database, that team can use the module
    to build a secure, working database.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 假设数据中心为蔬菜的各个团队都需要一个数据库。你创建了一个新的、有偏见的数据库模块，该模块建立了一组默认参数以提供安全性和功能性。数据库模块使用内嵌的默认值作为模块输入，以覆盖数据中心为蔬菜的许多用例。即使咖啡团队不知道如何创建数据库，该团队也可以使用该模块构建一个安全、可工作的数据库。
- en: As a general practice, set *opinionated defaults* in your module. You want to
    err on the prescriptive side. If a team needs more flexibility, it can update
    the module or override the default attributes. Preset defaults help teach secure
    and standard practices for deploying specific infrastructure resources.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项通用实践，在你的模块中设置**有偏见的默认值**。你希望偏向于规定性的一边。如果团队需要更多的灵活性，它可以更新模块或覆盖默认属性。预设的默认值有助于教授部署特定基础设施资源的安全和标准实践。
- en: In this scenario, the Beans team expresses a need for more flexibility. The
    module does not use a new version of the database, PostgreSQL version 12\. No
    other team uses that version of PostgreSQL. The Beans team decides to update the
    database version and push the changes into the repository.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，豆类团队表达了对更多灵活性的需求。该模块没有使用新的数据库版本，即PostgreSQL版本12。没有其他团队使用该版本的PostgreSQL。豆类团队决定更新数据库版本并将更改推送到仓库。
- en: However, the changes do not get released immediately. The build system sends
    a notification to module approvers in the infrastructure team. In figure 5.13,
    the infrastructure team pauses the build system and reviews the changes. If the
    changes pass the team’s approval, the build system releases the module. The Beans
    team can use the new version of the database module with PostgreSQL version 12.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，更改不会立即发布。构建系统向基础设施团队的模块审批者发送通知。在图5.13中，基础设施团队暂停了构建系统并审查了更改。如果更改通过了团队的批准，构建系统将发布模块。豆类团队可以使用带有PostgreSQL版本12的新版本的数据库模块。
- en: Why should you allow the Beans team to change the infrastructure module? *Self-service*
    of module changes empowers all teams to update their systems and reduce the burden
    on infrastructure and platform teams. You want to balance their development progress
    with security and infrastructure availability. Adding an approval before module
    release identifies potential failures or nonstandard changes to infrastructure.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你应该允许Beans团队更改基础设施模块？*自助服务*的模块变更赋予所有团队更新其系统的权力，并减轻基础设施和平台团队的负担。你希望平衡他们的开发进度与安全和基础设施的可用性。在模块发布前添加审批可以识别潜在故障或非标准的基础设施变更。
- en: '![](../../OEBPS/Images/CH05_F13_Wang.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH05_F13_Wang.png)'
- en: Figure 5.13 An application team can update the database module. However, the
    team must wait for approval from subject-matter experts before being able to use
    the new release.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.13 一个应用团队可以更新数据库模块。然而，该团队必须等待主题专家的批准才能使用新版本。
- en: The practice of allowing any team to use modules and edit them with approvers
    works best with established module development standards and processes. If you
    don’t establish module standards, this approach falls apart and adds friction
    to delivering the infrastructure change to production.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 允许任何团队使用模块并经审批者编辑的做法，在建立了模块开发标准和流程的情况下效果最佳。如果你没有建立模块标准，这种方法就会失效，并给将基础设施变更交付到生产中增加摩擦。
- en: Let’s return to the example. The infrastructure team does not have much confidence
    in the change, so the team asks a database administrator for additional review.
    The database administrator points out that if the Beans team upgrades its module
    version, the resulting behavior deletes the previous database and creates an empty
    one with the new version! This would significantly disrupt the application supporting
    bean growth.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到例子。基础设施团队对变更没有太多信心，因此团队请求数据库管理员进行额外审查。数据库管理员指出，如果Beans团队升级其模块版本，导致的行为将删除之前的数据库，并使用新版本创建一个空的数据库！这将严重干扰支持豆类生长的应用程序。
- en: In figure 5.14, the Beans team submits a request for help from the database
    team. An administrator recommends some practices that will help update the database
    without deleting data. The Beans team implements these practices and asks module
    approvers for a second review. Once the module gets released, the team can use
    the module without worrying about disrupting its applications.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在图5.14中，Beans团队向数据库团队提交了求助请求。管理员推荐了一些有助于更新数据库而不删除数据的做法。Beans团队实施了这些做法，并请求模块审批者进行第二次审查。一旦模块发布，团队就可以使用该模块，而不用担心会干扰其应用程序。
- en: '![](../../OEBPS/Images/CH05_F14_Wang.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH05_F14_Wang.png)'
- en: Figure 5.14 For disruptive module updates, the application team submits a ticket
    to the database team to verify database migration steps before releasing a new
    module version.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.14 对于破坏性的模块更新，应用团队提交工单给数据库团队，以在发布新模块版本之前验证数据库迁移步骤。
- en: If you have concerns that a change might be particularly disruptive to a system’s
    architecture, security, or availability, *ask for review from a subject-matter
    expert* before releasing a new version. A subject-matter expert can help identify
    any problems that will affect other teams using the module and advise on the best
    way to update it. The process of review helps you evolve your IaC and identify
    potential failures from infrastructure changes.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你担心某个变更可能会特别破坏系统的架构、安全或可用性，在发布新版本之前，*请向主题专家请求审查*。主题专家可以帮助识别任何会影响使用该模块的其他团队的问题，并就如何最佳更新它提供建议。审查过程有助于你演进你的基础设施即代码（IaC），并识别来自基础设施变更的潜在故障。
- en: In general, you need a process that empowers your team to make infrastructure
    changes *and* provides the team the knowledge and support to complete those changes
    successfully without disrupting critical systems. Manual review may seem tedious
    but helps educate your team and prevent problems in production. Your team must
    find a balance between quickly deploying changes to production and waiting for
    manual review from a subject-matter expert, something I’ll expand on in chapter
    7.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你需要一个流程，赋予你的团队能够进行基础设施变更的权力，并且提供团队完成这些变更所需的知识和支持，而不会干扰关键系统。手动审查可能看起来很繁琐，但有助于教育你的团队并防止生产中出现问题。你的团队必须在快速部署变更到生产中和等待主题专家手动审查之间找到平衡，这一点我将在第7章中进一步阐述。
- en: By working collaboratively on modules, you share IaC knowledge across teams
    and collectively identify potential disruptions to critical infrastructure. You
    can treat modules as *artifacts* for use across an organization, similar to shared
    application libraries, container images, or virtual machine images. Anyone in
    the company can use and update modules (with additional help, if needed!) to evolve
    infrastructure architecture, security, or availability.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在模块上协作工作，您可以在团队间共享基础设施即代码（IaC）知识，并集体识别对关键基础设施的潜在干扰。您可以将模块视为组织内使用的*工件*，类似于共享的应用程序库、容器镜像或虚拟机镜像。公司中的任何人都可使用和更新模块（如有需要，可提供额外帮助！）以演进基础设施架构、安全或可用性。
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Structure and share modules and configurations in a single repository or multiple
    repositories.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单一存储库或多个存储库中结构化和共享模块和配置。
- en: A single repository structure organizes all configuration and modules in one
    place, making it easier to troubleshoot and identify usable resources.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一存储库结构将所有配置和模块组织在一个地方，这使得故障排除和识别可用资源变得更加容易。
- en: A multiple repository structure organizes all configuration and modules into
    their own code repositories, divided by business domain, function, team, or environment.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多存储库结构将所有配置和模块组织到各自的代码存储库中，按业务领域、功能、团队或环境划分。
- en: A multiple repository structure allows better access control for individual
    infrastructure configuration or modules and streamlines pipeline execution for
    each repository.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多存储库结构允许对单个基础设施配置或模块进行更好的访问控制，并简化每个存储库的管道执行。
- en: A single repository may not scale as more people collaborate on IaC and require
    additional resources for a build system to process changes quickly.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着越来越多的人参与基础设施即代码（IaC）协作并需要额外的资源来快速处理更改，单一存储库可能无法扩展。
- en: Refactor a single repository into multiple repositories, one for each module.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将单一存储库重构为多个存储库，每个模块一个存储库。
- en: Choose a consistent versioning methodology for modules and update them using
    Git tags.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为模块选择一致的版本控制方法，并使用Git标签进行更新。
- en: Package and release a module to an artifact repository, which will allow anyone
    in the organization to retrieve a specific module version.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将模块打包并发布到工件存储库，这将允许组织中的任何人都可检索特定模块版本。
- en: When sharing modules across teams, establish opinionated default parameters
    in modules to maintain security and functionality.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在团队间共享模块时，在模块中建立有见地的默认参数以维护安全和功能。
- en: Allow anyone in the organization to suggest updates to modules, but add governance
    to identify potentially disruptive changes to modules that affect architecture,
    security, or infrastructure availability.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许组织中的任何人为模块提出更新建议，但添加治理机制以识别可能对架构、安全或基础设施可用性造成干扰的模块更改。
