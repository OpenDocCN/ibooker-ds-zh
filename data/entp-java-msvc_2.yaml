- en: Appendix. Spring Boot microservices
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录。Spring Boot 微服务
- en: Throughout the book, we’ve focused on developing microservices for Enterprise
    Java with Thorntail. This appendix provides details on developing microservices
    with Spring Boot. Included are snippets from *Spring Boot in Action* by Craig
    Walls (Manning, 2015). If you’re particularly focused on Spring Boot microservices,
    taking a look at this book for further details would be worthwhile (see [www.manning.com/books/spring-boot-in-action](http://www.manning.com/books/spring-boot-in-action)).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们一直专注于使用 Thorntail 为企业 Java 开发微服务。本附录提供了使用 Spring Boot 开发微服务的详细信息。其中包含来自
    Craig Walls 所著的《Spring Boot in Action》（Manning, 2015）的片段。如果你特别关注 Spring Boot 微服务，查看这本书以获取更多细节将是有益的（见
    [www.manning.com/books/spring-boot-in-action](http://www.manning.com/books/spring-boot-in-action)）。
- en: Anatomy of a Spring Boot project
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Spring Boot 项目的解剖结构
- en: This section contains snippets from section 2.1.1 of *Spring Boot in Action*,
    outlining the parts of a Spring Boot application and its requirements.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含来自《Spring Boot in Action》第 2.1.1 节的片段，概述了 Spring Boot 应用程序及其要求。
- en: Examining a newly initialized Spring Boot project
  id: totrans-4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查一个新初始化的 Spring Boot 项目
- en: '[Figure 1](#app01fig01) illustrates the structure of a Spring Boot reading-list
    project.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1](#app01fig01) 展示了 Spring Boot 阅读列表项目的结构。'
- en: Figure 1\. Structure of reading-list project
  id: totrans-6
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1\. 阅读列表项目的结构
- en: '![](Images/0afig01_alt.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0afig01_alt.jpg)'
- en: The first thing to notice is that the project structure follows the layout of
    a typical Maven or Gradle project. The main application code is placed in the
    src/main/java branch of the directory tree, resources are placed in the src/main/resources
    branch, and test code is placed in the src/test/java branch. At this point, you
    don’t have any test resources, but if you did, you’d put them in src/test/resources.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，项目结构遵循典型的 Maven 或 Gradle 项目的布局。主要应用程序代码位于目录树的 src/main/java 分支，资源位于
    src/main/resources 分支，测试代码位于 src/test/java 分支。目前，你没有任何测试资源，但如果有，你将把它们放在 src/test/resources。
- en: 'Digging deeper, you’ll see a handful of files sprinkled about the project:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 深入挖掘，你会在项目中看到一些散布的文件：
- en: '***build.gradle*—** The Gradle build specification'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***build.gradle*—** Gradle 构建规范'
- en: '***ReadingListApplication.java*—** The application’s bootstrap class and primary
    Spring configuration class'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***ReadingListApplication.java*—** 应用程序的引导类和主要 Spring 配置类'
- en: '***application.properties*—** A place to configure application and Spring Boot
    properties'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***application.properties*—** 配置应用程序和 Spring Boot 属性的地方'
- en: '***ReadingListApplicationTests.java*—** A basic integration test class'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***ReadingListApplicationTests.java*—** 一个基本的集成测试类'
- en: The build specification contains a lot of Spring Boot goodness to uncover, so
    I’ll save inspection of it until last. Instead, we’ll start with ReadingListApplication.java.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 构建规范包含许多 Spring Boot 的优点需要挖掘，所以我将把它留到最后检查。相反，我们将从 ReadingListApplication.java
    开始。
- en: Bootstrapping Spring
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 引导 Spring
- en: 'The `ReadingListApplication` class serves two purposes in a Spring Boot application:
    configuration and bootstrapping. First, it’s the central Spring configuration
    class. Even though Spring Boot autoconfiguration eliminates the need for a lot
    of Spring configuration, you’ll need at least a small amount of Spring configuration
    to enable autoconfiguration. As you can see in this listing, there’s only one
    line of configuration code.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadingListApplication` 类在 Spring Boot 应用程序中扮演两个角色：配置和引导。首先，它是中心 Spring 配置类。尽管
    Spring Boot 自动配置消除了许多 Spring 配置的需求，但你至少需要一小部分 Spring 配置来启用自动配置。正如你在这段代码中可以看到的，只有一行配置代码。'
- en: Listing 1\. `ReadingListApplication`
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 1\. `ReadingListApplication`
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1*** Enable component-scanning and autoconfiguration.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 启用组件扫描和自动配置。'
- en: '***2*** Bootstrap the application.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 引导应用程序。'
- en: '`@SpringBootApplication` enables Spring component scanning and Spring Boot
    autoconfiguration. In fact, `@SpringBootApplication` combines three other useful
    annotations:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`@SpringBootApplication` 启用 Spring 组件扫描和 Spring Boot 自动配置。实际上，`@SpringBootApplication`
    结合了三个其他有用的注解：'
- en: '*Spring’s* `@Configuration`—Designates a class as a configuration class using
    Spring’s Java-based configuration. Although you won’t write a lot of configuration
    in this book, you’ll favor Java-based configuration over XML configuration when
    you do.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Spring 的* `@Configuration`—使用基于 Spring 的 Java 配置将类指定为配置类。尽管你在这本书中不会写很多配置，但当你需要时，你将优先选择基于
    Java 的配置而不是 XML 配置。'
- en: '*Spring’s* `@ComponentScan`—Enables component scanning so that the web controller
    classes and other components you write will be automatically discovered and registered
    as beans in the Spring application context. Later in this appendix, you’ll write
    a simple Spring MVC controller that will be annotated with `@Controller` so that
    component scanning can find it.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Spring的* `@ComponentScan`——启用组件扫描，以便自动发现和注册你编写的Web控制器类和其他组件为Spring应用程序上下文中的bean。在本附录的后面部分，你将编写一个简单的Spring
    MVC控制器，它将被标记为`@Controller`，以便组件扫描可以找到它。'
- en: '*Spring Boot’s* `@EnableAutoConfiguration`—This humble little annotation might
    as well be named `@Abracadabra` because it’s the one line of configuration that
    enables the magic of Spring Boot autoconfiguration. This one line keeps you from
    having to write the pages of configuration that would be required otherwise.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Spring Boot的* `@EnableAutoConfiguration`——这个谦逊的小注解几乎可以命名为`@Abracadabra`，因为它是一行配置，它启用了Spring
    Boot自动配置的魔力。这一行让你不必编写在其他情况下所需的页面配置。'
- en: In older versions of Spring Boot, you’d annotate the `ReadingListApplication`
    class with all three of these annotations. But since Spring Boot 1.2.0, `@SpringBootApplication`
    is all you need.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Boot的旧版本中，你需要在`ReadingListApplication`类上标注这三个注解。但自从Spring Boot 1.2.0以来，`@SpringBootApplication`就足够了。
- en: As I said, `ReadingListApplication` is also a bootstrap class. There are several
    ways to run Spring Boot applications, including traditional WAR file deployment.
    But for now, the `main()` method here enables you to run your application as an
    executable JAR file from the command line. It passes a reference to the `ReadingListApplication`
    class to `SpringApplication.run()`, along with the command-line arguments, to
    kick off the application.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如我所说，`ReadingListApplication`也是一个引导类。运行Spring Boot应用程序有几种方法，包括传统的WAR文件部署。但到目前为止，这里的`main()`方法使你能够从命令行以可执行JAR文件的形式运行你的应用程序。它将`ReadingListApplication`类的引用以及命令行参数传递给`SpringApplication.run()`，以启动应用程序。
- en: 'Even though you haven’t written any application code, you can still build the
    application at this point and try it out. The easiest way to build and run the
    application is to use the `bootRun` task with Gradle:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你没有编写任何应用程序代码，你仍然可以在这一点上构建应用程序并尝试它。构建和运行应用程序的最简单方法是使用Gradle的`bootRun`任务：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `bootRun` task comes from Spring Boot’s Gradle plugin. Alternatively, you
    can build the project with Gradle and run it with Java at the command line:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`bootRun`任务来自Spring Boot的Gradle插件。或者，你也可以使用Gradle构建项目，并在命令行中用Java运行它：'
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The application should start up fine and enable a Tomcat server listening on
    port 8080\. You can point your browser at http://localhost:8080 if you want, but
    because you haven’t written a controller class yet, you’ll be met with an HTTP
    404 (Not Found) error and an error page. Before this appendix is finished, though,
    that URL will serve your reading-list application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序应该可以正常运行并启用监听8080端口的Tomcat服务器。如果你想的话，可以将浏览器指向http://localhost:8080，但由于你还没有编写控制器类，你将遇到HTTP
    404（未找到）错误和错误页面。然而，在附录完成之前，这个URL将为你提供阅读列表应用程序。
- en: You’ll almost never need to change ReadingListApplication.java. If your application
    requires any additional Spring configuration beyond what Spring Boot autoconfiguration
    provides, it’s usually best to write it into separate `@Configuration`-configured
    classes. (They’ll be picked up and used by component scanning.) In exceptionally
    simple cases, though, you could add custom configuration to ReadingListApplication.java.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎永远不会需要修改ReadingListApplication.java。如果你的应用程序需要任何超出Spring Boot自动配置提供的Spring配置，通常最好将其写入单独的`@Configuration`配置类中。（它们将通过组件扫描被拾取和使用。）然而，在极其简单的情况下，你也可以将自定义配置添加到ReadingListApplication.java中。
- en: Testing Spring Boot applications
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试Spring Boot应用程序
- en: The Initializr also gives you a skeleton test class to help you get started
    with writing tests for your application. But `ReadingListApplicationTests`, shown
    in the following listing, is more than just a placeholder for tests. It also serves
    as an example of how to write tests for Spring Boot applications. `@SpringApplicationConfiguration`
    loads a Spring application context.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Initializr还为你提供了一个骨架测试类，帮助你开始编写应用程序的测试。但是，如以下列表所示，`ReadingListApplicationTests`不仅仅是一个测试的占位符。它还作为如何编写Spring
    Boot应用程序测试的示例。`@SpringApplicationConfiguration`加载Spring应用程序上下文。
- en: Listing 2\. `ReadingListApplicationTests`
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2. `ReadingListApplicationTests`
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1*** Load context via Spring Boot.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 通过Spring Boot加载上下文。'
- en: '***2*** Test that the context loads.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 测试上下文是否加载。'
- en: In a typical Spring integration test, you’d annotate the test class with `@ContextConfiguration`
    to specify how the test should load the Spring application context. But in order
    to take full advantage of Spring Boot magic, the `@SpringApplicationConfiguration`
    annotation should be used instead. As you can see in [listing 2](#appex02), `ReadingListApplicationTests`
    is annotated with `@SpringApplicationConfiguration` to load the Spring application
    context from the `ReadingListApplication` configuration class.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的 Spring 集成测试中，您会使用 `@ContextConfiguration` 注解来注解测试类，以指定测试应该如何加载 Spring 应用程序上下文。但为了充分利用
    Spring Boot 的魔法，应使用 `@SpringApplicationConfiguration` 注解。正如您在[列表 2](#appex02)中可以看到的，`ReadingListApplicationTests`
    使用了 `@SpringApplicationConfiguration` 注解来从 `ReadingListApplication` 配置类加载 Spring
    应用程序上下文。
- en: '`ReadingListApplicationTests` also includes one simple test method, `contextLoads()`.
    It’s so simple, in fact, that it’s an empty method. But it’s sufficient for the
    purpose of verifying that the application context loads without any problems.
    If the configuration defined in `ReadingListApplication` is good, the test will
    pass. If any problems exist, the test will fail.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadingListApplicationTests` 还包括一个简单的测试方法 `contextLoads()`。实际上，它是一个空方法。但这对验证应用程序上下文在没有任何问题的情况下加载是足够的。如果
    `ReadingListApplication` 中定义的配置良好，测试将通过。如果存在任何问题，测试将失败。'
- en: You’ll add some of your own tests as we flesh out the application. But the `contextLoads()`
    method is a fine start and verifies every bit of functionality provided by the
    application at this point.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们完善应用程序，您将添加一些自己的测试。但 `contextLoads()` 方法是一个不错的起点，并验证了应用程序在此阶段提供的所有功能。
- en: Configuring application properties
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配置应用程序属性
- en: The application.properties file given to you by the Initializr is initially
    empty. This file is optional, so you could remove it completely without impacting
    the application. But there’s also no harm in leaving it in place.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Initializr 给您的 application.properties 文件最初是空的。此文件是可选的，因此您可以完全删除它而不会影响应用程序。但将其保留也没有任何害处。
- en: 'You’ll definitely find opportunity to add entries to application.properties
    later. For now, however, if you want to poke around with application.properties,
    try adding the following line:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您肯定会在以后有机会向 application.properties 中添加条目。目前，如果您想对 application.properties 进行探索，请尝试添加以下行：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With this line, you’re configuring the embedded Tomcat server to listen on port
    8000 instead of the default port 8080\. You can confirm this by running the application
    again.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一行，您正在配置嵌入的 Tomcat 服务器监听 8000 端口，而不是默认的 8080 端口。您可以通过再次运行应用程序来确认这一点。
- en: This demonstrates that the application.properties file comes in handy for fine-grained
    configuration of the stuff that Spring Boot automatically configures. But you
    can also use it to specify properties used by application code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明，application.properties 文件对于对 Spring Boot 自动配置的内容进行细粒度配置非常有用。但您也可以用它来指定应用程序代码使用的属性。
- en: The main thing to notice is that at no point do you explicitly ask Spring Boot
    to load application.properties for you. By virtue of the fact that application.properties
    exists, it will be loaded and its properties made available for configuring both
    Spring and application code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的主要一点是，您从未明确要求 Spring Boot 为您加载 application.properties。由于 application.properties
    存在，它将被加载，并且其属性将可用于配置 Spring 和应用程序代码。
- en: Spring Boot starter dependencies
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Spring Boot 启动器依赖项
- en: This section provides information about the Spring Boot starters and how they’re
    used.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了有关 Spring Boot 启动器及其使用的信息。
- en: Using starter dependencies
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用启动器依赖项
- en: To understand the benefit of Spring Boot starter dependencies, let’s pretend
    that they don’t exist. What kind of dependencies would you add to your build without
    Spring Boot? Which Spring dependencies do you need in order to support Spring
    MVC? Do you remember the group and artifact IDs for Thymeleaf, or any external
    dependency? Which version of Spring Data JPA should you use? Are all of these
    compatible?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 Spring Boot 启动器依赖项的好处，让我们假设它们不存在。如果没有 Spring Boot，您会在构建中添加哪些依赖项？为了支持 Spring
    MVC，您需要哪些 Spring 依赖项？您还记得 Thymeleaf 的组和工件 ID，或者任何外部依赖项吗？您应该使用哪个版本的 Spring Data
    JPA？所有这些是否兼容？
- en: Uh-oh. Without Spring Boot starter dependencies, you have some homework to do.
    All you want to do is develop a Spring web application with Thymeleaf views that
    persists its data via JPA. But before you can even write your first line of code,
    you have to figure out what needs to be put into the build specification to support
    your plan.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀。没有 Spring Boot 启动器依赖项，你有一些作业要做。你想要的只是开发一个使用 Thymeleaf 视图的 Spring 网络应用程序，并通过
    JPA 持久化其数据。但在你能够写下第一行代码之前，你必须弄清楚需要在构建规范中放入什么来支持你的计划。
- en: 'After much consideration (and probably a lot of copy-and-paste from another
    application’s build that has similar dependencies), you arrive at the following
    dependencies block in your Gradle build specification:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 经过深思熟虑（可能还从具有类似依赖项的另一个应用程序的构建中复制粘贴了很多），你最终在你的 Gradle 构建规范中得到了以下依赖项块：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This dependency list is fine and might even work. But how do you know? What
    kind of assurance do you have that the versions you chose for those dependencies
    are even compatible with each other? They might be, but you won’t know until you
    build the application and run it. And how do you know that the list of dependencies
    is complete? With not a single line of code having been written, you’re still
    a long way from kicking the tires on your build.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个依赖项列表是好的，甚至可能工作。但你怎么知道呢？你选择的那些依赖项的版本是否甚至彼此兼容？它们可能兼容，但你不会知道，直到你构建并运行应用程序。而且你怎么知道依赖项列表是完整的呢？在没有写下一行代码的情况下，你离测试你的构建还有很长的路要走。
- en: 'Let’s step back and recall what it is you want to do. You’re looking to build
    an application with these traits:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们退一步，回顾一下你想要做什么。你正在寻找具有以下特性的应用程序：
- en: It’s a web application.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个网络应用程序。
- en: It uses Thymeleaf.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用 Thymeleaf。
- en: It persists data to a relational database via Spring Data JPA.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过 Spring Data JPA 将数据持久化到关系型数据库。
- en: Wouldn’t it be simpler if you could specify those facts in the build and let
    the build sort out what you need? That’s exactly what Spring Boot starter dependencies
    do.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能在构建中指定这些事实，让构建整理出你需要的东西，那会简单得多吗？这正是 Spring Boot 启动器依赖项所做的。
- en: Specifying facet-based dependencies
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 指定基于功能的依赖项
- en: Spring Boot addresses project dependency complexity by providing several dozen
    starter dependencies. A *starter dependency* is essentially a Maven POM that defines
    transitive dependencies on other libraries that together provide support for a
    certain functionality. Many of these starter dependencies are named to indicate
    the facet or kind of functionality they provide.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 通过提供几十个启动器依赖项来解决项目依赖项复杂性。*启动器依赖项*本质上是一个 Maven POM，它定义了对其他库的传递依赖，这些库共同提供对特定功能的支持。许多这些启动器依赖项的命名是为了表明它们提供的功能面或类型。
- en: For example, the reading-list application is going to be a web application.
    Rather than add several individually chosen library dependencies to the project
    build, it’s much easier to simply declare that this is a web application. You
    can do that by adding Spring Boot’s web starter to the build.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，阅读列表应用程序将是一个网络应用程序。与其向项目构建中添加几个单独选择的库依赖项，不如简单地声明这是一个网络应用程序。你可以通过向构建中添加 Spring
    Boot 的网络启动器来实现这一点。
- en: You also want to use Thymeleaf for web views and persist data with JPA. Therefore,
    you need the Thymeleaf and Spring Data JPA starter dependencies in the build.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你还希望使用 Thymeleaf 进行网络视图，并使用 JPA 持久化数据。因此，你需要在构建中包含 Thymeleaf 和 Spring Data JPA
    启动器依赖项。
- en: For testing purposes, you also want libraries that will enable you to run integration
    tests in the context of Spring Boot. Therefore, you also want a test-time dependency
    on Spring Boot’s test starter.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试目的，你还希望有库，使你能够在 Spring Boot 的上下文中运行集成测试。因此，你还需要对 Spring Boot 的测试启动器的测试时间依赖项。
- en: 'Taken altogether, you have the following five dependencies that the Initializr
    provides in the Gradle build:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，你在 Gradle 构建中拥有 Initializr 提供的以下五个依赖项：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you saw earlier, the easiest way to get these dependencies into your application’s
    build is to select the Web, Thymeleaf, and JPA check boxes in the Initializr.
    But if you didn’t do that when initializing the project, you can certainly go
    back and add them by editing the generated build.gradle or pom.xml.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如你之前所见，将依赖项添加到应用程序构建中最简单的方法是在 Initializr 中选择 Web、Thymeleaf 和 JPA 复选框。但如果你在初始化项目时没有这样做，你当然可以返回并通过编辑生成的
    build.gradle 或 pom.xml 来添加它们。
- en: Via transitive dependencies, adding these four dependencies is the equivalent
    of adding several dozen individual libraries to the build. Some of those transitive
    dependencies include such things as Spring MVC, Spring Data JPA, and Thymeleaf,
    as well as any transitive dependencies that those dependencies declare.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过传递依赖项，添加这四个依赖项相当于向构建中添加了几十个单独的库。其中一些传递依赖项包括Spring MVC、Spring Data JPA和Thymeleaf，以及那些依赖项声明的任何传递依赖项。
- en: The most important thing to notice about the four starter dependencies is that
    they’re only as specific as they need to be. You don’t say that you want Spring
    MVC; you simply say that you want to build a web application. You don’t specify
    JUnit or any other testing tools; you just say that you want to test your code.
    The Thymeleaf and Spring Data JPA starters are a bit more specific, but only because
    there’s no less-specific way to declare that you want Thymeleaf and Spring Data
    JPA. The four starters in this build are only a few of the many starter dependencies
    that Spring Boot offers.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这四个启动器依赖项最重要的注意事项是，它们只具体到需要的程度。你不会说你想要Spring MVC；你只是说你想要构建一个网络应用程序。你不会指定JUnit或其他测试工具；你只是说你想要测试你的代码。Thymeleaf和Spring
    Data JPA启动器稍微具体一些，但这只是因为没有更不具体的方式来声明你想要Thymeleaf和Spring Data JPA。在这个构建中的四个启动器只是Spring
    Boot提供的许多启动器依赖项中的一小部分。
- en: In no case did you need to specify the version. The starter dependencies’ versions
    are determined by which Spring Boot version you’re using. The starter dependencies
    themselves determine the versions of the various transitive dependencies that
    they pull in.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，你都不需要指定版本。启动器依赖项的版本由你使用的Spring Boot版本决定。启动器依赖项本身决定了它们拉入的各种传递依赖项的版本。
- en: Not knowing what versions of the various libraries are used may be a little
    unsettling to you. Be encouraged to know that Spring Boot has been tested to ensure
    that all of the dependencies pulled in are compatible. It can be liberating to
    just specify a starter dependency and not have to worry about which libraries
    and which versions of those libraries you need to maintain.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 未知各种库的版本可能会让你感到有些不安。但请放心，Spring Boot已经经过测试，确保所有拉入的依赖项都是兼容的。只需指定启动器依赖项，而不必担心需要维护哪些库及其版本，这可以是一种解放。
- en: 'But if you must know what you’re getting, you can always discover that from
    the build tool. In the case of Gradle, the `dependencies` task will give you a
    dependency tree that includes every library that your project is using and their
    versions:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你必须知道你得到的是什么，你总是可以从构建工具中找到答案。在Gradle的情况下，`dependencies`任务会给你一个包含你的项目使用的每个库及其版本的依赖项树：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can get a similar dependency tree from a Maven build with the `tree` goal
    of the `dependency` plugin:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过Maven构建的`dependency`插件的`tree`目标获得类似的依赖项树：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For the most part, you should never concern yourself with the specifics of what
    each Spring Boot starter dependency provides. Generally, it’s enough to know that
    the web starter enables you to build a web application, the Thymeleaf starter
    enables you to use Thymeleaf templates, and the Spring Data JPA starter enables
    data persistence to a database by using Spring Data JPA.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你无需关心每个Spring Boot启动器依赖项提供的具体内容。通常，知道网络启动器使你能够构建一个网络应用程序，Thymeleaf启动器使你能够使用Thymeleaf模板，以及Spring
    Data JPA启动器通过使用Spring Data JPA将数据持久化到数据库就足够了。
- en: But what if, in spite of the testing performed by the Spring Boot team, there’s
    a problem with a starter dependency’s choice of libraries? How can you override
    the starter?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果尽管Spring Boot团队进行了测试，选择启动器依赖项的库仍然存在问题，你该如何覆盖启动器？
- en: Overriding starter transitive dependencies
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 覆盖启动器传递依赖项
- en: Ultimately, starter dependencies are just dependencies like any other dependency
    in your build. You can use the facilities of the build tool to selectively override
    transitive dependency versions, exclude transitive dependencies, and certainly
    specify dependencies for libraries not covered by Spring Boot starters.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，启动器依赖项只是构建中与其他依赖项一样的依赖项。你可以使用构建工具的功能来选择性地覆盖传递依赖项的版本、排除传递依赖项，当然也可以指定Spring
    Boot启动器未涵盖的库的依赖项。
- en: For example, consider Spring Boot’s web starter. Among other things, the web
    starter transitively depends on the Jackson JSON library. This library is handy
    if you’re building a REST service that consumes or produces JSON resource representations.
    But if you’re using Spring Boot to build a more traditional human-facing web application,
    you may not need Jackson. Even though including it shouldn’t hurt anything, you
    can trim the fat off of your build by excluding Jackson as a transitive dependency.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑Spring Boot的web启动器。在其他方面，web启动器间接依赖于Jackson JSON库。如果你正在构建一个消费或生成JSON资源表示的REST服务，这个库非常有用。但是，如果你使用Spring
    Boot构建一个更传统的面向人类的Web应用程序，你可能不需要Jackson。即使包含它不会造成任何伤害，你也可以通过排除Jackson作为间接依赖项来减少构建的体积。
- en: 'If you’re using Gradle, you can exclude transitive dependencies like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Gradle，你可以像这样排除间接依赖项：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In Maven, you can exclude transitive dependencies with the `<exclusions>` element.
    The following `<dependency>` for the Spring Boot web starter has `<exclusions>`
    to keep Jackson out of the build:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在Maven中，你可以使用`<exclusions>`元素排除间接依赖项。以下Spring Boot web启动器的`<dependency>`具有`<exclusions>`以排除Jackson：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Conversely, maybe having Jackson in the build is fine, but you want to build
    against a different version of Jackson than what the web starter references. Suppose
    that the web starter references Jackson 2.3.4, but you’d rather use version 2.4.3\.
    Using Maven, you can express the desired dependency directly in your project’s
    pom.xml file like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，也许在构建中包含Jackson是可以的，但你可能想针对web启动器引用的Jackson的不同版本进行构建。假设web启动器引用了Jackson 2.3.4，但你更愿意使用版本2.4.3。使用Maven，你可以在项目的pom.xml文件中直接表达所需的依赖项，如下所示：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Maven always favors the closest dependency, meaning that because you’ve expressed
    this dependency in your project’s build, it’ll be favored over the one that’s
    transitively referred to by another dependency.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Maven总是优先选择最近的依赖项，这意味着由于你在项目构建中表达了此依赖项，它将优先于另一个依赖项间接引用的依赖项。
- en: 'Similarly, if you’re building with Gradle, you can specify the newer version
    of Jackson in your build.gradle file like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果你使用Gradle进行构建，你可以在build.gradle文件中指定Jackson的新版本，如下所示：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This dependency works in Gradle because it’s newer than the version transitively
    referred to by Spring Boot’s web starter. But suppose that instead of using a
    newer version of Jackson, you’d like to use an older version. Unlike Maven, Gradle
    favors the newest version of a dependency. Therefore, if you want to use an older
    version of Jackson, you have to express the older version as a dependency in your
    build and exclude it from being transitively resolved by the web starter dependency:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个依赖项在Gradle中可以工作，因为它比Spring Boot的web启动器间接引用的版本更新。但是，假设你不想使用Jackson的新版本，而想使用旧版本。与Maven不同，Gradle更喜欢依赖项的最新版本。因此，如果你想使用Jackson的旧版本，你必须将旧版本作为依赖项在构建中表达，并排除它被web启动器依赖项间接解析：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In any case, be cautious when overriding the dependencies that are pulled in
    transitively by Spring Boot starter dependencies. Although different versions
    may work fine, a great amount of comfort can be taken from knowing that the versions
    chosen by the starters have been tested to play well together. You should override
    these transitive dependencies only under special circumstances (such as a bug
    fix in a newer version).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，当覆盖由Spring Boot启动器依赖项间接引入的依赖项时，请谨慎行事。尽管不同版本可能运行良好，但了解启动器选择的版本已经过测试，可以很好地协同工作，这会让人感到非常安心。你应该只在特殊情况下（例如，修复较新版本中的错误）覆盖这些间接依赖项。
- en: Now that you have an empty project structure and build specification ready,
    it’s time to start developing the application itself. As you do, you’ll let Spring
    Boot handle the configuration details while you focus on writing the code that
    provides the reading-list functionality.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好了空的项目结构和构建规范，是时候开始开发应用程序本身了。在这个过程中，你将让Spring Boot处理配置细节，而你则专注于编写提供阅读列表功能的代码。
- en: Developing a Spring Boot application
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开发Spring Boot应用程序
- en: In [listing 3](#appex03), you’ll further develop a Spring Boot application,
    with content from section 2.3.1 of *Spring Boot in Action*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表3](#appex03)中，你将进一步开发一个Spring Boot应用程序，内容来自《Spring Boot实战》第2.3.1节。
- en: Focusing on application functionality
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 专注于应用程序功能
- en: One way to gain an appreciation of Spring Boot autoconfiguration would be for
    me to spend the next several pages showing you the configuration that’s required
    in the absence of Spring Boot. But several great books on Spring could show you
    that, and showing it again wouldn’t help you get the reading-list application
    written any quicker.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得对 Spring Boot 自动配置的欣赏，一种方法是我可以在接下来的几页中向您展示在没有 Spring Boot 的情况下所需的配置。但几本关于
    Spring 的优秀书籍可以向您展示这一点，再次展示也不会帮助您更快地编写阅读列表应用程序。
- en: Instead of wasting time talking about Spring configuration, know that Spring
    Boot is going to take care of that for you, so let’s see how taking advantage
    of Spring Boot autoconfiguration keeps you focused on writing application code.
    I can think of no better way to do that than to start writing the application
    code for the reading-list application.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是浪费时间讨论 Spring 配置，请知道 Spring Boot 会为您处理这些，所以让我们看看如何利用 Spring Boot 自动配置来让您专注于编写应用程序代码。我想不出比开始编写阅读列表应用程序的代码更好的方法了。
- en: Defining the domain
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义领域
- en: The central domain concept in your application is a book that’s on a reader’s
    reading list. Therefore, you’ll need to define an entity class that represents
    a book. [Listing 3](#appex03) shows how the `Book` type is defined.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您应用程序的核心领域概念是读者阅读列表中的一本书。因此，您需要定义一个表示书的实体类。[列表 3](#appex03) 展示了如何定义 `Book` 类型。
- en: Listing 3\. The `Book` class
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3\. `Book` 类
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, the `Book` class is a simple Java object with a handful of properties
    describing a book and the necessary accessor methods. It’s annotated with `@Entity`
    designating it as a JPA entity. The `id` property is annotated with `@Id` and
    `@GeneratedValue` to indicate that this field is the entity’s identity and that
    its value will be automatically provided.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Book` 类是一个简单的 Java 对象，具有一些属性来描述一本书以及必要的访问器方法。它被注解为 `@Entity`，表明它是一个 JPA
    实体。`id` 属性被注解为 `@Id` 和 `@GeneratedValue`，以表明该字段是实体的标识符，并且其值将自动提供。
- en: Defining the repository interface
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义存储库接口
- en: 'Next you need to define the repository through which the `ReadingList` objects
    will be persisted to the database. Because you’re using Spring Data JPA, that
    task is a simple matter of creating an interface that extends Spring Data JPA’s
    `JpaRepository` interface:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要定义一个存储库，通过该存储库将 `ReadingList` 对象持久化到数据库。由于您正在使用 Spring Data JPA，这项任务只是创建一个扩展
    Spring Data JPA 的 `JpaRepository` 接口的接口：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'By extending `JpaRepository`, `ReadingListRepository` inherits 18 methods for
    performing common persistence operations. The `JpaRepository` interface is parameterized
    with two parameters: the domain type that the repository will work with, and the
    type of its ID property. In addition, I’ve added a `findByReader()` method through
    which a reading list can be looked up, given a reader’s username.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展 `JpaRepository`，`ReadingListRepository` 继承了 18 个用于执行常见持久化操作的方法。`JpaRepository`
    接口使用两个参数进行参数化：存储库将与之工作的领域类型以及其 ID 属性的类型。此外，我还添加了一个 `findByReader()` 方法，可以通过读者的用户名来查找阅读列表。
- en: If you’re wondering about who will implement `ReadingListRepository` and the
    18 methods it inherits, don’t worry too much about it. Spring Data provides a
    special magic of its own, making it possible to define a repository with just
    an interface. The interface will be implemented automatically at runtime when
    the application is started.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道谁将实现 `ReadingListRepository` 及其继承的 18 个方法，不必过于担心。Spring Data 提供了自己的特殊魔法，使得只需定义一个接口就可以定义存储库。当应用程序启动时，该接口将在运行时自动实现。
- en: Creating the web interface
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建网络界面
- en: Now that you’ve defined the application’s domain and have a repository for persisting
    objects from that domain to the database, all that’s left is to create the web
    frontend. A Spring MVC controller like the one in the following listing will handle
    HTTP requests for the application.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经定义了应用程序的领域，并且有一个用于将领域对象持久化到数据库的存储库，剩下要做的就是创建网络前端。以下列表中的 Spring MVC 控制器将处理应用程序的
    HTTP 请求。
- en: Listing 4\. `ReadingListController`
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4\. `ReadingListController`
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`ReadingListController` is annotated with `@Controller` in order to be picked
    up by component scanning and automatically registered as a bean in the Spring
    application context. It’s also annotated with `@RequestMapping` to map all of
    its handler methods to a base URL path of “/”.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadingListController` 被注解为 `@Controller`，以便被组件扫描并自动注册为 Spring 应用程序上下文中的一个
    bean。它还被注解为 `@RequestMapping`，将所有处理方法映射到基本 URL 路径 “/”。'
- en: 'The controller has two methods:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器有两个方法：
- en: '`readersBooks()`—Handles HTTP `GET` requests for /{reader} by retrieving a
    `Book` list from the repository (which was injected into the controller’s constructor)
    for the reader specified in the path. It puts the list of `Book` into the model
    under the key `books` and returns `readingList` as the logical name of the view
    to render the model.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readersBooks()`——通过从仓库（它被注入到控制器的构造函数中）检索指定路径中的读者的`Book`列表来处理针对/{reader}的HTTP
    `GET`请求。它将`Book`列表放入模型中的`books`键下，并以`readingList`作为要渲染模型的视图的逻辑名称返回。'
- en: '`addToReadingList()`—Handles HTTP `POST` requests for /{reader}, binding the
    data in the body of the request to a `Book` object. This method sets the `Book`
    object’s `reader` property to the reader’s name, and then saves the modified `Book`
    via the repository’s `save()` method. Finally, it returns by specifying a redirect
    to /{reader} (which will be handled by the other controller method).'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addToReadingList()`——处理针对/{reader}的HTTP `POST`请求，将请求体中的数据绑定到一个`Book`对象上。此方法将`Book`对象的`reader`属性设置为读者的名字，然后通过仓库的`save()`方法保存修改后的`Book`。最后，通过指定重定向到/{reader}（将由其他控制器方法处理）来返回。'
- en: The `readersBooks()` method concludes by returning `readingList` as the logical
    view name. Therefore, you must also create that view. I decided at the outset
    of this project that we’d be using Thymeleaf to define the application views,
    so the next step is to create a file named readingList.html in src/main/resources/templates
    with the following content.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`readersBooks()`方法通过返回`readingList`作为逻辑视图名称来结束。因此，你也必须创建那个视图。我在这个项目的开始时就决定我们会使用Thymeleaf来定义应用程序视图，所以下一步是在src/main/resources/templates中创建一个名为readingList.html的文件，内容如下。'
- en: Listing 5\. readingList.html
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5\. readingList.html
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This template defines an HTML page that is conceptually divided into two parts.
    At the top of the page is a list of books that are in the reader’s reading list.
    At the bottom is a form that the reader can use to add a new book to the reading
    list.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板定义了一个HTML页面，从概念上分为两部分。页面的顶部是读者阅读列表中的书籍列表。底部是一个读者可以使用它来添加新书到阅读列表的表单。
- en: 'For aesthetic purposes, the Thymeleaf template references a stylesheet named
    style.css. That file should be created in src/main/resources/static and look like
    this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了美观，Thymeleaf模板引用了一个名为style.css的样式表。该文件应创建在src/main/resources/static中，如下所示：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This stylesheet is simple and doesn’t go overboard to make the application look
    nice. But it serves our purposes and, as you’ll soon see, serves to demonstrate
    a piece of Spring Boot’s autoconfiguration.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个样式表很简单，并没有过度设计以使应用程序看起来很漂亮。但它满足了我们的需求，正如你很快就会看到的，它还用来演示Spring Boot的自动配置功能。
- en: Believe it or not, that’s a complete application. Every single line has been
    presented to you in this appendix. Flip back through the previous pages, and see
    if you can find any configuration. Aside from the three lines of configuration
    in [listing 1](#appex01) (which turns on autoconfiguration), you didn’t have to
    write any Spring configuration.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，这是一个完整的应用程序。附录中已经向你展示了每一行代码。翻回前面的页面，看看你是否能找到任何配置。除了[列表1](#appex01)中的三行配置（它启用了自动配置）之外，你不需要编写任何Spring配置。
- en: Despite the lack of Spring configuration, this complete Spring application is
    ready to run. Let’s fire it up and see how it looks.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管没有Spring配置，但这个完整的Spring应用程序已经准备好运行。让我们启动它，看看它的样子。
- en: Spring Boot testing
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Spring Boot测试
- en: This section provides information about testing with Spring Boot, by mocking
    parts of Spring MVC. This section contains content from section 4.2.1 of *Spring
    Boot in Action*.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了有关使用Spring Boot进行测试的信息，通过模拟Spring MVC的部分。本节包含来自*Spring Boot实战*第4.2.1节的内容。
- en: Mocking Spring MVC
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模拟Spring MVC
- en: Since Spring 3.2, the Spring Framework has had a useful facility for testing
    web applications by mocking Spring MVC. This makes it possible to perform HTTP
    requests against a controller without running the controller within an actual
    servlet container. Instead, Spring’s Mock MVC framework mocks enough of Spring
    MVC to make it almost as though the application is running within a servlet container—but
    it’s not.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 自Spring 3.2以来，Spring框架已经有一个有用的功能，可以通过模拟Spring MVC来测试Web应用程序。这使得可以在不运行实际servlet容器中的控制器的情况下对控制器执行HTTP请求。相反，Spring的Mock
    MVC框架模拟了足够的Spring MVC，使得应用程序几乎就像在servlet容器中运行一样——但它并不是。
- en: 'To set up a Mock MVC in your test, you can use `MockMvcBuilders`. This class
    offers two static methods:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的测试中设置Mock MVC，你可以使用`MockMvcBuilders`。这个类提供了两个静态方法：
- en: '`standaloneSetup()`—Builds a Mock MVC to serve one or more manually created
    and configured controllers'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`standaloneSetup()`—构建一个 Mock MVC 来服务于一个或多个手动创建和配置的控制台'
- en: '`webAppContextSetup()`—Builds a Mock MVC using a Spring application context,
    which presumably includes one or more configured controllers'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`webAppContextSetup()`—使用 Spring 应用程序上下文构建一个 Mock MVC，该上下文可能包括一个或多个配置好的控制台'
- en: The primary difference between these two options is that `standaloneSetup()`
    expects you to manually instantiate and inject the controllers you want to test,
    whereas `webAppContextSetup()` works from an instance of `WebApplicationContext`,
    which itself was probably loaded by Spring. The former is slightly more akin to
    a unit test in that you’ll likely use it only for focused tests around a single
    controller. The latter, however, lets Spring load your controllers as well as
    their dependencies for a full-blown integration test.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个选项之间的主要区别在于，`standaloneSetup()` 预期您手动实例化和注入您想要测试的控制台，而 `webAppContextSetup()`
    则从一个 `WebApplicationContext` 的实例开始工作，这个实例本身可能是由 Spring 加载的。前者在某种程度上更类似于单元测试，您可能会仅针对单个控制台进行聚焦测试。然而，后者允许
    Spring 加载您的控制台以及它们的依赖项，以进行全面的集成测试。
- en: For our purposes, you’re going to use `webAppContextSetup()` so you can test
    the `ReadingListController` as it has been instantiated and injected from the
    application context that Spring Boot has autoconfigured.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们的目的，您将使用 `webAppContextSetup()`，这样您就可以测试 `ReadingListController`，因为它已经被实例化并从
    Spring Boot 自动配置的应用程序上下文中注入。
- en: The `webAppContextSetup()` takes a `WebApplicationContext` as an argument. Therefore,
    you need to annotate the test class with `@WebAppConfiguration` and use `@Autowired`
    to inject the `WebApplicationContext` into the test as an instance variable. This
    listing shows the starting point for your Mock MVC tests.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`webAppContextSetup()` 接收一个 `WebApplicationContext` 作为参数。因此，您需要使用 `@WebAppConfiguration`
    注解测试类，并使用 `@Autowired` 将 `WebApplicationContext` 注入到测试中作为一个实例变量。此列表显示了您的 Mock
    MVC 测试的起点。'
- en: Listing 6\. `MockMvcWebTests`
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6\. `MockMvcWebTests`
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1*** Enables web context testing'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 启用 web 上下文测试'
- en: '***2*** Injects WebApplicationContext'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 注入 WebApplicationContext'
- en: '***3*** Sets up MockMvc'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 设置 MockMvc'
- en: The `@WebAppConfiguration` annotation declares that the application context
    created by `SpringJUnit4ClassRunner` should be a `WebApplicationContext` (as opposed
    to a basic non-web `ApplicationContext`).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`@WebAppConfiguration` 注解声明由 `SpringJUnit4ClassRunner` 创建的应用程序上下文应该是一个 `WebApplicationContext`（而不是基本非
    Web 的 `ApplicationContext`）。'
- en: The `setupMockMvc()` method is annotated with JUnit’s `@Before`, indicating
    that it should be executed before any test methods. It passes the injected `WebApplicationContext`
    into the `webAppContextSetup()` method and then calls `build()` to produce a `MockMvc`
    instance, which is assigned to an instance variable for test methods to use.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`setupMockMvc()` 方法被 JUnit 的 `@Before` 注解标记，表示它应该在任何测试方法之前执行。它将注入的 `WebApplicationContext`
    传递给 `webAppContextSetup()` 方法，然后调用 `build()` 来生成一个 `MockMvc` 实例，并将其分配给实例变量以供测试方法使用。'
- en: 'Now that you have `MockMvc`, you’re ready to write test methods. Let’s start
    with a simple test method that performs an HTTP `GET` request against /readingList
    and asserts that the model and view meet your expectations. The following `homePage()`
    test method does what you need:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您有了 `MockMvc`，您就可以编写测试方法了。让我们从一个简单的测试方法开始，该方法对 /readingList 执行 HTTP `GET`
    请求，并断言模型和视图符合您的期望。以下 `homePage()` 测试方法就是您需要的：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As you can see, a lot of static methods are being used in this test method,
    including static methods from Spring’s `MockMvcRequestBuilders` and `MockMvcResultMatchers`,
    as well as from the Hamcrest library’s `Matchers`. Before diving into the details
    of this test method, let’s add a few static imports so that the code is easier
    to read:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在这个测试方法中使用了大量的静态方法，包括来自 Spring 的 `MockMvcRequestBuilders` 和 `MockMvcResultMatchers`
    的静态方法，以及来自 Hamcrest 库的 `Matchers`。在深入探讨这个测试方法的细节之前，让我们添加一些静态导入，以便代码更容易阅读：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'With those static imports in place, the test method can be rewritten like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置了这些静态导入之后，测试方法可以重写如下：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now the test method almost reads naturally. First it performs a `GET` request
    against /readingList. Then it expects that the request is successful (`isOk()`
    asserts an HTTP 200 response code) and that the view has a logical name of `readingList`.
    It also asserts that the model contains an attribute named `books`, but that attribute
    is an empty collection. It’s all straightforward.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试方法几乎读起来很自然。首先，它对/readingList执行一个`GET`请求。然后它期望请求成功（`isOk()`断言HTTP 200响应码）并且视图有一个逻辑名称为`readingList`。它还断言模型包含一个名为`books`的属性，但该属性是一个空集合。这一切都很直接。
- en: The main thing to note is that at no time is the application deployed to a web
    server. Instead it’s run within a mocked-out Spring MVC, just capable enough to
    handle the HTTP requests you throw at it via the `MockMvc` instance.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的主要一点是，应用程序从未部署到Web服务器。相反，它在模拟的Spring MVC中运行，足以处理通过`MockMvc`实例抛给它的HTTP请求。
- en: Pretty cool, huh? Let’s try one more test method. This time you’ll make it a
    bit more interesting by sending an HTTP `POST` request to post a new book. You
    should expect that after the `POST` request is handled, the request will be redirected
    back to /readingList and that the `books` attribute in the model will contain
    the newly added book. The following listing shows how to use Spring’s Mock MVC
    to do this kind of test.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 真的很酷，对吧？让我们再试一个测试方法。这次你将通过向新书籍发送HTTP `POST`请求来让它更有趣。你应该期望在`POST`请求处理完毕后，请求将被重定向回/readingList，并且模型中的`books`属性将包含新添加的书籍。以下列表显示了如何使用Spring的Mock
    MVC进行此类测试。
- en: Listing 7\. `MockMvcWebTests`
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7. `MockMvcWebTests`
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1*** Performs POST request'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 执行POST请求'
- en: '***2*** Sets up expected book'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 设置预期书籍'
- en: '***3*** Performs GET request'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 执行GET请求'
- en: This test is a bit more involved; it’s two tests in one method. The first part
    posts the book and asserts the results from that request. The second part performs
    a fresh `GET` request against the homepage and asserts that the newly created
    book is in the model.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试稍微复杂一些；它是一个方法中的两个测试。第一部分发布书籍并断言该请求的结果。第二部分对主页执行一个新的`GET`请求并断言新创建的书籍在模型中。
- en: When posting the book, you must make sure that you set the content type to `application/x-www-form-urlencoded`
    (with `MediaType.APPLICATION_FORM_URLENCODED`) because that’s the content type
    that a browser will send when the book is posted in the running application. You
    then use the `MockMvcRequestBuilders's param()` method to set the fields that
    simulate the form being submitted. After the request has been performed, you assert
    that the response is a redirect to /readingList.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布书籍时，你必须确保将内容类型设置为`application/x-www-form-urlencoded`（使用`MediaType.APPLICATION_FORM_URLENCODED`），因为当书籍在运行的应用程序中发布时，浏览器将发送这种内容类型。然后你使用`MockMvcRequestBuilders's
    param()`方法设置模拟提交的表单字段。请求执行后，你断言响应是重定向到/readingList。
- en: Assuming that much of the test method passes, you move on to [part 2](kindle_split_015.xhtml#part02).
    First, you set up a `Book` object that contains the expected values. You’ll use
    this to compare with the value that’s in the model after fetching the homepage.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 假设测试方法的大部分都通过了，你继续到[第二部分](kindle_split_015.xhtml#part02)。首先，你设置一个包含预期值的`Book`对象。你将使用这个对象与获取主页后模型中的值进行比较。
- en: Then you perform a `GET` request for /readingList. For the most part, this is
    no different from the way you tested the homepage before, except that instead
    of an empty collection in the model, you’re checking that it has one item, and
    that the item is the same as the expected `Book` you created. If so, then your
    controller seems to be doing its job of saving a book when one is posted to it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你对/readingList执行一个`GET`请求。大部分情况下，这与之前测试主页的方式没有不同，只是你检查模型中有一个项目，并且该项目与预期的`Book`相同。如果是这样，那么你的控制器似乎在将书籍发布给它时完成了保存书籍的工作。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Select content from *Spring Boot in Action* covered additional details on developing
    microservices with Spring Boot.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 *Spring Boot实战* 中选择的内容涵盖了使用Spring Boot开发微服务的更多细节。
- en: Further details on developing Spring Boot microservices can be found in *Spring
    Boot in Action* ([www.manning.com/books/spring-boot-in-action](http://www.manning.com/books/spring-boot-in-action)).
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *Spring Boot实战*（[www.manning.com/books/spring-boot-in-action](http://www.manning.com/books/spring-boot-in-action)）中可以找到关于开发Spring
    Boot微服务的更多细节。
