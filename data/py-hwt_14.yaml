- en: 10 Fundamentals of objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 对象的基础知识
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Inspecting objects
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查对象
- en: Illustrating an object’s lifecycle
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示一个对象的生命周期
- en: Copying an object
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制一个对象
- en: 'Resolving a variable: the LEGB rule'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决变量：LEGB规则
- en: Understanding an object’s callability
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解对象的调用性
- en: Objects are everywhere in Python, as Python is an object-oriented programming
    (OOP) language by design. We work with objects constantly in our applications.
    Thus, it’s important to know the fundamentals of using objects, particularly instance
    objects of a custom class, as they’re the most prevalent data model in applications.
    In a function, for example, we expect that users may send different types of data,
    and we can add this flexibility by handling applicable data types accordingly.
    As another example, copying an object is necessary when we have a working copy
    to update while keeping the original object intact in case we need to revert our
    update. In this chapter, I’ll cover the fundamentals of objects. Certainly, this
    chapter isn’t intended to be exhaustive, as everything is an object in Python,
    and I can’t cover all the aspects of how objects are used. Another thing to note
    is that some sections address a specific problem (section 10.4, for example, is
    about changing a variable in a different scope), but I’ll use addressing the specific
    problem to cover a more general topic (such as the variable lookup order).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，对象无处不在，因为Python是一种设计上就是面向对象编程（OOP）的语言。我们在应用程序中不断与对象打交道。因此，了解使用对象的基本知识非常重要，尤其是自定义类的实例对象，因为它们是应用程序中最普遍的数据模型。例如，在一个函数中，我们期望用户可能发送不同类型的数据，我们可以通过相应地处理适用的数据类型来增加这种灵活性。作为另一个例子，当我们有一个工作副本需要更新，同时保持原始对象完整以便在需要撤销更新时使用时，复制一个对象是必要的。在本章中，我将介绍对象的基础知识。当然，本章并不旨在详尽无遗，因为Python中的一切都是对象，我无法涵盖对象使用的所有方面。另外，要注意的是，一些部分针对特定问题（例如第10.4节是关于在不同作用域中更改变量），但我会通过解决特定问题来涵盖更一般的话题（例如变量的查找顺序）。
- en: 10.1 How do I inspect an object’s type to improve code flexibility?
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 我如何检查一个对象类型以改进代码的灵活性？
- en: 'We always work with a variety of objects, such as functions, classes, and instances.
    Let’s use custom functions as an example. Most of our coding work involves writing
    functions: defining the input, performing the operations, and providing the output.
    A function’s input usually has a specific type requirement; accordingly, users
    must use one specific type of data to call a function. Consider the following
    function, which filters the list of tasks (the tasks argument) based on their
    urgencies in our task management app:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是与各种对象打交道，例如函数、类和实例。让我们以自定义函数为例。我们的大部分编码工作都涉及编写函数：定义输入、执行操作和提供输出。函数的输入通常具有特定的类型要求；相应地，用户必须使用一种特定类型的数据来调用函数。考虑以下函数，它根据我们在任务管理应用程序中的任务紧急程度来过滤任务列表（任务参数）：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Our first thought may be that the by_urgency argument should be an integer,
    such as 4 and 5 as possible arguments. Thus, the function may have the following
    implementation:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一反应可能是by_urgency参数应该是一个整数，例如4和5作为可能的参数。因此，函数可能有以下实现：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Reminder To use this function, you need to create the Task class (chapter 8)
    and create some instances to be used as the tasks argument.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒：使用此功能，您需要创建任务类（第8章）并创建一些实例作为任务参数。
- en: 'In the function’s body, we use a list comprehension to select the tasks whose
    urgency level matches that supplied by the by_urgency argument. It’s entirely
    plausible, however, to have a feature that allows users to filter tasks with multiple
    urgency levels like this: filter_tasks([4, 5]). For this feature, the function
    should have the following implementation instead:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体中，我们使用列表推导来选择与by_urgency参数提供的紧急程度匹配的任务。然而，完全有可能有一个允许用户使用这种方式过滤具有多个紧急程度的任务的特性：filter_tasks([4,
    5])。为此特性，函数应该有以下的实现：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Instead of comparing the integer values, now we use item in list to check whether
    a task’s urgency level is in the provided urgency values.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是比较整数值，现在我们使用列表中的项来检查任务的紧急程度是否在提供的紧急程度值中。
- en: To accommodate these two cases, we should have a mechanism to check the by_urgency
    argument and filter the tasks accordingly. This form of checking an object’s type
    is an example of object *introspection*—inspecting an object to find out its characteristics,
    such as type, attributes, and methods. In this section, we’ll review the key techniques
    of object introspection and their use scenarios with a primary focus on improving
    code flexibility. Using the filter_tasks function as our work subject, we’ll write
    a single function that can take different kinds of input.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应这两种情况，我们应该有一个机制来检查 `by_urgency` 参数并相应地过滤任务。这种检查对象类型的方式是对象 *自省* 的一个例子——检查对象以找出其特征，例如类型、属性和方法。在本节中，我们将回顾对象自省的关键技术及其使用场景，主要关注提高代码的灵活性。以
    `filter_tasks` 函数作为我们的工作对象，我们将编写一个可以接受不同类型输入的单个函数。
- en: Concept *Introspection* is the act of examining an object’s type or properties,
    such as attributes, during the execution of the program.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 概念 *自省* 是在程序执行过程中检查对象的类型或属性，如属性的行为。
- en: 10.1.1 Checking an object’s type using type
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.1 使用 `type` 检查对象类型
- en: In the code example in section 10.1, to provide flexibility in handling an int
    or a list as an argument in the filter_tasks function, we need to check the argument’s
    type. In this section, we’ll see what built-in functions we can use to check an
    object’s type.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 10.1 节的代码示例中，为了在 `filter_tasks` 函数中处理整数或列表作为参数的灵活性，我们需要检查参数的类型。在本节中，我们将看到我们可以使用哪些内置函数来检查对象类型。
- en: 'The first function that may come to your mind is type. Calling type on an object
    returns its type, and you’ve seen this usage several times. The following code
    snippet shows some examples as a quick refresher:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能首先想到的函数是 `type`。对一个对象调用 `type` 返回其类型，你已经在几个地方看到过这种用法。以下代码片段展示了几个例子，作为快速复习：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As expected, 4 has a type of int, and [4, 5] has a type of list. We know how
    to obtain an object’s type information, so the next question to ask is how we
    can compare the type of an object against the desired type. If you overthink the
    comparison, you may not get the answer, which is to compare the object’s type
    with the class:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，数字 4 的类型是 `int`，而 `[4, 5]` 的类型是 `list`。我们知道如何获取一个对象类型的信息，所以接下来要问的问题是，我们如何将对象的类型与期望的类型进行比较。如果你过度思考比较的问题，可能得不到答案，答案是：将对象的类型与类进行比较：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: QUESTION When you compare two objects, are == and is the same?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：当你比较两个对象时，`==` 和 `is` 是否相同？
- en: 'Based on these comparisons, we can now update the filter_tasks function to
    handle both calling scenarios, as shown in the next listing. Please note that
    we simplify the condition by assuming that there are only two possibilities for
    the by_urgency argument: int and list.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些比较，我们现在可以更新 `filter_tasks` 函数以处理两种调用场景，如下一列表所示。请注意，我们通过假设 `by_urgency` 参数只有两种可能性：整数和列表来简化条件。
- en: Listing 10.1 Comparing an object’s type with a class
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.1 比较对象类型与类
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As shown in this listing, when by_urgency is a list, we check the presence of
    the urgency in the list, and when by_urgency is an int, we compare each task’s
    urgency level with the number.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如此列表所示，当 `by_urgency` 是一个列表时，我们检查列表中是否存在紧迫性，而当 `by_urgency` 是一个整数时，我们比较每个任务的紧迫级别与数字。
- en: 10.1.2 Checking an object’s type using isinstance
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.2 使用 `isinstance` 检查对象类型
- en: Another useful introspection function is isinstance, which checks whether an
    object is an instance of the specified class. As you’ll see in this section, isinstance
    does a similar job to type, but it’s the preferred approach for checking an object’s
    type.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的自省函数是 `isinstance`，它检查一个对象是否是特定类的实例。正如你将在本节中看到的，`isinstance` 与 `type`
    执行类似的工作，但它是检查对象类型的首选方法。
- en: 'When you learned about creating proper docstrings for a function (section 6.5),
    you used help on the isinstance function, but I didn’t expand the discussion of
    its usage. Now it’s time to learn formally what we can do with isinstance:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当你学习为函数创建适当的文档字符串（第 6.5 节）时，你使用了 `isinstance` 函数的帮助，但我没有扩展其用法的讨论。现在是我们正式学习我们可以使用
    `isinstance` 做些什么的时候了：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first argument is the object, and the second argument is the specific class.
    In fact, the second argument can also be a tuple of classes, allowing you to check
    an object flexibly against multiple classes. Observe this feature:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是对象，第二个参数是特定的类。实际上，第二个参数也可以是类的元组，这允许你灵活地检查对象与多个类。观察这个特性：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If your function takes either list or tuple, for example, you can combine the
    test in a single isinstance call, as shown in the preceding code snippet. Note
    that the relationship between these classes is equivalent to an “or” evaluation:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的函数接受列表或元组，例如，你可以在单个 `isinstance` 调用中组合测试，如前面的代码片段所示。请注意，这些类之间的关系相当于一个“或”评估：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using the isinstance function, we can update the filter_tasks function to handle
    by_urgency as int or list, as the following listing shows.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `isinstance` 函数，我们可以将 `filter_tasks` 函数更新为可以处理 `by_urgency` 作为整数或列表，如下所示。
- en: Listing 10.2 Checking an object’s type using isinstance
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.2 使用 `isinstance` 检查对象类型
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When you compare listings 10.1 and 10.2, you may notice that both type and isinstance
    determine whether an object is of a specific type. *But they’re not the same.*
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当你比较列表 10.1 和 10.2 时，你可能注意到 `type` 和 `isinstance` 都确定对象是否为特定类型。*但它们并不相同*。
- en: 'When we use type to determine an object’s type, we’re doing a one-to-one comparison:
    the object’s type against the specified type. By contrast, isinstance is more
    flexible, and it’s a one-to-many comparison; it checks against not only a class,
    but also its superclass. That is, isinstance considers class inheritance, but
    type doesn’t. Sound confusing? Here’s a general example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `type` 来确定对象的类型时，我们正在进行一对一的比较：对象的类型与指定的类型。相比之下，`isinstance` 更灵活，它是一对多的比较；它不仅检查类，还检查其超类。也就是说，`isinstance`
    考虑了类继承，而 `type` 则没有。听起来很复杂？这里有一个通用示例：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'From the first and second comparisons, you can tell that when you use type,
    the obtained type information is specific to the immediate class: Supervisor.
    By contrast, although supervisor is an instance of the Supervisor class, not the
    User class, isinstance also uses the information that Supervisor is a subclass
    of User, and it returns True even if you check the instance against the superclass
    User.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从第一次和第二次比较中，你可以看出，当你使用 `type` 时，获得类型信息是针对直接类特定的：Supervisor。相比之下，尽管 supervisor
    是 Supervisor 类的实例，而不是 User 类，但 `isinstance` 也使用了 Supervisor 是 User 子类的信息，即使你检查实例与超类
    User，它也会返回 True。
- en: This flexibility is important, as even if our function checks a specific type
    using isinstance, such as User, it’s still valid if we call the function by sending
    an instance of Supervisor (an argument named user), which passes the isinstance(user,
    User) check.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这种灵活性很重要，即使我们的函数使用 `isinstance` 检查特定类型，例如 User，如果我们通过发送 Supervisor（一个名为 user
    的参数）的实例来调用该函数，它仍然有效，因为这样的实例通过了 `isinstance(user, User)` 检查。
- en: Maintainability To improve the robustness of type checking, you should use isinstance
    when you’re checking an object’s type, as this function considers not only the
    object’s immediate class, but also the class’s subclasses.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性 为了提高类型检查的稳健性，你应该在检查对象类型时使用 `isinstance`，因为这个函数不仅考虑对象的直接类，还考虑类的子类。
- en: 10.1.3 Checking an object’s type generically
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.3 以通用方式检查对象类型
- en: In listings 10.1 and 10.2, we assumed that the passed by_urgency argument is
    either int or list. But it’s not user-friendly if another user tries to call the
    filter_tasks function as filter_tasks(tasks, (4, 5)). That is, instead of using
    list, the user calls the function with a tuple object. As you can see, to provide
    greater flexibility to our function, it’s rather restrictive to check only the
    argument’s type against a specific kind. In this section, we’ll see how we can
    obtain an object’s type information more generically.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 10.1 和 10.2 中，我们假设传递的 `by_urgency` 参数是整数或列表。但如果另一个用户尝试以 `filter_tasks(tasks,
    (4, 5))` 的方式调用 `filter_tasks` 函数，那么这就不太友好。也就是说，用户不是使用列表，而是使用元组对象来调用函数。正如你所看到的，为了使我们的函数更加灵活，仅检查参数类型与特定类型是相当受限的。在本节中，我们将看到如何更通用地获取对象类型信息。
- en: We know that isinstance is preferred over type in checking an object’s type.
    Moreover, we can specify multiple classes in isinstance. Thus, the next listing
    shows a working solution for checking by_urgency in the filter_tasks function
    against multiple classes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道在检查对象类型时，`isinstance` 优于 `type`。此外，我们可以在 `isinstance` 中指定多个类。因此，下一个列表显示了在
    `filter_tasks` 函数中检查 `by_urgency` 对多个类的有效解决方案。
- en: Listing 10.3 Checking an object’s type against multiple classes using isinstance
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.3 使用 `isinstance` 检查对象类型与多个类
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you might expect, the updated filter_tasks function can handle list and
    tuple for the by_urgency argument. But it’s also possible that a user may want
    to call this function with a set object: filter_tasks(tasks, {4, 5}). The current
    implementation can’t handle this call. Theoretically, we can add set to the isinstance
    function call. The problem is that many other list-like data types, such as Series
    in the pandas library, can be used for by_urgency. Thus, it’s impossible to list
    all these types one by one, considering that you can also define custom classes.
    We should have a mechanism to check an object’s type generically.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所预期的那样，更新后的 filter_tasks 函数可以处理 list 和 tuple 作为 by_urgency 参数。但用户也可能希望用 set
    对象调用此函数：filter_tasks(tasks, {4, 5})。当前的实现无法处理此调用。理论上，我们可以将 set 添加到 isinstance
    函数调用中。问题是，还有许多其他类似列表的数据类型，例如 pandas 库中的 Series，也可以用于 by_urgency。因此，考虑到您还可以定义自定义类，不可能逐一列出所有这些类型。我们应该有一种机制来通用地检查对象的类型。
- en: In the standard library, the collections.abc module defines several *abstract
    base classes* (where the name abc comes from), which can be used to test whether
    a specific class has attributes or methods, a concept known as *interface* in
    programming.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准库中，collections.abc 模块定义了几个 *抽象基类*（其中 abc 的名称由此而来），可以用来测试一个特定类是否具有属性或方法，这在编程中被称为
    *接口*。
- en: Concept In OOP, *interface* represents the defined attributes, functions, methods,
    classes, and other applicable components of an entity (such as a class or a package)
    that developers can use.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 概念 在面向对象编程（OOP）中，*接口* 代表实体（如类或包）定义的属性、函数、方法、类以及其他适用组件，开发者可以使用它们。
- en: 'Relevant to the present topic is the Collection abstract class, which requires
    three key special methods: __contains__ (to check whether an item exists: item
    in obj), __iter__ (convertible to an iterator: iter(obj)), and __len__ (to check
    the number of items: len(obj)). list, tuple, set, and many other types of data
    containers, including Series, implement these methods, and all of them are concrete
    (as opposed to abstract) classes of Collection. Thus, we can update the filter_tasks
    function to be more generic in terms of checking the by_urgency argument’s type,
    as the next listing shows.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与当前主题相关的是 Collection 抽象类，它需要三个关键的特殊方法：__contains__（检查项目是否存在：item in obj），__iter__（可转换为迭代器：iter(obj)），以及
    __len__（检查项目数量：len(obj)）。list、tuple、set 以及许多其他类型的数据容器，包括 Series，都实现了这些方法，并且它们都是
    Collection 的具体（而非抽象）类。因此，我们可以将 filter_tasks 函数更新为更通用的形式，以检查 by_urgency 参数的类型，如下所示。
- en: Listing 10.4 Checking an object’s type against an abstract class
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.4 检查对象类型与抽象类
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: By using the abstract Collection class, we can accommodate all the collection-like
    data types without identifying the variety of classes that a user may send, which
    helps improve our code’s flexibility.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用抽象 Collection 类，我们可以适应所有类似集合的数据类型，而无需识别用户可能发送的类的多样性，这有助于提高我们代码的灵活性。
- en: As you can see from these sections, we’re gradually improving the flexibility
    of our function by checking the type of the argument by using type and isinstance
    with one type, isinstance with multiple definite types, and isinstance with a
    generic type. Figure 10.1 provides a visual summary of these usages.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从这些部分中看到的那样，我们通过使用 type 和 isinstance 检查参数类型，逐渐提高了我们函数的灵活性，使用一种类型、多个确定类型以及通用类型。图
    10.1 提供了这些用法的视觉总结。
- en: '![CH10_F01_Cui](../Images/CH10_F01_Cui.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![CH10_F01_Cui](../Images/CH10_F01_Cui.png)'
- en: Figure 10.1 Checking an object’s type information using type and isinstance.
    cls, as well as cls0 and cls1, refer to specific classes, whereas abs_cls refers
    to an abstract class that might represent an unlimited number of classes that
    use the interface.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 使用 type 和 isinstance 检查对象的类型信息。cls、cls0 和 cls1 指的是特定的类，而 abs_cls 指的是一个可能代表无限多个使用该接口的类的抽象类。
- en: 10.1.4 Discussion
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.4 讨论
- en: Checking an object’s type is an essential aspect of object introspection. There
    are too many other introspection techniques to cover comprehensively. As a developer,
    when you’re using a new library that you’re not familiar with, instead of looking
    up the information online, you can run dir(obj), which returns all the available
    attributes and methods for the object.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 检查对象的类型是对象自省的一个基本方面。有太多其他自省技术无法全面涵盖。作为开发者，当您使用一个您不熟悉的库时，您不必在网上查找信息，而是可以运行 dir(obj)，这将返回对象的所有可用属性和方法。
- en: The collections.abc module has many other abstract base classes. One abstract
    class is Sequence, and list is a concrete class of Sequence. Another abstract
    class is Iterable, which defines the __iter__ interface.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: collections.abc 模块还有许多其他的抽象基类。其中一个抽象类是 Sequence，list 是 Sequence 的具体类。另一个抽象类是
    Iterable，它定义了 __iter__ 接口。
- en: 10.1.5 Challenge
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.5 挑战
- en: 'In listing 5.1, we defined the following function to check whether an object
    is an iterable:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 5.1 中，我们定义了以下函数来检查一个对象是否是可迭代的：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We mentioned that Iterable is an abstract class in the collections.abc module.
    Can you rewrite the is_iterable function by taking advantage of the Iterable class?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到 Iterable 是 collections.abc 模块中的一个抽象类。你能利用 Iterable 类重写 is_iterable 函数吗？
- en: Hint If an object is an iterable, its class must have implemented __iter__ and
    have the corresponding interface for the Iterable class.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果一个对象是可迭代的，其类必须实现了 __iter__ 并具有 Iterable 类的相应接口。
- en: 10.2 What’s the lifecycle of instance objects?
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 实例对象的生存周期是什么？
- en: When a project grows in its scope, you define your own custom classes. When
    you learn to implement custom classes (chapters 8 and 9), you come across various
    terms related to the creation of custom class instances. Understanding the lifecycle
    of these instances is a fundamental skill that enables you, the Python developer,
    to manipulate these instances properly.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当项目规模扩大时，你定义自己的自定义类。当你学习如何实现自定义类（第 8 章和第 9 章）时，你会遇到与自定义类实例创建相关的各种术语。理解这些实例的生存周期是一项基本技能，它使你，Python
    开发者，能够正确地操作这些实例。
- en: In this section, I’ll review the key events of an instance object by going through
    specific examples. During this process, you’ll see terms describing essential
    programming concepts that you need to know to communicate with other developers
    effectively. Some of these terms are covered in chapter 8; I’ll briefly review
    them here and place the discussion in the context of an object’s lifecycle.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将通过具体示例回顾实例对象的关键事件。在这个过程中，你会看到描述基本编程概念的术语，这些术语是你与开发者有效沟通所必需的。其中一些术语在第
    8 章中有介绍；我将在这里简要回顾它们，并将讨论置于对象的生存周期背景中。
- en: 10.2.1 Instantiating an object
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.1 实例化对象
- en: The life of an instance object starts with its creation, known as *instantiation**.*
    This section reviews the instantiation process.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 实例对象的生存周期始于其创建，称为 *实例化**。本节回顾了实例化过程。
- en: Reminder *Instantiation* is the process of creating an instance object of a
    specific class.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒：*实例化* 是创建特定类实例对象的过程。
- en: 'For some built-in data types, such as str and list, we can use literals to
    create an instance, such as "Hello, World!" for a str instance and [1, 2, 3] for
    a list instance. Other than these literals for creating built-in data types, a
    more general situation is calling the constructor of a class. Consider the following
    Task class (and note that I’m keeping its implementation minimal so that I can
    focus on showing you the most relevant content):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些内置数据类型，如 str 和 list，我们可以使用字面量来创建实例，例如 "Hello, World!" 用于 str 实例，[1, 2, 3]
    用于 list 实例。除了用于创建内置数据类型的这些字面量之外，更普遍的情况是调用类的构造函数。考虑以下 Task 类（并注意我正在保持其实现尽可能简单，以便我可以专注于向您展示最相关的内容）：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the Task class, besides the __init__ method, we implement the __new__ method.
    Note that we typically don’t implement __new__, as there isn’t much we need to
    worry about in this method. Here, in both __new__ and __init__, we add two print
    function calls, allowing us to see when each function is called. More importantly,
    the printed message will inform us of the memory address of the instance (using
    the id function), allowing us to know the identity of the object for tracking
    purposes. With this class, let’s see what happens when we create an instance object:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Task 类中，除了 __init__ 方法外，我们还实现了 __new__ 方法。请注意，我们通常不会实现 __new__，因为在这个方法中我们不需要担心太多。在这里，在
    __new__ 和 __init__ 中，我们添加了两个 print 函数调用，这样我们就可以看到每个函数何时被调用。更重要的是，打印的消息将告诉我们实例的内存地址（使用
    id 函数），这样我们就可以为了跟踪目的知道对象的身份。有了这个类，让我们看看当我们创建实例对象时会发生什么：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Expect a different memory address on your computer.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在你的计算机上期望不同的内存地址。
- en: When we call the Task’s constructor, __new__ is invoked first, creating the
    instance without assigning any attributes; at this stage, it’s a brand-new object,
    as indicated by the method name. The purpose of this step is to allocate a specific
    slot in the memory to save the object. This is also why we can obtain the instance’s
    memory address.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 Task 构造函数时，首先调用 __new__ 方法，创建实例而不分配任何属性；在这个阶段，它是一个全新的对象，正如方法名所示。这一步的目的是在内存中为对象分配一个特定的槽位。这也是为什么我们可以获得实例的内存地址。
- en: The next step is invoking the __init__ method, in which the newly created instance
    gets its attribute assignment to complete the initialization process. As indicated
    by the same memory address, we’re constantly dealing with the same object in __new__,
    in __init__, and in the created task variable. Putting all these observations
    together, figure 10.2 shows the instantiation process.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是调用 __init__ 方法，其中新创建的实例完成属性分配以完成初始化过程。正如相同的内存地址所示，我们在 __new__、__init__ 和创建的任务变量中始终处理同一个对象。将这些观察结果综合起来，图
    10.2 展示了实例化过程。
- en: '![CH10_F02_Cui](../Images/CH10_F02_Cui.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![CH10_F02_Cui](../Images/CH10_F02_Cui.png)'
- en: Figure 10.2 The instantiation process of a custom class. After we call the constructor
    of a custom class, behind the scenes, the __new__ and __init__ methods are invoked
    sequentially, with __new__ creating the new object and __init__ completing the
    initialization process. In the end, the construction results in the creation of
    an instance object.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 自定义类的实例化过程。在调用自定义类的构造函数之后，幕后，__new__ 和 __init__ 方法依次被调用，其中 __new__ 创建新对象，__init__
    完成初始化过程。最终，构建结果导致实例对象的创建。
- en: 10.2.2 Being active in applicable namespaces
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.2 在适用命名空间中保持活跃
- en: You create an instance by calling the class constructor. Next, you use the created
    instance. This section introduces the namespace concept. You’ll see that the created
    instance is active in an applicable namespace, allowing it to be used.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过调用类构造函数来创建一个实例。接下来，你使用创建的实例。本节介绍了命名空间概念。你会发现创建的实例在适用命名空间中保持活跃，允许其被使用。
- en: 'We created an instance object of the Task class by running task = Task ("Laundry"),
    in which the variable task represents the instance object. Later in our code,
    we may want to retrieve the task’s title attribute, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过运行 task = Task("Laundry") 创建了 Task 类的实例对象，其中变量 task 代表实例对象。在代码的后续部分，我们可能想要检索任务的标题属性，如下所示：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When we write this line of code, we implicitly assume that the task variable
    refers to the variable that we’ve defined: an instance of the Task class. When
    Python tries to run this line of code, however, it doesn’t know our assumption;
    instead, it needs a mechanism to locate the task variable so that it can create
    the f-string. The mechanism for looking up variables involves *namespaces,* which
    track the variables that have been defined.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写这一行代码时，我们隐含地假设任务变量指向我们定义的变量：Task 类的实例。然而，当 Python 尝试运行这一行代码时，它并不知道我们的假设；相反，它需要一个机制来定位任务变量，以便它可以创建
    f-string。查找变量的机制涉及 *命名空间*，它跟踪已定义的变量。
- en: Concept Working as a dictionary, a *namespace* tracks variables that have been
    defined within its space. When you use a variable, the namespace can help locate
    the variable’s information.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 概念作为一个字典，*命名空间* 跟踪其空间内已定义的变量。当你使用变量时，命名空间可以帮助定位变量的信息。
- en: 'Suppose that the Task class is defined and the task instance is created in
    the same Python file, which forms a module. In this module, we have a *global
    namespace* that tracks all the variables, and we can check these variables by
    calling the globals function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 Task 类在同一个 Python 文件中定义，并且创建了 task 实例，这形成了一个模块。在这个模块中，我们有一个 *全局命名空间* 跟踪所有变量，我们可以通过调用
    globals 函数来检查这些变量：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can think of namespaces as being dictionaries in which the active variables
    are the keys and the corresponding values (objects) are the values. The preceding
    example highlights two variables: the Task class and the instance task. After
    we define the class and create an instance, both objects enter the namespace,
    and they can be located whenever we use these variables. As a quick reference,
    the following identity comparison shows that the values of ''Task'' and ''task''
    are indeed the class and the instance object:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将命名空间想象成字典，其中活动变量是键，相应的值（对象）是值。前面的例子突出了两个变量：Task类和task实例。在我们定义类并创建实例之后，这两个对象都进入命名空间，并且无论何时我们使用这些变量，都可以找到它们。作为一个快速参考，以下身份比较显示'Task'和'task'的值确实是类和实例对象：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After we create the instance, we can use it, as it can be resolved by looking
    up the global namespace, which has registered the created instance.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建实例之后，我们可以使用它，因为它可以通过查找已注册创建实例的全局命名空间来解析。
- en: 10.2.3 Tracking reference counts
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.3 跟踪引用计数
- en: When an object is active in the namespace, Python tracks how many other objects
    hold references to it for memory management purposes. This important event is
    happening behind the scenes, and many modern OOP languages have a similar feature.
    In this section, we’ll discuss the mechanism of tracking reference counts.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个对象在命名空间中处于活动状态时，Python会跟踪有多少其他对象持有对该对象的引用，以进行内存管理。这个重要的事件在幕后发生，许多现代面向对象的语言都有类似的功能。在本节中，我们将讨论跟踪引用计数的机制。
- en: A computer has a fixed amount of memory. When our applications are running,
    we create objects that consume memory. The more objects we add, the more memory
    our application uses. If we keep creating objects, our computer may run out of
    memory, causing our applications to crash and maybe even freezing up the computer.
    Thus, our applications should have a mechanism for removing objects from memory
    when we’re no longer using them. *Reference counting* is such a mechanism.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机有固定数量的内存。当我们的应用程序运行时，我们创建对象，这些对象会消耗内存。我们添加的对象越多，我们的应用程序使用的内存就越多。如果我们继续创建对象，我们的计算机可能会耗尽内存，导致我们的应用程序崩溃，甚至可能冻结计算机。因此，我们的应用程序应该有一种机制，在我们不再使用对象时从内存中删除对象。"引用计数"就是这样一种机制。
- en: Understanding the distinction between objects and variables
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 理解对象和变量之间的区别
- en: 'To understand how reference counting works, we first need to understand the
    distinction between objects and variables. When we run task = Task("Laundry"),
    two distinct things happen:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解引用计数是如何工作的，我们首先需要理解对象和变量之间的区别。当我们运行task = Task("Laundry")时，会发生两件不同的事情：
- en: An instance object is created, creating the actual object and its related data
    stored in memory.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个实例对象，创建实际对象及其相关数据存储在内存中。
- en: The object is referenced by the variable task, using a label to refer to the
    underlying object in memory.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象通过变量task进行引用，使用标签来引用内存中底层的对象。
- en: Notably, the relationship between the object and the label can change. In Python,
    which is a dynamically typed language, we can assign a different object to the
    same label; the object that was associated with the label still exists in memory,
    but now the label references the new object (figure 10.3).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，对象和标签之间的关系可能会改变。在Python这样的动态类型语言中，我们可以将不同的对象赋给相同的标签；与标签关联的对象仍然存在于内存中，但现在标签引用了新的对象（图10.3）。
- en: '![CH10_F03_Cui](../Images/CH10_F03_Cui.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![CH10_F03_Cui](../Images/CH10_F03_Cui.png)'
- en: Figure 10.3 The relationship between objects and variables. In the assignment
    statement, an instance object of the Task class is created in memory, and this
    object is associated with the task variable. Later, we assign a str object to
    the task variable. This reassignment disrupts the previous association between
    task and the actual Task("Laundry") object and creates a new association between
    task and the str object.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 对象和变量之间的关系。在赋值语句中，内存中创建了一个Task类的实例对象，并且这个对象与task变量相关联。后来，我们将str对象赋值给task变量。这种重新赋值破坏了task与实际Task("Laundry")对象之间的先前关联，并创建了task与str对象之间新的关联。
- en: As shown in figure 10.3, we create a variable named task by assigning it to
    an instance of the Task class so that the variable task is referencing the Task
    instance object. When we assign the same variable task to another str object,
    task no longer references the Task instance object; instead, it references the
    str object.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如图10.3所示，我们通过将task赋值给Task类的实例来创建一个名为task的变量，这样变量task就引用了Task实例对象。当我们将相同的变量task赋值给另一个str对象时，task不再引用Task实例对象；相反，它引用了str对象。
- en: Incrementing and decrementing reference counts
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 增加和减少引用计数
- en: Now we understand the distinction between objects and variables, and we know
    that a variable represents a reference to the underlying object in memory. Such
    a reference to the object is counted as 1 to start with the initial assignment
    statement. This section shows how we can change the reference counts.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们理解了对象和变量之间的区别，并且我们知道变量在内存中代表对底层对象的引用。这种对对象的引用从初始赋值语句开始计为1。本节展示了我们如何改变引用计数。
- en: 'Before we try to change an object’s reference count, we should find a way to
    track the reference count. In Python, we can use the getrefcount function in the
    sys module:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试改变一个对象的引用计数之前，我们应该找到一种方法来跟踪引用计数。在Python中，我们可以使用sys模块中的getrefcount函数：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding example has two references to the Task instance object. Wait a
    second. Shouldn’t there only be one reference—the task variable in the assignment?
    It’s an awesome question. The answer is that using the variable in the getrefcount
    function call creates another reference to the object, making the current reference
    count 2\. More generally, using a variable in a function increments the underlying
    object’s reference count.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例中有两个对Task实例对象的引用。等等，不应该只有一个引用——赋值中的task变量吗？这是一个很棒的问题。答案是，在getrefcount函数调用中使用变量会创建对对象的另一个引用，使得当前的引用计数为2。更普遍地说，在函数中使用变量会增加底层对象的引用计数。
- en: 'We know how to track an object’s reference count, and we can do some experiments
    to manipulate the count for an object. To increase this count, one common approach
    is to include the variable in a data container, such as a dict or a list object:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道如何跟踪一个对象的引用计数，并且我们可以进行一些实验来操纵对象的计数。为了增加这个计数，一个常见的方法是将变量包含在数据容器中，例如字典或列表对象：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In both cases, using task in a dict and a list object increments the reference
    count by 1\. We’ve seen how reference counting increments, and it’s time to see
    how we can decrement the count. The common way is to use the del statement:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，使用task在字典和列表对象中都会增加引用计数1。我们已经看到了引用计数的增加，现在是时候看看我们如何可以减少计数了。常见的方法是使用del语句：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After removing tasks, we remove a reference to the instance object; thus, the
    reference count drops by 1\. We can also delete work to reduce the reference count
    by 1, but doing the same thing all the time is boring. Instead of deleting the
    dict object, we can manipulate the work objectby replacing task with a different
    value, in which case we also remove a reference to the Task instance:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在移除任务后，我们移除对实例对象的引用；因此，引用计数减少1。我们也可以删除工作来减少引用计数1，但总是做同样的事情会显得很无聊。而不是删除字典对象，我们可以通过用不同的值替换task来操作工作对象，在这种情况下，我们也移除了对Task实例的引用：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can see how responsively and instantaneously Python tracks the reference
    count for us. But what does reference counting end up with? Let’s continue exploring
    the lifecycle of the instance object.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到Python是如何响应和即时地跟踪引用计数的。但引用计数最终会怎样呢？让我们继续探索实例对象的生命周期。
- en: 10.2.4 Destructing the object
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.4 对象的销毁
- en: Section 10.2.3 discussed how Python tracks reference counts. The key is that
    when an object’s reference count reaches zero, Python destructs the object so
    that the memory that it occupied can be released for the system to use. In this
    section, we take a closer look at the destruction process.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 10.2.3节讨论了Python如何跟踪引用计数。关键是当一个对象的引用计数达到零时，Python会销毁该对象，以便它占用的内存可以被系统释放以供使用。在本节中，我们将更详细地探讨销毁过程。
- en: Like the construction process, the destruction process is typically handled
    in Python through automatic reference counting. To zoom in on the destruction
    process, we can override __del__, the special method related to object destruction,
    as shown in the next listing.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 与构建过程一样，销毁过程通常通过Python中的自动引用计数来处理。为了更深入地了解销毁过程，我们可以覆盖__del__，与对象销毁相关的特殊方法，如下面的列表所示。
- en: Listing 10.5 Overriding __del__ in a class
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.5 在类中覆盖__del__
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With this updated Task class, let’s write some code to review initialization
    and the global namespace processes:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个更新的 Task 类，让我们编写一些代码来回顾初始化和全局命名空间过程：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To set the reference count to zero manually so that we can trigger the destruction
    process, we can use the del statement:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了手动将引用计数设置为 0 以触发销毁过程，我们可以使用 del 语句：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you can see, calling del on task invokes the __del__ special method. By
    cross-checking the memory address, we’re indeed removing the same instance that
    we created. Notably, after the destruction, "task" is also removed from the namespace,
    and we can no longer access the task variable. If you insist on trying, you’ll
    see an error:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，对 task 调用 del 会调用 __del__ 特殊方法。通过交叉检查内存地址，我们确实移除了我们创建的相同实例。值得注意的是，在销毁后，“task”也从命名空间中移除，我们不能再访问
    task 变量。如果您坚持尝试，您将看到错误：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 10.2.5 Discussion
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.5 讨论
- en: This section discusses the major events in the lifecycle of an object, using
    an instance object of a custom class as an example. Putting all the key points
    together, figure 10.4 shows the big picture of an object’s lifecycle.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了对象生命周期中的主要事件，以自定义类的实例对象为例。将所有关键点综合起来，图 10.4 展示了对象生命周期的整体图景。
- en: '![CH10_F04_Cui](../Images/CH10_F04_Cui.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![CH10_F04_Cui](../Images/CH10_F04_Cui.png)'
- en: Figure 10.4 The key events in an object’s lifecycle. An object starts with the
    construction and becomes active in an applicable namespace. During its usage,
    Python tracks its reference count. When there are no references to the object,
    Python destructs it to make its occupied memory available again.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 对象生命周期中的关键事件。对象从构造开始，在适用的命名空间中变得活跃。在其使用过程中，Python 跟踪其引用计数。当没有对象引用时，Python
    销毁它，使其占用的内存再次可用。
- en: The great thing about working with Python is that these events are largely automatic;
    Python does the heavy lifting behind the scenes. Unless you’re building a memory-intensive
    application, you don’t need to worry about these underlying events. Nevertheless,
    these concepts are fundamental to OOP, and if you’re also learning another OOP
    language, this knowledge can expedite your learning process.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Python 一起工作的好处是这些事件在很大程度上是自动的；Python 在幕后做繁重的工作。除非您正在构建内存密集型应用程序，否则您不需要担心这些底层事件。尽管如此，这些概念是面向对象编程的基础，如果您也在学习另一种面向对象编程语言，这些知识可以加速您的学习过程。
- en: A key module that I haven’t mentioned is gc, the name of which stands for *garbage
    collection**.* This module has advanced algorithms to handle memory management
    while working with the reference counting mechanism. Reference counting can’t
    destruct objects when cyclic referencing happens, for example. This problematic
    scenario arises when two or more objects reference each other, and their reference
    counts can never reach 0\. Interested readers can explore the gc module to find
    out how this kind of problem (cyclic referencing) is handled.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我还没有提到的一个关键模块是 gc，其名称代表 *垃圾回收**。此模块具有处理内存管理的先进算法，同时与引用计数机制一起工作。当发生循环引用时，引用计数无法销毁对象，例如。这种问题场景发生在两个或更多对象相互引用，并且它们的引用计数永远不会达到
    0。感兴趣的读者可以探索 gc 模块，以了解这类问题（循环引用）是如何处理的。
- en: 10.2.6 Challenge
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.6 挑战
- en: As a Python beginner, James is particularly interested in how reference counting
    works for custom class instances. He has a question. Suppose that he creates an
    instance variable, such as task = Task("Homework"), and he knows that the reference
    count for the underlying object is 1—the task variable. Does using the task variable
    in a function increment its reference counts? Write some code to tell him what
    happens.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名 Python 初学者，詹姆斯特别感兴趣的是自定义类实例的引用计数是如何工作的。他有一个问题。假设他创建了一个实例变量，例如 task = Task("Homework")，并且他知道底层对象的引用计数为
    1——task 变量。在函数中使用 task 变量是否会增加其引用计数？请编写一些代码来告诉他会发生什么。
- en: Hint You can check the reference count of an argument by including getrefcount
    in the function.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：您可以在函数中包含 getrefcount 来检查参数的引用计数。
- en: 10.3 How do I copy an object?
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 我如何复制一个对象？
- en: When we work with an object, we can modify its attributes, but we may also want
    to keep its original attributes in case we need to cancel the modification. This
    need is common in many applications. In our task management application, one feature
    allows users to edit an existing task. After the user makes some changes, they
    can either save the update or cancel the edits. In this use case, we create a
    copy of the original task so we have the new copy for tracking the updates and
    the original one as the backup. In this section, you’ll learn the proper way to
    copy an object.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们与一个对象一起工作时，我们可以修改其属性，但我们也可能想要保留其原始属性，以防我们需要取消修改。这种需求在许多应用中很常见。在我们的任务管理应用中，一个功能允许用户编辑现有的任务。在用户进行一些更改后，他们可以保存更新或取消编辑。在这个用例中，我们创建原始任务的副本，以便我们有新的副本来跟踪更新，并将原始副本作为备份。在本节中，你将学习正确复制对象的方法。
- en: 10.3.1 Creating a (shallow) copy
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.1 创建（浅）拷贝
- en: In Python, the copy module provides copy-related functionalities for objects.
    This section shows how to make a copy. More precisely, it discusses creating a
    shallow copy as opposed to a deep copy; section 10.3.2 distinguishes between those
    two processes.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，copy模块为对象提供了与复制相关的功能。本节展示了如何进行复制。更确切地说，它讨论了创建浅拷贝而不是深拷贝；第10.3.2节区分了这两个过程。
- en: 'Suppose that we’ve created the following class Task for our application. For
    simplicity, the class has implemented only __init__ and __repr__:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经为我们的应用创建了一个名为Task的以下类。为了简单起见，该类只实现了__init__和__repr__：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the application, the user can view the list of tasks and can edit a specific
    task if they want. They may want to edit the following instance of Task, for example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用中，用户可以查看任务列表，并且如果他们想的话可以编辑特定的任务。例如，他们可能想要编辑以下实例的Task：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the user is happy with the edit, the updated task is saved, and if the user
    cancels the edit, everything in the original task is kept. Because an instance
    of the Task class has a dict representation, a naïve solution to creating a copy
    may use the dict object as an “informal” copy of the original instance:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户对编辑满意，则更新后的任务将被保存，如果用户取消编辑，则原始任务中的所有内容都将保持不变。因为Task类的实例有一个字典表示，创建副本的一个简单解决方案可能使用字典对象作为原始实例的“非正式”副本：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As shown in this example, we obtain the dict representation using __dict__.
    For this dict object, we can create a copy using its instance method copy. When
    the user edits the task, we use the dict object to track the changes. This solution
    has a complicating factor, however: after the dict object is updated, we must
    revert the dict object to an instance of Task so that we can use additional functionalities
    implemented by the Task class. Otherwise, we can’t do much with a dict object
    because we have no access to task-related functionalities such as save_data.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如此例所示，我们使用__dict__获取字典表示。对于这个字典对象，我们可以使用它的实例方法copy来创建一个副本。当用户编辑任务时，我们使用字典对象来跟踪更改。然而，这个解决方案有一个复杂因素：在字典对象更新后，我们必须将其还原为Task的实例，以便我们可以使用Task类实现的其他功能。否则，我们无法对字典对象做很多事情，因为我们无法访问与任务相关的功能，如save_data。
- en: 'Instead of making a copy of the instance’s dictionary representation, we can
    copy it directly by using the functionalities available in the copy module. The
    following code snippet shows a better solution that makes a real copy of the instance:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接使用copy模块中可用的功能来复制实例的字典表示，而不是复制其字典表示。以下代码片段显示了一个更好的解决方案，它创建了一个真正的实例副本：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Trivia Note that the function copy has the same name as the module copy. This
    example isn’t the only case in which a function has the same name as its module.
    The datetime module has a function called datetime, for example, so you’ll sometimes
    see from datetime import datetime.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 事实趣闻：函数copy与模块copy具有相同的名称。这个例子并不是唯一一个函数与它的模块具有相同名称的情况。例如，datetime模块有一个名为datetime的函数，所以你有时会看到from
    datetime import datetime。
- en: We import the copy function from the copy module, and we can send the instance
    task to the copy function. The printout shows that the copied variable task_copied
    holds the same data as task and confirms that it’s a copy of the original task.
    With this copied task, after the user makes the edits, we run task_copied.save_data()
    to update our database.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从copy模块中导入copy函数，并将实例task发送到copy函数。打印输出显示，复制的变量task_copied与task具有相同的数据，并确认它是原始任务的副本。使用这个复制的任务，在用户进行编辑后，我们运行task_copied.save_data()来更新我们的数据库。
- en: 10.3.2 Noting the potential problem of a shallow copy
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.2 注意浅拷贝的潜在问题
- en: 'At the beginning of section 10.3.1, I mentioned that there are two kinds of
    copies: shallow and deep. The copy function is creating a shallow copy. But what’s
    a shallow copy, and what’s a deep copy? In this section, I’ll show how these types
    of copies differ and discuss a potential problem that might arise from a shallow
    copy.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 10.3.1 节的开始，我提到有两种复制方式：浅复制和深复制。复制函数正在创建一个浅复制。但浅复制和深复制是什么？在本节中，我将展示这些类型复制的区别，并讨论可能由浅复制引起的问题。
- en: 'For our task management application, suppose that we can have tags for each
    task. To address this need, our Task class may look like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的任务管理应用程序，假设我们可以为每个任务有标签。为了满足这个需求，我们的 Task 类可能看起来像这样：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ Ternary assignment
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 三元赋值
- en: Concept A *ternary expression* is evaluated based on a logical condition and
    has the format value_when_true if condition else value_when_false. When you use
    a ternary expression to assign a value, the process is called ternary assignment.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 概念 A *三元表达式* 根据逻辑条件进行评估，其格式为 value_when_true if condition else value_when_false。当你使用三元表达式来赋值时，这个过程被称为三元赋值。
- en: With this updated class, let’s create an instance and make a copy using the
    copy function in the next listing.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个更新的类，让我们创建一个实例，并在下一个列表中使用复制函数来制作一个副本。
- en: Listing 10.6 Creating a copy of an existing task
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.6 创建现有任务的副本
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the application, the user starts to update the task. Specifically, the user
    adds another tag to the task:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中，用户开始更新任务。具体来说，用户给任务添加了另一个标签：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As you can see, we’re able to update the copied task’s tags. But the user decides
    to cancel this edit. In this scenario, we still use the original task’s data.
    Because we haven’t touched the original task, its data should stay the same:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们能够更新复制任务的标签。但用户决定取消这次编辑。在这种情况下，我们仍然使用原始任务的数据。因为我们没有修改原始任务，它的数据应该保持不变：
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We’re sure that the original task has the tags:[''school'', ''urgent''], but
    why has it been changed? Specifically, it’s been changed to match the list object
    in the copied task. This situation can’t be a coincidence, as you should suspect.
    It seems that task and task_copied have the same list object for tags. This hypothesis
    is easy to test:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确信原始任务有标签：['school', 'urgent']，但它为什么改变了？具体来说，它被更改为与复制任务中的列表对象匹配。这种情况不太可能是巧合，你应该怀疑。看起来
    task 和 task_copied 对于标签有相同的列表对象。这个假设很容易测试：
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Checking equality with is or ==
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 is 或 == 检查相等性
- en: When I compare two objects in Python, you may notice that sometimes I use is,
    and at other times I use ==. is compares whether two objects are the same object,
    so it’s also known as the *identity test*. By contrast, == compares whether two
    objects have the same value. Because they’re intended for different comparisons
    (identity versus value), they should be used differently. In the common use case
    of comparing an object against None, for example, you should use is, although
    you may have seen people use ==. None is a singleton object, meaning that only
    one object holds None in an application. Whenever you use None, it’s the same
    object accessed from the memory. Thus, a comparison of an object with None should
    use is, as the comparison is supposed to be an identity test. The same identity
    test is intended to be used to compare task.tags and task_copied.tags.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在 Python 中比较两个对象时，你可能注意到有时我使用 is，而有时我使用 ==。is 比较两个对象是否是同一个对象，因此它也被称为 *身份测试*。相比之下，==
    比较两个对象是否有相同的值。因为它们用于不同的比较（身份与值），所以它们应该以不同的方式使用。例如，在比较对象与 None 的常见用例中，你应该使用 is，尽管你可能见过人们使用
    ==。None 是一个单例对象，这意味着只有一个对象在应用程序中持有 None。每次你使用 None 时，它都是从内存中访问的相同对象。因此，与 None
    对象的比较应该使用 is，因为这种比较应该是一个身份测试。相同的身份测试旨在用于比较 task.tags 和 task_copied.tags。
- en: On the other hand, if we want to compare the memory addresses of the two list
    objects, we should use == instead. Every time we call the id function on an object,
    it creates an int object to denote the object’s memory address. Thus, calling
    id two times creates two distinct int objects, and we’re only comparing whether
    these two int objects have equal values.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们想比较两个列表对象的内存地址，我们应该使用 ==。每次我们调用对象的 id 函数时，它都会创建一个 int 对象来表示对象的内存地址。因此，调用
    id 两次会创建两个不同的 int 对象，而我们只比较这两个 int 对象是否有相同的值。
- en: As shown in the preceding example, both equality comparisons (identity and memory
    address) support our hypothesis that the list object of task_copied’s tags is
    the same as task’s. Why could that happen? This unexpected sharing of the list
    object highlights the difference between shallow and deep copies. In a *shallow
    copy,* we copy the outmost data container. Between copies, we share the contained
    mutable objects, such as the list object for tags. By contrast, in a *deep copy,*
    we copy not only the outmost container, but also recursive copies of the interior
    objects. Both types of copies leave the contained immutable objects (such as strings
    and tuples) alone, as they have no way to manipulate those objects anyway. Figure
    10.5 shows the differences between deep and shallow copies.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，两种等价比较（身份和内存地址）支持我们的假设，即task_copied的tags列表对象与task的相同。为什么会这样呢？这种意外的列表对象共享突出了浅拷贝和深拷贝之间的区别。在浅拷贝中，我们只复制最外层数据容器。在副本之间，我们共享包含的可变对象，如tags的列表对象。相比之下，在深拷贝中，我们不仅复制最外层容器，还递归地复制内部对象。两种类型的拷贝都让包含的不可变对象（如字符串和元组）保持不变，因为它们无论如何都无法操作这些对象。图10.5显示了深拷贝和浅拷贝之间的区别。
- en: '![CH10_F05_Cui](../Images/CH10_F05_Cui.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![CH10_F05_Cui](../Images/CH10_F05_Cui.png)'
- en: Figure 10.5 The distinction between shallow and deep copies. In a shallow copy,
    the outmost data container (or any noncontainer object, such as a string) and
    its immutable contained objects are copied, but not the interior mutable objects,
    such as a list. By contrast, in a deep copy, the outmost container and all its
    interior objects have distinct copies. The gray boxes represent objects in memory.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 浅拷贝和深拷贝的区别。在浅拷贝中，最外层数据容器（或任何非容器对象，如字符串）及其不可变包含对象被复制，但不包括内部可变对象，如列表。相比之下，在深拷贝中，最外层容器及其所有内部对象都有独立的副本。灰色框表示内存中的对象。
- en: In figure 10.5, we use a list object, which contains a str "hello" and a list
    [3, 4, 5]. When we make a shallow copy, we copy only the outermost list object.
    The interior list object [3, 4, 5] and the immutable str object "hello" are shared
    by the shallow copy and its original list. By contrast, when we make a deep copy,
    the outmost container and its mutable item, the interior list object, are copied
    distinctly for each object.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在图10.5中，我们使用一个包含字符串"hello"和列表[3, 4, 5]的列表对象。当我们进行浅拷贝时，我们只复制最外层的列表对象。内部列表对象[3,
    4, 5]和不可变的字符串对象"hello"在浅拷贝及其原始列表之间是共享的。相比之下，当我们进行深拷贝时，最外层容器及其可变项，即内部列表对象，为每个对象分别复制。
- en: Because of the differences in the way the two types of copies deal with interior
    mutable objects, if you make only a shallow copy, you can overwrite the data in
    the original object accidentally. Thus, if you want two real copies of independent
    objects, you should create a deep copy, as shown in the next section.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于两种类型的副本处理内部可变对象的方式不同，如果你只进行浅拷贝，你可能会意外地覆盖原始对象中的数据。因此，如果你想创建两个独立的对象的真正副本，你应该创建一个深拷贝，如下一节所示。
- en: 10.3.3 Creating a deep copy
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.3 创建深拷贝
- en: Now that we know the difference between shallow and deep copies, we can revisit
    the task editing feature of our application. For this feature, we want the original
    task and the copied task to be distinct, sharing no interior mutable objects—in
    our case, the tags attribute—so that we’re free to update the mutable attribute
    tags without affecting the original task. Based on the distinction between shallow
    and deep copies, this feature requires us to create a deep copy.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了浅拷贝和深拷贝之间的区别，我们可以回顾一下我们应用程序的任务编辑功能。对于这个功能，我们希望原始任务和复制的任务是独立的，不共享任何内部可变对象——在我们的例子中是tags属性——这样我们就可以自由地更新可变属性tags，而不会影响原始任务。基于浅拷贝和深拷贝之间的区别，这个功能要求我们创建一个深拷贝。
- en: 'Besides the copy function, the copy module has a deepcopy function. That function
    is specifically designed to create a deep copy of an object:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 除了copy函数外，copy模块还有一个deepcopy函数。该函数专门设计用来创建对象的深拷贝：
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In this code, we use the deepcopy function to create a copy of the original
    task. At this stage, we shouldn’t expect a difference between a shallow copy and
    a deep copy because we haven’t manipulated the interior mutable object yet. Next,
    it’s time to see the usefulness of a deep copy:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们使用deepcopy函数创建原始任务的副本。在这个阶段，我们不应该期望浅拷贝和深拷贝之间有差异，因为我们还没有操作内部可变对象。接下来，是时候看看深拷贝的有用性了：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this code snippet, we update the data for the deep copied task’s tags attribute.
    Notably, this change exists in task_deepcopied but not in task—the expected behavior,
    because the deep copy creates a distinct copy of each interior object, including
    the mutable list object tags.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们更新了深拷贝任务标签属性的数据库。值得注意的是，这个更改存在于task_deepcopied中，而不在task中——这是预期的行为，因为深拷贝会为每个内部对象创建一个独立的副本，包括可变列表对象tags。
- en: 10.3.4 Discussion
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.4 讨论
- en: Shallow and deep copies differ in their behaviors when they copy the interior
    mutable objects, usually in the form of data containers, such as list, dict, and
    set. Shallow copies don’t create a copy for these interior data containers, which
    can save memory if you’re not concerned about the shared interior objects. By
    contrast, when you expect to create a copy with distinct data, such as when you
    edit a task and want to keep its original data, you should use a deep copy instead.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 浅拷贝和深拷贝在复制内部可变对象时的行为不同，通常以数据容器形式存在，如列表、字典和集合。浅拷贝不会为这些内部数据容器创建副本，如果您不关心共享的内部对象，这可以节省内存。相比之下，当您期望创建具有独立数据的副本时，例如在编辑任务并希望保留其原始数据时，您应该使用深拷贝。
- en: 10.3.5 Challenge
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.5 挑战
- en: 'In the examples, we use copy and deepcopy functions in the copy module. Calling
    these functions creates a shallow copy and a deep copy, respectively. Notably,
    you can override two special methods, __copy__ and __deepcopy__, in a custom class,
    which will be triggered when you use the copy and deepcopy functions. In the case
    of overriding __copy__, suppose that we change the title for the copied task:
    "Homework" -> "Copied: Homework". We also want the copy to have a distinct copy
    of the tags attribute, making it like a deep copy. Can you implement this feature?'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们使用copy模块中的copy和deepcopy函数。调用这些函数分别创建浅拷贝和深拷贝。值得注意的是，您可以在自定义类中覆盖两个特殊方法__copy__和__deepcopy__，当您使用copy和deepcopy函数时，这些方法将被触发。在覆盖__copy__的情况下，假设我们更改了复制的任务的标题：“作业”->“复制的：作业”。我们还希望副本具有独特的tags属性副本，使其类似于深拷贝。你能实现这个功能吗？
- en: Hint Copying an instance is supposed to be instance-specific, so __copy__ should
    be an instance method. In the body, you should return a new instance with the
    updated task’s title and a new list object for tags.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：复制实例应该是实例特定的，所以__copy__应该是一个实例方法。在方法体中，你应该返回一个带有更新任务标题和新的tags列表对象的新实例。
- en: 10.4 How do I access and change a variable in a different scope?
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 如何访问和更改不同作用域中的变量？
- en: 'Section 10.2 introduced the concept of namespaces. When we define a class,
    such as Task, in a Python module (a .py file), the class is registered in the
    global namespace, which takes the form of a dictionary: the identifiers are the
    keys, and the corresponding objects are the values. Suppose that in our task management
    app, we have a module with the filename of task.py. This file contains the code
    shown in the next listing.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 第10.2节介绍了命名空间的概念。当我们在一个Python模块（一个.py文件）中定义一个类，例如Task时，该类被注册在全局命名空间中，其形式为一个字典：标识符是键，相应的对象是值。假设在我们的任务管理应用程序中，我们有一个名为task.py的模块。这个文件包含了下一列表中显示的代码。
- en: Listing 10.7 Attempting to change a global variable
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.7 尝试更改全局变量
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In listing 10.7, we have the variable db_filename, which is the file path of
    our task management app. By calling the set_database, we set the db_name to db_filename.
    In the printout, however, db_filename has a value of "N/A". This result is unexpected,
    as we thought we’d changed it. What happened?
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表10.7中，我们有变量db_filename，它是我们任务管理应用程序的文件路径。通过调用set_database，我们将db_name设置为db_filename。然而，在打印输出中，db_filename的值为“N/A”。这个结果是不预期的，因为我们认为我们已经更改了它。发生了什么？
- en: 'In this section, I’ll show you how to access and change a variable in this
    scenario. More generally, this kind of problem pertains to manipulating variables
    in a different scope, with a special emphasis on cases involving two keywords:
    global and nonlocal. Through the examples, you’ll learn how to access variables,
    which are resolved by applying the LEGB rule.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向您展示如何在这种情况下访问和更改变量。更普遍地说，这类问题涉及在不同作用域中操作变量，特别强调涉及两个关键字：global和nonlocal的情况。通过这些示例，您将学习如何访问通过应用LEGB规则解析的变量。
- en: '10.4.1 Accessing any variable: The LEGB rule for name lookup'
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.1 访问任何变量：名称查找的LEGB规则
- en: Scopes and namespaces are closely related. *Scopes* form the boundaries for
    namespaces, and *namespaces* constitute the contents of scopes. Using a Python
    module as an example, figure 10.6 shows the relationship between namespaces and
    scopes.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域和命名空间密切相关。*作用域*形成了命名空间的边界，而*命名空间*构成了作用域的内容。以Python模块为例，图10.6展示了命名空间和作用域之间的关系。
- en: '![CH10_F06_Cui](../Images/CH10_F06_Cui.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![CH10_F06_Cui](../Images/CH10_F06_Cui.png)'
- en: Figure 10.6 The relationship between the global namespace and the global scope.
    In a module, the global namespace tracks all the variables, as well as functions
    and classes, in the form of a dictionary. The global namespace resides in the
    global scope, which defines the boundary.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 全局命名空间和全局作用域之间的关系。在一个模块中，全局命名空间以字典的形式跟踪所有变量，以及函数和类。全局命名空间位于全局作用域中，它定义了边界。
- en: As shown in figure 10.6, the namespace tracks all the objects, each of which
    has its own identifier in the module. Thus, we can think of a namespace as being
    a container whose internal space is filled with different objects. The scope is
    the container’s entire enclosing structure, defining the boundary of the module.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如图10.6所示，命名空间跟踪所有对象，每个对象在模块中都有自己的标识符。因此，我们可以将命名空间视为一个容器，其内部空间填充着不同的对象。作用域是容器的整个封装结构，定义了模块的边界。
- en: To interpret code from Python’s perspective, when Python encounters a variable,
    it’s trying to resolve that variable, meaning that it needs to find the variable’s
    referenced object. Section 10.2.2 mentioned that Python looks up variables in
    a namespace that is associated with a scope. There are different levels of scopes
    for the lookup order, known as the LEGB rule.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 从Python的角度解释代码时，当Python遇到一个变量，它试图解析该变量，这意味着它需要找到变量引用的对象。第10.2.2节提到，Python在关联的作用域的命名空间中查找变量。存在不同级别的作用域，称为LEGB规则。
- en: Concept The *LEGB rule* dictates the order of resolving a variable in Python,
    from local (L), to enclosing (E), global (G), and built-in (B).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 概念 *LEGB规则* 指定了Python中解析变量的顺序，从局部（L），到封装（E），全局（G），再到内置（B）。
- en: The acronym *LEGB* stands for *local, enclosing, global,* and *built-in* scopes
    in an incremental order in terms of scale. A module forms a global scope. Above
    the global, the built-in scope holds the namespaces for all the built-in functions
    and classes. In the module, you can define a class or a function, each of which
    forms a local scope.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 缩写词*LEGB*代表按规模递增的顺序的*局部、封装、全局*和*内置*作用域。一个模块形成一个全局作用域。在全局作用域之上，内置作用域包含所有内置函数和类的命名空间。在模块中，你可以定义一个类或一个函数，每个都形成一个局部作用域。
- en: Trivia It may sound weird to refer to a module’s scope as global. But if you
    recall that a function within a module creates a local scope, it’s not too surprising
    to call a scope global when it’s larger than local. This logic may help you remember
    the distinction.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 知识点听起来将模块的作用域称为全局可能有些奇怪。但如果你回想起模块内的函数创建了一个局部作用域，那么当作用域大于局部作用域时，将其称为全局作用域也就不足为奇了。这种逻辑可能有助于你记住这种区别。
- en: But what about the enclosing scope? When I introduced decorators in section
    7.3, I nested a function within another function. For the inner function, the
    local scope of the outer function is known as the *enclosing scope.* Figure 10.7
    shows how variables/functions (referred to as names in general) are resolved by
    looking up a specific scope.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 但封装作用域又是如何呢？在我第7.3节介绍装饰器时，我在另一个函数内部嵌套了一个函数。对于内部函数，外部函数的局部作用域被称为*封装作用域*。图10.7展示了通过查找特定作用域来解析变量/函数（通常称为名称）的方式。
- en: '![CH10_F07_Cui](../Images/CH10_F07_Cui.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![CH10_F07_Cui](../Images/CH10_F07_Cui.png)'
- en: Figure 10.7 Examples of variable resolution. Functions such as int and print
    are built-in functions, and they’re resolved by looking up the built-in scope.
    The variable number and the function outer_fun are resolved in the global scope.
    The variable x is used in inner_fun, which is resolved in the enclosing scope.
    number_str and x_str are resolved in the local scope.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 变量解析的示例。像int和print这样的函数是内置函数，它们通过查找内置作用域来解析。变量number和函数outer_fun在全局作用域中解析。变量x在inner_fun中使用，它在封装作用域中解析。number_str和x_str在局部作用域中解析。
- en: The LEGB rule applies in the sequential order for variable resolution. As shown
    in figure 10.8, for a variable (or a name in general, or a name as an identifier,
    which can refer to a function, a list, or even a class), Python first searches
    its local scope. If the name is resolved, the corresponding value is used. If
    not, Python continues searching the enclosing scope. If the name is resolved,
    the value is used—and so on for the global and built-in scopes sequentially. If
    a name can’t be resolved after Python checks all these scopes, a NameError is
    raised.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: LEGB 规则按照顺序应用于变量解析。如图 10.8 所示，对于变量（或一般名称，或作为标识符的名称，它可以指代函数、列表甚至类），Python 首先搜索其局部作用域。如果名称被解析，则使用相应的值。如果没有，Python
    继续搜索封装作用域。如果名称被解析，则使用该值——然后按顺序搜索全局和内置作用域。如果在 Python 检查了所有这些作用域之后，名称仍然无法解析，则会引发
    NameError。
- en: '![CH10_F08_Cui](../Images/CH10_F08_Cui.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![CH10_F08_Cui](../Images/CH10_F08_Cui.png)'
- en: 'Figure 10.8 The general process of resolving a variable: the LEGB rule. When
    Python encounters a variable, it tries to resolve it by looking up the local,
    enclosing (if applicable), global, and built-in scopes sequentially. If the variable
    is resolved, Python uses the value; otherwise, it raises a NameError.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 解析变量的通用过程：LEGB 规则。当 Python 遇到变量时，它会通过按顺序查找局部、封装（如果适用）、全局和内置作用域来尝试解析它。如果变量被解析，Python
    使用该值；否则，它会引发 NameError。
- en: 10.4.2 Changing a global variable in a local scope
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.2 在局部作用域中更改全局变量
- en: At the beginning of this section, I presented a problem in which we failed to
    change the variable db_filename by calling the set_database function. In section
    10.4.1, you learned that db_filename represents a global variable, whereas the
    set_database function forms a local scope. Thus, the problem is generalized as
    changing a global variable in a local scope, which is the topic of this section.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的开始，我提出了一个问题，即我们未能通过调用 set_database 函数来更改变量 db_filename。在 10.4.1 节中，您了解到
    db_filename 代表一个全局变量，而 set_database 函数形成一个局部作用域。因此，这个问题被概括为在局部作用域中更改全局变量，这是本节的主题。
- en: 'Before I show you the solution, focus on part of the code in listing 10.7\.
    Note that I’m calling the print function to show you what’s available in the function’s
    local scope:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我向您展示解决方案之前，请关注列表 10.7 中的代码的一部分。请注意，我正在调用 print 函数来向您展示函数局部作用域中可用的内容：
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For the first assignment statement (db_filename = "N/A"), we create a variable
    named db_filename in the global scope. Then we define the set_database function
    in the next several lines. If we check the global namespace, we expect it to include
    both db_filename and set_database:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个赋值语句（db_filename = "N/A"），我们在全局作用域中创建了一个名为 db_filename 的变量。然后，在接下来的几行中定义了
    set_database 函数。如果我们检查全局命名空间，我们期望它包含 db_filename 和 set_database：
- en: '[PRE40]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the body of the set_database function, the code that requires our special
    attention is db_filename = db_name, the intention of which is to update the global
    variable db_filename. But the printout in listing 10.7 shows that it doesn’t work.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在 set_database 函数的主体中，需要我们特别注意的代码是 db_filename = db_name，其目的是更新全局变量 db_filename。但列表
    10.7 中的打印输出显示，它不起作用。
- en: 'Let’s observe one more thing before we find the explanation. You may have noticed
    that I also included an extra line of code: print(list(locals())), which generates
    the registered objects in the local scope of the set_database function. When we
    call this function, we should be able to observe the local namespace’s content:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们找到解释之前，让我们观察另一件事。您可能已经注意到，我还包括了一行额外的代码：print(list(locals()))，它生成了 set_database
    函数局部作用域中注册的对象。当我们调用这个函数时，我们应该能够观察到局部命名空间的内容：
- en: '[PRE41]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The set_database function’s local namespace has two variables: db_name and
    db_filename. When Python executes the line of code db_filename = db_name, how
    does the LEGB rule play out in resolving db_filename and db_name, respectively?'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: set_database 函数的局部命名空间有两个变量：db_name 和 db_filename。当 Python 执行 db_filename =
    db_name 这一行代码时，LEGB 规则如何分别解决 db_filename 和 db_name？
- en: The variable db_name exists only in the local scope, and it’s resolved to be
    the argument that we use for the function call. For db_filename, both local and
    global scopes have a variable with such a name, but according to the LEGB rule,
    the one in the local scope is used. As the one in the local scope has no registered
    value, Python interprets this line of code as an assignment statement to create
    a new variable instead of updating the existing global variable.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 db_name 只存在于局部作用域中，并且它被解析为我们用于函数调用的参数。对于 db_filename，局部和全局作用域都有一个具有该名称的变量，但根据
    LEGB 规则，局部作用域中的那个被使用。由于局部作用域中的那个没有注册的值，Python 将此行代码解释为创建新变量的赋值语句，而不是更新现有的全局变量。
- en: 'Now that we know what happened, it’s easier to understand the solution: using
    the global keyword to denote that a specific variable is global instead of local,
    as the next listing shows.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了发生了什么，理解解决方案就更容易了：使用全局关键字来表示一个特定的变量是全局的而不是局部的，如下面的列表所示。
- en: Listing 10.8 Changing a global variable successfully
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.8 成功改变全局变量
- en: '[PRE42]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the body of the set_database function, before the assignment, we denote that
    db_filename is global so that the local scope won’t register this name again.
    Next, we run the assignment. Python knows that it’s updating the db_filename in
    the global scope. We can observe the updated value (tasks.sqlite) by printing
    db_filename, which no longer has the initial value "N/A".
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在 set_database 函数的主体中，在赋值之前，我们表示 db_filename 是全局的，这样局部作用域就不会再次注册这个名称。接下来，我们执行赋值。Python
    知道它正在更新全局作用域中的 db_filename。我们可以通过打印 db_filename 来观察更新的值（tasks.sqlite），它不再有初始值
    "N/A"。
- en: Please note that you use the global keyword only when you attempt to change
    a global variable in a local scope. If you use the global variable without any
    assignment or update, you don’t need to use global, as it’ll be resolved through
    accessing the global scope.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你只有在尝试在局部作用域中更改全局变量时才使用 global 关键字。如果你使用全局变量而不进行任何赋值或更新，你不需要使用 global，因为它将通过访问全局作用域来解决。
- en: 10.4.3 Changing an enclosing variable
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.3 改变封闭变量
- en: In section 10.4.2, you learned about using global to change a global variable
    in a local scope. Another keyword, nonlocal, changes an enclosing variable in
    a local scope. nonlocal is used less often than global, as global scopes are everywhere,
    but enclosing scopes exist only in functions that have nested functions. Thus,
    I’ll briefly introduce changing an enclosing variable in this section. To help
    explain this feature, I’ll use the simple code example in the following listing.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 10.4.2 节中，你学习了如何在局部作用域中使用 global 来改变全局变量。另一个关键字 nonlocal 用于改变局部作用域中的封闭变量。nonlocal
    的使用频率低于 global，因为全局作用域无处不在，但封闭作用域仅存在于有嵌套函数的函数中。因此，我将简要介绍在本节中改变封闭变量的方法。为了帮助解释这个特性，我将使用以下列表中的简单代码示例。
- en: Listing 10.9 Changing a nonlocal variable
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.9 改变非局部变量
- en: '[PRE43]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the change_text function, we define a local variable text. The two inner
    functions form their own local scopes; to them, the change_text function’s scope
    is the enclosing scope. These two functions differ in whether they declare text
    as a nonlocal variable by using the nonlocal keyword. When you use the nonlocal
    keyword, you’re telling Python to use the variable text in the enclosing scope.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在 change_text 函数中，我们定义了一个局部变量 text。这两个内部函数形成它们自己的局部作用域；对于它们来说，change_text 函数的作用域是封闭作用域。这两个函数在是否通过使用
    nonlocal 关键字将 text 声明为非局部变量方面有所不同。当你使用 nonlocal 关键字时，你是在告诉 Python 使用封闭作用域中的变量
    text。
- en: From the printout, we can see that calling the inner function inner_fun1 changes
    the nonlocal variable text successfully. Calling inner_fun0 has no effect on the
    nonlocal variable text, however, because Python interprets text = "No nonlocal"
    as a regular assignment statement instead of updating the nonlocal variable.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 从打印输出中，我们可以看到调用内部函数 inner_fun1 成功地改变了非局部变量 text。然而，调用 inner_fun0 对非局部变量 text
    没有影响，因为 Python 将 text = "No nonlocal" 解释为常规的赋值语句，而不是更新非局部变量。
- en: 10.4.4 Discussion
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.4 讨论
- en: Section 10.4 covers how Python resolves variables, as well as functions and
    classes, by following the LEGB order (Local -> Enclosing -> Global -> Built-in).
    When you write code that involves multiple scopes, remember what scopes are expected
    to resolve specific variables. Because of the complication of the LEGB order,
    remember to use the global keyword if you need to update a global variable in
    a local scope. Don’t make a silly mistake by assuming that you can make the update
    by calling a function, as we attempted in listing 10.7.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 第 10.4 节涵盖了 Python 如何通过遵循 LEGB 顺序（Local -> Enclosing -> Global -> Built-in）来解析变量、函数和类。当你编写涉及多个作用域的代码时，请记住哪些作用域预期解析特定的变量。由于
    LEGB 顺序的复杂性，如果你需要在局部作用域中更新全局变量，请记住使用 global 关键字。不要犯愚蠢的错误，以为可以通过调用函数来更新，就像我们在列表
    10.7 中尝试的那样。
- en: 10.4.5 Challenge
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.5 挑战
- en: John has a programming background in Swift, the language used for creating macOS
    and iOS apps. In Swift, an if...else... statement can form a scope separate from
    the global scope. How can he find out whether the if...else... statement has its
    local scope in Python?
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 约翰有 Swift 的编程背景，Swift 是用于创建 macOS 和 iOS 应用的语言。在 Swift 中，if...else... 语句可以形成一个独立于全局作用域的作用域。他如何在
    Python 中找出 if...else... 语句是否有其局部作用域？
- en: Hint Create a global variable and attempt to change it in the if...else... statement.
    If a local scope does exist, you can’t change its value if you don’t use the global
    keyword.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：创建一个全局变量，并在 if...else... 语句中尝试更改它。如果存在局部作用域，如果你不使用 global 关键字，你将无法更改其值。
- en: 10.5 What’s callability, and what does it imply?
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.5 什么是可调用性，它意味着什么？
- en: As an OOP language, Python organizes its building blocks—such as packages, modules,
    classes, functions, and data—as different kinds of objects. Thus, understanding
    the characteristics of objects is essential to writing better Python code. In
    section 3.1, when we discussed choosing between lists and tuples, we discussed
    hashability and mutability, which refer to an object’s capability to be hashed
    and mutated, respectively.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种面向对象的语言，Python 将其构建块（如包、模块、类、函数和数据）组织为不同类型的对象。因此，理解对象的特点对于编写更好的 Python 代码至关重要。在第
    3.1 节中，当我们讨论在列表和元组之间进行选择时，我们讨论了可哈希性和可变性，分别指的是对象被哈希和修改的能力。
- en: 'Besides hashability and mutability, a key characteristic of objects is *callability*—whether
    an object can be called. As in most modern languages, we call an object in Python
    by using a pair of parentheses (the call operator). Thus, if an object can be
    used with the call operator, we say that it’s callable; if an object can’t be
    used with the call operator, it’s not callable. In fact, Python has a built-in
    function, callable, that can check an object’s callability. We know that we can
    call a function, and we should expect it to be callable, as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可哈希性和可变性之外，对象的一个关键特性是 *可调用性*——一个对象是否可以被调用。与大多数现代语言一样，我们在 Python 中通过使用一对括号（调用运算符）来调用对象。因此，如果一个对象可以用调用运算符使用，我们就说它是可调用的；如果一个对象不能用调用运算符使用，它就不是可调用的。实际上，Python
    有一个内置函数，callable，可以检查对象的可调用性。我们知道我们可以调用一个函数，并且我们应该期望它是可调用的，如下所示：
- en: '[PRE44]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The concept of callability seems to be straightforward, but callability is an
    underlying mechanism for several key features in Python. This section reviews
    the important practical implications of an object’s callability.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 可调用性的概念似乎很简单，但可调用性是 Python 中几个关键特性的底层机制。本节回顾了对象可调用性的重要实际含义。
- en: 10.5.1 Distinguishing classes from functions
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.1 区分类和函数
- en: We can call a class, such as Task("Homework", "Math and physics"), to create
    an instance object of the Task class. We can also call a function, such as print("Hello,
    World!"), to perform a defined operation. Thus, both classes and functions are
    callable, and the same callability can make it hard to distinguish classes from
    functions. You may often hear people say that Python has many useful built-in
    functions, such as list, range, and sum, but not all of them are functions. The
    first implication of callability involves the nuances between classes and functions.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调用一个类，例如 Task("Homework", "Math and physics")，来创建 Task 类的实例对象。我们也可以调用一个函数，例如
    print("Hello, World!")，来执行一个定义的操作。因此，类和函数都是可调用的，相同的可调用性可能会使得区分类和函数变得困难。你可能经常听到人们说
    Python 有很多有用的内置函数，比如 list、range 和 sum，但并非所有这些都是函数。可调用的第一个含义涉及到类和函数之间的细微差别。
- en: Concept *Callable* means an object that can be called. When a function expects
    a callable, such as the sorted function’s key argument, you can pass a function
    or a class. If you have a custom class that implements __call__, you can use an
    instance of that class as a callable too!
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: “可调用”这个概念意味着一个可以被调用的对象。当一个函数期望一个可调用对象，例如 sorted 函数的 key 参数时，你可以传递一个函数或一个类。如果你有一个实现了
    __call__ 的自定义类，你也可以使用该类的实例作为可调用对象！
- en: Many of these “functions” are not functions. Instead, they are classes, such
    as bool, int, and dict, as opposed to callable and hash, which are functions.
    The major reason why they’re not easy to differentiate is their shared callability,
    but the difference is notable from a semantic perspective. When we call these
    classes, we obtain an instance object of the class, such as calling bool to obtain
    a bool object, and calling dict returns a dict object.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这些“函数”中的许多并不是函数。相反，它们是类，例如 bool、int 和 dict，与 callable 和 hash 这样的函数不同。它们之所以难以区分的主要原因是它们共享的可调用性，但从语义角度来看，这种差异是明显的。当我们调用这些类时，我们得到的是该类的实例对象，例如调用
    bool 得到一个 bool 对象，调用 dict 返回一个 dict 对象。
- en: 'Trivia These built-in classes have their names in lowercase, as opposed to
    the camel naming convention for custom classes. Naming these built-in types in
    lowercase is for historic reasons: they were named that way in early versions
    of Python.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 逸事：这些内置类的名称都是小写，这与自定义类的驼峰命名法相反。将这些内置类型命名为小写是出于历史原因：在 Python 的早期版本中就是这样命名的。
- en: By contrast, real functions aren’t directly associated with any underlying classes.
    Thus, we don’t get an instance object of the same name by calling these functions.
    We don’t expect to get a sum object by calling sum or a hash object by calling
    hash, for example. By contrast, we do obtain a range object by calling range or
    a slice object by calling slice.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，真实函数并不直接与任何底层类相关联。因此，通过调用这些函数，我们不会得到同名实例对象。例如，我们不会期望通过调用 sum 得到一个 sum 对象，或者通过调用
    hash 得到一个 hash 对象。相反，我们可以通过调用 range 得到一个 range 对象，或者通过调用 slice 得到一个切片对象。
- en: 10.5.2 Revisiting the higher-order function map
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.2 重新审视高阶函数映射
- en: One manifestation of Python’s functional programming is *higher-order functions**:*
    functions that take other functions as an argument or return functions as the
    output. Section 7.2 introduced one higher-order function, map, but is it a real
    function? Your intuition may tell you that it is. Intuition can be wrong, however.
    We’ll revisit map in this section.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Python 函数式编程的一个表现是*高阶函数**：接受其他函数作为参数或返回函数作为输出的函数。第 7.2 节介绍了一个高阶函数 map，但它真的是一个函数吗？你的直觉可能会告诉你它是。然而，直觉可能会出错。我们将在本节中重新审视
    map。
- en: 'The easiest way to inspect an object is to call it with the print function.
    We expect a custom or built-in function to be a function:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 检查一个对象的最简单方法是用 print 函数调用它。我们期望一个自定义或内置函数是一个函数：
- en: '[PRE45]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If map is indeed a function, we should expect a printed message telling us
    that it’s a built-in function, such as sum. Let’s see whether that’s the case:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 map 确实是一个函数，我们应该期望一个打印的消息告诉我们它是一个内置函数，例如 sum。让我们看看这是否是事实：
- en: '[PRE46]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Unlike what you may have thought, map isn’t a function. Instead, it’s a class:
    the map class. Consistent with map’s being a class, calling map creates a map
    object, like built-in classes such as list and dict:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 与你想象的可能不同，map 不是一个函数。相反，它是一个类：map 类。与 map 是一个类的事实一致，调用 map 创建了一个 map 对象，就像内置类
    list 和 dict 一样：
- en: '[PRE47]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The misconception that map is a function may result from the assumption that
    classes usually take nonfunction objects for instance construction. Don’t forget,
    however, that all of Python’s functions are objects. Thus, the map class is special
    in the sense that the construction involves accepting functions as an argument.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 认为 map 是一个函数的误解可能源于这样的假设，即类通常使用非函数对象进行实例构造。然而，不要忘记，Python 的所有函数都是对象。因此，map 类在构造时接受函数作为参数是特殊的。
- en: 10.5.3 Using callable as the key argument
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.3 使用可调用对象作为键参数
- en: Several Python functions include a parameter called key that’s used when functions
    perform sorting, such as sorted, or comparison, such as max. In section 3.2, the
    list’s sort method uses a function as key; we may have an assumption that we can
    use only a function for the key argument. But any callable can be the key argument,
    as discussed in this section.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 几个 Python 函数包括一个名为 key 的参数，当函数执行排序（如 sorted）或比较（如 max）时使用。在第 3.2 节中，列表的 sort
    方法使用了一个函数作为 key；我们可能有一个假设，即我们只能为 key 参数使用函数。但正如本节所讨论的，任何可调用对象都可以作为 key 参数。
- en: 'The easiest scenario for using a class instead of a function as the key argument
    in sorted is using the built-in str class. Suppose that we want to sort a list
    of poker cards. Without setting a key argument, the sorting fails due to the inability
    to compare integers and strings:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类而不是函数作为 sorted 的键参数的最简单场景是使用内置的 str 类。假设我们想要对一个扑克牌列表进行排序。如果没有设置键参数，由于无法比较整数和字符串，排序将失败：
- en: '[PRE48]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Because str is used as the key, the sorting can happen, but the order isn’t
    right: A should be greater than J. Let’s solve the problem by creating a class,
    PokerOrder, as shown in the next listing.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 因为使用了字符串作为键，所以可以进行排序，但顺序不正确：A 应该大于 J。让我们通过创建一个名为 PokerOrder 的类来解决这个问题，如下一列表所示。
- en: Listing 10.10 Creating a custom class for sorting poker cards
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.10 创建用于排序扑克牌的自定义类
- en: '[PRE49]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Reminder When we’re trying to retrieve a value from a dict object, the get method
    can include a fallback value when the key doesn’t exist.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：当我们尝试从一个字典对象中检索值时，如果键不存在，get 方法可以包含一个回退值。
- en: 'In the PokerOrder class, we override the __new__ method so that we can modify
    the default behavior when we construct an instance of the PokerOrder, which is
    a subclass of int. Notably, as covered in section 8.1, super() creates a proxy
    object that refers to the superclass int, which expects to take a number (the
    casted_number in our implementation) to construct an instance. Specifically, if
    the card is between 2 and 10, we use the number. If the card is J, Q, K, or A,
    we cast it to its corresponding integers so the class can map the non-number cards
    to the correct numeric values. Let’s sort them now:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PokerOrder 类中，我们重写了 `__new__` 方法，这样我们就可以在构造 PokerOrder 的实例时（PokerOrder 是 int
    的子类）修改默认行为。值得注意的是，如第8.1节所述，`super()` 创建了一个代理对象，它引用了超类 int，该超类期望接收一个数字（在我们的实现中是
    casted_number）来构造一个实例。具体来说，如果牌在2到10之间，我们使用这个数字。如果牌是 J、Q、K 或 A，我们将其转换为相应的整数，这样类就可以将非数字牌映射到正确的数值。现在让我们对它们进行排序：
- en: '[PRE50]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 10.5.4 Creating decorators as classes
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.4 将装饰器作为类创建
- en: 'In section 7.3, you learned about creating decorators, which are higher-order
    functions that modify decorated functions without affecting the intended operations
    of the decorated functions. Behind the scenes, the decoration process sends the
    to-be-decorated function to the decorator. That is, the decoration process essentially
    calls a higher-order function. Because classes are also callable, this characteristic
    allows us to create decorators in the form of a custom class, as shown in this
    section. To refresh your memory, the following code snippet shows how to create
    a decorator that can log a function’s execution time:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7.3节中，你学习了如何创建装饰器，装饰器是高阶函数，它修改被装饰的函数而不影响被装饰函数的预期操作。幕后，装饰过程将待装饰的函数发送到装饰器。也就是说，装饰过程本质上调用了一个高阶函数。因为类也是可调用的，这个特性允许我们以自定义类的形式创建装饰器，如本节所示。为了刷新你的记忆，以下代码片段显示了如何创建一个可以记录函数执行时间的装饰器：
- en: '[PRE51]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Please note that I use only the minimum elements for a decorator. If you’re
    unfamiliar with decorators, refer to section 7.3 for best practices in creating
    a decorator. To convert this function to a class, bear in mind that the constructor
    for the class expects to take a function as its argument. We may have the following
    solution:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我只为装饰器使用了最基本元素。如果你对装饰器不熟悉，请参考第7.3节以获取创建装饰器的最佳实践。要将此函数转换为类，请记住类构造函数期望接收一个函数作为其参数。我们可能有以下解决方案：
- en: '[PRE52]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Notice two things in this code snippet:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个代码片段中的两点：
- en: The protected attribute _logger is used to store the created inner function
    internally, as we know that the decoration process is creating a closure, which
    is an inner function.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受保护的属性 `_logger` 用于内部存储创建的内部函数，正如我们所知，装饰过程正在创建一个闭包，这是一个内部函数。
- en: We override the special method __call__, which is invoked when we try to call
    an instance of the class. That is, when we call the decorated function, we should
    call the closure instead, which is the _logger attribute. Note that by implementing
    __call__ in a custom class, we make the instances of the class callable. Thus,
    as shown in figure 10.9, we should know that besides functions and classes, instance
    objects of a class that implements __call__ are also callable, as in the case
    of the TimeLogger class.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们重写了 __call__ 特殊方法，当尝试调用类的实例时会被调用。也就是说，当我们调用装饰过的函数时，我们应该调用闭包，即 _logger 属性。请注意，通过在自定义类中实现
    __call__，我们使类的实例可调用。因此，如图 10.9 所示，我们应该知道除了函数和类之外，实现了 __call__ 的类的实例对象也是可调用的，就像
    TimeLogger 类的情况一样。
- en: '![CH10_F09_Cui](../Images/CH10_F09_Cui.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![CH10_F09_Cui](../Images/CH10_F09_Cui.png)'
- en: Figure 10.9 Three types of callable objects and their expected results after
    calling. You call functions to get their return values. You call classes to get
    instance objects. And you call a callable instance to get the result of the __call__
    method.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 三种可调用对象及其调用后的预期结果。你调用函数以获取它们的返回值。你调用类以获取实例对象。你调用一个可调用实例以获取 __call__ 方法的返回结果。
- en: 'With this class, we can use the same syntax to decorate a function:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个类，我们可以用相同的语法来装饰一个函数：
- en: '[PRE53]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Note, however, that the decorated function is no longer a function. Instead,
    it’s an instance object of the TimeLogger class:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，装饰过的函数不再是一个函数。相反，它变成了 TimeLogger 类的一个实例对象：
- en: '[PRE54]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: By default, we can’t call an instance object. We can’t write [1, 2, 3]() or
    "Hello, World!"(), for example. To make this instance object behave like a function,
    we override the __call__ special method, which returns the _logger attribute—a
    function and therefore callable. In other words, we pass the call operation of
    an instance object to its function attribute (_logger) to make this instance object
    callable.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们不能调用一个实例对象。例如，我们不能写 [1, 2, 3]() 或 "Hello, World!"()。为了使这个实例对象表现得像一个函数，我们重写了
    __call__ 特殊方法，它返回 _logger 属性——一个函数，因此是可调用的。换句话说，我们将实例对象的调用操作传递给它的函数属性 (_logger)，使这个实例对象可调用。
- en: 10.5.5 Discussion
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.5 讨论
- en: This section focuses on Python objects’ callability—their ability to be called
    by the call operator (). In essence, both classes and functions are callable,
    which creates a lot of crosstalk possibilities, such as serving as the key argument
    and creating a decorator by using a custom class. Particularly in the latter case,
    you can implement complicated decorators that take parameters. Using a class makes
    it easier to offer this flexibility, as you can add other attributes to the instance
    object.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 本节重点介绍 Python 对象的可调用性——它们被调用操作符 () 调用的能力。本质上，类和函数都是可调用的，这创造了大量的交叉可能性，例如作为键参数和使用自定义类创建装饰器。特别是在后一种情况下，你可以实现接受参数的复杂装饰器。使用类使得提供这种灵活性变得更容易，因为你可以向实例对象添加其他属性。
- en: 10.5.6 Challenge
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.6 挑战
- en: Ruby creates the TimeLogger class as a decorator to log the functions’ performance
    in her project. As discussed in section 7.3, one best practice for implementing
    a decorator is using the wraps decorator from the functools module. How should
    she use the wraps in the TimeLogger class?
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 在她的项目中创建 TimeLogger 类作为装饰器来记录函数的性能。如第 7.3 节所述，实现装饰器的一个最佳实践是使用 functools
    模块中的 wraps 装饰器。她应该如何在 TimeLogger 类中使用 wraps？
- en: Hint We wrap the decorated function before we define the inner function.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：在我们定义内部函数之前，我们包装了装饰过的函数。
- en: Summary
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: We can check the type of an object by using the built-in type function. Obtaining
    the type information during the run time of our program makes it possible for
    us to write flexible code.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用内置的 type 函数来检查对象的类型。在程序运行时获取类型信息使我们能够编写灵活的代码。
- en: The isinstance function can check whether an object is an instance of a class
    or a tuple of classes. isinstance is also more flexible than type, as it gives
    us a valid result if the checked class has a superclass.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: isinstance 函数可以检查一个对象是否是某个类或类元组的实例。isinstance 比 type 更灵活，因为它如果检查的类有一个超类，也会给出有效结果。
- en: The collections.abc module allows us to check an object’s generic type to apply
    the same operations to multiple classes that implement the same interface.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: collections.abc 模块允许我们检查对象的通用类型，以便对实现相同接口的多个类应用相同的操作。
- en: 'An instance object of a class goes through this process: Instantiation -> active
    in a namespace -> being tracked regarding the reference counts (happening simultaneously
    with its activeness in a namespace) -> destruction.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类的实例对象会经历以下过程：实例化 -> 在命名空间中激活 -> 跟踪引用计数（与其在命名空间中的激活同时发生）-> 销毁。
- en: When you make a copy of an object, the default copying behavior is copying only
    the outmost data container, termed a shallow copy.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你复制一个对象时，默认的复制行为是仅复制最外层数据容器，这被称为浅拷贝。
- en: When you need the copy to have distinct copies for the contained mutable objects,
    you should create a deep copy, allowing you to manipulate the inner mutable objects
    without affecting the original one.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要复制包含的可变对象的独立副本时，你应该创建一个深拷贝，这样你就可以在不影响原始对象的情况下操作内部的可变对象。
- en: The built-in copy module is designed to copy objects in a standard way. But
    you can override __copy__ and __deepcopy__ if you want to define customized copying
    behaviors for your class.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置的copy模块旨在以标准方式复制对象。但如果你想要为你的类定义自定义的复制行为，你可以覆盖__copy__和__deepcopy__方法。
- en: When Python needs to resolve a variable or a name in general, it uses the LEGB
    rule (Local -> Enclosing -> Global -> Built-in) to find a value for the used name.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当Python需要解析一个变量或名称时，它使用LEGB规则（局部 -> 封闭 -> 全局 -> 内置）来找到使用名称的值。
- en: When you want to change a variable in a local scope, dependent on where the
    variable is initially defined, you need to use the global or nonlocal keyword,
    the former for a globally defined variable and the latter for a variable in the
    enclosing scope, which exists only for a nested function.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想要在局部作用域中更改一个变量，且该变量最初定义的位置不同时，你需要使用全局或非局部关键字，前者用于全局定义的变量，后者用于封装作用域中的变量，它仅存在于嵌套函数中。
- en: Both classes and functions are callable natively. Despite the shared callability,
    you need to know the distinction between classes and functions for the built-in
    functions. Because of the shared callability, you can use classes and functions
    in some common scenarios, such as using them as a key argument or creating a decorator.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类和函数都可以原生调用。尽管它们具有相同的可调用性，但你仍需要了解类和函数之间的区别，尤其是在内置函数方面。由于可调用性的共享，你可以在某些常见场景中使用类和函数，例如将它们用作键参数或创建装饰器。
