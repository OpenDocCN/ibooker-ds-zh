- en: 6 Projecting monopartite networks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 投影单部分网络
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Translating an indirect graph pattern into a direct relationship
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将间接图模式转换为直接关系
- en: Using Cypher projection to project an in-memory graph
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Cypher投影将内存图投影出来
- en: Presenting self-loops
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示自环
- en: Introducing weighted variations of degree and PageRank centrality algorithms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍加权变体的度数和PageRank中心性算法
- en: In the previous chapter, you performed a network analysis of the Twitter follower
    network. The decision to start with the follower network was straightforward.
    Most graph algorithms are designed to be executed on a monopartite network, where
    only a single node and relationship type are present. However, the Twitter social
    network schema contains multiple node types and relationships. Instead of adjusting
    graph algorithms to support multipartite networks (multiple node and relationship
    types), the general approach is to first project a monopartite network (single
    node and relationship type). I have briefly alluded to this concept in chapter
    2, where I presented some options on how to infer monopartite projections on the
    Twitter social network.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你对Twitter关注者网络进行了网络分析。决定从关注者网络开始是直截了当的。大多数图算法都是设计在单部分网络中执行的，其中只有一个节点和关系类型。然而，Twitter社交网络模式包含多种节点类型和关系。而不是调整图算法以支持多部分网络（多个节点和关系类型），一般的方法是首先将单部分网络（单个节点和关系类型）投影出来。我在第二章中简要提到了这个概念，其中我介绍了一些如何在Twitter社交网络上进行单部分投影的选项。
- en: Suppose you want to analyze how content spreads on Twitter and which users are
    the most influential content creators. Users can post content in the form of tweets.
    However, for a tweet to reach a wider audience and possibly go viral, it must
    be shared by other users with their audiences. On Twitter, sharing other people’s
    content with your audience is called retweeting. So to understand which are the
    most influential content creators, you need to examine the retweeting behavior
    of the network. Many studies have been published using the retweet network, ranging
    from a network analysis of the European Parliament (Cherepnalkoski & Mozetič,
    2015) to science- and health-related retweet clusters on Twitter during the COVID-19
    pandemic (Durazzi et al., 2021). The most influential content creators on Twitter
    can be defined as users who publish the most retweeted content. However, you can
    take it up a notch and assume that it is not only the number of retweets that
    is important but also who is retweeting. For example, there is a large difference
    between a user like Andrew Ng, who is well respected in the machine learning world,
    sharing your content and someone who just joined the platform and has no audience
    doing the same. Therefore, Andrew Ng’s retweet gives you more content influence
    than a user with no audience.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想分析内容在Twitter上的传播方式以及哪些用户是最有影响力的内容创作者。用户可以以推文的形式发布内容。然而，为了让推文触及更广泛的受众并可能成为病毒式传播，它必须被其他用户与他们的受众分享。在Twitter上，将他人的内容与你的受众分享称为转发。因此，为了了解哪些是最有影响力的内容创作者，你需要检查网络的转发行为。许多研究已经使用转发网络发表，从2015年关于欧洲议会的网络分析（Cherepnalkoski
    & Mozetič）到COVID-19大流行期间Twitter上与科学和健康相关的转发集群（Durazzi等人，2021）。Twitter上最有影响力的内容创作者可以定义为发布最多被转发的内容的用户。然而，你可以更进一步，假设不仅转发数量很重要，转发的人也很重要。例如，像Andrew
    Ng这样的用户，在机器学习领域享有盛誉，分享你的内容与一个刚刚加入平台且没有受众的人做同样的事情，这之间有很大的区别。因此，Andrew Ng的转发给你的内容带来的影响力比一个没有受众的用户要大得多。
- en: In general, centrality algorithms are a good fit for determining the most important
    or influential nodes in the network. Let’s say you decide to use the PageRank
    algorithm, as you have already heard about it in the previous chapter. The PageRank
    algorithm is also a good match, as it considers both the number of incoming relationships
    and from which nodes they come to calculate the influence of a node in a network.
    To determine how you can utilize PageRank to identify the most influential content
    creators, you must consider the graph model you used to represent the retweet
    pattern in the Twitter social network.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，中心性算法非常适合确定网络中最重要或最有影响力的节点。比如说，你决定使用PageRank算法，因为你已经在上一章中听说过它。PageRank算法也是一个很好的选择，因为它既考虑了进入关系的数量，也考虑了这些关系来自哪些节点，以此来计算网络中一个节点的影响力。为了确定如何利用PageRank来识别最有影响力的内容创作者，你必须考虑你用来表示Twitter社交网络中转发模式的图模型。
- en: In your Twitter social network schema, a user can publish a tweet as visualized
    on the right side of figure 6.1\. However, when another user retweets a tweet,
    a new `Tweet` node is created with a `RETWEETS` relationship pointing to the original
    tweet. If you were to execute the PageRank algorithm on the network in figure
    6.1, which node would be the most important? Remember that PageRank treats each
    relationship as a vote of confidence or influence. The influence then flows throughout
    the network. Please take a minute or two to think about which node in the network
    in figure 6.1 would be the most important based on the PageRank algorithm. For
    me, it is easier to start with the least influential nodes and work my way up
    to the most important ones.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的Twitter社交网络模式中，用户可以发布推文，如图6.1右侧所示。然而，当另一个用户重发一条推文时，会创建一个新的`Tweet`节点，并带有指向原始推文的`RETWEETS`关系。如果您要在图6.1的网络中执行PageRank算法，哪个节点最重要？请记住，PageRank将每个关系视为信任或影响力的投票。然后，这种影响力在整个网络中流动。请花一两分钟思考一下，根据PageRank算法，图6.1网络中的哪个节点最重要。对我来说，从最不具影响力的节点开始，逐步向上到最重要的节点更容易。
- en: '![06-01](../../OEBPS/Images/06-01.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![06-01](../../OEBPS/Images/06-01.png)'
- en: Figure 6.1 Graph model that represents a retweet pattern
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1表示重发模式图模型
- en: Figure 6.2 visualizes the retweet pattern, where node sizes are scaled based
    on their PageRank score. The bigger the node is, the higher its PageRank score.
    User nodes have no incoming relationships, so their PageRank score is the lowest.
    Both the original tweet and the retweet have incoming relationships, so they are
    already more important than users. The retweet has a single incoming relationship,
    and the original tweet has two incoming connections. With the PageRank algorithm,
    both the count of incoming links as well as the importance of nodes linking to
    a particular node are considered when calculating the PageRank score. So it is
    not always given that a node with more incoming links will have a higher score.
    However, in the retweet network in figure 6.2, the original tweet draws influence
    from its author as well as the retweet and the retweet’s author. On the other
    hand, the retweet node draws influence only from the retweet’s author, which means
    the retweet will be less important than the original tweet.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2可视化了重发模式，节点大小根据其PageRank分数进行缩放。节点越大，其PageRank分数越高。用户节点没有进入关系，因此它们的PageRank分数最低。原始推文和重发都有进入关系，因此它们比用户更重要。重发有一个进入关系，原始推文有两个进入连接。在PageRank算法中，计算PageRank分数时考虑了进入链接的数量以及链接到特定节点的节点的重要性。因此，并不总是说具有更多进入链接的节点会有更高的分数。然而，在图6.2的重发网络中，原始推文从其作者以及重发和重发的作者那里获得影响力。另一方面，重发节点只从重发的作者那里获得影响力，这意味着重发将比原始推文不那么重要。
- en: '![06-02](../../OEBPS/Images/06-02.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![06-02](../../OEBPS/Images/06-02.png)'
- en: Figure 6.2 Retweet pattern where the node size represents its PageRank score
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2表示节点大小代表其PageRank分数的重发模式
- en: As visualized in figure 6.2, the influence flows from users to tweets and, optionally,
    through retweet relationships to the original content. In theory, the content
    with the highest retweet count will have the highest PageRank score. There are
    some exceptions, as the importance of tweets and retweets drops with a higher
    number of published tweets and retweets by a user; however, it is still a good
    approximation of which tweets were the most retweeted. You could then aggregate
    the importance of tweets by users and identify the most influential users. Unfortunately,
    this approach ignores one major item in your definition of influential content
    creators. Since users don’t have any incoming relationships, the PageRank score
    is identical for all users, and the algorithm does not differentiate between important
    and unimportant users. Consequently, the PageRank score does not reflect whether
    influential users retweeted the content.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如图6.2所示，影响力从用户流向推文，并且可选地通过重发关系流向原始内容。理论上，重发次数最多的内容将具有最高的PageRank分数。有一些例外，因为推文和重发的数量随着用户发布的推文和重发数量的增加而降低其重要性；然而，这仍然是一个很好的近似，可以确定哪些推文被转发得最多。然后，您可以汇总用户推文的重要性，并识别最有影响力的用户。不幸的是，这种方法忽略了你定义有影响力内容创作者的一个主要项目。由于用户没有任何进入关系，所有用户的PageRank分数是相同的，算法无法区分重要用户和不重要用户。因此，PageRank分数并不能反映有影响力的用户是否转发过内容。
- en: Interestingly, with network analysis, it is more frequent to adapt the dataset
    to fit the algorithm than the other way around. To determine which users are the
    most influential based on retweeting behavior, you must somehow model the influence
    flow between users. It turns out that the best way to model influence flow between
    users is to reduce the network where both users and tweets are present to a monopartite
    network where only users are considered. As a monopartite network contains only
    a single type of nodes, you need to somehow exclude `Tweet` nodes while preserving
    the information about the retweets. If a user retweets a post from another user,
    they increase or amplify the reach of the original tweet and, consequently, the
    author of the original tweet. You can represent how users amplify other users’
    content reach with a direct relationship. How you want to name the new *inferred
    relationship* depends on your domain and use case. In this example, I will name
    the new relationship type `AMPLIFY`, since it is used to represent how users amplify
    the reach of one another through retweets. The term *inferred relationship* means
    the relationship is not explicitly defined in data but is inferred or created
    based on some assumptions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在数据分析中，更常见的是根据算法调整数据集，而不是相反。为了确定哪些用户基于转发行为最具影响力，你必须以某种方式模拟用户之间的影响力流动。结果证明，在用户和推文都存在的网络中，将网络简化为只考虑用户的单部分网络是模拟用户之间影响力流动的最佳方式。由于单部分网络只包含一种类型的节点，你需要以某种方式排除
    `Tweet` 节点，同时保留关于转发的信息。如果一个用户转发另一个用户的帖子，他们会增加或放大原始推文的覆盖范围，从而也增加了原始推文作者的覆盖范围。你可以用一个直接关系来表示用户如何放大其他用户的
    内容覆盖范围。你想要给这个新的 *推断关系* 起什么名字取决于你的领域和用例。在这个例子中，我将这个新的关系类型命名为 `AMPLIFY`，因为它用来表示用户通过转发如何相互放大对方的覆盖范围。*推断关系*
    这个术语意味着这种关系在数据中并没有明确定义，而是基于某些假设推断或创建的。
- en: Figure 6.3 shows the concept of translating a graph pattern between two `User`
    nodes that spans over three relationships into a direct link between the two.
    On the left side of this visualization is the retweet pattern as it is stored
    in the database. However, since you want to evaluate how influential users are
    based on retweet patterns with the PageRank algorithm, you need to transform the
    indirect path between the two users into a direct relationship, as indicated on
    the right side of figure 6.3\. The influence will flow between users using a direct
    relationship to model retweet behavior. Consequently, the PageRank algorithm will
    consider both the number of retweets as well as who retweeted the content in the
    final score when executed on the monopartite network, where the retweet pattern
    is modeled as a direct relationship.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3展示了将两个 `User` 节点之间跨越三个关系的图模式转换为两个节点之间直接链接的概念。在这个可视化的左侧是存储在数据库中的转发模式。然而，由于你想根据转发模式使用PageRank算法评估用户的影响力，你需要将两个用户之间的间接路径转换为直接关系，如图6.3的右侧所示。影响力将通过直接关系在用户之间流动，以模拟转发行为。因此，当在单部分网络中执行时，PageRank算法将考虑转发次数以及谁转发了内容，在最终得分中都会考虑，其中转发模式被模拟为直接关系。
- en: '![06-03](../../OEBPS/Images/06-03.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![06-03](../../OEBPS/Images/06-03.png)'
- en: Figure 6.3 Translating an indirect retweet pattern into a direct `AMPLIFY` relationship
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 将间接转发模式转换为直接的 `AMPLIFY` 关系
- en: You could easily describe this network transformation with a Cypher statement.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用Cypher语句轻松描述这种网络转换。
- en: Listing 6.1 Describing the translation of the indirect retweet pattern to a
    direct `AMPLIFY` relationship
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.1 描述将间接转发模式转换为直接 `AMPLIFY` 关系的翻译
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After you have transformed all the retweet patterns into a direct relationship,
    you end up with a monopartite network that contains only `User` nodes and `AMPLIFY`
    relationships (figure 6.4).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在将所有转发模式转换为直接关系之后，你最终会得到一个只包含 `User` 节点和 `AMPLIFY` 关系的单部分网络（图6.4）。
- en: Figure 6.4 visualizes a subgraph of the projected or inferred monopartite network
    that represents `User` nodes and `AMPLIFY` relationships, constructed based on
    the retweet pattern. Since a user can retweet posts from other users multiple
    times, you can store the count as the relationship property. Therefore, you can
    describe the network in figure 6.4 as directed and weighted. The same idea of
    a reduced monopartite network, where nodes represent only users and relationships
    represent the retweets between users, has been used by many researchers (Evkoski
    et al., 2020; Evkoski et al., 2021; Priyanta & Prayana Trisna, 2019).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4可视化了一个投影或推断的单部分网络子图，它代表了基于转发模式的`User`节点和`AMPLIFY`关系，构建了基于转发模式。由于一个用户可以从其他用户那里多次转发帖子，你可以将计数存储为关系属性。因此，你可以将图6.4中的网络描述为有向和加权的。许多研究人员（Evkoski等，2020；Evkoski等，2021；Priyanta
    & Prayana Trisna，2019）已经使用了表示只有用户节点和表示用户之间转发的关系的简化单部分网络的概念。
- en: '![06-04](../../OEBPS/Images/06-04.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![06-04](../../OEBPS/Images/06-04.png)'
- en: Figure 6.4 Projected monopartite network of `User` nodes and `AMPLIFY` relationships
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 投影的单部分网络，包括`User`节点和`AMPLIFY`关系
- en: The inferred amplify network could then be used to examine the users who produce
    the best (most sharable) content under the assumption that the retweet means that
    a user liked the content of the original tweet. I would imagine that if you want
    to express your disagreement with the tweet’s content, you would quote the tweet
    and describe your dispute with the tweet. You defined that the quote and retweet
    should be stored under a different relationship type in the original graph schema.
    However, since there are no quotes in the dataset, you could assume that all the
    retweets are positive, meaning users agree with the original tweet’s content.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 基于假设转发意味着用户喜欢原始推文的内文，推断出的放大网络可以用来检查产生最佳（最具可分享性）内容的用户。我想象如果你想要表达对推文内容的反对意见，你会引用推文并描述你对推文的争议。你定义说，引用和转发应该存储在原始图模式的不同关系类型下。然而，由于数据集中没有引用，你可以假设所有转发都是积极的，这意味着用户同意原始推文的内容。
- en: You will learn more details and caveats of various approaches to inferring monopartite
    networks through practical examples. To follow the exercises in this chapter,
    you need to have the Twitter network imported into the Neo4j database, as described
    in chapter 3.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过实际示例了解更多关于推断单部分网络的详细信息和注意事项。为了跟随本章的练习，你需要将Twitter网络导入到Neo4j数据库中，如第3章所述。
- en: 6.1 Translating an indirect multihop path into a direct relationship
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 将间接多跳路径转换为直接关系
- en: You will begin by translating the multihop retweet relationship into a direct
    `AMPLIFY` relationship (figure 6.5). With Neo4j Graph Data Science (GDS), you
    could take two different approaches to accomplish this task.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你将首先将多跳转发关系转换为直接的`AMPLIFY`关系（图6.5）。使用Neo4j图数据科学（GDS），你可以采取两种不同的方法来完成这个任务。
- en: '![06-05](../../OEBPS/Images/06-05.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![06-05](../../OEBPS/Images/06-05.png)'
- en: Figure 6.5 Two options to translate an indirect multihop path to a direct relationship
    in a projected graph
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 在投影图中将间接多跳路径转换为直接关系的两种选项
- en: To project a monopartite retweet network with native projection, you must first
    materialize it in your Neo4j database. Native projection does not offer custom
    network transformations during graph loading. On the other hand, you can use Cypher
    projection to load a *virtual graph* into memory. In this context, a virtual graph
    is a graph that is not stored in the database and is constructed only at projection
    time. The ability to project custom transformations without storing them in the
    database is a nice feature that lets you explore various graph projections and
    analyze them while keeping the graph database clean. Cypher projection features
    all the expressivity of the Cypher query language to select, filter, and transform
    the graph to be projected. In the following subsection, you will learn how to
    use Cypher projection to avoid storing the monopartite retweet network in the
    database.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用原生投影投影单部分转发网络，你必须首先在Neo4j数据库中实例化它。原生投影在图加载期间不提供自定义网络转换。另一方面，你可以使用Cypher投影将一个*虚拟图*加载到内存中。在这个上下文中，虚拟图是一个不在数据库中存储，仅在投影时构建的图。能够在不将自定义转换存储在数据库中的情况下进行投影是一个很好的特性，它让你可以探索各种图投影并在保持图数据库清洁的同时分析它们。Cypher投影具有Cypher查询语言的全部表达能力，用于选择、过滤和转换要投影的图。在下面的子节中，你将学习如何使用Cypher投影来避免在数据库中存储单部分转发网络。
- en: 6.1.1 Cypher projection
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.1 Cypher 投影
- en: Cypher projection, shown in the following listing, is a more flexible and expressive
    approach to projecting an in-memory graph. As you might deduce from the feature’s
    name, you can use Cypher statements to define the nodes and relationships you
    want to load in the in-memory graph. The Cypher projection function is called
    `gds.graph .project` and has three mandatory and two optional parameters.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，Cypher 投影是一种更灵活和表达性的方法来投影内存图。如您从该功能的名称中推断出的那样，您可以使用 Cypher 语句来定义您想要加载到内存图中的节点和关系。Cypher
    投影函数称为 `gds.graph.project`，有三个强制参数和两个可选参数。
- en: Listing 6.2 Cypher projection syntax
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.2 Cypher 投影语法
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Cypher statement to match the desired graph pattern
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 匹配所需图模式的 Cypher 语句
- en: ❷ Projected graph name
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 投影图名称
- en: ❸ Source node of a relationship
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 关系的源节点
- en: ❹ Target node of a relationship
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 关系的目标节点
- en: ❺ Optional property and type configuration map
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 可选的属性和类型配置映射
- en: ❻ Optional parameter map to define undirected relationships
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 定义无向关系的可选参数映射
- en: You can think of Cypher projection as using Cypher statements to describe relationships
    of a projected graph, where each connection is defined with its source and target
    nodes. First, you must use the Cypher syntax to match the source and target nodes
    of the relationships you want to project. As mentioned, you can match existing
    relationships in the database or define virtual connections not materialized in
    the database. Once you have specified the source and target nodes of the desired
    relationships, you can use the `gds.graph.project` function in a `WITH` or `RETURN`
    clause to project a graph instead of having to use the `CALL` clause. The first
    parameter of the `gds.graph .project` function is used to define the name of the
    projected in-memory graph. On the other hand, the second and third parameters
    describe the source and target nodes of the projected relationship. The fourth
    parameter is optional and is used to specify node and relationship properties
    and their labels or types, if needed. By defining node labels and relationship
    types, you can efficiently filter them at algorithm runtime.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将 Cypher 投影视为使用 Cypher 语句描述投影图的连接关系，其中每个连接都由其源节点和目标节点定义。首先，您必须使用 Cypher 语法匹配您想要投影的关系的源节点和目标节点。如前所述，您可以匹配数据库中的现有关系或定义数据库中未实体化的虚拟连接。一旦指定了所需关系的源节点和目标节点，您就可以在
    `WITH` 或 `RETURN` 子句中使用 `gds.graph.project` 函数来投影图，而不是必须使用 `CALL` 子句。`gds.graph.project`
    函数的第一个参数用于定义投影内存图的名称。另一方面，第二个和第三个参数描述了投影关系的源节点和目标节点。第四个参数是可选的，用于指定节点和关系属性及其标签或类型（如果需要）。通过定义节点标签和关系类型，您可以在算法运行时有效地过滤它们。
- en: Note Cypher projection is a more flexible and expressive approach to describing
    the graph you project. Essentially, it is a way of defining the projected graph
    using the node and relationship lists. As the relationship list is defined using
    Cypher statements, you can take full advantage of the expressiveness of Cypher
    Query Language to filter or transform the desired graph projection, without having
    to materialize it first in the database. However, there is a downside to this
    approach, as the performance of Cypher projection is worse than that of native
    projection. Because of its inferior performance, Cypher projection is not recommended
    for larger graphs or the production phase.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Cypher 投影是描述您投影的图的一种更灵活和表达性的方法。本质上，它是一种使用节点和关系列表定义投影图的方式。由于关系列表是使用 Cypher
    语句定义的，您可以利用 Cypher 查询语言的全部表达性来过滤或转换所需的图投影，而无需首先在数据库中将其实体化。然而，这种方法有一个缺点，即 Cypher
    投影的性能不如原生投影。由于其性能较差，Cypher 投影不建议用于大型图或生产阶段。
- en: Next, you will use Cypher projection to load the retweet amplify network as
    an in-memory graph. You must prepare the relationship Cypher statement before
    using Cypher projection to load the in-memory graph and execute graph algorithms.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将使用 Cypher 投影来将重推放大网络加载为内存图。在使用 Cypher 投影加载内存图并执行图算法之前，您必须准备关系 Cypher 语句。
- en: Exercise 6.1
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 6.1
- en: Describe the retweet pattern in the `MATCH` statement. Return the user that
    retweeted another user under the `source` column and the user who was retweeted
    under the `target` column. Since a user can retweet another user multiple times,
    count the number of retweets and return the number of retweets under the `weight`
    column. Return only the first five rows of the result.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MATCH`语句中描述重推模式。在`source`列下返回重推其他用户的用户，在`target`列下返回被重推的用户。由于一个用户可以多次重推另一个用户，因此计算重推次数并在`weight`列下返回重推次数。只返回结果的前五行。
- en: You can now use the Cypher statement used in exercise 6.1 as input to the `gds.graph`
    `.project` function to project an in-memory graph using Cypher projection.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以将练习6.1中使用的Cypher语句作为`gds.graph.project`函数的输入，以使用Cypher投影在内存中生成图。
- en: Listing 6.3 Loading the amplify retweet network as an in-memory graph using
    Cypher projection
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.3 使用Cypher投影将放大重推网络加载为内存图
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Matches the retweet pattern and counts the number of retweets between a pair
    of users
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 匹配重推模式并计算一对用户之间的重推次数
- en: ❷ Projects an in-memory graph using Cypher projection
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用Cypher投影在内存中生成图
- en: 'The Cypher statement in listing 6.3 starts by matching the retweet pattern.
    The user who retweeted is specified as the `source` node, while the retweeted
    user is described as the `target` node. Next, you count the number of retweets
    between a single pair of users using the `count()` function. Now that the relationship
    list is prepared, you can project it using the `gds.graph.project` function. In
    this example, you provided the `source` and `target` nodes along with the relationship
    property `weight`, specified in the data configuration parameter. Check the documentation
    for a complete list of possible configuration keys: [http://mng.bz/GyJO](http://mng.bz/GyJO).
    The Cypher projection function will return the output shown in table 6.1.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.3中的Cypher语句首先匹配重推模式。重推用户指定为`source`节点，而被重推的用户描述为`target`节点。接下来，您使用`count()`函数计算一对用户之间的重推次数。现在关系列表已准备就绪，您可以使用`gds.graph.project`函数进行投影。在这个例子中，您提供了`source`和`target`节点以及数据配置参数中指定的关系属性`weight`。请检查文档以获取可能的配置键的完整列表：[http://mng.bz/GyJO](http://mng.bz/GyJO)。Cypher投影函数将返回表6.1所示的输出。
- en: Table 6.1 Cypher projection function output
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.1 Cypher投影函数输出
- en: '| `graphName` | `nodeCount` | `relationshipCount` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `graphName` | `nodeCount` | `relationshipCount` |'
- en: '| "amplify" | 1828 | 2719 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| "amplify" | 1828 | 2719 |'
- en: There are 1,828 nodes and 2,719 relationships in the projected in-memory `amplify`
    graph. The retweet amplification network can be described as a directed, weighted
    network.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在投影的内存`amplify`图中，有1,828个节点和2,719个关系。重推放大网络可以被描述为一个有向、加权的网络。
- en: 6.2 Retweet network characterization
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 重推网络特征描述
- en: Next, you will perform a short network analysis of the retweet amplification
    network. This analysis aims to reinforce your experience with executing graph
    algorithms.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将对重推放大网络进行简短的网络分析。这次分析旨在加强您执行图算法的经验。
- en: 6.2.1 Degree centrality
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.1 度中心性
- en: First, you will evaluate the node degree distribution of the inferred network.
    In the previous chapter, you used a plain Cypher statement to calculate and visualize
    the node degree distribution. Here, the retweet amplification network is not materialized
    in the database, so you don’t have the option of using a plain Cypher statement
    to calculate the node degree distribution. Instead, you can use the GDS degree
    centrality algorithm `gds.degree` to evaluate the node degree distribution
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您将评估推断网络的节点度分布。在前一章中，您使用了一个普通的Cypher语句来计算和可视化节点度分布。在这里，重推放大网络没有在数据库中实现，因此您没有使用普通Cypher语句来计算节点度分布的选项。相反，您可以使用GDS度中心性算法`gds.degree`来评估节点度分布
- en: You can use the `stats` mode of the algorithm to examine the node degree distribution,
    as shown in the following listing. By default, the `gds.degree` centrality calculates
    the out-degree. Remember, the out-degree is the count of outgoing relationships
    a node has, while the in-degree counts the incoming links.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用算法的`stats`模式来检查节点度分布，如下所示。默认情况下，`gds.degree`中心性计算的是出度。请记住，出度是一个节点拥有的 outgoing
    关系的计数，而入度是 incoming 链接的计数。
- en: Listing 6.4 Evaluating the out-degree distribution of the inferred retweet amplification
    network
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.4 评估推断重推放大网络的出度分布
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Table 6.2 shows the resulting distribution.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.2显示了结果分布。
- en: Table 6.2 Out-degree distribution of the retweet amplification network
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.2 重推放大网络的出度分布
- en: '| Metric | Value |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 度量 | 值 |'
- en: '| `p99` | 18.00011444091797 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `p99` | 18.00011444091797 |'
- en: '| `min` | 0.0 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `min` | 0.0 |'
- en: '| `max` | 146.00096893310547 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `max` | 146.00096893310547 |'
- en: '| `mean` | 1.4874205599728507 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `mean` | 1.4874205599728507 |'
- en: '| `p90` | 2.0000076293945312 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `p90` | 2.0000076293945312 |'
- en: '| `p50` | 1.0 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `p50` | 1.0 |'
- en: '| `p999` | 61.00023651123047 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `p999` | 61.00023651123047 |'
- en: '| `p95` | 4.000022888183594 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `p95` | 4.000022888183594 |'
- en: '| `p75` | 1.0 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `p75` | 1.0 |'
- en: On average, a node in the network has around 1.5 outgoing relationships. The
    `p`*X* values represent the percentile values; for example, `p75` represents the
    75th percentile value of 1.0, which means 75% of nodes have 1 or 0 outgoing relationships.
    You can deduce that the inferred retweet network is sparse.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络中，一个节点平均有大约 1.5 个出度关系。`p`*X* 值表示百分位数；例如，`p75` 表示 1.0 的 75 个百分位数，这意味着 75%
    的节点有 1 或 0 个出度关系。你可以推断出推断的重推网络是稀疏的。
- en: Exercise 6.2
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 6.2
- en: Use the degree centrality algorithm to calculate and return the top five nodes
    with the highest out-degree in the retweet amplification network. Use the `stream`
    mode of the algorithm to stream the results without storing them in the database
    or the projected graph. The `stream` mode of the `gds.degree` algorithm outputs
    `nodeId` and `score` columns. Use `gds.util.asNode` to map the node IDs to node
    instances and retrieve the `username` property for the top five nodes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用度中心性算法计算并返回重推放大网络中出度最高的前五个节点。使用算法的 `stream` 模式来流式传输结果，而不将其存储在数据库或投影图中。`gds.degree`
    算法的 `stream` 模式输出 `nodeId` 和 `score` 列。使用 `gds.util.asNode` 将节点 ID 映射到节点实例，并检索前五个节点的
    `username` 属性。
- en: The solution to exercise 6.2 produces the output shown in table 6.3.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 6.2 的解决方案生成了表 6.3 中所示的结果。
- en: Table 6.3 The top five users by out-degree in the retweet amplification network
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.3 重推放大网络中按出度排名前五的用户
- en: '| `user` | `score` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `user` | `score` |'
- en: '| "textsla" | 146.0 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| "textsla" | 146.0 |'
- en: '| "godfrey_G_" | 61.0 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| "godfrey_G_" | 61.0 |'
- en: '| "iPythonistaBot" | 48.0 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| "iPythonistaBot" | 48.0 |'
- en: '| "Beka "Bexx" Modebade" | 36.0 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| "Beka "Bexx" Modebade" | 36.0 |'
- en: '| "chidambara09" | 33.0 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| "chidambara09" | 33.0 |'
- en: The user textsla has retweeted posts from 146 different users. It wouldn’t surprise
    me if most of the users on this list had automatic retweets in place for specific
    hashtags. Since you are dealing with a weighted network, you can also evaluate
    the weighted out-degree distribution. Most of the GDS library graph algorithms
    support the algorithms’ weighted variations by using the `relationshipWeightProperty`
    configuration parameter. You can evaluate the weighted out-degree distribution
    of the retweet amplification network with the following Cypher statement.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 用户 textsla 从 146 个不同的用户那里转发了帖子。如果这个列表上的大多数用户都为特定的标签设置了自动重推，我并不会感到惊讶。由于你处理的是一个加权网络，你也可以评估加权出度分布。大多数
    GDS 库图算法通过使用 `relationshipWeightProperty` 配置参数支持算法的加权变体。你可以使用以下 Cypher 语句评估重推放大网络的加权出度分布。
- en: Listing 6.5 Evaluating the weighted out-degree distribution of the inferred
    retweet amplification network
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.5 评估推断重推放大网络的加权出度分布
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Table 6.4 shows the resulting distribution.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.4 显示了结果分布。
- en: Table 6.4 Weighted out-degree distribution of the retweet amplification network
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.4 重推放大网络的加权出度分布
- en: '| Metric | Value |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 度量 | 值 |'
- en: '| `p99` | 65.00048065185547 |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `p99` | 65.00048065185547 |'
- en: '| `min` | 0.0 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `min` | 0.0 |'
- en: '| `max` | 2,006.0078048706055 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `max` | 2,006.0078048706055 |'
- en: '| `mean` | 4.715000173456038 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `mean` | 4.715000173456038 |'
- en: '| `p90` | 3.0000076293945312 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `p90` | 3.0000076293945312 |'
- en: '| `p50` | 1.0 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `p50` | 1.0 |'
- en: '| `p999` | 670.0038986206055 |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `p999` | 670.0038986206055 |'
- en: '| `p95` | 7.000022888183594 |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `p95` | 7.000022888183594 |'
- en: '| `p75` | 1.0 |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `p75` | 1.0 |'
- en: Although the average weighted out-degree is 4.7, the 75th percentile is only
    1 and the 90th percentile only raises to 3\. It seems that there are a few outliers
    that raise the average of the whole population. For example, a single user has
    2,006 retweets. Given that most of the retweets in this dataset happened in the
    three-day window, I would venture a guess that the highest retweeting users have
    some retweet automatization set up.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管平均加权出度为 4.7，但第 75 个百分位数仅为 1，第 90 个百分位数仅上升到 3。这似乎表明有一些异常值提高了整个群体的平均值。例如，一个用户有
    2,006 次重推。鉴于这个数据集中大多数重推发生在三天窗口内，我敢猜测最高重推用户可能设置了一些重推自动化。
- en: Exercise 6.3
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 6.3
- en: Use the degree centrality algorithm to calculate and return the top five nodes
    with the highest weighted out-degree in the retweet amplification network. The
    solution is almost identical to exercise 6.2, except that you include the `relationshipWeightProperty`
    parameter to calculate the weighted out-degree.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用度中心性算法计算并返回在转发放大网络中具有最高加权出度的前五个节点。解决方案几乎与练习6.2相同，只是你包括了`relationshipWeightProperty`参数来计算加权出度。
- en: 'The outgoing node degree can help you evaluate and identify users spreading
    or distributing content through the network the most.. On the other hand, you
    can use the in-degree distribution to identify users who produce the most sharable
    (and perhaps best?) content. The node degree centrality algorithm has an `orientation`
    parameter that allows you to evaluate in-degree, out-degree, or a combination
    of both. The `orientation` parameter has three possible inputs:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 出度节点度可以帮助你评估和识别通过网络传播或分发内容最多的用户。另一方面，你可以使用入度分布来识别产生最多可分享（也许最好？）内容的用户。节点度中心性算法有一个`orientation`参数，允许你评估入度、出度或两者的组合。`orientation`参数有三个可能的输入：
- en: '`NATURAL`—Evaluates the out-degree (count of outgoing relationships)'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NATURAL`—评估出度（出关系数量）'
- en: '`REVERSE`—Evaluates the in-degree (count of incoming relationships)'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`REVERSE`—评估入度（入关系数量）'
- en: '`UNDIRECTED`—Evaluates the sum of both the in- and out-degrees'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UNDIRECTED`—评估入度和出度的总和'
- en: Therefore, you can use the `orientation` parameter to evaluate the in-degree
    distribution by setting it to `REVERSE`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以通过将`orientation`参数设置为`REVERSE`来评估入度分布。
- en: Listing 6.6 Returns the top five users with the highest in-degree
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.6 返回具有最高入度的前五个用户
- en: '[PRE5]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Table 6.5 shows the resulting distribution.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.5显示了结果分布。
- en: Table 6.5 In-degree distribution of the retweet amplification network
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.5 转发放大网络的入度分布
- en: '| Metric | Value |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `度量` | `值` |'
- en: '| `p99` | 29.00011444091797 |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `p99` | 29.00011444091797 |'
- en: '| `min` | 0.0 |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `min` | 0.0 |'
- en: '| `max` | 117.00048065185547 |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `max` | 117.00048065185547 |'
- en: '| `mean` | 1.4874205599728507 |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `mean` | 1.4874205599728507 |'
- en: '| `p90` | 3.0000076293945312 |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `p90` | 3.0000076293945312 |'
- en: '| `p50` | 0.0 |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `p50` | 0.0 |'
- en: '| `p999` | 96.00048065185547 |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `p999` | 96.00048065185547 |'
- en: '| `p95` | 7.000022888183594 |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `p95` | 7.000022888183594 |'
- en: '| `p75` | 1.0 |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `p75` | 1.0 |'
- en: More than 50% of the users haven’t been retweeted even once. In some way, it
    makes sense that there are fewer users who write content that is retweeted than
    users who do the retweeting. If you remember from the previous chapter as well,
    the in- and out-degree mean will always be identical, as the number of connections
    and users stays the same, and only the relationship direction is reversed. Interestingly,
    in this example, the 75th- and the 90th-percentile values are identical. It seems
    that the in-degree distribution is a bit more top-heavy than the out-degree. This
    would imply that several content creators consistently produce content that is
    being retweeted. Maybe that implies producing quality content, but we would have
    to investigate further. Perhaps, only their hashtag game is strong.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 超过50%的用户甚至没有被转发过一次。从某种意义上说，转发内容的用户少于转发用户是有道理的。如果你还记得上一章，入度和出度的平均值总是相同的，因为连接数和用户数保持不变，只有关系方向相反。有趣的是，在这个例子中，第75百分位数和第90百分位数是相同的。这似乎表明入度分布比出度分布更偏向于顶部。这表明几个内容创作者持续产生被转发的内容。也许这意味着生产高质量的内容，但我们需要进一步调查。也许，只有他们的标签游戏很强大。
- en: Exercise 6.4
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 练习6.4
- en: Use the degree centrality algorithm to calculate and return the top five nodes
    with the highest in-degree in the retweet amplification network. Use the `stream`
    mode of the algorithm to stream the results without storing them in the database
    or the projected graph.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用度中心性算法计算并返回在转发放大网络中具有最高入度的前五个节点。使用算法的`stream`模式来流式传输结果，而不将其存储在数据库或投影图中。
- en: The solution of exercise 6.4 produces the output shown in table 6.6.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 练习6.4的解决方案产生了表6.6所示的结果。
- en: Table 6.6 Top five users by in-degree in the retweet amplification network
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.6 转发放大网络中按入度排名前五的用户
- en: '| `user` | `score` |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `user` | `score` |'
- en: '| "Paula_Piccard" | 117.0 |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| "Paula_Piccard" | 117.0 |'
- en: '| "IainLJBrown" | 96.0 |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| "IainLJBrown" | 96.0 |'
- en: '| "Eli_Krumova" | 90.0 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| "Eli_Krumova" | 90.0 |'
- en: '| "Analytics_699" | 69.0 |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| "Analytics_699" | 69.0 |'
- en: '| "annargrs" | 65.0 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| "annargrs" | 65.0 |'
- en: A total of 117 different users have retweeted Paula_Piccard. The difference
    between the first and fifth places is not as large as the out-degree distribution.
    You might assume they produce relevant and quality content, as they are often
    retweeted. You would have to scrape more tweets with the relevant hashtags for
    more accurate results.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 共有 117 个不同的用户重推了 Paula_Piccard。第一名和第五名之间的差距不如出度分布大。您可能会认为他们产生相关且高质量的内容，因为他们经常被重推。为了获得更准确的结果，您可能需要抓取更多带有相关标签的推文。
- en: Exercise 6.5
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 6.5
- en: Evaluate the weighted in-degree distribution with the `stats` mode of the degree
    centrality algorithm. If you need some help, you can look at the examples for
    the weighted out-degree and include the `orientation` parameter. After that, use
    the `stream` mode of the algorithm to identify the users with the top five highest
    weighted in-degrees.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用度中心性算法的 `stats` 模式评估加权入度分布。如果您需要一些帮助，可以查看加权出度的示例，并包括 `orientation` 参数。之后，使用算法的
    `stream` 模式来识别具有最高五个加权入度的用户。
- en: You will now execute the weakly connected components (WCC) algorithm you learned
    in chapter 5 to consolidate your knowledge.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将执行第5章中学到的弱连接组件（WCC）算法，以巩固您的知识。
- en: 6.2.2 Weakly connected components
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.2 弱连接组件
- en: The WCC algorithm should be part of almost every network analysis. With it,
    you can evaluate how connected the network is and identify disconnected components.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: WCC 算法应该是几乎所有网络分析的一部分。通过它，您可以评估网络的连接程度并识别断开连接的组件。
- en: Exercise 6.6
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 6.6
- en: Evaluate the distribution of weakly connected component sizes with the `gds.wcc`
    `.stats` procedure.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `gds.wcc` 的 `.stats` 程序评估弱连接组件大小的分布。
- en: Table 6.7 shows the statistics resulting from the WCC algorithm.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.7 显示了 WCC 算法产生的统计数据。
- en: Table 6.7 Summary statistics for the WCC algorithm executed on the retweet amplification
    network
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.7 在重推放大网络上执行 WCC 算法的摘要统计数据
- en: '| `componentCount` | `componentDistribution` |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `componentCount` | `componentDistribution` |'
- en: '| 207 | { "p99": 28,"min": 1,"max": 1082,"mean": 8.830917874396135,"p90": 6,"p50":
    2,"p999": 1082,"p95": 13,"p75": 3 } |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 207 | { "p99": 28,"min": 1,"max": 1082,"mean": 8.830917874396135,"p90": 6,"p50":
    2,"p999": 1082,"p95": 13,"p75": 3 } |'
- en: The largest component consists of 1,082 members, which is around 60% of the
    total users in the retweet amplification network. As previously mentioned, most
    real-world networks have a single super component containing most of the network’s
    nodes with a couple of smaller components on the side. What is strange to me is
    that minimum size components contain only a single member. With Cypher projection,
    you have filtered users who retweeted or were retweeted. My first thought was
    that there should be no components with only a single member. As this is an unexpected
    result, it is worth exploring. You can execute the following Cypher statement
    to examine sample components with a single member.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的组件由 1,082 个成员组成，约占重推放大网络中总用户的 60%。如前所述，大多数现实世界的网络都有一个包含大多数网络节点的单个超级组件，旁边有几个较小的组件。对我来说奇怪的是，最小尺寸的组件只包含一个成员。使用
    Cypher 投影，您已经过滤了重推或被重推的用户。我的第一个想法是，不应该有只包含一个成员的组件。由于这是一个意外的结果，值得探索。您可以使用以下 Cypher
    语句来检查具有单个成员的样本组件。
- en: Listing 6.7 Examining sample components with a single member
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.7 使用单个成员检查样本组件
- en: '[PRE6]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Executes the stream mode of the WCC algorithm
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 执行 WCC 算法的流模式
- en: ❷ Collects nodes grouped by component id
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 按组件ID分组收集节点
- en: ❸ Filters components that contain only a single member
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 过滤只包含单个成员的组件
- en: ❹ Extracts the node ID from the list for three sample components
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 从列表中提取三个样本组件的节点 ID
- en: ❺ Matches their retweets
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 匹配他们的重推
- en: The Cypher statement in listing 6.7 starts by executing the `stream` mode of
    the WCC algorithm on the retweet amplification network. The `stream` mode of the
    WCC algorithm outputs the `nodeId` column, representing the internal node ID of
    the node, and the `componentId` column, which describes to which component the
    node belongs. In the next step of the Cypher statement, you aggregate by the `componentId`
    to calculate the component size and collect its members’ node IDs. Afterward,
    you use the `WHERE` clause to filter components with only one member. As there
    should be only a single element in the `componentMembers` list of the single-member
    components, you can easily extract the only node ID using the square bracket syntax
    in combination with its index position. To not overwhelm the results visualization,
    you will only examine three components with a single member. The last thing you
    need to do is match the retweets pattern for the three specific node IDs. The
    Cypher statement in listing 6.7 will produce the visualization shown in figure
    6.6 in Neo4j Browser.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.7中的Cypher语句首先在转推放大网络上执行WCC算法的`stream`模式。WCC算法的`stream`模式输出`nodeId`列，表示节点的内部节点ID，以及`componentId`列，它描述节点属于哪个组件。在Cypher语句的下一步中，你通过`componentId`进行聚合，以计算组件大小并收集其成员的节点ID。之后，你使用`WHERE`子句过滤出只有一个成员的组件。由于单个成员组件的`componentMembers`列表中应该只有一个元素，你可以很容易地使用方括号语法结合其索引位置提取唯一的节点ID。为了不让结果可视化过于繁杂，你将只检查具有单个成员的三个组件。最后，你需要匹配三个特定节点ID的转推模式。列表6.7中的Cypher语句将在Neo4j浏览器中产生图6.6所示的可视化。
- en: '![06-06](../../OEBPS/Images/06-06.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![06-06](../../OEBPS/Images/06-06.png)'
- en: Figure 6.6 Components that contain a single member, where users retweeted themselves
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 包含单个成员的组件，其中用户转发了自己的推文
- en: On Twitter, a user can also retweet their posts. In graph theory, a *self-loop*
    is a relationship with the same start and end node. As mentioned, the WCC algorithm
    is helpful for identifying how connected the network is as well as identifying
    various unexpected patterns.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在Twitter上，用户也可以转推自己的帖子。在图论中，*自环*是与相同起始和结束节点的关系。如前所述，WCC算法有助于识别网络的连接程度以及识别各种意外的模式。
- en: 6.3 Identifying the most influential content creators
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 识别最有影响力的内容创作者
- en: 'The main objective of the task in this chapter is to identify the most influential
    content creators on the available subset of the Twitter social network dataset.
    You will determine the most important content creators by following these two
    steps:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 本章任务的主要目标是识别Twitter社交网络数据集可用子集中的最有影响力的内容创作者。你将通过以下两个步骤来确定最重要的内容创作者：
- en: Ignore self-loops during projection.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在投影过程中忽略自环。
- en: Execute the weighted variant of the PageRank algorithm.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行PageRank算法的加权变体。
- en: 6.3.1 Excluding self-loops
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.1 排除自环
- en: I think it makes sense to exclude all the self-loops from the network before
    you execute the weighted PageRank algorithm. The self-loop can be translated as
    the node stating that it is influential. I think that retweeting your own tweets
    shouldn’t increase your influence in the network. Unfortunately, there is no magic
    button to press that excludes self-loops, so you must project another in-memory
    graph using Cypher projection.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为在执行加权PageRank算法之前排除网络中的所有自环是有意义的。自环可以被解释为节点声明它是有影响力的。我认为转发自己的推文不应该增加你在网络中的影响力。不幸的是，没有一键排除自环的魔法按钮，所以你必须使用Cypher投影在内存中投影另一个图。
- en: Exercise 6.7
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 练习6.7
- en: Use Cypher projection to load the retweet amplification network into memory
    and exclude all self-loops. Essentially, you only need to change the relationship
    Cypher statement to filter out relationships that start and end at the same node.
    Name the new projected graph `amplify-noselfloops`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Cypher投影将转推放大网络加载到内存中并排除所有自环。本质上，你只需要更改关系Cypher语句以过滤出起始和结束节点相同的边。将新的投影图命名为`amplify-noselfloops`。
- en: 6.3.2 Weighted PageRank variant
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.2 加权PageRank变体
- en: Next, you will execute the weighted PageRank algorithm to identify potential
    content influencers. Remember, the PageRank algorithm considers both the number
    of incoming connections and the nodes’ importance that links to it. Instead of
    simply analyzing which user has the most retweets, you are also evaluating which
    other influential nodes in the network retweeted them.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将执行加权PageRank算法以识别潜在的内容影响者。记住，PageRank算法考虑了指向节点的连接数量和节点的重要性。你不仅分析哪个用户拥有最多的转发，还在评估网络中哪些其他有影响力的节点也转发了它们。
- en: The weighted variant of the PageRank algorithm also considers the relationship
    weight when calculating node importance. With the unweighted variant of PageRank,
    the node’s importance is equally spread among its neighbors. On the other hand,
    with the weighted variant, each neighbor gets the share of importance related
    to the relationship weight (figure 6.7).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 加权版本的PageRank算法在计算节点重要性时也考虑了关系权重。在未加权的PageRank版本中，节点的重要性在它的邻居之间平均分配。另一方面，在加权版本中，每个邻居都获得与关系权重相关的重要性份额（图6.7）。
- en: '![06-07](../../OEBPS/Images/06-07.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![06-07](../../OEBPS/Images/06-07.png)'
- en: Figure 6.7 The difference between weighted and unweighted PageRank calculation
    in a single iteration
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 单次迭代中加权与无加权PageRank计算的差异
- en: As previously mentioned, the weighted variant of the PageRank algorithm considers
    the relationship weight when it calculates how the influence spreads across the
    network. Figure 6.7 visualizes a simple network consisting of three nodes. The
    difference between the weighted and unweighted variants is demonstrated as to
    how node A spreads its influence. With the unweighted variant, nodes B and C get
    an equal share of importance from node A. In the weighted network, the relationship
    from node A to C has a weight of 1, and the connection from node A to B has a
    value of 2\. In every iteration of the weighted PageRank algorithm, node B will
    receive two-thirds of node A’s influence, and node C will receive only one-third.
    The equation to calculate the share of influence with the weighted PageRank algorithm
    is simply dividing the relationship weight by the sum of all outgoing relationship
    weights.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，加权版本的PageRank算法在计算影响如何在网络中传播时考虑了关系权重。图6.7可视化了一个由三个节点组成的简单网络。加权版本和无加权版本之间的区别在于节点A如何传播其影响。在无加权版本中，节点B和C从节点A那里获得相等的重要性份额。在加权网络中，节点A到C的关系权重为1，节点A到B的连接值为2。在加权PageRank算法的每一次迭代中，节点B将接收到节点A三分之二的影响，而节点C将只接收到三分之一。使用加权PageRank算法计算影响份额的方程只是将关系权重除以所有输出关系权重的总和。
- en: Now, you can execute the weighted PageRank algorithm on the retweet amplification
    network without self-loops. Similarly, as with degree centrality, you only need
    to include the `relationshipWeightProperty` parameter to execute the weighted
    variant of the algorithm. You must complete exercise 6.7 before executing the
    following Cypher statement.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在没有自环的转发放大网络上执行加权PageRank算法。同样，与度中心性一样，你只需要包含`relationshipWeightProperty`参数来执行算法的加权版本。你必须完成练习6.7，然后才能执行以下Cypher语句。
- en: Listing 6.8 Executing the PageRank algorithm on the retweet amplification network
    with no self-loops
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.8 在没有自环的转发放大网络上执行PageRank算法
- en: '[PRE7]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Table 6.8 shows the top five users for this example by PageRank score.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.8显示了按PageRank分数排序的该示例的前五名用户。
- en: Table 6.8 Top five users by weighted PageRank score in the retweet amplification
    network with no self-loops
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.8 无自环的转发放大网络中按加权PageRank分数排序的前五名用户
- en: '| `user` | `score` |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `用户` | `分数` |'
- en: '| "Paula_Piccard" | 8.270755243786214 |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| "Paula_Piccard" | 8.270755243786214 |'
- en: '| "annargrs" | 7.836125000000006 |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| "annargrs" | 7.836125000000006 |'
- en: '| "psb_dc" | 7.478576023152348 |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| "psb_dc" | 7.478576023152348 |'
- en: '| "IainLJBrown" | 7.457764370226901 |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| "IainLJBrown" | 7.457764370226901 |'
- en: '| "Eli_Krumova" | 6.95963977383344 |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| "Eli_Krumova" | 6.95963977383344 |'
- en: The list of the top five users by weighted PageRank list is similar to the list
    of the top five users by in-degree. Of course, the Twitter subgraph you are analyzing
    is relatively tiny. While you haven’t analyzed the tweet topics or hashtags, I’ve
    mentioned that I scraped the dataset by focusing on the natural language processing
    (NLP) and knowledge graph topics. So users in table 6.8 could be good candidates
    to follow on Twitter if you are interested in NLP or knowledge graph topic updates.
    Additionally, as a marketing strategy, you could try to contact and ask these
    users if they might be willing to share your content.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 按照加权 PageRank 排名前五的用户列表与按入度排名前五的用户列表相似。当然，你正在分析的 Twitter 子图相对较小。虽然你还没有分析推文主题或标签，但我提到我已经通过关注自然语言处理（NLP）和知识图谱主题来抓取数据集。因此，如果你对
    NLP 或知识图谱主题更新感兴趣，表 6.8 中的用户可能是 Twitter 上值得关注的对象。此外，作为一种营销策略，你可以尝试联系这些用户，看看他们是否愿意分享你的内容。
- en: 6.3.3 Dropping the projected in-memory graph
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.3 删除投影的内存图
- en: It is important to remember to release the projected in-memory graph once you
    are done with the analysis to free up memory for other analyses. At the moment,
    you should have two graphs loaded in memory. The following Cypher statement will
    drop all currently projected graphs.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析完成后，记得释放投影的内存图以释放内存，以便进行其他分析。目前，你应该有两个图已加载到内存中。以下 Cypher 语句将删除所有当前投影图。
- en: Listing 6.9 Releasing all the projected graphs from memory
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.9 从内存中释放所有投影图
- en: '[PRE8]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Lists all projected graphs
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 列出所有投影图
- en: ❷ Releases each projected graph from memory
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从内存中释放每个投影图
- en: 6.4 Solutions to exercises
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 练习解答
- en: The solution to exercise 6.1 is as follows.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 6.1 的解答如下。
- en: Listing 6.10 Counting the occurrence of the retweet pattern between users
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.10 计算用户之间转发模式的出现次数
- en: '[PRE9]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The solution to exercise 6.2 is as follows.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 6.2 的解答如下。
- en: Listing 6.11 Returns the users with the top five highest out-degrees
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.11 返回具有最高五个加权出度的用户
- en: '[PRE10]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The solution to exercise 6.3 is as follows.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 6.3 的解答如下。
- en: Listing 6.12 Returns the users with the top five highest weighted out-degrees
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.12 返回具有最高五个加权出度的用户
- en: '[PRE11]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The solution to exercise 6.4 is the following.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 6.4 的解答如下。
- en: Listing 6.13 Returns the users with the top five highest weighted in-degrees
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.13 返回具有最高五个加权入度的用户
- en: '[PRE12]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The solutions to exercise 6.5 are as follows.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 6.5 的解答如下。
- en: Listing 6.14 Evaluates the weighted in-degree distribution
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.14 评估加权入度分布
- en: '[PRE13]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Listing 6.15 Returns the users with the top five highest weighted in-degrees
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.15 返回具有最高五个加权入度的用户
- en: '[PRE14]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The solution to exercise 6.6 is as follows.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 6.6 的解答如下。
- en: Listing 6.16 Evaluates the number and size of weakly connected components
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.16 评估弱连通组件的数量和大小
- en: '[PRE15]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The solution to exercise 6.7 is as follows.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 6.7 的解答如下。
- en: Listing 6.17 Loads the amplify retweet network as an in-memory graph using Cypher
    projection and excluding self-loops
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.17 使用 Cypher 投影将放大转发网络作为内存图加载，并排除自环
- en: '[PRE16]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Inferring monopartite networks is a frequent step in graph analysis.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推断单连通网络是图分析中常见的步骤。
- en: Cypher projection can be used to project a virtual graph (nonexisting relationships
    in the database).
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cypher 投影可用于投影虚拟图（数据库中不存在的关联）。
- en: Cypher projection is a more flexible but less performant option to project in-memory
    graphs.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cypher 投影是一种更灵活但性能较低的内存图投影选项。
- en: Cypher projection takes in a Cypher statement that defines the node and another
    Cypher statement that specifies the relationships that should be projected.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cypher 投影接受一个定义节点的 Cypher 语句，以及另一个指定应投影的关系的 Cypher 语句。
- en: The Cypher statement to define nodes with Cypher projection has the reserved
    columns `id` and `labels`.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Cypher 投影定义节点时，保留的列有 `id` 和 `labels`。
- en: The Cypher statement to define relationships with Cypher projection has the
    reserved columns `source`, `target`, and `type`.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Cypher 投影定义与关系时，保留的列有 `source`、`target` 和 `type`。
- en: The GDS library uses two directed relationships that point in the opposite direction
    to represent an undirected relationship.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GDS 库使用两个方向相反的定向关系来表示无向关系。
- en: You can change the relationship direction or treat it as undirected during in-memory
    graph projection.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内存图投影期间，你可以更改关系方向或将它视为无向。
- en: The degree centrality distribution can be evaluated with the `gds.degree.stats`
    procedure.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`gds.degree.stats`过程来评估度中心性分布。
- en: The weighted variant of PageRank considers the relationship weight when it calculates
    how the influence spreads over the graph.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PageRank的加权变体在计算影响力如何在图中传播时考虑了关系权重。
- en: You can use weighted variants of the degree centrality and PageRank algorithms
    by defining the `relationshipWeightProperty` parameter.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过定义`relationshipWeightProperty`参数，你可以使用度中心性和PageRank算法的加权变体。
- en: The parameters `nodeLabels` and `relationshipTypes` can be used to consider
    only a subset of the projected graph as an input to a graph algorithm.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`nodeLabels`和`relationshipTypes`参数来仅考虑投影图的子集作为图算法的输入。
- en: A self-loop is a relationship that has the same start and end node.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自环是一种具有相同起始节点和结束节点的关系。
