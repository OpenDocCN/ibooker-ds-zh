- en: Part 2\. Managing complexity
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二部分\. 管理复杂性
- en: The second part of the book is more interactive than the first, as it contains
    even more practical code samples. You’ll get to explore different little angles
    at which we can attack complexity in our application designs, such as modularity,
    asynchronous programming patterns, testing suites, keeping your code concise,
    and API design principles.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 书的第二部分比第一部分更具互动性，因为它包含了更多的实际代码示例。你将有机会探索我们在应用程序设计中攻击复杂性的不同小角度，例如模块化、异步编程模式、测试套件、保持代码简洁以及
    API 设计原则。
- en: '[Chapter 5](kindle_split_017.html#ch05) is a detailed examination of modularity
    in JavaScript. We start with the basics, learning about encapsulation, closures,
    and a few quirks of the language. Then we delve into the different formats that
    allow us to build modular code, such as CommonJS, AMD, and ES6 modules. We’ll
    also go over different package managers, comparing what they bring to the table.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第五章](kindle_split_017.html#ch05) 对 JavaScript 中的模块化进行了详细探讨。我们从基础知识开始，学习封装、闭包和语言的一些怪癖。然后我们深入研究不同的格式，这些格式允许我们构建模块化代码，例如
    CommonJS、AMD 和 ES6 模块。我们还将讨论不同的包管理器，比较它们各自的特点。'
- en: '[Chapter 6](kindle_split_018.html#ch06) teaches you to think about asynchronous
    code. We’ll go through tons of practical code samples, following a few different
    styles and conventions. You’ll learn all about Promises, the `async` control flow
    library, ES6 generators, and event-based programming.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[第六章](kindle_split_018.html#ch06) 教你思考异步代码。我们将通过大量的实际代码示例，遵循几种不同的风格和约定。你将了解所有关于
    Promises、`async` 控制流库、ES6 生成器和基于事件的编程。'
- en: '[Chapter 7](kindle_split_019.html#ch07) aims to expand your JavaScript horizons
    by teaching you about MVC. You’ll take a fresh look at jQuery and learn how you
    could be writing more modular code instead. Later on, you’ll leverage the Backbone.js
    MVC framework to componentize your front-end efforts even further. Backbone.js
    can even be used to render views on the server side, and we’ll leverage the Node.js
    platform to do exactly that.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[第七章](kindle_split_019.html#ch07) 通过教授你 MVC（模型-视图-控制器）来扩展你的 JavaScript 视野。你将重新审视
    jQuery，并学习如何编写更模块化的代码。稍后，你将利用 Backbone.js MVC 框架进一步组件化你的前端工作。Backbone.js 甚至可以用于在服务器端渲染视图，我们将利用
    Node.js 平台来实现这一点。'
- en: In [chapter 8](kindle_split_020.html#ch08) you’ll learn how to automate testing
    right off the bat, using Grunt tasks. Then you’ll learn how to write tests for
    the browser, and how to run them using either Chrome or the PhantomJS headless
    browser. You won’t only learn to do unit testing, but also visual testing and
    even performance testing as well.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第八章](kindle_split_020.html#ch08) 中，你将学习如何立即使用 Grunt 任务自动化测试。然后你将学习如何为浏览器编写测试，以及如何使用
    Chrome 或 PhantomJS 无头浏览器运行它们。你不仅将学习单元测试，还将学习视觉测试甚至性能测试。
- en: '[Chapter 9](kindle_split_021.html#ch09) is dedicated to REST API design principles.
    In this chapter you’re exposed to the best practices you should follow when laying
    out the foundations for an API service, as well as how you could design a layered
    architecture to complement the API. Last, you’ll learn how to easily consume the
    API, using the conventions set forth by following a RESTful design approach.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[第九章](kindle_split_021.html#ch09) 专注于 REST API 设计原则。在本章中，你将了解在为 API 服务奠定基础时应遵循的最佳实践，以及如何设计分层架构以补充
    API。最后，你将学习如何轻松消费 API，使用遵循 RESTful 设计方法的约定。'
- en: Chapter 5\. Embracing modularity and dependency management
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第五章\. 接受模块化和依赖管理
- en: '*This chapter covers*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Working with code encapsulation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用代码封装
- en: Understanding modularity in JavaScript
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 JavaScript 中的模块化
- en: Incorporating dependency injection
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成依赖注入
- en: Using package management
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用包管理
- en: Trying out ECMAScript 6
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用 ECMAScript 6
- en: Now that we’re done with the Build First crash course, you’ll notice a decline
    in Grunt tasks, though you’ll definitely continue to improve your build. In contrast,
    you’ll see more examples discussing the tradeoffs between different ways you can
    work with the JavaScript code underlying your apps. This chapter focuses on *modular
    design*, driving down the code complexity of applications by separating concerns
    into different modules of interconnected, small pieces of code that do one thing
    well and are easily testable. You’ll manage complexity in asynchronous code flows,
    client-side JavaScript patterns and practices, and various kinds of testing in
    [chapters 6](kindle_split_018.html#ch06), [7](kindle_split_019.html#ch07), and
    [8](kindle_split_020.html#ch08), respectively.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了“构建第一”速成课程，你会注意到Grunt任务有所减少，尽管你肯定会继续提高你的构建能力。相比之下，你会看到更多关于如何处理你应用程序底层的JavaScript代码的不同方法的权衡的例子。本章重点介绍*模块化设计*，通过将关注点分离到不同模块中，降低应用程序的代码复杂性，这些模块是相互连接的小块代码，每块代码都擅长做一件事，并且易于测试。你将管理异步代码流、客户端JavaScript模式和[第6章](kindle_split_018.html#ch06)、[第7章](kindle_split_019.html#ch07)和[第8章](kindle_split_020.html#ch08)中的各种测试中的复杂性。
- en: '[Part 2](kindle_split_016.html#part02) boils down to increasing the quality
    in your application designs through separation of concerns. To improve your ability
    to separate concerns, I’ll teach you all about modularity, shared rendering, and
    asynchronous JavaScript development. To increase the resiliency of your applications,
    you should test your JavaScript, as well, which is the focus of [chapter 8](kindle_split_020.html#ch08).
    While this is a JavaScript-focused book, it’s crucial that you understand REST
    API design principles to improve communication across pieces of your application
    stack, and that’s exactly the focus of [chapter 9](kindle_split_021.html#ch09).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[第二部分](kindle_split_016.html#part02)的核心是通过分离关注点来提高应用程序设计的质量。为了提高你分离关注点的技能，我将教你所有关于模块化、共享渲染和异步JavaScript开发的知识。为了提高你应用程序的弹性，你也应该测试你的JavaScript，这是[第8章](kindle_split_020.html#ch08)的重点。虽然这是一本以JavaScript为重点的书，但了解REST
    API设计原则对于改善应用程序堆栈各部分之间的通信至关重要，这正是[第9章](kindle_split_021.html#ch09)的重点。'
- en: '[Figure 5.1](#ch05fig01) shows how these bits and pieces of the second half
    of the book relate to each other.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.1](#ch05fig01)展示了本书后半部分这些片段是如何相互关联的。'
- en: Figure 5.1\. Modularity, good architecture, and testing are fundamentals of
    designing maintainable applications.
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.1. 模块化、良好的架构和测试是设计可维护应用程序的基础。
- en: '![](05fig01_alt.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](05fig01_alt.jpg)'
- en: Applications typically depend on external libraries (such as jQuery, Underscore,
    or AngularJS), which should be handled and updated by using package managers,
    rather than manually downloaded. Similarly, your application can also be broken
    down into smaller pieces that interact with each other, and that’s another focus
    of this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序通常依赖于外部库（如jQuery、Underscore或AngularJS），这些库应该通过包管理器来处理和更新，而不是手动下载。同样，你的应用程序也可以分解成更小的部分，它们相互交互，这也是本章的另一个重点。
- en: You’ll learn the art of code encapsulation, treating your code as self-contained
    components; designing great interfaces and arranging them precisely; and information
    hiding to reveal everything the consumer needs, but nothing else. I’ll spend a
    good number of words explaining elusive concepts such as *scoping*, which determines
    where variables belong; the `this` keyword, which you must understand; and *closures,*
    which help you hide information.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习代码封装的艺术，将你的代码视为自包含的组件；设计出色的接口并精确排列它们；以及信息隐藏，只揭示消费者需要的，而隐藏其他一切。我将用很多话来解释一些难以捉摸的概念，例如*作用域*，它决定了变量属于哪里；你必须理解的`this`关键字；以及*闭包*，它帮助你隐藏信息。
- en: Then we’ll look at dependency resolution as an alternative to maintaining a
    sorted list of script tags by hand. Afterward, we’ll jump to package management,
    which is how you’ll install and upgrade third-party libraries and frameworks.
    Last, we’ll look at the upcoming ECMAScript 6 specification, which has a few nice
    new tricks in store for building modular applications.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将探讨依赖关系解析作为手动维护脚本标签排序列表的替代方案。之后，我们将转向包管理，这是你安装和升级第三方库和框架的方式。最后，我们将查看即将推出的ECMAScript
    6规范，它为构建模块化应用程序提供了一些新技巧。
- en: 5.1\. Working with code encapsulation
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1. 使用代码封装
- en: Encapsulation means keeping functionality self-contained and hiding implementation
    details from consumers of a given piece of code (those who access it). Each piece,
    whether a function or an entire module, should have a clearly defined responsibility,
    hide implementation details, and expose a succinct API to satisfy its consumers’
    needs. Self-contained functionality is easier to understand and change than code
    that has many responsibilities.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 封装意味着保持功能自包含，并隐藏特定代码片段（访问者）的实现细节。每个部分，无论是函数还是整个模块，都应该有一个明确定义的责任，隐藏实现细节，并暴露简洁的API以满足其消费者的需求。自包含的功能比具有许多责任的代码更容易理解和修改。
- en: 5.1.1\. Understanding the Single Responsibility Principle
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.1\. 理解单一职责原则
- en: 'In the Node.js community, inspired by the UNIX philosophy of keeping programs
    concise and self-contained, packages are well known for having a specific purpose.
    The high availability of coherent packages that don’t go overboard with features
    plays a big role in making the `npm` package manager great. For the most part,
    package authors accomplish this by following the Single Responsibility Principle
    (SRP): build packages that do one thing, and do it well. SRP doesn’t apply only
    to packages as a whole; you should follow SRP at the module and method levels,
    as well. SRP helps your code stay readable and maintainable by keeping it simple
    and concise.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js社区中，受到UNIX哲学中保持程序简洁和自包含的启发，包因其特定的用途而闻名。这些功能协调且不过度扩展的包的高可用性在使`npm`包管理器变得出色方面发挥了重要作用。在很大程度上，包作者通过遵循单一职责原则（SRP）来实现这一点：构建只做一件事且做得很好的包。SRP不仅适用于整个包；你应在模块和方法级别上遵循SRP。SRP通过保持代码简单和简洁，有助于使代码保持可读性和可维护性。
- en: Consider the following use case. You need to build a component that takes a
    string and returns a hyphenated representation. It will be helpful when generating
    semantic links in web applications such as blogging platforms. This component
    might take blog post titles such as `'Some Piece Of Text'`, and convert them to
    `'some-piece-of-text'`. This is called *slugging*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下用例。你需要构建一个组件，该组件接受一个字符串并返回一个带连字符的表示形式。在生成博客平台等Web应用程序中的语义链接时将非常有用。该组件可能接受像`'Some
    Piece Of Text'`这样的博客文章标题，并将它们转换为`'some-piece-of-text'`。这被称为*slugging*。
- en: Suppose you start with the following listing (available as ch05/01_single-responsibility-principle
    in the samples). It uses a two-step process in which it first normalizes all nonalphanumeric
    character sequences into single dashes and then removes leading and trailing dashes.
    Then it lowercases the string. Exactly what you need but nothing else.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你从以下列表开始（在示例中的ch05/01_single-responsibility-principle中可用）。它使用两步过程，首先将所有非字母数字字符序列规范化为单个连字符，然后删除前后连字符。然后转换字符串为小写。这正是你所需要的，但没有其他东西。
- en: Listing 5.1\. Converting text using slugging
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.1\. 使用slugging转换文本
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first expression, `/[^a-z0-9]+/ig` is used to find sequences of one or more
    characters that aren’t alphanumerical, such as spaces, dashes, or exclamation
    points. These expressions are replaced by dashes. The second expression looks
    for dashes at either end of the string. Combining these two, you can build a URL-safe
    version of blog post titles.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个表达式`/[^a-z0-9]+/ig`用于查找一个或多个非字母数字字符的序列，例如空格、连字符或感叹号。这些表达式被替换为连字符。第二个表达式查找字符串两端的连字符。结合这两个表达式，你可以构建一个适合URL的博客文章标题版本。
- en: '|  |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Understanding regular expressions**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**理解正则表达式**'
- en: Although you don’t need to know regular expressions to understand this example,
    I encourage you learn the basics. Regular expressions are used to find patterns
    in strings, and they can also be used to replace those occurrences with something
    else. These expressions are supported in virtually all major languages.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你不需要了解正则表达式就能理解这个例子，但我鼓励你学习基础知识。正则表达式用于在字符串中查找模式，也可以用来将这些出现替换为其他内容。这些表达式在几乎所有主要语言中都得到支持。
- en: Expressions such as `/[^a-z0-9]+/ig` can be confusing to look at, but they aren’t
    that hard to write! My blog has an entry-level article you can read if the subject
    interests you.^([[a](#ch05fn01a)])
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式如`/[^a-z0-9]+/ig`看起来可能很复杂，但它们并不难编写！如果你对这个主题感兴趣，我的博客上有一篇入门文章你可以阅读.^([[a](#ch05fn01a)])
- en: ^a You can find the article on my blog at [http://bevacqua.io/bf/regex](http://bevacqua.io/bf/regex).
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^a 你可以在我的博客上找到这篇文章[http://bevacqua.io/bf/regex](http://bevacqua.io/bf/regex)。
- en: '|  |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In the previous example, the `separator` variable is a simple regular expression
    that will match sequences of non-letter, non-numeric characters. For example,
    in the `'Cats, Dogs and Zebras!'` string, it will match the first comma and space
    as a single occurrence, both spaces around `'and'`, and the `'!'` at the end.
    The second regular expression matches dashes at either end of the string, so that
    the resulting slug begins and ends with words, especially because you’re converting
    any nonalphanumeric characters into dashes in the previous step. Combining these
    two steps is enough to produce a decent slugging function for your component.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`separator`变量是一个简单的正则表达式，它将匹配非字母、非数字字符的序列。例如，在`'Cats, Dogs and Zebras!'`字符串中，它将匹配第一个逗号和空格作为一个单独的匹配项，`'and'`周围的两个空格，以及末尾的`'!'`。第二个正则表达式匹配字符串两端的破折号，这样生成的缩略名以单词开头和结尾，特别是因为你已经在之前的一步中将任何非字母数字字符转换为破折号。结合这两个步骤就足以为你组件生成一个不错的缩略函数。
- en: 'Imagine a feature request for which you need to add a timestamp of the publication
    date to the slug. An optional argument in the slugging method to turn on this
    functionality might be tempting, but it would also be wrong: your API would become
    more confusing to use, harder to refactor (change its code without breaking other
    components, detailed in [chapter 8](kindle_split_020.html#ch08) when we discuss
    testing), and even more difficult to document. It would be more sensible to build
    your component by following the SRP principle using a composition pattern instead.
    *Composition* only means applying functions in sequence, rather than mashing their
    functionality together. So first you’d apply slugging and then you could add a
    timestamp to the slugs, as shown in the following code snippet:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个需要添加发布日期时间戳到缩略名的功能请求。在缩略方法中添加一个可选参数以启用此功能可能很有吸引力，但这将是错误的：你的API将更难以使用，更难以重构（在不破坏其他组件的情况下更改其代码，在第8章中详细讨论，当时我们讨论测试），并且更难以编写文档。更合理的方法是按照SRP原则使用组合模式来构建你的组件。*组合*仅仅意味着按顺序应用函数，而不是将它们的功能混合在一起。所以首先你会应用缩略，然后你可以添加时间戳到缩略名，如下面的代码片段所示：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, imagine that your Search Engine Optimization (SEO) expert comes along,
    and he wants you to exclude irrelevant words from your URL slugs so you get better
    representation in search results. You might be tempted to do that right in the
    `getSlug` function, but here are a few reasons why that would be wrong in this
    case, too:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下，你的搜索引擎优化（SEO）专家出现了，他希望你在URL缩略名中排除无关的词，以便在搜索结果中获得更好的展示。你可能会被诱惑在`getSlug`函数中直接这样做，但这里有几个原因说明为什么在这种情况下这也是错误的：
- en: It would become harder to test the slugging functionality on its own, because
    you’d have logic that doesn’t have anything to do with the slugging.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单独测试缩略功能将变得更加困难，因为你会有一些与缩略无关的逻辑。
- en: The exclusion code might become more advanced as time goes on, but it’d still
    be contained in `getSlug.`
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着时间的推移，排除码可能会变得更加高级，但它仍然会被包含在`getSlug.`中。
- en: 'If you’re cautious, you’ll code a function aimed at the expert’s requirements,
    which looks like the following code snippet:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你小心谨慎，你会编写一个针对专家需求的函数，其代码片段如下：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That looks fairly clean! By giving each method a clear responsibility, you extended
    your functionality without complicating matters too much. In addition, you uncovered
    the possibility of reuse. You might use the SEO expert’s filtering functionality
    all over an application, and that would be easy to extract from your slugging
    module, because it doesn’t depend on that. Similarly, testing each of these three
    methods will be easy. For now, it should be enough to say that keeping code succinct
    and to the point and doing exactly what the function name implies is one of the
    fundamental aspects of maintainable, testable code. In [chapter 8](kindle_split_020.html#ch08)
    you’ll learn more about unit testing.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来相当干净！通过为每个方法赋予清晰的责任，你在不过度复杂化问题的同时扩展了你的功能。此外，你还发现了可重用的可能性。你可能会在整个应用程序中使用SEO专家的过滤功能，并且从你的缩略模块中提取它将很容易，因为它不依赖于它。同样，测试这三个方法中的每一个也将很容易。目前，可以说保持代码简洁、明确，并做到函数名所暗示的正是可维护、可测试代码的基本方面之一。在第8章中，你将了解更多关于单元测试的内容。
- en: Splitting functionality in a modular way is important, but it’s not enough.
    If you’re building a typical component, which has a few methods but shouldn’t
    expose its variables, you need to hide this information from the public interface.
    I’ll discuss the importance of information hiding next.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以模块化方式分割功能很重要，但这还不够。如果你正在构建一个典型的组件，它有几个方法但不应公开其变量，你需要将此信息从公共接口中隐藏。我将在下一节讨论信息隐藏的重要性。
- en: 5.1.2\. Information hiding and interfaces
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.2\. 信息隐藏和接口
- en: As you’re building out an application, code will invariably grow in both volume
    and complexity. This can eventually turn your code base into an unapproachable
    tangle, but you can help it by writing more straightforward code and making it
    easier to follow the flow of code. One way to drive down the complexity creep
    is to hide away unnecessary information, keeping it inaccessible on the interface.
    This way only what matters gets exposed; the rest is considered to be irrelevant
    to the consumer, and it’s often referred to as *implementation details*. You don’t
    want to expose elements such as state variables you use while computing a result
    or the seed for a random number generator. This has to be done at every level;
    each function in every module should attempt to hide everything that isn’t relevant
    to its consumers. In doing this, you’ll do fellow developers and your future self
    a favor by reducing the amount of guesswork involved in figuring out how a particular
    method or module works.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在构建应用程序时，代码的体积和复杂性不可避免地会增加。这最终可能会使你的代码库变得难以接近，但你可以通过编写更直接的代码并使其更容易遵循代码流来帮助解决这个问题。降低复杂性增长的一种方法是通过隐藏不必要的信息，使其在接口上不可访问。这样，只有重要的信息被暴露出来；其余的被认为是与消费者无关的，这通常被称为*实现细节*。你不希望暴露诸如你在计算结果时使用的状态变量或随机数生成器的种子之类的元素。这必须在每个级别上完成；每个模块中的每个函数都应该尝试隐藏与其消费者无关的所有内容。通过这样做，你将帮助其他开发者和未来的你，减少在弄清楚特定方法或模块如何工作时的猜测工作。
- en: As an example, consider the following listing illustrating how you might build
    an object to calculate a simple average sum. The listing (found as ch05/02_information-hiding
    in the samples) uses a constructor function and augments the prototype so `Average`
    objects have an `add` method and a `calc` method.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下示例代码，说明如何构建一个对象来计算简单的平均值。该示例代码（在samples中的ch05/02_information-hiding目录下找到）使用构造函数并扩展原型，使得`Average`对象具有`add`方法和`calc`方法。
- en: Listing 5.2\. Calculating an average sum
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.2\. 计算平均值
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'All that’s left to do is create an `Average` object, add values to it, and
    calculate the average. The problem in this approach is that you might not want
    people directly accessing your private data, such as `Average.count`. Maybe you’d
    rather hide those values from the API consumers using the techniques we’ll cover
    soon. An even simpler approach might be to ditch the object entirely and use a
    function instead. You could use the `.reduce` method (found on the Array prototype,
    new in ES5) to apply an accumulator function on an array of values to calculate
    the average:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作就是创建一个`Average`对象，向其中添加值，并计算平均值。这种方法的问题可能是你不想让人们直接访问你的私有数据，例如`Average.count`。你可能更愿意使用我们即将介绍的技术来隐藏这些值，供API消费者使用。一个更简单的方法可能是完全放弃对象，改用函数。你可以使用`.reduce`方法（在ES5中新增，位于Array原型上）对值数组应用累加函数来计算平均值：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The upside of this function is that it does exactly what you want. It takes
    an array of values, and it returns the average, as its name indicates. In addition,
    it doesn’t keep any state variables the way your prototypical implementation did,
    effectively hiding any information about its inner workings. This is what’s called
    a *pure function*: the result can only depend on the arguments passed to it, and
    it can’t depend on state variables, services, or objects that aren’t part of the
    argument body. Pure functions have another property: they don’t produce any side
    effects other than the result they provide. These two properties combined make
    pure functions good interfaces; they are self-contained and easily testable. Because
    they have no side effects or external dependencies, you can refactor their contents
    as long as the relationship between input and output doesn’t change.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的优点是它确实做了你想要的事情。它接受一个值数组，并返回平均值，正如其名称所示。此外，它没有像你的典型实现那样保留任何状态变量，有效地隐藏了其内部工作原理的任何信息。这被称为
    *纯函数*：结果只能依赖于传递给它的参数，而不能依赖于状态变量、服务或不是参数体一部分的对象。纯函数还有另一个特性：它们不会产生除了提供的结果之外的任何副作用。这两个特性的结合使纯函数成为良好的接口；它们是自包含的，易于测试。因为它们没有副作用或外部依赖，只要输入和输出之间的关系不改变，你就可以重构它们的内部内容。
- en: Functional factories
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 函数式工厂
- en: 'An alternative implementation might use a *functional factory.* That’s a function
    that, when executed, returns a function that does what you want. As you’ll better
    understand in the next section, anything you declare in the factory function is
    private to the factory, and the function that resides within. This is easier to
    understand after reading the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种实现可能使用一个 *函数式工厂*。这是一个函数，当执行时，返回一个执行你想要的功能的函数。正如你将在下一节更好地理解的那样，你在工厂函数中声明的任何内容都是工厂私有的，以及存在于其中的函数。这在你阅读以下代码后更容易理解：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `sum` and `count` variables are only available to instances of the function
    returned by `averageFactory`; furthermore, each instance has access only to its
    own context, those variables that were declared within that instance, but not
    to the context of other instances. Think of it like a cookie cutter. The `averageFactory`
    is the cookie cutter, and it cuts cookies (your function) that take a value and
    return the cumulative average (so far). As an example, here’s how its use might
    look:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum` 和 `count` 变量仅适用于由 `averageFactory` 返回的函数的实例；此外，每个实例只能访问其自身的上下文，即在该实例内部声明的变量，但不能访问其他实例的上下文。想象一下一个饼干模具。`averageFactory`
    就是饼干模具，它切割饼干（你的函数），这些饼干接受一个值并返回累积平均值（到目前为止）。作为一个例子，下面是如何使用它的样子：'
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Much like using your cookie cutter to cut out new cookies won’t affect existing
    cookies, creating more instances won’t have any effect on existing ones. This
    coding style is similar to what you did previously using a prototype, with the
    difference that `sum` and `count` can’t be accessed from anywhere other than the
    implementation. Consumers can’t access these variables, effectively making them
    an implementation detail of the API. Implementation details don’t only introduce
    noise; they can also potentially present security concerns: you wouldn’t want
    to grant the outside world the ability to modify the inner state of your components.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 就像使用你的饼干模具切割新的饼干不会影响现有的饼干一样，创建更多实例也不会对现有的实例产生影响。这种编码风格与你之前使用原型所做的类似，不同之处在于 `sum`
    和 `count` 只能在实现中访问，消费者无法访问这些变量，实际上使它们成为 API 的实现细节。实现细节不仅会引入噪音；它们也可能潜在地带来安全风险：你不会希望授予外部世界修改组件内部状态的能力。
- en: Understanding *variable scopes,* which define where variables are accessible,
    and `this` keyword, which provides context about the caller of a function, is
    essential in building solid structures that can hide information properly. Properly
    scoping variables enables you to hide the information that consumers of an interface
    aren’t supposed to know about.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 *变量作用域*，它定义了变量的可访问性，以及提供函数调用者上下文的 `this` 关键字，对于构建能够正确隐藏信息的稳固结构至关重要。正确的作用域变量使你能够隐藏接口消费者不应该知道的信息。
- en: 5.1.3\. Scoping and this keyword
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.3. 作用域和 this 关键字
- en: 'In his undisputed classic, *JavaScript: The Good Parts* (O’Reilly Media, 2008),^([[1](#ch05fn01)])
    Douglas Crockford explains many of the quirks of the language, and encourages
    us to avoid the “bad parts,” such as `with` blocks, `eval` statements, and type-coercing
    equality operators (`==` and `!=`). If you’ve never read his book, I recommend
    you do so sooner rather than later. Crockford says that `new` and `this` are tricky
    to understand, and he suggests avoiding them entirely. I say you need to understand
    them. I’ll describe what `this` represents, and then I’ll explain how it can be
    manipulated and assigned. In any given piece of JavaScript code, the context is
    made up of the current function scope, and `this`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在他无可争议的经典著作《JavaScript：优秀的部分》（O’Reilly Media，2008）中，Douglas Crockford 解释了语言中的许多怪癖，并鼓励我们避免“不好的部分”，例如`with`块、`eval`语句和类型强制相等运算符（`==`和`!=`）。如果你从未读过他的书，我建议你尽早阅读。Crockford
    表示`new`和`this`难以理解，并建议完全避免它们。我说你需要理解它们。我将描述`this`代表什么，然后解释如何操作和分配它。在任何给定的JavaScript代码片段中，上下文由当前函数作用域和`this`组成。
- en: '¹ You can find *JavaScript: The Good Parts* at Amazon following this link:
    [http://bevacqua.io/bf/goodparts](http://bevacqua.io/bf/goodparts).'
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ 你可以通过以下链接在亚马逊找到《JavaScript：优秀的部分》：[http://bevacqua.io/bf/goodparts](http://bevacqua.io/bf/goodparts)。
- en: 'If you’re used to server-side languages, such as Java or C#, then you’re used
    to thinking of a scope: the bag where variables are contained, which starts and
    ends whenever a curly brace is opened and closed, respectively. In JavaScript,
    scoping happens at the function level (called *lexical scoping)*, rather than
    at the block level.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯了服务器端语言，如Java或C#，那么你已经习惯了思考作用域：变量存放的袋子，它随着每个花括号的打开和关闭而开始和结束。在JavaScript中，作用域在函数级别发生（称为词法作用域），而不是在块级别。
- en: '[Figure 5.2](#ch05fig02) disambiguates lexical scoping from block scoping by
    comparing C#, which has block scoping (other examples include Java, Perl, C, and
    C++) with JavaScript, which has lexical scoping (R is another example).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.2](#ch05fig02) 通过比较具有块作用域的C#（其他示例包括Java、Perl、C和C++）与具有词法作用域的JavaScript（R是另一个示例）来区分词法作用域和块作用域。'
- en: Figure 5.2\. Discrepancies in scoping across languages
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.2\. 不同语言的作用域差异
- en: '![](05fig02_alt.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig02_alt.jpg)'
- en: In the figure, a `message` variable is used in both examples. In the first example,
    `message` is only available inside the `if` statement block, while in the second
    example `message` is available to the entire function, thanks to lexical scoping.
    As you’ll learn, this has both benefits and drawbacks.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，两个示例都使用了`message`变量。在第一个示例中，`message`仅在`if`语句块内部可用，而在第二个示例中，由于词法作用域，`message`对整个函数都可用。正如你将要学习的，这既有优点也有缺点。
- en: Variable scoping in JavaScript
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: JavaScript中的变量作用域
- en: 'An understanding of how scopes work will set you up to understand the module
    pattern, which we’ll visit in [section 5.2](#ch05lev1sec2) as a way of componentizing
    your code base. In JavaScript, `function` is a first-class citizen, and it’s treated
    like any other object. Nested functions each come with their own scope, and inner
    functions have access to the parent scope up until the global space. Consider
    the `getCounter` function in the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 理解作用域的工作原理将使你能够理解模块模式，我们将在[5.2节](#ch05lev1sec2)中讨论它，作为组件化代码库的一种方式。在JavaScript中，`function`是一个一等公民，它被当作任何其他对象来对待。嵌套函数各自带有自己的作用域，内部函数可以访问直到全局空间的上层作用域。考虑以下代码中的`getCounter`函数：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, the `counter` variable is context-bound to the `getCounter`
    function. The returned function can access `counter`, because it’s part of the
    parent scope. But nothing outside `getCounter` can create a reference to `counter`;
    access to it has been shut down and only the privileged children of `getCounter`
    can manipulate it. If you introduce a `console.log(this)` statement at either
    scoping level, you’ll see in both cases the global `Window` object instance is
    referenced. This is the true “bad part;” by default, the `this` keyword will be
    a reference to the global object, as demonstrated in the following listing.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`counter`变量与`getCounter`函数相关联。返回的函数可以访问`counter`，因为它属于父作用域的一部分。但`getCounter`之外没有任何东西可以创建对`counter`的引用；对其的访问已被关闭，只有`getCounter`的特权子代可以操作它。如果你在任一作用域级别引入`console.log(this)`语句，你会在两种情况下看到全局`Window`对象实例被引用。这是真正的“不好的部分”；默认情况下，`this`关键字将引用全局对象，如下面的列表所示。
- en: Listing 5.3\. Understanding the `this` keyword
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.3\. 理解`this`关键字
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There are different ways we can manipulate the `this` keyword. The most common
    way to assign a `this` context is to invoke methods on an object. For example,
    when doing `'Hello'.toLowerCase()`, `'Hello'` will be used as the `this` context
    for the function call.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有不同方式可以操作 `this` 关键字。将 `this` 上下文赋值的最常见方式是在对象上调用方法。例如，当执行 `'Hello'.toLowerCase()`
    时，`'Hello'` 将用作函数调用的 `this` 上下文。
- en: Getting to the call site
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 获取调用位置
- en: When functions are invoked directly as properties on an object, the object will
    become the `this` reference. If the method is in the object’s prototype—for example
    `Object.prototype.toString`—`this` will also be the object the method has been
    invoked on. Note that this is a fragile behavior; if you get a direct reference
    to a method and invoke that, then `this` won’t be the `parent` anymore but rather
    the global object once again. To illustrate, let me show you another listing.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数直接作为对象的属性调用时，该对象将成为 `this` 引用。如果该方法位于对象的原型中——例如 `Object.prototype.toString`——`this`
    也将是方法被调用的对象。请注意，这是一个脆弱的行为；如果你直接引用一个方法并调用它，那么 `this` 就不再是 `parent`，而是再次成为全局对象。为了说明这一点，让我再给你展示另一个列表。
- en: Listing 5.4\. Scoping the `this keyword`
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.4\. `this` 关键字的范围
- en: '![](108fig01_alt.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](108fig01_alt.jpg)'
- en: 'Under strict mode, `this` will default to `undefined`, instead of `Window`.
    Outside strict mode, `this` is always an object; it’s the provided object if it’s
    called with an object reference; it’s a boxed representation if it’s called with
    a primitive boolean, string, or numeric value; or it’s the global object (again,
    `undefined` under strict mode) if it’s called with either `undefined` or `null`,
    either by getting a direct reference to the method or by using any one of these:
    `.apply`, `.call`, or `.bind`. The value passed as `this` to a function in strict
    mode isn’t boxed into an object. We’ll get to what else strict mode does shortly.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下，`this` 将默认为 `undefined`，而不是 `Window`。在非严格模式下，`this` 总是一个对象；如果它通过对象引用调用，则是提供对象；如果它通过原始布尔值、字符串或数值值调用，则是一个封装表示；如果它通过
    `undefined` 或 `null` 调用，无论是通过直接引用方法还是使用 `.apply`、`.call` 或 `.bind` 中的任何一个，则是指向全局对象（在严格模式下再次是
    `undefined`）。在严格模式下传递给函数的 `this` 值不会被封装到对象中。我们很快就会了解到严格模式还能做什么。
- en: 'Other than what happens out of the box when invoking functions, you can use
    different methods to assign a value to `this`; it’s not entirely out of your control.
    In fact, you could use `.bind` to create a function that will always have the
    `this` value provided to it. Alternative ways of executing a method include `.apply`,
    `.call`, and the `new` operator. Here’s a cheat sheet so you can see the methods
    in action:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 除了调用函数时默认发生的情况外，你可以使用不同的方法为 `this` 赋值；这并不完全在你的控制之下。实际上，你可以使用 `.bind` 创建一个始终具有提供给它的
    `this` 值的函数。执行方法的其他方式包括 `.apply`、`.call` 和 `new` 操作符。以下是一个速查表，以便你可以看到这些方法的作用：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In JavaScript, variables fill a scope in the following order:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，变量按照以下顺序填充作用域：
- en: 'Scope context variables: this and arguments'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作用域上下文变量：this 和 arguments
- en: 'Named function parameters: function (these, variable, names)'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名函数参数：function (these, variable, names)
- en: 'Function expressions: function something () {}'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数表达式：function something () {}
- en: 'Local scope variables: var foo'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 局部作用域变量：var foo
- en: If you’re not experimenting or following along with a JavaScript interpreter
    by your side, make sure to look at the code sample (ch05/03_context-scoping);
    I’ve included these examples in the source code provided with the book, and they
    have a few inline comments if you have trouble understanding. Let’s now discuss
    what the strict mode entails.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有在旁边使用 JavaScript 解释器进行实验，或者没有跟随代码示例（ch05/03_context-scoping），请确保查看代码示例；我已经将这些示例包含在本书提供的源代码中，如果你理解上有困难，它们包含了一些内联注释。现在让我们讨论严格模式包含的内容。
- en: 5.1.4\. Strict mode
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.4\. 严格模式
- en: When enabled, strict mode modifies semantics in the way your code works, reducing
    the leniency toward missing `var` statements and similarly error-prone practices,
    sort of complementary to using a linter.^([[2](#ch05fn02)]) Strict mode can be
    enabled on individual functions or on an entire script.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用时，严格模式会以修改代码工作语义的方式修改语义，减少对缺少 `var` 语句和类似容易出错的做法的宽容度，这在某种程度上与使用代码检查器是互补的.^([[2](#ch05fn02)])
    严格模式可以在单个函数或整个脚本上启用。
- en: ² Get a detailed explanation of strict mode in Mozilla Developer Network at
    [http://bevacqua.io/bf/strict](http://bevacqua.io/bf/strict).
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ² 在 Mozilla 开发者网络中获取严格模式的详细解释，请访问 [http://bevacqua.io/bf/strict](http://bevacqua.io/bf/strict)。
- en: 'For client-side code, the function form is preferred. To turn on strict mode,
    put the `''use strict''`; statement (double quotes work, too) at the top of a
    file or function:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于客户端代码，首选函数形式。要启用严格模式，请在文件或函数顶部放置`'use strict';`语句（双引号也行）：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Aside from `this` defaulting to `undefined`, rather than the global object,
    strict is less tolerant of mistakes, turning them into errors rather than correcting
    them. Restrictions also include banning the `with` statement, octal notation,
    and preventing keywords such as `eval` and `arguments` to be assigned.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`this`默认为`undefined`而不是全局对象之外，严格模式对错误的容忍度更低，将它们转换为错误而不是纠正它们。限制还包括禁止`with`语句、八进制表示法，以及防止将关键字如`eval`和`arguments`赋值。
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Under strict mode, the engine also throws an exception if you attempt to write
    on read-only properties, delete undeletable properties, instantiate an object
    with duplicate property keys, or declare a function with duplicate argument names.
    This kind of intolerance helps catch issues due to sloppy coding.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下，如果尝试写入只读属性、删除不可删除的属性、使用重复属性键创建对象或声明具有重复参数名称的函数，引擎也会抛出异常。这种不容忍的态度有助于捕捉到由于编码马虎而产生的问题。
- en: The last quirk I want to cover while we’re on the topic of scoping is something
    that’s commonly referred to as hoisting. Understanding hoisting is important if
    you’re to write complex JavaScript applications sensibly.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论作用域的话题时，我想讨论的最后一个小问题是通常被称为提升的内容。理解提升对于编写合理的复杂JavaScript应用程序非常重要。
- en: 5.1.5\. Variable hoisting
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.5\. 变量提升
- en: A large number of JavaScript interview questions can be answered with an understanding
    of scoping, how `this` works, and hoisting. We’ve covered the first two, but what
    exactly is hoisting? In JavaScript, *hoisting* means that variable declarations
    are pulled to the beginning of a scope. This explains the unexpected behavior
    you can observe in certain situations.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 许多JavaScript面试题可以通过理解作用域、`this`的工作原理以及提升来回答。我们已经涵盖了前两点，但提升究竟是什么？在JavaScript中，*提升*意味着变量声明被拉到作用域的起始位置。这解释了你在某些情况下可以观察到的意外行为。
- en: 'Function expressions are hoisted entirely: the function body is also hoisted,
    not only their declaration. If I had a single thing to take away from *The Good
    Parts*, it would be learning about hoisting; it changed the way I write code,
    and reason about it.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 函数表达式被完全提升：函数体也被提升，而不仅仅是它们的声明。如果我从《JavaScript高级程序设计》这本书中只能学到一点，那就是关于提升的知识；它改变了我的编码方式，以及我对它的思考方式。
- en: 'Hoisting is the reason invoking function expressions before declaring them
    works as expected. Assigning functions to a variable won’t do the trick, because
    the variable won’t be assigned by the time you want to invoke the function. The
    following code is one example; you’ll find more examples in the accompanying source
    code, listed as ch05/04_hoisting:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 提升是调用函数表达式在声明之前按预期工作的原因。将函数赋值给变量不会奏效，因为变量在你想要调用函数的时候还没有被赋值。以下代码是一个例子；你将在附带的源代码中找到更多例子，列在ch05/04_hoisting中：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You might expect the method to print `'number'` first, and `2` afterward, or
    maybe `3`. Try running it! Why does it print `'undefined'` and then `undefined`?
    Well, hello hoisting! It’ll be easier to picture if you rearrange the code the
    way it ends up after hoisting takes place. Let’s look at the following listing.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能预期方法首先打印`'number'`，然后是`2`，或者可能是`3`。试着运行它！为什么它先打印`'undefined'`然后是`undefined`？嗯，你好，提升！如果你按照提升后代码的最终顺序重新排列代码，会更容易理解。让我们看看以下列表。
- en: Listing 5.5\. Using hoisting
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.5\. 使用提升
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `value` declaration at the end of the `test` function got hoisted to the
    top of the scope, and it’s also why `test` didn’t give a `TypeError` exception,
    warning that `undefined` isn’t a function. Keep in mind that if you used the variable
    form of declaring the `test` function, you would, in fact, have gotten that error,
    because although `var test` would be hoisted, the assignment wouldn’t be, effectively
    becoming the code in the following listing.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`test`函数末尾的`value`声明被提升到了作用域的顶部，这也是为什么`test`没有抛出`TypeError`异常，警告`undefined`不是一个函数。记住，如果你使用了声明`test`函数的变量形式，实际上你会得到那个错误，因为虽然`var
    test`会被提升，但赋值不会，实际上变成了以下列表中的代码。'
- en: Listing 5.6\. Hoisting `var test`
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.6\. 提升var test
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The code in [listing 5.6](#ch05ex06) won’t work as expected, because `test`
    won’t be defined by the time you want to invoke it. It’s important to learn what
    gets hoisted and what doesn’t. If you make a habit of writing code as if it were
    already hoisted, pulling variable declarations and functions to the top of their
    scope, you’ll run into fewer problems than you might run into otherwise. At this
    point you should feel comfortable with scoping and the `this` keyword. It’s time
    to talk about closures and modular patterns in JavaScript.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[代码列表 5.6](#ch05ex06) 中的代码不会按预期工作，因为当你想要调用 `test` 时，它还没有被定义。了解哪些内容会被提升以及哪些不会是非常重要的。如果你养成了一种编写代码就像它已经被提升的习惯，将变量声明和函数拉到它们作用域的顶部，你遇到的问题会比其他情况下少得多。到现在，你应该对作用域和
    `this` 关键字感到很舒服了。现在是时候讨论 JavaScript 中的闭包和模块模式了。'
- en: 5.2\. JavaScript modules
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2. JavaScript 模块
- en: Up to this point, you’ve looked at the single responsibility principle, information
    hiding, and how to apply those in JavaScript. You also have a decent idea of how
    variables are scoped and hoisted. Let’s move on to closures. These will help you
    create new scopes and prevent variables from leaking information.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经了解了单一职责原则、信息隐藏以及如何在 JavaScript 中应用这些原则。你对变量的作用域和提升也有了一定的了解。现在让我们继续学习闭包。闭包将帮助你创建新的作用域并防止变量泄露信息。
- en: 5.2.1\. Closures and the module pattern
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.1. 闭包和模块模式
- en: 'Functions are also referred to as closures, particularly when focusing on the
    fact that functions create new scopes. An IIFE is a function that you execute
    immediately. The term IIFE stands for Immediately-Invoked Function Expression.
    Using an IIFE is useful when all you want is a closure. The following code is
    an example IIFE:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也被称为闭包，尤其是在关注函数创建新作用域的事实时。立即调用的函数表达式（IIFE）是一个立即执行的函数。IIFE 的全称是 Immediately-Invoked
    Function Expression。使用 IIFE 有助于创建闭包。以下代码是一个 IIFE 的示例：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Note the parentheses wrapping the function. These tell the interpreter you’re
    not only declaring an anonymous function, but also using it as a value. These
    expressions can also be used in assignments, which are useful if you need variables
    accessible by the exported return value. This is commonly referred to as the module
    pattern, as shown in the following code (labeled ch05/05_closures in the samples):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意函数周围的括号。这告诉解释器你不仅声明了一个匿名函数，还将其用作一个值。这些表达式也可以用于赋值操作，这在需要变量可以通过导出的返回值访问时非常有用。这通常被称为模块模式，如下面的代码所示（在示例中标记为
    ch05/05_closures）：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A common variant to the previous code doesn’t rely on anything outside of the
    closure, but instead imports the variables it’s going to use. If it wants to expose
    a public API, then it imports the global object. I tend to favor this approach
    because everything is nicely wrapped by a closure, and you can instruct JSHint
    to blow up on issues due to undeclared variables. Without a closure and JSHint,
    these would inadvertently become globals. To illustrate, look at the following
    code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码的一个常见变体不依赖于闭包之外的内容，而是导入它将要使用的变量。如果它想要公开一个公共 API，那么它就导入全局对象。我倾向于更喜欢这种方法，因为所有内容都被闭包很好地封装起来，你可以指示
    JSHint 在未声明的变量问题上爆炸。没有闭包和 JSHint，这些可能会意外地成为全局变量。为了说明这一点，请看以下代码：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Let’s consider *prototypal modularity*, which augments a prototype rather than
    using closures, as a complementary alternative to IIFE expressions. Using prototypes
    provides performance gains, as many objects can share the same prototype and adding
    functions on the prototype provides the functionality to all the objects that
    inherit from it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑 *原型式模块化*，它通过增强原型而不是使用闭包作为 IIFE 表达式的补充替代方案。使用原型可以提供性能提升，因为许多对象可以共享同一个原型，而在原型上添加函数可以为从它继承的所有对象提供功能。
- en: 5.2.2\. Prototypal modularity
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.2. 原型式模块化
- en: Depending on your use case, prototypes might be exactly what you need. Think
    of prototypes as JavaScript’s way of declaring classes, even though it’s an entirely
    different model, because prototypes are simply links, and you can’t override properties
    unless you replace them entirely (and do the overriding by hand). In short, don’t
    try to treat prototypes as classes, because it will assuredly result in maintainability
    issues. Prototypes are most useful when you expect to have multiple instances
    of your module. For example, all JavaScript strings share the `String` prototype.
    A good use for prototypes is when interacting with DOM nodes. Sometimes I find
    myself declaring prototypal modules inside a closure and then keeping private
    state in the closure, outside the prototype. The following listing shows pseudo-code,
    but please look at the accompanying code sample listed as ch05/06_prototypal-modularity
    for a fully working example and to get a better understanding of the pattern.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的使用场景，原型可能正是您所需要的。将原型视为 JavaScript 声明类的方式，尽管它是一个完全不同的模型，因为原型仅仅是链接，除非您完全替换它们（并且手动进行覆盖），否则您无法覆盖属性。简而言之，不要试图将原型视为类，因为这肯定会引起可维护性问题。当您预期您的模块有多个实例时，原型最有用。例如，所有
    JavaScript 字符串都共享 `String` 原型。原型的一个良好用途是在与 DOM 节点交互时。有时我发现自己在闭包内声明原型模块，然后在闭包外部保持私有状态，在原型之外。以下列表展示了伪代码，但请参阅作为
    ch05/06_prototypal-modularity 列出的配套代码示例，以获取一个完全工作的示例，并更好地理解该模式。
- en: Listing 5.7\. Using pseudo-code for prototypes
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.7\. 使用伪代码进行原型设计
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is one way to keep data safe from consumers; many scenarios exist when
    data privatization isn’t necessary and where allowing consumers to manipulate
    your instance data might be a good thing. You should wrap all of this in a closure
    so your private data doesn’t leak out. I believe prototypes in JavaScript are
    most useful when dealing with DOM interaction, as we’ll investigate in [chapter
    7](kindle_split_019.html#ch07). That’s because when dealing with DOM objects,
    you usually have to work with many elements at the same time; prototypes improve
    performance because their methods aren’t replicated on each instance, saving resources.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是保持数据安全的一种方法；存在许多场景，在这些场景中，数据私有化不是必需的，允许消费者操作您的实例数据可能是一件好事。您应该将这些内容全部封装在闭包中，以便您的私有数据不会泄露出来。我相信在处理
    DOM 交互时，JavaScript 中的原型最有用，正如我们将在第 7 章中调查的那样。那是因为在处理 DOM 对象时，您通常必须同时处理许多元素；原型通过不在每个实例上复制其方法来提高性能，从而节省资源。
- en: 'Now that you have a clearer understanding of how scoping, hoisting, and closures
    work, we can move on to how modules are meant to interact with one another. First,
    let’s look at CommonJS modules: a way to keep code well-organized and deal with
    dependency injection (DI) at once.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经更清楚地了解了作用域、提升和闭包是如何工作的，我们可以继续探讨模块应该如何相互交互。首先，让我们看看 CommonJS 模块：这是一种保持代码井然有序并一次性处理依赖注入（DI）的方法。
- en: 5.2.3\. CommonJS modules
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.3\. CommonJS 模块
- en: CommonJS (CJS) is a specification adopted by Node.js, among others, which allows
    you to write modular JavaScript files. Each module is defined by a single file,
    and if you assign a value to `module.exports`, it becomes that module’s public
    interface. To consume a module, you call `require` with the relative path from
    the consumer to the dependency.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: CommonJS（CJS）是由 Node.js 等其他一些规范采用的规范，它允许您编写模块化的 JavaScript 文件。每个模块由一个单独的文件定义，如果您将值赋给
    `module.exports`，它就成为了该模块的公共接口。要使用模块，您需要使用从消费者到依赖项的相对路径调用 `require`。
- en: 'Let’s look at a quick example, labeled ch05/07_commonjs-modules in the samples:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个快速示例，在示例中标记为 ch05/07_commonjs-modules：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'One of the most useful advantages of these modules is that variables don’t
    leak to the global object: you have no need to wrap your code in a closure. The
    variables that are declared on the top-most scope (such as the `simple` variable
    in the previous snippet) are merely available in that module. If you want to expose
    something, you need to make that intent explicit by adding it to `module.exports`.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模块最有用的优点之一是变量不会泄漏到全局对象：您不需要将代码封装在闭包中。在最高作用域声明的变量（如前一个片段中的 `simple` 变量）仅在该模块中可用。如果您想公开某些内容，您需要通过将其添加到
    `module.exports` 中来明确表示这种意图。
- en: 'At this point you might think I went off the trail with CJS, given that it’s
    not supported natively in browsers any more than are CoffeeScript and TypeScript.
    You’ll soon learn how to compile these modules using Browserify, a popular library
    designed to compile CJS modules to something browsers can deal with. CJS has the
    following benefits over the way browsers behave:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能会认为我偏离了CJS的路径，因为CJS在浏览器中不再原生支持，就像CoffeeScript和TypeScript一样。你很快就会了解到如何使用Browserify编译这些模块，Browserify是一个流行的库，旨在将CJS模块编译成浏览器可以处理的内容。CJS相对于浏览器行为有以下优点：
- en: No global variables, less cognitive load
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有全局变量，认知负荷更少
- en: Straightforward process to expose an API and consume a module
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 揭示API和消费模块的简单流程
- en: Easier to test modules by mocking dependencies
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过模拟依赖项来测试模块更容易
- en: Access to packages on npm, thanks to Browserify
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Browserify访问npm上的包
- en: Modularity, which translates into testability
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化，这转化为可测试性
- en: Easy to share code between client and server, if you’re using Node.js
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用Node.js，客户端和服务器之间共享代码更容易
- en: You’ll learn more about package management solutions (npm, Bower, and Component)
    in [section 5.4](#ch05lev1sec4). Before we get there, we’ll look at *dependency
    management*, or how to deal with the components needed by your application, and
    how different libraries can help manage them.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在[第5.4节](#ch05lev1sec4)中了解更多关于包管理解决方案（npm、Bower和Component）的信息。在我们到达那里之前，我们将探讨依赖项管理，即如何处理应用程序所需的组件，以及不同的库如何帮助管理它们。
- en: 5.3\. Using dependency management
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3. 使用依赖项管理
- en: 'We’ll discuss two kinds of dependency management here: internal and external.
    When talking about internal dependencies, I’m referring to those that are part
    of the program you’re writing. Most frequently, these are a one-to-one mapping
    to physical files, but you might also have multiple modules in a single file.
    By modules I mean pieces of code that have a single responsibility, regardless
    of them being services, factories, models, controllers, or something else. External
    dependencies are, in contrast, those in which the code isn’t governed by your
    application itself. You may own or have authored the package, but the code belongs
    to a different repository altogether, regardless.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将讨论两种依赖项管理类型：内部和外部。当谈到内部依赖项时，我指的是程序编写的一部分。最常见的情况是，这些依赖项与物理文件一对一映射，但你也可能在单个文件中有多个模块。通过模块，我指的是具有单一职责的代码片段，无论它们是服务、工厂、模型、控制器还是其他什么。相比之下，外部依赖项是指代码不由你的应用程序本身管理的那些。你可能拥有或编写了该包，但代码属于完全不同的存储库。
- en: I’ll explain what dependency graphs are, and then we’ll investigate ways of
    working through them, such as the caveats with resorting to the RequireJS module
    loader, the innocent straightforwardness made available by CommonJS, and the elegant
    way AngularJS (a Model-View-Controller framework built by Google) resolves dependencies
    while keeping everything modular and testable.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我将解释依赖图是什么，然后我们将研究处理它们的方法，例如使用RequireJS模块加载器的注意事项，CommonJS提供的简单直接性，以及AngularJS（由Google构建的模型-视图-控制器框架）在保持一切模块化和可测试性的同时解决依赖项的优雅方式。
- en: 5.3.1\. Dependency graphs
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.1. 依赖图
- en: When writing out a module which depends on something else, the most common approach
    is to have your module create an instance of the object you depend on. To illustrate
    the point, bear with me through a little Java code; it should be easy to wrap
    your head around. The following listing displays a `UserService` class, which
    has the purpose of serving any data requests from a domain logic layer. It could
    consume any `IUserRepository` implementation which is tasked with retrieving the
    data from a repository such as a MySQL database or a Redis store. This listing
    is labeled ch05/08_dependency-graphs in the samples.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写依赖于其他内容的模块时，最常见的方法是让您的模块创建一个依赖于的对象的实例。为了说明这一点，请耐心地跟随我通过一小段Java代码；这应该很容易理解。以下列表显示了一个`UserService`类，它的目的是从领域逻辑层处理任何数据请求。它可以消费任何`IUserRepository`实现，该实现负责从MySQL数据库或Redis存储等存储库检索数据。此列表在示例中标记为ch05/08_dependency-graphs。
- en: Listing 5.8\. Using a module to create an object
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.8. 使用模块创建对象
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: But that doesn’t cut it; if your service is supposed to use any repository that
    conforms to the interface, why are you hard-coding `UserMySqlRepository` that
    way? Hard-coded dependencies make it more difficult to test a module, because
    you wouldn’t merely test against the interface, but rather against a concrete
    implementation. A better approach, which is coincidentally more testable, might
    be passing that dependency through the constructor, as shown in the following
    listing. This pattern is often referred to as dependency injection, which is a
    smart-sounding alternative to giving an object its instance variables.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 但这还不够；如果你的服务应该使用符合接口的任何存储库，为什么你还要那样硬编码 `UserMySqlRepository` 呢？硬编码的依赖使得测试模块变得更加困难，因为你不会仅仅针对接口进行测试，而是针对具体的实现进行测试。一个更好的方法，碰巧也更易于测试，可能是通过构造函数传递那个依赖，如下面的列表所示。这种模式通常被称为依赖注入，它是一个听起来很聪明的替代方案，用于给对象提供实例变量。
- en: Listing 5.9\. Using dependency injection
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.9\. 使用依赖注入
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This way, you can build out your service the way it was intended, as a consumer
    of any repository conforming to the `IUserRepository` interface without any knowledge
    of implementation specifics. Creating a `UserService` might not sound like such
    a great deal, but it gets harder as soon as you take into consideration its dependencies,
    and its dependencies’ dependencies. This is called a *dependency tree.* The following
    snippet is certainly unappealing:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你可以按照预期的方式构建你的服务，作为一个符合 `IUserRepository` 接口的任何存储库的消费者，而不需要了解实现的具体细节。创建一个
    `UserService` 可能听起来不是什么大事，但一旦考虑到它的依赖以及依赖的依赖，事情就会变得复杂。这被称为 *依赖树*。以下片段显然不太吸引人：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The code shows *inversion of control* (IoC),^([[3](#ch05fn03)]) which is a wordy
    definition for something rather simple. IoC means that instead of making an object
    responsible for the instantiation of its dependencies, or getting references to
    them, the object is given the dependencies through its constructor or through
    public properties. [Figure 5.3](#ch05fig03) examines the benefits of using an
    IoC pattern.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 代码展示了 *控制反转* (IoC)，^([[3](#ch05fn03)]) 这是一个对相当简单的事情的冗长定义。IoC 意味着不是让对象负责其依赖项的实例化或获取它们的引用，而是通过构造函数或通过公共属性将依赖项提供给对象。[图
    5.3](#ch05fig03) 考察了使用 IoC 模式的益处。
- en: ³ Read a primer on inversion of control and dependency injection by Martine
    Fowler at [http://bevacqua.io/bf/ioc](http://bevacqua.io/bf/ioc).
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³ 在 [http://bevacqua.io/bf/ioc](http://bevacqua.io/bf/ioc) 阅读Martine Fowler关于控制反转和依赖注入的入门指南。
- en: Figure 5.3\. Classical dependencies compared with using IoC to improve testability
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.3\. 经典依赖与使用 IoC 提高可测试性的比较
- en: '![](05fig03_alt.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片 5.3](05fig03_alt.jpg)'
- en: The IOC code (at the bottom of the figure) is easier to test, more loosely coupled,
    and easier to maintain as a result, than the classic dependency management code
    shown at the top of the figure.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的 IOC 代码（位于底部）比图顶部的经典依赖管理代码更容易测试、更松散耦合，并且更容易维护。
- en: IoC frameworks are used to address dependency resolution and mitigate dependency
    hell. The basic gist of these frameworks is that you ditch the `new` keyword and
    rely on an IoC container. The *IoC container* is a registry that has knowledge
    about how to instantiate your services, repositories, and any other modules. Learning
    how to configure a traditional IoC container (such as Spring in the case of Java,
    or Castle Windsor for C#) is outside of the scope of this book, but a top-level
    view of the issue is required to pave the road ahead.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: IoC 框架用于解决依赖解析和缓解依赖地狱问题。这些框架的基本原理是放弃使用 `new` 关键字，并依赖于 IoC 容器。*IoC 容器* 是一个注册表，它了解如何实例化你的服务、存储库以及任何其他模块。学习如何配置传统的
    IoC 容器（例如 Java 中的 Spring 或 C# 中的 Castle Windsor）超出了本书的范围，但了解该问题的概览对于铺平道路是必要的。
- en: Is IoC important for testability?
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: IoC 对于可测试性重要吗？
- en: Ultimately, the importance of avoiding hard-coded dependencies lies in the ability
    to easily mock them when unit testing, as you’ll see in [chapter 8](kindle_split_020.html#ch08).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，避免硬编码依赖的重要性在于在单元测试时可以轻松地模拟它们，正如你将在 [第 8 章](kindle_split_020.html#ch08) 中看到的。
- en: Unit testing is about asserting whether interfaces work as expected, regardless
    of how they’re implemented. *Mocks* are stubs that implement the interface, but
    don’t do anything other than the bare minimum to conform to them. For example,
    a mocked user repository might always return the same hard-coded `User` object.
    This is useful in the context of unit testing, where you might want to test the
    `UserService` class on its own, but don’t need details about its inner workings,
    much less how its dependencies are implemented!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是关于断言接口是否按预期工作，而不管它们的实现方式如何。*模拟*是实现接口的存根，但除了符合它们的最基本要求外，不做任何事情。例如，一个模拟的用户存储库可能会始终返回相同的硬编码
    `User` 对象。这在单元测试的上下文中很有用，您可能想单独测试 `UserService` 类，但不需要了解其内部工作原理，更不用说其依赖项的实现方式了！
- en: 'Great! Enough Java for now, though. What does any of this have to do with JavaScript
    Application Design? Understanding testability principles is required if you hope
    to write testable code. Although you may not agree with the Test-Driven Development
    movement, it’s undeniable that code that isn’t written with testability in mind
    is much harder to write tests for. When speaking about client-side JavaScript,
    you have an additional layer of complexity: networking. Modules aren’t immediately
    available unless your code is bundled together the way you learned to do it in
    [chapter 2](kindle_split_013.html#ch02).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在就足够了解 Java 了。这一切与 JavaScript 应用程序设计有什么关系呢？如果您希望编写可测试的代码，理解测试原则是必要的。尽管您可能不同意测试驱动开发运动，但不可否认的是，没有考虑到可测试性的代码编写起来要困难得多。当谈到客户端
    JavaScript 时，您还有一个额外的复杂性层：网络。除非您的代码以您在第二章中学到的方式打包在一起，否则模块不会立即可用。
- en: Next, I’ll introduce you to RequireJS, an asynchronous module loader, which
    is a better option than the classical approach of having an unmanaged dependency
    soup.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将向您介绍 RequireJS，这是一个异步模块加载器，它比传统的无管理依赖库方法更优。
- en: 5.3.2\. Introducing RequireJS
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.2\. 介绍 RequireJS
- en: 'RequireJS is a JavaScript asynchronous module loader (AMD) that allows you
    to define modules and have them depend on one another. The following code (found
    as ch05/09_requirejs-usage in the samples) is an example usage of AMD, depicting
    a module that depends on something else:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: RequireJS 是一个 JavaScript 异步模块加载器 (AMD)，允许您定义模块，并使它们相互依赖。以下代码（在 samples 中的 ch05/09_requirejs-usage
    可以找到）是 AMD 的一种示例用法，描述了一个依赖于其他模块的模块：
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'By convention, `''lib/text`’ looks for the file that can be found at the `./lib/text.js`
    path, relative to the JavaScript directory root. That resource will be requested,
    interpreted, and once all dependencies have been loaded, the module’s function
    will be invoked, getting its dependencies as arguments to the module’s function,
    much like the Java code I talked about in [section 5.3.1](#ch05lev2sec9). The
    sample `''lib/text''` module is defined as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，`'lib/text`’ 会查找在 JavaScript 目录根目录下的 `./lib/text.js` 路径上的文件。该资源将被请求、解释，一旦所有依赖项都已加载，模块的函数将被调用，并将依赖项作为模块函数的参数传递，就像我在第
    5.3.1 节中提到的 Java 代码一样。以下是如何定义 `'lib/text'` 模块的示例：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Next, let’s analyze where RequireJS is better than the alternatives, and where
    it falls short.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们分析 RequireJS 相比其他替代方案的优势和不足之处。
- en: Benefits and drawbacks of RequireJS
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: RequireJS 的优缺点
- en: 'In this case, the definition uses an empty array because it has no dependencies.
    The returned function is the public interface provided by the `''lib/text''` module.
    The use of RequireJS has a few benefits:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，定义使用了一个空数组，因为它没有依赖。返回的函数是 `'lib/text'` 模块提供的公共接口。使用 RequireJS 有几个好处：
- en: Dependency graph is automatically resolved. No more worrying about ordering
    script tags!
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖图会自动解析。不再需要担心脚本标签的顺序了！
- en: Asynchronous module loading is included.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含异步模块加载。
- en: A compile step isn’t required during development.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发过程中不需要编译步骤。
- en: It’s unit testable, so you only load the module that needs to be tested.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是单元可测试的，因此您只需加载需要测试的模块。
- en: Closures are enforced, because your module is defined in a function.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于您的模块是在一个函数中定义的，因此强制执行闭包。
- en: 'These are all true and nice to have, but drawbacks exist. If a package your
    code depends on isn’t wrapped in AMD magic, you have no option other than adding
    a compile step to bundle everything together. Unless you bundle your modules together,
    RequireJS will create an HTTP request cascade to fetch each dependency, which
    would be too slow in production systems. Many of the benefits of AMD came from
    the lack of a compile step, so you’re left with a glorified dependency graph resolver
    packed with the following drawbacks:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是真实且令人愉悦的，但存在缺点。如果你的代码依赖的包没有被 AMD 魔法包装，你除了添加一个编译步骤来将所有内容捆绑在一起外别无选择。除非你将模块捆绑在一起，否则
    RequireJS 将创建一个 HTTP 请求级联来获取每个依赖项，这在生产系统中会非常慢。AMD 的许多好处都来自于没有编译步骤，所以你只剩下了一个装满以下缺点的美化版的依赖关系图解析器：
- en: Asynchronous loading functionality is unavailable if you use the bundler.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用打包器，异步加载功能将不可用。
- en: It requires vendors to conform to the AMD model.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它要求供应商遵守 AMD 模型。
- en: It clutters your code with AMD wrappers.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它会在你的代码中添加 AMD 包装器，造成混乱。
- en: Production needs compilation.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产需要编译。
- en: Code in release environments diverges from local development.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在发布环境中的代码与本地开发环境中的代码不同。
- en: It’s been a while since we spoke of Grunt in [chapter 4](kindle_split_015.html#ch04),
    and you wouldn’t want to release a bunch of unoptimized scripts! Grunt will help
    compile AMD modules during your builds so they don’t need to be fetched asynchronously.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 自从我们在第 4 章 [chapter 4](kindle_split_015.html#ch04) 中提到 Grunt 以来已经有一段时间了，你肯定不希望发布一大堆未优化的脚本！Grunt
    将帮助你在构建过程中编译 AMD 模块，这样它们就不需要异步获取了。
- en: To compile^([[4](#ch05fn04)]) AMD modules through `r.js`, the RequireJS optimizer,
    using Grunt, you can use the `grunt-contrib-requirejs` package. That package allows
    you to pass options through to `r.js`. The following listing is the pertinent
    task configuration. You’ll set default options that apply to every target in Grunt
    and tweak the `debug` target. This is useful when you’d otherwise have to repeat
    parts of the configuration, breaking the DRY principle.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过 `r.js`（RequireJS 优化器）使用 Grunt 编译 AMD 模块，你可以使用 `grunt-contrib-requirejs`
    包。该包允许你将选项传递给 `r.js`。以下列表是相关的任务配置。你将为每个目标设置默认选项，并调整 `debug` 目标。这在你需要重复配置的部分时非常有用，因为这会违反
    DRY 原则。
- en: ⁴ Check out the accompanying code sample that shows how to compile RJS modules
    at [http://bevacqua.io/bf/requirejs](http://bevacqua.io/bf/requirejs).
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴ 想了解如何编译 RJS 模块，请查看随附的代码示例：[http://bevacqua.io/bf/requirejs](http://bevacqua.io/bf/requirejs)。
- en: Listing 5.10\. Using Grunt to configure a module
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.10\. 使用 Grunt 配置模块
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the debug distribution you generate a source map,^([[5](#ch05fn05)]) which
    helps browsers map what they’re executing to the source code you used to compile
    it. This is useful when debugging, as you’ll get stack traces that point to the
    source code rather than hard-to-debug compilation results. The `release` target
    doesn’t have any additional configuration, because it merely uses the defaults
    provided previously. It’ll be easier for you to visualize the configuration if
    you take a look at the directory structure in the accompanying samples, which
    looks like the one in [figure 5.4](#ch05fig04).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试版本中，你生成一个源映射，^([[5](#ch05fn05)])，这有助于浏览器将它们正在执行的代码映射到编译它时使用的源代码。这在调试时非常有用，因为你将获得指向源代码的堆栈跟踪，而不是难以调试的编译结果。`release`
    目标没有额外的配置，因为它只是使用了之前提供的默认值。如果你查看随附样本中的目录结构，这将更容易可视化配置，该结构类似于 [图 5.4](#ch05fig04)。
- en: ⁵ For more information on source maps, refer to this introductory article on
    HTML5Rocks at [http://bevacqua.io/bf/sourcemap](http://bevacqua.io/bf/sourcemap).
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵ 关于源映射的更多信息，请参阅 HTML5Rocks 上的这篇入门文章：[http://bevacqua.io/bf/sourcemap](http://bevacqua.io/bf/sourcemap)。
- en: Figure 5.4\. Typical file structure when using RequireJS during Grunt builds
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.4\. 使用 RequireJS 在 Grunt 构建时的典型文件结构
- en: '![](05fig04.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![05fig04.jpg](05fig04.jpg)'
- en: '|  |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: A sample that integrates RequireJS with Grunt can be found in the book’s source
    code at ch05/10_requirejs-grunt. It contains detailed information about the meaning
    of each option used to configure the RequireJS build task.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一个集成了 RequireJS 和 Grunt 的示例可以在本书的源代码中找到，位于 ch05/10_requirejs-grunt 目录下。它包含了关于配置
    RequireJS 构建任务时使用的每个选项含义的详细信息。
- en: '|  |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Not having to add script tags in a specific order is a nice feature to have,
    and you have a few ways to accomplish that. If you’re not entirely sold on the
    AMD solution, or if you’re curious, read on for an explanation of how you could
    bring CommonJS modules to the browser, as an alternative.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 不必按照特定顺序添加脚本标签是一个很好的特性，而且你有几种方法可以实现这一点。如果你对AMD解决方案并不完全满意，或者如果你对此感到好奇，请继续阅读，以了解如何将CommonJS模块引入浏览器，作为替代方案。
- en: '5.3.3\. Browserify: CJS in the browser'
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.3. Browserify：浏览器中的CJS
- en: In [section 5.2.3](#ch05lev2sec8) I explained the benefits of CJS, the module
    system used in Node.js packages. These modules also have a place in the browser,
    thanks to Browserify. This option is frequently pitched as an alternative to AMD,
    although opinions vary. As you’re following a Build First approach, compiling
    CJS modules for the browser won’t be a big deal; it’s another step in your build
    process!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在[5.2.3节](#ch05lev2sec8)中，我解释了CJS（Node.js包中使用的模块系统）的好处。这些模块也因Browserify而有了在浏览器中的位置。这个选项经常被提出作为AMD的替代方案，尽管意见不一。由于你遵循的是Build
    First方法，因此为浏览器编译CJS模块不会成为大问题；这只是你构建过程中的一步！
- en: In addition to the advantages described in [section 5.2.3](#ch05lev2sec8), such
    as no implicit globals, CJS offers a terse alternative to AMD in that you don’t
    need all the clutter and boilerplate needed by AMD to define a module. A continuously
    improving trait in favor of CJS modules is immediate access to any package in
    the npm registry out of the box. In 2013, the npm registry grew by an order of
    magnitude (or 10x), and at the time of this writing, it boasts well more than
    100,000 registered packages.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在[5.2.3节](#ch05lev2sec8)中描述的优点之外，如没有隐式全局变量，CJS还提供了对AMD的简洁替代方案，因为你不需要AMD定义模块所需的所有杂乱和样板代码。CJS模块的一个持续改进的特性是能够立即访问npm注册表中的任何包。到2013年，npm注册表增长了10倍，在撰写本文时，它拥有超过10万个注册包。
- en: 'Browserify will recursively analyze all the `require()` calls in your app to
    build a bundle that you can serve up to the browser in a single `<script>` tag.
    As you might expect, Grunt has numerous plugins eager to compile your CJS modules
    into a Browserify bundle, and one such plugin is `grunt-browserify`. Configuring
    it is more akin to what you saw in [chapter 2](kindle_split_013.html#ch02), where
    you provided a filename declaring the entry point of your CJS module and an output
    filename as well:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Browserify会递归地分析你应用中的所有`require()`调用，以构建一个你可以通过单个`<script>`标签提供给浏览器的捆绑包。正如你所期望的，Grunt有许多插件急于将你的CJS模块编译成Browserify捆绑包，其中之一就是`grunt-browserify`。配置它类似于你在[第二章](kindle_split_013.html#ch02)中看到的内容，其中你提供了一个文件名来声明你的CJS模块的入口点，以及一个输出文件名：
- en: '[PRE26]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: I think most of the mental load in taking this approach won’t come from Browserify,
    but rather learning about `require` and modularity in CJS modules. Luckily, you
    already used CJS modules when configuring Grunt tasks throughout [part 1](kindle_split_011.html#part01),
    and that should give you insight into CJS, as well as a bunch of code samples
    to look at! A fully working example of how to compile CJS modules, using `grunt-browserify`,
    can be found at ch05/11_browserify-cjs in the accompanying code samples. Next
    up, we’ll look at how AngularJS deals with dependency resolution, as a third (and
    last) way to deal with dependency management.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为采用这种方法的大部分心理负担不会来自Browserify，而是学习`require`和CJS模块的模块化。幸运的是，你在配置Grunt任务时已经使用了CJS模块，这在[第一部分](kindle_split_011.html#part01)中已经提到，这应该能给你关于CJS的见解，以及一些可以查看的代码示例！如何使用`grunt-browserify`编译CJS模块的完整示例可以在配套代码示例的ch05/11_browserify-cjs中找到。接下来，我们将探讨AngularJS如何处理依赖解析，作为处理依赖管理的第三（也是最后）种方法。
- en: 5.3.4\. The Angular way
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.4. Angular的方式
- en: Angular is an innovative client-side Model-View-Controller (MVC) framework developed
    at Google. In [chapter 7](kindle_split_019.html#ch07) you’ll use another popular
    JavaScript MVC framework called Backbone. But Angular’s dependency resolver deserved
    a mention in this section.^([[6](#ch05fn06)])
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Angular是Google开发的一个创新的客户端Model-View-Controller (MVC)框架。在[第七章](kindle_split_019.html#ch07)中，你将使用另一个流行的JavaScript
    MVC框架Backbone。但Angular的依赖解析器在这个部分也值得提及。[6](#ch05fn06)
- en: ⁶ Angular’s documentation has an extensive guide explaining how DI works in
    Angular at [http://bevacqua.io/bf/angular-di](http://bevacqua.io/bf/angular-di).
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶ Angular的文档提供了一个详尽的指南，解释了在Angular中DI是如何工作的，可以在[http://bevacqua.io/bf/angular-di](http://bevacqua.io/bf/angular-di)找到。
- en: Leveraging Dependency Injection in Angular
  id: totrans-205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 利用Angular中的依赖注入
- en: 'Angular has a fairly elaborate dependency injection solution in place, so we
    won’t get into the details. Luckily for us, it’s abstracted well enough that it’s
    easy to use. I’ve personally used many different DI frameworks, and Angular makes
    it feel natural: you don’t even realize you’re doing DI, similarly to Java and
    RequireJS. Let’s walk together through a contrived example, which can be found
    at ch05/12_angularjs-dependencies in the samples. It’s convenient to keep the
    module declaration in its own file, something like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 已经有一个相当复杂的依赖注入解决方案，所以我们不会深入细节。幸运的是，它足够抽象，使用起来很方便。我个人使用过许多不同的 DI 框架，Angular
    让它感觉自然：你甚至没有意识到你正在进行 DI，就像 Java 和 RequireJS 一样。让我们通过一个虚构的例子一起走过，这个例子可以在 samples
    中的 ch05/12_angularjs-dependencies 找到。将模块声明保存在自己的文件中很方便，就像这样：
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then each of the different pieces of a module, such as services or controllers,
    are registered as extensions to that module, which you previously declared. Note
    that you’re passing an empty array to the `angular.module` function so your module
    doesn’t depend on any other modules:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，模块的各个不同部分，如服务或控制器，都被注册为之前声明的模块的扩展。请注意，你正在传递一个空数组给 `angular.module` 函数，这样你的模块就不依赖于任何其他模块：
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Registering controllers is also similar; in the following example you’ll use
    the `textService` service you created. This works in a similar way to RequireJS,
    because you need to use the name you gave to the service:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注册控制器的方式也类似；在下面的例子中，你将使用你创建的 `textService` 服务。这与 RequireJS 的工作方式类似，因为你需要使用你为服务指定的名称：
- en: '[PRE29]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Next up, let’s compare Angular to RJS in a nutshell.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们简要比较一下 Angular 和 RJS。
- en: Comparing Angular and RequireJS
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 比较 Angular 和 RequireJS
- en: Angular is different from RequireJS in that, rather than acting as a module
    loader, Angular worries about the dependency graph. You need to add a script tag
    for each file you’re using, unlike with AMD, which dealt with that for you.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 与 RequireJS 不同之处在于，它不是作为一个模块加载器来工作，而是关注依赖图。你需要为每个使用的文件添加一个 script 标签，这与
    AMD 不同，AMD 会为你处理这个问题。
- en: 'In the case of Angular you see an interesting behavior where script order isn’t
    all that relevant. As long as you have Angular on top and then the script that
    declares your module, the rest of the scripts can be in whatever order you want,
    and Angular will deal with that for you. You need code such as the following on
    top of your script tag list, which is why the module declaration needs its own
    file:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 的情况下，你会看到一个有趣的行为，即脚本顺序并不那么重要。只要你有 Angular 在顶部，然后是声明你的模块的脚本，其余的脚本可以按你想要的任何顺序排列，Angular
    会为你处理这些。你需要在脚本标签列表的顶部添加以下代码，这就是为什么模块声明需要自己的文件：
- en: '[PRE30]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The rest of the scripts, which are part of the `app` module (or whatever name
    you give it), can be loaded in any order, as long as they come after the module
    declaration:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的脚本，作为 `app` 模块（或你给它起的任何名字）的一部分，可以按任何顺序加载，只要它们在模块声明之后：
- en: '[PRE31]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Let’s draw a few quick conclusions on the current state of module systems in
    JavaScript.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速总结一下当前 JavaScript 模块系统的状态。
- en: Bundling Angular components using Grunt
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 Grunt 打包 Angular 组件
- en: 'As a side note, when preparing a build, you can explicitly add Angular and
    the module to the top, and then glob for the rest of the pieces of the puzzle.
    Here’s how you might configure the `files` array passed to a bundling task, such
    as the ones in the `grunt-contrib-concat` or `grunt-contrib-uglify` packages:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，在准备构建时，你可以明确地将 Angular 和模块放在顶部，然后为拼图的其余部分进行全局搜索。以下是如何配置传递给打包任务的 `files`
    数组的示例，例如 `grunt-contrib-concat` 或 `grunt-contrib-uglify` 包中的任务：
- en: '[PRE32]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You might not want to commit to the full-featured framework that is AngularJS,
    and you’re not about to include it in your project for its dependency resolution
    capabilities! As a closing thought, I’d like to add that there’s no right choice,
    which is why I presented these three methods:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不想完全依赖功能丰富的 AngularJS 框架，你也不打算将其包含到你的项目中以利用其依赖解析能力！作为一个结束语，我想补充说，没有绝对正确的选择，这就是为什么我介绍了这三种方法：
- en: RequireJS modules, using AMD definitions
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RequireJS 模块，使用 AMD 定义
- en: CommonJS modules, and then compiling them with Browserify
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CommonJS 模块，然后使用 Browserify 编译它们
- en: AngularJS, where modules will resolve the dependency graph for you
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AngularJS，其中模块会为你解析依赖图
- en: If your project uses Angular, that’s good enough that you wouldn’t need either
    AMD or CJS, because Angular provides a sufficiently modular structure. If you’re
    not using Angular, then I’d probably go for CommonJS, mostly because of the abundance
    of npm packages you can potentially take advantage of.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的项目使用 Angular，那么它已经足够好，你不需要 AMD 或 CJS，因为 Angular 提供了一个足够模块化的结构。如果你不使用 Angular，那么我可能会选择
    CommonJS，主要是因为你可以利用大量的 npm 包。
- en: The next section sheds light on other package managers, and as you did for npm,
    teaches you how to leverage them in your client-side projects.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将介绍其他包管理器，并像对 npm 所做的那样，教你如何在客户端项目中利用它们。
- en: 5.4\. Understanding package management
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4\. 理解包管理
- en: One of the drawbacks of using package managers is that they tend to organize
    dependencies using a certain structure. For example, npm uses `node_modules` to
    store installed packages, and Bower uses `bower_components`. One of the great
    advantages to Build First is that’s not a problem, because you can add references
    to those files in your builds and that’s that! The original location of the packages
    won’t matter at all. That’s a huge reason to use a Build First approach.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用包管理器的一个缺点是它们倾向于使用某种特定的结构来组织依赖项。例如，npm 使用 `node_modules` 来存储已安装的包，而 Bower 使用
    `bower_components`。Build First 的一个巨大优势是这根本不是问题，因为你可以将这些文件的引用添加到你的构建中，就这样！包的原始位置根本无关紧要。这就是使用
    Build First 方法的一个巨大原因。
- en: 'I want to discuss two popular front-end package managers in this section: Bower
    and Component. We’ll consider the tradeoffs in each and compare them to npm.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我想在本节讨论两个流行的前端包管理器：Bower 和 Component。我们将考虑每个的权衡，并将它们与 npm 进行比较。
- en: 5.4.1\. Introducing Bower
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.1\. 介绍 Bower
- en: 'Although npm is an extraordinary package manager, it isn’t fit for all package
    management needs: virtually all of the packages published to it are CJS modules,
    because it’s ingrained into the Node ecosystem. Although I chose to use Browserify
    so that I could write modular front-end code under the CJS format, this might
    not be the choice for every project you work on.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 npm 是一个非凡的包管理器，但它并不适合所有的包管理需求：几乎发布到它的所有包都是 CJS 模块，因为它深深植根于 Node 生态系统。尽管我选择使用
    Browserify 以便能够在 CJS 格式下编写模块化的前端代码，但这可能不是你参与的所有项目的选择。
- en: 'Bower is a package manager for the web, created at Twitter, and it’s *content
    agnostic*, meaning it doesn’t matter whether authors pack up images, style sheets,
    or JavaScript code. By now you should be accustomed to the way npm tracks packages
    and version numbers, using the `package.json` manifest. Bower has a `bower.json`
    manifest that’s similar to `package.json`. Bower is installed through `npm`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Bower 是一个由 Twitter 创建的用于网页的包管理器，它是 *内容无关的*，这意味着作者打包图片、样式表或 JavaScript 代码都无关紧要。到现在你应该已经习惯了
    npm 使用 `package.json` 清单跟踪包和版本号的方式。Bower 有一个 `bower.json` 清单，类似于 `package.json`。Bower
    通过 `npm` 安装：
- en: '[PRE33]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Installing packages with `bower` is fast and straightforward; all you need to
    do is specify the name or a git remote endpoint. The first thing you’ll need to
    do on a given project is run `bower init`. Bower will ask you a few questions
    (you can press Enter because the defaults are fine), and then it’ll create a `bower.json`
    manifest for you, as in [figure 5.5](#ch05fig05).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `bower` 安装包既快速又直接；你只需要指定名称或 git 远程端点。在特定项目中，你首先需要运行 `bower init`。Bower 会问你几个问题（你可以按
    Enter 键，因为默认值就很好），然后它会为你创建一个 `bower.json` 清单文件，如图 5.5 所示。
- en: Figure 5.5\. Using `bower init` to create a `bower.json` manifest file
  id: totrans-237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.5\. 使用 `bower init` 创建 `bower.json` 清单文件
- en: '![](05fig05_alt.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig05_alt.jpg)'
- en: Once that’s out of the way, installing packages is a breeze. The following example
    installs Lo-Dash, a utility library similar to Underscore, but more actively maintained.
    It will download the scripts and place them in a `bower_components` directory,
    as shown in [figure 5.6](#ch05fig06).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些准备工作完成，安装包就变得轻而易举。以下示例展示了如何安装 Lo-Dash，一个类似于 Underscore 的实用库，但维护更为积极。它将下载脚本并将它们放置在
    `bower_components` 目录中，如图 5.6 所示。
- en: Figure 5.6\. Using bower `install --save` to fetch a dependency and add it to
    the manifest
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.6\. 使用 bower `install --save` 获取依赖项并将其添加到清单中
- en: '![](05fig06_alt.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig06_alt.jpg)'
- en: '[PRE34]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: That’s it! You should have scripts in the `bower_components/lodash` directory.
    Including them in your builds is a matter of adding the file to your distribution
    configuration. As usual, this example can be found in the accompanying source
    code; look for `ch05/13_bower-packages`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些！你应该在`bower_components/lodash`目录中有脚本。将它们包含在你的构建配置中是一个将文件添加到你的分发配置的问题。通常，这个示例可以在配套的源代码中找到；寻找`ch05/13_bower-packages`。
- en: Bower is arguably the second-largest package manager, with close to 20,000 packages
    in its registry, and behind npm, which has more than 100,000\. Component, another
    package management solution, lags behind with nearly 3,000 packages under its
    belt, but it offers a more modular alternative and a more comprehensive solution
    to client-side package management. Let’s take a look!
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Bower可以说是第二大包管理器，其注册表中拥有近20,000个包，仅次于拥有超过10万个包的npm。Component作为另一个包管理解决方案，其拥有的包数量约为3,000个，但它提供了一个更模块化的替代方案，以及更全面的客户端包管理解决方案。让我们来看看吧！
- en: 5.4.2\. Big libraries, small components
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.2. 大型库，小型组件
- en: Huge libraries such as jQuery do everything you need, as well as things you
    don’t need. For instance, you might not need the animations or the AJAX that come
    with it. In this sense, struggling to keep pieces out of jQuery using custom builds
    is an uphill battle; automating the process isn’t trivial, and you’re doing more
    to get less, which I guess is what the “write less, do more” slogan refers to.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 像jQuery这样的大型库可以做你需要的一切，以及你不需要的东西。例如，你可能不需要它附带的动画或AJAX。从这个意义上说，试图通过自定义构建将部分内容从jQuery中排除出去是一场艰难的战斗；自动化这个过程并不简单，你得到的比付出的多，我想这就是“写得更少，做得更多”这个口号所指的。
- en: Component is a tool that’s all about small components that do one thing only
    but do it well. Rather than using a big library for all your needs, TJ Holowaychuk,^([[7](#ch05fn07)])
    prolific open source author, advocates using multiple small blocks to build exactly
    what you need in a modular way and without any added bloat.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Component是一个专注于小型组件的工具，这些组件只做一件事情，但做得很好。TJ Holowaychuk，一位多产的开源作者，而不是使用一个大型的库来满足所有需求，他提倡使用多个小块来以模块化的方式构建你需要的精确内容，而不添加任何额外的冗余。
- en: ⁷ Read an introduction to Component on Holowaychuk’s blog at [http://bevacqua.io/bf/component](http://bevacqua.io/bf/component).
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷ 在Holowaychuk的博客上阅读Component的介绍：[http://bevacqua.io/bf/component](http://bevacqua.io/bf/component)。
- en: 'The first thing you’ll need to do, as usual, is install the CLI tool from `npm`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的第一件事，就像往常一样，是从`npm`安装CLI工具：
- en: '[PRE35]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you’re consuming components, you can get away with a manifest with the bare
    minimum valid JSON. Let’s create that, too:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用组件，你可以用一个包含最基本有效JSON的清单来应付。让我们也创建一个吧：
- en: '[PRE36]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Installing components such as Lo-Dash works similarly to what you did previously
    with Bower. The main difference is that rather than using a registry whose sole
    purpose is tracking packages, like Bower does, Component uses GitHub as its default
    registry. Specifying the username and repository, as shown in the following command,
    is enough to fetch a component:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 安装像Lo-Dash这样的组件的工作方式与之前使用Bower的方式相似。主要区别在于，与Bower使用一个仅用于跟踪包的注册表不同，Component使用GitHub作为其默认注册表。指定用户名和存储库，如以下命令所示，就足以获取一个组件：
- en: '[PRE37]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In contrast with what other libraries do, Component will always update the manifest,
    adding the packages you install. You must also add the entry point to the scripts
    field in the component manifest.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他库的做法相比，Component总是会更新清单，添加你安装的包。你还需要将入口点添加到组件清单的脚本字段中。
- en: '[PRE38]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Another difference you can find in Component is that it has an additional build
    step, which will bundle any components you’ve installed into a single `build.js`
    concatenated file. Given that components use CommonJS-style `require` calls, the
    necessary `require` function will also be provided.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在Component中，你还可以发现另一个不同之处，那就是它有一个额外的构建步骤，这个步骤会将你安装的所有组件打包成一个单一的`build.js`连接文件。鉴于组件使用CommonJS风格的`require`调用，必要的`require`函数也将被提供。
- en: '[PRE39]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: I encourage you to look at a pair of accompanying samples, which might help
    you learn how to use Component. The first one, ch05/14_adopting-component, is
    a fully working example of what has been described here.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你查看一些配套的示例，这可能会帮助你学习如何使用Component。第一个示例，ch05/14_adopting-component，是这里所描述内容的完整工作示例。
- en: The second, ch05/15_automate-component-build, explains how to automate the build
    step with Grunt, using the `grunt-component-build` package. Such a build step
    is particularly useful if your code is also treated as components.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个，ch05/15_automate-component-build，解释了如何使用`grunt-component-build`包通过Grunt自动化构建步骤。这样的构建步骤如果您的代码也被视为组件，则特别有用。
- en: To wrap things up, I’ll give you an overview of each of the systems we’ve discussed,
    which might help you decide on a package manager or module system.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我将为您概述我们讨论的每个系统，这可能会帮助您决定使用哪个包管理器或模块系统。
- en: 5.4.3\. Choosing the right module system
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.3. 选择正确的模块系统
- en: Component has the right idea behind it—modular pieces of code that do one thing
    well—but it has subtle drawbacks, as well. For instance, it has an unnecessary
    build step in `component install`. Executing `component install` should build
    everything you need for the components to work, the way `npm` does. It’s also
    kind of mystical to configure, and the documentation is hard to find. Poor naming
    is a huge drawback in this regard, as you can’t do a web search for Component
    and not get unrelated results, making it hard to find the documentation you want.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Component背后的理念是正确的——模块化的代码片段，能够很好地完成一项任务——但它也有一些细微的缺点。例如，它在`component install`中有一个不必要的构建步骤。执行`component
    install`应该构建组件运行所需的所有内容，就像`npm`做的那样。它也相当神秘，配置起来有点困难，文档也难以找到。糟糕的命名是这方面的巨大缺点，因为您无法通过在网络上搜索Component而得到不相关的结果，这使得找到您想要的文档变得困难。
- en: Bower is fine if you don’t buy into the CJS concept, and it’s certainly better
    than downloading code and placing it into directories by yourself and dealing
    with version upgrades on your own. Bower is fine for fetching packages, but it
    does little to help you with modularity, and that’s where it falls short.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不认同CJS概念，Bower是个不错的选择，而且它当然比您自己下载代码、将其放入目录并自行处理版本升级要好。Bower在获取包方面做得不错，但它对模块化的帮助甚微，这也是它的不足之处。
- en: As far as Browserify goes, at the moment it’s the best option that’s available
    to us, if you’re willing to concede that CJS is the simplest module format available
    today. The lack of a package manager embedded into Browserify is a good thing,
    because it doesn’t matter which source you pick for modules you consume. They
    can come from npm, Bower, GitHub, or somewhere else.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 就Browserify而言，目前如果您愿意承认CJS是今天最简单的模块格式，那么它是我们目前最好的选择。Browserify没有内置包管理器是一个好事，因为它并不重要您选择哪个源来获取您消费的模块。它们可以来自npm、Bower、GitHub或其他地方。
- en: Browserify provides mechanisms for both bringing vendor code into the CJS format
    and exporting a CJS formatted application into a single file. As we discussed
    in 5.3.3, Browserify can produce source maps that help debug during development,
    and using it gives you access to any CJS modules originally written for Node development.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Browserify提供了将供应商代码引入CJS格式以及将CJS格式的应用程序导出为单个文件的机制。正如我们在5.3.3节中讨论的那样，Browserify可以生成源映射，有助于开发过程中的调试，并且使用它可以使你访问最初为Node开发编写的任何CJS模块。
- en: Last, AMD modules might be a good fit for using Bower, because they don’t interfere
    with each other. The benefit here is that you don’t have to learn the CJS approach,
    although I would argue that there isn’t all that much to learn about it.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，AMD模块可能非常适合与Bower一起使用，因为它们不会相互干扰。这里的优点是您不必学习CJS方法，尽管我会争辩说这并没有太多需要学习的。
- en: Before discussing the changes coming to the JavaScript language in ECMAScript
    6, there’s one more topic we need to tend to. That’s the topic of circular dependencies,
    such as a chicken depending on an egg that depends on a chicken.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论即将到来的ECMAScript 6中JavaScript语言的变化之前，我们还有一个话题需要处理。那就是循环依赖的话题，比如鸡依赖于依赖于鸡的蛋。
- en: 5.4.4\. Learning about circular dependencies
  id: totrans-269
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.4. 了解循环依赖
- en: 'Circular dependencies, explained previously as a chicken depending on an egg
    that depends on a chicken, are a tough nut to crack, and they’re straight up unsupported
    by many module systems. In this brief section I aim to dispel any issues you have
    by answering the following questions:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 循环依赖，如之前解释的鸡依赖于依赖于鸡的蛋，是一个难以解决的问题，并且许多模块系统根本不支持它们。在本节中，我旨在通过回答以下问题来解决您可能遇到的问题：
- en: Is there a good reason to use circular dependencies?
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用循环依赖有合理的理由吗？
- en: What patterns can you use to avoid them?
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用哪些模式来避免它们？
- en: How do the solutions we’ve talked about handle circular dependencies?
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论的解决方案是如何处理循环依赖的？
- en: Components that depend on each other represent a code smell, meaning there might
    be a deeper problem in your code. The best approach to circular dependencies is
    to avoid them altogether. You can use a few patterns to avoid them. If two components
    are talking to each other, it might be a sign that they need to communicate through
    a service they both consume, for example. That way, it’ll be easier to reason
    about (and write code for) the affected components. In [chapter 7](kindle_split_019.html#ch07),
    you’ll look at the ways you can avoid these chicken-and-egg type of situations
    when using AngularJS in client-side applications.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 互相依赖的组件代表了一种代码异味，这意味着你的代码中可能存在更深层次的问题。解决循环依赖的最佳方法是完全避免它们。你可以使用一些模式来避免它们。如果两个组件正在互相通信，这可能是一个迹象，表明它们需要通过它们都消费的服务进行通信，例如。这样，将更容易对受影响的组件进行推理（并为它们编写代码）。在[第
    7 章](kindle_split_019.html#ch07)中，你将了解在客户端应用程序中使用 AngularJS 避免这些鸡生蛋、蛋生鸡类型情况的方法。
- en: Using a service as a middleman is one of many ways to solve circular dependencies.
    You might have your `chicken` module depend on `egg` and talk to it directly,
    but if `egg` wants to talk to `chicken`, then it should use the callbacks `chicken`
    gives to it. An even simpler approach is to have instances of your modules depend
    on each other. Have a `chicken` and an `egg` depending on each other, rather than
    the entire families, and the problem is circumvented.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使用服务作为中间人是解决循环依赖的多种方法之一。你可能让 `chicken` 模块直接依赖于 `egg` 并与之通信，但如果 `egg` 想要与 `chicken`
    通信，那么它应该使用 `chicken` 给它的回调。一个更简单的方法是让模块实例互相依赖。让 `chicken` 和 `egg` 互相依赖，而不是整个家族，这样就可以绕过这个问题。
- en: You also need to take into account that different systems deal with circular
    dependencies differently. If you try to resolve a circular dependency in Angular,
    it will throw an error. Angular doesn’t provide any mechanisms to deal with circular
    dependencies at the module level. You can get around this by using their dependency
    resolver. Once an `egg` module that depends on the `chicken` module is resolved,
    then the `chicken` module can fetch the `egg` module when it’s used.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要考虑到不同的系统处理循环依赖的方式不同。如果你尝试在 Angular 中解决循环依赖，它将抛出一个错误。Angular 并没有提供任何机制来处理模块级别的循环依赖。你可以通过使用他们的依赖解析器来解决这个问题。一旦一个依赖于
    `chicken` 模块的 `egg` 模块被解析，那么当 `chicken` 模块被使用时，它可以获取 `egg` 模块。
- en: In the case of AMD modules, if you define a circular dependency such that `chicken`
    needs `egg` and `egg` needs `chicken`, then when `egg`’s module function is called,
    it will get an `undefined` value for `chicken`. `egg` can fetch `chicken` later,
    after modules have been defined by using the `require` method.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AMD 模块的情况下，如果你定义了一个循环依赖，使得 `chicken` 需要 `egg` 而 `egg` 需要 `chicken`，那么当 `egg`
    的模块函数被调用时，它将为 `chicken` 获取一个 `undefined` 值。`egg` 可以在模块定义后使用 `require` 方法来获取 `chicken`。
- en: CommonJS allows circular dependencies by pausing module resolution whenever
    a `require` call is made. If a `chicken` module requires an `egg` module, then
    interpretation of the `chicken` module is halted. When the `egg` module requires
    `chicken`, it will get the partial representation of the `chicken` module, until
    the `require` call is made. Then the `chicken` module will finish being interpreted.
    The code sample labeled ch05/16_circular-dependencies illustrates this point.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: CommonJS 允许通过在每次 `require` 调用暂停模块解析来解决循环依赖。如果一个 `chicken` 模块需要 `egg` 模块，那么 `chicken`
    模块的解析将被暂停。当 `egg` 模块需要 `chicken` 时，它将获得 `chicken` 模块的局部表示，直到 `require` 调用被做出。然后
    `chicken` 模块将完成解析。代码示例 ch05/16_circular-dependencies 说明了这一点。
- en: The bottom line is that you should avoid circular dependencies like the plague.
    Circular dependencies introduce unnecessary complexity into your programs, module
    systems don’t have a standard way of dealing with them, and they can always be
    avoided by writing code in a more organized way.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，你应该像躲避瘟疫一样避免循环依赖。循环依赖将不必要的复杂性引入到你的程序中，模块系统没有标准的方式来处理它们，而且它们总是可以通过更有序地编写代码来避免。
- en: To wrap up this chapter, we’ll go through a few changes coming to the language
    in ECMAScript 6, and what they bring to the table when it comes to modular component
    design.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结本章内容，我们将探讨 ECMAScript 6 中即将到来的几个变化，以及它们在模块化组件设计方面的贡献。
- en: '5.5\. Harmony: a glimpse of ECMAScript 6'
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5. 和谐：对 ECMAScript 6 的一瞥
- en: As you might know, ECMAScript (ES) is the spec that defines the behavior of
    JavaScript code. ES6, also known as Harmony, is the (long-awaited) upcoming version
    of the spec. Once ES6 lands, you’ll benefit from hundreds of small and large improvements
    to the language, part of which I’ll cover in this section. At the time of this
    writing, parts of Harmony are in Chrome Canary, the edge version of Google Chrome,
    and also in the Firefox Nightly build. In Node, you can use the `--harmony` flag
    when invoking the `node` process to enable ES6 language features.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，ECMAScript (ES) 是定义 JavaScript 代码行为的规范。ES6，也称为 Harmony，是该规范的（长期期待的）新版本。一旦
    ES6 发布，你将受益于语言数百项大小改进，其中一部分我将在本节中介绍。在撰写本文时，Harmony 的一部分在 Chrome Canary（Google
    Chrome 的边缘版本）和 Firefox Nightly 构建中。在 Node 中，你可以通过调用 `node` 进程时使用 `--harmony` 标志来启用
    ES6 语言功能。
- en: Please note that ES6 features are highly experimental and subject to change;
    the spec is constantly in flux. Take what’s discussed in this section with a pinch
    of salt. I’ll introduce you to concepts and syntax in the upcoming language release;
    features proposed as part of ES6 at this point are unlikely to change, but specific
    syntax is more likely to be tweaked.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，ES6 功能高度实验性，并可能发生变化；规范始终处于变动之中。对本节中讨论的内容持保留态度。我将在即将发布的新语言版本中介绍概念和语法；目前作为
    ES6 部分提出的功能不太可能改变，但具体的语法更有可能被调整。
- en: Google has made an interesting effort in popularizing ES6 learning through their
    Traceur project, which compiles ES6 down to ES3 (a generally available spec version),
    allowing you to write code in ES6 and then execute the resulting ES3\. Although
    Traceur doesn’t support every feature in Harmony, it’s one of the most featured
    compilers available.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Google 通过他们的 Traceur 项目在推广 ES6 学习方面做出了有趣的努力，该项目将 ES6 编译成 ES3（一个普遍可用的规范版本），允许你用
    ES6 编写代码，然后执行生成的 ES3。尽管 Traceur 不支持 Harmony 中的所有功能，但它是最功能丰富的编译器之一。
- en: 5.5.1\. Traceur as a Grunt task
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.1\. Traceur 作为 Grunt 任务
- en: 'Traceur is available as a Grunt task, thanks to a package called `grunt-traceur`.
    You can use the following configuration to set it up. It will compile each file
    individually and place the results in a `build` directory:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一个名为 `grunt-traceur` 的包，Traceur 可作为 Grunt 任务使用。你可以使用以下配置来设置它。它将单独编译每个文件，并将结果放置在
    `build` 目录中：
- en: '[PRE40]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: With the help of this task, you can compile a few of the ES6 Harmony examples
    I’ll show you along the way. Naturally, the accompanying code samples have a working
    example of this Grunt task, as well as a few different snippets of what you can
    do with Harmony, so be sure to check out `ch05/17_harmony-traceur` and skim through
    those samples. [Chapters 6](kindle_split_018.html#ch06) and [7](kindle_split_019.html#ch07)
    also contain more pieces of ES6 code, to give you a better picture of what features
    are coming to the language.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个任务，你可以编译我沿途展示的一些 ES6 Harmony 示例。自然地，相关的代码示例包含了这个 Grunt 任务的运行示例，以及一些关于你可以使用
    Harmony 做什么的片段，所以请务必查看 `ch05/17_harmony-traceur` 并浏览这些示例。[第 6 章](kindle_split_018.html#ch06)
    和 [第 7 章](kindle_split_019.html#ch07) 也包含更多 ES6 代码片段，以更好地了解即将到来的语言功能。
- en: Now that you know of a few ways to turn ES6 features on, let’s dive into Harmony’s
    way of doing modules.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了几种开启 ES6 功能的方法，让我们深入了解 Harmony 的模块实现方式。
- en: 5.5.2\. Modules in Harmony
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.2\. Harmony 中的模块
- en: Throughout this chapter, you’ve navigated different module systems and learned
    about modular design patterns. Input from both AMD and CJS have influenced the
    design decisions behind Harmony modules, in a way that aims to please proponents
    of either system. These modules have their own scope; they export public API members
    using the `export` keyword, which can later be imported individually using the
    `import` keyword. An optional explicit `module` declaration allows for file concatenation.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已导航不同的模块系统，并学习了模块化设计模式。AMD 和 CJS 的输入影响了 Harmony 模块背后的设计决策，旨在取悦任何一方的支持者。这些模块有自己的作用域；它们使用
    `export` 关键字导出公共 API 成员，这些成员可以稍后使用 `import` 关键字单独导入。可选的显式 `module` 声明允许文件连接。
- en: What follows is an example of how these mechanics work. I’m using the latest
    syntax available^([[8](#ch05fn08)]) at the time of this writing. The syntax comes
    from a meeting held in March 2013 by TC39, the technical committee in charge of
    moving the language forward. If I were you, I wouldn’t focus too much on the specifics,
    only the general idea.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何这些机制工作的一个示例。我在写作时使用了当时可用的最新语法^([[8](#ch05fn08)])。这种语法来自2013年3月由负责推动语言发展的技术委员会TC39举行的一次会议。如果我是你，我不会过多关注具体细节，只需把握总体思路。
- en: ⁸ Find the ES6 article at [http://bevacqua.io/bf/es6-modules](http://bevacqua.io/bf/es6-modules).
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁸ 在[http://bevacqua.io/bf/es6-modules](http://bevacqua.io/bf/es6-modules)找到ES6文章。
- en: 'To begin with, you’ll define a basic module with a couple of exported methods:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将定义一个包含几个导出方法的简单模块：
- en: '[PRE41]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Consuming these methods is a matter of referencing them in an `import` statement,
    as shown in the following code snippet. These statements can choose to import
    one, many, or all the exports found in a module. The following statement imports
    the `circumference` export into the local module:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 消费这些方法只需在`import`语句中引用它们，如下面的代码片段所示。这些语句可以选择导入模块中找到的一个、多个或所有导出。以下语句将`circumference`导出导入到本地模块中：
- en: '[PRE42]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If you want to import multiple exports, you comma-separate them:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要导入多个导出，可以用逗号分隔它们：
- en: '[PRE43]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Importing every export from a module in an object, rather than directly on
    the local context, can be done using the `as` syntax:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`as`语法，你可以将模块中的每个导出导入到一个对象中，而不是直接导入到本地上下文中：
- en: '[PRE44]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If you want to define modules explicitly, rather than having them be defined
    implicitly, for release scenarios where you’re going to bundle your scripts in
    a single file, there’s a literal way in which you can define a module:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要显式地定义模块，而不是让它们隐式地定义，对于你打算将脚本打包到一个文件中的发布场景，你可以用一种字面量方式来定义一个模块：
- en: '[PRE45]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If you’re interested in the module system in ES6, you should read an article^([[9](#ch05fn09)])
    that encompasses what you’ve learned so far about ES6, and sheds light on the
    module system’s extensibility. Always keep in mind that the syntax is subject
    to change. Before heading to [chapter 6](kindle_split_018.html#ch06), I have one
    last little ES6 feature to touch on with regard to modularity. That’s the `let`
    keyword.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对ES6中的模块系统感兴趣，你应该阅读一篇文章^([[9](#ch05fn09)])，这篇文章涵盖了关于ES6你已经学到的内容，并阐明了模块系统的可扩展性。始终记住，语法可能会变化。在前往[第6章](kindle_split_018.html#ch06)之前，我还有一个关于模块性的小ES6特性要提及。那就是`let`关键字。
- en: ⁹ Find this ES6 article at [http://bevacqua.io/bf/es6-modules](http://bevacqua.io/bf/es6-modules).
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁹ 在[http://bevacqua.io/bf/es6-modules](http://bevacqua.io/bf/es6-modules)找到这篇文章。
- en: 5.5.3\. Let there be block scope
  id: totrans-306
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.3\. 块作用域的出现
- en: The ES6 `let` keyword is an alternative to `var` statements. You may remember
    that `var` is function scoped, as you analyzed in [section 5.1.3](#ch05lev2sec3).
    With `let`, you get block scoping instead, which is more akin to the scoping rules
    found in traditional languages. Hoisting plays an important role when it comes
    to variable declaration, and `let` is a great way to get around the limitations
    of function scoping in certain cases.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: ES6的`let`关键字是`var`语句的替代品。你可能记得`var`是函数作用域的，正如你在[5.1.3节](#ch05lev2sec3)中分析的。使用`let`，你得到的是块作用域，这更类似于传统语言中的作用域规则。在变量声明方面，提升（Hoisting）起着重要作用，而`let`是绕过函数作用域限制的绝佳方式。
- en: Consider, for instance, the scenario below, a typical situation where you conditionally
    want to declare a variable. Hoisting makes it awkward to declare the variable
    inside the `if`, because you know it’ll get hoisted to the top of the scope, and
    keeping it inside the `if` block might cause trouble if someday you decide to
    use the same variable name in the `else` block.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下场景，这是一个典型的你想要条件性地声明变量的情况。提升（Hoisting）使得在`if`语句内部声明变量变得尴尬，因为你知道它会被提升到作用域的顶部，如果将来你决定在`else`块中使用相同的变量名，这可能会引起麻烦。
- en: '[PRE46]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Using the `let` keyword you could get away with declaring it in the `if` block,
    not worrying about it leaking outside of that block, and without the need to split
    the variable declaration from its assignment:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`let`关键字，你可以在`if`块中声明它，不必担心它泄漏到该块之外，也不需要将变量声明与其赋值分开：
- en: '[PRE47]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The difference is subtle in this case, but getting away from having a long list
    of variables listed on the top of a function scope, which might only be used in
    one of the code paths, is a code smell in current JavaScript implementations using
    `var`. It’s a code smell that could easily be avoided by using the `let` keyword,
    keeping variables in the block scope they belong to.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，差异是微妙的，但避免在函数作用域顶部列出长列表的变量，这些变量可能只会在代码路径中的一个被使用，在当前使用`var`的JavaScript实现中是一个代码异味。这是一个可以通过使用`let`关键字来轻松避免的代码异味，将变量保持在它们所属的块作用域中。
- en: 5.6\. Summary
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6. 概述
- en: At long last, you’re done with scoping, module systems, and so on!
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 终于，你完成了作用域、模块系统等内容的学习！
- en: You learned that keeping code self-contained that has a clear purpose, as well
    as information hiding, can greatly improve your interface designs.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你了解到保持代码自包含且具有明确目的，以及信息隐藏，可以极大地提高你的界面设计。
- en: Scoping, `this`, and hoisting are much clearer now, which will help you design
    code that fits the JavaScript paradigm better, without even realizing it.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作用域、`this`和提升现在更加清晰，这将帮助你更好地设计符合JavaScript范式的代码，甚至没有意识到这一点。
- en: Using closures and the module pattern taught you how module systems work.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用闭包和模块模式教会了你模块系统是如何工作的。
- en: You compared how CommonJS, RequireJS, and Angular deal with module loading,
    and how they handle circular dependencies.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你比较了CommonJS、RequireJS和Angular如何处理模块加载，以及它们如何处理循环依赖。
- en: You learned about the importance of testability, which we’ll expand on in [chapter
    8](kindle_split_020.html#ch08), and how the Inversion of Control pattern can make
    your code more testable.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你了解到可测试性的重要性，我们将在第8章中进一步探讨，以及控制反转模式如何使你的代码更具可测试性。
- en: We discussed how to leverage npm packages in the browser thanks to Browserify,
    downloading dependencies with Bower, and the UNIX philosophy of writing modular
    code with Component.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了如何利用Browserify在浏览器中利用npm包，使用Bower下载依赖项，以及使用Component编写模块化代码的UNIX哲学。
- en: You saw what’s coming in ES6, such as the module system and the `let` keyword,
    and you learned how to play around with ES6 using the Traceur compiler.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你看到了ES6即将带来的内容，例如模块系统和`let`关键字，以及你学习了如何使用Traceur编译器玩转ES6。
- en: In [chapter 6](kindle_split_018.html#ch06) you’ll learn about asynchronous JavaScript
    development. You’ll learn your way around common pitfalls, and you’ll work through
    examples that will help you understand how to effectively debug these functions.
    You’ll look at various patterns for writing asynchronous functions, such as callbacks,
    events, Promises, and the upcoming generators API in Harmony.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6章[章节6](kindle_split_018.html#ch06)中，你将学习关于异步JavaScript开发的内容。你将了解常见的陷阱，并通过示例来帮助你理解如何有效地调试这些函数。你将查看编写异步函数的各种模式，如回调、事件、Promise和即将到来的Harmony生成器API。
- en: Chapter 6\. Understanding asynchronous flow control methods in JavaScript
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6章. 理解JavaScript中的异步流程控制方法
- en: '*This chapter covers*'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Understanding callback hell and how to avoid it
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解回调地狱以及如何避免它
- en: Making Promises and keeping them in JavaScript
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在JavaScript中创建Promise并保持它们
- en: Using asynchronous control flow
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用异步控制流
- en: Learning event-based programming
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习基于事件的编程
- en: Using Harmony (ECMAScript 6) generator functions
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Harmony（ECMAScript 6）生成器函数
- en: '[Chapter 5](kindle_split_017.html#ch05) taught the importance of building your
    components in a modular fashion, and you learned a great deal about scoping, hoisting,
    and closures, all of which are necessary to understand asynchronous JavaScript
    code effectively. Without a modest understanding of asynchronous development in
    JavaScript, it becomes harder to write quality code that’s easy to read, refactor,
    and maintain.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 第5章[章节5](kindle_split_017.html#ch05)讲述了以模块化方式构建组件的重要性，你学习了大量的关于作用域、提升和闭包的知识，这些都是有效理解异步JavaScript代码所必需的。如果没有对JavaScript异步开发的适度理解，编写易于阅读、重构和维护的高质量代码就会变得更加困难。
- en: One of the most frequently recurring issues for JavaScript development beginners
    is dealing with “callback hell,” where many functions are nested inside each other,
    making it hard to debug or even understand a piece of code. This chapter aims
    to demystify asynchronous JavaScript.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 对于JavaScript开发初学者来说，最经常遇到的问题之一是处理“回调地狱”，其中许多函数嵌套在彼此内部，使得调试或甚至理解一段代码变得困难。本章旨在揭开异步JavaScript的神秘面纱。
- en: '*Asynchronous execution* is when code isn’t executed immediately, but rather
    in the future; such code isn’t synchronous because it doesn’t run sequentially.
    Even though JavaScript is single-threaded, user-triggered events such as clicks,
    timeouts, or AJAX responses can still create new execution paths. This chapter
    will cover different ways you can handle asynchronous flow in a tolerable and
    painless way, by applying a consistent style to asynchronous code flows. Much
    like [chapter 5](kindle_split_017.html#ch05), this chapter has many practical
    code examples for you to follow!'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '*异步执行* 是指代码不是立即执行，而是在未来执行；这样的代码不是同步的，因为它不是顺序执行的。尽管 JavaScript 是单线程的，但用户触发的事件，如点击、超时或
    AJAX 响应，仍然可以创建新的执行路径。本章将介绍不同的方法，通过应用一致的风格来处理异步流程，以可接受且不痛苦的方式处理异步代码流。就像第 5 章（kindle_split_017.html#ch05）一样，本章有许多实用的代码示例供你参考！'
- en: 'To kick things off, we’ll look at one of the oldest patterns available: passing
    a callback as an argument so the caller of a function can determine what happens
    in the future when the callback is invoked. This pattern is referred to as continuation-passing
    style, and it’s the bread and butter of asynchronous callbacks.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，我们将查看一个最古老的模式之一：将回调作为参数传递，以便函数的调用者可以确定回调被调用时未来的行为。这种模式被称为延续传递风格，它是异步回调的核心。
- en: 6.1\. Using callbacks
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1\. 使用回调
- en: 'A prime example of using callbacks is found in the `addEventListener` API,
    which allows us to bind event listeners on DOM (Document Object Model) nodes.
    When those events are triggered, our callback function gets called. In the following
    trivial example, when we click anywhere in the document, a log statement will
    be printed to the console:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 使用回调的一个典型例子可以在 `addEventListener` API 中找到，它允许我们在 DOM（文档对象模型）节点上绑定事件监听器。当这些事件被触发时，我们的回调函数会被调用。在以下简单的示例中，当我们点击文档中的任何地方时，会在控制台打印一条日志语句：
- en: '[PRE48]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Click event handling isn’t always that trivial. Sometimes you end up looking
    at something that resembles the following listing.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 点击事件处理并不总是那么简单。有时你可能会看到以下类似的列表。
- en: Listing 6.1\. Callback soup using logic noodles
  id: totrans-338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.1\. 使用逻辑面条的回调汤
- en: '![](132fig01_alt.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![132fig01_alt.jpg](132fig01_alt.jpg)'
- en: What’s going on? My thoughts exactly. You’ve been dragged through callback hell,
    that friendly name that describes deeply nested and indented callbacks on top
    of more callbacks, which make it pretty difficult to follow the flow and understand
    what’s going on. If you can’t make sense of the code presented in [listing 6.1](#ch06ex01),
    that’s good. You shouldn’t have to. Let’s dig deeper into the subject.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？这正是我的想法。你已经经历了回调地狱，这是一个友好的名字，描述了在更多回调之上深度嵌套和缩进的回调，这使得跟踪流程和理解发生了什么变得相当困难。如果你无法理解
    [列表 6.1](#ch06ex01) 中展示的代码，那很好。你不需要这样做。让我们更深入地探讨这个主题。
- en: 6.1.1\. Avoiding callback hell
  id: totrans-341
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.1\. 避免回调地狱
- en: You should understand how a piece of code flows at a glance, even if it’s asynchronous.
    If you need to spend more than a few seconds to understand how it flows, then
    there’s probably something wrong with that piece of code. Each nested callback
    means more nested scopes, as observed in [chapter 5](kindle_split_017.html#ch05),
    and indentation one level deeper, which consumes a little more real estate in
    your display, making it harder to follow the code.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是异步的代码，你也应该能够一眼看出其流程，如果你需要花几秒钟以上才能理解其流程，那么这段代码可能存在问题。每个嵌套的回调意味着更多的嵌套作用域，正如在第
    5 章中观察到的，以及更深一级的缩进，这会在你的显示区域占用更多空间，使得代码更难跟踪。
- en: Callback hell doesn’t happen overnight, and you can prevent it from ever happening.
    Using an example (named ch06/01_callback-hell in the samples), let’s see how it
    might slowly creep through the cracks of your code base over time. Suppose you
    have to make an AJAX request to fetch data, and then show that to a human. You’ll
    use an imaginary http object to simplify the AJAX-foo. Let’s also assume you have
    a record variable holding a reference to a particular DOM element.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 回调地狱并非一夜之间发生，你可以防止它发生。使用一个示例（在示例中命名为 ch06/01_callback-hell），让我们看看它可能随着时间的推移慢慢渗透到你的代码库的裂缝中。假设你需要发起一个
    AJAX 请求来获取数据，然后将其展示给人类。为了简化 AJAX-foo，我们将使用一个假想的 http 对象。假设你有一个记录变量，它持有对特定 DOM
    元素的引用。
- en: '[PRE49]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: That’s still easy to follow! What if you need to update another component after
    the `GET` request succeeded? Consider the following listing. Let’s assume there’s
    a DOM element in the `status` variable.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然很容易理解！如果你需要在`GET`请求成功后更新另一个组件，该怎么办？考虑以下列表。假设有一个`status`变量中的DOM元素。
- en: Listing 6.2\. Callback creep
  id: totrans-346
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.2\. 回调蔓延
- en: '[PRE50]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Okay, that’s starting to get bad! Nested callbacks add complexity every time
    you add a nesting level into the piece of code, because now you have to keep track
    of the context of the existing function as well as the context of the deeper callback.
    Take into account that in a real application each of these methods would probably
    have more lines in them, making it even harder to keep all of that state in your
    memory.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这开始变得糟糕了！嵌套回调每次在代码中添加一个嵌套级别时都会增加复杂性，因为你现在必须跟踪现有函数的上下文以及更深回调的上下文。考虑到在真实的应用程序中，这些方法中的每一个可能都有更多的行，这使得在记忆中保持所有这些状态变得更加困难。
- en: How do you fight the callback creep? All that complexity can be avoided by reducing
    the callback nesting depth.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何对抗回调蔓延？通过减少回调嵌套深度，可以避免所有这些复杂性。
- en: 6.1.2\. Untangling the callback jumble
  id: totrans-350
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.2\. 解开回调混乱
- en: 'You have ways to untangle these innocent pieces of code. Here’s a list of things
    you should take into account and fix:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 你有方法来解开这些无辜的代码片段。以下是一个你应该考虑并修复的事项列表：
- en: '*Name anonymous functions,* to improve their readability, and give hints as
    to what they’re doing. Named anonymous callbacks provide two-fold value. Their
    names can be used to convey intent, and it also helps when tracking down exceptions,
    as the stack trace will show the function name, instead of showing up as “anonymous
    function.” A named function will be easier to identify and save you headaches
    when debugging.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*命名匿名函数*，以提高其可读性，并给出它们所做工作的提示。命名的匿名回调提供了双重价值。它们的名称可以用来传达意图，并且在跟踪异常时也很有帮助，因为堆栈跟踪将显示函数名称，而不是显示为“匿名函数”。命名的函数将更容易识别，并在调试时节省你很多麻烦。'
- en: '*Remove unnecessary callbacks,* such as the one after reporting the status
    in the example. If a callback is only executed at the end of the function, and
    not asynchronously, you can get rid of it. The code that used to be in the callback
    could come right after the function call.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*移除不必要的回调*，例如在示例中报告状态之后的那个。如果一个回调只在函数的末尾执行，而不是异步执行，你可以将其移除。原本在回调中的代码可以直接放在函数调用之后。'
- en: '*Be careful about mixing conditionals with flow control code.* Conditionals
    hinder your ability to follow a piece of code, because new possibilities are introduced,
    and you need to think of all the possible ways in which the code might be followed.
    Flow control presents a similar problem. It makes it harder to read through the
    code, because the next instruction isn’t always the following line. Anonymous
    callbacks containing conditionals make it particularly hard to follow the flow,
    and they should be avoided. The first example in [section 6.1](#ch06lev1sec1)
    is a good demonstration of how this mixture is a recipe for disaster. You can
    mitigate this problem by separating the conditionals from the flow control. Provide
    a reference to the function, instead of an anonymous callback, and you can keep
    the conditionals as they were.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*小心将条件语句与流程控制代码混合*。条件语句会阻碍你跟踪代码的能力，因为引入了新的可能性，你需要考虑代码可能遵循的所有可能方式。流程控制也会带来类似的问题。它使得阅读代码更困难，因为下一条指令不总是下一行。包含条件语句的匿名回调尤其难以跟踪流程，应该避免。[第
    6.1 节](#ch06lev1sec1)中的第一个示例很好地展示了这种混合是如何成为灾难的配方。你可以通过将条件语句与流程控制分离来减轻这个问题。提供函数的引用，而不是匿名回调，并可以保留条件语句的原样。'
- en: After making the changes suggested in the previous list, the code ends up like
    the following listing.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在对前一个列表中建议的更改进行更改后，代码最终会变成以下列表。
- en: Listing 6.3\. Cleaning up the jumble
  id: totrans-356
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.3\. 清理混乱
- en: '![](135fig01_alt.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![135fig01_alt.jpg](135fig01_alt.jpg)'
- en: That’s not that bad; what else?
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不是最糟糕的；还有其他什么？
- en: The `reportStatus` function now seems pointless; you could inline its contents,
    move them to the only call site, and reduce the mental overhead. Simple methods
    that aren’t going to be reused can be replaced with their contents, reducing cognitive
    load.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reportStatus`函数现在看起来毫无意义；你可以内联其内容，将其移动到唯一的调用位置，并减少心理负担。那些不会被重用的简单方法可以用其内容替换，从而减少认知负荷。'
- en: Sometimes it makes sense to do the opposite, too. Instead of declaring the click
    handler inline, you could pull it into a named function, making the `addEventListener`
    line shorter. This one is mostly a matter of preference, but it can help when
    lines of code get longer than the 80 character mark.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时候，做相反的事情也是有意义的。您不必在行内声明点击处理程序，而是可以将其拉入一个命名函数，使`addEventListener`行更短。这主要是一个个人偏好的问题，但当代码行超过80个字符时，它可能有所帮助。
- en: The next listing shows the resulting code after applying these changes. Although
    the code is functionally equivalent, it’s gotten much easier to read. Compare
    it with [listing 6.2](#ch06ex02) to get a clearer picture.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了应用这些更改后的结果代码。尽管代码在功能上等效，但阅读起来容易多了。与[列表6.2](#ch06ex02)进行比较，可以得到更清晰的画面。
- en: Listing 6.4\. Pulling functions
  id: totrans-362
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.4\. 提取函数
- en: '[PRE51]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: What you did was make your code read as it flows. The trick is to keep each
    function as small and focused as you can get away with, as covered in [chapter
    5](kindle_split_017.html#ch05). Then it’s a matter of giving the functions proper,
    descriptive names that clearly state the purpose of the method. Learning when
    to inline unnecessary callbacks, as you did with `report-Status`, is a matter
    of practice.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 您所做的是使代码的阅读流畅。技巧是尽可能保持每个函数尽可能小和专注，正如在第5章中所述。然后，就是给函数起适当、描述性的名字，清楚地说明方法的用途。学习何时内联不必要的回调，就像您在`report-Status`中所做的那样，是一个实践问题。
- en: 'In general, it won’t matter if the code itself becomes a bit longer, as long
    as its readability improves. Readability is the single most important aspect of
    the code you write, because that’s how you’ll spend most of your time: reading
    code. Let’s go over one more example before moving on.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，只要代码的可读性得到提高，代码本身变得稍微长一点并不会有什么影响。可读性是您编写的代码最重要的单一方面，因为您将花费大部分时间在阅读代码上。在继续之前，让我们再来看一个例子。
- en: 6.1.3\. Requests upon requests
  id: totrans-366
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.3\. 请求之上的请求
- en: In web applications, it’s not uncommon to have web requests that depend on other
    AJAX requests; the back end might not be suited to give you all the data you need
    in a single AJAX call. For example, you might need to access a list of your customer’s
    clients, but to do that you must first get the customer ID, using their email
    address, and then you need to get the regions associated with that customer before
    finally getting the clients associated with that region and that customer.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序中，拥有依赖于其他AJAX请求的Web请求并不罕见；后端可能不适合在单个AJAX调用中提供您所需的所有数据。例如，您可能需要访问客户客户的列表，但为了做到这一点，您必须首先使用他们的电子邮件地址获取客户ID，然后您需要获取与该客户关联的区域，最后才能获取与该区域和客户关联的客户。
- en: Let’s look at the following listing (found as ch06/02_requests-upon-requests
    in the samples) to see how this AJAX-fest might look.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下列表（在示例中的ch06/02_requests-upon-requests中找到）以了解这个AJAX狂欢可能看起来是什么样子。
- en: Listing 6.5\. Using AJAX for callback nesting
  id: totrans-369
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.5\. 使用AJAX进行回调嵌套
- en: '[PRE52]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As you’ll learn in [chapter 9](kindle_split_021.html#ch09) while analyzing REST
    API service design, having to jump through so many hoops to get to the data you
    need is usually a symptom of client-side code conforming to whatever API the back-end
    server offers, rather than having a dedicated API that’s specifically built for
    the front end. In the case I described, it would be best if the server did all
    that work based off a customer email, rather than making that many round-trips
    to the server.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在[第9章](kindle_split_021.html#ch09)中分析REST API服务设计时，您将了解到，为了获取所需的数据而不得不跳过这么多环节通常是一个迹象，表明客户端代码是符合后端服务器提供的任何API，而不是有一个专门为前端构建的API。在我描述的案例中，如果服务器能够基于客户电子邮件完成所有这些工作，而不是进行那么多往返服务器，那就最好不过了。
- en: '[Figure 6.1](#ch06fig01) shows the repeated round-trips to the server, compared
    with an API dedicated to the front end. As you can see in the figure, with a preexisting
    API, chances are it won’t fit the needs of your front end, and you’ll have to
    massage inputs in your browser before handing them off to the API. In the worst-case
    scenario, you might even have to make multiple requests to get the desired result,
    meaning extra round-trips. If you had a dedicated API, it would be up for whatever
    task you ask of it, allowing you to optimize and reduce the number of requests
    made against the server, reducing server load and eliminating unnecessary round-trips.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6.1](#ch06fig01)显示了与服务器之间的重复往返，与前端专用API相比。如图所示，使用现有的API，很可能它不会满足前端的需求，你必须在浏览器中对输入进行按摩处理，然后再将其传递给API。在最坏的情况下，你可能甚至需要发出多个请求以获得所需的结果，这意味着额外的往返。如果你有一个专用的API，它将能够完成你提出的任何任务，这将允许你优化并减少对服务器的请求次数，减少服务器负载并消除不必要的往返。'
- en: Figure 6.1\. The trade-offs between resorting to an existing API or using one
    dedicated to the front end
  id: totrans-373
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.1. 诉诸现有API或使用前端专用API之间的权衡
- en: '![](06fig01_alt.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig01_alt.jpg)'
- en: 'If you take into account that this code might be inside a closure and also
    inside an event handler, the indentation becomes unbearable: it’s too hard to
    follow code through all of those nesting levels, particularly if the methods are
    long. Naming the callback functions and extracting them, rather than using anonymous
    functions, is good enough to start refactoring the functionality so it’s easier
    to understand.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑到这段代码可能位于闭包内，也可能位于事件处理程序内，缩进变得难以忍受：很难通过所有这些嵌套级别来跟踪代码，尤其是如果方法很长的话。给回调函数命名并将它们提取出来，而不是使用匿名函数，就足够开始重构功能，使其更容易理解。
- en: The following listing shows the refactored code as an example of how you might
    break down nesting.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了重构后的代码，作为如何分解嵌套的一个示例。
- en: Listing 6.6\. Nesting no more
  id: totrans-377
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.6. 不再嵌套
- en: '![](138fig01_alt.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![图片](138fig01_alt.jpg)'
- en: 'You can already see how this is easier to understand; the flow is much clearer
    now that everything is at the same nesting level. You might’ve noticed the pattern
    where every method checks for errors to ensure the next step isn’t met with any
    surprises. In the next few sections we’ll look at different ways to handle asynchronous
    flow in JavaScript:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经可以看到这更容易理解了；现在所有内容都在相同的嵌套级别，流程更加清晰。你可能已经注意到了一个模式，即每个方法都会检查错误以确保下一步不会遇到任何意外。在接下来的几节中，我们将探讨在JavaScript中处理异步流的不同方法：
- en: Using callback libraries
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用回调库
- en: Promises
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承诺
- en: Generators
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器
- en: Event emitters
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件发射器
- en: You’ll learn how each of those solutions simplifies error handling. For now,
    you’ll build on the current sample, figuring out how to get rid of those error
    checks.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习每个解决方案如何简化错误处理。现在，你将在当前示例的基础上进行构建，找出如何去除那些错误检查。
- en: 6.1.4\. Asynchronous error handling
  id: totrans-385
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.4. 异步错误处理
- en: You should plan for errors, rather than ignore them. You should never let errors
    go unnoticed. That being said, when using either the callback hell or the named
    functions approach, it’s tedious to do any sort of error handling. Surely there’s
    a better way to go about it than adding an error handling line to each of your
    functions.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该计划处理错误，而不是忽略它们。你永远不应该让错误被忽视。话虽如此，当使用回调地狱或命名函数方法时，进行任何形式的错误处理都是一件繁琐的事情。当然，比在每个函数中添加错误处理行更好的方法肯定存在。
- en: In [chapter 5](kindle_split_017.html#ch05) you learned about different ways
    you can manipulate function invocation, such as using `.apply`, `.call`, and `.bind`.
    Imagine you could get away with writing a line such as the following code and
    have that get rid of repeated error-checking statements, while still checking
    for them, but in one place. Wouldn’t that be great?
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](kindle_split_017.html#ch05)中，你学习了不同的函数调用操作方法，例如使用`.apply`、`.call`和`.bind`。想象一下，如果你能写出一行如下代码，并且能够去除重复的错误检查语句，同时仍然进行检查，但只在一个地方进行，那岂不是很好？
- en: '[PRE53]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In the previous statement, the `flow` method takes an array of functions and
    executes each one in turn. Each function is passed a `next` argument that it should
    invoke when it’s done. If the first argument passed to `next` is “truthy” (JavaScript
    slang for any value that’s not `false`, `0`, `''`, `null`, or `undefined`), then
    `done` gets called immediately, interrupting the flow.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的语句中，`flow`方法接受一个函数数组，并依次执行每个函数。每个函数都会接收到一个`next`参数，当它完成时应该调用该参数。如果传递给`next`的第一个参数是“真值”（JavaScript中指任何非`false`、`0`、`''`、`null`或`undefined`的值），则`done`会被立即调用，中断流程。
- en: The first argument is reserved for errors. If that argument is truthy, then
    you’ll short-circuit and call done directly. Otherwise, the next function in the
    array is called, and it gets passed all the arguments provided to `next`, except
    for the error, plus a new `next` callback function that allows the following method
    to continue chaining. Pulling that off does seem difficult.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数保留用于错误。如果该参数是“真值”，则你会短路并直接调用`done`。否则，将调用数组中的下一个函数，并将传递给`next`的所有参数（除了错误之外）以及一个新的`next`回调函数传递给它，该回调函数允许下一个方法继续链式调用。实现这一点似乎确实有些困难。
- en: First, you’ll ask consumers of the `flow` method to call a `next` callback when
    the method is done working. That’ll help with the flow part. You’ll have to provide
    that callback method and have it call the next function in the list, passing it
    all the arguments that were used to call `next`. You’ll append a new `next` callback,
    which will call the following method, and so on.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将要求`flow`方法的消费者在方法完成工作时调用一个`next`回调。这将有助于流程部分。你必须提供那个回调方法，并让它调用列表中的下一个函数，传递所有用于调用`next`的参数。你将附加一个新的`next`回调，该回调将调用下一个方法，依此类推。
- en: '[Figure 6.2](#ch06fig02) explains the `flow` function you’re going to implement.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6.2](#ch06fig02)解释了你将要实现的`flow`函数。'
- en: Figure 6.2\. Understanding an asynchronous flow method
  id: totrans-393
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.2\. 理解异步流程方法
- en: '![](06fig02_alt.jpg)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig02_alt.jpg)'
- en: Before you implement your `flow` method, let’s look at a full usage example.
    This is what you were doing previously, finding clients for a particular customer,
    but you’re not doing the error checking in every step anymore; the `flow` method
    will take care of that. The following listing shows what using `flow` would look
    like.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在你实现`flow`方法之前，让我们看看一个完整的用法示例。这就是你之前所做的事情，为特定客户寻找客户，但你不再需要在每个步骤中进行错误检查；`flow`方法将负责这一点。下面的列表显示了使用`flow`的样子。
- en: Listing 6.7\. Using the flow method
  id: totrans-396
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.7\. 使用流程方法
- en: '![](139fig01_alt.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![图片](139fig01_alt.jpg)'
- en: Keeping in mind what we’ve discussed, let’s look at the implementation of the
    `flow` function. Adding a *guard* clause ensures that calling `next` multiple
    times on any given step doesn’t have a negative effect. Only the first call to
    `next` will be taken into consideration. A `flow` implementation can be found
    in the following listing.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们之前讨论的内容，让我们看看`flow`函数的实现。添加一个*保护*子句可以确保在给定步骤中对`next`的多次调用不会产生负面影响。只有第一次调用`next`会被考虑。`flow`的实现可以在下面的列表中找到。
- en: Listing 6.8\. Implementing the asynchronous series `flow` method
  id: totrans-399
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.8\. 实现异步系列`flow`方法
- en: '![](140fig01_alt.jpg)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![图片](140fig01_alt.jpg)'
- en: Experiment and follow the flow on your own, and if you get lost, keep in mind
    that the `next()` method merely returns a function that has an effect once. If
    you didn’t want to include that safeguard, you could reuse that same function
    every step of the way. This approach, however, accounts for programming mistakes
    by the consumers where they might call `next` twice during the same step.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试自己跟随流程，如果你迷失了方向，请记住`next()`方法仅仅返回一个函数，该函数一旦被调用就会产生效果。如果你不想包含那个保护措施，你可以在每个步骤中重复使用同一个函数。然而，这种方法考虑到了消费者可能在实际步骤中两次调用`next`的编程错误。
- en: Maintaining methods such as `flow` to keep them up-to-date and bug-free can
    be cumbersome if all you want is to avoid the nesting hell of a callback-based
    asynchronous flow and get error handling to go with that. Luckily, smart people
    have implemented this and many other asynchronous flow patterns into a JavaScript
    library called `async`, and also baked it into popular web frameworks such as
    Express, too. We’ll go over control flow paradigms in this chapter, such as callbacks,
    Promises, events, and generators. Next up, you’ll get acquainted with `async`.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 维护如`flow`这样的方法以保持它们最新和没有错误可能会很繁琐，如果您只是想避免基于回调的异步流程的嵌套地狱，并希望得到相应的错误处理。幸运的是，聪明的人已经将这种以及其他许多异步流程模式实现到了一个名为`async`的JavaScript库中，并且它也被集成到流行的Web框架如Express中。在本章中，我们将讨论控制流范式，如回调、Promise、事件和生成器。接下来，您将熟悉`async`。
- en: 6.2\. Using the async library
  id: totrans-403
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2\. 使用async库
- en: 'In the world of Node, many developers find it hard not to use the `async` control
    flow library. *Native modules*, those that are part of the Node platform itself,
    follow the pattern where the last argument taken by a function is a callback that
    receives an error as its first argument. The following code snippet illustrates
    the case in point, using Node’s file system API to read a file asynchronously:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node的世界里，许多开发者发现很难不使用`async`控制流库。*原生模块*，即Node平台本身的一部分，遵循最后一个函数参数是接收错误作为第一个参数的回调的模式。以下代码片段使用Node的文件系统API异步读取文件，说明了这一点：
- en: '[PRE54]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `async` library provides many asynchronous control flow methods, much like
    the one in [section 6.1.3](#ch06lev2sec3), when you built the `flow` utility method.
    Your `flow` method is much the same as `async.waterfall`. The difference is that
    `async` provides tens of these methods that can simplify your asynchronous code
    if applied correctly.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`库提供了许多异步控制流方法，就像在[6.1.3节](#ch06lev2sec3)中构建`flow`实用方法时一样。您的`flow`方法与`async.waterfall`非常相似。区别在于`async`提供了数十种方法，如果正确应用，可以简化您的异步代码。'
- en: You can get `async` from either `npm` or `Bower`, or from GitHub.^([[1](#ch06fn01)])
    While you’re on GitHub, you might want to check the excellent piece of documentation
    that Caolan McMahon (`async`’s author) has written.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从`npm`或`Bower`，或从GitHub获取`async`。[^[[1](#ch06fn01)]] 当您在GitHub上时，您可能想查看Caolan
    McMahon（`async`的作者）编写的优秀文档。
- en: ¹ You can download async from GitHub at [https://github.com/caolan/async](https://github.com/caolan/async).
  id: totrans-408
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ 您可以从GitHub下载async库：[https://github.com/caolan/async](https://github.com/caolan/async)。
- en: 'In the following subsections we’ll go into detail about the `async` control
    flow library, discussing problems you might run into and how `async` can solve
    those for you, making it easier for you, and everyone else, to read the code.
    To get started, you’ll look at three slightly different flow control methods:
    `waterfall`, `series`, and `parallel`.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的小节中，我们将详细介绍`async`控制流库，讨论您可能遇到的问题以及`async`如何为您解决这些问题，使代码更容易阅读。要开始，您将查看三种略有不同的流程控制方法：`waterfall`、`series`和`parallel`。
- en: 6.2.1\. Waterfall, series, or parallel?
  id: totrans-410
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.1\. 水流、顺序或并行？
- en: 'One of the most important aspects of mastering asynchronous JavaScript is learning
    about all the different tools at your disposal, and you certainly will in this
    chapter. One such tool is common control flow techniques:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握异步JavaScript最重要的方面之一是了解您可用的所有不同工具，您在本章中一定会学到。其中一种工具是常见的控制流技术：
- en: Do you want to run tasks asynchronously so they don’t depend on each other to
    do their thing? Run them *concurrently* using `.parallel`.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您想异步运行任务，使它们之间不相互依赖吗？使用`.parallel`来并发运行它们。
- en: Do your tasks depend on the previous ones? Run them in *series*, one after the
    other, but still asynchronously.
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的任务是否依赖于前一个任务？您可以按顺序运行它们，一个接一个，但仍然异步执行。
- en: Are your tasks tightly coupled? Use a waterfall mechanism that lets you *pass*
    arguments to the next task in the list. The HTTP cascade we discussed earlier
    is a perfect use case for waterfall.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的任务是否紧密耦合？使用允许您将参数传递给列表中下一个任务的瀑布机制。我们之前讨论的HTTP级联是一个完美的瀑布机制用例。
- en: '[Figure 6.3](#ch06fig03) compares the three alternatives in greater detail.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6.3](#ch06fig03)更详细地比较了三种替代方案。'
- en: Figure 6.3\. Comparison of parallel, series, and waterfall in the async library.
  id: totrans-416
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.3\. async库中并行、顺序和瀑布的比较。
- en: '![](06fig03_alt.jpg)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig03_alt.jpg)'
- en: As you can see in the figure, subtle differences exist between these three strategies.
    Let’s break them down.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 如图中所示，这三种策略之间存在细微的差异。让我们来分析一下。
- en: Concurrent
  id: totrans-419
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 并发
- en: 'Concurrent task execution is most helpful when you have a few different asynchronous
    tasks that have no interdependencies, but where you still need to do something
    when all of them finish; for example, when fetching different pieces of data to
    render a view. You can define a concurrency level, or how many tasks can be busy
    while the rest are queued up:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 并发任务执行在当你有几个不同的异步任务，它们没有相互依赖，但你仍然需要在所有这些任务完成时做某事时最有帮助；例如，当获取不同的数据来渲染视图时。你可以定义一个并发级别，即有多少个任务可以忙碌，而其余的任务则在队列中等待：
- en: Once a task finishes, another one is grabbed from the queue until the queue
    is emptied.
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦一个任务完成，就会从队列中抓取另一个任务，直到队列为空。
- en: Each task is passed a special `next` method that should be invoked when processing
    completes.
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个任务都会传递一个特殊的`next`方法，当处理完成时应该调用它。
- en: The first argument passed to `next` is reserved for errors; if you pass in an
    error, no further tasks will be executed (although the ones already executing
    will run to completion).
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递给`next`的第一个参数是保留用于错误的；如果你传递了一个错误，则不会执行任何其他任务（尽管已经执行的任务将运行到完成）。
- en: The second argument is where you’ll pass in the results for your task.
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是传递任务结果的地方。
- en: Once all tasks end, the `done` callback is invoked. Its first argument will
    be the error (if any), and the second one will have the results sorted by the
    tasks, regardless of how long they took to finish.
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦所有任务结束，就会调用`done`回调。它的第一个参数将是错误（如果有），第二个参数将按任务排序的结果，无论它们完成所需的时间有多长。
- en: Series
  id: totrans-426
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 系列
- en: Sequential execution helps you connect correlative tasks, meant to be executed
    one by one, even if the code execution happens asynchronously, outside of the
    main loop. Think of the series flow as the concurrent flow with its concurrency
    level set to 1\. In fact, that’s exactly what it is! The same conventions of `next(err,
    results)` and `done(err, results)` apply.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序执行可以帮助你连接相关任务，这些任务旨在依次执行，即使代码执行是异步的，在主循环之外。想象一下系列流程就像并发流程，其并发级别设置为1。实际上，这正是它的样子！`next(err,
    results)`和`done(err, results)`的相同约定同样适用。
- en: Waterfall
  id: totrans-428
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 水落石出
- en: 'The waterfall variant is similar to sequential execution, but it allows you
    to easily roll the arguments from one task to the next in a cascade. This type
    of flow is most useful when tasks can only be initiated using the data provided
    by the response of other tasks. In the case of waterfall the flow is different
    in that `next` takes in an error followed by any number of result arguments: `next(err,
    result1, result2, result...n)`. The `done` callback behaves in this exact same
    way, giving you all of the arguments that were passed to the last `next` callback.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 水落石出的变体类似于顺序执行，但它允许你轻松地将一个任务的参数滚到下一个任务中，形成一个瀑布。这种类型的流程在任务只能使用其他任务的响应提供的数据来启动时最有用。在瀑布的情况下，流程不同，`next`接受一个错误，后跟任意数量的结果参数：`next(err,
    result1, result2, result...n)`。`done`回调的行为与此完全相同，为你提供了传递给最后一个`next`回调的所有参数。
- en: Next, let’s get more insight into how `series` and `parallel` work.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们深入了解`series`和`parallel`是如何工作的。
- en: Flow control in series
  id: totrans-431
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 系列中的流程控制
- en: You’ve already seen `waterfall` in action, in the `flow` method you implemented.
    Let’s talk about `series`, which is a slightly different approach from what `waterfall`
    does. It executes the steps in series, one at a time the way `waterfall` does,
    but it doesn’t fiddle with the arguments of each step function. Instead, each
    step only receives a `next` callback argument, expecting the `(err, data)` signature.
    You might wonder, “How does that help me?” The answer to that is sometimes the
    consistency of having a single argument, and having that argument be a callback,
    is useful. Consider the following listing as an illustrative example of how `async.series`
    works.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在`flow`方法中看到了`waterfall`的作用。让我们谈谈`series`，它与`waterfall`所做的略有不同。它按顺序执行步骤，一次一个，就像`waterfall`一样，但它不会干涉每个步骤函数的参数。相反，每个步骤只接收一个`next`回调参数，期望`(err,
    data)`签名。你可能想知道，“那对我有什么帮助？”答案是有时拥有单个参数的一致性，并且该参数是一个回调，这很有用。以下列表是一个说明`async.series`如何工作的示例。
- en: Listing 6.9\. Using `async.series`
  id: totrans-433
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.9\. 使用`async.series`
- en: '[PRE55]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Sometimes the results need to be manipulated individually, the way you did in
    the previous listing. In those cases, it makes more sense to use an object to
    describe the tasks rather than an array. If you do that, the `done` callback will
    get a `results` object, mapping results to the property name for each task. This
    sounds complicated, but it isn’t, so let’s modify the code in the following listing
    to illustrate the point.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候需要对结果进行单独的操作，就像你在之前的列表中所做的那样。在这些情况下，使用一个对象来描述任务而不是数组更有意义。如果你这样做，`done` 回调将获得一个
    `results` 对象，将结果映射到每个任务的属性名。这听起来很复杂，但实际上并不复杂，所以让我们修改以下列表中的代码来阐述这个观点。
- en: Listing 6.10\. Using the `done` callback
  id: totrans-436
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.10\. 使用 `done` 回调
- en: '[PRE56]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If a task merely involves calling a function that takes arguments and the `next`
    callback, you could use `async.apply` to shorten your code; that’ll make it easier
    to read. The `apply` helper will take the method you want to call and the arguments
    you want to use and return a function that takes a `next` callback and appends
    that to your argument list. The two approaches shown in the following code snippets
    are functionally equivalent:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个任务仅仅涉及调用一个接受参数和 `next` 回调的函数，你可以使用 `async.apply` 来缩短你的代码；这将使代码更容易阅读。`apply`
    辅助函数将接受你想要调用的方法和你想要使用的参数，并返回一个接受 `next` 回调并将其附加到你的参数列表中的函数。以下代码片段中显示的两种方法在功能上是等效的：
- en: '[PRE57]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The following code is a simplified version of the task flow you put together
    previously, using `async.apply`:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是之前组合的任务流程的简化版本，使用了 `async.apply`：
- en: '[PRE58]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: If you used `waterfall`, this kind of optimization wouldn’t have been possible.
    The function created by `async.apply` expects only a `next` argument but nothing
    else. In `waterfall` flows, tasks can get passed an arbitrary number of arguments.
    In contrast, in a `series`, tasks always receive exactly one argument, the `next`
    callback.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用了 `waterfall`，这种优化将不会成为可能。由 `async.apply` 创建的函数只期望一个 `next` 参数，没有其他。在 `waterfall`
    流中，任务可以传递任意数量的参数。相比之下，在 `series` 中，任务总是接收恰好一个参数，即 `next` 回调。
- en: Concurrent flow control
  id: totrans-443
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 并发流程控制
- en: Then there’s `async.parallel`. Running tasks concurrently works exactly like
    running tasks in series does, except you don’t chip away at tasks one at a time,
    but rather run them all at the same time. Concurrent flows result in faster execution
    time, making `parallel` the favorite when you don’t have any specific requirements
    for your workflow other than asynchronicity.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是 `async.parallel`。并发运行任务的工作方式与按顺序运行任务完全一样，只是你不会逐个处理任务，而是同时运行它们。并发流程导致执行时间更快，因此在你的工作流程没有特定要求，只需异步性时，`parallel`
    是首选。
- en: The `async` library also provides functional methods, allowing you to loop through
    lists, map objects to something else, or sort them. Next we’ll look at these functional
    methods and an interesting task queue functionality built into `async`.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '`async` 库还提供了功能方法，允许你遍历列表、将对象映射到其他内容或对它们进行排序。接下来，我们将探讨这些功能方法以及 `async` 内置的有趣任务队列功能。'
- en: 6.2.2\. Asynchronous functional tasks
  id: totrans-446
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.2\. 异步功能任务
- en: Suppose you need to go through a list of product identifiers and fetch their
    object representations over HTTP. That’s an excellent use case for a map. Maps
    transform input into output using a function that modifies the input. The following
    listing (available as ch06/05_async-functional in the samples) shows how it’s
    done using `async.map`.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要遍历一个产品标识符列表，并通过HTTP获取它们的对象表示。这是一个非常适合使用映射（map）的场景。映射通过一个修改输入的函数将输入转换为输出。以下列表（在示例中的
    ch06/05_async-functional 文件夹中可用）展示了如何使用 `async.map` 来实现这一点。
- en: Listing 6.11\. Transforming input into output with maps
  id: totrans-448
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.11\. 使用映射将输入转换为输出
- en: '[PRE59]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: At the point `done` is called, it will either have an error argument as the
    first argument, which you should handle, or an array of results as the second
    argument, which will be in the same order as the list you provided when calling
    `async.map`. A few methods behave similarly to `map` in `async`. They’ll take
    in an array and a function, apply the function to every item in the array, and
    then call `done` with the results.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `done` 时，它将有一个错误参数作为第一个参数，你应该处理它，或者有一个结果数组作为第二个参数，该数组将与调用 `async.map` 时提供的列表顺序相同。一些方法的行为与
    `async` 中的 `map` 类似。它们将接受一个数组和函数，将函数应用于数组中的每个项目，然后使用结果调用 `done`。
- en: For instance, `async.sortBy` allows you to sort an array in place (meaning it
    won’t create a copy), and all you need to do is pass in a value as the sort criteria
    for the `done` callback of the function. You could use it as shown in the following
    listing.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`async.sortBy` 允许你原地排序一个数组（这意味着它不会创建一个副本），而你只需要传递一个值作为函数 `done` 回调的排序标准。你可以像以下列表中那样使用它。
- en: Listing 6.12\. Sorting an array
  id: totrans-452
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.12\. 对数组进行排序
- en: '[PRE60]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Both `map` and `sortBy` are based on `each`, which you can think of as `parallel`,
    or `series` if you use the `eachSeries` version. `each` merely loops through an
    array and applies a function to each element; then an optional `done` callback
    is invoked that has an error argument telling you if something went wrong. The
    following listing shows an example of using `async.each`.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 和 `sortBy` 都基于 `each`，你可以将其视为 `parallel`，或者如果你使用 `eachSeries` 版本，则为 `series`。`each`
    只是对数组进行循环并应用一个函数到每个元素；然后调用一个可选的 `done` 回调函数，它有一个错误参数告诉你是否出错。以下列表显示了使用 `async.each`
    的一个示例。'
- en: Listing 6.13\. Using `async.each`
  id: totrans-455
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.13\. 使用 `async.each`
- en: '[PRE61]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: More methods in the `async` library deal with functional situations, all of
    which revolve around asynchronously transforming an array into an alternative
    representation of its data. We won’t cover the rest of them, but I encourage you
    to look at the extensive documentation on GitHub.^([[2](#ch06fn02)])
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`async` 库中的更多方法处理函数式情况，所有这些都与异步地将数组转换为数据的不同表示形式有关。我们不会涵盖其余的内容，但我鼓励你查看 GitHub
    上的详尽文档.^([[2](#ch06fn02)])'
- en: ² You can find the flow control library `async` on GitHub at [https://github.com/caolan/async](https://github.com/caolan/async).
  id: totrans-458
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ² 你可以在 GitHub 上找到流控制库 `async`，网址为 [https://github.com/caolan/async](https://github.com/caolan/async)。
- en: 6.2.3\. Asynchronous task queues
  id: totrans-459
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.3\. 异步任务队列
- en: 'Moving on to the last method, `async.queue`, this method will create a queue
    object that can be used to run tasks in series or concurrently. It takes two arguments:
    the worker function, which will take a task object and a callback to signal that
    the work is complete, and the concurrency level, which determines how many tasks
    can run at any given moment.'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是最后一种方法，`async.queue`，此方法将创建一个队列对象，可用于按顺序或并发运行任务。它接受两个参数：工作函数，它将接受一个任务对象和一个回调函数来表示工作已完成，以及并发级别，它决定了在任何给定时刻可以运行多少个任务。
- en: If the concurrency level is `1`, you’re effectively turning the queue into a
    series, executing tasks as the previous one ends. Let’s create a simple queue
    in the following listing (labeled ch06/06_async-queue in the samples).
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 如果并发级别是 `1`，你实际上是将队列变成了一个序列，在先前的任务结束后执行任务。让我们在以下列表中创建一个简单的队列（在示例中标记为 ch06/06_async-queue）。
- en: Listing 6.14\. Creating a simple queue
  id: totrans-462
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.14\. 创建一个简单的队列
- en: '[PRE62]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You can use the `q` object to put your queue to work. To add a new job to the
    queue, use `q.push`. You’ll need to pass a task object, which is what gets passed
    to the worker; in our case the task is a numeric literal, but it could be an object
    or even a function; and an optional callback, which gets called when this particular
    job is done. Let’s see how to do that in code:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `q` 对象来使队列工作。要向队列中添加新工作，请使用 `q.push`。你需要传递一个任务对象，这是传递给工作者的内容；在我们的例子中，任务是一个数值字面量，但它也可以是一个对象或甚至是一个函数；以及一个可选的回调函数，当这个特定的工作完成时会被调用。让我们看看如何在代码中实现它：
- en: '[PRE63]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: That’s it. The nicety is that you can push more tasks at different points in
    time, and it’ll still work. In contrast, `parallel` or `series` are one-shot operations
    where you can’t add tasks to the list at a later time. That being said, our last
    topic regarding the `async` control flow library is about composing flows and
    creating task lists dynamically—both of which may bring further flexibility to
    your approach.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。好处是你可以在不同时间点推送更多任务，它仍然会工作。相比之下，`parallel` 或 `series` 是一次性操作，你无法在之后添加任务到列表中。话虽如此，我们关于
    `async` 控制流库的最后一个主题是关于组合流和动态创建任务列表——这两者都可能为你的方法带来更多的灵活性。
- en: 6.2.4\. Flow composition and dynamic flows
  id: totrans-467
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.4\. 流组成和动态流
- en: At times, you’ll need to craft more advanced flows where
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要构建更高级的流，其中
- en: Task b depends on task a
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务 b 依赖于任务 a
- en: While task c needs to be performed afterward
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当任务 c 需要在之后执行
- en: And task d can be executed in parallel to all of that
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务 d 可以与所有这些并行执行
- en: 'When all of it is done, you’ll run a last task: task e.'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有这些都完成后，你将运行最后一个任务：任务 e。
- en: '[Figure 6.4](#ch06fig04) shows what that flow might look like:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6.4](#ch06fig04) 展示了该流可能的样子：'
- en: 'Figure 6.4\. Dissection of a complex asynchronous flow. Hint: always group
    tasks, in your brain, according to their requirements.'
  id: totrans-474
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.4. 复杂异步流程的剖析。提示：始终根据需求在脑海中分组任务。
- en: '![](06fig04_alt.jpg)'
  id: totrans-475
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig04_alt.jpg)'
- en: Tasks A (getting on a bus) and B (paying the bus fare) need to be executed in
    waterfall, as task B depends on the outcome of task A.
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务A（上车）和任务B（支付车费）需要按瀑布模式执行，因为任务B依赖于任务A的结果。
- en: Task C (getting to your workplace) needs to be executed in series, after tasks
    A and B have been resolved. It depends on both of them, but not directly.
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务C（到达你的工作场所）需要在任务A和B解决后按顺序执行。它依赖于这两个任务，但不是直接依赖。
- en: Task D (reading a book) doesn’t have any dependencies, so it can be executed
    in parallel to tasks A, B, and C.
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务D（阅读一本书）没有依赖关系，因此它可以与任务A、B和C并行执行。
- en: Task E (working) depends on both task C and task D, so it has to be executed
    once those tasks are finished.
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务E（工作）依赖于任务C和任务D，因此必须在那些任务完成后执行。
- en: 'This sounds, and looks, more complicated than it is. All you need to do, provided
    you’re using a control flow library such as `async`, is write a few functions
    on top of each other. That could look like the pseudo-code shown in the following
    example. Here I’m using `async.apply`, introduced in [section 6.2.1](#ch06lev2sec5),
    to make the code shorter. A fully documented sample can be found at ch06/07_async-composition
    in the samples:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来和看起来比实际要复杂。只要你使用`async`这样的控制流库，你只需要编写几个堆叠在一起的函数。这可以像以下示例中的伪代码那样。在这里，我使用在[6.2.1节](#ch06lev2sec5)中引入的`async.apply`来缩短代码。一个完整的示例可以在`samples/ch06/07_async-composition`中找到：
- en: '[PRE64]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Composing flows in this way is most useful if you’re writing Node.js applications,
    which involve many `async` operations, such as querying a database, reading files,
    or connecting to an external API, all of which can often result in highly complex,
    asynchronous operation trees.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式组合流程在编写涉及许多`async`操作的应用程序时非常有用，例如查询数据库、读取文件或连接到外部API，所有这些操作往往会导致高度复杂的异步操作树。
- en: Composing flows dynamically
  id: totrans-483
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 动态组合流程
- en: Creating flows dynamically, by adding tasks to an object, allows you to put
    together task lists that would’ve been much harder to organize without using a
    control flow library. This is a nod to the fact that you’re writing code in JavaScript,
    a dynamic language. You can exploit that by coding up dynamic functions, so do
    so! The following listing takes a list of items and maps each of them to a function,
    which then queries something with that item.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向对象添加任务动态创建流程，可以使你组织任务列表变得更容易，这在没有使用控制流库的情况下会困难得多。这是对你在JavaScript这种动态语言中编写代码的事实的一种认可。你可以通过编写动态函数来利用这一点，所以请这样做！以下列表将一个项目列表映射到每个函数，然后使用该函数查询该项目。
- en: Listing 6.15\. Mapping and querying a list of items
  id: totrans-485
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.15. 映射和查询项目列表
- en: '[PRE65]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '|  |'
  id: totrans-487
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**A lightweight alternative to async**'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '**异步的轻量级替代方案**'
- en: There’s something I’d like to mention about `async` regarding client-side usage.
    `async` was originally developed mostly for the Node.js community, and, as such,
    it isn’t as rigorously tested for the browser.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`async`在客户端使用方面，我想提一下。`async`最初主要是为Node.js社区开发的，因此它对浏览器的测试并不那么严格。
- en: I built my own version, `contra`, which has an extensive suite of unit tests
    that get executed before every release. I kept the code in `contra` to a minimum;
    it’s 10 times smaller than `async`, making it ideal for the browser. It provides
    methods that can be found on `async,` as well as a simple way to implement event
    emitters, which are explained in [section 6.4](#ch06lev1sec4). You can find it
    on GitHub,^([[a](#ch06fn01a)]) and it’s available on both npm and Bower.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 我构建了自己的版本，`contra`，它有一个广泛的单元测试套件，在每次发布之前都会执行。我将`contra`中的代码保持到最小；它比`async`小10倍，使其非常适合浏览器。它提供了可以在`async`中找到的方法，以及实现事件发射器的一种简单方法，这在[6.4节](#ch06lev1sec4)中有解释。你可以在GitHub上找到它，^([[a](#ch06fn01a)])，并且它可在npm和Bower上使用。
- en: ^a Get `contra`, my flow control library at [https://github.com/bevacqua/contra](https://github.com/bevacqua/contra),
    on GitHub.
  id: totrans-491
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^a 在GitHub上获取我的流程控制库`contra`，网址为[https://github.com/bevacqua/contra](https://github.com/bevacqua/contra)。
- en: '|  |'
  id: totrans-492
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Let’s move on to Promises, a way to deal with asynchronous programming by chaining
    functions together, and dealing in contracts. Have you used jQuery’s AJAX functionality?
    Then you’ve worked with a flavor of Promises called Deferred, which is slightly
    different than the official ES6 Promises implementation, but fundamentally similar.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论 Promises，这是一种通过链式函数和合同处理来处理异步编程的方法。你使用过 jQuery 的 AJAX 功能吗？那么你已经使用过一种名为
    Deferred 的 Promises 变体，它与官方的 ES6 Promises 实现略有不同，但本质上相似。
- en: 6.3\. Making Promises
  id: totrans-494
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3\. 创建 Promises
- en: Promises are an up-and-coming standard, and are in fact part of the official
    ECMAScript 6 draft specification. Currently you can use Promises by including
    a library, such as `Q`, `RSVP.js`, or `when`. You could also use Promises by adding
    the ES6 Promises polyfill.^([[3](#ch06fn03)]) A *polyfill* is a piece of code
    that enables technology that you’d expect the language runtime to provide natively.
    In this case, a polyfill for Promises would provide Promises, as they’re natively
    supposed to work in ES6, made available to previous implementations of the ES
    standard.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: Promises 是一个新兴的标准，实际上它是官方 ECMAScript 6 草案规范的一部分。目前，你可以通过包含一个库，如 `Q`、`RSVP.js`
    或 `when` 来使用 Promises。你也可以通过添加 ES6 Promises polyfill 来使用 Promises.^([[3](#ch06fn03)])
    一个 *polyfill* 是一段代码，它使你期望语言运行时能够原生提供的功能成为可能。在这种情况下，Promise 的 polyfill 将提供 Promises，就像它们在
    ES6 中应该原生工作一样，使它们对 ES 标准的早期实现可用。
- en: ³ Find the ES6 Promises polyfill at [http://bevacqua.io/bf/promises](http://bevacqua.io/bf/promises).
  id: totrans-496
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³ 在 [http://bevacqua.io/bf/promises](http://bevacqua.io/bf/promises) 找到 ES6
    Promises polyfill。
- en: In this section, I’ll describe Promises per ES6, which you can use today, provided
    you include the polyfill. The syntax varies slightly if you’re using something
    other than the polyfill for Promises, but these variations are subtle enough,
    and the core concepts remain the same.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将描述 ES6 中的 Promises，只要你包含 polyfill，你就可以使用它。如果你使用的是除了 polyfill 以外的 Promise，语法会有所不同，但这些变化足够微妙，核心概念保持不变。
- en: 6.3.1\. Promise fundamentals
  id: totrans-498
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.1\. Promise 基础
- en: 'Creating a Promise involves a callback function that takes `fulfill` and `reject`
    functions as its arguments. Calling `fulfill` will change the state of the Promise
    to `fulfilled`; you’ll see what that means in a minute. Calling `reject` will
    change the state to `rejected`. The following code is a brief and self-explaining
    Promise declaration where your Promise will be fulfilled half of the time and
    rejected the other half:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 Promise 涉及一个回调函数，该函数将 `fulfill` 和 `reject` 函数作为其参数。调用 `fulfill` 将改变 Promise
    的状态为 `fulfilled`；你将在下一分钟看到这意味着什么。调用 `reject` 将状态改为 `rejected`。以下是一段简短且自解释的 Promise
    声明代码，其中你的 Promise 将有一半的时间被实现，另一半时间被拒绝：
- en: '[PRE66]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'As you might’ve noticed, Promises don’t have any inherent properties that make
    them exclusively asynchronous, and you can also use them for synchronous operations.
    This comes in handy when mixing synchronous and asynchronous code, because Promises
    don’t care about that. Promises start out in `pending`, and once they fail or
    succeed, they’re resolved and can’t change state anymore. Promises can be in one
    of three mutually exclusive states:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，Promises 没有任何固有的属性使它们专门用于异步操作，你也可以使用它们进行同步操作。当混合同步和异步代码时，这很有用，因为 Promises
    不关心这一点。Promises 从 `pending` 状态开始，一旦它们失败或成功，它们就被解决，并且状态不能再改变。Promises 可以处于三种互斥状态之一：
- en: '**`Pending:`** Hasn’t fulfilled or rejected yet.'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`Pending:`** 尚未实现或拒绝。'
- en: '**`Fulfilled:`** The action relating to the Promise succeeded.'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`Fulfilled:`** 与 Promise 相关的操作已成功执行。'
- en: '**`Rejected:`** The action relating to the Promise failed.'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`Rejected:`** 与 Promise 相关的操作失败。'
- en: Promise continuation
  id: totrans-505
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Promise 连续
- en: Once you create a Promise object, you can add callbacks to it via the `then(success,
    failure)` method. These callbacks will be executed accordingly when the Promise
    is resolved. When the Promise is fulfilled, or if it’s already fulfilled, the
    `success` callback will be called, and if it’s rejected or if it’s already rejected,
    `failure` will be invoked.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了一个 Promise 对象，你可以通过 `then(success, failure)` 方法向其添加回调函数。当 Promise 被解决时，这些回调函数将相应地执行。当
    Promise 被实现，或者如果它已经被实现，`success` 回调将被调用，如果它被拒绝或者如果它已经被拒绝，`failure` 将被调用。
- en: '[Figure 6.5](#ch06fig05) illustrates how Promises can be rejected or fulfilled
    and how Promise continuation works.'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6.5](#ch06fig05) 展示了 Promises 如何被拒绝或实现，以及 Promise 连续工作的方式。'
- en: Figure 6.5\. Promise continuation basics
  id: totrans-508
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.5\. Promise 连续基础
- en: '![](06fig05_alt.jpg)'
  id: totrans-509
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig05_alt.jpg)'
- en: There are a few takeaways from [figure 6.5](#ch06fig05). First, remember that
    when creating a `Promise` object you’ll take both fulfill and reject callbacks,
    which you can then use to resolve the `Promise`. Calling `p.then(success, fail)`
    will execute success when and if the Promise is fulfilled, and fail when and if
    the Promise is rejected. Note that both callbacks are optional, and you could
    also use `p.catch(fail)` as syntactic sugar for `p.then(null, fail)`.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 从[图 6.5](#ch06fig05)中可以得出几点启示。首先，记住在创建 `Promise` 对象时，你会接受实现和拒绝回调，然后你可以使用它们来解决
    `Promise`。调用 `p.then(success, fail)` 将在 Promise 被实现时执行成功，在 Promise 被拒绝时执行失败。请注意，这两个回调都是可选的，你也可以使用
    `p.catch(fail)` 作为 `p.then(null, fail)` 的语法糖。
- en: The following expanded listing shows the `then` continuation calls added to
    our previous example. You can find it under ch06/08_promise-basics in the code
    samples.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 以下扩展列表显示了添加到我们之前示例中的 `then` 后续调用。你可以在代码示例中的 ch06/08_promise-basics 下找到它。
- en: Listing 6.16\. Promise with continuation calls
  id: totrans-512
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.16\. 带有后续调用的 Promise
- en: '![](151fig01_alt.jpg)'
  id: totrans-513
  prefs: []
  type: TYPE_IMG
  zh: '![](151fig01_alt.jpg)'
- en: 'You can invoke `promise.then` as many times as you please, and all the callbacks
    in the correct branch (either success or rejection) will be invoked when the Promise
    is resolved, in the same order in which they were added. If the code was asynchronous,
    maybe if a `setTimeout` or an `XMLHttpRequest` was involved, the callbacks that
    depend on the outcome of the Promise won’t be executed until the Promise resolves,
    as shown in the following listing. Once the Promise is resolved, callbacks passed
    to `p.then(success, fail)` or `p.catch(fail)` will be executed immediately, where
    appropriate: `success` callbacks will only be executed if the Promise was fulfilled,
    and `fail` callbacks will only be executed if the Promise was rejected.'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随意多次调用 `promise.then`，当 Promise 被解决时，正确的分支（无论是成功还是拒绝）中的所有回调都将被调用，它们的调用顺序与它们被添加的顺序相同。如果代码是异步的，可能涉及
    `setTimeout` 或 `XMLHttpRequest`，那么依赖于 Promise 结果的回调将不会执行，直到 Promise 被解决，如下面的列表所示。一旦
    Promise 被解决，传递给 `p.then(success, fail)` 或 `p.catch(fail)` 的回调将立即执行，在适当的时候：如果 Promise
    被实现，则只执行 `success` 回调，如果 Promise 被拒绝，则只执行 `fail` 回调。
- en: Listing 6.17\. Executing Promises
  id: totrans-515
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.17\. 执行 Promise
- en: '[PRE67]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Besides creating different branches by invoking `.then` multiple times on a
    Promise object, you could also chain those callbacks together, altering the result
    each time. Let’s look into Promise chaining.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在 Promise 对象上多次调用 `.then` 来创建不同的分支外，你还可以将这些回调链式连接起来，每次都改变结果。让我们来看看 Promise
    链式调用。
- en: Promise transformation chains
  id: totrans-518
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Promise 转换链
- en: This is where things get harder to understand, but let’s go step by step. When
    you chain callbacks, they get whatever the previous one returned. Consider the
    following listing, where the first callback will parse the JSON value resolved
    by the Promise into an object, and the following callback prints whether `buildfirst`
    is `true` on that object.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的内容更难理解，但让我们一步一步来。当你链式调用回调时，它们将获得前一个回调返回的内容。考虑以下列表，第一个回调将解析 Promise 解决的 JSON
    值到一个对象中，接下来的回调将打印该对象上的 `buildfirst` 是否为 `true`。
- en: Listing 6.18\. Using a transformation chain
  id: totrans-520
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.18\. 使用转换链
- en: '![](152fig01_alt.jpg)'
  id: totrans-521
  prefs: []
  type: TYPE_IMG
  zh: '![](152fig01_alt.jpg)'
- en: Chaining callbacks to transform previous values is useful, but it won’t do you
    any good if what you need is to chain asynchronous callbacks. How can you chain
    Promises that perform asynchronous tasks? We’ll look at that next.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 将回调链式调用以转换前一个值是有用的，但如果你需要链式调用异步回调，这对你就没有任何好处。你如何链式调用执行异步任务的 Promise？我们将在下一节中探讨这个问题。
- en: 6.3.2\. Chaining Promises
  id: totrans-523
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.2\. 链式调用 Promise
- en: Instead of returning values in your callbacks, you could also return other Promises.
    Returning a Promise has an interesting effect, where the next callback in the
    chain will wait until the returned Promise is completed. In preparation for your
    next example, where you’ll query the GitHub API for a list of users and then get
    the name of one of their repositories, let’s sketch out a `Promise` wrapper of
    the `XMLHttpRequest` object, the native browser API uses to make AJAX calls.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在回调中返回值，也可以返回其他 Promise。返回一个 Promise 有一个有趣的效果，即链中的下一个回调将等待返回的 Promise 完成。为了准备你的下一个示例，你将查询
    GitHub API 获取用户列表，然后获取他们其中一个仓库的名称，让我们绘制一个 `Promise` 包装器，该包装器是原生浏览器 API 使用的 `XMLHttpRequest`
    对象。
- en: A bare AJAX call
  id: totrans-525
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 纯 AJAX 调用
- en: The specifics of how the `XMLHttpRequest` works are outside of the scope of
    this book, but the code should be self-explanatory. The following listing shows
    how you could make an AJAX call using minimal code.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `XMLHttpRequest` 的工作原理的具体内容超出了本书的范围，但代码应该是自解释的。以下列表展示了如何使用最少的代码发起一个 AJAX
    调用。
- en: Listing 6.19\. Making an AJAX call
  id: totrans-527
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.19\. 发起 AJAX 调用
- en: '[PRE68]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: It’s a matter of passing in an endpoint, setting an HTTP method—`GET`, in this
    case—and doing something with the results asynchronously. That’s a perfect opportunity
    to turn AJAX into a Promise.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个传递一个端点，设置一个 HTTP 方法——在这个例子中是 `GET`，并对结果进行异步操作的问题。这是一个将 AJAX 转换为 Promise
    的完美机会。
- en: Promising AJAX data
  id: totrans-530
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 承诺 AJAX 数据
- en: You don’t have to change the code at all, other than appropriately wrapping
    the AJAX call in a Promise and calling `resolve` and `reject` as necessary. The
    following listing depicts a possible `get` implementation, which provides access
    to the XHR object through the use of Promises.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要对代码进行任何修改，除了适当地将 AJAX 调用包裹在一个 Promise 中，并在必要时调用 `resolve` 和 `reject`。以下列表展示了一个可能的
    `get` 实现，它通过使用 Promises 提供对 XHR 对象的访问。
- en: Listing 6.20\. Promising AJAX
  id: totrans-532
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.20\. 承诺 AJAX
- en: '![](154fig01_alt.jpg)'
  id: totrans-533
  prefs: []
  type: TYPE_IMG
  zh: '![图片 154fig01_alt.jpg](154fig01_alt.jpg)'
- en: 'Once that’s out of the way, putting together the sequence of calls leading
    up to the name of a repository looks bafflingly easy. Notice how you’re mixing
    asynchronous calls thanks to Promises, and synchronous calls by using `then` transformations.
    Here’s what the code looks like, taking into account the `get` method you implemented:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些问题都解决了，将导致仓库名称的调用序列组合起来看起来令人困惑地简单。注意你如何通过 Promises 混合异步调用，并通过使用 `then` 转换进行同步调用。以下是代码的样子，考虑到你实现的
    `get` 方法：
- en: '[PRE69]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: You could’ve packed the `JSON.parse` method in the `get` method, but it felt
    like a good opportunity to display how you might mix and match asynchronous and
    synchronous operations using Promises.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `JSON.parse` 方法打包到 `get` 方法中，但这似乎是一个展示如何使用 Promises 混合和匹配异步和同步操作的好机会。
- en: This is great if you want to do operations similar to what you did with `async.waterfall`
    in [section 6.2.1](#ch06lev2sec5), where each task was fed the results from the
    previous one. What about using another flow control mechanism you got from `async`?
    Read on!
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要执行类似于在 [第 6.2.1 节](#ch06lev2sec5) 中使用 `async.waterfall` 所做的操作，其中每个任务都从前一个任务的结果中获取数据，这将是非常棒的。那么，使用从
    `async` 中获得的另一个流程控制机制呢？请继续阅读！
- en: 6.3.3\. Controlling the flow
  id: totrans-538
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.3\. 控制流程
- en: Flow control with Promises is arguably as easy as flow control using a library
    such as `async`. If you want to wait on a collection of Promises before doing
    another task, the way you did with `async.parallel`, you could wrap the Promises
    in a `Promise.all` call, as shown in the following listing.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Promises 进行流程控制可能和像 `async` 这样的库进行流程控制一样简单。如果你想在执行另一个任务之前等待一组 Promises，就像你使用
    `async.parallel` 那样，你可以将 Promises 包裹在一个 `Promise.all` 调用中，如下面的列表所示。
- en: Listing 6.21\. Promising to pause
  id: totrans-540
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.21\. 承诺暂停
- en: '![](155fig01_alt.jpg)'
  id: totrans-541
  prefs: []
  type: TYPE_IMG
  zh: '![图片 155fig01_alt.jpg](155fig01_alt.jpg)'
- en: The `delay(Math.min.apply(Math, results))` Promise will be run only after all
    the previous Promises have resolved successfully; also note how `then(results)`
    gets passed an array of results containing the result of each Promise. As you
    might’ve inferred from the `.then` call, `Promise.all(array)` returns a Promise
    which will be fulfilled when all the items in `array` are fulfilled.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '`delay(Math.min.apply(Math, results))` Promise 将在所有之前的 Promises 成功解决之后运行；同时请注意
    `then(results)` 如何传递一个包含每个 Promise 结果的结果数组。正如你可能从 `.then` 调用中推断出的，`Promise.all(array)`
    返回一个 Promise，当 `array` 中的所有项目都得到解决时，它将被实现。'
- en: Using `Promise.all` is particularly useful when executing long-running operations,
    such as a series of AJAX calls, because you wouldn’t want to make them in series
    if you could make them all at once. If you know all of the request endpoints,
    make the requests concurrently rather than serially. Then, once those requests
    are done, you can finally compute whatever depended on performing those asynchronous
    requests.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Promise.all` 在执行长时间运行的操作时特别有用，例如一系列 AJAX 调用，因为你不想如果可以一次性完成它们，却按顺序进行。如果你知道所有的请求端点，请并发而不是顺序地发出请求。然后，一旦这些请求完成，你就可以最终计算依赖于执行这些异步请求的任何内容了。
- en: Functional programming using promises
  id: totrans-544
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 Promises 进行函数式编程
- en: To perform functional tasks such as the ones provided by methods such as `async.map`
    or `async.filter`, you’re better off using the native `Array` methods when using
    Promises. Rather than resorting to a Promise-specific implementation, you can
    use a `.then` call to transform the results into what you need. Consider the following
    listing, using the same `delay` function as above, which takes results above 400
    and then sorts them.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Promises 执行功能任务，如 `async.map` 或 `async.filter` 等方法提供的功能时，你最好使用原生的 `Array`
    方法。而不是求助于特定的 Promise 实现，你可以使用 `.then` 调用来将结果转换为所需的格式。考虑以下列表，使用与上面相同的 `delay` 函数，该函数接受超过
    400 的结果然后进行排序。
- en: Listing 6.22\. Using the `delay` function to sort results
  id: totrans-546
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.22\. 使用 `delay` 函数对结果进行排序
- en: '![](155fig02_alt.jpg)'
  id: totrans-547
  prefs: []
  type: TYPE_IMG
  zh: '![](155fig02_alt.jpg)'
- en: As you can see, mixing synchronous and asynchronous operations using Promises
    couldn’t be easier, even when functional operations or AJAX requests are involved.
    You’ve been looking at the happy path so far, where everything works fine, but
    how exactly should you approach sensible error handling when using Promises?
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用 Promises 混合同步和异步操作非常简单，即使涉及到函数操作或 AJAX 请求也是如此。到目前为止，你一直在查看成功的路径，其中一切正常，但当你使用
    Promises 时，应该如何恰当地处理合理的错误处理呢？
- en: 6.3.4\. Handling rejected Promises
  id: totrans-549
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.4\. 处理拒绝的 Promises
- en: You can provide rejection handlers by passing a callback function as the second
    argument to a `.then(success, failure)` call, as you examined in [section 6.3.1](#ch06lev2sec9).
    Similarly, using `.catch(failure)` makes it easier to convey intent, and it’s
    an alias for `.then(undefined, failure)`.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将回调函数作为 `.then(success, failure)` 调用的第二个参数来提供拒绝处理程序，正如你在 [第 6.3.1 节](#ch06lev2sec9)
    中所检查的那样。同样，使用 `.catch(failure)` 可以更容易地传达意图，它是 `.then(undefined, failure)` 的别名。
- en: Until now we’ve talked in terms of explicit rejections, as in rejections when
    you explicitly call `reject` in the callback passed to the Promise constructor,
    but that’s not your only option.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在谈论显式拒绝，例如在将回调函数传递给 Promise 构造函数时显式调用 `reject`，但这并不是你的唯一选择。
- en: Let’s examine the example below, which includes error throwing and handling.
    Note that I’m using `throw` in the Promise, although you should use the more semantic
    `reject` argument to display that you can throw exceptions from the original Promise
    as well as in `then` calls.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查下面的示例，它包括错误抛出和处理。请注意，我在 Promise 中使用了 `throw`，尽管你应该使用更具语义的 `reject` 参数来显示你可以在原始
    Promise 以及 `then` 调用中抛出异常。
- en: Listing 6.23\. Catching and throwing
  id: totrans-553
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.23\. 捕获和抛出
- en: '[PRE70]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: If you execute this example, you’ll notice how the error thrown by the `delay(0)`
    Promise will prevent the success branch from firing, therefore never showing the
    `'I dislike the result!'` message. But if `delay(0)` wasn’t there, then the success
    branch would throw another error, which would prevent further progress in the
    success branch.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行此示例，你会注意到 `delay(0)` Promise 抛出的错误将阻止成功分支的触发，因此永远不会显示 `'I dislike the result!'`
    消息。但如果 `delay(0)` 不存在，那么成功分支将抛出另一个错误，这将阻止成功分支的进一步进展。
- en: At this point, you’ve looked at callback hell and how to avert it. You’ve looked
    at asynchronous flow control using the `async` library, and you’ve also dealt
    with flow control using Promises, which is coming in ES6, but is already widely
    available through other libraries and polyfills.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经了解了回调地狱以及如何避免它。你已经了解了使用 `async` 库进行异步流程控制，并且你也处理了使用 Promises 的流程控制，这在
    ES6 中即将到来，但已经通过其他库和 polyfills 广泛可用。
- en: Next up we’ll discuss *events*, which are a form of asynchronous JavaScript
    that I’m sure you’ve come across when dealing with JavaScript development at one
    point or another. Later, you’ll check out what else is coming in ES6 in terms
    of asynchronous flow. Namely, you’ll look at ES6 generators, which are a novel
    feature to deal with iterators lazily, similar to what you can find in languages
    such as C# in their enumerable implementation.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论 *事件*，这是一种异步 JavaScript 的形式，我相信你在处理 JavaScript 开发时肯定遇到过。稍后，你将了解 ES6
    中关于异步流程的其他新特性。具体来说，你将了解 ES6 生成器，这是一种处理迭代器的创新特性，类似于在 C# 等语言的可枚举实现中可以找到的特性。
- en: 6.4\. Understanding events
  id: totrans-558
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4\. 理解事件
- en: Events are also known as publish/subscribe or event emitters. An *event emitter*
    is a pattern where a component emits events of certain types and passes them arguments,
    and any interested parties can subscribe to events of interest and react to the
    event and the provided arguments. Many different ways exist to implement an event
    emitter, most of which involve prototypal inheritance in one way or another. But
    you could also attach the necessary methods to an existing object, as you’ll see
    in [section 6.4.2](#ch06lev2sec14).
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 事件也被称为发布/订阅或事件发射器。*事件发射器*是一种模式，其中组件发射特定类型的事件并传递参数，任何感兴趣的方都可以订阅感兴趣的事件并对事件和提供的参数做出反应。存在许多不同的方法来实现事件发射器，其中大多数以某种方式涉及原型继承。但您也可以将必要的方法附加到现有对象上，正如您将在[第6.4.2节](#ch06lev2sec14)中看到的那样。
- en: Events are natively implemented in browsers, too. Native events might be an
    AJAX request getting a response, a human interacting with the DOM, or a WebSocket
    carefully listening for any action coming its way. Events are asynchronous by
    nature, and they’re sprinkled all over the browser, so it’s your job to manage
    them appropriately.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 事件在浏览器中也是原生实现的。原生事件可能是一个AJAX请求获取响应，人类与DOM交互，或者WebSocket仔细监听任何即将到来的动作。事件本质上是异步的，并且散布在浏览器各处，因此管理它们是您的工作。
- en: 6.4.1\. Events and the DOM
  id: totrans-561
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.1\. 事件和DOM
- en: 'Events are one of the oldest asynchronous patterns of the web, and you can
    find them in the bindings that connect the browser DOM with your JavaScript code.
    The following example registers an event listener which will be triggered every
    time the document body gets clicked:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是网络中最古老的异步模式之一，您可以在连接浏览器DOM与您的JavaScript代码的绑定中找到它们。以下示例注册了一个事件监听器，每次文档主体被点击时都会触发：
- en: '[PRE71]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'DOM events are more often than not triggered by a human being who clicks, pans,
    touches, or pinches on their browser window. DOM events are hard to test for if
    they aren’t abstracted well enough. Even in the trivial case displayed below,
    consider the implications of having an anonymous function handling the click event:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: DOM事件通常是由人类在浏览器窗口上点击、滚动、触摸或捏合触发的。如果它们没有被很好地抽象化，DOM事件就很难测试。即使在下面显示的简单情况下，也要考虑匿名函数处理点击事件的含义：
- en: '[PRE72]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'It’s hard to test functionality like this because you have no way to access
    the event handler independently from the event. For easier testing, and to avoid
    the hassle of simulating clicks to test the handler (which should still be done
    in integration testing, as you’ll see in [chapter 8](kindle_split_020.html#ch08)),
    it’s recommended that you either extract the handler into a named function, or
    you move the main body of the logic into a testable named function. This also
    favors reusability in case two events can be handled in the same way. The following
    piece of code shows how the click handler could be extracted:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 测试这种功能很困难，因为您无法独立访问事件处理器。为了便于测试，并避免模拟点击来测试处理器（您将在第8章中看到，这仍然需要在集成测试中完成），建议您将处理器提取到命名函数中，或者将逻辑的主体移动到可测试的命名函数中。这也促进了可重用性，因为如果两个事件可以以相同的方式处理。以下代码片段显示了如何提取点击处理器：
- en: '[PRE73]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Thanks to `Function.prototype.bind` you’re keeping the element as part of the
    context. Arguments exist both in favor of and against using `this` in this way.
    You should pick the strategy you’re most comfortable with and stick to it. Either
    always bind handlers to the relevant element or always bind handlers using a `null`
    context. Consistency is one of the most important traits of readable (and maintainable)
    code.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了`Function.prototype.bind`，您将元素作为上下文的一部分保留下来。使用这种方式使用`this`既有利也有弊。您应该选择您最舒适的战略并坚持下去。要么始终将处理器绑定到相关元素，要么始终使用`null`上下文绑定处理器。一致性是可读（和可维护）代码最重要的特性之一。
- en: Next up you’ll implement your own event emitter, where you’ll attach the relevant
    methods to an object without using prototypes, making for an easy implementation.
    Let’s investigate what that might look like.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将实现自己的事件发射器，您将相关方法附加到对象上，而不使用原型，从而实现简单的实现。让我们看看这可能会是什么样子。
- en: 6.4.2\. Creating your own event emitters
  id: totrans-570
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.2\. 创建您自己的事件发射器
- en: 'Event emitters usually support multiple types of events, rather than a single
    one. Let’s implement step by step your own function to create event emitters or
    improve existing objects as event emitters. In a first step, you’ll either return
    the object unchanged or create a new object if one wasn’t provided:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 事件发射器通常支持多种类型的事件，而不是单一的一种。让我们一步一步实现你自己的函数来创建事件发射器或改进现有对象作为事件发射器。在第一步中，你将返回对象不变，或者如果没有提供，则创建一个新对象：
- en: '[PRE74]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Using multiple event types is powerful and only costs you an object to store
    the mapping of event types to event listeners. Similarly, you’ll use an array
    for each event type, so you can bind multiple event listeners to each event type.
    You’ll also add a simple function that registers event listeners. The following
    listing (found as ch06/11_event-emitter in the samples) displays how you could
    turn existing objects into event emitters.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个事件类型非常强大，而且只需一个对象来存储事件类型到事件监听器的映射。同样，你将为每个事件类型使用一个数组，这样你就可以将多个事件监听器绑定到每个事件类型。你还将添加一个简单的函数来注册事件监听器。以下列表（在
    samples 中的 ch06/11_event-emitter 可以找到）显示了如何将现有对象转换为事件发射器。
- en: Listing 6.24\. Promoting objects to event emitter status
  id: totrans-574
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.24\. 提升对象到事件发射器状态
- en: '![](158fig01_alt.jpg)'
  id: totrans-575
  prefs: []
  type: TYPE_IMG
  zh: '![](158fig01_alt.jpg)'
- en: 'Now you can add event listeners once an emitter is created. This is how it
    works. Keep in mind that listeners can be provided with an arbitrary number of
    arguments when an event is fired; you’ll implement the method to fire events next:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一旦创建了事件发射器，你就可以添加事件监听器了。这是它的工作方式。记住，当事件被触发时，监听器可以接收任意数量的参数；你将实现一个触发事件的方法：
- en: '[PRE75]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Naturally, that works like a DOM event listener. All you need to do now is implement
    the method that fires the events. Without it, there wouldn’t be an event emitter.
    You’ll implement an `emit` method that allows you to fire the event listeners
    for a particular event type, passing in an arbitrary number of arguments. The
    following listing shows how it looks.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，这就像一个 DOM 事件监听器。现在你需要实现一个触发事件的方法。没有它，就不会有事件发射器。你将实现一个 `emit` 方法，允许你为特定的事件类型触发事件监听器，并传递任意数量的参数。以下列表显示了它的样子。
- en: Listing 6.25\. Firing event listeners
  id: totrans-579
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.25\. 触发事件监听器
- en: '[PRE76]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The `Array.prototype.slice.call(arguments, 1)` statement is an interesting one.
    Here you’ll apply `Array.prototype.slice` on the `arguments` object and tell it
    to start at index 1\. This does two things. It casts the arguments object into
    a true array, and it gives a nice array with all of the arguments that were passed
    into `emit`, except for the event type, which you don’t need to invoke the event
    listeners.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.prototype.slice.call(arguments, 1)` 这个语句很有趣。在这里，你将对 `arguments` 对象应用
    `Array.prototype.slice`，并告诉它从索引 1 开始。这做了两件事。它将参数对象转换为一个真正的数组，并给出一个包含所有传递给 `emit`
    的参数的数组，除了不需要调用事件监听器的事件类型。'
- en: Executing listeners asynchronously
  id: totrans-582
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异步执行监听器
- en: There’s one last tweak to do, which is executing the listeners asynchronously
    so they don’t halt execution of the main loop if one of them blows up. You could
    also use a try/catch block here, but let’s not get involved with exceptions in
    event listeners; let the consumer handle that. To achieve this, use a `setTimeout`
    call, as shown in the following listing.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要进行一个调整，那就是异步执行监听器，这样如果其中一个监听器崩溃，它们不会阻止主循环的执行。你也可以在这里使用 try/catch 块，但让我们不要在事件监听器中涉及异常；让消费者来处理。为了实现这一点，使用以下列表中所示的
    `setTimeout` 调用。
- en: Listing 6.26\. Event emission
  id: totrans-584
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.26\. 事件发射
- en: '[PRE77]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: You can now create emitter objects, or you can turn existing objects into event
    emitters. Note that, given that you’re wrapping the event listeners in a timeout,
    if a callback throws an error, the rest will still run to completion. This isn’t
    the case in synchronous implementations of event emitters, as an error will stop
    execution on the current code path.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以创建发射器对象，或者将现有的对象转换为事件发射器。请注意，由于你将事件监听器包裹在超时中，如果回调抛出错误，其余的仍然会运行到完成。在事件发射器的同步实现中并非如此，因为错误会停止当前代码路径的执行。
- en: As a fun experiment, I’ve prepared a listing using event emitters and thoroughly
    exploiting `Function.prototype.bind` in the following listing. Can you tell how
    it works and why?
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项有趣的实验，我在以下列表中使用了事件发射器，并充分利用了 `Function.prototype.bind`。你能告诉我它是如何工作的以及为什么吗？
- en: Listing 6.27\. Using event emitters
  id: totrans-588
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.27\. 使用事件发射器
- en: '[PRE78]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Obviously this is a contrived example that doesn’t do much, but it’s interesting
    how two of the listeners control the flow, while the others control the output,
    and a single emit fires an unstoppable chain of events. As usual, you’ll find
    a fully working copy of this snippet in the accompanying samples under ch06/11_event-emitter.
    While you’re at it, make sure to read the samples for all the previous examples!
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这是一个人为构造的例子，它并没有做什么，但有趣的是，其中两位听众控制着流程，而其他人控制着输出，并且一个单一的发射会引发一系列不可阻挡的事件。通常，你可以在附带的示例中找到这个片段的完整工作副本，位于ch06/11_event-emitter目录下。同时，确保阅读所有之前示例的样本！
- en: The power of event emitters stems from their flexibility, and one possible way
    to use emitters is by inverting their meaning. Imagine you control a component
    with an event emitter, and you expose the emit functionality, rather than the
    “listen” functionality. Your component can now be passed by arbitrary messages,
    and process them, while at the same time it might also emit its own events and
    let others process them, resulting in effective communication across components.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 事件发射器的强大之处在于其灵活性，一种可能的用法是反转其含义。想象一下，你控制着一个具有事件发射器的组件，并公开了发射功能，而不是“监听”功能。现在，你的组件可以通过任意消息传递，并处理它们，同时它也可能发射自己的事件，并让其他人处理它们，从而在组件之间实现有效的通信。
- en: 'I have one last topic for you in this chapter: ES6 generators. Generators are
    a special kind of function in ES6 that can be iterated over lazily, and provide
    amusing value. Let’s inspect them more closely.'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我还有一个话题要讲：ES6生成器。生成器是ES6中的一种特殊函数，可以懒加载迭代，并提供有趣的价值。让我们更仔细地检查它们。
- en: '6.5\. Glimpse of the future: ES6 generators'
  id: totrans-593
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5. 概观未来：ES6生成器
- en: JavaScript generators, heavily inspired by Python, are an interesting new perk
    coming our way, which allow you to represent sequences of values, such as the
    Fibonacci sequence, on which you can iterate. Although you’re already capable
    of iterating over arrays, generators are lazy. Lazy is good because it means it’s
    possible to create an infinite sequence generator and iterate over it without
    falling victim to an infinite loop or stack overflow exception. Generator functions
    are denoted with an asterisk, and items in the sequence must be returned using
    the `yield` keyword.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 受Python强烈启发的JavaScript生成器是一个即将到来的有趣新特性，它允许你表示值序列，如斐波那契数列，你可以对其迭代。尽管你已经有能力迭代数组，但生成器是懒加载的。懒加载是好的，因为它意味着可以创建一个无限序列生成器，并迭代它而不会陷入无限循环或栈溢出异常。生成器函数用星号表示，序列中的项必须使用`yield`关键字返回。
- en: 6.5.1\. Creating your first generator
  id: totrans-595
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.5.1. 创建你的第一个生成器
- en: In the following listing you’ll see how to create a generator function that
    represents a never-ending Fibonacci sequence. By definition, the first two numbers
    in the series are 1 and 1, and each subsequent number is the sum of the previous
    two.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的列表中，你将看到如何创建一个表示永不结束的斐波那契数列的生成器函数。根据定义，该序列中的前两个数字是1和1，每个后续数字都是前两个数字的和。
- en: Listing 6.28\. Using a Fibonacci sequence
  id: totrans-597
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.28. 使用斐波那契数列
- en: '[PRE79]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Once you have a generator, you may want to consume the values it produces,
    and to do that, you need to call the generator function, which will give you an
    iterator. The iterator can be used to get values from the generator, one at a
    time, by calling `iterator.next()`. That function call will result in an object
    such as `{ value: 1, done: false }` for iterators using the generator in the previous
    listing. The `done` property will become true when the iterator’s done going through
    the generator function, but in this example it would never finish because of the
    infinite `while(true)` loop. The following example demonstrates how you could
    iterate over a few values using the never-ending `fibonacci` generator:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '一旦你有了生成器，你可能想要消费它产生的值，为此，你需要调用生成器函数，这将给你一个迭代器。迭代器可以通过调用`iterator.next()`来从生成器中逐个获取值。对于使用前列表中的生成器的迭代器，该函数调用将产生一个如`{
    value: 1, done: false }`的对象。当迭代器完成遍历生成器函数时，`done`属性将变为true，但在本例中，由于无限`while(true)`循环，它永远不会结束。以下示例演示了如何使用永不结束的`fibonacci`生成器迭代几个值：'
- en: '[PRE80]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The easiest way to run the examples in this section is visiting [http://es6fiddle.net](http://es6fiddle.net),
    which will run ES6 code for you, including anything that uses generators. Alternatively,
    you could get Node `v0.11.10` or later, which you can easily fetch from [https://nodejs.org/dist](https://nodejs.org/dist).
    Then, doing `node --harmony <file>` when executing a script will enable ES6 features
    such as generators, including the `function* ()` construct, the `yield` keyword,
    and the `for..of` construct, which comes next.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 运行本节示例的最简单方法是访问 [http://es6fiddle.net](http://es6fiddle.net)，它将为你运行 ES6 代码，包括使用生成器的任何内容。或者，你可以获取
    Node `v0.11.10` 或更高版本，你可以轻松地从 [https://nodejs.org/dist](https://nodejs.org/dist)
    获取。然后，在执行脚本时使用 `node --harmony <file>` 将启用 ES6 功能，包括生成器，例如 `function* ()` 构造、`yield`
    关键字和 `for..of` 构造，接下来我们将讨论这些。
- en: Iterate using for..of
  id: totrans-602
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 for..of 迭代
- en: 'The `for..of` syntax allows you to shortcut the process of iterating over a
    generator. Normally you’d call `iterator.next()`, store or use the provided `result.value`,
    and then check `iterator.done` to see if the iterator is exhausted. The `for..of`
    syntax handles that for you, trimming down your code. The following is a representation
    of iterating over a generator with a `for..of` loop. Note that you’re using a
    finite generator, because using a generator such as `fibonacci` would create an
    infinite loop, unless you use `break` to exit the loop:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '`for..of` 语法允许你简化遍历生成器的过程。通常你会调用 `iterator.next()`，存储或使用提供的 `result.value`，然后检查
    `iterator.done` 以查看迭代器是否耗尽。`for..of` 语法为你处理这些，简化了你的代码。以下是一个使用 `for..of` 循环遍历生成器的表示。请注意，你使用的是一个有限生成器，因为使用像
    `fibonacci` 这样的生成器将创建一个无限循环，除非你使用 `break` 退出循环：'
- en: '[PRE81]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: At this point you might wonder how generators can help you deal with asynchronous
    flows, and we’re about to get to that. First, however, we need to go back to generator
    functions and explain what suspension means.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能会想知道生成器如何帮助你处理异步流程，我们很快就会讨论这个问题。然而，首先，我们需要回到生成器函数并解释什么是暂停。
- en: Execution suspension in generators
  id: totrans-606
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 生成器中的执行暂停
- en: 'Let’s look at the first generator example again:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看第一个生成器示例：
- en: '[PRE82]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'How does that work? Why doesn’t it get stuck in an infinite loop? Whenever
    a `yield` statement is executed, execution in the generator gets suspended and
    relinquished back to the consumer, passing them the value which was yielded. That’s
    how `iterator.next()` gets a value. Let’s inspect this behavior more closely using
    a simple generator, which has side effects:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何工作的？为什么它不会陷入无限循环？每当执行 `yield` 语句时，生成器中的执行将被暂停并归还给消费者，传递给他们被产生的值。这就是 `iterator.next()`
    获取值的方式。让我们通过一个简单的生成器更仔细地检查这种行为，该生成器具有副作用：
- en: '[PRE83]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'When you iterate over a generator sequence, execution in the generator will
    be *suspended* (pausing its execution until the next item in the sequence is requested)
    immediately after each `yield` call. This allows you to execute side effects such
    as the `console.log` statement in the previous example, as a consequence of calling
    `iterator.next()` for the second time. The following snippet shows how iterating
    over the previous generator would flow:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 当你迭代一个生成器序列时，生成器中的执行将在每个 `yield` 调用后立即暂停（直到请求序列中的下一个项目）。这允许你执行副作用，例如上一个示例中的
    `console.log` 语句，这是由于第二次调用 `iterator.next()` 的结果。以下代码片段显示了如何迭代之前的生成器：
- en: '[PRE84]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Armed with your newfound knowledge about generators, next you’ll try to figure
    out how to turn the tables and build an iterator that can consume generators in
    a way that makes asynchronous code easier to write.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有了关于生成器的全新知识后，接下来你将尝试弄清楚如何扭转局面，构建一个可以消费生成器的迭代器，从而使异步代码更容易编写。
- en: 6.5.2\. Asynchronicity and generators
  id: totrans-614
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.5.2\. 异步性和生成器
- en: Let’s build an iterator that can exploit suspension well enough to combine synchronous
    and asynchronous flows in a seamless manner. How could you accomplish a `flow`
    method that would allow you to implement functionality such as that in the following
    listing (ch06/13_generator-flow)? In this listing, you use `yield` on a method
    that needs to be executed asynchronously, and then you invoke a `next` function
    that would be provided by the `flow` implementation once you’ve fetched all the
    needed food types. Note how you’re still using the callback convention where the
    first argument is either an error or a false value.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个迭代器，它可以很好地利用挂起，以无缝的方式结合同步和异步流程。你如何实现一个 `flow` 方法，允许你实现如下列表（ch06/13_generator-flow）中的功能？在这个列表中，你在需要异步执行的方法上使用
    `yield`，然后调用一个 `next` 函数，这个 `next` 函数将由 `flow` 实现提供，一旦你获取了所有需要的食物类型。注意你仍然在使用回调约定，其中第一个参数要么是错误，要么是假值。
- en: Listing 6.29\. Building an iterator to exploit suspension
  id: totrans-616
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.29\. 构建一个利用挂起的迭代器
- en: '[PRE85]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: To make the previous listing work, you need to create the `flow` method in such
    a way that it allows `yield` statements to pause until `next` gets called. The
    `flow` method would take a generator as an argument, such as the one in the previous
    listing, and iterate through it. The generator should be passed a `next` callback
    so you can avoid anonymous functions, and you can, alternatively, yield functions
    that take a `next` callback and have the iterator pass the `next` callback to
    them as well. The consumer can let the iterator know that it’s time to move on
    by calling `next()`. Then execution would get unsuspended and pick up where it
    left off.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 要使前面的列表工作，你需要以允许 `yield` 语句暂停直到 `next` 被调用这种方式创建 `flow` 方法。`flow` 方法将接受一个生成器作为参数，例如前面列表中的那个，并遍历它。生成器应该传递一个
    `next` 回调，这样你可以避免匿名函数，你也可以，作为替代，产生接受 `next` 回调的函数，并将 `next` 回调传递给它们。消费者可以通过调用
    `next()` 来让迭代器知道是时候继续了。然后执行将取消挂起，并从上次停止的地方继续。
- en: You can find how a `flow` function might be implemented in the following listing.
    It works much like the iterators you’ve seen so far, except that it also has the
    capability to let the generator function, which gets passed into `flow`, do the
    sequencing. The key aspect of this asynchronous generator pattern is the back-and-forth
    enabled by letting the generator suspend (by using `yield`) and unsuspend (by
    invoking `next`) the flow of the iteration.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下列表中找到 `flow` 函数可能实现的示例。它的工作方式与迄今为止看到的迭代器非常相似，除了它还具有让传递给 `flow` 的生成器函数进行序列化的能力。这种异步生成器模式的关键方面是通过允许生成器通过使用
    `yield` 暂停（挂起）和通过调用 `next` 恢复（取消挂起）迭代流的来回移动。
- en: Listing 6.30\. Generator flow implementation
  id: totrans-620
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.30\. 生成器流程实现
- en: '![](164fig01.jpg)'
  id: totrans-621
  prefs: []
  type: TYPE_IMG
  zh: '![图片](164fig01.jpg)'
- en: Using the `flow` function you can easily mix flows, and have the flow leap into
    (and out of) asynchronous mode easily. Going forward you’ll use a combination
    of plain old JavaScript callbacks and control flow using the `contra` library,
    which is a lightweight alternative to `async`.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `flow` 函数，你可以轻松混合流程，并且使流程轻松地跳入（和跳出）异步模式。向前看，你将使用传统的 JavaScript 回调和 `contra`
    库中的控制流组合，`contra` 是 `async` 的轻量级替代品。
- en: 6.6\. Summary
  id: totrans-623
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6\. 摘要
- en: That was a lot of ground to cover, so you might want to take a break for a minute
    and check out the source code samples and play around with them a little more.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要覆盖很多内容，所以你可能想要休息一分钟，查看源代码示例，并稍微玩一下。
- en: We established what callback hell is, and you learned how to stay away from
    it by naming your functions or composing your own flow control methods.
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们确定了回调地狱是什么，你学习了如何通过命名你的函数或组合你自己的流程控制方法来避免它。
- en: You learned how to use `async` to meet different needs such as asynchronous
    series, mapping asynchronously, or creating asynchronous queues. You delved into
    the world of Promises. You understand how to create a Promise, how to compose
    multiple Promises, and how to mix and match asynchronous and synchronous flows.
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你学习了如何使用 `async` 来满足不同的需求，例如异步序列、异步映射或创建异步队列。你深入了解了 Promise 的世界。你理解了如何创建一个 Promise，如何组合多个
    Promise，以及如何混合和匹配异步和同步流程。
- en: You took an implementation-agnostic look at events and learned how to implement
    your own event emitters.
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你以实现无关的方式审视了事件，并学习了如何实现你自己的事件发射器。
- en: I gave you a glimpse of what’s coming in ES6 with Generators, and how you might
    use them to develop asynchronous flows.
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我向你展示了 ES6 中生成器的未来，以及你如何可能使用它们来开发异步流程。
- en: In [chapter 7](kindle_split_019.html#ch07) you’ll take a harder look at client-side
    programming practices. We’ll discuss the current state of interacting with the
    DOM, how to improve on that, and what the future holds in terms of componentized
    development. We’ll detail implications of using jQuery, how it might not be your
    one-size-fits-all library, and a few alternatives you can gravitate toward. You’ll
    also get your hands dirty with BackboneJS, an MVC framework.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](kindle_split_019.html#ch07)中，你将更深入地了解客户端编程实践。我们将讨论与DOM交互的当前状态，如何改进它，以及组件化开发方面的未来趋势。我们将详细说明使用jQuery的后果，它可能不是适合所有情况的库，以及你可以转向的一些替代方案。你还将通过BackboneJS这个MVC框架亲自动手实践。
- en: Chapter 7\. Leveraging the Model-View-Controller
  id: totrans-630
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7章\. 利用模型-视图-控制器
- en: '*This chapter covers*'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Comparing pure jQuery to MVC
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较纯jQuery与MVC
- en: Learning about MVC in JavaScript
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习JavaScript中的MVC
- en: Introducing Backbone
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Backbone
- en: Building Backbone applications
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建Backbone应用程序
- en: Looking at shared-view rendering in the server and browser
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看服务器和浏览器中的共享视图渲染
- en: Until now, we’ve discussed topics around application development, such as crafting
    a build process. We also talked about code-related topics, such as coherent asynchronous
    flows and modular application design. We haven’t yet covered the bulk of an application
    itself, which is what we’ll do in this chapter. I’ll explain why jQuery, a popular
    library that makes interacting with the DOM easier, might be lacking for large-scale
    application design and what tools you can use to supplement it or how to replace
    it entirely. You’ll look at developing an application using the Model-View-Controller
    (MVC) design pattern, and you’ll create an application to manage a list of to-do
    items throughout the chapter.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了围绕应用程序开发的话题，例如构建过程。我们还讨论了与代码相关的话题，例如连贯的异步流程和模块化应用程序设计。我们还没有涵盖应用程序本身的绝大部分，这正是本章要做的。我将解释为什么jQuery，一个使与DOM交互变得更容易的流行库，可能在大型应用程序设计中有所不足，以及你可以使用哪些工具来补充它或完全替换它。你将学习使用模型-视图-控制器（MVC）设计模式开发应用程序，并在本章中创建一个管理待办事项列表的应用程序。
- en: 'Like modularity, MVC improves software quality by separating concerns. In the
    case of MVC, this separation is split into three types of modules: Models, Views,
    and Controllers. These parts are interconnected to separate internal information
    representation (Models, what the developer understands) from the presentation
    layer (Views, what the user sees) from the logic that connects both representations
    of the same data (Controllers, which also help validate user data and decide what
    views to show them).'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 与模块化一样，MVC通过分离关注点来提高软件质量。在MVC的情况下，这种分离分为三种类型的模块：模型（Models）、视图（Views）和控制器（Controllers）。这些部分相互连接，以将内部信息表示（模型，开发者理解的内容）与表示层（视图，用户看到的内容）以及连接这两种相同数据表示的逻辑（控制器，它还帮助验证用户数据并决定显示哪些视图）分开。
- en: First I’ll tell you why jQuery doesn’t suffice in large scale application design,
    and then I’ll teach you about MVC in JavaScript through the Backbone.js library.
    The goal here isn’t for you to become a Backbone grandmaster, but rather to get
    you started in the wonderful world of modern JavaScript application structure
    design.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我会告诉你为什么jQuery在大型规模应用程序设计中不足以满足需求，然后我会通过Backbone.js库教你关于JavaScript中的MVC。这里的目的是让你开始进入现代JavaScript应用程序结构设计的奇妙世界，而不是让你成为Backbone的大师。
- en: 7.1\. jQuery isn’t enough
  id: totrans-640
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1\. jQuery是不够的
- en: Since its inception, the jQuery library has helped virtually every web developer
    out there by doing a few things well. It works around known bugs across different
    browser versions, and it normalizes the web API across browsers, giving the consumer
    a flexible API that delivers consistent results, making it easy to use.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 自从jQuery库问世以来，它通过做好几件事情，帮助了几乎每一位在世的网络开发者。它解决了不同浏览器版本中的已知错误，并在浏览器之间标准化了Web API，为消费者提供了一个灵活的API，该API提供一致的结果，使其易于使用。
- en: jQuery helped popularize CSS selectors as the preferred method of querying the
    DOM in JavaScript. The native `querySelector` DOM API works similarly to querying
    in jQuery, allowing you to search for DOM elements using a CSS selector string.
    On its own, however, jQuery isn’t enough. Let’s discuss why.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery帮助普及了CSS选择器作为在JavaScript中查询DOM的首选方法。原生的`querySelector` DOM API与jQuery查询类似，允许你使用CSS选择器字符串搜索DOM元素。然而，仅凭jQuery是不够的。让我们来讨论一下原因。
- en: Code organization and jQuery
  id: totrans-643
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码组织和jQuery
- en: jQuery provides no means for organizing your code base, and that’s okay because
    jQuery wasn’t designed to do that. Although jQuery makes it simpler to access
    the native DOM API, it makes no effort to perform the necessary tasks to take
    your application closer to a well-structured one. Relying on jQuery alone is fine
    for traditional web applications where you don’t have a need for structure, but
    doing so isn’t suitable for the job of developing single page applications, which
    tend to have a larger and more complex client-side code base.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 并不提供组织代码库的方法，这是可以接受的，因为 jQuery 并不是为此而设计的。尽管 jQuery 使访问原生 DOM API 变得更加简单，但它并没有努力执行将应用程序结构化的必要任务。仅依赖
    jQuery 对于不需要结构的传统 Web 应用程序来说是可行的，但对于开发单页应用程序来说并不合适，因为单页应用程序往往拥有更大和更复杂的客户端代码库。
- en: Another reason jQuery is so popular even today is because it’s a library that
    plays well with others. This means you’re not forced into using jQuery for everything
    you do. Rather, you can combine it with other libraries, which may or may not
    be meant to augment jQuery. You may also use jQuery on its own without other libraries.
    Unless you pair jQuery with an MVC library or framework, it’ll be difficult to
    develop modular components that don’t become a maintainability nightmare over
    time.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原因，即使今天 jQuery 仍然如此受欢迎，是因为它是一个与其他库兼容性良好的库。这意味着你不必强迫自己在所有事情上都使用 jQuery。相反，你可以将其与其他库结合使用，这些库可能旨在增强
    jQuery，也可能不是。你也可以单独使用 jQuery 而不依赖其他库。除非你将 jQuery 与 MVC 库或框架搭配使用，否则很难开发出不会随着时间的推移变成维护噩梦的模块化组件。
- en: The MVC pattern separates your application’s concerns into views, models, and
    controllers; these components interact and collaborate with each other to serve
    the application. Most of the logic you develop becomes self-contained, meaning
    that a single complex view won’t translate into a complex application, making
    it a great choice for developing scalable applications. MVC came into existence
    in the late 1970s, but it only made its way into web applications with Ruby on
    Rails in 2005\. In 2010, Backbone was released, bringing MVC into the client-side
    JavaScript application development mainstream. Today, dozens of alternatives exist
    for developing MVC web applications in JavaScript.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 模式将应用程序的关注点分为视图、模型和控制器；这些组件相互交互和协作以服务于应用程序。你开发的大部分逻辑都变得自包含，这意味着一个复杂的视图不会转化为一个复杂的应用程序，这使得它成为开发可扩展应用程序的一个很好的选择。MVC
    诞生于 20 世纪 70 年代末，但直到 2005 年 Ruby on Rails 的出现才进入 Web 应用程序领域。2010 年，Backbone 发布，将
    MVC 带入了客户端 JavaScript 应用程序开发的主流。如今，JavaScript 开发 MVC Web 应用程序有数十种替代方案。
- en: View templates
  id: totrans-647
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 视图模板
- en: First you have the HTML; we’ll call that the *view.* This is what defines how
    your component looks and how it’s represented on the user interface. This is also
    how you define where pieces of data will go. If you use only jQuery, then you’d
    have to create the DOM elements that make up your component by hand, with their
    corresponding HTML attribute values and inner text. Typically, though, you’d use
    a templating engine, which takes a template string (of HTML, in your case) and
    data, and fills out the template using that data. There might be parts of the
    template where you loop through an array and create a few HTML elements for each
    item in the array. That kind of code is tedious to write in plain JavaScript,
    even if you’re using jQuery. You don’t have to worry about that if you’re using
    a templating library, because the engine will handle it for you. [Figure 7.1](#ch07fig01)
    illustrates how templates work as reusable components.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你有 HTML；我们可以称之为 *视图*。这是定义你的组件外观及其在用户界面上的表示方式。这也是你定义数据片段将放置在哪里的方式。如果你只使用 jQuery，那么你必须手动创建构成你的组件的
    DOM 元素，包括它们相应的 HTML 属性值和内文。通常情况下，你会使用模板引擎，它接受一个模板字符串（在这种情况下是 HTML）和数据，并使用这些数据填充模板。模板中可能有部分是循环遍历数组并为数组中的每个项目创建一些
    HTML 元素。这种代码在纯 JavaScript 中编写起来很繁琐，即使你使用 jQuery 也是如此。如果你使用模板库，你不必担心这一点，因为引擎会为你处理。![图
    7.1](#ch07fig01) 展示了模板作为可重用组件的工作方式。
- en: Figure 7.1\. Reusing templates with different template data models
  id: totrans-649
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.1\. 使用不同的模板数据模型重用模板
- en: '![](07fig01_alt.jpg)'
  id: totrans-650
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig01_alt.jpg)'
- en: Using controllers
  id: totrans-651
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用控制器
- en: Then there’s the functionality, giving life to your views; we call this the
    *controller.* This is how you take your still HTML template and give it life.
    In the controller you’ll do things such as binding DOM events to certain actions
    or updating the view when something happens. This is an easy thing to do with
    jQuery; you add events to the DOM, and that’s it, right? That’s fine for one-time
    bindings, but what if you want to develop a component using a view like you saw
    previously and also bind events to the rendered HTML?
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是功能，为您的视图赋予生命；我们称之为*控制器*。这就是您如何使静态HTML模板获得生命力的方式。在控制器中，您会执行诸如将DOM事件绑定到特定操作或当发生某些事情时更新视图等操作。这用jQuery来做很容易；您向DOM添加事件，然后就可以了，对吧？对于一次性绑定来说，这很好，但如果你想要开发一个像之前看到的视图一样，并且将事件绑定到渲染的HTML上的组件，怎么办呢？
- en: For this scenario you’d need a way to consistently create the DOM structure,
    bind events to it, react to changes, and update it. You also need this to work
    in isolation, because this is a reusable component, and you want it to work in
    many places in your application. To be blunt, you’ll end up slowly writing your
    own MVC framework. That’s fine, as a learning exercise. In fact, that’s exactly
    how I’ve come to understand and value MVC in JavaScript. I wrote my own MVC engine
    for a pet project, my blog, and that’s what got me on the path of learning more
    about other MVC engines in JavaScript. The alternative is to use an existing (and
    proven) MVC framework.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个场景，您需要一个方法来一致地创建DOM结构，将其绑定到事件，对变化做出反应，并更新它。您还需要它能够独立工作，因为这是一个可重用的组件，您希望它在应用程序的许多地方都能工作。坦白说，您最终会慢慢地编写自己的MVC框架。这很好，作为一个学习练习。事实上，这正是我理解并重视JavaScript中MVC的方式。我为一个宠物项目，我的博客，编写了自己的MVC引擎，这就是我走上学习更多关于JavaScript中其他MVC引擎的道路。另一种选择是使用现有的（并且经过验证的）MVC框架。
- en: This primer explains how the MVC pattern works, how it helps develop complex
    applications, and why it’s needed. In [section 7.2](#ch07lev1sec2) you’ll learn
    how it can be applied in JavaScript. You’ll look at different libraries that help
    write MVC code, and then you’ll settle for Backbone. As you would expect, the
    MVC pattern dictates that your application should be split into
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南解释了MVC模式的工作原理，它如何帮助开发复杂的应用程序，以及为什么需要它。在[7.2节](#ch07lev1sec2)中，您将了解它如何在JavaScript中应用。您将查看不同的库，这些库有助于编写MVC代码，然后您将选择Backbone。正如您所期望的，MVC模式规定您的应用程序应该分为
- en: Models that hold the information necessary to render a view
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持有渲染视图所需信息的模型
- en: Views that are in charge of rendering a model and allowing the human to interact
    with it
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负责渲染模型并允许人与之交互的视图
- en: Controllers that fill the models before rendering their related views and manage
    human interaction with the component
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在渲染相关视图之前填充模型并管理人与组件交互的控制器
- en: '[Figure 7.2](#ch07fig02) illustrates the interaction between the different
    elements in a typical MVC application design.'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7.2](#ch07fig02)展示了典型MVC应用程序设计中不同元素之间的交互。'
- en: Figure 7.2\. The MVC pattern separates concerns into controllers, views, and
    models.
  id: totrans-659
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.2。MVC模式将关注点分为控制器、视图和模型。
- en: '![](07fig02_alt.jpg)'
  id: totrans-660
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2](07fig02_alt.jpg)'
- en: Models
  id: totrans-661
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模型
- en: Models define the information to be conveyed by the views. This information
    can be pulled from a service that, in turn, fetches the data from a database source,
    as we’ll cover in [chapter 9](kindle_split_021.html#ch09) when discussing REST
    API design and the service layer. A model contains raw data, but there isn’t any
    logic in models; they’re static collections of related data. It doesn’t know anything
    about displaying that data, either. That concern is left to views and views alone.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 模型定义了视图需要传达的信息。这些信息可以从一个服务中提取，该服务反过来从数据库源获取数据，正如我们在[第9章](kindle_split_021.html#ch09)中讨论REST
    API设计和服务层时将要介绍的。模型包含原始数据，但模型中没有逻辑；它们是相关数据的静态集合。模型也不知道如何显示这些数据。这个关注点留给视图和视图本身。
- en: Views
  id: totrans-663
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 视图
- en: A view is the combination of a template, which gives structure to a data representation
    of the model, and a model, which contains the data itself. Models can and often
    are reused across different views. For instance, an “Article” model could be used
    in both the “Search” view and the “ArticleList” view. Combining a view template
    with a view model yields a view that can then be used as the response to an HTTP
    request.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 视图是模板和数据表示的组合，模板为模型的数据表示提供结构，而模型则包含实际数据。模型可以在不同的视图中重用，并且通常可以重用。例如，“文章”模型可以在“搜索”视图和“文章列表”视图中使用。将视图模板与视图模型结合，可以得到一个视图，然后可以将其用作对HTTP请求的响应。
- en: Controllers
  id: totrans-665
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 控制器
- en: Controllers decide what view to render, and that’s one of their primary purposes.
    The controller will decide on a view to render, prepare a view model containing
    all the relevant bits and pieces for the view template, and let the view engine
    render the view using the provided model and template. You can use controllers
    to add behavior to your views, respond to specific actions, or redirect humans
    to another view.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器决定要渲染哪个视图，这是它们的主要目的之一。控制器将决定要渲染的视图，准备一个包含视图模板所需所有相关部分和片段的视图模型，并让视图引擎使用提供的模型和模板渲染视图。你可以使用控制器为视图添加行为，响应特定动作，或将人类用户重定向到另一个视图。
- en: Router
  id: totrans-667
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 路由器
- en: 'The view router is a fundamental piece of MVC in the web, although it’s not
    part of its name. A view router is the first component of MVC applications that
    gets hit by a request. A router matches URL patterns to controller actions by
    following previously defined rules. Rules are defined in code, and they capture
    a request based on a condition: “Whenever a request for `/articles/{slug}` is
    made, route that request through the `Articles` controller, invoking the `getBySlug`
    action, passing it the `slug` parameter” (the `slug` is interpolated from the
    requested URL). The router then delegates to the controller, which will validate
    the request, decide on a view and render it, redirect to other URLs, and perform
    similar actions. Rules are evaluated in sequence. If the requested URL doesn’t
    match the rule’s pattern, it simply ignores the request, and the next rule is
    evaluated.'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 视图路由是Web中MVC（模型-视图-控制器）模式的一个基本组成部分，尽管它并不包含在其名称中。视图路由是MVC应用程序中第一个被请求击中的组件。路由器通过遵循先前定义的规则将URL模式与控制器动作相匹配。规则在代码中定义，并根据条件捕获请求：“每当有对`/articles/{slug}`的请求时，通过`Articles`控制器路由该请求，调用`getBySlug`动作，并传递`slug`参数”（`slug`是从请求的URL中插入的）。然后路由器将任务委托给控制器，控制器将验证请求，决定要渲染的视图，渲染它，重定向到其他URL，并执行类似操作。规则按顺序评估。如果请求的URL不匹配规则的模式，它将简单地忽略请求，并评估下一个规则。
- en: Let’s get deeper into JavaScript MVC, which spans the rest of this chapter.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地探讨JavaScript MVC，这贯穿了本章的其余部分。
- en: 7.2\. Model-View-Controller in JavaScript
  id: totrans-670
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2. 模型-视图-控制器在JavaScript中
- en: The MVC pattern is nothing new, although it has seen a significant increase
    in adoption in the last decade, particularly in the client-side web world, which
    has traditionally been completely devoid of any structure. In this section I’ll
    explain why I chose Backbone as my teaching weapon of choice, and why I discarded
    the other options I was considering. In [section 7.3](#ch07lev1sec3) I’ll show
    you the basics of MVC through Backbone. Then in [section 7.4](#ch07lev1sec4) you’ll
    dive into a case study where you’ll use Backbone to develop a small application
    so you can learn how to use it to build scalable applications. In [chapter 9](kindle_split_021.html#ch09)
    you’ll take Backbone to the next level, along with everything else you’ve learned
    so far, and use it to flesh out a larger application.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: MVC模式并不是什么新鲜事物，尽管在过去十年中，它的采用率显著增加，尤其是在客户端Web领域，这个领域传统上完全缺乏任何结构。在本节中，我将解释为什么我选择Backbone作为我的首选教学武器，以及为什么我放弃了其他考虑的选项。在[第7.3节](#ch07lev1sec3)中，我将通过Backbone解释MVC的基础。然后在[第7.4节](#ch07lev1sec4)中，你将深入一个案例研究，其中你将使用Backbone开发一个小型应用程序，以便你可以学习如何使用它来构建可扩展的应用程序。在[第9章](kindle_split_021.html#ch09)中，你将把Backbone提升到下一个层次，以及迄今为止你所学到的所有内容，并使用它来完善一个更大的应用程序。
- en: 7.2.1\. Why Backbone?
  id: totrans-672
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.1. 为什么选择Backbone？
- en: Many different frameworks and libraries exist for performing client-side MVC,
    let alone server-side MVC, and sadly I can’t cover all of them. One of the hardest
    choices I had to make for this book was picking an MVC framework to use. For a
    long while, I was torn between React, Backbone, and Angular. Ultimately, I decided
    Backbone is the best tool for teaching the concepts I want to relay to you. Arriving
    at that choice wasn’t easy, and it came down mostly to maturity, simplicity, and
    familiarity. Backbone is one of the oldest MVC libraries out there, and therefore
    one of the most mature. It’s also one of the most popular MVC libraries. Angular
    is an MVC framework developed at Google. It’s also mature—in fact it was released
    before Backbone—but it’s also much more complex, having a steep learning curve.
    React is Facebook’s take; it’s not as complex as Angular, but it’s a much younger
    project, having been initially released in 2013, and it doesn’t provide true MVC
    capabilities as it’s meant to provide only the View in MVC.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多不同的框架和库用于执行客户端MVC，更不用说服务器端MVC了，遗憾的是我无法涵盖所有这些。我为这本书必须做出的最艰难的选择之一是选择一个MVC框架来使用。有一段时间，我在React、Backbone和Angular之间犹豫不决。最终，我决定Backbone是教授我想传达给您的概念的最佳工具。做出那个选择并不容易，这主要取决于成熟度、简单性和熟悉性。Backbone是现有的最古老的MVC库之一，因此也是最成熟的之一。它也是最流行的MVC库之一。Angular是Google开发的MVC框架。它也很成熟——事实上，它是在Backbone之前发布的——但它也更复杂，学习曲线陡峭。React是Facebook的解决方案；它不像Angular那样复杂，但它是一个更年轻的项目，最初于2013年发布，并且它不提供真正的MVC功能，因为它旨在只提供MVC中的视图。
- en: Angular introduces concepts that can be hard to grasp at first, and I didn’t
    want to spend the rest of the book explaining these concepts. I felt Angular would’ve
    gotten in the way of teaching how to write MVC code, and I would’ve had to teach
    how to write Angular code instead. Most importantly, one of the requirements I
    had going in was to show off how to do shared rendering, reusing the same logic
    in the server and the browser, to render your views across the stack, and Angular
    isn’t the best solution out there when you want to have both server-side and client-side
    rendering, as it wasn’t developed with that constraint in mind. We’ll explore
    shared rendering in [section 7.5](#ch07lev1sec5).
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: Angular引入了一些概念，一开始可能难以理解，我不想在书的剩余部分解释这些概念。我觉得Angular可能会妨碍教授如何编写MVC代码，我可能不得不教授如何编写Angular代码。最重要的是，我进入时的一个要求是展示如何进行共享渲染，在服务器和浏览器中重用相同的逻辑来渲染您的视图，跨越整个堆栈，而Angular并不是当您想要同时具有服务器端和客户端渲染时最好的解决方案，因为它并不是在这种限制下开发的。我们将在[第7.5节](#ch07lev1sec5)中探讨共享渲染。
- en: '|  |'
  id: totrans-675
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Understanding progressive enhancement**'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '**理解渐进增强**'
- en: Progressive enhancement is a technique that helps deliver a usable experience
    to everyone who uses your site. The technique suggests that you prioritize content,
    and then progressively add enhancements, such as additional functionality, to
    the content. Applications that are progressively enhanced must therefore serve
    the full content of a page without depending on client-side JavaScript to render
    the view. Once that minimally digestible content is provided to the user, the
    experience may be enhanced gradually by detecting the features available to the
    user’s browser. After that initial experience is provided, we may then provide
    a single-page application experience by means of client-side JavaScript.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 渐进增强是一种技术，它帮助为使用您网站的每个人提供可用的体验。这种技术建议您优先考虑内容，然后逐步添加增强功能，例如额外的功能，到内容中。因此，渐进增强的应用程序必须提供页面的全部内容，而不依赖于客户端JavaScript来渲染视图。一旦向用户提供这种最小化可消化的内容，就可以通过检测用户浏览器可用的功能来逐步增强体验。在提供这种初始体验之后，我们可能通过客户端JavaScript提供单页应用程序体验。
- en: Developing applications under this philosophy has several benefits. Because
    you’re prioritizing content, everyone visiting your site can get the minimal experience.
    This doesn’t mean that people who have JavaScript disabled can view your site,
    but that people who are data roaming on mobile networks can see the content faster.
    Furthermore, if the requests for the JavaScript assets fail to load, at least
    they’ll have access to a readable version of your website.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种哲学下开发应用程序有几个好处。因为您优先考虑内容，所以访问您网站的每个人都可以获得基本体验。这并不意味着禁用JavaScript的人可以查看您的网站，但意味着在移动网络上数据漫游的人可以更快地看到内容。此外，如果JavaScript资源的请求加载失败，至少他们可以访问您网站的可读版本。
- en: You can read more about progressive enhancement on my blog at [http://ponyfoo.com/articles/tagged/progressive-enhancement](http://ponyfoo.com/articles/tagged/progressive-enhancement).
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在我的博客上阅读更多关于渐进增强的内容，请访问 [http://ponyfoo.com/articles/tagged/progressive-enhancement](http://ponyfoo.com/articles/tagged/progressive-enhancement)。
- en: '|  |'
  id: totrans-680
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: React introduces more complexity than Backbone does, and it doesn’t provide
    a true MVC solution the way Angular and Backbone does. React helps you write your
    views, giving you templating capabilities, but it involves more work on your part
    if you want to use it exclusively as your MVC engine.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: React 引入的复杂性比 Backbone 更高，并且它不像 Angular 和 Backbone 那样提供真正的 MVC 解决方案。React 帮助你编写视图，提供模板化功能，但如果你想将其作为
    MVC 引擎独家使用，则需要你做更多的工作。
- en: Backbone is easier to learn progressively. You don’t need to use every feature
    in it to build a simple application. As you make progress, you can add more components
    and include extra features in Backbone, such as routing, but you won’t need to
    even know about those features until you need them.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone 更容易渐进式学习。你不需要使用其中的每个功能来构建一个简单的应用程序。随着你的进步，你可以在 Backbone 中添加更多组件，并包含额外的功能，如路由，但你甚至不需要知道这些功能，直到你需要它们。
- en: 7.2.2\. Installing Backbone
  id: totrans-683
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.2\. 安装 Backbone
- en: In [chapter 5](kindle_split_017.html#ch05), you wrote your client-side code
    using CommonJS. Later, you’ll compile those modules so that browsers can interpret
    them. The next section is dedicated to laying down an automated compilation process
    using Grunt and Browserify. For now, let’s talk about Backbone. The first thing
    you’ll do is install it through npm, as shown here.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](kindle_split_017.html#ch05)中，你使用 CommonJS 编写了客户端代码。稍后，你将编译这些模块，以便浏览器可以解释它们。下一节将专门介绍使用
    Grunt 和 Browserify 实现自动化编译过程。现在，让我们谈谈 Backbone。你首先要做的是通过 npm 安装它，如下所示。
- en: Remember, if you don’t have a `package.json` file, you should create one using
    `npm init.` Check out [appendix A](kindle_split_022.html#app01) on Node.js applications
    if you get stuck.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果你没有 `package.json` 文件，你应该使用 `npm init.` 命令创建一个。如果你在 Node.js 应用程序方面遇到困难，请查看[附录
    A](kindle_split_022.html#app01)。
- en: '[PRE86]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Backbone needs a DOM manipulation library such as jQuery or Zepto to function
    properly. You’ll use jQuery in your examples, because it’s more widely known.
    I recommend you look at Zepto if you’re considering this setup for a production-grade
    application, as it has a significantly smaller footprint. Let’s go ahead and install
    jQuery as well:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone 需要一个 DOM 操作库，如 jQuery 或 Zepto，才能正常工作。在你的示例中，你将使用 jQuery，因为它更广为人知。如果你考虑将此设置用于生产级应用程序，我建议你查看
    Zepto，因为它具有显著更小的体积。让我们继续安装 jQuery：
- en: '[PRE87]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Once you have both Backbone and jQuery, you can start putting together the
    application. The first few lines of code you’ll write are to set up your Backbone
    library. Backbone expects a jQuery-like library to be assigned to `Backbone.$`
    before you use it, so you’ll need to give it that:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了 Backbone 和 jQuery，你就可以开始组装应用程序了。你将要编写的第一行代码是用来设置你的 Backbone 库。Backbone
    需要在使用之前将一个类似 jQuery 的库分配给 `Backbone.$`，所以你需要这样做：
- en: '[PRE88]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Backbone will use jQuery to interact with the DOM, attach and remove event handlers,
    and perform AJAX requests. That’s all there is to getting up and running.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone 将使用 jQuery 与 DOM 交互，附加和删除事件处理器，以及执行 AJAX 请求。这就是启动和运行的所有内容。
- en: It’s time to see Browserify in action! I’ll walk you through setting up Grunt
    to compile the code for the browser. Once that’s out of the way, you can make
    your way through the examples in the next few sections.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候看看 Browserify 的实际应用了！我将带你通过设置 Grunt 来编译浏览器代码。一旦这个问题解决，你就可以浏览下一节中的示例。
- en: 7.2.3\. Browserifying your Backbone module with Grunt
  id: totrans-693
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.3\. 使用 Grunt Browserify Backbone 模块
- en: You already touched on how to Browserify modules in [chapter 5](kindle_split_017.html#ch05),
    [section 5.3.3](kindle_split_017.html#ch05lev2sec11). The following listing shows
    how the Gruntfile configuration for Browserify looked back then.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在[第 5 章](kindle_split_017.html#ch05)的[5.3.3 节](kindle_split_017.html#ch05lev2sec11)中接触到了如何使用
    Browserify 模块。以下列表显示了当时 Browserify 的 Gruntfile 配置。
- en: Listing 7.1\. Gruntfile configuration for Browserify
  id: totrans-695
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.1\. Browserify 的 Gruntfile 配置
- en: '[PRE89]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'This time around, let’s do two small tweaks to that configuration. The first
    tweak is because you want to watch for changes and have Grunt rebuild the bundle.
    This enables continuous, rapid development, as we addressed in [chapter 3](kindle_split_014.html#ch03).
    To watch for changes you can use `grunt-contrib-watch`, as we discussed in [chapter
    3](kindle_split_014.html#ch03), using configuration such as the one in the following
    code:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，让我们对那个配置进行两个小的调整。第一个调整是因为你想要监视变化并让Grunt重新构建包。这使我们能够实现持续、快速的开发，正如我们在第3章中讨论的那样。要监视变化，你可以使用我们在第3章中讨论的`grunt-contrib-watch`，使用如下代码中的配置：
- en: '[PRE90]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The `tasks` property contains any tasks that should run when the matched `files`
    change.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: '`tasks`属性包含任何在匹配的`files`发生变化时应运行的任务。'
- en: 'The other tweak uses something that’s called a transform. *Transforms* allow
    Browserify to change the source code in your modules, better adjusting it to your
    needs when it comes to running that code on the browser. In your case, the transform
    to include is called `brfs` for “Browser File System.” This transform inlines
    the results of `fs.readFileSync` calls, making it possible to keep the view templates
    separate from the JavaScript code. Consider the following module:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种调整使用了一种称为转换的东西。*转换*允许Browserify更改你的模块中的源代码，在将代码运行在浏览器上时更好地调整以满足你的需求。在你的情况下，要包含的转换被称为`brfs`，代表“浏览器文件系统”。这个转换将`fs.readFileSync`调用的结果内联，使得将视图模板与JavaScript代码分离成为可能。考虑以下模块：
- en: '[PRE91]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'That piece of code couldn’t be transformed to run in the browser because the
    browser doesn’t have access to files in your server’s file system. To work around
    that issue, you can use `brfs` by adding it to the list of transforms in your
    Grunt configuration options for `grunt-browserify.` The `brfs` transform will
    read files referenced by `fs.readFile` and `fs.readFileSync` statements and inline
    them in your bundle, allowing them to work seamlessly in either Node or the browser:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 那段代码无法转换以在浏览器中运行，因为浏览器无法访问你的服务器文件系统中的文件。为了解决这个问题，你可以在Grunt配置选项中添加`brfs`到`grunt-browserify`的转换列表中。`brfs`转换将读取由`fs.readFile`和`fs.readFileSync`语句引用的文件，并将它们内联到你的包中，使得它们可以在Node或浏览器中无缝工作：
- en: '[PRE92]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'You’ll also need to install the `brfs` package from npm in your local project,
    with the following code:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要在你的本地项目中安装`brfs`包，以下代码为安装命令：
- en: '[PRE93]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: That’s it, as far as Browserifying your CommonJS modules with Grunt goes! Next
    up, I’ll introduce you to the major concepts in Backbone, how they work, and when
    to use them.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了，关于使用Grunt Browserify你的CommonJS模块！接下来，我将向你介绍Backbone的主要概念，它们是如何工作的，以及何时使用它们。
- en: 7.3\. Introduction to Backbone
  id: totrans-707
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3\. Backbone简介
- en: 'A few constructs exist in Backbone that you can build your applications around.
    Here’s a list:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone中存在一些结构，你可以围绕它们构建你的应用程序。以下是一个列表：
- en: Views render the UI and deal with human interaction.
  id: totrans-709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图负责渲染UI并处理人机交互。
- en: Models can be used to track, compute, and validate properties.
  id: totrans-710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型可以用来跟踪、计算和验证属性。
- en: Collections are ordered sets of models, useful for interacting with lists.
  id: totrans-711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合是有序的模型集合，用于与列表交互。
- en: Routers allow you to control the URL, enabling development of single-page applications.
  id: totrans-712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器允许你控制URL，从而能够开发单页应用程序。
- en: You might’ve noticed that controllers are nowhere to be found in that list.
    In reality, Backbone views act as controllers. This subtle fork from traditional
    MVC is often referred to as Model-View-View-Model (MVVM). [Figure 7.3](#ch07fig03)
    illustrates the differences between Backbone and traditional MVC, as they were
    shown in [figure 7.2](#ch07fig02), and explains where routing fits in this structure.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到列表中找不到控制器。实际上，Backbone视图充当控制器。这种从传统MVC中微妙的偏离通常被称为模型-视图-视图-模型（MVVM）。[图7.3](#ch07fig03)说明了Backbone与传统MVC之间的差异，正如它们在第7.2节[图7.2](#ch07fig02)中所示，并解释了路由在这个结构中的位置。
- en: 'Figure 7.3\. Backbone deals with the human-facing aspects of MVC: event handling,
    validation, and UI rendering.'
  id: totrans-714
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.3\. Backbone处理MVC中面向人类的部分：事件处理、验证和UI渲染。
- en: '![](07fig03_alt.jpg)'
  id: totrans-715
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig03_alt.jpg)'
- en: Naturally, there’s more to learn about each one of these constructs. Let’s visit
    each one.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，关于这些结构中的每一个，都有更多东西可以学习。让我们逐一访问它们。
- en: 7.3.1\. Backbone views
  id: totrans-717
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.1\. Backbone视图
- en: The views are in charge of rendering the UI, and you’re in charge of putting
    together the rendering logic for your views. How to render the UI is entirely
    up to you. The two preferred options are using jQuery or a templating library.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 视图负责渲染UI，而你则负责为你的视图组合渲染逻辑。如何渲染UI完全取决于你。两种首选的选项是使用jQuery或模板库。
- en: Views are always associated with an element, which is where the rendering will
    take place. In the following listing, let’s see how a basic view could be rendered.
    Here you’re creating a Backbone view, adding custom render functionality that
    will set text in the view element. Then you’re instantiating the view and rendering
    the view instance.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 视图总是与一个元素相关联，渲染将在这里进行。在下面的列表中，让我们看看一个基本视图是如何被渲染的。在这里，你创建了一个Backbone视图，添加了自定义的渲染功能，这将设置视图元素中的文本。然后你实例化了视图并渲染了视图实例。
- en: Listing 7.2\. Rendering a basic view
  id: totrans-720
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.2\. 渲染基本视图
- en: '[PRE94]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'See how you declared the `el` property and assigned `.view` to it? You can
    assign a CSS selector to that property, and it’ll look up that element in the
    DOM. In the view that element will get assigned to `this.el.` With an HTML page,
    such as the following one, you could render this minimal Backbone view:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 你看你是如何声明`el`属性并将其赋值为`.view`的吗？你可以将一个CSS选择器赋给这个属性，然后它会在DOM中查找这个元素。在这个视图中，这个元素将被分配给`this.el.`。使用一个HTML页面，例如以下页面，你可以渲染这个最小的Backbone视图：
- en: '[PRE95]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The bundle script file would be the compiled application as I explained in [section
    7.2.3](#ch07lev2sec10). Once you run this, the view element would get the `foo`
    text content. You can check out this example in the accompanying source code;
    it’s listed as ch07/01_backbone-views.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前在[7.2.3节](#ch07lev2sec10)中解释的，捆绑脚本文件将是编译后的应用程序。一旦运行，视图元素将获得`foo`文本内容。你可以在配套的源代码中查看这个示例；它列在ch07/01_backbone-views中。
- en: Your view is static as it is, and you probably have a good idea how to render
    one with jQuery, but that involves more work, because you’d have to create every
    element, set their attributes, and construct a DOM tree in code. Using templates
    is easier to maintain and keeps your concerns separate. Let’s see how that works.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 你的视图是静态的，你可能已经知道如何使用jQuery渲染一个视图，但这需要更多的工作，因为你必须创建每个元素，设置它们的属性，并在代码中构建一个DOM树。使用模板更容易维护，并且可以将你的关注点分开。让我们看看它是如何工作的。
- en: Using Mustache templates
  id: totrans-726
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用Mustache模板
- en: Mustache is a view-templating library that takes a template string and a view
    model and returns the resulting view. The way you reference model values in your
    template is by declaring them using the special `{{value}}` notation, which is
    replaced by the model’s `value` property.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: Mustache是一个视图模板库，它接受一个模板字符串和一个视图模型，并返回生成的视图。你在模板中引用模型值的方式是通过使用特殊的`{{value}}`符号来声明它们，这个符号将被模型的`value`属性所替换。
- en: Mustache also uses a similar syntax that lets you iterate through arrays, wrapping
    part of the template in `{{#collection}}` and `{{/collection}}`. When looping
    a collection, you can access the array item itself using `{{.}},` and you can
    also directly access its properties.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: Mustache还使用类似的语法，允许你遍历数组，将模板的一部分包裹在`{{#collection}}`和`{{/collection}}`中。当遍历一个集合时，你可以使用`{{.}}`访问数组项本身，你也可以直接访问它的属性。
- en: 'To give you a quick example, let’s start with an HTML view template:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给你一个快速示例，让我们从一个HTML视图模板开始：
- en: '[PRE96]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'To fill this template, you need to use Mustache, passing it to a model. First,
    you’ll have to install Mustache from npm:'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 为了填充这个模板，你需要使用Mustache，将其传递给一个模型。首先，你将不得不从npm安装Mustache：
- en: '[PRE97]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Rendering this template is a matter of passing it to Mustache as a string,
    along with a view model:'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染这个模板只是将其作为一个字符串传递给Mustache，以及一个视图模型：
- en: '[PRE98]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'To do this in Backbone you’ll create a reusable module, shown in the following
    code snippet, which will know to render any view using Mustache, passing it to
    the view’s template and the view’s view model. Here you’re creating a base view
    you can let other views inherit from, sharing basic functionality such as view
    rendering, so that you don’t have to copy and paste this method onto every view
    you create:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 在Backbone中做这件事，你需要创建一个可重用的模块，如下面的代码片段所示，它将知道如何使用Mustache渲染任何视图，将视图的模板和视图的视图模型传递给它。在这里，你创建了一个可以供其他视图继承的基础视图，共享基本功能，如视图渲染，这样你就不必在每个创建的视图中复制和粘贴这个方法：
- en: '[PRE99]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: In the previous example, where you had a static view, it was fine to keep all
    of your application in a single module. But this time around, you’re modularizing
    it a bit. Having a base view is neat, and having a single module for each view
    is as important. In the snippet below, you’re requiring the base view template
    you saw previously and extending that one. You’re using `fs.readFileSync` to load
    your Mustache template, because `require` only works with JavaScript and JSON
    files. You won’t include the template in the view module itself because it’s always
    nice to keep your concerns separated, particularly if these concerns are in different
    languages. Also, the view template could arguably be used by many different views.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，你有一个静态视图，将所有应用程序放在一个模块中是完全可以的。但这次，你稍微模块化了它。有一个基本视图是很好的，为每个视图有一个单独的模块同样重要。在下面的代码片段中，你正在要求之前看到的基视图模板并扩展它。你使用
    `fs.readFileSync` 来加载你的 Mustache 模板，因为 `require` 只适用于 JavaScript 和 JSON 文件。你不会在视图模块本身中包含模板，因为这总是很好地将你的关注点分开，尤其是如果这些关注点在不同的语言中。此外，视图模板可能被许多不同的视图使用。
- en: '[PRE100]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Last, you’ll adapt your original application module, making it require the view
    rather than declare it, and declaring a view model before rendering the view.
    This time around, the view will be rendered with Mustache, as shown in the following
    listing.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要调整你的原始应用程序模块，使其需要视图而不是声明视图，并在渲染视图之前声明视图模型。这一次，视图将通过 Mustache 渲染，如下面的列表所示。
- en: Listing 7.3\. Rendering a view with Mustache
  id: totrans-740
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.3\. 使用 Mustache 渲染视图
- en: '[PRE101]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: You can check out this example in the accompanying code samples; it’s listed
    as ch07/02_backbone-view-templates. Next up are the models, another crucial part
    of Backbone applications.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在附带的代码示例中查看这个示例；它在 ch07/02_backbone-view-templates 中列出。接下来是模型，Backbone 应用程序的另一个关键部分。
- en: 7.3.2\. Creating Backbone models
  id: totrans-743
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.2\. 创建 Backbone 模型
- en: Backbone models (also called data models) hold your application data, which
    are often copies of the data that can be found in a database. They can be used
    to observe changes, as well as validate those changes. These aren’t to be confused
    with view models (such as what we’ve assigned to `sampleView.viewModel` in the
    previous example, also called template data), which usually contain a combination
    of Backbone data models, often formatted to fit the prose in the HTML template.
    For instance, a date might be stored in an ISO format in the data model, but formatted
    into a human-readable string in the template data. In the same way views get extended
    off `Backbone.View`, models get extended from `Backbone.Model`, and they can go
    a great way toward making your data interactive. Models can be validated, testing
    user input for bad data; they can be observed, helping you react to changes in
    the data model; and you can also compute properties based on data in the model.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone 模型（也称为数据模型）存储你的应用程序数据，这些数据通常是数据库中可以找到的数据的副本。它们可以用来观察变化，以及验证这些变化。这些不要与视图模型（例如我们在上一个示例中分配给
    `sampleView.viewModel` 的视图模型，也称为模板数据）混淆，视图模型通常包含 Backbone 数据模型的组合，通常格式化为适合 HTML
    模板的文本。例如，日期可能以 ISO 格式存储在数据模型中，但在模板数据中格式化为可读的字符串。同样，视图从 `Backbone.View` 扩展，模型从
    `Backbone.Model` 扩展，它们可以大大提高你的数据交互性。模型可以进行验证，测试用户输入的坏数据；它们可以观察，帮助你响应数据模型中的变化；你还可以根据模型中的数据计算属性。
- en: Probably the most impactful thing you can do with your models is observing changes
    in the model data. This allows your UI to react to changes in the data with little
    effort. Remember, the same piece of data can be represented in many different
    ways. For instance, you could represent the same piece of data as an item in a
    list, as an image, or as a description. Models enable you to update each of those
    representations as data changes, in real time!
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用你的模型做的最有影响力的事情可能是观察模型数据的变化。这允许你的用户界面几乎不费吹灰之力地对数据的变化做出反应。记住，同一份数据可以用许多不同的方式表示。例如，你可以将同一份数据表示为列表中的一个条目、一张图片或一个描述。模型使你能够实时更新这些表示，随着数据的变化而变化！
- en: Data modeling and malleability
  id: totrans-746
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 数据建模和可塑性
- en: Let’s look at an example (found under ch07/03_backbone-models in the samples)
    where you take a piece of user input and render it as plain text, in binary, and
    as an anchor link, if it’s a URL. To kick things off, you’ll create a model to
    check whether its data looks like a link. The `get` method allows you to access
    the value of a model property in Backbone.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子（在`samples/ch07/03_backbone-models`中找到），在这个例子中，你将用户输入的内容渲染为纯文本、二进制格式，如果它是URL，则渲染为锚点链接。为了开始，你需要创建一个模型来检查其数据是否看起来像链接。`get`方法允许你在Backbone中访问模型属性的值。
- en: '[PRE102]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Assuming you had a `binary.fromString` method to convert the model data to
    a binary string, and you wanted to get the first few characters of the binary
    stream, you could add a model method for that, because it’s also data-related.
    As a rule of thumb, every method that could be reused that depends solely (or
    mostly) on model data should probably be a model method. The following is a possible
    implementation to get the binary string. If the binary code is more than 20 characters,
    you can trim it using the Unicode ellipsis character, `''\u2026''` or `''...''`:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个`binary.fromString`方法来将模型数据转换为二进制字符串，并且你想要获取二进制流的第一个几个字符，你可以为这个添加一个模型方法，因为它也涉及到数据。一般来说，每个可以重用且仅（或主要）依赖于模型数据的方法可能都应该是一个模型方法。以下是一个获取二进制字符串的可能实现。如果二进制代码超过20个字符，你可以使用Unicode省略号字符`'\u2026'`或`'...'`进行截断：
- en: '[PRE103]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: I mentioned you could listen for changes in your models. Let’s learn more about
    events.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到你可以监听模型中的变化。让我们更深入地了解事件。
- en: Models and events
  id: totrans-752
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 模型和事件
- en: 'To tie your view to this model, you need to create an instance of the model.
    One of the most interesting aspects of models is events. For example, you could
    listen for changes in the model and update your view every time the model changes.
    You can use the view’s `initialize` property to create a model instance, bind
    your change listener to it, and give the model an initial value, as shown in the
    following code snippet:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的视图与该模型关联，你需要创建该模型的一个实例。模型最有趣的特点之一是事件。例如，你可以监听模型中的变化，并在模型每次发生变化时更新你的视图。你可以使用视图的`initialize`属性来创建模型实例，将其绑定到变化监听器上，并给模型提供一个初始值，如下面的代码片段所示：
- en: '[PRE104]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Instead of rendering the view from the outside, the view will rerender itself
    as necessary whenever the model changes. It turns out that’s easy to implement.
    Whenever the model changes, `updateView` is invoked, and you have a chance to
    update the view model and render the template with the updated values.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是从外部渲染视图，视图将在模型发生变化时根据需要自行重新渲染。实际上，这很容易实现。每当模型发生变化时，`updateView`会被调用，你就有机会更新视图模型并使用更新后的值渲染模板。
- en: '[PRE105]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'All that’s left for your view to do is allow user input to modify the model.
    You can conveniently bind to DOM events by adding properties to the `events` property
    on the view. These properties should have a key in the form of `{event-type} {element-selector}`;
    for example, `click .submit-button`. The property value should be the name of
    an event handler that’s available in the view. In the following code snippet,
    I implement an event handler that updates the model every time the input changes:'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 你视图剩下的工作就是允许用户输入修改模型。你可以通过在视图的`events`属性上添加属性来方便地绑定到DOM事件。这些属性应该具有`{event-type}
    {element-selector}`形式的键；例如，`click .submit-button`。属性值应该是视图中可用的事件处理器的名称。在以下代码片段中，我实现了一个事件处理器，每次输入更改时都会更新模型：
- en: '[PRE106]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Whenever a change event is raised, the model data will be updated. That will,
    in turn, trigger the model’s change event listener, which will update the view
    model and refresh the UI. Keep in mind that if anything else changed the model
    data, such as incoming server data, that would refresh the UI accordingly as well.
    That’s where the value of using models comes from. As your data gets more complex,
    you can benefit more from using models to access it, because they’re equipped
    to track and react to changes in the data in such a way that your code isn’t tightly
    coupled.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 每当触发一个变化事件时，模型数据将被更新。这反过来会触发模型的变化事件监听器，它将更新视图模型并刷新UI。请注意，如果其他任何东西改变了模型数据，例如传入的服务器数据，UI也会相应地刷新。这就是使用模型的价值所在。随着你的数据变得更加复杂，你可以从使用模型来访问数据中受益更多，因为它们能够跟踪并响应数据的变化，这样你的代码就不会紧密耦合。
- en: This is one of the ways in which models help shape your data without repeating
    logic in your code, and we’ll closely inspect the benefits of models, such as
    data validation, over the next few sections. One last aspect of data organization
    you’ll want to look at is collections. Let’s get a quick overview of those before
    heading to view routing.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 这是模型帮助塑造你的数据而不在代码中重复逻辑的一种方式，在接下来的几节中，我们将仔细检查模型的好处，如数据验证。你还需要关注数据组织的最后一个方面，那就是集合。在我们转向视图路由之前，让我们快速了解一下这些内容。
- en: 7.3.3\. Organizing models with Backbone collections
  id: totrans-761
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.3\. 使用Backbone集合组织模型
- en: Collections in Backbone enable you to group and order a set of models. You can
    listen for items being added or removed from the collection, and you can even
    get notified when any model in the collection is modified. In the same way models
    are helpful in computing data out of their properties, collections are concerned
    with finding specific models in addition to dealing with CRUD-like (Create Read
    Update Delete) operations.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone中的集合允许你分组和排序一组模型。你可以监听集合中项的添加或移除，甚至可以在集合中的任何模型被修改时收到通知。同样，模型在计算其属性中的数据时很有帮助，集合除了处理类似CRUD（创建、读取、更新、删除）的操作外，还关注于查找特定的模型。
- en: 'A collection takes a model type so that you can add values to it using plain
    objects, which get converted internally into that model type. The collection created
    in the following snippet, for example, would create `SampleModel` instances whenever
    you added an item to it. The collections example can be found at ch07/04_backbone-collections:'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 集合需要一个模型类型，这样你就可以使用普通对象向其中添加值，这些值在内部被转换为该模型类型。例如，在下面的代码片段中创建的集合，每次你向其中添加项时都会创建`SampleModel`实例。集合的示例可以在ch07/04_backbone-collections找到。
- en: '[PRE107]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Similarly to models or views, collections need to be instantiated for you to
    take advantage of them. To keep this example short, your view will create an instance
    of this collection, listen for insertions, and add models to the collection. The
    `toJSON` method casts your collection to a plain JavaScript object that can be
    used to fetch model data when rendering a template, as shown in the following
    listing.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 与模型或视图类似，集合需要被实例化，你才能利用它们。为了使这个例子简短，你的视图将创建这个集合的实例，监听插入操作，并将模型添加到集合中。`toJSON`方法将你的集合转换为普通的JavaScript对象，可以在渲染模板时用于获取模型数据，如下面的列表所示。
- en: Listing 7.4\. Fetching model data
  id: totrans-766
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.4\. 获取模型数据
- en: '[PRE108]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Collections can also validate models as they’re inserted, as you’ll see in [section
    7.4](#ch07lev1sec4). There’s one last item on your checklist before getting there,
    though. I’m talking about Backbone routers.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 集合也可以在插入模型时对其进行验证，正如你将在[第7.4节](#ch07lev1sec4)中看到的。但在到达那里之前，你的清单上还有最后一项。我指的是Backbone路由器。
- en: 7.3.4\. Adding Backbone routers
  id: totrans-769
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.4\. 添加Backbone路由器
- en: 'Modern web applications are increasingly becoming single-page applications,
    meaning that the site is loaded once, which results in fewer round-trips to the
    server, and the client-side code takes over. Routing on the client side can be
    handled by either changing what comes after the hash in the URL or using paths
    such as `#/users` or `#/users/13`. In modern browsers, it can be modified using
    the History API, which allows you to change the URL without resorting to the hash
    hack, resulting in cleaner-looking links, as if the site was getting the pages
    from the server. In Backbone, you can define and instantiate routers that serve
    two purposes: changing the URL to give the human a permanent link they can use
    to navigate to a part of your application, and taking action when the URL changes.'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 现代Web应用程序越来越多地成为单页应用程序，这意味着网站只加载一次，这导致服务器往返次数减少，客户端代码接管。客户端的路由可以通过更改URL中的hash后面的内容或使用路径如`#/users`或`#/users/13`来处理。在现代浏览器中，可以使用History
    API来修改，这允许你更改URL而不必求助于hash hack，从而产生更干净的链接，就像网站从服务器获取页面一样。在Backbone中，你可以定义和实例化路由器，它们有两个作用：更改URL以给人类提供一个永久链接，他们可以使用它来导航到应用程序的一部分，以及当URL更改时采取行动。
- en: '[Figure 7.4](#ch07fig04) shows how a router can track your application’s state.'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7.4](#ch07fig04)显示了路由器如何跟踪应用程序的状态。'
- en: Figure 7.4\. Routing in Backbone and the route inspector
  id: totrans-772
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.4\. Backbone中的路由和路由检查器
- en: '![](07fig04_alt.jpg)'
  id: totrans-773
  prefs: []
  type: TYPE_IMG
  zh: '![07fig04_alt.jpg](07fig04_alt.jpg)'
- en: As you learned in [section 7.1](#ch07lev1sec1), routers are the first human
    contact in your application. Traditional routers define rules that route requests
    to particular controller actions. In the case of Backbone, the controller intermediary
    doesn’t exist, and requests are routed directly to views, which play the role
    of the controller as well as provide the view templates and rendering logic. The
    Backbone router inspects the `location` for changes and invokes action methods,
    providing them with relevant URL parameters.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[第7.1节](#ch07lev1sec1)中学到的，路由器是应用程序中人类接触的第一步。传统的路由器定义规则将请求路由到特定的控制器动作。在Backbone的情况下，控制器中介不存在，请求直接路由到视图，视图既扮演控制器的角色，也提供视图模板和渲染逻辑。Backbone路由器检查`location`的变化并调用动作方法，向它们提供相关的URL参数。
- en: Route Changes
  id: totrans-775
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 路由更改
- en: 'The following code snippet (available as ch07/05_backbone-routing) instantiates
    a view router and uses `Backbone.history.start` to begin monitoring the URL for
    changes. It’ll also check the current URL to see if it matches one of the routes
    that have been defined, and in that case it’ll trigger that route:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段（作为ch07/05_backbone-routing提供）实例化了一个视图路由器，并使用`Backbone.history.start`开始监控URL的变化。它还会检查当前URL是否与已定义的某个路由匹配，如果是，则触发该路由：
- en: '[PRE109]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: That’s all you need to do as far as wiring goes. Let’s write your `ViewRouter`
    component now.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 就线路连接而言，你需要做的就这些。现在让我们编写你的`ViewRouter`组件。
- en: A routing module
  id: totrans-779
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 路由模块
- en: 'Routers are in charge of connecting each URL to an action. Typically, you’ll
    build your application so that the action method either prepares a view and renders
    it, or does something that renders a view, such as navigating to a different route.
    In the following snippet I’m creating a router with different routes:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器负责将每个URL连接到动作。通常，你会构建你的应用程序，使得动作方法要么准备一个视图并渲染它，要么执行一些渲染视图的操作，例如导航到不同的路由。在以下代码片段中，我创建了一个具有不同路由的路由器：
- en: '[PRE110]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The first route, when humans visit the application root, triggers them to redirect
    to the default route, as indicated in the following snippet. In this case, that’s
    the `items` route. This ensures that the user won’t be left stranded if they visit
    the page at the root level rather than at `#items`, or `/items` if you’re using
    the history API. The `trigger` option tells `navigate` to change the URL and trigger
    the action method for that route. Next we should add the `root` method to the
    object passed to `Backbone .Router.extend`:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 当人类访问应用程序根目录时，第一条路由会触发他们重定向到默认路由，如下面的代码片段所示。在这种情况下，那就是`items`路由。这确保了如果用户在根级别而不是在`#items`或`/items`（如果你使用历史API）访问页面，他们不会迷路。`trigger`选项告诉`navigate`更改URL并触发该路由的动作方法。接下来，我们应该将`root`方法添加到传递给`Backbone.Router.extend`的对象中：
- en: '[PRE111]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'As long as all of your views get rendered to the same view container, it could
    suffice to instantiate the view when a particular action is triggered, such as
    in the following snippet:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 只要所有视图都渲染到相同的视图容器中，在特定动作触发时实例化视图就足够了，如下面的代码片段所示：
- en: '[PRE112]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'You’d have to `require` the view at the top of your routing module, like this:'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在路由模块的顶部`require`视图，如下所示：
- en: '[PRE113]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Last, you might notice that the `getItemById` route has a named parameter in
    the form of `:id.` The router will parse the URL in views, match the `items/:id`
    pattern, and call your action method passing in the `id` as a parameter. Then,
    it’s a matter of using that parameter when rendering the view.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可能注意到`getItemById`路由有一个名为`:id`的命名参数。路由器将在视图中解析URL，匹配`items/:id`模式，并调用你的动作方法，将`id`作为参数传递。然后，在渲染视图时使用该参数。
- en: '[PRE114]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: That’s all there is to view routing! In [section 7.4](#ch07lev1sec4) you’ll
    expand on all of these concepts to build a small application. Next up, let’s investigate
    how to use your newfound Backbone knowledge to build your first application with
    MVC in the browser.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是视图路由的全部内容！在[第7.4节](#ch07lev1sec4)中，你将扩展所有这些概念来构建一个小型应用程序。接下来，让我们调查如何使用你新学到的Backbone知识在浏览器中构建第一个使用MVC的应用程序。
- en: '7.4\. Case study: the shopping list'
  id: totrans-791
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4. 案例研究：购物清单
- en: Before you run off and develop your own applications, I want to give you a self-contained
    example of how to write MVC in the browser using Backbone, putting into practice
    everything you’ve learned so far in this chapter.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始开发自己的应用程序之前，我想给你一个使用Backbone在浏览器中编写MVC的独立示例，将本章中到目前为止所学的一切付诸实践。
- en: In this section you’ll progressively build a simple shopping list application,
    which allows you to view shopping list items, remove them from the list, add new
    ones, and change the quantities. I’ve divided the exercise into five stages. At
    each stage, you’ll add functionality and refactor what you have so far to keep
    your code tidy. The five stages are
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将逐步构建一个简单的购物清单应用程序，该应用程序允许您查看购物清单项目、从列表中删除它们、添加新的项目以及更改数量。我已经将练习分为五个阶段。在每一个阶段，您将添加功能并对到目前为止的内容进行重构，以保持代码整洁。这五个阶段是
- en: Creating a static view with shopping list items
  id: totrans-794
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建带有购物清单项目的静态视图
- en: Adding remove buttons for deleting items
  id: totrans-795
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加删除按钮以删除项目
- en: Building a form to add new items to your shopping list
  id: totrans-796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个表单以添加新的购物清单项目
- en: Implementing inline editing on the list to change the quantities
  id: totrans-797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列表中实现内联编辑以更改数量
- en: Adding view routing
  id: totrans-798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加视图路由
- en: That sounds like fun! Keep in mind that you have access to the code at any of
    these five stages in the accompanying code samples.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来很有趣！请记住，您可以在附带的代码示例中的任何五个阶段访问代码。
- en: 7.4.1\. Starting with a static shopping list
  id: totrans-800
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.1\. 从静态购物清单开始
- en: Let’s go back to basics and put the application together from scratch. The Gruntfile
    remains the same as it was back in [section 7.2.3](#ch07lev2sec10), and it won’t
    change during the course of this case study, so you don’t need to revisit it.
    Look at the HTML in [listing 7.5](#ch07ex05) (available as ch07/06_shopping-list)
    to get started. Note that you’re including the built Browserify bundle to get
    the Common.js code working in the browser. The `<div>` will act as your view container
    in this example. This piece of HTML is called `app.html`, because it’s the single
    page the application will run on.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到基础，从头开始构建应用程序。Gruntfile 与 [7.2.3 节](#ch07lev2sec10) 中的相同，在本案例研究的过程中不会改变，所以您不需要重新访问它。查看
    [列表 7.5](#ch07ex05) 中的 HTML（作为 ch07/06_shopping-list 提供）以开始。请注意，您正在包含构建的 Browserify
    包，以便在浏览器中运行 Common.js 代码。在这个例子中，`<div>` 将作为视图容器。这个 HTML 片段被称为 `app.html`，因为它是应用程序将运行的单一页面。
- en: Listing 7.5\. Creating the shopping list
  id: totrans-802
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.5\. 创建购物清单
- en: '[PRE115]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Next up, this example needs to render a list of shopping items, displaying the
    quantity and name of each item. Here’s a Mustache snippet that can render an array
    of shopping list items. Mustache templates will go into the `views/templates`
    directory.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，这个示例需要渲染购物项目列表，显示每个项目的数量和名称。这里有一个可以渲染购物清单项目数组的 Mustache 片段。Mustache 模板将放入
    `views/templates` 目录。
- en: '[PRE116]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Your views will need to render these templates using a view model. This functionality
    should go in a base view so that it’s only implemented once.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 您的视图需要使用视图模型来渲染这些模板。这个功能应该放在基本视图中，以确保它只实现一次。
- en: Rendering views with Mustache
  id: totrans-807
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 Mustache 渲染视图
- en: To easily render Mustache templates in your views and to avoid repetition, you’ll
    wire up a base view and place it in the `views` directory. The rest of your views
    will extend this one, allowing you to add functionality that gets shared across
    every view. If a view needs to be rendered in another way, that’s okay; you can
    override the `render` method again.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在视图中轻松渲染 Mustache 模板并避免重复，您将连接一个基本视图并将其放置在 `views` 目录中。您的其余视图将扩展这个视图，允许您添加跨每个视图共享的功能。如果视图需要以其他方式渲染，那也是可以的；您可以再次覆盖
    `render` 方法。
- en: '[PRE117]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Next you’ll create items for your List view.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将为您的列表视图创建项目。
- en: The shopping list view
  id: totrans-811
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 购物清单视图
- en: A static shopping list of items will suffice for now, which is why in the following
    listing you can set the view model object once and forget about it. Note the `initialize`
    method, which runs when the view gets instantiated so that the view renders itself
    when it’s created. This view uses the template you saw previously and targets
    the `.view` element in `app.html`.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 目前一个静态的购物清单就足够了，这就是为什么在下面的列表中，您可以设置一次视图模型对象并忘记它。注意 `initialize` 方法，它在视图实例化时运行，以便在创建时视图会自行渲染。这个视图使用您之前看到的模板，并针对
    `app.html` 中的 `.view` 元素。
- en: Listing 7.6\. Creating a list of items
  id: totrans-813
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.6\. 创建项目列表
- en: '[PRE118]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Last, you need to initialize the application. Here’s the entry point code where
    you create an instance of the List view after initializing Backbone. Note that
    because the view renders itself, you only have to instantiate it.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要初始化应用程序。这是入口点代码，在初始化 Backbone 后创建 List 视图的实例。请注意，因为视图会自行渲染，所以您只需要实例化它。
- en: '[PRE119]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: You’ve laid out the ground work for a shopping list application. Let’s build
    on that in the next stage. You’ll add delete buttons and refactor to accommodate
    a dynamic application where the data can change.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经为购物清单应用程序奠定了基础。让我们在下一阶段在此基础上构建。你将添加删除按钮，并重构以适应数据可以变化的应用程序。
- en: 7.4.2\. This time with remove buttons
  id: totrans-818
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.2. 这次带有删除按钮
- en: 'The first thing you’ll do at this stage is update the view template so that
    it includes buttons to remove items from the shopping list. You’ll set a `data-name`
    attribute on the buttons so you can identify which item should be removed from
    the list. The updated template can be found in the following snippet:'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你首先需要更新视图模板，使其包括从购物清单中移除项目的按钮。你将在按钮上设置一个 `data-name` 属性，以便你可以识别应该从列表中移除哪个项目。更新的模板可以在下面的代码片段中找到：
- en: '[PRE120]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Before wiring up the Remove button, you need to set up a proper model and a
    collection.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接删除按钮之前，你需要设置一个合适的模型和集合。
- en: Using a model and a collection
  id: totrans-822
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用模型和集合
- en: The collection will let you listen for changes to the list, such as when an
    item gets removed from the list. The model can be used to track changes at the
    individual level, and it allows you to do validation, as well as computation,
    as you’ll see in the next few stages. For your purposes, you don’t need much more
    than a standard Backbone model, but it’s always a good idea to keep your models
    strictly separated in different modules and well named. The `ShoppingItem` model
    will be in the `models` directory.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 这个集合将允许你监听列表的变化，例如当列表中的某个项目被移除时。该模型可以用于跟踪个体层面的变化，并且它允许你在接下来的几个阶段进行验证以及计算。就你的目的而言，你不需要比标准的
    Backbone 模型更多，但始终将你的模型严格分离在不同的模块中，并给予良好的命名是个好主意。`ShoppingItem` 模型将位于 `models`
    目录中。
- en: '[PRE121]'
  id: totrans-824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: The collection isn’t that special, either; it needs a reference to the model.
    That way, the collection will know what kind of model to create when inserting
    new objects into the list. To keep things neatly organized, you’ll place your
    collections in a `collections` directory.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 集合也没有那么特别；它需要一个对模型的引用。这样，集合就知道在将新对象插入列表时应该创建什么类型的模型。为了保持整洁的目录结构，你将你的集合放在 `collections`
    目录中。
- en: '[PRE122]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Rather than setting the view model once and forgetting about it, and now that
    you have both the model and the collection in place, you should change your view
    to use the collection instead. The first change you’ll make in your view will
    be to `require` the collection, as shown in the following code:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是设置一次视图模型就不再理会它，现在你已经有了模型和集合，你应该更改你的视图以使用集合。在你的视图中，你将做出的第一个更改是 `require` 集合，如下面的代码所示：
- en: '[PRE123]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Instead of the `viewModel` property, which you’ll set dynamically from now on,
    you’ll use a `collection` property to keep track of your models. Note that, as
    I mentioned previously, I don’t have to explicitly create `ShoppingList` instances
    for my collection, because it already knows that’s the model type it has to use.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用 `viewModel` 属性，从现在起你将动态设置它，你将使用 `collection` 属性来跟踪你的模型。请注意，正如我之前提到的，我不需要明确创建
    `ShoppingList` 实例，因为我的集合已经知道它必须使用该模型类型。
- en: '[PRE124]'
  id: totrans-830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Next, you’ll have the view update the UI when it first loads. To do that, you’ll
    set the view model to whatever is in the collection and then render the view.
    Using the `toJSON` method gives a plain array of model objects.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将让视图在首次加载时更新 UI。为此，你将设置视图模型为集合中的任何内容，然后渲染视图。使用 `toJSON` 方法会得到一个包含模型对象的普通数组。
- en: '[PRE125]'
  id: totrans-832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Last, you’ll wire up your shopping list item Remove button.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将连接你的购物清单项目删除按钮。
- en: Wiring up DOM events in Backbone
  id: totrans-834
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在 Backbone 中连接 DOM 事件
- en: To listen for DOM events, you can assign properties to an `events` object in
    your views. These properties should be named using an event name and a CSS selector,
    separated by a space. The following code is what you’ll use in your updated view.
    It’ll trigger an action whenever a `click` event occurs in an element matching
    the `.remove` selector. Keep in mind that these events look for elements inside
    your view `el`, in this case the `<div>` you created during the previous stage,
    and it won’t fire events for elements that are outside the view. Last, the event
    should be set to the name of a method that can be found in your view.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 要监听 DOM 事件，你可以在你的视图中为 `events` 对象分配属性。这些属性的命名应使用事件名称和 CSS 选择器，两者之间用空格分隔。以下是你将在更新后的视图中使用的代码。它会在匹配
    `.remove` 选择器的元素上发生 `click` 事件时触发一个动作。请注意，这些事件在视图 `el` 内部查找元素，在本例中是你在上一个阶段创建的
    `<div>`，它不会为视图外部的元素触发事件。最后，事件应设置为可在视图中找到的方法名称。
- en: '[PRE126]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Let’s define `removeItem` now. You’ll use a collection filtering method. The
    button can be accessed through `e.target`, and you’ll use its `data-name` attribute
    to fetch the name. Then you’ll use that name to filter the collection to find
    the shopping list item associated with this particular button.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义 `removeItem`。你将使用集合过滤方法。按钮可以通过 `e.target` 访问，你将使用它的 `data-name` 属性来获取名称。然后你将使用该名称来过滤集合，以找到与该特定按钮关联的购物清单项目。
- en: '[PRE127]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Once a model is removed from the collection, the view should be updated again.
    The naive approach would be to update the view model and render the view after
    removing an item from the collection. The problem is that items may be removed
    from a collection in different places throughout an application, particularly
    if it’s a good one. A better approach is to listen to events emitted by the collection.
    In this case, you can listen for the `remove` event in the collection and refresh
    the view whenever that event is raised.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦模型从集合中删除，视图应再次更新。直观的方法是在从集合中删除项目后更新视图模型并重新渲染视图。问题是项目可能在不同地方从集合中删除，尤其是在应用程序很好时。更好的方法是监听集合发出的事件。在这种情况下，你可以监听集合中的
    `remove` 事件，并在该事件被触发时刷新视图。
- en: The following listing sets up the event listener as you initialize the view,
    and also includes refactoring so that the code isn’t duplicated, staying loyal
    to the DRY principle.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表在初始化视图时设置事件监听器，并包括重构，以避免代码重复，保持对 DRY 原则的忠诚。
- en: Listing 7.7\. Setting up an event listener
  id: totrans-841
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.7. 设置事件监听器
- en: '[PRE128]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: That was a big chunk to digest! You may now head over to the accompanying code
    samples and take a glance at ch07/07_the-one-with-delete-buttons, which is the
    working example you got as you completed this stage. In the next portion of this
    walkthrough, you’ll create a form that humans can use to add items to their shopping
    list.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一大块内容！你现在可以查看配套的代码示例，浏览 ch07/07_the-one-with-delete-buttons，这是你在完成这个阶段时获得的运行示例。在本次教程的下一部分，你将创建一个人类可以用来向购物清单添加项目的表单。
- en: 7.4.3\. Adding items to your cart
  id: totrans-844
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.3. 向购物车添加项目
- en: In the previous stage you gave life to your shopping list, allowing items to
    be removed from the list. This time, you’ll add the option to add new items as
    well, so that humans can make their own purchases, instead of removing the items
    they don’t want.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个阶段，你使你的购物清单有了生命，允许从列表中删除项目。这次，你将添加添加新项目的选项，这样人类就可以进行自己的购买，而不是删除他们不想要的项目。
- en: To keep things interesting, let’s throw in another requirement. When creating
    a new item, you need to make sure its name isn’t already listed. If the item is
    already on the grocery list, then the quantity needs to be added to the existing
    item. That avoids creating duplicate items.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持趣味性，让我们加入另一个要求。在创建新项目时，你需要确保其名称尚未列出。如果项目已经在购物清单上，那么数量需要添加到现有项目上。这样可以避免创建重复的项目。
- en: Creating an “add to cart” component
  id: totrans-847
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建“添加到购物车”组件
- en: You’ll add the bit of HTML in the following listing to add groceries to the
    list. This sample can be found as ch07/08_creating-items. You’ll use a couple
    of inputs, and a button that will add the item to the shopping list collection.
    There’s also a field that will only be displayed if an error message is set. You’ll
    use that field for input validation purposes. To keep things simple, this piece
    of HTML will go into your list template for now. You’ll refactor and move it into
    its own view in the next couple of stages.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在以下列表中添加的 HTML 代码用于将杂货添加到列表中。此示例可在 ch07/08_creating-items 中找到。你将使用几个输入和一个按钮，该按钮将项目添加到购物清单集合中。还有一个字段，如果设置了错误消息，则仅显示该字段。你将使用该字段进行输入验证。为了保持简单，现在这段
    HTML 将放入你的列表模板中。在接下来的几个阶段中，你将重构并将其移动到自己的视图中。
- en: Listing 7.8\. Setting up an add to cart component
  id: totrans-849
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.8\. 设置添加到购物车组件
- en: '[PRE129]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Until now your models never changed. You could remove items but not update them.
    Now that the models can be changed via human interaction, it’s time to add in
    validation.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你的模型从未改变。你可以删除项目但不能更新它们。现在模型可以通过人类交互进行更改，是时候添加验证了。
- en: Input validation
  id: totrans-852
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输入验证
- en: Human input should never be trusted, because users can easily enter a quantity
    that isn’t numeric, or they can forget to enter a name. Maybe they entered a negative
    number, and that should be taken into consideration as well. Backbone allows you
    to validate information by supplying a `validate` method on your models. That
    method takes an `attrs` object, which is an internal model variable that holds
    all of the model properties so that you can access them directly. The following
    listing shows how to implement the validation function. You’re checking that the
    model has a name, a numeric quantity that’s not `NaN` (Not a Number). Confusingly,
    `NaN` is of type `'number'` and `NaN` is not equal to itself either, so you need
    to test for `NaN` using the native JavaScript `isNaN` method. Last, you’ll make
    sure that the quantity is at least 1.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 人类输入永远不应被信任，因为用户可以轻松地输入非数字的数量，或者他们可能忘记输入名称。也许他们输入了一个负数，这也应该被考虑在内。Backbone 允许你通过在模型上提供
    `validate` 方法来验证信息。该方法接受一个 `attrs` 对象，这是一个内部模型变量，它包含所有模型属性，以便你可以直接访问它们。以下列表显示了如何实现验证函数。你正在检查模型是否有名称、一个不是
    `NaN`（非数字）的数字数量。令人困惑的是，`NaN` 是 `'number'` 类型，而 `NaN` 也不等于自身，因此你需要使用原生的 JavaScript
    `isNaN` 方法来测试 `NaN`。最后，你将确保数量至少为 1。
- en: Listing 7.9\. Implementing the validation function
  id: totrans-854
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.9\. 实现验证函数
- en: '[PRE130]'
  id: totrans-855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'To make editing simpler, you’ll also add a helper method to the model that
    takes a quantity and updates the model, adding that amount to the current quantity.
    This change should be validated to make sure that a negative amount doesn’t make
    the resulting quantity go below 1\. Models aren’t validated by default when changing
    their values, but you can force that by turning on the `validate` option. The
    following code shows what that method looks like:'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使编辑更简单，你还需要向模型添加一个辅助方法，该方法接受一个数量并更新模型，将此数量添加到当前数量。此更改应经过验证以确保负数不会使结果数量低于 1。默认情况下，更改模型值时不会验证模型，但你可以通过启用
    `validate` 选项来强制执行。以下代码显示了该方法的外观：
- en: '[PRE131]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'When adding any amount to the model, validation will be triggered, and if it
    fails, the model won’t be changed, but instead a `validationError` property will
    be set on the model. Suppose you have a model with a quantity of 6; the following
    code will fail and set the `validationError` property to the appropriate error
    message:'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 当向模型添加任何数量时，将触发验证，如果验证失败，则模型不会更改，而是在模型上设置 `validationError` 属性。假设你有一个数量为 6 的模型；以下代码将失败并将
    `validationError` 属性设置为适当的错误消息：
- en: '[PRE132]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Now that your model protects itself against bad data, you can update the view
    and give life to your new form.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 现在模型可以保护自己免受不良数据的影响，你可以更新视图并给你的新表单赋予生命。
- en: Refactoring the view logic
  id: totrans-861
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 重构视图逻辑
- en: 'The first change we’ll make to the view is adding a render method that can
    display an error message while keeping the name and quantity that the human entered,
    so that they’re not cleared when an error occurs. Let’s name that method `updateViewWithValidation`
    for clarity:'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对视图进行的第一个更改是添加一个可以显示错误消息的渲染方法，同时保持人类输入的名称和数量，这样在发生错误时它们不会被清除。为了清晰起见，让我们将该方法命名为
    `updateViewWithValidation`：
- en: '[PRE133]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'You also need to bind an event listener to click events on your Add button.
    To do that, add another property to the `events` object in your view. Then all
    that’s left is creating the `addItem` event handler:'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要将事件监听器绑定到添加按钮的点击事件上。为此，在你的视图中的`events`对象中添加另一个属性。然后剩下的就是创建`addItem`事件处理程序：
- en: '[PRE134]'
  id: totrans-865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'The first couple of things your `addItem` handler should do is get the human
    input and parse the quantity as a base 10 integer:'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`addItem`处理程序应该做的第一件事是获取人类输入并将数量解析为十进制整数：
- en: '[PRE135]'
  id: totrans-867
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Once you have the user input, the first thing you’ll do is figure out if any
    items in the collection have the same name, and, in that case, you’ll use the
    `addToOrder` method to update the model after validating the input. If the item
    isn’t already in the list, then you create a new `ShoppingItem` model instance
    and validate it. If the validation passes, then you add the newly created item
    onto the collection. In code, that looks like the following listing.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了用户输入，你首先会确定集合中是否有任何项目具有相同的名称，如果是这样，你将在验证输入后使用`addToOrder`方法更新模型。如果项目尚未在列表中，那么你将创建一个新的`ShoppingItem`模型实例并对其进行验证。如果验证通过，那么你将新创建的项目添加到集合中。在代码中，这看起来像以下列表。
- en: Listing 7.10\. Validating a shopping item
  id: totrans-869
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.10\. 验证购物项
- en: '[PRE136]'
  id: totrans-870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Because you’re using the `ShoppingItem` class, you’ll have to add the following
    statement to the top of your module:'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你正在使用`ShoppingItem`类，你必须在模块顶部添加以下语句：
- en: '[PRE137]'
  id: totrans-872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'If the validation step fails, you need to render the view again, adding the
    validation error message so that the user knows what went wrong:'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 如果验证步骤失败，你需要重新渲染视图，添加验证错误消息，以便用户知道出了什么问题：
- en: '[PRE138]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'If validation goes well, the collection will either get a new item or an existing
    item will change. These cases should be handled by listening to the `add` and
    `change` events on the collection. You need to add the following couple of lines
    to the `initialize` method on the view:'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 如果验证成功，集合将获得一个新项目，或者现有项目将发生变化。这些情况应该通过监听集合上的`add`和`change`事件来处理。你需要在视图的`initialize`方法中添加以下几行：
- en: '[PRE139]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: That’s all there is to this stage. You now have the ability to add new items
    to the list, modify the quantity on existing ones, and remove items. In the next
    stage, you’ll make editing more intuitive by adding an inline edit button on each
    list item.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这一阶段的全部内容。你现在可以添加新项目到列表中，修改现有项目的数量，以及删除项目。在下一阶段，你将通过在每个列表项上添加内联编辑按钮来使编辑更加直观。
- en: 7.4.4\. Using inline editing
  id: totrans-878
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.4\. 使用内联编辑
- en: 'In this section we’ll introduce inline item editing. Each item will get an
    Edit button. Clicking on it will allow humans to change the quantity and then
    save the record. That feature in itself is simple, but you’re going to take this
    opportunity and clean house a bit. You’re going to split your growing list view
    into three: an Add Item view that will be in charge of the input form, a List
    Item view that will be in charge of individual list items, and the original List
    view that will handle removals and additions to the collection.'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍内联项目编辑。每个项目都将获得一个编辑按钮。点击它将允许人类更改数量，然后保存记录。这个功能本身很简单，但你将利用这个机会来清理一下。你将把不断增长的长列表分成三个部分：一个负责输入表单的添加项目视图，一个负责单个列表项的列表项视图，以及原始的列表视图，它将处理集合的删除和添加。
- en: Componentizing your views
  id: totrans-880
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 组件化你的视图
- en: 'The first order of business will be breaking your list view template in two.
    You’ll use two different view containers: one for the list and another one for
    the form. The `<div>` you used to have can be replaced by the following code:'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 第一项任务是将你的列表视图模板分成两部分。你将使用两个不同的视图容器：一个用于列表，另一个用于表单。你之前使用的`<div>`可以替换为以下代码：
- en: '[PRE140]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: This division of labor also means you need to split your Mustache template.
    Rather than have the `list` template do everything, you’ll replace it with two
    other templates. As you’ll soon learn, the list itself won’t need any templating;
    only the form and the individual list items will. The following code is what `views/templates/addItem.mu`
    looks like. The form remains almost unchanged, except the `fieldset` tag has been
    promoted to view container status, so it’s no longer in the template.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分工也意味着你需要将Mustache模板拆分。而不是让`list`模板做所有事情，你将用另外两个模板来替换它。正如你很快就会学到的，列表本身不需要任何模板；只有表单和单个列表项需要。以下代码是`views/templates/addItem.mu`的样子。表单几乎保持不变，除了`fieldset`标签已经提升为视图容器的状态，因此它不再在模板中。
- en: '[PRE141]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: The List view no longer needs a template itself, because the only element that’s
    needed is the `<ul>` element, bound to your List view through the `el` property,
    as you’ll see in a minute. Each list item will be kept in its own view, and you’ll
    use a view template for them. The List Item view model will hold a property to
    track whether the item is being edited or not. This property is checked in the
    view template to decide if you need to render a label and the action buttons or
    the inline editing form. The list item template looks like the following listing
    and goes into `views/templates/listItem.mu`.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 列表视图不再需要自己的模板，因为唯一需要的元素是`<ul>`元素，通过`el`属性绑定到你的列表视图，你将在下面看到。每个列表项都将保留在其自己的视图中，并且你将使用视图模板来处理它们。列表项视图模型将持有跟踪项是否正在被编辑的属性。这个属性在视图模板中被检查，以决定是否需要渲染标签和操作按钮或内联编辑表单。列表项模板如下所示，并放入`views/templates/listItem.mu`中。
- en: Listing 7.11\. Viewing a list item template
  id: totrans-886
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.11\. 查看列表项模板
- en: '[PRE142]'
  id: totrans-887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'You’ll still create the collection in the List view, but you need to pass that
    collection to the `addItem` view. This couples both views tightly, because the
    `addItem` view needs a List view that can create a collection, and that isn’t
    modular. This is what your entry point, `app.js`, looks like now. You’ll sort
    out the coupling issues in the next stage; this code snippet is about turning
    your components smaller:'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然会在列表视图中创建集合，但你需要将这个集合传递给`addItem`视图。这会使两个视图紧密耦合，因为`addItem`视图需要一个可以创建集合的列表视图，而这不是模块化的。这就是你现在入口点`app.js`的样子。你将在下一阶段解决耦合问题；这个代码片段是关于使你的组件更小：
- en: '[PRE143]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Let’s continue by creating the Add Item view.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建添加项目视图。
- en: A modular “add to cart” view
  id: totrans-891
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 模块化的“添加到购物车”视图
- en: The Add Item view is similar to what you had in the List view before starting
    to componentize it. First, the following listing shows how the view is initialized,
    and how it uses the `.add-view` selector to find the `<fieldset>`, which will
    be used as the view container.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 添加项目视图与你在开始组件化列表视图之前所拥有的相似。首先，下面的列表显示了视图是如何初始化的，以及它是如何使用`.add-view`选择器来找到`<fieldset>`，这个`<fieldset>`将被用作视图容器。
- en: Listing 7.12\. Initializing the view
  id: totrans-893
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.12\. 初始化视图
- en: '[PRE144]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: This view is only concerned with adding models to the collection, and it shows.
    It’ll have a click event handler on the Add button that will look almost exactly
    identical to your old `addItem` method. The only difference is that in this version
    you update the view every time the `addItem` event handler is fired, as shown
    in the following listing.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图只关注向集合中添加模型，并且它确实如此。它将在添加按钮上有一个点击事件处理器，这个处理器几乎与你的旧`addItem`方法完全相同。唯一的区别是，在这个版本中，每当`addItem`事件处理器被触发时，你都会更新视图，如下面的列表所示。
- en: Listing 7.13\. Updating the view
  id: totrans-896
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.13\. 更新视图
- en: '[PRE145]'
  id: totrans-897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: The only thing the Add Item view has to do is add items, so that’s all there
    is to it! Let’s put together the List item view next.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 添加项目视图唯一要做的就是添加项目，所以这就是全部！接下来让我们来构建列表项视图。
- en: Creating a list item component
  id: totrans-899
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建列表项组件
- en: 'The list item component will be in charge of rendering any changes made to
    its model and provide the opportunity to edit or remove items from the list. Let’s
    go over this view from scratch. First off, there are the usual suspects. You need
    to read the template file and extend the base view. The `tagName` property means
    that this view will get rendered to an `<li>` element. Start with the following
    code snippet:'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 列表项组件将负责渲染对其模型所做的任何更改，并提供编辑或从列表中删除项的机会。让我们从头开始审视这个视图。首先，有一些常见的问题。你需要读取模板文件并扩展基本视图。`tagName`属性意味着这个视图将被渲染为`<li>`元素。以下是一个代码片段：
- en: '[PRE146]'
  id: totrans-901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'This view will take the model and collection properties as they’re created,
    as you’ll see when refactoring the List view, which you’ll do next. Whenever the
    model changes, you’ll render the view again. The view also needs to be rendered
    when it’s initialized. In case a validation error occurs while using the inline
    editing feature, you’ll track that with the view model as well. Here’s how that
    looks in code:'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图将接受模型和集合属性，正如你在重构列表视图时将会看到的那样。每当模型发生变化时，你都会重新渲染视图。视图在初始化时也需要被渲染。如果在使用内联编辑功能时发生验证错误，你也会通过视图模型跟踪它。以下是代码中的样子：
- en: '[PRE147]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'The remove event handler is much simpler now, because all you have to do is
    remove the model from the collection, and you still have both of those in the
    properties of your view. This is how it looks in code:'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 移除事件处理程序现在更简单，因为你只需从集合中移除模型，你仍然可以在视图的属性中找到这两个。这在代码中看起来是这样的：
- en: '[PRE148]'
  id: totrans-905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Next you’ll wire up the edit and cancel methods, which are similar. The first
    one puts the item in edit mode, while the second leaves edit mode. All these methods
    need to do is change the `editing` property. The rest will be handled by the model
    change event listener, which will make sure to render the view again. When switching
    the edit mode on or off, you’ll clear the `validationError` property as well.
    The following listing introduces these event handlers.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将连接编辑和取消方法，它们是相似的。第一个将项目置于编辑模式，而第二个将退出编辑模式。所有这些方法需要做的就是更改 `editing` 属性。其余的将由模型更改事件监听器处理，确保重新渲染视图。当切换编辑模式时，你还将清除
    `validationError` 属性。下面的列表介绍了这些事件处理程序。
- en: Listing 7.14\. Adding edit and cancel methods
  id: totrans-907
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.14\. 添加编辑和取消方法
- en: '[PRE149]'
  id: totrans-908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'The last task of the List Item view will be saving edits made to a record.
    You’ll bind to clicks on the Save button, parse the input, and update the quantity.
    You’ll get out of edit mode only if the validation succeeded. Keep in mind I’m
    not repeating all of the previous event handlers, for brevity:'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 列表项视图的最后一个任务将是保存对记录所做的编辑。你将绑定到保存按钮的点击事件，解析输入，并更新数量。只有当验证成功时，你才会退出编辑模式。记住，我没有重复所有之前的事件处理程序，为了简洁：
- en: '[PRE150]'
  id: totrans-910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: List items don’t have any other responsibilities, but the list should add and
    remove this partial view to the UI. When saying partial view, I mean that it only
    represents a portion of an object, in this case a portion of the list rather than
    the whole. The List view needs to hold as many list item views as it has to.
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 列表项没有其他职责，但列表应该将这个部分视图添加和移除到 UI 中。当说到部分视图时，我的意思是它只代表对象的一部分，在这种情况下是列表的一部分而不是整个列表。列表视图需要持有与它拥有的列表项视图一样多的列表项视图。
- en: Rebuilding the list view
  id: totrans-912
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 重建列表视图
- en: Previously, your List view would rerender every time an item was added or deleted.
    Now your list will only render individual items and append them to the DOM or
    remove existing items from the DOM. This is not only faster than rerendering the
    whole list, but it’s also more modular. The list is only managing the big picture
    actions, when items are added or removed. The individual items will each be in
    charge of maintaining their own state and updating their own UI representation.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，你的列表视图会在每次添加或删除项目时重新渲染。现在，你的列表将只渲染单个项目并将它们附加到 DOM 或从 DOM 中移除现有项目。这不仅比重新渲染整个列表更快，而且也更模块化。列表只管理大图景动作，即项目添加或删除时。单个项目将各自负责维护它们自己的状态并更新它们自己的
    UI 表示。
- en: For this to work, the List view will no longer rely on the `view.render` method,
    but manipulate the DOM directly instead. The aspects of the old List view that
    you kept, such as the hard-coded collection data, extending from the base view,
    and the `el` property declaration are shown in the following listing. Note that
    the view container has changed to match your `<ul>` element.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这可行，列表视图将不再依赖于 `view.render` 方法，而是直接操作 DOM。你保留的旧列表视图的方面，例如硬编码的集合数据、从基本视图扩展以及
    `el` 属性声明，在下面的列表中展示。请注意，视图容器已更改为与你的 `<ul>` 元素匹配。
- en: Listing 7.15\. Aspects of the old list view
  id: totrans-915
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.15\. 旧列表视图的方面
- en: '[PRE151]'
  id: totrans-916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Because you no longer desire to repaint the entire view every time an item changes,
    you’ll rely on two new methods, `addItem` and `removeItem`, to do the DOM manipulation.
    You’ll run these methods whenever the collection is updated, keeping the UI up
    to date at all times. You can also use the `addItem` method to render the initial
    representation of the collection, by running it on each model in the collection
    when initializing the view. The `initialize` method will look like the following
    code snippet. I’ll explain the `partials` variable next.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你不再希望每次项目更改时都重新绘制整个视图，你将依赖于两个新方法，`addItem` 和 `removeItem`，来进行 DOM 操作。每当集合更新时，你将运行这些方法，以保持
    UI 始终是最新的。你还可以使用 `addItem` 方法通过在初始化视图时对集合中的每个模型运行它来渲染集合的初始表示。`initialize` 方法将如下代码片段所示。我将在下一节解释
    `partials` 变量。
- en: '[PRE152]'
  id: totrans-918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Before you can see the `addItem` method, I’ll mention that it needs to `require`
    the List Item view. You’ll use that to create partial views, one for each model
    in the collection. Let’s add that to the top of the List view module:'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 在你看到`addItem`方法之前，我要提到它需要`require`列表项视图。你将使用它来创建部分视图，每个集合中的模型一个。让我们将这个添加到列表视图模块的顶部：
- en: '[PRE153]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'You’re now ready to implement the `addItem` method. That method will take a
    model and create an instance of the `ListItemView`. Then the view element, which
    is an `<li>`, will be appended to `this.$el`, which is your `<ul>` element. To
    cleanly find and remove items from the list, you’ll track them in the `partials`
    variable. Backbone models have a unique ID property that can be accessed through
    `model.cid`, so you can use that as the keys in your `partials` object. The code
    is as follows:'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在准备好实现`addItem`方法。该方法将接受一个模型并创建一个`ListItemView`的实例。然后视图元素，一个`<li>`，将被添加到`this.$el`，即你的`<ul>`元素。为了干净地查找和从列表中移除项目，你将在`partials`变量中跟踪它们。Backbone模型有一个独特的ID属性，可以通过`model.cid`访问，因此你可以将其用作`partials`对象中的键。代码如下：
- en: '[PRE154]'
  id: totrans-922
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Removing elements is now merely a matter of looking at the `partials` object,
    accessing the partial by means of the `model.cid` key, and removing the element.
    You should then make sure that it gets removed from the `partials` object as well.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 移除元素现在只是查看`partials`对象，通过`model.cid`键访问部分，并移除元素。然后你应该确保它也从`partials`对象中移除。
- en: '[PRE155]'
  id: totrans-924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Phew! That was an intense refactoring session, but it paid off. Now you have
    a few different views working on the same collection, and they’re much more self-contained
    now. The Add Item view only adds items to the collection, the List view only cares
    about creating new List Item views or removing them from the DOM, and the List
    Item view is only concerned about changes to an individual model.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！那是一个密集的重构会话，但这是值得的。现在你有一些不同的视图正在处理同一个集合，而且它们现在更加自包含。添加项目视图只向集合添加项目，列表视图只关心创建新的列表项视图或从DOM中移除它们，而列表项视图只关注单个模型的变化。
- en: Give yourself a congratulatory pat on the back, and check out the accompanying
    code samples to make sure you understand all the changes you’ve made at this stage
    and the current state of the shopping list application. You’ll find the example
    listed as ch07/09_item-editing.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 给自己一个鼓励的拍拍背，并查看附带的代码示例，以确保你理解了在此阶段所做的所有更改以及购物清单应用程序的当前状态。你可以找到示例在 ch07/09_item-editing。
- en: You accomplished a nice separation of concerns at this stage, but you can do
    better. Let’s examine that in the last stage of this process.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这个阶段实现了很好的关注点分离，但你可以做得更好。让我们在过程的最后阶段来检查这一点。
- en: 7.4.5\. A service layer and view routing
  id: totrans-928
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.5. 服务层和视图路由
- en: This last stage introduces two changes to your organization. You’ll add a thin
    service layer and introduce view routing into your application design. By creating
    a service that provides a unique shopping list collection, you give your views
    the ability to actively ask the service for the shopping list data. This dramatically
    decouples your views, which previously generated the data and shared it with each
    other.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个阶段引入了两个对组织结构的更改。你将添加一个薄层服务，并将视图路由引入到你的应用程序设计中。通过创建一个提供唯一购物清单集合的服务，你让你的视图能够主动向服务请求购物清单数据。这极大地解耦了你的视图，之前它们生成数据并相互共享。
- en: Note that in this case you’re still hard coding an array of items, but you could
    as easily pull them from an Ajax request and provide access to them through a
    Promise, as you saw in [chapter 6](kindle_split_018.html#ch06). For the time being,
    the following listing will do. This should be placed in the `services` directory.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，你仍然是在硬编码一个项目数组，但你同样可以从Ajax请求中获取它们，并通过Promise提供对这些项目的访问，就像你在[第6章](kindle_split_018.html#ch06)中看到的那样。目前，以下列表将足够使用。这应该放在`services`目录中。
- en: Listing 7.16\. Hard coding an array of items
  id: totrans-931
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.16\. 硬编码一个项目数组
- en: '[PRE156]'
  id: totrans-932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Once that’s in place, both the Add Item and the List views should `require`
    the service, and assign `shoppingService.collection` to their `collection` properties.
    In doing that, you no longer need to pass around a reference to the collection
    that was previously initialized by the List view.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦到位，添加项目和列表视图都应该`require`该服务，并将`shoppingService.collection`分配给它们的`collection`属性。这样做之后，你不再需要传递之前由列表视图初始化的集合引用。
- en: Let’s turn to the routing changes, rounding up your shopping list adventure.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转向路由更改，总结一下你的购物清单冒险之旅。
- en: Routing for the shopping list
  id: totrans-935
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 购物清单的配置
- en: You’re also going to implement routing at this stage. To keep things interesting,
    you’ll move the Add Item view to a different route. The code in the following
    listing should go into its own module. Place it at `routers/viewRouter.js.` The
    `'root'` action helps redirect humans when they open up the application, and there’s
    no other hash location set.
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，您也将实现路由。为了保持趣味性，您将把“添加项目”视图移动到不同的路由。以下列表中的代码应该放入其自己的模块中。将其放置在 `routers/viewRouter.js`。`'root'`
    动作有助于在人类打开应用程序时进行重定向，并且没有设置其他哈希位置。
- en: Listing 7.17\. Moving the Add Item view to a different route
  id: totrans-937
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.17\. 将“添加项目”视图移动到不同的路由
- en: '[PRE157]'
  id: totrans-938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: As I mentioned back in [section 7.3.4](#ch07lev2sec14) when I first introduced
    Backbone routers, you’ll have to go back to `app.js` and replace what you had
    in there with the code in the following listing. This will wire up your view router
    and activate it. Rather than statically defining the first view served to the
    human, it’ll depend on from which URL they visit your application.
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在[第 7.3.4 节](#ch07lev2sec14)中提到的，当我首次介绍 Backbone 路由器时，您需要回到 `app.js` 并将其中原有的代码替换为以下列表中的代码。这将连接您的视图路由器并激活它。而不是静态地定义第一个提供给人类的视图，它将取决于他们从哪个
    URL 访问您的应用程序。
- en: Listing 7.18\. Activating the view router
  id: totrans-940
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.18\. 激活视图路由器
- en: '[PRE158]'
  id: totrans-941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'The last change you need to make to have routing has to do with views and templating.
    First, you’ll revert back to the single view container you used to have before
    the last stage:'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要进行的最后一个更改以实现路由与视图和模板有关。首先，您将恢复到最后阶段之前使用的单个视图容器：
- en: '[PRE159]'
  id: totrans-943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Second, you need to set the `el` property to `''.view''` in both the Add Item
    view and the List view. You also have to change the view templates around a bit.
    For example, the Add Item view template should have a Cancel button that goes
    back to the List view. It should look like the following code:'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，您需要在“添加项目”视图和列表视图中都将 `el` 属性设置为 `'.view'`。您还必须稍微更改一下视图模板。例如，“添加项目”视图模板应该有一个取消按钮，该按钮可以返回到列表视图。它应该看起来像以下代码：
- en: '[PRE160]'
  id: totrans-945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Last, you’ll give your List view a well-deserved view template, which will
    be small. It needs the `<ul>` that will keep the list and an anchor link that
    matches the route for the Add Item view. The following code snippet shows how
    the template, placed in `views/templates/list.mu`, should look:'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您将为您的列表视图提供一个应得的视图模板，它将很小。它需要一个 `<ul>` 来保持列表和一个与“添加项目”视图路由匹配的锚点链接。以下代码片段显示了放置在
    `views/templates/list.mu` 中的模板应该看起来像什么：
- en: '[PRE161]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'The List view should render this template when initialized and look up the
    list element:'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 列表视图在初始化时应渲染此模板并查找列表元素：
- en: '[PRE162]'
  id: totrans-949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'When adding an item to the list, rather than appending them to `$el`, which
    is now the shared view container, you should append them to `$list`:'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 当向列表添加项目时，而不是将它们附加到 `$el`（现在是一个共享的视图容器），您应该将它们附加到 `$list`：
- en: '[PRE163]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: That’s all there is to it! Make sure to check out the code in the accompanying
    repository. The last stage can be found under ch07/10_the-road-show, and it contains
    everything you’ve worked on so far. Next up, you’ll learn about Rendr, a technology
    you can use to render client-side Backbone views on the server side, which is
    useful for improving human-perceived performance when developing Node.js applications.
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部内容！请确保查看附带的代码库。最后阶段可以在 ch07/10_the-road-show 下找到，其中包含您迄今为止所做的一切。接下来，您将学习关于
    Rendr 的内容，这是一种您可以在服务器端渲染客户端 Backbone 视图的技术，这对于在开发 Node.js 应用程序时提高人类感知性能非常有用。
- en: '7.5\. Backbone and Rendr: server/client shared rendering'
  id: totrans-953
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5\. Backbone 和 Rendr：服务器/客户端共享渲染
- en: Rendr boosts the perceived performance of Backbone applications by rendering
    them on the server side. This allows you to display the rendered page before JavaScript
    code is executed in the browser and Backbone kicks in. The first time the page
    gets loaded, the human will see the content sooner. After that first load, Backbone
    will take over and handle routing on the client side. The first load is extremely
    important and rendering the application on the server before the human gets any
    content is better than having them wait for Backbone to pull your data, fill your
    views, and render your templates. That’s why server-side rendering is still vital
    to the web application development process. Let’s start with a quick dive into
    the world of Rendr.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: Rendr通过在服务器端渲染Backbone应用程序来提升其感知性能。这允许你在浏览器中的JavaScript代码执行和Backbone启动之前显示渲染后的页面。当页面第一次加载时，人类将更快地看到内容。在那次首次加载之后，Backbone将接管并在客户端处理路由。第一次加载非常重要，在人类获得任何内容之前在服务器上渲染应用程序比让他们等待Backbone获取你的数据、填充你的视图和渲染你的模板要好。这就是为什么服务器端渲染在Web应用程序开发过程中仍然至关重要。让我们快速了解一下Rendr的世界。
- en: 7.5.1\. Diving into Rendr
  id: totrans-955
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.1\. 深入Rendr
- en: Rendr uses a conventional approach to application building. It expects you to
    name your modules in a certain way and place them in certain directories. Rendr
    also has opinions about the kinds of templates you should use and how your application
    should access its data. By default, this means Rendr expects you to have a REST
    API to access the application data; you’ll investigate REST API design in [chapter
    9](kindle_split_021.html#ch09).
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: Rendr采用传统的应用程序构建方法。它期望你以某种方式命名你的模块并将它们放置在特定的目录中。Rendr还对应该使用哪种模板以及你的应用程序如何访问其数据有自己的看法。默认情况下，这意味着Rendr期望你有一个REST
    API来访问应用程序数据；你将在第9章中研究REST API设计。[第9章](kindle_split_021.html#ch09)。
- en: Rendr runs on Node.js, acting as middleware in your HTTP stack. It works by
    intercepting requests and rendering views server-side before handing the prerendered
    results to the client. In its conventional approach, it helps separate concerns
    by defining controllers, where you can fetch data, render views, or perform redirects.
    Rather than having to reference your templates in your views, Rendr uses well-defined
    naming policies that abstract away dependencies, which are mostly managed by the
    Rendr engine. This will become clearer once you look at the code in [section 7.5.2](#ch07lev2sec21).
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: Rendr在Node.js上运行，作为你的HTTP堆栈中的中间件。它通过拦截请求并在将预渲染的结果交给客户端之前在服务器端渲染视图来工作。在其传统方法中，它通过定义控制器来帮助分离关注点，在那里你可以获取数据、渲染视图或执行重定向。Rendr而不是在视图中引用你的模板，使用定义良好的命名策略来抽象依赖关系，这些依赖关系主要由Rendr引擎管理。一旦你查看[第7.5.2节](#ch07lev2sec21)中的代码，这将会更加清晰。
- en: Problems in paradise
  id: totrans-958
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 天堂中的问题
- en: 'Not all is peaches and cream. At the time of this writing, Rendr (v0.5) includes
    “peculiar” design choices that ultimately made me decide not to use it throughout
    this chapter, as it would’ve complicated the examples. For instance, Rendr uses
    Browserify to bring the modules you write into the browser, but it has three distinct
    hacks in the way it compiles your CommonJS modules using Browserify:'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 并非一切尽善尽美。在撰写本文时，Rendr（v0.5）包含了一些“独特”的设计选择，这最终使我决定在本章中不使用它，因为它会复杂化示例。例如，Rendr使用Browserify将你编写的模块带到浏览器中，但它使用Browserify编译你的CommonJS模块的方式有三个不同的“黑客”技巧：
- en: '**1**.  jQuery needs to be shimmed through `browserify-shim.` This is problematic
    because the server-side version of Rendr uses its own version of jQuery, and there
    could be versioning discrepancies. If you try to use the CommonJS version obtained
    through `npm`, it won’t work.'
  id: totrans-960
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  jQuery需要通过`browserify-shim`进行模拟。这很成问题，因为Rendr的服务器端版本使用它自己的jQuery版本，并且可能存在版本差异。如果你尝试通过`npm`获取的CommonJS版本，它将无法工作。'
- en: '**2**.  It needs aliases for part of its `require` calls to work as expected,
    which is an issue because it translates into the next deficiency, as well.'
  id: totrans-961
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  它需要别名来使其`require`调用按预期工作，这是一个问题，因为它也转化为下一个缺陷。'
- en: '**3**.  You can’t use the `brfs` transform with Rendr.'
  id: totrans-962
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**.  你不能使用`brfs`转换与Rendr一起使用。'
- en: The decision to not go deeper into Rendr mostly had more to do with it being
    less broadly applicable. If you chose a server-side language other than Node.js,
    you couldn’t carry as many of the concepts I’ll teach into your designs. Beside
    these problems, there definitely is value in learning about the conventional MVC
    capabilities Rendr provides to your Backbone applications. Many conventional MVC
    frameworks exist in server-side languages, providing similar features as those
    resulting from combining Backbone and Rendr, but you rarely learn about those
    when talking about client-side JavaScript. The ability to perform shared rendering
    definitely boosts its appeal. As with most things when deciding on a technology
    stack, it’s a tradeoff. Note that Facebook’s React is a good example of a library
    that’s capable of doing both server-side and client-side rendering without any
    additional tooling needed.
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 决定不深入探讨 Rendr 主要是因为它应用范围较窄。如果你选择 Node.js 以外的服务器端语言，你无法将我即将教授的许多概念应用到你的设计中。除了这些问题之外，了解
    Rendr 为你的 Backbone 应用程序提供的传统 MVC 功能肯定是有价值的。在服务器端语言中存在许多传统的 MVC 框架，它们提供了与 Backbone
    和 Rendr 结合后类似的功能，但在讨论客户端 JavaScript 时，你很少了解到这些。执行共享渲染的能力无疑增加了其吸引力。与大多数决定技术栈的事情一样，这是一个权衡。请注意，Facebook
    的 React 是一个很好的例子，它是一个能够进行服务器端和客户端渲染的库，无需任何额外的工具。
- en: Diving in
  id: totrans-964
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 深入了解
- en: To showcase Rendr, I’ve settled for a slightly modified version of an example
    AirBnB (the company behind Rendr) uses to teach how Rendr works. You can find
    the code as ch07/11_entourage in the accompanying code samples.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示 Rendr，我选择了一个稍微修改过的示例 Airbnb（Rendr 的公司）使用的示例，用于教授 Rendr 的工作原理。你可以在配套代码样本的
    ch07/11_entourage 中找到代码。
- en: 'First, let’s talk about the templates. Rendr encourages you to use a superset
    of Mustache called Handlebars. Handlebars provides extra features, mostly in the
    form of helper methods you can use, such as an `if` convenience method. Rendr
    expects you to compile the Handlebars templates and place the bundled result in
    `app/templates/compiledTemplates.js.` To do that, start by installing the Grunt
    plugin for Handlebars:'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们谈谈模板。Rendr 鼓励你使用 Mustache 的超集，即 Handlebars。Handlebars 提供了额外的功能，主要是以辅助方法的形式，例如
    `if` 方便方法。Rendr 期望你编译 Handlebars 模板，并将打包的结果放置在 `app/templates/compiledTemplates.js`
    中。为此，首先安装 Handlebars 的 Grunt 插件：
- en: '[PRE164]'
  id: totrans-967
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: To configure the Handlebars Grunt plugin, you have to add the code in the following
    listing to the `Gruntfile.` The `options` passed to the `handlebars:compile` task
    target are needed by Rendr, which expects the templates to be named in a certain
    way.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置 Handlebars Grunt 插件，你必须将以下列表中的代码添加到 `Gruntfile` 中。传递给 `handlebars:compile`
    任务的 `options` 是 Rendr 所需要的，它期望模板以某种方式命名。
- en: Listing 7.19\. Configuring the Handlebars plugin
  id: totrans-969
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.19\. 配置 Handlebars 插件
- en: '[PRE165]'
  id: totrans-970
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: The Browserify configuration is, at the moment, also tied to Rendr’s expectations.
    You’ll need to shim jQuery, rather than install it from `npm.` You’re expected
    to provide an alias so Rendr can access `rendr-handlebars`, the Handlebars adapter
    used by Rendr. Last, Rendr needs you to provide a few mappings so it can access
    your application’s modules. The code to configure Browserify to play nice with
    Rendr can be found in the following listing.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Browserify 的配置也依赖于 Rendr 的期望。你需要模拟 jQuery，而不是从 `npm` 中安装它。你被期望提供一个别名，以便 Rendr
    可以访问 `rendr-handlebars`，这是 Rendr 使用的 Handlebars 适配器。最后，Rendr 需要你提供一些映射，以便它可以访问你的应用程序模块。配置
    Browserify 以与 Rendr 协同工作的代码可以在以下列表中找到。
- en: Listing 7.20\. Configuring Browserify to work with Rendr
  id: totrans-972
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.20\. 配置 Browserify 以与 Rendr 一起工作
- en: '[PRE166]'
  id: totrans-973
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: That’s it, as far as build configuration goes. It might not be ideal, but once
    it’s in there you can forget about it. Let’s go into the sample application code
    and see how it works.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 就构建配置而言，这就足够了。可能不是最理想的，但一旦配置完成，你就可以将其置之脑后。让我们进入示例应用程序代码，看看它是如何工作的。
- en: 7.5.2\. Understanding boilerplate in Rendr
  id: totrans-975
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.2\. 理解 Rendr 中的样板代码
- en: The first step you’ll take in putting together your Rendr application is creating
    the entry point for the Node program. You’ll name this file `app.js` and place
    it in your application root. As I mentioned previously, Rendr works as a middleware
    in your HTTP stack, sitting inside Express.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建你的 Rendr 应用程序时，你将采取的第一步是为 Node 程序创建入口点。你将把这个文件命名为 `app.js` 并将其放置在你的应用程序根目录中。正如我之前提到的，Rendr
    作为你的 HTTP 栈中的中间件工作，位于 Express 内部。
- en: Express middleware for Rendr
  id: totrans-977
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Rendr 的 Express 中间件
- en: Express is a popular Node.js framework that wraps the native `http` module,
    providing more functionality and allowing you to perform routing and a few other
    things. Past this section, most of what we’ll discuss is inherent to Rendr and
    not part of Express. Rendr enhances Express to make its conventions work, though.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: Express 是一个流行的 Node.js 框架，它封装了原生的 `http` 模块，提供了更多功能，并允许你执行路由和其他一些操作。在本节之后，我们将讨论的大部分内容都是
    Rendr 的固有特性，而不是 Express 的部分。尽管如此，Rendr 通过增强 Express 来使其约定生效。
- en: '[PRE167]'
  id: totrans-979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: Have a look at the following piece of code. You’re using the `express` package
    to set up an HTTP server in Node. Calling `express()` will create a new Express
    application instance, and you can add middleware to that instance with `app.use`.
    Invoking `app.listen(port)` will keep the application running and react on incoming
    HTTP requests on the chosen port. Best practice dictates that the listening port
    for your application should be configurable as an environment variable and have
    a sensible default value.
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下代码片段。你正在使用 `express` 包在 Node 中设置一个 HTTP 服务器。调用 `express()` 将创建一个新的 Express
    应用程序实例，并且你可以使用 `app.use` 向该实例添加中间件。调用 `app.listen(port)` 将使应用程序保持运行并响应所选端口上的传入
    HTTP 请求。最佳实践规定，你的应用程序的监听端口应该可配置为环境变量，并具有合理的默认值。
- en: '[PRE168]'
  id: totrans-981
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: The `static` middleware tells Express to serve all of the content in the specified
    directory as static assets. If a human requests `http://localhost:3000/js/foo.js`,
    and the `public/js/foo.js` file exists, that’s what Express will respond with.
    The `bodyParser` middleware is a utility that will parse request bodies that are
    detected to be in JSON or form data format.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: '`static` 中间件告诉 Express 将指定目录中的所有内容作为静态资源提供服务。如果有人请求 `http://localhost:3000/js/foo.js`，并且
    `public/js/foo.js` 文件存在，那么 Express 将会这样响应。`bodyParser` 中间件是一个工具，它将解析检测到为 JSON
    或表单数据格式的请求体。'
- en: The following listing configures Rendr for your example. The middleware will
    take care of everything else, as you’ll see next. The data adapter configuration
    tells Rendr what API it should query. The beauty of Rendr lies in that, both on
    the client side as well as on the server side, it’ll query the API whenever it
    needs to fetch data.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表配置了 Rendr 以供你的例子使用。中间件将处理其他所有事情，正如你接下来将看到的。数据适配器配置告诉 Rendr 应该查询哪个 API。Rendr
    的美在于，无论是在客户端还是服务器端，它都会在需要获取数据时查询 API。
- en: Listing 7.21\. Configuring Rendr
  id: totrans-984
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.21\. 配置 Rendr
- en: '[PRE169]'
  id: totrans-985
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: Setting up Rendr
  id: totrans-986
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设置 Rendr
- en: 'Rendr provides a series of base objects you’re expected to extend when building
    your application. The `BaseApp` object, which extends from `BaseView,` should
    be extended and placed in `app/app.js` to create a Rendr app. In this file you
    could add app initialization code that runs in both the client and the server
    and is used to maintain the application’s global state. The following snippet
    of code will suffice:'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: Rendr 提供了一系列基本对象，你需要在构建应用程序时扩展它们。从 `BaseView` 扩展而来的 `BaseApp` 对象应该被扩展并放置在 `app/app.js`
    中以创建一个 Rendr 应用程序。在这个文件中，你可以添加在客户端和服务器上运行的初始化代码，这些代码用于维护应用程序的全局状态。以下代码片段就足够了：
- en: '[PRE170]'
  id: totrans-988
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'You also need to create a router module, which you could use to track page
    views whenever there’s a route change, although for now you’ll merely create an
    instance of the base router. The router module should be placed at `app/router.js,`
    and it should look like the following code:'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要创建一个路由模块，你可以用它来跟踪页面视图，每当有路由变化时，尽管现在你只是创建了一个基础路由的实例。路由模块应该放置在 `app/router.js`
    中，它应该看起来像以下代码：
- en: '[PRE171]'
  id: totrans-990
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: Let’s turn our attention to how the meat of your Rendr application should look.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把注意力转向你的 Rendr 应用程序的主体应该是什么样子。
- en: 7.5.3\. A simple Rendr application
  id: totrans-992
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.3\. 一个简单的 Rendr 应用程序
- en: 'You’ve configured Grunt and Express to comply with Rendr’s needs. Now it’s
    time to develop the application itself. To make this example easier to understand,
    I’ll show you the code in the logical order Rendr uses to serve its responses.
    To keep your example self-contained, yet interesting, you’ll create three different
    views:'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经配置了 Grunt 和 Express 以满足 Rendr 的需求。现在，是时候开发应用程序本身了。为了使这个例子更容易理解，我将按照 Rendr
    用来提供响应的逻辑顺序展示代码。为了保持你的例子既独立又有趣，你将创建三个不同的视图：
- en: '**1**.  Home is the welcome screen for your app.'
  id: totrans-994
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 首页是应用程序的欢迎屏幕。'
- en: '**2**.  Users keeps a list of GitHub users.'
  id: totrans-995
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 用户列表包含 GitHub 用户。'
- en: '**3**.  User contains the details of a specific user.'
  id: totrans-996
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 用户包含特定用户的详细信息。'
- en: These views will have a one-to-one relationship with routes. The home view will
    sit at the application root, `/`; the user list will be at `/users`; and the user
    details view will be at `/users/:login`, where `:login` is the user login on GitHub
    (`bevacqua` in my case). Views are rendered by controllers.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 这些视图将与路由保持一对一的关系。主页视图将位于应用程序根目录`/`；用户列表将位于`/users`；用户详情视图将位于`/users/:login`，其中`:login`是GitHub上的用户登录名（在我的情况下是`bevacqua`）。视图由控制器渲染。
- en: '[Figure 7.5](#ch07fig05) shows what the user list will look like when you’re
    done.'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7.5](#ch07fig05)显示了完成后的用户列表将看起来是什么样子。'
- en: Figure 7.5\. A list of users in your GitHub browser built using Rendr
  id: totrans-999
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.5. 使用Rendr构建的GitHub浏览器中用户列表
- en: '![](07fig05.jpg)'
  id: totrans-1000
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig05.jpg)'
- en: Let’s start with routing and then learn how controllers operate.
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从路由开始，然后学习控制器是如何工作的。
- en: Routes and controllers
  id: totrans-1002
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 路由和控制器
- en: The following code matches routes to controller actions. The controller actions
    should be defined as the controller name, followed by a hash, and then the action
    name. This module goes into `app/routes.js`.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将路由匹配到控制器操作。控制器操作应定义为控制器名称，后跟一个哈希，然后是操作名称。此模块位于`app/routes.js`。
- en: '[PRE172]'
  id: totrans-1004
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Controllers fetch any data that’s required to render a view. You have to define
    each action that’s expected by the routes. Let’s put the two controllers together.
    By convention, controllers should be placed in `app/controllers/{{name}}_controller.js`.
    The following code snippet, your Home controller, should be placed at `app/controllers/home_controller.js.`
    It should expose an `index` function, matching the `index` route. This function
    takes a parameters object and a callback that, once called, will render the view:'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器获取渲染视图所需的所有数据。你必须定义路由期望的每个操作。让我们将两个控制器放在一起。按照惯例，控制器应放置在`app/controllers/{{name}}_controller.js`。以下代码片段，你的主页控制器，应放置在`app/controllers/home_controller.js`。它应该公开一个`index`函数，与`index`路由相匹配。这个函数接受一个参数对象和一个回调函数，一旦调用，将渲染视图：
- en: '[PRE173]'
  id: totrans-1006
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: The `user_controller.js` module is different. It has an `index` action as well,
    but it also has a `show` action. In both cases, you need to call `this.app.fetch`
    with parameters to get the model data and then invoke the callback once you’re
    done, as shown in the following listing.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: '`user_controller.js`模块不同。它有一个`index`操作，但还有一个`show`操作。在两种情况下，你都需要使用参数调用`this.app.fetch`以获取模型数据，然后在你完成时调用回调函数，如下所示。'
- en: Listing 7.22\. Retrieving model data
  id: totrans-1008
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.22. 获取模型数据
- en: '[PRE174]'
  id: totrans-1009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: Fetching this data wouldn’t be possible if you didn’t have matching models and
    collections. Let’s flesh those out next.
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有匹配的模型和集合，将无法获取这些数据。让我们接下来详细说明这些内容。
- en: Models and collections
  id: totrans-1011
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 模型和集合
- en: 'Models and collections need to extend the base objects provided by Rendr, so
    let’s create those. The following code is for your base model, placed at `app/models/base.js`:'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 模型和集合需要扩展Rendr提供的基类对象，因此让我们创建这些。以下代码是基模型，放置在`app/models/base.js`。
- en: '[PRE175]'
  id: totrans-1013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'The base collection is similarly thin. Having your own base objects, though,
    is necessary to easily share functionality across your models:'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 基础集合同样很薄。然而，拥有自己的基类对象对于轻松在模型之间共享功能是必要的：
- en: '[PRE176]'
  id: totrans-1015
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'We’ll have to define your models using the endpoint you want to use to fetch
    the models, in this case from the GitHub API. Your models should also export a
    unique identifier that’s the same as what you used when calling `app.fetch` in
    your User controller. The following code shows what the User model looks like.
    This should be placed at `app/models/user.js`:'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用你想要用于获取模型的端点来定义你的模型，在这种情况下是从GitHub API。你的模型还应该导出一个唯一的标识符，这与你在用户控制器中调用`app.fetch`时使用的相同。以下代码显示了用户模型的样子。这应该放置在`app/models/user.js`。
- en: '[PRE177]'
  id: totrans-1017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'As long as your models don’t have any validation or computed data functions,
    they’ll look similar: a `url` endpoint, the unique identifier, and the name of
    the parameter that’s used to look up a single model instance. When you look at
    REST API design in [chapter 9](kindle_split_021.html#ch09), constructing a URL
    in this way will feel more natural to you. Here’s what the Repo model looks like:'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你的模型没有验证或计算数据函数，它们看起来就会很相似：一个`url`端点，唯一的标识符，以及用于查找单个模型实例的参数名称。当你查看第9章中REST
    API的设计时，以这种方式构造URL会感觉更自然。以下是如何看起来像Repo模型：
- en: '[PRE178]'
  id: totrans-1019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'As in your case study in [section 7.4](#ch07lev1sec4), collections need to
    reference a model to learn what kind of data they’re dealing with. Collections
    are similar to models and use a unique identifier to teach Rendr what kind of
    collection they are and a URL from which you can fetch data. The following code
    shows the Users collection in code. It should be placed in `app/collections/users.js`:'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你在[第7.4节](#ch07lev1sec4)中的案例研究一样，集合需要引用一个模型来学习它们正在处理的数据类型。集合类似于模型，并使用一个唯一标识符来告诉Rendr它们是哪种集合，以及你可以从中获取数据的URL。以下代码展示了代码中的用户集合。它应该放在`app/collections/users.js`中：
- en: '[PRE179]'
  id: totrans-1021
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'The Repos collection is almost identical, except it uses the Repo model, and
    it has a different URL for fetching the data from the REST API. The code is as
    follows, and it should go in `app/collections/repos.js`:'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库集合几乎相同，除了它使用Repo模型，并且它有一个不同的URL从REST API获取数据。代码如下，并且应该放在`app/collections/repos.js`中：
- en: '[PRE180]'
  id: totrans-1023
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: At this point, the user requested a URL, and the router decided which controller
    action that should direct them to. The action method probably fetched data from
    the API and then it invoked its callback. At last, let’s learn how views behave
    to render the HTML.
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，用户请求了一个URL，路由器决定将他们引导到哪个控制器动作。动作方法可能从API获取数据，然后调用其回调。最后，让我们学习一下视图是如何渲染HTML的。
- en: Views and templates
  id: totrans-1025
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 视图和模板
- en: 'As with most things Rendr, the first step in defining your views is creating
    your own base view, which is an extension of Rendr’s base view. The base view
    should go in `app/views/base.js` and look like the following code:'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Rendr中的大多数事情一样，定义你的视图的第一步是创建你自己的基本视图，这是Rendr基本视图的扩展。基本视图应该放在`app/views/base.js`中，如下所示代码：
- en: '[PRE181]'
  id: totrans-1027
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'Your first view is the Home view. It should be placed at `app/views/home/index.js`
    and look like the following. As you can see, views also need to export an identifier:'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 你的第一个视图是主页视图。它应该放在`app/views/home/index.js`中，如下所示。正如你所看到的，视图也需要导出一个标识符：
- en: '[PRE182]'
  id: totrans-1029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'Given that your views consist mostly of links to each other, but not much functionality,
    they’re mostly empty. The Users view is almost identical to the Home view. It
    goes in `app/views/users/index.js`, and its code follows:'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你的视图主要由相互链接组成，但功能不多，它们大多是空的。用户视图几乎与主页视图相同。它放在`app/views/users/index.js`中，其代码如下：
- en: '[PRE183]'
  id: totrans-1031
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: The User Details view goes in `app/views/users/show.js`. This view has to tamper
    with the template data, which is what I’ve referred to as the view model, to make
    the `repos` object available to the template, as shown in the following listing.
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 用户详情视图放在`app/views/users/show.js`中。这个视图必须修改模板数据，这就是我所说的视图模型，以便将`repos`对象提供给模板，如下所示。
- en: Listing 7.23\. Making the `repos` object available to the template
  id: totrans-1033
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.23\. 使`repos`对象可用于模板
- en: '[PRE184]'
  id: totrans-1034
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'The last view you’ll put together is a partial to render a list of repositories.
    It should be placed in `app/views/user_repos_view.js`, and as you can see, partials
    barely differ from other views, and they need a view controller like any other
    view:'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要组合的最后一个视图是一个部分视图，用于渲染仓库列表。它应该放在`app/views/user_repos_view.js`中，正如你所看到的，部分视图几乎与其他视图没有区别，并且它们需要一个视图控制器，就像其他视图一样：
- en: '[PRE185]'
  id: totrans-1036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: Last, there are the view templates. The first view template you’ll look at is
    the `layout .hbs` file. This is the HTML that will serve as a container for all
    your templates. You can find the code in the following listing. Note that you’re
    bootstrapping the application data and initializing it using JavaScript. This
    is required by Rendr. The `{{{body}}}` expression will be replaced by the views
    dynamically as the route changes.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是视图模板。你将要查看的第一个视图模板是`layout .hbs`文件。这是将作为所有模板容器的HTML。你可以在以下列表中找到代码。请注意，你正在启动应用程序数据并使用JavaScript初始化它。这是Rendr所必需的。`{{{body}}}`表达式将被视图动态替换，随着路由的变化。
- en: Listing 7.24\. Bootstrapping the application data
  id: totrans-1038
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.24\. 启动应用程序数据
- en: '[PRE186]'
  id: totrans-1039
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: Next you have the Home view template. Here are a few links with no view model
    data access going on. This template goes in `app/templates/home/index.hbs`. Note
    that Backbone will capture navigation to any links in your application that match
    one of its routes and behave as a single-page application. Rather than reloading
    the entire page whenever a link is clicked, Backbone will load the corresponding
    view.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是主页视图模板。这里有一些没有访问视图模型数据的链接。这个模板放在`app/templates/home/index.hbs`中。请注意，Backbone会捕获导航到任何匹配其路由的应用程序中的链接，并表现得像一个单页应用程序。而不是在点击链接时重新加载整个页面，Backbone将加载相应的视图。
- en: '[PRE187]'
  id: totrans-1041
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'Now things get more interesting. Here you’re looping through the list of models
    that were fetched in the controller action, and rendering a list of users and
    links to their account details. This template goes in `app/templates/users/index.hbs`:'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 现在事情变得更有趣了。在这里，你正在遍历控制器操作中获取的模型列表，并渲染用户列表及其账户详情链接。这个模板放在`app/templates/users/index.hbs`：
- en: '[PRE188]'
  id: totrans-1043
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: Next up you have the User Details template, which goes in `app/templates/users/show.hbs`.
    You can find the template code in the following listing. Take into account how
    you’re telling Handlebars to load the `user_repos_view` partial and how that name
    matches exactly the identifier that was defined in its view.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是用户详情模板，它位于`app/templates/users/show.hbs`。你可以在下面的列表中找到模板代码。考虑到你是如何告诉Handlebars加载`user_repos_view`部分的，以及这个名字如何与定义在其视图中的标识符完全匹配。
- en: Listing 7.25\. Setting up the User Details template
  id: totrans-1045
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.25. 设置用户详情模板
- en: '[PRE189]'
  id: totrans-1046
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: The User Repos view is your last view template, a partial in this case. It has
    to be located at `app/templates/user_repos_view.hbs,` and it’s used to iterate
    through a collection of repositories, displaying interesting metrics about each
    repository, as shown in the following listing.
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 用户仓库视图是你的最后一个视图模板，在这个例子中是一个部分。它必须位于`app/templates/user_repos_view.hbs`，它用于遍历一组仓库，显示每个仓库的有趣指标，如下面的列表所示。
- en: Listing 7.26\. Setting up the User Repos template
  id: totrans-1048
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.26. 设置用户仓库模板
- en: '[PRE190]'
  id: totrans-1049
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: That’s it! Phew. As you can see, once you get past the vast amount of boilerplate
    code around your application, creating a Rendr app isn’t that hard. I’m sure over
    time they’ll reduce the amount of boilerplate around the meat of your Rendr applications.
    The nice aspect of creating an application using Rendr, Backbone, and CommonJS
    is how modular your code can become. Modularity is one of the characteristic properties
    of testable code.
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！呼。正如你所见，一旦你绕过围绕应用程序的大量样板代码，创建一个Rendr应用程序并不那么困难。我确信随着时间的推移，它们会减少围绕Rendr应用程序核心的样板代码量。使用Rendr、Backbone和CommonJS创建应用程序的可爱之处在于你的代码可以多么模块化。模块化是可测试代码的特征属性之一。
- en: 7.6\. Summary
  id: totrans-1051
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6. 概述
- en: 'Wow, we certainly accomplished big results in this chapter:'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，我们在这个章节中确实取得了很大的成果：
- en: You learned why jQuery isn’t enough, and how a more structured approach would
    help you with the application development process.
  id: totrans-1053
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你学习了为什么jQuery不够用，以及更结构化的方法如何帮助你进行应用程序开发过程。
- en: You got an overview of how Model-View-Controller patterns are supposed to work.
  id: totrans-1054
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你对模型-视图-控制器模式应该如何工作有一个概述。
- en: You went on a Backbone adventure after learning about the basic concepts in
    Backbone.
  id: totrans-1055
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在了解了Backbone的基本概念之后，你开始了Backbone的冒险之旅。
- en: You exploited CommonJS and Browserify to get modular Backbone components interoperating
    in the browser.
  id: totrans-1056
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你利用CommonJS和Browserify使模块化的Backbone组件在浏览器中互操作。
- en: You took advantage of Rendr to bring a Backbone application to the server side,
    improving perceived performance.
  id: totrans-1057
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你利用Rendr将Backbone应用程序带到服务器端，提高了感知性能。
- en: Let’s use this momentum to learn more about testability and how to write good
    tests. All kinds of testing await; turn the page already!
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用这种势头来学习更多关于可测试性和如何编写良好测试的知识。各种测试都在等待；翻到下一页吧！
- en: Chapter 8\. Testing JavaScript components
  id: totrans-1059
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8章. 测试JavaScript组件
- en: '*This chapter covers*'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Applying unit testing fundamentals to JavaScript components
  id: totrans-1061
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将单元测试基础知识应用于JavaScript组件
- en: Writing unit tests in Tape
  id: totrans-1062
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Tape中编写单元测试
- en: Mocking, spying, and proxying
  id: totrans-1063
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟、监视和代理
- en: Testing browsers hands-on
  id: totrans-1064
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动测试浏览器
- en: Using Grunt for test automation
  id: totrans-1065
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Grunt进行测试自动化
- en: Understanding integration and visual testing
  id: totrans-1066
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解积分和视觉测试
- en: By writing tests, you’ll improve the reliability of the modules and applications
    you build and insure they work the way you intend. In typical Build First fashion,
    you’ll get the necessary insight to automate those tests and run them on the cloud.
    This chapter includes a few guidelines that will help you write tests, and you
    will also get hands-on experience in testing components. In some cases I’ll walk
    you through the tests that you may write for a given piece of code, helping you
    visualize the thought process behind writing thoughtful unit tests.
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写测试，你可以提高你构建的模块和应用程序的可靠性，并确保它们按你预期的那样工作。按照典型的“先构建”风格，你将获得必要的洞察力来自动化这些测试并在云上运行它们。本章包含一些指导方针，将帮助你编写测试，你还将获得实际测试组件的经验。在某些情况下，我会带你了解你可能为给定代码块编写的测试，帮助你可视化编写深思熟虑的单元测试背后的思维过程。
- en: While I’m not an advocate for the Test-Driven Development (TDD) paradigm, which
    encourages you to write tests before you develop any functionality, I think tests
    are important, and you should write them. In this chapter we’ll go back and forth
    between process design and application design. You’ll look at how to write tests,
    and then I’ll give you the tools to automate testing.
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我不是测试驱动开发（TDD）范式的倡导者，该范式鼓励你在开发任何功能之前编写测试，但我认为测试很重要，你应该编写它们。在本章中，我们将交替进行流程设计和应用设计。你将了解如何编写测试，然后我会给你提供自动化测试的工具。
- en: '|  |'
  id: totrans-1069
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**What do you mean you’re not an advocate for TDD?**'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: '**你是什么意思，你不是TDD的倡导者？**'
- en: That’s right. I wouldn’t recommend you use TDD, so let me elaborate on that.
    I don’t have anything against TDD itself, but writing tests is already a large
    commitment. If you’re getting started and throw TDD into your learning process,
    it probably won’t work out well for you. It definitely didn’t work for me when
    I was first getting into testing! TDD can be overwhelming, and maybe you don’t
    write any tests because you don’t know where to start. Or maybe you write pointless
    ones, testing against the implementation itself rather than testing the underlying
    interfaces and their expected behavior. Before attempting to learn TDD, I suggest
    that you try writing a few tests for existing code. That way when (and if) you
    decide to go down the TDD route you’ll know how your tests should be structured,
    what parts are important to test, and what parts are not. More importantly, you’ll
    know whether writing a particular test case is necessary or even helpful. That
    being said, if you already have experience writing unit tests, and Test-Driven
    Development suits you, then I have nothing against that!
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 确实如此。我不建议你使用TDD，让我详细说明一下。我对TDD本身没有意见，但编写测试已经是一项重大的承诺。如果你是初学者，将TDD加入你的学习过程中，可能不会对你有好处。当我刚开始接触测试时，TDD对我肯定不起作用！TDD可能会让人感到不知所措，也许你不知道从哪里开始，或者你可能会编写一些无意义的测试，这些测试针对的是实现本身，而不是测试底层接口及其预期行为。在尝试学习TDD之前，我建议你尝试为现有代码编写一些测试。这样，当你（如果）决定走TDD路线时，你会知道你的测试应该如何构建，哪些部分是重要的测试点，哪些部分不是。更重要的是，你会知道编写特定测试用例是否必要，甚至是否有帮助。话虽如此，如果你已经具备编写单元测试的经验，并且测试驱动开发适合你，那么我对此没有异议！
- en: '|  |'
  id: totrans-1072
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You learned about modularity, mostly in [chapter 5](kindle_split_017.html#ch05);
    improving your asynchronous flows, as discussed in [chapter 6](kindle_split_018.html#ch06);
    and structuring your code in a more organized manner, thanks to the MVC pattern
    in [chapter 7](kindle_split_019.html#ch07). All that modularity helps drive down
    the complexity in your application designs by creating smaller components that
    are easier to work on and understand. A benefit of the work you’ve accomplished
    so far in [part 2](kindle_split_016.html#part02) is that testing becomes much
    simpler.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 你主要在[第5章](kindle_split_017.html#ch05)中学习了模块化；在第6章中讨论了改进你的异步流程；以及通过第7章中的MVC模式，以更有组织的方式构建你的代码。所有这些模块化都有助于通过创建更小的组件来降低你的应用设计复杂性，这些组件更容易操作和理解。到目前为止，在[第2部分](kindle_split_016.html#part02)中完成的工作的一个好处是，测试变得简单得多。
- en: 8.1\. JavaScript testing crash course
  id: totrans-1074
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1\. JavaScript测试速成课程
- en: The essence of testing lies in learning how to isolate functionality so that
    it can be easily tested. This is the reason modularity is so important for attaining
    more testable code, which in turn improves quality, the cornerstone of Build First.
    Modular, loosely coupled code is easier to test because you have fewer things
    to account for, and your tests can be contained in small units that are only concerned
    with one small piece of code getting something right. In contrast, monolithic,
    tightly coupled code is harder to test because more things can go wrong, many
    of which might be completely unrelated to the piece of functionality you were
    attempting to test.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的本质在于学习如何隔离功能，以便于轻松地进行测试。这就是为什么模块化对于获得更易于测试的代码如此重要的原因，这反过来又提高了质量，这是“先构建”的基石。模块化、松散耦合的代码更容易测试，因为你要考虑的事情更少，你的测试可以包含在小的单元中，这些单元只关注一小段代码的正确性。相比之下，单体、紧密耦合的代码更难测试，因为可能出现更多错误，其中许多可能与你试图测试的功能部分完全无关。
- en: 8.1.1\. Logical units in isolation
  id: totrans-1076
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.1\. 独立的逻辑单元
- en: 'Consider the following contrived example for reference. You have a method that
    queries an API endpoint (you’ll learn about API design in [chapter 9](kindle_split_021.html#ch09),
    so hang tight), and then crunches numbers before returning a value. Suppose you
    want to make sure the data, whatever it was, was correctly multiplied by 555:'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下虚构的示例以供参考。你有一个查询 API 端点的方法（你将在[第9章](kindle_split_021.html#ch09)中学习关于 API
    设计的内容，所以请耐心等待），然后在对数字进行计算后再返回一个值。假设你想确保数据，无论是什么，都被正确地乘以 555：
- en: '[PRE191]'
  id: totrans-1078
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'In this case, you don’t care about the bits of this method that don’t have
    to do with the computational part, and they get in the way of your testing. Testing
    becomes harder, as you now need to deal with the Promise stuff to verify that
    the data gets computed correctly. You might want to consider refactoring this
    into two smaller methods, one that does computation only, and one that deals with
    querying the API:'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你不需要关心这个方法中与计算部分无关的部分，它们会妨碍你的测试。测试变得困难，因为你现在需要处理 Promise 的事情来验证数据是否被正确计算。你可能想要考虑将其重构为两个更小的方法，一个只做计算，另一个处理查询
    API：
- en: '[PRE192]'
  id: totrans-1080
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'This kind of separation of concerns enables reusability, because you could
    run the computation in other places in your code that might need it. More importantly,
    it’s much easier to test the computation in isolation now. The following piece
    of code is good enough at making sure the `compute` method works as intended:'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关注点的分离使得可重用性成为可能，因为你可以将计算运行在代码的其他可能需要它的地方。更重要的是，现在单独测试计算要容易得多。以下代码片段足以确保 `compute`
    方法按预期工作：
- en: '[PRE193]'
  id: totrans-1082
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: Things become much easier when you use a library equipped to help with testing
    requirements, and I’ll teach you how to use the Tape library, which adheres to
    a unit testing protocol called Test Anything Protocol^([[1](#ch08fn01)]) (TAP).
    Other popular JavaScript testing libraries include Jasmine and Mocha, but we’ll
    stay away from those. They involve more complicated setups, often requiring a
    test harness and filling the global namespace with global variables. We’ll be
    using Tape, which doesn’t rely on globals or a test harness, and makes it easy
    to test code regardless of whether it’s written for Node.js or the browser.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用一个配备帮助测试需求的库时，事情会变得容易得多，我将教你如何使用 Tape 库，它遵循一个名为测试任何协议 (TAP) 的单元测试协议^([[1](#ch08fn01)))。其他流行的
    JavaScript 测试库包括 Jasmine 和 Mocha，但我们不会涉及那些。它们涉及更复杂的设置，通常需要一个测试框架并在全局命名空间中填充全局变量。我们将使用
    Tape，它不依赖于全局或测试框架，并且使得测试代码变得容易，无论它是为 Node.js 还是浏览器编写的。
- en: ¹ Visit [http://testanything.org](http://testanything.org) to learn more about
    the Test Anything Protocol.
  id: totrans-1084
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ 访问 [http://testanything.org](http://testanything.org) 了解更多关于测试任何协议的信息。
- en: 8.1.2\. Using the Test Anything Protocol (TAP)
  id: totrans-1085
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.2\. 使用测试任何协议 (TAP)
- en: 'TAP is a test protocol implemented in a variety of languages, including Node.js.
    There are a few ways in which you can execute `tap` tests:'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: TAP 是在多种语言中实现的测试协议，包括 Node.js。你可以通过几种方式执行 `tap` 测试：
- en: Using `node` to run the tests directly in your terminal
  id: totrans-1087
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `node` 在你的终端中直接运行测试
- en: In a browser, compiling the tests to client-side JavaScript using Browserify
  id: totrans-1088
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在浏览器中，使用 Browserify 将测试编译为客户端 JavaScript
- en: Remotely, using automation services such as Travis-CI, the way you did in [chapter
    4](kindle_split_015.html#ch04)
  id: totrans-1089
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程使用自动化服务，如 Travis-CI，就像你在[第4章](kindle_split_015.html#ch04)中做的那样
- en: To get things started, you’ll look at how to use Tape in your local environment
    by plainly firing up a browser. In [section 8.4](#ch08lev1sec4) you’ll learn how
    to automate this process using Grunt to avoid firing up the browser on your own,
    and I’ll explain how to include it in your CI workflows.
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，你将了解如何在本地环境中使用 Tape，只需简单地启动一个浏览器。在[第8.4节](#ch08lev1sec4)中，你将学习如何使用 Grunt
    自动化此过程，以避免自己启动浏览器，我将解释如何将其包含在你的 CI 工作流程中。
- en: Getting started with JavaScript unit tests that need a browser can be confusing
    at first. You’ll set up a pointless unit test in Node first, and then you’ll run
    that in the browser before getting to unit testing principles and advice, which
    you’ll find in [section 8.2](#ch08lev1sec2).
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用需要浏览器的 JavaScript 单元测试可能会让人一开始感到困惑。你首先在 Node 中设置一个无意义的单元测试，然后在你到达单元测试原则和建议之前，在浏览器中运行它，这些原则和建议你可以在[第8.2节](#ch08lev1sec2)中找到。
- en: 8.1.3\. Putting together our first unit test
  id: totrans-1092
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.3\. 编写我们的第一个单元测试
- en: 'To create your first unit test and run it in the browser, start with the `compute`
    function from the previous examples in this chapter, placed in a CommonJS module.
    This example is available as ch08/01_your-first-tape-test in the samples. You
    can save this file in `src/compute.js`:'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建你的第一个单元测试并在浏览器中运行它，从本章前面示例中的`compute`函数开始，将其放在一个CommonJS模块中。这个例子在samples中的ch08/01_your-first-tape-test可用。你可以把这个文件保存到`src/compute.js`：
- en: '[PRE194]'
  id: totrans-1094
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'In the following code you’ll find the unit test written using `tape`, which
    provides an interface to perform basic assertions. Once you create a test, you
    can give it a name and a function will provide an interface to write your test.
    You’ll learn more about assertions in [section 8.2](#ch08lev1sec2). Each test
    case in Tape can be defined using a description and a test method. You’ll place
    this file in `test/compute.js`:'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，你可以找到使用`tape`编写的单元测试，它提供了一个执行基本断言的接口。一旦创建了一个测试，你可以给它命名，一个函数将提供一个接口来编写你的测试。你将在[第8.2节](#ch08lev1sec2)中了解更多关于断言的内容。Tape中的每个测试用例都可以使用描述和测试方法来定义。你将把这个文件放在`test/compute.js`：
- en: '[PRE195]'
  id: totrans-1096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'Note that you have to `require` the `compute` function to test it. Tape won’t
    load your source code for you. Similarly, the `tape` module should also be `require`d.
    The API is fairly simple and requires you to call `t.end()` to denote when a test
    has finished. Tape is mostly concerned with assertions about your assumptions
    and tracking test results. To run any tests written using `tape`, you merely need
    to run the code using Node:'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你必须`require` `compute`函数来测试它。Tape不会为你加载源代码。同样，`tape`模块也应该被`require`。API相当简单，需要你调用`t.end()`来表示测试已完成。Tape主要关注关于你的假设的断言和跟踪测试结果。要运行使用`tape`编写的任何测试，你只需使用Node运行代码即可：
- en: '[PRE196]'
  id: totrans-1098
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: Let’s see what it takes to run these tests in the browser as well.
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在浏览器中运行这些测试需要什么。
- en: 8.1.4\. Tape in the browser
  id: totrans-1100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.4\. 浏览器中的Tape
- en: 'Running Tape tests in the browser is mostly a matter of Browserifying your
    tests. You could do this once by using the global Browserify package, or you could
    automate it using Grunt. Let’s automate it. You’ll need to use `grunt-browserify`
    to do that:'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中运行Tape测试主要是将你的测试browserify化。你可以通过使用全局Browserify包一次性完成，或者使用Grunt来自动化这个过程。让我们自动化它。你需要使用`grunt-browserify`来完成这个任务：
- en: '[PRE197]'
  id: totrans-1102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: Once you’ve installed `grunt-browserify`, you need to set up a Gruntfile the
    way you did throughout [part 1](kindle_split_011.html#part01), and configure the
    browserify task to compile your CommonJS code down to something browsers can interpret
    seamlessly. In the case of the unit test you’ve seen, your configuration could
    look like the following listing (you can find this example under ch08/02_tape-in-the-browser).
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 `grunt-browserify`，你需要按照[第1部分](kindle_split_011.html#part01)中的方式设置一个Gruntfile，并配置browserify任务将你的CommonJS代码编译成浏览器可以无缝解释的内容。在单元测试的例子中，你的配置可能看起来像以下列表（你可以在ch08/02_tape-in-the-browser下找到这个例子）。
- en: Listing 8.1\. Compiling code for a browser to interpret
  id: totrans-1104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.1\. 编译浏览器可解释的代码
- en: '[PRE198]'
  id: totrans-1105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: Using the `browserify:tests` target, you can compile the code so it can be referenced
    in an HTML file. As a last step you need to put together the HTML file. Luckily,
    you won’t need to touch it once it’s put together, because the JavaScript will
    be taken care of by the Browserify bundler, and you won’t need to change the script
    tags by hand or anything else in your HTML, as shown in the following listing.
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`browserify:tests`目标，你可以编译代码以便在HTML文件中引用。作为最后一步，你需要组合HTML文件。幸运的是，一旦组合好，你就不需要再碰它了，因为JavaScript将由Browserify打包器处理，你不需要手动更改HTML中的脚本标签或其他任何内容，如下面的列表所示。
- en: Listing 8.2\. Compiling code to be referenced by the HTML file
  id: totrans-1107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.2\. 编译代码以便HTML文件引用
- en: '[PRE199]'
  id: totrans-1108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: Running the tests will only be a matter of opening this HTML file with a browser.
    You’ll come back to Grunt later in the chapter to look at automating your testing
    process. Let’s talk about testing principles and how to apply them in JavaScript
    tests.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试只需用浏览器打开这个HTML文件即可。你将在本章后面回到Grunt，看看如何自动化测试过程。让我们谈谈测试原则以及如何在JavaScript测试中应用它们。
- en: 8.1.5\. Arrange, Act, Assert
  id: totrans-1110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.5\. 安排、行动、断言
- en: Writing unit tests is often made out to be a difficult and tedious process,
    but it doesn’t have to be. If your code is written with modularity and testability
    in mind, it’ll be much easier to test. Monolithic, tightly coupled code does turn
    testing into a complicated process. That’s because tests are most effective when
    they can verify small components in isolation, so you shouldn’t have to worry
    about dependencies. This type of testing is referred to as *unit testing*. The
    second most common type of testing is *integration testing*, which involves testing
    that the interaction between components works as expected, focusing on how the
    network of components operates. [Figure 8.1](#ch08fig01) compares both types of
    testing.
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 编写单元测试通常被认为是一个困难且繁琐的过程，但并不一定如此。如果您的代码是考虑到模块化和可测试性编写的，那么测试就会容易得多。单体、紧密耦合的代码确实会使测试变得复杂。这是因为测试在能够独立验证小组件时最有效，因此您不必担心依赖项。这种测试被称为*单元测试*。第二种最常见的测试类型是*集成测试*，它涉及测试组件之间的交互是否按预期工作，关注组件网络的操作方式。[图8.1](#ch08fig01)比较了这两种测试类型。
- en: Figure 8.1\. Differences between unit and integration testing strategies. Note
    that a combination of the two should be used. Unit tests and integration tests
    are not exclusive. Pure functions are discussed in [section 8.1.15](#ch08lev2sec15).
  id: totrans-1112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.1\. 单元测试和集成测试策略之间的差异。请注意，应结合使用这两种方法。单元测试和集成测试不是互斥的。纯函数在第8.1.15节[部分](#ch08lev2sec15)中讨论。
- en: '![](08fig01_alt.jpg)'
  id: totrans-1113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](08fig01_alt.jpg)'
- en: 8.1.6\. Unit testing
  id: totrans-1114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.6\. 单元测试
- en: In contrast with integration tests, which focus on interaction, good unit tests
    actively disregard interaction, only focusing on how a single component works
    in isolation. Furthermore, good unit tests don’t care about a component’s implementation
    details; they only focus on the component’s public API. That means good unit tests
    can be read as examples of how a component is expected to work. Even though not
    ideal, sometimes unit tests are the next best thing when a package’s documentation
    is lacking.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 与关注交互的集成测试相比，好的单元测试积极忽略交互，只关注单个组件在独立情况下如何工作。此外，好的单元测试不关心组件的实现细节；它们只关注组件的公共API。这意味着好的单元测试可以被视为组件预期如何工作的示例。尽管不是理想的情况，但有时当软件包的文档不足时，单元测试是次优选择。
- en: Good unit tests often follow the “Arrange Act Assert” (AAA) pattern, creating
    fake versions of dependencies in unit tests and spying on methods to make sure
    they are invoked. The following subsections explore those concepts. Before you
    get to [section 8.3](#ch08lev1sec3), you’ll go through real unit testing case
    scenarios.
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 好的单元测试通常遵循“安排 行动 断言”（AAA）模式，在单元测试中创建依赖项的模拟版本，并监视方法以确保它们被调用。以下小节将探讨这些概念。在您到达第8.3节[部分](#ch08lev1sec3)之前，您将经历实际的单元测试案例场景。
- en: 'The AAA pattern can help you to develop concise and organized unit tests. It
    consists of building your unit tests in three stages:'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: AAA模式可以帮助您开发简洁且有序的单元测试。它包括在三个阶段构建单元测试：
- en: 'Arrange: You create instances of everything needed by your test.'
  id: totrans-1118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安排：您创建测试所需的所有实例。
- en: 'Act: You execute your tests and track their results.'
  id: totrans-1119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行动：您执行测试并跟踪其结果。
- en: 'Assert: You verify whether the results match the expected output.'
  id: totrans-1120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断言：您验证结果是否与预期输出匹配。
- en: Following these simple steps, it’s easy to find your place when skimming through
    a unit test. Assertions are used to verify, for instance, the result of `typeof
    {}` matches `object.` Note that when these steps can be simplified into a single,
    readable line, you probably should do so.
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这些简单的步骤，在快速浏览单元测试时很容易找到自己的位置。断言用于验证，例如，`typeof {}`的结果是否匹配`object`。请注意，当这些步骤可以简化为单行且易于阅读时，您可能应该这样做。
- en: 8.1.7\. Convenience over convention
  id: totrans-1122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.7\. 便利性胜过约定
- en: Some purists will tell you to do only a single assertion per unit test. I suggest
    you stay pragmatic and allow yourself to write a few assertions in the same test,
    as long as they test the same specific piece of functionality. It won’t hurt if
    you do, because the test harness (Tape, in your case) will tell you exactly which
    assertion failed in which test. Using a single assertion per test often leads
    to massive code duplication and frustrating testing sessions.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 一些纯粹主义者会告诉您每个单元测试只做一次断言。我建议您保持务实，并允许自己在同一测试中写几个断言，只要它们测试的是同一具体的功能。如果您这样做，也不会有什么坏处，因为测试框架（在您的案例中是Tape）会确切地告诉您哪个断言在哪个测试中失败了。通常，每个测试使用单个断言会导致大量代码重复和令人沮丧的测试会话。
- en: '8.1.8\. Case study: unit testing an event emitter'
  id: totrans-1124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.8\. 案例研究：单元测试事件发射器
- en: Let’s write tests against the `emitter` method, which augments objects allowing
    them to emit and listen to events that we saw back in [chapter 6](kindle_split_018.html#ch06).
    That should give you a good idea what a real unit test might look like. The following
    listing (available as ch08/03_arrange-act-assert in the samples) shows the full
    method in all its glory. This is the same event `emitter` method you implemented
    in [section 6.4.2](kindle_split_018.html#ch06lev2sec14).
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为 `emitter` 方法编写测试，该方法增强对象，使它们能够发出和监听我们在 [第 6 章](kindle_split_018.html#ch06)
    中看到的事件。这应该能给你一个关于真实单元测试可能的样子的大致概念。以下列表（在示例中可用，位于 ch08/03_arrange-act-assert）展示了该方法的全貌。这正是你在
    [第 6.4.2 节](kindle_split_018.html#ch06lev2sec14) 中实现的事件 `emitter` 方法。
- en: Listing 8.3\. Your event `emitter` implementation
  id: totrans-1126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.3\. 你的事件 `emitter` 实现方法
- en: '[PRE200]'
  id: totrans-1127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'How do you test all of that? It’s pretty big! Repeat after me: test against
    the interface. The rest doesn’t matter that much. You want to make sure that,
    given the correct parameters, each of the public API methods does what you expect
    it to do. In the case of the `emitter` function, the API consists of the `emitter`
    function itself, the `on` method, and the `emit` method. The API is anything that
    can be accessed by the consumer, which is what you want to verify.'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何测试所有这些？这相当大！跟我重复：测试接口。其余的并不那么重要。你想要确保，给定正确的参数，每个公共 API 方法都按照你期望的方式执行。在 `emitter`
    函数的情况下，API 包括 `emitter` 函数本身、`on` 方法和 `emit` 方法。API 是消费者可以访问的任何东西，这正是你想要验证的。
- en: You can think of writing good unit tests as asserting the right things. The
    assertions your tests will verify should be deterministic, and they should also
    disregard implementation details, such as how the event listeners are stored.
    Private methods are typically implementation details, and you shouldn’t worry
    about testing them; only the public interface matters. If you want to test private
    methods, you’ll have to expose them so that they can be unit tested like any other
    public interface method.
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将编写好的单元测试视为断言正确的事情。你的测试将验证的断言应该是确定的，并且它们也应该忽略实现细节，例如事件监听器是如何存储的。私有方法通常是实现细节，你不需要担心测试它们；只有公共接口才是重要的。如果你想测试私有方法，你必须将它们公开，以便它们可以像任何其他公共接口方法一样进行单元测试。
- en: 8.1.9\. Testing the event emitter
  id: totrans-1130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.9\. 测试事件发射器
- en: To get things going, let’s start with a test asserting whether calling `emitter`
    with different arguments results in an emitter object. This is a basic test in
    which you’ll verify that an object is returned with the expected properties (`on`
    and `emit`) on it.
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，让我们从一个测试开始，断言使用不同的参数调用 `emitter` 是否会导致发射器对象。这是一个基本测试，你将验证返回的对象具有预期的属性（`on`
    和 `emit`）。
- en: Listing 8.4\. Your first test using TAP
  id: totrans-1132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.4\. 使用 TAP 编写的第一个测试
- en: '![](218fig01_alt.jpg)'
  id: totrans-1133
  prefs: []
  type: TYPE_IMG
  zh: '![218fig01_alt.jpg](218fig01_alt.jpg)'
- en: It’s always good to have unit tests that assert the basics of how something
    is expected to operate. Keep in mind that you only need to write these tests once,
    and they’ll help you assert these validations anytime. Let’s write a few more
    basic assertions in the following listing, making sure the returned object is
    indeed the same object you provided.
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 总是拥有断言某物预期操作基本方法的单元测试是件好事。记住，你只需要编写这些测试一次，它们将帮助你随时断言这些验证。让我们在以下列表中编写一些更多的基本断言，确保返回的对象确实是提供的同一个对象。
- en: Listing 8.5\. Writing basic assertions
  id: totrans-1135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.5\. 编写基本断言
- en: '[PRE201]'
  id: totrans-1136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: In the “basic JavaScript unit test” department, you’ll sometimes find tests
    asserting whether something that’s supposed to be a function is indeed a function.
    Although it’s true that any other test would fail if `emitter` wasn’t a function,
    redundancy is a good thing to have when it comes to unit testing. In addition,
    your tests should fail at assertions rather than while arranging or acting. If
    your tests fail somewhere else, it might indicate it’s time to add more tests
    to assert that doesn’t happen, or maybe the problem lies with your code.
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 在“基本的 JavaScript 单元测试”领域，你有时会找到断言某物应该是一个函数的测试，实际上确实是一个函数。虽然如果 `emitter` 不是一个函数，其他任何测试都会失败，但冗余在单元测试中是一件好事。此外，你的测试应该在断言处失败，而不是在安排或执行时失败。如果你的测试在其他地方失败，可能意味着是时候添加更多测试来断言不会发生这种情况，或者问题可能出在你的代码上。
- en: Testing for object types might seem trivial, but it can pay off. Even more important
    is testing return value types. The first test you wrote made sure the properties
    were there, but it didn’t check if they were functions. Let’s rework it, adding
    type checks. These will seem like trivial changes, but you want to be explicit
    about the purposes of an assertion, for clarity.
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 测试对象类型可能看起来很 trivial，但可能会带来回报。更重要的是测试返回值类型。你编写的第一个测试确保了属性存在，但没有检查它们是否是函数。让我们重新设计它，添加类型检查。这些变化可能看起来很
    trivial，但你希望明确断言的目的，以便清晰。
- en: Listing 8.6\. Type checking in your tests
  id: totrans-1139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.6. 测试中的类型检查
- en: '![](219fig01_alt.jpg)'
  id: totrans-1140
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](219fig01_alt.jpg)'
- en: 8.1.10\. Testing for the .on method
  id: totrans-1141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.10. 测试 `.on` 方法
- en: Next we’ll write tests for the `.on` method. This time around, we’ll be content
    if calling `.on` does not throw. In a bit, we’ll make sure that the listeners
    work when we test the `emit` method. Note how I wrote two different tests which
    are almost identical, even though they have different purposes. In testing, it’s
    fairly common to find duplicate code, and it’s fine to copy and paste, although
    it’s not encouraged to abuse it.
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写`.on`方法的测试。这一次，如果调用`.on`不抛出异常，我们就满意了。稍后，我们将确保在测试`emit`方法时监听器能够正常工作。注意，我编写了两个几乎完全相同的测试，尽管它们有不同的目的。在测试中，找到重复的代码是相当常见的，复制粘贴是可以的，尽管不鼓励滥用。
- en: Listing 8.7\. Testing the `.on` function
  id: totrans-1143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.7. 测试 `.on` 函数
- en: '![](ch08ex07-0.jpg)'
  id: totrans-1144
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](ch08ex07-0.jpg)'
- en: '![](ch08ex07-1.jpg)'
  id: totrans-1145
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](ch08ex07-1.jpg)'
- en: Last, you need to test the `emit` function. To do that, you’ll attach a few
    listeners, as before, and then you’ll emit the event. Then you’ll assert that
    the listeners fired correctly, once for each call to `.on`. Notice how if you
    changed `emit` to be asynchronous by wrapping the event handlers in a `setTimeout`
    call, this test would fail. In those cases, you can either adapt the test to the
    new functionality or avoid changing the functionality in the first place.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要测试`emit`函数。为此，你将像之前一样附加一些监听器，然后发出事件。然后你将断言监听器正确触发，每次调用`.on`时触发一次。注意，如果你将`emit`改为异步，通过在事件处理器中包装`setTimeout`调用，这个测试就会失败。在这种情况下，你可以调整测试以适应新的功能，或者一开始就避免改变功能。
- en: Listing 8.8\. Testing the `.emit` function
  id: totrans-1147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.8. 测试 `.emit` 函数
- en: '![](220fig02_alt.jpg)'
  id: totrans-1148
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](220fig02_alt.jpg)'
- en: Finally, let’s add one more method to make sure that `emit` passes any arguments
    to the event listener the way we expect.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们添加一个方法来确保`emit`以我们期望的方式将任何参数传递给事件监听器。
- en: Listing 8.9\. Further testing on .emit
  id: totrans-1150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.9. 对 `.emit` 的进一步测试
- en: '![](221fig01_alt.jpg)'
  id: totrans-1151
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](221fig01_alt.jpg)'
- en: That’s it! Your event emitter implementation is fully tested. You only wrote
    assertions that verify how the public API works, and you didn’t meddle with implementation
    details. At this point, you could add tests that deal with unconventional usage
    of the API, such as calling `emit()` without any arguments. Then you could decide
    whether you’d want `emit` to throw an exception in that particular case. Think
    of your tests as a formal and stricter API documentation.
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！你的事件发射器实现已经完全测试过了。你只编写了验证公共API如何工作的断言，而没有干涉实现细节。在这个阶段，你可以添加处理API非传统使用的测试，例如在没有参数的情况下调用`emit()`。然后你可以决定是否希望`emit`在特定情况下抛出异常。将你的测试视为正式和更严格的API文档。
- en: In the following section you’ll learn about creating mocks, spying on function
    calls, and proxying `require` statements.
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学习如何创建模拟、监视函数调用以及代理`require`语句。
- en: 8.1.11\. Mocks, spies, and proxies
  id: totrans-1154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.11. 模拟、间谍和代理
- en: Sometimes you want greater isolation, even though two parts of an application
    can’t be decoupled any further. The application might need to query a real database,
    fetch data using a service, or connect together different modules, or there may
    be some other reason why you can’t decouple the implementation. You can use a
    variety of different tools, such as mocks, spies, and proxies, to circumvent the
    testing issues introduced by tight coupling. [Figure 8.2](#ch08fig02) depicts
    the issue and the solution provided by these stubs.
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你想要更大的隔离性，即使应用程序的两个部分不能进一步解耦。应用程序可能需要查询真实数据库，使用服务获取数据，连接不同的模块，或者可能有其他原因不能解耦实现。你可以使用各种不同的工具，如模拟、间谍和代理，来绕过紧密耦合引入的测试问题。[图
    8.2](#ch08fig02) 描述了问题以及这些存根提供的解决方案。
- en: Figure 8.2\. Using source code as-is versus using mocks when testing
  id: totrans-1156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.2. 使用源代码与在测试中使用模拟
- en: '![](08fig02_alt.jpg)'
  id: totrans-1157
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](08fig02_alt.jpg)'
- en: Next up you’ll learn about mocking dependencies, which can come in handy if
    you’re working with a component that has external dependencies.
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将学习如何模拟依赖项，如果你正在使用具有外部依赖项的组件，这可能会很有用。
- en: 8.1.12\. Mocking
  id: totrans-1159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.12\. 模拟
- en: '*Mocking* creates fake instances of the dependencies (such as services or other
    objects) in your System Under Test (SUT). In statically typed languages, mocking
    often involves access to the compiler, often referred to as Reflection. One of
    the advantages of JavaScript being a dynamically-typed language is that you can
    create an object with a couple of properties and that’s it. Suppose you have to
    test the following snippet of code:'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: '*模拟* 在你的系统测试（SUT）中创建了依赖项（如服务或其他对象）的假实例。在静态类型语言中，模拟通常涉及对编译器的访问，通常称为反射。JavaScript
    作为一种动态类型语言的一个优点是，你可以创建一个具有几个属性的对象，然后就可以了。假设你必须测试以下代码片段：'
- en: '[PRE202]'
  id: totrans-1161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: In a real application, maybe that snippet accessed the network and queried an
    endpoint, getting back data from the application’s API. You should never need
    to connect to external services to run a unit test, making this an ideal scenario
    for mocking. In this case in particular, you’re making a `GET` request and calling
    back a `done` function with an optional error and data in return.
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，也许这个片段访问了网络并查询了一个端点，从应用程序的 API 获取数据。你永远不需要连接到外部服务来运行单元测试，这使得模拟成为一个理想的场景。在这种情况下，你正在发起一个
    `GET` 请求，并调用一个带有可选错误和数据返回的 `done` 函数。
- en: 'Mocking the `http` object using plain JavaScript, as it turns out, is easy.
    Note how you’re using `setTimeout` to keep the method asynchronous, the way the
    original code expected, and how you can conjure up any response you like to fit
    your test:'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纯 JavaScript 模拟 `http` 对象，实际上很容易。注意你如何使用 `setTimeout` 来保持方法异步，就像原始代码预期的那样，以及你如何可以随意构造任何响应来适应你的测试：
- en: '[PRE203]'
  id: totrans-1164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: The server-side aspect of this test, querying the real HTTP endpoint, should
    be handled in server tests, which isn’t a client-side concern anymore. Another
    option might be testing these things in integration tests, which is a topic you’ll
    navigate later in the chapter. I’ll introduce Sinon.js next. Sinon is a library
    for creating mocks, spies, and stubs. It also allows you to fake XHR requests,
    server responses, and timers. Let’s look at it.
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试的服务器端方面，查询真实的 HTTP 端点，应该在服务器测试中处理，这不再是客户端关心的问题了。另一个选择可能是将这些事情放在集成测试中测试，这是你将在本章后面了解的主题。接下来，我将介绍
    Sinon.js。Sinon 是一个用于创建模拟、间谍和存根的库。它还允许你模拟 XHR 请求、服务器响应和计时器。让我们看看它。
- en: 8.1.13\. Introducing Sinon.js
  id: totrans-1166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.13\. 介绍 Sinon.js
- en: Sometimes it’s not enough to mock values by hand, and in those more advanced
    case scenarios, using a library such as Sinon.js might come in handy. Sinon helps
    you easily test `setTimeout` delays, dates, XHR requests, and even set up fake
    HTTP servers to use in your tests. Using Sinon, it’s trivial to create functions
    called spies. *Spies* are functions that are prepared to tell you whether they’ve
    been called, how many times, and what arguments they were invoked with. As it
    turns out, you’ve already used a custom flavor of spies in [listing 8.9](#ch08ex09),
    where we had a `listener` function that kept track of how many times it was called.
    Let’s see how using spies helps assert function calls.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，仅仅手动模拟值是不够的，在那些更高级的场景中，使用像 Sinon.js 这样的库可能会很有帮助。Sinon 可以帮助你轻松地测试 `setTimeout`
    延迟、日期、XHR 请求，甚至设置假 HTTP 服务器以供测试使用。使用 Sinon，创建名为间谍（spies）的函数变得非常简单。*间谍* 是一种准备告诉你它们是否被调用、被调用的次数以及它们使用什么参数被调用的函数。实际上，你已经在
    [列表 8.9](#ch08ex09) 中使用了一种定制的间谍版本，其中我们有一个 `listener` 函数，它跟踪了被调用的次数。让我们看看使用间谍如何帮助断言函数调用。
- en: 8.1.14\. Spying on function calls
  id: totrans-1168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.14\. 监视函数调用
- en: Spies can be used whenever a function you’re testing requires function parameters,
    and you can use them to easily assert whether they’ve been used and how.
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 间谍可以在测试的函数需要函数参数时使用，并且你可以使用它们来轻松断言它们是否被使用以及如何使用。
- en: 'Let’s go through a simple example (found as ch08/04_spying-on-function-calls).
    Here’s a pair of functions that take a callback function parameter:'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的例子（在 ch08/04_spying-on-function-calls 中找到）来了解一下。这里有一对接受回调函数参数的函数：
- en: '[PRE204]'
  id: totrans-1171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'Sinon makes it easy to test these. Without the need to construct a custom callback,
    you can ensure that `immediate` invoked your callback exactly once:'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: Sinon 使得测试这些变得容易。无需构建自定义回调，你可以确保 `immediate` 函数正好调用了一次你的回调：
- en: '[PRE205]'
  id: totrans-1173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: Note how I switched from `t.end` to `t.plan`. Using `t.plan(n)` allows you to
    define how many assertions you expect to be made during the execution of your
    test case. The test will fail if it doesn’t exactly match the number of asserts.
    This is most useful for asynchronous tests, where your code may or may not end
    up invoking a callback where you had a few more asserts. Using `t.plan` verifies
    that the correct amount of asserts were indeed executed.
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我是如何从 `t.end` 切换到 `t.plan` 的。使用 `t.plan(n)` 允许你定义在测试用例执行期间你期望进行的断言数量。如果测试没有精确匹配断言的数量，则测试将失败。这对于异步测试最有用，因为你的代码可能最终没有调用回调，其中你可能还有更多的断言。使用
    `t.plan` 可以验证确实执行了正确的断言数量。
- en: Testing delayed execution is a bit trickier, but Sinon provides an easy-to-use
    interface for that, as shown in the following listing. By calling `sinon.useFakeTimers()`,
    any subsequent calls to `setTimeout` or `setInterval` are going to be faked. You
    also get a simple `tick` API to manually change the clock.
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 测试延迟执行稍微有点复杂，但 Sinon 提供了一个易于使用的接口，如下面的列表所示。通过调用 `sinon.useFakeTimers()`，任何随后的对
    `setTimeout` 或 `setInterval` 的调用都将被模拟。你还得到一个简单的 `tick` API，可以手动更改时钟。
- en: Listing 8.10\. Testing delayed execution
  id: totrans-1176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.10\. 测试延迟执行
- en: '[PRE206]'
  id: totrans-1177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: Sinon.js has more tricks you can perform, such as creating fake XHR requests.
    The last topic I want to discuss regarding mocking is the case where you need
    to create a mock for the results provided by invoking `require` on any given module.
    Let’s check out how that works!
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: Sinon.js 有更多你可以执行的小技巧，例如创建假的 XHR 请求。关于模拟的最后一个话题，我想讨论的是当你需要为通过在给定的模块上调用 `require`
    而提供的任何结果创建模拟时的情况。让我们看看这是如何工作的！
- en: 8.1.15\. Proxying require calls
  id: totrans-1179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.15\. 代理调用需求
- en: The issue here is that sometimes modules require other modules, which in turn
    require additional modules, and you don’t want all that in unit tests. Unit tests
    are about controlling the environment, detecting the absolutely necessary pieces
    that are needed to execute a test, and mocking everything else. There’s a nice
    npm package called `proxyquire` that can help with that situation. Consider that
    you’d like to test the code in the following listing (available as ch08/05_proxying-your-dependencies
    in the samples), in which you’d like to fetch a user from the database and then
    return a subset of the model for security reasons.
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，有时模块需要其他模块，而这些模块又需要额外的模块，而你不希望在单元测试中看到所有这些。单元测试是关于控制环境，检测执行测试所需的绝对必要的部分，并模拟其他一切。有一个叫做
    `proxyquire` 的很好的 npm 包可以帮助这种情况。假设你想测试以下列表中的代码（在 samples 中的 ch08/05_proxying-your-dependencies
    可用），你希望从数据库中获取一个用户，然后出于安全原因返回模型的一个子集。
- en: Listing 8.11\. Using the `require` method
  id: totrans-1181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.11\. 使用 `require` 方法
- en: '[PRE207]'
  id: totrans-1182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: Let’s consider a small refactor for a moment. It’s always best to isolate “pure”
    functionality. A *pure function* is a concept that comes from functional programming,
    and it describes a function whose outputs are defined solely by its inputs and
    nothing else. Pure functions return the same value every time they receive the
    same inputs. In the example above, your pure and reusable piece of functionality
    is mapping the user model to its “safe” subset, so let’s extract that into its
    own function, and make your code a little prettier and easier to follow through.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时考虑一个小重构。始终最好将“纯”功能隔离。*纯函数*是函数式编程中的一个概念，它描述了一个函数，其输出仅由其输入定义，而与其他任何东西无关。纯函数每次接收到相同的输入时都会返回相同的值。在上面的例子中，你的纯且可重用的功能是将用户模型映射到其“安全”子集，所以让我们将其提取到自己的函数中，并使你的代码更加美观且易于理解。
- en: Listing 8.12\. Creating a pure function
  id: totrans-1184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.12\. 创建一个纯函数
- en: '[PRE208]'
  id: totrans-1185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: As you can see, though, unless you expose the `subset` function on its own,
    you’re stuck with querying the database to get a user. You could argue that the
    module should get a `user` object, instead of merely an `id`, and you’re right.
    Sometimes, however, you have to query the database. Maybe you have a `user` parameter
    and do something with it, but you also want to ask the database about his permissions
    or the groups he belongs to. In those cases, as well as in the previous case,
    assuming you don’t refactor it any further, a good way to get around the situation
    is to return a fake result from `require` calls.
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如你所见，除非你单独公开 `subset` 函数，否则你将陷入查询数据库以获取用户的困境。你可以争论该模块应该获取一个 `user` 对象，而不仅仅是
    `id`，这是正确的。然而，有时你不得不查询数据库。也许你有一个 `user` 参数并对其进行操作，但你还想询问数据库关于他的权限或他所属的组。在这些情况下，以及在前一种情况下，假设你没有进一步重构它，一个好的解决方案是从
    `require` 调用中返回一个模拟结果。
- en: The good news is that using `proxyquire` means you don’t have to change the
    application code at all. The following listing demonstrates how to use `proxyquire`
    to mock up a required module without resorting to a database at all. Note how
    the mock object you’re passing to `proxyquire` is a map of `require` paths and
    the results you want to get (rather than what you’d normally get).
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，使用 `proxyquire` 意味着你根本不需要更改应用程序代码。以下列表演示了如何使用 `proxyquire` 来模拟所需模块，而无需使用数据库。注意你传递给
    `proxyquire` 的模拟对象是 `require` 路径和期望得到的结果的映射（而不是你通常得到的结果）。
- en: Listing 8.13\. Mocking up a required module
  id: totrans-1188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.13\. 模拟所需模块
- en: '[PRE209]'
  id: totrans-1189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: Once you isolate the mapping functionality without resorting to a database connection,
    the test becomes trivial. You’re using the `mapper` function, complete with fake
    database access, and asserting whether it gives back an object with the `name`
    and `email` properties on it. Note that you’re using Sinon’s `cb.args` to figure
    out the arguments when the `cb` spy was first called.
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你通过不使用数据库连接来隔离映射功能，测试就变得非常简单。你正在使用带有模拟数据库访问的 `mapper` 函数，并断言它是否返回具有 `name`
    和 `email` 属性的对象。请注意，你正在使用 Sinon 的 `cb.args` 来确定 `cb` 间谍首次调用时的参数。
- en: Listing 8.14\. Creating spies with Sinon
  id: totrans-1191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.14\. 使用 Sinon 创建间谍
- en: '![](226fig01_alt.jpg)'
  id: totrans-1192
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](226fig01_alt.jpg)'
- en: In the following section I’ll go a bit deeper into client-side testing, talking
    about fake XHR (XMLHttpRequest). You’ll also get a feel for DOM interaction testing
    before you look at other forms of automation and a mention of non-unit testing
    flavors.
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我将更深入地探讨客户端测试，讨论模拟 XHR（XMLHttpRequest）。在你查看其他自动化形式和非单元测试类型之前，你还将对 DOM
    交互测试有所了解。
- en: 8.2\. Testing in the browser
  id: totrans-1194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2\. 浏览器中的测试
- en: Testing client-side code is typically a hassle because of both AJAX requests
    and DOM interaction. That, often paired with a complete lack of modularity and
    code organization, spells chaos for the client-side JavaScript test developer.
    That being said, in [chapter 5](kindle_split_017.html#ch05) you resolved your
    browser modularity concerns by settling for Browserify. Browserify allows you
    to use self-contained CommonJS modules even in client-side code but at the cost
    of an extra build step.
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 AJAX 请求和 DOM 交互，测试客户端代码通常很麻烦。这通常伴随着模块化和代码组织的完全缺乏，对客户端 JavaScript 测试开发者来说意味着混乱。尽管如此，在[第
    5 章](kindle_split_017.html#ch05)中，你通过选择 Browserify 解决了浏览器模块化的问题。Browserify 允许你在客户端代码中使用自包含的
    CommonJS 模块，但代价是额外的构建步骤。
- en: You also resolved code organization issues by resorting to an MVC framework
    on the client side, to keep your concerns properly separated. In [chapter 9](kindle_split_021.html#ch09),
    you’ll learn about REST API design, which you’ll apply to future web applications
    you write, getting rid of the endpoint chaos that usually characterizes front-end
    application development.
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 你还通过在客户端使用 MVC 框架来解决代码组织问题，以正确分离你的关注点。在[第 9 章](kindle_split_021.html#ch09)中，你将了解
    REST API 设计，你将将其应用于你未来编写的 Web 应用程序，消除通常表征前端应用程序开发的端点混乱。
- en: 'In the next section, you’ll learn how to write tests for your client-side code
    by mocking XHR requests and isolating DOM interaction so that you can write tests
    against it. Let’s start with the easy part: mocking up XHR requests and server
    responses.'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学习如何通过模拟 XHR 请求和隔离 DOM 交互来编写客户端代码的测试，以便你可以针对它编写测试。让我们从简单部分开始：模拟 XHR
    请求和服务器响应。
- en: 8.2.1\. Faking XHR and server communication
  id: totrans-1198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.1\. 模拟 XHR 和服务器通信
- en: Similarly to the way you created fake `require` results with `proxyquire`, you
    can use Sinon to mock any XHR requests you’d like, without modifying your source
    code. Use Sinon to simulate server responses and snoop request data. Those are
    the only reasons you’ll need to deal with XHR. [Figure 8.3](#ch08fig03) shows
    how these mocks can help you to isolate and test code that would normally depend
    on an external resource.
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于使用`proxyquire`创建假的`require`结果，你可以使用Sinon来模拟任何你想要的XHR请求，而无需修改你的源代码。使用Sinon来模拟服务器响应和监视请求数据。这些是你唯一需要处理XHR的原因。[图8.3](#ch08fig03)显示了这些模拟如何帮助你隔离和测试通常依赖于外部资源的代码。
- en: Figure 8.3\. Native XMLHttpRequest compared with fake XHR mocks during tests
  id: totrans-1200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.3\. 测试期间原生XMLHttpRequest与假XHR模拟的比较
- en: '![](08fig03_alt.jpg)'
  id: totrans-1201
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig03_alt.jpg)'
- en: To see how that might look in code, here’s a snippet of client-side JavaScript
    that makes an HTTP request and gives you the response text (see sample ch08/06_fake-xhr-requests).
    I’m using the `superagent` module to make the HTTP requests, because it works
    seamlessly in the server or the browser. Perfect for Browserifying action!
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看代码中的实现方式，这里有一个客户端JavaScript代码片段，它发起一个HTTP请求并返回响应文本（参见sample ch08/06_fake-xhr-requests）。我使用`superagent`模块来发起HTTP请求，因为它在服务器或浏览器中都能无缝工作。非常适合用于Browserifying操作！
- en: '[PRE210]'
  id: totrans-1203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: In this case you don’t want to write tests for `superagent` itself. You don’t
    want to test the API call, either. You probably want to make sure that an AJAX
    call is made, though. The method is supposed to call you back with the response
    text, so you should test for that as well, as shown in the following listing.
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你不想为`superagent`本身编写测试。你也不想测试API调用。你可能想确保确实发起了一个AJAX调用。该方法应该通过响应文本回调给你，所以你应该测试这一点，如下所示。
- en: Listing 8.15\. Creating a method that sends response text
  id: totrans-1205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.15\. 创建发送响应文本的方法
- en: '[PRE211]'
  id: totrans-1206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: That’s fine for testing the outcome, but you can’t afford to have tests depend
    on network conditions or to spend that long waiting to make assertions. The right
    way to test your method is to simulate the responses. Sinon allows you to do this
    by creating a fake server, which provides two-fold value. It captures real requests
    made by your code and transforms them into testable objects it controls. It also
    allows you to create responses for those requests within your tests, simulating
    an operational server. To get that functionality, create the fake server using
    `sinon.fakeServer.create()` before invoking the method under test. Then, once
    the method that’s supposed to create an AJAX request is invoked, you can respond
    to the request, setting your response’s status code, headers, and body. Let’s
    update your test method to reflect those changes.
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测试结果来说这很好，但你不能让测试依赖于网络条件，或者花费那么长时间等待来做出断言。测试你的方法的正确方式是模拟响应。Sinon允许你通过创建一个假服务器来实现这一点，它提供了双重价值。它捕获你的代码发出的真实请求，并将它们转换成它控制的可测试对象。它还允许你在测试中为这些请求创建响应，模拟一个运行中的服务器。为了获得这种功能，在调用测试方法之前，使用`sinon.fakeServer.create()`创建假服务器。然后，一旦调用了应该创建AJAX请求的方法，你可以响应这个请求，设置响应的状态码、头和正文。让我们更新你的测试方法以反映这些变化。
- en: Listing 8.16\. Testing the “Quote of the Day” service
  id: totrans-1208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.16\. 测试“每日名言”服务
- en: '[PRE212]'
  id: totrans-1209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: As you can see, you verified that a single request was made and that you got
    called back with exactly the same value as the response text.
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你验证了一个请求被发起，并且你确实收到了与响应文本完全相同的值。
- en: The last piece of browser testing to dabble in before heading over to the automation
    department is DOM interaction testing. Much like testing AJAX calls, DOM testing
    is complicated because you’re interacting with something that’s across a gap.
    Mind the gap.
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 在前往自动化部门之前，需要尝试的最后一块浏览器测试是DOM交互测试。DOM测试就像测试AJAX调用一样复杂，因为你正在与跨隔阂的东西交互。注意隔阂。
- en: '8.2.2\. Case study: testing DOM interaction'
  id: totrans-1212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.2\. 案例研究：测试DOM交互
- en: 'Client-side development and testing are funny in that way. You have three layers:
    HTML, JavaScript, and CSS, all working together to serve a sophisticated concoction
    of bits. Yet, as any good developer will, you must keep the concerns separated
    across the three technologies, trying not to couple them too tightly together.
    CSS is easy to leave untied. You create classes in CSS and assign them to DOM
    elements by giving them their matching `class` attributes. Your CSS starts falling
    apart when it makes assumptions about the structure of your HTML. The best pieces
    of CSS are those that don’t depend on the HTML being structured exactly in a particular
    way, those that aren’t tightly coupled to the HTML.'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端开发和测试就是这样有趣。你有三个层次：HTML、JavaScript和CSS，它们共同工作以提供复杂的位组合。然而，正如任何优秀的开发者所做的那样，你必须在这三种技术之间保持关注点的分离，尽量避免将它们过于紧密地耦合在一起。CSS很容易保持独立。你可以在CSS中创建类，并通过给它们匹配的`class`属性将它们分配给DOM元素。当CSS对HTML的结构做出假设时，它就开始崩溃了。最好的CSS是那些不依赖于HTML以特定方式结构的CSS，那些不紧密耦合到HTML的CSS。
- en: JavaScript and HTML are similar to CSS and HTML in that your HTML shouldn’t
    make any assumptions about your JavaScript. HTML should work fairly well even
    with JavaScript turned off; this is called progressive enhancement and it helps
    deliver primary content to your users faster, resulting in a better experience
    overall. The problem is that your JavaScript code must make assumptions about
    your HTML. Finding the inner text for a DOM node, attaching event listeners, reading
    data attributes, setting attributes, or any other form of DOM manipulation, leads
    with the assumption that a DOM node is there.
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript和HTML与CSS和HTML相似，你的HTML不应该对JavaScript做出任何假设。即使JavaScript被关闭，HTML也应该工作得相当好；这被称为渐进增强，它有助于更快地将主要内容传递给用户，从而提供更好的整体体验。问题是你的JavaScript代码必须对HTML做出假设。获取DOM节点的内部文本、附加事件监听器、读取数据属性、设置属性或任何其他形式的DOM操作，都是以假设DOM节点存在为前提的。
- en: Let’s get to your imaginary application where events come to party and decimal
    numbers get rounded.
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进入你的想象中的应用程序，其中事件来参加派对，十进制数字被四舍五入。
- en: Setting up the HTML
  id: totrans-1216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设置HTML
- en: In this application, you have an input where you’re meant to enter decimal numbers
    and then click on a button to get the rounded version of that same number back.
    Each result is written into a list that’s displayed on the page. There’s also
    another button to clear the result list. [Figure 8.4](#ch08fig04) depicts how
    the application should look.
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，你有一个输入框，你可以在其中输入十进制数字，然后点击按钮以获取该数字的四舍五入版本。每个结果都会写入页面上的一个列表中。还有一个按钮可以清除结果列表。[图8.4](#ch08fig04)展示了应用程序应有的外观。
- en: Figure 8.4\. The application you’ll be building in this case study
  id: totrans-1218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.4. 本案例研究中将要构建的应用程序
- en: '![](08fig04.jpg)'
  id: totrans-1219
  prefs: []
  type: TYPE_IMG
  zh: '![图片](08fig04.jpg)'
- en: We’ll start by going through the application, and explain the choices made along
    the way. Then, I’ll show you what you should be testing in this small application,
    and how you can get test coverage on those factors without worrying about implementation
    details.
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从浏览这个应用程序开始，并解释在过程中所做的选择。然后，我会向你展示在这个小型应用程序中你应该测试什么，以及如何在不担心实现细节的情况下对这些因素进行测试覆盖率。
- en: 'Consider the following piece of HTML. Note that you’re not writing any JavaScript
    in the DOM directly. Keeping your concerns separated is extremely important to
    testability:'
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下HTML片段。请注意，你不会在DOM中直接编写任何JavaScript。保持关注点的分离对于可测试性至关重要：
- en: '[PRE213]'
  id: totrans-1222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: Next you’ll learn how to implement JavaScript functionality.
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将学习如何实现JavaScript功能。
- en: Implementing the JavaScript functionality
  id: totrans-1224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现JavaScript功能
- en: Next we’ll discuss a small JavaScript application that interacts with the HTML
    shown in the previous example, using the JavaScript DOM API. To begin, you’ll
    use `query-Selector`, a (relatively) little-known but powerful native browser
    API that allows you to find DOM nodes in a similar fashion to how jQuery works,
    using CSS selectors. `querySelector` is supported in all major browsers, going
    as far back as Internet Explorer 8\. The API is present on the document root as
    well as on any DOM nodes, allowing you to limit the search to their children.
    If you want to look for many elements, instead of the first one, you can use `querySelectorAll`
    instead.
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论一个小的 JavaScript 应用程序，它使用 JavaScript DOM API 与前面示例中显示的 HTML 进行交互。首先，你将使用
    `querySelector`，这是一个相对不为人知但功能强大的原生浏览器 API，它允许你以类似 jQuery 的方式使用 CSS 选择器找到 DOM 节点。`querySelector`
    在所有主流浏览器中都受支持，甚至可以追溯到 Internet Explorer 8。该 API 存在于文档根以及任何 DOM 节点上，允许你将搜索限制在其子节点。如果你想查找多个元素，而不是第一个元素，你可以使用
    `querySelectorAll` 代替。
- en: '[PRE214]'
  id: totrans-1226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '|  |'
  id: totrans-1227
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-1228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: I never use the `id` attribute in HTML. It causes all sorts of problems, such
    as CSS selector precedence, leading to developers using `!important` style rules
    and the inability to reuse the value, because HTML `id` attributes are meant to
    be unique.
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 我从不使用 HTML 中的 `id` 属性。它会导致各种问题，例如 CSS 选择器优先级，导致开发者使用 `!important` 风格规则，并且无法重用值，因为
    HTML `id` 属性的本意是要保持唯一性。
- en: '|  |'
  id: totrans-1230
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Let’s implement the code in charge of figuring out how your input did. If it’s
    not a number, then that’s a mistake. If it’s an integer, that’s a problem too.
    Otherwise, you’ll return the rounded value:'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现负责确定你的输入如何处理的代码。如果它不是一个数字，那么那是一个错误。如果它是一个整数，那也是一个问题。否则，你将返回四舍五入的值：
- en: '[PRE215]'
  id: totrans-1232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: The `done` callback should create a new paragraph in your result list and fill
    it with the error message, if any, or the rounded value, if present. You’ll also
    set a different CSS class if you see an error than when you’re successful, to
    help a designer style the page accordingly without you making additional changes
    to your JavaScript, as shown in the following listing.
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: '`done` 回调应该在你的结果列表中创建一个新的段落，并用任何错误消息（如果有）或四舍五入的值（如果有）填充它。如果你看到错误，你将设置不同的 CSS
    类，以帮助设计师相应地设计页面，而无需你对 JavaScript 进行任何额外的更改，如下面的列表所示。'
- en: Listing 8.17\. Using the `done` callback
  id: totrans-1234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.17\. 使用 `done` 回调
- en: '[PRE216]'
  id: totrans-1235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'The last piece to the puzzle is binding the click event and parsing the input
    before handing it off to the two methods you put together in [listing 8.17](#ch08ex17).
    The following code snippet will do:'
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个拼图是绑定点击事件，在将输入传递给你在[列表 8.17](#ch08ex17)中组合的两个方法之前解析输入。以下代码片段将完成这项工作：
- en: '[PRE217]'
  id: totrans-1237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: Wiring up the Reset button is even easier. Your listener should remove every
    paragraph created by the barman; that’s as straightforward as it gets! The following
    listing shows how you might do it.
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 连接重置按钮甚至更容易。你的监听器应该移除酒吧管理员创建的每个段落；这再简单不过了！以下列表显示了你可以如何做到这一点。
- en: Listing 8.18\. Wiring a Reset button
  id: totrans-1239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.18\. 连接重置按钮
- en: '[PRE218]'
  id: totrans-1240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: That’s it; your application is fully operational. How can you make sure future
    refactorings don’t break existing code? You need to identify tests that ensure
    your code works as intended and then write those tests.
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样；你的应用程序已经完全可用。你如何确保未来的重构不会破坏现有的代码？你需要识别确保你的代码按预期工作的测试，然后编写这些测试。
- en: Identifying the test cases
  id: totrans-1242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 识别测试用例
- en: First off, let me go on a tangent to mention that you need to completely disregard
    the HTML at the beginning of this case study. You shouldn’t write any HTML in
    your tests. If you need a DOM, you should build it using JavaScript inside your
    tests. As you’ll see when you implement the tests, this can be even easier than
    writing HTML. Separating concerns is one of the most important aspects of unit
    testing.
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我偏离一下话题，提到你需要完全忽略这个案例研究开头的 HTML。你不应该在测试中编写任何 HTML。如果你需要一个 DOM，你应该在测试中使用
    JavaScript 来构建它。正如你将在实现测试时看到的那样，这甚至可能比编写 HTML 更容易。分离关注点是单元测试最重要的方面之一。
- en: Next, you should try and identify your application concerns and differentiate
    them from implementation details. For the sake of this experiment, consider everything
    you wrote previously to be implementation details, because your application doesn’t
    provide an API or even build a public-facing object of any sort. When everything
    in the implementation is an implementation detail, you can still unit test, but
    you need to test against what the application is supposed to do, as opposed to
    what each method is supposed to do.
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你应该尝试识别你的应用程序关注点并将它们与实现细节区分开来。为了进行这个实验，假设你之前写下的所有内容都是实现细节，因为你的应用程序没有提供API，甚至没有构建任何面向公众的对象。当实现中的每一件事都是实现细节时，你仍然可以进行单元测试，但你需要测试应用程序应该做什么，而不是每个方法应该做什么。
- en: The test cases are supposed to assert that the statements you can find in the
    application definition presented previously, quoted here, hold true when checked
    against its implementation.
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 测试案例应该断言你可以在之前呈现的应用程序定义中找到的语句，在与其实现进行核对时是正确的。
- en: '|  |'
  id: totrans-1246
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Application definition
  id: totrans-1247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 应用程序定义
- en: In this application you have an input where you enter decimal numbers and then
    click on a button to get the rounded version of that same number back. Each result
    is written into a list that’s displayed on the page. There’s also another button
    to clear the result list.
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，你有一个输入框，你可以输入十进制数字，然后点击按钮以获取该数字的四舍五入版本。每个结果都写入到页面上的列表中。还有一个按钮可以清除结果列表。
- en: '|  |'
  id: totrans-1249
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Several test cases are noted in the following list. These were derived from
    the quoted definition and other logic constraints imposed in the implementation
    (which you’d like to turn into part of the definition). Keep in mind you could
    prepare any test cases you want, as long as they satisfy the definition. These
    are the ones I designed:'
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表中列出了几个测试案例。这些是从引用的定义和其他实施中施加的逻辑约束（你希望将其变成定义的一部分）中得出的。请记住，你可以准备任何你想要的测试案例，只要它们满足定义即可。这些是我设计的：
- en: Clicking barman without input should result in an error message.
  id: totrans-1251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有输入时点击barman应该导致错误信息。
- en: Clicking barman with an integer should result in an error message.
  id: totrans-1252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用整数点击barman应该导致错误信息。
- en: Clicking barman with a number should result in a rounded number.
  id: totrans-1253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数字点击barman应该得到一个四舍五入的数字。
- en: Clicking barman twice, with two values should produce two results.
  id: totrans-1254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用两个值点击barman两次应该产生两个结果。
- en: Clicking clear when the list is empty does not throw.
  id: totrans-1255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当列表为空时点击清除不会抛出异常。
- en: Clicking clear removes any results in the list.
  id: totrans-1256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击清除将移除列表中的任何结果。
- en: Let’s get to the testing. I mentioned earlier that you’d create the DOM in code
    in every test. You’ll do that by creating a Setup task, called before every test,
    and a Teardown task, called after every test. Setup will create the elements.
    Teardown will remove them. This gives every test a clean slate even after another
    test has run.
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始测试。我之前提到过，你将在每个测试中通过代码创建DOM。你将通过创建一个在每次测试之前调用的Setup任务和一个在每次测试之后调用的Teardown任务来实现这一点。Setup将创建元素。Teardown将删除它们。这为每个测试提供了一个干净的起点，即使另一个测试已经运行。
- en: Setup and Teardown
  id: totrans-1258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Setup和Teardown
- en: Most JavaScript testing frameworks, for baffling reasons, include globals in
    your test program. For instance, if you want to run a task before each test when
    using the Mocha test framework (Buster.js and Jasmine also do this), you’d pass
    a callback function to the `beforeEach` global method. In fact, test cases should
    be described with other globals, such as `describe` and `it`, as shown in the
    following listing.
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数JavaScript测试框架出于令人费解的原因，将全局变量包含在测试程序中。例如，如果你想在Mocha测试框架（Buster.js和Jasmine也这样做）中在每次测试之前运行一个任务，你将传递一个回调函数到`beforeEach`全局方法。实际上，测试案例应该用其他全局变量来描述，例如`describe`和`it`，如下所示。
- en: Listing 8.19\. Using `describe` to describe test cases
  id: totrans-1260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.19。使用`describe`描述测试案例
- en: '[PRE219]'
  id: totrans-1261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: This is terrible! Indiscriminate use of globals, even in tests, shouldn’t be
    the norm. Luckily `tape` doesn’t submit to this nonsense, and it’s still easy
    to run something before each test. The following listing shows the same piece
    of code, using `tape` instead.
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: 这太糟糕了！在测试中使用全局变量，甚至不应该成为常态。幸运的是，`tape`没有屈服于这种荒谬，仍然可以在每个测试之前轻松运行一些代码。以下列表显示了相同的代码，但使用`tape`。
- en: Listing 8.20\. Using `tape` to describe test cases
  id: totrans-1263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.20。使用`tape`描述测试案例
- en: '[PRE220]'
  id: totrans-1264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: 'Granted, it looks more verbose, but it doesn’t pollute the global namespace,
    breaking one of the oldest conventions. In `tape`, tests emit events, such as
    `prerun`, at different points in the test run. To set up and tear down our tests,
    you’ll need to create and use a `testCase` method. The name is irrelevant, but
    I find `testCase` applies well in this situation:'
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这看起来更冗长，但它不会污染全局命名空间，打破了最古老的约定之一。在`tape`中，测试在测试运行的不同点发出事件，例如`prerun`。为了设置和拆除我们的测试，你需要创建并使用一个`testCase`方法。名称无关紧要，但我发现`testCase`在这个情况下适用：
- en: '[PRE221]'
  id: totrans-1266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: Now that you know how to run these methods for every test, it’s time to code
    them!
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何为每个测试运行这些方法，是时候编写它们了！
- en: Preparing the test harness
  id: totrans-1268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 准备测试工具
- en: In the `setup` method, you need to create each DOM element you’ll need in the
    tests and set any default values made available through the HTML. Note that testing
    the HTML itself isn’t part of these tests, which is why you completely disregard
    it. Your concern is that, assuming the HTML is what you expect, the application
    will run successfully. Testing the HTML is a concern of integration testing.
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setup`方法中，你需要创建测试中需要的每个DOM元素，并设置通过HTML提供的任何默认值。请注意，测试HTML本身并不属于这些测试的一部分，这就是为什么你完全忽略它。你的关注点是，假设HTML是你预期的，应用程序将成功运行。测试HTML是集成测试的关注点。
- en: The `setup` method is found in the following listing. The `bar` module is your
    application’s code, wrapped in a function so you can execute it whenever you want.
    In this case, you need to run the application before every test. That will attach
    event listeners to your freshly baked DOM elements.
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup`方法在下面的列表中。`bar`模块是你的应用程序代码，封装在一个函数中，这样你就可以随时执行它。在这种情况下，你需要在每个测试之前运行应用程序。这将把事件监听器附加到新创建的DOM元素上。'
- en: Listing 8.21\. Using the `setup` method
  id: totrans-1271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.21\. 使用`setup`方法
- en: '[PRE222]'
  id: totrans-1272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'The `teardown` method is even easier, because you give it a few selectors and
    iterate through them, removing the elements created during `setup`:'
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: '`teardown`方法甚至更简单，因为你只需给它几个选择器，然后遍历它们，移除在`setup`期间创建的元素：'
- en: '[PRE223]'
  id: totrans-1274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: Woo-hoo! Onto the tests.
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: 哇哦！接下来是测试。
- en: Coding your test cases
  id: totrans-1276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编写测试用例
- en: As long as you keep your concerns cleanly separated between Arrange, Act, and
    Assert, you shouldn’t have any issues writing or reading your tests. In the first
    one you get the `barman` element, click it, and get any results. You verify there’s
    one result. Then you assert that the CSS class and text in that result are correct,
    as shown in the following listing.
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你在安排（Arrange）、行动（Act）和断言（Assert）之间保持关注点的清晰分离，你就不会在编写或阅读测试时遇到任何问题。在第一个测试中，你获取`barman`元素，点击它，并获取任何结果。你验证只有一个结果。然后你断言该结果中的CSS类和文本是正确的，如下面的列表所示。
- en: Listing 8.22\. Asserting the CSS class and text are correct
  id: totrans-1278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.22\. 断言CSS类和文本是否正确
- en: '[PRE224]'
  id: totrans-1279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: The next test also does error checking. Making sure your error checking works
    as expected is as important as making sure the happy path does indeed work. In
    the following listing, you’re also setting a value in the input, before the click.
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个测试也进行了错误检查。确保你的错误检查按预期工作，与确保预期的工作路径确实工作一样重要。在下面的列表中，你也在点击之前在输入中设置了一个值。
- en: Listing 8.23\. Error checking your code
  id: totrans-1281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.23\. 检查你的代码错误
- en: '![](235fig01_alt.jpg)'
  id: totrans-1282
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](235fig01_alt.jpg)'
- en: By now you should start to see the pattern. See how easy it is to identify what
    each test does when they follow the AAA convention? This next one, shown in the
    following listing, verifies that the happy path works as intended. It sets the
    input to a decimal value and clicks on the button, and then it checks that the
    result was a rounded number.
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该开始看到模式。看看当它们遵循AAA约定时，如何容易地识别每个测试做什么？接下来的一个，如下面的列表所示，验证了预期的工作路径是否按预期工作。它将输入设置为十进制值，然后点击按钮，然后检查结果是否为四舍五入的数字。
- en: Listing 8.24\. Verifying the path works
  id: totrans-1284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.24\. 验证路径是否有效
- en: '![](235fig02_alt.jpg)'
  id: totrans-1285
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](235fig02_alt.jpg)'
- en: It’s certainly good to write tests that interact with your code the way you
    expect humans to interact with it. Sometimes humans do the unexpected, and that
    should be tested for as well.
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 编写与你的代码交互的测试用例，就像你期望人类与之交互一样，这无疑是好的。有时人类会做出意想不到的事情，这也应该被测试。
- en: Testing possible outcomes
  id: totrans-1287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 测试可能的输出
- en: 'We’re wired in a certain way, where we believe in three possible outcomes:
    something either never works, works once, or it always works. I often joke that
    only three numbers exist: 0, 1, and infinite. As shown in the following listing,
    asserting that making two clicks works as intended should be enough. You can always
    go back and add more tests.'
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以一种特定的方式被连接起来，我们相信三种可能的结果：某物要么永远不工作，要么工作一次，要么总是工作。我经常开玩笑说，只有三个数字存在：0，1和无限。如下所示，断言两次点击按预期工作应该是足够的。你总是可以回头添加更多测试。
- en: Listing 8.25\. Making sure two clicks works
  id: totrans-1289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.25\. 确保两次点击工作
- en: '![](236fig01_alt.jpg)'
  id: totrans-1290
  prefs: []
  type: TYPE_IMG
  zh: '![图片](236fig01_alt.jpg)'
- en: When developing code, you might find that your code is throwing errors, wearing
    down your productivity. Simple tests such as the one in the following listing
    that asserts a method call does not throw are helpful in these types of cases.
    The next section talks about automated testing, which definitely helps as well.
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发代码时，你可能会发现你的代码正在抛出错误，这会降低你的生产力。以下列表中的简单测试，断言一个方法调用不会抛出错误，在这些情况下是有帮助的。下一节将讨论自动化测试，这肯定也有帮助。
- en: Listing 8.26\. Asserting a method call does not throw errors
  id: totrans-1292
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.26\. 断言一个方法调用不会抛出错误
- en: '[PRE225]'
  id: totrans-1293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: The last test in your embarrassingly small suite is close to an integration
    test. It clicks repeatedly, and then it asserts that clicking the Clear button
    does indeed remove the accumulated results.
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 在你令人尴尬的小套件中的最后一个测试几乎是一个集成测试。它反复点击，然后断言点击清除按钮确实移除了累积的结果。
- en: Listing 8.27\. Verifying the Clear button works
  id: totrans-1295
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.27\. 验证清除按钮工作
- en: '[PRE226]'
  id: totrans-1296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: The most value in your tests always comes when it’s time to refactor. Suppose
    you changed the implementation of your Event Bar program. You run the tests again.
    If they succeed, all is good, unless you find a bug testing by hand, in which
    case you add more tests and fix the issue. If they fail, two possibilities exist.
    The tests now may be outdated. For example, the Clear button may have been changed
    to “remove only the oldest result” when clicked. In that case you should update
    the tests to reflect those changes. The other reason why the tests may fail is
    because of an oversight in your changes, which would break functionality. The
    fact that these tests are forever repeatable, at no extra cost, is what makes
    them so valuable.
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的测试中，最大的价值总是在需要重构的时候出现。假设你改变了你的事件栏程序的实施。你再次运行测试。如果它们成功，一切正常，除非你手动测试时发现了一个错误，在这种情况下，你需要添加更多测试并修复问题。如果它们失败，有两种可能性。现在的测试可能已经过时了。例如，当点击清除按钮时，它可能已经被更改为“仅移除最旧的结果”。在这种情况下，你应该更新测试以反映这些变化。测试永远可以重复进行，无需额外成本，这就是它们如此有价值的原因。
- en: You can check out the fully working example, with all the code I’ve shown you,
    in the accompanying code samples, as ch08/07_dom-interaction-testing. Next up
    we’ll go back to the case study we developed during [chapter 7](kindle_split_019.html#ch07)
    and add unit tests to it.
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在附带的代码示例中查看完全工作的示例，包括我向你展示的所有代码，在ch08/07_dom-interaction-testing目录下。接下来，我们将回到我们在[第7章](kindle_split_019.html#ch07)中开发的案例研究，并为其添加单元测试。
- en: '8.3\. Case study: unit testing the MVC shopping list'
  id: totrans-1299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3\. 案例研究：单元测试MVC购物清单
- en: In [chapter 7](kindle_split_019.html#ch07) we reached quite a few milestones
    in developing an MVC shopping list application, and in this section we’ll unit
    test one of the iterations of that application. Concretely, you’ll pair with me
    in unit testing the application at the end of [section 7.4](kindle_split_019.html#ch07lev1sec4),
    right before we added Rendr to the solution in [section 7.5](kindle_split_019.html#ch07lev1sec5).
    You can check out the source code for that application at ch07/10_the-road-show
    in the samples. Its unit-tested counterpart can be found under ch08/07b_testability-boulevard.
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](kindle_split_019.html#ch07)中，我们在开发MVC购物清单应用程序方面取得了相当多的里程碑，在本节中，我们将对这个应用程序的一个迭代进行单元测试。具体来说，你将与我一起在[7.4节](kindle_split_019.html#ch07lev1sec4)的结尾进行单元测试，在我们将Rendr添加到解决方案的[7.5节](kindle_split_019.html#ch07lev1sec5)之前。你可以在样本中的ch07/10_the-road-show目录下查看该应用程序的源代码。其单元测试的对应版本可以在ch08/07b_testability-boulevard下找到。
- en: The Road Show was a small-sized application, yet large enough to show how you
    could slowly add tests to an application and end up having a well-tested application.
    Taking this gradual approach to testing would have been much harder if we hadn’t
    put effort into modularizing our application, but we learned to do that in [chapter
    5](kindle_split_017.html#ch05) and applied those concepts when putting together
    the application in [chapter 7](kindle_split_019.html#ch07). This section guides
    us through writing tests for the view router, and model validation. You are then
    free to explore adding test coverage for the view controllers.
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 路演是一个小型应用程序，但足够大，可以展示你如何可以逐步向应用程序添加测试，最终得到一个经过良好测试的应用程序。如果我们没有在[第5章](kindle_split_017.html#ch05)中投入精力模块化我们的应用程序，那么采取这种逐步的测试方法将会困难得多。我们在[第7章](kindle_split_019.html#ch07)中学习了如何这样做，并在构建应用程序时应用了这些概念。本节将指导我们编写视图路由器和模型验证的测试。然后你可以自由探索为视图控制器添加测试覆盖率。
- en: 8.3.1\. Testing the view router
  id: totrans-1302
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.1\. 测试视图路由器
- en: The first step you always need to take before any testing can begin is configuring
    the environment so tests can run. In this case that means you’ll copy the application
    (from ch07/10_the-road-show) to be used as a starting point, and then add the
    test harness built in this chapter for running Tape in the browser (the ch08/02_tape-in-the-browser
    sample) on top of that.
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始任何测试之前，你总是需要先配置环境，以便测试可以运行。在这种情况下，这意味着你需要将应用程序（从ch07/10_the-road-show）复制过来作为起点，然后在此之上添加本章构建的测试工具，用于在浏览器中运行Tape（ch08/02_tape-in-the-browser示例）。
- en: Once the initial setup is put together (ch08/07b_testability-boulevard in the
    samples), you can start fleshing out your tests using Tape. We’ll start with the
    router (which was shown in [listing 7.18](kindle_split_019.html#ch07ex18) in [chapter
    7](kindle_split_019.html#ch07)) because that’s the simplest module we want to
    test. For reference, the following listing is how the module looks at the moment.
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦初始设置完成（示例中的ch08/07b_testability-boulevard），你就可以开始使用Tape充实你的测试。我们将从路由器开始（在第7章[列表7.18](kindle_split_019.html#ch07ex18)中展示），因为这是我们想要测试的最简单的模块。为了参考，以下列表是模块当前的样子。
- en: Listing 8.28\. Testing the module
  id: totrans-1305
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.28\. 测试模块
- en: '[PRE227]'
  id: totrans-1306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: We want to assert a few things in testing this module. You want to know that
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在测试这个模块时断言一些事情。你想要知道的是
- en: There are three routes.
  id: totrans-1308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有三条路径。
- en: Their associated route handlers do in fact exist.
  id: totrans-1309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与它们相关的路由处理程序确实存在。
- en: The `root` route handler properly redirects to the `listItems` action.
  id: totrans-1310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`root`路由处理程序正确地重定向到`listItems`操作。'
- en: View routes would render the correct view in each case.
  id: totrans-1311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图路由在每种情况下都会渲染正确的视图。
- en: You may already be drooling over the possibilities, considering creating mocks
    for the views, or maybe using `proxyquire` to stub those modules altogether. To
    get started, we’ll assert that three routes are in fact registered, and that their
    route handlers exist on the router.
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经迫不及待地想要考虑为视图创建模拟，或者可能使用`proxyquire`来完全模拟这些模块。为了开始，我们将断言确实注册了三个路由，并且它们的路由处理程序存在于路由器上。
- en: To achieve this, the following listing uses `proxyquireify` (a flavor of `proxyquire`
    that works on the client side) combined with `sinon` and `tape` to put together
    the `routes.js` test module.
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，以下列表使用`proxyquireify`（一种在客户端上工作的`proxyquire`变体）结合`sinon`和`tape`来构建`routes.js`测试模块。
- en: Listing 8.29\. The first View Router tests
  id: totrans-1314
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.29\. 第一个视图路由器测试
- en: '![](ch08ex29-0.jpg)'
  id: totrans-1315
  prefs: []
  type: TYPE_IMG
  zh: '![第八章练习29-0](ch08ex29-0.jpg)'
- en: '![](ch08ex29-1.jpg)'
  id: totrans-1316
  prefs: []
  type: TYPE_IMG
  zh: '![第八章练习29-1](ch08ex29-1.jpg)'
- en: 'Once the test file is ready, you can verify that the tests pass by going through
    the same process as in [section 8.4](#ch08lev1sec4): opening up a browser with
    the compiled test bundle and checking the developer console for any error messages.'
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦测试文件准备就绪，你可以通过打开一个带有编译测试包的浏览器并检查开发者控制台中的任何错误消息来验证测试是否通过。
- en: Test runner HTML file
  id: totrans-1318
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 测试运行器HTML文件
- en: 'First off, you’ll need a test runner HTML file like the following one. There’s
    nothing special about it, except that it loads the built test bundle:'
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要一个测试运行器HTML文件，如下所示。它没有什么特别之处，只是加载了构建的测试包：
- en: '[PRE228]'
  id: totrans-1320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: Once you’ve created both the `routes.js` test module and the `runner.html` test
    runner, you should create a Grunt task to build the bundle.
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了`routes.js`测试模块和`runner.html`测试运行器，你应该创建一个Grunt任务来构建包。
- en: Create a Grunt task to build the bundle
  id: totrans-1322
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建一个Grunt任务来构建包
- en: Because you’ve learned how to write your own tasks, and as a way of reinforcing
    that knowledge, you’ll create your own task to compile the Browserify bundle!
    To make that work, you should include all of the following listing in a `Gruntfile`.
    It uses the `browserify` package directly, without the `grunt-browserify` plugin
    intermediary. Sometimes using a package directly instead of through a plugin can
    offer greater flexibility in what your tasks can do.
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你已经学会了如何编写自己的任务，并且为了巩固这一知识，你将创建自己的任务来编译 Browserify 包！为了使其工作，你应该在 `Gruntfile`
    中包含以下所有列表。它直接使用 `browserify` 包，而不是通过 `grunt-browserify` 插件作为中介。有时直接使用包而不是通过插件可以提供更大的灵活性，让你的任务能够做更多的事情。
- en: Listing 8.30\. Creating a custom Browserify task
  id: totrans-1324
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.30\. 创建自定义 Browserify 任务
- en: '![](ch08ex30-0.jpg)'
  id: totrans-1325
  prefs: []
  type: TYPE_IMG
  zh: '![](ch08ex30-0.jpg)'
- en: '![](ch08ex30-1.jpg)'
  id: totrans-1326
  prefs: []
  type: TYPE_IMG
  zh: '![](ch08ex30-1.jpg)'
- en: See test execution
  id: totrans-1327
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 查看测试执行
- en: 'When everything is set up, you can run the following command and see the tests
    being executed in your browser:'
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 当一切设置完毕后，你可以运行以下命令，并在浏览器中看到正在执行的测试：
- en: '[PRE229]'
  id: totrans-1329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: A browser window should pop up. If we open the developer console, we’d see the
    output shown in [figure 8.5](#ch08fig05).
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: 应该会弹出一个浏览器窗口。如果我们打开开发者控制台，我们会看到[图 8.5](#ch08fig05)中显示的输出。
- en: Figure 8.5\. Developer Tools showing the results for the tests we’ve provided
  id: totrans-1331
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.5\. 开发者工具显示我们提供的测试结果
- en: '![](08fig05.jpg)'
  id: totrans-1332
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig05.jpg)'
- en: There are a few more routing tests to be had. Next up, you’ll make sure that
    each route handler does what it’s meant to, whether it’s meant to redirect users
    to a different route or render a particular view.
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几个路由测试要做。接下来，你将确保每个路由处理器都按预期工作，无论是重定向用户到不同的路由还是渲染特定的视图。
- en: A few more tests
  id: totrans-1334
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 一些额外的测试
- en: The following listing contains the code for the remaining tests. You can add
    it to the end of the `routes.js` test suite.
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表包含了剩余测试的代码。你可以将其添加到 `routes.js` 测试套件的末尾。
- en: Listing 8.31\. Testing route handlers individually
  id: totrans-1336
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.31\. 单独测试路由处理器
- en: '![](ch08ex31-0.jpg)'
  id: totrans-1337
  prefs: []
  type: TYPE_IMG
  zh: '![](ch08ex31-0.jpg)'
- en: '![](ch08ex31-1.jpg)'
  id: totrans-1338
  prefs: []
  type: TYPE_IMG
  zh: '![](ch08ex31-1.jpg)'
- en: Once all of the tests are in your routes.js file, you can run the Grunt task
    again and reload the browser. [Figure 8.6](#ch08fig06) contains the results of
    executing the new test suite.
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有的测试都添加到你的 `routes.js` 文件中，你可以再次运行 Grunt 任务并重新加载浏览器。[图 8.6](#ch08fig06) 包含了执行新测试套件的结果。
- en: Figure 8.6\. Reveals the results of our modest test suite and its ten assertions
  id: totrans-1340
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.6\. 展示了我们适度测试套件及其十个断言的结果
- en: '![](08fig06.jpg)'
  id: totrans-1341
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig06.jpg)'
- en: While our tests for the router are minimal, in that they don’t assert much,
    we’re at least ensuring that the routes exist and that their route handlers do
    what they’re expected to. Routing in an application is typically a convergence
    point where configuration is plumbed together, and tests help ensure that the
    correct modules are used.
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们对路由器的测试是最基本的，它们并不断言很多，但我们至少确保了路由的存在以及它们的路由处理器按预期工作。在应用程序中，路由通常是配置汇聚的点，测试有助于确保使用正确的模块。
- en: 8.3.2\. Testing validation on a view model
  id: totrans-1343
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.2\. 测试视图模型上的验证
- en: The application also needs to test model validation with a few different inputs,
    making sure that a model is invalid under certain circumstances, and valid when
    every validation condition is met. For reference, code for the Shopping Item module
    is included in the following listing.
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序还需要使用几个不同的输入来测试模型验证，确保在特定情况下模型无效，在满足所有验证条件时有效。为了参考，以下列表中包含了购物项模块的代码。
- en: Listing 8.32\. Testing validation
  id: totrans-1345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.32\. 测试验证
- en: '[PRE230]'
  id: totrans-1346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: Validation brings us to an interesting use case for JavaScript when it comes
    to testing. Given that we want to set up a test for each possible validation scenario,
    we could set up a list of test cases in an array, and then create a single test
    for each test case.
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: 验证在测试 JavaScript 时带来一个有趣的使用场景。鉴于我们想要为每个可能的验证场景设置一个测试，我们可以在一个数组中设置一个测试用例列表，然后为每个测试用例创建一个单独的测试。
- en: The following listing shows one possible way to stay DRY in our tests by using
    a test case factory and a battery of test cases. I’ve thrown in a test that’s
    not part of the test cases array for contrast.
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了一种使用测试用例工厂和一系列测试用例来保持测试中 DRY 的可能方法。我加入了一个不属于测试用例数组的测试用例以供对比。
- en: Listing 8.33\. Model validation test case battery
  id: totrans-1349
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.33\. 模型验证测试用例库
- en: '![](ch08ex33-0.jpg)'
  id: totrans-1350
  prefs: []
  type: TYPE_IMG
  zh: '![](ch08ex33-0.jpg)'
- en: '![](ch08ex33-1.jpg)'
  id: totrans-1351
  prefs: []
  type: TYPE_IMG
  zh: '![](ch08ex33-1.jpg)'
- en: 'Imagine if you had to write each test case as an individual test: much copy-pasting
    would ensue, breaking the DRY principle.'
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你必须将每个测试用例单独编写为一个测试：这将导致大量的复制粘贴，违反了 DRY 原则。
- en: Following the practices we’ve discussed in this chapter, you could write tests
    for the views as well. Good test cases could be
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: 按照本章中我们讨论的实践，你也可以为视图编写测试。好的测试案例可以是
- en: Making sure the template assigned to the view is the one intended for that view
  id: totrans-1354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保分配给视图的模板是针对该视图的预期模板
- en: Checking that event handlers are declared in the `events` property
  id: totrans-1355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查事件处理器是否在 `events` 属性中声明
- en: Ensuring those event handlers do what they’re expected to
  id: totrans-1356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保那些事件处理器执行了它们预期执行的操作
- en: You could use `sinon` to mock the different properties in the view before invoking
    each method under test. I’ll leave those test cases as an exercise for you.
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `sinon` 在调用每个待测试方法之前模拟视图中的不同属性。我将把这些测试案例留给你作为练习。
- en: When you finish writing your tests for the view controllers, it’ll be time to
    shift your attention toward more automation. This time, you’ll automate Tape tests
    using Grunt, and you’ll also learn how to run these tests continuously on a remote
    integration server.
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成视图控制器的测试编写后，将是时候将你的注意力转向更多的自动化了。这次，你将使用 Grunt 自动化 Tape 测试，你还将学习如何在远程集成服务器上持续运行这些测试。
- en: 8.4\. Automating Tape tests
  id: totrans-1359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4\. 自动化 Tape 测试
- en: 'You automated the Browserify process using Grunt in [section 8.1.4](#ch08lev2sec4).
    How can you add the `tape` tests to your Grunt builds? Running the tests on Node
    is significantly easier than executing them on the browser. As you learned earlier,
    you could run them on Node by providing the `node` CLI with the test file path:'
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 [第 8.1.4 节](#ch08lev2sec4) 中使用 Grunt 自动化了 Browserify 流程。你如何将 `tape` 测试添加到你的
    Grunt 构建中？在 Node 上运行测试比在浏览器上执行它们要容易得多。正如你之前所学的，你可以通过向 `node` CLI 提供测试文件路径来在 Node
    上运行它们：
- en: '[PRE231]'
  id: totrans-1361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: 'Automating the process shown in the previous code by using the `grunt-tape`
    plugin couldn’t be easier. The following code snippet (found as ch08/08_grunt-tape-node
    in the samples) is all you need in your Gruntfile to run the `tape` tests in Grunt.
    Note that you don’t have to run Browserify because, in this case, the tests will
    run in Node:'
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `grunt-tape` 插件自动化之前代码中显示的过程非常简单。以下代码片段（在 samples 中的 ch08/08_grunt-tape-node
    中找到）是你 Gruntfile 中运行 `tape` 测试所需的所有内容。请注意，你不需要运行 Browserify，因为在这种情况下，测试将在 Node
    上运行：
- en: '[PRE232]'
  id: totrans-1363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: That was fast. How about in the browser?
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: 这很快。在浏览器中怎么样？
- en: 8.4.1\. Automating Tape tests for the browser
  id: totrans-1365
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.1\. 自动化浏览器中的 Tape 测试
- en: Running `tape` tests on browsers from your command line is also fairly easy.
    You can use `testling` to do it. Testling (also known as substack) is a tool written
    by James Halliday, a tremendously prolific Node contributor, who’s also the author
    of Tape, and a modularity fanatic. There wasn’t a readily available `grunt-testling`
    package in existence, but I decided not to disappoint. I created `grunt-testling`
    so that you could run Testling from Grunt. The `grunt-testling` package doesn’t
    require any Grunt configuration. But you need to configure `testling` itself.
    Testling is configured by placing a `'testling'` property in your `package.json`
    and telling it where the test files are. The following listing (found as ch08/09_grunt-tape-browser)
    is a sample `package.json` to do that.
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的命令行上运行 `tape` 测试在浏览器中也很容易。你可以使用 `testling` 来完成。Testling（也称为 substack）是由 James
    Halliday 编写的工具，他是一位多产的 Node 贡献者，也是 Tape 的作者，并且是一个模块化狂热者。当时并没有现成的 `grunt-testling`
    包，但我决定不要让你失望。我创建了 `grunt-testling`，这样你就可以从 Grunt 中运行 Testling。`grunt-testling`
    包不需要任何 Grunt 配置。但你需要配置 `testling` 本身。Testling 通过在 `package.json` 中放置一个 `'testling'`
    属性并告诉它测试文件的位置来进行配置。以下列表（在 ch08/09_grunt-tape-browser 中找到）是一个用于此目的的示例 `package.json`。
- en: Listing 8.34\. Automating Tape tests
  id: totrans-1367
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.34\. 自动化 Tape 测试
- en: '[PRE233]'
  id: totrans-1368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: Once you’ve configured `testling`, installed `grunt-testling`, and added it
    to your Gruntfile, you should be all set!
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你配置了 `testling`，安装了 `grunt-testling`，并将其添加到你的 Gruntfile 中，你应该就绪了！
- en: '[PRE234]'
  id: totrans-1370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: 'You can now run the tests in a browser entering the following command into
    your terminal:'
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以通过在终端中输入以下命令在浏览器中运行测试：
- en: '[PRE235]'
  id: totrans-1372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[Figure 8.7](#ch08fig07) shows the results of using Testling with Grunt.'
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8.7](#ch08fig07) 展示了使用 Testling 与 Grunt 结合使用的结果。'
- en: Figure 8.7\. Driving tests through the Testling CLI using Grunt
  id: totrans-1374
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.7\. 使用 Testling CLI 通过 Grunt 驱动测试
- en: '![](08fig07.jpg)'
  id: totrans-1375
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig07.jpg)'
- en: 'Next up let me briefly reiterate a concept you first saw in [chapter 3](kindle_split_014.html#ch03):
    continuous development adapted to testing.'
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我简要重申一下你在 [第 3 章](kindle_split_014.html#ch03) 中首次看到的概念：适应测试的持续开发。
- en: 8.4.2\. Continuous testing
  id: totrans-1377
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.2\. 持续测试
- en: An important aspect of running tests is to do so on every change, making sure
    you don’t spend a long time with broken code in your local development environment.
    You might recall a particular `watch` configuration snippet in [chapter 3](kindle_split_014.html#ch03)
    that allowed you to run specific tasks when file changes were detected somewhere
    in your code base. The following listing is an adapted version of that snippet
    to run tests and lint when files change.
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试的一个重要方面是在每次更改时进行，确保你不会在本地开发环境中长时间处理损坏的代码。你可能还记得第 3 章[中](kindle_split_014.html#ch03)的一个特定的
    `watch` 配置片段，它允许你在代码库中的某个地方检测到文件更改时运行特定任务。以下列表是那个片段的改编版本，用于在文件更改时运行测试和代码风格检查。
- en: Listing 8.35\. Running tests and lint when files change
  id: totrans-1379
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.35\. 在文件更改时运行测试和代码风格检查
- en: '[PRE236]'
  id: totrans-1380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: Automating tests in both Node and the browser is important. Watching for changes
    and running those tests locally again is also important. At this point you might
    want to check out [chapter 4](kindle_split_015.html#ch04), [section 4.4](kindle_split_015.html#ch04lev1sec4)
    again, where I discussed continuous integration, which is fundamental to setting
    up your project so tests are executed on every push to your version control system.
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node 和浏览器中自动化测试都很重要。监视更改并在本地再次运行这些测试也很重要。此时，你可能想再次查看第 4 章[中](kindle_split_015.html#ch04)、[4.4
    节](kindle_split_015.html#ch04lev1sec4)，我在那里讨论了持续集成，这对于设置你的项目至关重要，因为每次将代码推送到版本控制系统时都会执行测试。
- en: Testing components in isolation isn’t the only way to test an application. In
    fact, countless types of testing exist, and we’ll briefly discuss a few interesting
    ones in the next section.
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: 在隔离状态下测试组件并不是测试应用程序的唯一方式。实际上，存在无数种测试类型，我们将在下一节简要讨论其中一些有趣的类型。
- en: 8.5\. Integration, visual, and performance testing
  id: totrans-1383
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5\. 集成、视觉和性能测试
- en: As I mentioned a few times before, testing comes in various sizes and shapes.
    Integration testing, for instance, allows you to test different paths in your
    application workflow, making sure that component interaction works as expected.
    Components were already tested in isolation, and integration testing provides
    both a redundancy layer and the ability to capture bugs that aren’t evident without
    executing an application and seeing for yourself.
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到几次的那样，测试有多种大小和形状。例如，集成测试允许你测试应用程序工作流程中的不同路径，确保组件交互按预期工作。组件已经在隔离状态下进行了测试，集成测试提供了冗余层，并能够捕获在执行应用程序并亲自查看之前不明显的问题。
- en: 8.5.1\. Integration testing
  id: totrans-1385
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.5.1\. 集成测试
- en: Integration tests are no different from unit tests in the sense of tooling.
    You can still use Tape, Sinon, and Proxyquire to run these tests. The difference
    lies in what should be tested. In integration, you no longer strive to test a
    completely isolated version of a component, but rather test as many interconnections
    as you can get away with, and mock the rest. For instance, you might run your
    application’s web server, hit it with real HTTP requests, and check if the response
    matches your assertions.
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试在工具方面与单元测试并无不同。你仍然可以使用 Tape、Sinon 和 Proxyquire 来运行这些测试。区别在于应该测试什么。在集成测试中，你不再努力测试一个完全隔离的组件版本，而是尽可能多地测试可以测试的互连，并对剩余部分进行模拟。例如，你可能运行你的应用程序的
    web 服务器，用真实的 HTTP 请求对其进行打击，并检查响应是否与你的断言相符。
- en: You may also use Selenium, a browser automation tool, to help drive these comprehensive
    tests on the client side. Selenium uses a web server to communicate with a browser
    through its API, which is supported in a variety of languages. You can send commands
    to the browser through a Selenium server. You could write down a series of steps
    for your test to follow, and then Selenium fires up a browser and does those actions
    for you. A running web server and browser automation, working together, allow
    you to automate tests that you might do by hand. Remember, you only have to put
    together the test once! Then you can run it as many times as needed. You can always
    go back and change the tests, too. I’m not going to lie to you, though. Setting
    up Selenium is cumbersome and generally frustrating, and it’s poorly documented.
    But once you’ve put together a few tests, you’ll reap the benefits.
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用Selenium，一个浏览器自动化工具，来帮助在客户端执行这些综合测试。Selenium通过其API与浏览器通信，该API支持多种语言。你可以通过Selenium服务器向浏览器发送命令。你可以为你的测试编写一系列步骤，然后Selenium启动一个浏览器并为你执行这些操作。一个运行中的Web服务器和浏览器自动化协同工作，允许你自动化你可能手动执行的测试。记住，你只需要组装一次测试！然后你可以根据需要多次运行它。你还可以随时返回并更改测试。不过，我不得不告诉你，设置Selenium很麻烦，通常很令人沮丧，而且文档也很差。但一旦你组装了几次测试，你将获得好处。
- en: Integration tests aren’t limited to browser automation with a tool like Selenium,
    though. You could run integration tests that work solely on your back-end stack
    or merely in the front end.
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试不仅限于使用Selenium等工具进行浏览器自动化。你还可以运行仅在你后端堆栈或仅在前端工作的集成测试。
- en: 8.5.2\. Visual testing
  id: totrans-1389
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.5.2\. 视觉测试
- en: 'Visual testing mostly consists of taking screenshots of an application, at
    different viewport dimensions, and validating that the layout isn’t broken. You
    can perform these validations by either comparing a screenshot to what you expect
    or by superimposing the latest screenshot with the previous one, generating what’s
    called a “diff.” These diffs let you quickly identify what changed from one version
    to another by highlighting the differences and shading the parts of the screenshot
    that haven’t changed. Many Grunt plugins can take screenshots of an application
    for you. Several even go the extra mile and compare the latest screenshot with
    the previous one, showing you where the differences may lie. One such Grunt plugin
    is `grunt-photobox`. Configuring it is mostly a matter of deciding which URL you
    want to load and what resolution you want the viewport to be when taking the screenshots.
    This is particularly useful if your site follows the Responsive Web Design paradigm,
    which uses CSS media queries to change the appearance of a page based on the dimensions
    of the viewport and other variables. The following code snippet shows how you
    might configure `grunt-photobox` to take pictures of a page in three different
    sizes. Let me go over the options:'
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉测试主要是由在不同视口尺寸下对应用程序进行截图，并验证布局没有损坏。你可以通过比较截图与预期内容或通过将最新截图叠加到上一个截图上，生成所谓的“差异”来执行这些验证。这些差异让你能够通过突出显示差异和阴影未更改的截图部分，快速识别从一个版本到另一个版本的变化。许多Grunt插件可以为你自动获取应用程序的截图。其中一些甚至更进一步，将最新截图与上一个截图进行比较，显示差异可能存在的位置。一个这样的Grunt插件是`grunt-photobox`。配置它主要是决定你想要加载哪个URL以及你想要在截图时视口的分辨率。如果你的网站遵循响应式Web设计范式，这尤其有用，该范式使用CSS媒体查询根据视口尺寸和其他变量更改页面的外观。以下代码片段显示了如何配置`grunt-photobox`以获取不同尺寸的页面截图。让我过一遍选项：
- en: The `urls` field is an array of pages you want to take pictures from.
  id: totrans-1391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`urls`字段是你想要从中获取图片的页面数组。'
- en: 'In `screenSizes` you can define the width of each screenshot you want to take;
    the height will be the full height of the page. Make sure you use strings. Note
    that Photobox will take a picture of each site in each of the resolutions you’ve
    decided on:'
  id: totrans-1392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`screenSizes`中，你可以定义你想要获取的每个屏幕截图的宽度；高度将是页面的完整高度。请确保使用字符串。请注意，Photobox将会按照你决定的每个分辨率对每个网站进行截图：
- en: '[PRE237]'
  id: totrans-1393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE237]'
- en: 'Once you’ve configured Photobox in Grunt, you can run the following command
    and Photobox will generate a site you can browse to compare the screenshots:'
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在Grunt中配置了Photobox，你可以运行以下命令，Photobox将会生成一个你可以浏览的网站来比较截图：
- en: '[PRE238]'
  id: totrans-1395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: You can find the fully working example in the accompanying code samples as ch08/10_visual-testing.
    Finally, let’s shift our attention to performance testing.
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在附带的代码示例中找到完整工作的示例，作为ch08/10_visual-testing。最后，让我们将注意力转向性能测试。
- en: 8.5.3\. Performance testing
  id: totrans-1397
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.5.3. 性能测试
- en: Keeping tabs on the performance of your application can help quickly identify
    the root cause of performance issues. You can monitor performance in web applications
    using tools such as Google PageSpeed or Yahoo YSlow. Both tools give you similar
    insights, and they can both be automated using Grunt plugins. They do have a few
    differences between their services. The PageSpeed Grunt tool gives you more insight
    into what improvements you should make to your site. For example, it might let
    you know that you aren’t caching your static assets as aggressively as you should.
    The YSlow plugin gives you a more compact version, telling you how many requests
    were made, how long the page took to load, how much content was downloaded, and
    a performance score.
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪应用程序的性能可以帮助快速识别性能问题的根本原因。您可以使用Google PageSpeed或Yahoo YSlow等工具在Web应用程序中监控性能。这两个工具都提供了类似的见解，并且它们都可以通过Grunt插件自动化。它们在其服务之间确实有一些差异。PageSpeed
    Grunt工具为您提供更多关于您应该对网站进行哪些改进的见解。例如，它可能会让您知道您没有像应该的那样积极缓存静态资源。YSlow插件提供了一个更紧凑的版本，告诉您请求了多少次，页面加载花费了多长时间，下载了多少内容，以及性能评分。
- en: The PageSpeed plugin, `grunt-pagespeed`, requires you to get an API key from
    Google.^([[2](#ch08fn02)]) You can then configure the plugin as shown in [listing
    8.36](#ch08ex36) (sample ch08/11_pagespeed-insights). In the code, you’re telling
    PageSpeed which URL you want it to hit, what locale you want the results to be
    generated in, what strategy to use (`'desktop'` or `'mobile'`), and the minimum
    score (out of 100) to consider the test successful. Note that you’re purposely
    avoiding including the API key in the Gruntfile. Instead, you’ll get it from an
    environment variable to keep the secret safe.
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: PageSpeed插件`grunt-pagespeed`要求您从Google获取一个API密钥.^([[2](#ch08fn02)]) 然后，您可以像[列表8.36](#ch08ex36)（sample
    ch08/11_pagespeed-insights）中所示那样配置插件。在代码中，您告诉PageSpeed它想要访问哪个URL，想要生成的结果区域，要使用的策略（`'desktop'`或`'mobile'`），以及认为测试成功的最低分数（满分100分）。请注意，您故意避免在Gruntfile中包含API密钥。相反，您将从环境变量中获取它以保持秘密安全。
- en: ² Get the API key from [https://code.google.com/apis/console](https://code.google.com/apis/console).
  id: totrans-1400
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ² 从[https://code.google.com/apis/console](https://code.google.com/apis/console)获取API密钥。
- en: Listing 8.36\. Configuring the PageSpeed plugin
  id: totrans-1401
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.36. 配置PageSpeed插件
- en: '[PRE239]'
  id: totrans-1402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: 'To run the example, you’ll have to take the key you got from Google and enter
    the following command into your terminal:'
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行示例，您必须将您从Google获得的密钥输入到您的终端中：
- en: '[PRE240]'
  id: totrans-1404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: For more information about the reasons for storing secrets in environment variables,
    go back to [chapter 3](kindle_split_014.html#ch03), [section 3.2](kindle_split_014.html#ch03lev1sec2).
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: 关于将秘密存储在环境变量中的原因的更多信息，请参阅[第3章](kindle_split_014.html#ch03)，[第3.2节](kindle_split_014.html#ch03lev1sec2)。
- en: In the case of `grunt-yslow`, the Grunt plugin for YSlow, you won’t need to
    get any API keys, which makes matters considerably simpler. Configuring the plugin
    is a matter of specifying the website URL you want to hit and setting the threshold
    levels for page weight, page load speed, performance score (out of 100), and request
    count, as shown in the following listing (sample ch08/12_yahoo-yslow).
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: 在`grunt-yslow`（YSlow的Grunt插件）的情况下，您不需要获取任何API密钥，这使得事情变得相当简单。配置插件只是指定您想要访问的网站URL，并设置页面重量、页面加载速度、性能评分（满分100分）和请求数量的阈值，如下所示（sample
    ch08/12_yahoo-yslow）。
- en: Listing 8.37\. Configuring the YSlow plugin
  id: totrans-1407
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.37. 配置YSlow插件
- en: '[PRE241]'
  id: totrans-1408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: 'To run these YSlow tests, enter the following command into your terminal:'
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这些YSlow测试，请在您的终端中输入以下命令：
- en: '[PRE242]'
  id: totrans-1410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: All of these examples can be found in the accompanying source code samples,
    under ch08\. Make sure to check them out!
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些示例都可以在附带的源代码示例中找到，位于ch08目录下。请务必查看它们！
- en: 8.6\. Summary
  id: totrans-1412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.6. 概述
- en: 'That was exciting! We covered many concepts in a short time:'
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: 那真是太激动人心了！我们在短时间内覆盖了许多概念：
- en: You got a crash course on unit testing and learned how to tune your components,
    making them more suitable to test.
  id: totrans-1414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您接受了单元测试的速成课程，并学习了如何调整组件，使它们更适合测试。
- en: I explained Tape and how you can use it to seamlessly run tests on both the
    client side and the server side, without duplicating your code.
  id: totrans-1415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我解释了Tape以及您如何使用它无缝地在客户端和服务器端运行测试，而无需重复代码。
- en: You learned about mocks, spies, and proxies; why you need them; and how you
    can use them in JavaScript code.
  id: totrans-1416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你学习了关于模拟、间谍和代理；为什么你需要它们；以及如何在JavaScript代码中使用它们。
- en: I showed you several case studies to help you figure out what things you should
    be testing for and how you should test them.
  id: totrans-1417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我展示了几个案例研究，帮助你弄清楚你应该测试哪些内容以及如何测试。
- en: You looked at automation using Grunt to run Tape tests on both the server and
    the browser without leaving the command line.
  id: totrans-1418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你使用 Grunt 在服务器和浏览器上运行 Tape 测试，而无需离开命令行来处理自动化。
- en: I introduced you to integration and visual testing, and you learned how to automate
    those tasks using Grunt.
  id: totrans-1419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我介绍了集成和视觉测试，并学习了如何使用 Grunt 自动化这些任务。
- en: If you’re interested in learning more about testing, I suggest you check out
    *Test-Driven JavaScript Development*, by Christian Johansen (Developer’s Library,
    2010).
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于测试的知识，我建议你阅读 Christian Johansen 所著的 *Test-Driven JavaScript Development*（开发者图书馆，2010年）。
- en: Chapter 9\. REST API design and layered service architectures
  id: totrans-1421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9章\. REST API设计和分层服务架构
- en: '*This chapter covers*'
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Designing API architectures
  id: totrans-1423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计API架构
- en: Understanding the REST constraint model
  id: totrans-1424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解REST约束模型
- en: Learning about API paging, caching, and throttling schemes
  id: totrans-1425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解API分页、缓存和节流方案
- en: API documentation techniques
  id: totrans-1426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API文档技术
- en: Developing layered service architectures
  id: totrans-1427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发分层服务架构
- en: Consuming a REST API on the client side
  id: totrans-1428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在客户端消费REST API
- en: I’ve described how to approach build processes, and you’ve learned about deployments
    and configuring the different environments your application will live on. You
    also learned about modularity, dependency management, asynchronous code flows
    in JavaScript, and the MVC approach to developing scalable application architectures.
    To round things out, this chapter focuses on designing a REST API architecture
    and consuming it on the client side, allowing you to tie the front end to a back-end
    persistence layer using a transparent and clean API.
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经描述了如何处理构建过程，你已经了解了部署以及配置应用程序将运行的不同环境。你还学习了模块化、依赖管理、JavaScript中的异步代码流以及开发可扩展应用程序架构的MVC方法。为了使内容更加完整，本章重点介绍了设计REST
    API架构并在客户端消费它，允许你使用透明且干净的API将前端与后端持久层绑定。
- en: 9.1\. Avoiding API design pitfalls
  id: totrans-1430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1\. 避免API设计陷阱
- en: If you’ve ever worked on the front end of a web project for a large enterprise,
    then I’m sure you can relate to the complete lack of cohesion in the design of
    the back-end API. Do you need to access a list of product categories? You should
    do an AJAX request `GET /categories`. Do you have products belonging to a category?
    Sure thing; use `GET /getProductListFromCategory?category_id=id.` Do you have
    products in two categories? Use `GET /productInCategories?values=id_1,id_2,...id_n.`
    Need to save changes to the product description? Tough luck, you’ll have to send
    the entire product again through the wire. `POST /product,` appending a large
    JSON blob in the body. Need to send a customized email to a particular human?
    `POST /email-customer` with their email and the email message data.
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经为大型企业的前端项目工作过，那么我相信你一定能够理解后端 API 设计的完全缺乏一致性。你需要访问产品类别列表吗？你应该执行一个 AJAX 请求
    `GET /categories`。你有属于某个类别的产品吗？当然；使用 `GET /getProductListFromCategory?category_id=id`。你有属于两个类别的产品吗？使用
    `GET /productInCategories?values=id_1,id_2,...id_n`。需要保存产品描述的更改？很遗憾，你将不得不再次通过网络发送整个产品。`POST
    /product`，在主体中附加一个大的 JSON 块。需要向特定的人发送定制的电子邮件吗？`POST /email-customer`，包括他们的电子邮件和电子邮件消息数据。
- en: 'If you can’t find anything wrong with that API design, chances are you’ve spent
    too much time working with similar APIs. The following list details issues with
    how it was designed:'
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有发现该API设计有任何问题，那么很可能是你花了太多时间与类似的API一起工作。以下列表详细说明了设计中的问题：
- en: 'Each new method has its own set of naming conventions: the `GET` verb is repeated
    in the endpoint, camelCase, hyphen-delimited, or underscore_separated. You name
    it!'
  id: totrans-1433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个新方法都有自己的命名约定：`GET` 动词在端点中重复，使用驼峰式、连字符分隔或下划线分隔。你命名它！
- en: Beside naming conventions, endpoints aren’t marked in any way that differentiates
    them from those that render views.
  id: totrans-1434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了命名约定外，端点没有以任何方式标记，以区分它们与渲染视图的端点。
- en: Argument intake preference also varies wildly with no clear distinction through
    the query string or the request body. Maybe cookies could do the trick!
  id: totrans-1435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数输入偏好也极其不同，没有通过查询字符串或请求体进行明确的区分。也许 cookies 可以解决这个问题！
- en: It’s not clear when to use each HTTP verb `(HEAD`, `GET`, `POST`, `PUT`, `PATCH`,
    `DELETE`). As a result, only `GET` and `POST` are used.
  id: totrans-1436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不清楚何时使用每个 HTTP 动词（`HEAD`、`GET`、`POST`、`PUT`、`PATCH`、`DELETE`）。因此，只有 `GET` 和
    `POST` 被使用。
- en: Inconsistency throughout the API. Well-designed APIs are not only well documented,
    but also present consistency across the board that allows consumers to hack through
    the API, as well as implementers to easily build on the existing API by copying
    what it does.
  id: totrans-1437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 中的不一致性。设计良好的 API 不仅具有良好的文档，而且在各个方面都表现出一致性，这允许消费者在 API 中进行黑客攻击，以及实现者通过复制其功能来轻松地构建在现有
    API 之上。
- en: This isn’t merely the work of a madman who decided to mix naming and argument-passing
    conventions, along with glossing over any kind of standardization and cohesion
    across API endpoints. The most likely scenario for how the API got to the state
    it is in today is employee rotation on the project maintaining the API. Yes, it
    could also be a single person who doesn’t know any better, but in that case you’ll
    observe at least some degree of consistency across the API methods. A well-designed
    API enables consumers to infer documentation for a method once they’ve used a
    few related methods. That’s because methods would be named in a consistent manner,
    they would take similar parameters, and those parameters would be named and ordered
    consistently as well. When an API is poorly designed, or doesn’t follow a set
    of consistency guidelines, it’s harder to achieve this state where the how can
    be inferred from simply using the API. Inference can only be attained when the
    API is consistently designed to be straightforward.
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不仅仅是某个疯子决定混合命名和参数传递约定，同时忽略 API 端点之间的任何标准化和一致性。API 今天的状况最可能的情景是维护 API 的项目员工轮换。是的，也可能是一个不知道更好的单个人，但在那种情况下，你会在
    API 方法中观察到至少一些程度的一致性。一个设计良好的 API 能够让消费者在使用几个相关方法后推断出方法的文档。这是因为方法将以一致的方式进行命名，它们将接受类似的参数，这些参数也将以一致的方式进行命名和排序。当一个
    API 设计不佳，或者不遵循一套一致性指南时，从简单地使用 API 中推断出如何操作会更难。只有当 API 被一致地设计为简单易懂时，才能达到这种推断状态。
- en: In this chapter I’ll teach you how to design cohesive, consistent, and coherent
    APIs for direct consumption in your web projects and elsewhere. The API consumed
    by the front end is one area where we could do better. Together with JavaScript
    testing, I’d say that these are two of the most commonly undervalued aspects of
    front-end development.
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将教你如何设计一致、一致和连贯的 API，以便在您的 Web 项目和其他地方直接消费。前端使用的 API 是我们可以做得更好的一个领域。与
    JavaScript 测试一起，我认为这些都是前端开发中最常被低估的方面之一。
- en: REST stands for Representational State Transfer, and it’s a comprehensive set
    of guidelines that you can use to design API architectures. Once you understand
    REST, I’ll give you a tour of how to design a typical layered service architecture
    to go with that API. Before signing off, you’ll gain insight into developing client-side
    code to interact with the REST API, allowing you to react to responses from the
    API. Let’s get going!
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: REST 代表表示状态转移，它是一套全面的指南，你可以用它来设计 API 架构。一旦你理解了 REST，我将带你去看看如何设计一个典型的分层服务架构，以配合该
    API。在结束之前，你将获得开发客户端代码以与 REST API 交互的见解，这将允许你对 API 的响应做出反应。让我们开始吧！
- en: 9.2\. Learning REST API design
  id: totrans-1441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2. 学习 REST API 设计
- en: REST is a set of architectural constraints that aid you when developing an API
    over HTTP. Imagine you start developing a web API in “anything goes” mode—a clean
    slate. Then add REST constraints into the mix, one by one. The end result will
    be a standardized API that most developers will feel comfortable developing and
    consuming. Note that there are different interpretations of how a REST API should
    be designed, and that several of my interpretations are sprinkled throughout this
    chapter. These are the interpretations that work well for me, but in the end that’s
    simply my opinion.
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: REST 是一组架构约束，它在你开发基于 HTTP 的 API 时为你提供帮助。想象一下，你以“什么都行”的模式开始开发一个 Web API——一张白纸。然后逐个加入
    REST 约束。最终结果将是一个标准化的 API，大多数开发者都会感到舒适地进行开发和消费。请注意，关于如何设计 REST API 有不同的解释，而且我在本章中穿插了几个我的解释。这些是我认为效果很好的解释，但最终这仅仅是我的观点。
- en: 'Roy Fielding wrote a dissertation that introduced REST to the world,^([[1](#ch09fn01)])
    and it has only seen an increase in adoption since its publication in 2000\. I’ll
    only cover the constraints relevant to our purposes: putting together a dedicated
    REST API for the front end of your application to consume. Among other constraints,
    you’ll touch on how to construct the endpoints that make up your API, how to handle
    requests, and what kinds of status codes you should use. Later we’ll go into more
    advanced HTTP communication topics, such as paging results, caching responses,
    and throttling requests.'
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: Roy Fielding撰写了一篇博士论文，向世界介绍了REST，[[1](#ch09fn01)] 自2000年发表以来，其采用率一直在增加。我将只涵盖与我们目的相关的约束：为你的应用程序前端构建一个专门的REST
    API。在其他约束中，你将接触到如何构建组成你的API的端点，如何处理请求，以及你应该使用哪些类型的状态码。稍后我们将深入更高级的HTTP通信主题，例如分页结果、缓存响应和限制请求。
- en: ¹ Fielding, Roy Thomas. Architectural Styles and the Design of Network-Based
    Software Architectures. Doctoral dissertation, UC Irvine, 2000\. [http://bevacqua.io/bf/rest](http://bevacqua.io/bf/rest).
  id: totrans-1444
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ Fielding, Roy Thomas. 《网络软件架构的设计与架构风格》。博士论文，加州大学欧文分校，2000年。[http://bevacqua.io/bf/rest](http://bevacqua.io/bf/rest)。
- en: The first such constraint that you’ll visit is that REST is stateless, meaning
    requests should contain all the information necessary for the back end to understand
    what you want, and the server shouldn’t take advantage of any additional context
    stored in the server. In practical terms, you get “pure” endpoints where the output
    (response) is defined solely by the inputs (request).
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: 你将访问的第一个这样的约束是REST是无状态的，这意味着请求应包含所有必要的信息，以便后端理解你想要什么，服务器不应利用存储在服务器中的任何额外上下文。在实践中，你得到“纯”端点，其中输出（响应）完全由输入（请求）定义。
- en: The other constraint that interests us is that REST expects a uniform interface.
    Each endpoint in the API is expected to take parameters, affect the persistence
    layer, and respond in a certain, predictable way. To expand on these, you’ll need
    to understand that REST deals in resources.
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感兴趣的另一个约束是REST期望一个统一的接口。API中的每个端点都期望接受参数，影响持久层，并以某种可预测的方式响应。为了进一步说明，你需要了解REST处理资源。
- en: '|  |'
  id: totrans-1447
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**REST resources**'
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: '**REST资源**'
- en: In REST, a *resource* is an abstraction of information, any information. For
    your purposes you could act as if resources and database models were equivalents.
    Users are a resource, and so are Products and Categories. Resources can be queried
    through the uniform interface I described.
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: 在REST中，*资源*是信息的抽象，任何信息。就你的目的而言，你可以假设资源和数据库模型是等效的。用户是一种资源，产品和分类也是如此。资源可以通过我描述的统一接口进行查询。
- en: '|  |'
  id: totrans-1450
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Let’s bring the discussion closer to the ground and describe in practical terms
    what this means for the way you structure the front-end API.
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更接近实际，用实际术语描述这对你结构前端API意味着什么。
- en: 9.2.1\. Endpoints, HTTP verbs, and versioning
  id: totrans-1452
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.1. 端点、HTTP动词和版本
- en: Have you ever used an API and felt it was great? Felt that you “get it,” and
    in fact you could guess the names of their methods, their methods worked in the
    way you expected them to, and there were no surprises? A couple of examples of
    well-executed APIs come to my mind; the first one is the language API in the Ruby
    standard library, with methods that clearly define what their purpose is, are
    consistent in the parameters they take, and have mirror methods that do exactly
    their opposite.
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经使用过API并且觉得它很棒？感觉你“明白了”，实际上你能猜到它们方法的名称，它们的方法以你预期的方式工作，而且没有惊喜？几个执行良好的API的例子浮现在我的脑海中；第一个是Ruby标准库中的语言API，它有明确定义其目的的方法，参数使用上保持一致，并且有镜像方法，这些方法正好执行相反的操作。
- en: The `String` class in Ruby has a `.capitalize` method; it creates an uppercase
    copy of a string.
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby中的`String`类有一个`.capitalize`方法；它创建一个字符串的大写副本。
- en: 'Then there’s `.capitalize!`, which capitalizes the original string rather than
    creating a copy. You also have `.strip`, which returns a copy where leading and
    trailing whitespace is gone. You probably guessed the next one: `.strip!`, which
    is the same as `.strip` but on the original string.'
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是`.capitalize!`，它将原始字符串大写而不是创建一个副本。你还有`.strip`，它返回一个没有前后空白字符的副本。你可能已经猜到了下一个：`.strip!`，它与`.strip`相同，但作用于原始字符串。
- en: Facebook has other good examples. Their Graph REST API is easy to use, and it’s
    cohesive in that endpoints work mostly the same way. You can also chop parts of
    the URL and hack your way through their website; for example, [http://facebook.com/me](http://facebook.com/me)
    takes you to your own profile, as their API recognizes `me` as the currently authenticated
    user.
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook有其他很好的例子。他们的Graph REST API易于使用，并且它在端点方面是一致的，即端点大多以相同的方式工作。你也可以截取URL的一部分，通过他们的网站进行“黑客”操作；例如，[http://facebook.com/me](http://facebook.com/me)
    会带你到你的个人资料，因为他们的API将 `me` 识别为当前认证的用户。
- en: 'This kind of consistent behavior is critical to a great API. In contrast, bad
    API design leads to confusion and is characterized by the lack of a naming convention,
    ambiguous or poor documentation, or even worse: undocumented side effects. PHP
    is a notorious guide to writing a poor API. The issue arises because of the lack
    of a specification and different authors taking over different parts of the PHP
    language API. As a result, PHP functions have wildly varying signatures, names,
    and even casing conventions. You have no way to guess the name of a given function.
    Sometimes these issues can be solved by wrapping the existing API in a consistent
    one, which is a big part of how jQuery became popular—by abstracting the DOM API
    in a more convenient and consistent API.'
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: 这种一致的行为对于优秀的API至关重要。相比之下，糟糕的API设计会导致困惑，并具有缺乏命名约定、模糊或差的文档，甚至更糟糕的是：未记录的副作用。PHP是编写糟糕API的臭名昭著的指南。问题在于缺乏规范和不同的作者接管PHP语言API的不同部分。结果，PHP函数具有广泛变化的签名、名称和甚至大小写约定。你无法猜测给定函数的名称。有时这些问题可以通过将现有的API包装在一致的API中来解决，这是jQuery成为流行的一部分——通过在更方便和一致的API中抽象DOM
    API。
- en: The single most important aspect in API design is consistency, and that starts
    with endpoint naming conventions.
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: 在API设计中，最重要的方面是一致性，而这始于端点命名约定。
- en: Naming your endpoints
  id: totrans-1459
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 命名你的端点
- en: To begin with, you need to define a prefix for all API endpoints. If you have
    a subdomain to use, such as `api.example.com`, that’ll work too. For front-end
    API efforts, using `example.com/api` as a prefix should work. A prefix helps discern
    API methods from view routes and sets an expectation for the kind of responses
    they produce (typically JSON in modern web applications).
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要为所有API端点定义一个前缀。如果你有一个要使用的子域名，例如 `api.example.com`，那也可以。对于前端API工作，使用 `example.com/api`
    作为前缀应该可以。前缀有助于区分API方法和视图路由，并设定了它们产生的响应类型的预期（在现代网络应用中通常是JSON）。
- en: 'The prefix on its own isn’t enough, though. Putting together a coherent API
    mostly relies on following strict guidelines when naming your endpoints. Here’s
    a set of guidelines to get you started:'
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前缀本身就足够了，但构建一个连贯的API主要依赖于在命名端点时遵循严格的指南。以下是一套指南，帮助你开始：
- en: Use all lowercase, hyphenated endpoints such as `/api/verification-tokens.`
    This increases URL “hackability,” which is the ability to manually go in and modify
    the URL by hand. You can pick any naming scheme you like, as long as you’re consistent
    about it.
  id: totrans-1462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用全部小写、带有连字符的端点，例如 `/api/verification-tokens.` 这样可以增加URL的“可玩性”，即手动进入并手动修改URL的能力。你可以选择任何你喜欢的命名方案，只要你能保持一致性。
- en: Use a noun or two to describe the resource, such as `verification-tokens`, `users`,
    or `products.`
  id: totrans-1463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个或两个名词来描述资源，例如 `verification-tokens`、`users` 或 `products`。
- en: 'Always describe resources in plural`: /api/users` rather than `/api/user.`
    This makes the API more semantic, as you’ll see in a minute.'
  id: totrans-1464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是使用复数来描述资源：`/api/users` 而不是 `/api/user`。这样可以使API更具语义性，正如你将在下一分钟看到的。
- en: These guidelines get us to an interesting point. Let’s make an example out of
    `/api/products` to see how you can design the API in a way that’s RESTful and
    consistent.
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指南带我们到了一个有趣的观点。让我们以 `/api/products` 为例，看看你如何设计一个既RESTful又一致的API。
- en: HTTP verbs and CRUD consistency
  id: totrans-1466
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: HTTP动词和CRUD一致性
- en: First, getting a list of products is probably the most basic task you could
    perform against the products API. The `/api/products` endpoint is prime for the
    task, so you implement a route on the server that returns a list of products as
    JSON, and you start feeling pretty good about yourself. Next, you want to return
    individual products; this will be used when humans visit the product details page.
    In this case, you might be tempted to define the endpoint as `/api/product/:id`,
    but one of your guidelines was to always use plurals, so that’ll end up looking
    like `/api/products/:id.`
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，获取产品列表可能是你对产品API执行的最基本任务。`/api/products` 端点是这项任务的理想选择，因此你在服务器上实现了一个返回产品列表的JSON的路线，并且开始对自己感到相当满意。接下来，你想要返回单个产品；这将在人类访问产品详情页面时使用。在这种情况下，你可能倾向于将端点定义为
    `/api/product/:id`，但你的一个指导原则是始终使用复数形式，所以它最终会看起来像 `/api/products/:id.`
- en: Both of those methods are clearly defined as `GET` requests, because they interact
    with the server in a read-only fashion. What about removing a product? Typically,
    non-REST interfaces use methods such as `POST /removeProduct?id=:id.` Sometimes
    the `GET` verb is used, which results in web crawlers such as Google wiping out
    important database information by following `GET` links on a site.^([[2](#ch09fn02)])
    REST suggests you use the `DELETE` HTTP verb instead, on the same endpoint that
    you used to `GET` a single product, `/api/products/:id.` Taking advantage of one
    of the building blocks of HTTP—their verbs—you can compose more semantic and consistent
    APIs.
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都明确定义为 `GET` 请求，因为它们以只读方式与服务器交互。那么移除产品怎么办呢？通常，非REST接口使用如 `POST /removeProduct?id=:id.`
    这样的方法。有时会使用 `GET` 动词，这会导致像谷歌这样的网络爬虫通过跟随网站上的 `GET` 链接来清除重要的数据库信息。[^([2](#ch09fn02))]
    REST建议你使用与获取单个产品相同的端点上的 `DELETE` HTTP动词，即 `/api/products/:id`。利用HTTP的一个构建块——它们的动词——你可以构建更具语义和一致性的API。
- en: '² Read this article for a similar story on how Google wiped clean the content
    on a website just by following links: [http://bevacqua.io/bf/spider](http://bevacqua.io/bf/spider).'
  id: totrans-1469
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ² 阅读这篇文章，了解谷歌如何仅通过跟随链接就清除了网站内容的类似故事：[http://bevacqua.io/bf/spider](http://bevacqua.io/bf/spider)。
- en: Inserting items of a given resource type involves a similar thought process.
    In non-REST scenarios you might’ve had `POST /createProduct` and a body of relevant
    data, whereas in REST you should use the more semantic `PUT` verb, along with
    the consistent `/api/products` endpoint. Last, edits should use the `PATCH` verb
    and an endpoint such as `/api/products/:id`. We’ll reserve the POST verb for operations
    that don’t merely involve creating or updating database objects, such as `/notifySubscribers`
    via email. Relationships are one last type of endpoint that can be considered
    part of basic storage operations (Create, Read, Update, Delete, or CRUD for short).
    Given all of what I’ve described so far, it probably won’t be hard for you to
    imagine how `GET /api/products/:id/parts` is a great starting point for a request
    that responds with the individual parts that make up a particular product.
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: 插入给定资源类型的项目涉及类似的思想过程。在非REST场景中，你可能有过 `POST /createProduct` 和相关数据的主体，而在REST中，你应该使用更具语义的
    `PUT` 动词，以及一致的 `/api/products` 端点。最后，编辑应使用 `PATCH` 动词和一个如 `/api/products/:id`
    的端点。我们将保留 `POST` 动词用于不单纯涉及创建或更新数据库对象的操作，例如通过电子邮件的 `/notifySubscribers`。关系是最后一种可以被认为是基本存储操作（创建、读取、更新、删除，简称
    CRUD）的端点类型。鉴于我迄今为止所描述的所有内容，你可能不会觉得想象 `GET /api/products/:id/parts` 是一个请求的良好起点有多难，该请求会响应构成特定产品的单个部件。
- en: That’s it, as far as CRUD goes. What happens if you want to use something other
    than CRUD? Use your best judgment. Usually, you could use the `POST` verb, ideally
    constraining yourself to a particular resource type, which doesn’t necessarily
    need to be a database model reference. For instance, `POST /api/authentication/login`
    can handle login attempts on the front end.
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: 就CRUD而言，这就是全部内容。如果你想要使用除了CRUD之外的东西怎么办？使用你的最佳判断。通常，你可以使用 `POST` 动词，理想情况下将你自己限制在特定的资源类型上，这不一定需要是数据库模型引用。例如，`POST
    /api/authentication/login` 可以处理前端上的登录尝试。
- en: As a summary, [Table 9.1](#ch09table01) shows the verbs and endpoints discussed
    so far per a typical REST API design. I omitted the `/api` prefixes for brevity.
    Note that I use `products` as an example resource type to make the example easier
    to relate to, but this applies to any resource type.
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: 作为总结，[表9.1](#ch09table01) 显示了到目前为止讨论的动词和端点，按照典型的REST API设计。为了简洁起见，我省略了 `/api`
    前缀。请注意，我使用 `products` 作为示例资源类型，以便使示例更容易相关联，但这适用于任何资源类型。
- en: Table 9.1\. Product endpoints in a typical REST API
  id: totrans-1473
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表9.1. 典型REST API中的产品端点
- en: '| Verb | Endpoint | Description |'
  id: totrans-1474
  prefs: []
  type: TYPE_TB
  zh: '| 动词 | 端点 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-1475
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| GET | /products | Gets a list of products |'
  id: totrans-1476
  prefs: []
  type: TYPE_TB
  zh: '| GET | /products | 获取产品列表 |'
- en: '| GET | /products/:id | Gets a single product by ID |'
  id: totrans-1477
  prefs: []
  type: TYPE_TB
  zh: '| GET | /products/:id | 通过ID获取单个产品 |'
- en: '| GET | /products/:id/parts | Gets a list of parts in a single product |'
  id: totrans-1478
  prefs: []
  type: TYPE_TB
  zh: '| GET | /products/:id/parts | 获取单个产品中的部件列表 |'
- en: '| PUT | /products/:id/parts | Inserts a new part for a particular product |'
  id: totrans-1479
  prefs: []
  type: TYPE_TB
  zh: '| PUT | /products/:id/parts | 为特定产品插入一个新的部件 |'
- en: '| DELETE | /products/:id | Deletes a single product by ID |'
  id: totrans-1480
  prefs: []
  type: TYPE_TB
  zh: '| 删除 | /products/:id | 通过ID删除单个产品 |'
- en: '| PUT | /products | Inserts a new product |'
  id: totrans-1481
  prefs: []
  type: TYPE_TB
  zh: '| PUT | /products | 插入一个新的产品 |'
- en: '| HEAD | /products/:id | Returns whether the product exists through a status
    code of 200 or 404 |'
  id: totrans-1482
  prefs: []
  type: TYPE_TB
  zh: '| HEAD | /products/:id | 通过状态码200或404返回产品是否存在 |'
- en: '| PATCH | /products/:id | Edits an existing product by ID |'
  id: totrans-1483
  prefs: []
  type: TYPE_TB
  zh: '| PATCH | /products/:id | 通过ID编辑现有产品 |'
- en: '| POST | /authentication/login | Most other API methods should use POST requests
    |'
  id: totrans-1484
  prefs: []
  type: TYPE_TB
  zh: '| POST | /authentication/login | 大多数其他API方法应使用POST请求 |'
- en: Please note that the HTTP verbs chosen for each type of action aren’t set in
    stone. It is, in fact, a topic of heated arguments, where people argue `POST`
    should be used for inserts, or any other operation that’s not idempotent, and
    endpoints using the other verbs (`GET`, `PUT`, `PATCH`, `DELETE`) must result
    in idempotent operations—repeated requests on those endpoints shouldn’t alter
    the outcome.
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为每种操作类型选择的HTTP动词并不是一成不变的。实际上，这是一个激烈争论的话题，人们争论`POST`应该用于插入，或任何其他非幂等操作，而使用其他动词（`GET`、`PUT`、`PATCH`、`DELETE`）的端点必须导致幂等操作——对这些端点的重复请求不应改变结果。
- en: Versioning is also an important aspect of REST API design, but is it necessary
    for front-end operations?
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制也是REST API设计的一个重要方面，但对于前端操作来说，这是否必要呢？
- en: API versioning
  id: totrans-1487
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: API版本控制
- en: In traditional API scenarios, versioning is useful because it allows you to
    commit breaking changes to your service without demolishing the interaction with
    existing consumers. Two main schools of thought exist in the REST API versioning
    department.
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的API场景中，版本控制是有用的，因为它允许您在不破坏现有消费者交互的情况下对服务进行破坏性更改。在REST API版本控制方面存在两种主要的思想流派。
- en: One school of thought is convinced that the API version should be set in HTTP
    headers, and that if a version isn’t specified in the request, you should get
    a response from the latest version of the API. This formal approach is closer
    to what the original dissertation for REST proposed, but an argument is that if
    the API is poorly executed it can lead to breaking changes inadvertently.
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: 一种观点认为，API版本应该设置在HTTP头中，如果没有在请求中指定版本，您应该从API的最新版本获得响应。这种正式的方法更接近原始REST论文所提出的，但有人认为如果API执行不当，可能会导致意外破坏性更改。
- en: 'Instead, they propose that the version is embedded into the API endpoint prefix:
    `/api/v1/....` This also identifies right away which version of the API your application
    wants by looking at the requested endpoint.'
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，他们提出将版本嵌入到API端点前缀中：`/api/v1/....` 通过查看请求的端点，可以立即识别出应用程序想要使用哪个API版本。
- en: Truth is, it doesn’t change that much from having the `v1` be in the endpoint
    or in a request header, so it’s mostly a matter of preference for the API implementer.
    When it comes to web applications and their accompanying API, you don’t necessarily
    need to implement any versioning, and that’s why I’m inclined to go with the request
    header approach. That way, if somewhere down the line you decide you do need versioning,
    you can easily define a “latest version” as the default, and if consumers still
    want the previous version they can add a header explicitly asking for the old
    one. That being said, requesting a specific version of the API is always more
    desirable than blindly accepting whatever the latest API may be, so as not to
    break functionality unexpectedly.
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，将`v1`放在端点或请求头中并不会改变太多，所以这主要取决于API实现者的偏好。当涉及到Web应用程序及其伴随的API时，您不一定需要实现任何版本控制，这就是我倾向于采用请求头方法的原因。这样，如果您在某个时候决定确实需要版本控制，您可以轻松地定义“最新版本”作为默认版本，如果消费者仍然想要旧版本，他们可以显式地添加一个请求头以获取旧版本。话虽如此，请求特定的API版本总是比盲目接受最新的API更可取，以免意外破坏功能。
- en: 'I mentioned you don’t need to necessarily implement versioning in the REST
    API consumed by the front end, and that depends on two factors:'
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到您不一定需要在前端使用的REST API中实现版本控制，这取决于两个因素：
- en: Is the API public facing as well? In this case, versioning is necessary, baking
    a bit more predictability into your service’s behavior.
  id: totrans-1493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API是否面向公众？在这种情况下，版本控制是必要的，这将在你的服务行为中增加更多的可预测性。
- en: Is the API used by several applications? Are the API and the front end developed
    by separate teams? Is there a drawn-out process to change an API endpoint? If
    any of these cases apply, you’re probably better off versioning your API.
  id: totrans-1494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被多个应用程序使用的API吗？API和前端是由不同的团队开发的吗？更改API端点是否有漫长的流程？如果这些情况中的任何一个适用，你可能最好对你的API进行版本控制。
- en: Unless your team and your application are small enough that both live in the
    same repository and developers touch on both indistinctly, go for the safe bet
    and use versions in your API.
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你的团队和应用程序足够小，以至于两者都位于同一个存储库中，并且开发者可以模糊地触及两者，否则请选择安全的方案，并在你的API中使用版本。
- en: Time to move on and study what requests and responses may look like.
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候继续前进，研究请求和响应可能的样子了。
- en: 9.2.2\. Requests, responses, and status codes
  id: totrans-1497
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.2. 请求、响应和状态码
- en: As I’ve mentioned before, consistency by following REST conventions is key in
    developing a highly usable API. This applies to requests and responses as well.
    An API is expected to take arguments consistently; the way this usually works
    is that you take the ID via the endpoint. In the case of the product by ID route,
    `/api/products/:id`, when requesting the `/api/products/bad0-bab8` URL, assume
    `bad0-bab8` is the requested resource identifier.
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，遵循REST约定的一致性是开发高度可用的API的关键。这也适用于请求和响应。API应该一致地接受参数；这通常是通过端点获取ID的方式实现的。在按ID获取产品的路由`/api/products/:id`的情况下，当请求`/api/products/bad0-bab8`
    URL时，假设`bad0-bab8`是请求的资源标识符。
- en: Requests
  id: totrans-1499
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 请求
- en: 'Modern-day web routers have no trouble dissecting the URL and providing the
    specified request parameters. For instance, the following code shows how Express,
    a Node.js web framework, lets you define a dynamic route that captures requests
    for products via an identifier. Then it parses the request URL and hands you the
    appropriately parsed parameters:'
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: 当今的Web路由器在解析URL并提供指定的请求参数方面毫无困难。例如，以下代码展示了Node.js Web框架Express如何让你定义一个动态路由，该路由通过标识符捕获对产品的请求。然后它解析请求URL并为你提供适当的解析参数：
- en: '[PRE243]'
  id: totrans-1501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: Having the identifier as part of the request endpoint is great because it allows
    `DELETE` and `GET` requests to use the same endpoint, making for a more intuitive
    API, like I mentioned previously about Ruby. You should decide on a consistent
    data-transfer strategy to upload the data to the server when making `PUT`, `PATCH`,
    or `POST` requests that modify a resource in the server. Nowadays, JSON is used
    almost ubiquitously as the data transport of choice due to its simplicity, the
    fact that it’s native to browsers, and the high availability of JSON parsing libraries
    across server-side languages.
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: 将标识符作为请求端点的一部分是非常好的，因为它允许`DELETE`和`GET`请求使用相同的端点，从而创建一个更直观的API，就像我之前提到的Ruby。你应该决定一个一致的数据传输策略，在制作修改服务器上资源的`PUT`、`PATCH`或`POST`请求时上传数据。如今，由于它的简单性、它是浏览器的本地格式以及服务器端语言中JSON解析库的高度可用性，JSON几乎被普遍用作数据传输的首选格式。
- en: Responses
  id: totrans-1503
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 响应
- en: Like requests, responses should conform to a consistent data-transfer format,
    so you have no surprises when parsing the response. Even when an error occurs
    on the server side, the response is still expected to be valid according to the
    chosen transport; for example, if our API is built using JSON, then all the responses
    produced by our API should be valid JSON (granted the user is accepting a JSON
    response in the HTTP headers).
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: 就像请求一样，响应应该符合一致的数据传输格式，这样在解析响应时就不会有惊喜。即使服务器端发生错误，响应仍然应该根据所选的传输方式是有效的；例如，如果我们的API是使用JSON构建的，那么我们API产生的所有响应都应该有效的JSON（假设用户在HTTP头中接受JSON响应）。
- en: 'You should figure out the envelope in which you’ll wrap your responses. An
    envelope, or message wrapper, is crucial for providing a consistent experience
    across all your API endpoints, allowing consumers to make certain assumptions
    about the responses the API provides. A useful starting point may be an object
    with a single field, named `data`, that contains the body of your response:'
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该弄清楚你将包裹你的响应的包装器。包装器或消息包装器对于在所有API端点提供一致体验至关重要，它允许消费者对API提供的响应做出某些假设。一个有用的起点可能是一个包含单个字段的对象，该字段名为`data`，包含你的响应正文：
- en: '[PRE244]'
  id: totrans-1506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: 'Errors may be another useful field, only present when an error occurs, containing
    an object that may expose properties such as an error message, reason, and accompanying
    metadata. Suppose you query the API on the `GET /api/products/baeb-b00f` endpoint,
    but a `baeb-b00f` product doesn’t exist in the database:'
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: 错误字段可能也是一个有用的字段，仅在发生错误时出现，包含可能暴露错误消息、原因和伴随元数据的对象。假设您在`GET /api/products/baeb-b00f`端点上查询API，但数据库中不存在`baeb-b00f`产品：
- en: '[PRE245]'
  id: totrans-1508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: Using an envelope and the appropriate error fields in your responses aren’t
    enough on their own. As a REST API developer you should also be conscious about
    the status codes that you choose for your API’s responses.
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用信封和适当的错误字段在您的响应中是不够的。作为一名REST API开发者，您还应该意识到您为API响应选择的状态码。
- en: HTTP Status codes
  id: totrans-1510
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: HTTP状态码
- en: 'In the case of a product not being found, you should respond with the `404
    Not Found` status code, in addition to the properly formatted response that describes
    the error. Status codes are particularly important in allowing API consumers to
    make assumptions about the responses. When you respond with status codes in the
    2xx Success class, the response body should contain all of the relevant data that
    was requested. Here’s an example showing the response to a request on a product
    that could be found, alongside with the HTTP version and status code:'
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: 在找不到产品的情况下，您应该响应`404未找到`状态码，以及描述错误的正确格式化响应。状态码在允许API消费者对响应做出假设方面尤为重要。当您以2xx成功类状态码响应时，响应体应包含所有请求的相关数据。以下是一个示例，展示了针对可能找到的产品请求的响应，以及HTTP版本和状态码：
- en: '[PRE246]'
  id: totrans-1512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: Then there’s the 4xx Client Error class codes, which mean the request most likely
    failed due to an error made by the client side (the user wasn’t properly authenticated,
    for instance). In these cases, you should use the `error` field to describe why
    the request was faulty. For instance, if input validation fails on a form while
    attempting to create a product, you could return a response using a `400 Bad Request`
    status code, as shown in the following listing.
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是4xx客户端错误类代码，这意味着请求很可能由于客户端（例如用户未正确认证）的错误而失败。在这些情况下，您应该使用`error`字段来描述请求为何有误。例如，如果在尝试创建产品时表单输入验证失败，您可以使用`400请求错误`状态码返回响应，如下所示。
- en: Listing 9.1\. Describing an error
  id: totrans-1514
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.1\. 描述错误
- en: '[PRE247]'
  id: totrans-1515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: 'Another kind of error in the 5xx status code range is an unexpected error such
    as `500 Internal Server Error.` These should be presented to the consumer in the
    same way as 4xx errors. Suppose the previous request results in an error; you
    should then respond with a 500 status code and a snippet of data in the response
    body, similar to the following:'
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: 5xx状态码范围内的另一种错误是意外错误，例如`500内部服务器错误`。这些错误应该以与4xx错误相同的方式呈现给消费者。假设之前的请求导致错误；然后您应该以500状态码和响应体中的数据片段进行响应，类似于以下内容：
- en: '[PRE248]'
  id: totrans-1517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: It’s usually relatively easy to capture these kinds of errors when everything
    else fails and respond with a `500` message, passing in a bit of context as to
    what went wrong.
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: 当其他所有方法都失败时，捕获这类错误通常相对容易，并返回一个`500`消息，传递一些关于出错原因的上下文信息。
- en: Up to this point I’ve covered endpoints, request bodies, status codes, and response
    bodies. Setting proper response headers is another REST API design aspect that’s
    worth mentioning for a variety of reasons.
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经介绍了端点、请求体、状态码和响应体。设置适当的响应头是另一个值得提及的REST API设计方面，原因有很多。
- en: 9.2.3\. Paging, caching, and throttling
  id: totrans-1520
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.3\. 分页、缓存和节流
- en: Although not as important in small applications, paging, caching, and throttling
    all play a part in defining a consistent and highly usable API. Paging in particular
    is often a necessity, because a complete lack of paging would easily cripple your
    application by allowing the API to query and transfer massive amounts of data
    from the database to the clients.
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在小型应用中不太重要，但分页、缓存和节流都在定义一致且高度可用的API中发挥着作用。特别是分页通常是必需的，因为完全缺乏分页会很容易通过允许API从数据库查询和传输大量数据到客户端来削弱您的应用。
- en: Response Paging
  id: totrans-1522
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 响应分页
- en: Going back to the first REST endpoint example I used, suppose I make a query
    to your API for `/api/products`. How many products should that endpoint return?
    All of them? What if there are a hundred? A thousand? Ten? A million? You have
    to draw the line somewhere. You could set a default pagination limit across the
    API and have the ability to override that default for each individual endpoint.
    Within a reasonable range, the consumer should have the ability to pass in a query
    string parameter and choose a different limit.
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: 回到第一个REST端点示例，假设我向你的API发出对`/api/products`的查询。这个端点应该返回多少产品？所有？如果有100个、1000个、10个或100万个呢？你必须在哪里划线。你可以在API中设置默认的分页限制，并能够为每个单独的端点覆盖该默认值。在合理的范围内，消费者应该能够传递一个查询字符串参数并选择不同的限制。
- en: Suppose you settle for 10 products per request. You then have to implement a
    paging mechanism to access the rest of the products available on your application.
    To implement paging, you use the `Link` header.
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你每个请求只接受10个产品。那么，你必须实现分页机制来访问你应用上可用的其他产品。要实现分页，你使用`Link`头。
- en: 'If you query the first products page, the response’s `Link` header should be
    similar to the following code:'
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查询第一个产品页面，响应的`Link`头应该类似于以下代码：
- en: '[PRE249]'
  id: totrans-1526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: Note that the endpoints must be absolute so the consumer can parse the `Link`
    header and query them directly. The `rel` attribute describes the relationship
    between the requested page and the linked page.
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，端点必须是绝对路径，以便消费者可以解析`Link`头并直接查询它们。`rel`属性描述了请求页面与链接页面之间的关系。
- en: 'If you now request the second page, `/api/products/?p=2`, you should get a
    similar `Link` header, this time letting you know that “previous” and “first”
    related pages are also available:'
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在请求第二页，`/api/products/?p=2`，你应该得到一个类似的`Link`头，这次会告诉你“上一页”和“第一页”的相关页面也是可用的：
- en: '[PRE250]'
  id: totrans-1529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: Cases exist where data flows too rapidly for traditional paging methods to behave
    as expected. For instance, if a few records make their way into the database between
    requests for the first page and the second one, the second page results in duplicates
    of items that were on page one but were pushed to the second page as a result
    of the inserts. This issue has two solutions. The first solution is to use identifiers
    instead of page numbers. This allows the API to figure out where you left off,
    and even if new records get inserted, you’ll still get the next page in the context
    of the last range of identifiers that the API gave you. The second approach is
    to give tokens to the consumer that allow the API to track the position they arrived
    at after the last request and what the next page should look like.
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一些情况，数据流动得太快，以至于传统的分页方法无法按预期工作。例如，如果在请求第一页和第二页之间，有少量记录进入数据库，那么第二页将导致第一页上的项目重复，这些项目由于插入而被推到了第二页。这个问题有两个解决方案。第一个解决方案是使用标识符而不是页码。这允许API确定你离开的位置，即使有新的记录被插入，你仍然会在API给出的最后一个标识符范围上下文中获得下一页。第二种方法是向消费者提供令牌，允许API跟踪他们在最后请求之后到达的位置以及下一页应该是什么样子。
- en: If you deal with the kind of large datasets that require paging to work efficiently,
    then you’ll probably get big returns from implementing caching and throttling.
    Caching will probably yield better results than throttling, so let’s discuss that
    first.
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你处理需要分页才能高效工作的那种大型数据集，那么实施缓存和节流可能会带来很大的回报。缓存可能比节流产生更好的结果，所以让我们先讨论一下缓存。
- en: Response Caching
  id: totrans-1532
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 响应缓存
- en: Typically it’s up to the end client to cache API results as deemed necessary.
    The API, however, can make suggestions with varying degrees of confidence on how
    its responses should be cached. What follows is a crash course on HTTP caching
    behaviors and the related HTTP headers.
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，缓存API结果的责任在于最终客户端根据需要决定。然而，API可以以不同程度的信心提出建议，说明其响应应该如何缓存。以下是对HTTP缓存行为和相关HTTP头部的快速入门课程。
- en: Setting the `Cache-Control` header to `private` bypasses intermediaries (such
    as proxies like `nginx`, other caching layers like Varnish, and all kinds of hardware
    in between) and only allows the end client to cache the response. Similarly, setting
    it to `public` allows intermediaries to store a copy of the response in their
    cache.
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Cache-Control`头设置为`private`可以绕过中间代理（例如像`nginx`这样的代理，其他像Varnish这样的缓存层，以及介于其间的各种硬件），并且只允许最终客户端缓存响应。同样，将其设置为`public`允许中间代理将其缓存中的响应副本存储起来。
- en: 'The `Expires` header tells the browser that a resource should be cached and
    not requested again until the expiration date has elapsed:'
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: '`Expires`头告诉浏览器一个资源应该被缓存，并且直到过期日期过去之前不再请求：'
- en: '[PRE251]'
  id: totrans-1536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: It’s hard to define future `Expires` headers in API responses because if the
    data in the server changes, it could mean that the client’s cache becomes stale,
    but it doesn’t have any way of knowing that until the expiration date. A conservative
    alternative to `Expires` headers in responses is using a pattern known as “conditional
    requests.”
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: 在API响应中定义未来的`Expires`头是困难的，因为如果服务器中的数据发生变化，这可能意味着客户端的缓存变得过时，但客户端直到过期日期之前都没有任何方式知道这一点。作为响应中`Expires`头的一个保守替代方案，可以使用一种称为“条件请求”的模式：
- en: 'Conditional requests can be time-based, specifying a `Last-Modified` header
    in your responses. It’s best to specify a `max-age` in the `Cache-Control` header,
    to let the browser invalidate the cache after a certain period of time even if
    the modification date doesn’t change:'
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: 条件请求可以是基于时间的，在您的响应中指定一个`Last-Modified`头。最好在`Cache-Control`头中指定一个`max-age`，以便在一段时间后即使修改日期没有变化，浏览器也会使缓存失效：
- en: '[PRE252]'
  id: totrans-1539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: 'The next time the browser requests this resource, it will only ask for the
    contents of the resource if they’re unchanged since this date, using the `If-Modified-Since`
    request header:'
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: 下次浏览器请求此资源时，它将仅在资源自该日期以来未更改的情况下请求资源内容，使用`If-Modified-Since`请求头：
- en: '[PRE253]'
  id: totrans-1541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: If the resource hasn’t changed since `Thu, 3 Jul 2014 18:31:12 GMT`, the server
    will return with an empty body with the `304 Not Modified` status code.
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
  zh: 如果资源自`Thu, 3 Jul 2014 18:31:12 GMT`以来没有变化，服务器将返回一个空体，并带有`304 Not Modified`状态码：
- en: 'An alternative to the `Last-Modified` negotiation is to use the `ETag` (also
    known as Entity Tag) header, which is usually a hash that represents the resource
    in its current state. This allows the server to identify if the cached contents
    of the resource are different than the most recent version:'
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`Last-Modified`协商的替代方案，可以使用`ETag`（也称为实体标签）头，它通常是一个表示资源当前状态的哈希值。这允许服务器确定缓存的资源内容是否与最新版本不同：
- en: '[PRE254]'
  id: totrans-1544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: 'On subsequent requests, the `If-None-Match` request header is sent with the
    `ETag` value of the last requested version for the same resource:'
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
  zh: 在随后的请求中，将发送带有相同资源最后请求版本的`ETag`值的`If-None-Match`请求头：
- en: '[PRE255]'
  id: totrans-1546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: If the current version has the same `ETag` value, your current version is what
    the client has cached and a `304 Not Modified` response will be returned. Once
    you have caching in place, request throttling could also mitigate server load.
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前版本具有相同的`ETag`值，则当前版本是客户端缓存的版本，并将返回一个`304 Not Modified`响应。一旦实施缓存，请求节流也可以减轻服务器负载。
- en: Request Throttling
  id: totrans-1548
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 请求节流
- en: '*Throttling*, also known as rate limiting, is a technique you can use to limit
    the number of requests a client can make to your API in a certain window of time.
    You have numerous criteria to rely on to rate limit consumers, but one of the
    most common ways to do so is to define a fixed rate limit and reset the quota
    after a certain period of time. You also have to decide how you’re going to enforce
    such limiting. Maybe the limit is enforced per IP address, and you could also
    have a more permissive limit for authenticated users.'
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: '*节流*，也称为速率限制，是一种可以用来限制客户端在一定时间窗口内对您的API发起请求数量的技术。您有多个标准可以用来限制消费者，但最常见的方法之一是定义一个固定的速率限制，并在一段时间后重置配额。您还必须决定如何执行这种限制。可能限制是按IP地址执行的，您还可以为认证用户提供更宽松的限制。'
- en: 'Suppose you define a rate limit of 2,000 requests per hour for unauthenticated
    users; the API should include the following headers in its responses, with every
    request shaving off a point from the remainder. The `X-RateLimit-Reset` header
    should contain a UNIX timestamp describing the moment when the limit will be reset:'
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您为未认证用户定义了每小时2,000个请求的限制；API应该在响应中包含以下头，每次请求都会从剩余额度中扣除一个点。`X-RateLimit-Reset`头应包含一个UNIX时间戳，描述限制将被重置的时刻：
- en: '[PRE256]'
  id: totrans-1551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: 'Once the request quota is drained, the API should return a `429 Too Many Requests`
    response, with a helpful error message wrapped in the usual error envelope:'
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦请求配额耗尽，API应该返回一个`429 Too Many Requests`响应，其中包含一个包含在常规错误封装中的有用错误消息：
- en: '[PRE257]'
  id: totrans-1553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: This kind of safeguarding is usually unnecessary when dealing with an internal
    API, or an API meant only for your front end, but it’s a crucial measure to take
    when exposing the API publicly. Together with paging and caching, these measures
    help relieve the strain on your back-end services.
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理内部API或仅面向前端使用的API时，这种保护通常是不必要的，但当公开API时，这是一个至关重要的措施。与分页和缓存一起，这些措施有助于减轻后端服务的压力。
- en: When something unexpected happens as the consumer is using your API, thorough
    documentation will be the last bastion of the highly usable services you design.
    The next section explains the essentials of properly documenting an API.
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: 当消费者在使用你的API时发生意外情况时，详尽的文档将是您设计的非常易用的服务的最后堡垒。下一节将解释正确记录API的基本要素。
- en: 9.2.4\. Documenting an API
  id: totrans-1556
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.4\. 记录API
- en: Any API worth using is well-documented, regardless of whether it’s public facing
    or not. When everything else fails, consumers refer to the API documentation.
    You can get away with auto-generating the API based on metadata sprinkled throughout
    your code base, often in the form of code comments, but you have to make sure
    the documentation stays up to date and relevant.
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
  zh: 任何值得使用的API都应该有良好的文档，无论它是面向公众的还是不是。当其他一切失败时，消费者会参考API文档。你可以根据代码库中散布的元数据自动生成API，通常以代码注释的形式出现，但你必须确保文档保持最新和相关性。
- en: Good API documentation should
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的API文档应该
- en: Explain how the response envelope looks.
  id: totrans-1559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释响应信封的外观。
- en: Demonstrate how error reporting works.
  id: totrans-1560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示错误报告是如何工作的。
- en: Show how authentication, paging, throttling, and caching work on a high level.
  id: totrans-1561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示身份验证、分页、节流和缓存在高级别是如何工作的。
- en: Detail every single endpoint, explain the HTTP verbs used to query those endpoints,
    and describe each piece of data that should be in the request and the fields that
    may appear in the response.
  id: totrans-1562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详细说明每个端点，解释用于查询这些端点的HTTP动词，并描述请求中应包含的每条数据以及可能出现在响应中的字段。
- en: Test cases can sometimes help as documentation by providing up-to-date working
    examples that also indicate best practices in accessing an API. Documentation
    enables API client developers to rapidly sift through any issues they may have
    because they didn’t fully understand the kind of data the API expected from them.
    Another desirable component in API documentation is a changelog that briefly details
    the changes that occur from one version to the next. Refer to [section 4.2.2](kindle_split_015.html#ch04lev2sec7)
    for more information about changelogs.
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例有时可以作为文档提供帮助，提供最新的工作示例，同时指示访问API的最佳实践。文档使API客户端开发者能够快速筛选他们可能遇到的任何问题，因为他们没有完全理解API期望他们提供的数据类型。API文档中另一个理想的组成部分是变更日志，它简要地详细说明从一个版本到下一个版本发生的变化。有关变更日志的更多信息，请参阅[第4.2.2节](kindle_split_015.html#ch04lev2sec7)。
- en: Documentation may be useful even when the API and the web application live together,
    because it helps reduce time spent researching what the API is supposed to expect
    or how it works. Instead of sifting through code, developers can read the documentation.
    When asked something about the API, you can direct them to the docs. In this regard,
    documentation doesn’t present benefits only when maintaining a REST API, but it
    makes sense for any kind of service, library, or framework. In the case of a library—take
    jQuery, for example—the documentation should cover each of the library’s public
    API methods, clearly detailing the possible arguments and response combinations.
    The docs may also explain the underlying implementation in those cases where it
    helps the consumer understand why the API is shaped the way it is. Well-executed
    API documentation examples include Twitter, Facebook, GitHub, and Stack-Exchange.^([[3](#ch09fn03)])
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
  zh: 即使API和Web应用程序在一起，文档也可能很有用，因为它有助于减少研究API预期或其工作方式所需的时间。开发者不必在代码中筛选，可以直接阅读文档。当被问及有关API的问题时，你可以引导他们查看文档。在这方面，文档不仅对维护REST
    API有益，而且对任何类型的服务、库或框架都很有意义。以库为例——以jQuery为例——文档应涵盖库的每个公共API方法，明确详细地说明可能的参数和响应组合。在那些有助于消费者理解API为何如此设计的案例中，文档也可能解释底层实现。执行良好的API文档示例包括Twitter、Facebook、GitHub和Stack-Exchange.^([[3](#ch09fn03)])
- en: ³ You can find these examples at [http://bevacqua.io/bf/api-twitter](http://bevacqua.io/bf/api-twitter),
    [http://bevacqua.io/bf/api-fb](http://bevacqua.io/bf/api-fb), [http://bevacqua.io/bf/api-github](http://bevacqua.io/bf/api-github),
    and [http://bevacqua.io/bf/api-stack](http://bevacqua.io/bf/api-stack), respectively.
  id: totrans-1565
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³ 你可以在[http://bevacqua.io/bf/api-twitter](http://bevacqua.io/bf/api-twitter)、[http://bevacqua.io/bf/api-fb](http://bevacqua.io/bf/api-fb)、[http://bevacqua.io/bf/api-github](http://bevacqua.io/bf/api-github)和[http://bevacqua.io/bf/api-stack](http://bevacqua.io/bf/api-stack)分别找到这些示例。
- en: Armed with the knowledge needed to design a REST API, in the next section you’ll
    explore the possibility of creating a series of layers for the API. These layers
    will define the API and help you keep your service modularly structured and testable.
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了设计REST API所需的知识后，在下一节中，你将探讨为API创建一系列层的可能性。这些层将定义API并帮助你保持服务模块化结构并易于测试。
- en: 9.3\. Implementing layered service architectures
  id: totrans-1567
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3. 实现分层服务架构
- en: If your API is small enough and dedicated to the front end, chances are that
    it’ll live in the same project. If that’s the case, then it makes sense that the
    API lives in the same layer as the web application’s controllers.
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的API足够小并且仅针对前端，那么它很可能会存在于同一个项目中。如果是这样，那么API与Web应用的控制器位于同一层是有意义的。
- en: A common approach is to have a so-called service layer that handles the core
    of the data processing task, while having a data layer that’s in charge of interacting
    with the database. Meanwhile, the API should be designed as a thin layer on top
    of the others. This architecture is pictured in [figure 9.1](#ch09fig01).
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的做法是拥有一个所谓的服务层来处理数据处理任务的核心，同时拥有一个数据层来负责与数据库的交互。同时，API应该设计为其他层之上的一个薄层。这种架构在[图9.1](#ch09fig01)中有所展示。
- en: Figure 9.1\. Overview of a three-tiered service architecture
  id: totrans-1570
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.1. 三层服务架构概述
- en: '![](09fig01_alt.jpg)'
  id: totrans-1571
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig01_alt.jpg)'
- en: Looking at the figure from the top down, you can see the basic parts of each
    API layer.
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
  zh: 从上往下看这个图，你可以看到每个API层的组成部分。
- en: 9.3.1\. Routing layer
  id: totrans-1573
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.1. 路由层
- en: 'The API layer is in charge of dealing with throttling, paging, caching headers,
    parsing request bodies, and preparing responses. All of that, however, should
    be accomplished by using the service layer as the only way to access or modify
    the data, for the following reasons:'
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
  zh: API层负责处理节流、分页、缓存头、解析请求体和准备响应。然而，所有这些都应该通过使用服务层作为访问或修改数据的唯一方式来完成，以下是一些原因：
- en: Controllers must validate request data before producing a response.
  id: totrans-1575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器在生成响应之前必须验证请求数据。
- en: The API asks the service for the different pieces of data it needs to properly
    fulfill the response.
  id: totrans-1576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API会向服务请求它需要的数据，以便正确地完成响应。
- en: When the service jobs are complete, the API controller responds with a proper
    status code and relevant response data.
  id: totrans-1577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当服务任务完成时，API控制器会以适当的状态码和相关的响应数据做出响应。
- en: 9.3.2\. Service layer
  id: totrans-1578
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.2. 服务层
- en: 'The service layer can be architected to defer all data access to a third layer:
    the data layer. This layer is in charge of dealing with computation for any missing
    data that can’t be directly extracted from the data stores:'
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
  zh: 服务层可以被设计为将所有数据访问推迟到第三层：数据层。这一层负责处理无法直接从数据存储中提取的任何缺失数据的计算：
- en: The service layer is composed of many small services. Each of them handles a
    subset of the business.
  id: totrans-1580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务层由许多小型服务组成。每个服务都处理业务的一部分。
- en: The service layer queries the data layer, computes business logic rules, and
    validates request data on a model level.
  id: totrans-1581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务层查询数据层，计算业务逻辑规则，并在模型级别验证请求数据。
- en: CRUD operations typically end up being a pass-through to the data layer.
  id: totrans-1582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CRUD操作通常最终会传递到数据层。
- en: Tasks such as sending out emails, where no persistence access is involved, may
    be handled entirely by a component of the service layer without resorting to a
    data store.
  id: totrans-1583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像发送电子邮件这样的任务，其中不涉及持久性访问，可能完全由服务层的一个组件处理，而不需要求助于数据存储。
- en: 9.3.3\. Data layer
  id: totrans-1584
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.3. 数据层
- en: 'The data layer is in charge of communicating with the persistence medium such
    as a database, flat file, memory, and so on. Its purpose is to provide access
    to any of those mediums through a consistent interface. The goal of having such
    an interface in place is that you can easily swap persistence layers (database
    engines, or in-memory key-value stores, for example), also making it easier to
    test:'
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
  zh: 数据层负责与持久化介质（如数据库、平面文件、内存等）通信。其目的是通过一个一致的接口提供对这些介质的访问。设置此类接口的目标是你可以轻松地交换持久化层（例如数据库引擎或内存中的键值存储），这也使得测试变得更加容易：
- en: The data access layer provides an interface to the data in the underlying data
    store. This makes it easier to interact with different data sources and change
    vendors.
  id: totrans-1586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据访问层为底层数据存储中的数据提供了一个接口。这使得与不同的数据源交互和更换供应商变得更加容易。
- en: Models stay the same independently of the underlying data store; they’re part
    of the interface.
  id: totrans-1587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型与底层数据存储无关，它们是接口的一部分。
- en: The underlying data models are kept away from the interface. This makes swapping
    out data stores easier, because data layer consumers won’t be affected.
  id: totrans-1588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 底层数据模型与接口保持分离。这使得更换数据存储变得更加容易，因为数据层消费者不会受到影响。
- en: That was a frantic overview! Let’s slow down and pace ourselves through this
    three-tiered architecture in greater detail. Note that this type of architecture
    isn’t limited to API design but could also fit typical web applications and possibly
    other types of applications too, if they deserve the extra infrastructure.
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个匆忙的概述！让我们放慢速度，更详细地逐步分析这个三层架构。请注意，这种类型的架构不仅限于API设计，也可能适用于典型的Web应用程序，甚至可能适用于其他类型的应用程序，如果它们值得额外的基础设施。
- en: 9.3.4\. Routing layer
  id: totrans-1590
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.4\. 路由层
- en: Controllers are the public-facing layer in this type of architecture. At this
    layer you’ll define the routes your application can be accessed from. The routing
    layer is also in charge of parsing any parameters found in the requested URL and
    in the request body.
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器是这种架构中的公共接口层。在这一层，你将定义应用程序可以被访问的路径。路由层还负责解析请求URL和请求体中找到的任何参数。
- en: Before even trying to fulfill the request, you may have to validate that the
    client didn’t exceed their allowed quota, and if that were the case, you can kill
    the request right then, passing the appropriate response and status code of `429
    Too Many Requests.`
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试满足请求之前，你可能需要验证客户端是否超出了他们允许的配额，如果是这样，你可以在那时终止请求，传递适当的响应和状态码`429 Too Many Requests`。
- en: As we all know, user input can’t be trusted, and this is where you’re meant
    to validate and sanitize user input most aggressively. Once the request is parsed,
    make sure that the request provided exactly what’s needed to fulfill the request,
    nothing less and also nothing more. Once you’ve made sure all of the required
    fields are provided, you should sanitize them and make sure that the inputs are
    valid. For example, if the provided email address isn’t a valid email, your API
    should know to respond with a `400 Bad Request` and an appropriately formatted
    response body.
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，用户输入是不可信的，这就是你需要在最严格的意义上验证和清理用户输入的地方。一旦请求被解析，确保请求提供了满足请求所需的所有信息，不多也不少。一旦你确认所有必需的字段都已提供，你应该清理它们并确保输入有效。例如，如果提供的电子邮件地址不是一个有效的电子邮件，你的API应该知道响应一个`400
    Bad Request`和一个格式适当的响应体。
- en: Once the request is parsed and its inputs validated, you’re ready to hand it
    to the service layer, which will trade the inputs provided by the request into
    the outputs it requires. (Bear with me for a minute; we’ll go deeper into the
    service layer.) Once the service layer gets back to you, you can finally figure
    out if the request can be fulfilled or not and respond with the corresponding
    status code and response data. What exactly is the service layer supposed to do,
    then? Glad you asked!
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦请求被解析并且其输入得到验证，你就可以将其交给服务层，服务层会将请求提供的输入转换为所需的输出。（请稍等，我们将会更深入地探讨服务层。）一旦服务层回复你，你就可以最终确定请求是否能够得到满足，并使用相应的状态码和响应数据做出回应。那么，服务层究竟应该做什么呢？很高兴你提出了这个问题！
- en: 9.3.5\. Service layer
  id: totrans-1595
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.5\. 服务层
- en: At the service level, also known as the business logic layer, the request is
    processed, data is pulled from the data layer, and a representation of that data
    is returned. At this point it makes sense to validate business rules, whereas
    it wasn’t a responsibility of the routing layer.
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务层，也称为业务逻辑层，请求被处理，数据从数据层获取，并返回该数据的表现形式。此时验证业务规则是有意义的，而这不是路由层的责任。
- en: For instance, if a user tries to create a new product with a price of `very
    expensive` or `-1`, it’s up to the routing layer to figure out that’s not a valid
    money input. If the selected product category expects products in the `$20 - $150`
    range and the product is priced `$200`, then it’s up to the service layer to figure
    out that the request can’t be fulfilled.
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果用户尝试创建一个价格为“非常昂贵”或“-1”的新产品，那么确定这不是有效的货币输入的责任就落在路由层。如果选定的产品类别期望产品价格在“$20
    - $150”范围内，而产品定价为“$200”，那么确定该请求无法满足的责任就落在服务层。
- en: The service layer is also responsible for doing any necessary data aggregation.
    Although it’s likely that the routing layer will only have to make a single call
    into the service layer to get what it needs, the same isn’t true for the interaction
    between the service and data layers. As an example, the service layer may need
    to get a list of articles on a news site and hand that over to a service that
    performs a processing task on the contents of those articles, finding commonalities
    and eventually returning a list of articles related to each other.
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
  zh: 服务层也负责执行任何必要的数据聚合。尽管路由层可能只需要对服务层进行一次调用就能获取所需的数据，但服务层与数据层之间的交互并非如此。例如，服务层可能需要获取新闻网站上文章的列表，并将其交给一个对文章内容进行加工处理的服务，找出相似之处，并最终返回相关文章的列表。
- en: In this regard, the service layer is the event organizer in the architecture,
    in that it will query and command other layers to provide it with the means to
    produce a meaningful response. Let’s quickly comb through the specifics of how
    the data layer should be shaped.
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: 在这方面，服务层是架构中的事件组织者，因为它将查询和命令其他层，以提供产生有意义响应的手段。让我们快速了解一下数据层应该如何构建的具体细节。
- en: 9.3.6\. Data layer
  id: totrans-1600
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.6\. 数据层
- en: The data layer is the only layer that’s meant to access a persistence component,
    which would be your database. The goal of the data layer is to ensure a consistent
    API is provided, regardless of the underlying data store being used. If you’re
    persisting data in MongoDB, MySQL, or Redis, the API offered by the data layer
    will hide that detail from the service layer by providing a consistent API that
    isn’t tied to any particular persistence model.
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
  zh: 数据层是唯一一个旨在访问持久化组件（即您的数据库）的层。数据层的目标是确保提供一致的API，无论使用的是哪种底层数据存储。如果您在MongoDB、MySQL或Redis中持久化数据，数据层提供的API将通过提供不依赖于任何特定持久化模型的统一API来隐藏这些细节。
- en: '[Figure 9.2](#ch09fig02) shows the potential data stores that could be behind
    the data layer’s interface. Note that this interface doesn’t necessarily hide
    a single type of backing data store: you could be using both Redis and MySQL,
    for instance.'
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.2](#ch09fig02)显示了可能位于数据层接口后面的潜在数据存储。请注意，这个接口不一定隐藏单一类型的数据存储：例如，您可能同时使用Redis和MySQL。'
- en: Figure 9.2\. The data layer interface and a few underlying data stores
  id: totrans-1603
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.2\. 数据层接口和几个底层数据存储
- en: '![](09fig02_alt.jpg)'
  id: totrans-1604
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig02_alt.jpg)'
- en: The data layer is typically thin, bridging the gap between the service and persistence
    layers. Results produced by the data layer are also expected to be consistent,
    because changing the underlying persistence model truly won’t make a difference.
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
  zh: 数据层通常是较薄的，在服务和持久化层之间架起桥梁。数据层产生的结果也预期是一致的，因为改变底层持久化模型实际上不会产生影响。
- en: Although not recommended, in small projects it’s plausible to merge the service
    layer and the data layer if there won’t be any significant changes in the persistence
    model of the application. Keep in mind that splitting the two is easy at first,
    but doing so once you have dozens of services that consume dozens of different
    data models becomes increasingly complex and nontrivial. That’s why, if possible,
    it’s recommended to split these two layers from the get-go.
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不推荐，但在小型项目中，如果应用程序的持久化模型没有重大变化，合并服务层和数据层是可行的。请记住，一开始分割这两个层是容易的，但一旦有数十个服务消费数十种不同的数据模型，这样做会变得越来越复杂和非平凡。这就是为什么，如果可能的话，建议从一开始就分割这两个层。
- en: The last topic we’ll go over in this chapter is how services like these should
    be consumed on the client side.
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论的最后一个主题是如何在客户端消费这类服务。
- en: 9.4\. Consuming a REST API on the client side
  id: totrans-1608
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4. 消费客户端的REST API
- en: 'When intensively interacting with a REST API layer on the client side of a
    web application, it’s often prudent to come up with a thin layer to act as an
    intermediary between the API and the core of your application. This layer relies
    on creating a shared infrastructure to emit requests against the API in exchange
    for the following list of benefits enumerated:'
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Web应用程序的客户端与REST API层进行密集交互时，通常明智的做法是创建一个薄层作为API和应用程序核心之间的中介。这个层依赖于创建共享基础设施来向API发出请求，以换取以下列出的好处：
- en: A high-level overview of the requests taking place in your application
  id: totrans-1610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对应用程序中发生的请求的高级概述
- en: Allows you to perform caching and avoid extra requests
  id: totrans-1611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许你执行缓存并避免额外的请求
- en: Manage errors in a single place in your application, providing a consistent
    UI experience
  id: totrans-1612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序的一个地方管理错误，提供一致的UI体验
- en: Ability to shoot down pending requests when navigating away in a single-page
    application
  id: totrans-1613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单页应用程序中导航时能够取消挂起的请求
- en: I’ll start by describing what creating such a layer would entail, and then we’ll
    move on to the specifics.
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先描述创建这样一个层将涉及什么，然后我们将继续讨论具体细节。
- en: 9.4.1\. The request handling layer
  id: totrans-1615
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.4.1. 请求处理层
- en: Putting together such a layer can be tackled in two ways. You can patch the
    XHR implementation in browsers, guaranteeing that any AJAX requests made by your
    application will have to go through the proxy you patched into XHR, or you can
    create a wrapper around XHR and use it every time an AJAX request takes place.
    The latter approach is typically regarded as being “cleaner,” because it doesn’t
    affect the native behavior provided by the browser the way the monkey-patching
    approach does, which sometimes leads to unexpected behavior. This is often reason
    enough to prefer creating a simple wrapper around XHR calls and using that instead
    of the native APIs.
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
  zh: 组建这样的层可以通过两种方式完成。你可以修补浏览器中的XHR实现，确保你的应用程序发出的任何AJAX请求都必须通过修补到XHR中的代理进行，或者你可以围绕XHR创建一个包装器并在每次AJAX请求发生时使用它。后者通常被认为更“干净”，因为它不会像猴子补丁方法那样影响浏览器提供的原生行为，这有时会导致意外行为。这通常是优先创建围绕XHR调用的简单包装器并使用该包装器而不是原生API的足够理由。
- en: I’ve created a library called `measly` exactly with this purpose in mind. It
    takes the less invasive wrapper approach, because that way it won’t affect code
    that’s unaware of how Measly behaves, and it allows you to easily associate requests
    with different parts of the DOM. It also allows for caching and event handling,
    both of which can be limited to the context of a particular DOM element or global.
    I’ll walk you through several key features in `measly.` To get started, you’ll
    have to install it from npm. It’s also available on Bower under the same name.
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了一个名为`measly`的库，正是出于这个目的。它采用较少侵入性的包装器方法，因为这样它就不会影响不了解Measly行为的代码，并且允许你轻松地将请求与DOM的不同部分关联起来。它还允许进行缓存和事件处理，这两者都可以限制在特定DOM元素或全局的上下文中。我将向您介绍`measly`的几个关键特性。要开始，您需要从npm安装它。它也在Bower上以相同名称提供。
- en: '[PRE258]'
  id: totrans-1618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: After you install `measly,` you’ll be ready to get into the next section, where
    we’ll explore how to use it to make sure requests don’t end up causing unintended
    side effects.
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`measly`后，你将准备好进入下一节，我们将探讨如何使用它来确保请求不会导致意外的副作用。
- en: 9.4.2\. Shooting down old requests
  id: totrans-1620
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.4.2. 取消旧请求
- en: Single-page web applications are all the rage these days. In traditional web
    applications, the user agent aborts all pending requests when navigating away
    to another page, but what about single-page applications (SPA)? If you’re developing
    an SPA, chances are that you hope stray requests won’t corrupt the state of your
    application when a human navigates to another page.
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
  zh: 单页Web应用程序如今非常流行。在传统的Web应用程序中，当用户代理导航到另一个页面时，会取消所有挂起的请求，但单页应用程序（SPA）又是如何呢？如果你正在开发SPA，那么你很可能希望当用户导航到另一个页面时，散乱的请求不会破坏应用程序的状态。
- en: 'The following code is a generic example assuming a client-side MVC framework
    that broadcasts events when entering and leaving views. In this example you’re
    creating a `measly` layer on the view container element and aborting all requests
    on that layer when leaving the view:'
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个通用的示例，假设客户端MVC框架在进入和离开视图时广播事件。在这个例子中，你正在在视图容器元素上创建一个`measly`层级，并在离开视图时取消该层级的所有请求：
- en: '[PRE259]'
  id: totrans-1623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: 'Whenever you need to make an AJAX call, you’ll have to look up the layer first.
    You can keep a reference around for convenience, as well. Using the `measly` layer
    to create requests is fairly straightforward. In this case you’re making a request
    for `DELETE/api/products/:id`, deleting a product by ID using a REST API:'
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你需要发起AJAX调用时，你首先需要查找层级。你也可以保留一个引用以方便使用。使用`measly`层级创建请求相当直接。在这种情况下，你正在发起一个对`DELETE/api/products/:id`的请求，通过REST
    API按ID删除产品：
- en: '[PRE260]'
  id: totrans-1625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: 'Whenever you make a request, `measly` emits a series of events, letting you
    react to them. For example, if you want to know when a request succeeds you can
    use the `data` event, and if you want to listen for errors you can subscribe to
    the `error` event. You have two different places where you can listen for errors:'
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你发起一个请求时，`measly`会发出一系列事件，让你可以对其做出反应。例如，如果你想知道请求何时成功，你可以使用`data`事件，如果你想监听错误，你可以订阅`error`事件。你有两个不同的地方可以监听错误：
- en: At the request level directly, where you’re notified only if a particular request
    results in an error.
  id: totrans-1627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在请求级别直接，你只有在特定请求导致错误时才会收到通知。
- en: At a layer level, where you can learn about any requests that result in an error.
  id: totrans-1628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在层级层面，你可以了解任何导致错误的请求。
- en: Each of these methods has obvious use cases. You definitely want to know when
    a request succeeds so you can do something specific armed with the response data.
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法都有明显的用例。你肯定想知道请求何时成功，这样你就可以利用响应数据做些具体的事情。
- en: You may also need to learn about any errors that originate in your application
    on a global scale, so you can display the corresponding UI elements to notify
    the human about those errors or to send reports to a logging service.
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还需要了解任何在全局范围内起源于你应用程序的错误，这样你就可以显示相应的UI元素来通知人类这些错误，或者将报告发送到日志服务。
- en: 9.4.3\. Consistent AJAX error management
  id: totrans-1631
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.4.3\. 一致的AJAX错误管理
- en: The following listing explains how you can show a UI dialog whenever an AJAX
    error occurs, but only if the status code in the response equals 500, meaning
    there was an internal server error. You’ll fill the dialog with the error message
    provided by the response, and after a short timeout, you’ll hide it again.
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表解释了如何在AJAX错误发生时显示UI对话框，但只有当响应中的状态码等于500时，这意味着发生了内部服务器错误。你将在对话框中填写响应提供的错误消息，然后经过短暂的超时后再次隐藏它。
- en: Listing 9.2\. Showing a UI dialog box when an AJAX error occurs
  id: totrans-1633
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.2\. 当AJAX错误发生时显示UI对话框
- en: '![](269fig01_alt.jpg)'
  id: totrans-1634
  prefs: []
  type: TYPE_IMG
  zh: '![](269fig01_alt.jpg)'
- en: 'To be frank, this is a terribly uninteresting approach, and not something you
    couldn’t accomplish. A more useful scenario would be in-context validation. In
    this case, watch out for `400 Bad Request` responses, which is the status code
    that should be assigned by the API to a validation failure response. Measly will
    set `this` in the event handler as the request object, allowing you to access
    important properties of the request, such as its DOM context element. The following
    code intercepts any `400 Bad Request` response and turns it into a validation
    message in the context of a piece of DOM. If you’re binding Measly close enough
    to the visual context of the requests you create, humans won’t have any trouble
    finding your list of validation messages:'
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
  zh: 坦白说，这是一个非常无趣的方法，而且不是你不能完成的事情。更有用的场景是在上下文中进行验证。在这种情况下，请注意`400 Bad Request`响应，这是API应该分配给验证失败响应的状态码。Measly将在事件处理程序中将`this`设置为请求对象，允许你访问请求的重要属性，例如其DOM上下文元素。以下代码拦截任何`400
    Bad Request`响应，并将其转换为DOM上下文中的验证消息。如果你将Measly与创建的请求的视觉上下文绑定得足够紧密，人类将不会在查找你的验证消息列表时遇到任何麻烦：
- en: '[PRE261]'
  id: totrans-1636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: The best part is that you get this almost for free! Because you’re already using
    the context to make sure requests are aborted whenever you switch views, you may
    only have to declare a few child layers where it makes sense to do so, such as
    partial views or HTML forms. The last point I’d like to bring up is caching rules
    in Measly.
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的部分是，你几乎可以免费获得这个功能！因为你在使用上下文确保在切换视图时请求被终止，你可能只需要声明几个子层，这样做是有意义的，例如部分视图或 HTML
    表单。我想提出的最后一个点是 Measly 中的缓存规则。
- en: Measly caching rules
  id: totrans-1638
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Measly 缓存规则
- en: Measly lets you cache two ways. First, it allows you to define an amount of
    time a response is considered fresh, meaning that subsequent requests for the
    same resource will result in the cached response for as long as the cached copy
    is fresh. The following listing shows how you can request to cache the response
    for 60 seconds, and then when a button is clicked Measly either uses the cached
    copy (if within 60 seconds since the last request) or makes a new request if the
    data has been updated.
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
  zh: Measly 允许你以两种方式缓存。首先，它允许你定义一个响应被认为是新鲜的时间量，这意味着对同一资源的后续请求将导致缓存响应，只要缓存副本仍然新鲜。以下列表显示了如何请求缓存响应
    60 秒，然后当按钮被点击时，Measly 要么使用缓存副本（如果自上次请求以来在 60 秒内），要么如果数据已更新，则发起新的请求。
- en: Listing 9.3\. Caching files with Measly
  id: totrans-1640
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.3\. 使用 Measly 缓存文件
- en: '[PRE262]'
  id: totrans-1641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: The other way you can avoid querying the server with an unwarranted HTTP request
    is to prevent it manually. The following listing is an example where a list of
    products is cached by hand.
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过手动阻止不合理的 HTTP 请求来避免对服务器进行查询。以下列表是一个示例，其中产品列表是通过手动缓存的。
- en: Listing 9.4\. Manually preventing unwarranted HTTP requests
  id: totrans-1643
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.4\. 手动阻止不合理的 HTTP 请求
- en: '[PRE263]'
  id: totrans-1644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: You’ll find a quick demo into how Measly works in the accompanying code samples
    for this chapter, listed as ch09/01_a-measly-client-side-layer. In the demo I
    show how to create different contexts to contain different requests to a portion
    of the DOM.
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本章的配套代码示例中找到一个关于 Measly 如何工作的快速演示，该示例列在 ch09/01_a-measly-client-side-layer
    中。在演示中，我展示了如何创建不同的上下文来包含对 DOM 部分的不同请求。
- en: All in all, `measly` may not be the answer you’re looking for, but along with
    the rest of this book I hope it gave you something to think about!
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，`measly` 可能不是你想要的答案，但结合这本书的其余部分，我希望它给你带来了一些思考！
- en: 9.5\. Summary
  id: totrans-1647
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5\. 摘要
- en: 'That wasn’t that hard, was it? We covered a lot of ground, and looked at many
    best practices along the way:'
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不难，对吧？我们覆盖了大量的内容，并在过程中探讨了众多最佳实践：
- en: Responsible API design follows the REST constraint model by providing conventional
    endpoints, sanitizing inputs, and also providing consistent outputs.
  id: totrans-1649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负责任的 API 设计遵循 REST 约束模型，通过提供常规端点、清理输入并提供一致的输出。
- en: Paging, throttling, and caching in a REST API are all necessary to provide a
    fast and safe API service.
  id: totrans-1650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 REST API 中，分页、节流和缓存都是提供快速和安全 API 服务所必需的。
- en: Documentation should be taken seriously to lower the friction introduced by
    your API.
  id: totrans-1651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该认真对待文档，以降低 API 引入的摩擦。
- en: You should develop a thin API layer backed by a domain logic layer and a data
    layer.
  id: totrans-1652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该开发一个由领域逻辑层和数据层支持的薄 API 层。
- en: A thin client-side layer helps you assign a context to AJAX requests, validate
    responses, and render HTTP errors on the user interface.
  id: totrans-1653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个薄客户端层可以帮助你为 AJAX 请求分配上下文、验证响应，并在用户界面上渲染 HTTP 错误。
