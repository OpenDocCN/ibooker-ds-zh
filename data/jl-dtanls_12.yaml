- en: 10 Creating data frame objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 创建数据框对象
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Creating data frames
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数据框
- en: Using RCall.jl to integrate with the R language
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RCall.jl与R语言集成
- en: Understanding the Tables.jl interface
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Tables.jl接口
- en: Plotting a correlation matrix
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制相关矩阵图
- en: Constructing a data frame iteratively by adding rows to it
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过向其中添加行来迭代构建数据框
- en: Serializing Julia objects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化Julia对象
- en: In chapter 8, I introduced you to working with data frames, using sample data
    loaded from a CSV file. In this chapter, I’ll show you more ways to convert values
    of different types to and from a DataFrame object. You need to have this fundamental
    knowledge so you can use the DataFrames.jl package efficiently. You must be prepared
    for source data to come in various formats, and you need to know how to convert
    that data to a DataFrame.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8章中，我向您介绍了如何使用从CSV文件加载的样本数据来处理数据框。在本章中，我将向您展示更多将不同类型的数据值转换为DataFrame对象以及从DataFrame对象转换回来的方法。您需要具备这些基本知识，以便能够高效地使用DataFrames.jl包。您必须准备好源数据可能以各种格式出现，并且您需要知道如何将这些数据转换为DataFrame。
- en: Since the topic of creating DataFrame objects is broad, in this chapter, I use
    several small tasks as examples of applying the concepts you learn. Following
    one complex example (as we did with the Lichess puzzle data in chapters 8 and
    9) would not allow me to show all the options that are useful in practice. To
    ensure that this chapter, apart from teaching you how to create data frames, also
    gives you useful recipes for data analysis, we will create a plot of a correlation
    matrix of data stored in a data frame.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于创建DataFrame对象的话题范围很广，在本章中，我通过几个小型任务作为应用您所学概念的示例。跟随一个复杂的例子（就像我们在第8章和第9章中处理Lichess谜题数据那样）将无法展示实践中所有有用的选项。为了确保本章除了教您如何创建数据框之外，还能为您提供有用的数据分析食谱，我们将创建一个存储在数据框中的数据的相关矩阵图。
- en: 'I divided the chapter into two sections to help you easily navigate the available
    options and concentrate on the scenarios that are most relevant in your day-to-day
    work:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我将本章分为两个部分，以帮助您轻松导航可用的选项，并专注于您日常工作中最相关的场景：
- en: In section 10.1, you’ll learn various ways to create a data frame from an object
    of a different type holding the source data. You will need to do such operations
    if you already have data that you want to store in a data frame.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第10.1节中，您将学习从不同类型的数据对象创建数据框的各种方法。如果您已经拥有想要存储在数据框中的数据，您将需要执行此类操作。
- en: In section 10.2, you’ll learn to create a data frame iteratively by adding new
    rows to it as new data becomes available. You will use this approach to create
    data frame objects if the data you want to store in a data frame is generated
    when your program is running (for example, if you collect results of a simulation
    experiment).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第10.2节中，您将学习通过向其中添加新行来迭代地创建数据框。如果您想要存储在数据框中的数据是在程序运行时生成的（例如，如果您收集模拟实验的结果），您将使用这种方法来创建数据框对象。
- en: In section 10.1.2, we will use the RCall.jl package that provides integration
    between Julia and R. Running the examples in that section requires having a properly
    configured R installation on your computer. Therefore, make sure to follow the
    environment setup instructions in appendix A.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在第10.1.2节中，我们将使用RCall.jl包，该包提供了Julia与R之间的集成。在该节中运行示例需要您计算机上有一个正确配置的R安装。因此，请确保遵循附录A中的环境设置说明。
- en: 10.1 Reviewing the most important ways to create a data frame
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 回顾创建数据框的最重要方法
- en: In this section, you’ll learn the three most common ways to create a data frame
    from source data that has a different type than DataFrame. This is an essential
    skill you need to master because your source might have various formats. However,
    to use the functionalities that the DataFrames.jl package offers, you first need
    to create an object that has the DataFrame type.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习从与DataFrame类型不同的源数据创建数据框的三个最常见方法。这是您需要掌握的基本技能，因为您的源数据可能有各种格式。然而，为了使用DataFrames.jl包提供的功能，您首先需要创建一个具有DataFrame类型的对象。
- en: 'In this section, I illustrate the most common scenarios by using the Anscombe’s
    quartet data that we worked with in chapter 4\. In these scenarios, we create
    a data frame via the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我通过使用我们在第4章中处理过的Anscombe的四重奏数据来展示最常见的场景。在这些场景中，我们通过以下方式创建数据框：
- en: A matrix
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵
- en: A collection of vectors
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量集合
- en: The Tables.jl interface
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: The Tables.jl interface
- en: 'In addition, you will learn how to use RCall.jl to integrate Julia with the
    R language and how to create a plot of a correlation matrix of data stored in
    a data frame. Before we can start creating data frame objects, we first need to
    re-create the aq matrix with the Anscombe’s quartet data that we used in chapter
    4:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还将学习如何使用RCall.jl将Julia与R语言集成以及如何创建存储在数据框中的数据的相关矩阵的绘图。在我们开始创建数据框对象之前，我们首先需要重新创建第4章中使用的Anscombe的四重奏数据：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'First, make sure to load the DataFrames.jl package:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保加载DataFrames.jl包：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 10.1.1 Creating a data frame from a matrix
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.1 从矩阵创建数据框
- en: In this section, you will learn how to create a data frame from a matrix since
    matrices are commonly used to store data that you might want to analyze.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何从矩阵创建数据框，因为矩阵是存储你可能想要分析的数据的常见格式。
- en: One of the differences between a Matrix and a DataFrame in Julia is that a Matrix
    does not support column names. Therefore, when we pass a Matrix to a DataFrame
    constructor, we need to provide column names. These names can be given as either
    a vector of strings or a vector of symbols. I show both options in the following
    listing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Julia中Matrix和DataFrame之间的一个区别是Matrix不支持列名。因此，当我们向DataFrame构造函数传递Matrix时，我们需要提供列名。这些名称可以是字符串向量或符号向量。我在下面的列表中展示了这两种选项。
- en: Listing 10.1 Creating the aq1 data frame
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.1 创建aq1数据框
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Uses a vector of strings as column names
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用字符串向量作为列名
- en: ❷ Uses a vector of symbols as column names
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用符号向量作为列名
- en: 'When we convert a Matrix to a DataFrame, columns of the Matrix become columns
    in a DataFrame. For convenience, you can ask the DataFrame constructor to create
    column names automatically by passing the :auto argument instead of a vector of
    column names:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将Matrix转换为DataFrame时，Matrix的列成为DataFrame的列。为了方便，你可以通过传递：auto参数而不是列名向量来请求DataFrame构造函数自动创建列名：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When we use the :auto option, the generated column names consist of an x character
    followed by the column number.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用：auto选项时，生成的列名由一个x字符后跟列号组成。
- en: 'Similarly to a Matrix argument, the DataFrame constructor accepts a Vector
    of vectors as a first argument and column names as a second argument. Let’s first
    create a Vector of vectors from our aq matrix (recall that we discussed the collect
    and eachcol functions in chapter 4):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于Matrix参数，DataFrame构造函数接受一个向量作为第一个参数，列名作为第二个参数。让我们首先从我们的aq矩阵创建一个向量向量（回想一下我们在第4章讨论了collect和eachcol函数）：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The way to create a DataFrame from the aq_vec object is to either pass the column
    names as the second argument
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从aq_vec对象创建DataFrame的方法是传递列名作为第二个参数
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'or pass the :auto keyword argument:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 或者传递：auto关键字参数：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 10.1.2 Creating a data frame from vectors
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.2 从向量创建数据框
- en: 'You will often want to convert objects that store columns as vectors to a DataFrame.
    Vectors, like the matrices discussed in section 10.1.1, are a common format in
    which your source data might originally be stored. For example, in listing 4.2,
    we used the following NamedTuple to store the Anscombe’s quartet data:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常会想要将存储列作为向量的对象转换为DataFrame。与第10.1.1节中讨论的矩阵一样，向量是源数据可能最初存储的常见格式。例如，在列表4.2中，我们使用了以下命名元组来存储Anscombe的四重奏数据：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the data NamedTuple, we have stored the columns of our data frame as vectors.
    For example, recall from chapter 4 that you can retrieve the x column from the
    set1 data set as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名元组数据中，我们将数据框的列存储为向量。例如，回想一下第4章中你可以如下检索set1数据集中的x列：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Constructor using keyword arguments
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用关键字参数的构造函数
- en: 'We can pass vectors to a DataFrame constructor in two ways. The first is to
    use the keyword arguments:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两种方式将向量传递给DataFrame构造函数。第一种是使用关键字参数：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Using this style, we pass a column name followed by a vector that we want to
    store in this column. Note that we take advantage of the fact that keyword arguments
    in Julia do not require any additional decorators (like a : prefix in the case
    of Symbol); see the discussion of keyword arguments in section 2.4.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种风格，我们传递一个列名后跟一个我们想要存储在这个列中的向量。请注意，我们利用了Julia中的关键字参数不需要任何额外的装饰器（例如，在Symbol的情况下使用：前缀）的事实；请参阅第2.4节中关于关键字参数的讨论。
- en: In this example, we have unnested the data object that held four data sets into
    eight columns. In section 10.1.3, you will see another way to convert the data
    object to a data frame that relies on the Tables.jl interface.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将包含四个数据集的数据对象展开到八个列中。在第 10.1.3 节中，您将看到另一种将数据对象转换为数据框的方法，它依赖于 Tables.jl
    接口。
- en: Constructor using pairs
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对构造函数
- en: 'Another way you can create the same data frame is by using positional arguments
    with the Pair notation column_name => column_data:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 创建相同数据框的另一种方法是使用位置参数和 Pair 表示法列名 => 列数据：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Again, instead of symbols, we could have used strings, which can be handy when
    you want your columns to contain nonstandard characters like spaces.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们本可以使用字符串而不是符号，这在您希望列包含非标准字符（如空格）时非常有用。
- en: 'An additional feature of the notation using Pair is that instead of passing
    multiple positional arguments, we can pass a vector of these pairs to get the
    same result (I omit printing it to save space since the output is the same as
    in the preceding example):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Pair 表示法的附加功能是，我们不必传递多个位置参数，而可以传递这些对的向量以获得相同的结果（我省略了打印以节省空间，因为输出与前面的示例相同）：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'What is the benefit of such an approach? It is useful because it is then easy
    to traverse the data NamedTuple with a comprehension. Let’s do this step by step.
    First, create a vector iterating data set numbers (from 1 to 4) and columns (:x
    and :y):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的好处是什么？它很有用，因为这样就可以轻松地使用推导式遍历数据 NamedTuple。让我们一步一步来做。首先，创建一个迭代数据集编号（从 1
    到 4）和列（:x 和 :y）的向量：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note that in this comprehension, we use a double for loop, which produces a
    vector of tuples. Next, we can convert these values to column names by using the
    string function that concatenates its passed arguments into a string:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个推导式中，我们使用了一个双重循环，它产生了一个元组向量。接下来，我们可以使用将传递的参数连接成字符串的字符串函数将这些值转换为列名：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We are almost done. Next, using a comprehension, create a vector with pairs
    mapping each column name to a column value from the data object:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了。接下来，使用推导式，创建一个向量，将每个列名映射到数据对象中的列值：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this code, you see the call to the getproperty function. You can use this
    function to get a property of a NamedTuple using a variable. Therefore, writing
    data.set1 is equivalent to writing getproperty(data, :set1).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，您可以看到对 getproperty 函数的调用。您可以使用此函数通过变量获取 NamedTuple 的属性。因此，编写 data.set1
    等同于编写 getproperty(data, :set1)。
- en: 'Now that we have a vector of pairs of column names and column values, we can
    pass it to the DataFrame constructor (I omit the output again as it is identical
    to the earlier cases):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个包含列名和列值的对列向量，我们可以将其传递给 DataFrame 构造函数（我再次省略了输出，因为它与前面的情况相同）：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Constructor using a dictionary
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字典的构造函数
- en: 'Relatedly, when you collect dictionaries in Julia by using the collect function,
    you get a vector of pairs mapping their keys to values. For example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 相关地，当您在 Julia 中使用 collect 函数收集字典时，您会得到一个将它们的键映射到值的对向量。例如：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Therefore, you could write DataFrame(collect(data_dict)) to create a data frame
    from the data_dict dictionary. However, in this case, it is unnecessary. The DataFrame
    constructor automatically handles this, and you can just pass a dictionary to
    it to get a data frame:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以编写 DataFrame(collect(data_dict)) 来从 data_dict 字典创建数据框。然而，在这种情况下，这是不必要的。DataFrame
    构造函数自动处理此操作，您只需将其传递给字典即可获得数据框：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the common case of the Dict dictionary, as shown in the example, the columns
    of the resulting data frame are sorted by their names, as Dict has an undefined
    order of iteration (see chapter 4 for a discussion of this topic).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Dict 字典的常见情况下，如示例所示，结果数据框的列按其名称排序，因为 Dict 的迭代顺序未定义（有关此主题的讨论，请参阅第 4 章）。
- en: 'When creating a data frame, an important consideration is memory management.
    You have two options here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建数据框时，一个重要的考虑因素是内存管理。您有两个选项：
- en: Make the DataFrame constructor copy the data passed to it so that the columns
    of a data frame are freshly allocated.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让 DataFrame 构造函数复制传递给它的数据，这样数据框的列就会被重新分配。
- en: Make the DataFrame constructor reuse the data passed to it so that the columns
    of a data frame are not allocated.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让 DataFrame 构造函数重用传递给它的数据，这样数据框的列就不会被分配。
- en: The copycols keyword argument
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: copycols 关键字参数
- en: By default, a DataFrame constructor copies data. This is a safe approach that
    leads to code that is less error prone. However, if you are concerned about memory
    usage or performance, you can turn off copying by passing the copycols=false keyword
    argument to the DataFrame constructor.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，DataFrame 构造函数会复制数据。这是一个安全的方法，可以导致更少错误倾向的代码。然而，如果你担心内存使用或性能，你可以通过将 copycols=false
    关键字参数传递给 DataFrame 构造函数来关闭复制。
- en: 'Let’s compare these options. First, check that the columns are copied by default:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较这些选项。首先，检查列默认是复制的：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now let’s investigate the noncopying behavior:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们调查非复制行为：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Exercise 10.1 Compare the performance of creating a data frame holding a single
    random vector of one million elements with and without copying of a source vector.
    You can generate this vector by using the rand(10^6) command.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 10.1 比较创建包含单个随机向量的数据框（长度为一百万）时，有和没有复制源向量的性能。你可以通过使用 rand(10^6) 命令生成这个向量。
- en: Rules of handling nonstandard arguments
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 处理非标准参数的规则
- en: Before wrapping up the discussion of creating a DataFrame from vectors, I’ll
    comment on a convenience feature of the DataFrame constructor. As you know from
    chapter 5, by default, Julia never implicitly vectorizes your code. Instead, you
    are required to use explicit broadcasting.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束从向量创建 DataFrame 的讨论之前，我将评论 DataFrame 构造函数的一个便利功能。正如你在第 5 章中了解到的，默认情况下，Julia
    从不隐式向量化你的代码。相反，你必须使用显式广播。
- en: 'In DataFrames.jl, an exception to this rule is made for user convenience. If
    you pass a scalar (for example, a number or a string) to a DataFrame constructor,
    this scalar is automatically repeated as many times as required to match the length
    of the vectors passed in the constructor. This behavior is called *pseudo broadcasting*.
    Here is an example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DataFrames.jl 中，为了用户方便，对这一规则做了例外。如果你将标量（例如，一个数字或一个字符串）传递给 DataFrame 构造函数，这个标量会自动重复，直到与构造函数中传递的向量的长度相匹配。这种行为被称为
    *伪广播*。以下是一个例子：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The scalar 1 is repeated three times to match the length of the 1:3 range.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 标量 1 被重复三次，以匹配 1:3 范围的长度。
- en: 'Another convenience feature is that the DataFrame constructor always collects
    ranges (like 1:3 passed in the preceding example) to a Vector. You can check it
    by writing this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个便利功能是，DataFrame 构造函数总是将范围（如前一个例子中传递的 1:3）收集到一个 Vector 中。你可以通过编写以下代码来检查它：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The rationale behind such a rule is that most of the time, if you store a column
    in a DataFrame, you want this column to be mutable—that is, to allow adding elements
    to it or changing the values stored in them. Ranges, on the other hand, are read-only
    objects. This is the reason the DataFrame constructor always converts them to
    a Vector.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种规则背后的原因是，大多数情况下，如果你在 DataFrame 中存储一个列，你希望这个列是可变的——也就是说，允许向其中添加元素或更改存储在其中的值。另一方面，范围是只读对象。这就是
    DataFrame 构造函数总是将它们转换为向量的原因。
- en: 'Finally, pseudo broadcasting applies only to scalars. If you pass vectors of
    different lengths to the DataFrame constructor, you will get an error:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，伪广播仅适用于标量。如果你将不同长度的向量传递给 DataFrame 构造函数，你会得到一个错误：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This behavior might be surprising to R users, who are allowed to pass to a data
    frame constructor vectors of different lengths if the least common denominator
    of these lengths is equal to the length of the longest passed vector. For example,
    if you use vectors having lengths 6, 2, and 3, you will get a data frame with
    six rows.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为可能会让 R 用户感到惊讶，因为当这些长度的最小公倍数等于最长传递向量的长度时，R 允许将不同长度的向量传递给数据框构造函数。例如，如果你使用长度为
    6、2 和 3 的向量，你会得到一个包含六行的数据框。
- en: Integration of Julia with R
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 与 R 的集成
- en: 'To show this feature of R, I will use the RCall.jl package and explain how
    you can convert R data frame objects to a DataFrame object from DataFrames.jl.
    Knowing how to use the RCall.jl package is useful, as you might already have code
    written in R that you want to run as a part of your Julia program:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示 R 的这一特性，我将使用 RCall.jl 包，并解释如何将 R 数据框对象转换为 DataFrames.jl 的 DataFrame 对象。了解如何使用
    RCall.jl 包是有用的，因为你可能已经编写了 R 代码，并希望将其作为 Julia 程序的一部分运行：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Executes an R command by prefixing the string containing R code with the R
    character
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过在包含 R 代码的字符串前加上 R 字符来执行 R 命令
- en: ❷ Converts an R data frame into a DataFrame by using the rcopy function
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 rcopy 函数将 R 数据框转换为 DataFrame
- en: After loading the RCall.jl package, we first create the r_df object that is
    an R data frame. One of the ways you can execute any R command is by writing it
    in a string prefixed by the R character. Next, using the rcopy function, I convert
    the R data frame to a DataFrame object defined in DataFrames.jl.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载 RCall.jl 包之后，我们首先创建 r_df 对象，它是一个 R 数据框。您执行任何 R 命令的一种方法是将它写入以 R 字符为前缀的字符串中。接下来，使用
    rcopy 函数，我将 R 数据框转换为 DataFrames.jl 中定义的 DataFrame 对象。
- en: The example shows us that R recycles the 1:2 and 1:3 vectors when creating a
    data frame to have their lengths match the 1:6 vector. As I have explained, this
    behavior is not allowed in DataFrames.jl since it could lead to hard-to-catch
    bugs in production code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 示例显示，当创建数据框以使长度与 1:6 向量匹配时，R 会回收 1:2 和 1:3 向量。正如我解释的那样，在 DataFrames.jl 中不允许这种行为，因为它可能导致生产代码中难以捕捉的
    bug。
- en: The RCall.jl package
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: RCall.jl 包
- en: This section presented a minimal example showing how to use Julia and R together
    with the RCall.jl package. If you would like to learn more about the available
    features, consult the package documentation ([https://juliainterop.github.io/RCall.jl/stable/](https://juliainterop.github.io/RCall.jl/stable/)).
    Here, let’s discuss the most important aspects of using the RCall.jl package.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了一个最小示例，展示了如何使用 Julia 和 R 以及 RCall.jl 包一起工作。如果您想了解更多关于可用功能的信息，请参阅包文档（[https://juliainterop.github.io/RCall.jl/stable/](https://juliainterop.github.io/RCall.jl/stable/)）。在这里，让我们讨论使用
    RCall.jl 包最重要的方面。
- en: First, you need to have R installed to work with it. In some computing environments,
    installing the RCall.jl package might not automatically detect your R installation.
    In this case, consult the Installing RCall.jl manual ([http://mng.bz/jAy8](http://mng.bz/jAy8))
    for instructions explaining how to resolve the problem.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要安装 R 才能使用它。在某些计算环境中，安装 RCall.jl 包可能无法自动检测您的 R 安装。在这种情况下，请参阅安装 RCall.jl
    手册（[http://mng.bz/jAy8](http://mng.bz/jAy8)）以获取说明如何解决问题的说明。
- en: In our example code, we used a string prefixed by the R character to execute
    R code. Additionally, the RCall.jl package offers you an R REPL mode in which
    you can execute R code in your terminal directly. When you are in the Julia REPL
    and press the $ (dollar) key, the prompt will switch from julia> to R>, and the
    R mode will be activated. You exit this mode by pressing Backspace. The R REPL
    mode is useful in interactive sessions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例代码中，我们使用以 R 字符为前缀的字符串来执行 R 代码。此外，RCall.jl 包提供了 R REPL 模式，您可以直接在终端中执行 R
    代码。当您处于 Julia REPL 并按下 $（美元）键时，提示符将从 julia> 切换到 R>，并且 R 模式将被激活。您可以通过按退格键退出此模式。R
    REPL 模式在交互式会话中非常有用。
- en: You can find a more detailed explanation of how to use the R REPL mode, as well
    as a description of additional features of the RCall.jl package that I have not
    described here, in the “Getting Started” section of the package manual ([http://mng.bz/WM7l](http://mng.bz/WM7l)).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在包手册的“入门”部分找到有关如何使用 R REPL 模式的更详细解释，以及 RCall.jl 包的附加功能描述，这些功能我在这里没有描述。（[http://mng.bz/WM7l](http://mng.bz/WM7l)）
- en: 10.1.3 Creating a data frame using a Tables.jl interface
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.3 使用 Tables.jl 接口创建数据框
- en: In this subsection, we discuss the Tables.jl package, which provides simple
    yet powerful interface functions for working with all kinds of *tabular data*—data
    that has observations stored in rows and variables stored in columns. The Tables.jl
    package is needed because in many analytical tasks, you get a table-like object
    that is not a DataFrame.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们讨论了 Tables.jl 包，它提供了简单而强大的接口函数，用于处理各种 *表格数据*——数据中观测值存储在行中，变量存储在列中。Tables.jl
    包是必需的，因为在许多分析任务中，您会得到一个类似表格的对象，但它不是一个 DataFrame。
- en: For example, if you solve a differential equation by using the DifferentialEquations.jl
    package, you might want to store the solution as a data frame, as shown in the
    package documentation ([http://mng.bz/82l5](http://mng.bz/82l5)). The point is
    that it is enough that DifferentialEquations.jl implements a proper interface
    that allows for such a conversion; it does not need to have DataFrames.jl as its
    dependency. As discussed in chapter 1, such composability is one of the strengths
    of Julia.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您使用 DifferentialEquations.jl 包求解微分方程，您可能希望将解决方案存储为数据框，如包文档所示（[http://mng.bz/82l5](http://mng.bz/82l5)）。关键是
    DifferentialEquations.jl 实现了一个适当的接口，允许进行此类转换；它不需要将 DataFrames.jl 作为其依赖项。如第 1 章所述，这种可组合性是
    Julia 的一个优势。
- en: DataFrame is an example of a type that supports the table interface provided
    by the Tables.jl package. If you have an object that supports the Tables.jl interface,
    you can pass it as a single argument to the DataFrame constructor and get a DataFrame
    as a result.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame是支持Tables.jl包提供的表格接口的类型的例子。如果你有一个支持Tables.jl接口的对象，你可以将其作为单个参数传递给DataFrame构造函数，并得到一个DataFrame作为结果。
- en: 'The list of packages that support integration with Tables.jl is extensive ([http://mng.bz/E0xX](http://mng.bz/E0xX)).
    In this section, we will concentrate on two of the most common object types that
    support this interface and are defined in Base Julia:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 支持与Tables.jl集成的包列表非常广泛([http://mng.bz/E0xX](http://mng.bz/E0xX))。在本节中，我们将集中讨论两种最常见的支持此接口的对象类型，它们在Base
    Julia中定义：
- en: A NamedTuple of vectors
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量NamedTuple
- en: An iterator of NamedTuple objects
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NamedTuple对象的迭代器
- en: Iterators in Julia
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Julia中的迭代器
- en: You learned in chapter 4 about various types of collections that Julia supports.
    These include arrays, tuples, named tuples, and dictionaries.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你在第四章学习了Julia支持的各种集合类型。这些包括数组、元组、命名元组和字典。
- en: 'Many of the Julia collections can be iterated. You can think of this as follows.
    If a collection c is iterable, you can write a for loop like this to sequentially
    retrieve all elements of the collection c in this loop (note that this code is
    not runnable):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Julia集合都可以迭代。你可以这样想。如果一个集合c是可迭代的，你可以写一个for循环，如下所示，以顺序检索集合c在这个循环中的所有元素（请注意，此代码不可运行）：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Also, many functions, like map, rely on a collection being iterable. Types that
    support this form of usage are said to implement the iteration interface. If you
    define your own type that you want to support this interface, you can check the
    Julia Manual ([http://mng.bz/82w2](http://mng.bz/82w2)) to learn how to do that.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，许多函数，如map，依赖于集合的可迭代性。支持这种使用形式的类型被称为实现了迭代接口。如果你定义了自己的类型并希望支持此接口，你可以查看Julia手册([http://mng.bz/82w2](http://mng.bz/82w2))来了解如何实现。
- en: You can find a list of standard Julia collections that support an iteration
    interface in the “Iteration” section of the Julia Manual ([http://mng.bz/N5xv](http://mng.bz/N5xv)).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Julia手册的“迭代”部分找到支持迭代接口的标准Julia集合列表([http://mng.bz/N5xv](http://mng.bz/N5xv))。
- en: 'In the first case of a NamedTuple of vectors, the interpretation is intuitive.
    The field names of a NamedTuple become column names of a data frame, and the vectors
    become its columns. Remember that these vectors must have the same length for
    the operation to work. Here is an example using the data.set1 NamedTuple:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在NamedTuple向量的第一种情况下，解释是直观的。NamedTuple的字段名成为数据框的列名，向量成为其列。记住，这些向量必须具有相同的长度才能使操作生效。以下是一个使用data.set1
    NamedTuple的示例：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The second scenario occurs when an iterator of NamedTuple objects is passed.
    Then we assume that each NamedTuple has the same set of fields (the field names
    from the first NamedTuple are used), and each NamedTuple is used to create one
    row of data.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况发生在传递NamedTuple对象的迭代器时。然后我们假设每个NamedTuple具有相同的字段集（使用第一个NamedTuple的字段名），并且每个NamedTuple用于创建一行数据。
- en: 'Let’s start with a minimal example to make sure that the rules I describe are
    clear, and then we will move to a more advanced case of the data NamedTuple:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单的例子开始，以确保我描述的规则清晰，然后我们将转向数据NamedTuple的更复杂的情况：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In this case, we pass a vector (which is iterable) to the DataFrame constructor.
    This vector contains three elements, and each is a NamedTuple having fields a
    and b. Thus, as a result, we get a data frame with three rows and two columns:
    a and b.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将一个向量（它是可迭代的）传递给DataFrame构造函数。这个向量包含三个元素，每个元素都是一个具有字段a和b的NamedTuple。因此，结果我们得到一个包含三行两列的数据框：a和b。
- en: 'Let’s turn to the data object. It is a NamedTuple of NamedTuple objects:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转向数据对象。它是一个NamedTuple，其中包含NamedTuple对象：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If data were a NamedTuple of vectors, we would get a data frame with four columns,
    set1, set2, set3, and set4. However, this NamedTuple stores named tuples, so this
    rule does not apply to it. Since NamedTuple is iterable and it stores named tuples,
    each value is treated as a row in the created DataFrame. Since each of the internal
    named tuples contains fields x and y, we will get a DataFrame with two columns
    x and y and four rows representing the four data sets we work with. Let’s see
    if this is the case in the next listing.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据是一个向量的命名元组，我们会得到一个包含四个列的数据框，分别是set1、set2、set3和set4。然而，这个命名元组存储的是命名元组，因此这个规则不适用于它。由于命名元组是可迭代的并且存储命名元组，每个值都被视为创建的DataFrame中的一行。由于每个内部命名元组都包含字段x和y，我们将得到一个包含x和y两列以及四个行的DataFrame，代表我们处理的四个数据集。让我们看看在下一个列表中这是否成立。
- en: Listing 10.2 Creating the aq2 data frame
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.2 创建aq2数据框
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We get a vector of four vectors, both in columns x and y. Note that in listing
    10.2, you can see that columns of a DataFrame can store any objects; in this case,
    the columns store vectors.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到一个包含四个向量的向量，在x和y列中都有。注意，在列表10.2中，你可以看到DataFrame的列可以存储任何对象；在这种情况下，列存储向量。
- en: 10.1.4 Plotting a correlation matrix of data stored in a data frame
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.4 绘制存储在数据框中的数据的相关矩阵
- en: 'In this section, we will plot the correlation matrix of data stored in the
    aq1 data frame that we created in section 10.1\. Recall that this data frame stores
    the Anscombe’s data:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将绘制存储在我们在10.1节创建的aq1数据框中的数据的相关矩阵。回想一下，这个数据框存储了安斯康姆的数据：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: First, we create a correlation matrix of this data frame’s columns, and then
    we plot it. To compute the correlation matrix, we use the pairwise function from
    the StatsBase.jl package.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建这个数据框列的相关矩阵，然后我们绘制它。为了计算相关矩阵，我们使用StatsBase.jl包中的pairwise函数。
- en: 'This function takes two arguments. The first argument is the function we want
    to apply—in our case, the cor function from the Statistics module that computes
    the Pearson correlation. The second argument is a collection of vectors for which
    we want to compute the correlation. Since our data is stored in a data frame,
    we get this collection by using the eachcol function:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受两个参数。第一个参数是我们想要应用的函数——在我们的例子中，是从Statistics模块中计算皮尔逊相关性的cor函数。第二个参数是我们想要计算相关性的向量集合。由于我们的数据存储在数据框中，我们通过使用eachcol函数来获取这个集合：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Next, we plot the cor_mat matrix by using the heatmap function from Plots.jl.
    As a first and second argument to this function, we pass names of variables, which
    we get using the names(aq1) call. The third argument is the cor_mat correlation
    matrix.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用Plots.jl包中的heatmap函数绘制cor_mat矩阵。作为这个函数的第一个和第二个参数，我们传递变量的名称，这些名称是通过names(aq1)调用获得的。第三个参数是cor_mat相关矩阵。
- en: 'We additionally pass aspect_ratio=:equal and size=(400,400) keyword arguments
    to make sure that each cell in our correlation matrix is a square. Without passing
    these keyword arguments, the correlation matrix would not be square, but would
    be wider horizontally than vertically. Additionally, we pass rightmargin=5Plots.mm
    to make sure that the annotation of the color bar is not cropped; we already discussed
    adding extra padding when we plotted figure 7.6 in chapter 7:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还传递了aspect_ratio=:equal和size=(400,400)关键字参数，以确保我们的相关矩阵中的每个单元格都是一个正方形。如果不传递这些关键字参数，相关矩阵将不是正方形，而是水平方向比垂直方向更宽。此外，我们传递rightmargin=5Plots.mm以确保颜色条的注释不会被裁剪；我们已经在第7章中讨论了在绘制图7.6时添加额外填充的情况：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Figure 10.1 shows the resulting plot. We can see that pairs of matching variables—(:x1,
    :y1), (:x2, :y2), (:x3, :y3), and (:x4, :y4)—have similar Pearson correlation
    coefficients.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1显示了生成的图表。我们可以看到匹配变量的对——(:x1, :y1)、(:x2, :y2)、(:x3, :y3)和(:x4, :y4)——具有相似的皮尔逊相关系数。
- en: '![CH10_F01_Kaminski2](../Images/CH10_F01_Kaminski2.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![CH10_F01_Kaminski2](../Images/CH10_F01_Kaminski2.png)'
- en: Figure 10.1 In plotting the correlation matrix of the aq1 data frame, light
    squares indicate positive correlation and dark squares indicate negative correlation.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 在绘制aq1数据框的相关矩阵时，浅色方块表示正相关，深色方块表示负相关。
- en: 10.2 Creating data frames incrementally
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 逐步创建数据框
- en: In many cases, you will want to create a data frame incrementally—for example,
    by adding new rows of data to an existing data frame. One of the most common scenarios
    in which this is useful is when you generate data in your program and want to
    store it in a data frame. I will show an example in subsection 10.2.3, where we
    will discuss a simulation of a two-dimensional random walk.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，你可能会想逐步创建一个数据框——例如，通过向现有数据框中添加新数据行。这种情况下最有用的一个场景是在你的程序中生成数据并希望将其存储在数据框中。我将在10.2.3小节中展示一个示例，我们将讨论二维随机游走的模拟。
- en: 'This section covers the three most common operations allowing you to add rows
    to a data frame:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了三种最常见的操作，允许你向数据框中添加行：
- en: Vertical concatenation of several data frames into one new data frame
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多个数据框垂直连接到一个新的数据框中
- en: Appending a data frame to an existing data frame in place
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现有数据框中就地追加数据框
- en: Adding a new row to an existing data frame in place
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现有数据框中就地添加新行
- en: 10.2.1 Vertically concatenating data frames
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.1 垂直连接数据框
- en: In this section, you will learn how to combine multiple data frames into one
    by vertically concatenating them. This operation is often needed when you have
    data coming from several sources but want to store it in one data frame.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何通过垂直连接将多个数据框合并为一个。当你有来自多个来源的数据但希望将其存储在一个数据框中时，这个操作通常很有必要。
- en: We start by creating several data frames that we will vertically concatenate.
    In section 10.1, you learned that by writing DataFrame(data.set1), you can create
    a data frame from a NamedTuple of vectors. In this section, we start by creating
    four data frames for each of the four data sets contained in the data object.
    Next, we will vertically concatenate these four data frames.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建几个我们将要垂直连接的数据框。在10.1节中，你学习了通过编写DataFrame(data.set1)，你可以从一个向量NamedTuple创建一个数据框。在本节中，我们首先为数据对象中包含的四个数据集创建四个数据框。接下来，我们将垂直连接这四个数据框。
- en: In the next listing, we will use the map function to create four source data
    frames from four fields of the data NamedTuple.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个列表中，我们将使用map函数从数据NamedTuple的四个字段中创建四个源数据框。
- en: Listing 10.3 Creating multiple data frames by using the map function
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.3 使用map函数创建多个数据框
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We create the data_dfs NamedTuple by storing four data frames corresponding
    to four data sets in the data object. We would now like to vertically concatenate
    (stack) these data frames. You can do this in Julia by using the vcat function:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在数据对象中存储与四个数据集对应的四个数据框来创建data_dfs NamedTuple。我们现在想垂直连接（堆叠）这些数据框。在Julia中，你可以使用vcat函数来完成这个操作：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The result of the operation is a single data frame with the source data frames
    stacked one over the other. The only problem is that we do not see which rows
    come from which source data frame. You can fix this by passing the source keyword
    argument to vcat. If you pass a column name as source, this column will store
    the number of the data frame from which a given row originates:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 操作的结果是一个单一的数据框，源数据框堆叠在一块。唯一的问题是，我们看不到哪些行来自哪个源数据框。你可以通过传递source关键字参数给vcat来解决这个问题。如果你传递一个列名作为source，这个列将存储给定行来自哪个数据框的编号：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After the operation, the source_id column contains numbers from 1 to 4 showing
    from which source data frame a given row was taken. If you would like to use custom
    names for source data frames, pass as a source keyword argument a Pair holding
    the source column name and the identifiers assigned to passed data frames. Here
    is an example:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 操作完成后，source_id列包含从1到4的数字，显示给定行来自哪个源数据框。如果你希望为源数据框使用自定义名称，请将一个包含源列名称和分配给传递的数据框的标识符的Pair作为source关键字参数传递。以下是一个示例：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you have a lot of data frames stored in a vector, listing them one by one
    in the vcat call might be inconvenient. We can use the reduce function, passing
    it a vcat as a first argument followed by a vector of data frames, and, if needed,
    appropriate keyword arguments. In this case, we can turn the data_dfs NamedTuple
    into a vector of data frame objects by using the collect function so we can use
    this pattern. Here is an example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有很多数据框存储在一个向量中，在vcat调用中逐个列出它们可能不太方便。我们可以使用reduce函数，传递一个vcat作为第一个参数，后面跟着一个数据框向量，如果需要，还可以传递适当的关键字参数。在这种情况下，我们可以使用collect函数将data_dfs
    NamedTuple转换为一个数据框对象向量，这样我们就可以使用这个模式。以下是一个示例：
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The reduce function
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: reduce函数
- en: The reduce function is not specific to DataFrames.jl. In general, if you write
    reduce (op, collection), a reduction of the passed collection with a given operator
    op is performed; see the Julia Manual at [tinyurl.com/3pbhaw84](http://tinyurl.com/3pbhaw84)
    for more details.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: reduce 函数并不仅限于 DataFrames.jl。一般来说，如果你编写 reduce (op, collection)，它将执行使用给定操作符
    op 对传递的集合进行归约；有关更多详细信息，请参阅 Julia 手册 [tinyurl.com/3pbhaw84](http://tinyurl.com/3pbhaw84)。
- en: For example, if you write reduce(*, [2, 3, 4]), you get 24, as it is a product
    of the numbers stored in the vector [2, 3, 4].
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你编写 reduce(*, [2, 3, 4])，你将得到 24，因为它是存储在向量 [2, 3, 4] 中的数字的乘积。
- en: In vertical concatenation operations I have shown up until now, all data frames
    have the same column names. However, in practice, you might want to vertically
    concatenate data frames that do not meet this condition. We use the cols=:union
    keyword argument to create a union of columns from the passed data frames. Columns
    that are not present in some data frames are filled with missing where necessary.
    The following listing shows a simple example.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在我之前展示的垂直连接操作中，所有数据帧都具有相同的列名。然而，在实际操作中，你可能希望连接不满足此条件的数据帧。我们使用 cols=:union 关键字参数从传递的数据帧中创建列的并集。在必要的地方，缺失值填充在不存在某些数据帧的列中。以下列表显示了一个简单的示例。
- en: Listing 10.4 Vertically concatenating data frames whose column names do not
    match
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.4 列名不匹配的垂直连接数据帧
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can see that vcat(df1, df2) throws an error because the passed data frames
    have nonmatching column names. On the other hand, vcat(df1, df2; cols= :union)
    works and keeps a union of columns passed in the source data frames. Note that
    since column c is not present in df1, its first three elements are filled with
    missing in the resulting data frame. Similarly, column b is not present in df2,
    so its last three elements are filled with missing in the resulting data frame.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，vcat(df1, df2) 抛出错误，因为传递的数据帧具有不匹配的列名。另一方面，vcat(df1, df2; cols= :union)
    可以正常工作，并保留在源数据帧中传递的列的并集。请注意，由于列 c 不在 df1 中，其前三个元素在结果数据帧中填充了缺失值。同样，列 b 不在 df2 中，因此其最后三个元素在结果数据帧中填充了缺失值。
- en: Options for the cols keyword argument in vcat
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: vcat 中 cols 关键字参数的选项
- en: 'The cols keyword argument in vcat can take the following values:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: vcat 中的 cols 关键字参数可以采用以下值：
- en: :setequal—Requires all data frames to have the same column names, disregarding
    order. If they appear in different orders, the order of the first provided data
    frame is used.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: :setequal—要求所有数据帧具有相同的列名，不考虑顺序。如果它们以不同的顺序出现，则使用第一个提供的数据帧的顺序。
- en: :orderequal—Requires all data frames to have the same column names and in the
    same order.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: :orderequal—要求所有数据帧具有相同的列名和相同的顺序。
- en: :intersect—Only the columns present in all provided data frames are kept. If
    the intersection is empty, an empty data frame is returned.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: :intersect—仅保留所有提供的数据帧中存在的列。如果交集为空，则返回空数据帧。
- en: :union—Columns present in at least one of the provided data frames are kept.
    Columns not present in some data frames are filled with missing where necessary.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: :union—保留至少在一个提供的数据帧中存在的列。在必要的地方，缺失值填充在不存在某些数据帧的列中。
- en: By default, the cols keyword argument takes the :setequal value.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，cols 关键字参数采用 :setequal 值。
- en: Exercise 10.2 Check the result of vcat on the data frames df1=DataFrame(a=1,
    b=2) and df2=DataFrame(b=2, a=1). Next, verify the result of the operation if
    we additionally pass the cols=:orderequal keyword argument.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 10.2 检查 vcat 在数据帧 df1=DataFrame(a=1, b=2) 和 df2=DataFrame(b=2, a=1) 上的结果。接下来，验证如果额外传递
    cols=:orderequal 关键字参数的操作结果。
- en: 10.2.2 Appending a table to a data frame
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.2 将表格追加到数据帧
- en: In section 10.2.1, you learned how to create a new data frame from several source
    data frames. Next, we’ll discuss a similar operation that updates the data frame
    instead. I will show you how to append tabular data to an existing data frame
    in place. The difference is that appending does not create a new data frame but
    mutates an existing one.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在 10.2.1 节中，你学习了如何从多个源数据帧创建新的数据帧。接下来，我们将讨论一个类似的操作，该操作会更新数据帧。我将向你展示如何就地向现有数据帧中添加表格数据。不同之处在于，追加不会创建新的数据帧，而是修改现有的数据帧。
- en: You can append data to an existing data frame by using the append! function.
    Let’s start with an example. We will create an empty data frame and then append
    to it the data_dfs.set1 and data_dfs.set2 data frames, as the next listing shows.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 append! 函数向现有数据帧中添加数据。让我们从一个例子开始。我们将创建一个空数据帧，然后按照以下列表所示，向其中添加 data_dfs.set1
    和 data_dfs.set2 数据帧。
- en: Listing 10.5 Appending a data frame to a data frame
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.5 将数据框附加到数据框
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Apart from updating the passed data frame in place, the append! function has
    similar mechanics to vcat with the following differences:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 除了就地更新传递的数据框之外，append!函数与vcat有类似的机制，但有以下不同之处：
- en: You are allowed to append to a data frame any table that follows the Tables.jl
    interface (vcat requires all arguments to be data frames).
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将任何遵循Tables.jl接口的表附加到数据框中（vcat要求所有参数都是数据框）。
- en: append! does not support the source keyword argument. If you want to have a
    column representing the source of a given row when using append!, you should add
    it to the source data frames before appending them.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: append!不支持`source`关键字参数。如果你想在append!中使用时有一个表示给定行来源的列，你应该在附加之前将其添加到源数据框中。
- en: append! supports the cols keyword argument like vcat does. For :setequal, :orderequal,
    and :union values of this argument, the behavior is the same. For the :intersect
    value, the behavior is a bit different; for this option, the appended table contains
    more columns than the target data frame, but all column names that are present
    in the target data frame must be present in the appended data frame, and only
    these are used. Additionally, the :subset value, which behaves like :intersect,
    is supported, but if a column is missing in the appended data frame, then missing
    values are pushed to the target data frame for that column. As presented in listing
    10.5, you can always, independent of the value of the cols keyword argument, append
    data to a data frame that has no columns (DataFrame() object), and similarly,
    DataFrame() can always be appended.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: append!支持与vcat相同的`cols`关键字参数。对于此参数的`:setequal`、`:orderequal`和`:union`值，行为相同。对于`:intersect`值，行为略有不同；对于此选项，附加的表包含比目标数据框更多的列，但所有在目标数据框中存在的列名必须在附加数据框中存在，并且只使用这些列。此外，支持与`:intersect`行为相似的`:subset`值，但如果附加数据框中缺少列，则对于该列，将缺失值推送到目标数据框。如列表10.5所示，你可以始终，无论`cols`关键字参数的值如何，将数据附加到没有列的数据框（DataFrame()对象），同样，DataFrame()也可以始终附加。
- en: append! supports the promote keyword argument that is not needed in vcat. This
    argument determines what should happen if the values stored in the appended data
    frame cannot be stored in the columns of the target data frame. If promote=false,
    an error is thrown. If promote=true, then in the target data frame, the column
    types are changed so that the append! operation can be successfully completed.
    By default, promote=false except if the cols keyword argument is :union or :subset;
    then promote=true.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: append!支持`promote`关键字参数，这在vcat中是不需要的。此参数确定如果附加数据框中存储的值无法存储在目标数据框的列中，应该发生什么。如果`promote=false`，则会抛出错误。如果`promote=true`，则目标数据框中的列类型会改变，以便append!操作可以成功完成。默认情况下，`promote=false`，除非cols关键字参数是`:union`或`:subset`；然后`promote=true`。
- en: Let’s look at examples of the first and last points from the preceding list,
    as they demonstrate the biggest differences between append! and vcat.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看前面列表中的第一点和最后一点，因为它们展示了append!和vcat之间最大的差异。
- en: 'We start by examining how to append a Tables.jl table that is not a data frame
    to a data frame. As discussed in section 10.1, a NamedTuple of vectors is a Tables.jl
    table. Therefore, data.set1 and data.set2 are such tables. As a result, the following
    code produces a result that’s identical to the result of listing 10.5 (I omit
    the output to save space):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查如何将一个不是数据框的Tables.jl表附加到数据框中。如第10.1节所述，向量的NamedTuple是Tables.jl表。因此，data.set1和data.set2是这样的表。因此，以下代码产生的结果与列表10.5的结果相同（我省略了输出以节省空间）：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The promote keyword of the append! function is most often needed when you have
    data that potentially contains missing values. Consider the following example:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的数据可能包含缺失值时，append!函数的`promote`关键字通常需要。考虑以下示例：
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We get an error because column b in the df1 data frame does not allow storing
    missing values in it. You can resolve this issue by passing the promote=true keyword
    argument to append!:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到一个错误，因为df1数据框中的列b不允许在其中存储缺失值。你可以通过传递`promote=true`关键字参数来解决这个问题！：
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This time, the operation succeeds, and, as you can see, the b column element
    type is promoted to Union{Int, Missing} as its element type is displayed as Int64?.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，操作成功了，正如你所看到的，b列的元素类型提升为Union{Int, Missing}，因为它的元素类型显示为Int64?。
- en: 10.2.3 Adding a new row to an existing data frame
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.3 向现有数据框添加新行
- en: 'The append! function adds a table to a data frame in place. Often, however,
    you need to add a single row to a data frame. This operation can be performed
    using the push! function. This function works exactly the same way as append!,
    including the allowed keyword arguments. The only difference is that instead of
    accepting whole tables, push! accepts a single row. The values of the following
    types are valid rows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: append!函数在数据框中就地添加一个表。然而，通常你需要向数据框中添加一行。这个操作可以使用push!函数来完成。这个函数的工作方式与append!完全相同，包括允许的关键字参数。唯一的区别是，push!接受的是单行，而不是整个表。以下类型的值是有效的行：
- en: DataFrameRow, NamedTuple, and dictionary—The column names contained in the pushed
    row are checked and are matched to the target data frame column names following
    the cols keyword argument rules
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DataFrameRow、NamedTuple和字典——推送到行中的列名会被检查，并按照cols关键字参数规则与目标数据框的列名匹配
- en: AbstractArray and Tuple—The pushed collection must have the same number of elements
    as there are columns in the target data frame.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AbstractArray和Tuple——推送的集合必须与目标数据框中的列数相同。
- en: Let’s look at two minimal examples of both options, and then we will switch
    to a practical case study of this functionality.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看两种选项的最小示例，然后我们将转向这个功能的一个实际案例研究。
- en: 'We’ll start with an example of pushing data that has column names defined using
    NamedTuples to represent rows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以一个使用NamedTuples定义列名来表示行的数据推送为例：
- en: '[PRE42]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, we push a vector to a data frame:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将一个向量推送到数据框中：
- en: '[PRE43]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note that in this case, since the vector does not carry information about column
    names, we have to initialize the columns of the data frame with DataFrame (a=Int[],
    b=Int[]) before pushing rows to it. When we push NamedTuples to a data frame,
    it is enough to initialize it with DataFrame(), as column names can be inferred
    from the pushed NamedTuples.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，由于向量不携带列名信息，我们必须在向其推送行之前用DataFrame（a=Int[], b=Int[]）初始化数据框的列。当我们向数据框推送NamedTuples时，只需要用DataFrame()初始化它就足够了，因为列名可以从推送的NamedTuples中推断出来。
- en: 10.2.4 Storing simulation results in a data frame
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.4 在数据框中存储模拟结果
- en: Pushing rows to a data frame is useful when performing computer simulation studies.
    The reason a data frame is a good object to store simulation results is twofold.
    First, simulations usually produce data that has a fixed structure, so consecutive
    simulation results can easily be stored as rows in a data frame. Second, after
    you finish doing your simulation, you usually want to analyze the produced data,
    and DataFrames.jl provides many functions that make this part of your task easy.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 将行推送到数据框在执行计算机模拟研究时很有用。数据框是一个很好的对象来存储模拟结果，原因有两点。首先，模拟通常会产生具有固定结构的数据，因此连续的模拟结果可以很容易地作为数据框中的行存储。其次，在你完成模拟后，你通常想要分析产生的数据，DataFrames.jl提供了许多函数，使得这一部分的任务变得简单。
- en: In this section, I use an example of a random walk simulation to show you how
    this is done.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我通过一个随机游走模拟的例子来展示如何进行这一操作。
- en: Definition of a two-dimensional random walk
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 二维随机游走的定义
- en: Let’s create a simple simulation of a two-dimensional random walk ([http://mng.bz/E0Zl](http://mng.bz/E0Zl)).
    We will call the first dimension x and the second y.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个二维随机游走的简单模拟([http://mng.bz/E0Zl](http://mng.bz/E0Zl))。我们将第一维称为x，第二维称为y。
- en: Assume that an object starts its journey at point (0, 0) and in one step, can
    move left (decrease its x location by 1), right (increase its x location by 1),
    down (decrease its y location by 1), or up (increase its y location by 1). Each
    direction is picked randomly with the same probability. We want to visualize a
    sample of 10 steps of this simulation. Figure 10.2 depicts a single step of this
    process.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个对象从点(0, 0)开始它的旅程，并在一步中可以向左（减少其x位置1个单位）、向右（增加其x位置1个单位）、向下（减少其y位置1个单位）或向上（增加其y位置1个单位）移动。每个方向以相同的概率随机选择。我们想要可视化这个模拟的10步样本。图10.2描述了这个过程的单步。
- en: '![CH10_F02_kaminski2](../Images/CH10_F02_kaminski2.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![CH10_F02_kaminski2](../Images/CH10_F02_kaminski2.png)'
- en: Figure 10.2 Possible changes of coordinates of the point in a single step of
    a two-dimensional random walk. Each direction is picked with the same probability.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 在二维随机游走单步中点的坐标可能的变化。每个方向被以相同的概率选择。
- en: In our implementation, we will not try to provide the most efficient way to
    perform this simulation. Rather, our goal is to learn how to work with data frames.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的实现中，我们不会尝试提供执行此模拟的最有效方法。相反，我们的目标是学习如何与数据框（data frames）一起工作。
- en: 'First, we create a function that generates one random step of our simulation:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个函数来生成我们模拟的一次随机步：
- en: '[PRE44]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ❶ Randomly samples one of the four accepted directions
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 随机选择四个接受方向中的一个
- en: ❷ Returns a NamedTuple with an updated location
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回一个包含更新位置的命名元组
- en: The step function assumes that the current value passed to it has x and y properties
    that give information about the location of the object in the first and second
    dimension, respectively. It returns a NamedTuple with an updated location of the
    object.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 步进函数假设传递给它的当前值具有x和y属性，分别提供关于对象在第一和第二维度的位置信息。它返回一个包含对象更新位置的命名元组。
- en: 'It is worth paying attention to the rand(((1,0), (-1,0), (0,1), (0,-1))) operation.
    The rand function gets passed a tuple containing four tuples ((1,0), (-1,0), (0,1),
    (0,-1)). Since this tuple is a four-element collection, the rand function returns
    one of its elements picked with equal probability. An important feature of this
    syntax is that we are not allocating any memory to perform it, since we are using
    tuples (see chapter 4 for an explanation of the differences between tuples and
    vectors). Therefore, it is fast:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，rand(((1,0), (-1,0), (0,1), (0,-1)))操作。rand函数接收一个包含四个元组的元组((1,0), (-1,0),
    (0,1), (0,-1))。由于这个元组是一个四元素集合，rand函数返回其元素之一，以相等的概率选择。这个语法的一个重要特性是我们没有分配任何内存来执行它，因为我们正在使用元组（参见第4章中关于元组和向量的区别的解释）。因此，它很快：
- en: '[PRE45]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, note that the dx, dy = ... syntax performs an *iterator destructuring*.
    The first element of the tuple returned by the rand function gets assigned to
    dx, and the second to the dy variable—for example:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，请注意，dx, dy = ... 语法执行了*迭代解构*。rand函数返回的元组的第一个元素被分配给dx，第二个分配给dy变量——例如：
- en: '[PRE46]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Before moving forward, let’s quickly check by simulation that indeed the rand(((1,0),
    (-1,0), (0,1), (0,-1))) operation returns each of the four tuples with equal probability
    by running 10 million (10^7) random draws. In the code, I use _ as the variable
    name in the for _ in 1:10^7 expression. This approach can be used when a variable
    name is required by Julia’s syntax, but you do not plan to use the value of that
    variable in your code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续前进之前，让我们通过模拟快速检查rand(((1,0), (-1,0), (0,1), (0,-1)))操作确实以相等的概率返回四个元组，通过运行1000万（10^7）次随机抽取。在代码中，我在for
    _ in 1:10^7表达式中使用_作为变量名。这种方法可以在需要Julia语法中的变量名，但你不想在代码中使用该变量的值时使用：
- en: '[PRE47]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We see that all four values have approximately a one-in-four chance of being
    observed as expected. We already used the Random.seed! and proptable functions
    in chapter 6.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到所有四个值有大约四分之一的概率被观察到，正如预期的那样。我们已经在第6章中使用了Random.seed!和proptable函数。
- en: A simple simulator of a random walk
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 随机行走的简单模拟器
- en: We are now ready to run our simulation in the next listing.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以运行下一列表中的模拟了。
- en: Listing 10.6 A sample simulation of the two-dimensional random walk
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.6 两个维度的随机行走的样本模拟
- en: '[PRE48]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: ❶ Initializes the data frame with the starting point of the simulation
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用模拟的起点初始化数据表
- en: ❷ Uses the underscore (_) as the name of the variable for the iteration, as
    we will not need it later
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用下划线(_)作为迭代的变量名，因为我们稍后不需要它
- en: ❸ Gets the current location of the object as a DataFrameRow representing the
    last row of the walk data frame
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 获取对象的当前位置，作为表示行走数据表最后一行的DataFrameRow
- en: ❹ Adds a new row to the end of the walk data frame
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在行走数据表的末尾添加一行新数据
- en: ❺ In instance 1, the object is at point (0, 0).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在实例1中，对象位于点(0, 0)。
- en: ❻ In instance 11, after 10 moves, the object is at point (0, 8).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 在实例11中，移动了10次后，对象位于点(0, 8)。
- en: 'Let’s plot the result of our simulation:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们绘制模拟的结果：
- en: '[PRE49]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: ❶ Adds text annotations to data points on the plot
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在图上的数据点上添加文本注释
- en: ❷ Makes ticks on the plot integers in the range of observed values
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在图中观察值范围内的整数上打勾
- en: Figure 10.3 shows the result of the simulation.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3显示了模拟的结果。
- en: '![CH10_F03_Kaminski2](../Images/CH10_F03_Kaminski2.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![CH10_F03_Kaminski2](../Images/CH10_F03_Kaminski2.png)'
- en: Figure 10.3 In this visualization of our walk data frame, each number on the
    plot indicates in which instance the object was present in a given location.For
    this run of the simulation, the points on the grid are visited only once.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 在这个行走数据表的可视化中，图上的每个数字都表示对象在给定位置出现的实例。对于这次模拟运行，网格上的点只访问一次。
- en: The object was at point (0,0) in instance 1 and then moved 10 times to end up
    in location (0, 8) in instance 11.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例1中，对象位于点(0,0)，然后移动了10次，最终在实例11中到达位置(0, 8)。
- en: 'This example shows you some more advanced options that can be used in the plots
    function:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了在 plots 函数中可以使用的更多高级选项：
- en: The series_annotations keyword argument allows you to pass labels that should
    be used as text annotations on the drawn points.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: series_annotations 关键字参数允许您传递用作绘制点上的文本注释的标签。
- en: The xticks and yticks keyword arguments govern how x- and y-axis ticks should
    be located.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: xticks 和 yticks 关键字参数控制 x 轴和 y 轴刻度的位置。
- en: 'Note that I wanted the ticks to be integers in the range of values present
    in a given dimension in the walk data frame. Let’s look at how the range(extrema(walk
    .y)...)) expression works step by step. First, we run the extrema function:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我希望刻度是整数，范围在行走数据框给定维度的值中。让我们一步一步地看看 range(extrema(walk .y)...)) 表达式是如何工作的。首先，我们运行
    extrema 函数：
- en: '[PRE50]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'It produces a tuple with a minimum and maximum value observed in the walk.y
    vector. Next, we use the range function to create a range of values from minimal
    to maximal value with the step equal to 1\. Note that normally the range function
    expects to get two positional arguments for our case; for example:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 它产生一个包含在 walk.y 向量中观察到的最小值和最大值的元组。接下来，我们使用 range 函数创建一个从最小值到最大值的值范围，步长为 1。请注意，通常
    range 函数期望获取两个位置参数，例如：
- en: '[PRE51]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Since the extrema function returns a two-element tuple, we need to splat it
    by using the ... notation.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 由于极值函数返回一个包含两个元素的元组，我们需要使用 ... 符号将其展开。
- en: Analysis of simulation output
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟输出分析
- en: Let’s go back to figure 10.3\. What might catch your attention is that all the
    points on this figure are distinct. In each instance from 1 to 11, the point has
    a different location. Should this fact surprise us? I would argue yes. (I have
    carefully chosen the seed of the random number generator to achieve this effect.)
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到图 10.3。可能会引起你注意的是，这个图上的所有点都是不同的。在从 1 到 11 的每个实例中，点的位置都不同。这个事实会让我们感到惊讶吗？我会说会的。（我已经仔细选择了随机数生成器的种子以实现这种效果。）
- en: 'Note that the chance that locations in instances 1 and 3 are different is 3/4\.
    The reason is that no matter how we move from instance 1 to instance 2, there
    is exactly one way to get back to the position we had in instance 1 when we are
    in instance 3\. Therefore, the chance that we will not get back is 3/4 (only one
    direction out of four possible supports this event). A similar reasoning applies
    to instances 2 and 4, 3 and 5, ..., and finally instances 9 and 11 (in total,
    nine events, each happening with 3/4 probability). Since all nine events are independent,
    following the laws of probability, the probability of having all unique points
    is at most a product of these nine individual probabilities:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，实例 1 和 3 中位置不同的概率是 3/4。原因是无论我们从实例 1 移动到实例 2 的方式如何，当我们处于实例 3 时，回到实例 1 的位置只有一种方式。因此，我们不会回到原地的概率是
    3/4（只有四个可能的方向中的一个支持这个事件）。类似的推理适用于实例 2 和 4、3 和 5、...，最后是实例 9 和 11（总共九个事件，每个事件发生的概率都是
    3/4）。由于所有九个事件都是独立的，根据概率法则，所有唯一点的概率至多是这些九个单个概率的乘积：
- en: '[PRE52]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We expect this probability to be smaller in practice, because in the preceding
    calculation, we considered hitting the same spot only two steps ahead, and in
    general, we might get back to the position we had in instance 1 in instance 5
    (without visiting it in instance 3)—for example, after the sequence of moves (0,
    1), (1, 0), (0, -1), (-1, 0).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们预计这个概率在实际中会更小，因为在先前的计算中，我们只考虑了向前两步到达相同位置的情况，而在一般情况下，我们可能在实例 5 中回到实例 1 的位置（在实例
    3 中没有访问过它）——例如，在移动序列（0, 1）、（1, 0）、（0, -1）、（-1, 0）之后。
- en: Let’s use a simulation to approximate this probability of having all unique
    points in the next listing.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用模拟来近似下一个列表中所有唯一点的概率。
- en: Listing 10.7 Code checking the probability of having a walk with all unique
    points
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.7 检查所有唯一点的行走的概率的代码
- en: '[PRE53]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: ❶ Defines a function running a whole simulation once
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义一个函数运行一次整个模拟
- en: ❷ Checks if all rows in the walk data frame are unique
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查行走数据框中的所有行是否唯一
- en: We observe that the probability that our 10-step walk consists of all unique
    points is 4.2%, which is less than 7.5%, as expected.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们观察到，我们的 10 步行走由所有唯一点组成的概率是 4.2%，这低于预期的 7.5%。
- en: The new element of the walk_unique function in comparison to the code from listing
    10.6 is the nrow(unique(walk)) == nrow(walk) expression. It compares the number
    of rows of the original walk data frame and the unique(walk) data frame. The unique
    function, when applied to a data frame object, retains only distinct rows stored
    in it.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表10.6中的代码相比，walk_unique函数的新元素是nrow(unique(walk)) == nrow(walk)表达式。它比较原始walk数据框和unique(walk)数据框的行数。当应用于数据框对象时，unique函数仅保留其中存储的唯一行。
- en: The unique function
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: unique函数
- en: The unique function allows you to de-duplicate rows of a data frame. Additionally,
    it can optionally be passed any column selector that is accepted by a data frame
    (these selectors were explained in chapter 9) as a second positional argument.
    In that case, the de-duplication is performed only on the selected columns. For
    example, unique(walk, "x") would ensure that there are no duplicates in the x
    column of the walk data frame.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: unique函数允许您去除数据框的重复行。此外，您可以可选地传递任何数据框接受的列选择器（这些选择器在第9章中已解释）作为第二个位置参数。在这种情况下，去重仅在所选列上执行。例如，unique(walk,
    "x")将确保walk数据框的x列中没有重复项。
- en: If you would like to avoid allocating a new data frame when removing duplicates,
    you have two options. First, you could pass the view=true keyword argument to
    the unique function. Instead of allocating a new data frame, a view of the source
    data frame is returned. Second, you could use the unique! function instead, which
    works the same as unique but drops the rows of the passed data frame in place.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在删除重复项时避免分配新的数据框，您有两个选择。首先，您可以将view=true关键字参数传递给unique函数。而不是分配新的数据框，它将返回源数据框的视图。其次，您可以使用unique!函数，它与unique函数的工作方式相同，但会就地删除传递的数据框的行。
- en: The unique function is not only defined for data frames; it is available without
    loading any packages and returns an array containing unique values of a collection
    as determined by the isequal function. We already discussed the unique function
    in chapter 4.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: unique函数不仅适用于数据框；它无需加载任何包即可使用，并返回由isequal函数确定的集合的唯一值数组。我们已经在第4章中讨论了unique函数。
- en: Exercise 10.3 Change the code from listing 10.7 so that we perform only two-steps-ahead
    verification if the random walk visits the same point again. Verify that under
    such a definition, the probability that we do not have duplicate visits of the
    same point is around 7.5%.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 练习10.3 将列表10.7中的代码修改为，如果随机游走再次访问相同点时，只进行两步验证。验证在这种情况下，我们没有重复访问相同点的概率大约为7.5%。
- en: Serialization of Julia objects
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Julia对象的序列化
- en: In chapter 11, we will use the walk data frame that we created in this section.
    Therefore, before we finish our discussion, let’s save it to disk. We could use
    the CSV.jl package for this, as you learned in chapter 8\. However, I would like
    to show you another persistent storage option that Julia offers.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在第11章中，我们将使用本节创建的walk数据框。因此，在我们结束讨论之前，让我们将其保存到磁盘上。我们可以使用CSV.jl包来完成此操作，正如你在第8章中学到的。然而，我想向你展示Julia提供的另一个持久化存储选项。
- en: 'The Serialization module offers functionality to save Julia objects in binary
    format to disk. This is a similar functionality to pickle in Python or save and
    load functions in R. The two functions you need to learn are serialize, which
    writes an object to disk, and deserialize, which reads it from disk into memory:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Serialization模块提供了将Julia对象以二进制格式保存到磁盘的功能。这与Python中的pickle功能或R中的save和load函数类似。您需要学习的两个函数是serialize，它将对象写入磁盘，以及deserialize，它从磁盘读取它到内存中：
- en: '[PRE54]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: ❶ The first argument is the file we want to write the object to, and the second
    is the object we want to save.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 第一个参数是我们想要写入对象的文件，第二个参数是我们想要保存的对象。
- en: ❷ The deserialize function takes a single argument, which is the file where
    we have stored the data we want to read in.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ deserialize函数接受一个单一参数，即我们存储要读取数据的文件。
- en: In the code, I have checked that serializing and deserializing the walk data
    frame produces the same value. Please do not erase the walk.bin file we have created,
    as we will use it in chapter 11.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我已经检查了序列化和反序列化walk数据框会产生相同的值。请勿删除我们创建的walk.bin文件，因为我们将在第11章中使用它。
- en: Limitations of object serialization
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 对象序列化的局限性
- en: Serialization of Julia objects is designed as functionality for short-term storage.
    Therefore, serialization and deserialization can safely be done only by the same
    version of Julia with the same loaded packages in the same versions.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 对象的序列化设计为短期存储功能。因此，序列化和反序列化只能由具有相同版本和相同加载包版本的 Julia 安全执行。
- en: Summary
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: You can construct DataFrame objects from a wide variety of source values, including
    matrices, vectors of vectors, a list of vectors, a NamedTuple of vectors, an iterator
    of named tuples, and a dictionary with vectors as keys. You can pass any object
    supporting the table interface defined in the Tables.jl package to the DataFrame
    constructor. This flexibility means that you can easily create DataFrame objects
    in your code.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以从各种源值构建 DataFrame 对象，包括矩阵、向量向量、向量列表、向量命名元组、命名元组的迭代器以及以向量为键的字典。你可以将支持在 Tables.jl
    包中定义的表接口的任何对象传递给 DataFrame 构造函数。这种灵活性意味着你可以在代码中轻松创建 DataFrame 对象。
- en: When constructing data frames from matrices, you either need to pass column
    names as a second argument or request automatic generation of column names. You
    can have full control of the constructed data frame, while retaining convenience
    when you do not care about exact names of the columns.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当从矩阵构建数据框时，你需要传递列名作为第二个参数或请求自动生成列名。你可以完全控制构建的数据框，同时在不关心列的确切名称时保持便利性。
- en: You can construct data frames by passing the column name and column value to
    the DataFrame constructor. This is one of the most often used ways of constructing
    a data frame.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过将列名和列值传递给 DataFrame 构造函数来构建数据框。这是构建数据框最常用的方法之一。
- en: You can easily convert any object that supports the Tables.jl interface into
    a data frame. This often significantly simplifies your code, as dozens of Julia
    packages define types supporting the Tables.jl interface.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以轻松地将支持 Tables.jl 接口的任何对象转换为数据框。这通常可以显著简化你的代码，因为数十个 Julia 包定义了支持 Tables.jl
    接口的数据类型。
- en: The DataFrame constructor supports the copycols keyword argument that takes
    a Boolean value and allows you to decide whether the passed data should be copied.
    Having such control is useful in practice. By default, data is copied, so you
    do not run into the risk of having data aliases spread around your code. However,
    if you need performance, or your computations are memory bound, you can use copycols=false
    to avoid copying.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DataFrame 构造函数支持 copycols 关键字参数，它接受一个布尔值，允许你决定传递的数据是否应该被复制。在实际应用中，拥有这样的控制是有用的。默认情况下，数据会被复制，所以你不会遇到数据别名在代码中传播的风险。然而，如果你需要性能，或者你的计算受内存限制，你可以使用
    copycols=false 来避免复制。
- en: You can integrate Julia with R by using the RCall.jl package. This is useful
    when you have R installed on your machine and would like to use R code in your
    Julia project.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 RCall.jl 包将 Julia 与 R 集成。当你已经在你的机器上安装了 R 并希望在 Julia 项目中使用 R 代码时，这非常有用。
- en: The pairwise function from StatsBase.jl can be used to compute values of a function
    taking all possible pairs of entries of a passed collection. It is often used
    to create a correlation matrix of a data frame’s columns, in which case the cor
    function is used. We obtain a collection of data frame columns by using the eachcol
    function.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: StatsBase.jl 中的成对函数可以用来计算一个函数对所有可能成对条目集合的值。它通常用于创建数据框列的相关矩阵，在这种情况下，使用的是 cor
    函数。我们可以通过使用 eachcol 函数来获取数据框列的集合。
- en: You can plot a heatmap of a matrix by using the heatmap function from the Plots.jl
    package. This function is often used to display a correlation matrix.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用来自 Plots.jl 包的 heatmap 函数绘制矩阵的热图。这个函数通常用于显示相关矩阵。
- en: You can vertically concatenate data frames by using the vcat function. This
    operation is often needed in practice when you want to combine several source
    data frames into one.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 vcat 函数垂直连接数据框。在实际应用中，当你想将多个源数据框合并为一个时，这个操作通常很有必要。
- en: If you collect your data incrementally, you can use the append! and push! functions
    to add rows to your data frame dynamically. The append! function appends whole
    tables to a data frame, while push! adds a single row. These functions are often
    used when you want to store results of a simulation in a data frame.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你增量收集数据，可以使用 append! 和 push! 函数动态地向数据框中添加行。append! 函数将整个表附加到数据框中，而 push! 则添加一行。这些函数在你想将模拟的结果存储在数据框中时经常被使用。
- en: Sometimes you want to combine data that has different columns or different types
    of values in the columns. For this reason, vcat, append!, and push! support the
    cols keyword argument that governs how situations in which you do not have matching
    columns should be handled. Additionally, the append! and push! functions take
    the promote keyword argument that allows you to perform column type promotion
    in case you want to add to your data frame some data that does not have a type
    matching the element type of a column in a target data frame. These options are
    often used when working with real-life data that is of low quality and requires
    cleaning.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时您可能想要合并具有不同列或列中不同类型值的表格数据。因此，vcat、append! 和 push! 支持cols关键字参数，该参数控制在没有匹配列的情况下的处理方式。此外，append!
    和 push! 函数还接受 promote 关键字参数，允许您在想要向数据框添加一些与目标数据框中列的元素类型不匹配的数据时执行列类型提升。这些选项通常在处理质量较低且需要清理的现实生活数据时使用。
- en: You can use the unique function to de-duplicate rows of a data frame. This function
    is often used when cleaning data.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用独特的功能来去除数据框中的重复行。这个函数通常在清理数据时使用。
- en: You can serialize and deserialize Julia objects by using the Serialization module.
    This is a convenient method for short-term persistent storage of Julia objects.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过使用序列化模块来序列化和反序列化 Julia 对象。这是一种方便的方法，用于短期持久化存储 Julia 对象。
