- en: 17 Collective intelligence
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17 集体智慧
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Automated exploratory data analysis
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化探索性数据分析
- en: Conducting baseline EDA tasks with the `tableone` package
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`tableone`包执行基线EDA任务
- en: Performing advanced EDA operations with the `DataExplorer` and `SmartEDA` packages
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`DataExplorer`和`SmartEDA`包执行高级EDA操作
- en: Applying new functional and aesthetic techniques to `ggplot2` bar charts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将新的功能和美学技术应用于`ggplot2`条形图
- en: Our first purpose here is to establish who might be smarter—the small number
    of Las Vegas oddsmakers with advanced data science degrees who establish *opening*
    odds using very sophisticated algorithms where millions of dollars are at stake
    for the casinos they work for, or the thousands of gamblers, professionals and
    amateurs with skin in the game, who then wager their hard-earned money and, in
    the process, influence the *closing* odds.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里的第一个目的是确定谁可能更聪明——是那些拥有高级数据科学学位的少数拉斯维加斯赔率分析师，他们使用非常复杂的算法来设定*开盘*赔率，而这些赔率涉及他们为赌场工作的数百万美元，还是那些有切身利益的数千名赌徒、专业人士和业余爱好者，他们随后押注他们辛苦赚来的钱，并在这一过程中影响*收盘*赔率。
- en: For instance, on October 17, 2018, the Memphis Grizzlies played at the Indiana
    Pacers. The opening total from Las Vegas oddsmakers—that is, the estimated number
    of points to be scored by the Grizzlies and Pacers combined—was 209\. Wagers were
    then placed on what is otherwise known as the over/under until the betting line
    closed. Money wagered on the over comes from gamblers who think the Grizzlies
    and Pacers will score more than 209 points; money wagered on the under comes from
    gamblers who think the two teams will combine for fewer than 209 points. It doesn’t
    matter who wins, who loses, or what the final margin is; all that matters is whether
    or not the combined point total is greater than or less than 209.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，2018年10月17日，孟菲斯灰熊队在印第安纳活塞队的主场进行了比赛。拉斯维加斯赔率分析师的开盘总分——即灰熊队和活塞队预计的总得分——为209分。然后投注者对通常被称为上下盘的投注进行了投注，直到投注线关闭。投注在上盘的资金来自认为灰熊队和活塞队将得分超过209分的赌徒；投注在下盘的资金来自认为两队总得分将少于209分的赌徒。无论谁赢，谁输，或最终差距是多少；唯一重要的是总得分是否大于或小于209分。
- en: The opening total is meant to encourage even money on the over and the under.
    When that’s *not* the case, the opening total subsequently moves up or down—up
    to encourage more bets on the under and down to encourage additional bets on the
    over. With respect to the Grizzlies-Pacers game, the over/under closed at 204.5
    (this is also known as the closing total), which, of course, means most of the
    betting money was on the under as opposed to the over.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 开盘总分旨在鼓励投注在上下盘的金额相等。当这种情况*不是*发生时，开盘总分随后会上升或下降——上升以鼓励更多的下盘投注，下降以鼓励更多的上盘投注。就灰熊队与活塞队的比赛而言，总分收盘价为204.5（这也被称为收盘总分），这意味着大部分投注资金都投在了下盘，而不是上盘。
- en: The opening point spread—often called the opening spread, or just the spread—was
    Indiana -7, or Memphis +7\. In other words, the same Las Vegas oddsmakers estimated
    that Indiana would win by seven points (or that Memphis would lose by seven points).
    Money therefore wagered on the Pacers comes from gamblers who think the Pacers
    will win *and* win by more than seven points; money wagered instead on the Grizzlies
    comes from gamblers who think the Grizzlies will lose by fewer than seven points
    *or* maybe win outright.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 开盘点差——通常被称为开盘差分，或简称差分——是印第安纳-7，或孟菲斯+7。换句话说，同样的拉斯维加斯赔率分析师估计印第安纳将赢得七分（或者说孟菲斯将输掉七分）。因此，投注在活塞队上的钱来自认为活塞队将赢得*并且*赢得超过七分的赌徒；而投注在灰熊队上的钱来自认为灰熊队将输掉少于七分或可能直接赢得比赛的赌徒。
- en: Like the over/under, the opening spread is supposed to encourage equal amounts
    of money to be wagered on both teams—Indiana to cover or Memphis to cover. And
    like the over/under, the spread then moves based on actual bets. With regard to
    the Grizzlies-Pacers game, the spread closed at Indiana -7.5, which means most
    of the betting money (probably not much more than half) was on the Pacers to win
    and to win by more than seven points.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 与上下盘类似，开盘差分旨在鼓励在两支球队上投注的金额相等——印第安纳队覆盖或孟菲斯队覆盖。并且与上下盘类似，差分随后会根据实际投注进行调整。就灰熊队与活塞队的比赛而言，差分收盘价为印第安纳-7.5，这意味着大部分投注资金（可能不会超过一半）都投在了活塞队赢得比赛并赢得超过七分。
- en: The Pacers defeated the Grizzlies 111-83, which means that the closing total
    and the closing spread were nearer the final results than the opening total and
    the opening spread. At least with respect to this one game, the gamblers knew
    more than the oddsmakers. We’ll examine every NBA game from the 2018-19 regular
    season to see if this was the rule or just one exception to the rule.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 比赛者队以111-83击败了灰熊队，这意味着收盘总比分和收盘盘口比分比开盘总比分和开盘盘口比分更接近最终结果。至少就这场比赛而言，赌徒们比博彩公司知道得更多。我们将检查2018-19赛季的每一场NBA比赛，看看这是否是规则还是规则的例外。
- en: Our second purpose is to introduce ways that R makes exploratory data analysis
    (EDA) quick and easy; we’ll present and review three automated EDA packages and
    discuss their advantages and disadvantages versus more methodical EDA approaches.
    We’ll begin by loading our packages.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个目的是介绍R使探索性数据分析（EDA）变得快速和简单的方法；我们将介绍并回顾三个自动化的EDA包，并讨论它们与更系统化的EDA方法的优缺点。我们将从加载我们的包开始。
- en: 17.1 Loading packages
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.1 加载包
- en: 'We’ll wrangle our data with a combination of `dplyr` and `tidyr` functions
    and visualize our results with `ggplot2` bar charts and facet plots. Otherwise,
    we’ll sequentially explore our data through three automated EDA packages—`tableone`,
    `DataExplorer`, and `SmartEDA`—as shown here:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`dplyr`和`tidyr`函数的组合来整理我们的数据，并用`ggplot2`条形图和分面图来可视化我们的结果。否则，我们将通过三个自动化的EDA包——`tableone`、`DataExplorer`和`SmartEDA`——按顺序探索我们的数据，如下所示：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We’ll next import our one data set.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将导入我们的一个数据集。
- en: 17.2 Importing data
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.2 导入数据
- en: 'We import our data by making a call to the `read_csv()` function from the `readr`
    package and pass a file called 2018-2019 NBA_Box_Score_Team-Stats.csv that was
    downloaded from [www.bigdataball.com](https://www.bigdataball.com/) and subsequently
    stored in our default working directory. Our data set, at least for now, is called
    oddsdf1:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用`readr`包中的`read_csv()`函数并传递一个名为2018-2019 NBA_Box_Score_Team-Stats.csv的文件来导入我们的数据，该文件是从[www.bigdataball.com](https://www.bigdataball.com/)下载的，并随后存储在我们的默认工作目录中。我们的数据集，至少目前，被称为oddsdf1：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we pass oddsdf1 to the base R `dim()` function to return the row and
    column counts:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将oddsdf1传递给基础R的`dim()`函数以返回行和列计数：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Our data set contains 2,624 records and 57 variables, which is both more and
    less than what we need for our analysis. In other words, it contains rows and
    columns that won’t factor into our analysis, but it doesn’t (yet) contain other
    variables that we’ll instead have to derive ourselves. Thus, we’ll run several
    data wrangling operations to transform our raw data into an object that’s much
    more useful to us.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据集包含2,624条记录和57个变量，这既比我们分析所需的要多，又比我们需要的要少。换句话说，它包含不会影响我们分析的行和列，但（目前）它不包含我们将不得不自己推导的其他变量。因此，我们将运行几个数据整理操作，将我们的原始数据转换成一个对我们更有用的对象。
- en: 17.3 Wrangling data
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.3 数据整理
- en: 'We start by reducing the length of our data. The oddsdf1 data set contains
    records for the 2018-19 NBA regular season (which we want) and the 2019 playoffs
    (which we don’t want). So we make a call to the `filter()` function from the `dplyr`
    package to subset oddsdf1 on those observations where the variable `DATASET` doesn’t
    equal NBA 2019 Playoffs (the `!=` operator means not equal to):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过减少数据的长度开始。oddsdf1数据集包含2018-19 NBA常规赛（我们想要的）和2019季后赛（我们不想要的）的记录。因此，我们调用`dplyr`包中的`filter()`函数来对oddsdf1进行子集化，选择那些变量`DATASET`不等于NBA
    2019 Playoffs的观测值（`!=`运算符表示不等于）：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we reduce the width of our data. Although much of the data in oddsdf1
    is interesting, it’s hardly necessary for our purposes, so we call the `dplyr`
    `select()` function to subset oddsdf1 on just the few variables we absolutely
    require:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们减少数据宽度。尽管oddsdf1中的大部分数据很有趣，但对于我们的目的来说几乎不是必要的，所以我们调用`dplyr`的`select()`函数来对oddsdf1进行子集化，只保留我们绝对需要的少数变量：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Our surviving variables include the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保留的变量包括以下内容：
- en: '`GAME_ID`—A unique and sequential identifier for each game that increments
    by one chronologically using date and start time.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GAME_ID`——每个比赛的唯一和按时间顺序递增的标识符，使用日期和开始时间递增。'
- en: '`DATE`—The date of each game in mm/dd/yy format. This is now a character string.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DATE`——每场比赛的日期，格式为mm/dd/yy。现在这是一个字符字符串。'
- en: '`TEAM`—The abbreviated team name (e.g., Philadelphia rather than Philadelphia
    76ers, or Boston instead of Boston Celtics); the two teams based in Los Angeles,
    the LA Clippers and the LA Lakers, are the exceptions. This is now a character
    string.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TEAM`——简化的队伍名称（例如，费城而不是费城76人，或波士顿而不是波士顿凯尔特人）；洛杉矶的两支队伍，洛杉矶快船队和洛杉矶湖人队，是例外。现在是一个字符串。'
- en: '`VENUE`—Equals `R` for road teams and `H` for home teams. This is now a character
    string.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VENUE`——对于客队等于`R`，对于主队等于`H`。现在是一个字符串。'
- en: '`PTS`—Equals the total points scored for each participating team. This is now
    numeric and will remain numeric.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PTS`——等于每个参与队伍的总得分。现在它是数字，并将保持数字。'
- en: '`OPENING_SPREAD`—Equals the predicted point spread before any wagers have been
    placed. When the spread is, for instance, 4.5, the underdog must win outright
    or lose by 4 or fewer points to cover; when the spread is -4.5, the favorite must
    win by 5 or more points to cover. This is now numeric and will remain numeric.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OPENING_SPREAD`——等于任何投注都已下注之前的预测点差。当点差为例如4.5时，弱队必须直接获胜或以4分或更少的差距输掉比赛才能覆盖；当点差为-4.5时，强队必须以5分或更多的差距获胜才能覆盖。现在它是数字，并将保持数字。'
- en: '`OPENING_TOTAL`—Equals the predicted total points scored by the participating
    teams; also known as the over/under. Gamblers bet the over or under based on the
    actual number of combined points they expect to be scored. This is now numeric
    and will remain numeric.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OPENING_TOTAL`——等于参与队伍预测的总得分；也称为总分上下。赌徒们根据他们预期的总得分来下注总分上下。现在它是数字，并将保持数字。'
- en: '`CLOSING_SPREAD`—Equals the predicted point spread after all wagers have been
    placed and the betting line has closed. This is now numeric and will remain numeric.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLOSING_SPREAD`——等于所有投注都已下注并且投注线已关闭后的预测点差。现在它是数字，并将保持数字。'
- en: '`CLOSING_TOTAL`—Equals the predicted number of combined points after all wagers
    have been placed and the betting line has closed. This is now numeric and will
    remain numeric.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLOSING_TOTAL`——等于所有投注都已下注并且投注线已关闭后的预测总得分。现在它是数字，并将保持数字。'
- en: 'You might have figured out that oddsdf1 actually contains two records for each
    game. The top record pertains to the road team, and the bottom record pertains
    to the home team. Here are the specifics:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经发现，oddsdf1实际上每场比赛包含两条记录。上面的记录属于客队，下面的记录属于主队。以下是具体信息：
- en: The variables `GAME_ID` and `DATE` are the same for each pair of records. The
    first game of the 2018-19 regular season matched the Philadelphia 76ers at the
    Boston Celtics. Therefore, `GAME_ID` equals `21800001`, and `DATE` equals `10/16/18`
    for the first two oddsdf1 records.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量`GAME_ID`和`DATE`对于每对记录都是相同的。2018-19赛季常规赛的第一场比赛是费城76人对阵波士顿凯尔特人队。因此，`GAME_ID`等于`21800001`，`DATE`等于`10/16/18`对于前两条oddsdf1记录。
- en: The variables `TEAM`, `VENUE`, and `PTS` are unique to the road and home teams.
    The final score is therefore reflected in the two values under `PTS`.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量`TEAM`、`VENUE`和`PTS`对于客队和主队是唯一的。因此，最终得分反映在`PTS`下的两个值中。
- en: The variables `OPENING_SPREAD` and `CLOSING_SPREAD` are exact opposites of each
    other. For instance, if `OPENING_SPREAD` or `CLOSING_SPREAD` equals `4.5` for
    the road team, it equals `-4.5` for the home team.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量`OPENING_SPREAD`和`CLOSING_SPREAD`是彼此的相反数。例如，如果`OPENING_SPREAD`或`CLOSING_SPREAD`对于客队等于`4.5`，那么对于主队就等于`-4.5`。
- en: The variables `OPENING_TOTAL` and `CLOSING_TOTAL` are the same for each pair
    of records.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量`OPENING_TOTAL`和`CLOSING_TOTAL`对于每对记录都是相同的。
- en: However, this isn’t the structure we want or need; our analysis requires that
    our data set contains one record, not two, for each game. So our next order of
    business is to break oddsdf1 into two equal halves and then join the two halves
    by rows.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这不是我们想要的或需要的结构；我们的分析需要我们的数据集对于每场比赛只包含一条记录，而不是两条。因此，我们接下来的任务是将oddsdf1拆分为两个相等的部分，然后通过行将这两部分连接起来。
- en: 'To make this happen, we first call the `filter()` function again, this time
    to subset oddsdf1 where the variable `VENUE` equals `R`; our new object is called
    roadodds:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们首先再次调用`filter()`函数，这次是为了对oddsdf1进行子集化，其中变量`VENUE`等于`R`；我们新的对象称为roadodds：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, we pass roadodds via the pipe operator to the `rename()` function to
    rename every variable. The `rename()` function requires the *new* variable names
    to be left of the assignment operator and the *old* variable names to be on the
    right. For instance, we’re renaming `PTS` to `ptsR`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过管道操作符将roadodds传递给`rename()`函数，以重命名每个变量。`rename()`函数要求将*新*变量名放在赋值运算符的左边，将*旧*变量名放在右边。例如，我们将`PTS`重命名为`ptsR`：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, the remaining oddsdf1 records, where the variable `VENUE` equals `H`,
    are thrown into a new object called homeodds:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将变量`VENUE`等于`H`的剩余oddsdf1记录扔进一个新的对象中，称为homeodds：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We then subset homeodds so that it just includes the variables `TEAM`, `VENUE`,
    `PTS`, `OPENING_SPREAD`, and `CLOSING_SPREAD`. The variables `GAME_ID`, `DATE`,
    `OPENING_TOTAL`, and `CLOSING_TOTAL`, which are the same between each pair of
    oddsdf1 records, are contained in roadodds and are therefore not needed in homeodds
    as well:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将homeodds子集化，使其仅包括变量`TEAM`、`VENUE`、`PTS`、`OPENING_SPREAD`和`CLOSING_SPREAD`。变量`GAME_ID`、`DATE`、`OPENING_TOTAL`和`CLOSING_TOTAL`在每个oddsdf1记录对中都是相同的，包含在roadodds中，因此不需要在homeodds中重复：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The surviving homeodds variables are then renamed to distinguish them from
    their road team equivalents:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将幸存下来的homeodds变量重命名，以区分它们与道路队伍等价物的变量：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, we create a new object called oddsdf2 by calling the base R `cbind()`
    function, which joins roadodds and homeodds by rows into a single data set:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过调用基础R的`cbind()`函数创建一个新的对象，称为oddsdf2，该函数通过行将roadodds和homeodds合并成一个单一的数据集：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We then call the `dim()` function—oddsdf2 contains 1,230 rows and 14 columns.
    An NBA regular season schedule, where all 30 teams play 82 games, equals 1,230
    games, so this checks out:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们调用`dim()`函数——oddsdf2包含1,230行和14列。一个NBA常规赛赛程，其中所有30支球队各打82场比赛，等于1,230场比赛，所以这是正确的：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we call the base R `as.factor()` function to convert four of the five
    oddsdf2 character strings (all but the variable `date`) to factor variables:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用基础R的`as.factor()`函数将oddsdf2中的五个字符字符串中的四个（除了变量`date`）转换为因子变量：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We convert `date` from a character string to a date class by calling the `as.Date()`
    function from base R. The second argument to the `as.Date()` function is an instruction
    to R to keep the current mm/dd/yy format—for now:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用基础R的`as.Date()`函数将`date`从字符字符串转换为日期类。`as.Date()`函数的第二个参数是R保持当前mm/dd/yy格式的指令——目前是这样：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we create a new variable by passing oddsdf2 to the `dplyr mutate()` function;
    our new variable, called `month`, is derived from the variable `date`. For instance,
    where `date` equals `10/27/18`, `month` equals `October`; likewise, where `date`
    equals `2/9/19`, `month` equals `February`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过将oddsdf2传递给`dplyr mutate()`函数创建一个新变量；我们的新变量称为`month`，是从变量`date`派生出来的。例如，当`date`等于`10/27/18`时，`month`等于`October`；同样，当`date`等于`2/9/19`时，`month`等于`February`：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The 2018-19 NBA regular season started on October 16 and ended on April 10\.
    Therefore, October was the first month in the 2018-19 regular season schedule,
    November the second month, December the third month, and so on. That being said,
    we pass oddsdf2 to the `dplyr mutate``()` and `case_when()` functions—`mutate``()`
    creates another new variable and `case_when()` assigns conditional values to the
    cells. When the variable `month` equals `October`, our new variable, `month2`,
    should equal `1`; when `month` equals `November`, `month2` should instead equal
    `2`; and so forth.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 2018-19 NBA常规赛于10月16日开始，并于4月10日结束。因此，10月是2018-19常规赛赛程的第一个月，11月是第二个月，12月是第三个月，依此类推。话虽如此，我们将oddsdf2传递给`dplyr
    mutate()`和`case_when()`函数——`mutate()`创建另一个新变量，而`case_when()`将条件值分配给单元格。当变量`month`等于`October`时，我们的新变量`month2`应该等于`1`；当`month`等于`November`时，`month2`应该改为`2`；以此类推。
- en: 'Our new variable is then converted to a factor by calling the `as.factor()`
    function from base R:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将新变量通过调用基础R的`as.factor()`函数转换为因子：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We then call the `select()` function to drop the variables `ID`, `date`, and
    `month` from oddsdf2 (notice the minus signs in front of the variable names):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们调用`select()`函数从oddsdf2中删除变量`ID`、`date`和`month`（注意变量名前的减号）：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, let’s start to explore our data, immediately starting with the `tableone`
    package. This package was designed to return summary data on both continuous and
    categorical variables mixed within one table.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始探索我们的数据，立即从`tableone`包开始。这个包被设计用来在一个表中返回连续和分类变量的摘要数据。
- en: 17.4 Automated exploratory data analysis
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.4 自动化探索性数据分析
- en: Exploratory data analysis (EDA) is a combination of computing basic statistics
    and creating visual content to get an initial read on a data set and to establish
    a scope for further analysis. There are several R packages that allow us to automate
    EDA tasks, or at least to create more content with fewer lines of code versus
    a manual and more methodical EDA approach (see chapter 2, for instance).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 探索性数据分析（EDA）是计算基本统计信息和创建视觉内容相结合，以对数据集进行初步了解并确定进一步分析的范畴。有几个 R 包允许我们自动化 EDA 任务，或者至少与手动和更系统化的
    EDA 方法相比，用更少的代码创建更多内容（例如，参见第 2 章）。
- en: We’re going to demonstrate three of these packages. The first of these is called
    `tableone`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将演示这三个包中的三个。第一个包被称为 `tableone`。
- en: 17.4.1 Baseline EDA with tableone
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.4.1 使用 tableone 进行基线 EDA
- en: The `tableone` package was inspired by a typical *Table 1* found in many research
    publications, which usually includes several lines of summary statistics; as such,
    `tableone`, as you might have guessed, returns results in tabular format only
    and, therefore, doesn’t produce any visual representations of the data.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`tableone` 包的灵感来源于许多研究出版物中常见的典型 *表 1*，通常包括几行汇总统计信息；因此，`tableone`，正如你可能猜到的，只以表格格式返回结果，并且因此不会产生任何数据的视觉表示。'
- en: 'Maybe the most simple and straightforward EDA task is to summarize an entire
    data set. With `tableone`, we can do that by passing a data set, in this case
    oddsdf2, to the `CreateTableOne()` function. We subsequently get a stack of summary
    statistics returned when we then call the base R `print()` function (due to space
    considerations, some output isn’t included):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最简单直接的 EDA 任务就是总结整个数据集。使用 `tableone`，我们可以通过传递一个数据集，在这个例子中是 oddsdf2，到 `CreateTableOne()`
    函数中来实现这一点。随后，当我们调用基本的 R `print()` 函数时（由于空间考虑，一些输出没有包括在内），我们得到一系列的汇总统计信息：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'So here’s what we can glean just by running a single `tableone` function:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们只需运行单个 `tableone` 函数就能得到以下信息：
- en: The oddsdf2 data set contains 1,230 records.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: oddsdf2 数据集包含 1,230 条记录。
- en: All 30 teams played 41 road games and 41 home games during the 2018-19 regular
    season.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有 30 支球队在 2018-19 赛季中进行了 41 场客场比赛和 41 场主场比赛。
- en: Each team was therefore the road team in 3.3% of all 2018-19 regular season
    games and the home team in an additional 3.3% of all games.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，每支球队在所有 2018-19 赛季比赛中作为客场球队的比例为 3.3%，另外 3.3% 的比赛作为主队。
- en: Road teams averaged 109.85 points per game that year while home teams averaged
    112.57 points per game.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那一年，客场球队平均每场比赛得分为 109.85 分，而主队平均每场比赛得分为 112.57 分。
- en: The dispersion in points scored, represented by the standard deviation (`SD`)
    in the variables `ptsR` and `ptsH`, is about the same between road and home teams.
    This means that in roughly two-thirds of the 2018-19 regular season games, the
    road team scored approximately 110 plus or minus 13 points and the home team scored
    approximately 113 plus or minus 13 points.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 得分分布的离散程度，由变量 `ptsR` 和 `ptsH` 中的标准差（`SD`）表示，客场和主队之间大致相同。这意味着在 2018-19 赛季的比赛中，大约三分之二的情况下，客场球队得分大约为
    110 加减 13 分，而主队得分大约为 113 加减 13 分。
- en: The opening spread and especially the closing spread accurately represent the
    average margin in points scored per game between road and home teams.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开盘差值和尤其是收盘差值准确地代表了客场和主队之间每场比赛平均得分差。
- en: On average, the closing spread is slightly greater than the opening spread;
    home teams are favored more frequently than road teams.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平均来看，收盘差值略大于开盘差值；主队比客场队更受青睐。
- en: On average, there was almost no movement between the opening and closing totals;
    but that is probably not an accurate reflection of game-over-game variation.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平均来看，开盘和收盘之间的移动几乎为零；但这可能不是比赛间变化的准确反映。
- en: Finally, we get a breakdown of the regular season game count by month. Take
    away the partial months of October and April and the month of February, which,
    of course, has just 28 days and is further shortened because of the all-star break,
    and the regular season schedule appears to be equally spaced.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们得到了按月份划分的常规赛比赛次数的细分。去掉十月份和四月份的部分月份以及二月份，因为当然，二月只有 28 天，并且由于全明星赛而进一步缩短，常规赛赛程似乎均匀分布。
- en: The `summary()` function returns even more detail. Summary statistics on continuous
    variables, including the mean, median, minimum, and maximum values, and the first
    and third quartiles, are always returned first, followed by observation counts
    for the oddsdf2 categorical variables.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`summary()` 函数返回更多细节。连续变量的汇总统计量，包括均值、中位数、最小值、最大值以及第一和第三四分位数，总是首先返回，然后是 `oddsdf2`
    分类变量的观测计数。'
- en: 'But first, we disable scientific notation by passing the `scipen = 999` argument
    to the base R `options()` function (again, some results aren’t included due to
    space considerations):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们通过将 `scipen = 999` 参数传递给基础 R 的 `options()` 函数来禁用科学记数法（再次提醒，由于空间考虑，一些结果未包括在内）：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `summary()` function doesn’t return anything new and interesting with respect
    to the oddsdf2 categorical variables, but it does provide some additional insights
    on our continuous variables. For instance, we get the skewness (`skew`) and kurtosis
    (`kurt`) for each of those variables. Skewness represents the degree of distortion
    from a normal, or Gaussian, distribution; it therefore measures asymmetry in a
    data’s distribution. When negative, the distribution is negatively skewed or left-skewed;
    when positive, the distribution is positively skewed or right-skewed; and when
    equal to 0, the distribution is actually symmetrical. Skewness, then, could complement
    or even replace a Shapiro-Wilk test, where any results greater than 2 or less
    than -2 would qualify as non-normal distributions.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`summary()` 函数在 `oddsdf2` 的分类变量方面没有返回任何新的有趣内容，但它确实为我们的一些连续变量提供了一些额外的见解。例如，我们得到了每个变量的偏度（`skew`）和峰度（`kurt`）。偏度表示从正态分布或高斯分布的扭曲程度；因此，它衡量数据分布中的不对称性。当为负时，分布是负偏或左偏；当为正时，分布是正偏或右偏；当等于
    0 时，分布实际上是对称的。因此，偏度可以补充甚至取代 Shapiro-Wilk 测试，其中任何大于 2 或小于 -2 的结果都视为非正态分布。'
- en: Kurtosis, on the other hand, is a measure of how long, or not so long, the tails
    are in a distribution. When equal to or close to 0, the distribution is normal;
    when negative, the distribution has thin tails; and when positive, the distribution
    has fat tails.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，峰度是衡量分布中尾部长度或不是那么长的度量。当等于或接近 0 时，分布是正态的；当为负时，分布有瘦尾；当为正时，分布有胖尾。
- en: Next, we’ll plot some of these same distributions as part of a broader exercise
    to further explore our data through another automated EDA package called `DataExplorer`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将绘制一些相同的分布，作为更广泛练习的一部分，以通过另一个名为 `DataExplorer` 的自动化 EDA 包进一步探索我们的数据。
- en: 17.4.2 Over/under EDA with DataExplorer
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.4.2 使用 DataExplorer 进行盈亏 EDA
- en: Our scope for further EDA, at least for the time being, will be around the opening
    and closing totals, or the over/under; we’ll save the opening and closing point
    spreads for a subsequent EDA exercise with yet another package. That being said,
    we’ll create a new data set, oddsdf3, by subsetting oddsdf2, add five new oddsdf3
    variables, and then introduce the capabilities of the `DataExplorer` package to
    learn more about our data.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进一步 EDA 的范围，至少目前，将围绕开盘和收盘总点数，或盈亏；我们将把开盘和收盘点差保存为后续 EDA 练习，使用另一个包。话虽如此，我们将通过子集化
    `oddsdf2` 创建一个新的数据集 `oddsdf3`，添加五个新的 `oddsdf3` 变量，然后介绍 `DataExplorer` 包的功能，以了解更多关于我们的数据。
- en: Wrangling data
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 数据整理
- en: 'We create oddsdf3 by passing oddsdf2 to the `dplyr select()` function and subsetting
    oddsdf2 on 9 of its 13 variables:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将 `oddsdf2` 传递给 `dplyr select()` 函数并对 `oddsdf2` 的 13 个变量中的 9 个进行子集化来创建 `oddsdf3`：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we go about creating our new variables. The first of these, `ptsT`, is
    the total points scored per game between the road and home teams; therefore, we
    pass oddsdf3 to the `dplyr mutate()` function and sum the variables `ptsR` and
    `ptsH` to equal `ptsT`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们着手创建新的变量。其中第一个，`ptsT`，是客场和主队每场比赛的总得分；因此，我们将 `oddsdf3` 传递给 `dplyr mutate()`
    函数，并将变量 `ptsR` 和 `ptsH` 求和等于 `ptsT`：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Our second variable, `diff_ptsT_opentotal`, is the absolute difference between
    the variables `ptsT` and `opentotal`. The `abs()` function is a base R function
    that keeps positive numbers positive and converts negative numbers to positive:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个变量 `diff_ptsT_opentotal` 是变量 `ptsT` 和 `opentotal` 之间的绝对差值。`abs()` 函数是一个基础
    R 函数，它保持正数不变，并将负数转换为正数：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Our third variable, `diff_ptsT_closetotal`, is the absolute difference between
    the variables `ptsT` and `closetotal`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第三个变量 `diff_ptsT_closetotal` 是变量 `ptsT` 和 `closetotal` 之间的绝对差值：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Our fourth variable requires that we combine the `mutate()` function with the
    `case_when()` function. When `closetotal` is greater than `opentotal`, our new
    variable, `totalmove`, should equal `up`; when `closetotal` is less than `opentotal`,
    `totalmove` should equal `down`; and when `closetotal` equals `opentotal`, `totalmove`
    should equal `same`. Then, we call the `as.factor()` function to convert `totalmove`
    to a factor variable; after all, it can assume just one of three potential values:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第四个变量要求我们将 `mutate()` 函数与 `case_when()` 函数结合使用。当 `closetotal` 大于 `opentotal`
    时，我们的新变量 `totalmove` 应等于 `up`；当 `closetotal` 小于 `opentotal` 时，`totalmove` 应等于
    `down`；当 `closetotal` 等于 `opentotal` 时，`totalmove` 应等于 `same`。然后，我们调用 `as.factor()`
    函数将 `totalmove` 转换为因子变量；毕竟，它只能假设三个潜在值中的一个：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Our fifth variable, `versusPTS`, also requires `mutate``()` in combination
    with `case_when``().` When `diff_ptsT_opentotal` is greater than `diff_ptsT_closetotal`,
    or when the absolute difference between total points scored and the opening total
    is greater than the absolute difference between total points scored and the closing
    total, `versusPTS` should equal `closetotal`. When the opposite condition is true,
    `versusPTS` should instead equal `opentotal`. And when there’s no difference between
    `diff_ptsT_opentotal` and `diff_ptsT_closetotal`, the new variable `versusPTS`
    should equal `same`. Then, we convert `versusPTS` to a factor variable by once
    more calling the `as.factor()` function:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第五个变量 `versusPTS` 也需要 `mutate()` 与 `case_when()` 结合使用。当 `diff_ptsT_opentotal`
    大于 `diff_ptsT_closetotal`，或者当总得分与开盘总得分之间的绝对差值大于总得分与收盘总得分之间的绝对差值时，`versusPTS` 应等于
    `closetotal`。当相反的条件成立时，`versusPTS` 应该等于 `opentotal`。当 `diff_ptsT_opentotal` 与
    `diff_ptsT_closetotal` 之间没有差异时，新的变量 `versusPTS` 应等于 `same`。然后，我们再次通过调用 `as.factor()`
    函数将 `versusPTS` 转换为因子变量：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As a result of all this wrangling, the oddsdf3 variables aren’t necessarily
    sequenced left to right in any logical order. One way of rearranging the variable
    order in R is to simply call the `select()` function. Rather than instructing
    `select()` to subset our data, we’ll pass *every* oddsdf3 variable—actually, their
    current position numbers—to the `select()` function and, by doing so, R will then
    rearrange the variables in the order by which the variables are passed as arguments.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有这些处理，`oddsdf3` 变量不一定按逻辑顺序从左到右排序。在 R 中重新排列变量顺序的一种方法就是简单地调用 `select()` 函数。我们不会指示
    `select()` 对我们的数据进行子集化，而是将 *所有* 的 `oddsdf3` 变量——实际上，它们的当前位置编号——传递给 `select()`
    函数，通过这样做，R 将根据变量作为参数传递的顺序重新排列变量。
- en: 'A call to the `head()` function from base R returns the top six records:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从基础 R 调用 `head()` 函数返回前六条记录：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We now have a data set by which we can readily compare and contrast opening
    and closing totals against total points scored.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个数据集，我们可以用它轻松地比较和对比开盘和收盘总得分与总得分。
- en: Creating the data profiling report
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数据概要报告
- en: 'Let’s now introduce the `DataExplorer` package. We previously suggested that
    the most encompassing EDA activity—summarizing an entire data set—might also be
    the most basic. By passing the oddsdf3 data set to the `DataExplorer create_report()`
    function, we actually get a comprehensive data profiling report in the form of
    an interactive HTML file (see figure 17.1). The `create_report()` function automatically
    runs many of the `DataExplorer` EDA functions and then stacks the results, not
    in the RStudio Console, but rather in a standalone report that can be saved and
    shared:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们介绍 `DataExplorer` 包。我们之前建议，最全面的 EDA 活动——总结整个数据集——可能也是最基础的。通过将 `oddsdf3`
    数据集传递给 `DataExplorer create_report()` 函数，我们实际上得到了一个综合的数据概要报告，形式为一个交互式 HTML 文件（见图
    17.1）。`create_report()` 函数自动运行许多 `DataExplorer` EDA 函数，并将结果堆叠，不是在 RStudio 控制台中，而是在一个可以保存和共享的独立报告中：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![CH17_F01_Sutton](../../OEBPS/Images/CH17_F01_Sutton.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![CH17_F01_Sutton](../../OEBPS/Images/CH17_F01_Sutton.png)'
- en: Figure 17.1 A screen capture of a data profiling report that was created by
    passing a data set as the only argument to a simple function from the `DataExplorer`
    package
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.1 由 `DataExplorer` 包中的简单函数通过传递数据集作为唯一参数创建的数据概要报告的屏幕截图
- en: If *cool* is synonymous with effortless style, then the `DataExplorer` package
    is most definitely a head turner. While we absolutely created more with less—that
    is, more content, most of it visual, with less code and therefore requiring less
    time and effort than a manual alternative—some of the content (most of which we’re
    about to share) doesn’t actually add any value—and that’s the trade-off. Are you
    under the gun to put something in front of your boss, even if it’s a mix of relevant
    and not-so-relevant content? Or would you—and your boss—be better served by a
    more surgical approach?
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果说 *酷* 是指轻松的风格，那么 `DataExplorer` 包绝对是一个引人注目的选择。虽然我们确实以更少的代码（即更多的内容，大部分是视觉的，更少的代码，因此需要更少的时间和精力）创造了更多内容，但其中一些内容（其中大部分我们即将分享）实际上并没有增加任何价值——这就是权衡。你是在压力下向老板展示一些内容，即使这些内容既有相关的也有不那么相关的吗？或者你和你老板是否更倾向于一种更精确的方法？
- en: Consider the EDA from chapter 2\. That necessitated a lot of brainpower and
    a lot of code, but every plot communicated a relevant message. There wasn’t a
    bit of noise. The message here is that manual and automated EDA approaches both
    have their pros and cons; depending on the project and mitigating factors, you’ll
    have to decide what works best for you.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑第 2 章中的 EDA。这需要大量的脑力劳动和大量的代码，但每个图表都传达了一个相关的信息。没有一点噪音。这里的信息是，手动和自动 EDA 方法都有其优缺点；根据项目和缓解因素，你将不得不决定哪种最适合你。
- en: Let’s now explore the content we get from the data profiling report.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来探索从数据概览报告中获得的内容。
- en: Basic statistics
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 基本统计信息
- en: 'The data profiling report first displays a graphical representation of some
    basic statistics: how our data set is split between categorical and continuous
    variables and how much missing data we might have. We can produce this visualization
    by passing oddsdf3 to the `plot_intro()` function (see figure 17.2):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 数据概览报告首先显示一些基本统计信息的图形表示：我们的数据集在分类变量和连续变量之间的分布情况以及可能存在的缺失数据量。我们可以通过将 `oddsdf3`
    传递给 `plot_intro()` 函数来生成这种可视化（见图 17.2）：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![CH17_F02_Sutton](../../OEBPS/Images/CH17_F02_Sutton.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![CH17_F02_Sutton](../../OEBPS/Images/CH17_F02_Sutton.png)'
- en: Figure 17.2 A graphical display of basic statistics on a data set from the `DataExplorer`
    package
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.2 `DataExplorer` 包中数据集的基本统计信息的图形显示
- en: Note that only `create_report``()` publishes results in a standalone report;
    when you run individual commands such as `plot_intro()` that are otherwise packed
    into the `create_report()` function, the results are instead displayed in RStudio.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，只有 `create_report()` 会发布独立的报告；当你运行 `plot_intro()` 等单独的命令，这些命令通常打包在 `create_report()`
    函数中时，结果会在 RStudio 中显示。
- en: 'We also can get the same in tabular format by passing oddsdf3 to the `introduce()`
    function:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过将 `oddsdf3` 传递给 `introduce()` 函数来以表格格式获取相同信息：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Half of the 14 oddsdf3 variables are continuous, and the other half are categorical
    (or discrete). In addition, we have no missing data.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 14 个 `oddsdf3` 变量中，有一半是连续的，另一半是分类的（或离散的）。此外，我们没有缺失数据。
- en: Data structure
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构
- en: 'There are two ways of getting a graphical representation of a data set’s structure—basically,
    a visual alternative to the `dplyr glimpse()` function. One way is to call the
    `plot_str()` function (see figure 17.3):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 获取数据集结构的图形表示有两种方式——基本上，是 `dplyr glimpse()` 函数的视觉替代。一种方式是调用 `plot_str()` 函数（见图
    17.3）：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![CH17_F03_Sutton](../../OEBPS/Images/CH17_F03_Sutton.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![CH17_F03_Sutton](../../OEBPS/Images/CH17_F03_Sutton.png)'
- en: Figure 17.3 A visual representation of a data set’s structure. The base R `str()`
    function and `dplyr` `glimpse()` function both return similar information, but
    not in a graphical format.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.3 数据集结构的视觉表示。基本的 R `str()` 函数和 `dplyr` `glimpse()` 函数都返回类似的信息，但不是以图形格式。
- en: 'The second way is to again call `plot_str()`, but to then add the `type = "r"`
    argument, which tells R to plot the data structure in the form of a radial network
    (see figure 17.4):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方式是再次调用 `plot_str()`，但添加 `type = "r"` 参数，这告诉 R 以径向网络的形式绘制数据结构（见图 17.4）：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![CH17_F04_Sutton](../../OEBPS/Images/CH17_F04_Sutton.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![CH17_F04_Sutton](../../OEBPS/Images/CH17_F04_Sutton.png)'
- en: Figure 17.4 A visual representation of the same data structure, but in the form
    of a radial network. This and the previous view are made possible by the `DataExplorer`
    package.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.4 以径向网络的形式展示了相同的数据结构。这两种视图都是通过 `DataExplorer` 包实现的。
- en: Either way, we see that `month2`, for instance, is a factor variable with seven
    levels and that `closetotal` is one of the seven oddsdf3 continuous (or numeric)
    variables.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，我们都可以看到例如 `month2` 是一个有七个级别的因子变量，而 `closetotal` 是七个连续（或数值）变量之一。
- en: Missing data profile
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 缺失数据概览
- en: 'By previously running the `plot_intro()` and `introduce()` functions, we already
    know that oddsdf3 doesn’t contain any missing data. But if the opposite were true,
    neither of those functions would tell us anything *specific* about Not Availables
    (NAs) or incomplete observations in our data set. But the `plot_missing()` function
    returns a visualization that displays the missing values profile by variable (see
    figure 17.5):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过之前运行 `plot_intro()` 和 `introduce()` 函数，我们已经知道 oddsdf3 不包含任何缺失数据。但如果情况相反，那么这些函数都不会告诉我们关于数据集中不可用（NAs）或不完整观测的任何具体信息。但
    `plot_missing()` 函数返回一个可视化，显示每个变量的缺失值概览（见图 17.5）：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![CH17_F05_Sutton](../../OEBPS/Images/CH17_F05_Sutton.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![CH17_F05_Sutton](../../OEBPS/Images/CH17_F05_Sutton.png)'
- en: Figure 17.5 A `DataExplorer` plot that provides a missing values profile
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.5 `DataExplorer` 绘制的提供缺失值概览的图
- en: Univariate distribution
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 单变量分布
- en: There are three methods of plotting the distribution of continuous data with
    `DataExplorer`. When we run the `create_report()` function, `DataExplorer` automatically
    detects which variables are continuous and then returns histograms and quantile-quantile
    (QQ) plots for each. In addition, we have the option of telling `DataExplorer`
    to print density plots in lieu of or in addition to histograms or QQ plots.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `DataExplorer` 有三种方法来绘制连续数据的分布。当我们运行 `create_report()` 函数时，`DataExplorer`
    会自动检测哪些变量是连续的，然后为每个变量返回直方图和分位数-分位数（QQ）图。此外，我们还可以选择告诉 `DataExplorer` 在直方图或 QQ 图之外或与之一起打印密度图。
- en: 'The `plot_histogram()` function returns a matrix of histograms that displays
    frequency distributions for each of our continuous variables (see figure 17.6).
    By default, `DataExplorer` usually returns plots in alphabetical order by variable
    name:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot_histogram()` 函数返回一个直方图矩阵，显示我们每个连续变量的频率分布（见图 17.6）。默认情况下，`DataExplorer`
    通常按变量名字母顺序返回绘图：'
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![CH17_F06_Sutton](../../OEBPS/Images/CH17_F06_Sutton.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![CH17_F06_Sutton](../../OEBPS/Images/CH17_F06_Sutton.png)'
- en: Figure 17.6 A matrix of histograms from the `DataExplorer` package
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.6 `DataExplorer` 包的直方图矩阵
- en: Some of our continuous variables appear to be normally distributed, or at least
    close enough, but the variables `diff_ptsT_closetotal` and `diff_ptsT_opentotal`
    are clearly right-skewed.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的一些连续变量似乎呈正态分布，或者至少足够接近，但变量 `diff_ptsT_closetotal` 和 `diff_ptsT_opentotal`
    明显是右偏斜的。
- en: 'The `plot_qq()` function returns a matrix of QQ plots (see figure 17.7). When
    data is normally distributed, or at least close enough to assuming a Gaussian
    distribution, the points will fall on top of or very near the diagonal line in
    a QQ plot; otherwise, we’ll instead observe points at one or both tails that deviate,
    sometimes significantly so, from a QQ plot diagonal line (e.g., see `diff_ptsT_closetotal`
    and `diff_ptsT_opentotal`):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot_qq()` 函数返回一个 QQ 图矩阵（见图 17.7）。当数据呈正态分布，或者至少足够接近假设高斯分布时，点将落在 QQ 图的对角线上或非常接近对角线；否则，我们会在
    QQ 图的一侧或两侧观察到偏离对角线的点，有时偏离程度很大（例如，参见 `diff_ptsT_closetotal` 和 `diff_ptsT_opentotal`）：'
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![CH17_F07_Sutton](../../OEBPS/Images/CH17_F07_Sutton.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![CH17_F07_Sutton](../../OEBPS/Images/CH17_F07_Sutton.png)'
- en: Figure 17.7 A matrix of QQ plots from the `DataExplorer` package
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.7 `DataExplorer` 包的 QQ 图矩阵
- en: Finally, the `plot_density()` function returns a series of density plots (see
    figure 17.8).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`plot_density()` 函数返回一系列密度图（见图 17.8）。
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![CH17_F08_Sutton](../../OEBPS/Images/CH17_F08_Sutton.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![CH17_F08_Sutton](../../OEBPS/Images/CH17_F08_Sutton.png)'
- en: Figure 17.8 A matrix of density plots from the `DataExplorer` package
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.8 `DataExplorer` 包的密度图矩阵
- en: The data profiling report, by default, calls the `plot_histogram()`, `plot_qq()`,
    and `plot_density()` functions, and therefore returns three series of like visualizations
    on the same variables, so we get three views into frequency distributions when
    often just one will suffice. That being said, many statistical tests, such as
    linear regression, for instance (see chapter 5), assume normality in numeric data,
    so understanding frequency distributions first is absolutely critical.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，数据概览报告会调用`plot_histogram()`、`plot_qq()`和`plot_density()`函数，因此对于同一变量返回三个类似的可视化系列，所以我们得到了三个关于频率分布的视角，而通常一个就足够了。尽管如此，许多统计测试，例如线性回归（见第5章），假设数值数据是正态分布的，因此首先理解频率分布是绝对关键的。
- en: Correlation analysis
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 相关性分析
- en: 'When we make a call to the `DataExplorer plot_correlation()` function, we get
    a correlation matrix, or heat map, returned with the computed correlation coefficients
    added as data labels (see figure 17.9). By default, the `create_report()` function
    adds a correlation heat map to the data profiling report that includes continuous
    *and* categorical variables. By adding `type = "c"` as a second argument, we’re
    manually limiting the results to the oddsdf3 continuous variables only:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`DataExplorer plot_correlation()`函数时，我们得到一个相关矩阵，或热图，其中包含计算出的相关系数作为数据标签（见图17.9）。默认情况下，`create_report()`函数会将相关热图添加到数据概览报告中，包括连续和分类变量。通过将`type
    = "c"`作为第二个参数添加，我们手动将结果限制为仅包含oddsdf3连续变量：
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '![CH17_F09_Sutton](../../OEBPS/Images/CH17_F09_Sutton.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![CH17_F09_Sutton](../../OEBPS/Images/CH17_F09_Sutton.png)'
- en: Figure 17.9 A correlation matrix, or heat map, from the `DataExplorer` package;
    by default, correlation heat maps include all variables, continuous or categorical.
    Here, we’ve limited the results to include the oddsdf3 continuous variables only.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.9 来自`DataExplorer`包的相关矩阵或热图；默认情况下，相关热图包括所有变量，无论是连续的还是分类的。在这里，我们已将结果限制为仅包含oddsdf3连续变量。
- en: What’s especially nice about the `plot_correlation()` function is that `DataExplorer`
    automatically ignores any missing values and then generates the heat map anyway.
    Note that the correlation coefficients between `closetotal` and `ptsR`, `ptsH`,
    and `ptsT` are (slightly) higher than the correlation coefficients between `opentotal`
    and these same three variables.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot_correlation()`函数特别令人满意的是，`DataExplorer`会自动忽略任何缺失值，然后仍然生成热图。请注意，`closetotal`与`ptsR`、`ptsH`和`ptsT`之间的相关系数（略微）高于`opentotal`与这三个相同变量的相关系数。'
- en: Categorical variable analysis
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 分类变量分析
- en: 'Finally, let’s pivot and tell `DataExplorer` to provide some visual insights
    into the oddsdf3 categorical variables. The data profiling report that is generated
    by calling the `create_report()` function automatically contains bar charts for
    every categorical variable as a means of visualizing frequencies, or counts. We
    can replicate that automation by passing the oddsdf3 data set to the `plot_bar()`
    function (see figure 17.10):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们转换一下思路，告诉`DataExplorer`提供一些关于oddsdf3分类变量的可视化洞察。通过调用`create_report()`函数生成的数据概览报告自动包含每个分类变量的条形图，作为可视化频率或计数的手段。我们可以通过将oddsdf3数据集传递给`plot_bar()`函数来复制这种自动化（见图17.10）：
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![CH17_F10_Sutton](../../OEBPS/Images/CH17_F10_Sutton.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![CH17_F10_Sutton](../../OEBPS/Images/CH17_F10_Sutton.png)'
- en: Figure 17.10 `DataExplorer` bar charts for every oddsdf3 categorical variable
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.10 `DataExplorer`为每个oddsdf3分类变量生成的条形图
- en: 'But as you can see, some of these plots are absolutely meaningless and, of
    course, would never be generated if it weren’t for automation. There are a couple
    of interesting takeaways, however, after sifting through the noise:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，正如你所见，其中一些图表毫无意义，当然，如果不是自动化，这些图表根本就不会生成。然而，在筛选掉噪音之后，有几个有趣的发现：
- en: The opening total was greater than the closing total almost as frequently as
    the closing total was greater than the opening total. Otherwise, they were the
    same about 100 times out of 1,230 games in our data set.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的数据集中，开盘总价比收盘总价更高的频率几乎与收盘总价比开盘总价更高的频率相同。否则，它们在大约1,230场比赛中有大约100次是相同的。
- en: More significantly for our purposes, the margin between the closing total (the
    over/under when the betting line closed) and total points scored was usually less
    than the margin between the opening total (the over/under when the betting line
    opened) and total points scored. This suggests that the closing total (influenced
    by gamblers) more frequently performed better than the opening total (generated
    by oddsmakers and their algorithms).
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于我们的目的来说，收盘总分数（在投注线关闭时的总分上下）与总得分之间的差距通常小于开盘总分数（在投注线开盘时的总分上下）与总得分之间的差距。这表明收盘总分数（受赌徒影响）比开盘总分数（由赔率制定者和他们的算法生成）更频繁地表现更好。
- en: 'It’s also possible to create a series of bar charts grouped by a discrete variable.
    In the line of code that follows, we create six stacked bar charts by the variable
    `month2` (see figure 17.11):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过按离散变量分组创建一系列条形图。在下面的代码行中，我们通过变量`month2`创建了六个堆叠条形图（见图17.11）：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![CH17_F11_Sutton](../../OEBPS/Images/CH17_F11_Sutton.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![CH17_F11_Sutton](../../OEBPS/Images/CH17_F11_Sutton.png)'
- en: Figure 17.11 Another series of `DataExplorer` bar charts, but these are stacked
    due to being grouped by the oddsdf3 variable `month2`
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.11 另一系列`DataExplorer`条形图，但这些由于按oddsdf3变量`month2`分组而堆叠
- en: A close examination of the `totalmove` and `versusPTS` stacked bar charts suggests
    month-over-month performance variances between or across the factor levels of
    those two variables.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对`totalmove`和`versusPTS`堆叠条形图的仔细观察表明，这两个变量的因素水平之间存在或跨月度的性能差异。
- en: Aside from the principal components analysis, which we purposely kept out of
    scope, we otherwise demonstrated almost every `DataExplorer` function; in the
    process, we gained some insights into our data and established a scope for further
    analysis. We’ll get to that additional analysis soon enough, but in the meantime,
    we’re going to explore opening and closing point spreads with the help of yet
    another automated EDA package.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们故意将其排除在范围之外的成分分析之外，我们几乎演示了几乎所有的`DataExplorer`函数；在这个过程中，我们获得了对数据的洞察，并为进一步分析建立了一个范围。我们将很快进行这项额外分析，但在此期间，我们将借助另一个自动化的EDA包来探索开盘和收盘点差。
- en: 17.4.3 Point spread EDA with SmartEDA
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.4.3 使用SmartEDA进行点差EDA
- en: Our new scope will be around the opening and closing point spreads and how they
    compare to final scores. We’ll first create a new data set subset from oddsdf2,
    add some derived variables, and then explore the data with a package called `SmartEDA`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新范围将围绕开盘和收盘点差以及它们与最终得分的比较。我们首先从oddsdf2创建一个新的数据集子集，添加一些派生变量，然后使用名为`SmartEDA`的包来探索数据。
- en: Wrangling data
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 数据整理
- en: 'By making a call to the `dplyr select()` function, we subset the oddsdf2 data
    set and pass the results to a new data set called oddsdf4:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`dplyr select()`函数，我们选取了oddsdf2数据集的子集，并将结果传递给一个新的数据集，称为oddsdf4：
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, we go about creating our new variables and appending each of them to
    oddsdf4\. The first of these, called `margin`, is a continuous variable that equals
    the difference between `ptsR` and `ptsH`, or the difference between the number
    of points scored between the road and home teams:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们着手创建新的变量，并将它们逐一附加到oddsdf4上。其中第一个，称为`margin`，是一个连续变量，等于`ptsR`和`ptsH`之间的差值，或者说是客场和主队得分之间的差值：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Our second new variable, `diff_margin_openspreadH`, equals the absolute difference
    between the variables `margin` and `openspreadH`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个新变量`diff_margin_openspreadH`等于变量`margin`和`openspreadH`之间的绝对差值：
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Our third variable, `diff_margin_closespreadH`, equals the absolute difference
    between the variables `margin` and `closespreadH`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第三个变量`diff_margin_closespreadH`等于变量`margin`和`closespreadH`之间的绝对差值：
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Our fourth and final variable, `spreadmove`, again requires that we call the
    `mutate()` function in tandem with the `case_when()` function. When the absolute
    value of `closespreadH` is greater than the absolute value of `openspreadH`, `spreadmove`
    should then equal `up`; from the perspective of home teams, then, when the absolute
    value of the closing spread is greater than the absolute value of the opening
    spread (it went, e.g., from 6 to 7 or -6 to -7), `spreadmove` should equal `up`.
    When the opposite condition is true, `spreadmove` should instead equal `down`.
    And, when there is no difference in the absolute values of opening and closing
    spreads, then `spreadmove` should equal `same`. Because `spreadmove` should be
    a categorical variable, we then call the `as.factor()` function to make it just
    that:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第四个也是最后一个变量`spreadmove`再次要求我们同时调用`mutate()`函数和`case_when()`函数。当`closespreadH`的绝对值大于`openspreadH`的绝对值时，`spreadmove`应等于`up`；从主队的角度来看，当收盘价差值的绝对值大于开盘价差值的绝对值（例如，从6变为7或从-6变为-7）时，`spreadmove`应等于`up`。当条件相反时，`spreadmove`应改为等于`down`。当开盘价差和收盘价差的绝对值没有差异时，`spreadmove`应等于`same`。因为`spreadmove`应该是一个分类变量，所以我们调用`as.factor()`函数使其成为那样：
- en: '[PRE42]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We then call the `select()` function to rearrange the oddsdf4 variables in
    a more logical order. A subsequent call to the `head()` function returns the top
    six oddsdf4 records:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后调用`select()`函数来重新排列oddsdf4变量，使其更有逻辑性。随后调用`head()`函数返回前六个oddsdf4记录：
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Creating the EDA report
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 创建EDA报告
- en: The `SmartEDA` package is a cross of sorts between `tableone` and `DataExplorer`
    because it returns results in both tabular and graphical formats. But all things
    considered, `SmartEDA` bears more of a resemblance to `DataExplorer`; one reason
    is that, as we did with `DataExplorer`, we can also create an interactive HTML
    report that automatically aggregates other `SmartEDA` EDA functions into one function.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`SmartEDA`包是`tableone`和`DataExplorer`的某种结合，因为它以表格和图形两种格式返回结果。但综合考虑，`SmartEDA`更类似于`DataExplorer`；一个原因是我们像使用`DataExplorer`一样，也可以创建一个交互式的HTML报告，该报告会自动将其他`SmartEDA`
    EDA函数聚合到一个函数中。'
- en: However, you’ll readily notice that the `SmartEDA` functions aren’t as intuitive
    or as simple as their `DataExplorer` equivalents. In addition, many of these same
    functions, when run manually, work best when you first break up your data set
    or just ask `SmartEDA` to output a random sample; we didn’t have to do either
    with the `DataExplorer` package, or even the `tableone` package, for that matter.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你会很快注意到，`SmartEDA`函数并不像它们的`DataExplorer`等价函数那样直观或简单。此外，许多这些相同的函数在手动运行时，最好首先拆分你的数据集或让`SmartEDA`输出一个随机样本；我们不需要使用`DataExplorer`包，甚至`tableone`包也不需要这样做。
- en: 'In any event, we get a `SmartEDA` HTML report by passing two mandatory arguments,
    the oddsdf4 data set and the output file name, to the `ExpReport()` function (see
    figure 17.12). This will take several seconds to run:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 不论如何，我们通过向`ExpReport()`函数（参见图17.12）传递两个必填参数，即oddsdf4数据集和输出文件名，来获取`SmartEDA`
    HTML报告。这需要几秒钟的时间来运行：
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '![CH17_F12_Sutton](../../OEBPS/Images/CH17_F12_Sutton.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![CH17_F12_Sutton](../../OEBPS/Images/CH17_F12_Sutton.png)'
- en: Figure 17.12 The top of an interactive HTML EDA report from the `SmartEDA` package
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.12 `SmartEDA`包的交互式HTML EDA报告的顶部
- en: Overview of the data
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 数据概述
- en: '`SmartEDA` aggregates the following functions and bundles the outputs in the
    standalone HTML file we just created. Otherwise, when we pass oddsdf4 and the
    `type = 1` argument to the `ExpData()` function, `SmartEDA` returns a high-level
    overview of our data in the form of a table. We get the dimension, the number
    of variables for each class, and information around missing cases published in
    RStudio:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`SmartEDA`聚合以下功能，并将输出捆绑在我们刚刚创建的独立HTML文件中。否则，当我们向`ExpData()`函数传递oddsdf4和`type
    = 1`参数时，`SmartEDA`会以表格的形式返回我们数据的高级概述。我们得到维度、每个类的变量数量以及RStudio中发布的关于缺失案例的信息：'
- en: '[PRE45]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When we instead pass the `type = 2` argument to the `ExpData()` function, `SmartEDA`
    returns the structure of our data, namely, the oddsdf4 variable names, their type,
    the row counts, and more information around missing data (of which there is none,
    of course):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向`ExpData()`函数传递`type = 2`参数时，`SmartEDA`返回我们数据的结构，即oddsdf4变量名、它们的类型、行数以及更多关于缺失数据的信息（当然，没有缺失数据）：
- en: '[PRE46]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Summary of continuous variables
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 连续变量摘要
- en: We get a summary of the oddsdf4 continuous variables by calling the `ExpNumStat()`
    function. By adding the `Outlier = TRUE` argument, we’re instructing `SmartEDA`
    to return the lower hinge, upper hinge, and number of outliers in our data, among
    other measures that we get by default. The lower hinge (LB.25%) is the median
    of the lower half of the data up to and including the median; the upper hinge
    (UB.75%) is the median of the upper half of the data up to and including the median;
    we otherwise know these as the lower and upper quartiles. In addition, by adding
    `round = 2` as a second argument, we’re telling `SmartEDA` to return all the results
    with just two digits right of the decimal point.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 `ExpNumStat()` 函数，我们可以得到 oddsdf4 连续变量的摘要。通过添加 `Outlier = TRUE` 参数，我们指示
    `SmartEDA` 返回除了默认获取的其他度量之外的数据的较低枢纽、较高枢纽和异常值数量。较低枢纽（LB.25%）是数据下半部分的中位数，包括中位数本身；较高枢纽（UB.75%）是数据上半部分的中位数，包括中位数本身；我们通常将这些称为下四分位数和上四分位数。此外，通过添加
    `round = 2` 作为第二个参数，我们告诉 `SmartEDA` 只返回小数点后两位的所有结果。
- en: 'There’s a lot more to unpack here, but let’s take a look at the nNeg, nZero,
    and nPos measures—these amount to, respectively, the number of records where each
    variable equals either a negative number, zero, or a positive number. The variables
    `openspreadH` and `closespreadH` equal negative numbers for almost two-thirds
    of the 1,230 oddsdf4 records, which means that the home team opened and/or closed
    as the favorite in almost 66% of the games during the 2018-19 NBA regular season.
    Now take a look at these same measures with respect to the derived variable `margin`,
    which is equal to `ptsR` minus `ptsH`: `margin` is negative just 729 times, corresponding
    to about 59% of the records. This aligns very well with what we learned back in
    chapter 9—that home teams win about 58% to 59% of all regular season games:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有更多内容需要解析，但让我们来看看 nNeg、nZero 和 nPos 度量——这些分别代表每个变量等于负数、零或正数的记录数量。变量 `openspreadH`
    和 `closespreadH` 在 1,230 条 oddsdf4 记录中几乎三分之二的情况下等于负数，这意味着在 2018-19 NBA 常规赛季的比赛中，主队几乎在
    66% 的情况下开盘或收盘作为热门。现在来看看这些相同的度量与派生变量 `margin` 的关系，`margin` 等于 `ptsR` 减去 `ptsH`：`margin`
    只有 729 次为负，对应大约 59% 的记录。这与我们在第 9 章中学到的非常吻合——主队赢得大约 58% 到 59% 的所有常规赛季比赛：
- en: '[PRE47]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Distributions of continuous variables
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 连续变量的分布
- en: 'Most of the remaining `SmartEDA` content is visual. A call to the `ExpOutQQ()`
    function returns QQ plots of all continuous variables (see figure 17.13):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分剩余的 `SmartEDA` 内容是视觉的。调用 `ExpOutQQ()` 函数会返回所有连续变量的 QQ 图（见图 17.13）：
- en: '[PRE48]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '![CH17_F13_Sutton](../../OEBPS/Images/CH17_F13_Sutton.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![CH17_F13_Sutton](../../OEBPS/Images/CH17_F13_Sutton.png)'
- en: Figure 17.13 A random sample of four QQ plots from the `SmartEDA` package
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.13 `SmartEDA` 包的四个随机样本 QQ 图
- en: It’s fascinating to discover that the `DataExplorer` package, and now the `SmartEDA`
    package as well, feature QQ plots first and foremost to graphically represent
    the distribution of continuous data; after all, while QQ plots are regularly returned
    when running regression diagnostics, they are rarely featured in EDA. Here, we’re
    instructing `SmartEDA` to return a random sample of four plots and to arrange
    them in a 2 × 2 matrix. Once more, when the plotted data falls on top of the diagonal
    line in a QQ plot, that data is normally distributed; if not, the data is skewed
    one way or another.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 发现 `DataExplorer` 包，以及现在的 `SmartEDA` 包，首先提供 QQ 图来图形化表示连续数据的分布，这非常有趣；毕竟，虽然 QQ
    图在运行回归诊断时通常会返回，但在 EDA 中却很少被提及。在这里，我们指导 `SmartEDA` 返回四个随机样本的图，并将它们排列成一个 2 × 2 矩阵。再次强调，当绘制的数据落在
    QQ 图的对角线上时，这些数据是正态分布的；如果不是，数据则存在某种偏斜。
- en: 'Then, we call the `ExpNumViz()` function to get a random sample of four density
    plots, also arranged in a 2 × 2 matrix (see figure 17.14):'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用 `ExpNumViz()` 函数来获取四个随机样本的密度图，也排列成一个 2 × 2 矩阵（见图 17.14）：
- en: '[PRE49]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '![CH17_F14_Sutton](../../OEBPS/Images/CH17_F14_Sutton.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![CH17_F14_Sutton](../../OEBPS/Images/CH17_F14_Sutton.png)'
- en: Figure 17.14 A random sample of four density plots from the `SmartEDA` package
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.14 `SmartEDA` 包的四个随机样本密度图
- en: It so happens that `SmartEDA` returned QQ plots and density plots for the variables
    `openspreadH` and `diff_margin_closespreadH`; `openspreadH` is normally distributed,
    whereas `diff_margin_closespreadH` isn’t. Notice the probability distributions
    from their respective density plots, and compare those to their corresponding
    QQ plots. In addition, what’s nice about these density plots is that `SmartEDA`
    prints the skewness and kurtosis numbers. When the data is normally distributed,
    as it is for the variable `openspreadH`, skewness and kurtosis will both equal
    some number close to 0; alternatively, when the data is otherwise skewed, as it
    is for the variable `diff_margin_ closespreadH`, skewness and kurtosis will instead
    equal numbers, positively or negatively, further from 0\. In fact, skewness and
    kurtosis are positive or negative depending on how the data is skewed; when positively
    skewed, the measures are positive, and when negatively skewed, both measures are
    negative.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 恰好`SmartEDA`为变量`openspreadH`和`diff_margin_closespreadH`返回了QQ图和密度图；`openspreadH`是正态分布的，而`diff_margin_closespreadH`则不是。注意它们各自的密度图中的概率分布，并将这些与它们相应的QQ图进行比较。此外，这些密度图的一个优点是`SmartEDA`会打印出偏度和峰度的数值。当数据是正态分布的，就像变量`openspreadH`那样，偏度和峰度都会接近于0的某个数值；相反，当数据是其他形式的偏斜，就像变量`diff_margin_closespreadH`那样，偏度和峰度将分别等于远离0的正负数值。实际上，偏度和峰度是正负的，这取决于数据是如何偏斜的；当正偏斜时，这些度量值是正的，而当负偏斜时，这两个度量值都是负的。
- en: 'Finally, another call to `ExpNumVix``()`, this time with `scatter = TRUE` passed
    as an additional argument, returns a random sample of four scatterplots arranged
    in a 2 × 2 matrix (see figure 17.15):'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，再次调用`ExpNumVix``()`函数，这次通过额外的参数传递了`scatter = TRUE`，返回了一个由四个散点图组成的2 × 2矩阵的随机样本（见图17.15）：
- en: '[PRE50]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '![CH17_F15_Sutton](../../OEBPS/Images/CH17_F15_Sutton.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![CH17_F15_Sutton](../../OEBPS/Images/CH17_F15_Sutton.png)'
- en: Figure 17.15 A random sample of four scatterplots from the `SmartEDA` package
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.15 `SmartEDA`包中的四个随机散点图的样本
- en: Unfortunately, it’s not possible to create a correlation matrix with `SmartEDA`;
    therefore, the only way to visualize the relationship between pairs of continuous
    variables is to create a series of scatterplots. The output file we previously
    created by calling the `ExpReport()` function actually contained 36 scatterplots.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，使用`SmartEDA`无法创建相关矩阵；因此，可视化成对连续变量之间关系的方法只能是创建一系列散点图。我们之前通过调用`ExpReport()`函数创建的输出文件实际上包含了36个散点图。
- en: Categorical variable analysis
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 分类型变量分析
- en: 'That’s it for our continuous data. As for our categorical variables, we first
    make a call to the `ExpTable()` function, which returns basic statistics for `month2`
    and `spreadmove` in a tabular format. What’s really nice is that `ExpTable()`
    breaks down our categorical data by factor level and provides the roll-ups for
    each. It’s interesting to discover that the opening point spread increased almost
    52% of the time and decreased just 32% of the time (it otherwise closed where
    it opened nearly 16% of the time):'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的连续数据的全部内容。至于我们的分类型变量，我们首先调用`ExpTable()`函数，该函数以表格格式返回`month2`和`spreadmove`的基本统计数据。真正令人高兴的是`ExpTable()`按因素水平分解我们的分类型数据，并为每个因素水平提供汇总。有趣的是，开盘点差价有52%的时间增加，只有32%的时间减少（其余时间几乎以相同的价格开盘，占16%）：
- en: '[PRE51]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Finally, we twice subset our data on each categorical variable and then call
    the `ExpCatViz()` function. We get a pair of bar charts that graphically represent
    the data previously returned by calling the `ExpTable()` function (see figure
    17.16):'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们对每个分类型变量进行了两次子集划分，然后调用`ExpCatViz()`函数。我们得到了一对柱状图，这些柱状图以图形方式表示了之前通过调用`ExpTable()`函数返回的数据（见图17.16）：
- en: '[PRE52]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '![CH17_F16_Sutton](../../OEBPS/Images/CH17_F16_Sutton.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![CH17_F16_Sutton](../../OEBPS/Images/CH17_F16_Sutton.png)'
- en: Figure 17.16 On the left, the bar chart displays the `month2` frequencies by
    factor level, and on the right, the bar chart displays the `spreadmove` frequencies
    by factor level.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.16 在左侧，柱状图显示了按因素水平显示的`month2`频率，而在右侧，柱状图显示了按因素水平显示的`spreadmove`频率。
- en: Remember, the purpose of EDA is to get an initial read on a data set—it’s not
    the be-all and end-all. That’s up next, where we bring everything together.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，EDA的目的是对数据集进行初步了解——它不是一切和结束。接下来，我们将把所有这些内容整合在一起。
- en: 17.5 Results
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.5 结果
- en: Regardless of how we subsequently slice and dice the data, the closing total
    outperformed the opening total, and the closing point spread outperformed the
    opening point spread—at least as far as the 2018-19 regular season is concerned.
    That is, closing totals and closing point spreads were more often nearer to game
    results than were opening totals and opening point spreads. This suggests that
    the masses—at least those who follow the NBA and are disposed to risk their earnings—add
    value above and beyond the expert predictions from the Las Vegas oddsmakers. We’ll
    share the over/under results first.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们随后如何切割和切片数据，收盘总价比开盘总价表现更好，收盘点差也优于开盘点差——至少就2018-19赛季而言。也就是说，收盘总价和收盘点差比开盘总价和开盘点差更接近比赛结果。这表明大众——至少是那些关注NBA并愿意冒险的人——在拉斯维加斯赔率专家的预测之上增加了价值。我们将首先分享胜负彩的结果。
- en: 17.5.1 Over/under
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.5.1 胜负彩
- en: Our EDA exercise with the `DataExplorer` package returned some interesting insights
    and provided a good foundation from which to move forward. One of the bar charts
    showed that the variable `versusPTS` equals `closetotal` more frequently than
    it equals `opentotal`, though without providing the counts. Put differently, there
    appeared to be more games during the 2018-19 NBA regular season where the difference
    between the closing over/under and total points scored was less than the opening
    over/under and total points scored.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`DataExplorer`包进行的EDA练习提供了一些有趣的见解，并为我们提供了一个良好的前进基础。其中一个条形图显示，变量`versusPTS`等于`closetotal`的频率高于等于`opentotal`，尽管没有提供计数。换句话说，在2018-19
    NBA常规赛中，似乎有更多比赛的收盘胜负彩与总分的差异小于开盘胜负彩与总分的差异。
- en: Plotting opening total and closing total performance versus combined points
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制开盘总价和收盘总价与总分的对比图
- en: In the chunk of code that follows, we first pass the oddsdf3 data set to the
    `dplyr summarize()` function—`SUM1` equals the number of instances where `diff_ptsT_opentotal`
    is greater than `diff_ptsT_closetotal`, `SUM2` equals the number of instances
    where the opposite condition is true, and `SUM3` equals the number of instances
    where `diff_ptsT_opentotal` and `diff_ptsT_closetotal` are the same.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们首先将oddsdf3数据集传递给`dplyr summarize()`函数——`SUM1`等于`diff_ptsT_opentotal`大于`diff_ptsT_closetotal`的实例数量，`SUM2`等于相反条件成立的实例数量，而`SUM3`等于`diff_ptsT_opentotal`和`diff_ptsT_closetotal`相同的实例数量。
- en: 'These results are then passed to the `tidyr pivot_longer()` function, which
    increases the row count at the expense of the column count. Two new variables
    are created in the process, `sum` and `total`; `SUM1`, `SUM2`, and `SUM3` are
    then converted to factors within `sum`, and their values are placed in the cells
    within `total`. All of this gets us an object we can then throw into a plot and
    analyze. The end result is a tibble called tblA:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果随后传递给`tidyr pivot_longer()`函数，该函数以牺牲列计数为代价增加行计数。在此过程中创建了两个新变量，`sum`和`total`；`SUM1`、`SUM2`和`SUM3`随后在`sum`中转换为因子，其值放置在`total`的单元格中。所有这些最终得到一个可以投入绘图和分析的对象。最终结果是名为tblA的tibble。
- en: '[PRE53]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then we call the `ggplot2 ggplot()` and `geom_bar()` functions to visualize
    tblA with a bar chart (see figure 17.17):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用`ggplot2 ggplot()`和`geom_bar()`函数，用条形图可视化tblA（见图17.17）：
- en: Our x-axis variable is `sum`, and our y-axis variable is `total`. By adding
    the `fill` argument, we’re telling R to color-code the bars by the variable `sum`
    rather than printing them in grayscale.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的自变量是`sum`，因变量是`total`。通过添加`fill`参数，我们告诉R根据变量`sum`对条形图进行颜色编码，而不是以灰度打印。
- en: By passing the `stat` `=` `"identity"` argument to the `geom_bar()` function,
    we’re instructing R to map the height of the bars to the y-axis variable previously
    supplied to the `ggplot` aesthetic.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将`stat`参数设置为`"identity"`传递给`geom_bar()`函数，我们指示R将条形图的高度映射到之前提供给`ggplot`美学的y轴变量。
- en: Affixing labels that tie back to the y-axis variable is always a nice enhancement
    to any bar chart; here, the `geom_text()` function places the y-axis totals atop
    the bars and prints them in a bold font. If we preferred to affix the labels somewhere
    inside the bars, we would merely modify the `vjust` argument (short for vertical
    adjustment) to a positive number.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为条形图添加与y轴变量相关的标签总是一个很好的增强；在这里，`geom_text()`函数将y轴总价放置在条形图上方，并以粗体字体打印。如果我们更喜欢将标签放置在条形图内部，我们只需将`vjust`参数（即垂直调整）修改为正数。
- en: Adding labels atop the bars usually requires, for aesthetic purposes, that we
    then extend the length of the y-axis by calling the `ylim()` function and specifying
    the starting and ending points.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在柱状图上方添加标签通常需要从美学角度出发，通过调用`ylim()`函数并指定起始和结束点来延长y轴的长度。
- en: By calling the `scale_x_discrete()` function, we replace `SUM1`, `SUM2`, and
    `SUM3` with more descriptive labels, which then preclude the need to take up space
    with a legend.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用`scale_x_discrete()`函数，我们将`SUM1`、`SUM2`和`SUM3`替换为更具描述性的标签，从而避免了使用图例占用空间的需求。
- en: '![CH17_F17_Sutton](../../OEBPS/Images/CH17_F17_Sutton.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![CH17_F17_Sutton](../../OEBPS/Images/CH17_F17_Sutton.png)'
- en: Figure 17.17 A bar chart shows that the closing total outperformed the opening
    total versus total points scored by approximately 10%.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.17 一个柱状图显示，收盘总点数相对于开盘总点数超出了大约10%。
- en: 'All of this comes together in the following chunk of code:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都在以下代码块中综合起来：
- en: '[PRE54]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As it turns out, the closing total outperformed the opening total by approximately
    10%.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，收盘总点数比开盘总点数高出大约10%。
- en: By movement
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 按变动
- en: 'The next chunk of code is a replication of the `dplyr` and `tidyr` code that
    produced tblA—except that we’re inserting the `dplyr group_by()` function to group
    the results by each factor in the variable `totalmove` and then adding the `filter()`
    function to exclude the 100 instances where `diff_ptsT_opentotal` equals `diff_ptsT_closetotal`.
    Our results are then cast to a tibble called tblB:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码块是对生成tblA的`dplyr`和`tidyr`代码的复制——除了我们插入`dplyr group_by()`函数来按变量`totalmove`中的每个因素分组结果，并添加`filter()`函数来排除`diff_ptsT_opentotal`等于`diff_ptsT_closetotal`的100个实例。然后我们的结果被转换为一个名为tblB的tibble：
- en: '[PRE55]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In our next plot, we call the `ggplot2 facet_wrap()` function to create a panel
    for each remaining factor in the variable `totalmove`. R then creates a like bar
    chart within each panel (see figure 17.18):'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个图表中，我们调用`ggplot2 facet_wrap()`函数为变量`totalmove`中的每个剩余因素创建一个面板。然后R在每一个面板内创建一个类似的柱状图（见图17.18）：
- en: '[PRE56]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '![CH17_F18_Sutton](../../OEBPS/Images/CH17_F18_Sutton.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![CH17_F18_Sutton](../../OEBPS/Images/CH17_F18_Sutton.png)'
- en: Figure 17.18 A facet plot that breaks down opening and closing totals versus
    points scored by factors in the variable `totalmove`. It turns out that the closing
    total outperformed the opening total by about 10%, irrespective of whether the
    opening total then went up or down.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.18 一个分解面板图，展示了开盘总点数与收盘总点数相对于变量`totalmove`中的因素的点数对比。结果是，收盘总点数比开盘总点数高出大约10%，无论开盘总点数随后是上升还是下降。
- en: Whether the opening total then went up or down before closing is largely immaterial.
    It turns out that the closing total outperformed the opening total by 10%, irrespective
    of subsequent movement.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 开盘总点数在收盘前是上升还是下降在很大程度上并不重要。结果是，收盘总点数比开盘总点数高出10%，无论随后的变动如何。
- en: By month
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 按月份
- en: 'Next, we pass oddsdf3 to the `group_by``()` and `summarize()` functions to
    tally the number of instances where `diff_ptsT_opentotal` is less than `diff_ptsT_closetotal`
    and where `diff_ptsT_closetotal` is less than `diff_ptsT_opentotal` by each factor
    in the variable `month2`. These results are then passed to the `pivot_longer()`
    function so that we get `SUM1` and `SUM2` results for every month. Our final results
    are reflected in a tibble called tblC:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将oddsdf3传递给`group_by()`和`summarize()`函数，按变量`month2`中的每个因素计算`diff_ptsT_opentotal`小于`diff_ptsT_closetotal`和`diff_ptsT_closetotal`小于`diff_ptsT_opentotal`的实例数量。然后这些结果传递给`pivot_longer()`函数，以便我们为每个月份得到`SUM1`和`SUM2`的结果。我们的最终结果反映在一个名为tblC的tibble中：
- en: '[PRE57]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Our next `ggplot2` visualization is therefore a grouped bar chart where we get
    two results, or two bars, for every month (see figure 17.19). The `geom_bar()
    position = "dodge"` argument places each pair of bars side by side and adjoins
    them.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的下一个`ggplot2`可视化是一个分组柱状图，每个月份我们得到两个结果，或者说两个柱状图（见图17.19）。`geom_bar() position
    = "dodge"`参数将每对柱状图并排放置并连接它们。
- en: '![CH17_F19_Sutton](../../OEBPS/Images/CH17_F19_Sutton.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![CH17_F19_Sutton](../../OEBPS/Images/CH17_F19_Sutton.png)'
- en: Figure 17.19 Opening total versus closing total performance by month. The 2018-19
    NBA regular season started in October and ended the following April.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.19 按月份的开盘总点数与收盘总点数的性能对比。2018-19 NBA常规赛于10月开始，并于次年的4月结束。
- en: To prevent our labels from then straddling each pair of bars, we must add the
    `position_dodge()` function to the `geom_text()` function. By specifying the width
    to equal 0.9, the labels are centered atop the bars; even a minor adjustment from
    0.9 to 1 would instead affix the labels left of center.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止我们的标签跨越每对条形，我们必须将`position_dodge()`函数添加到`geom_text()`函数中。通过指定宽度等于0.9，标签被居中放置在条形上方；即使从0.9到1的微小调整也会使标签固定在中心左侧。
- en: 'By calling the `scale_x_discrete()` function, we’re able to map each `month2`
    factor to actual months, so that `1` equals October, `2` equals November, and
    so forth. And because our x-axis labels tie back to the variable `month2` and
    not the variable `sum`, a legend, placed beneath the plot, is therefore in order:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`scale_x_discrete()`函数，我们能够将每个`month2`因子映射到实际的月份，因此`1`等于十月，`2`等于十一月，以此类推。而且因为我们的x轴标签与变量`month2`相关联，而不是与变量`sum`相关联，所以需要在图表下方放置一个图例：
- en: '[PRE58]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The closing total outperformed the opening total in four months out of seven.
    However, the most fascinating, and maybe most significant, results are from October
    and November 2018\. In these first two months of the regular season, with relatively
    few observations to work from, the closing total substantially outperformed the
    opening total.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在七个月中有四个月的收盘总方差超过了开盘总方差。然而，最引人入胜，也许是最重要的结果来自2018年10月和11月。在这两个常规赛的第一个月，由于观察数据相对较少，收盘总方差显著超过了开盘总方差。
- en: Plotting opening total and closing total variances versus combined points
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制开盘总方差和收盘总方差与综合点数的关系图
- en: 'Now we’re interested in the average variances between the opening and closing
    totals and the combined point totals between opposing teams. We pass oddsdf3 to
    the `summarize()` function, which computes the means for `diff_ptsT_opentotal`
    and `diff_ptsT_closetotal`. The initial results are then passed to the `pivot_longer()`
    function to convert `AVG1` and `AVG2` to factors within a new variable called
    `avg` and to place their values within another new variable called `value`. The
    final results are cast to a tibble called tblD:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对开盘总和与收盘总和之间的平均方差以及对抗队伍之间的综合点数总和感兴趣。我们将oddsdf3传递给`summarize()`函数，该函数计算`diff_ptsT_opentotal`和`diff_ptsT_closetotal`的平均值。然后将初始结果传递给`pivot_longer()`函数，将`AVG1`和`AVG2`转换为名为`avg`的新变量中的因子，并将它们的值放置在另一个名为`value`的新变量中。最终结果被转换为名为tblD的tibble：
- en: '[PRE59]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Our next visualization is a very simple bar chart that displays opening total
    and closing total variances with total points scored (see figure 17.20).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的可视化是一个非常简单的条形图，显示了开盘总方差和收盘总方差与总得分（见图17.20）。
- en: '![CH17_F20_Sutton](../../OEBPS/Images/CH17_F20_Sutton.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![CH17_F20_Sutton](../../OEBPS/Images/CH17_F20_Sutton.png)'
- en: Figure 17.20 The average variances between opening and closing totals and combined
    points scored by opposing teams
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.20 开盘总和与收盘总和以及对抗队伍所得分综合点数之间的平均方差
- en: 'Rather than calling the `geom_bar()` function and passing the `stat = "identity"`
    argument, we merely call the `geom_col()` function instead. By inserting the base
    R `round()` function inside the `geom_text()` function, our labels are guaranteed
    to include only two digits right of the decimal point:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是调用`geom_bar()`函数并传递`stat = "identity"`参数，我们只是调用`geom_col()`函数。通过在`geom_text()`函数内插入基础R的`round()`函数，我们的标签保证只包含小数点后两位数字：
- en: '[PRE60]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The variances are obviously very similar, but the closing total did, in fact,
    outperform the opening total by about 2%.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 方差显然非常相似，但收盘总方差实际上确实比开盘总方差高出约2%。
- en: By movement
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 通过移动
- en: 'We then break down these same results by whether the opening total went up
    or down before closing; therefore, we insert the `group_by()` function into a
    copy of our `dplyr` and `tidyr` code to group the results by each factor in the
    variable `totalmove`. Then, we call the `filter()` function to limit the final
    results to where `totalmove` doesn’t equal `same`. We subsequently get a tibble
    called tblE:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们根据开盘总和在收盘前是上升还是下降来分解这些相同的结果；因此，我们将`group_by()`函数插入到我们的`dplyr`和`tidyr`代码的副本中，按变量`totalmove`中的每个因子分组结果。然后，我们调用`filter()`函数将最终结果限制在`totalmove`不等于`same`的地方。随后我们得到一个名为tblE的tibble：
- en: '[PRE61]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Our next visualization is a facet plot (see figure 17.21) that contains one
    panel for each of the remaining factors in the tblE variable `totalmove`. Once
    more, we’ve replaced the `geom_bar()` function with `geom_col``()`. In addition,
    we’ve modified the aesthetic parameter `vjust` from `-0.2` to `1.5`, which affixes
    our labels *below* the top of the bars. As a result, it then becomes unnecessary
    to call the `ylim()` function to extend the length of the y-axis:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的可视化是一个面图（见图17.21），它为`totalmove`变量中剩余的每个因素包含一个面板。再次，我们将`geom_bar()`函数替换为`geom_col()`函数。此外，我们还修改了美学参数`vjust`，从`-0.2`改为`1.5`，这使得标签位于柱状图的顶部下方。因此，就不再需要调用`ylim()`函数来扩展y轴的长度：
- en: '[PRE62]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '![CH17_F21_Sutton](../../OEBPS/Images/CH17_F21_Sutton.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![CH17_F21_Sutton](../../OEBPS/Images/CH17_F21_Sutton.png)'
- en: Figure 17.21 The average variances between opening and closing totals and combined
    points scored by opposing teams separated by each remaining factor in the variable
    `totalmove`
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.21 开盘和收盘总点数以及对方球队得分总和的平均方差，按`totalmove`变量中剩余的每个因素分开
- en: The variances are again very similar regardless of which direction the opening
    total went before closing. Nevertheless, the closing total outperformed the opening
    total by 2% irrespective of whether the opening total went up or down.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 无论开盘总点数在收盘前是上升还是下降，方差再次非常相似。尽管如此，收盘总点数在2%的幅度上优于开盘总点数。
- en: By month
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 按月份
- en: 'Finally, we’ll plot these variances by month. We therefore pass the oddsdf3
    data set to the `group_by``()` and `summarize()` functions to compute the `diff_ptsT_opentotal`
    and `diff_ptsT_closetotal` means by each factor in the variable `month2`. By subsequently
    calling the `pivot_longer()` function, we transform `AVG1` and `AVG2` from variables
    to factors within a new variable called `avg` and place their values within yet
    another new variable called `value`. Our results are cast to a tibble called tblF:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将按月份绘制这些方差。因此，我们将oddsdf3数据集传递给`group_by()`和`summarize()`函数，以计算`month2`变量中每个因素的`diff_ptsT_opentotal`和`diff_ptsT_closetotal`平均值。随后调用`pivot_longer()`函数，将`AVG1`和`AVG2`从变量转换为新变量`avg`中的因素，并将它们的值放置在另一个新变量`value`中。我们的结果被转换为一个名为tblF的tibble：
- en: '[PRE63]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We’ve made some aesthetic changes from our previous month-over-month plot (see
    figure 17.22). Rather than pass the `position` `=` `"dodge"` argument to the `geom_bar()`
    function, this time, we pass `position_dodge``()` and specify a width of `0.5`,
    which effectively obscures half the width of one series of bars by the other series.
    As a result, we then round the labels to the nearest whole number; otherwise,
    the labels would often blend together and be indecipherable. To center these same
    labels atop the bars, we also add the `position_dodge()` function to the `geom_text()`
    function; however, this time we specify the width to also equal `0.5` rather than
    `0.9` as before:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对上个月月度图表进行了一些美学上的调整（见图17.22）。这次，我们不是将`position`参数设置为`"dodge"`传递给`geom_bar()`函数，而是传递`position_dodge()`，并指定宽度为`0.5`，这实际上使得一个系列柱状图的一半宽度被另一个系列柱状图所遮挡。因此，我们随后将标签四舍五入到最接近的整数；否则，标签通常会混合在一起，难以辨认。为了将这些相同的标签居中放置在柱状图上方，我们也在`geom_text()`函数中添加了`position_dodge()`函数；然而，这次我们指定的宽度也等于`0.5`，而不是之前的`0.9`：
- en: '[PRE64]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '![CH17_F22_Sutton](../../OEBPS/Images/CH17_F22_Sutton.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![CH17_F22_Sutton](../../OEBPS/Images/CH17_F22_Sutton.png)'
- en: Figure 17.22 The month-over-month average variances between opening and closing
    totals and combined points scored. The labels affixed atop the bars have been
    rounded to the nearest whole number.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.22 开盘和收盘总点数以及得分总和的月度平均方差。柱状图上方的标签已四舍五入到最接近的整数。
- en: The closing total beat or at least equaled the opening total in all seven months
    of the 2018-19 NBA regular season—if we go by the rounded variances. If we instead
    go by the visual representation of the same results, the closing total bested
    the opening total in five out of seven months. The most significant variances
    favoring the closing total were in October and November 2018 when, again, relatively
    few games had been played, and thus there were just a handful of observations
    to work from.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果根据四舍五入的方差来看，2018-19 NBA常规赛的七个月中，收盘总点数在所有七个月都击败或至少等于开盘总点数。如果我们根据相同结果的视觉表示来看，那么在七个月中有五个月收盘总点数优于开盘总点数。最显著的、有利于收盘总点数的方差出现在2018年10月和11月，当时相对较少的比赛已经进行，因此只有少数几个观察值可供分析。
- en: We’ll now pivot and report on the performance differences between the opening
    and closing point spreads.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将旋转并报告开盘和收盘点数差异的表现。
- en: 17.5.2 Point spreads
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.5.2 点差
- en: 'To minimize the presentation of duplicate lines of code (notwithstanding variable
    swaps), we’ll display our results by printing tibbles and eschewing any further
    visualizations. We’ll begin by tallying the number of times the closing spread
    was closer to the final margin than was the opening spread, the number of times
    the opening spread was closer to the final margin, and the number of times the
    closing and opening spreads were the same. The following chunk of code matches
    the `dplyr` and `tidyr` code that previously produced tblA; here, we’re casting
    the results to a tibble called tblG:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最小化重复代码的展示（尽管变量进行了交换），我们将通过打印tibbles并避免任何进一步的视觉呈现来展示我们的结果。我们将从计算收盘价比开盘价更接近最终利润率的次数、开盘价更接近最终利润率的次数以及收盘价和开盘价相同的次数开始。以下代码块与之前生成tblA的`dplyr`和`tidyr`代码匹配；在这里，我们将结果转换为名为tblG的tibble：
- en: '[PRE65]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The closing total outperformed the opening total by approximately 11% (equal
    to the inverse of `SUM2` divided by `SUM1`).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 收盘总价比开盘总价高出约11%（等于`SUM2`的倒数除以`SUM1`）。
- en: 'Next, we break down these same results by whether the opening spread then moved
    up or down; our final results don’t include instances where the variable `spreadmove`
    equals `same` or where the variable `sum` equals `SUM3`. The following lines of
    code that ultimately produce a tibble called tblH are similar to the code that
    produced tblB:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们根据开盘价随后是上升还是下降来分解这些相同的成果；我们的最终结果不包括变量`spreadmove`等于`same`或变量`sum`等于`SUM3`的情况。以下生成名为tblH的tibble的代码行与生成tblB的代码相似：
- en: '[PRE66]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The closing spread outperformed the opening spread regardless of whether the
    opening spread subsequently moved up or down before closing, but the results vary
    by the `spreadmove` factor level. When the opening spread went down, the closing
    spread outperformed the opening spread by about 13%; when the opening spread went
    up, the closing spread outperformed the opening spread by about 8%.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管开盘价在收盘前可能上升或下降，但收盘价的表现始终优于开盘价，但结果会因`spreadmove`因素水平的不同而有所变化。当开盘价下降时，收盘价比开盘价高出约13%；当开盘价上升时，收盘价比开盘价高出约8%。
- en: 'Then, we compute how the opening and closing spreads performed against the
    final margins by each factor in the variable `month2`. The following chunk of
    code, which produces a tibble called tblI, matches the tblC code very well:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们计算了开盘价和收盘价与最终利润率之间的表现，按变量`month2`中的每个因素进行。以下生成名为tblI的代码块与tblC代码非常匹配：
- en: '[PRE67]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The closing spread outperformed the opening spread in five out of seven months—two
    of the first three months of the 2018-19 NBA regular season plus, curiously, the
    last three months.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在七个月中有五个月，收盘价的表现优于开盘价——包括2018-19 NBA常规赛前三个月中的两个月，以及令人好奇的最后三个月。
- en: 'Next, we compute the average variance between the opening and closing spreads
    versus the final margin and cast the results to a tibble called tblJ (see the
    tblD code for comparison purposes):'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们计算开盘价和收盘价与最终利润率之间的平均方差，并将结果转换为名为tblJ的tibble（参见tblD代码以进行比较）：
- en: '[PRE68]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The closing spread outperformed the opening spread by approximately 2%.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 收盘价比开盘价高出约2%。
- en: 'We then compute these same variances by whether the opening spread moved up
    or down. Our results, pushed to a tibble called tblK, don’t include instances
    where the variable `spreadmove` equals `same` (see the code for tblE for a comparison):'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们根据开盘价是上升还是下降来计算这些相同的方差。我们的结果被推送到一个名为tblK的tibble中，不包括变量`spreadmove`等于`same`的情况（参见tblE代码以进行对比）：
- en: '[PRE69]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The closing spread outperformed the opening spread more or less equally irrespective
    of whether the opening spread then moved up or down before closing.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 不论开盘价在收盘前是上升还是下降，收盘价的表现与开盘价的表现大致相当。
- en: 'Finally, we compute the month-over-month opening and closing performances against
    the final margins (see the tblF code for a comparison):'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们计算了月度开盘和收盘表现与最终利润率之间的对比（参见tblF代码以进行对比）：
- en: '[PRE70]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The closing spread outperformed the opening spread in every month of the 2018-19
    NBA regular season, except (curiously) in the first month.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在2018-19 NBA常规赛的每个月份，除了（令人好奇的是）第一个月，收盘价的表现都优于开盘价。
- en: While some of these variances—not just between the opening and closing spreads,
    but also between the opening and closing totals—might appear small, they are hardly
    immaterial. In the gambling world, small variances usually have large financial
    ramifications, for the casinos and wagerers alike. In the final analysis, if only
    based on 2018-19 regular season data, the closing total and the closing spread,
    influenced by gamblers, were more often than not nearer end-of-game results than
    the opening total and the opening spread established by Las Vegas oddsmakers.
    Furthermore, the “value add” from gamblers was more prevalent early in the 2018-19
    season, when there wasn’t much historical data to work with, than later on. The
    relative lack of training data therefore appeared to affect the oddsmakers more
    than it affected the collective intelligence of the wagerers.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些差异——不仅限于开盘和收盘差价，还包括开盘和收盘总金额——可能看起来很小，但它们绝不是无关紧要的。在赌博界，小的差异通常对赌场和赌徒都有重大的财务影响。在最终分析中，仅基于
    2018-19 赛季的数据，受赌徒影响的收盘总金额和收盘差价，往往比拉斯维加斯博彩公司设定的开盘总金额和开盘差价更接近比赛结束的结果。此外，“赌徒的价值增加”在
    2018-19 赛季早期更为普遍，当时可供工作的历史数据不多，而后期则较少。因此，相对缺乏训练数据似乎对博彩公司的影响比对赌徒集体智慧的影响更大。
- en: In the next chapter, we’ll examine how the salary cap, which the NBA implemented
    between the 1983-84 and 1984-85 seasons, *might* have affected intra-season and
    inter-season parity. We’ll introduce several statistical measures of dispersion
    to quantify parity before and after 1985 to determine whether the salary cap actually
    improved parity as the league said it would.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 NBA 在 1983-84 赛季和 1984-85 赛季之间实施的薪资上限可能如何影响了赛季内和赛季间的平衡。我们将介绍几个用于量化
    1985 年前后平衡的统计指标，以确定薪资上限是否真的像联盟所说的那样改善了平衡。
- en: Summary
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The upside to automated EDA is that you can produce more with less, that is,
    more content with fewer lines of code. This also allows you to focus on running
    statistical tests, developing predictive models, creating unsupervised algorithms,
    and so on.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动 EDA 的优点是你可以用更少的资源生产更多，也就是说，用更少的代码行生成更多内容。这也允许你专注于运行统计测试、开发预测模型、创建无监督算法等等。
- en: The downside to automated EDA is that you probably won’t get optimal content
    returned; that is, you’ll likely get results that don’t matter and won’t get other
    results that would and should matter.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动 EDA 的缺点是，你可能不会得到最佳的内容返回；也就是说，你可能会得到一些无关紧要的结果，而不会得到其他应该重要的结果。
- en: Manual, or methodical, EDA approaches compel you to think about your data and,
    along the way, provide a tremendous learning opportunity. Automated EDA is akin
    to a global positioning system—you’ll get to a predetermined destination, but
    you might not know how you got there.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动或系统的 EDA 方法迫使你思考你的数据，并在过程中提供巨大的学习机会。自动 EDA 类似于全球定位系统——你将到达预定的目的地，但你可能不知道你是如何到达那里的。
- en: When it comes to automated or manual, it doesn’t necessarily have to be either/or;
    some mix of automated and manual EDA could conceivably be a great solution for
    many projects. In addition, you can pick and choose which `tableone`, `DataExplorer`,
    and/or `SmartEDA` functions you might want to run manually to complement base
    R and `tidyverse` functions.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当涉及到自动或手动时，不一定是非此即彼；自动和手动 EDA 的某种组合可能对许多项目来说是一个很好的解决方案。此外，你可以挑选和选择你想要手动运行的 `tableone`、`DataExplorer`
    和/或 `SmartEDA` 函数，以补充基础 R 和 `tidyverse` 函数。
- en: 'One more point about automated EDA and specifically the three packages that
    were demonstrated: though `tableone`, `DataExplorer,` and `SmartEDA` are no doubt
    three of the mostly popular automated EDA packages, that doesn’t necessarily mean
    they’ve been adequately vetted. The manual functions from `SmartEDA` are quirky
    at best and buggy at worst. `DataExplorer` outputs a relatively polished and thorough
    combination of tabular and graphical results that can be saved in a standalone
    file and then shared; it’s therefore the best of these three automated EDA packages.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于自动 EDA 以及特别演示的三个包，还有一个观点：尽管 `tableone`、`DataExplorer` 和 `SmartEDA` 无疑是三个最受欢迎的自动
    EDA 包，但这并不一定意味着它们已经得到了充分的审查。`SmartEDA` 的手动功能最多有些古怪，最坏的情况是存在错误。`DataExplorer` 输出相对精致和详尽的表格和图形结果组合，可以保存为独立文件并共享；因此，它是这三个自动
    EDA 包中最好的。
- en: Our results consistently demonstrated that closing totals and closing spreads
    are nearer to final results than opening totals and opening spreads. Gamblers
    add value, especially early in the season when there are relatively few games
    or results from which to establish opening odds.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的研究结果一致表明，结算总账和结算赔率比开盘总账和开盘赔率更接近最终结果。赌徒们增加了价值，尤其是在赛季早期，那时可供建立开盘赔率的比赛或结果相对较少。
- en: Wisdom therefore exists in crowds; the idea that a mass of people operating
    independently and with skin in the game are smarter than a much smaller number
    of experts may very well be true.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，智慧存在于人群中；独立操作且对游戏有投入的人群比数量多得多的专家更聪明的观点可能非常正确。
