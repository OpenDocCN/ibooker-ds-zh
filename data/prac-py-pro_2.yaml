- en: Part 3\. Nailing down large systems
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三部分. 确定大型系统
- en: In [part 2](../Text/kindle_split_011.html#part02), you learned the concepts
    that form a large part of software design, and in [part 3](#part03), you’ll start
    to apply them. By building an application from scratch, you’ll see how software
    design concepts can be applied at various points in the development life cycle.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二部分](../Text/kindle_split_011.html#part02)中，你学习了构成软件设计大部分概念的内容，而在[第三部分](#part03)中，你将开始应用它们。通过从头开始构建一个应用程序，你将看到软件设计概念如何在开发生命周期的各个阶段得到应用。
- en: Although designing software that works—and works quickly—may be part of your
    goal, another part of the goal must be software that you and other developers
    can understand and maintain. This part of the book will show you that design is
    an iterative process with some wiggle room; there isn’t always a right or wrong
    answer, and there’s rarely a point at which you’re “done.” You’ll learn how to
    identify pain points in your code so that you can use what you’ve learned to minimize
    effort and maximize understanding.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然设计出既工作又快速运行的软件可能是你的目标之一，但另一个目标必须是你可以和其他开发者理解并维护的软件。本书的这一部分将向你展示设计是一个具有一些灵活性迭代的过程；并不总是有正确或错误答案，而且很少有一个你可以说“完成”的点。你将学习如何识别代码中的痛点，以便你可以使用你所学的知识来最小化努力并最大化理解。
- en: Chapter 6\. Separation of concerns in practice
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6章. 实践中的关注点分离
- en: '*This chapter covers*'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Developing an application with separate high-level concerns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用分离的高级关注点开发应用程序
- en: Using specific types of encapsulation to loosen the coupling of different concerns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特定的封装类型来放松不同关注点之间的耦合
- en: Creating a well-separated foundation to enable future extension
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个良好的分离基础以实现未来的扩展
- en: In [chapter 2](../Text/kindle_split_012.html#ch02), I showed you some of the
    best practices around separation of concerns in Python. *Separating concerns*
    means creating boundaries between code that deals with distinct activities to
    make the code more understandable. You learned how functions, classes, modules,
    and packages are useful in decomposing code into pieces that are easier to reason
    about. Although [chapter 2](../Text/kindle_split_012.html#ch02) covered several
    of the tools available for separating concerns, it’s helpful to get some experience
    applying them.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二章](../Text/kindle_split_012.html#ch02)中，我向你展示了关于Python中关注点分离的一些最佳实践。“分离关注点”意味着在处理不同活动的代码之间创建边界，使代码更易于理解。你学习了函数、类、模块和包如何有助于将代码分解成更容易推理的片段。尽管[第二章](../Text/kindle_split_012.html#ch02)涵盖了用于分离关注点的几个工具，但获得一些应用这些工具的经验是有帮助的。
- en: As is true for many, I learn best by doing. As I work through a real project,
    I often discover connections I didn’t see before or find new questions to explore.
    In this chapter, you’ll work through a real application that exhibits a good use
    case for separating concerns. You’ll improve upon it in the chapters to come,
    and you’ll end up with something you can extend for your own personal use.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多人来说，我最好的学习方式是通过实践。当我处理一个真实的项目时，我经常发现之前没有看到的关系，或者找到新的问题去探索。在本章中，你将处理一个真实的应用程序，它展示了分离关注点的良好用例。你将在接下来的章节中对其进行改进，最终得到一个你可以用于个人用途的扩展版本。
- en: '|  |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-11
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This and future chapters make light use of structured query language (SQL),
    a domain-specific language for manipulating and retrieving data from databases.
    If you haven’t used SQL before, or need a refresher, you might want to run through
    a tutorial before continuing. Ben Brumm’s *SQL in Motion* course ([www.manning.com/livevideo/sql-in-motion](http://www.manning.com/livevideo/sql-in-motion))
    is a good primer.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书和未来的章节对结构化查询语言（SQL）的使用较少，SQL是一种用于从数据库中操作和检索数据的特定领域语言。如果你之前没有使用过SQL，或者需要复习，你可能想在继续之前运行一个教程。Ben
    Brumm的*SQL in Motion*课程([www.manning.com/livevideo/sql-in-motion](http://www.manning.com/livevideo/sql-in-motion))是一个很好的入门课程。
- en: '|  |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 6.1\. A command-line bookmarking application
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1. 命令行书签应用程序
- en: In this chapter, you’ll develop an application for saving and organizing bookmarks
    (more specifics on that in a minute).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将开发一个用于保存和组织书签的应用程序（关于这个的更多细节将在下一分钟介绍）。
- en: I’m not a great notetaker. Throughout school and my career, I’ve struggled to
    find a way of writing things down for myself that helps me learn and retain information.
    When I find a great resource that goes through a concept in a novel way or with
    insightful examples, I’ve struck gold, but I usually need to dedicate time to
    read and practice the information in that resource. As a result, I’ve amassed
    a great number of bookmarks over the last few years. Maybe I’ll have the time
    to read through them someday!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我不是一个优秀的笔记记录者。在整个学校和我的职业生涯中，我一直在努力寻找一种记录方式，帮助我学习和保留信息。当我发现一个以新颖方式或通过有洞察力的例子解释概念的优质资源时，我就找到了宝藏，但通常我需要花时间阅读和实践该资源中的信息。因此，在过去的几年里，我积累了大量的书签。也许有一天我会抽出时间阅读它们！
- en: The default bookmark feature in most browsers is lacking. Although things can
    be nested in folders and given a title, it’s often pretty difficult to recall
    why you saved something in the first place. A bunch of my bookmarks are code-related
    articles about testing, performance, new programming languages, and the like.
    When I find an interesting repository on GitHub, I also use GitHub’s “star” feature
    to save it for later. But GitHub stars are limited too; at the time of writing,
    they’re one big flat list that you can filter only by programming language. Whatever
    bookmark implementations you might use, they’re mostly built on the same foundational
    principles.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数浏览器中默认的书签功能不足。尽管事情可以嵌套在文件夹中并给出标题，但通常很难回忆起最初为什么保存某物。我的一些书签是关于测试、性能、新编程语言等相关的代码文章。当我发现
    GitHub 上的有趣仓库时，我也会使用 GitHub 的“星标”功能来保存它以供以后使用。但 GitHub 星标也是有限的；在撰写本文时，它们是一个可以按编程语言过滤的大列表。无论你使用什么书签实现，它们大多建立在相同的基本原则上。
- en: 'Bookmarks are an example of a small *CRUD* workflow: create, read, update,
    and delete ([figure 6.1](#ch06fig01)). These four operations make up a lot of
    data-driven tools in the world. You can *create* a bookmark to save for later,
    and then *read* its information to get the URL. You may want to *update* a bookmark’s
    title if the one you gave it originally was confusing, and you usually *delete*
    them when you’re done with them. This is a pretty good place to start your application.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 书签是一个小的 *CRUD* 工作流程的例子：创建、阅读、更新和删除 ([图 6.1](#ch06fig01))。这四个操作构成了世界上许多数据驱动工具的基础。你可以
    *创建* 一个书签以供以后使用，然后 *阅读* 其信息以获取 URL。如果你最初给出的书签标题很令人困惑，你可能想 *更新* 书签的标题，并且通常在你完成它们时
    *删除* 它们。这是一个开始你应用程序的好地方。
- en: Because a long description is one of the features missing from some existing
    bookmark tools, your application will include that off the bat. You’ll add a few
    more features in the following chapters, and do so in a way that will enable you
    to keep adding features you want.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于长描述是某些现有书签工具中缺失的功能之一，因此你的应用程序将直接包含该功能。你将在接下来的章节中添加更多功能，并以一种能够让你继续添加你想要的功能的方式来实现。
- en: Figure 6.1\. CRUD operations are the basis of many applications that manage
    user data.
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.1\. CRUD 操作是许多管理用户数据的应用程序的基础。
- en: '![](../Images/f0128-01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0128-01.jpg)'
- en: 6.2\. A tour of Bark
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2. 漫步 Bark
- en: 'You’re going to develop Bark, a command-line bookmarking application. Bark
    allows you to create bookmarks that, for now, will be made up of a few pieces
    of information:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你将开发 Bark，一个命令行书签应用程序。Bark 允许你创建书签，目前这些书签将由一些信息组成：
- en: '*ID*—A unique, numerical identifier for each bookmark'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ID*—每个书签的唯一、数字标识符'
- en: '*Title*—A short text title for the bookmark, like “GitHub”'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*标题*—书签的简短文本标题，例如“GitHub”'
- en: '*URL*—A link to the article or website being saved'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*URL*—保存的文章或网站的链接'
- en: '*Notes*—An optional, long description or explanation about the bookmark'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*备注*—关于书签的任意长描述或解释'
- en: '*Date added*—A timestamp so you can see how old the bookmark is (in a bid to
    stave off that pesky procrastination)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*添加日期*—一个时间戳，以便你可以看到书签有多久（为了抵制那讨厌的拖延症）'
- en: Bark will also let you list all bookmarks that have been added and then delete
    a specific bookmark by its ID. This is all managed through a *command-line interface*
    (CLI)—an application you interact with in your terminal. On startup, Bark’s CLI
    will present you with a menu of options. Each option, when selected, will trigger
    an action that will read or modify a database.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Bark 还允许你列出所有已添加的书签，然后通过其 ID 删除特定的书签。这一切都是通过 *命令行界面* (CLI) 管理的——你通过终端与之交互的应用程序。启动时，Bark
    的 CLI 将向你展示一个选项菜单。选择每个选项时，都会触发一个操作，该操作将读取或修改数据库。
- en: '|  |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: You won’t develop a feature to cover the *update* portion of CRUD for bookmarking
    in this chapter; you’ll get to that in [chapter 7](../Text/kindle_split_018.html#ch07).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，你不会开发一个功能来覆盖CRUD的*更新*部分以实现书签；你将在[第7章](../Text/kindle_split_018.html#ch07)中做到这一点。
- en: '|  |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '6.2.1\. The benefits of separation: Reprise'
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.1. 分离的好处：重述
- en: 'Even though the CRUD-like operations Bark supports are fairly common for this
    kind of application, there’s a sizable amount of stuff happening. For an application
    this big, it’s important to remember what benefits separation of concerns will
    offer:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Bark支持类似CRUD的操作对于这类应用程序来说相当常见，但发生的事情相当多。对于这样一个大的应用程序，记住分离关注点将提供的好处是很重要的：
- en: '*Reduced duplication*—If each piece of your software does one thing, it will
    be easier to see when two of them do the same thing. You can analyze similar pieces
    of code to see if it makes sense to combine them into a single source of truth
    for that behavior.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*减少重复*——如果你的软件的每一部分都做一件事情，那么当你看到两件相同的事情时，就会更容易发现。你可以分析相似的代码片段，看看是否可以将它们合并成一个单一的真实来源，以实现该行为。'
- en: '*Improved maintainability*—Code is read much more often than it’s written.
    Code that can be understood incrementally because each piece has a clear responsibility
    allows developers to jump into areas of interest, understand what they need, and
    jump back out.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提高可维护性*——代码的阅读次数远多于编写次数。由于每个部分都有明确的职责，因此代码可以逐步理解，这使得开发者可以跳入感兴趣的领域，了解他们需要什么，然后跳出来。'
- en: '*Ease of generalization and extension*—Code with one responsibility can be
    generalized to cover that responsibility for a number of use cases, or it can
    be broken up further to support more varied behavior. Code that does numerous
    things will have a hard time supporting such flexibility because it’s hard to
    see where changes may have an effect.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*易于泛化和扩展*——具有单一职责的代码可以泛化以覆盖多个用例的责任，或者可以进一步拆分以支持更多样化的行为。执行多项任务的代码将难以支持这种灵活性，因为很难看到变化可能产生影响的区域。'
- en: Keep these ideas in mind as you work through the exercise in this chapter. My
    goal is for you to come out of this chapter with something you can continue developing
    and adding features to. To do this, you’ll first think about and then implement
    a high-level architecture that will support that outcome.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在你完成本章的练习时，请记住这些想法。我的目标是让你在本章结束时能够继续开发并添加功能。为此，你首先需要考虑并实现一个高级架构，以支持这种结果。
- en: 6.3\. An initial code structure, by concern
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3. 按关注点划分的初始代码结构
- en: I try to start developing applications like Bark with a concise explanation
    of how it does what it does. This tends to lead me toward an initial architecture.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我尝试用简洁的解释来开发像Bark这样的应用程序，解释它是如何做到它所做的事情。这往往引导我走向一个初始架构。
- en: 'For example, how does Bark work? What is its concise description? Perhaps the
    following statement comprises the answers to these questions: *Using a command-line
    interface, a user chooses options for adding, removing, and listing bookmarks
    stored in a database.*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Bark是如何工作的？它的简洁描述是什么？也许以下陈述包含了这些问题的答案：*使用命令行界面，用户可以选择添加、删除和列出存储在数据库中的书签的选项.*
- en: 'Now let’s break that down a bit:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来稍微分析一下：
- en: '*Command-line interface*—This is a way to present options to a user and understand
    which options they choose.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*命令行界面*——这是一种向用户展示选项并了解他们选择了哪些选项的方式。'
- en: '*Choosing options*—Once an option is chosen, some action or business logic
    happens as a result.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择选项*——一旦选择了某个选项，就会发生一些动作或业务逻辑。'
- en: '*Stored in a database*—Data needs to be persisted for later use.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*存储在数据库中*——数据需要持久化以供以后使用。'
- en: These points represent the high-level layers of abstraction for Bark. The CLI
    is the *presentation* layer of the application. The database is the *persistence*
    layer. The actions and *business logic* are kind of like the glue that connects
    the presentation and persistence layers. Each is a fairly separate concern, as
    shown in [figure 6.2](#ch06fig02). This kind of *multitier architecture*, where
    each layer (tier) of an application has freedom to evolve, is used by many organizations.
    Teams can assemble around each tier based on areas of expertise, and each layer
    can potentially be reused with other applications if desired.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些点代表了Bark的高级抽象层。CLI是应用程序的*表示层*。数据库是*持久层*。动作和*业务逻辑*就像是连接表示层和持久层的胶水。每个都是相当独立的关注点，如图6.2([图6.2](#ch06fig02))所示。这种*多层架构*，其中每个应用层(层)都有自由发展的空间，被许多组织使用。团队可以根据专业领域围绕每个层进行组织，如果需要，每个层都可以与其他应用程序潜在地重用。
- en: Figure 6.2\. CRUD operations are the basis of many applications that manage
    user data.
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.2\. CRUD操作是许多管理用户数据的应用程序的基础。
- en: '![](../Images/f0130-01.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/f0130-01.jpg)'
- en: 'You’ll develop each of these layers of Bark as you work through the chapter.
    Because each is a separate concern, it makes sense to think of them as separate
    Python modules:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在阅读本章内容的过程中开发Bark的每一层。因为每个都是独立的关注点，所以将它们视为独立的Python模块是有意义的：
- en: A database module
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库模块
- en: A commands module
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令模块
- en: A bark module, which contains the code that actually *runs* the Bark application
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: bark模块，其中包含实际*运行*Bark应用程序的代码
- en: We’ll start from the persistence layer and work our way up.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从持久层开始，逐步向上进行。
- en: '|  |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Application architecture patterns**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用程序架构模式**'
- en: Separating applications into layers of presentation, persistence, and actions
    or rules is a common pattern. Some variations on this approach are so common,
    they’ve been given names. *Model-view-controller* (MVC) is a way of *modeling*
    data for persistence, providing users with a *view* into that data, and allowing
    them to *control* changes to that data with some set of actions. *Model-view-viewmodel*
    (MVVM) puts an emphasis on allowing the view and data model to communicate freely.
    These and other *multitier architectures* are great examples of separation of
    concerns.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序分为表示层、持久层和动作或规则的层是一种常见的模式。这种方法的某些变体非常常见，以至于它们被赋予了名称。*模型-视图-控制器* (MVC)是一种用于*建模*数据以进行持久化的方法，为用户提供数据的*视图*，并允许他们通过一组动作来*控制*对数据的更改。*模型-视图-视图模型*
    (MVVM)强调允许视图和数据模型自由通信。这些和其他*多层架构*是关注点分离的绝佳例子。
- en: '|  |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 6.3.1\. The persistence layer
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.1\. 持久层
- en: The persistence layer is the lowest level of Bark ([figure 6.3](#ch06fig03)).
    This layer will be concerned with taking information it receives and communicating
    it to the database.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 持久层是Bark的最低层([图6.3](#ch06fig03))。这一层将负责接收信息并将其传达给数据库。
- en: Figure 6.3\. The persistence layer deals with data storage—it’s the lowest level
    of the application.
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.3\. 持久层处理数据存储——它是应用程序的最低层。
- en: '![](../Images/f0131-01.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/f0131-01.jpg)'
- en: You’ll be using SQLite, a portable database that stores data in a single file
    by default (www.sqlite.org/index.html). This is convenient, compared to more complex
    database systems, because you can start from scratch by deleting the file if something
    goes wrong.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用SQLite，这是一个便携式数据库，默认情况下通过单个文件存储数据(www.sqlite.org/index.html)。与更复杂的数据库系统相比，这很方便，因为如果出现问题，你可以从删除文件开始从头开始。
- en: '|  |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Despite being one of the most widely used databases, SQLite is installed on
    only some operating systems by default. I recommend downloading a precompiled
    binary for your operating system from the official download page ([https://sqlite.org/download.html](https://sqlite.org/download.html)).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管SQLite是最广泛使用的数据库之一，但默认情况下，它只在一些操作系统上安装。我建议从官方下载页面下载适用于您的操作系统的预编译二进制文件([https://sqlite.org/download.html](https://sqlite.org/download.html))。
- en: '|  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Starting in the database module, you’ll create a `Database-Manager` class for
    manipulating data in the database. Python provides a built-in sqlite3 module,
    which you can use to get a connection to the database, make queries, and iterate
    over results. SQLite databases are usually a single file with a .db extension;
    if you make a sqlite3 connection to a file that doesn’t exist, the module will
    create it for you.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据库模块开始，您将创建一个`Database-Manager`类来操作数据库中的数据。Python提供了一个内置的sqlite3模块，您可以使用它来获取数据库连接、执行查询和遍历结果。SQLite数据库通常是一个具有.db扩展名的单个文件；如果您将sqlite3连接到一个不存在的文件，模块会为您创建它。
- en: 'The database module provides most of what you need to manage bookmark data,
    including the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库模块提供了您管理书签数据所需的大部分功能，包括以下内容：
- en: Creating a table (for initializing the database)
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个表（用于初始化数据库）
- en: Adding or deleting a record
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加或删除记录
- en: Listing the records in a table
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出表中的记录
- en: Selecting and sorting records from a table based on some criteria
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据某些标准从表中选择和排序记录
- en: Counting the number of records in a table
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算表中记录的数量
- en: How can these tasks be broken down further? Each seems somewhat separate, from
    the business logic perspective described earlier, but what about at the persistence
    layer? Most of the activities described can be achieved by constructing an appropriate
    SQL statement and executing it. Executing it requires a connection to the database,
    which requires the path to the database file.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些任务如何进一步分解？从之前描述的业务逻辑角度来看，每个任务似乎都是相对独立的，但在持久化层呢？大多数描述的活动都可以通过构建适当的SQL语句并执行它来实现。执行它需要与数据库建立连接，这需要数据库文件的路径。
- en: Whereas managing the persistence is a high-level concern, these individual concerns
    are what you get when you peel open the persistence layer. They should each be
    separate as well. First things first, though—you need a connection to the database.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然管理持久性是一个高级关注点，但这些个别关注点是在您打开持久化层时获得的。它们应该各自独立。首先，您需要与数据库建立连接。
- en: '|  |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Working with databases**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据库操作**'
- en: Many smart people have produced wonderful and robust packages that make working
    with databases in Python easier. SQLAlchemy (www.sqlalchemy.org) is a widely used
    tool for not only interacting with databases, but abstracting data models via
    an *object-relational mapping* (ORM). An ORM allows you to treat database records
    as objects in languages like Python, without worrying much about the details of
    a database at all. The Django web framework also provides an ORM for writing data
    models.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 许多聪明的人已经制作了出色且健壮的包，使得在Python中使用数据库变得更加容易。SQLAlchemy（www.sqlalchemy.org）是一个广泛使用的工具，不仅用于与数据库交互，还通过*对象关系映射*（ORM）抽象数据模型。ORM允许您在Python等语言中将数据库记录视为对象，而不必过多担心数据库的细节。Django
    Web框架也提供ORM来编写数据模型。
- en: In the spirit of learning by doing, you’ll write the database interaction code
    yourself in this chapter. It’s limited to the scope of Bark, but it can be added
    to or replaced if you’d like to do more with the rest of the application. If you
    need to use a database in future projects, consider whether you want to write
    your database code from scratch or use one of these third-party packages instead.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在“做中学”的精神下，您将在本章中自己编写数据库交互代码。它限于Bark的范围，但如果您想对应用程序的其他部分做更多操作，可以添加或替换它。如果您需要在未来的项目中使用数据库，考虑您是想从头开始编写数据库代码还是使用这些第三方包之一。
- en: '|  |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: CREATING AND CLOSING THE DATABASE CONNECTION
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建和关闭数据库连接
- en: While Bark is running, it needs only one connection to the database—it can reuse
    this connection for all its operations. To make this connection, you can use `sqlite3
    .connect`, which accepts the path of the database file to which it should connect.
    Again, if the file does not exist, it will be created.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在Bark运行期间，它只需要一个数据库连接——它可以重用此连接进行所有操作。要建立此连接，您可以使用`sqlite3 .connect`，它接受应连接到的数据库文件的路径。再次强调，如果文件不存在，它将被创建。
- en: The `__init__` for `DatabaseManager` should
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`DatabaseManager`的`__init__`应该'
- en: Accept an argument containing the path to the database file (Don’t hardcode
    it; separate your concerns!)
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受一个包含数据库文件路径的参数（不要硬编码；分离关注点！）
- en: Use the database file path to create a SQLite connection using `sqlite3 .connect(path)`
    and store it as an instance attribute
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用数据库文件路径通过`sqlite3 .connect(path)`创建SQLite连接并将其存储为实例属性
- en: It’s good practice to close the connection to the SQLite database when the program
    finishes, to limit the possibility of data corruption. For symmetry, the `__del__`
    for `DatabaseManager` should close the connection with the connection’s `.close()`
    method.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序结束时关闭与 SQLite 数据库的连接是一个好习惯，以限制数据损坏的可能性。为了对称性，`DatabaseManager` 的 `__del__`
    应该使用连接的 `.close()` 方法关闭连接。
- en: This will serve as the foundation for executing statements.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为执行语句提供基础。
- en: '[PRE0]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* Creates and stores a connection to the database for later use**'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建并存储数据库连接以供以后使用**'
- en: '***2* Cleans up the connection when done, to be safe**'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 执行完成后清理连接，以确保安全**'
- en: EXECUTING STATEMENTS
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行语句
- en: Your `DatabaseManager` will need a way to execute statements. These statements
    have a couple of things in common, so encapsulating those aspects into a reusable
    method will reduce the likelihood of errors from rewriting the same code each
    time you want to execute a new kind of statement.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 `DatabaseManager` 需要一种执行语句的方法。这些语句有几个共同点，因此将这些方面封装到可重用的方法中可以减少在每次想要执行新类型的语句时重写相同代码的错误可能性。
- en: Some SQL statements return data; these statements are called *queries*. Sqlite3
    manages query results with a concept called a *cursor*. Using a cursor to execute
    a statement lets you iterate over the results it returns. Statements that aren’t
    queries (`INSERT`, `DELETE`, and so on) don’t return any results, but the cursor
    manages this by returning an empty list.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 SQL 语句返回数据；这些语句被称为*查询*。Sqlite3 使用一个称为*光标*的概念来管理查询结果。使用光标执行语句允许你遍历它返回的结果。不是查询的语句（如
    `INSERT`、`DELETE` 等）不返回任何结果，但光标通过返回一个空列表来管理这一点。
- en: Write an `_execute` method on `DatabaseManager` that you can use to execute
    all statements using a cursor, returning a result that you can choose to use where
    you need to. The `_execute` method should
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `DatabaseManager` 上编写一个 `_execute` 方法，你可以使用它来通过光标执行所有语句，返回一个你可以选择在需要的地方使用的对象。`_execute`
    方法应该
- en: Accept a statement as a string argument
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受一个字符串形式的语句作为参数
- en: Get a cursor from the database connection
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数据库连接获取一个光标
- en: Execute a statement using the cursor (more on this shortly)
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用光标执行一个语句（关于这个稍后会有更多介绍）
- en: Return the cursor, which has stored the result of the executed statement (if
    any)
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回光标，它已存储执行语句的结果（如果有）
- en: '[PRE1]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* Creates the cursor**'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建光标**'
- en: '***2* Uses the cursor to execute the SQL statement**'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用光标执行 SQL 语句**'
- en: '***3* Returns the cursor, which has stored the results**'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 返回光标，它已存储了结果**'
- en: Statements that aren’t queries usually manipulate data, and if anything bad
    happens while they’re executing, the data could become corrupted. Databases guard
    against this with a feature called a *transaction*. If a statement executing within
    a transaction fails or is otherwise interrupted, the database will roll back to
    its last known working state. Sqlite3 lets you use the connection object to create
    a transaction via a *context manager*, a Python block using the `with` keyword
    that provides some special behavior when the code enters and exits the block.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通常不是查询的语句会操作数据，如果在执行过程中发生任何问题，数据可能会被损坏。数据库通过一个称为*事务*的功能来防止这种情况。如果一个语句在事务中执行失败或被其他方式中断，数据库将回滚到最后已知的工作状态。Sqlite3
    允许你通过一个*上下文管理器*来创建事务，这是一个使用 `with` 关键字的 Python 块，它在代码进入和退出块时提供一些特殊行为。
- en: 'Update `_execute` to put the `cursor` creation, execution, and return inside
    a transaction, like the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 `_execute` 以将 `cursor` 的创建、执行和返回放在一个事务中，如下所示：
- en: '[PRE2]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* This creates a database transaction context.**'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这创建了一个数据库事务上下文。**'
- en: '***2* This happens within the database transaction.**'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 这是在数据库事务中发生的。**'
- en: 'Using `.execute` inside a transaction will get you where you need to go, functionally
    speaking. But it’s a good security practice to use placeholders for real values
    in SQL statements to prevent users from doing malicious things with specially
    crafted queries.^([[1](#ch06fn01)]) Update `_execute` to accept two things:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在事务中使用 `.execute` 可以从功能上达到目的。但是，使用占位符在 SQL 语句中放置真实值是一个好的安全习惯，以防止用户使用精心制作的查询进行恶意操作。[^1](#ch06fn01)]
    更新 `_execute` 以接受两个参数：
- en: ¹
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See the Wikipedia article on SQL injection: [https://en.wikipedia.org/wiki/SQL_injection](https://en.wikipedia.org/wiki/SQL_injection).'
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参考维基百科关于 SQL 注入的文章：[https://en.wikipedia.org/wiki/SQL_injection](https://en.wikipedia.org/wiki/SQL_injection)。
- en: A SQL statement as a string, possibly containing placeholders
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含占位符的 SQL 语句字符串
- en: A list of values to fill in the placeholders in the statement
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填充语句中占位符的值列表
- en: 'The method should then execute the statement by passing both arguments to the
    cursor’s `execute`, which accepts the same arguments. It should look something
    like the following snippet:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，该方法应通过将两个参数传递给游标的`execute`方法来执行语句，该方法接受相同的参数。它看起来可能像以下片段：
- en: '[PRE3]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* values is optional; some statements don’t have placeholders to fill in.**'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 值是可选的；一些语句没有占位符需要填充。**'
- en: '***2* Executes the statement, providing any passed-in values to the placeholders**'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 执行语句，提供任何传递给占位符的值**'
- en: Now you have a database connection and the ability to execute arbitrary statements
    on that connection. Remember that the connection is managed for you automatically
    when you create a `DatabaseManager` instance, so you don’t need to think about
    how it’s opened and closed, unless you want to change it. Now, statement execution
    is managed within the `_execute` method, so you also don’t need to think about
    *how* a statement is executed; you only need to tell it *what* statement to execute.
    This is the power of separating your concerns.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经建立了数据库连接，并且能够在该连接上执行任意语句。记住，当你创建`DatabaseManager`实例时，连接会自动为你管理，因此你不需要考虑它是如何打开和关闭的，除非你想更改它。现在，语句执行是在`_execute`方法中管理的，因此你也不需要考虑*如何*执行一个语句；你只需要告诉它*要执行什么*语句。这就是分离关注点的力量。
- en: Now that you’ve got these building blocks, it’s time to develop some database
    interactions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经拥有了这些构建块，是时候开发一些数据库交互了。
- en: CREATING TABLES
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建表格
- en: 'One of the first things you’ll need is a database table in which to store your
    bookmark data. You’ll have to *create* this table using a SQL statement. Because
    the concerns of connecting to the database and executing statements are now abstracted,
    the work of creating a table includes the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要的第一件事是存储书签数据的数据库表格。你必须使用SQL语句来*创建*这个表格。因为连接数据库和执行语句的关注点现在是抽象的，创建表格的工作包括以下内容：
- en: Determine the column names for the table.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定表格的列名。
- en: Determine the data type of each column.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定每列的数据类型。
- en: Construct the right SQL statement to create a table with those columns.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建正确的SQL语句来创建具有那些列的表格。
- en: 'Remember that each bookmark has an ID, title, URL, optional notes, and the
    date it was added. The data type and constraints for each column follow:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，每个书签都有一个ID、标题、URL、可选的备注以及添加日期。每列的数据类型和约束如下：
- en: '*ID*—The ID is the *primary key* of the table, or the main identifier of each
    record. It should automatically increment each time a new record is added, using
    the `AUTOINCREMENT` keyword. This column is an `INTEGER` type; the rest are `TEXT`.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ID*—ID是表的*主键*，或每条记录的主要标识符。每次添加新记录时，它应自动递增，使用`AUTOINCREMENT`关键字。该列是`INTEGER`类型；其余都是`TEXT`类型。'
- en: '*Title*—The title is required because it’s hard to skim your existing bookmarks
    if they’re only URLs. You can tell SQLite the column can’t be empty by using the
    `NOT NULL` keyword.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*标题*—标题是必需的，因为如果你只有URL，很难浏览你的现有书签。你可以通过使用`NOT NULL`关键字来告诉SQLite该列不能为空。'
- en: '*URL*—The URL is required, so it gets `NOT NULL` as well.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*URL*—URL是必需的，因此它也具有`NOT NULL`属性。'
- en: '*Notes*—Notes for a bookmark are optional, so only the `TEXT` specifier is
    necessary.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*备注*—书签的备注是可选的，因此只需要`TEXT`指定符。'
- en: '*Date*—The date the bookmark was added is required, so it gets `NOT NULL`.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*日期*—添加书签的日期是必需的，因此它具有`NOT NULL`属性。'
- en: A table creation statement in SQLite uses the `CREATE TABLE` keywords, followed
    by the table name, the list of columns, and their data type information in parentheses.
    Because you’ll want Bark to create the table on startup if it doesn’t already
    exist, you can use `CREATE TABLE IF NOT EXISTS`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite中的表格创建语句使用`CREATE TABLE`关键字，后跟表名，括号内的列列表及其数据类型信息。因为你想让Bark在启动时创建表格（如果它还不存在），你可以使用`CREATE
    TABLE IF NOT EXISTS`。
- en: Based on the previous descriptions of the bookmark columns, what would the SQL
    statement look like for creating a bookmarks table? See if you can write it out,
    then come back to check your work against the following listing.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 根据之前对书签列的描述，创建书签表的SQL语句看起来会是什么样子？看看你是否能写出来，然后回到这里检查你的工作与以下列表是否一致。
- en: Listing 6.1\. The creation statement for a bookmarks table
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.1\. 创建书签表的创建语句
- en: '[PRE4]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* The main ID of each record, which increments automatically as records
    are added**'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 每条记录的主要ID，它在添加记录时自动递增**'
- en: '***2* NOT NULL requires a column to be populated with a value.**'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* NOT NULL要求列必须填充一个值。**'
- en: You can now write your method for creating tables. Each column is identified
    by a name, like `title`, that maps to a data type and constraints, like `TEXT
    NOT NULL`, so a dictionary seems like an appropriate Python type for representing
    columns. The method needs to
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以编写创建表的方法了。每个列都通过一个名称，如`title`，映射到一个数据类型和约束，如`TEXT NOT NULL`，因此字典似乎是一个合适的Python类型来表示列。该方法需要
- en: 'Accept two arguments: the name of the table to create, and a dictionary of
    column names mapped to their data types and constraints'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受两个参数：要创建的表的名称，以及列名称映射到其数据类型和约束的字典
- en: Construct a `CREATE TABLE` SQL statement like the one shown earlier
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个类似于之前显示的`CREATE TABLE` SQL语句
- en: Execute the statement using `DatabaseManager._execute`
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`DatabaseManager._execute`执行该语句
- en: Try writing the `create_table` method now, and then check back to see how it
    compares to the following listing.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试编写`create_table`方法，然后回头看看它与以下列表有何不同。
- en: Listing 6.2\. Creating a SQLite table
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.2\. 创建SQLite表
- en: '[PRE5]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* Constructs the column definitions, with their data types and constraints**'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 构建列定义，包括其数据类型和约束**'
- en: '***2* Constructs the full create table statement and executes it**'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 构建完整的创建表语句并执行**'
- en: '|  |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**A note on generalization**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于泛化的说明**'
- en: Right now, you need only the `bookmarks` table for Bark. I’ve already argued
    in this book that early optimization is a no-no, and the same is true for generalization.
    So why make a general-use `create_table` method?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你只需要为Bark使用`bookmarks`表。我已经在这本书中论证过早期优化是不必要的，同样的，泛化也是如此。那么为什么还要创建一个通用的`create_table`方法呢？
- en: When I start building a method with hardcoded values, I check to see if it’s
    much work to parameterize those values with arguments to the method. For example,
    replacing the string `'bookmarks'` with a `table_name` string argument isn’t much
    work. The columns and their data types follow similarly. Using this approach,
    the `create_table` method can be made general enough to create most any table
    you’ll need.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当我开始使用硬编码的值构建一个方法时，我会检查将这些值参数化为方法参数是否需要很多工作。例如，将字符串`'bookmarks'`替换为`table_name`字符串参数并不需要太多工作。列及其数据类型也是如此。使用这种方法，`create_table`方法可以足够通用，以创建你需要的任何表格。
- en: '|  |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You’ll use this method later on to create a `bookmarks` table, which is what
    Bark will interact with to manage bookmarks as you develop the application.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用此方法稍后创建`bookmarks`表，这是Bark在开发应用程序时将与之交互以管理书签的方式。
- en: ADDING RECORDS
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加记录
- en: Now that you can create a table, you need to be able to add bookmark records
    to it. This is the “C” in CRUD ([figure 6.4](#ch06fig04)).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你能够创建一个表，你需要能够向其中添加书签记录。这是CRUD中的“C”部分 ([图6.4](#ch06fig04))。
- en: 'SQLite expects the `INSERT INTO` keyword, followed by the table name, to indicate
    the intent to add a new record to the table. This is followed by the list of columns
    you’re supplying values for in parentheses, the `VALUES` keyword, and then the
    values you’re supplying in parentheses. A record insert statement in SQLite looks
    like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite期望`INSERT INTO`关键字，后跟表名，以表示向表中添加新记录的意图。这后面跟着你提供的列列表，括号中的`VALUES`关键字，然后是提供的值，括号中的值。SQLite中的记录插入语句看起来像这样：
- en: '[PRE6]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Figure 6.4\. Creation is the most basic operation necessary for CRUD, so it’s
    the crux of many systems.
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.4\. 创建是CRUD操作中最基本的操作，因此它是许多系统的核心。
- en: '![](../Images/f0136-01.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0136-01.jpg)'
- en: Remember that it’s a good practice to use placeholders instead, as in the `_execute`
    method earlier. What parts of the preceding query should use placeholders?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，使用占位符是一个好习惯，就像之前在`_execute`方法中做的那样。前述查询的哪些部分应该使用占位符？
- en: '`bookmarks`'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bookmarks`'
- en: '`title`, `url`, and so on'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`title`，`url`等'
- en: '`''GitHub''`, `''https://github.com''`, and so on'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`''GitHub''`, `''https://github.com''`, 等等'
- en: All of the above
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有上述内容
- en: 'Only places where literal values go can use placeholders in statements, so
    3 is the correct answer. An `INSERT` statement for the `bookmarks` table, with
    placeholders, looks like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在语句中放置文字值的地方才能使用占位符，因此3是正确答案。一个带有占位符的`bookmarks`表的`INSERT`语句看起来像这样：
- en: '[PRE7]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To construct this statement, you’ll need to write an `add` method in `DatabaseManager`
    that
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建这个语句，你需要在`DatabaseManager`中编写一个`add`方法，
- en: 'Accepts two arguments: the name of the table, and a dictionary that maps column
    names to column values'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受两个参数：表的名称，以及映射列名称到列值的字典
- en: Constructs a placeholder string (a `?` for each column specified)
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个占位符字符串（每个指定的列一个 `?`）
- en: Constructs the string of the column names
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建列名称的字符串
- en: Gets the column values as a tuple (A dictionary’s `.values()` returns a `dict_
    values` object, which happens not to work with sqlite3’s `execute` method.)
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取列值作为元组（字典的 `.values()` 返回一个 `dict_values` 对象，但不幸的是它不与 sqlite3 的 `execute`
    方法一起工作。）
- en: Executes the statement with `_execute`, passing the SQL statement with placeholders
    and the column values as separate arguments
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `_execute` 执行语句，传递带有占位符的 SQL 语句和列值作为单独的参数
- en: Write the `add` method now, and check back with the following listing to see
    how it compares.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编写 `add` 方法，并查看以下列表以了解其比较。
- en: Listing 6.3\. Adding a record to a SQLite table
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.3\. 向 SQLite 表中添加记录
- en: '[PRE8]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* The keys of the data are the names of the columns.**'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 数据的键是列的名称。**'
- en: '***2* .values() returns a dict_values object, but execute needs a list or tuple.**'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* .values() 返回一个 dict_values 对象，但 execute 需要一个列表或元组。**'
- en: '***3* Passes the optional values argument to _execute**'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将可选的值参数传递给 _execute**'
- en: USING CLAUSES TO LIMIT ACTION SCOPE
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用子句限制操作范围
- en: To insert records into a database, all you need is the info to be inserted,
    but some database statements are used in tandem with one or more additional *clauses*.
    Clauses affect which records the statement will operate on. Using a `DELETE` statement
    without a clause, for example, could end up deleting all the records in the table.
    You don’t want that.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要将记录插入数据库，您只需要插入的信息，但某些数据库语句与一个或多个附加 *子句* 一起使用。子句会影响语句将操作哪些记录。例如，不使用子句的 `DELETE`
    语句可能会导致删除表中的所有记录。您不希望这样。
- en: '`WHERE` clauses can be appended to several kinds of statements to limit the
    statement’s effect to records matching that criteria. You can combine multiple
    `WHERE` criteria using `AND` or `OR`. In Bark, for example, each bookmark record
    has an ID, so you can limit a statement to acting on a particular record by its
    ID with a clause like `WHERE id = 3`.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`WHERE` 子句可以附加到几种类型的语句上，以限制语句的效果仅限于匹配该标准的记录。您可以使用 `AND` 或 `OR` 组合多个 `WHERE`
    标准。例如，在 Bark 中，每个书签记录都有一个 ID，因此您可以使用类似 `WHERE id = 3` 的子句来限制语句仅对特定记录进行操作。'
- en: This kind of limiting is useful both for queries (to search for specific records)
    and for regular statements. Clauses will be useful when you need to delete specific
    records.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这种限制对于查询（搜索特定记录）和常规语句都很有用。当您需要删除特定记录时，子句将很有用。
- en: DELETING RECORDS
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 删除记录
- en: After a bookmark has outlived its usefulness, you need a way to delete it ([figure
    6.5](#ch06fig05)). To delete a bookmark, you can issue a `DELETE` statement to
    the database, using a `WHERE` clause to specify a bookmark by its ID.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当书签已经失去其有用性后，您需要一种方法来删除它（[图 6.5](#ch06fig05)）。要删除书签，您可以向数据库发出 `DELETE` 语句，使用
    `WHERE` 子句通过其 ID 指定书签。
- en: Figure 6.5\. Delete is the counterpart of create, so most systems cover this
    operation as well.
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.5\. 删除是创建的对立面，因此大多数系统也覆盖了这项操作。
- en: '![](../Images/f0138-01.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0138-01.jpg)'
- en: 'In SQLite, the statement to delete the bookmark with an ID of 3 looks like
    this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLite 中，删除 ID 为 3 的书签的语句如下所示：
- en: '[PRE9]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As in the `create_table` and `add` methods, you can represent the criteria as
    a dictionary that maps column names to the values you want to match. Write a `delete`
    method that
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `create_table` 和 `add` 方法一样，您可以将标准表示为一个字典，该字典将列名称映射到您想要匹配的值。编写一个 `delete`
    方法，
- en: 'Accepts two arguments: the table name to delete records from, and a dictionary
    mapping column names to the value to match on. The criteria should be a required
    argument, because you don’t want to delete all your records.'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受两个参数：要删除记录的表名，以及将列名称映射到匹配值的字典。标准应该是必需的参数，因为您不希望删除所有记录。
- en: Constructs a string of placeholders for the `WHERE` clause.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `WHERE` 子句构建一个占位符字符串。
- en: Constructs the full `DELETE FROM` query and executes it with `_execute`.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建完整的 `DELETE FROM` 查询，并通过 `_execute` 执行它。
- en: Check your results against the following listing.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的结果与以下列表进行比较。
- en: Listing 6.4\. Deleting records in SQLite
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.4\. 在 SQLite 中删除记录
- en: '[PRE10]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* The criteria argument isn’t optional here; all records would be deleted
    without any criteria.**'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在这里，标准参数不是可选的；如果没有标准，将删除所有记录。**'
- en: '***2* Uses the values argument of _execute as the values to match against**'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用 _execute 的值参数作为匹配的值**'
- en: SELECTING AND SORTING RECORDS
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 选择和排序记录
- en: You can add and remove records from a table now, but how can you retrieve them?
    Aside from creating and deleting information, you’ll want to be able to read what
    you’ve already stored ([figure 6.6](#ch06fig06)).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以添加和删除表中的记录，但如何检索它们？除了创建和删除信息外，您还希望能够读取您已经存储的内容 ([图 6.6](#ch06fig06))。
- en: Figure 6.6\. Reading existing data is usually a necessary part of a CRUD application.
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.6\. 读取现有数据通常是 CRUD 应用程序的一个必要部分。
- en: '![](../Images/f0139-01.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0139-01.jpg)'
- en: 'You can create a query statement in SQLite using `SELECT` `*` `FROM bookmarks`
    (the `*` means “all columns”) and some criteria:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `SELECT` `*` `FROM bookmarks` (这里的 `*` 表示“所有列”) 和一些条件在 SQLite 中创建一个查询语句：
- en: '[PRE11]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Additionally, you can sort these results by a specific column using an `ORDER
    BY` clause:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以使用 `ORDER BY` 子句按特定列对这些结果进行排序：
- en: '[PRE12]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* This orders the results by the title column in ascending order.**'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这将按标题列的升序排序结果。**'
- en: 'Again, you should use placeholders where there are literal values in the query:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您应该在查询中存在文字值的地方使用占位符：
- en: '[PRE13]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Your `select` method will look somewhat similar to the `delete` method, except
    that `criteria` can be optional. (It will fetch all records by default.) It should
    also accept an optional `order_by` argument that specifies a column to sort the
    results by (the default is the primary key of the table). Using `delete` as a
    guide, write `select` now and come back to compare with the following listing
    when you’re done.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `select` 方法将与 `delete` 方法有些相似，但 `criteria` 可以是可选的。（默认情况下，它将检索所有记录。）它还应接受一个可选的
    `order_by` 参数，指定按哪个列排序结果（默认是表的主键）。以 `delete` 为指导，现在编写 `select` 并在完成后与以下列表进行比较。
- en: Listing 6.5\. A method for selecting SQL table data
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.5\. 选择 SQL 表数据的方法
- en: '[PRE14]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1* Criteria can be empty by default, because selecting all records in the
    table is all right.**'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 条件可以默认为空，因为选择表中的所有记录是可以接受的。**'
- en: '***2* Constructs the WHERE clause to limit the results**'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 构建用于限制结果的 WHERE 子句**'
- en: '***3* Constructs the ORDER BY clause to sort the results**'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 构建用于排序结果的 ORDER BY 子句**'
- en: '***4* This time, you want the return value from _execute to iterate over the
    results.**'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 这次，您希望从 _execute 返回的值迭代结果。**'
- en: You’ve now created a database connection; written an `_execute` method for executing
    arbitrary SQL statements with placeholders in a transaction; and written methods
    to add, query, and delete records. This is about all you’ll need for manipulating
    a SQLite database for the moment. You just finished a database manager in fewer
    than 100 lines of code. Nice work.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已创建了一个数据库连接；编写了一个 `_execute` 方法，用于在事务中执行带有占位符的任意 SQL 语句；并编写了添加、查询和删除记录的方法。对于目前来说，您需要做的关于操作
    SQLite 数据库的事情大概就是这些了。您只用不到 100 行代码就完成了一个数据库管理器。做得不错。
- en: Next, you’ll develop the business logic that interacts with the persistence
    layer.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将开发与持久化层交互的业务逻辑。
- en: 6.3.2\. The business logic layer
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.2\. 业务逻辑层
- en: Now that the persistence layer for Bark is in place, you can work on the layer
    that figures out what to put in and get out of the persistence layer ([figure
    6.7](#ch06fig07)).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Bark的持久化层已经就绪，您可以开始工作于确定从持久化层中放入和取出的层 ([图 6.7](#ch06fig07))。
- en: Figure 6.7\. The business logic layer determines when and how data is read from
    or written to the persistence layer.
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.7\. 业务逻辑层确定何时以及如何从或写入持久化层的数据。
- en: '![](../Images/f0140-01.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0140-01.jpg)'
- en: 'When a user interacts with something in the presentation layer of Bark, Bark
    needs to trigger something to happen in the business logic and ultimately in the
    persistence layer. It might be tempting to do something like the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户与 Bark 的表示层中的某个元素交互时，Bark 需要触发业务逻辑层，最终触发持久化层中的某些操作。可能会有人想做一些类似以下的事情：
- en: '[PRE15]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: But this would couple the text presented to the user with the actions that need
    to be triggered. You would have new conditions for each menu option, and if you
    wanted multiple options to trigger the same command, or you wanted to change the
    text, you would have to refactor some code. It would be nice if the presentation
    layer were the only place that knows about the menu option text displayed to the
    user.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 但这样会将用户展示的文本与需要触发的操作耦合起来。您将为每个菜单选项设置新的条件，如果您想触发多个选项执行相同的命令，或者您想更改文本，您可能需要重构一些代码。如果表示层是唯一知道显示给用户菜单选项文本的地方，那就太好了。
- en: Each action is kind of like a *command* that needs to be *executed* in response
    to a user’s menu choice. By encapsulating the logic of each action as a command
    object, and providing a consistent way to trigger them via an `execute` method,
    these actions can be decoupled from the presentation layer. The presentation layer
    can then point menu options to commands without worrying about how those commands
    work. This is called the *command pattern*.^([[2](#ch06fn02)])
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 每个动作都类似于一个需要根据用户的菜单选择来**执行**的**命令**。通过将每个动作的逻辑封装为命令对象，并通过`execute`方法提供一种一致的方式来触发它们，可以将这些动作与表示层解耦。然后，表示层可以将菜单选项指向命令，而无需担心这些命令的工作方式。这被称为**命令模式**。^([[2](#ch06fn02)])
- en: ²
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See Wikipedia’s “Command pattern” article for more on this pattern: https://en.wikipedia.org/wiki/Command
    _pattern.'
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参考维基百科的“命令模式”文章以了解更多关于此模式的信息：https://en.wikipedia.org/wiki/Command _pattern.
- en: You’ll develop each of the CRUD actions and some peripheral functionality as
    commands in the business logic layer.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你将开发每个CRUD操作和一些外围功能，作为业务逻辑层中的命令。
- en: CREATING THE BOOKMARKS TABLE
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建书签表**'
- en: Now that you’re working in the business logic layer, create a new “commands”
    module to house all the commands you’re going to write. Because most of the commands
    will need to make use of the `DatabaseManager`, import it from the database module
    and create an instance of it (called `db`) to be used throughout the commands
    module. Remember that its `__init__` method requires the file path to a SQLite
    database; I suggest calling it bookmarks.db. Leaving out any leading path will
    create the database file in the same directory as the Bark code.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你正在业务逻辑层工作，创建一个新的“commands”模块来存放你将要编写的所有命令。因为大多数命令将需要使用`DatabaseManager`，从数据库模块导入它并创建其实例（称为`db`）以在命令模块中使用。记住，它的`__init__`方法需要指向SQLite数据库的文件路径；我建议将其命名为bookmarks.db。省略任何前导路径将在与Bark代码相同的目录中创建数据库文件。
- en: Because you’ll need to initialize the bookmarks database table if it doesn’t
    already exist, start by writing a `CreateBookmarksTableCommand` class whose `execute`
    method creates the table for your bookmarks. You can make use of the `db.create_table`
    method you wrote earlier to create your bookmarks table. Later in the chapter,
    you’ll trigger this command to run when Bark starts up. Check your work against
    the following listing.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 因为如果书签数据库表不存在，你需要初始化它，所以首先编写一个`CreateBookmarksTableCommand`类，其`execute`方法创建你的书签表。你可以使用你之前编写的`db.create_table`方法来创建你的书签表。在章节的后面部分，你将在Bark启动时触发此命令的运行。对照以下列表检查你的工作。
- en: Listing 6.6\. A command for creating a table
  id: totrans-232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**列表6.6\. 创建表的命令**'
- en: '[PRE16]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1* Remember, sqlite3 will automatically create this database file if it
    doesn’t exist.**'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 记住，sqlite3如果不存在，将自动创建此数据库文件。**'
- en: '***2* This will eventually be called when Bark starts up.**'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 这将在Bark启动时最终被调用。**'
- en: '***3* Creates the bookmarks table with the necessary columns and constraints**'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 创建带有必要列和约束的书签表**'
- en: Notice that the command is only aware of its duties (calling persistence layer
    logic) and the interface of its dependency (`DatabaseManager.create_table`). This
    is loose coupling, thanks in part to separating the persistence logic and (eventually)
    the presentation logic. You should be seeing the benefits of separation of concerns
    more and more clearly as you work through these exercises.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该命令只知道自己的职责（调用持久层逻辑）以及其依赖项的接口（`DatabaseManager.create_table`）。这是松耦合，部分原因在于将持久逻辑和（最终）表示逻辑分离。随着你完成这些练习，你应该会越来越清楚地看到分离关注点的益处。
- en: ADDING BOOKMARKS
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**添加书签**'
- en: To add a bookmark, you’ll need to pass data received from the presentation layer
    on to the persistence layer. The data will be passed as a dictionary mapping column
    names to values. This is a great example of code relying on a shared interface
    rather than the specifics of an implementation. If the persistence layer and the
    business logic layer agree on a data format, they can each do what they need to,
    as long as the data format stays consistent.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加书签，你需要将来自表示层的接收到的数据传递到持久层。数据将以字典的形式传递，映射列名到值。这是一个代码依赖于共享接口而不是实现细节的绝佳例子。如果持久层和业务逻辑层就数据格式达成一致，它们可以各自完成所需的工作，只要数据格式保持一致。
- en: Write an `AddBookmarkCommand` class that will perform this operation. This class
    will
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个`AddBookmarkCommand`类来执行此操作。此类将
- en: Expect a dictionary containing the title, URL, and (optional) notes information
    for a bookmark.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预期一个包含书签标题、URL和（可选）备注信息的字典。
- en: Add the current datetime to the dictionary as `date_added`. To get the current
    time in UTC, in a standardized format with wide compatibility, use `datetime .datetime.utcnow().isoformat()`.^([[3](#ch06fn03)])
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前日期时间添加到字典中作为`date_added`。为了获取UTC时间，使用`datetime.datetime.utcnow().isoformat()`，这是一种标准化的格式，具有广泛的兼容性。^([[3](#ch06fn03)])
- en: ³
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See Wikipedia’s article on “ISO 8601” for more information on this time format:
    https://en.wikipedia.org/ wiki/ISO_8601.'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 查阅维基百科上关于“ISO 8601”的文章以获取更多关于此时间格式的信息：https://en.wikipedia.org/wiki/ISO_8601.
- en: Insert the data into the bookmarks table using the `DatabaseManager.add` method.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`DatabaseManager.add`方法将数据插入书签表。
- en: Return a success message that will eventually be displayed by the presentation
    layer.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回一个成功消息，该消息最终将由演示层显示。
- en: Check your work against the following listing.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的工作与以下列表进行对比检查。
- en: Listing 6.7\. A command for adding a bookmark
  id: totrans-249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.7\. 添加书签的命令
- en: '[PRE17]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1* Adds the current datetime as the record is added**'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 当记录添加时添加当前日期时间**'
- en: '***2* Using the DatabaseManager.add method makes short work of adding a record.**'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用DatabaseManager.add方法可以轻松添加记录。**'
- en: '***3* You’ll use this message in the presentation layer later.**'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 你将在演示层稍后使用此消息。**'
- en: You’ve now written all the business logic needed for creating bookmarks. Next,
    you’ll want to be able to list the bookmarks you’ve added.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经编写了创建书签所需的所有业务逻辑。接下来，你将想要能够列出你添加的书签。
- en: LISTING BOOKMARKS
  id: totrans-255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列出书签
- en: Bark needs to be able to show you the bookmarks you’ve saved—without that, Bark
    wouldn’t be of much use. You’re going to write a `ListBookmarksCommand` that will
    provide the logic for displaying the bookmarks in the database.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Bark需要能够显示你保存的书签——没有这个功能，Bark将没有多少用处。你将编写一个`ListBookmarksCommand`，它将提供在数据库中显示书签的逻辑。
- en: You’ll want to make use of the `DatabaseManager.select` method to get the bookmarks
    from the database. By default, SQLite sorts records by their order of creation
    (that is, by the primary key of the table), but it might also be useful to sort
    bookmarks by date or title. In Bark, bookmarks’ IDs and dates sort identically
    because they both strictly increase as you add bookmarks, but it’s good practice
    to sort explicitly by the column of interest in case that changes.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你将想要使用`DatabaseManager.select`方法从数据库中获取书签。默认情况下，SQLite按创建顺序（即表的主键顺序）排序记录，但按日期或标题排序书签可能也有用。在Bark中，书签的ID和日期按相同方式排序，因为当你添加书签时，它们都严格递增，但为了以防万一，按感兴趣的列显式排序是良好的实践。
- en: '`ListBookmarksCommand` should do the following:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListBookmarksCommand`应该执行以下操作：'
- en: Accept the column to order by, and save it as an instance attribute. You can
    set the default value to `date_added` if you like.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受要排序的列，并将其保存为实例属性。如果你愿意，可以将默认值设置为`date_added`。
- en: Pass this information along to `db.select` in its `execute` method.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将此信息传递给`db.select`的`execute`方法。
- en: Return the result (using the cursor’s `.fetchall()` method) because `select`
    is a query.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为`select`是一个查询，所以返回结果（使用游标的`.fetchall()`方法）。
- en: Write the command to list bookmarks, and come back to check your work against
    the following listing.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 编写列出书签的命令，然后回到检查你的工作与以下列表的对比。
- en: Listing 6.8\. A command to list existing bookmarks
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.8\. 列出现有书签的命令
- en: '[PRE18]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* You can create a version of this command for sorting by date or by title.**'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 你可以为此命令创建按日期或标题排序的版本。**'
- en: '***2* db.select returns a cursor you can iterate over to get the records.**'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* db.select返回一个可以迭代的游标以获取记录。**'
- en: Now you’ve got enough functionality to add bookmarks and view existing ones.
    The last step for managing bookmarks is a command for deleting them.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了添加书签和查看现有书签的功能。管理书签的最后一个步骤是删除它们的命令。
- en: DELETING BOOKMARKS
  id: totrans-268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 删除书签
- en: Similar to adding a new bookmark, the deletion of a bookmark requires some data
    to be passed from the presentation layer. This time, though, the data is simply
    an integer value representing the ID of the bookmark to delete.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 与添加新书签类似，删除书签需要从演示层传递一些数据。不过，这次数据只是一个表示要删除的书签ID的整数值。
- en: Write a `DeleteBookmarkCommand` command that accepts this information in its
    `execute` method and passes it to the `DatabaseManager.delete` method. Remember
    that `delete` accepts a dictionary mapping column names to values to match against;
    here, you’ll want to match the given value in the `id` column. Once the record
    is deleted, return a success message for use in the presentation layer.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 `DeleteBookmarkCommand` 命令，该命令在其 `execute` 方法中接受此信息，并将其传递给 `DatabaseManager.delete`
    方法。记住，`delete` 接受一个将列名映射到匹配值的字典；在这里，你将想要匹配 `id` 列中的给定值。一旦记录被删除，返回一个成功消息供表示层使用。
- en: Come back and check your work against the following listing.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 回来检查你的工作与以下列表是否一致。
- en: Listing 6.9\. A command to delete bookmarks
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.9\. 一个删除书签的命令
- en: '[PRE19]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* delete accepts a dictionary of column name, match value pairs.**'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* delete 接受一个列名、匹配值对的字典。**'
- en: QUITTING BARK
  id: totrans-275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 退出 Bark
- en: 'There’s one piece of polish left: a command for exiting Bark. A user could
    use the usual Ctrl-C method of stopping the Python program, but an option to exit
    is a little nicer.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下一点润色：一个退出 Bark 的命令。用户可以使用常用的 Ctrl-C 方法停止 Python 程序，但提供一个退出选项会更友好。
- en: Python provides the `sys.exit` function for stopping program execution. Write
    a `QuitCommand` whose `execute` method exits the program using this approach,
    then come back and check your work against the following listing.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了 `sys.exit` 函数用于停止程序执行。编写一个 `QuitCommand`，其 `execute` 方法使用这种方式退出程序，然后回来检查你的工作与以下列表是否一致。
- en: Listing 6.10\. A command to exit the program
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.10\. 一个退出程序的命令
- en: '[PRE20]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1* This should immediately exit Bark.**'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这应该立即退出 Bark。**'
- en: Now you can wipe the sweat from your brow . . . not because you’re done, but
    because you’ll be developing the presentation layer next.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以擦去额头上的汗水……不是因为完成了，而是因为你将开始开发表示层。
- en: 6.3.3\. The presentation layer
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.3\. 表示层
- en: Bark uses a command-line interface (CLI). Its presentation layer (the part the
    user sees, as shown in [figure 6.8](#ch06fig08)) is text in a terminal. Depending
    on the application, a CLI can run until the completion of a specific task, or
    it can keep running until the user explicitly exits. Because you wrote `QuitCommand`,
    you might guess that you’ll be doing the latter.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Bark 使用命令行界面 (CLI)。其表示层（用户所见的部分，如图 6.8 所示 [figure 6.8](#ch06fig08)）是终端中的文本。根据应用程序的不同，CLI
    可以运行到特定任务的完成，或者它可以持续运行，直到用户明确退出。由于你编写了 `QuitCommand`，你可能猜测你会做后者。
- en: 'The presentation layer of Bark contains an infinite loop:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Bark 的表示层包含一个无限循环：
- en: Clears the screen
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除屏幕
- en: Prints the menu options
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印菜单选项
- en: Gets the user’s choice
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取用户的选择
- en: Clears the screen and executes the command corresponding to the user’s choice
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除屏幕并执行用户选择的命令
- en: Waits for the user to review the result, pressing Enter when they’re done
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待用户查看结果，完成后按 Enter 键
- en: Figure 6.8\. The presentation layer shows users what actions can be taken and
    a way to trigger them.
  id: totrans-290
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.8\. 表示层显示了用户可以执行的操作以及触发它们的方式。
- en: '![](../Images/f0144-01.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0144-01.jpg)'
- en: Now that you’re working on the presentation layer, you’ll need to create a new
    bark module. It’s a good practice to put code for command-line applications into
    an `if` *`name`* `== '`*`main`*`':` block; this will make sure you don’t unintentionally
    execute the code in the module by importing the bark module somewhere. If you
    start with a Hello, World! type of program, you can do a quick check to make sure
    things are set up properly.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你正在开发表示层，你需要创建一个新的 bark 模块。将命令行应用程序的代码放入 `if` *`name`* `== '`*`main`*`':`
    块是一个好习惯；这将确保你不会意外地通过在其他地方导入 bark 模块来执行模块中的代码。如果你从一个 Hello, World! 类型的程序开始，你可以快速检查以确保一切设置正确。
- en: 'Start with the following in your bark module:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 bark 模块中开始以下内容：
- en: '[PRE21]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Try running `python bark.py` in your terminal; you should see `Welcome to Bark!`
    as a result. Now you can start hooking up the presentation layer to some business
    logic.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在终端中运行 `python bark.py`；你应该看到 `Welcome to Bark!` 作为结果。现在你可以开始将表示层连接到一些业务逻辑。
- en: DATABASE INITIALIZATION
  id: totrans-296
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 数据库初始化
- en: Remember that Bark needs to initialize the database, creating the bookmarks
    table if it doesn’t already exist. Import the commands module and update your
    code to execute the `CreateBookmarksTableCommand`, as shown in the following snippet.
    After making this update and running `python bark.py`, you won’t see any text
    output, but you should see that a bookmarks.db file is created.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Bark 需要初始化数据库，如果不存在，则创建书签表。导入命令模块，并更新你的代码以执行 `CreateBookmarksTableCommand`，如下面的代码片段所示。在做出此更新并运行
    `python bark.py` 后，你将看不到任何文本输出，但你应该看到创建了一个 bookmarks.db 文件。
- en: '[PRE22]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It may seem small, but you’ve just accomplished something pretty remarkable.
    This represents a full pass through all the layers of your *multitier architecture*.
    The presentation layer (the act of running bark.py, so far) has triggered a command
    in the business logic, which, in turn, set up a table in the persistence layer
    fit for storing bookmarks. Each layer knows just enough about its surroundings
    to do its job; things are well separated and loosely coupled. You’ll experience
    this a few more times as you start adding menu options to Bark that trigger more
    commands.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来很小，但你刚刚完成了一项相当了不起的事情。这代表了对你的 *多层架构* 所有层的完整遍历。表示层（到目前为止运行 bark.py 的行为）触发了业务逻辑中的命令，反过来，在持久层中设置了一个适合存储书签的表。每一层只需了解足够关于其周围环境的信息来完成其工作；事物被很好地分离，并且松散耦合。当你开始向
    Bark 添加触发更多命令的菜单选项时，你将再次体验到这一点。
- en: MENU OPTIONS
  id: totrans-300
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 菜单选项
- en: 'When you start Bark, it should present you with a menu of options that looks
    something like this:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动 Bark 时，它应该向你展示一个类似于以下内容的选项菜单：
- en: '[PRE23]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Each option has a keyboard shortcut and a descriptive title. If you look carefully,
    each of these options corresponds to one of the commands you wrote earlier. Because
    you wrote the commands using the command pattern, each command can be triggered
    the same way as the others—using its `execute` method. Commands differ only in
    what setup and input they require, and then from the presentation layer’s perspective
    they do whatever they do.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 每个选项都有一个键盘快捷键和一个描述性标题。如果你仔细观察，这些选项中的每一个都对应于你之前编写的一个命令。因为你使用了命令模式，每个命令都可以像其他命令一样被触发——使用它的
    `execute` 方法。命令之间的区别仅在于它们所需的设置和输入，以及从表示层的角度来看，它们执行了什么操作。
- en: Based on what you’ve learned about encapsulation, how would you go about hooking
    up the items in the presentation layer to the business logic they control?
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你对封装的了解，你将如何将表示层的项目连接到它们控制的业务逻辑？
- en: Use conditional logic to call the right `Command` class’s `execute` method based
    on the user input.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用条件逻辑根据用户输入调用正确的 `Command` 类的 `execute` 方法。
- en: Make a class that pairs the text to be displayed to the user and the command
    it triggers.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个将显示给用户的文本与触发它的命令配对的类。
- en: I recommend choice 2\. To hook each menu option up to the command it should
    trigger, you can create an `Option` class. The class’s `__init__` method can accept
    the name to display to the user in the menu, an instance of the command to execute
    when chosen by the user, and an optional preparation step (to get additional input
    from the user, for example). All of these can be stored as instance attributes.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我推荐选择 2。要将每个菜单选项连接到它应该触发的命令，你可以创建一个 `Option` 类。该类的 `__init__` 方法可以接受在菜单中显示给用户的名称、当用户选择时执行的命令的实例，以及可选的准备步骤（例如获取用户的额外输入）。所有这些都可以存储为实例属性。
- en: When chosen, an `Option` instance needs to
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择时，一个 `Option` 实例需要
- en: Run the specified preparation step, if any.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行指定的准备步骤（如果有）。
- en: Pass the return value from the preparation step, if any, to the specified command’s
    `execute` method.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将准备步骤的返回值（如果有），传递给指定命令的 `execute` 方法。
- en: Print the result of the execution. These are the success messages or bookmark
    results returned from the business logic.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印执行结果。这些是来自业务逻辑的成功消息或书签结果。
- en: An `Option` instance should be represented as its text description when shown
    to the user; you can use `__str__` to override the default behavior. Abstracting
    this work from the rest of the code that gets and validates user input allows
    you to keep your concerns separate.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 当向用户展示时，`Option` 实例应表示为其文本描述；你可以使用 `__str__` 来覆盖默认行为。将这项工作从获取和验证用户输入的其余代码中抽象出来，可以使你保持关注点的分离。
- en: Try writing the `Option` class, then check the following listing to see how
    you’ve done.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试编写 `Option` 类，然后查看以下列表，看看你做得怎么样。
- en: Listing 6.11\. Connecting menu text to business logic commands
  id: totrans-314
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.11。将菜单文本连接到业务逻辑命令
- en: '[PRE24]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1* The name displayed in the menu**'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在菜单中显示的名称**'
- en: '***2* An instance of the command to execute**'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 要执行的命令实例**'
- en: '***3* The optional preparation step to call before executing the command**'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在执行命令之前要调用的可选准备步骤**'
- en: '***4* choose will be called when the option is chosen by the user.**'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 当用户选择选项时将调用`choose`方法。**'
- en: '***5* Calls the preparation step if specified**'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 如果指定，则调用准备步骤**'
- en: '***6* Executes the command, passing in the data from the preparation, if any**'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 执行命令，传递准备阶段的数据（如果有的话）**'
- en: '***7* Represents the option as its name instead of the default Python behavior**'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 将选项表示为其名称，而不是默认的Python行为**'
- en: 'With the `Option` class in place, now is a good time to start hooking up more
    of the business logic you created earlier. Remember that you need to do a few
    things with each option:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Option`类就位后，现在是时候开始连接你之前创建的更多业务逻辑了。记住，你需要对每个选项做一些事情：
- en: Print the keyboard key for the user to enter to choose the option.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印用户输入以选择选项的键盘键。
- en: Print the option text.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印选项文本。
- en: Check if the user’s input matches an option and, if so, choose it.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查用户的输入是否与选项匹配，如果是，则选择它。
- en: What Python data structure would work well to hold all your options?
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 什么Python数据结构适合用来存储所有选项？
- en: '`list`'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`list`'
- en: '`set`'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`set`'
- en: '`dict`'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`dict`'
- en: Each keyboard key maps to a menu option, and you need to check the user’s input
    against the available options, so you need to keep those pairings stored somehow.
    Choice 3 is a good one because a `dict` can provide keyboard key and option pairs
    that you can also iterate over, with the dictionary’s `.items()` method, for printing
    the option text. I also recommend using `collections.OrderedDict` specifically,
    to ensure that your menu options will always be printed in the order you specify.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 每个键盘键映射到一个菜单选项，你需要检查用户的输入与可用选项是否匹配，因此你需要以某种方式存储这些配对。选择3是一个不错的选择，因为`dict`可以提供键盘键和选项配对，你可以使用字典的`.items()`方法迭代，以打印选项文本。我还建议特别使用`collections.OrderedDict`，以确保你的菜单选项始终按你指定的顺序打印。
- en: 'Add your options dictionary after `CreateBookmarksTableCommand` now, adding
    an item for each menu option. Once the dictionary is in place, create a `print_options`
    function that iterates over the options and prints them in the format you saw
    earlier:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CreateBookmarksTableCommand`之后添加你的选项字典，为每个菜单选项添加一个条目。一旦字典就位，创建一个`print_options`函数，该函数遍历选项，并以你之前看到的格式打印它们：
- en: '[PRE25]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Check your work with the following listing.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下列表检查你的工作。
- en: Listing 6.12\. Specifying and printing menu options
  id: totrans-335
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.12\. 指定和打印菜单选项
- en: '[PRE26]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: After you’ve added the menu options, running Bark should print all of the options
    you added. You can’t yet trigger them; for that, you’ll need to get some user
    input.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在你添加了菜单选项后，运行Bark应该会打印出你添加的所有选项。你目前还不能触发它们；为此，你需要获取一些用户输入。
- en: USER INPUT
  id: totrans-338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 用户输入
- en: 'With our overall goal of threading presentation to business logic to persistence,
    what remains to be added is a bit of interactivity with Bark users. The approach
    for getting the user’s desired option goes like this:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的总体目标是线程化展示到业务逻辑到持久化，剩下要添加的是与Bark用户的一点点交互。获取用户所需选项的方法如下：
- en: Prompt the user to enter a choice, using Python’s built-in `input` function.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Python的内置`input`函数提示用户输入选择。
- en: If the user’s choice matches one of those listed, call that option’s `choose`
    method.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户的选项与列出的选项之一匹配，则调用该选项的`choose`方法。
- en: Otherwise, repeat.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，重复。
- en: What approach might you use in Python to get this repeating behavior?
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 你在Python中可能会使用什么方法来获得这种重复行为？
- en: A `while` loop
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`while`循环'
- en: A `for` loop
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`for`循环'
- en: A recursive function call
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归函数调用
- en: Because there isn’t a definitive end state for getting the user’s input (they
    might enter an invalid choice four billion times), a `while` loop (option 1) makes
    the most sense. *While* the user’s choice is invalid, keep prompting them. You
    can take it easy on them by accepting the upper- and lowercase versions of each
    option if you like.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 由于获取用户输入没有明确的结束状态（他们可能输入无效选择四亿次），因此`while`循环（选项1）最有意义。*当*用户的选项无效时，继续提示他们。如果你喜欢，可以接受每个选项的大写和小写版本。
- en: Write a `get_option_choice` function, and use it after printing the options
    to get the user’s choice. Then call that option’s `choose` method. Try it out,
    then compare your work with the following listing.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个`get_option_choice`函数，在打印选项后使用它来获取用户的选项。然后调用该选项的`choose`方法。试一试，然后比较你的工作与以下列表。
- en: Listing 6.13\. Getting a user’s choice of menu option
  id: totrans-349
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.13\. 获取用户的菜单选项选择
- en: '[PRE27]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1* The choice is valid if the letter matches one of the keys in the options
    dictionary.**'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 如果字母与选项字典中的某个键匹配，则选择有效。**'
- en: '***2* Gets an initial choice from the user**'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从用户那里获取初始选择**'
- en: '***3* While the user’s choice is invalid, keep prompting them.**'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 当用户的选项无效时，继续提示他们。**'
- en: '***4* Returns the matching option once they’ve made a valid choice**'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 一旦他们做出了有效的选择，就返回匹配的选项**'
- en: At this point, you can run Bark, and some of the commands, like listing bookmarks
    and quitting, will respond to your input. But a couple of options require some
    additional preparation, as I alluded to earlier. You need to supply a title, description,
    and so on to add a bookmark, and you need to specify the ID of a bookmark to delete
    it. Much like you got user input for the menu option to choose, you’ll need to
    prompt the user for this bookmark data.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可以运行Bark，一些命令，如列出书签和退出，将响应用户的输入。但有几个选项需要一些额外的准备，正如我之前提到的。你需要提供标题、描述等来添加书签，你需要指定要删除的书签的ID。就像你为选择菜单选项获取用户输入一样，你需要提示用户这些书签数据。
- en: Here’s another opportunity to encapsulate some behavior. For each piece of information
    you need, you should
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是封装一些行为的机会。对于你需要的信息，你应该
- en: Prompt the user with a label—“Title” or “Description”, for example
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用标签提示用户——例如“标题”或“描述”
- en: If the information is required and the user presses Enter without entering any
    info, keep prompting them
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果信息是必需的，并且用户按下Enter键而没有输入任何信息，则继续提示他们
- en: Write three functions—one to provide the repeating prompt behavior, and two
    that use it to get information for adding or deleting a bookmark. Then add each
    information-fetching function as the `prep_call` to the appropriate `Option` instance.
    Check your results against the following listing to see how you did, or if you
    get stuck.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 编写三个函数——一个用于提供重复提示行为，另外两个用于获取添加或删除书签的信息。然后将每个信息获取函数作为`prep_call`添加到适当的`Option`实例中。对照以下列表检查你的结果，看看你做得如何，或者如果你卡住了。
- en: Listing 6.14\. Gathering bookmark information from the user
  id: totrans-360
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.14\. 从用户那里收集书签信息
- en: '[PRE28]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '***1* A general function for prompting users for input**'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 用于提示用户输入的通用函数**'
- en: '***2* Gets initial user input**'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 获取初始用户输入**'
- en: '***3* Continues prompting while the input is empty, if required**'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在需要的情况下，如果输入为空，则继续提示**'
- en: '***4* Function to get the necessary data for adding a new bookmark**'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 获取添加新书签所需数据的函数**'
- en: '***5* The notes for a bookmark are optional, so don’t keep prompting.**'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 书签的注释是可选的，所以不要继续提示。**'
- en: '***6* Gets the necessary information for deleting a bookmark**'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 获取删除书签所需的信息**'
- en: If all is well, you should now be able to run Bark and add, list, or delete
    bookmarks! Congratulations on a job well done.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你现在应该能够运行Bark并添加、列出或删除书签！恭喜你做得很好。
- en: '|  |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Nerding out**'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '**深入探讨**'
- en: 'We just covered a heck of a lot of stuff, but I want to point out something
    I find exciting. Because of the way you’ve built Bark, if you want to add new
    functionality, there’s a clear roadmap:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚覆盖了很多内容，但我想要指出一些我觉得很兴奋的事情。由于你构建Bark的方式，如果你想添加新功能，有一个清晰的路线图：
- en: Add any new database manipulation methods you may need to database.py.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你可能需要的任何新数据库操作方法添加到database.py中。
- en: Add a command class that performs the business logic you need in commands.py.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在commands.py中添加一个执行所需业务逻辑的命令类。
- en: Hook up the new command to a new menu option in bark.py.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的命令连接到bark.py中的新菜单选项。
- en: How cool is that? Separating concerns allows you to clearly see which areas
    of code you need to augment when adding new functionality.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这有多酷？分离关注点让你可以清楚地看到在添加新功能时需要增强哪些代码区域。
- en: '|  |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Before finishing up this chapter, there are a couple of remaining pieces of
    polish to attend to.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章之前，还有一些需要处理的细节。
- en: CLEARING THE SCREEN
  id: totrans-378
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清除屏幕
- en: Clearing the screen just before printing the menu or executing a command will
    make it easier to see the current context the user is in. To clear the screen,
    you can defer to your operating system’s command-line program for clearing the
    terminal text. The command for clearing the screen is `clear` on many operating
    systems, but it’s `cls` on Windows. You can figure out if you’re on Windows by
    checking `os.name`—on Windows this is `'nt'`. (Windows NT is to Windows 10 as
    macOS is to Mojave.)
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在打印菜单或执行命令之前清除屏幕将使查看用户当前所处的上下文更容易。要清除屏幕，你可以委托给操作系统的命令行程序来清除终端文本。在许多操作系统中清除屏幕的命令是`clear`，但在Windows上是`cls`。你可以通过检查`os.name`来确定是否在Windows上——在Windows上这是`'nt'`。（Windows
    NT相当于Windows 10，就像macOS相当于Mojave。）
- en: 'Write a `clear_screen` function that makes the appropriate call using `os.system`,
    as in the following code:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个`clear_screen`函数，使用`os.system`进行适当的调用，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Call this just before calling `print_options`, and just before calling the
    `.choose()` method of the user’s selected option:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`print_options`之前调用此方法，并在调用用户所选选项的`.choose()`方法之前调用：
- en: '[PRE30]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This will be most helpful when the menu and command results get printed over
    and over again, which is the final piece of this puzzle.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在菜单和命令结果被反复打印时最有帮助，这是这个谜题的最后一部分。
- en: APPLICATION LOOP
  id: totrans-385
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 应用程序循环
- en: The last step is to run Bark in a loop so that users can perform several actions
    in a row. To do this, create a `loop` method and move everything but the database
    initialization from the `if __name__ == '__main__'` block into it. Back in the
    `if __name__ == '__main__'` block, call `loop` inside a `while True:` block. At
    the end of `loop`, add a line to pause and wait for the user to press Enter before
    proceeding.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是循环运行Bark，以便用户可以连续执行多个操作。为此，创建一个`loop`方法，并将除数据库初始化之外的所有内容移动到`if __name__
    == '__main__'`块中。回到`if __name__ == '__main__'`块，在`while True:`块中调用`loop`。在`loop`的末尾，添加一行以暂停并等待用户按Enter键后继续。
- en: '[PRE31]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '***1* Everything that happens for each menu > option > result loop goes here.**'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 每个菜单 > 选项 > 结果循环中发生的一切都放在这里。**'
- en: '***2* Prompts the user to press Enter and reviews the result before proceeding
    (_ means “unused value”)**'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 提示用户按Enter键，并在继续之前检查结果 (_ 表示“未使用值”）**'
- en: '***3* Loops forever (until the user chooses the option corresponding to QuitCommand)**'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 无限循环（直到用户选择与退出命令对应的选项）**'
- en: Now Bark will give the user a way to return to the menu after each interaction,
    and the menu gives them an option to exit. This covers all the bases. What do
    you think? I think it’s about time to start using Bark.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Bark将给用户一个在每次交互后返回菜单的方法，菜单也给他们提供了一个退出选项。这涵盖了所有方面。你怎么看？我认为是时候开始使用Bark了。
- en: Summary
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Separation of concerns is a tool for achieving more readable, maintainable code.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关注点的分离是实现更易读、更易于维护的代码的工具。
- en: End-user applications are often separated into persistence, business logic,
    and presentation layers.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终用户应用程序通常分为持久层、业务逻辑层和表示层。
- en: Separation of concerns works closely with encapsulation, abstraction, and loose
    coupling.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关注点的分离与封装、抽象和松散耦合紧密相关。
- en: Applying effective separation of concerns allows you to add, change, and delete
    functionality without affecting the surrounding code.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用有效的关注点分离允许你在不影响周围代码的情况下添加、更改和删除功能。
- en: Chapter 7\. Extensibility and flexibility
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7章\. 可扩展性和灵活性
- en: '*This chapter covers*'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Using inversion of control to make code flexible
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用控制反转使代码灵活
- en: Using interfaces to make code extensible
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用接口使代码可扩展
- en: Adding new features to your existing code
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向现有代码添加新功能
- en: At many established organizations, your day-to-day work as a developer involves
    not only writing new applications, but updating existing ones. When you’re tasked
    with adding a new feature to an existing application, your goal is to *extend*
    the functionality of that application, introducing new behavior by adding code.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多成熟组织中，作为开发者，你的日常工作不仅包括编写新应用程序，还包括更新现有应用程序。当你被要求向现有应用程序添加新功能时，你的目标是 *扩展* 该应用程序的功能，通过添加代码引入新的行为。
- en: Some applications are *flexible* to this kind of change and can adapt to shifting
    requirements. Others may fight you tooth and nail. In this chapter, you’ll learn
    strategies for writing software that’s flexible and extensible by adding an “Import
    GitHub stars” feature to Bark.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用程序对这种改变 *灵活*，可以适应不断变化的需求。其他应用程序可能会与你抗争到底。在本章中，你将学习通过向Bark添加“导入GitHub星星”功能来编写灵活和可扩展的软件的策略。
- en: 7.1\. What is extensible code?
  id: totrans-404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1\. 什么是可扩展代码？
- en: Code is said to be *extensible* if adding new behaviors to it has little or
    no impact on existing behaviors. Said another way, software is extensible if you
    can add new behavior without changing existing code.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 如果向代码中添加新行为对现有行为的影响很小或没有影响，则称代码为*可扩展的*。换句话说，如果可以在不更改现有代码的情况下添加新行为，则软件是可扩展的。
- en: Think about a web browser like Google Chrome or Mozilla Firefox. You’ve probably
    installed something in one of these browsers to block advertisements or to easily
    save the article you’re reading to a notes tool like Evernote. Firefox calls these
    installable pieces of software *add-ons*, whereas Chrome calls them *extensions*,
    and both are examples of a *plugin system*. Plugin systems are implementations
    of extensibility. Chrome and Firefox weren’t built with ad blockers or Evernote
    in mind *specifically*, but they were designed to allow for such extensions to
    be built.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下像 Google Chrome 或 Mozilla Firefox 这样的网络浏览器。你可能在这些浏览器中安装了一些软件来阻止广告或轻松地将你正在阅读的文章保存到像
    Evernote 这样的笔记工具中。Firefox 将这些可安装的软件组件称为*插件*，而 Chrome 则称为*扩展*，两者都是*插件系统*的例子。插件系统是可扩展性的实现。Chrome
    和 Firefox 并非专门为广告拦截器或 Evernote 而构建的，但它们被设计成允许构建这样的扩展。
- en: Massive projects like web browsers succeed when they can cater to the needs
    of hundreds of thousands of users. It would be a massive feat to predict all those
    needs in advance, so an extensible system allows for solutions to those needs
    to be built after the product is brought to market. You won’t always need to be
    so forward-looking, but drawing on some of the same concepts will help you build
    better software.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 像网络浏览器这样的大型项目只有在能够满足数十万用户的需求时才能成功。提前预测所有这些需求将是一项巨大的壮举，因此可扩展系统允许在产品上市后构建满足这些需求解决方案。你并不总是需要如此前瞻性，但借鉴一些相同的概念将帮助你构建更好的软件。
- en: As with many facets of software development, extensibility is a spectrum and
    something you’ll iterate on. By practicing concepts like separation of concerns
    and loose coupling, you can improve your code’s extensibility over time. As the
    extensibility of your code improves, you’ll find that adding new features becomes
    faster because you can focus almost entirely on that new behavior without worrying
    about how it will affect the features around it. This also means you’ll have an
    easier time maintaining and testing your code, because features are more isolated
    and therefore less likely to introduce tricky bugs because of intermingled behavior.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 与软件开发的其他许多方面一样，可扩展性是一个连续体，并且是你需要不断迭代改进的。通过实践诸如关注点分离和松散耦合等概念，你可以随着时间的推移提高你代码的可扩展性。随着你代码的可扩展性提高，你会发现添加新功能变得更快，因为你几乎可以完全专注于新的行为，而不用担心它会如何影响周围的功能。这也意味着你将更容易维护和测试你的代码，因为功能更加隔离，因此由于混合行为而引入的复杂错误的可能性更小。
- en: 7.1.1\. Adding new behaviors
  id: totrans-409
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.1\. 添加新行为
- en: In the last chapter, you wrote the beginnings of the Bark application. You used
    a multitier architecture to separate the concerns of persisting, manipulating,
    and displaying bookmark data. You then built a small set of features on top of
    those layers of abstraction to make something useful. What happens when you’re
    ready to add new functionality?
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你编写了 Bark 应用程序的初步版本。你使用多层架构来分离持久化、操作和显示书签数据的问题。然后，你在这层抽象之上构建了一组小的功能，以使其变得有用。当你准备好添加新功能时会发生什么？
- en: In an ideal extensible system, adding new behavior involves adding new classes,
    methods, functions, or data that encapsulate the new behavior without changing
    existing code ([figure 7.1](#ch07fig01)).
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个理想的可扩展系统中，添加新行为涉及添加新的类、方法、函数或数据，这些新类、方法、函数或数据封装了新行为，而不改变现有代码（[图 7.1](#ch07fig01)）。
- en: Figure 7.1\. Adding new behavior to extensible code
  id: totrans-412
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.1\. 向可扩展代码添加新行为
- en: '![](../Images/f0153-01.jpg)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0153-01.jpg)'
- en: Figure 7.2\. Adding new behavior to code that isn’t extensible
  id: totrans-414
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.2\. 向不可扩展代码添加新行为
- en: '![](../Images/f0154-01.jpg)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0154-01.jpg)'
- en: Compare this with a less extensible system, where new functionality may require
    adding conditional statements to a function here, a method there, and so on ([figure
    7.2](#ch07fig02)). That breadth of changes and their granularity is sometimes
    referred to as *shotgun surgery*, because adding a feature requires peppering
    changes throughout your code like the pellets from a shotgun round.^([[1](#ch07fn01)])
    This often points to a mixing of concerns or an opportunity to abstract or encapsulate
    in a different way. Code that requires these kinds of changes is not extensible;
    creating new behavior is not a straightforward endeavor. You need to go searching
    through the code for exactly the right lines to update.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与一个可扩展性较差的系统进行比较，其中新功能可能需要在函数中添加条件语句，在方法中添加，等等（[图7.2](#ch07fig02)）。这种广泛的变化及其粒度有时被称为*枪击手术*，因为添加功能需要在代码中像散弹枪弹丸一样散布变化。[1](#ch07fn01)
    这通常表明关注点的混合或以不同方式抽象或封装的机会。需要这些类型更改的代码不可扩展；创建新行为不是一项简单的工作。你需要搜索代码以找到确切需要更新的行。
- en: ¹
  id: totrans-417
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-418
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Read more about shotgun surgery and other code smells in “An Investigation
    of Bad Smells in Object-Oriented Design,” Third International Conference on Information
    Technology: New Generations (2006), [https://ieeexplore.ieee.org/document/1611587](https://ieeexplore.ieee.org/document/1611587).'
  id: totrans-419
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有关枪击手术和其他代码恶臭的更多信息，请参阅“面向对象设计中的恶臭调查”，第三国际信息技术：新一代会议（2006年），[https://ieeexplore.ieee.org/document/1611587](https://ieeexplore.ieee.org/document/1611587)。
- en: 'Toward the end of the last chapter, I noted that adding a new feature to Bark
    is a relatively simple matter:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章的结尾，我提到向Bark添加新功能是一个相对简单的事情：
- en: Adding new data persistence logic in the database module, if needed
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，在数据库模块中添加新的数据持久性逻辑
- en: Adding new business logic to the command module for the underlying functionality
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为底层功能向命令模块添加新的业务逻辑
- en: Adding a new option in the bark module to handle user interaction
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在树皮模块中添加一个新选项以处理用户交互
- en: '|  |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-425
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Duplicating some code and updating that new copy to do what you need is a perfectly
    valid approach to extension. I use this approach occasionally on my way to making
    the original code more extensible. By creating a duplicate version, altering it,
    and seeing how the two versions differ, I can more easily refactor that duplicated
    code back into a single, multipurpose version later. If you try to deduplicate
    code without a thorough understanding of all the ways it’s being used, you risk
    assuming too much and making your code inflexible to future changes. So remember,
    duplication is better than the wrong abstraction.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 复制一些代码并更新新副本以执行所需操作是扩展的完全有效方法。我在使原始代码更具可扩展性的过程中偶尔使用这种方法。通过创建一个副本，对其进行修改，并观察两个版本之间的差异，我可以更容易地将复制的代码重构回一个单一的多用途版本。如果你在没有彻底理解代码所有使用方式的情况下尝试去重代码，你可能会做出过多的假设，并使你的代码对未来的变化缺乏灵活性。所以记住，复制比错误的抽象更好。
- en: '|  |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If Bark is close to ideal in doing the three activities, you should only need
    to add code, without affecting code that’s already present. You’ll discover whether
    this is the case when you start writing the GitHub stars importer a bit later
    in this chapter. But because real systems are rarely ideal, you’ll still find
    yourself needing to make changes to existing code regularly ([figure 7.3](#ch07fig03)).
    How does flexibility apply in these situations?
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Bark在执行三项活动方面接近理想，你只需添加代码，而不会影响现有的代码。你将在本章稍后开始编写GitHub星标导入器时发现这一点。但是，因为现实系统很少是理想的，你仍然会发现自己需要定期更改现有代码（[图7.3](#ch07fig03)）。在这些情况下，灵活性是如何应用的？
- en: Figure 7.3\. How extensibility looks in practice
  id: totrans-429
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.3\. 实践中可扩展性的样子
- en: '![](../Images/f0155-01.jpg)'
  id: totrans-430
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0155-01.jpg)'
- en: 7.1.2\. Modifying existing behaviors
  id: totrans-431
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.2\. 修改现有行为
- en: There are a number of reasons you might need to change code you or someone else
    has already written. You might need to change the code’s behavior, such as when
    you’re fixing a bug or addressing a change in requirements. You might need to
    refactor to make the code easier to work with, keeping the behavior consistent.
    In these cases, you aren’t necessarily looking to *extend* the code with new behavior,
    but the *flexibility* of the code still plays a big role.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能有多个原因需要更改你或其他人已经编写的代码。你可能需要更改代码的行为，例如当你正在修复错误或解决需求变更时。你可能需要重构以使代码更容易使用，同时保持行为一致。在这些情况下，你并不一定是在寻找通过添加新行为来*扩展*代码，但代码的*灵活性*仍然起着重要作用。
- en: 'Flexibility is a measure of code’s resistance to change. Ideal flexibility
    means that any piece of your code can be easily swapped out for another implementation.
    Code that requires shotgun surgery in order to change is *rigid*; it fights against
    changes by making you work hard. Kent Beck wittily said, “For each desired change,
    make the change easy (warning: this may be hard), then make the easy change.”^([[2](#ch07fn02)])
    Breaking down the code’s resistance first—through practices like decomposition,
    encapsulation, and so on—paves the way to enabling you to make the specific change
    you originally intended.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 灵活性是衡量代码抵抗变化的能力。理想的灵活性意味着你可以轻松地将代码中的任何部分替换为另一种实现。需要通过枪击式手术（ shotgun surgery）来更改的代码是*僵化的*；它通过让你付出更多努力来抵制变化。Kent
    Beck 机智地说：“对于每个期望的改变，使改变变得容易（警告：这可能很难），然后进行简单的改变。”^([[2](#ch07fn02)]) 通过分解、封装等实践首先打破代码的抵抗性，为使你能够实现最初意图的具体改变铺平道路。
- en: ²
  id: totrans-434
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-435
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Kent Beck on Twitter (September 25, 2012), [https://twitter.com/kentbeck/status/250733358307500032](https://twitter.com/kentbeck/status/250733358307500032).
  id: totrans-436
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Kent Beck 在 Twitter 上（2012年9月25日），[https://twitter.com/kentbeck/status/250733358307500032](https://twitter.com/kentbeck/status/250733358307500032).
- en: In my own work, I make little, continuous refactorings in the area of code I’m
    working in. For example, the code you work in may contain a complicated set of
    `if`/`else` statements, as in [listing 7.1](#ch07ex1). If you need to change a
    behavior in this set of conditionals, it’s likely you’ll need to read most of
    it to understand where the change should be made. And if the change you want to
    make applies to the body of each conditional, you’ll need to apply the change
    many times over.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的工作中，我在正在工作的代码区域进行少量、持续的重构。例如，你正在工作的代码可能包含一个复杂的 `if`/`else` 语句集合，如[列表7.1](#ch07ex1)所示。如果你需要更改这个条件集合中的行为，你很可能会需要阅读大部分内容来理解应该在何处进行更改。而且，如果你想要进行的更改适用于每个条件的主体，你需要多次应用这个更改。
- en: Listing 7.1\. A rigid mapping of conditions to outcomes
  id: totrans-438
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.1\. 条件到结果的僵化映射
- en: '[PRE32]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '***1* This conditional needs to be updated properly for each choice.**'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这个条件需要为每个选择正确更新。**'
- en: '***2* The concerns of mapping an option to a message and printing the message
    are mixed.**'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将选项映射到消息和打印消息的关注点混合在一起。**'
- en: How could this be improved?
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 如何才能改进？
- en: Extract information from the conditional checks and bodies into a `dict`.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从条件检查和主体中提取信息到一个 `dict`。
- en: Use a `for` loop to check against each available choice.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `for` 循环检查每个可用的选择。
- en: Because each choice maps to a specific outcome, extracting the mapping of behaviors
    into a dictionary (option 1) would be the right approach. By mapping the letter
    for the choice to the word that goes in the message, a new version of the code
    can retrieve the right word from the mapping regardless of the choice picked.
    You no longer need to keep adding `elif` statements to a conditional and defining
    the behavior for the new case. You can instead add a single new mapping from the
    chosen letter to the word you’ll use in the message, printing only at the end,
    as in [listing 7.2](#ch07ex2). The mapping of choices to messages acts like *configuration*—information
    a program uses to determine how to execute. Configuration is often easier to understand
    than conditional logic.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个选择都映射到一个特定的结果，所以将行为映射到字典（选项1）是正确的方法。通过将选择的字母映射到消息中的单词，新的代码版本可以从映射中检索到正确的单词，而不管选择了哪个选项。你不再需要不断向条件中添加
    `elif` 语句并为新情况定义行为。相反，你可以添加一个从所选字母到消息中使用的单词的单个新映射，只在最后打印，如[列表7.2](#ch07ex2)所示。选择到消息的映射就像*配置*——程序用来确定如何执行的信息。配置通常比条件逻辑更容易理解。
- en: Listing 7.2\. A more flexible way to map conditions to outcomes
  id: totrans-446
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.2\. 将条件映射到结果的一种更灵活的方法
- en: '[PRE33]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1* Extracting the mapping of choices to messages makes adding a new option
    simpler.**'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 提取选择到消息的映射使添加新选项变得简单。**'
- en: '***2* The outcome is centralized, and printing behavior is separated somewhat.**'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 结果是集中的，并且打印行为有所分离。**'
- en: This version of the code is more readable. Whereas the example in [listing 7.1](#ch07ex1)
    required you to understand the conditions and what each condition does, the version
    here is more clearly structured as a set of choices and a line that prints information
    about a specific choice. Adding more choices and changing the message that gets
    printed is also easier, because they’ve been separated. This is all in the pursuit
    of loose coupling.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的阅读性更好。与[列表7.1](#ch07ex1)中的示例相比，你需要理解条件和每个条件的作用，而这里的版本更清晰地结构化为一系列选择和一行打印特定选择信息的代码。添加更多选择和更改打印的消息也更容易，因为它们已经被分离。这一切都是为了追求松散耦合。
- en: 7.1.3\. Loose coupling
  id: totrans-451
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.3\. 松散耦合
- en: Above all, extensibility arises from loosely coupled systems. Without loose
    coupling, most changes in a system will require the shotgun surgery variety of
    development. Suppose you’d written Bark without the layers of abstraction around
    the database and the business logic—something like the following listing. This
    version is difficult to read, in part because of its physical layout (note the
    deep nesting) and also because so much is happening in one glob of code.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，可扩展性源于松散耦合的系统。没有松散耦合，系统中的大多数更改将需要类似枪击手术的开发方式。假设你没有在数据库和业务逻辑周围添加抽象层来编写Bark——类似于以下列表。这个版本难以阅读，部分原因在于其物理布局（注意深度嵌套），以及代码块中发生了很多事情。
- en: Listing 7.3\. A procedural approach to Bark
  id: totrans-453
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.3\. 对Bark的过程式方法
- en: '[PRE34]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '***1* Deep nesting is a strong hint that concerns need further separation.**'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 深度嵌套是一个需要进一步分离的关注点的强烈提示。**'
- en: '***2* if/elif/else are difficult to reason about.**'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* if/elif/else难以推理。**'
- en: '***3* Database behavior is repetitive and mixed with user interaction.**'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 数据库行为是重复的，并且与用户交互混合在一起。**'
- en: This code would work, but consider trying to implement a change that affects
    how you connect to the database, or a change to the underlying database altogether.
    It would be a major pain. This code has many interdependent pieces all talking
    to each other, so adding new behavior would mean figuring out the right place
    to add another `elif`, writing some raw SQL, and so on. Because you would incur
    these costs each time you wanted to add new behavior, this system would not scale
    well.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以工作，但考虑一下尝试实施影响你如何连接数据库或对底层数据库进行更改的更改。这将是一个巨大的痛苦。这段代码有许多相互依赖的部分都在相互交谈，因此添加新行为意味着找出添加另一个`elif`的正确位置，编写一些原始SQL，等等。因为你每次想要添加新行为时都会产生这些成本，所以这个系统扩展性不好。
- en: Imagine the atoms in a solid piece of iron—they’re tightly packed, firmly holding
    onto each other. That makes iron *rigid*, and it resists being bent or reshaped.
    But blacksmiths figured out how to overcome this by melting the iron, which loosens
    up the atoms so they can flow around each other freely. Even as it cools, the
    iron is *malleable*, or able to move and flex without breaking.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下固体铁块中的原子——它们紧密排列，紧紧地抓住彼此。这使得铁*刚性*，并抵抗弯曲或重塑。但铁匠们发现通过熔化铁来克服这一点，这会使原子松散，从而可以自由地流动。即使在冷却过程中，铁也是*可塑的*，能够移动和弯曲而不会断裂。
- en: This is what you want from your code, as shown in [figure 7.4](#ch07fig04).
    If each piece is only loosely coupled to any other piece, those pieces can move
    around more freely without breaking something unexpectedly. Letting the code get
    too tightly packed together, and permitting it to rely heavily on the code around
    it, will allow your code to settle into a solid form that’s hard to reshape.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是你想要的代码，如图[图7.4](#ch07fig04)所示。如果每个部分只与任何其他部分松散耦合，那么这些部分可以更自由地移动而不会意外地破坏某些东西。让代码过于紧密地堆叠在一起，并允许它过度依赖周围的代码，将使你的代码陷入一种难以重塑的固态形式。
- en: Figure 7.4\. Flexibility contrasted with rigidity
  id: totrans-461
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.4\. 灵活性与刚性的对比
- en: '![](../Images/f0158-01_alt.jpg)'
  id: totrans-462
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/f0158-01_alt.jpg)'
- en: The loose coupling you’ve used writing Bark means that new database functionality
    can be added with new methods on the `DatabaseManager` class or with focused changes
    to an existing (centralized) method. New business logic can be encapsulated in
    new `Command` classes, and adding to the menu is a matter of creating a new option
    in the `options` dictionary in the bark module and hooking it up to a command.
    This sounds a bit like the browser plugin systems I described earlier. Bark doesn’t
    expect to handle any *specific* new features, but they can be added with a known
    quantity of effort. This recap of loose coupling shows how what you’ve learned
    so far can help you design flexible code. Now I’ll teach you a few new techniques
    for getting even deeper flexibility.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 你在编写Bark时使用的松散耦合意味着可以通过在`DatabaseManager`类上添加新方法或对现有（集中式）方法进行有针对性的更改来添加新的数据库功能。新的业务逻辑可以封装在新的`Command`类中，向菜单添加内容只需在bark模块的`options`字典中创建一个新选项并将其连接到命令即可。这听起来有点像我之前描述的浏览器插件系统。Bark不期望处理任何*特定*的新功能，但它们可以通过已知数量的努力添加。这个松散耦合的回顾展示了你到目前为止所学的内容如何帮助你设计灵活的代码。现在，我将教你一些新的技巧，以获得更深层次的灵活性。
- en: 7.2\. Solutions for rigidity
  id: totrans-464
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2\. 刚度解决方案
- en: Rigidity in code is a lot like stiff joints. As software gets older, the code
    that gets used the least tends to be the most rigid, and it requires some care
    to loosen it up again. Specific kinds of rigid code require specific kinds of
    care, and you should regularly examine code for opportunities to keep it flexible
    through refactoring.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的刚度与僵硬的关节非常相似。随着软件的逐渐老化，使用最少的代码往往变得最为僵硬，需要一定的技巧来再次放松它。特定类型的僵硬代码需要特定的护理，你应该定期检查代码，寻找通过重构保持其灵活性的机会。
- en: In the next few sections, you’ll learn some specific ways to reduce rigidity.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，你将学习一些具体的方法来减少刚度。
- en: '7.2.1\. Letting go: Inversion of control'
  id: totrans-467
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.1\. 放手：控制反转
- en: You learned earlier that composition provides benefits over inheritance by allowing
    objects to reuse behaviors without confining them to a particular inheritance
    hierarchy. When you separate your concerns into many smaller classes and want
    to compose those behaviors back together, you can write a class that uses instances
    of those smaller classes. This is a common practice in object-oriented codebases.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前了解到，通过允许对象重用行为而不将它们限制在特定的继承层次结构中，组合比继承提供了更多的优势。当你将关注点分离成许多更小的类，并希望将这些行为组合在一起时，你可以编写一个使用这些较小类实例的类。这是面向对象代码库中的常见做法。
- en: Imagine you’re working in a module that deals with bicycles and their parts.
    You open up the bicycle module and see the code in the following listing. As you
    read to understand what the code is doing, try to assess how well it follows practices
    like encapsulation and abstraction.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你在一个处理自行车及其部件的模块中工作。你打开自行车模块，看到以下列表中的代码。当你阅读以理解代码正在做什么时，尝试评估它如何遵循封装和抽象等实践。
- en: Listing 7.4\. A composite class that depends on other, smaller classes
  id: totrans-470
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.4\. 依赖于其他较小类的复合类
- en: '[PRE35]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '***1* Small classes to be used for composition**'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 用于组合的小类**'
- en: '***2* Bicycle creates the parts it needs.**'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 自行车创建它需要的部件。**'
- en: '***3* A method to print all of the bicycle’s parts**'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 一种打印自行车所有部件的方法**'
- en: '***4* Creates the bicycle and prints its specs**'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 创建自行车并打印其规格**'
- en: 'Running this code will print out the specs of your bicycle:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将打印出自行车的规格：
- en: '[PRE36]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This will certainly get you a bicycle. The encapsulation looks good; each part
    of the bicycle lives in its own class. The levels of abstraction make sense too;
    there’s a `Bicycle` at the top level, and each of its parts is accessible a level
    down from that. So what’s wrong? Can you see anything that might be difficult
    to do with this code structure?
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然会给你一辆自行车。封装看起来不错；自行车的每个部件都生活在自己的类中。抽象层次也很有意义；在顶层有一个`Bicycle`，它的每个部件都可以从那个级别向下访问。那么问题在哪里？你能看到任何可能难以用这种代码结构完成的事情吗？
- en: Adding new parts to a bicycle
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向自行车添加新部件
- en: Upgrading parts of a bicycle
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 升级自行车的部件
- en: Adding new parts to a bicycle (option 1) turns out not to be very difficult.
    You can create an instance of a new part and store it on the `Bicycle` instance
    in the `__init__` method, the same as the others. Upgrading (changing) the parts
    of a `Bicycle` instance dynamically (option 2) turns out to be hard in this structure
    because the classes for those parts are hardcoded into the initialization.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 向自行车添加新部件（选项 1）实际上并不困难。你可以在 `__init__` 方法中创建一个新部件的实例，并将其存储在 `Bicycle` 实例中，就像其他部件一样。在当前结构中，动态升级（更改）`Bicycle`
    实例的部件（选项 2）变得很困难，因为这些部件的类被硬编码到初始化中。
- en: You could say that the `Bicycle` *depends on* the `Tire`, `Frame`, and other
    parts it needs. Without them, the bicycle can’t function. But if you want a `CarbonFiberFrame`,
    you have to crack open the `Bicycle` class’s code to update it. Because of this,
    `Tire` is currently a *rigid* dependency of `Bicycle`.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以说 `Bicycle` *依赖于* `Tire`、`Frame` 和它需要的其他部件。没有它们，自行车无法工作。但如果你想要 `CarbonFiberFrame`，你必须打开
    `Bicycle` 类的代码来更新它。正因为如此，`Tire` 目前是 `Bicycle` 的 *刚性* 依赖。
- en: '*Inversion of control* says that instead of creating instances of dependencies
    in your class, you can pass in existing instances for the class to make use of
    ([figure 7.5](#ch07fig05)). The *control* of dependency creation is *inverted*
    by giving the control to whatever code is creating a `Bicycle`. This is powerful.'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '*控制反转* 指的是，你可以在你的类中创建依赖项的实例，而不是传递现有的实例供类使用 ([图 7.5](#ch07fig05))。依赖项创建的控制被反转，将控制权交给创建
    `Bicycle` 的代码。这是强大的。'
- en: Figure 7.5\. Using inversion of control to gain flexibility
  id: totrans-484
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.5\. 使用控制反转获得灵活性
- en: '![](../Images/f0160-01_alt.jpg)'
  id: totrans-485
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/f0160-01_alt.jpg)'
- en: Try updating the `Bicycle.__init__` method to accept an argument for each of
    its dependencies, and pass them into the method. Come back to the following listing
    to see how you did.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试更新 `Bicycle.__init__` 方法，使其接受每个依赖项的参数，并将它们传递到方法中。回到以下列表中查看你的进展。
- en: Listing 7.5\. Using inversion of control
  id: totrans-487
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.5\. 使用控制反转
- en: '[PRE37]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '***1* The dependencies are passed into the class upon initialization.**'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 依赖项在初始化时传递到类中。**'
- en: '***2* The code that creates a Bicycle supplies it with the appropriate instances.**'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建自行车的代码提供了适当的实例。**'
- en: This should give you the same result as before. It may seem like all you did
    was shift the issue around, but it has enabled a degree of freedom in your bicycles.
    Now you can create any fancy tire or frame you wish and use it in place of the
    basic versions. As long as your `FancyTire` has the same methods and attributes
    as any other tire, `Bicycle` won’t care.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会给你之前相同的结果。这看起来可能只是把问题转移了一下，但它为你的自行车提供了一定程度的自由度。现在你可以创建任何花哨的轮胎或框架，并用它们替换基本版本。只要你的
    `FancyTire` 具有与其他轮胎相同的方法和属性，`Bicycle` 就不会关心。
- en: Try creating a new `CarbonFiberFrame` and upgrading your bicycle to use it.
    Come back to the following listing to see how you did.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试创建一个新的 `CarbonFiberFrame` 并升级你的自行车以使用它。回到以下列表中查看你的进展。
- en: Listing 7.6\. Using a new kind of frame for a bike
  id: totrans-493
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.6\. 使用一种新的自行车框架
- en: '[PRE38]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '***1* A carbon fiber frame can be used as easily as a regular frame.**'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 碳纤维框架可以像普通框架一样容易地使用。**'
- en: '***2* You should now see a carbon fiber frame in the printed specs.**'
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 你现在应该能在打印的规格中看到碳纤维框架。**'
- en: This ability to swap out dependencies with minimal effort is valuable in testing
    your code; to truly isolate behavior in your classes, you will occasionally want
    to replace a real implementation of a dependency with a test double. Having a
    rigid dependency on `Tire` forces you to mock the `Tire` class for each of your
    `Bicycle` tests to achieve isolation. Inversion of control frees you from this
    constraint, letting you pass in a `MockTire` instance, for example. This way,
    you won’t forget to mock something, because you must pass *some* kind of tire
    to the `Bicycle` instances you create.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 这种用最少的努力替换依赖项的能力在测试你的代码时非常有价值；为了真正隔离类中的行为，你有时会想用一个测试替身替换依赖项的实际实现。对 `Tire` 的刚性依赖迫使你为每个
    `Bicycle` 测试模拟 `Tire` 类，以实现隔离。控制反转让你摆脱这种约束，让你可以传递一个 `MockTire` 实例，例如。这样，你就不会忘记模拟某些东西，因为你必须为创建的
    `Bicycle` 实例传递 *某种* 轮胎。
- en: Making testing easier is one of the big reasons to follow the principles you’ve
    learned in this book. If your code is hard to test, it may be hard to understand
    as well. If it’s easy to test, it may be easy to understand. Neither is certain,
    but they’re correlated.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 使测试更容易是遵循你在本书中学到的原则的一个重要原因。如果你的代码难以测试，它可能也难以理解。如果它容易测试，它可能也容易理解。两者都不是确定的，但它们是相关的。
- en: '7.2.2\. The devil’s in the details: Relying on interfaces'
  id: totrans-499
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.2\. 细节决定成败：依赖接口
- en: You saw that `Bicycle` *depends* on `Tire` and other parts, and much of your
    code will inevitably have dependencies like this. But another way rigidity manifests
    is when your high-level code relies too strongly on the details of lower-level
    dependencies. I mentioned that a `FancyTire` could be put on a bicycle *as long
    as* it has the same methods and attributes as any other tire. More formally, any
    object can be swapped in if it has a tire *interface*.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到`Bicycle`依赖于`Tire`和其他部件，你的代码不可避免地会有这样的依赖。但另一种刚性表现是当你的高级代码过于强烈地依赖于低级依赖的细节时。我提到，只要有一个自行车*轮胎*具有与其他轮胎相同的方法和属性，就可以将`FancyTire`安装到自行车上。更正式地说，任何具有轮胎*接口*的对象都可以互换。
- en: The `Bicycle` class doesn’t have much knowledge about (or interest in) the details
    of a *specific* tire. It only cares that a tire has a particular set of information
    and behavior; otherwise, tires are free to do what they like.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bicycle`类对（或对）特定轮胎的细节了解不多（或感兴趣）。它只关心轮胎具有特定的信息和行为集；否则，轮胎可以自由地做它们喜欢的事情。'
- en: This practice of sharing agreed-upon interfaces (in contrast with class-specific
    details) between high- and low-level code will give you the freedom to swap implementations
    in and out. Remember that in Python the presence of duck typing means that strict
    interfaces aren’t required. You decide which methods and attributes comprise a
    particular interface. It’s up to you as a developer to make sure your classes
    adhere to the interfaces their consumers expect.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 这种在高级和低级代码之间共享已达成协议的接口（与类特定的细节相对）的做法将赋予你自由地互换实现的能力。记住，在Python中，鸭子类型的存在意味着不需要严格的接口。你决定哪些方法和属性组成特定的接口。作为开发者，确保你的类符合消费者期望的接口是你的责任。
- en: In Bark, `Command` classes in the business logic provide an `execute` method
    as part of their interface. The presentation layer uses this interface when a
    user selects an option. The implementation of a particular command can change
    as much as it needs to, and no change is required in the presentation layer as
    long as the interface stays the same. You would only need to change the presentation
    layer if, for example, the `Command` classes’ `execute` methods required an additional
    argument.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 在Bark中，业务逻辑中的`Command`类作为其接口的一部分提供了一个`execute`方法。当用户选择一个选项时，表示层使用这个接口。特定命令的实现可以改变，只要接口保持不变，就不需要在表示层进行任何更改。只有在例如`Command`类的`execute`方法需要额外的参数时，才需要更改表示层。
- en: This gets back to cohesion as well. Code that is closely related will not need
    to rely on interfaces; it’s close enough together that inserting an interface
    will feel forced. On the other hand, code that’s already in different classes
    or modules has already been separated, so using shared interfaces instead of directly
    reaching into other classes is most likely the way to go.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 这也回到了内聚性的问题。紧密相关的代码不需要依赖接口；它们足够接近，以至于插入一个接口会感觉是强加的。另一方面，已经位于不同类或模块中的代码已经分离，因此使用共享接口而不是直接访问其他类可能是最佳选择。
- en: '7.2.3\. Fighting entropy: The robustness principle'
  id: totrans-505
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.3\. 与熵作斗争：鲁棒性原则
- en: '*Entropy* is the tendency for organization to dissolve into disorganization
    over time. Code often starts out small, neat, and understandable, but it tends
    toward complexity over time. One reason this happens is because code often grows
    to accommodate different kinds of inputs.'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '*熵*是组织随时间逐渐解体成无序的趋势。代码通常开始时很小、整洁、易于理解，但随着时间的推移，往往会变得复杂。这种情况发生的一个原因是代码往往为了适应不同类型的输入而增长。'
- en: 'The *robustness principle*, also known as Postel’s Law, states: “Be conservative
    in what you do, be liberal in what you accept from others.” The spirit of this
    statement is that you should provide only the behavior necessary to achieve the
    desired outcome, while being open to imperfect or unexpected input. This isn’t
    to say you should accept any input under the sun, but being flexible can ease
    development for consumers of your code. By mapping a possibly large range of inputs
    to a known, smaller range of outputs, you can direct the flow of information toward
    a more limited, expected range ([figure 7.6](#ch07fig06)).'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '*鲁棒性原则*，也称为Postel定律，表述为：“在你所做的事情上要保守，在接收他人提供的内容时要宽容。” 这句话的精神是，你应该只提供实现预期结果所必需的行为，同时对外部输入的不完美或意外情况持开放态度。这并不是说你应该接受任何形式的输入，但保持灵活性可以简化代码消费者的开发过程。通过将可能的大范围输入映射到已知的小范围输出，你可以将信息流引导到一个更有限、更预期的范围（[图7.6](#ch07fig06)）。'
- en: Figure 7.6\. Reducing entropy when mapping inputs to outputs
  id: totrans-508
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.6. 将输入映射到输出时减少熵
- en: '![](../Images/f0163-01.jpg)'
  id: totrans-509
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/f0163-01.jpg)'
- en: 'Consider the built-in `int()` function, which converts its input to an integer.
    This function works for inputs that are already integers:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑内置的`int()`函数，它将输入转换为整数。这个函数适用于已经是整数的输入：
- en: '[PRE39]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'It also works for strings:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 它也适用于字符串：
- en: '[PRE40]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And it even works for floating-point numbers, returning just the whole number
    part:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 它甚至适用于浮点数，只返回整数部分：
- en: '[PRE41]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`int` accepts multiple data types and funnels them all to an integer return
    type, raising an exception only if it’s truly unclear how to proceed:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '`int`接受多种数据类型，并将它们全部转换为整数返回类型，只有在真正不清楚如何进行时才会抛出异常：'
- en: '[PRE42]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Spend some time understanding the range of inputs that consumers of your code
    might reasonably expect to supply, and then rein in that input so that you return
    only what the rest of your system expects. This will provide flexibility for those
    consumers at the entry points of the system, while keeping the number of situations
    the underlying code must handle manageable.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 花些时间了解代码消费者可能合理期望提供的输入范围，然后限制这些输入，以便只返回系统其他部分期望的内容。这将为系统入口点的消费者提供灵活性，同时保持底层代码必须处理的情况数量可控。
- en: 7.3\. An exercise in extension
  id: totrans-519
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3. 扩展练习
- en: Now that you understand what goes into an extensible and flexible design, you
    can apply those concepts by adding functionality to Bark. Right now, Bark is a
    rather manual tool—you can add bookmarks, but it’s a one-at-a-time thing, and
    users have to enter all the URLs and descriptions themselves. It’s tedious work,
    especially if they already have a pile of bookmarks saved in a different tool.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了可扩展和灵活设计的内容，你可以通过向Bark添加功能来应用这些概念。目前，Bark是一个相对手动化的工具——你可以添加书签，但每次只能添加一个，而且用户必须自己输入所有URL和描述。这是一项繁琐的工作，尤其是如果他们已经在不同的工具中保存了一大堆书签的话。
- en: 'You’re going to build a GitHub stars importer for Bark ([figure 7.7](#ch07fig07)).
    This new import option in the presentation layer must do the following:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 你将构建一个Bark的GitHub星星导入器（[图7.7](#ch07fig07)）。这个展示层的新导入选项必须完成以下任务：
- en: Prompt the Bark user for the GitHub username to import stars from.
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提示Bark用户输入要导入星星的GitHub用户名。
- en: Ask the user whether to preserve the timestamps of the original stars.
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 询问用户是否要保留原始星星的时间戳。
- en: Trigger a corresponding command.
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 触发相应的命令。
- en: Figure 7.7\. The flow for a GitHub stars importer for Bark
  id: totrans-525
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.7. Bark GitHub星星导入器的流程
- en: '![](../Images/f0164-01_alt.jpg)'
  id: totrans-526
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/f0164-01_alt.jpg)'
- en: The command that gets triggered must use the GitHub API to fetch the star data.^([[3](#ch07fn03)])
    I recommend installing and using the requests package ([https://github.com/psf/requests](https://github.com/psf/requests)).
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 触发的命令必须使用GitHub API获取星星数据.^([[3](#ch07fn03)]) 我建议安装并使用requests包 ([https://github.com/psf/requests](https://github.com/psf/requests))。
- en: ³
  id: totrans-528
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-529
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Learn about GitHub’s starred repositories API at [http://mng.bz/lony](http://mng.bz/lony).
  id: totrans-530
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在[http://mng.bz/lony](http://mng.bz/lony)了解GitHub的星星仓库API。
- en: 'The star data is paginated, so the process will look something like the following:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 星标数据是分页的，所以过程看起来可能如下所示：
- en: Get the initial page of star results. (The endpoint is [https://developer.github.com/v3/activity/starring/#list-repositories-being-starred](https://developer.github.com/v3/activity/starring/#list-repositories-being-starred).)
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取星星结果的初始页面。（端点是[https://developer.github.com/v3/activity/starring/#list-repositories-being-starred](https://developer.github.com/v3/activity/starring/#list-repositories-being-starred)。）
- en: Parse the data from the response, using it to execute an `AddBookmarkCommand`
    for each starred repository.
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从响应中解析数据，使用它为每个标记的仓库执行一个`AddBookmarkCommand`。
- en: 'Get the `Link: <…>; rel=next` header, if present.'
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '获取`Link: <…>; rel=next`头信息，如果存在。'
- en: Repeat for the next page if there is one; otherwise, stop.
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有下一页，则重复此操作；否则，停止。
- en: '|  |'
  id: totrans-536
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-537
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'To get the timestamps for GitHub stars, you have to pass an `Accept: application/vnd.github.v3.star+json`
    header in your API requests.'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '要获取GitHub星标的时间戳，你必须在API请求中传递一个`Accept: application/vnd.github.v3.star+json`头信息。'
- en: '|  |'
  id: totrans-539
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'From the user’s perspective, the interaction should look something like the
    following:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户的角度来看，交互应该看起来像以下这样：
- en: '[PRE43]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: It turns out that Bark, as written, isn’t *perfectly* extensible, particularly
    regarding bookmark timestamps. Currently, Bark forces the timestamp to be the
    time the bookmark is created (using `datetime.datetime.utcnow().isoformat()`),
    but you want the option to preserve the timestamps of GitHub stars. You can improve
    this by using inversion of control.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，Bark按目前的编写方式并不是**完全**可扩展的，特别是在书签时间戳方面。目前，Bark强制时间戳为书签创建的时间（使用`datetime.datetime.utcnow().isoformat()`），但你希望有保留GitHub星标时间戳的选项。你可以通过使用控制反转来改进这一点。
- en: Try updating the `AddBookmarkCommand` to accept an optional timestamp, using
    its original behavior as the fallback. Check the following listing to see how
    you did.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试更新`AddBookmarkCommand`以接受可选的时间戳，使用其原始行为作为后备。查看以下列表以查看你的完成情况。
- en: Listing 7.7\. Inverting control of the timestamp for a bookmark
  id: totrans-544
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.7\. 反转书签时间戳的控制
- en: '[PRE44]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '***1* Adds an optional timestamp argument to execute**'
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 添加一个可选的时间戳参数以执行**'
- en: '***2* Uses the passed-in timestamp if provided, using the current time as a
    fallback**'
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 如果提供了传入的时间戳，则使用它，否则使用当前时间作为后备**'
- en: You’ve now improved the flexibility of `AddBookmarkCommand`, and it’s extensible
    enough to handle what you need for the GitHub stars importer. You won’t need any
    new functionality at the persistence layer, so you can focus on the presentation
    and business logic for this new feature. Give it a shot and come back to check
    your work against the following two listings.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经提高了`AddBookmarkCommand`的灵活性，并且它足够灵活，可以处理GitHub星标导入所需的功能。你不需要在持久化层添加任何新功能，因此你可以专注于这个新特性的展示和业务逻辑。试一试，然后回来对照以下两个列表检查你的工作。
- en: Listing 7.8\. A GitHub stars import command
  id: totrans-549
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.8\. GitHub星标导入命令
- en: '[PRE45]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '***1* Given a repository dictionary, extract the needed pieces to create a
    bookmark.**'
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 给定一个仓库字典，提取创建书签所需的部分。**'
- en: '***2* The URL for the first page of star results**'
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 星标结果的第一页的URL**'
- en: '***3* Continues getting star results while more pages of results exist**'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在存在更多结果页面时继续获取星标结果**'
- en: '***4* Gets the next page of results, using the right header to tell the API
    to return timestamps**'
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 获取下一页的结果，使用正确的头信息告诉API返回时间戳**'
- en: '***5* The Link header with rel=next contains the link to the next page, if
    available.**'
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 包含rel=next的Link头包含下一页的链接，如果有的话。**'
- en: '***6* The info about the starred repository**'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 标记的仓库信息**'
- en: '***7* The timestamp when the star was created**'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 星标创建的时间戳**'
- en: '***8* Formats the timestamp in the same format that existing Bark bookmarks
    use**'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 使用与现有Bark书签相同的格式格式化时间戳**'
- en: '***9* Executes an AddBookmarkCommand, populating with the repository data**'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 执行一个AddBookmarkCommand，用仓库数据填充**'
- en: '***10* Returns a message indicating how many stars were imported**'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10* 返回一个消息，指示导入了多少星标**'
- en: Listing 7.9\. A GitHub stars import option
  id: totrans-561
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.9\. GitHub星标导入选项
- en: '[PRE46]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '***1* A function to get the GitHub username to import stars from**'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 一个获取GitHub用户名以导入星标的功能**'
- en: '***2* Whether or not to retain the time when the star was originally created**'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 是否保留星标最初创建时的时间**'
- en: '***3* Accepts “Y”, “y”, or just pressing Enter as the user saying “yes”**'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 接受“Y”、“y”或仅按Enter键作为用户表示“是”**'
- en: '***4* Adds the GitHub import option to the menu with the right command class
    and function**'
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将GitHub导入选项添加到菜单中，使用正确的命令类和函数**'
- en: '|  |'
  id: totrans-567
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**More practice**'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多练习**'
- en: If you’d like some more experience extending Bark, try implementing the ability
    to edit an existing bookmark.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想获得更多扩展Bark的经验，尝试实现编辑现有书签的功能。
- en: You’ll need to add a new method to `DatabaseManager` for updating records. Updating
    a record requires the user to specify which record to update (similar to delete)
    as well as the column name and the new value to use. You can use what you’ve already
    written in `add`, `select`, and `delete` as a guide.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要为`DatabaseManager`添加一个新方法来更新记录。更新记录需要用户指定要更新的记录（类似于删除）以及列名和要使用的新值。你可以将你在`add`、`select`和`delete`中已经写好的内容作为参考。
- en: The presentation layer must prompt the user for the ID of the bookmark to update,
    the column to update, and the new value to use. This will hook up to a new `Edit-BookmarkCommand`
    in the business logic layer.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 展示层必须提示用户输入要更新的书签ID、要更新的列以及要使用的新值。这将连接到业务逻辑层中的新`Edit-BookmarkCommand`。
- en: This is all stuff you’re a pro at now, so give it a shot! My version is in the
    source code for this chapter (see [https://github.com/daneah/practices-of-the-python-pro](https://github.com/daneah/practices-of-the-python-pro)).
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是你现在已经很擅长的内容，所以试试看！我的版本在本书的源代码中（见[https://github.com/daneah/practices-of-the-python-pro](https://github.com/daneah/practices-of-the-python-pro)）。
- en: '|  |'
  id: totrans-573
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: You should be seeing how adding behavior to an extensible system is a low-friction
    activity. It’s a joy to be able to focus almost entirely on accomplishing the
    desired behavior, composing pieces of the existing infrastructure to hook up the
    rest of the plumbing. There’s a rare moment as a developer when you might feel
    like the conductor of an orchestra, slowly layering the strings, woodwinds, and
    percussion together into a wonderful harmony. If your orchestra produces more
    of a cacophony from time to time, don’t get disheartened. Find the points of rigidity
    causing dissonance, and see how you can free yourself up, using what you’ve learned.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到，向一个可扩展的系统添加行为是一种低摩擦的活动。能够几乎完全专注于实现所需的行为，将现有基础设施的各个部分组合起来连接其他部分，这是一种乐趣。作为开发者，你可能会在某个罕见的时刻感觉自己像一支乐队的指挥，慢慢地将弦乐、木管乐和打击乐结合起来，创造出美妙的和谐。如果你的乐队偶尔产生更多的噪音，不要灰心。找出导致不和谐的僵硬点，看看你如何利用所学知识来解放自己。
- en: In the next chapter, you’ll learn more about inheritance and the occasions where
    it’s an appropriate solution.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解更多关于继承及其适用场合的内容。
- en: Summary
  id: totrans-576
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Build code so that adding new features means adding new functions, methods,
    or classes without editing existing ones.
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写代码，使得添加新功能意味着添加新函数、方法或类，而不需要编辑现有的代码。
- en: Inversion of control allows other code to customize behavior to its needs without
    changing the low-level implementation.
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制反转允许其他代码根据其需求自定义行为，而无需更改底层实现。
- en: Sharing agreed-upon interfaces between classes instead of giving them detailed
    knowledge about each other reduces coupling.
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类之间共享已同意的接口，而不是给他们提供关于彼此的详细信息，这可以减少耦合。
- en: Be deliberate about what input types you want to handle, and be strict about
    your output types.
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确你想要处理哪些输入类型，并对输出类型严格要求。
- en: Chapter 8\. The rules (and exceptions) of inheritance
  id: totrans-581
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8章\. 继承的规则（和例外）
- en: '*This chapter covers*'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Using inheritance and composition together to model systems
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用继承和组合共同建模系统
- en: Using Python built-ins to inspect object types
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python内置函数检查对象类型
- en: Making interfaces more strict with abstract base classes
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用抽象基类使接口更加严格
- en: If you’ve written your own classes or used a class-based framework in Python,
    you’ve almost certainly encountered *inheritance*. Classes can inherit from other
    classes, ending up with their parent class’s data and behavior. In this chapter,
    you’ll learn the details of inheritance in Python, where it works well, and where
    it should be avoided.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经编写了自己的类或在使用Python的基于类的框架，你几乎肯定遇到过*继承*。类可以继承自其他类，最终拥有其父类的数据和行为。在本章中，你将了解Python中继承的细节，它在哪些情况下工作得很好，以及在哪些情况下应该避免。
- en: 8.1\. The inheritance of programming past
  id: totrans-587
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1\. 编程过去的继承
- en: Inheritance was conceived of in the early days of computer programming, but
    although it has existed for a long time, folks still have spirited debates about
    when and how it should be used. For much of the history of object-oriented programming,
    inheritance was the name of the game. Many applications sought to model the real
    world as a carefully curated hierarchy of objects, in the hopes that it would
    lead to some kind of obvious, neat structure. This paradigm was so embedded into
    object-oriented programming practices that the two concepts—object-oriented programming
    and inheritance—were nearly inseparable.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是在计算机编程的早期被构想出来的，尽管它已经存在很长时间了，但人们仍然就何时以及如何使用它进行热烈的辩论。在面向对象编程的大部分历史中，继承是游戏的名字。许多应用程序试图将现实世界建模为一个精心策划的对象层级，希望它能导致某种明显、整洁的结构。这种范式已经深深嵌入到面向对象编程实践中，以至于面向对象编程和继承这两个概念几乎不可分离。
- en: 8.1.1\. The silver bullet
  id: totrans-589
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.1\. 银弹
- en: Though inheritance is sometimes the right tool to reach for, it has been used
    on occasion as the hammer for every nail—the elusive “silver bullet.” Much like
    a silver bullet, however, a paradigm that meets every need is a work of fiction.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然继承有时是正确的工具，但它有时被用作每个钉子的锤子——难以捉摸的“银弹”。然而，正如银弹一样，满足所有需求的范式是一种虚构。
- en: The ubiquity of class inheritance in object-oriented programming quietly sowed
    frustration for many developers, and over time more and more people renounced
    object-oriented programming altogether. This is an unfortunate outcome. Object
    orientation has a number of benefits for mental modeling of problems. Inheritance
    even has its place when modeling the right hierarchies. Although inheritance isn’t
    the solution to every data modeling problem you’ll encounter, it *is* the right
    solution for a specific set of use cases, which you’ll learn more about later
    in this chapter.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，类继承的普遍存在悄然地为许多开发者播下了挫败的种子，随着时间的推移，越来越多的人完全放弃了面向对象编程。这是一个不幸的结果。面向对象为问题的心理建模提供了许多好处。在建模正确的层级时，继承甚至有其位置。尽管继承不是解决你将遇到的每个数据建模问题的解决方案，但它*确实是*一组特定用例的正确解决方案，你将在本章后面了解更多。
- en: Before we get to that, though, it’s important for you to understand how class
    inheritance led to so much frustration.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们到达那里之前，了解类继承如何导致如此多的挫败感是很重要的。
- en: 8.1.2\. The challenges of hierarchies
  id: totrans-593
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.2\. 层级的挑战
- en: Object-oriented programming is all about the separation, encapsulation, and
    classification of information and behaviors. I work with a number of librarians
    who have forgotten more than I’ll ever know about classification—these folks work
    to identify relationships between things, creating taxonomies or even ontologies
    to categorize things.^([[1](#ch08fn01)]) This works well for organizing raw information,
    but it can introduce pain once software behavior is involved. As software grows,
    it becomes difficult to keep parent-child relationships between classes straight.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的全部都是关于信息的分离、封装和分类。我与一些图书管理员合作，他们比我更了解分类——这些人致力于识别事物之间的关系，创建分类法或甚至本体论来对事物进行分类。[^([1](#ch08fn01))]
    这对于组织原始信息很有效，但一旦涉及到软件行为，它可能会带来痛苦。随着软件的增长，保持类之间的父子关系变得困难。
- en: ¹
  id: totrans-595
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-596
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'For more on ontology in the context of information science, see the Wikipedia
    article: [https://en.wikipedia.org/wiki/Ontology_(information_science)](https://en.wikipedia.org/wiki/Ontology_(information_science)).'
  id: totrans-597
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 关于信息科学中的本体论，请参阅维基百科文章：[https://en.wikipedia.org/wiki/Ontology_(information_science)](https://en.wikipedia.org/wiki/Ontology_(information_science))。
- en: '|  |'
  id: totrans-598
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-599
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: _Parent_ classes are referred to as *superclasses* in Python (and in many other
    languages). *Child* classes are referred to as *subclasses*. I’ll use this nomenclature
    throughout the rest of the chapter.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: _父类_在Python（以及许多其他语言）中被称为*超类*。*子类*被称为*子类*。我将在本章的其余部分使用这个术语。
- en: '|  |'
  id: totrans-601
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: A class inherits all of its superclass’s information and behavior, and it can
    then override them to do something different ([figure 8.1](#ch08fig01)). This
    is probably the tightest coupling that exists in programming. A class is fully
    coupled to its superclass because everything it knows and does by default is tied
    to that superclass.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类继承其所有超类的信息和行为，然后可以覆盖它们以执行不同的操作（[图 8.1](#ch08fig01)）。这可能是编程中存在的最紧密耦合。一个类与其超类完全耦合，因为它所知道和默认执行的一切都与那个超类相关联。
- en: Figure 8.1\. Inheritance with one superclass and one subclass
  id: totrans-603
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.1. 一个超类和一个子类的继承
- en: '![](../Images/f0170-01_alt.jpg)'
  id: totrans-604
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/f0170-01_alt.jpg)'
- en: Seeing this coupling is *very difficult* when class hierarchies grow, because
    if you’re looking at a particular class, it isn’t obvious whether another class
    is inheriting from it or not. This leads to bugs because of unintended changes
    in behavior, as depicted in [figure 8.2](#ch08fig02).
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 当类层次结构增长时，看到这种耦合*非常困难*，因为如果你正在查看一个特定的类，并不明显另一个类是否继承自它。这会导致由于行为的不当变化而产生的错误，如图8.2所示。
- en: Figure 8.2\. How deep inheritance hierarchies can lead to more bugs
  id: totrans-606
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.2. 深层次的继承层次结构可能导致更多错误
- en: '![](../Images/f0171-01_alt.jpg)'
  id: totrans-607
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/f0171-01_alt.jpg)'
- en: 'To analogize, in quantum physics it’s possible for two particles to be *entangled*
    in such a way that changes to one will effect the same change in the other, regardless
    of how far apart they are in space. This “spooky action at a distance,” as Einstein
    called it, means that you can’t reliably determine the state of a particle, because
    that state could change at any moment because of a change in its twin particle’s
    state. This is exciting for physics, but in software it’s a big danger. By changing
    one class, you may inadvertently end up changing—or worse, breaking—the functionality
    in another subclass you were unaware of. It’s like the movie *Butterfly Effect*.
    (Spoiler alert: It doesn’t go well for Ashton Kutcher’s character.)'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 为了类比，在量子物理学中，两个粒子可以以一种方式*纠缠*在一起，即一个粒子的变化将影响另一个粒子的相同变化，无论它们在空间中相隔多远。爱因斯坦称之为“鬼魅般的远距离作用”，这意味着你无法可靠地确定粒子的状态，因为该状态可能会在任何时刻因为其孪生粒子的状态变化而改变。这对物理学来说很令人兴奋，但在软件中这是一个很大的危险。通过更改一个类，你可能会无意中改变——或者更糟，破坏——你未意识到的另一个子类的功能。这就像电影《蝴蝶效应》。（剧透警告：阿什顿·库彻的角色并不好过。）
- en: Developers frequently use inheritance to reuse code, but this presents challenges
    later on. With a deep hierarchy, classes at different levels may override or supplement
    their superclasses’ behavior. Before too long, you’ll find yourself traversing
    up and down your classes trying to follow the flow of information. I’ve said before
    that what we do as developers should increase our understanding and reduce cognitive
    load; deep hierarchies work against this goal. So why are we still using inheritance?
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者经常使用继承来重用代码，但这会带来后续的挑战。在深层层次结构中，不同级别的类可能会覆盖或补充其超类的行为。不久之后，你会发现自己在上下文穿越你的类，试图跟随信息的流动。我之前说过，我们作为开发者所做的事情应该增加我们的理解并减少认知负荷；深层层次结构与此目标相悖。那么我们为什么还在使用继承呢？
- en: 8.2\. The inheritance of programming present
  id: totrans-610
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2. 程序设计中的继承现状
- en: Because of the pains caused by complicated hierarchies, inheritance has gotten
    a bad reputation. It isn’t innately evil, though. It’s simply been used too often
    and for the wrong reasons.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 由于复杂层次结构带来的痛苦，继承已经声名狼藉。尽管如此，它本身并不是天生邪恶的。它只是被过度使用，并且出于错误的原因。
- en: 8.2.1\. What is inheritance for, really?
  id: totrans-612
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.1. 真正的继承是为了什么？
- en: Though many still reach for inheritance to reuse code in some class, that’s
    not what it’s for. Inheritance is for *specialization of behavior*. Put another
    way, you should fight the urge to subclass only to reuse code. Create subclasses
    to make a method return a different value or work differently under the hood.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管许多人仍然寻求使用继承来在某个类中重用代码，但这并不是继承的目的。继承是为了*行为的专门化*。换句话说，你应该抵制仅仅为了重用代码而子类化的冲动。创建子类是为了让一个方法返回不同的值或在其内部以不同的方式工作。
- en: In this sense, subclasses should be treated as *special cases* of their superclass.
    They will reuse code from the superclass, but only as a natural result of the
    idea that an instance of the subclass *is* an instance of the superclass.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个意义上，子类应该被视为其超类的*特殊情况*。它们将重用超类的代码，但这只是由于一个自然的结果，即子类的一个实例*确实是*超类的一个实例。
- en: When a class *B* inherits from a class *A*, we often say *B* “is-an” *A*. This
    is to stress that instances of *B* are in fact instances of *A*, and as such should
    look like an *A* (more on this in a bit). Contrast this with composition, where
    if an instance of class *C* uses an instance of a class *D*, we say that *C* “has-a”
    *D* to emphasize that *C* is composed of *D* (among other things, potentially).
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 当类*B*从类*A*继承时，我们经常说*B*“是”一个*A*。这是为了强调*B*的实例实际上是*A*的实例，并且应该看起来像*A*（稍后会详细说明）。这与组合相对比，如果类*C*使用类*D*的实例，我们说*C*“有”一个*D*，以强调*C*是由*D*（以及其他事物）组成的（可能还有其他）。
- en: Think back to the `Bicycle` example in the last chapter. You introduced multiple
    types of bicycle frames, upgrading the `AluminumFrame` to a `CarbonFiberFrame`
    and the `Tire` to a `FancyTire`. Suppose that `CarbonFiberFrame` and `FancyTire`
    inherited from `Frame` and `Tire`, respectively. Which of the following could
    be said about the way you modeled bicycles using inheritance and composition?
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下上一章中的`自行车`示例。你介绍了多种自行车车架类型，将`铝制车架`升级为`碳纤维车架`，并将`轮胎`升级为`花哨轮胎`。假设`碳纤维车架`和`花哨轮胎`分别从`车架`和`轮胎`继承而来。以下哪一项可以用来描述你使用继承和组合建模自行车的方式？
- en: A `Tire` has-a `Bicycle`.
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个`轮胎`有一个`自行车`。
- en: A `Bicycle` has-a `Tire`.
  id: totrans-618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个`自行车`有一个`轮胎`。
- en: A `CarbonFiberFrame` is-a `Frame`.
  id: totrans-619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个`碳纤维车架`是一个`车架`。
- en: A `CarbonFiberFrame` has-a `Frame`.
  id: totrans-620
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个`碳纤维车架`有一个`车架`。
- en: Because a tire isn’t composed of a bike (it’s the other way around), 1 is incorrect,
    whereas 2 makes sense—that’s composition. And because a carbon fiber frame *is*
    a frame (it doesn’t *have* a frame), 4 is also incorrect, whereas 3 makes sense—that’s
    inheritance. Again, inheritance is for specialization, whereas composition is
    for reusable behaviors ([figure 8.3](#ch08fig03)).
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 因为轮胎不是由自行车组成的（情况正好相反），所以1是不正确的，而2是有意义的——这是组合。而且因为碳纤维车架*是*一个车架（它没有*拥有*一个车架），所以4也是不正确的，而3是有意义的——这是继承。再次强调，继承用于专门化，而组合用于可重用行为([图8.3](#ch08fig03))。
- en: Figure 8.3\. How inheritance and composition work together
  id: totrans-622
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.3\. 继承和组合如何协同工作
- en: '![](../Images/f0173-01_alt.jpg)'
  id: totrans-623
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0173-01_alt.jpg)'
- en: Using inheritance to specialize behavior is only the first step. Think about
    how you’re able to swap in a carbon fiber frame to replace the aluminum frame
    on your bike. You can do this because each frame has the same connection points.
    Without all the right connections, your bike could fall apart. The same can be
    said of your software.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 使用继承来专门化行为只是第一步。想想你如何能够替换碳纤维车架来替换自行车上的铝制车架。你可以这样做，因为每个车架都有相同的连接点。如果没有所有正确的连接，你的自行车可能会散架。你的软件也是如此。
- en: 8.2.2\. Substitutability
  id: totrans-625
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.2\. 可替换性
- en: Barbara Liskov, Institute Professor at MIT, developed a principle outlining
    the concept of *substitutability* as it relates to inheritance. The Liskov substitution
    principle states that in a program, any instance of a class must be replaceable
    by an instance of one of its subclasses without affecting the correctness of the
    program.*^([[2](#ch08fn02)]) Correctness* in this context means the program remains
    error-free and achieves the same basic outcomes, though the precise result may
    be different or achieved in a different manner. Substitutability arises from subclasses
    strictly adhering to their superclasses’ interface.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 麻省理工学院的教授Barbara Liskov提出了一个原则，概述了与继承相关的*可替换性*概念。Liskov替换原则指出，在一个程序中，任何类的实例都必须可以被其子类之一的实例替换，而不会影响程序的正确性。*^([[2](#ch08fn02)])
    在这个语境中，“正确性”意味着程序保持无错误并实现相同的基本结果，尽管精确的结果可能不同或以不同的方式实现。可替换性源于子类严格遵循其超类接口。
- en: ²
  id: totrans-627
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-628
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'For more on the Liskov substitution principle, see the Wikipedia article: [https://en.wikipedia.org/wiki/Liskov_substitution_principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle).'
  id: totrans-629
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 关于Liskov替换原则的更多信息，请参阅维基百科文章：[https://en.wikipedia.org/wiki/Liskov_substitution_principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle)。
- en: It’s not difficult to stray from this principle in Python. Consider the following
    listing, which is perfectly valid Python code that models slugs and snails (two
    types of gastropod). The `Snail` inherits from `Slug` (snails and slugs are the
    same, aside from the shell), and you might even say the `Snail` is specializing
    the `Slug` by adding information about its shell. But the `Snail` is breaking
    substitutability, because a program that is using a `Slug` can’t replace it with
    a `Snail` without adding the `shell_size` argument to the `__init__` method, as
    shown in the following listing.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中偏离这个原则并不困难。考虑以下列表，这是一段完全有效的Python代码，用于模拟蛞蝓和蜗牛（两种软体动物）。`蜗牛`从`蛞蝓`继承（蜗牛和蛞蝓除了壳以外是一样的），你甚至可以说`蜗牛`通过添加有关其壳的信息来专门化`蛞蝓`。但是`蜗牛`违反了可替换性，因为使用`蛞蝓`的程序不能在不添加`shell_size`参数到`__init__`方法的情况下替换它，如下面的列表所示。
- en: Listing 8.1\. A subclass that breaks substitutability
  id: totrans-631
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.1\. 一个违反可替换性的子类
- en: '[PRE47]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '***1* Snail inherits from Slug.**'
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1* 蜗牛继承自蛞蝓。**'
- en: '***2* Using a different instance creation signature is a common way to violate
    substitutability.**'
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2* 使用不同的实例创建签名是违反可替换性的常见方式。**'
- en: '***3* You can create two Slug instances and race them.**'
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 你可以创建两个Slug实例并让它们比赛。**'
- en: '***4* Trying to use Snail without a shell_size argument raises an exception.**'
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 尝试使用没有shell_size参数的Snail会引发异常。**'
- en: You could pull more tricks out of your sleeve to make this work, but consider
    that this might be a better case for composition. A snail *has-a* shell, after
    all.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以施展更多的技巧来使这可行，但考虑这可能是组合的更好用例。毕竟，蜗牛*有*壳。
- en: I like to think about substitutability by examining the *role* a particular
    set of classes fills. If each class in a hierarchy can fulfill the role in question,
    they’re likely substitutable. If a subclass changes any of its method signatures
    or raises an exception as part of its specialization, it may not fulfill that
    role, and this might be a hint that the class hierarchy should be arranged differently.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢通过检查特定一组类所扮演的*角色*来思考可替换性。如果一个层次结构中的每个类都能履行所问的角色，它们很可能是可替换的。如果一个子类更改了其任何方法签名或在其特殊化过程中引发异常，它可能无法履行该角色，这可能是提示类层次结构应该以不同的方式组织的一个线索。
- en: 8.2.3\. The ideal use case for inheritance
  id: totrans-639
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.3\. 继承的理想用例
- en: Sandi Metz, a Ruby programmer who originally came from the Smalltalk community
    (Smalltalk being a programming language written in part by Alan Kay, one of the
    pioneers of object-oriented programming), laid out a great set of ground rules
    about when to use inheritance:^([[3](#ch08fn03)])
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: Sandi Metz，一位来自Smalltalk社区的Ruby程序员（Smalltalk是由对象编程先驱艾伦·凯部分编写的编程语言），提出了一套关于何时使用继承的很好的基本规则：[[3](#ch08fn03)])
- en: ³
  id: totrans-641
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-642
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See Sandi Metz, “All the Little Things,” RailsConf 2014, [www.youtube.com/watch?v=8bZh5LMaSmE](http://www.youtube.com/watch?v=8bZh5LMaSmE)
    for more.
  id: totrans-643
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 更多信息请参阅Sandi Metz，“所有的小事情”，RailsConf 2014，[www.youtube.com/watch?v=8bZh5LMaSmE](http://www.youtube.com/watch?v=8bZh5LMaSmE)。
- en: The problem you’re solving has a shallow, narrow hierarchy.
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你正在解决的问题有一个浅层、狭窄的层次结构。
- en: Subclasses are at the leaves of the object graph; they don’t make use of other
    objects.
  id: totrans-645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类位于对象图的叶子位置；它们不使用其他对象。
- en: Subclasses use (or specialize) *all* the behavior of their superclass.
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类使用（或特殊化）其超类*所有*的行为。
- en: I’ll talk through each of these in a little more detail.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 我将更详细地讨论这些内容。
- en: SHALLOW, NARROW HIERARCHY
  id: totrans-648
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 浅层、狭窄层次结构
- en: 'The *shallow* part of this rule addresses the problem with deep inheritance
    hierarchies you learned earlier: deeply nested class hierarchies can lead to difficult
    management and the introduction of bugs. Keeping the hierarchy small and contained
    makes it easier to reason about when necessary ([figure 8.4](#ch08fig04)).'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则的*浅层*部分解决了你之前学到的深层继承层次结构的问题：深层嵌套的类层次结构可能导致难以管理并引入错误。保持层次结构小而紧凑，使得在必要时进行推理变得更加容易（[图8.4](#ch08fig04)）。
- en: Figure 8.4\. Narrow, shallow inheritance hierarchies can be reasoned about more
    effectively.
  id: totrans-650
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.4\. 狭窄、浅层继承层次结构可以更有效地进行推理。
- en: '![](../Images/f0175-01_alt.jpg)'
  id: totrans-651
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0175-01_alt.jpg)'
- en: The *narrow* part of this rule means that no class in the hierarchy should have
    too many subclasses. As the number of subclasses grows, it becomes difficult to
    know which ones provide which specialization, and other developers may duplicate
    subclasses if they can’t find the one they’re looking for.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则的*狭窄*部分意味着在层次结构中，没有哪个类应该有太多的子类。随着子类数量的增加，很难知道哪些子类提供了哪些特殊化，如果其他开发者找不到他们想要的子类，他们可能会重复创建子类。
- en: SUBCLASSES AT THE LEAVES OF THE OBJECT GRAPH
  id: totrans-653
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 对象图叶子的子类
- en: You can think of all the objects in your software as nodes in a graph, with
    each object pointing to other objects it inherits from or makes use of through
    composition. When using inheritance, a class may point to other objects, but its
    *subclasses* generally shouldn’t have any further dependencies. Subclasses are
    for *specializing* behavior, but if a subclass has a unique dependency that the
    superclass or any other subclasses don’t have, composition might be a better way
    to accomplish that portion of the task. This is a good check to make sure that
    your subclasses are specializing behavior without adding much new coupling.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将你软件中的所有对象视为图中的节点，每个对象都指向它继承或通过组合使用其他对象。当使用继承时，一个类可以指向其他对象，但它的*子类*通常不应该有任何进一步的依赖。子类用于*特殊化*行为，但如果子类有一个超类或任何其他子类都没有的独特依赖，组合可能是一个更好的完成任务的方式。这是一个很好的检查，以确保你的子类在特殊化行为的同时没有添加太多新的耦合。
- en: SUBCLASSES USE ALL THE BEHAVIOR OF THEIR SUPERCLASS
  id: totrans-655
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 子类使用其超类所有的行为
- en: 'This is an outcome of the “is-a” relationship you learned about earlier. If
    a subclass *doesn’t* use all of its superclass’s behavior, is it *really* an instance
    of the superclass? Consider a class that represents a bird:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 这是之前你学到的“is-a”关系的结果。如果一个子类没有使用其超类中的所有行为，它是否真的是超类的一个实例？考虑一个代表鸟的类：
- en: '[PRE48]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You might subclass this so that `fly` does something different for certain
    kinds of birds:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以子类化这个类，使得`fly`对某些类型的鸟有不同的行为：
- en: '[PRE49]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'What happens when you get to a penguin, or a kiwi, or an ostrich? None of these
    birds fly at all. One possible solution is to override `fly` in this way:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 当你到达企鹅、几维鸟或鸵鸟时会发生什么？这些鸟都不会飞。一个可能的解决方案是以这种方式覆盖`fly`：
- en: '[PRE50]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You could also override `fly` to do nothing (`pass`) or raise an exception of
    some kind. This goes against the substitutability principle, though. Any code
    that *knows* it’s dealing with a `Penguin` will be unlikely to call `fly` at all,
    so that behavior isn’t being used. Again, composition of the flying behavior into
    classes that need it might be a better choice here.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以覆盖`fly`使其不执行任何操作（`pass`）或引发某种类型的异常。但这违背了可替换性原则。任何知道它正在处理`Penguin`的代码不太可能调用`fly`，因此这种行为没有被使用。再次强调，将飞行行为组合到需要它的类中可能是一个更好的选择。
- en: EXERCISE
  id: totrans-663
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: EXERCISE
- en: Now that you know some of the things to look for, try applying the rules for
    inheritance and composition to the `Bicycle` example. The bicycle module can be
    found in the source code for this chapter(see [https://github.com/daneah/practices-of-the-python-pro](https://github.com/daneah/practices-of-the-python-pro)).
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了一些需要关注的事情，尝试将继承和组合的规则应用到`Bicycle`示例中。自行车模块可以在本章的源代码中找到（见[https://github.com/daneah/practices-of-the-python-pro](https://github.com/daneah/practices-of-the-python-pro)）。
- en: How well does the `Bicycle` example follow the rules for inheritance that Metz
    describes? See if you can tell whether the objects in the bicycle module do or
    do not follow each of the rules.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bicycle`示例遵循Metz描述的继承规则有多好？看看你是否能判断自行车模块中的对象是否遵循每一条规则。'
- en: 'Come back here to see how you did:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 回到这里看看你的表现：
- en: '`Frame` and `Tire` both have a narrow, shallow hierarchy; they each have one
    level below them, with at most two subclasses.'
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Frame`和`Tire`都有一个狭窄的、浅层层次结构；它们各自有一个在其下面的层级，最多有两个子类。'
- en: The different types of tires and frames don’t depend on any other objects.
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同类型的轮胎和框架不依赖于任何其他对象。
- en: The different types of tires and frames use or specialize all the behavior of
    their superclasses.
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同类型的轮胎和框架使用或专门化它们超类中的所有行为。
- en: Success! The model you created uses inheritance properly where needed, and uses
    composition to bring different pieces together into a whole. Read on to see what
    tools Python provides for inspecting and using inheritance.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！你创建的模型在需要的地方正确使用了继承，并使用组合将不同的部分组合成一个整体。继续阅读，了解Python提供了哪些工具来检查和使用继承。
- en: 8.3\. Inheritance in Python
  id: totrans-671
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3\. Python中的继承
- en: Python provides a set of tools for examining classes and their inheritance structure,
    along with a number of ways to approach inheritance and composition. This section
    will cover each of them so that when you do use inheritance, you’ll have the know-how
    to debug and test your code.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了一套用于检查类及其继承结构的工具，以及多种处理继承和组合的方法。本节将涵盖它们，以便当你使用继承时，你将拥有调试和测试代码的知识。
- en: 8.3.1\. Type inspection
  id: totrans-673
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.1\. 类型检查
- en: One of the most common things you’ll want to know when debugging your code is
    what type of object you’re dealing with on a particular line. Python’s dynamic
    typing means this isn’t always immediately obvious, so it’s a good thing to inspect.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在调试代码时，最想知道的一件事是在特定行你正在处理的是哪种类型的对象。Python的动态类型意味着这并不总是立即明显，所以检查是一个好习惯。
- en: '|  |'
  id: totrans-675
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Type checking**'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型检查**'
- en: The latest versions of Python support *type hinting*, which is a way to tell
    developers and automated tooling what types of objects a function or method expects.
    Tools can check for calls that might violate these types, without executing your
    code. Note that Python doesn’t enforce the types during execution; this feature
    is strictly a development aid.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: Python的最新版本支持*类型提示*，这是一种告诉开发者和自动化工具函数或方法期望哪些类型对象的方法。工具可以在不执行你的代码的情况下检查可能违反这些类型的调用。注意，Python在执行期间不强制执行类型；这个特性严格上是开发辅助工具。
- en: '|  |'
  id: totrans-678
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The basic way to check the type of an object is to use the built-in `type()`
    function. `type(some_object)` will tell you which class that object is an instance
    of:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 检查对象类型的基本方法是使用内置的`type()`函数。`type(some_object)`会告诉你该对象是哪个类的实例：
- en: '[PRE51]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Although this is useful, you’ll also frequently want to know if an object is
    an instance of a particular class or any of its subclasses. Python provides the
    `isinstance()` function for this purpose:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这很有用，但你也会经常想知道一个对象是否是特定类或其子类的实例。Python提供了`isinstance()`函数来完成这个目的：
- en: '[PRE52]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '***1* Any classes you reference will need to be imported into the namespace.**'
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 你引用的任何类都需要导入到命名空间中。**'
- en: 'Lastly, if you only need to know whether a class is a subclass of another,
    Python gives you the `issubclass` function:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你只想知道一个类是否是另一个类的子类，Python提供了`issubclass`函数：
- en: '[PRE53]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '|  |'
  id: totrans-686
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-687
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '`issubclass` is somewhat confusingly named. Because it considers a class to
    be a subclass of itself, it will return `True` even if the two classes you provide
    are in fact the same class.'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: '`issubclass`的命名有些令人困惑。因为它认为一个类是其自身的子类，所以即使你提供的两个类实际上是同一个类，它也会返回`True`。'
- en: '|  |'
  id: totrans-689
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: These tools can come in handy in real code occasionally, but their presence
    is often a red flag, because changing behavior based on the data type is precisely
    what subclasses of behavior are for. These built-in functions are good for inspecting
    objects from the outside, but Python also provides useful features for handling
    inheritance *within* classes.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具偶尔在真实代码中可能很有用，但它们的存在通常是一个红旗，因为基于数据类型改变行为正是行为子类的作用所在。这些内置函数对于从外部检查对象来说很好，但Python也提供了在类内部处理继承的有用特性。
- en: 8.3.2\. Superclass access
  id: totrans-691
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.2. 超类访问
- en: Suppose you’re creating a subclass and you need to specialize its behavior in
    a way that depends on its superclass’s original behavior. How can you do that
    in Python? You can use the built-in `super()` function, as shown in the following
    listing, which forwards any method or attribute accesses to the superclass.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在创建一个子类，并且需要以依赖于其超类原始行为的方式专门化其行为。你如何在Python中做到这一点？你可以使用内置的`super()`函数，如下所示，它将任何方法或属性访问转发到超类。
- en: Listing 8.2\. Using `super()` to access superclass behavior
  id: totrans-693
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.2. 使用`super()`访问超类行为
- en: '[PRE54]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '***1* A corrupt teller is-a teller.**'
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 一个腐败的出纳员是一个出纳员。**'
- en: '***2* The corrupt teller overrides the default deposit behavior.**'
  id: totrans-696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 腐败的出纳员覆盖了默认的存款行为。**'
- en: '***3* The corrupt teller skims a little off the top for himself.**'
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 腐败的出纳员从顶部拿走一小部分。**'
- en: '***4* He deposits the rest the way any teller does, but using a different amount.**'
  id: totrans-698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 他像任何出纳员一样存入剩余的金额，但使用不同的金额。**'
- en: Code that uses `super()` can become particularly confusing if substitutability
    is broken. Overriding methods to take different numbers of arguments, and passing
    only some of them along using `super()`, can lead to confusion and poor maintainability.
    Substitutability becomes particularly important in the case of *multiple inheritance*
    in Python.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`super()`的代码如果可替换性被破坏，可能会变得特别复杂。覆盖接受不同数量参数的方法，并使用`super()`仅传递其中一些，可能会导致混淆和可维护性差。在Python的**多重继承**情况下，可替换性变得尤为重要。
- en: 8.3.3\. Multiple inheritance and method resolution order
  id: totrans-700
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.3. 多重继承和方法解析顺序
- en: Up to now, I’ve mostly been discussing *single* inheritance, where a subclass
    has precisely one superclass. But Python also supports the idea of *multiple inheritance*,
    where a subclass may have two or more direct superclasses, as shown in [figure
    8.5](#ch08fig05).
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我主要讨论的是**单一**继承，其中子类恰好有一个超类。但Python也支持**多重继承**的概念，其中子类可能有两个或更多直接超类，如图8.5所示。
- en: Figure 8.5\. Single and multiple inheritance
  id: totrans-702
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.5. 单一和多重继承
- en: '![](../Images/f0178-01_alt.jpg)'
  id: totrans-703
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0178-01_alt.jpg)'
- en: Multiple inheritance has uses within plugin architectures or when you want to
    implement multiple interfaces in one class. For example, an aquatic vehicle has
    the interfaces of both a boat and a car.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 多重继承在插件架构中或当你想在单个类中实现多个接口时很有用。例如，水陆两栖车辆具有船和汽车两种接口。
- en: You can inherit from multiple classes in a subclass by providing more than one
    in the class definition, as shown in [listing 8.3](#ch08ex3). Place this code
    in a “cats” module to give it a try for yourself. Can you guess what `print(liger.eats())`
    does before running this code?
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在类定义中提供多个类来在子类中从多个类继承，如图8.3所示。将此代码放在一个“cats”模块中，自己试一试。在运行此代码之前，你能猜出`print(liger.eats())`会做什么吗？
- en: Listing 8.3\. Multiple inheritance in Python
  id: totrans-706
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.3\. Python 中的多重继承
- en: '[PRE55]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '***1* Lion is-a BigCat through single inheritance.**'
  id: totrans-708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Lion 通过单继承是 BigCat 的子类。**'
- en: '***2* Tiger also is-a BigCat through single inheritance.**'
  id: totrans-709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* Tiger 也通过单继承是 BigCat 的子类。**'
- en: '***3* Liger uses multiple inheritance; it is-a Lion and it is-a Tiger.**'
  id: totrans-710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* Liger 使用多重继承；它是 Lion 和 Tiger 的子类。**'
- en: Does the liger eat the prey you expected?
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 狮子会吃你预期的猎物吗？
- en: '[PRE56]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Because `Liger` inherits both from `Lion` and `Tiger`, you might have expected
    it would eat the same prey they eat, at a minimum. `super()` works a bit differently
    under multiple inheritance. When `super().eats()` is called, Python starts searching
    for the definition of `eats()` that it should use. Python does this through a
    process called *method resolution order*, which determines the list of classes
    Python will search, in order.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `Liger` 从 `Lion` 和 `Tiger` 继承，你可能预期它至少会吃它们吃的相同猎物。在多重继承下，`super()` 的工作方式略有不同。当调用
    `super().eats()` 时，Python 会开始搜索它应该使用的 `eats()` 方法定义。Python 通过一个称为 *方法解析顺序* 的过程来完成这项工作，该过程确定了
    Python 将按顺序搜索的类列表。
- en: 'These are the steps for method resolution order:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 这是方法解析顺序的步骤：
- en: Generate a depth-first ordering of the superclasses, from left to right. For
    `Liger` this is `Lion` (leftmost parent), `BigCat` (the only parent of `Lion`),
    `object` (the implicit parent of `BigCat`), `Tiger` (the next parent of `Liger`),
    `BigCat`, and `object` (see [figure 8.6](#ch08fig06)).
  id: totrans-715
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左到右生成超类的深度优先排序。对于 `Liger` 来说，这是 `Lion`（最左边的父类）、`BigCat`（`Lion` 的唯一父类）、`object`（`BigCat`
    的隐式父类）、`Tiger`（`Liger` 的下一个父类）、`BigCat` 和 `object`（见 [图 8.6](#ch08fig06)）。
- en: Figure 8.6\. The depth-first ordering for a class inheritance hierarchy
  id: totrans-716
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.6\. 类继承层次结构的深度优先排序
- en: '![](../Images/f0180-01_alt.jpg)'
  id: totrans-717
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](../Images/f0180-01_alt.jpg)'
- en: Remove any duplicates. The list becomes `Liger`, `Lion`, `BigCat`, `object`,
    and `Tiger`.
  id: totrans-718
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除任何重复项。列表变为 `Liger`、`Lion`、`BigCat`、`object` 和 `Tiger`。
- en: Move each class so that it appears after all of its subclasses. The final list
    is `Liger`, `Lion`, `Tiger`, `BigCat`, `object`.
  id: totrans-719
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个类移动，使其出现在所有子类之后。最终的列表是 `Liger`、`Lion`、`Tiger`、`BigCat`、`object`。
- en: How does this look for `Liger`? The full process is shown in [figure 8.7](#ch08fig07).
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Liger` 来说，这看起来如何？完整的过程在 [图 8.7](#ch08fig07) 中展示。
- en: Figure 8.7\. How Python determines the method resolution order for a class
  id: totrans-721
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.7\. Python 确定类的方法解析顺序
- en: '![](../Images/f0180-02_alt.jpg)'
  id: totrans-722
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0180-02_alt.jpg)'
- en: When you ask for `super().eats()`, Python will work its way through the method
    resolution order until it finds an `eats()` method on one of the classes (other
    than the one you called `super()` from). As you can see, it finds `Lion` first,
    which returns `['wildebeest']`. `Liger` then adds its own list of prey animals,
    resulting in the list you saw in the output.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 当你请求 `super().eats()` 时，Python 会通过方法解析顺序一路查找，直到在某个类（除了你调用 `super()` 的那个类）上找到一个
    `eats()` 方法。正如你所见，它首先找到 `Lion`，返回 `['wildebeest']`。然后 `Liger` 添加它自己的猎物列表，结果是你在输出中看到的列表。
- en: '|  |'
  id: totrans-724
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Inspecting the method resolution order**'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '**检查方法解析顺序**'
- en: 'You can see the method resolution order for any class by using its `__mro__`
    attribute:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用其 `__mro__` 属性来查看任何类的 `method resolution order`：
- en: '[PRE57]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '|  |'
  id: totrans-728
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You *can* make multiple inheritance work as you expected by practicing *cooperative*
    multiple inheritance. In cooperative multiple inheritance, each class commits
    to having the same method signatures (substitutability) and to calling `super().some_method()`
    from within its own `some_method()`. The presence of `super()` in each method
    means Python will keep going through the method resolution order even after it
    finds a method. This ensures that no class blocks execution or breaks things with
    an unexpected interface. The classes play nicely together.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 你 *可以* 通过练习 *合作* 多重继承使多重继承按预期工作。在合作多重继承中，每个类都承诺拥有相同的方法签名（可替换性）并在其 `some_method()`
    中调用 `super().some_method()`。每个方法中 `super()` 的存在意味着 Python 会在找到方法后继续通过方法解析顺序。这确保了没有类会阻止执行或因意外接口而破坏事物。类们相处得很好。
- en: Try updating the `Lion` and `Tiger` classes to call `super().eats()`, the same
    way the `Liger.eats()` method does. Rerun the code and come back here to check
    if it matches the following output.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试更新 `Lion` 和 `Tiger` 类以调用 `super().eats()`，就像 `Liger.eats()` 方法做的那样。重新运行代码，然后回到这里检查它是否与以下输出匹配。
- en: '[PRE58]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Although multiple inheritance isn’t something you’re likely to use every day,
    it’s important to know how to tackle it when you see it. As your software grows,
    the likelihood that you’ll need to make use of different paradigms increases,
    so come prepared.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然多重继承可能不是你每天都会用到的东西，但当你遇到它时，了解如何处理它是很重要的。随着你的软件不断增长，你需要使用不同范式的可能性也在增加，所以要做好准备。
- en: 8.3.4\. Abstract base classes
  id: totrans-733
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.4\. 抽象基类
- en: Up to now, I’ve fibbed to you a bit about interfaces being unavailable in Python.
    You first needed to get a handle on when and how to use inheritance and composition
    effectively, but now is a good time to delve a bit deeper.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我对你说过一些关于Python中接口不可用的谎言。你首先需要掌握何时以及如何有效地使用继承和组合，但现在是一个深入了解的好时机。
- en: '*Abstract base classes* in Python are a way of using something that looks like
    inheritance to achieve something that’s effectively an interface. An abstract
    base class, like a formal interface in other languages, outlines which methods
    and attributes its subclasses *must* implement. This gets back to the idea of
    fulfilling roles mentioned earlier, in [section 8.2.2](#ch08lev2sec4). You can’t
    create an instance of an abstract base class directly; it acts as a template for
    how other classes behave.'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python中的抽象基类是一种使用类似继承的方式来达到实际上是一个接口的效果。抽象基类，就像其他语言中的正式接口一样，概述了其子类必须实现的哪些方法和属性。这回到了之前提到的履行角色的概念，在[第8.2.2节](#ch08lev2sec4)。你不能直接创建抽象基类的实例；它充当了其他类行为的模板。'
- en: 'Python provides the abc module for easing the creation of abstract base classes.
    The abc module provides a couple of helpful constructs:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了一个abc模块，用于简化抽象基类的创建。abc模块提供了一些有用的构造：
- en: You can inherit from the `ABC` class to indicate that your class is an abstract
    base class.
  id: totrans-737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过从`ABC`类继承来表示你的类是一个抽象基类。
- en: You can mark methods defined in your abstract base class as abstract using the
    `@abstractmethod` decorator. (Decorators are outside the scope of this book, but
    you can think of `abstractmethod` as a label for a method you define.) This enforces
    the rule that these methods must be defined in any subclass of your abstract class.
  id: totrans-738
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用`@abstractmethod`装饰器在你的抽象基类中标记定义的方法为抽象方法。（装饰器超出了本书的范围，但你可以将`abstractmethod`视为你定义的方法的一个标签。）这强制规定这些方法必须在你的抽象类的任何子类中定义。
- en: Suppose you’re modeling a food chain, and you want to make sure all the predator
    classes adhere to an interface that includes an `eat` method for eating prey.
    You can create an abstract base class, `Predator`, that defines this method and
    its signature. Then you can subclass `Predator`, and any subclass that doesn’t
    define `eat` will raise an exception, as noted in the following listing.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在模拟一个食物链，并确保所有的捕食类都遵循一个包含用于捕食猎物的`eat`方法的接口。你可以创建一个抽象基类`Predator`，它定义了这个方法和它的签名。然后你可以从`Predator`派生出一个子类，任何没有定义`eat`的子类都会引发异常，如以下列表所示。
- en: Listing 8.4\. Using abstract base classes to enforce an interface
  id: totrans-740
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.4\. 使用抽象基类强制实现接口
- en: '[PRE59]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '***1* Inheriting from ABC makes this class an abstract base class.**'
  id: totrans-742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从ABC继承使这个类成为一个抽象基类。**'
- en: '***2* This indicates that the method must be defined on any subclasses.**'
  id: totrans-743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 这表示该方法必须在任何子类中定义。**'
- en: '***3* This method signature can be checked by IDEs in any subclasses.**'
  id: totrans-744
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 该方法签名可以在任何子类中由IDE进行检查。**'
- en: '***4* Abstract methods have no default implementation.**'
  id: totrans-745
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 抽象方法没有默认实现。**'
- en: '***5* States your intent to implement the interface by subclassing the abstract
    base class**'
  id: totrans-746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 通过从抽象基类派生来声明实现接口的意图**'
- en: '***6* This method must be defined, or an exception will be raised.**'
  id: totrans-747
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 此方法必须定义，否则将引发异常。**'
- en: '|  |'
  id: totrans-748
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-749
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you’re using an IDE, it can warn you if you have the wrong method signature.
    Python won’t check this at runtime, but it may still raise an error for the usual
    mistakes, like too many or too few arguments.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是IDE，它会在你有错误的方法签名时警告你。Python在运行时不会检查这一点，但它仍然可能会因为一些常见的错误（如参数过多或过少）而引发错误。
- en: '|  |'
  id: totrans-751
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Try creating a new `Predator` without the `eat` method, and then try creating
    an instance of it at the end of the module. You should see a `TypeError` mentioning
    that the instance couldn’t be created because it didn’t define an implementation
    for the abstract method `eat()`.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试创建一个没有`eat`方法的`Predator`新实例，然后在模块的末尾尝试创建它的实例。你应该会看到一个`TypeError`，指出实例无法创建，因为它没有为抽象方法`eat()`定义实现。
- en: Now try adding a method to the `Bear` class that makes it roar. What do you
    expect to happen?
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试向`Bear`类添加一个使其咆哮的方法。你期待会发生什么？
- en: A `TypeError` is raised when the instance is created because `Predator` doesn’t
    define `roar` as an abstract method.
  id: totrans-754
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当实例被创建时，会引发一个`TypeError`，因为`Predator`没有将`roar`定义为抽象方法。
- en: A `RuntimeError` is raised when `roar()` is called because `Predator` doesn’t
    define `roar` as an abstract method.
  id: totrans-755
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当调用`roar()`时，会引发一个`RuntimeError`，因为`Predator`没有将`roar`定义为抽象方法。
- en: It works like any normal class method.
  id: totrans-756
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它的工作方式与任何正常的类方法一样。
- en: Defining additional methods on a subclass of an abstract base class works just
    fine (option 3). An abstract base class enforces that its subclasses *minimally*
    implement the methods it defines, but additional behavior is fine because the
    subclass still implements the desired interface. It’s also possible to put additional
    behavior into the base class itself and receive it in subclasses like normal inheritance.
    Steer away from that practice, though, because putting real behavior in a class
    that claims to be abstract could confuse whoever reads the code.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 在抽象基类的子类上定义额外的方法定义（选项3）工作得很好。一个抽象基类强制其子类**最小化**实现它定义的方法，但额外的行为是可以接受的，因为子类仍然实现了所需的接口。也可以将额外的行为放入基类本身，并在子类中像正常继承一样接收它。但是，要避免这种做法，因为在一个声称是抽象的类中放置实际的行为可能会让阅读代码的人感到困惑。
- en: Abstract base classes are a nice supplement to Python’s duck typing; if you
    need additional protections and guarantees around the interfaces to which your
    classes must adhere, they’re there for you. I don’t find myself reaching for them
    often, though. Composition via inversion of control is usually enough for me.
    Try using both and see which makes more sense to you and your code.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象基类是Python的鸭子类型的一个很好的补充；如果你需要围绕你的类必须遵循的接口提供额外的保护和保证，它们就在那里供你使用。尽管如此，我并不经常使用它们。通过控制反转的组合通常对我来说已经足够了。尝试使用两者，看看哪一个对你和你的代码更有意义。
- en: Now that you’ve got a good handle on the different aspects of inheritance, let’s
    take a look at Bark to see what opportunities it holds for inheritance and composition.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经很好地掌握了继承的不同方面，让我们来看看树皮，看看它为继承和组合提供了哪些机会。
- en: 8.4\. Inheritance and composition in Bark
  id: totrans-760
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4. 在树皮中的继承和组合
- en: Bark hasn’t made use of inheritance so far. See how far you can get without
    it? But as you’ve learned, inheritance can help you out when used correctly. In
    this last section, you’ll see how you can use it to make Bark more robust.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 树皮到目前为止还没有使用继承。看看在不使用它的情况下你能走多远？但是，正如你所学的，当正确使用时，继承可以帮助你。在本节的最后，你将看到如何使用它来使树皮更加健壮。
- en: 8.4.1\. Refactoring to use an abstract base class
  id: totrans-762
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.1. 使用抽象基类重构
- en: Interfaces are a way to declare that a class implements a specific set of methods
    and attributes, and you just learned that abstract base classes can be used to
    augment the idea of interfaces in Python. Which of the following adhere to an
    interface in Bark?
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是一种声明类实现一组特定方法和属性的方式，而你刚刚了解到抽象基类可以用来增强Python中接口的概念。以下哪些在树皮中遵循接口？
- en: Commands in the commands module
  id: totrans-764
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令模块中的命令
- en: Database statement execution in the database module
  id: totrans-765
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库模块中的数据库语句执行
- en: Options in the bark module
  id: totrans-766
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 树皮模块中的选项
- en: Options in the bark module all behave similarly, but there isn’t a distinct
    *class* for each option, only distinct *instances* of `Option`. This doesn’t look
    like an interface. Database statement execution is similarly contained within
    a single class. Commands (option 1) make use of interfaces; each command class
    implements an `execute()` method that is called when the command is triggered.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 树皮模块中的所有选项都表现出类似的行为，但每个选项并没有一个独特的**类**，只有`Option`的**实例**是独特的。这看起来不像是一个接口。数据库语句的执行同样被包含在一个单独的类中。命令（选项1）利用接口；每个命令类实现了一个`execute()`方法，当命令被触发时会被调用。
- en: To make sure all your future commands remember to implement the `execute()`
    method, I’d like you to refactor the commands module to use an abstract base class.
    You can call this base class `Command`, and it should define the `execute()` method
    as an `abstractmethod` that raises `NotImplementedError` by default. Each of the
    existing command classes should then inherit from `Command`.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你未来的所有命令都记得实现`execute()`方法，我希望你重构命令模块以使用抽象基类。你可以称这个基类为`Command`，并且它应该定义一个`execute()`方法作为`abstractmethod`，默认情况下会引发`NotImplementedError`。现有的每个命令类都应该从`Command`继承。
- en: Note that the existing command classes all implement `execute()` already, so
    they’re covered on that front. But there are a few different signatures for the
    `execute()` method, which you learned isn’t good for substitutability or when
    dealing with abstract base classes. Some are called with a `data` argument, whereas
    others take no arguments. Think about how you could normalize the methods so they
    have the same signature. Which of the following would work?
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现有的命令类都已经实现了 `execute()` 方法，所以在这一方面已经得到了覆盖。但是，`execute()` 方法的签名有一些不同，你了解到这不利于可替换性或处理抽象基类的情况。有些方法使用
    `data` 参数调用，而有些则不接受任何参数。考虑一下你如何规范化这些方法，使它们具有相同的签名。以下哪个选项是可行的？
- en: Remove the `data` argument from the `execute()` methods that accept it.
  id: totrans-770
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从接受 `data` 参数的 `execute()` 方法中移除 `data` 参数。
- en: Add `data` as an optional keyword argument to the `execute()` methods that don’t
    already accept it.
  id: totrans-771
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `data` 作为可选的关键字参数添加到尚未接受它的 `execute()` 方法中。
- en: Make all `execute()` methods accept a variable number of positional arguments
    (`*args`).
  id: totrans-772
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使所有 `execute()` 方法接受可变数量的位置参数 (`*args`)。
- en: Removing the `data` argument (option 1) would stop you from being able to act
    on the data inside the commands, which would remove a fair amount of functionality
    from Bark. Although option 3 would work, it’s often best to be explicit about
    the arguments you accept until you need flexibility to handle widely differing
    numbers of arguments. Right now, `execute()` always needs one or zero arguments,
    so I’d choose to go the route of adding `data` as an argument to each of them
    (option 2).
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 移除 `data` 参数（选项 1）将阻止你能够在命令内部操作数据，这将从 Bark 中移除相当多的功能。尽管选项 3 可以工作，但通常最好在需要处理不同数量的参数的灵活性之前明确地说明你接受的参数。目前，`execute()`
    总是需要一个或零个参数，所以我选择将 `data` 作为参数添加到每个方法中（选项 2）。
- en: Try creating the `Command` abstract base class and inheriting from it for your
    commands. As you go along, try renaming `execute()` methods temporarily or changing
    their signatures to see how your IDE (or Bark) reacts to the broken interface.
    Come back to the following listing to see how you did.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试创建 `Command` 抽象基类，并从它继承以创建你的命令。在这个过程中，尝试临时重命名 `execute()` 方法或更改它们的签名，看看你的
    IDE（或 Bark）对破坏的接口有何反应。回到以下列表中查看你的结果。
- en: Listing 8.5\. An abstract base class for the command pattern
  id: totrans-775
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.5\. 命令模式的抽象基类
- en: '[PRE60]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '***1* Imports the tools needed from abc**'
  id: totrans-777
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从 abc 导入所需的工具**'
- en: '***2* Defines the Command base class**'
  id: totrans-778
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 定义 Command 基类**'
- en: '***3* Defines execute as an abstract method that accepts a data argument**'
  id: totrans-779
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 定义接受数据参数的抽象方法**'
- en: '***4* Each command inherits from Command.**'
  id: totrans-780
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 每个命令都继承自 Command。**'
- en: '***5* Adds the data argument (None by default, so callers can omit it)**'
  id: totrans-781
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 添加数据参数（默认为 None，因此调用者可以省略它）**'
- en: '***6* Commands that already accept a data argument need only inherit from Command.**'
  id: totrans-782
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 已经接受数据参数的命令只需要继承自 Command。**'
- en: 'Because `execute()` has a consistent signature, you can also simplify a line
    in the bark module where an option triggers a command in the `choose()` method:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `execute()` 具有一致的签名，你也可以简化 bark 模块中的一行，其中选项触发 `choose()` 方法中的命令：
- en: '[PRE61]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '***1* Always passes data to execute**'
  id: totrans-785
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 总是传递数据给 execute**'
- en: Bark should continue to work exactly as it did before. Adding the abstract base
    class here just makes it a little safer when creating future commands. If you
    decide that your commands need to implement additional methods or accept additional
    arguments in the future, you can start by adding them to `Command`, and your IDE
    can help you find the places that need to be updated. It’s a handy way to develop.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: Bark 应该继续像以前一样工作。在这里添加抽象基类只是为了在创建未来的命令时使其更安全。如果你决定你的命令需要在将来实现额外的方法或接受额外的参数，你可以从向
    `Command` 添加它们开始，你的 IDE 可以帮助你找到需要更新的地方。这是一个方便的开发方式。
- en: 8.4.2\. A final check on your inheritance work
  id: totrans-787
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.2\. 对你的继承工作进行最终检查
- en: 'You’ve successfully used inheritance to make your use of composition a bit
    more robust. Check one more time if your code passes Metz’s tests for good use
    of inheritance:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经成功使用继承使你的组合使用更加稳健。再次检查你的代码是否通过了 Metz 对良好继承使用的测试：
- en: '*Commands have a shallow, narrow hierarchy.* Seven command classes wide, each
    one level of hierarchy deep.'
  id: totrans-789
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*命令具有浅层、狭窄的层次结构。* 七个命令类宽，每个类都深入一个层次。'
- en: '*Commands don’t know about other objects.* They do make use of the database
    connection object, but that’s a piece of global state that adheres to a database
    interface.'
  id: totrans-790
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*命令不知道其他对象。*它们确实使用了数据库连接对象，但这是一种遵循数据库接口的全局状态。'
- en: '*Commands use or specialize all of the functionality from their superclass.*
    `Command` is an abstract class with no behavior itself.'
  id: totrans-791
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*命令使用或专门化其超类中的所有功能。* `Command` 是一个没有自身行为的抽象类。'
- en: Excellent. You’re using inheritance where it makes sense and adds value, without
    forcing that structure onto things that don’t need it. This kind of critical examination
    is valuable as you continue to write and refactor code.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。你正在使用继承，它在有道理且增加价值的地方使用，而没有强迫这种结构强加给不需要它的事物。这种批判性的审查在你继续编写和重构代码时非常有价值。
- en: Continue on to the next chapter to learn how to keep classes maintainable by
    keeping them small.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 继续阅读下一章，了解如何通过保持类的小型化来保持类的可维护性。
- en: Summary
  id: totrans-794
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Use inheritance to represent true is-a relationships (good for specialization
    of behavior).
  id: totrans-795
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用继承来表示真正的“是”关系（有利于行为的专业化）。
- en: Use composition for has-a relationships (good for reuse of code).
  id: totrans-796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用组合来表示“有”关系（有利于代码重用）。
- en: Method resolution order is key to keeping multiple inheritance straight.
  id: totrans-797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法解析顺序是保持多重继承直线的关键。
- en: Abstract base classes provide interface-like control and safety in Python.
  id: totrans-798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象基类在 Python 中提供类似接口的控制和安全。
- en: Chapter 9\. Keeping things lightweight
  id: totrans-799
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9章。保持轻量级
- en: '*This chapter covers*'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Using complexity measurements to identify code to refactor
  id: totrans-801
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用复杂性度量来识别需要重构的代码
- en: Python language features for breaking up code
  id: totrans-802
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 语言特性用于分解代码
- en: Using Python language features to support backward compatibility
  id: totrans-803
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Python 语言特性来支持向后兼容性
- en: In your software development, you’ll remain vigilant about separating concerns,
    but you’ll generally wait until a sensible organization presents itself in order
    to avoid creating the wrong abstractions. This means your classes will generally
    grow bit by bit until they become unruly.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的软件开发中，你将保持对分离关注点的警惕，但通常你会等到一个合理的组织结构出现，以避免创建错误的抽象。这意味着你的类将逐渐增长，直到变得难以管理。
- en: This is quite like the art of training a bonsai tree; you need to give the tree
    time to grow, and only after it tells you where it’s headed can you encourage
    it down that path. Trimming the tree too often can stress it, and forcing it into
    an unnatural shape may stunt its ability to thrive.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 这很像培养盆景的艺术；你需要给树时间生长，只有当它告诉你它将走向何方时，你才能鼓励它沿着那条路走。过度修剪树木会使其压力过大，强迫它采取不自然的形状可能会阻碍其茁壮成长的能力。
- en: In this chapter, you’ll learn how to prune your code to keep it healthy and
    thriving.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何修剪你的代码，以保持其健康和繁荣。
- en: 9.1\. How big should my class/function/module be?
  id: totrans-807
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1。我的类/函数/模块应该有多大？
- en: Many an online forum on software maintenance contains questions of this nature.
    I sometimes wonder if we keep asking because we think eventually we can transcend
    to some new plane of understanding, where the answer was obvious all along. Each
    ensuing discussion thread contains a mix of opinions, anecdotes, and occasional
    data points.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 许多关于软件维护的在线论坛都包含这类问题。我有时 wonder 如果我们继续提问是因为我们认为最终我们可以超越到某种新的理解层面，在那里答案一直都很明显。每个后续的讨论线程都包含了一组意见、轶事和偶尔的数据点。
- en: The desire to find a final answer to this question isn’t inherently bad; it’s
    useful to have guidelines and waypoints so you can recognize when you should invest
    time in your code. But it’s also important to understand the strengths and weaknesses
    of the metrics that we use to approach this question.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找这个问题的最终答案的愿望本身并不坏；拥有指导方针和里程碑，以便你能够识别何时应该在代码上投入时间是有用的。但了解我们用来接近这个问题的度量标准的优点和缺点也同样重要。
- en: 9.1.1\. Physical size
  id: totrans-810
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.1。物理大小
- en: 'Some folks attempt to prescribe a line limit for functions, methods, and classes.
    This metric seems nice because it’s readily measurable: “My function is 17 lines
    long.” I take issue with this approach because it can force a developer to break
    up a function that is otherwise perfectly understandable, increasing cognitive
    load.'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人试图为函数、方法和类规定行数限制。这个指标看起来不错，因为它很容易衡量：“我的函数有17行长。”我反对这种做法，因为它可能迫使开发者拆分一个本可以理解得很好的函数，从而增加认知负荷。
- en: 'If you draw a line in the sand at five lines, a six-line function is suddenly
    out of the question. This encourages developers to play “code golf,” trying to
    fit the same amount of logic into fewer lines. Python enables this kind of game
    too:'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你把线划在五行，那么六行的函数就突然变得不可行。这鼓励开发者玩“代码高尔夫”，试图将相同数量的逻辑压缩到更少的行中。Python 也允许这种游戏：
- en: '[PRE62]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Were you able to make sense of that code immediately? It’s not awful, but does
    mashing it into one line add value?
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 你能立即理解那段代码吗？它并不糟糕，但把它压缩成一行真的增加了价值吗？
- en: 'Take a look at a rewritten version, where each clause is given its own line:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下重写的版本，其中每个子句都有自己的行：
- en: '[PRE63]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Breaking things up logically gives someone reading your code a chance to digest
    each clause, forming a mental model of what’s happening as they go.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 合理地分解事物给阅读你代码的人一个机会，去消化每个子句，形成他们在阅读过程中发生的事情的心理模型。
- en: Another form of the line-limit rule I’ve seen is that “a class should fit on
    one screen.” This shares some of the pain points with its stricter version, while
    at the same time being less measurable due to different screen sizes and resolutions.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 我见过的行限制规则的另一种形式是“一个类应该适应一个屏幕”。这与它的严格版本共享一些痛点，同时由于屏幕尺寸和分辨率的差异，它也变得不那么可衡量。
- en: The spirit of these metrics is to “keep it simple,” with which I agree. But
    there are other ways to define “simple.”
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指标的精神是“保持简单”，我同意这一点。但还有其他定义“简单”的方法。
- en: 9.1.2\. Single responsibility
  id: totrans-820
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.2\. 单一职责
- en: A more open-ended measurement of the size of a class, method, or function is
    how many different things it does. As you’ve learned from separation of concerns,
    the ideal number is one. For functions and methods, this means performing a single
    calculation or task. For classes, it means dealing with a single, focused facet
    of some larger business problem.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 对类、方法或函数的大小的一个更开放式的度量是它做了多少不同的事情。正如你从关注点的分离中学到的，理想数字是1。对于函数和方法，这意味着执行一个计算或任务。对于类，这意味着处理某个更大的业务问题的单一、专注的方面。
- en: If you spot a function performing two tasks or a class that contains two distinct
    areas of focus, that’s a strong signal of an opportunity to separate them. But
    there may be times when what feels like a single task is still complex enough
    to warrant breaking down further.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现一个函数执行两个任务或一个包含两个不同关注领域的类，那么这是一个强烈的信号，表明有分离它们的机遇。但有时，看似单一的任务可能仍然足够复杂，需要进一步分解。
- en: 9.1.3\. Code complexity
  id: totrans-823
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.3\. 代码复杂性
- en: One of the more robust ways of understanding the cognitive and maintenance impact
    of code is through its *complexity*. Like time and space complexity, code complexity
    is a quantitative measurement of the characteristics of your code, not just a
    subjective measure of how confused you get by reading it.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 理解代码的认知和维护影响的一种更稳健的方法是通过其*复杂性*。就像时间和空间复杂度一样，代码复杂性是对你代码特性的定量测量，而不仅仅是阅读时感到困惑的主观度量。
- en: Complexity measurement tools are a great thing to have in your tool belt. I
    find that they often accurately point out code I would have trouble reading and
    understanding as a human. In the next few sections, I’ll show you what code complexity
    looks like, along with some tools for measuring it.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂度测量工具是你工具箱中的一大法宝。我发现它们通常能准确地指出我作为人类可能会觉得难以阅读和理解的部分代码。在接下来的几节中，我将向你展示代码复杂性的样子，以及一些测量它的工具。
- en: MEASURING CODE COMPLEXITY
  id: totrans-826
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 测量代码复杂性
- en: A common measure of complexity is *cyclomatic* complexity. Although the name
    sounds scarily scientific, measuring cyclomatic complexity involves determining
    the number of execution paths through a function or method. The structure (and
    therefore, complexity) of a function is affected by the number of conditional
    expressions and loops it contains.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂性的一个常见度量是*循环复杂度*。尽管这个名字听起来令人恐惧地科学，但测量循环复杂度涉及到确定通过函数或方法执行的执行路径数量。函数的结构（因此，复杂性）受到其中包含的条件表达式和循环数量的影响。
- en: The higher the complexity score is for a function or method, the more conditionals
    and loops you should expect it to contain. The specific score isn’t always terribly
    useful; its trend over time, and how it changes in response to alterations you
    make in the code, is what will help you write more maintainable software. Seek
    to drive your complexity scores down over time, and consider pieces of code with
    high complexity when determining where to invest refactoring time.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 函数或方法的复杂度得分越高，你应该期望它包含的条件和循环越多。具体的得分并不总是非常有用；其随时间的变化以及它对代码中你做出的更改的反应，将帮助你编写更易于维护的软件。努力在一段时间内降低你的复杂度得分，并在确定在哪里投入重构时间时考虑复杂度高的代码片段。
- en: 'You can measure the complexity of a function yourself. By creating a graph
    of the *control flow*, or the path the code takes as it executes, you can count
    the number of nodes and edges in the graph and calculate the cyclomatic complexity.
    The following are represented as nodes in the control flow graph of a program:'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自己测量函数的复杂度。通过创建 *控制流* 的图，即代码执行时采取的路径，你可以计算图中节点和边的数量，并计算圈复杂度。以下是在程序的控制流图中表示为节点的：
- en: The “start” of the function (where the control flow enters)
  id: totrans-830
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的“开始”部分（控制流进入的地方）
- en: '`if`/`elif`/`else` conditions (each one is its own node)'
  id: totrans-831
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if`/`elif`/`else` 条件（每个都是独立的节点）'
- en: '`for` loops'
  id: totrans-832
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for` 循环'
- en: '`while` loops'
  id: totrans-833
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while` 循环'
- en: The “end” of a loop (where you draw the execution path back to the start of
    the loop)
  id: totrans-834
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环的“结束”部分（将执行路径绘制回循环的开始）
- en: '`return` statements'
  id: totrans-835
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return` 语句'
- en: Consider the function in the following listing, which accepts a sentence as
    either a string or a list of words and determines whether the sentence has any
    long words in it. It contains a loop and multiple conditional expressions.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下列表中的函数，它接受一个句子作为字符串或单词列表，并确定句子中是否有任何长单词。它包含一个循环和多个条件表达式。
- en: Listing 9.1\. A function with conditionals and a loop
  id: totrans-837
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.1\. 包含条件和循环的函数
- en: '[PRE64]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '***1* Splits words in sentence if it’s a string (conditional)**'
  id: totrans-839
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 如果是字符串，则在句子中拆分单词（条件）**'
- en: '***2* Does work for each word (loop)**'
  id: totrans-840
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 对每个单词（循环）执行工作**'
- en: '***3* Returns True if a long word is found (conditional)**'
  id: totrans-841
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果找到长单词，则返回 True（条件）**'
- en: '***4* Returns False if no words were long**'
  id: totrans-842
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 如果没有长单词，则返回 False**'
- en: The edges are arrows that follow the different execution paths your code can
    take. Cyclomatic complexity, *M*, for a function or method is equal to the number
    of edges minus the number of nodes, plus two. You can add nodes and edges for
    the lines of code that aren’t inside a conditional block or a loop if it helps
    you diagram a function, but they won’t affect the overall complexity—they each
    add one node and one edge, which cancel out in the math.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 边是遵循代码可以采取的不同执行路径的箭头。函数或方法的圈复杂度，*M*，等于边的数量减去节点的数量，再加上 2。如果你通过绘制函数来帮助，可以为不在条件块或循环内的代码行添加节点和边，但它们不会影响整体复杂度——每个都添加一个节点和一个边，在数学上相互抵消。
- en: The `has_long_words` function has one conditional to check if the input is a
    string, a loop for each word in the sentence, and a conditional inside the loop
    to check if a word is long. Its diagram is shown in [figure 9.1](#ch09fig01).
    By diagramming the control flow and simplifying the graph as plain nodes and edges,
    you can count them up and plug the results into the cyclomatic complexity equation.
    In this case, the graph of `has_long_words` has 8 nodes with 10 edges, so its
    complexity is *M* = *E* - *N* + 2 = 10 - 8 + 2 = 4.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: '`has_long_words` 函数有一个条件来检查输入是否为字符串，一个循环来遍历句子中的每个单词，以及循环内的一个条件来检查单词是否长。其图示显示在[图
    9.1](#ch09fig01)中。通过绘制控制流并简化图形为普通节点和边，你可以数出它们并把这些结果代入圈复杂度方程。在这种情况下，`has_long_words`
    的图有 8 个节点和 10 条边，所以其复杂度是 *M* = *E* - *N* + 2 = 10 - 8 + 2 = 4。'
- en: Figure 9.1\. Diagramming control flow to measure cyclomatic complexity
  id: totrans-845
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.1\. 绘制控制流以测量圈复杂度
- en: '![](../Images/f0190-01_alt.jpg)'
  id: totrans-846
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0190-01_alt.jpg)'
- en: Most sources recommend shooting for a complexity of 10 or lower for a given
    function or method. This corresponds roughly to how much developers can reasonably
    understand at once.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数资料建议，对于给定的函数或方法，应追求 10 或以下的复杂度。这大致相当于开发者一次可以合理理解的内容量。
- en: In addition to helping you understand the health of your code, cyclomatic complexity
    is useful in testing. Recall that cyclomatic complexity measures the number of
    execution paths a function or method has. Consequently, this is also the minimum
    number of distinct test cases you would need to write to cover each execution
    path. This follows from the fact that each `if`, `while`, and so on requires you
    to prepare a different set of preconditions to test what happens in one case or
    the other.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 除了帮助您了解代码的健康状况外，循环复杂度在测试中也非常有用。回想一下，循环复杂度衡量一个函数或方法有多少执行路径。因此，这也是您需要编写的最小不同测试用例数，以覆盖每个执行路径。这源于每个`if`、`while`等都需要您准备不同的预条件集来测试一个或另一个情况会发生什么。
- en: Remember that perfect test coverage doesn’t guarantee that your code actually
    works; it only means your tests caused that part of the code to run. But making
    sure you cover the execution paths of interest is usually a good idea. Untested
    branches of execution are usually what people are referring to when they talk
    about “edge cases,” a term with negative connotations that usually means “a thing
    we didn’t think of.” The excellent Coverage package by Ned Batchelder ([https://coverage.readthedocs.io](https://coverage.readthedocs.io))
    can print branch coverage metrics for your tests.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，完美的测试覆盖率并不能保证您的代码实际上能工作；它只意味着您的测试导致该部分代码运行。但确保您覆盖了感兴趣的执行路径通常是好主意。未测试的执行分支通常是人们谈论“边缘情况”时所指的，这个术语有负面含义，通常意味着“我们没有想到的事情。”Ned
    Batchelder的出色Coverage包([https://coverage.readthedocs.io](https://coverage.readthedocs.io))可以为您的测试打印分支覆盖率指标。
- en: '|  |'
  id: totrans-850
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Halstead complexity**'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: '**Halstead复杂性**'
- en: For some applications, reducing the risk of shipping defective software is as
    big a priority as maintainability. Although reducing branches in your code tends
    to make it more readable and understandable, it hasn’t been proven to reduce the
    number of bugs in software. Cyclomatic complexity predicts the number of defects
    about as well as the number of lines of code does. But there’s at least one set
    of metrics out there that tries to address the defect rate.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些应用程序，降低发布有缺陷软件的风险与可维护性一样重要。尽管减少代码中的分支往往会使代码更易于阅读和理解，但这还没有被证明可以减少软件中的错误数量。循环复杂度预测缺陷的数量与代码行数一样好。但至少有一套度量标准试图解决缺陷率问题。
- en: 'Halstead complexity attempts to measure quantitatively the ideas of level of
    abstraction, maintainability, and defect rate. Measuring Halstead complexity involves
    inspecting a program’s use of the programming language’s built-in operators and
    how many variables and expressions it contains. It’s beyond the scope of this
    book, but I recommend reading more about it. (The Wikipedia article is a good
    place to start: [https://en.wikipedia.org/wiki/Halstead_complexity_measures](https://en.wikipedia.org/wiki/Halstead_complexity_measures).)
    Radon ([https://radon.readthedocs.io](https://radon.readthedocs.io)) can measure
    the Halstead complexity of your Python programs if you’re interested in exploring.'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: Halstead复杂性试图定量地衡量抽象级别、可维护性和缺陷率等概念。衡量Halstead复杂性涉及检查程序对编程语言内置运算符的使用以及它包含多少变量和表达式。这超出了本书的范围，但我建议您阅读更多关于它的内容。（可以从维基百科文章开始：[https://en.wikipedia.org/wiki/Halstead_complexity_measures](https://en.wikipedia.org/wiki/Halstead_complexity_measures)。）如果您对探索感兴趣，Radon
    ([https://radon.readthedocs.io](https://radon.readthedocs.io)) 可以测量您Python程序的Halstead复杂性。
- en: '|  |'
  id: totrans-854
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Recall the code you wrote to import GitHub stars in Bark (reproduced in the
    following listing). Try to diagram the control flow and calculate the cyclomatic
    complexity.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下您在Bark中编写的导入GitHub星标的代码（在下述列表中重现）。尝试绘制控制流并计算循环复杂度。
- en: Listing 9.2\. The code for importing GitHub stars in Bark
  id: totrans-856
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.2. 在Bark中导入GitHub星标的代码
- en: '[PRE65]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '***1* A loop that code further down will come back to**'
  id: totrans-858
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 另一个循环，代码将回到这里**'
- en: '***2* Another loop that code further down will come back to**'
  id: totrans-859
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 另一个循环，代码将回到这里**'
- en: '***3* One branch of execution**'
  id: totrans-860
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 执行的一个分支**'
- en: '***4* Another branch of execution**'
  id: totrans-861
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 另一个执行分支**'
- en: '***5* The point that returns to the for, or, if complete, to the while**'
  id: totrans-862
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 返回for循环或，如果完成，返回while循环的点**'
- en: When you’re done, come back and check your work against the solution in [figure
    9.2](#ch09fig02).
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 当您完成时，回来检查您的工作与[图9.2](#ch09fig02)中的解决方案是否一致。
- en: Figure 9.2\. The cyclomatic complexity of a function from the Bark application
  id: totrans-864
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.2. Bark应用程序中函数的循环复杂度
- en: '![](../Images/f0193-01_alt.jpg)'
  id: totrans-865
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/f0193-01_alt.jpg)'
- en: Fortunately, you won’t need to diagram each function and method you write. A
    number of tools out there, like SonarQube ([www.sonarqube.org](http://www.sonarqube.org))
    and Radon ([https://radon.readthedocs.io](https://radon.readthedocs.io)), can
    measure these for you. These tools can even be integrated into your code editors
    so that you can break up complex code as you develop.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你不需要为每个编写的函数和方法绘制图表。市面上有许多工具，如SonarQube ([www.sonarqube.org](http://www.sonarqube.org))
    和Radon ([https://radon.readthedocs.io](https://radon.readthedocs.io))，可以为你测量这些指标。这些工具甚至可以集成到你的代码编辑器中，这样你可以在开发过程中将复杂的代码拆分。
- en: Now that you’ve learned some of the ways to discover when code has grown complex,
    you can get some practice breaking down that complexity.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了一些发现代码变得复杂的方法，你可以练习分解这种复杂性。
- en: 9.2\. Breaking down complexity
  id: totrans-868
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2. 分解复杂性
- en: 'I have some mildly bad news: recognizing that code is complex is the easy part.
    The next challenge is understanding how to deal with specific kinds of complexity.
    Throughout the rest of this chapter, I’ll point out some common patterns of complexity
    I’ve seen during my travels with Python, and I’ll show you the options you have
    for tackling them.'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一些不太好的消息：认识到代码是复杂的是容易的部分。下一个挑战是理解如何处理特定类型的复杂性。在本章的其余部分，我会指出我在与Python旅行的过程中看到的一些常见的复杂性模式，并展示你可以用来解决这些问题的选项。
- en: 9.2.1\. Extracting configuration
  id: totrans-870
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.1. 提取配置
- en: 'I’ll start with an example you’ve already seen in this book: as your software
    grows, certain areas of the code need to continue adapting to new requirements.'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 我将以这本书中你已经见过的例子开始：随着你的软件增长，代码的某些区域需要继续适应新的需求。
- en: 'Imagine you’re building a web service that indecisive users can query to see
    what they should eat for lunch. If a user goes to your service’s `/random` endpoint,
    they should get a random food, like `pizza`, in return. Your initial handler function
    accepts the user’s request as an argument, and it might look something like this:'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你正在构建一个网络服务，犹豫不决的用户可以查询以了解他们午餐应该吃什么。如果用户访问你的服务的`/random`端点，他们应该得到一个随机的食物，比如`pizza`。你的初始处理函数将用户请求作为参数接受，它可能看起来像这样：
- en: '[PRE66]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '***1* A list of foods (This could go in a database eventually.)**'
  id: totrans-874
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 食物列表（这最终可能放入数据库中。）**'
- en: '***2* The function accepts the user’s HTTP request (unused currently).**'
  id: totrans-875
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 函数接受用户的HTTP请求（目前未使用）。**'
- en: '***3* Returns a random food from the list, as a string**'
  id: totrans-876
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 从列表中随机返回一个食物，作为一个字符串**'
- en: 'When your service gets popular (people are *all* indecisive), some users want
    to build a full-fledged app around it. They tell you they want to get the response
    from you in JSON format because it’s easy to work with. You don’t want to change
    the default behavior for the rest of your users, so you tell them you’ll return
    a JSON response if they send an `Accept: application/json` header in their request.
    (Don’t worry much about how HTTP headers work if you’re not already familiar with
    them; assume that `request.headers` is a dictionary of header names to header
    values.) You could update your function to account for this:'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: '当你的服务变得流行（人们都犹豫不决）时，一些用户想要围绕它构建一个完整的应用程序。他们告诉你他们想要以JSON格式从你那里得到响应，因为它很容易处理。你不想改变其他用户的默认行为，所以你告诉他们，如果他们在请求中发送`Accept:
    application/json`头，你将返回JSON响应。（如果你不熟悉HTTP头，不必太担心它们的工作方式；假设`request.headers`是一个包含头名称到头值的字典。）你可以更新你的函数来处理这种情况：'
- en: '[PRE67]'
  id: totrans-878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '***1* Chooses the food at random and stores it for use momentarily**'
  id: totrans-879
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 随机选择食物并暂时存储它**'
- en: '***2* Returns {"food": "pizza"}, for example, if the request has the Accept:
    application/json header**'
  id: totrans-880
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 如果请求有`Accept: application/json`头，则返回`{"food": "pizza"}`，例如**'
- en: '***3* Continues returning “pizza”, for example, by default**'
  id: totrans-881
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 默认情况下继续返回“pizza”，例如**'
- en: Think about this change in terms of cyclomatic complexity; what is the complexity
    before and after the change?
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 从循环复杂性的角度考虑这个变化；变化前后复杂性是什么？
- en: 1 before, 2 after
  id: totrans-883
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1之前，2之后
- en: 2 before, 2 after
  id: totrans-884
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2之前，2之后
- en: 1 before, 3 after
  id: totrans-885
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1之前，3之后
- en: 2 before, 1 after
  id: totrans-886
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2之前，1之后
- en: Your initial function had no conditionals or loops, so the complexity was 1\.
    Because you’ve added only one new condition (the case when the user requests JSON),
    the complexity has gone from 1 to 2 (option 1).
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 你的初始函数没有条件语句或循环，因此复杂性为1。因为你只添加了一个新的条件（用户请求JSON的情况），复杂性从1增加到2（选项1）。
- en: 'An increase of complexity by 1 to handle a new requirement isn’t terrible to
    start with. But if you continue on that trajectory for long, increasing complexity
    linearly with each requirement, you’ll soon be dealing with hairy code:'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理新的要求，将复杂度增加 1 并不是什么坏事。但如果你继续沿着这个轨迹前进，随着每个要求的增加线性增加复杂度，你很快就会遇到棘手的代码：
- en: '[PRE68]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '***1* Each additional requirement is a new condition, increasing complexity.**'
  id: totrans-890
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 每个额外的要求都是一个新条件，增加了复杂性。**'
- en: Do you remember how to solve this? As a hint, observe that the conditionals
    are mapping a value (the value of the `Accept` header) to another value (the response
    to return). What data structure makes sense?
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得如何解决这个问题吗？作为一个提示，观察到条件语句正在将一个值（`Accept` 头部的值）映射到另一个值（要返回的响应）。哪种数据结构是有意义的？
- en: '`list`'
  id: totrans-892
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`列表`'
- en: '`tuple`'
  id: totrans-893
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`元组`'
- en: '`dict`'
  id: totrans-894
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`字典`'
- en: '`set`'
  id: totrans-895
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`集合`'
- en: A Python dictionary (option 3) maps values to other values, so it’s a good fit
    for refactoring this code. Remodeling the execution flow as a configuration of
    header values to response formats, and then choosing the right one based on the
    user’s request, will simplify things.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: Python 字典（选项 3）将值映射到其他值，因此它非常适合重构此代码。将执行流程重构为头部值到响应格式的配置，然后根据用户的请求选择正确的格式，将简化问题。
- en: Try extracting the different header values and response types into a dictionary,
    using the default behavior as the fallback if the user doesn’t request a response
    format (or requests an unknown format). Check your work against the following
    listing when you’re done.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将不同的头部值和响应类型提取到一个字典中，如果用户没有请求响应格式（或请求了未知格式），则使用默认行为作为后备。完成工作后，请对照以下列表检查你的工作。
- en: Listing 9.3\. An endpoint with extracted configuration
  id: totrans-898
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.3\. 提取配置的端点
- en: '[PRE69]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '***1* Extracted from the previous if/elif conditions**'
  id: totrans-900
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从之前的 if/elif 条件中提取**'
- en: '***2* Gets the requested response format if available; otherwise, falls back
    to returning the plain string**'
  id: totrans-901
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 如果有请求的响应格式，则获取该格式；否则，回退到返回纯字符串**'
- en: Believe it or not, this new solution is reduced back to a cyclomatic complexity
    of 1\. And even if you continue adding entries to the `formats` dictionary, no
    additional complexity is added. This is the kind of gain I talked about in [chapter
    4](../Text/kindle_split_014.html#ch04); you’ve gone from a linear algorithm to
    a constant one.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，这个新解决方案又回到了 1 的圈复杂度。即使你继续向 `formats` 字典中添加条目，也不会增加额外的复杂度。这正是我在第 4 章中提到的那种收益；你已经从线性算法转变为常数算法。
- en: Extracting configuration into a map also makes code much more readable, in my
    experience. Trying to sift through a number of `if`/`elif` conditions is tiresome,
    even when they’re all fairly similar. In contrast, a dictionary’s keys are generally
    scannable. If you know the key you’re looking for, it’s quick to spot.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 将配置提取到映射中，据我所知，也使得代码的阅读性大大提高。试图筛选多个 `if`/`elif` 条件是令人疲惫的，即使它们都相当相似。相比之下，字典的键通常是可扫描的。如果你知道你要找的键，那么快速找到它是很容易的。
- en: Can we do even better?
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能做得更好吗？
- en: 9.2.2\. Extracting functions
  id: totrans-905
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.2\. 提取函数
- en: 'With the growing cyclomatic complexity defeated, two other things are still
    growing in tandem within the `random_food` function:'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决日益增长的圈复杂度问题后，`random_food` 函数中还有两件事在同步增长：
- en: The code that knows *what* to do (format the response as JSON, XML, and so on)
  id: totrans-907
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道要做什么的代码（将响应格式化为 JSON、XML 等等）
- en: The code that knows *how to decide* what to do (based on the `Accept` header
    values)
  id: totrans-908
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道如何决定要做什么的代码（基于 `Accept` 头部值）
- en: This is an opportunity to separate concerns. As I’ve advocated a few times in
    this book, extracting some functions here could be helpful. If you look at each
    item in the `formats` dictionary, you’ll notice that the value is a function of
    the `food` variable. Each of these values could be a function that accepts a `food`
    argument and returns the formatted response that will go back to the user, as
    shown in [figure 9.3](#ch09fig03).
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个分离关注点的机会。正如我在本书中多次提倡的那样，在这里提取一些函数可能会有所帮助。如果你查看 `formats` 字典中的每个条目，你会注意到值是
    `food` 变量的函数。这些值中的每一个都可以是一个接受 `food` 参数并返回将返回给用户的格式化响应的函数，如图 9.3 所示。[图 9.3](#ch09fig03)。
- en: Figure 9.3\. Extracting inline expressions as functions
  id: totrans-910
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.3\. 将内联表达式提取为函数
- en: '![](../Images/f0196-01_alt.jpg)'
  id: totrans-911
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0196-01_alt.jpg)'
- en: Try changing your `random_food` function to use these separated response-format
    functions. The dictionary will now map formats to the function that can return
    the response for that format, and `random_food` will call that function with the
    `food` value. If no function is available after calling `formats.get(…``)`, you
    should fall back to a function that returns the `food` value unchanged; this can
    be done using a lambda. Check the following listing when you’re done.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将你的`random_food`函数更改为使用这些分离的响应格式函数。现在字典将格式映射到可以返回该格式响应的函数，而`random_food`将使用`food`值调用该函数。如果在调用`formats.get(…``)`之后没有可用的函数，你应该回退到一个返回未更改`food`值的函数；这可以使用lambda来完成。完成后请检查以下列表。
- en: Listing 9.4\. A service endpoint with response-formatting functions
  id: totrans-913
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.4\. 带有响应格式化函数的服务端点
- en: '[PRE70]'
  id: totrans-914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '***1* The extracted formatting functions**'
  id: totrans-915
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 提取了格式化函数**'
- en: '***2* Maps data formats to their respective formatting functions now**'
  id: totrans-916
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 现在将数据格式映射到相应的格式化函数**'
- en: '***3* Gets the appropriate formatting function if available**'
  id: totrans-917
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果有，获取适当的格式化函数**'
- en: '***4* Uses a lambda as the fallback to return the unchanged food value**'
  id: totrans-918
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用lambda作为后备来返回未更改的食物值**'
- en: '***5* Calls the formatting function and returns its response**'
  id: totrans-919
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 调用格式化函数并返回其响应**'
- en: To fully separate the concerns, you can now extract `formats` and the business
    of getting the right function from it into its own function, `get_format_function`.
    This function accepts the user’s `Accept` header value and returns the right formatting
    function. Try that out now and refer to the following listing when you’re done
    to check your work.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全分离关注点，你现在可以将`formats`和从其中获取正确函数的业务提取到它自己的函数中，即`get_format_function`。这个函数接受用户的`Accept`头值并返回正确的格式化函数。现在尝试一下，完成后参考以下列表来检查你的工作。
- en: Listing 9.5\. Separating concerns into two functions
  id: totrans-921
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.5\. 将关注点分离到两个函数中
- en: '[PRE71]'
  id: totrans-922
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '***1* Determines which formatting function to use**'
  id: totrans-923
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 确定要使用哪个格式化函数**'
- en: '***2* random_food is three short steps now.**'
  id: totrans-924
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 现在随机食物只需要三个简短的步骤。**'
- en: '***3* Previously mixed concerns are abstracted to function calls now.**'
  id: totrans-925
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 之前混合的关注点现在被抽象为函数调用。**'
- en: 'You may be thinking this code is more complex; you now have four functions
    compared to your initial one. But you’ve achieved something here: each of these
    functions has a cyclomatic complexity of 1, is quite readable, and has a nice
    separation of concerns.'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为这段代码更复杂；现在你有四个函数，而最初只有一个。但你在这里实现了某些东西：这些函数的循环复杂度都是1，可读性很好，并且关注点得到了很好的分离。
- en: 'You’ve also got something *extensible* on your hands, because when you need
    to handle new response formats, the process is as follows:'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 你还掌握了一些*可扩展*的技巧，因为当你需要处理新的响应格式时，过程如下：
- en: Add a new function to format the response as desired.
  id: totrans-928
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新函数来按需格式化响应。
- en: Add the mapping of the required `Accept` header value to the new formatting
    function.
  id: totrans-929
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所需的`Accept`头值映射到新的格式化函数。
- en: Profit.
  id: totrans-930
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利润。
- en: You can create new business value just by adding new code and updating configuration.
    This is the ideal.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需添加新的代码和更新配置，就能创造新的商业价值。这是理想状态。
- en: Now that you know some tricks for functions, I want to show you a few for classes.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了一些关于函数的技巧，我想向你展示一些关于类的技巧。
- en: 9.3\. Decomposing classes
  id: totrans-933
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3\. 分解类
- en: Classes can grow unruly like functions, and perhaps at a faster rate. But it
    feels somehow more scary to break down a class than it does a function. Functions
    feel like building blocks, but classes feel like completed products. This is a
    mental barrier I often struggle to suppress.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 类可能会像函数一样变得难以管理，而且增长速度可能更快。但分解一个类似乎比分解一个函数更让人感到恐惧。函数感觉像是构建块，而类则感觉像是成品。这是我经常努力克服的心理障碍。
- en: You should have the confidence to decompose classes as frequently as functions.
    Classes are just another tool at your disposal. When you find that a class starts
    growing in complexity, it’s usually due to a mixing of concerns. Once you identify
    a concern that feels like its own object, you’ve got enough to start breaking
    it down.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该有信心像分解函数一样频繁地分解类。类只是你手中的另一个工具。当你发现一个类开始变得复杂时，通常是因为关注点的混合。一旦你确定了一个感觉像它自己的对象的关注点，你就有了开始分解它的足够内容。
- en: 9.3.1\. Initialization complexity
  id: totrans-936
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.1\. 初始化复杂性
- en: I often see classes that have complex initialization procedures. For better
    or worse, these classes are usually complex because they deal with complex data
    structures. Have you ever seen a class like the following?
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常看到具有复杂初始化过程的类。不管好坏，这些类通常很复杂，因为它们处理复杂的数据结构。你有没有见过如下所示的类？
- en: Listing 9.6\. A class with complex domain logic in its construction
  id: totrans-938
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.6\. 构造中具有复杂领域逻辑的类
- en: '[PRE72]'
  id: totrans-939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '***1* Extracts some fields from the passed-in data**'
  id: totrans-940
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从传入的数据中提取了一些字段**'
- en: '***2* Complexity arising from the domain logic of your business**'
  id: totrans-941
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 来自业务领域逻辑的复杂性**'
- en: When the domain logic you’re dealing with is complex, your code is more likely
    to reflect that. In these cases, it’s more important than ever for developers
    to rely on useful abstractions to make sense of it all.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理的领域逻辑很复杂时，你的代码更有可能反映出这一点。在这些情况下，开发者依赖有用的抽象来理解所有内容比以往任何时候都更重要。
- en: I’ve talked about extracting functions and methods as a useful way to break
    down code. One approach you could take here is to extract the logic for `display_title`
    into a `set_display_title` method that you could call from the `__init__` method,
    as shown in the following listing. Try creating a book module and adding the `Book`
    class to it, extracting a setter method for `display_title`.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经讨论过将函数和方法提取出来作为分解代码的有用方式。你可以采取的一种方法是将 `display_title` 的逻辑提取到一个 `set_display_title`
    方法中，这样你就可以从 `__init__` 方法中调用它，如下面的列表所示。尝试创建一个 `book` 模块，并将 `Book` 类添加到其中，提取 `display_title`
    的设置方法。
- en: Listing 9.7\. Using a setter to simplify class construction
  id: totrans-944
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.7\. 使用设置器简化类构造
- en: '[PRE73]'
  id: totrans-945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '***1* Calls the extracted function**'
  id: totrans-946
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 调用提取的函数**'
- en: '***2* Extracted function sets display_title.**'
  id: totrans-947
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 提取了设置 `display_title` 的函数集。**'
- en: 'This has cleaned up the `__init__` method, but a couple of issues arise from
    this approach:'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经清理了 `__init__` 方法，但这种方法引发了一些问题：
- en: Getters and setters are generally discouraged in Python because they can clutter
    up a class.
  id: totrans-949
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Python 中，通常不建议使用获取器和设置器，因为它们可能会使类变得杂乱。
- en: It’s good practice to set all necessary attributes to some initial value directly
    inside `__init__`, but `display_title` is set in a different method.
  id: totrans-950
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `__init__` 方法中直接将所有必要的属性设置为某个初始值是一种良好的实践，但 `display_title` 是在另一种方法中设置的。
- en: You could fix the latter by setting `display_title` to `'Untitled'` by default,
    but this can be misleading. A reader might conclude the display title is typically
    (or even *always*) `'Untitled'`, if they don’t read carefully.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将 `display_title` 设置为 `'Untitled'` 默认值来修复后者，但这可能会产生误导。如果读者没有仔细阅读，他们可能会得出结论，显示标题通常是（甚至总是）`'Untitled'`。
- en: There is one approach that can give you the readability benefit of extracting
    a method, without suffering these drawbacks. It involves creating a function that
    returns the value for `display_title`.
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种方法可以让你在不遭受这些缺点的情况下获得提取方法的可读性好处。这涉及到创建一个返回 `display_title` 值的函数。
- en: 'But wait! If you think about how you use `Book`, it might be something like
    this:'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等！如果你考虑一下你是如何使用 `Book` 的，它可能看起来像这样：
- en: '[PRE74]'
  id: totrans-954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: How can you make the `display_title` logic a function without having to update
    the second line to return `book.display_title()` instead? Fortunately, Python
    provides a tool for this occasion. The `@property` decorator can be used to signify
    that a method on a class should be accessible as an attribute.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何将 `display_title` 的逻辑变成一个函数，而无需更新第二行以返回 `book.display_title()`？幸运的是，Python
    提供了一个工具来处理这种情况。`@property` 装饰器可以用来表示类上的方法应该作为属性可访问。
- en: Create a `display_title` *method* now, decorated with `@property`, that uses
    the existing logic to return the proper display title. Compare your changes with
    the following listing when you’re done.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个 `display_title` *方法*，并用 `@property` 装饰器装饰，使用现有的逻辑来返回正确的显示标题。完成更改后，将你的更改与以下列表进行比较。
- en: '|  |'
  id: totrans-957
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-958
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Methods can be used as properties only if `self` is their only argument, because
    when you access the attribute, you can’t pass any arguments to it.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当 `self` 是它们的唯一参数时，方法才能用作属性，因为当你访问属性时，你不能向它传递任何参数。
- en: '|  |'
  id: totrans-960
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 9.8\. Using `@property` to simplify class construction
  id: totrans-961
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.8\. 使用 `@property` 简化类构造
- en: '[PRE75]'
  id: totrans-962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '***1* A property is a function that can be referenced as an attribute.**'
  id: totrans-963
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 属性是一个可以作为属性引用的函数。**'
- en: Using `@property`, you can still reference `book.display_title` as an attribute,
    but all its complexity is abstracted into its own function. This reduces the complexity
    of the `__init__` method, making it more readable at the same time. I make frequent
    use of `@property` in my own code.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `@property`，你仍然可以将 `book.display_title` 作为属性引用，但所有复杂性都抽象到了它自己的函数中。这减少了 `__init__`
    方法的复杂性，同时也使其更易于阅读。我在自己的代码中经常使用 `@property`。
- en: '|  |'
  id: totrans-965
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-966
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Because properties are methods, repeatedly accessing them means that the methods
    are called each time. This is often okay, but it can have performance impacts
    for properties that are expensive to calculate.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 因为属性是方法，反复访问它们意味着每次都会调用这些方法。这通常是可以接受的，但对于计算成本较高的属性，可能会对性能产生影响。
- en: '|  |'
  id: totrans-968
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: What should you do when there’s enough functionality to abstract a whole *class*
    worth of methods?
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 当有足够的功能可以抽象出一个整个 *类* 值得的方法时，你应该做什么？
- en: 9.3.2\. Extracting classes and forwarding calls
  id: totrans-970
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.2\. 提取类和转发调用
- en: When you extracted `get_format_function` from `random_food` in [section 9.2.2](#ch09lev2sec5),
    you still *called* the extracted function from its original location. When dealing
    with classes, something similar will need to happen if you want to maintain *backward
    compatibility*. Backward compatibility is the practice of evolving your software
    without breaking the implementation consumers previously relied on. If you change
    the arguments of a function, the name of a class, and so on, consumers will need
    to update their code if they want it to continue working. To avoid these problems,
    you could take a hint from the post office’s mail forwarding system.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 [第 9.2.2 节](#ch09lev2sec5) 中从 `random_food` 中提取 `get_format_function` 时，你仍然
    *调用* 从其原始位置提取的函数。当处理类时，如果你想保持 *向后兼容性*，则需要发生类似的事情。向后兼容性是指在不会破坏之前依赖的实现消费者的前提下，使你的软件不断进化的实践。如果你更改函数的参数、类的名称等，消费者需要更新他们的代码，以便继续工作。为了避免这些问题，你可以从邮局的邮件转发系统中得到一些启示。
- en: When you move to a new address, you can tell the post office to forward your
    mail ([figure 9.4](#ch09fig04)). People who send you mail at your old address
    don’t need to know your new address immediately because the post office will intercept
    the mail and direct it to you automatically. Each time you receive a piece of
    mail addressed to your old residence, you can notify the sender of your new address
    so they can update their records. Once you’re confident you aren’t receiving mail
    made out to the old address any longer, you can stop the post office forwarding.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 当你搬迁到新地址时，你可以告诉邮局转发你的邮件（[图 9.4](#ch09fig04)）。那些给你旧地址发邮件的人不需要立即知道你的新地址，因为邮局会拦截邮件并将其自动转寄给你。每次你收到寄往你旧住址的邮件时，你都可以通知发件人你的新地址，以便他们更新记录。一旦你确信你不再收到寄往旧地址的邮件，你就可以停止邮局转发。
- en: Figure 9.4\. Mail can be forwarded by the post office when you move to a new
    location.
  id: totrans-973
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.4\. 当你搬迁到新地点时，邮局可以转发邮件。
- en: '![](../Images/f0201-01_alt.jpg)'
  id: totrans-974
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0201-01_alt.jpg)'
- en: When you extract one class from another, you’ll want to continue providing the
    previously existing functionality for a while, despite changing things under the
    hood, so that consumers don’t need to immediately worry about upgrading their
    software. As with your mail, you can continue accepting calls in one class and
    pass them along to another class under the hood. This is known as *forwarding*.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从一个类中提取一个类时，你希望继续提供之前存在的功能一段时间，尽管在底层进行更改，这样消费者就不需要立即担心升级他们的软件。就像你的邮件一样，你可以继续在一个类中接受调用，并在底层将它们传递给另一个类。这被称为
    *转发*。
- en: Suppose your `Book` class has grown to keep track of the author information.
    This feels natural at the start; what is a book without its author? But as the
    class takes on more functionality, the author starts to feel like a separate concern.
    As shown in the following listing, methods soon exist for the author’s name as
    it should be displayed on a website, as well as how it should be displayed in
    a research paper citation.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的 `Book` 类已经增长到需要跟踪作者信息。一开始这感觉是自然的；一本书没有作者是什么？但随着类承担更多功能，作者开始感觉像是一个独立的问题。如下所示，很快就会存在用于作者姓名的方法，这些姓名应该显示在网站上，以及它们应该如何显示在研究论文的引用中。
- en: Listing 9.9\. A `Book` class too concerned with author details
  id: totrans-977
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.9\. 过于关注作者细节的 `Book` 类
- en: '[PRE76]'
  id: totrans-978
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Suppose you’d been using this `Book` class like so:'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你一直是这样使用这个 `Book` 类的：
- en: '[PRE77]'
  id: totrans-980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '***1* Stores the author as a dictionary from the data**'
  id: totrans-981
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将作者存储为从数据中创建的字典**'
- en: '***2* Displays the author, such as “Dane Hillard”**'
  id: totrans-982
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 显示作者，例如“Dane Hillard”**'
- en: '***3* Gets the citation-suitable author name, such as “Hillard, D”**'
  id: totrans-983
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 获取适合引用的作者姓名，例如“Hillard, D”**'
- en: Being able to reference `book.author_for_display` and `book.author_for_citation`
    has been great, and you’d like to keep that. But referencing the `author` dictionary
    in those properties is starting to feel clumsy, and you know that you’ll want
    to do a lot more with authors soon. How do you proceed?
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 能够引用`book.author_for_display`和`book.author_for_citation`已经很好了，你希望保留这一点。但是，在这些属性中引用`author`字典开始感觉笨拙，而且你知道你很快就会想要对作者做更多的事情。你该如何进行？
- en: Extract an `AuthorFormatter` class for formatting author names in different
    ways.
  id: totrans-985
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取一个`AuthorFormatter`类，用于以不同方式格式化作者姓名。
- en: Extract an `Author` class to encapsulate author behaviors and information.
  id: totrans-986
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取一个`Author`类来封装作者的行为和信息。
- en: Although a class for formatting author names (option 1) might provide value,
    extracting an `Author` class (option 2) provides a better separation of concerns.
    When several methods in a class share a common prefix or suffix, especially one
    that doesn’t match the name of the class, there might be a new class waiting to
    be extracted. Here, `author_` is a sign that an `Author` class might make sense.
    It’s time to try your hand at extracting a class.
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一个用于格式化作者姓名的类（选项1）可能提供价值，但提取一个`Author`类（选项2）提供了更好的关注点分离。当一个类中的几个方法共享一个公共前缀或后缀，尤其是与类名不匹配的一个，可能有一个新的类等待被提取。在这里，`author_`是一个迹象，表明`Author`类可能是有意义的。现在是时候尝试提取一个类了。
- en: Create an `Author` class (either in the same module or imported from a new module).
    This `Author` class should contain all the same information as before, but in
    a more structured manner. The class should
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`Author`类（可以在同一模块中创建或从新模块中导入）。这个`Author`类应该包含与之前相同的信息，但以更结构化的方式。这个类应该
- en: Accept `author_data` as a dictionary in `__init__`, storing each relevant value
    (first name, last name, and so on) from the dictionary as an attribute
  id: totrans-989
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`__init__`中接受`author_data`作为字典，将字典中的每个相关值（名、姓等）存储为属性
- en: Have two properties, `for_display` and `for_citation`, that return the properly
    formatted author string
  id: totrans-990
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有两个属性，`for_display`和`for_citation`，它们返回正确格式化的作者字符串
- en: Remember that you also want `Book` to keep working for users, so you want to
    keep the existing `author_data`, `author_for_display`, and `author_for_citation`
    behaviors on `Book` for now. By initializing an `Author` instance with `author_data`,
    you can *forward* calls from `Book.author_for_display` to `Author.for_display`,
    and so on. This way, `Book` will let `Author` do most of the work, keeping only
    a temporary system in place to make sure calls keep working. Give it a try now,
    and come back to the following listing to see how you did.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你希望`Book`对用户仍然有效，因此你希望现在继续在`Book`上保留现有的`author_data`、`author_for_display`和`author_for_citation`行为。通过使用`author_data`初始化`Author`实例，你可以将`Book.author_for_display`的调用*转发*到`Author.for_display`，依此类推。这样，`Book`将让`Author`做大部分工作，同时保留一个临时系统以确保调用仍然有效。现在试试看，然后回到以下列表中查看你的结果。
- en: Listing 9.10\. Extracting an `Author` class from the `Book` class
  id: totrans-992
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.10\. 从`Book`类中提取`Author`类
- en: '[PRE78]'
  id: totrans-993
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '***1* What was previously stored only as a dictionary is now structured attributes.**'
  id: totrans-994
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 之前仅以字典形式存储的内容现在是有结构的属性。**'
- en: '***2* The Author-level properties are simpler than the originals.**'
  id: totrans-995
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 作者级别的属性比原始属性更简单。**'
- en: '***3* Continues storing author_data until consumers don’t need it anymore**'
  id: totrans-996
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 直到消费者不再需要它为止继续存储author_data**'
- en: '***4* Stores an instance of Author for forwarding calls**'
  id: totrans-997
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 存储一个Author实例以转发调用**'
- en: '***5* Replaces previous logic with forwarding to the Author instance**'
  id: totrans-998
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 用转发到Author实例的逻辑替换之前的逻辑**'
- en: Do you notice that even though the code now has more lines, each line has been
    simplified? And looking at the classes, it’s a bit easier to tell what kind of
    information they contain. Eventually, much of the code still in `Book` will also
    be removed, at which point `Book` will be leveraging composition of the `Author`
    class to provide information about its authors.
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到尽管代码现在有更多行，但每一行都简化了吗？并且查看这些类，它们包含的信息类型更容易识别。最终，`Book`中仍然存在的大部分代码也将被移除，到那时`Book`将利用`Author`类的组合来提供有关其作者的信息。
- en: If you want to be *really* nice to your consumers as you decompose a class,
    you can also leave them hints so they know they should switch to the new code.
    For example, you want the consumers of `Book` to move from `book.author_for_display`
    to `book.author.for_display` so that you can remove the forwarding. Python has
    a built-in system for this kind of messaging, called `warnings`.
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在分解类时想对消费者非常友好，您也可以给他们留下提示，让他们知道他们应该切换到新代码。例如，您希望`Book`的消费者从`book.author_for_display`迁移到`book.author.for.display`，以便您可以删除转发。Python有一个内置的系统用于此类消息，称为`warnings`。
- en: 'One type of warning is specifically a `DeprecationWarning`, which you can use
    to let people know that something should no longer be used. This warning generally
    prints a message in a program’s output telling the user they should make a change.
    A deprecation warning can be produced as follows:'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 一种警告类型是特定的 `DeprecationWarning`，您可以使用它来让人们知道某些东西应该不再使用。这种警告通常会在程序输出中打印一条消息，告诉用户他们应该做出更改。一个弃用警告可以如下生成：
- en: '[PRE79]'
  id: totrans-1002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'You can help consumers upgrade their code smoothly by adding a `DeprecationWarning`
    to each method you eventually want to remove.^([[1](#ch09fn01)]) Try adding them
    to the author-related properties in the `Book` class now. You can say something
    useful like `''Use book.author .for_display instead''`. If you run the code now,
    you should see warning messages in the output that look like the following:'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在每个最终想要删除的方法中添加一个 `DeprecationWarning` 来帮助消费者平滑地升级他们的代码.^([[1](#ch09fn01)])
    现在尝试将它们添加到 `Book` 类的作者相关属性中。您可以说一些有用的话，比如 `'Use book.author .for_display instead'`。如果您现在运行代码，您应该在输出中看到类似以下警告信息：
- en: ¹
  id: totrans-1004
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-1005
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See Brett Slatkin, “Refactoring Python: Why and how to restructure your code,”
    PyCon 2016, [www.youtube.com/watch?v=D_6ybDcU5gc](http://www.youtube.com/watch?v=D_6ybDcU5gc),
    for a treasure trove of deprecation and extraction tricks.'
  id: totrans-1006
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参见Brett Slatkin，“重构Python：为什么以及如何重构你的代码”，PyCon 2016，[www.youtube.com/watch?v=D_6ybDcU5gc](http://www.youtube.com/watch?v=D_6ybDcU5gc)，了解弃用和提取技巧的宝藏。
- en: '[PRE80]'
  id: totrans-1007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Congratulations! You’ve extracted a new class, breaking down the complexity
    of a class that outgrew itself. You did it in a backward-compatible way, leaving
    hints for users so they know what’s coming and how to fix it. This resulted in
    more structured, more readable code with separate concerns and strong cohesion.
    Well done, you.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已提取了一个新的类，简化了超出自身复杂性的类的复杂性。您以向后兼容的方式完成了这项工作，为用户提供提示，让他们知道即将发生什么以及如何修复它。这导致了更结构化、更易于阅读的代码，具有分离的关注点和强大的内聚性。做得好，您。
- en: Summary
  id: totrans-1009
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Code complexity and separate concerns are better metrics than physical size
    for breaking up code.
  id: totrans-1010
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码复杂性和分离的关注点是比物理大小更好的拆分代码的指标。
- en: Cyclomatic complexity measures the number of execution paths through your code.
  id: totrans-1011
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圈复杂度衡量了通过您代码的执行路径数量。
- en: Extract configuration, functions, methods, and classes freely to break down
    complexity.
  id: totrans-1012
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自由提取配置、函数、方法和类，以简化复杂性。
- en: Use forwarding and deprecation warnings to temporarily support the new and old
    ways of doing things.
  id: totrans-1013
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用转发和弃用警告来暂时支持新旧做法。
- en: Chapter 10\. Achieving loose coupling
  id: totrans-1014
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10章\. 实现松耦合
- en: '*This chapter covers*'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Recognizing the signs of tightly coupled code
  id: totrans-1016
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别紧密耦合代码的迹象
- en: Strategies for reducing coupling
  id: totrans-1017
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 降低耦合的策略
- en: Message-oriented programming
  id: totrans-1018
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息导向编程
- en: Loose coupling is what allows you to make changes in different areas of your
    code without worrying that you’ll break something elsewhere. It allows you to
    work on one feature while your coworker tackles another. It’s also the foundation
    for other desirable characteristics, like extensibility. Without loose coupling,
    the job of maintaining your code can quickly grow out of hand.
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 松耦合允许您在不担心会破坏其他地方的情况下，对代码的不同区域进行更改。它允许您在同事处理另一个功能的同时，专注于一个功能。它也是其他期望特性的基础，如可扩展性。没有松耦合，维护您代码的工作可能会迅速失控。
- en: In this chapter, you’ll see some of the pains of tight coupling and learn how
    to address them.
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将看到紧密耦合的一些痛苦，并学习如何解决这些问题。
- en: 10.1\. Defining coupling
  id: totrans-1021
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1\. 定义耦合
- en: Because the idea of coupling plays such a big role in effective software development,
    it’s important to get a solid grip on what it means. What is coupling exactly?
    You can think of it as the connective tissue between the different areas of your
    code.
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 由于耦合的概念在有效软件开发中扮演着如此重要的角色，因此了解它的含义非常重要。耦合究竟是什么？您可以将其视为您代码不同区域之间的连接组织。
- en: 10.1.1\. The connective tissue
  id: totrans-1023
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.1\. 连接组织
- en: Coupling can be a tricky concept at first because it’s not necessarily tangible.
    It’s a kind of mesh that runs throughout your code ([figure 10.1](#ch10fig01)).
    Where two pieces of code have high interdependency, that mesh is tightly woven
    and taut. Moving either piece of code around requires the other to move around
    too. The mesh between areas with little or no interdependence is flexible—maybe
    it’s made of rubber bands. You’d have to change the code in this looser part of
    the mesh much more drastically for it to impact the code around it.
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 耦合一开始可能是一个棘手的概念，因为它并不一定是具体的。它是一种贯穿你代码的网状结构([图10.1](#ch10fig01))。当两段代码有高度依赖性时，这个网状结构就编织得紧密且紧张。移动任何一段代码都需要另一段代码也移动。在几乎没有相互依赖性的区域之间的网状结构是灵活的——可能是由橡皮筋制成的。你将不得不在这个网状结构较松的部分进行更多的代码更改，才能对其周围的代码产生影响。
- en: Figure 10.1\. Coupling is a measure of the interconnectedness of distinct pieces
    of software.
  id: totrans-1025
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.1\. 耦合是衡量不同软件组件之间相互连接程度的度量。
- en: '![](../Images/f0206-01_alt.jpg)'
  id: totrans-1026
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0206-01_alt.jpg)'
- en: I like this analogy because it doesn’t say that tight coupling is inherently
    *bad* in all cases. Rather, it focuses on the ways tight and loose coupling differ
    and helps you get a sense of the resulting outcomes for your code—tight coupling
    usually means more work when you want to shuffle things around. It also implies
    that coupling is a continuum rather than a binary, all-or-nothing thing.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢这个类比，因为它并没有说在所有情况下紧密耦合都是固有的*坏*。相反，它关注紧密耦合和松散耦合的不同之处，并帮助你对你代码的结果有一个感觉——紧密耦合通常意味着当你想要重新排列事物时需要做更多的工作。它还暗示耦合是一个连续体，而不是一个二元、全有或全无的东西。
- en: Although coupling is measured along a continuum, there *are* common ways it
    manifests. You can learn to recognize these and reduce coupling in your software
    as you see fit. First, though, I want to give you a more fine-grained definition
    of tight and loose coupling.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然耦合是在一个连续体上测量的，但确实有一些常见的表现方式。你可以学会识别这些，并根据你的需要减少软件中的耦合。不过，首先，我想给你一个更细致的定义，关于紧密耦合和松散耦合。
- en: 10.1.2\. Tight coupling
  id: totrans-1029
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.2\. 紧密耦合
- en: 'Coupling between two pieces of code (modules, classes, and so on) is considered
    tight when those pieces of code are interconnected. But what does interconnectedness
    look like? In your code, several things create interconnections:'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 当两段代码（模块、类等）相互连接时，这种耦合被认为是紧密的。但相互连接看起来是什么样子？在你的代码中，有几个因素会创建连接：
- en: A class that stores another object as an attribute
  id: totrans-1031
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将另一个对象作为属性存储的类
- en: A class whose methods call functions from another module
  id: totrans-1032
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个方法调用另一个模块的函数的类
- en: A function or method that does a lot of procedural work using methods from another
    object
  id: totrans-1033
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个使用另一个对象的多个方法进行大量过程性工作的函数或方法
- en: Anytime a class, method, or function needs to carry a lot of knowledge about
    another module or class, that’s tight coupling. Consider the code in the following
    listing. The `display_book_info` function needs to know all the different pieces
    of information that a `Book` instance contains.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 任何时候一个类、方法或函数需要携带大量关于另一个模块或类的知识时，这就是紧密耦合。考虑以下列表中的代码。`display_book_info`函数需要了解`Book`实例包含的所有不同信息。
- en: Listing 10.1\. A function tightly coupled to an object
  id: totrans-1035
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.1\. 与对象紧密耦合的函数
- en: '[PRE81]'
  id: totrans-1036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '***1* A book stores several pieces of info as attributes.**'
  id: totrans-1037
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 一本书将几条信息作为属性存储。**'
- en: '***2* This function has knowledge of all the book’s attributes.**'
  id: totrans-1038
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 这个函数了解所有书籍的属性。**'
- en: If the `Book` class and the `display_book_info` function live in the same module,
    this code might be tolerable. It operates on related information, and it’s together
    in one place. But as your codebase grows, you may eventually find functions like
    `display_book_info` in one module operating on classes from other modules.
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Book`类和`display_book_info`函数位于同一个模块中，这段代码可能还可以接受。它操作相关信息，并且它们都在一个地方。但随着你的代码库增长，你可能会在某个模块中找到像`display_book_info`这样的函数，它操作来自其他模块的类。
- en: Tight coupling isn’t inherently bad. Occasionally, it’s just trying to tell
    you something. Because `display_book_info` operates only on info from `Book` and
    does something book-related, the function and the class have *high cohesion*.
    It’s *so* tightly coupled to `Book` that it makes sense for you to move it inside
    the `Book` class as a method, as shown in the following listing.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 紧密耦合并不是固有的坏。偶尔，它只是在试图告诉你一些东西。因为`display_book_info`只操作来自`Book`的信息，并且做一些与书籍相关的事情，所以函数和类有*高内聚性*。它与`Book`耦合得如此紧密，以至于将其作为一个方法移动到`Book`类中是有意义的，如下面的列表所示。
- en: Listing 10.2\. Reducing coupling by increasing cohesion
  id: totrans-1041
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.2\. 通过增加内聚性来减少耦合
- en: '[PRE82]'
  id: totrans-1042
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '***1* Function moved to a method whose only necessary argument is self (still
    a Book)**'
  id: totrans-1043
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 函数移动到只必要参数是self（仍然是Book）的方法中**'
- en: '***2* All references to book change to self.**'
  id: totrans-1044
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 所有关于书籍的引用都改为self.**'
- en: In general, tight coupling is problematic when it exists between two separate
    concerns. Some tight coupling is a sign of high cohesion that isn’t structured
    well.
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，当两个不同的关注点之间存在紧密耦合时，这是一个问题。一些紧密耦合是高内聚但结构不佳的标志。
- en: You may have seen or written code similar to [listing 10.3](#ch10ex3). Imagine
    you’ve got a search index to which your users can submit queries. The search module
    provides functionality for cleaning up those queries to make sure they produce
    consistent results from the index. You write a main procedure that gets a query
    from the user, cleans it up, and prints the cleaned-up version.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能见过或编写过类似[列表10.3](#ch10ex3)的代码。想象一下，你有一个搜索索引，用户可以向其中提交查询。搜索模块提供了清理这些查询的功能，以确保它们从索引中产生一致的结果。你编写了一个主程序，从用户那里获取查询，清理它，并打印清理后的版本。
- en: Listing 10.3\. A procedure tightly coupled to the details of a class
  id: totrans-1047
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.3\. 与类细节紧密耦合的过程
- en: '[PRE83]'
  id: totrans-1048
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '***1* Turns '' George Washington '' into ''George Washington''**'
  id: totrans-1049
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 ''George Washington'' 转换为 ''George Washington''**'
- en: '***2* Turns ''Universitätsstraße'' (“University Street”) into ''universitätsstrasse''**'
  id: totrans-1050
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将 ''Universitätsstraße'' （“大学街”）转换为 ''universitätsstrasse''**'
- en: '***3* Gets a query from the user**'
  id: totrans-1051
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 从用户那里获取查询**'
- en: '***4* Removes spaces and normalizes casing**'
  id: totrans-1052
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 移除空格并规范化大小写**'
- en: '***5* Prints the cleaned-up query**'
  id: totrans-1053
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 打印清理后的查询**'
- en: Is the main procedure tightly coupled to the search module?
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 主程序是否与搜索模块紧密耦合？
- en: No, because it could easily do that work itself.
  id: totrans-1055
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不是，因为它可以轻松地自己完成这项工作。
- en: Yes, because it calls some of the functions inside the search module.
  id: totrans-1056
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，因为它调用了搜索模块内部的一些函数。
- en: Yes, because it would likely have to change if you changed the way cleaning
    queries works.
  id: totrans-1057
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，因为如果改变了清理查询的方式，它很可能会发生变化。
- en: You can effectively identify coupling by assessing the likelihood that any given
    change to a module will require a change to the code that uses it (option 3).
    Although the main procedure *could* do the work the cleaning functions do, it’s
    important to discuss coupling as it currently exists in your code. Option 1 is
    hypothetical and doesn’t help you achieve this. Calling a few functions from a
    module (option 2) is sometimes a sign of coupling, but the more important metric
    is how likely a change to the search module will require changes to the main procedure.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过评估任何给定模块的更改是否需要更改使用它的代码（选项3）来有效地识别耦合。尽管主程序*可能*能完成清理函数的工作，但讨论代码中当前存在的耦合是很重要的。选项1是假设性的，并不能帮助你实现这一点。从一个模块中调用几个函数（选项2）有时是耦合的迹象，但更重要的是，一个搜索模块的更改需要更改主程序的可能性。
- en: Suppose your users report that they’re still getting inconsistent results from
    minor changes to their queries. You do some investigation and realize it’s because
    some users like to put quotes around their queries, thinking it will make them
    more specific, but your search index treats quotes literally, matching only records
    that contain the quotes as written. You decide to discard the quotes before running
    the query.
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的用户报告说，他们对查询的微小变化仍然得到不一致的结果。你进行了一些调查，发现这是因为一些用户喜欢在查询周围加上引号，认为这会使它们更具体，但你的搜索索引将引号视为字面意思，只匹配包含引号的记录。你决定在运行查询之前删除引号。
- en: The way things are currently written, this would involve adding a new function
    to the search module *and* updating all the places where you clean queries to
    ensure they call the new function, as shown in the following listing. Those points
    in the code are all tightly coupled to the search module.
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 按照目前的方式编写，这将涉及向搜索模块添加一个新函数，并更新所有清理查询的地方以确保它们调用新函数，如下面的列表所示。这些代码点都与搜索模块紧密耦合。
- en: Listing 10.4\. Tight coupling causing changes to ripple outward
  id: totrans-1061
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.4\. 紧耦合导致变化向外扩散
- en: '[PRE84]'
  id: totrans-1062
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '***1* A new function for removing quotes**'
  id: totrans-1063
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 用于移除引号的新功能**'
- en: '***2* Calls the new function anywhere you normalize queries**'
  id: totrans-1064
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在你规范化查询的任何地方调用新函数**'
- en: Read on to understand what *loose* coupling is and how it can help you in situations
    like this.
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 继续阅读以了解什么是*松耦合*以及它如何帮助你在这种情况中。
- en: 10.1.3\. Loose coupling
  id: totrans-1066
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.3\. 松耦合
- en: '*Loose coupling* is the ability of two pieces of code to interact to accomplish
    a task without either relying heavily on the details of the other. This is often
    achieved through the use of shared abstractions. You learned about interfaces
    in earlier chapters, and you used a shared abstraction in Bark to achieve the
    command pattern.'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: '*松耦合*是指两段代码能够相互交互以完成任务，而不依赖于另一段代码的详细信息。这通常是通过使用共享抽象来实现的。你已经在前面的章节中学习了接口，并在Bark中使用共享抽象来实现命令模式。'
- en: Loosely coupled code implements and uses interfaces; at the extreme end, it
    uses *only* interfaces for intercommunication. Python’s dynamic typing allows
    us to relax this a bit, but there’s a philosophy here I’d really like to emphasize
    to you.
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 松耦合的代码实现和使用接口；在极端情况下，它只使用接口进行交互。Python的动态类型允许我们稍微放松这一点，但我真的想强调这一点。
- en: If you begin to think about the intercommunication between pieces of your code
    in terms of the *messages* that objects send to each other ([figure 10.2](#ch10fig02)),
    rather than focusing on the objects themselves, you’ll begin to identify cleaner
    abstractions and stronger cohesion. What are messages? Messages are the questions
    you ask of an object or the things you tell it to do.
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你开始从对象之间发送的消息的角度来考虑你代码之间的交互，而不是专注于对象本身，你将开始识别更简洁的抽象和更强的内聚性。什么是消息？消息是你向对象提出的问题或你要告诉它做的事情。
- en: Take another look at the main procedure of your query cleaner in the following
    listing. You achieve each transform on the query by calling a function to get
    a new query. Each of these is a message you’re sending.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 重新审视以下列表中查询清理程序的主程序。你通过调用一个函数来获取新的查询，从而在查询上实现每个转换。这些都是你发送的消息。
- en: Listing 10.5\. Calling functions from a module
  id: totrans-1071
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.5\. 从模块中调用函数
- en: '[PRE85]'
  id: totrans-1072
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '***1* Tells the search module to remove spaces**'
  id: totrans-1073
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 告诉搜索模块去除空格**'
- en: '***2* Tells the search module to remove quotes**'
  id: totrans-1074
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 告诉搜索模块去除引号**'
- en: '***3* Tells the search module to normalize the casing**'
  id: totrans-1075
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 告诉搜索模块规范化大小写**'
- en: Figure 10.2\. Imagining interconnections between classes as the messages they
    send and receive
  id: totrans-1076
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.2\. 将类之间的相互连接想象成它们发送和接收的消息
- en: '![](../Images/f0210-01_alt.jpg)'
  id: totrans-1077
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0210-01_alt.jpg)'
- en: What you’ve written achieves the task—cleaning the query—but how do the messages
    feel to you? Does calling the various functions from the search module feel like
    a lot of hoops to jump through? If I saw this code, I might say to myself, “I
    just want the cleaned-up query. I don’t care how!” Going through the paces of
    calling each function is tedious, especially if you’re cleaning queries throughout
    your code.
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 你所编写的代码完成了任务——清理查询——但你对这些消息的感觉如何？从搜索模块调用各种函数是否感觉像跳过很多圈？如果我看到这段代码，我可能会对自己说，“我只想得到清理后的查询。我不在乎它是如何做到的！”调用每个函数的过程是乏味的，尤其是在你需要在代码中清理查询时。
- en: 'Think about this in terms of the message or messages you’d *like* to send.
    A cleaner approach might be to send a single message: “Here’s my query; clean
    it please.” What approach might you take to achieve this?'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 从你希望发送的消息的角度来考虑这个问题。一种更简洁的方法可能是发送一个单一的消息：“这是我的查询；请清理它。”你可能会采取什么方法来实现这一点？
- en: Combine the query-cleaning functions into a single function to remove spaces
    and quotes and normalize casing.
  id: totrans-1080
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将查询清理函数合并为一个单一函数，以去除空格和引号并规范化大小写。
- en: Wrap the existing function calls in another function you can call anywhere.
  id: totrans-1081
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有的函数调用包装到另一个你可以从任何地方调用的函数中。
- en: Use a class to encapsulate the query-cleaning logic.
  id: totrans-1082
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用类来封装查询清理逻辑。
- en: Any of these could work. Because separation of concerns is generally a good
    idea, option 1 might not be the best choice because it combines several concerns
    into a single function. Wrapping the existing functions into another (option 2)
    would keep the concerns separate while providing a single entry point for the
    cleaning behavior, which is good. Encapsulating that logic further into a class
    (option 3) could make sense later on, if you need the cleaning logic to maintain
    information between steps.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法中的任何一种都可能有效。因为关注点的分离通常是一个好主意，所以选项1可能不是最佳选择，因为它将多个关注点合并到一个函数中。将现有函数包装到另一个函数中（选项2）可以保持关注点的分离，同时提供一个单一的清理行为入口点，这是好的。将这种逻辑进一步封装到类中（选项3）可能在需要清理逻辑在步骤之间保持信息时更有意义。
- en: Try refactoring the search module to make each transform function private, providing
    a `clean_query(query)` function that performs all the cleaning and returns the
    cleaned query. Come back here and check your work against the following listing.
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试重构搜索模块，使每个转换函数私有，提供一个`clean_query(query)`函数，执行所有清理并返回清理后的查询。回来这里检查你的工作与以下列表进行对比。
- en: Listing 10.6\. Simplifying a shared interface
  id: totrans-1085
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.6\. 简化共享接口
- en: '[PRE86]'
  id: totrans-1086
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '***1* Transforms are made private because they’re underlying details of cleaning.**'
  id: totrans-1087
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 转换被设为私有，因为它们是清理的底层细节。**'
- en: '***2* A single entry point receives the original query, cleans it, and returns
    it.**'
  id: totrans-1088
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 单个入口点接收原始查询，清理它，并返回它。**'
- en: '***3* The consuming code needs to call only a single function now, reducing
    coupling.**'
  id: totrans-1089
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 消费者代码现在只需要调用一个函数，减少了耦合。**'
- en: 'Now when you think of another technique to clean your queries, you’ll be able
    to do the following (shown in [figure 10.3](#ch10fig03)):'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你想到另一种清理查询的技术时，你将能够做以下事情（如图10.3所示）：
- en: Create a function to perform the new transform on a query.
  id: totrans-1091
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数来对查询执行新的转换。
- en: Call the new function inside `clean_query`.
  id: totrans-1092
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`clean_query`内部调用新函数。
- en: Call it a day, confident that consumers are all cleaning queries properly.
  id: totrans-1093
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结束这一天，自信地认为所有消费者都在正确地清理查询。
- en: You can see that loose coupling, separation of concerns, and encapsulation all
    work together. The separation and encapsulation of behavior with a carefully thought
    out interface to the outside world helps achieve the loose coupling you desire.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到松散耦合、关注点分离和封装是如何共同工作的。通过精心设计的对外界接口的行为分离和封装，有助于实现你想要的松散耦合。
- en: Figure 10.3\. Using encapsulation and separation of concerns to maintain loose
    coupling
  id: totrans-1095
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.3\. 使用封装和关注点分离来保持松散耦合
- en: '![](../Images/f0212-01_alt.jpg)'
  id: totrans-1096
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0212-01_alt.jpg)'
- en: 10.2\. Recognizing coupling
  id: totrans-1097
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2\. 识别耦合
- en: You’ve seen examples of tight and loose coupling now, but coupling can take
    on a few specific forms in practice. Giving a name to these forms, and recognizing
    the signs of each form, will help you mitigate tight coupling early on, keeping
    you more productive in the long term.
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了紧密耦合和松散耦合的例子，但在实践中耦合可以采取几种特定的形式。给这些形式命名，并识别每种形式的迹象，将帮助你早期减轻紧密耦合，从长远来看使你更加高效。
- en: 10.2.1\. Feature envy
  id: totrans-1099
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.1\. 特征依赖
- en: In the early version of your query-cleaning code, the consumer needed to call
    several functions from the search module. When code performs several tasks using
    mainly features from another area, that code is said to have *feature envy*. Your
    main procedure feels like it wants to *be* the search module because it uses all
    of its features explicitly. This is also common in classes, as shown in [figure
    10.4](#ch10fig04).
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 在你查询清理代码的早期版本中，消费者需要从搜索模块调用几个函数。当代码主要使用来自另一个区域的功能执行多个任务时，这种代码被称为*特征依赖*。你的主要程序感觉就像想要*成为*搜索模块，因为它明确地使用了它的所有功能。这在类中也很常见，如图10.4所示。
- en: Figure 10.4\. Feature envy from one class to another
  id: totrans-1101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.4\. 一个类到另一个类的特征依赖
- en: '![](../Images/f0212-02.jpg)'
  id: totrans-1102
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0212-02.jpg)'
- en: 'Feature envy can be solved the same way you fixed your query-cleaning logic:
    roll it up into a single entry point back at the source. In the previous example,
    you created a `clean_query` function in the search module. The search module is
    where query-cleaning logic goes, so a `clean_query` function is perfectly at home
    there. Other code can continue using `clean_query`, blissfully unaware of what
    happens underneath and trusting that it will receive a properly cleaned query
    in return. That code no longer has feature envy; it’s happy letting the search
    module be in charge of search-related things.'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 特征依赖可以通过与你修复查询清理逻辑相同的方式解决：将其卷起为源处的单个入口点。在前面的例子中，你在搜索模块中创建了一个`clean_query`函数。搜索模块是查询清理逻辑所在的地方，所以`clean_query`函数在那里非常合适。其他代码可以继续使用`clean_query`，无忧无虑地不知道下面发生了什么，并相信它会收到一个正确清理的查询。这段代码不再有特征依赖；它很高兴让搜索模块负责搜索相关的事情。
- en: As you refactor to remove feature envy, it will feel like you’re giving up a
    certain amount of control. Before refactoring, you can see exactly how the information
    flows through the code, but afterward, that flow is often hidden under a layer
    of abstraction. This requires putting a certain amount of trust in the code you
    interact with to do what it says. It will feel uncomfortable occasionally, but
    a thorough test suite can help you remain confident in the functionality.
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 当你重构以消除特性嫉妒时，你会感觉好像在放弃一定程度的控制。在重构之前，你可以清楚地看到信息是如何在代码中流动的，但之后，这种流动通常被抽象层所隐藏。这需要你对交互的代码有一定的信任，相信它能够按照它所说的去做。偶尔你会感到不舒服，但一个全面的测试套件可以帮助你保持对功能的信心。
- en: 10.2.2\. Shotgun surgery
  id: totrans-1105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.2\. 散弹枪式手术
- en: You learned about shotgun surgery in [chapter 7](../Text/kindle_split_018.html#ch07),
    and it often happens as a result of tight coupling. You make one change to a class
    or module, and you need to make changes far and wide to keep other code working.
    Peppering changes throughout your code each time you need to update behavior is
    tiresome!
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第7章](../Text/kindle_split_018.html#ch07)中学习了“散弹枪式手术”，这通常是由于紧密耦合造成的。你对一个类或模块进行一次更改，就需要在代码的各个地方进行广泛的更改以保持其他代码的正常工作。每次需要更新行为时，都要在代码中穿插更改，这会让人感到非常繁琐！
- en: By addressing feature envy, separating concerns, and practicing good encapsulation
    and abstraction, you’ll minimize the amount of shotgun surgery you’ll have to
    do. Anytime you find yourself jumping around to different functions, methods,
    or modules to realize the change you’re trying to make, ask yourself if you’re
    experiencing tight coupling between those areas of code. Then see what opportunities
    there are to move a method to a better-suited class, a function to a better-suited
    module, and so on—a place for everything, and everything in its place.
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过解决特性嫉妒、分离关注点、实践良好的封装和抽象，你可以最大限度地减少需要进行的散弹枪式手术的数量。任何时候当你发现自己需要在不同的函数、方法或模块之间跳转以实现你想要做的更改时，问问自己你是否在这些代码区域之间经历了紧密耦合。然后看看有什么机会可以将一个方法移动到一个更适合的类，一个函数移动到一个更适合的模块，等等——物归其位，各得其所。
- en: 10.2.3\. Leaky abstractions
  id: totrans-1108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.3\. 泄露的抽象
- en: The goal of abstraction, as you’ve learned, is to hide the details of a particular
    task from the consumer. The consumer triggers the behavior and receives the result
    but doesn’t care about what happens under the hood. If you start to notice feature
    envy, it might be because of a *leaky abstraction*.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所学的，抽象的目标是隐藏特定任务的具体细节。消费者触发行为并接收结果，但并不关心底层发生了什么。如果你开始注意到特性嫉妒，那可能是因为存在一个*泄露的抽象*。
- en: A leaky abstraction is one that doesn’t sufficiently hide its details. The abstraction
    claims to provide a simple way to get something done, but it ultimately requires
    you to have some knowledge about what lies beneath when using it. This sometimes
    manifests as feature envy, but it can also be subtle, as you’ll see in a moment.
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 泄露的抽象是指那些没有充分隐藏其细节的抽象。这种抽象声称提供了一种简单的方式来完成任务，但最终在使用时，你需要对底层有所了解。这有时会表现为特性嫉妒，但也可以很微妙，就像你马上就会看到的。
- en: Picture a Python package for making HTTP requests (`requests`, maybe). If your
    goal is purely to make a `GET` request to some URL and get the response back,
    you’d be best served by an abstraction on the `GET` behavior, such as `requests.get('https://www.google.com')`.
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个用于制作HTTP请求的Python包（比如`requests`）。如果你的目标仅仅是向某个URL发送一个`GET`请求并获取响应，那么对`GET`行为的抽象，如`requests.get('https://www.google.com')`，将是最适合你的。
- en: This abstraction works well *most* of the time, but what happens when you lose
    your internet connection? When Google is unavailable? When things are “just weird”
    for a moment and your `GET` request doesn’t make it anywhere? In these cases,
    `requests` generally raises an exception indicating the problem ([figure 10.5](#ch10fig05)).
    This is useful for error handling, but it requires the calling code to know a
    bit about the *possible* errors so it knows which are likely to occur and how
    to handle them. Once you start handling errors from `requests` in many places,
    you’re coupled to it, because your code expects a certain set of possible outcomes,
    which are specific to the requests package.
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 这种抽象在**大多数**情况下都工作得很好，但当你失去互联网连接时会发生什么？当Google不可用时？当事情“只是有点奇怪”时，你的`GET`请求没有到达任何地方？在这些情况下，`requests`通常会引发一个表示问题的异常（[图10.5](#ch10fig05)）。这对于错误处理很有用，但它要求调用代码了解一些**可能**的错误，以便知道哪些可能发生以及如何处理它们。一旦你开始在许多地方处理`requests`的错误，你就与之耦合了，因为你的代码期望一组特定的可能结果，这些结果特定于requests包。
- en: Figure 10.5\. Abstractions occasionally leak the details they’re trying to hide.
  id: totrans-1113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.5。抽象有时会泄露它们试图隐藏的细节。
- en: '![](../Images/f0214-01_alt.jpg)'
  id: totrans-1114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/f0214-01_alt.jpg)'
- en: Leaks happen because there’s a trade-off to consider with abstractions—generally
    speaking, the further you abstract a concept in code, the less customization you
    can provide. This is because abstraction is inherently meant to remove access
    to detail; the fewer details you can access, the fewer ways you have to change
    the details. As developers, we often want to tweak things to better suit our needs,
    though, so we sometimes provide lower-level access to the very details we tried
    to hide.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 泄露发生是因为抽象需要权衡——一般来说，你在代码中越抽象一个概念，你能够提供的定制化就越少。这是因为抽象本质上是为了移除对细节的访问；你能访问的细节越少，你改变细节的方式就越少。然而，作为开发者，我们经常想要调整东西以更好地满足我们的需求，所以我们有时会提供对那些我们试图隐藏的细节的更低级访问。
- en: When you find yourself providing access to a low-level detail from a high-level
    layer of abstraction, you’re likely introducing coupling. Remember that loose
    coupling relies on *interfaces*—shared abstractions—rather than specific low-level
    details. Read on to see some of the specific strategies you can use to achieve
    loose coupling in your code.
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 当你发现自己从抽象层的高层提供对低级细节的访问时，你很可能会引入耦合。记住，松耦合依赖于**接口**——共享抽象，而不是具体的低级细节。继续阅读，看看你可以使用的一些具体策略来实现代码中的松耦合。
- en: 10.3\. Coupling in Bark
  id: totrans-1117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3. Bark中的耦合
- en: You can separate concerns and encapsulate behaviors all you like, but those
    concerns inevitably need to interact with each other. Coupling is a necessary
    part of software development, but it doesn’t have to be *tight* coupling. Now
    that you’re familiar with some of the signs of tight coupling, it’s time to look
    at techniques for reducing it while keeping your code in working order. Some of
    these will be familiar to you, and you’ll see how they can be further applied
    to the Bark application.
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随心所欲地分离关注点并封装行为，但那些关注点不可避免地需要相互交互。耦合是软件开发的一个必要部分，但它不必是**紧密**耦合。现在你已经熟悉了一些紧密耦合的迹象，是时候看看如何通过保持代码的正常运行来减少耦合的技术了。其中一些你可能已经熟悉，你将看到它们如何进一步应用于Bark应用程序。
- en: 'Remember the multitier architecture you used for Bark, shown again in [figure
    10.6](#ch10fig06). Each tier has a distinct set of concerns:'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 记住你为Bark使用的多层架构，再次在[图10.6](#ch10fig06)中展示。每一层都有一个独特的关注点集合：
- en: The presentation layer shows information to, and gets information from, the
    user.
  id: totrans-1120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示层向用户展示信息，并从用户那里获取信息。
- en: The business logic layer contains the “smarts” of the application—the logic
    related to the task at hand.
  id: totrans-1121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务逻辑层包含应用程序的“智慧”——与当前任务相关的逻辑。
- en: The persistence layer stores data for the application, to be reused later on.
  id: totrans-1122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久层存储应用程序的数据，以便稍后重用。
- en: Figure 10.6\. Separating concerns into a multitier architecture
  id: totrans-1123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.6。将关注点分离到多层架构中
- en: '![](../Images/f0215-01.jpg)'
  id: totrans-1124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/f0215-01.jpg)'
- en: You hooked the presentation layer to the business logic layer using the command
    pattern. Each option in the menu triggers a corresponding command in the business
    logic, through that command’s `execute` method. The set of commands with their
    shared `execute` abstraction are a great example of loose coupling.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用命令模式将表示层连接到业务逻辑层。菜单中的每个选项都会通过该命令的`execute`方法触发业务逻辑中的相应命令。具有共享`execute`抽象的命令集是松耦合的一个很好的例子。
- en: The presentation layer knows very little about the commands it’s hooked up to,
    and the commands don’t care why they were triggered, as long as they receive the
    data they expect. This allows each layer to change independently to adapt to new
    requirements.
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 展示层对其连接的命令了解得非常少，而命令也不关心它们被触发的理由，只要它们收到预期的数据即可。这允许每一层独立地改变以适应新的需求。
- en: 'Now think about how the business logic layer interacts with the persistence
    layer. Remember the `AddBookmarkCommand` you created, shown in [listing 10.7](#ch10ex7).
    This command does the following:'
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在思考一下业务逻辑层如何与持久化层交互。记得你创建的`AddBookmarkCommand`，如[代码列表10.7](#ch10ex7)所示。这个命令执行以下操作：
- en: Receives the data for a bookmark along with an optional timestamp
  id: totrans-1128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接收书签数据以及可选的时间戳
- en: Generates a timestamp if needed
  id: totrans-1129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，生成时间戳
- en: Tells the persistence layer to store the bookmark
  id: totrans-1130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉持久化层存储书签
- en: Returns a message stating that the addition was a success
  id: totrans-1131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回一条消息，表明添加成功
- en: Listing 10.7\. Command for adding a new bookmark
  id: totrans-1132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[代码列表10.7]\. 添加新书签的命令'
- en: '[PRE87]'
  id: totrans-1133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '***1* Receives bookmark data**'
  id: totrans-1134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 接收书签数据**'
- en: '***2* Generates a timestamp if needed**'
  id: totrans-1135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 如果需要，生成时间戳**'
- en: '***3* Persists the bookmark data**'
  id: totrans-1136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 持久化书签数据**'
- en: '***4* Returns a success message**'
  id: totrans-1137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 返回成功消息**'
- en: What if I told you there’s some tight coupling in here? The whole class is five
    lines long—you might ask yourself, “How much coupling can there be in five lines?”
    As it turns out, the last two lines of the `execute` method show signs of tight
    coupling.
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我告诉你这里有一些紧密耦合呢？整个类只有五行长——你可能会问自己，“五行中能有多少耦合？”实际上，`execute`方法的最后两行显示了紧密耦合的迹象。
- en: The first offending line, which calls `db.add`, demonstrates a tight coupling
    with not just the persistence layer, but the database itself. Put another way,
    if you decide in the future that you’d like to store your bookmarks in something
    other than a database—like a JSON file, for example—`db.add` doesn’t fit well
    any longer. There’s also some feature envy going on; most of the commands make
    direct use of one of the operations from `DatabaseManager`.
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行有问题的代码，调用`db.add`，展示了与持久化层以及数据库本身的紧密耦合。换句话说，如果你将来决定想要将书签存储在数据库之外的地方——比如JSON文件，那么`db.add`就不再适用了。还存在一些特征嫉妒的问题；大多数命令直接使用`DatabaseManager`中的一个操作。
- en: The second line that presents coupling is the `return` statement. What is its
    current purpose? It returns a message stating the addition was a success. Who
    is the message intended for? The user. You’re handling a piece of presentation-level
    information in the business logic layer, which is an example of a leaky abstraction.
    The presentation layer should be in charge of what’s shown to users. Some of the
    other commands you wrote have this same structure, which you’ll fix shortly.
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 展示耦合的第二行是`return`语句。它的当前目的是什么？它返回一条消息，表明添加成功。这条消息是给谁的？用户。你在业务逻辑层处理了一块展示层的信息，这是一个抽象泄露的例子。展示层应该负责向用户展示什么。你编写的一些其他命令也有这种结构，你很快就会修复这个问题。
- en: Another command, the `CreateBookmarksTableCommand`, introduces even tighter
    coupling. The `Table` in its name implies the presence of a database, a persistence
    layer feature, and then the command is referenced when the application starts,
    in the presentation layer. This command spans all the layers of abstraction you
    so carefully built! Don’t worry, you’ll be able to clean that up soon as well.
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个命令，`CreateBookmarksTableCommand`，引入了更紧密的耦合。其名称中的`Table`暗示了数据库的存在，这是一个持久化层特性，然后当应用程序启动时，在展示层中引用了这个命令。这个命令跨越了你精心构建的所有抽象层！别担心，你很快就能清理这个问题。
- en: Read on to see how this coupling can cause problems in a real-life situation
    and how you should think about tackling it.
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 继续阅读，了解这种耦合如何在现实生活中的情况中引起问题，以及你应该如何思考解决它。
- en: 10.4\. Addressing coupling
  id: totrans-1143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4\. 解决耦合问题
- en: Imagine now that you’re tasked with taking Bark mobile. (Also imagine phones
    that run Python!) You’d like to reuse as much of Bark’s code as possible to optimize
    the experience for users on their phones while maintaining the existing command-line
    interface, as shown in [figure 10.7](#ch10fig07).
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你现在被分配了将Bark移动化的任务。（也想象一下运行Python的手机！）你希望尽可能多地重用Bark的代码，以优化手机用户的体验，同时保持现有的命令行界面，如图[10.7](#ch10fig07)所示。
- en: Addressing new requirements often exposes tightly coupled areas of code. New
    use cases require you to swap out behavior and inevitably uncover the points in
    your code without flexibility. What will you find in Bark?
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 面对新的需求通常会导致代码中紧密耦合的区域暴露出来。新的用例要求你替换行为，不可避免地会揭示出你代码中缺乏灵活性的点。在Bark中你会找到什么？
- en: Figure 10.7\. How core business logic supports a variety of use cases
  id: totrans-1146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.7\. 核心业务逻辑如何支持各种用例
- en: '![](../Images/f0217-01_alt.jpg)'
  id: totrans-1147
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0217-01_alt.jpg)'
- en: 10.4.1\. User messaging
  id: totrans-1148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.1\. 用户消息
- en: Because mobile apps tend to focus on visual and tactile elements, you’ll want
    to use icons in addition to your messages to indicate success. A moment ago, you
    saw that the messaging in Bark is coupled to the business logic layer. To fix
    this limitation, you need to release control of the messaging fully to the presentation
    layer. How can you keep the interaction between commands and the presentation
    layer without each command having explicit knowledge of the message it shows?
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于移动应用倾向于关注视觉和触觉元素，你将希望除了消息外还使用图标来指示成功。刚才你看到Bark中的消息与业务逻辑层耦合。为了解决这个问题，你需要完全将消息的控制权释放到表示层。如何在不让每个命令明确知道它显示的消息的情况下保持命令与表示层之间的交互？
- en: Note that the outcome of some commands is a success message, whereas for others
    it’s a result of some kind (a list of bookmarks, for example). You can handle
    this in the presentation layer by splitting up the concept of “success” and “result,”
    with each command returning a tuple representing *both* the status and the result.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，某些命令的结果是成功消息，而其他命令的结果是某种类型的结果（例如，书签列表）。你可以在表示层通过拆分“成功”和“结果”的概念来处理这种情况，每个命令返回一个表示*两者*的状态和结果的元组。
- en: The commands you’ve built should all execute successfully, so for the moment
    the status for each command can be `True`. Eventually, you could have commands
    return `False` if they can fail. The commands that currently return a result can
    continue using the same result as before, and commands without a result can use
    `None`.
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 你构建的命令都应该成功执行，所以目前每个命令的状态可以是`True`。最终，你可以让命令返回`False`，如果它们可能失败。目前返回结果的命令可以继续使用之前相同的结果，而没有结果的命令可以使用`None`。
- en: Update each of your commands to return a `status,` `result` tuple. You’ll also
    need to update the `Option` class in the presentation layer to account for the
    new return behavior. What approach fits with how you’ve built the presentation
    layer so far?
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 更新你的每个命令以返回一个`status,` `result`元组。你还需要更新表示层的`Option`类，以适应新的返回行为。哪种方法与迄今为止你构建的表示层相匹配？
- en: Make `Option` print different success messages depending on the command executed.
  id: totrans-1153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让`Option`根据执行的命令打印不同的成功消息。
- en: Configure each `Option` instance with a specific message to use when a command
    succeeds.
  id: totrans-1154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置每个`Option`实例，使其在命令成功时使用特定的消息。
- en: Subclass `Option` for each kind of message you want to display.
  id: totrans-1155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你想要显示的每种消息类型对`Option`进行子类化。
- en: Option 1 could work, but each new command would add to the conditional logic
    that determines which message to show. Option 3 might also work, but remember
    that inheritance should be used sparingly; it’s unclear that there’s enough specialized
    behavior present to justify creating all those subclasses. Option 2 gives you
    just the right amount of customization without a lot of extra effort. Remember
    that Bark should continue to function identically as you refactor the messaging—you’re
    refactoring only to make development easier on yourself.
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 选项1可能可行，但每个新的命令都会增加确定要显示哪个消息的条件逻辑。选项3也可能可行，但请记住，继承应该谨慎使用；不清楚是否有足够的专业行为来证明创建所有这些子类是合理的。选项2提供了恰到好处的定制，而不需要太多的额外努力。请记住，Bark在重构消息时应该继续以相同的方式运行——你重构只是为了让自己开发更容易。
- en: Try it yourself, and come back to the following two listings for help, or look
    at the full source code for this chapter (see [https://github.com/daneah/practices-of-the-python-pro](https://github.com/daneah/practices-of-the-python-pro)).
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下，然后回到以下两个列表以获取帮助，或者查看本章的完整源代码（见[https://github.com/daneah/practices-of-the-python-pro](https://github.com/daneah/practices-of-the-python-pro))）。
- en: Listing 10.8\. Decoupling layers of abstraction with interfaces
  id: totrans-1158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.8\. 使用接口解耦抽象层
- en: '[PRE88]'
  id: totrans-1159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '***1* The AddBookmarkCommand succeeds but doesn’t return a result.**'
  id: totrans-1160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* AddBookmarkCommand成功执行但未返回结果。**'
- en: '***2* The return value is a True status and a None result.**'
  id: totrans-1161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 返回值是一个True状态和一个None结果。**'
- en: '***3* The ListBookmarksCommand succeeds and returns a list of bookmarks.**'
  id: totrans-1162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* `ListBookmarksCommand`成功并返回书签列表。**'
- en: '***4* The return value is a True status and the bookmark list.**'
  id: totrans-1163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 返回值是True状态和书签列表。**'
- en: Listing 10.9\. Using statuses and results in the presentation layer
  id: totrans-1164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.9。在表示层中使用状态和结果
- en: '[PRE89]'
  id: totrans-1165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '***1* The default message for commands that return a result is the result itself.**'
  id: totrans-1166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 返回结果的命令的默认消息是结果本身。**'
- en: '***2* Stores the configured success message for this option for later use**'
  id: totrans-1167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 存储此选项配置的成功消息以供以后使用**'
- en: '***3* Receives the status and result from the executed command**'
  id: totrans-1168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 接收执行命令的状态和结果**'
- en: '***4* Formats the result for display if needed**'
  id: totrans-1169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 如果需要，格式化结果以供显示**'
- en: '***5* Prints the success message, inserting the formatted result if needed**'
  id: totrans-1170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 打印成功消息，如果需要则插入格式化的结果**'
- en: '***6* Options without a result can specify a static success message.**'
  id: totrans-1171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 没有结果的选项可以指定一个静态的成功消息。**'
- en: '***7* Options that should print only the result don’t need to specify a message.**'
  id: totrans-1172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 应仅打印结果的选项不需要指定消息。**'
- en: '***8* Options that have a result and a custom message can put both together.**'
  id: totrans-1173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 具有结果和自定义信息的选项可以将两者合并。**'
- en: Congratulations! You’ve decoupled the business logic and presentation layer.
    They now interact using the idea of a status and a result instead of a specific
    hardcoded message. In the future, when you’ve built a new mobile frontend for
    Bark, it can use the statuses and results to determine the icons and messaging
    to show on phones.
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已经解耦了业务逻辑和表示层。他们现在使用状态和结果的概念而不是特定的硬编码消息进行交互。在未来，当您为Bark构建新的移动前端时，它可以使用状态和结果来确定手机上显示的图标和消息。
- en: 10.4.2\. Bookmark persistence
  id: totrans-1175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.2. 书签持久性
- en: Your mobile users are always on the go, so you want them to have access to their
    bookmarks from anywhere. The database has to live in the cloud behind an API so
    they can see bookmarks on any of their devices.
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 您的移动用户总是处于移动状态，因此您希望他们能够从任何地方访问他们的书签。数据库必须位于云中，通过API才能让他们在任何设备上查看书签。
- en: As you saw, some areas of your command code are specific to local database operations.
    You need to swap out the database module for a new persistence layer that interacts
    with the new API. By this point, you should remember that shared abstractions
    are a good way to reduce coupling. Although it may sound like a big task, thinking
    about how the local database and the API are similar and different will help you
    conceptualize the abstraction to handle both ([figure 10.8](#ch10fig08)).
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，您的命令代码中的一些区域是针对本地数据库操作的特定部分。您需要用一个新的与新的API交互的持久层替换数据库模块。到这一点，您应该记得共享抽象是减少耦合的好方法。尽管这可能听起来像是一项大任务，但思考本地数据库和API的相似之处和不同之处将帮助您概念化处理两者的抽象（[图10.8](#ch10fig08)）。
- en: Both the database and API persistence layers need to deal with a similar set
    of concerns, despite the differences in some of the details. This is where abstraction
    shines. Just as you reduced each of your commands to an `execute` interface that
    returns a status and result to decouple them from the presentation layer, you
    can reduce your persistence layer to a more general set of CRUD operations to
    decouple it from the commands. Then, any new persistence layer you want to build
    can use the same abstraction.
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在细节上有所不同，但数据库和API持久层都需要处理一系列类似的问题。这正是抽象发挥作用的地方。正如您将每个命令简化为返回状态和结果的`execute`接口以将其从表示层解耦一样，您可以将持久层简化为更通用的CRUD操作以将其从命令解耦。然后，任何您想要构建的新持久层都可以使用相同的抽象。
- en: Figure 10.8\. A database and an API share several commonalities.
  id: totrans-1179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.8。数据库和API共享一些共同点。
- en: '![](../Images/f0220-01_alt.jpg)'
  id: totrans-1180
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0220-01_alt.jpg)'
- en: 10.4.3\. Try it out
  id: totrans-1181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.3. 尝试一下
- en: You’ve got the tools and knowledge you need to decouple your commands from `DatabaseManager`.
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经拥有了将您的命令与`DatabaseManager`解耦所需的工具和知识。
- en: Using an abstract base class, `PersistenceLayer`, to define the interface, create
    a `BookmarkDatabase` persistence layer that will sit between your commands and
    the `DatabaseManager` class, as shown in [figure 10.9](#ch10fig09).
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用抽象基类`PersistenceLayer`定义接口，创建一个位于您的命令和`DatabaseManager`类之间的`BookmarkDatabase`持久层，如图10.9所示。
- en: Figure 10.9\. Decoupling commands from database specifics with an interface
    and specific implementation
  id: totrans-1184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.9。使用接口和具体实现解耦命令与数据库特定性
- en: '![](../Images/f0221-01_alt.jpg)'
  id: totrans-1185
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0221-01_alt.jpg)'
- en: 'Create these classes in a new persistence module; you’ll refactor your commands
    to use this instead of `DatabaseManager` directly. Instead of database- or API-specific
    method names, the interface should provide methods that would apply to most any
    persistence layer:'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的持久化模块中创建这些类；您将重构您的命令以使用此模块而不是直接使用 `DatabaseManager`。接口应提供适用于大多数持久化层的方法，而不是数据库或
    API 特定的方法名称：
- en: '`__init__` for initial configuration'
  id: totrans-1187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__` 用于初始配置'
- en: '`create(data)` to create a new bookmark'
  id: totrans-1188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create(data)` 用于创建新的书签'
- en: '`list(order_by)` to list all bookmarks'
  id: totrans-1189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list(order_by)` 用于列出所有书签'
- en: '`edit(bookmark_id, data)` to update a bookmark'
  id: totrans-1190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`edit(bookmark_id, data)` 用于更新书签'
- en: '`delete(bookmark_id)` to remove a bookmark'
  id: totrans-1191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete(bookmark_id)` 用于删除书签'
- en: The logic in `CreateBookmarksTableCommand` is really the initial configuration
    for a bookmark database persistence layer, so you can move it into `BookmarksDatabase.__init_``_`.
    The instantiation of the `DatabaseManager` fits well there too. You can then write
    the implementation for each method of the `PersistenceLayer` abstraction in `BookmarksDatabase`.
    Each database-centric method call (`db.add`, for example) from your original commands
    can be moved into the appropriate method, freeing up the commands to call the
    methods from `BookmarksDatabase`. Give this a go, referencing the following listing
    and the full source code for this chapter as you go along.
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateBookmarksTableCommand` 中的逻辑实际上是书签数据库持久化层的初始配置，因此您可以将其移动到 `BookmarksDatabase.__init__`。`DatabaseManager`
    的实例化也很好地适应了那里。然后您可以在 `BookmarksDatabase` 中编写 `PersistenceLayer` 抽象的每个方法的实现。您原始命令中的每个数据库中心方法调用（例如
    `db.add`）都可以移动到适当的方法中，从而释放命令调用 `BookmarksDatabase` 的方法。尝试一下，在过程中参考以下列表和本章的完整源代码。'
- en: Listing 10.10\. A persistence interface and implementation
  id: totrans-1193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.10\. 一个持久化接口及其实现
- en: '[PRE90]'
  id: totrans-1194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '***1* The abstract base class that defines the persistence layer interface**'
  id: totrans-1195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义持久化层接口的抽象基类***'
- en: '***2* Each method corresponds to a CRUD-like operation for persistence.**'
  id: totrans-1196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 每个方法对应持久化的 CRUD 操作。***'
- en: '***3* A specific persistence layer implementation that uses a database**'
  id: totrans-1197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用数据库的特定持久化层实现。***'
- en: '***4* Handles database creation with DatabaseManager**'
  id: totrans-1198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用 DatabaseManager 处理数据库创建。***'
- en: '***5* Database-specific implementation for each of the behaviors of the interface**'
  id: totrans-1199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 接口每个行为的数据库特定实现。***'
- en: Now that you have the interface for a persistence layer and a specific implementation
    of that interface that knows how to use `DatabaseManager` to persist bookmarks,
    you’re ready to update your commands to depend on the `PersistenceLayer` interface
    instead of `DatabaseManager`. In the commands module, replace the `db` instance
    of `DatabaseManager` with `persistence`, an instance of `BookmarkDatabas``e`.
    Then go through the rest of the module, replacing calls to `DatabaseManager` methods
    (like `db.select`) with those from `PersistenceLayer` (like `persistence.list`).
    Refer to the following listing to check your work.
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有了持久化层的接口以及该接口的特定实现，该实现知道如何使用 `DatabaseManager` 来持久化书签，您就可以更新您的命令，使其依赖于
    `PersistenceLayer` 接口而不是 `DatabaseManager`。在命令模块中，将 `DatabaseManager` 的 `db` 实例替换为
    `persistence`，即 `BookmarkDatabase` 的一个实例。然后遍历模块的其余部分，将 `DatabaseManager` 方法的调用（如
    `db.select`）替换为 `PersistenceLayer` 的调用（如 `persistence.list`）。参考以下列表来检查您的作品。
- en: Listing 10.11\. Updating business logic to use abstraction
  id: totrans-1201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.11\. 更新业务逻辑以使用抽象
- en: '[PRE91]'
  id: totrans-1202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '***1* Imports BookmarksDatabase in place of DatabaseManager**'
  id: totrans-1203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 用 BookmarksDatabase 替代 DatabaseManager 的导入。***'
- en: '***2* Sets up the persistence layer (This can be swapped in the future.)**'
  id: totrans-1204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 设置持久化层（将来可以替换）。***'
- en: '***3* persistence.create takes the place of db.add.**'
  id: totrans-1205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* persistence.create 替代了 db.add。***'
- en: '***4* persistence.list takes the place of db.select.**'
  id: totrans-1206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* persistence.list 替代了 db.select。***'
- en: '***5* persistence.delete takes the place of db.delete.**'
  id: totrans-1207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* persistence.delete 替代了 db.delete。***'
- en: '***6* persistence.edit takes the place of db.update.**'
  id: totrans-1208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* persistence.edit 替代了 db.update。***'
- en: Bark is now extensible to new use cases like importing stars from GitHub. Its
    concerns are well-separated so that you can reason about the presentation, business
    logic, and persistence in isolation. It’s now feasible to swap any of those layers
    out to realize distinct new use cases.
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: Bark 现在可以扩展到新的用例，如从 GitHub 导入星星。其关注点很好地分离，以便您可以独立地推理表示、业务逻辑和持久化。现在可以交换任何这些层以实现不同的新用例。
- en: You could swap `BookmarksDatabase` for, say, a `BookmarksStorageService` that
    sends bookmark data via an HTTP API to the cloud. You could also swap in a `DummyBookmarksDatabase`
    for testing that only persists bookmarks in memory for the duration of the tests.
    Loose coupling is rife with opportunities! I strongly encourage you to explore
    a few of these on your own.
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`BookmarksDatabase`替换为，比如说，一个`BookmarksStorageService`，它通过HTTP API将书签数据发送到云端。你也可以在测试时使用`DummyBookmarksDatabase`来替换，这样测试期间书签只保存在内存中。松耦合充满了机会！我强烈建议你自己探索其中的一些。
- en: The principles you’ve applied to Bark carry over readily to many real-world
    projects. By applying what you’ve learned here to your own projects, you’ll be
    able to increase maintainability as well as help others pick up your code and
    make sense of it. I can’t express just how much value this holds as you continue
    building software.
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 你应用到Bark的原则可以轻易地应用到许多现实世界的项目中。通过将在这里学到的知识应用到你的项目中，你将能够提高可维护性，并帮助他人理解你的代码。随着你继续构建软件，这种价值是无法用言语表达的。
- en: In the last part of this book, we’ll recap the breadth of what you’ve learned
    and look at some recommendations for what to explore next. See you there!
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的最后一部分，我们将回顾你所学到的一切，并探讨一些关于下一步探索的建议。那里见！
- en: Summary
  id: totrans-1213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Separate concerns, encapsulate data and behaviors, and then create shared abstractions
    to loosen coupling.
  id: totrans-1214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将关注点分开，封装数据和行为，然后创建共享的抽象来松耦合。
- en: Classes that know and use many details of another class may need to be subsumed
    by that class.
  id: totrans-1215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解并使用另一个类许多细节的类可能需要被那个类所包含。
- en: Tight coupling can be addressed by re-encapsulation with stronger cohesion,
    but it can often be well-served by the introduction of a new abstraction shared
    by both parties. (For example, a menu and a command may rely on the command returning
    a status and a result instead of specific messaging.)
  id: totrans-1216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过更强的内聚性重新封装可以解决紧密耦合的问题，但引入一个双方共享的新抽象层通常也能很好地解决问题。（例如，一个菜单和一个命令可能依赖于命令返回状态和结果，而不是特定的消息。）
