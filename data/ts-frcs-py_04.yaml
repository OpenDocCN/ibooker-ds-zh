- en: 3 Going on a random walk
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 随机游走之旅
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Identifying a random walk process
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别随机游走过程
- en: Understanding the ACF function
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解自相关函数（ACF）功能
- en: Classifying differencing, stationarity, and white noise
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分类差分、平稳性和白噪声
- en: Using the ACF plot and differencing to identify a random walk
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自相关图和差分来识别随机游走
- en: Forecasting a random walk
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预测随机游走
- en: In the previous chapter, we compared different naive forecasting methods and
    learned that they often serve as benchmarks for more sophisticated models. However,
    there are instances where the simplest methods will yield the best forecasts.
    This is the case when we face a random walk process.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们比较了不同的简单预测方法，并了解到它们通常作为更复杂模型的基准。然而，在某些情况下，最简单的方法会产生最佳的预测结果。当我们面对随机游走过程时，情况就是这样。
- en: In this chapter, you will learn what a random walk process is, how to recognize
    it, and how to make forecasts using random walk models. Along the way, we will
    look at the concepts of differencing, stationarity, and white noise, which will
    come back in later chapters as we develop more advanced statistical learning models.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习什么是随机游走过程，如何识别它，以及如何使用随机游走模型进行预测。在这个过程中，我们将探讨差分、平稳性和白噪声的概念，这些概念将在我们开发更高级的统计学习模型时在后续章节中再次出现。
- en: For this chapter’s examples, suppose that you want to buy shares of Alphabet
    Inc. (GOOGL). Ideally, you would want to buy if the closing price of the stock
    is expected to go up in the future; otherwise, your investment will not be profitable.
    Hence, you decide to collect data on the daily closing price of GOOGL over 1 year
    and use time series forecasting to determine the future closing price of the stock.
    The closing price of GOOGL from April 27, 2020, to April 27, 2021, is shown in
    figure 3.1\. At the time of writing, data beyond April 27, 2021, was not available
    yet.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的示例，假设你想购买Alphabet Inc.（GOOGL）的股票。理想情况下，如果你预计股票的收盘价未来会上涨，那么你就应该买入；否则，你的投资将不会盈利。因此，你决定收集GOOGL过去一年的每日收盘价数据，并使用时间序列预测来确定股票的未来收盘价。GOOGL从2020年4月27日到2021年4月27日的收盘价如图3.1所示。在撰写本文时，2021年4月27日之后的数据尚未可用。
- en: '![](../../OEBPS/Images/03-01.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/03-01.png)'
- en: Figure 3.1 Daily closing price of GOOGL from April 27, 2020, to April 27, 2021
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 2020年4月27日至2021年4月27日GOOGL的每日收盘价
- en: In figure 3.1 you can clearly see a long-term trend, since the closing price
    increased between April 27, 2020, and April 27, 2021\. However, there are also
    abrupt changes in the trend, with periods where it sharply decreases before suddenly
    increasing again.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在图3.1中，你可以清楚地看到长期趋势，因为从2020年4月27日到2021年4月27日，收盘价一直在上升。然而，趋势中也有突然的变化，有时它会急剧下降，然后又突然上升。
- en: It turns out that the daily closing price of GOOGL can be modeled using the
    random walk model. To do so, we will first determine whether our process is *stationary*
    or not. If it is a non-stationary process, we will have to apply transformations,
    such as *differencing*, in order to make it stationary. Then we will be able to
    use the *autocorrelation function* plot to conclude that the daily closing price
    of GOOGL can be approximated by the random walk model. Both differencing and the
    autocorrelation plot will be covered in this chapter. Finally, we’ll wrap up the
    chapter with forecasting methods that attempt to predict the future closing price
    of GOOGL.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，GOOGL的每日收盘价可以使用随机游走模型进行建模。为此，我们首先将确定我们的过程是否是平稳的。如果它是一个非平稳过程，我们必须应用如差分之类的转换，使其变得平稳。然后我们将能够使用自相关函数图来得出结论，即GOOGL的每日收盘价可以用随机游走模型近似。差分和自相关图将在本章中介绍。最后，我们将本章以尝试预测GOOGL未来收盘价的预测方法结束。
- en: By the end of this chapter, you will have mastered the concepts of stationarity,
    differencing, and autocorrelation, which will return in later chapters as we further
    develop our forecasting skills. For now, let’s focus on defining the random walk
    process.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将掌握平稳性、差分和自相关性的概念，这些概念将在我们进一步发展预测技能时在后续章节中再次出现。现在，让我们专注于定义随机游走过程。
- en: 3.1 The random walk process
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 随机游走过程
- en: A *random walk* is a process in which there is an equal chance of going up or
    down by a random number. This is usually observed in financial and economic data,
    like the daily closing price of GOOGL. Random walks often expose long periods
    where a positive or negative trend can be observed. They are also often accompanied
    by sudden changes in direction.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 随机游走是一个过程，其中以随机数上升或下降的概率相等。这通常在金融和经济数据中观察到，如 GOOGL 的每日收盘价。随机游走经常暴露出可以观察到正或负趋势的长周期。它们也经常伴随着方向的突然变化。
- en: In a random walk process, we say that the present value *y[t]* is a function
    of the value at the previous timestep *y*[*t*–1], a constant C, and a random number
    *ϵ[*t*]*, also termed *white noise*. Here, *ϵ[*t*]* is the realization of the
    standard normal distribution, which has a variance of 1 and a mean of 0.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在随机游走过程中，我们说当前值 *y[t]* 是前一时间步的值 *y*[*t*–1]、常数 C 和随机数 *ϵ[*t*]*（也称为白噪声）的函数。在这里，*ϵ[*t*]*
    是标准正态分布的实现，其方差为 1，均值为 0。
- en: Therefore, we can mathematically express a random walk with the following equation,
    where *y[t]* is the value at the present time *t*, C is a constant, *y*[*t*–1]
    is the value at the previous timestep *t*–1, and *ϵ[*t*]* is a random number.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以用以下方程式数学地表达一个随机游走，其中 *y[t]* 是当前时间 *t* 的值，C 是一个常数，*y*[*t*–1] 是前一时间步 *t*–1
    的值，而 *ϵ[*t*]* 是一个随机数。
- en: '*y[t]* = C + *y*[*t*–1] + *ϵ[*t*]*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*y[t]* = C + *y*[*t*–1] + *ϵ[*t*]*'
- en: Equation 3.1
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 方程式 3.1
- en: Note that if the constant C is nonzero, we designate this process as a random
    walk with drift.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果常数 C 不为零，我们将其指定为有漂移的随机游走。
- en: 3.1.1 Simulating a random walk process
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1 模拟随机游走过程
- en: To help you understand the random walk process, let’s simulate one with Python—that
    way you can understand how a random walk behaves, and we can study its properties
    in a purely theoretical scenario. Then we’ll transpose our knowledge onto our
    real-life example, where we’ll model and forecast the closing price of GOOGL.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您理解随机游走过程，让我们用 Python 模拟一个——这样您可以了解随机游走是如何表现的，我们可以在纯粹的理论场景中研究其属性。然后我们将我们的知识应用到我们的现实生活例子中，我们将模拟和预测
    GOOGL 的收盘价。
- en: From equation 3.1, we know that a random walk depends on its previous value
    *y*[*t*–1] plus white noise ϵ[*t*] and some constant C. To simplify our simulation,
    let’s assume that the constant C is 0\. That way, our simulated random walk can
    be expressed as
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从方程式 3.1，我们知道随机游走取决于其前一个值 *y*[*t*–1]、白噪声 ϵ[*t*] 和一些常数 C。为了简化我们的模拟，让我们假设常数 C
    为 0。这样，我们的模拟随机游走可以表示为
- en: '*y[t]* = *y*[*t*–1] + *ϵ[t]*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*y[t]* = *y*[*t*–1] + *ϵ[t]*'
- en: Equation 3.2
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 方程式 3.2
- en: Now we must choose the first value of our simulated sequence. Again, for simplification,
    we will initialize our sequence at 0\. This will be the value of *y*[0].
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须选择我们模拟序列的第一个值。同样，为了简化，我们将序列初始化为 0。这将 *y*[0] 的值。
- en: We can now start building our sequence using equation 3.2\. We’ll start off
    with our initial value of 0 at time *t* = 0. Then, from equation 3.2, the value
    at *t* = 1, represented by *y*[1] will be equal to the previous value *y*[0] plus
    white noise.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始使用方程式 3.2 构建我们的序列。我们将从时间 *t* = 0 的初始值 0 开始。然后，根据方程式 3.2，时间 *t* = 1
    的值，表示为 *y*[1]，将等于前一个值 *y*[0] 加上白噪声。
- en: '*y*[0] = 0'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*[0] = 0'
- en: '*y*[1] = *y*[0] + ϵ[1] = 0 + ϵ[1] = ϵ[1]'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*[1] = *y*[0] + ϵ[1] = 0 + ϵ[1] = ϵ[1]'
- en: Equation 3.3
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 方程式 3.3
- en: The value at *t* = 2, denoted as *y*[2], will be equal to the value at the previous
    step, which is *y*[1], plus some white noise.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 时间 *t* = 2 的值，表示为 *y*[2]，将等于前一步的值，即 *y*[1]，加上一些白噪声。
- en: '*y*[1] = ϵ[1]'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*[1] = ϵ[1]'
- en: '*y*[2] = *y*[1] + ϵ[2] = ϵ[1] + ϵ[2]'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*[2] = *y*[1] + ϵ[2] = ϵ[1] + ϵ[2]'
- en: Equation 3.4
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 方程式 3.4
- en: Then the value at *t* = 3, denoted as *y*[2], will be equal to the value at
    the previous step, which is *y*[2], plus some white noise.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然后时间 *t* = 3 的值，表示为 *y*[2]，将等于前一步的值，即 *y*[2]，加上一些白噪声。
- en: '*y*[2] = ϵ[1] + ϵ[2]'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*[2] = ϵ[1] + ϵ[2]'
- en: '*y*[3] = *y*[2] + ϵ[3] = ϵ[1] + ϵ[2] + ϵ[3]'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*[3] = *y*[2] + ϵ[3] = ϵ[1] + ϵ[2] + ϵ[3]'
- en: Equation 3.5
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 方程式 3.5
- en: Looking at equation 3.5, you should start seeing a pattern. By initializing
    our random walk process at 0 and setting the constant C to 0, we determine that
    the value at time *t* is simply the sum of white noise from *t* = 1 to time *t*.
    Thus, our simulated random walk will respect the equation 3.6, where *y[t]* is
    the value of the random walk process at time *t*, and ϵ*t* is a random number
    at time *t*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 观察方程式 3.5，你应该开始看到一种模式。通过将我们的随机游走过程初始化为 0 并将常数 C 设置为 0，我们确定时间 *t* 的值仅仅是时间 *t*
    = 1 到时间 *t* 的白噪声之和。因此，我们的模拟随机游走将遵循方程式 3.6，其中 *y[t]* 是时间 *t* 的随机游走过程的值，而 ϵ*t* 是时间
    *t* 的一个随机数。
- en: '![](../../OEBPS/Images/03-01-Equation-3-6.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![方程式3-6](../../OEBPS/Images/03-01-Equation-3-6.png)'
- en: Equation 3.6
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 方程式3.6
- en: Equation 3.6 establishes that at any point in time *t*, the value of our simulated
    time series will be the cumulative sum of a series of random numbers. We can visualize
    how our simulated random walk takes shape in figure 3.2.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 方程式3.6表明，在任意时间点t，我们模拟的时间序列的值将是随机数序列的累积和。我们可以在图3.2中可视化我们的模拟随机游走。
- en: '![](../../OEBPS/Images/03-02.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图3-02](../../OEBPS/Images/03-02.png)'
- en: Figure 3.2 Visualizing the construction of our simulated random walk. As you
    can see, our initial value is 0\. Then, since the constant was also set to 0,
    the value of our random walk at any point in time is simply the cumulative sum
    of random numbers, or white noise.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 可视化我们模拟随机游走的构建。正如你所见，我们的初始值是0。然后，由于常数也被设为0，我们随机游走在任何时间点的值仅仅是随机数的累积和，或者说是白噪声。
- en: We are now ready to simulate our random process using Python. In order for this
    exercise to be reproducible, we will need to set a *seed*, which is an integer
    that we pass to the `random.seed` method. That way, no matter how many times we
    run the code, the same random numbers will be generated. This ensures that you
    will obtain the same results and plot as outlined in this chapter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用Python来模拟我们的随机过程。为了使这个练习可重复，我们需要设置一个*种子*，这是一个传递给`random.seed`方法的整数。这样，无论我们运行代码多少次，都会生成相同的随机数。这确保了你将获得与本章中概述的相同的结果和图表。
- en: 'Note At any time, you can refer to the source code for this chapter here: [https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH03](https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH03).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在任何时候，你都可以在这里查看本章的源代码：[https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH03](https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH03)。
- en: 'Then we must decide on the length of our simulated process. For this exercise,
    we will generate 1,000 samples. The `numpy` library allows us to generate numbers
    from a normal distribution by using the `standard_normal` method. This ensures
    that the numbers come from a distribution with mean of 0, as per the definition
    of white noise; I’ve also given it a variance of 1 (a normal distribution). Then
    we can set the very first value of our series to 0\. Finally, the `cumsum` method
    will calculate the cumulative sum of white noise for each timestep in our series,
    and we will have simulated our random walk:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须决定模拟过程的长度。在这个练习中，我们将生成1,000个样本。`numpy`库允许我们通过使用`standard_normal`方法从正态分布中生成数字。这确保了数字来自均值为0的分布，正如白噪声的定义；我还给它设定了方差为1（一个正态分布）。然后我们可以将序列的第一个值设为0。最后，`cumsum`方法将计算序列中每个时间步长的白噪声的累积和，我们就可以模拟随机游走了：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Set the random seed. This is done by passing an integer, in this case 42.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 设置随机种子。这是通过传递一个整数来完成的，在这个例子中是42。
- en: ❷ Generate 1,000 random numbers from a normal distribution with a mean of 0
    and variance of 1.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从均值为0和方差为1的正态分布中生成1,000个随机数。
- en: ❸ Initialize the first value of the series to 0.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将序列的第一个值初始化为0。
- en: ❹ Calculate the cumulative sum of errors for each timestep in the simulated
    process.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 计算模拟过程中每个时间步长的误差累积和。
- en: 'We can plot our simulated random walk and see what it looks like. Since our
    *x*-axis and *y*-axis do not have a real-life meaning, we will simply label them
    as “timesteps” and “value,” respectively. The following code block generates figure
    3.3:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以绘制我们的模拟随机游走并查看其外观。由于我们的x轴和y轴没有现实生活中的意义，我们将简单地将其标记为“时间步长”和“值”。以下代码块生成了图3.3：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can see the defining characteristics of a random walk in figure 3.3\. You’ll
    notice a positive trend over the first 400 timesteps, followed by a negative trend,
    and a sharp increase toward the end. Therefore, we have both sudden changes and
    long periods where a trend is observed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在图3.3中看到随机游走的定义特征。你会注意到在前400个时间步长中有一个正向趋势，随后转为负向趋势，并在最后急剧上升。因此，我们既有突然的变化，也有观察到趋势的长时期。
- en: '![](../../OEBPS/Images/03-03.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图3-03](../../OEBPS/Images/03-03.png)'
- en: Figure 3.3 A simulated random walk. Notice how we have a positive trend during
    the first 400 timesteps, followed by a negative trend, and a sharp increase toward
    the end. These are good hints that we have a random walk process.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 模拟随机游走。注意我们如何在最初的400个时间步长中呈现出一个正向趋势，随后转为负向趋势，并在最后急剧上升。这些都是我们有一个随机游走过程的良好线索。
- en: We know this is a random walk because we simulated it. However, when dealing
    with real-life data, we need to find a way to identify whether our time series
    is a random walk or not. Let’s see how we can achieve this.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道这是一个随机游走，因为我们模拟了它。然而，当处理现实生活中的数据时，我们需要找到一种方法来识别我们的时间序列是否是随机游走。让我们看看我们如何实现这一点。
- en: 3.2 Identifying a random walk
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 识别随机游走
- en: To determine if our time series can be approximated as a random walk or not,
    we must first define a random walk. In the context of time series, a *random walk*
    is defined as a series whose first difference is stationary and uncorrelated.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定我们的时间序列是否可以近似为随机游走，我们首先必须定义随机游走。在时间序列的背景下，**随机游走**被定义为第一差分是平稳且不相关的序列。
- en: Random walk
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 随机游走
- en: A random walk is a series whose first difference is stationary and uncorrelated.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 随机游走是一个第一差分是平稳且不相关的序列。
- en: This means that the process moves completely at random.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着过程完全随机移动。
- en: I’ve just introduced a lot of new concepts in a single sentence, so let’s break
    down the steps to identify a random walk into a process. The steps are outlined
    in figure 3.4.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我刚刚在一句话中介绍了很多新的概念，所以让我们将识别随机游走过程的步骤分解一下。这些步骤在图3.4中有所概述。
- en: '![](../../OEBPS/Images/03-04.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/03-04.png)'
- en: Figure 3.4 Steps to follow to identify whether time series data can be approximated
    as a random walk or not. The first step is naturally to gather the data. Then
    we test for stationarity. If it is not stationary, we apply transformations until
    stationarity is achieved. Then we can plot the autocorrelation function (ACF).
    If there is no autocorrelation, we have a random walk.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 检验时间序列数据是否可以近似为随机游走的步骤。第一步自然是收集数据。然后我们测试平稳性。如果它不是平稳的，我们应用变换直到达到平稳性。然后我们可以绘制自相关函数（ACF）。如果没有自相关，我们就有了一个随机游走。
- en: In the following subsections, we will cover the concepts of stationarity and
    autocorrelation in detail.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的小节中，我们将详细讨论平稳性和自相关的概念。
- en: 3.2.1 Stationarity
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 平稳性
- en: A *stationary time series* is one whose statistical properties do not change
    over time. In other words, it has a constant mean, variance, and autocorrelation,
    and these properties are independent of time.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**平稳时间序列**是指其统计属性随时间不发生变化的时间序列。换句话说，它具有恒定的均值、方差和自相关，并且这些属性与时间无关。
- en: Many forecasting models assume stationarity. The moving average model (chapter
    4), autoregressive model (chapter 5), and autoregressive moving average model
    (chapter 6) all assume stationarity. These models can only be used if we verify
    that the data is indeed stationary. Otherwise, the models will not be valid, and
    the forecasts will not be reliable. Intuitively, this makes sense, because if
    the data is non-stationary, its properties are going to change over time, which
    would mean that our model parameters must also change through time. This means
    that we cannot possibly derive a function of future values as a function of past
    values, since the coefficients change at each point in time, making forecasting
    unreliable.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 许多预测模型都假设平稳性。移动平均模型（第4章）、自回归模型（第5章）和自回归移动平均模型（第6章）都假设平稳性。只有在我们验证数据确实是平稳的情况下，这些模型才能使用。否则，模型将无效，预测将不可靠。直观上，这是有道理的，因为如果数据是非平稳的，其属性会随时间变化，这意味着我们的模型参数也必须随时间变化。这意味着我们不可能从过去值推导出未来值的函数，因为系数在每一个时间点都会变化，这使得预测不可靠。
- en: We can view stationarity as an assumption that can make our lives easier when
    forecasting. Of course, we will rarely see a stationary time series in its original
    state because we are often interested in forecasting processes with a trend or
    with seasonal cycles. This is when models like ARIMA (chapter 7) and SARIMA (chapter
    8) come into play.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将平稳性视为一个假设，它可以使我们的预测工作更加容易。当然，我们很少会看到原始状态下的平稳时间序列，因为我们通常对具有趋势或季节性周期的预测过程感兴趣。这就是ARIMA（第7章）和SARIMA（第8章）模型发挥作用的时候。
- en: Stationarity
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 平稳性
- en: A stationary process is one whose statistical properties do not change over
    time.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一个平稳过程是指其统计属性随时间不发生变化的过程。
- en: A times series is said to be stationary if its mean, variance, and autocorrelation
    do not change over time.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一个时间序列如果其均值、方差和自相关随时间不发生变化，则被称为平稳的。
- en: For now, since we are still in the early stages of time series forecasting,
    we’ll focus on stationary time series, which means that we will need to find ways
    to *transform* our time series to make them stationary. A transformation is simply
    a mathematical manipulation of the data that stabilizes its mean and variance,
    thus making it stationary.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，由于我们仍处于时间序列预测的早期阶段，我们将专注于平稳时间序列，这意味着我们需要找到将我们的时间序列转换为平稳状态的方法。变换仅仅是数据的数学操作，以稳定其均值和方差，从而使其平稳。
- en: The simplest transformation one can apply is differencing. This transformation
    helps stabilize the mean, which in turn removes or reduces the trend and seasonality
    effects. Differencing involves calculating the series of changes from one timestep
    to another. To accomplish that, we simply subtract the value of the previous timestep
    *y*[*t*–1] from the value in the present *y[t]* to obtain the differenced value
    *y'[t]*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 可以应用的最简单的变换是差分。这种变换有助于稳定均值，从而消除或减少趋势和季节性影响。差分涉及计算从一个时间步到另一个时间步的变化序列。为了实现这一点，我们只需从当前时间步的值
    *y[t]* 中减去前一个时间步的值 *y*[*t*–1]，以获得差分值 *y'[t]*。
- en: '*y''[t]* = *y[t]*– *y*[*t*–1]'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*y''[t]* = *y[t]* – *y*[*t*–1]'
- en: Equation 3.7
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 方程式3.7
- en: Transformation in time series forecasting
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列预测中的变换
- en: A transformation is a mathematical operation applied to a time series in order
    to make it stationary.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 变换是对时间序列应用的一种数学运算，以使其平稳。
- en: Differencing is a transformation that calculates the change from one timestep
    to another. This transformation is useful for stabilizing the mean.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 差分是一种计算从一个时间步到另一个时间步变化的变换。这种变换对于稳定均值是有用的。
- en: Applying a log function to the series can stabilize its variance.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对序列应用对数函数可以稳定其方差。
- en: Figure 3.5 illustrates the process of differencing. Notice that taking the difference
    makes us lose one data point, because at the initial point in time, we cannot
    take the difference with its previous step, since *t* = –1 does not exist.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 阐述了差分的过程。注意，进行差分会使我们失去一个数据点，因为在初始时间点，我们无法与之前的时间步进行差分，因为 *t* = –1 不存在。
- en: '![](../../OEBPS/Images/03-05.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/03-05.png)'
- en: Figure 3.5 Visualizing the differencing transformation. Here, a first-order
    differencing is applied. Notice how we lose one data point after this transformation
    because the initial point in time cannot be differenced with previous values since
    they do not exist.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 展示了差分变换的可视化。在这里，应用了一阶差分。注意，在这个变换之后我们失去了一个数据点，因为初始时间点不能与之前的时间点进行差分，因为它们不存在。
- en: It is possible to difference a time series many times. Taking the difference
    once is applying a *first-order* differencing. Taking it a second time would be
    a *second-order* differencing. It is often not necessary to difference more than
    twice to obtain a stationary series.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列可以进行多次差分。进行一次差分是应用一阶差分。进行第二次差分则是一阶差分。通常不需要进行超过两次的差分来获得一个平稳序列。
- en: While differencing is used to obtain a constant mean through time, we must also
    make sure we have a constant variance in order for our process to be stationary.
    Logarithms are used to help stabilize the variance.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然差分用于通过时间获得恒定的均值，但我们还必须确保我们有一个恒定的方差，以便我们的过程是平稳的。对数用于帮助稳定方差。
- en: Keep in mind that when we model a time series that has been transformed, we
    must *untransform* it to return the results of the model to the original units
    of measurement. The formal term for undoing a transformation is *inverse transform*.
    Therefore, if you apply a log transformation to your data, make sure you raise
    your forecast values to the power of 10 in order to bring the values back to their
    original magnitude. That way, your predictions will make sense in their original
    context.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当我们对一个已经变换的时间序列进行建模时，我们必须对其进行*逆变换*，以便将模型的结果返回到原始的测量单位。撤销变换的正式术语是*逆变换*。因此，如果您对数据进行对数变换，请确保将您的预测值提高到10的幂，以便将值恢复到其原始幅度。这样，您的预测将在原始上下文中是有意义的。
- en: Now that we know what type of transformations we need to apply on a time series
    to make it stationary, we need to find a way to test whether a series is stationary
    or not.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了需要对时间序列应用哪种类型的变换以使其平稳，我们需要找到一种方法来测试一个序列是否平稳。
- en: 3.2.2 Testing for stationarity
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.2 平稳性检验
- en: Once a transformation is applied to a time series, we need to test for stationarity
    to determine if we need to apply another transformation to make the time series
    stationary, or if we need to transform it at all. A common test is the augmented
    Dickey-Fuller (ADF) test.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦对一个时间序列应用了转换，我们需要测试其平稳性，以确定是否需要应用另一个转换使时间序列平稳，或者是否需要对其进行转换。一个常见的测试是增强迪基-富勒（ADF）测试。
- en: 'The ADF test verifies the following null hypothesis: there is a unit root present
    in a time series. The alternative hypothesis is that there is no unit root, and
    therefore the time series is stationary. The result of this test is the ADF statistic,
    which is a negative number. The more negative it is, the stronger the rejection
    of the null hypothesis. In its implementation in Python, the p-value is also returned.
    If its value is less than 0.05, we can also reject the null hypothesis and say
    the series is stationary.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ADF 测试验证以下原假设：时间序列中存在一个单位根。备择假设是不存在单位根，因此时间序列是平稳的。这个测试的结果是 ADF 统计量，它是一个负数。它越负，对原假设的拒绝就越强。在其
    Python 实现中，也会返回 p 值。如果其值小于 0.05，我们也可以拒绝原假设，并说序列是平稳的。
- en: Augmented Dickey-Fuller (ADF) test
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 增强迪基-富勒（ADF）测试
- en: The augmented Dickey-Fuller (ADF) test helps us determine if a time series is
    stationary by testing for the presence of a unit root. If a unit root is present,
    the time series is not stationary.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 增强迪基-富勒（ADF）测试通过测试单位根的存在来帮助我们确定时间序列是否平稳。如果存在单位根，则时间序列不是平稳的。
- en: The null hypothesis states that a unit root is present, meaning that our time
    series is not stationary.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 原假设表明存在一个单位根，这意味着我们的时间序列不是平稳的。
- en: 'Let’s consider a very simple time series where the present value *y[t]* only
    depends on its past value *y*[*t*–1] subject to a coefficient α[1], a constant
    C, and white noise *ϵ[*t*]*. We can write the following general expression:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个非常简单的时间序列，其中当前值 *y[t]* 只取决于其过去值 *y*[*t*–1]，在系数 α[1]、常数 C 和白噪声 *ϵ[*t*]*
    的作用下。我们可以写出以下一般表达式：
- en: '*y[t]* = C + α[1]*y*[*t*–1] + *ϵ[*t*]*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*y[t]* = C + α[1]*y*[*t*–1] + *ϵ[*t*]*'
- en: Equation 3.8
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 方程式 3.8
- en: In equation 3.8, *ϵ[*t*]* represents some error that we cannot predict, and
    C is a constant. Here, α[1] is the root of the time series. This time series will
    be stationary only if the root lies within the unit circle. Therefore, its value
    must be between –1 and 1\. Otherwise the series is non-stationary.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在方程式 3.8 中，*ϵ[*t*]* 代表一些我们无法预测的错误，C 是一个常数。在这里，α[1] 是时间序列的根。这个时间序列只有在根位于单位圆内时才是平稳的。因此，它的值必须在
    –1 和 1 之间。否则，序列是非平稳的。
- en: Let’s verify this by simulating two different series. One will be stationary
    and the other will have a unit root, meaning that it will not be stationary. The
    stationary process follows equation 3.9, and the non-stationary process follows
    equation 3.10.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过模拟两个不同的序列来验证这一点。一个将是平稳的，另一个将有一个单位根，这意味着它将不会是平稳的。平稳过程遵循方程式 3.9，非平稳过程遵循方程式
    3.10。
- en: '*y[t]* = 0.5*y*[*t*–1] + *ϵ[*t*]*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*y[t]* = 0.5*y*[*t*–1] + *ϵ[*t*]*'
- en: Equation 3.9
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 方程式 3.9
- en: '*y[t]* = *y*[*t*–1] + *ϵ[*t*]*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*y[t]* = *y*[*t*–1] + *ϵ[*t*]*'
- en: Equation 3.10
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 方程式 3.10
- en: In equation 3.9, the root of the series is 0.5\. Since it is between –1 and
    1, this series is stationary. On the other hand, in equation 3.10, the root of
    the series is 1, meaning that it is a unit root. Therefore, we expect this series
    to be non-stationary.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在方程式 3.9 中，序列的根是 0.5。由于它位于 –1 和 1 之间，这个序列是平稳的。另一方面，在方程式 3.10 中，序列的根是 1，这意味着它是一个单位根。因此，我们预计这个序列是非平稳的。
- en: By looking at both series in figure 3.6, we can gain some intuition about how
    stationary and non-stationary series evolve through time. We can see that the
    non-stationary process has long periods of positive and negative trends. However,
    the stationary process does not seem to increase or decrease over the long term.
    This high-level qualitative analysis can help us intuitively determine if a series
    is stationary or not.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过观察图 3.6 中的两个序列，我们可以获得一些关于平稳和非平稳序列随时间演变的直觉。我们可以看到，非平稳过程有长期的正负趋势。然而，平稳过程似乎在长期内没有增加或减少。这种高级定性分析可以帮助我们直观地确定一个序列是否平稳。
- en: '![](../../OEBPS/Images/03-06.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/03-06.png)'
- en: Figure 3.6 Simulated stationary and non-stationary time series over 400 timesteps.
    You can see that the stationary series does not increase or decrease over the
    long term. However, the non-stationary process has long periods of positive and
    negative trends.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6展示了在400个时间步长内模拟的平稳和非平稳时间序列。你可以看到，平稳序列在长期内不会增加或减少。然而，非平稳过程有长期的正负趋势。
- en: A stationary series has constant properties over time, meaning that the mean
    and variance are not a function of time, so let’s plot the mean of each series
    over time. The mean of a stationary process should be flat over time, whereas
    the mean of a non-stationary process should vary.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 平稳序列随时间保持恒定的属性，意味着均值和方差不是时间的函数，因此让我们绘制每个序列随时间的均值。平稳过程的均值应该随时间保持平坦，而非平稳过程的均值应该变化。
- en: '![](../../OEBPS/Images/03-07.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/03-07.png)'
- en: Figure 3.7 Mean of stationary and non-stationary processes over time. You can
    see how the mean of the stationary process becomes constant after the first few
    timesteps. On the other hand, the mean of the non-stationary process is a clear
    function of time, as it is constantly changing.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7展示了平稳和非平稳过程随时间变化的均值。你可以看到，平稳过程的均值在最初的几个时间步之后变得恒定。另一方面，非平稳过程的均值是时间的明显函数，因为它不断变化。
- en: As you can see in figure 3.7, the mean of the stationary process becomes constant
    after the first few timesteps. This is the expected behavior of a stationary process.
    The fact that the mean does not change as a function of time means that it is
    independent of time, as per the definition of a stationary process. However, the
    mean of the non-stationary process is clearly a function of time, as we can see
    it decreasing and increasing again over time. Thus, the presence of a unit root
    makes the mean of the series dependent on time, so the series is not stationary.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如图3.7所示，你可以看到，在经过最初的几个时间步之后，平稳过程的均值变得恒定。这正是平稳过程的预期行为。均值不随时间变化的事实意味着它独立于时间，正如平稳过程的定义。然而，非平稳过程的均值显然是时间的函数，因为我们看到它在时间上有所下降和再次上升。因此，存在单位根使得序列的均值依赖于时间，所以这个序列不是平稳的。
- en: Let’s further prove to ourselves that a unit root is a sign of non-stationarity
    by plotting the variance of each series over time. Again, a stationary series
    will have a constant variance over time, meaning that it is time independent.
    On the other hand, the non-stationary process will have a variance that changes
    over time.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步通过绘制每个序列随时间的方差来证明单位根是非平稳性的一个标志。同样，平稳序列将随时间保持恒定的方差，这意味着它是时间独立的。另一方面，非平稳过程将具有随时间变化的方差。
- en: '![](../../OEBPS/Images/03-08.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/03-08.png)'
- en: Figure 3.8 Variance of the simulated stationary and non-stationary series over
    time. The variance of the stationary process is independent of time, as it is
    constant after the first few timesteps. For the non-stationary process, the variance
    changes over time, meaning that it is not independent.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8展示了模拟的平稳和非平稳序列随时间变化的方差。平稳过程的方差不依赖于时间，因为它在最初的几个时间步之后保持恒定。对于非平稳过程，方差随时间变化，这意味着它不是独立的。
- en: In figure 3.8 we can see that after the first few timesteps the variance of
    the stationary process is constant over time, which follows equation 3.9\. Again,
    this corresponds to the definition of a stationary process, since variance does
    not depend on time. On the other hand, the process with a unit root has a variance
    that depends on time, since it greatly varies over the 400 timesteps. Therefore,
    this series is not stationary.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在图3.8中，我们可以看到，在最初的几个时间步之后，平稳过程的方差随时间保持恒定，这符合方程3.9。同样，这符合平稳过程的定义，因为方差不依赖于时间。另一方面，具有单位根的过程具有随时间变化的方差，因为它在400个时间步长内变化很大。因此，这个序列不是平稳的。
- en: By now, you should be convinced that a series with a unit root is not a stationary
    series. In both figures 3.7 and 3.8, the mean and variance were dependent on time,
    as their values kept changing. Meanwhile, the series with a root of 0.5 displayed
    a constant mean and variance over time, demonstrating that this series is indeed
    stationary.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经确信具有单位根的序列不是平稳序列。在图3.7和图3.8中，均值和方差都依赖于时间，因为它们的值不断变化。同时，具有0.5根的序列在时间上显示出恒定的均值和方差，证明了这一序列确实是平稳的。
- en: All these steps were performed to justify the use of the augmented Dickey-Fuller
    (ADF) test. We know that the ADF test verifies the presence of a unit root in
    the series. The null hypothesis, stating that a unit root is present, means that
    the series is not stationary. If the test returns a p-value less than a certain
    significance level, typically 0.05 or 0.01, then we can reject the null hypothesis,
    meaning that there are no unit roots, and so the series is stationary.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些步骤都是为了证明使用增强迪基-富勒 (ADF) 测试的合理性。我们知道 ADF 测试验证了序列中存在单位根。零假设，即存在单位根，意味着序列不是平稳的。如果测试返回的
    p 值小于某个显著性水平，通常为 0.05 或 0.01，则我们可以拒绝零假设，这意味着没有单位根，因此序列是平稳的。
- en: Once we have a stationary series, we must determine whether there is autocorrelation
    or not. Remember that a random walk is a series whose first difference is stationary
    and uncorrelated. The ADF test takes care of the stationarity portion, but we’ll
    need to use the autocorrelation function to determine if the series is correlated
    or not.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个平稳序列，我们必须确定是否存在自相关。记住，随机游走是一个其第一差分是平稳且不相关的序列。ADF 测试负责平稳性部分，但我们需要使用自相关函数来确定序列是否相关。
- en: 3.2.3 The autocorrelation function
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.3 自相关函数
- en: Once a process is stationary, plotting the autocorrelation function (ACF) is
    a great way to understand what type of process you are analyzing. In this case,
    we will use it to determine if we are studying a random walk or not.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一个过程是平稳的，绘制自相关函数 (ACF) 是理解你正在分析的过程类型的好方法。在这种情况下，我们将使用它来确定我们是否在研究随机游走。
- en: We know that correlation measures the extent of a linear relationship between
    two variables. Autocorrelation therefore measures the linear relationship between
    lagged values of a time series. Thus, the ACF reveals how the correlation between
    any two values changes as the lag increases. Here, the lag is simply the number
    of timesteps separating two values.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，相关系数衡量的是两个变量之间线性关系的程度。因此，自相关衡量的是时间序列滞后值之间的线性关系。因此，ACF 揭示了任何两个值之间的相关性如何随着滞后的增加而变化。在这里，滞后仅仅是两个值之间分离的时间步数。
- en: Autocorrelation function
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 自相关函数
- en: The autocorrelation function (ACF) measures the linear relationship between
    lagged values of a time series.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 自相关函数 (ACF) 衡量的是时间序列滞后值之间的线性关系。
- en: In other words, it measures the correlation of the time series with itself.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，它衡量的是时间序列与其自身之间的相关性。
- en: For example, we can calculate the autocorrelation coefficient between *y[t]*
    and *y*[*t*–1]. In this case, the lag is equal to 1, and the coefficient would
    be denoted as *r*[1]. Similarly, we can calculate the autocorrelation between
    *y[t]* and *y*[*t*–2]. Then the lag would be 2, and the coefficient would be denoted
    as *r*[2]. When we plot the ACF function, the coefficient is the dependent variable,
    while the lag is the independent variable. Note that the autocorrelation coefficient
    at lag 0 will always be equal to 1\. This makes sense intuitively, because the
    linear relationship between a variable and itself at the same timestep should
    be perfect, and therefore equal to 1.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以计算 *y[t]* 和 *y*[*t*–1] 之间的自相关系数。在这种情况下，滞后等于 1，系数将表示为 *r*[1]。同样，我们可以计算
    *y[t]* 和 *y*[*t*–2] 之间的自相关。然后滞后将是 2，系数将表示为 *r*[2]。当我们绘制 ACF 函数时，系数是因变量，而滞后是自变量。请注意，滞后
    0 的自相关系数始终等于 1。这在直观上是有意义的，因为变量在同一时间步长内与其自身的线性关系应该是完美的，因此等于 1。
- en: In the presence of a trend, a plot of the ACF will show that the coefficients
    are high for short lags, and they will decrease linearly as the lag increases.
    If the data is seasonal, the ACF plot will also display cyclical patterns. Therefore,
    plotting the ACF function of a non-stationary process will not give us more information
    than is available by looking at the evolution of our process through time. However,
    plotting the ACF for a stationary process can help us identify the presence of
    a random walk.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在存在趋势的情况下，ACF 的图表将显示短滞后时的系数较高，并且随着滞后的增加，它们将线性下降。如果数据是季节性的，ACF 图表也将显示周期性模式。因此，绘制非平稳过程的
    ACF 函数不会比通过观察过程随时间的变化提供更多信息。然而，绘制平稳过程的 ACF 可以帮助我们识别随机游走的存在。
- en: 3.2.4 Putting it all together
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.4 综合起来
- en: Now that you understand what stationarity is, how to transform a time series
    to make it stationary, what statistical test can be used to assess stationarity,
    and how plotting the ACF function can help you identify the presence of a random
    walk, we can put all these concepts together and apply them in Python. In this
    section, we will work with our simulated data (from section 3.1.1) and cover the
    necessary steps to identify a random walk.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了什么是平稳性，如何将时间序列转换为平稳性，可以使用哪些统计测试来评估平稳性，以及如何通过绘制ACF函数来帮助你识别随机游走的存在，我们可以将这些概念结合起来，并在Python中应用它们。在本节中，我们将使用我们的模拟数据（来自3.1.1节）并介绍识别随机游走的必要步骤。
- en: 'The first step is to determine whether our random walk is stationary or not.
    We know that since there are visible trends in our sequence, it is not stationary.
    Nevertheless, let’s apply the ADF test to make sure. We will use the `statsmodels`
    library, which is a Python library that implements many statistical models and
    tests. To run the ADF test, we simply pass it our array of simulated data. The
    result is a list of different values, but we are mainly interested in the first
    two: the ADF statistic and the p-value.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是确定我们的随机游走是否平稳。我们知道，由于我们的序列中有明显的趋势，它不是平稳的。尽管如此，让我们应用ADF测试以确保。我们将使用`statsmodels`库，这是一个Python库，实现了许多统计模型和测试。要运行ADF测试，我们只需将其传递给我们的模拟数据数组。结果是不同值的列表，但我们主要对前两个值感兴趣：ADF统计量和p值。
- en: '[PRE2]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Pass the simulated random walk to the adfuller function.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将模拟的随机游走传递给adfuller函数。
- en: ❷ Retrieve the ADF statistic, which is the first value in the list of results.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 查找ADF统计量，它是结果列表中的第一个值。
- en: ❸ Retrieve the p-value, which is the second value in the list of results.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 查找p值，它是结果列表中的第二个值。
- en: This prints an ADF statistic of –0.97 and a p-value of 0.77\. The ADF statistic
    is not a large negative number, and with a p-value greater than 0.05, we cannot
    reject the null hypothesis stating that our time series is not stationary. We
    can further support our conclusion by plotting the ACF function.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出ADF统计量为-0.97和p值为0.77。ADF统计量不是一个大的负数，并且由于p值大于0.05，我们不能拒绝原假设，即我们的时间序列不是平稳的。我们可以通过绘制ACF函数进一步支持我们的结论。
- en: The `statsmodels` library conveniently has a function to quickly plot the ACF.
    Again, we can simply pass it our array of data. We can optionally specify the
    number of lags, which will determine the range on the *x*-axis. In this case,
    we will plot the first 20 lags, but feel free to plot as many lags as you wish.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`statsmodels`库方便地有一个函数可以快速绘制ACF。同样，我们可以简单地传递它我们的数据数组。我们可以选择指定滞后数，这将确定*x*轴的范围。在这种情况下，我们将绘制前20个滞后，但你可以自由地绘制你想要的任何滞后数。'
- en: '[PRE3]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The output is shown in figure 3.9.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如图3.9所示。
- en: '![](../../OEBPS/Images/03-09.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/03-09.png)'
- en: Figure 3.9 Plot of the ACF of our simulated random walk. Notice how the autocorrelation
    coefficients slowly decrease. Even at lag 20, the value is still autocorrelated,
    which means that our random walk is not stationary at the moment.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 模拟随机游走的ACF图。注意自相关系数是如何逐渐减小的。即使在滞后20的情况下，值仍然是自相关的，这意味着我们的随机游走目前不是平稳的。
- en: In figure 3.9 you’ll notice how the autocorrelation coefficients slowly decrease
    as the lag increases, which is a clear indicator that our random walk is not a
    stationary process. Note that the shaded area represents a confidence interval.
    If a point is within the shaded area, then it is not significantly different from
    0\. Otherwise, the autocorrelation coefficient is significant.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在图3.9中，你会注意到随着滞后时间的增加，自相关系数逐渐减小，这是我们的随机游走不是平稳过程的明显指标。请注意，阴影区域代表置信区间。如果一个点在阴影区域内，那么它与0没有显著差异。否则，自相关系数是显著的。
- en: Because our random walk is not stationary, we need to apply a transformation
    to make it stationary in order to retrieve useful information from the ACF plot.
    Since our sequence mostly displays changes in the trend without seasonal patterns,
    we will apply a first-order differencing. Remember that we’ll lose the first data
    point every time we difference.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的随机游走不是平稳的，我们需要应用一个转换使其平稳，以便从ACF图中检索有用信息。由于我们的序列主要显示趋势的变化而没有季节性模式，我们将应用一阶差分。记住，每次差分我们都会丢失第一个数据点。
- en: 'To difference, we will use the `numpy` method `diff`. This will difference
    a given array of data. The `n` parameter controls how many times the array must
    be differenced. To apply a first-order differencing, the `n` parameter must be
    set to 1:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行差分，我们将使用`numpy`的`diff`方法。这将差分给定数据数组。`n`参数控制数组必须差分多少次。为了应用一阶差分，`n`参数必须设置为1：
- en: '[PRE4]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We can visualize the differenced simulated random walk in figure 3.10.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在图3.10中可视化差分的模拟随机游走。
- en: '![](../../OEBPS/Images/03-10.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图3.10](../../OEBPS/Images/03-10.png)'
- en: Figure 3.10 Evolution of our differenced random walk. It seems that we successfully
    removed the trend and that the variance is stable.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 我们差分随机游走的变化。看起来我们已经成功移除了趋势，并且方差是稳定的。
- en: 'As you can see in figure 3.10, we have removed the trend from our series. Furthermore,
    the variance looks quite stable. Let’s test for stationarity again, using the
    ADF test:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在图3.10中看到的，我们已经从我们的序列中移除了趋势。此外，方差看起来相当稳定。让我们再次测试平稳性，使用ADF测试：
- en: '[PRE5]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Here we pass in our differenced random walk.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这里我们传递我们的差分随机游走。
- en: This prints out an ADF statistic of –31.79 with a p-value of 0\. This time the
    ADF statistic is a large negative number, and the p-value is less than 0.05\.
    Therefore, we reject the null hypothesis, and we can say that this process has
    no unit root and is thus stationary.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这输出了一个ADF统计量为-31.79，p值为0.。这次ADF统计量是一个大的负数，p值小于0.05。因此，我们拒绝零假设，我们可以说这个过程没有单位根，因此是平稳的。
- en: 'We can now plot the ACF function of our newly stationary series:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以绘制我们新近平稳的时间序列的ACF函数：
- en: '[PRE6]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Looking at figure 3.11, you’ll notice that there are no significant autocorrelation
    coefficients after lag 0\. This means that the stationary process is completely
    random and can therefore be described as *white noise*. Each value is simply a
    random step away from the previous one, with no relation between them.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 观察图3.11，你会注意到在滞后0之后没有显著的自相关系数。这意味着平稳过程是完全随机的，因此可以描述为*白噪声*。每个值只是简单地从上一个值随机跳跃，它们之间没有关系。
- en: '![](../../OEBPS/Images/03-11.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图3.11](../../OEBPS/Images/03-11.png)'
- en: Figure 3.11 An ACF plot of our differenced random walk. Notice how there are
    no significant coefficients after lag 0\. This is a clear indicator that we are
    dealing with a random walk.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 我们差分随机游走的ACF图。注意在滞后0之后没有显著的系数。这是我们在处理随机游走的明确指标。
- en: 'We have demonstrated that our simulated data is indeed a random walk: the series
    is stationary and uncorrelated after a first-order differencing, which corresponds
    to the definition of a random walk.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经证明我们的模拟数据确实是一个随机游走：经过一阶差分后，序列是平稳且不相关的，这符合随机游走的定义。
- en: 3.2.5 Is GOOGL a random walk?
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.5 GOOGL是随机游走吗？
- en: We’ve applied the necessary steps to identify a random walk on our simulated
    data, so this is a great time to test our knowledge and new skills on a real-life
    dataset. Taking the closing price of GOOGL from April 27, 2020, to April 27, 2021,
    from [finance.yahoo.com](https://finance.yahoo.com/), let’s determine whether
    the process can be approximated as a random walk or not.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经应用了必要的步骤来识别模拟数据中的随机游走，因此这是一个测试我们在真实数据集上知识和新技能的好时机。从2020年4月27日到2021年4月27日的GOOGL收盘价，来自[finance.yahoo.com](https://finance.yahoo.com/)，让我们确定这个过程是否可以近似为随机游走。
- en: 'You can load the data in a `DataFrame` using the `read_csv` method from `pandas`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`pandas`的`read_csv`方法将数据加载到`DataFrame`中：
- en: '[PRE7]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Hopefully, your conclusion is that the closing price of GOOGL is indeed a random
    walk process. Let’s see how we arrive at this conclusion. For visualization purposes,
    let’s quickly plot our data, which results in figure 3.12:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你的结论是GOOGL的收盘价确实是一个随机游走过程。让我们看看我们是如何得出这个结论的。为了可视化的目的，让我们快速绘制我们的数据，这导致了图3.12：
- en: '[PRE8]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Nicely label the ticks on the x-axis.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 仔细标注x轴上的刻度。
- en: '![](../../OEBPS/Images/03-12.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图3.12](../../OEBPS/Images/03-12.png)'
- en: Figure 3.12 Closing price of GOOGL from April 27, 2020, to April 27, 2021
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 2020年4月27日至2021年4月27日的GOOGL收盘价
- en: 'Looking at figure 3.12, we can see a trend in the data as the closing price
    is increasing over time; therefore, we do not have a stationary process. This
    is further supported by the ADF test:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 观察图3.12，我们可以看到数据中存在趋势，因为收盘价随时间增加；因此，我们没有一个平稳过程。这一点进一步得到了ADF测试的支持：
- en: '[PRE9]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This returns an ADF statistic of 0.16 and a p-value greater than 0.05, so we
    know that our data is not stationary. Hence, we will difference our data to see
    if that makes it stationary:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回了0.16的ADF统计量和大于0.05的p值，因此我们知道我们的数据不是平稳的。因此，我们将对数据进行差分，看看这能否使其平稳：
- en: '[PRE10]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we can run the ADF test on the differenced data:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以对差分数据进行ADF测试：
- en: '[PRE11]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This gives an ADF statistic of –5.3 and a p-value smaller than 0.05, meaning
    that we have a stationary process.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了-5.3的ADF统计量和小于0.05的p值，这意味着我们有一个平稳过程。
- en: 'Now we can plot the ACF function and see if there is autocorrelation:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以绘制ACF函数，看看是否存在自相关：
- en: '[PRE12]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Figure 3.13 might make you scratch your head and wonder if there is autocorrelation
    or not. We do not see any significant coefficients, except at lags 5 and 18\.
    This situation can arise sometimes, and it is due to chance only. In such a situation,
    we can safely assume that the coefficients at lags 5 and 18 are not significant,
    because we do not have consecutive significant coefficients. It just happened
    by chance that the differenced values are slightly correlated with the ones at
    lags 5 and 18.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13可能会让你感到困惑，想知道是否存在自相关。我们看不到任何显著的系数，除了滞后5和18。这种情况有时会发生，并且仅是由于偶然。在这种情况下，我们可以安全地假设滞后5和18的系数并不显著，因为我们没有连续显著的系数。这只是一个偶然现象，差分值与滞后5和18的值略有相关性。
- en: '![](../../OEBPS/Images/03-13.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图3.13](../../OEBPS/Images/03-13.png)'
- en: Figure 3.13 We can see that there are no significant coefficients in the ACF
    plot. You might notice that at lags 5 and 18 the coefficients are significant,
    while the others are not. This happens by chance with some data, and these points
    can be assumed to be non-significant, because we do not have consecutive significant
    coefficients between lags 0 and 5 or lags 0 and 18.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 我们可以看到ACF图中没有显著的系数。你可能会注意到，在滞后5和18时系数是显著的，而其他则不是。这种情况在某些数据中偶然发生，并且可以假设这些点是非显著的，因为我们没有在滞后0到5或滞后0到18之间有连续显著的系数。
- en: Therefore, we can conclude that the closing price of GOOGL can be approximated
    by a random walk process. Taking the first difference makes the series stationary,
    and its ACF plot shows no autocorrelation, meaning that it is purely random.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以得出结论，GOOGL的收盘价可以通过随机游走过程来近似。取一阶差分使序列平稳，其ACF图显示没有自相关，这意味着它是完全随机的。
- en: 3.3 Forecasting a random walk
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 预测随机游走
- en: Now that we know what a random walk is and how to identify one, we can start
    forecasting. This might sound surprising, since we established that a random walk
    takes random steps as time progresses.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了什么是随机游走以及如何识别它，我们可以开始进行预测。这可能会让人感到惊讶，因为我们已经确定随机游走随着时间的推移会采取随机的步骤。
- en: Predicting a random change is impossible, unless we predict a random value ourselves,
    which is not ideal. In this case, we can only use naive forecasting methods, or
    baselines, which we covered in chapter 2\. Since the values change randomly, no
    statistical learning model can be applied. Instead, we can only reasonably predict
    the historical mean, or the last value.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 预测随机变化是不可能的，除非我们预测一个随机值，这显然不是理想的情况。在这种情况下，我们只能使用简单的预测方法，或者基线，这些我们在第2章中已经讨论过。由于值是随机变化的，因此无法应用统计学习模型。相反，我们只能合理地预测历史平均值，或者最后一个值。
- en: Depending on the use case, your forecasting horizon will vary. Ideally, when
    dealing with a random walk, you will only forecast the next timestep. However,
    you may be required to forecast many timesteps into the future. Let’s look at
    how to tackle each of these situations.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 根据用例的不同，你的预测范围会有所不同。理想情况下，当处理随机游走时，你将只预测下一个时间步。然而，你可能需要预测未来的多个时间步。让我们看看如何应对这些情况。
- en: 3.3.1 Forecasting on a long horizon
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 长期预测
- en: In this section, we’ll forecast a random walk on a long horizon. This is not
    an ideal case—a random walk can unexpectedly increase or decrease because past
    observations are not predictive of changes in the future. Here we’ll continue
    working with our simulated random walk from section 3.1.1.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将对长期视角下的随机游走进行预测。这不是一个理想的情况——随机游走可能会意外地增加或减少，因为过去的观察结果并不能预测未来的变化。在这里，我们将继续使用3.1.1节中的模拟随机游走。
- en: 'To make things easier, we will assign the random walk to a `DataFrame` and
    split the dataset into train and test sets. The train set will contain the first
    800 timesteps, which corresponds to 80% of the simulated data. The test set will
    thus contain the last 200 values:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化问题，我们将随机游走分配到一个`DataFrame`中，并将数据集分为训练集和测试集。训练集将包含前800个时间步，这对应于模拟数据的80%。因此，测试集将包含最后200个值：
- en: '[PRE13]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Assign the simulated random walk to a DataFrame. It will contain a single
    column called value.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将模拟随机游走分配到一个DataFrame中。它将包含一个名为value的单列。
- en: ❷ The first 80% of the data is assigned to the train set. Since we have 1,000
    timesteps, 80% of our simulated data corresponds to the values up to index 800.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 数据的前80%被分配到训练集中。由于我们有1,000个时间步，我们模拟数据的80%对应于索引800之前的值。
- en: ❸ Assign the last 20% of the simulated random walk to the test set.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将模拟随机游走的最后20%分配给测试集。
- en: Figure 3.14 illustrates our split. Using the train set, we must now predict
    the next 200 timesteps in the test set.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14说明了我们的分割。使用训练集，我们现在必须预测测试集中下一个200个时间步的值。
- en: '![](../../OEBPS/Images/03-14.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/03-14.png)'
- en: Figure 3.14 The train/test split of our generated random walk. The first 800
    timesteps are part of the train set, and the remaining values are part of the
    test set. Our goal is to forecast the values in the shaded area.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14展示了我们生成的随机游走的训练/测试分割。前800个时间步是训练集的一部分，其余的值是测试集的一部分。我们的目标是预测阴影区域的值。
- en: As mentioned, we can only use naive forecasting methods for this situation,
    since we are dealing with a random walk. In this case, we will use the historical
    mean, the last known value, and the drift method.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们只能使用简单的预测方法来处理这种情况，因为我们正在处理随机游走。在这种情况下，我们将使用历史平均值、最后一个已知值和漂移方法。
- en: 'Forecasting the mean is fairly straightforward. We’ll simply calculate the
    mean of the train set and say that the next 200 timesteps will be equal to that
    value. Here, we’ll create a new column pred_mean that will hold the historical
    mean as a prediction:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 预测平均值相当直接。我们将简单地计算训练集的平均值，并说下一个200个时间步的值将等于这个值。在这里，我们将创建一个新的列pred_mean，它将保存历史平均值作为预测：
- en: '[PRE14]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Calculate the mean of the train set.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 计算训练集的平均值。
- en: ❷ Predict the historical mean for the next 200 timesteps.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 预测下一个200个时间步的历史平均值。
- en: ❸ Show the first five rows of test.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 展示测试数据的头五行。
- en: You will get a historical mean of –3.68\. This means that we’ll forecast that
    the next 200 timesteps of our simulated random walk will have a value of –3.68.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到一个历史平均值为-3.68。这意味着我们将预测模拟随机游走的下一个200个时间步的值将为-3.68。
- en: 'Another possible baseline is to predict the last known value of the train set.
    Here, we’ll simply extract the last value of the train set and assign its value
    as our prediction for the next 200 timesteps:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能的基线是预测训练集的最后一个已知值。在这里，我们将简单地提取训练集的最后一个值，并将其值作为我们下一个200个时间步的预测：
- en: '[PRE15]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Retrieve the last value of the train set.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取训练集的最后一个值。
- en: ❷ Assign the last value as a prediction for the next 200 timesteps under the
    pred_last column.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在pred_last列中将最后一个值作为下一个200个时间步的预测。
- en: This method yields forecasts with a constant value of –6.81.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法产生的预测值恒为-6.81。
- en: Finally, we’ll apply the drift method, which we have not covered yet. The *drift*
    method is a modification of predicting the last known value. In this case, we
    allow the values to increase or decrease over time. The rate at which values will
    change in the future is equal to that seen in the train set. Therefore, it is
    equivalent to calculating the slope between the first and last value of the train
    set and simply extrapolating this straight line into the future.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将应用漂移方法，这是我们尚未讨论的方法。漂移方法是对预测最后一个已知值的修改。在这种情况下，我们允许值随时间增加或减少。未来值将变化的速率等于训练集中观察到的速率。因此，这相当于计算训练集第一行和最后一行之间的斜率，并将这条直线简单地外推到未来。
- en: Remember that we can calculate the slope of a straight line by dividing the
    change in the *y*-axis by the change in the *x*-axis. In our case, the change
    in the *y*-axis is the difference between the last value of our random walk *y*[f]
    and its initial value *y*[i]. Then, the change in the *x*-axis is equivalent to
    the number of timesteps minus 1, as shown in equation 3.11.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们可以通过将y轴的变化除以x轴的变化来计算直线的斜率。在我们的情况下，y轴的变化是随机游走的最后一个值y[f]与其初始值y[i]之间的差异。然后，x轴的变化相当于时间步数减1，如方程3.11所示。
- en: '![](../../OEBPS/Images/03-14-Equation-3-11.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/03-14-Equation-3-11.png)'
- en: Equation 3.11
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 方程式 3.11
- en: We calculated the last value of the train set when we implemented the last known
    value baseline, and we know that the initial value of our simulated random walk
    is 0; therefore, we can plug the numbers into equation 3.11 and calculate the
    drift in equation 3.12.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实现最后一个已知值基线时，我们计算了训练集的最后一个值，并且我们知道我们的模拟随机游走的初始值为 0；因此，我们可以将数字代入方程式 3.11 并计算方程式
    3.12 中的漂移。
- en: '![](../../OEBPS/Images/03-14-Equation-3-12.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/03-14-Equation-3-12.png)'
- en: Equation 3.12
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 方程式 3.12
- en: 'Let’s implement this in Python now. We will calculate the change in the *x*-axis
    and the *y*-axis, and simply divide them to obtain the drift:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在在 Python 中实现这个功能。我们将计算 *x* 轴和 *y* 轴的变化，并简单地除以它们以获得漂移：
- en: '[PRE16]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Calculate the change in the x-axis, which is the difference between the last
    index (799) and first index (0). It is equivalent to the number of timesteps minus
    1.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 计算 x 轴的变化，即最后一个索引（799）和第一个索引（0）之间的差异。它等同于时间步数减 1。
- en: ❷ Calculate the difference between the last and initial values of the simulated
    random walk in the train set. Recall that the last value of the train set is in
    the last_value variable from the previous baseline we implemented.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 计算模拟随机游走在训练集中的最后和初始值之间的差异。回想一下，训练集的最后一个值在之前实现的基线中的 last_value 变量中。
- en: ❸ Calculate the drift according to equation 3.11.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 根据方程式 3.11 计算漂移。
- en: As expected, this gives us a drift of –0.0085, which means that the values of
    our forecasts will slowly decrease over time. The drift method simply states that
    the value of our forecast is linearly dependent on the timestep, the value of
    the drift, and the initial value of our random walk, as expressed in equation
    3.13\. Keep in mind that our random walk starts at 0, so we can remove that from
    equation 3.13.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，这给出了漂移值为 –0.0085，这意味着我们的预测值将随着时间的推移逐渐减少。漂移方法简单地表明，我们的预测值与时间步、漂移值以及随机游走的初始值线性相关，如方程式
    3.13 所示。请注意，我们的随机游走从 0 开始，因此我们可以从方程式 3.13 中去掉这一点。
- en: forecast = drift × timestep + *y*[i]
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: forecast = drift × timestep + *y*[i]
- en: forecast = drift × timestep
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: forecast = drift × timestep
- en: Equation 3.13
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 方程式 3.13
- en: 'Since we want to forecast the next 200 timesteps following the train set, we’ll
    first create an array containing the range of timesteps starting at 800 and ending
    at 1000 with a step of 1\. Then we simply multiply each timestep by the drift
    to get our forecast values. Finally, we assign them to the pred_drift column of
    `test`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要预测训练集之后的下一个 200 个时间步，我们首先创建一个数组，包含从 800 开始到 1000 结束，步长为 1 的时间步范围。然后我们只需将每个时间步乘以漂移，以得到我们的预测值。最后，我们将它们分配给
    `test` 的 pred_drift 列：
- en: '[PRE17]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Create a list containing the range of timesteps starting at 800 and ending
    at 1000 with a step of 1.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个包含从 800 开始到 1000 结束，步长为 1 的时间步范围的列表。
- en: ❷ Multiply each timestep by the drift to get the forecast value at each timestep.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将每个时间步乘以漂移，以得到每个时间步的预测值。
- en: ❸ Assign our forecast values to the pred_drift column.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将我们的预测值分配给 pred_drift 列。
- en: 'With all three methods, we can now visualize what our forecasts look like against
    the actual values of the test set:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这三种方法，我们现在可以可视化我们的预测与测试集的实际值对比情况：
- en: '[PRE18]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Plot the values in the train set.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在训练集中绘制值。
- en: ❷ Plot the observed values in the test set.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在测试集中绘制观察值。
- en: ❸ Plot the forecast from the historical mean. It will be a red dotted and dashed
    line.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从历史平均值绘制预测图。它将是一条红色虚线和点划线。
- en: ❹ Plot the forecast from the last value of train set. It will be a green dashed
    line.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 从训练集的最后一个值绘制预测图。它将是一条绿色虚线。
- en: ❺ Plot the forecast using the drift method. It will be a black dotted line.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用漂移方法绘制预测图。它将是一条黑色虚线。
- en: ❻ Shade the forecast horizon.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 着色预测范围。
- en: ❼ Place the legend in the upper-left corner.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 将图例放置在左上角。
- en: As you can see in figure 3.15, our forecasts are faulty. They all fail to predict
    the sudden increase observed in the test set, which makes sense, because the future
    change in a random walk is completely random, and therefore unpredictable.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在图 3.15 中所见，我们的预测是错误的。它们都无法预测测试集中观察到的突然增加，这是有道理的，因为随机游走的未来变化是完全随机的，因此是不可预测的。
- en: '![](../../OEBPS/Images/03-15.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/03-15.png)'
- en: Figure 3.15 Forecasting our random walk using the mean, last known value, and
    drift methods. As you can see, all predictions are fairly poor and fail to predict
    the sudden increase observed in the test set.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.15 使用平均值、最后已知值和漂移方法预测我们的随机游走。如你所见，所有预测都相当糟糕，并且未能预测测试集中观察到的突然增加。
- en: We can further demonstrate that by calculating the mean squared error (MSE)
    of our forecasts. We cannot use the MAPE, as in chapter 2, because our random
    walk can take the value 0—it is impossible to calculate the percentage difference
    from an observed value of 0 because that implies a division by 0, which is not
    allowed in mathematics.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过计算我们预测的均方误差（MSE）来进一步证明这一点。我们无法使用第2章中提到的MAPE，因为我们的随机游走可以取值为0——由于这意味着除以0，这在数学中是不允许的。
- en: Therefore, we opt for the MSE, as it can measure the quality of the fit of a
    model, even if the observed value is 0\. The `sklearn` library has a `mean_squared_error`
    function that simply needs the observed and predicted values. It will then return
    the MSE.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们选择MSE，因为它可以衡量模型拟合的质量，即使观察到的值为0。`sklearn`库中的`mean_squared_error`函数只需要观察值和预测值。然后它会返回MSE。
- en: '[PRE19]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You will obtain an MSE of 327, 425, and 466 for the historical mean, last value,
    and drift methods, respectively. We can compare the MSEs for these three baselines
    in figure 3.16.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 对于历史平均值、最后值和漂移方法，你将分别获得327、425和466的MSE。我们可以在图3.16中比较这三个基线的MSE。
- en: '![](../../OEBPS/Images/03-16.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/03-16.png)'
- en: Figure 3.16 MSEs of our forecasts. Clearly, the future of a random walk is unpredictable,
    with MSEs exceeding 300.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.16 我们预测的均方误差（MSE）。显然，随机游走的未来是不可预测的，MSE超过了300。
- en: As you can see in figure 3.16, the best forecast was obtained by predicting
    the historical mean, and yet the MSE exceeds 300\. This is an extremely high value
    considering that our simulated random walk does not exceed the value of 30.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如图3.16所示，最佳预测是通过预测历史平均值获得的，但均方误差（MSE）超过了300。考虑到我们的模拟随机游走值不超过30，这是一个极高的值。
- en: By now, you should be convinced that forecasting a random walk on a long horizon
    does not make sense. Since the future value is dependent on the past value plus
    a random number, the randomness portion is magnified in a long horizon where many
    random numbers are added over the course of many timesteps.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经相信在长期预测随机游走是没有意义的。因为未来的值依赖于过去的价值加上一个随机数，在长期预测中，由于在许多时间步长中添加了许多随机数，随机部分被放大。
- en: 3.3.2 Forecasting the next timestep
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.2 预测下一个时间步
- en: Forecasting the next timestep of a random walk is the only reasonable situation
    we can tackle, although we will still use naive forecasting methods. Specifically,
    we will predict the last known value. However, we will make this forecast only
    for the next timestep. That way, our forecast should only be off by a random number,
    since the future value of a random walk is always the past value plus white noise.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将仍然使用简单的预测方法，但预测随机游走的下一个时间步是我们唯一可以处理的合理情况。具体来说，我们将预测最后一个已知值。然而，我们只会在下一个时间步进行这种预测。这样，我们的预测应该只会因为随机数而偏离，因为随机游走的未来值总是过去的价值加上白噪声。
- en: 'Implementing this method is straightforward: we take our initial observed value
    and use it to predict the next timestep. Once we record a new value, it will be
    used as a forecast for the following timestep. This process is then repeated into
    the future.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这个方法很简单：我们取我们的初始观察值并用来预测下一个时间步。一旦我们记录了一个新值，它将被用作下一个时间步的预测。然后这个过程会重复到未来。
- en: Figure 3.17 illustrates this process. Here, the observed value at 8:00 a.m.
    is used to forecast the value for 9:00 a.m., the actual value observed at 9:00
    a.m. is used to forecast the value at 10:00 a.m., and so on.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.17展示了这个过程。在这里，早上8:00观察到的值被用来预测早上9:00的值，早上9:00实际观察到的值被用来预测早上10:00的值，以此类推。
- en: '![](../../OEBPS/Images/03-17.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/03-17.png)'
- en: Figure 3.17 Forecasting the following timestep of a random walk. Here, the observed
    value at a point in time will be used as a forecast for the next point in time.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.17 预测随机游走的下一个时间步。在这里，在某个时间点的观察值将被用作下一个时间点的预测。
- en: Let’s apply this method to our random walk process. For the sake of illustrating
    this method, we will apply it over the entire random walk. This naive forecast
    can look deceptively amazing, when we are actually only predicting the last known
    value at each timestep.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这种方法应用于我们的随机游走过程。为了说明这种方法，我们将它应用于整个随机游走。这种朴素预测可能看起来非常令人印象深刻，但实际上我们只是在预测每个时间步的最后已知值。
- en: 'A good way to simulate this process is by shifting our data, and the `pandas`
    library has a `shift` method that does exactly what we want. We simply pass in
    the number of periods, which in our case is 1, since we are forecasting the next
    timestep:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟这个过程的一个好方法是移动我们的数据，而`pandas`库中的`shift`方法正好能做我们想要的事情。我们只需传入周期数，在我们的例子中是1，因为我们正在预测下一个时间步：
- en: '[PRE20]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ df_shift is now our forecast over the entire random walk, and it corresponds
    to the last known value at each timestep.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `df_shift` 现在我们对整个随机游走的预测，并且对应于每个时间步的最后已知值。
- en: You will notice that at step 1, the value is 0, which corresponds to the observed
    value at step 0 in the simulated random walk. Therefore, we are effectively using
    the present observed value as a forecast for the next timestep. Plotting our forecast
    yields figure 3.18.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到在第1步时，值为0，这对应于模拟随机游走中第0步的观察值。因此，我们实际上是在使用当前观察到的值来预测下一个时间步。绘制我们的预测结果得到图3.18。
- en: '[PRE21]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![](../../OEBPS/Images/03-18.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/03-18.png)'
- en: Figure 3.18 A naive forecast of the next timestep of a random walk. This plot
    gives the illusion of a very good model, when we are in fact only predicting the
    value observed at the previous timestep.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.18 对随机游走下一个时间步的朴素预测。这个图给人一种非常好的模型印象，但实际上我们只是在预测前一个时间步观察到的值。
- en: 'Looking at figure 3.18, you might think that we have developed an amazing model
    that is almost a perfect fit to our data. It seems that we do not have two separate
    lines in the graph, since both of them almost perfectly overlap, which is a sign
    of a perfect fit. Now, we can calculate the MSE:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 观察图3.18，你可能会认为我们已经开发了一个惊人的模型，它几乎完美地符合我们的数据。看起来图表中并没有两条分开的线，因为它们几乎完美地重叠，这是完美拟合的标志。现在，我们可以计算均方误差（MSE）：
- en: '[PRE22]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Calculate the MSE on the test set.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在测试集上计算均方误差（MSE）。
- en: This yields a value of 0.93, which again might lead us to think that we have
    a very performant model, since the MSE is very close to 0\. However, we know that
    we are simply forecasting the value observed at the previous timestep. This becomes
    more apparent if we zoom in on our graph, as shown in figure 3.19.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这得到一个0.93的值，这又可能让我们认为我们有一个非常高效的模型，因为均方误差（MSE）非常接近0。然而，我们知道我们只是在预测前一个时间步观察到的值。如果我们放大我们的图表，如图3.19所示，这一点会更加明显。
- en: '![](../../OEBPS/Images/03-19.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/03-19.png)'
- en: Figure 3.19 Close-up on the last 100 timesteps of our random walk. Here we can
    see how our forecasts are a simple shift of the original time series.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.19 对我们随机游走最后100个时间步的近距离观察。在这里，我们可以看到我们的预测是如何简单地移动原始时间序列的。
- en: Therefore, if a random walk process must be forecast, it is better to make many
    short-term forecasts. That way, we do not allow for many random numbers to accumulate
    over time, which will degrade the quality of our forecasts in the long term.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果必须对随机游走过程进行预测，最好是进行多次短期预测。这样，我们不会让许多随机数随着时间的推移积累，这将在长期内降低我们预测的质量。
- en: 'Because a random process takes random steps into the future, we cannot use
    statistical or deep learning techniques to fit such a process: there is nothing
    to learn from randomness and it cannot be predicted. Instead, we must rely on
    naive forecasting methods.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 由于随机过程会随机地向未来迈出步伐，我们不能使用统计或深度学习技术来拟合这样的过程：从随机性中没有什么可以学习的，它也不能被预测。相反，我们必须依赖朴素预测方法。
- en: 3.4 Next steps
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 下一步
- en: So far you’ve learned how to develop baseline models, and you’ve discovered
    that in the presence of a random walk you can only reasonably apply baseline models
    to make forecasts. You cannot fit a statistical model or use deep learning techniques
    on data that takes random steps in the future. Ultimately, you cannot predict
    random movements.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学习了如何开发基线模型，并且你已经发现，在存在随机游走的情况下，你只能合理地应用基线模型进行预测。你不能在采取未来随机步骤的数据上拟合统计模型或使用深度学习技术。最终，你不能预测随机运动。
- en: You learned that a random walk is a sequence where the first difference is not
    autocorrelated and is a stationary process, meaning that its mean, variance, and
    autocorrelation are constant over time. The steps required to identify a random
    walk are shown in figure 3.20.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你了解到随机游走是一个序列，其中第一差分不是自相关的，并且是一个平稳过程，这意味着它的均值、方差和自相关随时间保持恒定。识别随机游走的步骤在图3.20中展示。
- en: '![](../../OEBPS/Images/03-20.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/03-20.png)'
- en: Figure 3.20 Steps to identify a random walk
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.20 识别随机游走的步骤
- en: But what happens if your process is stationary and autocorrelated, meaning that
    you see consecutive significant coefficients on the ACF plot? For now, figure
    3.20 simply states that it is not a random walk, so you have to find another model
    to approximate the process and forecast it. In such a situation, you are facing
    a process that can be approximated by the moving average (MA) model, an autoregressive
    (AR) model, or the combination of both processes, leading to an autoregressive
    moving average (ARMA) model.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你的过程是平稳且自相关的，这意味着你在ACF图上看到连续的显著系数，会发生什么？目前，图3.20只是简单地说明它不是一个随机游走，所以你必须找到另一个模型来近似这个过程并进行预测。在这种情况下，你面临的是一个可以用移动平均（MA）模型、自回归（AR）模型或两者的组合来近似的进程，从而导致自回归移动平均（ARMA）模型。
- en: In the next chapter, we will focus solely on the moving average model. You’ll
    learn how to identify such processes and how to use the moving average model to
    make forecasts.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将专注于移动平均模型。你将学习如何识别此类过程以及如何使用移动平均模型进行预测。
- en: 3.5 Exercises
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 练习
- en: 'Now is a great time to apply the different skills you learned in this chapter.
    The following three exercises will test your knowledge and understanding of random
    walks and forecasting a random walk. The exercises are in order of difficulty
    and the time required to complete them. The solutions to exercises 3.5.1 and 3.5.2
    are on GitHub: [https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH03](https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH03).'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是应用本章学到的不同技能的大好时机。以下三个练习将测试你对随机游走和预测随机游走的知识和理解。练习的难度和完成所需的时间依次排列。练习3.5.1和3.5.2的解决方案在GitHub上：[https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH03](https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH03)。
- en: 3.5.1 Simulate and forecast a random walk
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.1 模拟并预测随机游走
- en: 'Simulate a different random walk than the one we have worked with in this chapter.
    You can simply change the seed and get new values:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟一个不同于本章中我们使用过的随机游走。你可以简单地改变种子并得到新的值：
- en: Generate a random walk of 500 timesteps. Feel free to choose an initial value
    different from 0\. Also, make sure you change the seed by passing a different
    integer to `np.random.seed()`.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个包含500个时间步长的随机游走。你可以自由选择一个不同于0的初始值。同时，确保通过传递不同的整数给`np.random.seed()`来改变种子。
- en: Plot your simulated random walk.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制你的模拟随机游走图。
- en: Test for stationarity.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试数据的平稳性。
- en: Apply a first-order difference.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用一阶差分。
- en: Test for stationarity.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试数据的平稳性。
- en: Split your simulated random walk into a train set containing the first 400 timesteps.
    The remaining 100 timesteps will be your test set.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的模拟随机游走分为包含前400个时间步长的训练集。剩余的100个时间步长将作为测试集。
- en: Apply different naive forecasting methods and measure the MSE. Which method
    yields the lowest MSE?
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用不同的朴素预测方法并测量MSE。哪种方法产生的MSE最低？
- en: Plot your forecasts.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制你的预测图。
- en: Forecast the next timestep over the test set and measure the MSE. Did it decrease?
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试集上预测下一个时间步长并测量MSE。它是否降低了？
- en: Plot your forecasts.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制你的预测图。
- en: 3.5.2 Forecast the daily closing price of GOOGL
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.2 预测GOOGL的每日收盘价
- en: 'Using the GOOGL dataset that we worked with in this chapter, apply the forecasting
    techniques we’ve discussed and measure their performance:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本章中我们使用的GOOGL数据集，应用我们讨论的预测技术并测量它们的性能：
- en: Keep the last 5 days of data as a test set. The rest will be the train set.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将最后5天的数据作为测试集。其余的将作为训练集。
- en: Forecast the last 5 days of the closing price using naive forecasting methods
    and measure the MSE. Which method is the best?
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用朴素预测方法预测最后5天的收盘价并测量均方误差（MSE）。哪种方法最好？
- en: Plot your forecasts.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制你的预测图。
- en: Forecast the next timestep over the test set and measure the MSE. Did it decrease?
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试集上预测下一个时间步长并测量MSE。它是否降低了？
- en: Plot your forecasts.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制你的预测图。
- en: 3.5.3 Forecast the daily closing price of a stock of your choice
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.3 预测你选择的股票的每日收盘价
- en: 'The historical daily closing price of many stocks is available for free on
    [finance.yahoo.com](http://finance.yahoo.com). Select a stock ticker of your choice,
    and download its historical daily closing price for 1 year:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 许多股票的历史每日收盘价可以在[finance.yahoo.com](http://finance.yahoo.com)上免费获得。选择你喜欢的股票代码，并下载其过去1年的历史每日收盘价：
- en: Plot the daily closing price of your chosen stock.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制你选择的股票的每日收盘价。
- en: Determine if it is a random walk or not.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定它是否是随机游走。
- en: If it is not a random walk, explain why.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它不是一个随机游走，请解释原因。
- en: Keep the last 5 days of data as a test set. The rest will be the train set.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将最后5天的数据保留为测试集。其余的将是训练集。
- en: Forecast the last 5 days using naive forecasting methods, and measure the MSE.
    Which method is the best?
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用朴素预测方法预测最后5天，并测量均方误差（MSE）。哪种方法最好？
- en: Plot your forecasts.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制你的预测。
- en: Forecast the next timestep over the test set, and measure the MSE. Did it decrease?
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试集上预测下一个时间步，并测量均方误差（MSE）。它是否减少了？
- en: Plot your forecasts.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制你的预测。
- en: Summary
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: A random walk is a process where the first difference is stationary and not
    autocorrelated.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机游走是一个过程，其中第一差分是平稳的，并且不是自相关的。
- en: We cannot use statistical or deep learning techniques on a random walk, since
    it moves at random in the future. Therefore, we must use naive forecasts.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不能在随机游走中使用统计或深度学习技术，因为它在未来的移动是随机的。因此，我们必须使用朴素预测。
- en: A stationary time series is one whose statistical properties (mean, variance,
    autocorrelation) do not change over time.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平稳时间序列是指其统计属性（均值、方差、自相关）随时间不改变的时间序列。
- en: The augmented Dickey-Fuller (ADF) test is used to assess stationarity by testing
    for unit roots.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增量迪基-富勒（ADF）测试通过检验单位根来评估平稳性。
- en: The null hypothesis of the ADF test is that there is a unit root in the series.
    If the ADF statistic is a large negative value and the p-value is less than 0.05,
    the null hypothesis is rejected, and the series is stationary.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ADF测试的零假设是序列中存在单位根。如果ADF统计量是一个大的负值，且p值小于0.05，则拒绝零假设，序列是平稳的。
- en: Transformations are used to make a series stationary. Differencing can stabilize
    the trend and seasonality, while logarithms stabilize the variance.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用变换来使序列平稳。差分可以稳定趋势和季节性，而对数可以稳定方差。
- en: Autocorrelation measures the correlation between a variable and itself at a
    previous timestep (lag). The autocorrelation function (ACF) shows how the autocorrelation
    changes as a function of the lag.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自相关衡量一个变量与其在先前时间步（滞后）上的相关性。自相关函数（ACF）显示了自相关如何随滞后变化。
- en: Ideally, we will forecast a random walk in the short term or the next timestep.
    That way, we do not allow for random numbers to accumulate, which will degrade
    the quality of our forecasts in the long term.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理想情况下，我们将对短期或下一个时间步的随机游走进行预测。这样，我们不允许随机数累积，这将在长期内降低我们预测的质量。
