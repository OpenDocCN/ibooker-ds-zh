- en: Part 3\. Beyond the basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：超越基础
- en: In Part 2, we worked through the core features, from source and matching directives
    to filtering, routing, and log event transformation and manipulation. We also
    saw some common sources and targets, from log files to Elasticsearch, MongoDB,
    and Slack. With this, we have enough knowledge to develop monitoring solutions
    to address many needs. But eventually, we will find ourselves needing to look
    beyond the basics.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分，我们探讨了核心功能，从源和匹配指令到过滤、路由以及日志事件的转换和处理。我们还看到了一些常见的源和目标，从日志文件到 Elasticsearch、MongoDB
    和 Slack。有了这些知识，我们已经足够开发出满足许多需求的监控解决方案。但最终，我们将会发现自己需要超越基础。
- en: We have made references to Cloud Native, Docker, and Kubernetes throughout the
    book but have not invested too much in the specifics of configuring Fluentd into
    these environments. This is mainly because it is worth appreciating that Fluentd
    is more than just a utility for Kubernetes. Before we specifically address logging
    with Docker and Kubernetes, we should first handle how Fluentd can scale, as this
    will inform aspects of how we can support containerization.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在整本书中多次提到了云原生、Docker 和 Kubernetes，但并没有过多地深入到将 Fluentd 配置到这些环境中的具体细节。这主要是因为我们值得欣赏的是，Fluentd
    不仅仅是一个 Kubernetes 的实用工具。在我们具体讨论使用 Docker 和 Kubernetes 进行日志记录之前，我们首先应该处理 Fluentd
    如何进行扩展的问题，因为这将影响我们如何支持容器化。
- en: When we look at Docker and Kubernetes, we will address how Fluentd supports
    containerized applications and how we capture the log events from these technologies
    and the challenges they can bring.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们审视 Docker 和 Kubernetes 时，我们将讨论 Fluentd 如何支持容器化应用程序，以及我们如何捕获这些技术和它们可能带来的挑战的日志事件。
- en: Finally, we take on the challenge of what to do when existing plugins can’t
    help us deal with esoteric or archaic applications or platforms with their custom
    ways of exposing data to be logged. Perhaps it is an application with an overly
    complex data structure, or maybe we need a custom parser to process it efficiently
    instead of using a regular expression. Maybe the only way to get log events is
    to call an application API. Whatever the problem, we need to develop our own plugins.
    So we’ll build a custom plugin to understand how to address such a problem and
    reveal the heart of Fluentd’s extensibility.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们面对的挑战是，当现有的插件无法帮助我们处理那些具有独特或过时应用方式的应用程序或平台时，我们应该怎么办。这可能是一个具有过于复杂的数据结构的程序，或者我们可能需要一个定制的解析器来高效地处理它，而不是使用正则表达式。也许获取日志事件唯一的方法是调用应用程序
    API。无论问题是什么，我们都需要开发自己的插件。因此，我们将构建一个自定义插件来了解如何解决此类问题，并揭示 Fluentd 扩展性的核心。
