- en: 3 Environment management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 环境管理
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Understanding environments
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解环境
- en: Designing the right environment using Namespaces
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命名空间设计正确环境
- en: Organizing your Git repo/branching strategy to support your environment
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织你的Git仓库/分支策略以支持你的环境
- en: Implementing config management for your environment
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的环境实现配置管理
- en: In chapter 2, you learned how GitOps can deploy applications to a run-time environment.
    This chapter teaches us more about those different run-time environments and how
    Kubernetes Namespaces can define environment boundaries. We’ll also learn about
    several configuration management tools (Helm, Kustomize, and Jsonnet) and how
    they can help manage an application’s configuration consistently in multiple environments.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2章中，你学习了GitOps如何将应用程序部署到运行时环境。本章将让我们更深入地了解这些不同的运行时环境以及Kubernetes命名空间如何定义环境边界。我们还将了解几个配置管理工具（Helm、Kustomize和Jsonnet），以及它们如何帮助在多个环境中一致地管理应用程序的配置。
- en: We recommend you read chapters 1 and 2 before reading this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议你在阅读本章之前先阅读第1章和第2章。
- en: 3.1 Introduction to environment management
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 环境管理简介
- en: 'In software deployment, an *environment* is where code is deployed and executed.
    Different environments serve different purposes in the life cycle of software
    development. For example, a local development environment (aka laptop) is where
    engineers can create, test, and debug new code versions. After engineers complete
    the code development, the next step is to commit the changes to Git and kick off
    a deployment to different environments for integration testing and eventual production
    release. This process is known as *continuous integration/continuous deployment*
    (CI/CD) and typically consists of the following environments: *QA, E2E, Stage,
    and Prod*.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件部署中，*环境*是代码部署和执行的地方。不同的环境在软件开发的生命周期中扮演不同的角色。例如，本地开发环境（也称为笔记本电脑）是工程师可以创建、测试和调试新代码版本的地方。工程师完成代码开发后，下一步是将更改提交到Git，并启动部署到不同的环境进行集成测试和最终的生产发布。这个过程被称为*持续集成/持续部署*（CI/CD），通常包括以下环境：*QA、E2E、Stage和Prod*。
- en: The QA environment is where the new code will be tested against hardware, data,
    and other production-like dependencies to ensure your service’s correctness. If
    all tests pass in QA, the new code will be promoted to the E2E environment as
    a stable environment for other prerelease services to test/integrate with. QA
    and E2E environments are also known as preproduction (preprod) environments because
    they do not host production traffic or use production data.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: QA环境是新代码将针对硬件、数据和类似生产依赖项进行测试的地方，以确保你的服务的正确性。如果QA环境中的所有测试都通过，新代码将被提升到E2E环境，作为其他预发布服务的稳定环境进行测试/集成。QA和E2E环境也被称为预生产（preprod）环境，因为它们不托管生产流量或使用生产数据。
- en: When a new version of code is ready for production release, the code will typically
    deploy first in the Stage environment (which has access to actual production dependencies)
    to ensure all production dependencies are in place before the code goes live in
    the Prod environment. For example, new code may require a new DB schema update,
    and the Stage environment can be used to verify the new schema is in place. Configuration
    is done to only direct test traffic to the Stage environment so that any problems
    introduced by the new code would not impact actual customers. However, the Stage
    environment is typically configured to use the “real” production database operations.
    Tests performed on the Stage environment must be carefully reviewed to ensure
    they are safe to perform in production. Once all tests pass in Stage, the new
    code will finally be deployed in Prod for live production traffic. Since Stage
    and Prod both have access to production data, they are both considered production
    environments.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码的新版本准备进行生产发布时，代码通常会首先部署到Stage环境（该环境可以访问实际的生产依赖项），以确保在代码在Prod环境中上线之前，所有生产依赖项都已就绪。例如，新代码可能需要新的数据库模式更新，而Stage环境可以用来验证新的模式是否到位。配置仅将测试流量直接导向Stage环境，以确保新代码引入的问题不会影响实际客户。然而，Stage环境通常配置为使用“真实”的生产数据库操作。在Stage环境中进行的测试必须仔细审查，以确保它们可以在生产环境中安全执行。一旦Stage环境中的所有测试都通过，新代码最终将在Prod环境中部署，以处理实时生产流量。由于Stage和Prod都可以访问生产数据，它们都被视为生产环境。
- en: '![](Images/CH03_F01_Yuen.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH03_F01_Yuen.png)'
- en: Figure 3.1 Preproduction has a QA environment for integration testing and an
    E2E environment for prerelease feature integration. Production environments may
    have aStaging environment for production dependency testing and the actual production
    environment for live traffic.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 预生产环境有集成测试的 QA 环境，以及用于预发布功能集成的端到端 E2E 环境。生产环境可能有一个用于生产依赖测试的 Staging 环境，以及用于实时流量的实际生产环境。
- en: 3.1.1 Components of an environment
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1 环境的组成部分
- en: 'An environment is composed of three equally important components:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 环境由三个同等重要的组件组成：
- en: Code
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码
- en: Run-time prerequisites
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时先决条件
- en: Configuration
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置
- en: Code is the machine instructions of the application to execute specific tasks.
    To execute the code, run-time dependencies may also be required. For example,
    Node.js code will require the Node.js binary and other npm packages in order to
    execute successfully. In the case of Kubernetes, all run-time dependencies and
    code are packaged as a deployable unit (aka Docker image) and orchestrated through
    the Docker daemon. The application’s Docker image can be confidently run in any
    environment, from the developer’s laptop to the production cluster running in
    the cloud, because the image encapsulates the code and all the dependencies, eliminating
    potential incompatibilities between environments.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是应用程序执行特定任务的机器指令。为了执行代码，可能还需要运行时依赖。例如，Node.js 代码需要 Node.js 二进制文件和其他 npm 包才能成功执行。在
    Kubernetes 的情况下，所有运行时依赖和代码都被打包成一个可部署单元（即 Docker 镜像），并通过 Docker 守护进程进行编排。应用程序的
    Docker 镜像可以在任何环境中运行，从开发者的笔记本电脑到在云中运行的运行生产集群，因为镜像封装了代码和所有依赖，消除了环境之间的潜在不兼容性。
- en: '![](Images/CH03_F02_Yuen.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH03_F02_Yuen.png)'
- en: Figure 3.2 The left side represents a non-container-based deployment that requires
    operating systems and run-time dependencies before the code can be deployed. The
    right side represents a container-based deployment that contains both code and
    run-time dependencies.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 左侧表示基于非容器的部署，在代码可以部署之前需要操作系统和运行时依赖。右侧表示基于容器的部署，包含代码和运行时依赖。
- en: Configuration of environment-specific application properties is typically deployed
    along with code and run-time dependencies, so the application instance can behave
    and connect to the correct dependencies per environment. Each environment could
    contain DB storage, distributed cache, or messaging (such as data) for isolation.
    Environments also have their own networking policy for ingress and egress for
    traffic isolation and custom access control. For example, ingress and egress can
    be configured to block traffic between preprod and prod environments for security.
    Access control can be configured to restrict access to the production environment
    to only a small set of engineers, while preprod environments are accessible by
    the entire development team.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 环境特定应用程序属性的配置通常与代码和运行时依赖一起部署，以便应用程序实例可以针对每个环境的行为和连接到正确的依赖项。每个环境都可能包含用于隔离的 DB
    存储、分布式缓存或消息传递（如数据）。环境还有自己的网络策略，用于隔离流量和自定义访问控制。例如，可以配置入口和出口以阻止预生产和生产环境之间的流量，以增强安全性。可以配置访问控制以仅允许一小部分工程师访问生产环境，而预生产环境则对整个开发团队开放。
- en: '![](Images/CH03_F03_Yuen.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH03_F03_Yuen.png)'
- en: Figure 3.3 An environment consists of application instances, ingress/egress
    for networking, and access control to protect its resources. An environment also
    includes application dependencies such as cache, DB, or messaging.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 环境由应用程序实例、网络入口/出口和用于保护其资源的访问控制组成。环境还包括应用程序依赖项，如缓存、DB 或消息传递。
- en: Picking the right granularity
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 选择合适的粒度
- en: Ultimately, the goal is for all new code to be deployed to production so that
    customers and end users can begin using it as soon as it passes quality testing.
    Delays in deploying code to production result in the postponement of realizing
    the new code’s business value produced by the development team. Picking the right
    environment granularity is critical for code to be deployed without delay. Factors
    to be considered are
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最终目标是所有新代码都能部署到生产环境中，以便客户和最终用户可以在代码通过质量测试后立即开始使用它。将代码部署到生产环境的延迟会导致开发团队产生的新代码的商业价值实现推迟。选择合适的环境粒度对于代码无延迟部署至关重要。需要考虑的因素包括
- en: '*Release independence*—If the code needs to be bundled with code from other
    teams to be deployed, one team’s deployment cycle is subject to the readiness
    of the code produced by the other teams. The right granularity should enable your
    code to be deployed without dependencies on other teams/code.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*发布独立性*——如果代码需要与其他团队的代码捆绑在一起进行部署，则一个团队的部署周期将受制于其他团队生成的代码的可用性。正确的粒度应使您的代码能够独立于其他团队/代码进行部署。'
- en: '*Test boundary*—Like release independence, testing of the new code should be
    independent of other code releases. If new code testing depends on other teams/code,
    the release cycle will be subject to the readiness of the others.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*测试边界*——类似于发布独立性，新代码的测试应该独立于其他代码发布。如果新代码测试依赖于其他团队/代码，则发布周期将受制于其他团队的准备情况。'
- en: '*Access control*—In addition to separate access control for preprod and prod,
    each environment can limit access control to only the team actively working on
    the codebase.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*访问控制*——除了预生产和生产环境的单独访问控制之外，每个环境还可以限制访问控制，仅限于积极在代码库上工作的团队。'
- en: '*Isolation*—Each environment is a logical work unit and should be isolated
    from other environments to avoid the “noisy neighbor” problem and limit access
    from different environments for security reasons.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*隔离*——每个环境是一个逻辑工作单元，应该与其他环境隔离，以避免“嘈杂邻居”问题并限制出于安全原因来自不同环境的访问。'
- en: 3.1.2 Namespace management
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2 命名空间管理
- en: 'Namespaces are a natural construct in Kubernetes to support environments. They
    allow dividing cluster resources among multiple teams or projects. Namespaces
    provide a scope for unique resource naming, resource quotas, RBAC, hardware isolation,
    and network configuration:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是 Kubernetes 支持环境的自然结构。它们允许将集群资源分配给多个团队或项目。命名空间提供了独特资源命名、资源配额、RBAC、硬件隔离和网络配置的范围：
- en: '*Kubernetes Namespace ~= Environment*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*Kubernetes 命名空间 ~= 环境*'
- en: In each Namespace, the application instance (aka Pod) is one or more Docker
    containers injected with environment-specific application properties during deployment.
    These application properties define how the environment should run (such as feature
    flags) and what external dependencies should be used (such as database connection
    strings).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个命名空间中，应用程序实例（即 Pod）是一个或多个在部署期间注入了特定环境应用程序属性的 Docker 容器。这些应用程序属性定义了环境应该如何运行（例如功能标志）以及应该使用哪些外部依赖项（例如数据库连接字符串）。
- en: In addition to the application Pods, the Namespace may also contain other Pods
    that provide additional functionality required by the environment.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 除了应用程序 Pod 之外，命名空间还可能包含其他提供环境所需额外功能的 Pod。
- en: '![](Images/CH03_F04_Yuen.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH03_F04_Yuen.png)'
- en: Figure 3.4 A Namespace is the equivalent of an environment in Kubernetes. Namespaces
    may consist of Pods (application instance), network policies (ingress/egress),
    and RBAC (access control), as well as application dependencies running in separate
    Pods.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 在 Kubernetes 中，命名空间相当于环境。命名空间可能包括 Pod（应用程序实例）、网络策略（入口/出口）和 RBAC（访问控制），以及运行在单独
    Pod 中的应用程序依赖项。
- en: RBAC is a method of regulating access to computer or network resources based
    on the roles of individual users within an enterprise. In Kubernetes, a role contains
    rules that represent a set of permissions. Permissions are purely additive (there
    are no deny rules). A role can be defined within a Namespace with a role or clusterwide
    with a ClusterRole.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC 是一种基于企业内部个人用户角色的计算机或网络资源访问控制方法。在 Kubernetes 中，一个角色包含代表一组权限的规则。权限是纯粹累加的（没有拒绝规则）。一个角色可以在命名空间内定义，具有角色或集群范围定义的
    ClusterRole。
- en: Namespaces can also have dedicated hardware and networking policies to optimize
    their configuration based on application requirements. For example, a CPU-intensive
    application can deploy in a Namespace with dedicated multicore hardware. Another
    service requiring heavy disk I/O can be deployed in a separate Namespace with
    high-speed SSD. Each Namespace can also define its networking policy (ingress/egress)
    to limit cross-Namespace traffic or accessing other Namespaces within the cluster
    using unqualified DNS names.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间还可以拥有专用硬件和网络策略，以根据应用程序需求优化其配置。例如，一个计算密集型应用程序可以在具有专用多核硬件的命名空间中部署。另一个需要大量磁盘
    I/O 的服务可以部署在具有高速 SSD 的单独命名空间中。每个命名空间还可以定义其网络策略（入口/出口），以限制跨命名空间流量或使用未经验证的 DNS 名称访问集群内的其他命名空间。
- en: Deploy an app in two different environments
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的环境中部署应用程序
- en: In this section, you will learn how to deploy the same app in two different
    environments (a test environment called guestbook-qa and a preprod end-to-end
    environment called guestbook-e2e) with different configurations using Namespaces.
    The application we will use for this exercise is the Guestbook Kubernetes example
    application.^([1](#pgfId-1076726))
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何使用命名空间在两个不同的环境中部署相同的应用程序（一个名为 guestbook-qa 的测试环境和一个名为 guestbook-e2e
    的预生产端到端环境），并使用不同的配置。我们将使用 Guestbook Kubernetes 示例应用程序进行此练习。[1](#pgfId-1076726)
- en: '![](Images/CH03_F05_Yuen.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH03_F05_Yuen.png)'
- en: Figure 3.5 Guestbook front\end architecture will have a service to expose the
    guestbook web frontend to live traffic. The backend architecture consists of Redis
    Master and Redis Slave for the data.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 Guestbook 前端架构将有一个服务来将 guestbook 网页前端暴露给实时流量。后端架构由 Redis 主节点和 Redis 从节点组成，用于数据。
- en: Exercise overview
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 练习概述
- en: Create environment Namespaces (guestbook-qa and guestbook-e2e).
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建环境命名空间（guestbook-qa 和 guestbook-e2e）。
- en: Deploy the guestbook application to the guestbook-qa environment.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 guestbook 应用程序部署到 guestbook-qa 环境。
- en: Test the guestbook-qa environment.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试 guestbook-qa 环境。
- en: Promote the guestbook application to the guestbook-e2e environment.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 guestbook 应用程序提升到 guestbook-e2e 环境。
- en: Test the guestbook-e2e environment.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试 guestbook-e2e 环境。
- en: Verify Kubernetes cluster connection Before you begin, verify that you have
    correctly configured your `KUBECONFIG` environment variable to point to the desired
    Kubernetes cluster. Please refer to appendix A for more information.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 验证 Kubernetes 集群连接 在您开始之前，请确保您已正确配置 `KUBECONFIG` 环境变量以指向所需的 Kubernetes 集群。有关更多信息，请参阅附录
    A。
- en: 'First, create the guestbook-qa and guestbook-e2e Namespaces for each of your
    guestbook environments:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为您的每个 guestbook 环境创建 guestbook-qa 和 guestbook-e2e 命名空间：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now you can deploy the guestbook application to the guestbook-qa environment
    using the following commands:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用以下命令将 guestbook 应用程序部署到 guestbook-qa 环境：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Before we proceed, let’s test that the guestbook-qa environment is working
    as expected. Use the following minikube command to find the URL to the guestbook-qa
    service, and then open the URL in your web browser:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们测试一下 guestbook-qa 环境是否按预期工作。使用以下 minikube 命令查找 guestbook-qa 服务的 URL，然后在您的网页浏览器中打开该
    URL：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the Messages text edit of the guestbook application, type something like
    `This` `is the` `guestbook-qa` `environment` and press the Submit button. Your
    screen should look something like figure 3.6.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 guestbook 应用程序的 Messages 文本编辑中，输入类似 `This` `is the` `guestbook-qa` `environment`
    的内容，然后按提交按钮。您的屏幕应该看起来像图 3.6 所示。
- en: '![](Images/CH03_F06_Yuen.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH03_F06_Yuen.png)'
- en: Figure 3.6 When you have your guestbook app deployed to QA, you can open the
    browser and submit a test message to verify your deployment.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 当您的 guestbook 应用程序已部署到 QA 时，您可以在浏览器中提交测试消息以验证您的部署。
- en: 'Now that we have the Guestbook application running in the guestbook-qa environment
    and have tested that it is working correctly, let’s promote guestbook-qa to the
    guestbook-e2e environment. In this case, we are going to use exactly the same
    YAML as was used in the guestbook-qa environment. This is similar to how your
    automated CD pipeline would work:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经将 Guestbook 应用程序运行在 guestbook-qa 环境中，并已测试其工作正常，让我们将 guestbook-qa 提升到
    guestbook-e2e 环境。在这种情况下，我们将使用与 guestbook-qa 环境中使用的完全相同的 YAML 文件。这类似于您的自动化 CD 管道的工作方式：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Great! The Guestbook app has now been deployed to the guestbook-e2e environment.
    Now let’s test that the guestbook-e2e environment is working correctly:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！Guestbook 应用程序现在已部署到 guestbook-e2e 环境。现在让我们测试一下 guestbook-e2e 环境是否工作正常：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Similar to what you did in the guestbook-qa environment, type something like
    `This is` `the` `guestbook-e2e environment,` `NOT` `the` `guestbook-qa` `environment!`
    in the Messages text edit and press the Submit button. Your screen should look
    something like figure 3.7.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与您在 guestbook-qa 环境中所做的一样，在 Messages 文本编辑中输入类似 `This is` `the` `guestbook-e2e`
    `environment,` `NOT` `the` `guestbook-qa` `environment!` 的内容，然后按提交按钮。您的屏幕应该看起来像图
    3.7 所示。
- en: '![](Images/CH03_F07_Yuen.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH03_F07_Yuen.png)'
- en: Figure 3.7 When you have your guestbook app deployed to QA, you can open the
    browser and submit a test message to verify your deployment.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 当您的 guestbook 应用程序已部署到 QA 时，您可以在浏览器中提交测试消息以验证您的部署。
- en: The important thing here is to realize that you have identical applications
    running in two different environments defined by Kubernetes Namespaces. Notice
    that each application is maintaining an independent copy of its data. If you enter
    a message in the QA Guestbook, it doesn’t show up in the E2E Guestbook. These
    are two different environments.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的是要意识到你在两个不同的环境中运行着相同的应用程序，这些环境由Kubernetes命名空间定义。请注意，每个应用程序都在维护其数据的独立副本。如果你在QA
    Guestbook中输入一条消息，它不会出现在E2E Guestbook中。这些是两个不同的环境。
- en: Exercise 3.1
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 练习3.1
- en: Now that you have created two preprod environments, guestbook-qa and guestbook-e2e,
    create two additional production environments, guestbook-stage and guestbook-prod,
    in a new production cluster.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了两个预生产环境，guestbook-qa和guestbook-e2e，在新的生产集群中创建另外两个生产环境，guestbook-stage和guestbook-prod。
- en: HINT You can create a new minikube cluster with the command `minikube start`
    `-p` `production` and switch between them using `kubectl` `config use-context
    <name>`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：你可以使用命令`minikube start` `-p` `production`创建一个新的minikube集群，并使用`kubectl config
    use-context <name>`在它们之间切换。
- en: 'Case study: Intuit environment management'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 案例研究：Intuit环境管理
- en: 'At Intuit, we organize our Namespaces per service and per environment in each
    AWS region with the separation of preprod and prod clusters. A typical service
    will have six Namespaces: QA, E2E, Stage/Prod West, and Stage/Prod East. QA and
    E2E Namespaces will be in the preprod cluster with open access to the corresponding
    team. Stage/Prod West and Stage/Prod East will be in the production cluster with
    restricted access.^a'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在Intuit，我们根据服务和环境在每个AWS区域中组织命名空间，并在预生产集群和prod集群之间进行分离。一个典型的服务将拥有六个命名空间：QA、E2E、Stage/Prod
    West和Stage/Prod East。QA和E2E命名空间将在预生产集群中，对相应团队开放访问。Stage/Prod West和Stage/Prod East将位于生产集群中，访问受限.^a
- en: ^a [https://www.cncf.io/case-study/intuit.](https://www.cncf.io/case-study/intuit/)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ^a [https://www.cncf.io/case-study/intuit.](https://www.cncf.io/case-study/intuit/)
- en: 3.1.3 Network isolation
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.3 网络隔离
- en: A critical aspect of defining environments for deploying your application is
    to ensure only the intended clients can access the specific environment. By default,
    all Namespaces can connect to services running in all other Namespaces. But in
    the case of two different environments, such as QA and Prod, you would not want
    cross-talk between those environments. Luckily, it is possible to apply a Namespace
    network policy that restricts network communication between Namespaces. Let’s
    look at how we can deploy an application to two different Namespaces and control
    access using network policies.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 定义部署应用程序的环境的一个关键方面是确保只有预期的客户端可以访问特定的环境。默认情况下，所有命名空间都可以连接到所有其他命名空间中运行的服务。但在QA和Prod这样的两个不同环境的情况下，你不想这些环境之间有交叉通信。幸运的是，可以应用命名空间网络策略来限制命名空间之间的网络通信。让我们看看我们如何将应用程序部署到两个不同的命名空间，并使用网络策略来控制访问。
- en: We will go over the steps to deploy services in two different Namespaces. You
    will also modify the network policies and observe the effects.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍在两个不同的命名空间中部署服务的步骤。你还将修改网络策略并观察其效果。
- en: Overview
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: Create environment Namespaces (qa and prod).
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建环境命名空间（qa和prod）。
- en: Deploy curl to the qa and prod Namespaces.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将curl部署到qa和prod命名空间。
- en: Deploy NGINX to the prod Namespace.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将NGINX部署到prod命名空间。
- en: Curl NGINX from both the qa and prod Namespaces (both work).
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从qa和prod命名空间（都可行）使用curl访问NGINX。
- en: Block incoming traffic to the prod Namespace from the qa Namespace.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从qa命名空间阻止对prod命名空间的入站流量。
- en: Curl NGINX from the qa Namespace (blocked).
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从qa命名空间（被阻止）使用curl访问NGINX。
- en: EGRESS *Egress* traffic is network traffic that begins inside a network and
    proceeds through its routers to a destination somewhere outside the network.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 出站*Egress*流量是开始于网络内部并通过其路由器流向网络外部的网络流量。
- en: Ingress *Ingress* traffic is composed of all the data communications and network
    traffic originating from external networks.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 入站*Ingress*流量由所有来自外部网络的数据通信和网络流量组成。
- en: Verify Kubernetes cluster connection Before you begin, verify that you have
    correctly configured your `KUBECONFIG` environment variable to point to the desired
    Kubernetes cluster. Please refer to appendix A for more information.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请验证你是否已正确配置了`KUBECONFIG`环境变量以指向所需的Kubernetes集群。请参阅附录A获取更多信息。
- en: '![](Images/CH03_F08_Yuen.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH03_F08_Yuen.png)'
- en: Figure 3.8 For the Curl Pod in QA to reach the Web Pod in Prod, the Curl Pod
    will need to go through the QA egress to reach the Prod ingress. Then the Prod
    ingress will route the traffic to the Web Pod in Prod.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 对于QA中的Curl Pod要到达生产环境中的Web Pod，Curl Pod需要通过QA出口到达生产入口。然后生产入口将流量路由到生产环境中的Web
    Pod。
- en: 'First, create the Namespaces for each of your environments:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为您的每个环境创建命名空间：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now we will create a Pod in both Namespaces from where we can run the Linux
    command `curl`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将同时在两个命名空间中创建一个Pod，从该Pod我们可以运行Linux命令`curl`：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Listing 3.1 curlpod.yaml
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.1 curlpod.yaml
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the prod Namespace, we will run an NGINX server that will receive the `curl`
    HTTP request:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产命名空间中，我们将运行一个NGINX服务器，该服务器将接收`curl` HTTP请求：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Listing 3.2 web.yaml
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.2 web.yaml
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'By default, Pods running in a Namespace can send network traffic to other Pods
    running in different Namespaces. Let’s prove this by executing a `curl` command
    from the Pod in the qa Namespace to the NGINX Pod in the prod Namespace:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在命名空间中运行的Pod可以向运行在不同命名空间中的其他Pod发送网络流量。让我们通过从qa命名空间中的Pod执行`curl`命令到生产命名空间中的NGINX
    Pod来证明这一点：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Gets the web Pod IP address
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取Web Pod的IP地址
- en: ❷ Gets back HTTP 200
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回HTTP 200
- en: ❸ Gets back HTTP 200
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 返回HTTP 200
- en: Typically, you never want your qa and prod environments to have dependencies
    between each other. It may be that if both instances of the application were properly
    configured, there would not be dependencies between qa and prod, but what if there
    was a bug in the configuration of qa where it was accidentally sending traffic
    to prod? You could potentially be corrupting production data. Or even within production,
    what if one environment was hosting your marketing site and another environment
    was hosting an HR application with sensitive data? In these cases, it may be appropriate
    to block network traffic between Namespaces or only allow network traffic between
    particular Namespaces. This can be accomplished by adding a `NetworkPolicy` to
    a Namespace.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您不希望qa和生产环境之间存在依赖关系。可能的情况是，如果应用程序的两个实例都正确配置，qa和生产之间可能没有依赖关系，但如果有qa配置中的错误，意外地向生产发送流量怎么办？您可能会损坏生产数据。或者，即使在生产环境中，如果一个环境托管您的营销网站，另一个环境托管一个包含敏感数据的HR应用程序，这种情况可能也是合适的。在这些情况下，可能有必要在命名空间之间阻止网络流量，或者仅允许特定命名空间之间的网络流量。这可以通过向命名空间添加一个`NetworkPolicy`来实现。
- en: 'Let’s add a `NetworkPolicy` to our Pods in each Namespace:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在每个命名空间中的Pod上添加一个`NetworkPolicy`：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Container network interface Network policy is supported only if Container Network
    Interface (CNI)^([2](#pgfId-1076918)) is configured (neither minikube nor Docker
    desktop). Please refer to appendix A for more information to test the configuration
    of network policies.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 容器网络接口Network policy仅在配置了容器网络接口（CNI）^([2](#pgfId-1076918)）的情况下受支持（minikube和Docker
    desktop均不支持）。请参阅附录A以获取有关测试网络策略配置的更多信息。
- en: Listing 3.3 Network policy [(http://mng.bz/WdAX)](https://shortener.manning.com/WdAX)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.3 网络策略 [(http://mng.bz/WdAX)](https://shortener.manning.com/WdAX)
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Applies to Namespace prod
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 适用于生产命名空间
- en: ❷ Selects all Pods in Namespace prod
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 选择生产命名空间中的所有Pod
- en: ❸ Specifies ingress to allow requests coming from prod Namespace only. Requests
    from other Namespaces will be blocked.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 仅允许来自生产命名空间的请求入站。来自其他命名空间的请求将被阻止。
- en: This `NetworkPolicy` is applied to the prod Namespace and allows only ingress
    (incoming network traffic) from the prod Namespace. Correctly using `NetworkPolicy`
    constraints is a critical aspect of defining environment boundaries.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此`NetworkPolicy`应用于生产命名空间，并且只允许来自生产命名空间的入站（入网流量）。正确使用`NetworkPolicy`约束是定义环境边界的关键方面。
- en: 'With the `NetworkPolicy` applied, we can rerun our `curl` commands to verify
    that each Namespace is now isolated from the others:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 应用了`NetworkPolicy`后，我们可以重新运行我们的`curl`命令来验证每个命名空间现在是否已与其他命名空间隔离：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Curl from namespace qa is blocked!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从qa命名空间发起的Curl请求被阻止！
- en: ❷ Gets back Http 200
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回Http 200
- en: 3.1.4 Preprod and prod clusters
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.4 预生产和生产集群
- en: Now that you know how to create multiple environments using Namespaces, it might
    seem like a trivial thing to use one cluster and create all the environments you
    need on that single cluster. For example, you may need QA, E2E, Stage, and Prod
    environments for your application. However, depending on your specific use case,
    this may not be the best approach. Our recommendation is to have two clusters
    to host your environments, one preprod cluster for preproduction environments
    and one prod cluster for production environments.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何使用命名空间创建多个环境，可能觉得在一个集群上创建所有所需的环境是一件微不足道的事情。例如，你可能需要为你的应用程序提供QA、E2E、阶段和Prod环境。然而，根据你的具体用例，这可能不是最佳方法。我们的建议是拥有两个集群来托管你的环境，一个用于预生产环境的预生产集群，一个用于生产环境的生产集群。
- en: The primary reason for having two separate clusters to host your environments
    is to protect your production environment from accidental outages or other impacts
    related to work being done with the preproduction environments.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有两个独立的集群来托管你的环境的主要原因是保护你的生产环境免受预生产环境工作中意外中断或其他影响。
- en: Cluster isolation in Amazon Web Services (AWS) In AWS, a separate VPC can be
    created for preprod and prod as a logical boundary to isolate the traffic and
    data. For even stronger isolation and more control on production credentials and
    access, the separate production virtual private cloud should be hosted in a different
    production AWS account.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊网络服务（AWS）中的集群隔离。在AWS中，可以创建一个单独的VPC来作为逻辑边界，用于隔离预生产和生产环境的流量和数据。为了获得更强的隔离和更多对生产凭据和访问的控制，应将单独的生产虚拟私有云托管在不同的生产AWS账户中。
- en: Someone might ask why we should have so many environments and separation of
    preprod and prod clusters. The simple answer is that a preprod cluster is needed
    to test the code before release into the production cluster. At Intuit, we use
    our QA environment for integration testing and E2E environment as a stable environment
    for other services to test prerelease features. If you are doing multibranch concurrent
    development, you can also configure additional preprod test environments for each
    of the branches.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有人可能会问为什么我们应该有这么多环境，以及预生产和生产集群的分离。简单的答案是，需要一个预生产集群来在发布到生产集群之前测试代码。在Intuit，我们使用我们的QA环境进行集成测试，将E2E环境作为其他服务测试预发布功能的稳定环境。如果你正在进行多分支并发开发，你也可以为每个分支配置额外的预生产测试环境。
- en: A key advantage of configuration management with Kubernetes is that since it
    uses Docker Containers, which are immutable portable images, the only differences
    with the deployments between environments is the Namespace configuration, environment-specific
    properties, and application dependencies such as caching or database. Preprod
    testing can verify your service code’s correctness, while the stage environment
    in the production cluster can be used to verify your application dependencies’
    correctness.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Kubernetes进行配置管理的关键优势在于，由于它使用不可变的可移植镜像Docker容器，因此不同环境之间的部署差异仅限于命名空间配置、特定环境的属性以及如缓存或数据库之类的应用程序依赖。预生产测试可以验证你的服务代码的正确性，而生产集群中的阶段环境可以用来验证你的应用程序依赖的正确性。
- en: Preprod and prod clusters should follow the same security best practices and
    operational rigor. Security issues can be detected early in the development cycle,
    and developer productivity is not interrupted if preprod clusters are operated
    with the same standards as production.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 预生产和生产集群应遵循相同的最佳安全实践和操作严谨性。安全问题可以在开发周期的早期被发现，如果预生产集群以与生产相同的标准运行，则不会打断开发者的生产力。
- en: 3.2 Git strategies
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 Git策略
- en: 'Using a separate Git repository to hold your Kubernetes manifests (aka config),
    keeping the config separate from your application source code, is highly recommended
    for the following reasons:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单独的Git仓库来存储你的Kubernetes清单（即配置），将配置与应用程序源代码分离，出于以下原因强烈推荐：
- en: It provides a clean separation of application code and application config. There
    will be times when you wish to modify the manifests without triggering an entire
    CI build. For example, you likely do not want to trigger a build if you simply
    want to bump the number of replicas in a Deployment spec.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了应用代码和应用配置的清晰分离。有时你可能希望修改清单而不触发整个CI构建。例如，如果你只是想增加Deployment规范中副本的数量，你可能不想触发构建。
- en: Application config vs. secrets In GitOps, application configuration generally
    excludes secrets since using Git to store secrets is a bad practice. There are
    several approaches for handling sensitive information (passwords, certificates,
    and so on), discussed in detail in chapter 7.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应用程序配置与机密信息 在 GitOps 中，应用程序配置通常不包括机密信息，因为使用 Git 存储机密是一种不良做法。在第 7 章中详细讨论了处理敏感信息（密码、证书等）的几种方法。
- en: Audit log is cleaner. For auditing purposes, a repo that only holds configuration
    will have a much cleaner Git history of what changes were made without the noise
    coming from check-ins due to regular development activity.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审计日志更清晰。出于审计目的，仅持有配置的仓库将有一个更干净的 Git 历史记录，记录了所做的更改，而没有来自常规开发活动的检查入的噪音。
- en: Your application may comprise services built from multiple Git repositories
    but deployed as a single unit. Frequently, microservices applications are composed
    of services with different versioning schemes and release cycles (such as ELK,
    Kafka, and Zookeeper). It may not make sense to store the manifests in one of
    the source code repositories of a single component.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的应用程序可能由多个 Git 仓库构建的服务组成，但作为单个单元部署。通常，微服务应用程序由具有不同版本控制和发布周期的服务组成（例如 ELK、Kafka
    和 Zookeeper）。将清单存储在单个组件的源代码仓库中可能没有意义。
- en: Access is separated. The developers who are developing the application may not
    necessarily be the same people who can/should push to production environments,
    either intentionally or unintentionally. Having separate repositories allows commit
    access to be given to the source code repo and not the application config repo,
    which can be reserved for a more select group of team members.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问是分开的。正在开发应用程序的开发人员可能不是可以/应该推送到生产环境的人，无论是故意还是无意。拥有单独的仓库允许将提交访问权限给予源代码仓库，而不是应用程序配置仓库，后者可以保留给更精选的团队成员组。
- en: If you are automating your CI pipeline, pushing manifest changes to the same
    Git repository can trigger an infinite loop of build jobs and Git commit triggers.
    Having a separate repo to push config changes to prevents this from happening.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您正在自动化您的 CI 管道，将清单更改推送到同一个 Git 仓库可能会触发构建作业和 Git 提交触发的无限循环。有一个单独的仓库来推送配置更改可以防止这种情况发生。
- en: For your code repositories, you can use whatever branching strategy you like
    (such as GitFlow) since it is only used for your CI. For your config repositories
    (which will be used for your CD), you need to consider the following strategies
    based on your organization size and tooling.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您的代码仓库，您可以使用您喜欢的任何分支策略（例如 GitFlow），因为这只是用于您的 CI。对于您的配置仓库（将用于您的 CD），您需要根据您的组织规模和工具考虑以下策略。
- en: 3.2.1 Single branch (multiple directories)
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 单分支（多个目录）
- en: With the single-branch strategy, the main branch will always contain the exact
    config used in each environment. There will be a default config for all environments
    with an environment-specific overlay defined in separate environment-specific
    directories. The single-branch strategy can be easily supported by tools such
    as Kustomize (section 3.3).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单分支策略时，主分支将始终包含每个环境中使用的确切配置。所有环境将有一个默认配置，并在单独的环境特定目录中定义环境特定覆盖。单分支策略可以很容易地通过
    Kustomize 等工具（第 3.3 节）得到支持。
- en: '![](Images/CH03_F09_Yuen.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH03_F09_Yuen.png)'
- en: Figure 3.9 The single-branch strategy will have one master branch and a subdirectory
    for each environment. Each subdirectory will contain the environment-specific
    overlay.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 单分支策略将有一个主分支和每个环境的子目录。每个子目录将包含环境特定的覆盖。
- en: In our CI/CD example, we will have environment-specific override directories
    for qa, e2e, stage, and prod. Each directory will contain environment-specific
    settings such as replica count, CPU, and memory request/limit.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 CI/CD 示例中，我们将为 qa、e2e、stage 和 prod 环境设置特定的覆盖目录。每个目录将包含特定环境的设置，例如副本数量、CPU
    和内存请求/限制。
- en: '![](Images/CH03_F10_Yuen.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH03_F10_Yuen.png)'
- en: Figure 3.10 Example with qal, e2e, stage, and production subdirectories. Each
    subdirectory will contain overlays such as replica count, CPU, and memory request/limit.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 使用 qal、e2e、stage 和生产子目录的示例。每个子目录将包含副本数量、CPU 和内存请求/限制等覆盖。
- en: 3.2.2 Multiple branches
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.2 多分支
- en: With the multiple-branches strategy, each branch is equivalent to an environment.
    The advantage here is that each branch will have the exact manifest for the environment
    without using any tool such as Kustomize. Each branch will also have a separate
    commit history for audit trail and rollback if needed. The disadvantage is that
    there will be no sharing of the common config among environments since tooling
    such as Kustomize does not work with Git branches.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在多分支策略中，每个分支都相当于一个环境。这里的优势是每个分支都将拥有该环境的精确清单，而无需使用任何工具，如Kustomize。每个分支还将拥有独立的提交历史，以便进行审计跟踪和需要时回滚。缺点是，由于工具如Kustomize不与Git分支一起工作，因此环境之间将无法共享通用配置。
- en: '![](Images/CH03_F11_Yuen.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图3.11](Images/CH03_F11_Yuen.png)'
- en: Figure 3.11 In the multiple-branches strategy, each branch is equivalent to
    an environment. Each branch will contain the exact manifest instead of an overlay.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 在多分支策略中，每个分支都相当于一个环境。每个分支将包含确切的清单，而不是覆盖。
- en: It may be possible to merge common infrastructure changes between multiple branches.
    Suppose that a new resource needs to be added to all environments. In that case,
    that resource could be added first to the QA branch and tested, and then merged
    (cherry-picked) into each successive branch after the appropriate testing was
    completed.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 可能可以在多个分支之间合并常见的基础设施更改。假设需要将新资源添加到所有环境中。在这种情况下，该资源可以首先添加到QA分支并测试，然后在适当的测试完成后合并（
    cherry-picked）到每个后续分支。
- en: 3.2.3 Multirepo vs. monorepo
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.3 多仓库与单仓库对比
- en: If you are in a startup environment with a single scrum team, you may not want
    (or need) the complexity of multiple repositories. All your code could be in one
    code repository with all your deployment configuration in one deployment repository.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个只有一个敏捷团队的初创环境中，你可能不希望（或需要）多个仓库的复杂性。所有代码都可以在一个代码仓库中，所有部署配置在一个部署仓库中。
- en: However, if you are in an enterprise environment with dozens (or hundreds) of
    developers, you will likely want to have multiple repos so that teams can be decoupled
    from each other and each run at their own speed. For example, different teams
    within the organization will have a different cadence and release process for
    their code. If a mono config repo is used, some features may be completed for
    weeks but need to wait for the scheduled release. This could mean delaying getting
    features into the hands of end users and discovering potential code issues. Rollback
    is also problematic since one code defect will require rolling back all changes
    from every team.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你在一个拥有数十（或数百）开发者的企业环境中，你可能会希望拥有多个仓库，以便团队可以相互解耦，并且各自以自己的速度运行。例如，组织内部的不同团队将会有不同的代码节奏和发布流程。如果使用单一配置仓库，某些功能可能需要几周时间才能完成，但需要等待计划中的发布。这可能会导致将功能交付给最终用户的时间延迟，并发现潜在的代码问题。回滚也存在问题，因为一个代码缺陷将需要回滚每个团队的所有更改。
- en: '![](Images/CH03_F12_Yuen.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图3.12](Images/CH03_F12_Yuen.png)'
- en: Figure 3.12 Monorepo is a single Git repo with multiple projects. In multirepo,
    each project will have a dedicated Git repo.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 单仓库是一个包含多个项目的单一Git仓库。在多仓库中，每个项目都将有一个专门的Git仓库。
- en: Another consideration for using multiple repos is to organize applications based
    on capabilities. If the repos are focused on discrete deployable capabilities,
    it will be easier to move the responsibility of those capabilities among teams
    (such as after a reorg).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个仓库的另一个考虑因素是根据功能组织应用程序。如果仓库专注于离散的可部署功能，那么在团队之间（如重组后）移动这些功能的责任将更容易。
- en: 3.3 Configuration management
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 配置管理
- en: As we saw in the tutorial and exercises in section 3.1, environment configuration
    management can be as simple as having a directory for each environment that contains
    the YAML manifests of all resources that should be deployed. All the values in
    these YAML manifests can be hardcoded to the particular values desired for that
    environment. To deploy, you run `kubectl apply -f <directory>`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在3.1节中的教程和练习中看到的，环境配置管理可以像为每个环境创建一个目录那样简单，该目录包含应部署的所有资源的YAML清单。这些YAML清单中的所有值都可以硬编码为特定环境的特定值。要部署，你运行`kubectl
    apply -f <directory>`。
- en: However, the reality is that managing multiple configurations in that way becomes
    unwieldy and error prone quickly. What if you need to add a new resource? You
    need to make sure you add that resource to the YAML in each of your environments.
    What if that resource needs specific properties (like replicas) to have different
    values for different environments? You need to carefully make all the correct
    customizations in all the right files.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现实情况是，以那种方式管理多个配置很快就会变得难以控制且容易出错。如果你需要添加一个新资源呢？你需要确保将那个资源添加到每个环境中的YAML文件中。如果那个资源需要特定属性（如副本）在不同环境中具有不同的值呢？你需要仔细地在所有正确的文件中做出所有正确的自定义设置。
- en: Several tools have been developed that address this need for configuration management.
    We will review each of the more popular configuration management tools later in
    this section. But first, let’s discuss what the factors are that you should consider
    when choosing which particular tool to use.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 已经开发出一些工具来满足配置管理的需求。我们将在本节稍后回顾每个更受欢迎的配置管理工具。但首先，让我们讨论一下在选择特定工具时应考虑的因素。
- en: 'Good Kubernetes configuration tools have the following properties:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的Kubernetes配置工具具有以下特性：
- en: '*Declarative*—The config is unambiguous, deterministic, and not system-dependent.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*声明式*—配置是明确的、确定的，并且不依赖于系统。'
- en: '*Readable*—The config is written in a way that is easy to understand.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可读性*—配置是以易于理解的方式编写的。'
- en: '*Flexible*—The tool helps facilitate and does not get in the way of accomplishing
    what you are trying to do.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*灵活*—该工具有助于促进并不会妨碍你完成想要做的事情。'
- en: '*Maintainable*—The tool should promote reuse and composability.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可维护性*—工具应促进重用和可组合性。'
- en: 'There are several reasons why Kubernetes config management is so challenging:
    what sounds like a simple act of deploying an application can have wildly different,
    even opposing, requirements, and it’s difficult for a single tool to accommodate
    all such requirements. Imagine the following use cases:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes配置管理之所以如此具有挑战性，有几个原因：看似简单的部署应用程序的行为可能会有截然不同，甚至相反的要求，而单个工具很难满足所有这些要求。想象以下用例：
- en: A cluster operator deploys third-party, off-the-shelf applications such as WordPress
    to their cluster with little to no customization of those apps. The most important
    criterion for this use case is to easily receive updates from an upstream source
    and upgrade their application as quickly and seamlessly as possible (new versions,
    security patches, and so on).
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集群管理员将第三方现成应用程序（如WordPress）部署到他们的集群中，对这些应用程序几乎没有或没有进行定制。对于这个用例，最重要的标准是能够轻松地从上游源接收更新，并以尽可能快速和无缝的方式升级他们的应用程序（新版本、安全补丁等）。
- en: A software-as-a-service (SaaS) application developer deploys their bespoke application
    to one or more environments (Dev, Staging, Prod-West, Prod-East). These environments
    may be spread across different accounts, clusters, and Namespaces with subtle
    differences between them, so configuration reuse is paramount. For this use case,
    it is important to go from a Git commit in their codebase to deploy to each of
    their environments in a fully automated way and manage their environments in a
    straightforward and maintainable way. These developers have zero interest in semantic
    versioning of their releases since they might be deploying multiple times a day.
    The notion of major, minor, and patch versions ultimately has no meaning for their
    application.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个软件即服务（SaaS）应用开发者将他们定制的应用程序部署到一个或多个环境中（开发、测试、Prod-West、Prod-East）。这些环境可能分布在不同的账户、集群和命名空间中，它们之间有细微的差别，因此配置重用至关重要。对于这个用例，从代码库中的Git提交到完全自动地将应用程序部署到每个环境，并以简单和可维护的方式管理环境，这一点非常重要。这些开发者对他们的发布版本没有语义版本化的兴趣，因为他们可能每天部署多次。主要版本、次要版本和补丁版本的概念最终对他们应用程序没有意义。
- en: As you can see, these are entirely different use cases, and more often than
    not, a tool that excels at one doesn’t handle the other well.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这些是完全不同的用例，而且往往一个在某个方面表现优异的工具在其他方面处理得并不好。
- en: 3.3.1 Helm
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 Helm
- en: Love it or hate it, Helm, being the first config tool on the scene, is an integral
    part of the Kubernetes ecosystem, and chances are that you’ve installed something
    at one point or another by running `helm install`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你喜欢它还是讨厌它，Helm作为第一个配置工具，是Kubernetes生态系统的一个基本组成部分，你很可能在某个时候通过运行`helm install`安装了某些东西。
- en: The important thing to note about Helm is that it is a self-described package
    manager for Kubernetes and doesn’t claim to be a configuration management tool.
    However, since many people use Helm templating for precisely this purpose, it
    belongs in this discussion. These users invariably end up maintaining several
    values.yaml, one for each environment (such as values-base.yaml, values-prod.yaml,
    and values-dev.yaml) and then parameterize their chart in such a way that environment-specific
    values can be used in the chart. This method more or less works, but it makes
    the templates unwieldy since Go templating is flat and needs to support every
    conceivable parameter for each environment, which ultimately litters the entire
    template with `{{-if` `/` `else}}` switches.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Helm，需要注意的是，它是一个自称为Kubernetes的包管理器，并不声称自己是配置管理工具。然而，由于许多人使用Helm模板正是为了这个目的，它属于这次讨论的范围。这些用户不可避免地会维护几个values.yaml文件，每个环境一个（例如values-base.yaml、values-prod.yaml和values-dev.yaml），然后以这种方式参数化他们的图表，以便可以在图表中使用特定环境的值。这种方法或多或少是可行的，但它使得模板难以管理，因为Go模板是扁平的，需要支持每个环境的每个可能的参数，这最终会在整个模板中充斥着`{{-if`
    `/` `else}}`开关。
- en: 'The good:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: '*There’s a chart for that.* Undoubtedly, Helm’s biggest strength is its excellent
    chart repository. Just recently, we needed to run a highly available Redis, without
    a persistent volume, to be used as a throwaway cache. There is something to be
    said for just being able to throw the `redis-ha` chart into your namespace, set
    `persistentVolume.enabled:` `false`, and point your service at it, and someone
    else has already done the hard work of figuring out how to run Redis reliably
    on a Kubernetes cluster.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*有图表就能解决*。毫无疑问，Helm最大的优势是其出色的图表仓库。最近，我们需要运行一个高可用的Redis，不使用持久卷，用作临时缓存。能够将`redis-ha`图表直接放入你的命名空间，设置`persistentVolume.enabled:`为`false`，并将你的服务指向它，这已经有人完成了在Kubernetes集群上可靠运行Redis的艰苦工作。'
- en: 'The bad:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: '*Go templating*—“Look at that beautiful and elegant Helm template!” said no
    one ever. It is well known that Helm templates suffer from a readability problem.
    We don’t doubt that this will be addressed with Helm 3’s support for Lua, but
    until then, well, we hope you like curly braces.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Go模板*—“看看那个美丽而优雅的Helm模板！”没有人这么说。众所周知，Helm模板存在可读性问题。我们相信Helm 3对Lua的支持将解决这个问题，但在此之前，嗯，我们希望你喜欢花括号。'
- en: '*Complicated SaaS CD pipelines*—For SaaS CI/CD pipelines, assuming you are
    using Helm the way it is intended (i.e., by running `helm install/upgrade`), an
    automated deploy in your pipeline might go several ways. In the best case, deploying
    from your pipeline will be as simple as'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*复杂的SaaS CD管道*—对于SaaS CI/CD管道，假设你正按照预期的方式使用Helm（即通过运行`helm install/upgrade`），你的管道中的自动化部署可能会有几种不同的方式。在最佳情况下，从你的管道中部署将像这样简单'
- en: '[PRE14]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: But in the worst case, where existing chart parameters cannot support your desired
    manifest changes, you go through a whole song and dance of bundling a new Helm
    chart, bumping its semantic version, publishing it to a chart repository, and
    redeploying with a Helm upgrade. In the Linux world, this is analogous to building
    a new RPM, publishing the RPM to a Yum repository, and then running `yum` `install`,
    all so you can get your shiny new CLI into /usr/bin. While this model works great
    for packaging and distribution, it’s an unnecessarily complicated and roundabout
    way to deploy your applications in the case of bespoke SaaS applications. For
    this reason, many people choose to run `helm template` and pipe the output to
    `kubectl apply`, but at that point, you are better off using some other tool that
    is specifically designed for this purpose.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但在最坏的情况下，如果现有的图表参数无法支持你想要的清单更改，你将不得不经历一系列的步骤：打包一个新的Helm图表，增加其语义版本，将其发布到图表仓库，然后使用Helm升级重新部署。在Linux世界中，这类似于构建一个新的RPM，将其发布到Yum仓库，然后运行`yum
    install`，所有这些只是为了让你可以将闪亮的新CLI放入`/usr/bin`。虽然这种模型对于打包和分发来说效果很好，但对于定制SaaS应用程序的部署来说，这是一个不必要的复杂且迂回的方式。因此，许多人选择运行`helm
    template`并将输出管道传输到`kubectl apply`，但到那时，你最好使用一些专门为此目的设计的其他工具。
- en: '*Nondeclarative by default*—If you ever added `--set` `param=value` to any
    one of your Helm deploys, I’m sorry to tell you that your deployment process is
    not declarative. These values are only recorded in the Helm ConfigMap netherworld
    (and maybe your Bash history), so hopefully you wrote those down somewhere. This
    is far from ideal if you ever need to re-create your cluster from scratch. A slightly
    better way would be to record all parameters in a new custom values.yaml that
    you can store in Git and deploy using `-f` `my-values.yaml`. However, this is
    annoying when you’re deploying an OTS chart from the Helm stable, and you don’t
    have an obvious place to store that values.yaml side-by-side to the relevant chart.
    The best solution that I’ve come up with is composing a new dummy chart with the
    upstream chart as a dependency. Still, we have yet to find a canonical way of
    updating a parameter in a values.yaml in a pipeline using a one-liner, short of
    running `sed`.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*默认非声明性*—如果你曾经在任何 Helm 部署中添加了 `--set` `param=value`，很抱歉地告诉你，你的部署过程不是声明性的。这些值只记录在
    Helm ConfigMap 的另一个世界（以及可能你的 Bash 历史记录）中，所以希望你在某处记录了这些值。如果你需要从头开始重新创建你的集群，这远远不是理想的。一个稍微好一点的方法是将所有参数记录在一个新的自定义
    values.yaml 文件中，你可以将其存储在 Git 中并使用 `-f` `my-values.yaml` 进行部署。然而，当你从 Helm 稳定版部署
    OTS 图表时，这会变得很烦人，你没有明显的地方来存储与相关图表并排的 values.yaml。我想出的最佳解决方案是将上游图表作为依赖项创建一个新的虚拟图表。尽管如此，我们还没有找到一种标准的方法来在管道中使用单行命令更新
    values.yaml 中的参数，除非运行 `sed`。'
- en: Configuring manifests for preprod vs. prod using Helm
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Helm 配置预生产和生产 manifest
- en: In this exercise, we will take the guestbook app we deployed earlier in the
    chapter and use Helm to manage its configuration for different environments.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用 Helm 管理我们在本章早期部署的 guestbook 应用程序在不同环境中的配置。
- en: Helm uses the following directory structure to structure its charts.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 使用以下目录结构来组织其图表。
- en: Listing 3.4 Helm chart directory structure
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.4 Helm 图表目录结构
- en: '[PRE15]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ The Chart.yaml is Helm’s descriptor of the chart.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Chart.yaml 是 Helm 对图表的描述。
- en: ❷ A directory of templates that, when combined with values, will generate valid
    Kubernetes manifest files
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一个模板目录，当与值结合时，将生成有效的 Kubernetes manifest 文件
- en: ❸ Various configuration values for the chart, which can be used for environment-specific
    configuration
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 图表的各个配置值，可用于特定环境的配置
- en: A Helm template file uses a text templating language to generate Kubernetes
    YAML. Helm template files look like Kubernetes YAML, but with template variables
    sprinkled throughout the file. As a result, even a basic Helm template file ends
    up looking like this.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 模板文件使用文本模板语言来生成 Kubernetes YAML。Helm 模板文件看起来像 Kubernetes YAML，但文件中散布着模板变量。因此，即使是基本的
    Helm 模板文件最终也会看起来像这样。
- en: Listing 3.5 Sample app Helm template
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.5 示例 Helm 模板
- en: '[PRE16]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, Helm templates are not very readable. But they are incredibly
    flexible since the final resulting YAML can be customized in any way the user
    desires.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Helm 模板的可读性不是很好。但它们非常灵活，因为最终生成的 YAML 可以根据用户的意愿进行任何方式的定制。
- en: Finally, when customizing a specific environment using Helm charts, an environment-specific
    values file is created containing the values to use for that environment. For
    example, for the production version of this application, the values file may look
    like this.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当使用 Helm 图表自定义特定环境时，会创建一个包含用于该环境的值的特定环境值文件。例如，对于此应用程序的生产版本，值文件可能看起来像这样。
- en: Listing 3.6 Sample app Helm values
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.6 示例 Helm 值
- en: '[PRE17]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Overrides the image tag whose default is the chart appVersion
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 覆盖默认的图表 appVersion 的镜像标签
- en: ❷ Sets the DEBUG environment variable to true
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将 DEBUG 环境变量设置为 true
- en: 'The final qa manifest can be installed to minikube in the qa-heml namespace
    with the following commands:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的 qa manifest 可以使用以下命令安装到 qa-heml 命名空间下的 minikube：
- en: '[PRE18]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Exercise 3.2
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 3.2
- en: In the preceding tutorial, we parameterized the guestbook image tag for QA and
    Prod environments using Helm. Add additional parameterization for the number of
    replicas desired for each guestbook deployment. Set the number of replicas to
    1 for QA and 3 for Prod.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的教程中，我们使用 Helm 对 QA 和生产环境中的 guestbook 镜像标签进行了参数化。为每个 guestbook 部署所需的副本数量添加额外的参数化。将
    QA 的副本数设置为 1，将生产环境的副本数设置为 3。
- en: 3.3.2 Kustomize
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.2 Kustomize
- en: Kustomize was created around the design principles described in Brian Grant’s
    excellent dissertation regarding declarative application management.^([3](#pgfId-1077191))
    Kustomize has seen a meteoric rise in popularity, and, in the eight months since
    it started, it has already been merged into kubectl. Whether or not you agree
    with how it was merged, it goes without saying that Kustomize applications will
    now be a permanent mainstay in the Kubernetes ecosystem and will be the default
    choice that users will gravitate toward for config management. Yes, it helps to
    be part of kubectl!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Kustomize 是围绕 Brian Grant 优秀的关于声明式应用程序管理的论文中描述的设计原则创建的。^([3](#pgfId-1077191))
    Kustomize 的受欢迎程度急剧上升，自从它开始以来，已经合并到 kubectl 中。无论你是否同意它的合并方式，不言而喻的是，Kustomize 应用程序现在将成为
    Kubernetes 生态系统中的永久性主流，并将成为用户在配置管理中倾向于选择的默认选项。是的，成为 kubectl 的一部分有帮助！
- en: 'The good:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 好处：
- en: '*No parameters and templates*—Kustomize apps are extremely easy to reason about,
    and really, a pleasure to look at. It’s about as close as you can get to Kubernetes
    YAML since the overlays you compose to perform customizations are simply subsets
    of Kubernetes YAML.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无参数和模板*——Kustomize 应用程序非常易于推理，实际上，看起来非常愉快。它几乎可以接近 Kubernetes YAML，因为您用来执行定制的覆盖只是
    Kubernetes YAML 的子集。'
- en: 'The bad:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 坏处：
- en: '*No parameters and templates*—The same property that makes Kustomize applications
    so readable can also make it limiting. For example, I was recently trying to get
    the Kustomize CLI to set an image tag for a custom resource instead of a Deployment
    but was unable to. Kustomize does have a concept of vars, which look a lot like
    parameters but somehow aren’t, and can only be used in Kustomize’s sanctioned
    whitelist of field paths. We feel like this is one of those times when the solution,
    despite making the hard things easy, ends up making the easy things hard.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无参数和模板*——使 Kustomize 应用程序如此易于阅读的同一特性也可能使其受限。例如，我最近试图让 Kustomize CLI 为自定义资源设置一个镜像标签而不是
    Deployment，但未能成功。Kustomize 确实有一个名为 vars 的概念，它看起来很像参数，但不知何故并不是，并且只能在 Kustomize
    的授权白名单字段路径中使用。我们觉得这是那些解决方案，尽管让困难的事情变得容易，但最终让容易的事情变得困难的时候之一。'
- en: Configure manifests for preprod vs. prod using Kustomize
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kustomize 配置预生产和生产环境
- en: In this exercise, we will use a sample application that we will use later in
    part 3 and use Kustomize to deploy it.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用一个示例应用程序，我们将在第 3 部分中使用它，并使用 Kustomize 来部署它。
- en: We will organize our configuration files into the following directory structure.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的配置文件组织成以下目录结构。
- en: Listing 3.7 Kustomize directory structure
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.7 Kustomize 目录结构
- en: '[PRE19]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ The base directory contains the common configuration that will be shared by
    the different environments.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 基础目录包含将在不同环境中共享的通用配置。
- en: ❷ The envs/prod directory contains the configuration for the Prod environment.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ envs/prod 目录包含生产环境的配置。
- en: ❸ The envs/qa directory contains the configuration for the QA environment.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ envs/qa 目录包含 QA 环境的配置。
- en: The manifests in the base directory contain all the resources that are common
    to all environments. In this simple example, we have a single Deployment resource.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 基础目录中的清单包含所有环境共有的资源。在这个简单的示例中，我们有一个单一的 Deployment 资源。
- en: Listing 3.8 Base deployment
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.8 基础部署
- en: '[PRE20]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ The image defined in the base config is irrelevant. This version of the image
    will never be deployed since the child overlay environments in this example will
    override this value.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 基础配置中定义的镜像是不相关的。由于本例中的子覆盖环境将覆盖此值，因此此版本的镜像永远不会被部署。
- en: To use the base directory as a base to other environments, a kustomization.yaml
    must be present in the directory. The following is the simplest kustomization.yaml
    possible. It merely lists the guestbook.yaml as the single resource comprising
    the application.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要将基础目录作为其他环境的基础，目录中必须存在 kustomization.yaml 文件。以下是最简单的 kustomization.yaml 文件。它仅将
    guestbook.yaml 列为构成应用程序的单个资源。
- en: Listing 3.9 Base Kustomization
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.9 基础 Kustomization
- en: '[PRE21]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that we’ve established the kustomize base directory, we can start customizing
    our environments. To customize and modify resources for a specific environment,
    we define an overlay directory that contains all the patches and customizations
    we want to be applied on top of the base resources. Our first overlay is the envs/qa
    directory. Inside this directory is another kustomization.yaml that specifies
    the patches that should be applied on top of the base. The following two listings
    provide an example of a `qa` overlay that
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了kustomize基础目录，我们可以开始定制我们的环境。为了定制和修改特定环境的资源，我们定义了一个包含所有要应用于基础资源的补丁和定制的overlay目录。我们的第一个overlay是envs/qa目录。在这个目录中还有一个kustomization.yaml，它指定了应该应用于基础的补丁。以下两个列表提供了一个示例，说明了一个`qa`
    overlay
- en: Sets a different guestbook image to be deployed to a new tag (v0.2)
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置一个不同的guestbook镜像以部署到新的标签（v0.2）
- en: Adds an environment variable, `DEBUG=true`, to the guestbook container
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向guestbook容器添加环境变量`DEBUG=true`。
- en: Listing 3.10 QA environment Kustomization
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.10 QA环境Kustomization
- en: '[PRE22]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ bases references the “base” directory that contains the shared configuration.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ bases引用包含共享配置的“base”目录。
- en: ❷ debug.yaml is a reference to a Kustomize patch that will modify the sample-app
    Deployment object and set the DEBUG environment variable.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ debug.yaml是对一个Kustomize补丁的引用，该补丁将修改sample-app Deployment对象并设置DEBUG环境变量。
- en: ❸ images overrides any container images defined in the base, with different
    tags or image repositories. This example overrides the image tag REPLACEME, with
    v0.2.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果在基础镜像中定义了具有不同标签或镜像仓库的容器镜像，则❸ images将覆盖这些镜像。此示例使用v0.2覆盖了REPLACEME镜像标签。
- en: Notice that Kustomize patches look very similar to actual Kubernetes resources.
    This is because they are in fact incomplete versions of them.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Kustomize补丁看起来非常类似于实际的Kubernetes资源。这是因为它们实际上是它们的完整版本。
- en: Listing 3.11 QA environment debug patch
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.11 QA环境debug补丁
- en: '[PRE23]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ The apiVersion group (apps), the kind (Deployment), and name (sample-app)
    are key pieces of information that inform Kustomize about which resource in the
    base this patch should be applied to.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ apiVersion group（apps）、kind（Deployment）和name（sample-app）是关键信息，它们告知Kustomize此补丁应该应用于基础资源中的哪个资源。
- en: ❷ The name field is used to identify which container will have the new environment
    variables.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用名称字段来识别哪个容器将具有新的环境变量。
- en: ❸ Finally, the new DEBUG environment variable we want in the QA environment
    is defined.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 最后，我们在QA环境中定义了我们想要的新的DEBUG环境变量。
- en: After all that is said and done, we run `kustomize` `build` `envs/qa`. This
    produces the final, rendered manifests for the QA environment.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些完成后，我们运行`kustomize` `build` `envs/qa`。这生成了QA环境的最终、渲染的清单。
- en: Listing 3.12 Kustomize build envs/qa
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.12 Kustomize构建envs/qa
- en: '[PRE24]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ The DEBUG environment variable is added.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 添加了DEBUG环境变量。
- en: ❷ The image tag is set to v0.2.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将镜像标签设置为v0.2。
- en: 'The final qa manifest can be installed to minikube in the qa namespace with
    the following commands:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的qa清单可以使用以下命令安装到qa命名空间中的minikube：
- en: '[PRE25]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Exercise 3.3
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 练习3.3
- en: In the previous tutorial, we parameterized the guestbook image tag for QA and
    Prod environments using Kustomize.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的教程中，我们使用Kustomize对QA和Prod环境的guestbook镜像标签进行了参数化。
- en: hint Create a replica_count.yaml patch file.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：创建一个replica_count.yaml补丁文件。
- en: Add additional parameterization for the number of replicas desired for each
    sample-app deployment. Set the number of replicas to 1 for QA and 3 for Prod.
    Deploy the QA environment to the qa namespace and the Prod environment to the
    prod namespace.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个sample-app部署所需的副本数量添加额外的参数化。将副本数设置为QA的1个和Prod的3个。将QA环境部署到qa命名空间，将Prod环境部署到prod命名空间。
- en: Exercise 3.4
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 练习3.4
- en: Currently, the Prod environment runs version v0.1 of the sample app, and QA
    runs version v0.2\. Let’s assume we have completed the testing in QA. Update the
    customization.yaml file to promote version v0.2 to run in Prod. Update the Prod
    environment in the prod namespace.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Prod环境运行的是sample app的v0.1版本，而QA运行的是v0.2版本。假设我们已经完成了QA的测试。更新customization.yaml文件，将版本v0.2提升到Prod环境中运行。更新prod命名空间中的Prod环境。
- en: 3.3.3 Jsonnet
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.3 Jsonnet
- en: Jsonnet is a language and not really a tool. Furthermore, its use is not specific
    to Kubernetes (although it’s been popularized by Kubernetes). The best way to
    think of Jsonnet is as a super-powered JSON combined with a sane way to do templating.
    Jsonnet combines all the things you wish you could do with JSON (comments, text
    blocks, parameters, variables, conditionals, file imports) without any of the
    things that you hate about go/Jinja2 templating, and adds features that you didn’t
    even know you needed or wanted (functions, object orientation, mixins). It does
    all of this in a declarative and hermetic (code as data) way.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Jsonnet 是一种语言，而不是真正的工具。此外，它的使用并不特定于 Kubernetes（尽管它是由 Kubernetes 推广的）。最好的方式是将
    Jsonnet 视为一个超级 JSON，结合了一种合理的模板化方法。Jsonnet 结合了你希望用 JSON 做的所有事情（注释、文本块、参数、变量、条件、文件导入），而没有你讨厌的
    go/Jinja2 模板化中的任何东西，并添加了你甚至不知道需要或想要的功能（函数、面向对象、混入）。它以声明性和密封（代码即数据）的方式完成所有这些。
- en: When we look at a basic Jsonnet file, it looks very similar to JSON, which makes
    sense because Jsonnet is a superset of JSON. All JSON is valid Jsonnet. But notice
    in our example, we can also have comments in the document. If you have been managing
    configuration in JSON for long enough, you will immediately understand how useful
    this is!
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看一个基本的 Jsonnet 文件时，它看起来非常类似于 JSON，这是有道理的，因为 Jsonnet 是 JSON 的超集。所有有效的 JSON
    都是有效的 Jsonnet。但请注意，在我们的示例中，我们还可以在文档中有注释。如果你在 JSON 中管理配置的时间足够长，你将立即理解这有多么有用！
- en: Listing 3.13 Basic Jsonnet
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.13 基本Jsonnet
- en: '[PRE26]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Continuing with the example, let’s see how we can start leveraging simple Jsonnet
    features. One of the simplest ways to reduce repetition, and better organize your
    code/configuration, is to use variables. In our next example, we declare a few
    variables at the top of the Jsonnet file (name, version, and replicas) and reference
    those variables throughout the document. This allows us to make changes at a single,
    visible place, without resorting to scanning the entire document for all other
    areas that need that same change, which would be error prone, especially in large
    documents.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们的示例，让我们看看我们如何开始利用简单的 Jsonnet 特性。减少重复并更好地组织代码/配置的最简单方法之一是使用变量。在我们的下一个示例中，我们在
    Jsonnet 文件顶部声明了一些变量（名称、版本和副本）并在整个文档中引用这些变量。这允许我们在一个单一、可见的地方进行更改，而无需扫描整个文档以查找所有需要相同更改的其他区域，这在大型文档中尤其容易出错。
- en: Listing 3.14 Variables
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.14 变量
- en: '[PRE27]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, with our advanced example, we start leveraging a few of the unique
    and powerful features of Jsonnet: functions, arguments, references, and conditionals.
    The next example starts to demonstrate the power of Jsonnet.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的高级示例中，我们开始利用 Jsonnet 一些独特且强大的特性：函数、参数、引用和条件。下一个示例将开始展示 Jsonnet 的强大之处。
- en: Listing 3.15 Advanced Jsonnet
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.15 高级 Jsonnet
- en: '[PRE28]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ Unlike previous examples, the configuration is defined as a Jsonnet function
    instead of a normal Jsonnet object. This allows the configuration to declare inputs
    and accept arguments from the command line. prod is a Boolean argument to the
    function, with a default value of false.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的示例不同，配置被定义为 Jsonnet 函数而不是一个普通的 Jsonnet 对象。这允许配置声明输入并接受来自命令行的参数。prod 是函数的一个布尔参数，默认值为
    false。
- en: ❷ We can self-reference other parts of the document without using variables.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在不使用变量的情况下自我引用文档的其他部分。
- en: ❸ The number of replicas is set based on a condition.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 副本的数量是基于条件设置的。
- en: Exercise 3.5
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 3.5
- en: 'In listing 3.15, try running the following two commands and compare the output:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 3.15 中，尝试运行以下两个命令并比较输出：
- en: '[PRE29]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: There are many more language features in Jsonnet, and we haven’t even scratched
    the surface of its capabilities. Jsonnet is not widely adopted in the Kubernetes
    community, which is unfortunate because, of all the tools described here, Jsonnet
    is hands down the most powerful configuration tool available and is why several
    offshoot tools are built on top of it. Explaining what’s possible with Jsonnet
    is a chapter in and of itself, which is why we encourage you to read how Databricks
    uses Jsonnet with Kubernetes, and Jsonnet’s excellent tutorial.^([4](#pgfId-1077485))
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Jsonnet 中有更多语言特性，我们甚至还没有触及到其能力的一角。Jsonnet 在 Kubernetes 社区中并没有得到广泛的应用，这很遗憾，因为在这里描述的所有工具中，Jsonnet
    无疑是最强大的配置工具，也是为什么有多个衍生工具建立在它之上的原因。解释 Jsonnet 可以做什么本身就是一本书的内容，这就是为什么我们鼓励你阅读 Databricks
    如何使用 Jsonnet 与 Kubernetes 结合，以及 Jsonnet 的优秀教程。[4](#pgfId-1077485)
- en: 'The good:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 好的：
- en: '*Extremely powerful*—It’s rare to hit a situation that couldn’t be expressed
    in some concise and elegant snippet of Jsonnet. With Jsonnet, you are continually
    finding new ways to maximize reuse and avoid repeating yourself.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*极其强大*——很少会遇到无法用一些简洁优雅的 Jsonnet 片段表达的情况。使用 Jsonnet，你不断地发现新的方法来最大化重用并避免重复。'
- en: 'The bad:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 坏处：
- en: '*It’s not YAML*—This might be an issue with unfamiliarity, but most people
    will experience some level of cognitive load when they’re staring at a nontrivial
    Jsonnet file. In the same way you would need to run a Helm template to verify
    your Helm chart is producing what you expect, you will similarly need to run `jsonnet`
    `--yaml-stream` `guestbook.jsonnet` to verify your Jsonnet is correct. The good
    news is that, unlike with Go templating, which can produce syntactically incorrect
    YAML due to some misplaced whitespace, these types of errors are caught with Jsonnet
    during the build, and the resulting output is guaranteed to be valid JSON/YAML.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不是 YAML*——这可能是由于不熟悉而引起的问题，但大多数人面对非平凡的 Jsonnet 文件时都会经历一定程度的认知负荷。同样地，你需要运行 Helm
    模板来验证你的 Helm 图表是否产生了你期望的结果，你也需要类似地运行 `jsonnet` `--yaml-stream` `guestbook.jsonnet`
    来验证你的 Jsonnet 是否正确。好消息是，与 Go 模板不同，Go 模板可能会因为一些错误的空白而产生语法上不正确的 YAML，这些错误类型在 Jsonnet
    构建过程中会被捕获，并且产生的输出保证是有效的 JSON/YAML。'
- en: ksonnet Not to be confused with Jsonnet, *ksonne*t is a defunct tool for creating
    application manifests that can be deployed to a Kubernetes cluster. However, ksonnet
    is no longer maintained, and other tools should be considered instead.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ksonnet 不要与 Jsonnet 混淆，*ksonne*t 是一个已废弃的工具，用于创建可以部署到 Kubernetes 集群的应用程序清单。然而，ksonnet
    已不再维护，应考虑其他工具。
- en: 3.3.4 Configuration management summary
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.4 配置管理总结
- en: As with everything, there are trade-offs to using each tool. Table 3.1 shows
    a summary of how these specific tools compare in terms of the four qualities we
    value in configuration management.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有事物一样，使用每个工具都有其权衡。表3.1展示了这些特定工具在配置管理中我们重视的四个品质方面的比较总结。
- en: Table 3.1 Features comparison
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.1 功能比较
- en: '|  | Helm | Kustomize | Jsonnet |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '|  | Helm | Kustomize | Jsonnet |'
- en: '| Declarative | Fair | Excellent | Excellent |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| 声明式 | 公平 | 优秀 | 优秀 |'
- en: '| Readability | Poor | Excellent | Fair |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| 可读性 | 差 | 优秀 | 一般 |'
- en: '| Flexibility | Excellent | Poor | Excellent |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| 灵活性 | 优秀 | 差 | 优秀 |'
- en: '| Maintainability | Fair | Excellent | Excellent |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| 可维护性 | 一般 | 优秀 | 优秀 |'
- en: Note that the tools discussed in this chapter are just the ones that happen
    to be the most popular in the Kubernetes community at the time of writing. This
    is a continually evolving space, and there are many other configuration management
    tools to consider.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本章讨论的工具只是当时在 Kubernetes 社区中最受欢迎的工具。这是一个不断发展的领域，还有许多其他配置管理工具可以考虑。
- en: 3.4 Durable vs. ephemeral environments
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 持久环境与短暂环境对比
- en: '*Durable* environments are environments that will always be available. For
    example, the production environment always needs to be available so that services
    do not get interrupted. In a durable environment, resources (memory, CPU, storage)
    will be committed permanently to achieve always-on availability. Often, E2E is
    a durable environment for internal integration, and Prod is a durable environment
    for production traffic.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '*持久*环境是指始终可用的环境。例如，生产环境始终需要可用，以便服务不会中断。在持久环境中，资源（内存、CPU、存储）将永久承诺以实现始终在线的可用性。通常，E2E
    是内部集成的持久环境，而 Prod 是生产流量的持久环境。'
- en: '*Ephemeral* environments are temporary environments that are not relied on
    by other services. Ephemeral environments also do not require resources to be
    permanently committed. For example, Stage is used for testing production readiness
    for the new code and does not need to be around after testing is complete. Another
    use case is for previewing a pull request for correctness to guarantee that only
    good code is merged into master. In this case, a temporary environment will be
    created with the pull request changes so it can be tested. Once all testing is
    complete, the PR environment will be deleted, and the PR changes will only be
    allowed to be merged back to master if all tests pass.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '*短暂的*环境是临时环境，其他服务不依赖于这些环境。短暂的环境也不需要永久性地分配资源。例如，预发布环境用于测试新代码的生产就绪性，测试完成后不需要保留。另一个用例是预览拉取请求的正确性，以确保只有好的代码被合并到主分支。在这种情况下，将创建一个临时环境，包含拉取请求的更改，以便进行测试。一旦所有测试完成，PR
    环境将被删除，并且只有当所有测试通过时，PR 更改才允许合并回主分支。'
- en: Given durable environments will be used by others, defects in a durable environment
    could interrupt others and might require rollback to restore the correct functionality.
    With GitOps and Kubernetes, rollback is simply to reapply the previous config
    through Git. Kubernetes will detect the changes in the manifest and restore the
    environment to the previous state.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 由于持久环境将被其他人使用，持久环境中的缺陷可能会中断其他人，可能需要回滚以恢复正确的功能。使用 GitOps 和 Kubernetes，回滚只是通过
    Git 重新应用之前的配置。Kubernetes 将检测清单中的更改，并将环境恢复到之前的状态。
- en: Kubernetes makes rollback in environments consistent and straightforward, but
    what about other resources like databases? Since user data is stored in a database,
    we cannot simply roll back the database to a previous snapshot, resulting in the
    loss of user data. As with the rolling updates deployment in Kubernetes, new and
    old versions of the code need to be compatible with rolling updates. In the case
    of the database, the DB schema needs to be backward compatible to avoid disruption
    during rollback and loss of user data. In practice, it means columns can only
    be added (not removed), and column definitions cannot be altered. Schema changes
    should be controlled with other change management frameworks, such as Flyway,^([5](#pgfId-1077566))
    so DB changes can also follow the GitOps process.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 使得环境回滚变得一致且简单，但对于其他资源如数据库呢？由于用户数据存储在数据库中，我们不能简单地回滚数据库到之前的快照，这会导致用户数据的丢失。与
    Kubernetes 中的滚动更新部署类似，新旧版本的代码需要与滚动更新兼容。在数据库的情况下，数据库模式需要向后兼容，以避免回滚期间的中断和用户数据的丢失。在实践中，这意味着只能添加（不能删除）列，并且列定义不能更改。模式更改应与其他变更管理框架（如
    Flyway，^([5](#pgfId-1077566))) 控制在一起，以便数据库更改也可以遵循 GitOps 流程。
- en: Summary
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Environments are where code is deployed and executed for a specific purpose.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境是代码部署和执行特定目的的地方。
- en: Each environment will have its own access control, networking, configuration,
    and dependencies.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个环境都将拥有自己的访问控制、网络、配置和依赖。
- en: Factors for picking environment granularity are release independence, test boundary,
    access control, and isolation.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择环境粒度的因素包括发布独立性、测试边界、访问控制和隔离。
- en: The Kubernetes Namespace is a natural construct to implement an environment.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 命名空间是实现环境的一种自然结构。
- en: Since a namespace is equivalent to an environment, deploying to a specific environment
    is merely specifying the targeted namespace.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于命名空间等同于环境，部署到特定环境只是指定了目标命名空间。
- en: Inter-environment traffic can be controlled by network policy.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过网络策略控制环境间的流量。
- en: Preprod and prod should follow the same security best practices and operation
    vigor.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预生产和生产应遵循相同的最佳安全实践和操作强度。
- en: Separation of the Git repo for Kubernetes manifest and the Git repo for code
    is highly recommended to allow environment changes independent from code changes.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高度推荐将 Kubernetes 清单的 Git 仓库与代码的 Git 仓库分开，以便环境更改独立于代码更改。
- en: A single branch works well with tooling like Kustomize for overlay.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个分支与像 Kustomize 这样的工具配合使用进行覆盖时效果很好。
- en: Monorepo for config works well for startups; multirepo works well for large
    enterprises.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一仓库对于初创公司来说配置工作效果很好；多仓库对于大型企业来说效果很好。
- en: Helm is a package manager.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm 是一个包管理器。
- en: Kustomize is a built-in config management tool, part of kubectl.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kustomize 是一个内置的配置管理工具，是 kubectl 的一部分。
- en: Jsonnet is a language that is for JSON templating.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jsonnet 是一种用于 JSON 模板的语言。
- en: 'Choosing the right config management tools should be based on the following
    criteria: declarative, readability, flexibility, and maintainability.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择合适的配置管理工具应基于以下标准：声明式、可读性、灵活性和可维护性。
- en: Durable environments are always on for others to use, and ephemeral environments
    are for short-lived testing and previewing.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可持久环境总是可供他人使用，而短暂环境则用于短期测试和预览。
- en: '* * *'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 1.[https://kubernetes.io/docs/tutorials/stateless-application/guestbook](https://kubernetes.io/docs/tutorials/stateless-application/guestbook/).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 1.[https://kubernetes.io/docs/tutorials/stateless-application/guestbook](https://kubernetes.io/docs/tutorials/stateless-application/guestbook/).
- en: 2.[http://mng.bz/8N1g](http://mng.bz/8N1g).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 2.[http://mng.bz/8N1g](http://mng.bz/8N1g).
- en: 3.[https://github.com/kubernetes/community/blob/master/contributors/design-proposals/architecture/declarative-application-management.md](https://github.com/kubernetes/community/blob/master/contributors/design-proposals/architecture/declarative-application-management.md).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 3.[https://github.com/kubernetes/community/blob/master/contributors/design-proposals/architecture/declarative-application-management.md](https://github.com/kubernetes/community/blob/master/contributors/design-proposals/architecture/declarative-application-management.md).
- en: 4.[http://mng.bz/NYmX](https://shortener.manning.com/NYmX).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 4.[http://mng.bz/NYmX](https://shortener.manning.com/NYmX).
- en: 5.[https://flywaydb.org/](https://flywaydb.org/).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 5.[https://flywaydb.org/](https://flywaydb.org/).
