- en: 5 Modeling the possible absence of data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 模拟数据可能不存在的情况
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Using `Option` to represent the possible absence of data
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Option`来表示数据的可能不存在
- en: Understanding why `null` is a terrible idea
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解为什么`null`是一个糟糕的想法
- en: Whether you should use C# 8 nullable reference types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否应该使用C# 8可空引用类型
- en: In chapter 4, I introduced you to the idea that types should precisely represent
    the data they encapsulate in order to write expressive function signatures. One
    particularly thorny issue is that of representing data that may not be available.
    For instance, when you register on a website, you typically have to provide your
    email address, but other details like your age and gender are optional. The website
    owner may want to process and analyze this data *if it’s available*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4章中，我向你介绍了这样一个观点：类型应该精确地表示它们封装的数据，以便编写表达式的函数签名。一个特别棘手的问题是表示可能不可用数据的问题。例如，当你在一个网站上注册时，你通常需要提供你的电子邮件地址，但其他细节，如你的年龄和性别是可选的。网站所有者可能希望处理和分析这些数据*如果它们可用*。
- en: “Wait a minute,” you’re probably thinking, “don’t we use `null` for this?” I’ll
    discuss `null` in section 5.5, but for the first part of this chapter, you could
    just pretend that `null` doesn’t exist and that we have to come up with a way
    to represent the possible absence of data.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: “等等，”你可能正在想，“我们不是用`null`来做这个的吗？”我将在第5.5节中讨论`null`，但本章的前一部分，你可以假装`null`不存在，我们必须想出一种方法来表示数据的可能不存在。
- en: When coding functionally, you never use `null`—*ever*. Instead, FP uses the
    `Option` type to represent optionality. I hope to show you that `Option` provides
    a much more robust and expressive representation. If you’ve never heard of `Option`
    before, I ask you to suspend judgment, as the added value of `Option` may not
    be clear until you see it used in the next couple of chapters.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当以函数式方式编码时，你永远不使用`null`——*永远不*。相反，FP使用`Option`类型来表示可选性。我希望向你展示`Option`提供了一种更健壮和更具表达性的表示。如果你以前从未听说过`Option`，我请你暂时放下判断，因为`Option`的附加价值可能直到你看到它在下一两章中使用时才变得明显。
- en: 5.1 The bad APIs you use every day
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 你每天使用的糟糕API
- en: 'The problem of representing the possible absence of data isn’t handled gracefully
    in .NET libraries. Imagine you go for a job interview and are given the following
    quiz:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET库中，处理表示数据可能不存在的问题并不优雅。想象一下，你去参加一个工作面试，并被要求进行以下测验：
- en: '*Question*: What does this program print?'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*问题*：这个程序会打印什么？'
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Take a moment to read through the code. Note that `NameValueCollection` is simply
    a map from `string` to `string`.[¹](#pgfId-1115264) Then, write down what you
    think the program prints (make sure nobody’s looking). Now, how much would you
    be willing to bet that you got the right answer? If you’re like me and have a
    nagging feeling that as a programmer you should really be concerned with other
    things than these annoying details, the rest of this section will help you see
    why the problem lies with the APIs themselves and not with your lack of knowledge.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 抽空阅读一下代码。注意`NameValueCollection`只是一个从`string`到`string`的映射。[¹](#pgfId-1115264)
    然后，写下你认为程序会打印的内容（确保没有人看着）。现在，你愿意下多少赌注你得到了正确答案？如果你像我一样，有一种挥之不去的感觉，认为作为一个程序员，你应该关心的事情不仅仅是这些烦人的细节，那么本节的其余部分将帮助你看到问题实际上出在API本身，而不是你知识不足。
- en: The code uses indexers to retrieve items from two empty collections, so both
    operations fail. Indexers are, of course, just normal functions—the `[]` syntax
    is just sugar—so both indexers are functions of type `string` `→` `string` and
    both are dishonest. Why do I say *dishonest*?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用索引器从两个空集合中检索项目，所以这两个操作都失败了。索引器当然只是普通函数——`[]`语法只是糖衣——所以这两个索引器都是类型为`string`
    `→` `string`的函数，并且都是不诚实的。我为什么说*不诚实*？
- en: The `NameValueCollection` indexer ❶ returns `null` if a key isn’t present. It’s
    somewhat open to debate whether `null` is actually a `string`, but I tend to say
    no.[²](#pgfId-1115270) You give the indexer a perfectly valid input `string`,
    and it returns the useless `null` value—not what the signature claims.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`NameValueCollection`索引器❶如果键不存在则返回`null`。关于`null`实际上是否是`string`，有些争议，但我倾向于说不。[²](#pgfId-1115270)
    你给索引器一个完全有效的输入`string`，它返回一个无用的`null`值——而不是签名所声称的。'
- en: The `Dictionary` indexer ❷ throws a `KeyNotFoundException`, so it’s a function
    that says, “Give me a `string`, and I’ll return you a `string`,” when it should
    actually say, “Give me a `string`, and I *may* return you a `string`, or I may
    throw an exception instead.”
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dictionary`索引器❷抛出`KeyNotFoundException`，所以它是一个函数，说“给我一个`string`，我会返回你一个`string`”，而实际上它应该说，“给我一个`string`，我*可能*返回你一个`string`，或者我可能抛出一个异常。”'
- en: 'To add insult to injury, the two indexers are dishonest in inconsistent ways.
    Now that you know this, it’s easy to see that the program prints:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，这两个索引器以不一致的方式不诚实。现在你知道了这一点，很容易看出程序打印的内容：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The interface exposed by two different associative collections in .NET is inconsistent.
    Who’d have thought? And the only way to find out is by looking at the documentation
    (boring) or stumbling on a bug (worse). Let’s look at the functional approach
    to representing the possible absence of data.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: .NET中两个不同的关联集合暴露的接口不一致。谁能想到呢？唯一的办法就是查看文档（无聊）或者偶然发现一个错误（更糟糕）。让我们看看表示数据可能缺失的功能方法。
- en: 5.2 An introduction to the Option type
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 介绍`Option`类型
- en: '`Option` is essentially a container that wraps a value ... or no value. It’s
    like a box that *may* contain a thing, or it could be empty. The symbolic definition
    for `Option` is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`Option`本质上是一个包含值...或者没有值的容器。它就像一个*可能*包含东西的盒子，或者它可能是空的。`Option`的符号定义如下：'
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s see what that means. `T` is a type parameter (the type of the inner value),
    so an `Option<int>` may contain an `int`. The `|` sign means *or*, so the definition
    says that an `Option<T>` can be one of two things:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这意味着什么。`T`是一个类型参数（内部值的类型），所以`Option<int>`可以包含一个`int`。`|`符号表示“或”，所以定义说明`Option<T>`可以是两种情况之一：
- en: '`None`—A special value indicating the absence of a value. If the `Option` has
    no inner value, we say that *the Option is None*.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`None`—表示值缺失的特殊值。如果`Option`没有内部值，我们说`the Option`是`None`。'
- en: '`Some(T)`—A container that wraps a value of type `T`. If the `Option` has an
    inner value, we say that *the Option is Some*.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Some(T)`—一个包装类型为`T`的值的容器。如果`Option`有内部值，我们说`the Option`是`Some`。'
- en: (In case you’re wondering, in `Option<T>`, I use angle brackets to indicate
    that `T` is a type parameter; in `Some(T)`, I use parentheses to indicate that
    `Some` is a function that takes a `T` and returns an `Option<T>`, wrapping the
    given value.)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: （如果你想知道，在`Option<T>`中，我使用尖括号来表示`T`是一个类型参数；在`Some(T)`中，我使用圆括号来表示`Some`是一个函数，它接受一个`T`并返回一个`Option<T>`，包装给定的值。）
- en: In terms of sets, `Option<T>` is the *union* of the set `Some(T)` with the singleton
    set `None` (see figure 5.1). `Option` is a good example of a sum type, which we
    discussed in section 4.2.4.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从集合的角度来看，`Option<T>`是集合`Some(T)`与单元素集合`None`的并集（见图5.1）。`Option`是求和类型的一个好例子，我们已经在第4.2.4节讨论过。
- en: '![](Images/CH05_F01_Buonanno2.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH05_F01_Buonanno2.png)'
- en: Figure 5.1 `Option<T>` is the union of the set `Some<T>` with the singleton
    set `None`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 `Option<T>`是集合`Some<T>`与单元素集合`None`的并集。
- en: If `bool` has two possible values, then `Some<bool>` also has two possible values,
    but `Option<bool>` has three possible values because it also includes `None`.
    Similarly, `Option<DayOfWeek>` has eight possible values, and so on.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`bool`有两个可能的值，那么`Some<bool>`也有两个可能的值，但`Option<bool>`有三个可能的值，因为它还包括`None`。同样，`Option<DayOfWeek>`有八个可能的值，等等。
- en: We’ll look at implementing `Option` in the next subsection, but first, let’s
    take a look at its basic usage so you’re familiar with the API. I recommend you
    follow along in the REPL, but you’ll need a bit of setup, and that’s described
    in the following sidebar.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一小节中查看实现`Option`，但首先，让我们看看它的基本用法，这样你就熟悉API了。我建议你在REPL中跟随，但你需要做一些设置，这将在以下侧边栏中描述。
- en: Using the `LaYumba.Functional` library in the REPL
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在REPL中使用`LaYumba.Functional`库
- en: 'I developed my own functional library, `LaYumba.Functional`, to support the
    teaching of many of the techniques in this book. It would be useful for you to
    play with the constructs included in `LaYumba.Functional` in the REPL. This requires
    you to import it in the REPL:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我开发了自己的功能库`LaYumba.Functional`，以支持本书中许多技术的教学。在REPL中尝试`LaYumba.Functional`中包含的构造将很有用。这需要你在REPL中导入它：
- en: If you haven’t done so already, download and compile the code samples from [https://github.com/la-yumba/functional-csharp-code-2](https://github.com/la-yumba/functional-csharp-code-2).
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，请下载并编译来自[https://github.com/la-yumba/functional-csharp-code-2](https://github.com/la-yumba/functional-csharp-code-2)的代码示例。
- en: 'Reference the `LaYumba.Functional` library in your REPL. Just how this works
    depends on your setup. On my system (using the C# Interactive window in Visual
    Studio with the code samples solution open), I can do so by typing the following:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 REPL 中引用 `LaYumba.Functional` 库。具体如何操作取决于你的设置。在我的系统中（使用 Visual Studio 中的
    C# Interactive 窗口，并且代码示例解决方案已打开），我可以通过输入以下内容来实现：
- en: '[PRE3]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Type the following imports into the REPL:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 REPL 中输入以下导入语句：
- en: '[PRE4]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once you’re set up, you can create some `Option`s:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好之后，你可以创建一些 `Option`：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Creates a `None`
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个 `None`
- en: ❷ Creates a `Some`
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个 `Some`
- en: That was easy! Now that you know how to create `Option`s, how can you interact
    with them? At the most basic level, you can do so with `Match`, a method that
    performs pattern matching. Simply put, it allows you to run different code depending
    on whether the `Option` is `None` or `Some`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单！现在你知道了如何创建 `Option`，那么你如何与它们交互呢？在最基本的情况下，你可以通过 `Match` 方法来实现，这是一个执行模式匹配的方法。简单来说，它允许你根据
    `Option` 是 `None` 还是 `Some` 来运行不同的代码。
- en: 'For example, if you have an optional name, you can write a function that returns
    a greeting for that name or a general-purpose message if no name is given. Type
    the following into the REPL:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你有一个可选的名字，你可以编写一个函数，为该名字返回一个问候语，如果没有提供名字，则返回一个通用消息。在 REPL 中输入以下内容：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ If `greetee` is `None`, `Match` evaluates this function.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果 `greetee` 是 `None`，则 `Match` 评估此函数。
- en: ❷ If `greetee` is `Some`, `Match` evaluates this function, passing it `greetee`'s
    inner value.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果 `greetee` 是 `Some`，则 `Match` 评估此函数，并将 `greetee` 的内部值传递给它。
- en: 'As you can see, `Match` takes two functions: the first one says what to do
    in the `None` case; the second, what to do in the `Some` case. In the `Some` case,
    the function is given the inner value of the `Option`.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`Match` 接受两个函数：第一个函数定义在 `None` 的情况下要做什么；第二个函数定义在 `Some` 的情况下要做什么。在 `Some`
    的情况下，函数会接收到 `Option` 的内部值。
- en: 'In the preceding call to `Match`, the named arguments `None:` and `Some:` are
    used for extra clarity. It’s possible to omit those:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 `Match` 调用中，使用了命名参数 `None:` 和 `Some:` 以增加清晰度。可以省略这些参数：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In general, I omit them because the empty parens `()` in the first lambda already
    suggest an empty container (that is, an `Option` in the `None` state), whereas
    the parens with an argument inside, `(name)`, suggest a container with a value
    inside. (The parens are optional in the `Some` case, as with any unary lambda,
    but I keep them here to maintain this graphic analogy.)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我会省略它们，因为第一个 lambda 中的空括号 `()` 已经暗示了一个空的容器（即 `None` 状态下的 `Option`），而括号内有参数的括号
    `(name)` 则暗示了一个包含值的容器。 （在 `Some` 的情况下，括号是可选的，就像任何一元 lambda 一样，但我保留它们以保持这种图形类比。）
- en: 'If this is all a bit confusing right now, don’t worry; things will fall into
    place as we go along. For now, these are the things to remember:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在这一切都有些令人困惑，不要担心；随着我们的深入，一切都会变得清晰。现在，这些是需要记住的事情：
- en: Use `Some(value)` to wrap a value into an `Option`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Some(value)` 将一个值包装到 `Option` 中。
- en: Use `None` to create an empty `Option`.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `None` 创建一个空的 `Option`。
- en: Use `Match` to run some code depending on the state of the `Option`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Match` 根据选项的状态执行一些代码。
- en: For now, you can think of `None` as a replacement for `null`, and `Match` as
    a replacement for a `null` check. You’ll see in subsequent sections why using
    `Option` is actually preferable to `null`, and why, eventually, you won’t need
    to use `Match` very often.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你可以将 `None` 视为 `null` 的替代品，将 `Match` 视为 `null` 检查的替代品。你将在后续章节中看到为什么使用 `Option`
    实际上比使用 `null` 更可取，以及为什么最终你不太需要经常使用 `Match`。
- en: 5.3 Implementing Option
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 实现 Option
- en: Feel free to skip to section 5.4 or skim over this section on first reading.
    To start with, it’s important that you understand enough to be able to *use* `Option`.
    But if you’d like to see what’s under the hood, in this section, I’ll show you
    the techniques I used in the implementation of `Option` that I included in `LaYumba.Functional`.
    This is both to show you that there’s little magic involved and to show you ways
    to work around some limitations of the C# type system. You might like to type
    this code into an empty project as you follow along.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 随意跳到第 5.4 节或首次阅读时浏览这一节。首先，重要的是你要理解足够的内容，以便能够 *使用* `Option`。但如果你想看看内部结构，在这一节中，我将向你展示我在
    `LaYumba.Functional` 中实现 `Option` 时使用的技巧。这样做是为了向你展示其中几乎没有魔法，以及如何绕过 C# 类型系统的一些限制。你可能想在你跟随的同时将此代码输入到一个空项目中。
- en: 5.3.1 An idealized implementation of Option
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.1 选项的理想化实现
- en: 'In many typed functional languages, `Option` can be defined with a one-liner
    along these lines:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多类型化的函数式编程语言中，`Option` 可以用一行代码定义如下：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The closest equivalent in C# is the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中最接近的等效方法是以下内容：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That is, we define `Option<T>` as a *marker* interface and then provide minimal
    implementations for `None` and `Some<T>`, saying that each of them is a valid
    `Option<T>`. `Some<T>` contains a `T`, and `None` contains nothing.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 即，我们定义 `Option<T>` 为一个*标记*接口，然后为 `None` 和 `Some<T>` 提供最小实现，表示它们都是有效的 `Option<T>`。`Some<T>`
    包含一个 `T`，而 `None` 不包含任何内容。
- en: 'Here we already run into a problem: because `None` does not actually contain
    a `T`, we’d like to say that `None` is a valid `Option<T>` regardless of what
    type `T` eventually resolves to. Unfortunately, the C# compiler does not allow
    this, so in order to make the code compile, we need to provide a generic parameter
    for `None` as well.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经遇到了一个问题：因为 `None` 实际上不包含一个 `T`，我们希望无论 `T` 最终解析为哪种类型，`None` 都是一个有效的 `Option<T>`。不幸的是，C#
    编译器不允许这样做，因此为了使代码能够编译，我们需要为 `None` 也提供一个泛型参数。
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We now have a basic, working implementation.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个基本的、可工作的实现。
- en: 5.3.2 Consuming an Option
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.2 消费一个 `Option`
- en: 'Next, we want to write code that consumes an `Option` using pattern matching.
    Ideally, I’d like it to look like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要编写使用模式匹配来消费 `Option` 的代码。理想情况下，我希望它看起来像这样：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Unfortunately, this does not compile. If we are to satisfy the syntax for pattern
    matching in C#, we need to rewrite the code as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这不能编译。如果我们想要满足 C# 中模式匹配的语法，我们需要将代码重写如下：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is definitely less elegant (imagine if you have a long type name instead
    of `string`), but at least it compiles. It does, however, generate a compiler
    warning, saying that “the switch expression does not handle all possible values
    of its input type.” This is because, in theory, some other implementation of `Option<string>`
    could exist, and the `switch` expression in our example does not cater to this.
    Unfortunately, there is no way to tell C# that we never want anything other than
    `Some` and `None` to implement `Option`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这肯定没有这么优雅（想象一下，如果你有一个比 `string` 更长的类型名），但至少它可以编译。然而，它确实会生成一个编译器警告，指出“switch
    表达式没有处理其输入类型的所有可能值。”这是因为，从理论上讲，可能存在其他实现 `Option<string>` 的方法，而我们示例中的 `switch`
    表达式并没有考虑到这一点。不幸的是，没有方法可以告诉 C# 我们永远不希望除了 `Some` 和 `None` 之外的其他东西实现 `Option`。
- en: 'We can mitigate both issues by defining our own adapter function `Match` that
    includes a *discard pattern*. This allows us to perform exhaustive pattern matching
    and gives us an interface that’s easy to consume:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过定义自己的适配器函数 `Match` 并包含一个*丢弃模式*来减轻这两个问题。这允许我们进行穷举模式匹配，并给我们一个易于消费的接口：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then we can consume an `Option` like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以像这样消费一个 `Option`：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now we have an elegant, concise way to consume an `Option`. (Notice that we
    also need an overload of `Match` that takes two actions, allowing us to *do something*
    depending on the state of the `Option`. This can easily be done following the
    approach described in section 4.3.2.)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个优雅、简洁的方式来消费一个 `Option`。（注意，我们还需要一个接受两个操作的 `Match` 重载，这样我们就可以根据 `Option`
    的状态来*执行某些操作*。这可以通过第 4.3.2 节中描述的方法轻松实现。）
- en: 5.3.3 Creating a None
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.3 创建一个 `None`
- en: 'Let’s move on to creating `Option`s. To explicitly create a `None`—say, for
    testing that `Greet` works with `None`—we have to write this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建 `Option`。为了显式创建一个 `None`——比如说，为了测试 `Greet` 是否与 `None` 一起工作——我们必须编写以下内容：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is not nice. I particularly dislike that we have to specify the `string`
    parameter: when calling a method, we’d like to have type inference resolve our
    generic parameters. What we need, ideally, is a value that can be converted to
    a `None<T>`, regardless of the type of `T`.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不好。我特别不喜欢我们必须指定 `string` 参数：当我们调用一个方法时，我们希望类型推断来解决我们的泛型参数。理想情况下，我们需要一个可以转换为
    `None<T>` 的值，无论 `T` 的类型如何。
- en: 'While you can’t do this with inheritance, it turns out you can do it with type
    conversion. To achieve this, we need to define a dedicated, non-generic type,
    `NoneType`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你不能用继承来实现这一点，但结果证明你可以用类型转换来实现。为了实现这一点，我们需要定义一个专用、非泛型类型，`NoneType`：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we change `Option<T>` to include implicit conversion from `NoneType`
    to `None<T>`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将 `Option<T>` 改为包括从 `NoneType` 到 `None<T>` 的隐式转换：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This effectively tells the runtime that an instance of `NoneType` can be used
    where an `Option<T>` is expected and instructs the runtime to convert the `NoneType`
    to a `None<T>`. Finally, we include a convenience field called `None` that stores
    a `NoneType`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上告诉运行时可以在期望 `Option<T>` 的地方使用 `NoneType` 的实例，并指示运行时将 `NoneType` 转换为 `None<T>`。最后，我们包括一个名为
    `None` 的便利字段，它存储一个 `NoneType`：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can now create a `None<T>` by simply typing `None`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以通过简单地输入`None`来创建一个`None<T>`：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Much better! Note that this assumes that the `None` field is in scope, which
    can be achieved with `using static`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这好多了！请注意，这假设`None`字段在作用域内，这可以通过`using static`实现。
- en: In the previous snippet, `None` returns a `NoneType`. Seeing that `Greet` expects
    an `Option<string>`, the runtime calls the implicit conversion we defined in `Option<T>`,
    which yields a `None<string>`. When all is said and done, you can forget that
    the `NoneType` exists and just code knowing that `None` returns a `None<T>` for
    the expected `T`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`None`返回一个`NoneType`。由于`Greet`期望一个`Option<string>`，运行时会调用我们在`Option<T>`中定义的隐式转换，这会产生一个`None<string>`。所有这些完成后，你可以忘记`NoneType`的存在，只需编写知道`None`会为期望的`T`返回一个`None<T>`的代码。
- en: 5.3.4 Creating a Some
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.4 创建一个Some
- en: 'Now for creating a `Some`. First, because `Some` indicates the presence of
    a value, it should *not* to be possible to wrap a `null` into a `Some`. To do
    this, instead of relying on the automatic methods generated for records by the
    compiler, we’ll explicitly define the constructor:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来创建一个`Some`。首先，由于`Some`表示值的存在，不应该可能将`null`包装到`Some`中。为了做到这一点，我们不会依赖于编译器为记录生成的自动方法，而是会显式定义构造函数：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here I also made the `Option`''s inner value `private` so that it can only
    be accessed when the `Option` is deconstructed in pattern matching. We can then
    define a convenience function, `Some`, that wraps a given value into a `Some`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我也将`Option`的内部值设置为`private`，这样它只能在模式匹配中解构`Option`时访问。然后我们可以定义一个便利函数`Some`，它将给定的值包装成一个`Some`：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'With this in place, we can create a `Some` like so:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以这样创建一个`Some`：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we have nice, clean syntax for creating both a `None` and a `Some`. To
    put the icing on the cake, I’m also going to define an implicit conversion from
    `T` to `Option<T>`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了创建`None`和`Some`的简洁语法。为了锦上添花，我还会定义一个从`T`到`Option<T>`的隐式转换：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This means that a `T` can be used where an `Option<T>` is expected and will
    automatically be wrapped into a `Some<T>`—unless it’s `null`, in which case it
    will be a `None<T>`. This snippet saves us from explicitly calling `Some`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`T`可以在期望`Option<T>`的地方使用，并且会自动被包装成一个`Some<T>`——除非它是`null`，在这种情况下它将是一个`None<T>`。这个代码片段让我们免去了显式调用`Some`的需要：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It also allows us to trivially convert a function that returns `null` to one
    that returns an `Option`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 它还允许我们轻松地将返回`null`的函数转换为返回`Option`的函数：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 5.3.5 Optimizing the Option implementation
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.5 优化`Option`实现
- en: For a number of reasons, in my `LaYumba.Functional` library, I’ve chosen to
    use a slightly different approach and define `Option` as in the following listing.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多原因，在我的`LaYumba.Functional`库中，我选择使用稍微不同的方法，并定义`Option`如下所示。
- en: Listing 5.1 An implementation of `Option` optimized for C#
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.1 `Option`的C#优化实现
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ The value wrapped by a `Some`
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 被Some包裹的值
- en: ❷ Indicates whether the `Option` is `Some` or `None`
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 表示`Option`是`Some`还是`None`
- en: ❸ Constructs an `Option` in the `Some` state
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 构建一个处于`Some`状态的`Option`
- en: ❹ Constructs an `Option` in the `None` state
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 构建一个处于`None`状态的`Option`
- en: ❺ Once an `Option` is constructed, the only way to interact with it is with
    `Match`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 一旦构建了`Option`，与之交互的唯一方式是通过`Match`。
- en: 'In this implementation, instead of using different types, I use *state* (namely,
    the `isSome` flag) to indicate whether the `Option` is `Some` or `None`. I’m providing
    a single constructor that creates an `Option` in the `Some` state. That’s because
    I’ve defined `Option` as a struct, and structs have an implicit parameterless
    constructor that initializes all fields to their default values. In this case,
    the `isSome` flag is initialized to `false`, indicating that the `Option` is `None`.
    This implementation has several advantages:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，我并不是使用不同的类型，而是使用*状态*（即`isSome`标志）来表示`Option`是`Some`还是`None`。我提供了一个单构造函数，它创建一个处于`Some`状态的`Option`。这是因为我已经将`Option`定义为结构体，结构体有一个隐式的无参数构造函数，它将所有字段初始化为其默认值。在这种情况下，`isSome`标志被初始化为`false`，表示`Option`是`None`。这个实现有几个优点：
- en: Performance is better because structs are allocated on the stack.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能更好，因为结构体是在栈上分配的。
- en: Being a struct, an `Option` cannot be `null`.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于是结构体，`Option`不能是`null`。
- en: The `default` value of an `Option` is `None` (with records, it was `null`).
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Option`的`default`值是`None`（在记录中是`null`）。'
- en: 'Everything else (the `NoneType`, implicit conversion, and the interface of
    `Match`) is the same as discussed previously. Finally, I’ve defined the `Some`
    function and the `None` value in the `F` class, which allows you to easily create
    `Option`s:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 其他所有内容（`NoneType`、隐式转换和`Match`的接口）与之前讨论的相同。最后，我在`F`类中定义了`Some`函数和`None`值，这使得你可以轻松创建`Option`：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now that you have seen all the pieces of the puzzle, take another look at the
    example I showed earlier. It should be clearer now:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了拼图的每一块，再看看我之前展示的例子。现在应该更清晰了：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As you’ve seen, there are different possible ways to implement `Option` in
    C#. I’ve chosen this particular implementation because it allows the cleanest
    API from the perspective of client code. But `Option` is a concept, not a particular
    implementation, so don’t be alarmed if you see a different implementation in another
    library or tutorial.[³](#pgfId-1115517) It will still have the defining features
    of an `Option`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，有几种不同的方法可以在C#中实现`Option`。我选择了这种特定的实现，因为它从客户端代码的角度提供了最干净的API。但`Option`是一个概念，而不是特定的实现，所以如果你在另一个库或教程中看到不同的实现，请不要惊慌。[³](#pgfId-1115517)
    它仍然具有`Option`的标志性特征：
- en: A value `None` that indicates the absence of a value
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表示值不存在的`None`值
- en: A function `Some` that wraps a value, indicating the presence of a value
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`Some`函数，它封装一个值，表示存在一个值
- en: A way to execute code depending on whether a value is present (in our case,
    `Match`)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据值是否存在来执行代码的方式（在我们的案例中，是`Match`）
- en: '`Option` is also called `Maybe`'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Option`也被称为`Maybe`'
- en: Different functional frameworks use varying terminology to express similar concepts.
    A common synonym for `Option` is `Maybe`, with the `Some` and `None` states called
    `Just` and `Nothing`, respectively.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的函数式框架使用不同的术语来表达类似的概念。`Option`的一个常见同义词是`Maybe`，其中`Some`和`None`状态分别称为`Just`和`Nothing`。
- en: Such naming inconsistencies are unfortunately quite common in FP, and this doesn’t
    help in the learning process. In this book, I’ll try to present the most common
    synonyms for each pattern or technique and then stick with one name. From now
    on, I’ll stick to `Option`. Just know that if you run across `Maybe` (say, in
    a JavaScript or Haskell library), it’s the same concept.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这种命名不一致性在函数式编程（FP）中很常见，这并不利于学习过程。在这本书中，我将尝试展示每个模式或技术最常见的同义词，然后坚持使用一个名称。从现在开始，我将坚持使用`Option`。只需知道，如果你遇到`Maybe`（比如在JavaScript或Haskell库中），它具有相同的概念。
- en: Let’s now look at some practical scenarios in which you can use `Option`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看一些实际场景，在这些场景中你可以使用`Option`。
- en: 5.4 Option as the natural result type of partial functions
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 作为部分函数的自然结果类型的`Option`
- en: 'We’ve discussed how functions map elements from one set to another and how
    types represent these sets. There’s an important distinction to make between total
    and partial functions:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了函数如何将一个集合的元素映射到另一个集合，以及类型如何表示这些集合。在总函数和部分函数之间有一个重要的区别：
- en: '*Total functions*—Mappings that are defined for *every* element of the domain'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*总函数*—对定义域中的每个元素都进行映射'
- en: '*Partial functions*—Mappings that are defined for *some* but not all elements
    of the domain'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*部分函数*—只对定义域中的某些元素而不是所有元素进行映射'
- en: 'Partial functions are problematic because it’s not clear what the function
    should do when given an input for which it can’t compute a result. The `Option`
    type offers a perfect solution to model such cases: if the function is defined
    for the given input, it returns a `Some` wrapping the result; otherwise, it returns
    `None`. Let’s look at some common use cases in which we can use this approach.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 部分函数有问题是，当给定的输入无法计算结果时，不清楚函数应该做什么。`Option`类型提供了一个完美的解决方案来模拟这种情况：如果函数为给定的输入定义了，它返回一个封装结果的`Some`；否则，它返回`None`。让我们看看一些常见的使用场景，我们可以使用这种方法。
- en: 5.4.1 Parsing strings
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.1 解析字符串
- en: Imagine a function that parses a string representation of an integer. You could
    model this as a function of type `string` `→` `int`. This is clearly a partial
    function because not all strings are valid representations of integers. In fact,
    there are infinitely many strings that can’t be mapped to an `int`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个解析整数字符串表示的函数。你可以将其建模为一个类型为`string` `→` `int`的函数。这显然是一个部分函数，因为并非所有字符串都是有效的整数表示。事实上，有无限多个字符串无法映射到`int`。
- en: You can provide a safer representation of parsing by having the parser function
    return an `Option<int>`. This will be `None` if the given `string` can’t be parsed,
    as figure 5.2 illustrates.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过让解析函数返回`Option<int>`来提供一个更安全的解析表示。如果给定的`string`无法解析，它将返回`None`，如图5.2所示。
- en: '![](Images/CH05_F02_Buonanno2.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH05_F02_Buonanno2.png)'
- en: Figure 5.2 Using `Option` to convey that parsing is a partial function. For
    input strings that provide valid representation of an integer, the parsing function
    wraps the parsed `int` into a `Some`. Otherwise, it returns `None`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 使用`Option`传达解析是一个部分函数。对于提供有效整数表示的输入字符串，解析函数将解析的`int`包装到`Some`中。否则，它返回`None`。
- en: 'A parser function with the signature `string` `→` `int` is partial, and it’s
    not clear from the signature what will happen if you supply a `string` that can’t
    be converted to an `int`. On the other hand, a parser function with signature
    `string` `→` `Option<int>` is total because, for any given string, it returns
    a valid `Option<int>`. Here’s an implementation that uses a BCL method to do the
    grunt work but exposes an `Option`-based API:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 签名为`string` `→` `int`的解析函数是部分函数，从签名中不清楚如果你提供一个无法转换为`int`的`string`会发生什么。另一方面，签名为`string`
    `→` `Option<int>`的解析函数是全函数，因为对于任何给定的字符串，它返回一个有效的`Option<int>`。以下是一个使用BCL方法执行繁重工作但公开基于`Option`的API的实现：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The helper functions in this subsection are included in `LaYumba.Functional`.
    You can try them out in the REPL:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节中的辅助函数包含在`LaYumba.Functional`中。你可以在REPL中尝试它们：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Similar methods are defined to parse strings into other commonly used types
    like doubles and dates and, more generally, to convert data in one form to another,
    more restrictive form.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了类似的方法来解析字符串到其他常用类型，如双精度浮点数和日期，以及更一般地，将一种形式的数据转换为另一种更严格的形式。
- en: 5.4.2 Looking up data in a collection
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.2 在集合中查找数据
- en: 'In section 5.1, I showed you that some collections expose an API that’s neither
    honest nor consistent in representing the absence of data. The gist was as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在5.1节中，我向你展示了某些集合公开的API在表示数据缺失方面既不诚实也不一致。要点如下：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The fundamental problem is the following. An associative collection maps keys
    to values and can, therefore, be seen as a function of type `TKey` `→` `TValue`.
    But there’s no guarantee that the collection contains a value for every possible
    key, so looking up a value is a partial function.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 基本问题是以下内容。关联集合将键映射到值，因此可以被视为类型`TKey` `→` `TValue`的函数。但是，没有保证集合包含每个可能的键的值，因此查找值是一个部分函数。
- en: 'A better, more explicit way to model the retrieval of a value is by returning
    an `Option`. It’s possible to write adapter functions that expose an `Option`-based
    API, and I generally name these `Option`-returning functions `Lookup`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过返回`Option`来建模值的检索是一个更好、更明确的方法。可以编写适配器函数来公开基于`Option`的API，我通常将这些返回`Option`的函数命名为`Lookup`：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`Lookup` takes a `NameValueCollection` and a `string` (the key) and returns
    a `Some` wrapping the value if the key exists and `None` otherwise. The following
    listing shows the implementation.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lookup`接受一个`NameValueCollection`和一个`string`（键）并返回一个包含值的`Some`，如果键存在，否则返回`None`。以下列表显示了实现。'
- en: Listing 5.2 Changing a `null`-returning function to return an `Option`
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.2 将返回`null`的函数改为返回`Option`
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: That’s it! The expression `collection[key]` is of type `string`, whereas the
    declared return value is `Option<string>`, so the `string` value will be implicitly
    converted into an `Option<string>`, with `null` being replaced by `None`. With
    minimal effort, we’ve gone from a `null`-based API to an `Option`-based API.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！表达式`collection[key]`是`string`类型，而声明的返回值是`Option<string>`，因此`string`值将被隐式转换为`Option<string>`，`null`被替换为`None`。我们付出了最小的努力，就从基于`null`的API转换到了基于`Option`的API。
- en: 'Here’s an overload of `Lookup` that takes an `IDictionary`. The signature is
    similar:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个`Lookup`的重载版本，它接受一个`IDictionary`。签名类似：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can implement the `Lookup` function as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`Lookup`函数实现如下：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We now have an honest, clear, and consistent API to query both collections:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个诚实、清晰且一致的API来查询这两个集合：
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: No more `KeyNotFoundException` or `NullReferenceException` because you asked
    for a key that wasn’t present in the collection. We can apply the same approach
    when querying other data structures.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你请求的键不在集合中，不再有`KeyNotFoundException`或`NullReferenceException`。我们可以将相同的方法应用于查询其他数据结构。
- en: 5.4.3 The smart constructor pattern
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.3 智能构造器模式
- en: In section 4.2.2, we defined the `Age` type, a type more restrictive than `int`,
    in that not all `int`s represent a valid age. You can, again, model this with
    `Option`, as figure 5.3 shows.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在4.2.2节中，我们定义了`Age`类型，这是一个比`int`更严格的类型，因为并非所有的`int`都代表有效的年龄。你同样可以用`Option`来建模，如图5.3所示。
- en: '![](Images/CH05_F03_Buonanno2.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH05_F03_Buonanno2.png)'
- en: Figure 5.3 Converting from `int` to `Age` can also be modeled with `Option`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 将`int`转换为`Age`也可以用`Option`来建模。
- en: 'If you need to create an `Age` from an `int`, instead of calling the constructor,
    which has to throw an exception if it’s unable to create a valid instance, you
    can define a function that returns `Some` or `None` to indicate the successful
    creation of an `Age`. This is known as a *smart constructor*: it’s smart in the
    sense that it’s aware of some rules and can prevent the construction of an invalid
    object. The following listing shows this approach.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要从一个`int`创建一个`Age`，而不是调用必须抛出异常以创建有效实例的构造函数，你可以定义一个返回`Some`或`None`的函数来指示`Age`创建成功。这被称为*智能构造函数*：它之所以智能，是因为它了解一些规则，可以防止创建无效的对象。以下列表展示了这种方法。
- en: Listing 5.3 Implementing a smart constructor for `Age`
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.3 实现`Age`的智能构造函数
- en: '[PRE37]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ❶ A smart constructor returning an `Option`
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个智能构造函数返回`Option`
- en: ❷ The constructor should now be marked as `private`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 构造函数现在应该标记为`private`。
- en: If you now need to obtain an `Age` from an `int`, you’ll get an `Option<Age>`,
    which forces you to account for the failure case.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在需要从一个`int`获取`Age`，你会得到`Option<Age>`，这迫使你必须考虑失败的情况。
- en: 5.5 Dealing with null
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5 处理`null`
- en: At the beginning of this chapter, I asked you to pretend there was no `null`
    in C# and that we had to come up with a way to represent optional values. Truly
    functional languages don’t have `null` and model optional values with the `Option`
    type. However, some of the most popular programming languages, including C#, not
    only allow for `null`, but use it as the default value for all reference types.
    In this section, I’ll show you why this is a problem and how it can be tackled.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我要求你假装C#中没有`null`，我们必须想出一种表示可选值的方法。真正函数式语言没有`null`，而是用`Option`类型来表示可选值。然而，一些最受欢迎的编程语言，包括C#，不仅允许`null`的存在，而且将其用作所有引用类型的默认值。在本节中，我将向你展示为什么这是一个问题以及如何解决这个问题。
- en: 5.5.1 Why null is such a terrible idea
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.1 为什么`null`是一个如此糟糕的想法
- en: Let’s look at some of the reasons why `null` causes so many problems.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看为什么`null`会导致这么多问题。
- en: Sloppy data modeling
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 不严谨的数据建模
- en: In section 4.2.4, you saw that the tuple `(Age, Gender)` has (120 × 2) = 240
    possible values. The same is true if you store those two values in a struct. Now,
    if you define a class or record to hold these values like so
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在4.2.4节中，你看到元组`(Age, Gender)`有(120 × 2) = 240个可能的值。如果你将这两个值存储在结构体中，情况也是一样的。现在，如果你定义一个类或记录来保存这些值，如下所示
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: then there are actually 241 possible values because reference types can be `null`.
    If you refactor `Age` to be a class, you now have 121 possible values for `Age`
    and 243 possible values for `HealthData`! Not only is `null` polluting the mathematical
    representation of the data, but we also have to write code to handle all those
    possible values.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 那么实际上有241个可能的值，因为引用类型可以是`null`。如果你将`Age`重构为类，你现在有121个可能的`Age`值和243个可能的`HealthData`值！`null`不仅污染了数据的数学表示，而且我们还得编写代码来处理所有这些可能的值。
- en: Ambiguous function signatures
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊的函数签名
- en: 'You may have heard that the `NullReferenceException` is the single most common
    source of bugs. But why is it so common? The answer lies, I believe, in a fundamental
    ambiguity:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过`NullReferenceException`是单个最常见的错误来源。但为什么它如此普遍？我相信答案在于一个基本的不确定性：
- en: Because reference types are `null` by default, your program may encounter a
    `null` as a result of a programming error, where a required value was simply not
    initialized.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为引用类型默认是`null`，你的程序可能会因为编程错误而遇到`null`，其中所需值根本未初始化。
- en: Other times, `null` is considered a legal value; for example, the authors of
    `NameValueCollection` decided it was OK to represent that a key is not present
    by returning `null`.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，`null`被认为是一个合法的值；例如，`NameValueCollection`的作者决定通过返回`null`来表示键不存在是可以的。
- en: Because there is no way to declare whether a `null` value is deliberate or the
    result of a programming error (at least before C# 8’s nullable reference types,
    which I’ll discuss in section 5.5.3), you’re often in doubt as to how to treat
    a `null` value. Should you allow for `null`? Should you throw an `ArgumentNullException`?
    Should you let the `NullReferenceException` bubble up? Essentially, every function
    that accepts or returns a reference type is ambiguous because it’s unclear whether
    a `null` value is a legal input or output.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于无法声明`null`值是故意的还是编程错误的后果（至少在C# 8的可空引用类型之前是这样，我将在5.5.3节中讨论），你经常对如何处理`null`值感到怀疑。你应该允许`null`吗？你应该抛出`ArgumentNullException`？你应该让`NullReferenceException`向上冒泡吗？本质上，每个接受或返回引用类型的函数都是模糊的，因为不清楚`null`值是合法的输入还是输出。
- en: Defensive null-checking
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 防御性null检查
- en: 'The ambiguity between legal and unintentional `null`s does not only cause bugs.
    It has another effect, which may be even more damaging: it leads to defensive
    programming. To prevent the lurking `NullReferenceException`, developers litter
    their code with `null` checks and assertions against `null` arguments. While there
    is a case for using these assertions (see section 5.5.4), if used throughout the
    codebase, they create a lot of noise.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 合法`null`和无意`null`之间的歧义不仅会导致错误。它还有一个可能更严重的影响：它会导致防御性编程。为了防止潜在的`NullReferenceException`，开发者会在代码中充斥着`null`检查和对`null`参数的断言。虽然使用这些断言有合理的理由（见5.5.4节），但如果在整个代码库中使用，它们会制造很多噪音。
- en: 5.5.2 Gaining robustness by using Option instead of null
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.2 通过使用Option代替null来提高健壮性
- en: The main step to address these problems is to *never* use `null` as a legal
    value. Instead, use `Option` to represent optional values. This way, any occurrence
    of `null` is the result of a programming error. (This means that you never need
    to check for `null`; just let the `NullReferenceException` bubble up.) Let’s see
    an example.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这些问题的主要步骤是*永远*不要使用`null`作为合法值。相反，使用`Option`来表示可选值。这样，任何`null`的出现都是编程错误的后果。（这意味着你永远不需要检查`null`；只需让`NullReferenceException`向上冒泡。）让我们看看一个例子。
- en: 'Imagine you have a form on your website that allows people to subscribe to
    a newsletter. A user enters his name and email, and this causes the instantiation
    of a `Subscriber`, which is then persisted to the database. `Subscriber` is defined
    as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你网站上有一个表单，允许人们订阅时事通讯。用户输入他的名字和电子邮件，这会导致`Subscriber`的实例化，然后持久化到数据库中。`Subscriber`定义如下：
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When it’s time to send out the newsletter, a custom greeting is computed for
    the subscriber, which is prepended to the body of the newsletter:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当是时候发送时事通讯时，为订阅者计算一个自定义问候语，并将其添加到时事通讯的主体之前：
- en: '[PRE40]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This all works fine. `Name` can’t be `null` because it’s a required field in
    the signup form, and it’s not nullable in the database.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都工作得很好。`Name`不能为`null`，因为它是在注册表单中的必填字段，并且在数据库中不可为空。
- en: Some months later, the rate at which new subscribers sign up drops, so the business
    decides to lower the barrier to entry by no longer requiring new subscribers to
    enter their name. The name field is removed from the form, and the database is
    modified accordingly.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 几个月后，新订阅者的注册率下降，因此公司决定降低进入门槛，不再要求新订阅者输入他们的名字。姓名字段从表单中删除，数据库也相应进行了修改。
- en: This should be considered a *breaking change* because it’s not possible to make
    the same assumptions about the data any more. And yet, the code still happily
    compiles. When time comes for the newsletter to be sent, `GreetingFor` throws
    an exception when it receives a `Subscriber` without a `Name`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该被视为一个*破坏性变更*，因为不再可能对数据进行相同的假设。然而，代码仍然可以顺利编译。当是时候发送时事通讯时，`GreetingFor`在接收到没有`Name`的`Subscriber`时会抛出异常。
- en: By this time, the person responsible for making the name optional in the database
    may be on a different team than the person maintaining the code that sends out
    the newsletter. The code may be in different repositories. In short, it may not
    be simple to look up all the usages of `Name`. Instead, it’s better to explicitly
    indicate that `Name` is now optional. That is, `Subscriber` should be changed
    to
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 到这时，负责在数据库中使姓名可选的人可能和负责维护发送时事通讯代码的人不在同一个团队。代码可能位于不同的存储库中。简而言之，查找`Name`的所有用法可能并不简单。因此，最好明确指出`Name`现在是可选的。也就是说，应该将`Subscriber`更改为
- en: '[PRE41]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ❶ `Name` is now explicitly marked as optional.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `Name`现在被明确标记为可选。
- en: 'This not only clearly conveys the fact that a value for `Name` may not be available,
    it causes `GreetingFor` to no longer compile. `GreetingFor` and any other code
    that was accessing the `Name` property will have to be modified to take into account
    the possibility of the value being absent. For example, you might modify it like
    so:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅清楚地传达了`Name`的值可能不可用的信息，还导致`GreetingFor`无法编译。`GreetingFor`以及任何其他访问`Name`属性的代码将需要修改，以考虑值可能不存在的情况。例如，你可能修改如下：
- en: '[PRE42]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: By using `Option`, you’re forcing the users of your API to handle the case in
    which no data is available. This places greater demands on the client code, but
    it effectively removes the possibility of a `NullReferenceException` occurring.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`Option`，你迫使API的用户处理没有数据可用的情况。这给客户端代码带来了更大的压力，但有效地消除了`NullReferenceException`发生的可能性。
- en: 'Changing a `string` to an `Option<string>` is a breaking change: in this way,
    you’re trading run-time errors for compile-time errors, thus making a compiling
    application more robust.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 将`string`更改为`Option<string>`是一个破坏性变更：这样，你是在用编译时错误交换运行时错误，从而使编译的应用程序更加健壮。
- en: 5.5.3 Non-nullable reference types?
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.3 非空引用类型？
- en: It has become widely accepted that having nullable types is a flaw in the language
    design. This is somewhat confirmed by the fact that so many releases of C# have
    introduced new syntax for dealing with `null`, gradually making the language more
    complex but without ever solving the problem at the root.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 广泛接受的观点是，在语言设计中存在可空类型是一个缺陷。这一点在一定程度上得到了证实，因为C#的许多版本都引入了处理`null`的新语法，逐渐使语言更加复杂，但从未从根本上解决问题。
- en: The most radical effort to take a stab at the problem has been made in C# 8
    by introducing a feature called *nullable reference types* (NRT). The name may
    seem odd, given that reference types were always nullable in C#; the point is
    that the feature allows you to mark the types you intend to be nullable, and the
    compiler keeps track of how you access instances of those types. For example,
    NRT allows you to write
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: C# 8通过引入一个名为*可空引用类型*（NRT）的功能，对解决这个问题做出了最激进的尝试。考虑到在C#中引用类型始终是可空的，这个名字可能看起来有些奇怪；其目的是，该功能允许你标记你打算设置为可空的类型，并且编译器会跟踪你如何访问这些类型的实例。例如，NRT允许你编写
- en: '[PRE43]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ❶ Enables the NRT feature in the code that follows
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 启用后续代码中的NRT功能
- en: ❷ A nullable field
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一个可空字段
- en: ❸ A non-nullable field
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 一个非空字段
- en: 'This allows you to be explicit in your declarations on which values can be
    `null`. Furthermore, if you dereference `Name` without a `null` check, you’ll
    get a compiler warning telling you that `Name` may be `null`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你在声明中明确指定哪些值可以是`null`。此外，如果你在未进行`null`检查的情况下取消引用`Name`，你将收到编译器警告，告诉你`Name`可能为`null`：
- en: '[PRE44]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'On the face of it, you might think this feature supersedes `Option`, and to
    a certain extent, it does. When you look deeper, however, you’ll find a few problems:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，你可能会认为这个特性取代了`Option`，在某种程度上，它确实如此。然而，当你深入探究时，你会发现一些问题：
- en: You need to explicitly opt into the feature by adding the `Nullable` element
    to your project file (or adding the `#nullable` directive in your files as shown
    previously).
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要通过将`Nullable`元素添加到你的项目文件中（或如前所述，在你的文件中添加`#nullable`指令）来显式选择此功能。
- en: 'Even when you’ve opted into NRT at project level, it’s still possible to override
    this within a file by using the `#nullable disable` directive. This means that
    you cannot reason about code in isolation: you now need to look in different places
    to see whether a `string` is nullable or not.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使你在项目级别选择了NRT，仍然可以通过使用`#nullable disable`指令在文件中覆盖此设置。这意味着你不能孤立地推理代码：你现在需要查看不同的地方以确定一个`string`是否可以为空。
- en: The compiler warnings only appear if both the nullable value declaration and
    the code where the value is dereferenced are in a NRT-enabled context, again making
    it difficult to reason about code in isolation.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有当可空值声明和引用该值的代码都在NRT启用上下文中时，编译器警告才会出现，这再次使得孤立地推理代码变得困难。
- en: Unless you’re treating warnings as errors, your code will still compile after
    changing, say, `string` to `string?`, which is, therefore, not a breaking change
    and will go unnoticed in a codebase with lots of warnings.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非你将警告视为错误，否则在将`string`更改为`string?`等更改后，你的代码仍然可以编译，这因此不是破坏性变更，并且在一个有很多警告的代码库中会被忽略。
- en: The compiler can’t always keep track of the `null` checks you’ve made along
    the way, For example,
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器并不能总是跟踪你沿途所做的`null`检查，例如，
- en: '[PRE45]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ❶ Checks that `subscriber.Name` is not `null`
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❶ 检查 `subscriber.Name` 是否不是 `null`
- en: ❷ Still warns that you may be dereferencing a `null`
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❷ 仍然警告你可能正在解引用一个 `null`
- en: results in a compiler warning even if `IsValid` checks that `Name` is not `null`.
    To fix this, you have to learn an obscure set of attributes to keep the compiler
    from warning you about these *false positives*.[⁴](#pgfId-1115734)
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 即使 `IsValid` 检查表明 `Name` 不是 `null`，也会导致编译器警告。为了解决这个问题，你必须学习一组不为人知的属性，以防止编译器警告这些
    *假阳性*。[⁴](#pgfId-1115734)
- en: 'Fields that are *not* marked as nullable can still end up being `null` (for
    example, when deserializing an object):'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未标记为可空的字段仍然可能成为 `null`（例如，在反序列化对象时）：
- en: '[PRE46]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The feature doesn’t allow you to deal with optionality in a way that is uniform
    between value and reference types. Despite the syntactic similarity between, say,
    `int?` and `string?`, they are completely different: `int?` is shorthand for `Nullable<int>`,
    so we have a structure wrapping the `int`, somewhat similarly to `Option`. On
    the other hand, `string?` is an annotation telling the compiler that the value
    could be `null`.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该特性不允许你在值类型和引用类型之间以统一的方式处理可选性。尽管 `int?` 和 `string?` 等之间的语法相似，但它们是完全不同的：`int?`
    是 `Nullable<int>` 的缩写，所以我们有一个包裹 `int` 的结构，与 `Option` 有点相似。另一方面，`string?` 是一个注释，告诉编译器该值可能是
    `null`。
- en: Notice that none of those limitations apply when using the `Option` type. Overall,
    despite my initial excitement as NRT was being developed, I’m now inclined to
    find it’s too little, too late. It seems that the language team set out with a
    bold agenda for this feature, but then watered it down to allow users to migrate
    their existing codebases to C# 8 without too much effort.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当使用 `Option` 类型时，这些限制都不适用。总的来说，尽管我在 NRT 开发初期感到兴奋，但现在我倾向于认为它来得太晚了，太少了。似乎语言团队为这个特性设定了一个大胆的计划，但后来将其稀释，以便用户可以不费太多力气就将现有的代码库迁移到
    C# 8。
- en: If you’re working on a team that embraces NRT and opts to use it everywhere,
    or if in a few years’ time adoption becomes ubiquitous, then NRT will certainly
    add value. But at the time of writing, if you’re working on a variety of projects
    and consuming a variety of libraries, not all of which use NRT throughout, I don’t
    see NRT bringing a real benefit.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个接受 NRT 并决定在所有地方使用它的团队中工作，或者如果在几年后采用变得普遍，那么 NRT 确实会带来价值。但在写作的时候，如果你在处理各种项目并使用各种库，其中并非所有都使用
    NRT，我看不出 NRT 会带来真正的益处。
- en: 5.5.4 Bulletproof against NullReferenceException
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.4 防止 NullReferenceException
- en: Given all that we discussed previously, in my opinion the most robust approach
    to prevent `null` values from wreaking havoc is as follows. Firstly
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们之前讨论的所有内容，在我看来，防止 `null` 值造成破坏的最稳健的方法如下。首先
- en: If you’re using C# 8, enable NRT. This helps to ensure that required values
    are always initialized. More importantly, it conveys intent to consumers of your
    code that also have NRT enabled.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用 C# 8，启用 NRT。这有助于确保必需值始终被初始化。更重要的是，它向你的代码的消费者传达了意图，这些消费者也启用了 NRT。
- en: For optional values, use `Option<T>` rather than `T?`.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于可选值，使用 `Option<T>` 而不是 `T?`。
- en: This means that, inside the boundaries of your code, you can be confident that
    no value is ever `null`. You should have no `null` checks nor throw any `ArgumentNullException`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，在你的代码的边界内，你可以确信没有任何值是 `null`。你不应该进行任何 `null` 检查，也不应该抛出任何 `ArgumentNullException`。
- en: Secondly, identify the boundaries of your code. This includes
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，确定你的代码的边界。这包括
- en: Public methods exposed by libraries that you intend to publish or share across
    projects
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你打算发布或跨项目共享的库公开的方法
- en: Web APIs
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web API
- en: Listeners to messages from message brokers or persisted queues
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听来自消息代理或持久队列的消息
- en: In those boundaries, prevent `null` values from seeping in
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些边界中，防止 `null` 值渗透进来
- en: For required values
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于必需值
- en: Throw an `ArgumentNullException`.
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出 `ArgumentNullException`。
- en: Return a response with a status code of 400 (Bad Request).
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个状态码为 400（请求错误）的响应。
- en: Reject the message.
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拒绝消息。
- en: 'For optional values, convert `null` values into `Option`s:'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于可选值，将 `null` 值转换为 `Option`：
- en: In C#, this can be done trivially with implicit conversion.
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C# 中，这可以通过隐式转换轻易完成。
- en: If your boundary involves deserializing data sent in another format, you can
    add the conversion logic to your formatter.
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的边界涉及反序列化以其他格式发送的数据，你可以将转换逻辑添加到你的格式化器中。
- en: Thirdly, where you consume .NET or third-party libraries, you also need to prevent
    `null` from seeping in. You saw an example of how to do this in listing 5.2, where
    we defined the `Option`-returning `Lookup` method on `NameValueCollection`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，当你使用 .NET 或第三方库时，你还需要防止 `null` 漏入。你在列表 5.2 中看到了如何做到这一点的一个例子，我们在其中定义了 `NameValueCollection`
    上的返回 `Option` 的 `Lookup` 方法。
- en: Converting JSON `null` to C# `Option`
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 将 JSON `null` 转换为 C# `Option`
- en: 'For convenience, my `LaYumba.Functional` library includes a formatter that
    works with .NET’s `System.Text.Json` and illustrates how `null` in JSON objects
    can be translated into C# `Option` and back. Here’s an example of how to use it:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我的 `LaYumba.Functional` 库包含一个与 .NET 的 `System.Text.Json` 兼容的格式化工具，展示了如何将
    JSON 对象中的 `null` 转换为 C# 的 `Option` 类型，并将其转换回。以下是如何使用它的一个示例：
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In summary, `Option` should be your default choice when representing a value
    that’s, well, optional. Use it in your data objects to model the fact that a property
    may not be set and in your functions to indicate the possibility that a suitable
    value may not be returned. Apart from reducing the chance of a `NullReferenceException`,
    this will enrich your model and make your code more self-documenting. Using `Option`
    in your function signature is one way of attaining the overarching recommendation
    of chapter 4: designing function signatures that are honest and highly descriptive
    of what the caller can expect.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，当表示一个“可选”的值时，`Option` 应该是你的默认选择。在你的数据对象中使用它来表示属性可能未设置的事实，并在你的函数中用来表示可能不会返回合适值的可能性。除了减少
    `NullReferenceException` 的可能性之外，这还将丰富你的模型并使你的代码更具自文档性。在你的函数签名中使用 `Option` 是实现第
    4 章总体建议的一种方式：设计诚实且高度描述性的函数签名，以便调用者可以期待。
- en: In upcoming chapters, we’ll look at how to work effectively with `Option`s.
    Although `Match` is the basic way of interacting with an `Option`, we’ll build
    a rich, high-level API starting in the next chapter. `Option` will be your friend,
    not only when you use it in your programs, but also as a simple structure through
    which I’ll illustrate many FP concepts.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨如何有效地使用 `Option`。虽然 `Match` 是与 `Option` 交互的基本方式，但我们将从下一章开始构建一个丰富的高级
    API。`Option` 将成为你的朋友，不仅当你将其用于程序中时，而且作为一个简单的结构，通过它我将展示许多函数式编程（FP）概念。
- en: Exercises
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'Write a generic `Parse` function that takes a string and parses it as a value
    of an `enum`. It should be usable as follows:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个泛型 `Parse` 函数，它接受一个字符串并将其解析为 `enum` 的值。它应该可以像以下这样使用：
- en: '[PRE48]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Write a `Lookup` function that takes an `IEnumerable` and a predicate and returns
    the first element in the `IEnumerable` that matches the predicate or `None`, if
    no matching element is found. Write its signature in arrow notation:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个 `Lookup` 函数，它接受一个 `IEnumerable` 和一个谓词，并返回 `IEnumerable` 中与谓词匹配的第一个元素或 `None`，如果没有找到匹配的元素。用箭头符号写出其签名：
- en: '[PRE49]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Write a type `Email` that wraps an underlying string, enforcing that it’s in
    a valid format. Ensure that you include the following:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个 `Email` 类型，它包装一个底层的字符串，并强制执行其格式有效。确保包括以下内容：
- en: A smart constructor
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能构造函数
- en: Implicit conversion to string so that it can easily be used with the typical
    API for sending emails
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式转换为字符串，以便可以轻松地与发送电子邮件的典型 API 一起使用
- en: Take a look at the extension methods defined on `IEnumerable` in `System.LINQ
    .Enumerable`.[⁵](#pgfId-1115822) Which ones could potentially return nothing or
    throw some kind of not-found exception and would, therefore, be good candidates
    for returning an `Option<T>` instead?
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看在 `System.LINQ.Enumerable` 中定义在 `IEnumerable` 上的扩展方法。[⁵](#pgfId-1115822) 哪些可能返回空值或抛出某种未找到异常，因此是返回
    `Option<T>` 的良好候选？
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Use the `Option` type to express the possible absence of a value. An `Option`
    can be in one of two states:'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Option` 类型来表示值的可能缺失。`Option` 可以处于两种状态之一：
- en: '`None`, indicating the absence of a value'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`None`，表示值的缺失'
- en: '`Some`, a simple container wrapping a non-`null` value'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Some`，一个包装非 `null` 值的简单容器'
- en: To execute code conditionally, depending on the state of an `Option`, use `Match`
    with the functions you’d like to evaluate in the `None` and `Some` cases.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要根据 `Option` 的状态有条件地执行代码，使用 `Match` 与你想要在 `None` 和 `Some` 情况下评估的函数。
- en: Use `Option` as a return value when a function cannot guarantee a valid output
    for all possible inputs including
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个函数无法保证对所有可能的输入都返回有效输出时，使用 `Option` 作为返回值
- en: Looking up values in collections
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在集合中查找值
- en: Creating objects requiring validation (smart constructors)
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建需要验证的对象（智能构造函数）
- en: 'Identify the boundaries of your code and prevent any `null` values from seeping
    in:'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定你代码的边界，并防止任何`null`值渗透进来：
- en: Enforce required values.
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制必要的值。
- en: Convert optional values to `Option`.
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将可选值转换为`Option`。
- en: '* * *'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ¹ In the early days of .NET, `NameValueCollection` was used quite frequently
    because it was common to use `ConfigurationManager.AppSettings` to get configuration
    settings from a `.config` file. This was superseded by the more recent configuration
    providers, so you may not encounter `NameValueCollection` often, even though it’s
    still part of .NET.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ 在.NET的早期阶段，`NameValueCollection`被频繁使用，因为通常使用`ConfigurationManager.AppSettings`从`.config`文件中获取配置设置。这已被更近期的配置提供者所取代，因此你可能不会经常遇到`NameValueCollection`，尽管它仍然是.NET的一部分。
- en: '² In fact, the language specification itself says so: if you assign `null`
    to a variable as in `string` `s` `=` `null;`, then `s` `is` `string` evaluates
    to `false`.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ² 事实上，语言规范本身也这么说：如果你将`null`赋值给变量，如`string s = null;`，那么`s is string`评估为`false`。
- en: ³ For example, the popular mocking framework NSubstitute includes an implementation
    of `Option`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ³ 例如，流行的模拟框架NSubstitute包括`Option`的实现。
- en: ⁴ For more details, see [http://mng.bz/10XQ](http://mng.bz/10XQ).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ⁴ 更多详情，请参阅[http://mng.bz/10XQ](http://mng.bz/10XQ)。
- en: '⁵ See the Microsoft documentation of enumerable methods: [http://mng.bz/PXd8](http://mng.bz/PXd8).'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ⁵ 请参阅Microsoft关于可枚举方法的文档：[http://mng.bz/PXd8](http://mng.bz/PXd8)。
