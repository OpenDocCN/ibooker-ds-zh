- en: Part 2\. The SPA client
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二部分：SPA客户端
- en: An SPA client provides much more than a traditional website user interface (UI).
    Though some say that SPA clients can be as responsive as desktop applications,
    it’s more accurate to say that well-written SPA clients are desktop applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单页应用（SPA）客户端提供的不仅仅是传统网站的用户界面（UI）。尽管有些人说SPA客户端可以像桌面应用程序一样响应，但更准确的说法是，编写良好的SPA客户端就是桌面应用程序。
- en: Like desktop applications, SPA clients differ substantially from traditional
    web pages. When we replace a traditional website with an SPA, the entire software
    stack changes—from the database server through the HTML templating. Companies
    that have had the vision to successfully transition from traditional websites
    to SPAs have understood that the old practices and structures must change. They’ve
    refocused engineering talent, discipline, and testing on the client. The server
    remains important, but it’s focused on providing JSON data services.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 与桌面应用程序一样，SPA客户端与传统网页有显著的不同。当我们用SPA替换传统网站时，整个软件栈都会发生变化——从数据库服务器到HTML模板。那些有远见卓识，成功从传统网站过渡到SPA的公司已经明白，旧的做法和结构必须改变。他们重新聚焦工程人才、纪律和客户端测试。服务器仍然很重要，但它的重点在于提供JSON数据服务。
- en: 'So let’s forget everything we know about traditional website client development.
    All right, not *everything*—it’s still good to know JavaScript, HTML5, CSS3, SVG,
    CORS, and a bunch of other acronyms. But we need to remember as we proceed through
    these chapters that *we’ll be building a desktop application*, not a traditional
    website. In [part 2](#part02) we learn how to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们忘记我们关于传统网站客户端开发所知道的一切。好吧，不是*一切*——了解JavaScript、HTML5、CSS3、SVG、CORS和其他一些缩写词仍然是有益的。但我们需要记住，当我们进入这些章节时，*我们将构建一个桌面应用程序*，而不是传统网站。在[第二部分](#part02)中，我们将学习如何：
- en: Build and test a highly scalable, testable, and capable SPA client
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和测试一个高度可扩展、可测试和强大的SPA客户端
- en: Make the Back button, bookmarks, and other history controls work as expected
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让后退按钮、书签和其他历史控制功能按预期工作
- en: Design, implement, and test robust feature modules and their APIs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计、实现和测试健壮的功能模块及其API
- en: Make our UI work seamlessly on mobile devices and desktops
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们的用户界面在移动设备和桌面电脑上无缝工作
- en: Organize modules and namespaces to greatly improve testing, team development,
    and design-for-quality.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织模块和命名空间，以极大地提高测试、团队开发和面向质量的设计。
- en: One thing we don’t discuss is how to use a particular SPA framework library.
    We have many reasons for this (see the sidebar in [chapter 6](kindle_split_017.html#ch06)
    for an in-depth discussion). We want to explain the inner workings of well-written
    SPAs instead of the implementation intricacies that apply to only a single framework
    library. Instead, we use an architecture refined over six years and many commercial
    products. This architecture encourages testability, readability, and design-for-quality.
    It also makes dividing work between many client developers simple and enjoyable.
    With this approach, readers who *want* to use a framework library can make an
    informed decision and use it with greater success.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有讨论的是如何使用特定的SPA框架库。我们有很多原因（参见[第6章](kindle_split_017.html#ch06)侧边栏中的深入讨论）。我们想解释编写良好的SPA的内部工作原理，而不是仅适用于单个框架库的实现复杂性。相反，我们使用经过六年和许多商业产品优化的架构。这个架构鼓励可测试性、可读性和面向质量的设计。它还使得在多个客户端开发者之间分配工作变得简单且愉快。采用这种方法，那些*想要*使用框架库的读者可以做出明智的决定，并更成功地进行使用。
- en: Chapter 3\. Develop the Shell
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3章：开发Shell
- en: '|  |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**This chapter covers**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Describing the Shell module and its place in our architecture
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述Shell模块及其在我们架构中的位置
- en: Structuring your files and namespaces
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构化你的文件和命名空间
- en: Creating and styling feature containers
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和设计功能容器
- en: Using an event handler to toggle a feature container
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事件处理器切换功能容器
- en: Using the anchor interface pattern to manage application state
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用锚接口模式来管理应用程序状态
- en: '|  |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In this chapter, we describe the *Shell*, a required component of our architecture.
    We develop a page layout that contains our feature containers, and then adjust
    the Shell to render them. Next we show how the Shell manages feature containers
    by having it extend and retract the chat slider. We then have it capture the user
    click event to open and close the slider. Finally, we use the URI anchor as our
    state API using the *anchor interface pattern*. This provides users the browser
    controls they expect—controls like Forward and Back buttons, browser history,
    and bookmarks.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们描述了*Shell*，这是我们架构的一个必需组件。我们开发了一个包含我们的功能容器的页面布局，然后调整Shell来渲染它们。接下来，我们展示了Shell如何通过扩展和收缩聊天滑块来管理功能容器。然后，我们让它捕获用户点击事件以打开和关闭滑块。最后，我们使用URI锚点作为我们的状态API，采用*锚点接口模式*。这为用户提供他们期望的浏览器控件——如前进和后退按钮、浏览器历史记录和书签。
- en: By the end of this chapter we’ll have built the foundation for a scalable and
    manageable SPA. But let’s not get too far ahead of ourselves. First we must understand
    the Shell.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将为可扩展和可管理的SPA打下基础。但让我们不要过于超前。首先，我们必须理解Shell。
- en: 3.1\. Grok the Shell
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1\. 理解Shell
- en: 'The *Shell* is the master controller for our SPA and is required in our architecture.
    We can compare the role of the Shell module to the shell of an airplane:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*Shell*是我们SPA的主控制器，并在我们的架构中是必需的。我们可以将Shell模块的作用与飞机的机身进行比较：'
- en: '*An airplane’s shell* (also called the monocoque or airframe) provides shape
    and structure to the vehicle. Assemblies like the seats, tray tables, and the
    engines are attached to it using various fasteners. All assemblies are built to
    work as independently as possible because nobody likes it when Aunt Milly opens
    her tray table and it causes the jet to promptly bank hard to the right.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*飞机的壳体*（也称为单体或机身）为车辆提供形状和结构。座椅、托盘桌和发动机等组件通过各种紧固件附着在其上。所有组件都设计成尽可能独立地工作，因为没有人喜欢当阿姨米莉打开她的托盘桌时，飞机突然向右急剧倾斜。'
- en: '*The Shell module* provides shape and structure to our application. Feature
    modules like chat, sign-in, and navigation are “attached” to the Shell with APIs.
    All feature modules are built to work as independently as possible because nobody
    likes it when Aunt Milly types “`ROTFLMAO!!!` `UR` `totally` `pwned!`” into her
    chat slider and the application promptly closes her browser window.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*Shell模块*为我们应用程序提供形状和结构。像聊天、登录和导航这样的功能模块通过API“附着”到Shell上。所有功能模块都设计成尽可能独立地工作，因为没有人喜欢当阿姨米莉在她的聊天滑块中输入“`ROTFLMAO!!!`
    `UR` `totally` `pwned!`”时，应用程序立即关闭她的浏览器窗口。'
- en: The Shell is just one piece of an architecture which we refined over many commercial
    projects. This architecture—and where the Shell fits in—is shown in [figure 3.1](#ch03fig01).
    We like to write the Shell first because it’s central to our architecture. It
    coordinates the *feature modules* with the business logic and universal browser
    interfaces like the URI or cookies. When the user clicks the Back button, signs
    in, or does anything else that changes the bookmark-able state of the application,
    the Shell coordinates the change.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Shell只是我们在许多商业项目中精炼的架构的一部分。这个架构——以及Shell的位置——在[图3.1](#ch03fig01)中展示。我们喜欢首先编写Shell，因为它是我们架构的核心。它协调功能模块与业务逻辑和通用浏览器接口（如URI或cookies）之间的关系。当用户点击后退按钮、登录或执行任何其他改变应用程序可书签状态的操作时，Shell协调这种变化。
- en: Figure 3.1\. The Shell in our SPA architecture
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.1\. 我们SPA架构中的Shell
- en: '![](03fig01_alt.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![03fig01_alt.jpg](03fig01_alt.jpg)'
- en: Those of you comfortable with the Model-View-Controller (MVC) architecture may
    consider the Shell the master controller, as it coordinates the controllers of
    all the subordinate feature modules.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于熟悉模型-视图-控制器（MVC）架构的您来说，可能会认为Shell是主控制器，因为它协调所有从属功能模块的控制器。
- en: 'The Shell is responsible for the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Shell负责以下事项：
- en: Rendering and managing the feature containers
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染和管理功能容器
- en: Managing the application state
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理应用程序状态
- en: Coordinating feature modules
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协调功能模块
- en: The next chapter will detail the coordination of feature modules. This chapter
    covers rendering the feature containers and managing the application state. First
    let’s prepare our files and namespaces.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将详细介绍功能模块的协调。本章涵盖渲染功能容器和管理应用程序状态。首先让我们准备我们的文件和命名空间。
- en: 3.2\. Set up the files and namespaces
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2\. 设置文件和命名空间
- en: We’ll set up our files and namespaces according to the code standards found
    in [appendix A](kindle_split_022.html#app01). In particular, we’ll have one JavaScript
    file per JavaScript namespace, and use self-executing anonymous functions to prevent
    pollution of the global namespace. We’ll also set up CSS files in a parallel structure.
    This convention speeds development, improves quality, and eases maintenance. Its
    value increases as we add more modules and developers to the project.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根据 [附录 A](kindle_split_022.html#app01) 中找到的代码标准来设置我们的文件和命名空间。特别是，我们将为每个 JavaScript
    命名空间创建一个 JavaScript 文件，并使用自执行的匿名函数来防止全局命名空间的污染。我们还将设置具有并行结构的 CSS 文件。这种约定加快了开发速度，提高了质量，并简化了维护。随着我们向项目中添加更多模块和开发者，其价值也会增加。
- en: 3.2.1\. Create the file structure
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.1\. 创建文件结构
- en: We’ve selected `spa` for the root namespace of our application. We synchronize
    the JavaScript and CSS file names, the JavaScript namespace, and the CSS selector
    names. This makes it much easier to track which JavaScript goes with which CSS.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的应用程序的根命名空间选择了 `spa`。我们同步 JavaScript 和 CSS 文件名、JavaScript 命名空间和 CSS 选择器名称。这使得跟踪哪个
    JavaScript 与哪个 CSS 相关联变得容易得多。
- en: Plan the Directories and Files
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 规划目录和文件
- en: 'Web developers often place their HTML file in a directory and then place their
    CSS and JavaScript in subdirectories. We see no reason to break convention. Let’s
    create the directories and files as shown in [listing 3.1](#ch03list01):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 网页开发者通常将他们的 HTML 文件放在一个目录中，然后将他们的 CSS 和 JavaScript 放在子目录中。我们没有看到打破传统的原因。让我们创建如
    [列表 3.1](#ch03list01) 所示的目录和文件：
- en: Listing 3.1\. Files and directories, first pass
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.1\. 文件和目录，第一次遍历
- en: '![](063fig01_alt.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![063fig01_alt.jpg](063fig01_alt.jpg)'
- en: Now that we have the basics in place, let’s get jQuery installed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了基础，让我们开始安装 jQuery。
- en: Install Jquery and a Plugin
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 安装 jQuery 和插件
- en: jQuery and its plugins are often offered as either minified or regular files.
    We almost always install the regular files because this helps in debugging, and
    we minimize as part of our build system anyway. Don’t worry about what they do
    yet—we’ll get to that later in the chapter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 及其插件通常提供为压缩版或普通版文件。我们几乎总是安装普通版文件，因为这有助于调试，而且我们无论如何都会在我们的构建系统中进行压缩。不用担心它们的功能——我们将在本章的后面部分详细介绍。
- en: 'The jQuery library provides useful cross-platform DOM manipulation and other
    utilities. We’re using version 1.9.1, which is available from [http://docs.jquery.com/Downloading_jQuery](http://docs.jquery.com/Downloading_jQuery).
    Let’s place it in our jQuery directory:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 库提供了有用的跨平台 DOM 操作和其他实用工具。我们使用的是版本 1.9.1，可以从 [http://docs.jquery.com/Downloading_jQuery](http://docs.jquery.com/Downloading_jQuery)
    获取。让我们将其放置在我们的 jQuery 目录中：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The jQuery `uriAnchor` plugin provides utilities to manage the anchor component
    of the URI. It’s available from github at [https://github.com/mmikowski/urianchor](https://github.com/mmikowski/urianchor).
    Let’s place it in the same jQuery directory:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 的 `uriAnchor` 插件提供了管理 URI 锚组件的实用工具。它可以在 github 上找到 [https://github.com/mmikowski/urianchor](https://github.com/mmikowski/urianchor)。让我们将其放置在相同的
    jQuery 目录中：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Our files and directories should now look like [listing 3.2](#ch03list02):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们文件和目录现在应该看起来像 [列表 3.2](#ch03list02)：
- en: Listing 3.2\. Files and directories after adding jQuery and plugin
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.2\. 添加 jQuery 和插件后的文件和目录
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that we have all of our files in place, it’s time to start writing some
    HTML, CSS, and JavaScript.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将所有文件放置到位，是时候开始编写一些 HTML、CSS 和 JavaScript 了。
- en: 3.2.2\. Write the application HTML
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.2\. 编写应用程序 HTML
- en: When we open our browser document (spa/spa.html) we can bask in all the SPA
    goodness we’ve wrought so far. Of course, because this is an empty file, the goodness
    provided is limited to a bug-free, highly secure blank page that does absolutely
    nothing. Let’s change the “blank page” part.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打开我们的浏览器文档（spa/spa.html）时，我们可以享受到目前为止我们所创造的所有的单页应用（SPA）优点。当然，因为这个文件是空的，所以提供的优点仅限于一个无错误的、高度安全的空白页，什么也不做。让我们改变“空白页”部分。
- en: 'The browser document (spa/spa.html) will always remain small. Its only role
    is to load libraries and stylesheets, and then start our application. Let’s fire
    up our favorite text editor and add all the code we’ll need to get through this
    chapter, as shown in [listing 3.3](#ch03list03):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器文档（spa/spa.html）将始终保持小巧。它的唯一作用是加载库和样式表，然后启动我们的应用程序。让我们启动我们最喜欢的文本编辑器，并添加我们通过本章所需的全部代码，如
    [列表 3.3](#ch03list03) 所示：
- en: Listing 3.3\. Application HTML—spa/spa.html
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.3\. 应用程序 HTML—spa/spa.html
- en: '![](065fig01_alt.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![065fig01_alt.jpg](065fig01_alt.jpg)'
- en: The performance conscious developers in the audience might ask “Why don’t we
    put scripts at the end of the `body` container like traditional web pages?” That
    is a fair question, because this usually allows the page to render faster, as
    static HTML and CSS can be displayed before the JavaScript finishes loading. SPAs
    don’t work like that, though. They generate the HTML with JavaScript, and therefore
    placing the scripts outside the header doesn’t result in faster rendering. Instead,
    we keep all of the external scripts in the `head` section to improve organization
    and legibility.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在场的性能意识开发者可能会问：“为什么我们不把脚本放在 `body` 容器的末尾，就像传统的网页一样？”这是一个合理的问题，因为这样通常可以使页面渲染更快，因为静态HTML和CSS可以在JavaScript加载完成之前显示。但是，单页应用（SPAs）并不这样工作。它们使用JavaScript生成HTML，因此将脚本放在头部外部并不会导致渲染更快。相反，我们保持所有外部脚本在
    `head` 部分以改善组织和可读性。
- en: 3.2.3\. Create the root CSS namespace
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.3. 创建根CSS命名空间
- en: 'Our root namespace is `spa`, and per our convention from [appendix A](kindle_split_022.html#app01)
    our root stylesheet should be called spa/css/spa.css. We previously created this
    file, but now it’s time to populate it. Because this is our root stylesheet, it’ll
    have a few more sections than our other CSS files. Let’s again use our favorite
    text editor to add the rules we need, as shown in [listing 3.4](#ch03list04):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的根命名空间是 `spa`，根据我们在[附录A](kindle_split_022.html#app01)中的约定，我们的根样式表应该命名为 spa/css/spa.css。我们之前创建了此文件，但现在我们需要填充它。因为这是我们的根样式表，它将比我们的其他CSS文件包含更多部分。让我们再次使用我们最喜欢的文本编辑器来添加所需的规则，如图[列表3.4](#ch03list04)所示：
- en: Listing 3.4\. The root CSS namespace—spa/css/spa.css
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.4. 根CSS命名空间—spa/css/spa.css
- en: '![](ch03list04-0.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch03list04-0.jpg)'
- en: '![](ch03list04-1.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch03list04-1.jpg)'
- en: Per our code standards, all CSS IDs and class names in this file are preceded
    by the `spa-` prefix. Now that we’ve created the root application CSS, we’ll create
    the corresponding JavaScript namespace.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的代码标准，这个文件中所有的CSS ID和类名都以前缀 `spa-` 开头。现在我们已经创建了根应用程序CSS，我们将创建相应的JavaScript命名空间。
- en: 3.2.4\. Create the root JavaScript namespace
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.4. 创建根JavaScript命名空间
- en: 'Our root namespace is `spa`, and per our convention from [appendix A](kindle_split_022.html#app01),
    our root JavaScript should be called spa/js/spa.js. The minimal JavaScript required
    is `var` `spa` `=` `{};`. But, we want to add a method to initialize the application,
    and we want to ensure that the code will pass JSLint. We can use the template
    from [appendix A](kindle_split_022.html#app01) and pare it down because we don’t
    need all the sections. Let’s open the file with our second-most-favorite text
    editor and populate it as shown in [listing 3.5](#ch03list05):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的根命名空间是 `spa`，根据我们在[附录A](kindle_split_022.html#app01)中的约定，我们的根JavaScript应该命名为
    spa/js/spa.js。所需的JavaScript最少是 `var spa = {};`。但是，我们想要添加一个初始化应用程序的方法，并确保代码能够通过JSLint检查。我们可以使用[附录A](kindle_split_022.html#app01)中的模板，并对其进行简化，因为我们不需要所有部分。让我们用我们第二喜欢的文本编辑器打开文件，并按照[列表3.5](#ch03list05)中的内容进行填充：
- en: Listing 3.5\. The root JavaScript namespace—spa/js/spa.js
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.5. 根JavaScript命名空间—spa/js/spa.js
- en: '![](067fig01_alt.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](067fig01_alt.jpg)'
- en: We want to ensure our code doesn’t have any common errors or bad practices.
    [Appendix A](kindle_split_022.html#app01) shows how to install and run the valuable
    JSLint utility, which does just that. It describes what all the `/*jslint ...
    */` switches at the top of our files mean. Besides the appendix, we also discuss
    JSLint further in [chapter 5](kindle_split_016.html#ch05).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要确保我们的代码没有任何常见错误或不良实践。[附录A](kindle_split_022.html#app01)展示了如何安装和运行有价值的JSLint实用工具，它正是这样做的。它描述了文件顶部所有的
    `/*jslint ... */` 开关的含义。除了附录，我们还在[第5章](kindle_split_016.html#ch05)中进一步讨论了JSLint。
- en: Let’s check our code by typing `jslint spa/js/spa.js` at the command line—we
    shouldn’t see any warnings or errors. We can now open our browser document (spa/
    spa.html) and see the contract-mandated “hello world” demonstration as shown in
    [figure 3.2](#ch03fig02).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在命令行中输入 `jslint spa/js/spa.js` 来检查我们的代码——我们不应该看到任何警告或错误。现在我们可以打开我们的浏览器文档（spa/spa.html），并看到合同规定的“hello
    world”演示，如图[图3.2](#ch03fig02)所示。
- en: Figure 3.2\. Obligatory “hello world” screenshot
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.2. 强制性的“hello world”截图
- en: '![](03fig02.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](03fig02.jpg)'
- en: Now that we’ve greeted the world and are emboldened by the savory flavor of
    success, let’s embark on a more ambitious quest. In the next section, we start
    building our first “real-world” SPA.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经向世界打招呼，并因成功的甜美味道而信心倍增，让我们开始一个更雄心勃勃的探索。在下一节中，我们将开始构建我们的第一个“真实世界”SPA。
- en: 3.3\. Create the feature containers
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3. 创建功能容器
- en: The Shell creates and manages the containers our feature modules will use. Our
    chat slider container, for example, will follow popular convention and be anchored
    on the bottom right of the browser window. The Shell is responsible for the slider
    container, but won’t manage the behavior inside of the container—that’s reserved
    for the chat feature module, which we’ll discuss in [chapter 6](kindle_split_017.html#ch06).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 外壳创建并管理我们的功能模块将使用的容器。例如，我们的聊天滑块容器将遵循流行惯例，并锚定在浏览器窗口的右下角。外壳负责滑块容器，但不会管理容器内部的行为——这留给了聊天功能模块，我们将在
    [第 6 章](kindle_split_017.html#ch06) 中讨论。
- en: Let’s place our chat slider in a layout that’s relatively complete. [Figure
    3.3](#ch03fig03) shows a wireframe of the containers we’d like to see.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把聊天滑块放置在一个相对完整的布局中。[图 3.3](#ch03fig03) 显示了我们希望看到的容器线框图。
- en: Figure 3.3\. Application containers wireframe
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.3\. 应用程序容器线框图
- en: '![](03fig03.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig03.jpg)'
- en: Of course, this is only a wireframe. We need to convert this into HTML and CSS.
    Let’s discuss how we might do that.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是一个线框图。我们需要将其转换为 HTML 和 CSS。让我们讨论一下我们可能如何做到这一点。
- en: 3.3.1\. Pick a strategy
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.1\. 选择策略
- en: We’ll develop the HTML and CSS for our feature containers in a single-layout
    document file at spa/layout.html. Only after we’ve tweaked our containers to our
    liking will we move the code to the Shell’s CSS and JavaScript files. This approach
    is usually the fastest and most efficient means to develop the initial layout
    because we can proceed without worrying about interactions with most other code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 spa/layout.html 单一布局文档文件中开发我们的功能容器的 HTML 和 CSS。只有在我们将容器调整到满意的程度之后，我们才会将代码移动到外壳的
    CSS 和 JavaScript 文件中。这种方法通常是开发初始布局最快和最有效的方法，因为我们可以在不担心与其他代码交互的情况下进行操作。
- en: First we’ll write the HTML, and then later we’ll add the styles.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先编写 HTML，然后稍后添加样式。
- en: 3.3.2\. Write the Shell HTML
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.2\. 编写外壳 HTML
- en: 'One great feature of HTML5 and CSS3 is that we really *can* separate styling
    from the content. The wireframe shows the containers we want and how they’ll be
    nested. This is all we need to write the HTML for our containers with confidence.
    Let’s open our layout document ([spa/layout.html](http://spa/layout.html)) and
    enter the HTML shown in [listing 3.6](#ch03list06):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5 和 CSS3 的一个显著特点是我们真的可以分离样式和内容。线框图显示了我们想要的容器以及它们的嵌套方式。这就是我们自信地编写容器 HTML
    所需要的一切。让我们打开我们的布局文档 ([spa/layout.html](http://spa/layout.html)) 并输入 [列表 3.6](#ch03list06)
    中所示的 HTML：
- en: Listing 3.6\. Create HTML for the containers—spa/layout.html
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.6\. 创建容器的 HTML——spa/layout.html
- en: '![](069fig01_alt.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](069fig01_alt.jpg)'
- en: Now we should validate the HTML to ensure it’s without error. We like to use
    the venerable Tidy tool, which can find missing tags and other common HTML errors.
    You can find Tidy online at [http://infohound.net/tidy/](http://infohound.net/tidy/),
    or download the source at [http://tidy.sourceforge.net/](http://tidy.sourceforge.net/).
    If you’re using a Linux distribution like Ubuntu or Fedora, Tidy is probably readily
    available in the standard software repositories. Now let’s give these containers
    some style.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该验证 HTML 以确保它没有错误。我们喜欢使用备受推崇的 Tidy 工具，它可以找到缺失的标签和其他常见的 HTML 错误。您可以在 [http://infohound.net/tidy/](http://infohound.net/tidy/)
    在线找到 Tidy，或从 [http://tidy.sourceforge.net/](http://tidy.sourceforge.net/) 下载源代码。如果您使用的是
    Ubuntu 或 Fedora 等Linux发行版，Tidy 可能已经在标准软件仓库中可用。现在让我们给这些容器添加一些样式。
- en: 3.3.3\. Write the Shell CSS
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.3\. 编写外壳 CSS
- en: We’ll write our CSS to provide a *liquid layout* where the width and height
    of our content will adjust to fill the browser window at all but the most extreme
    sizes. We’ll give our feature containers background colors so we can easily see
    them. We’ll also avoid any borders, because they can change the size of the CSS
    boxes. This introduces unwanted tedium into our rapid prototype process. Once
    we’re happy with the presentation of our containers, we can return to add borders
    as necessary.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写 CSS 以提供一种 *液体布局*，其中内容的宽度和高度将调整以填充浏览器窗口，除非在最极端的大小之外。我们将为我们的功能容器提供背景颜色，这样我们就可以轻松地看到它们。我们还将避免任何边框，因为它们可以改变
    CSS 盒子的大小。这会给我们的快速原型过程带来不必要的繁琐。一旦我们对容器的展示感到满意，我们就可以返回添加必要的边框。
- en: '|  |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Liquid layouts**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**液体布局**'
- en: As our layout grows more complex, we may need to use JavaScript to provide its
    *liquidity*. Often a window resize event handler is used to determine the browser
    window size and then recalculate and apply new CSS dimensions. We illustrate this
    technique in [chapter 4](kindle_split_015.html#ch04).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的布局变得越来越复杂，我们可能需要使用 JavaScript 来提供其**流动性**。通常，我们会使用窗口大小调整事件处理器来确定浏览器窗口的大小，然后重新计算并应用新的
    CSS 尺寸。我们在[第 4 章](kindle_split_015.html#ch04)中展示了这一技术。
- en: '|  |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Let’s add the CSS to the `<head>` section of our layout document ([spa/layout.html](http://spa/layout.html)).
    We can place it right after the `spa.css` stylesheet link as shown in [listing
    3.7](#ch03list07). All changes are shown in **bold**:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将 CSS 添加到布局文档的 `<head>` 部分 ([spa/layout.html](http://spa/layout.html))。我们可以在
    `spa.css` 样式表链接之后立即放置它，如图[3.7 节](#ch03list07)所示。所有更改都以**粗体**显示：
- en: Listing 3.7\. Create CSS for the containers—spa/layout.html
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.7\. 为容器创建 CSS—spa/layout.html
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When we open our browser document ([spa/layout.html](http://spa/layout.html)),
    we should see a page that looks amazingly similar to our wireframe, as shown in
    [figure 3.4](#ch03fig04). When we resize the browser window, we can see the feature
    containers also resize as needed. Our liquid layout does have a limitation—if
    we make the width or height less than 500 pixels, scrollbars are shown. We do
    this because we can’t squeeze our content below this size.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打开我们的浏览器文档 ([spa/layout.html](http://spa/layout.html)) 时，我们应该看到一个看起来与我们的线框图惊人相似的页面，如图[3.4
    节](#ch03fig04)所示。当我们调整浏览器窗口大小时，我们可以看到功能容器也会相应调整大小。我们的流动布局确实有一个限制——如果我们使宽度或高度小于
    500 像素，将显示滚动条。我们这样做是因为我们无法将内容挤压到这个大小以下。
- en: Figure 3.4\. HTML and CSS for containers—spa/layout.html
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.4\. 容器的 HTML 和 CSS—spa/layout.html
- en: '![](03fig04.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig04.jpg)'
- en: We can use Chrome Developer Tools to try out some of our newly defined styles
    that aren’t used in the initial display. For example, let’s add the class `spa-x-closed`
    to the `spa-shell-main` container. This will close the navigation bar on the left
    of the page. Removing the class will return the navigation bar, as shown in [figure
    3.5](#ch03fig05).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Chrome 开发者工具来尝试一些我们新定义的样式，这些样式在初始显示中并未使用。例如，让我们将类 `spa-x-closed` 添加到
    `spa-shell-main` 容器中。这将关闭页面左侧的导航栏。移除该类将恢复导航栏，如图[3.5 节](#ch03fig05)所示。
- en: Figure 3.5\. Double-click in the HTML to add a class in Chrome Developer Tools
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.5\. 在 Chrome 开发者工具中双击 HTML 添加类
- en: '![](03fig05_alt.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig05_alt.jpg)'
- en: 3.4\. Render the feature containers
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4\. 渲染功能容器
- en: The layout document ([spa/layout.html](http://spa/layout.html)) we created is
    a nice foundation. Now we’re going to use it in our SPA. The first step is to
    have the Shell render the containers instead of using static HTML and CSS.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的布局文档 ([spa/layout.html](http://spa/layout.html)) 是一个很好的基础。现在我们将使用它在我们的
    SPA 中。第一步是让 Shell 渲染容器，而不是使用静态 HTML 和 CSS。
- en: 3.4.1\. Convert the HTML to JavaScript
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.1\. 将 HTML 转换为 JavaScript
- en: 'We’ll need our JavaScript to manage all our document changes; therefore, we
    need to convert the HTML developed earlier into a JavaScript string. We’ll keep
    the HTML indentation to ease legibility and maintainability as shown in [listing
    3.8](#ch03list08):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要我们的 JavaScript 来管理所有文档更改；因此，我们需要将之前开发的 HTML 转换为 JavaScript 字符串。我们将保持 HTML
    缩进以方便可读性和维护性，如图[3.8 节](#ch03list08)所示：
- en: Listing 3.8\. Concatenating the HTML template
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.8\. 连接 HTML 模板
- en: '[PRE4]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We aren’t worried about any performance penalty of concatenated strings. Once
    we get to production, the JavaScript minifier will join the string for us.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不担心连接字符串的性能惩罚。一旦进入生产阶段，JavaScript 压缩器会为我们连接字符串。
- en: '|  |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Configure your editor!**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**配置您的编辑器！**'
- en: 'A professional developer should be using a professional-grade text editor or
    IDE. Most of these have regular expression and macro support. We should be able
    to automate converting HTML into a JavaScript string. For example, the venerable
    `vim` editor can be configured so that two keystrokes will format HTML into a
    JavaScript concatenated string. We can add the following to our ~/.vimrc file:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一位专业的开发者应该使用专业级的文本编辑器或 IDE。其中大多数都支持正则表达式和宏。我们应该能够自动化将 HTML 转换为 JavaScript 连接字符串。例如，备受尊敬的
    `vim` 编辑器可以被配置为通过两个按键将 HTML 格式化为 JavaScript 连接字符串。我们可以在我们的 ~/.vimrc 文件中添加以下内容：
- en: '[PRE5]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once we restart vim, we can visually select the HTML to change. When we press
    `;q` the selection will be formatted; when we press `;h` we will undo the format.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们重启 vim，我们可以直观地选择要更改的 HTML。当我们按下 `;q` 时，选择将被格式化；当我们按下 `;h` 时，我们将撤销格式。
- en: '|  |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 3.4.2\. Add an HTML template to our JavaScript
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.2\. 将 HTML 模板添加到我们的 JavaScript 中
- en: 'It’s now time to take a bold step and create our Shell. When we initialize
    the Shell, we’d like to have it fill the page element of our choice with the feature
    containers. While we’re at it, we’d like to cache the jQuery collection objects.
    We can use the module template from [appendix A](kindle_split_022.html#app01)
    along with the JavaScript string we just created to accomplish this. Let’s fire
    up our text editor and create the file shown in [listing 3.9](#ch03list09). Please
    pay careful attention to the annotations, as they provide useful details:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候大胆地迈出一步，创建我们的Shell。当我们初始化Shell时，我们希望它用功能容器填充我们选择页面的元素。在此期间，我们还想缓存jQuery集合对象。我们可以使用附录A中的模块模板[kindle_split_022.html#app01]以及我们刚刚创建的JavaScript字符串来完成此操作。让我们打开我们的文本编辑器并创建[列表3.9](#ch03list09)中所示的文件。请仔细注意注释，因为它们提供了有用的细节：
- en: Listing 3.9\. Starting the Shell—spa/js/spa.shell.js
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.9. 启动Shell——spa/js/spa.shell.js
- en: '![](ch03list09-0.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](ch03list09-0.jpg)'
- en: '![](ch03list09-1.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](ch03list09-1.jpg)'
- en: Now we have a module that renders the feature containers, but we still have
    to populate the CSS file and instruct the root namespace module (spa/js/spa.js)
    to use the Shell module (spa/js/spa.shell.js) instead of presenting the time-honored
    “hello world” text. Let’s get to it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个渲染功能容器的模块，但我们仍然需要填充CSS文件，并指导根命名空间模块（spa/js/spa.js）使用Shell模块（spa/js/spa.shell.js）而不是展示传统的“hello
    world”文本。让我们开始吧。
- en: 3.4.3\. Write the Shell stylesheet
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.3. 编写Shell样式表
- en: 'Using our handy namespacing conventions presented in [appendix A](kindle_split_022.html#app01),
    we know we need to put our `spa-shell-*` selectors into a file named spa/css/spa.shell.css.
    We can copy the CSS we developed in [spa/layout.html](http://spa/layout.html)
    directly into that file, as shown in [listing 3.10](#ch03list10):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们在附录A中介绍的命名空间约定[appendix A](kindle_split_022.html#app01)，我们知道我们需要将我们的`spa-shell-*`选择器放入一个名为spa/css/spa.shell.css的文件中。我们可以直接将我们在[spa/layout.html](http://spa/layout.html)中开发的CSS复制到该文件中，如[列表3.10](#ch03list10)所示：
- en: Listing 3.10\. The Shell CSS, take 1—spa/css/spa.shell.css
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.10. Shell CSS，第1版——spa/css/spa.shell.css
- en: '![](ch03list10-0.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](ch03list10-0.jpg)'
- en: '![](ch03list10-1.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](ch03list10-1.jpg)'
- en: 'All Selectors have the `spa-shell-` prefix. This has multiple benefits:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 所有选择器都有`spa-shell-`前缀。这有几个好处：
- en: It shows that these classes are controlled by the Shell module (spa/js/spa.shell.js).
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它显示这些类是由Shell模块（spa/js/spa.shell.js）控制的。
- en: It prevents namespace collisions with third-party scripts and our other modules.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它防止了与第三方脚本和我们的其他模块的命名空间冲突。
- en: When we’re debugging and inspecting the document HTML, we can immediately see
    which elements are generated and controlled by the shell module.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们在调试和检查文档HTML时，我们可以立即看到哪些元素是由shell模块生成的。
- en: All of these benefits prevent us from descending into the fiery depths of CSS-selector-name-goulash
    hell. Anyone who’s ever managed stylesheets on even a moderate scale should know
    exactly what we’re talking about.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些好处都阻止了我们陷入CSS选择器名称混乱的地狱。任何管理过大量样式表的人都应该知道我们说的是什么。
- en: 3.4.4\. Direct the application to use the Shell
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.4. 指导应用程序使用Shell
- en: 'Now let’s modify our root namespace module (spa/js/spa.js) to use the Shell
    instead of slavishly copying “hello world” into the DOM. The following adjustment
    shown in **bold** should do the trick:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们修改我们的根命名空间模块（spa/js/spa.js），让它使用Shell而不是盲目地将“hello world”复制到DOM中。以下**粗体**的调整应该能解决问题：
- en: '[PRE6]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We should now be able to open our browser document ([spa/spa.html](http://spa/spa.html))
    and see something similar to [figure 3.6](#ch03fig06). We can use Chrome Developer
    Tools to confirm the document generated by our SPA ([spa/spa.html](http://spa/spa.html))
    matches our layout document ([spa/layout.html](http://spa/layout.html)).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该能够打开我们的浏览器文档([spa/spa.html](http://spa/spa.html))并看到类似于[图3.6](#ch03fig06)的内容。我们可以使用Chrome开发者工具来确认我们的SPA生成的文档([spa/spa.html](http://spa/spa.html))与我们的布局文档([spa/layout.html](http://spa/layout.html))相匹配。
- en: Figure 3.6\. It’s like deja vu all over again—spa/spa.html
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.6. 这就像又一次的似曾相识——spa/spa.html
- en: '![](03fig06.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig06.jpg)'
- en: With this foundation in place, we’ll begin the work to have the Shell manage
    the feature containers. It might also be a good time to take a break, as the next
    section is fairly ambitious.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个基础上，我们将开始工作，让Shell管理功能容器。现在休息一下可能也是个好主意，因为下一部分相当雄心勃勃。
- en: 3.5\. Manage the feature containers
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5. 管理功能容器
- en: The Shell renders and controls the *feature containers*. These are “top level”
    containers—usually `DIV`s—that hold feature content. The Shell initializes and
    coordinates all the feature modules in the application. And the Shell directs
    feature modules to create and manage all content inside feature containers. We’ll
    discuss feature modules further in [chapter 4](kindle_split_015.html#ch04).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Shell负责渲染和控制*功能容器*。这些是“顶级”容器——通常是`DIV`元素，它们包含功能内容。Shell初始化并协调应用程序中的所有功能模块。Shell指导功能模块创建和管理功能容器内的所有内容。我们将在第4章中进一步讨论功能模块。[第4章](kindle_split_015.html#ch04)。
- en: In this section, we’ll first write a method to extend and retract the chat slider
    feature container. We’ll then build the click event handler so the slider may
    be opened or closed whenever the user wishes. Then we’ll check our work and talk
    about the next big thing—managing the page state using the URI hash fragment.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们首先编写一个方法来展开和缩回聊天滑动功能容器。然后我们将构建点击事件处理器，以便用户可以根据需要随时打开或关闭滑动。然后我们将检查我们的工作，并讨论下一个重要的事情——使用URI哈希片段管理页面状态。
- en: 3.5.1\. Write a method to extend or retract the chat slider
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.1\. 编写展开或缩回聊天滑动的方法
- en: 'We’ll be moderately ambitious with our chat slider function. We need it production-quality,
    but it doesn’t have to be extravagant. Here are the requirements we want to achieve:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对聊天滑动功能将抱有适度的雄心。我们需要它达到生产质量，但不需要过于奢华。以下是我们要实现的要求：
- en: Enable developers to configure the speed and height of slider motions.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许开发者配置滑动动作的速度和高度。
- en: Create a single method to extend or retract the chat slider.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个单一的方法来展开或缩回聊天滑动。
- en: Avoid a race condition where the slider may be extending and retracting at the
    same time.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 避免出现滑动同时展开和缩回的竞态条件。
- en: Enable developers to pass in an optional callback to be invoked on completion
    of a slider motion.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许开发者传递一个可选的回调函数，在滑动动作完成后调用。
- en: Create test code to ensure the slider is functioning properly.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写测试代码以确保滑动正常工作。
- en: 'Let’s adjust the Shell to meet these requirements as shown in [listing 3.11](#ch03list11).^([[1](#ch03fn01)])
    All changes are shown in **bold**. Please review the annotations as they detail
    how the changes pertain to the requirements:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调整Shell以满足这些要求，如[列表3.11](#ch03list11)所示.^([[1](#ch03fn01)]) 所有更改都以**粗体**显示。请查看注释，因为它们详细说明了更改如何与要求相关：
- en: ¹ Now would be a good time to thank your favorite celestial bodies for jQuery,
    as this would be a lot harder without it.
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ 现在是感谢您最喜欢的天体jQuery的时候了，因为没有它这将困难得多。
- en: Listing 3.11\. The Shell, revised to extend and retract the chat slider—spa/js/spa.shell.js
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.11\. Shell，修订以展开和缩回聊天滑动—spa/js/spa.shell.js
- en: '![](ch03list11-0.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch03list11-0.jpg)'
- en: '![](ch03list11-1.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch03list11-1.jpg)'
- en: If you *are* playing along at home, let’s first check our code with JSLint by
    typing `jslintspa/js/spa.shell.js` in the command line—we shouldn’t see any warnings
    or errors. Next let’s reload the browser document ([spa/spa.html](http://spa/spa.html))
    and see the chat slider extend after three seconds and retract after eight seconds.
    Now that we have the slider moving, we can employ a user’s mouse-click to toggle
    its position.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你*正在家中参与其中*，让我们首先通过在命令行中键入`jslintspa/js/spa.shell.js`来使用JSLint检查我们的代码——我们不应该看到任何警告或错误。接下来，让我们重新加载浏览器文档([spa/spa.html](http://spa/spa.html))，并查看聊天滑动在3秒后展开，在8秒后缩回。现在我们有了滑动的效果，我们可以使用用户的鼠标点击来切换其位置。
- en: 3.5.2\. Add the chat slider click event handler
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.2\. 添加聊天滑动点击事件处理器
- en: 'Most users expect to click on a chat slider and see it extend or retract, as
    this is the common convention. Here are the requirements we want to achieve:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数用户期望点击聊天滑动并看到它展开或缩回，因为这是一种常见的约定。以下是我们要实现的要求：
- en: Set tool-tip text to prompt user action, for example “Click to retract.”
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置工具提示文本以提示用户操作，例如“点击缩回。”
- en: Add a click event handler to call `toggleChat`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个点击事件处理器来调用`toggleChat`。
- en: Bind the click event handler to the jQuery event.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将点击事件处理器绑定到jQuery事件。
- en: Let’s adjust the Shell to meet these requirements as shown in [listing 3.12](#ch03list12).
    All changes are again shown in **bold**, and the annotations detail how the changes
    pertain to the requirements.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调整Shell以满足这些要求，如[列表3.12](#ch03list12)所示。所有更改再次以**粗体**显示，注释详细说明了更改如何与要求相关。
- en: Listing 3.12\. The Shell, revised to handle chat slider click events—spa/js/spa.shell.js
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.12\. Shell，修订以处理聊天滑动点击事件—spa/js/spa.shell.js
- en: '![](ch03list12-0.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch03list12-0.jpg)'
- en: '![](ch03list12-1.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch03list12-1.jpg)'
- en: Those playing along at home should again check our code by typing `jslint` `spa/js/spa.shell.js`
    at the command line. We again shouldn’t see any warnings or errors.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在家练习的人应该再次通过在命令行中键入 `jslint` `spa/js/spa.shell.js` 来检查我们的代码。我们不应该看到任何警告或错误。
- en: 'There’s an aspect of jQuery event handlers that we think is crucial to remember:
    the return value is interpreted by jQuery to specify its continued handling of
    the event. We usually return `false` from our jQuery event handlers. Here’s what
    that does:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为 jQuery 事件处理器的一个方面非常重要，需要记住：返回值被 jQuery 解释为指定其继续处理事件。我们通常从我们的 jQuery 事件处理器返回
    `false`。以下是这样做的作用：
- en: It tells jQuery to prevent the default action—like following a link, or selecting
    text—from occurring. The same effect can be acquired by invoking `event.preventDefault()`
    in the event handler.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它告诉 jQuery 阻止默认操作——比如跟随链接或选择文本——的发生。在事件处理器中调用 `event.preventDefault()` 可以获得相同的效果。
- en: It tells jQuery to stop the event from triggering the same event on the parent
    DOM element (this behavior is often called *bubbling*). The same effect can be
    acquired by invoking `event.stopPropagation()` in the event handler.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它告诉 jQuery 停止事件在父 DOM 元素上触发相同的事件（这种行为通常称为 *冒泡*）。在事件处理器中调用 `event.stopPropagation()`
    可以获得相同的效果。
- en: It concludes the handler execution. If the clicked element has other handlers
    bound to it after this handler, the next one in line will be executed. (If we
    don’t want subsequent handlers to execute, we can invoke `event.preventImmediatePropagation()`.)
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它结束了处理器执行。如果点击的元素在此处理器之后还有其他绑定的事件处理器，下一个处理器将被执行。（如果我们不希望后续处理器执行，我们可以调用 `event.preventImmediatePropagation()`。）
- en: These three actions are usually what we want our event handlers to do. Soon
    we’ll write event handlers where we do not want these actions. These event handlers
    will return the `true` value.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个动作通常是我们要让事件处理器执行的动作。很快我们将编写不希望这些动作的事件处理器。这些事件处理器将返回 `true` 值。
- en: The Shell doesn’t need to necessarily handle the click. It could instead provide
    the capability to manipulate the slider as a callback to the chat module—and we
    encourage this. But, because we haven’t written that module yet, we have handled
    the click event in the Shell for now.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 不必一定处理点击事件。它可以通过将滑块操作作为对聊天模块的回调来提供这种能力——我们鼓励这样做。但是，因为我们还没有编写那个模块，所以我们目前还在
    Shell 中处理点击事件。
- en: 'Now let’s add a little flair to our Shell styles. [Listing 3.13](#ch03list13)
    shows the changes:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们给 Shell 样式添加一点风采。[列表 3.13](#ch03list13) 展示了更改：
- en: Listing 3.13\. Adding some flair to the Shell—spa/css/spa.shell.css
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[列表 3.13](#ch03list13)．为 Shell 添加一些风采—spa/css/spa.shell.css'
- en: '![](084fig01_alt.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4.1](084fig01_alt.jpg)'
- en: 'When we reload the browser document ([spa/spa.html](http://spa/spa.html)) we
    can click on the slider and see it extend as shown in [figure 3.7](#ch03fig07):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们重新加载浏览器文档 ([spa/spa.html](http://spa/spa.html)) 时，我们可以点击滑块，看到它像 [图 3.7](#ch03fig07)
    中所示的那样扩展。
- en: Figure 3.7\. Extending the chat slider—spa/spa.html
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.7\. 扩展聊天滑块—spa/spa.html
- en: '![](03fig07.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7](03fig07.jpg)'
- en: 'The slider extends much more slowly than it retracts. We can change the speed
    of the slider by changing the configuration in the Shell (spa/js/spa.shell.js),
    for example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 滑块扩展的速度比收缩慢得多。我们可以通过更改 Shell 中的配置（spa/js/spa.shell.js）来改变滑块的速度，例如：
- en: '[PRE7]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the next section, we’ll adjust our application to better manage its state.
    When we’re finished, all browser history features like Bookmarks, the Forward
    button, and the Back button will work for the chat slider as the user expects.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将调整我们的应用程序以更好地管理其状态。完成之后，所有浏览器历史功能，如书签、前进按钮和后退按钮，都将按用户期望的方式为聊天滑块工作。
- en: 3.6\. Manage application state
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6\. 管理应用程序状态
- en: In computer science, a *state* is a unique configuration of information in an
    application. Desktop and web applications generally try to maintain some state
    between sessions. For example, when we save a word processing document and then
    open it again at a later date, the document is restored. The application may also
    restore the window size, our preferences, and the cursor and page location. Our
    SPA needs to manage state too, because people who use browsers have come to expect
    certain behaviors.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，*状态*是应用程序中信息的唯一配置。桌面和 Web 应用程序通常试图在会话之间保持某种状态。例如，当我们保存一个文档处理文档并在稍后日期再次打开它时，文档会被恢复。应用程序也可能恢复窗口大小、我们的首选项以及光标和页面位置。我们的
    SPA 也需要管理状态，因为使用浏览器的用户已经习惯了某些行为。
- en: 3.6.1\. Understand the behavior browser users expect
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.6.1\. 理解浏览器用户期望的行为
- en: Desktop and web applications vary widely in what aspect of state they maintain.
    A desktop application can omit a Previous button if it doesn’t provide a “go back”
    capability. But in a web application we’ve got the browser’s Back button—one of
    the most frequently used browser controls—staring our user in the face, begging
    to be clicked—and we can’t remove it.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 桌面和Web应用程序在维护状态方面差异很大。如果桌面应用程序不提供“返回”功能，则可以省略上一个按钮。但在Web应用程序中，我们有一个浏览器的前进按钮——这是最常用的浏览器控制之一——直接面对用户，请求被点击——而我们无法将其删除。
- en: And the same goes for the Forward button, the Bookmark button, and View history.
    The users expect these *history* controls to work. If they don’t, our users get
    cranky, and our application will never win a Webby. [Table 3.1](#ch03table01)
    illustrates the approximate desktop application counterparts to these history
    controls.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于前进按钮、书签按钮和查看历史记录，用户期望这些*历史记录*控制能够正常工作。如果它们不能正常工作，我们的用户会变得烦躁，我们的应用程序将永远不会赢得Webby奖。[表3.1](#ch03table01)展示了这些历史记录控制的大致桌面应用程序对应项。
- en: Table 3.1\. Browser versus desktop controls
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表3.1\. 浏览器与桌面控制对比
- en: '| Browser control | Desktop control | Comments |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 浏览器控制 | 桌面控制 | 评论 |'
- en: '| --- | --- | --- |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Back button | Undo | Revert to prior state |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 后退按钮 | 撤销 | 回到先前的状态 |'
- en: '| Forward button | Redo | Restore state from recent “undo” or “back” motion
    |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 向前按钮 | 重做 | 从最近的“撤销”或“后退”动作恢复状态 |'
- en: '| Bookmark | Save As | Store application state for future use or reference
    |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 书签 | 保存为 | 存储应用程序状态以供将来使用或参考 |'
- en: '| View history | Undo History | View steps in undo/redo sequence |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 查看历史记录 | 撤销历史记录 | 查看撤销/重做序列中的步骤 |'
- en: Because we do aspire to win a Webby, we have to ensure these history controls
    work as our users expect. Next we’ll discuss strategies to provide the behaviors
    our users expect.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们确实希望赢得Webby奖，我们必须确保这些历史记录控制按用户期望的方式工作。接下来，我们将讨论提供用户期望的行为的策略。
- en: 3.6.2\. Pick a strategy to manage history controls
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.6.2\. 选择一个策略来管理历史记录控制
- en: 'An optimal strategy to provide history controls should meet these requirements:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 提供历史记录控制的最佳策略应满足以下要求：
- en: The history controls should work as the user expects, per [table 3.1](#ch03table01).
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 历史记录控制应按用户期望的方式工作，如[表3.1](#ch03table01)所示。
- en: Development to support history controls should be reasonably inexpensive. It
    shouldn’t require significantly more time or complexity in comparison to development
    without history controls.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 支持历史记录控制的开发应相对便宜。与没有历史记录控制的开发展开相比，它不应需要更多的时间或复杂性。
- en: The application should perform well. The application shouldn’t take longer to
    respond to user actions, and the user interface shouldn’t be more complicated
    as a result.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序应表现良好。应用程序不应比响应用户动作花费更长的时间，用户界面也不应因此变得更加复杂。
- en: 'Let’s consider some strategies using the chat slider and the following user
    interaction as our example:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以聊天滑块和以下用户交互为例，考虑一些策略：
- en: Susan visits our SPA and clicks on the chat slider to open it.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 苏珊访问我们的SPA并点击聊天滑块以打开它。
- en: She bookmarks the SPA, and then browses to other sites.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 她将SPA添加到书签，然后浏览到其他网站。
- en: Later, she decides to return to our application and clicks on her bookmark.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，她决定返回我们的应用程序并点击她的书签。
- en: Let’s consider three strategies to make Susan’s bookmark work as expected. Please
    don’t worry about memorizing them; we just want to illustrate their relative merits:^([[2](#ch03fn02)])
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑三种策略，使苏珊的书签按预期工作。请不用担心记住它们；我们只是想说明它们的相对优点：^([[2](#ch03fn02)])
- en: ² There are other strategies—like the use of a persistent cookie or an iframe—but
    these are frankly too limited and convoluted to merit consideration.
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ² 有其他策略——比如使用持久cookie或iframe——但这些策略实际上过于有限且复杂，不值得考虑。
- en: '*Strategy 1*—On the click, the event handler directly calls the `toggleChat`
    routine, and ignores the URI. When Susan returns to her bookmark, the slider will
    be presented in its default position—closed. Susan isn’t pleased because the bookmark
    didn’t work as expected. James the developer isn’t pleased either, because his
    product manager finds the usability of the application unacceptable and is pestering
    him about it.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*策略1*——在点击时，事件处理程序直接调用`toggleChat`例程，并忽略URI。当苏珊返回到她的书签时，滑块将显示在其默认位置——关闭。苏珊对此并不满意，因为书签没有按预期工作。开发者詹姆斯也不满意，因为他的产品经理认为应用程序的可用性不可接受，并不断催促他。'
- en: '*Strategy 2*—On the click, the event handler directly calls the `toggleChat`
    routine, and then modifies the URI to record this state. When Susan returns to
    her bookmark, the application must recognize the parameter in the URI and act
    on it. Susan is pleased. James the developer is *not* pleased because he must
    now support two conditions that will open the slider: a run-time click event,
    and a load-time URI parameter. And James’s product manager isn’t too happy either
    because supporting this dual-path approach is slower and prone to bugs and inconsistencies.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*策略 2*—在点击时，事件处理器直接调用 `toggleChat` 例程，然后修改 URI 以记录此状态。当苏珊返回到她的书签时，应用程序必须识别
    URI 中的参数并对其采取行动。苏珊很高兴。开发者詹姆斯则 *不高兴*，因为他现在必须支持两种将滑块打开的条件：运行时点击事件和加载时 URI 参数。而且詹姆斯的产品经理也不太高兴，因为支持这种双路径方法速度较慢，且容易出错和出现不一致。'
- en: '*Strategy 3*—On the click, the event handler changes the URI and then promptly
    returns. The Shell `hashchange` event handler picks up the change, and dispatches
    to the `toggleChat` routine. When Susan returns to her bookmark, the URI is parsed
    by the same routine and the open slider is restored. Susan is pleased because
    the bookmark works as expected. James the developer is pleased as well, because
    he can use *one code path to implement all bookmark-able states*. And James’s
    product manager is pleased too, because development is fast and comparatively
    bug-free.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*策略 3*—在点击时，事件处理器更改 URI 然后立即返回。Shell `hashchange` 事件处理器捕获更改，并将任务调度到 `toggleChat`
    例程。当苏珊返回到她的书签时，URI 由相同的例程解析，并恢复打开的滑块。苏珊很高兴，因为书签按预期工作。开发者詹姆斯也很高兴，因为他可以使用 *一条代码路径实现所有可书签状态*。而且詹姆斯的产品经理也很高兴，因为开发速度快且相对无错误。'
- en: Our preferred solution is *Strategy 3* as it supports all history controls (requirement
    A). It addresses and minimizes development concerns (requirement B). And it ensures
    application performance by adjusting only the parts of the page that need to be
    changed when a history control is used (requirement C). This solution, where the
    URI always drives the page state, we call the *anchor interface pattern*, as shown
    in [figure 3.8](#ch03fig08).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首选的解决方案是 *策略 3*，因为它支持所有历史控制（要求 A）。它解决了并最小化了开发问题（要求 B）。并且通过仅调整在使用历史控制时需要更改的页面部分来确保应用程序性能（要求
    C）。这种 URI 总是驱动页面状态的解决方案，我们称之为 *锚点接口模式*，如图 [图 3.8](#ch03fig08) 所示。
- en: Figure 3.8\. The anchor interface pattern
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.8\. 锚点接口模式
- en: '![](03fig08_alt.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig08_alt.jpg)'
- en: We’ll return to this pattern in [chapter 4](kindle_split_015.html#ch04). Now
    that we have selected our strategy, let’s implement it.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [第 4 章](kindle_split_015.html#ch04) 中回到这个模式。现在我们已经选择了我们的策略，让我们来实现它。
- en: 3.6.3\. Change the anchor when a history event occurs
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.6.3\. 当发生历史事件时更改锚点
- en: 'The anchor component of a URI instructs the browser what part of a page to
    show. Other common names for the anchor are the *bookmark component* or the *hash
    fragment*. The anchor always starts with a `#` symbol, and is shown in **bold**
    in the following code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: URI 的锚点组件指示浏览器显示页面的一部分。锚点的其他常见名称有 *书签组件* 或 *哈希片段*。锚点始终以 `#` 符号开头，在以下代码中用 **粗体**
    表示：
- en: '[PRE8]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Traditionally, web developers have used the anchor mechanism to enable users
    to easily “jump” between sections of a long document. For example, a web page
    that has a table of contents at the top might link all the section titles to their
    corresponding sections within the document. And each of the sections may have
    a “back to top” link at the end. Blogs and forums still use this mechanism extensively.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，网络开发者使用锚点机制来使用户能够轻松地在长文档的各个部分之间“跳转”。例如，顶部有目录的网页可能会将所有章节标题链接到文档中相应的部分。每个部分可能在末尾都有一个“返回顶部”的链接。博客和论坛仍然广泛使用这种机制。
- en: One exceptional feature of the anchor component is that the browser does *not*
    reload the page when it’s changed. The anchor component is a client-side-only
    control, which makes it an ideal place to store our application state. This technique
    is used by many SPAs.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 锚点组件的一个特例是，当它更改时，浏览器不会重新加载页面。锚点组件仅是客户端控制，这使得它成为存储我们应用程序状态的理想位置。这种技术被许多单页应用程序（SPAs）所使用。
- en: We refer to an application state change that we want to keep in the browser
    history as a *history event*. Because we decided that opening or closing the chat
    is a history event (you missed the meeting), we can have our click event handler
    change the anchor to express the chat slider state. We can use the `uriAnchor`
    jQuery plugin to do the heavy lifting. Let’s revise the Shell so a user click
    changes the URI as shown in [listing 3.14](#ch03list14). All changes are shown
    in **bold**.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们希望在浏览器历史记录中保留的应用程序状态变化称为*历史事件*。因为我们决定打开或关闭聊天是一个历史事件（你错过了会议），所以我们可以让我们的点击事件处理器更改锚点以表达聊天滑块的状态。我们可以使用`uriAnchor`jQuery插件来完成这项繁重的工作。让我们修改Shell，以便用户点击可以像[列表3.14](#ch03list14)中所示的那样更改URI。所有更改都以**粗体**显示。
- en: Listing 3.14\. The uriAnchor jQuery plugin at play—spa/js/spa.shell.js
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.14\. uriAnchor jQuery插件在spa/js/spa.shell.js中的应用
- en: '[PRE9]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now when we click on the slider, we see the anchor in the URI change—but only
    if `toggleChat` succeeds and returns true. For example, when we click the chat
    slider open and then closed, we see the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们点击滑块，我们会看到URI中的锚点发生变化——但只有当`toggleChat`成功并返回true时。例如，当我们点击打开和关闭聊天滑块时，我们会看到以下内容：
- en: '[PRE10]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|  |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**About that exclamation point**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于那个感叹号**'
- en: The exclamation point following the hash symbol (`#!`) in the example URI is
    used to inform Google and other search engines that this URI may be indexed for
    search. We’ll cover more about search engine optimization in [chapter 9](kindle_split_021.html#ch09).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例URI中，跟随哈希符号（`#!`）的感叹号用于通知Google和其他搜索引擎，该URI可能被索引以供搜索。我们将在第9章中详细介绍搜索引擎优化。
- en: '|  |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: We need to ensure that when the anchor changes, only the part of the application
    that needs adjustment is changed. This makes the application much faster and avoids
    the disturbing “flicker” that happens when parts of the page are unnecessarily
    cleared and re-rendered. For example, let’s say Susan is viewing a list of a thousand
    user profiles when she opens the chat slider. If she clicks the Back button, the
    application should simply close the slider—the profiles shouldn’t be re-rendered.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保当锚点发生变化时，只有需要调整的应用程序部分发生变化。这使得应用程序运行得更快，并避免了当页面的某些部分不必要地被清除和重新渲染时发生的令人烦恼的“闪烁”。例如，假设Susan在打开聊天滑块时正在查看一千个用户资料的列表。如果她点击返回按钮，应用程序应该简单地关闭滑块——资料不应该被重新渲染。
- en: 'We ask ourselves three questions to determine whether the change from an event
    is worthy of history support:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们问自己三个问题，以确定事件的变化是否值得历史支持：
- en: How strongly will the user want to bookmark the change that has occurred?
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户将多么强烈地希望书签已发生的变化？
- en: How strongly will the user want to revert to the page state before the change?
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户将多么强烈地希望恢复到变化之前的状态？
- en: How expensive will this be?
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将花费多少？
- en: Although the incremental cost to maintain a state is usually minor using the
    anchor interface pattern, there are some situations where it can be expensive
    or impossible. For example, an online purchase would be very difficult to reverse
    when a user clicks the Back button. In such a situation, we need to avoid a history
    entry completely. Lucky for us, our `uriAnchor` plugin supports this.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用锚点接口模式维护状态的增量成本通常很小，但在某些情况下，它可能很昂贵或不可能。例如，当用户点击返回按钮时，在线购买可能很难撤销。在这种情况下，我们需要完全避免历史条目的创建。幸运的是，我们的`uriAnchor`插件支持这一点。
- en: 3.6.4\. Use the anchor to drive the application state
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.6.4\. 使用锚点驱动应用程序状态
- en: 'We want the anchor component to always drive the bookmark-able application
    state. This ensures history functions always work as expected. The following pseudo-code
    outlines how we like to handle a history event:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望锚点组件始终驱动可书签的应用程序状态。这确保了历史功能始终按预期工作。以下伪代码概述了我们如何处理历史事件的方式：
- en: 'When a history event occurs, change the anchor component of the URI to reflect
    the changed state:'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当发生历史事件时，更改URI的锚点组件以反映变化后的状态：
- en: The handler that received the event calls a Shell utility to change the anchor.
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收事件的处理器调用Shell实用程序来更改锚点。
- en: The event handler then exits.
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件处理器随后退出。
- en: 'A Shell `hashchange` event handler notices the URI change and acts on it:'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shell的`hashchange`事件处理器会注意到URI的变化并对其做出反应：
- en: It compares the current state to the state proposed by the new anchor.
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将当前状态与由新锚点提出的状态进行比较。
- en: It tries to change the sections of the application that need adjustment as determined
    by the comparison.
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它试图根据比较结果更改需要调整的应用程序部分。
- en: If it can’t make the requested changes, it maintains the current state and restores
    the anchor to match it.
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它无法执行所需的更改，它将保持当前状态，并将锚恢复以匹配它。
- en: Now that we’ve sketched out the pseudo-code, let’s get to work converting it
    into the real thing.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经绘制了伪代码，让我们开始将其转换为实际内容。
- en: Change the Shell to Use the Anchor Component
  id: totrans-241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将 Shell 修改为使用锚组件
- en: 'Let’s revise the Shell to use the anchor component to drive the application
    state, as shown in [listing 3.15](#ch03list15). There’s a fair bit of new code
    here, but don’t get discouraged—all will be explained in due time:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改 Shell 以使用锚组件来驱动应用程序状态，如 [列表 3.15](#ch03list15) 所示。这里有很多新的代码，但不要气馁——所有内容都将适时解释：
- en: Listing 3.15\. Using the anchor to drive application state—spa/js/spa.shell.js
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.15\. 使用锚来驱动应用程序状态——spa/js/spa.shell.js
- en: '![](ch03list15-0.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch03list15-0.jpg)'
- en: '![](ch03list15-1.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch03list15-1.jpg)'
- en: '![](089fig01_alt.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图片](089fig01_alt.jpg)'
- en: '![](089fig01a_alt.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图片](089fig01a_alt.jpg)'
- en: '![](089fig01b_alt.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图片](089fig01b_alt.jpg)'
- en: '![](089fig01c_alt.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![图片](089fig01c_alt.jpg)'
- en: Now that we’ve adjusted the code, we should see that all history controls—the
    Forward button, the Back button, bookmarks, and browser history—all work as expected.
    And the anchor should “fix itself” if we manually change it to have parameters
    or values that we don’t support—for example, try replacing the anchor in the browser
    address bar with `#!chat=barney` and press Return.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经调整了代码，我们应该看到所有历史控制——前进按钮、后退按钮、书签和浏览器历史记录——都按预期工作。如果我们手动将其更改为我们不支持参数或值，锚应该“自动修复”——例如，尝试在浏览器地址栏中替换锚为
    `#!chat=barney` 并按 Return。
- en: Now that we have the history controls working, let’s discuss how we use the
    anchor to drive the application state. We’ll start by showing how we use the `uriAnchor`
    to encode and decode the anchor.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了历史控制功能，让我们讨论我们如何使用锚来驱动应用程序状态。我们将首先展示我们如何使用 `uriAnchor` 来编码和解码锚。
- en: Understand how Urianchor Encodes and Decodes the Anchor
  id: totrans-252
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 理解 Urianchor 如何编码和解码锚
- en: 'We use the jQuery `hashchange` event to recognize a change in the anchor component.
    Application state is encoded using the concept of *independent* and *dependent*
    key-value pairs. Take for example the following anchor shown in **bold**:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 jQuery 的 `hashchange` 事件来识别锚组件的变化。应用程序状态使用 *独立* 和 *依赖* 键值对的概念进行编码。以下是一个用
    **粗体** 标示的锚示例：
- en: '[PRE11]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The *independent* key in this example is `profile`, and it has a value of `on`.
    Keys that further define the `profile` state are *dependent* keys, and they follow
    the colon (:) delimiter. This includes the key `uid` with a value of `suzie`,
    and the key `status` with the value of `green`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，*独立* 键是 `profile`，其值为 `on`。进一步定义 `profile` 状态的键是 *依赖* 键，它们遵循冒号 (:) 分隔符。这包括键
    `uid`，其值为 `suzie`，以及键 `status`，其值为 `green`。
- en: 'The `uriAnchor` plugin, js/jq/jquery.uriAnchor-1.1.3.js, takes care of encoding
    and decoding dependent and independent values for us. We can use the `$.uriAnchor
    .setAnchor()` method to change the browser URI to match the earlier example:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`uriAnchor` 插件，js/jq/jquery.uriAnchor-1.1.3.js，负责为我们编码和解码依赖和独立值。我们可以使用 `$.uriAnchor
    .setAnchor()` 方法来更改浏览器 URI，以匹配先前的示例：'
- en: '[PRE12]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `makeAnchorMap` method can be used to read and parse the anchor into a
    map:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `makeAnchorMap` 方法来读取和解析锚到一个映射中：
- en: '[PRE13]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Hopefully you now better understand how `uriAnchor` can be used to encode and
    decode the application state expressed in the URI anchor component. Now let’s
    take a closer look at how we use the URI anchor component to drive the application
    state.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你现在更好地理解了如何使用 `uriAnchor` 来编码和解码在 URI 锚组件中表示的应用程序状态。现在让我们更详细地看看我们如何使用 URI
    锚组件来驱动应用程序状态。
- en: Understand how Anchor Changes Drive Application State
  id: totrans-261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 理解锚变化如何驱动应用程序状态
- en: 'Our history control strategy is that any event that changes a bookmark-able
    state should do two things:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的历史控制策略是，任何改变可书签状态的任何事件都应该做两件事：
- en: Change the anchor.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改锚。
- en: Promptly return.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 立即返回。
- en: We added the `changeAnchorPart` method to the Shell, which allowed us to update
    only part of the anchor while ensuring independent and dependent keys and values
    are properly handled. It unified the logic for anchor management, and *it is the
    only means by which the anchor is modified by our application.*
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向 Shell 添加了 `changeAnchorPart` 方法，这使得我们能够更新锚的一部分，同时确保独立和依赖键值得到适当处理。它统一了锚管理的逻辑，*并且这是我们的应用程序修改锚的唯一方式*。
- en: 'When we say “promptly return,” we mean that after the anchor has been changed,
    the event handler’s work is done. It doesn’t change the page elements. It doesn’t
    update variables or flags. It doesn’t pass Go or collect 200 dollars. It simply
    returns directly back to its calling event. This is illustrated in our `onClickChat`
    event handler:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说“立即返回”时，我们的意思是锚点更改后，事件处理器的任务就完成了。它不会更改页面元素。它不会更新变量或标志。它不会通过“GO”或收集200美元。它只是直接返回到其调用事件。这在我们
    `onClickChat` 事件处理器中得到了说明：
- en: '[PRE14]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This event handler uses `changeAnchorPart` to change the `chat` parameter of
    the anchor and then promptly returns. Because the anchor component is changed,
    this initiates a `hashchange` browser event. The Shell listens for `hashchange`
    events and takes action based on the anchor contents. For example, if the Shell
    notices the `chat` value has changed from `opened` to `closed` it closes the chat
    slider.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 此事件处理器使用 `changeAnchorPart` 来更改锚点的 `chat` 参数，然后立即返回。因为锚点组件已更改，这触发了 `hashchange`
    浏览器事件。Shell 监听 `hashchange` 事件并根据锚点内容采取行动。例如，如果Shell注意到 `chat` 值已从 `opened` 变为
    `closed`，它将关闭聊天滑块。
- en: You might think of the anchor—modified by the `changeAnchorPart` method—as *the*
    API for bookmark-able states. The beauty of this approach is that it doesn’t matter
    *why* the anchor was changed—it could be that our application modified it, or
    the user clicked a bookmark, or played with the Forward or Back buttons, or directly
    typed into the browser address bar. In any case, it always works correctly and
    uses only a single execution path.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会把锚点——通过 `changeAnchorPart` 方法修改的锚点——视为可书签状态的 *API*。这种方法的优点是，它无关紧要 *为什么*
    锚点被更改——可能是我们的应用程序修改了它，或者用户点击了书签，或者玩弄了前进或后退按钮，或者直接在浏览器地址栏中输入。无论如何，它总是正确工作，并且只使用单个执行路径。
- en: 3.7\. Summary
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.7. 摘要
- en: We’ve finished implementing two of the primary responsibilities of the Shell.
    We created and styled feature containers, and we created a framework to drive
    application state using the URI anchor. We updated our chat slider to help illustrate
    these concepts.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了 Shell 的两个主要责任的实现。我们创建了并设计了功能容器，并创建了一个框架，使用 URI 锚点驱动应用程序状态。我们更新了聊天滑块以帮助说明这些概念。
- en: 'Our work with the Shell isn’t complete, because we’ve yet to tackle its third
    primary responsibility: coordinating feature modules. Our next chapter shows how
    to build feature modules, how to configure and initialize them from the Shell,
    and how to call them. Isolating features into their own modules greatly improves
    reliability, maintainability, scalability, and workflow. It also encourages the
    use and development of third-party modules. So stick around—this is where the
    rubber hits the road.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们与 Shell 的合作尚未完成，因为我们尚未解决其第三大主要责任：协调功能模块。下一章将展示如何构建功能模块，如何从 Shell 配置和初始化它们，以及如何调用它们。将功能隔离到它们自己的模块中大大提高了可靠性、可维护性、可扩展性和工作流程。它还鼓励使用和开发第三方模块。所以请留下来——这是真正落地的地方。
- en: Chapter 4\. Add feature modules
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4章. 添加功能模块
- en: '|  |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**This chapter covers**'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Defining feature modules and how they fit into our architecture
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义功能模块以及它们如何融入我们的架构
- en: Comparing feature modules and third-party modules
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较功能模块和第三方模块
- en: Explaining the fractal MVC design pattern and its role in our architecture
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释分形 MVC 设计模式及其在我们架构中的作用
- en: Setting up files and directories for feature modules
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为功能模块设置文件和目录
- en: Defining and implementing the feature module APIs
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义和实现功能模块 API
- en: Implementing commonly needed feature module capabilities
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现常用功能模块功能
- en: '|  |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Before you begin, you should have completed [chapters 1](kindle_split_011.html#ch01)–[3](kindle_split_014.html#ch03)
    of this book. You should also have the project files from [chapter 3](kindle_split_014.html#ch03)
    as we’ll be building on them. We recommend you copy all the files and the whole
    directory structure you created in [chapter 3](kindle_split_014.html#ch03) into
    a new “[chapter_4](#ch04)” directory so you may update them there.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，你应该已经完成了本书的[第1章](kindle_split_011.html#ch01)–[第3章](kindle_split_014.html#ch03)。你还应该有第3章的项目文件，因为我们将在它们的基础上构建。我们建议你将第3章中创建的所有文件和整个目录结构复制到一个新的“[第4章](#ch04)”目录中，以便你可以在那里更新它们。
- en: A *feature module* provides a well-defined and scoped capability to the SPA.
    In this chapter we move the chat slider capability introduced in [chapter 3](kindle_split_014.html#ch03)
    into a feature module and improve its capabilities. Besides the chat slider, examples
    of other feature modules might include an image viewer, an account management
    panel, or a workbench where users might assemble graphical objects.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '*功能模块*为SPA提供了一种定义明确且范围有限的 capability。在本章中，我们将第3章中引入的聊天滑块功能移动到一个功能模块中，并提高了其功能。除了聊天滑块之外，其他功能模块的例子可能包括图片查看器、账户管理面板，或者用户可能在其中组装图形对象的工坊。'
- en: We design our feature modules to interface with our application much like third-party
    modules do—with well-defined APIs and strong isolation. This allows us to release
    sooner with higher quality because we can focus on creating our value-add core
    modules while leaving secondary modules to third parties. This strategy also provides
    a clear enhancement path, as we can selectively replace third-party modules with
    better modules as time and resources permit. As an added benefit, our modules
    are easy to reuse across multiple projects.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计的功能模块与我们的应用程序接口类似，就像第三方模块一样——具有定义明确的API和强大的隔离性。这使得我们能够更早地以更高的质量发布，因为我们可以专注于创建我们的增值核心模块，同时将次要模块留给第三方。这种策略还提供了一条清晰的增强路径，因为我们可以在时间和资源允许的情况下，选择性地用更好的模块替换第三方模块。作为额外的优势，我们的模块易于在多个项目中重用。
- en: 4.1\. The feature module strategy
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1. 功能模块策略
- en: The Shell discussed in [chapter 3](kindle_split_014.html#ch03) is responsible
    for application-wide tasks like management of the URI anchor or cookies, and it
    dispatches feature-specific tasks to carefully isolated feature modules. These
    modules have their own View, Controller, and a slice of the Model that the Shell
    shares with them. An overview of the architecture is shown in [figure 4.1](#ch04fig01):^([[1](#ch04fn01)])
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章中讨论的Shell负责应用范围内的任务，如管理URI锚点或cookies，并将特定功能的任务调度到精心隔离的功能模块。这些模块有自己的视图、控制器，以及Shell与他们共享的一部分模型。架构概述如图4.1所示[图4.1](#ch04fig01)：^([[1](#ch04fn01)])
- en: ¹ The author has this diagram taped to the wall next to his desk.
  id: totrans-288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ 作者将此图贴在办公桌旁边的墙上。
- en: Figure 4.1\. Feature modules in SPA architecture (shown in white)
  id: totrans-289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.1. SPA架构中的功能模块（以白色显示）
- en: '![](04fig01_alt.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![04fig01_alt.jpg](04fig01_alt.jpg)'
- en: Sample feature modules might include `spa.wb.js` to handle sketching on a workbench,
    `spa.acct.js` for account management features like sign-in or sign-out, and `spa.chat.js`
    for the chat interface. Because we seem to be on a roll with chat, we’ll focus
    on that module in this chapter.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 样本功能模块可能包括`spa.wb.js`用于在工坊上绘图，`spa.acct.js`用于账户管理功能，如登录或登出，以及`spa.chat.js`用于聊天界面。由于我们似乎在聊天方面取得了进展，因此在本章中我们将重点关注该模块。
- en: 4.1.1\. A comparison with third-party modules
  id: totrans-292
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.1. 与第三方模块的比较
- en: Feature modules are a lot like third-party modules, which provide all sorts
    of capabilities to modern websites.^([[2](#ch04fn02)]) Example third-party modules
    include blog commenting (*DisQus*, or *LiveFyre*), advertising (*DoubleClick*
    or *ValueClick*), analytics (*Google* or *Overture*), sharing (*AddThis* or *ShareThis*),
    and social services (*Facebook* “Like” or *Google* “+1” buttons). They’re enormously
    popular because website operators can add high-quality features to their sites
    at a tiny fraction of the cost, effort, and maintenance than if they were to develop
    the features themselves.^([[3](#ch04fn03)]) Typically, third-party modules are
    added to a website by including a script tag in a static web page, or adding a
    function invocation to an SPA. Many features on many websites wouldn’t be possible
    were it not for third-party modules, as the costs would otherwise be prohibitive.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 功能模块与第三方模块非常相似，它们为现代网站提供各种功能.^([[2](#ch04fn02)]) 示例第三方模块包括博客评论(*DisQus*或*LiveFyre*)、广告(*DoubleClick*或*ValueClick*)、分析(*Google*或*Overture*)、分享(*AddThis*或*ShareThis*)和社交服务(*Facebook*“赞”或*Google*“+1”按钮)。它们非常受欢迎，因为网站运营商可以在极小的成本、努力和维护下，将高质量的功能添加到他们的网站上，而如果他们自己开发这些功能，成本将会非常高昂.^([[3](#ch04fn03)])
    通常，第三方模块是通过在静态网页中包含一个脚本标签或在SPA中添加一个函数调用来添加到网站上的。如果没有第三方模块，许多网站上的许多功能将无法实现，因为成本将是不切实际的。
- en: ² To learn more about third-party modules and how they’re created, see *Third-Party
    JavaScript* by Ben Vinegar and Anton Kovalyov (Manning, 2012).
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ² 要了解更多关于第三方模块及其创建的信息，请参阅Ben Vinegar和Anton Kovalyov的《第三方JavaScript》（Manning，2012年）。
- en: ³ It’s hard to gauge exactly how popular third-party modules are, but it’s hard
    to find a commercial website without at least one. At the time of this writing,
    for example, we counted at least 16 major third-party modules in use at [TechCrunch.com](http://TechCrunch.com),
    with at least five analytics services alone—and a whopping 53 script tags.
  id: totrans-295
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³很难准确衡量第三方模块的流行程度，但很难找到一个没有至少一个第三方模块的商业网站。例如，在撰写本文时，我们在[TechCrunch.com](http://TechCrunch.com)上发现了至少16个主要第三方模块在使用中，仅分析服务就有至少五个——以及惊人的53个脚本标签。
- en: 'Well-written third-party modules share these common characteristics:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 编写良好的第三方模块具有以下共同特征：
- en: '*They render in their own container*, which may be provided for them, or they
    append to the documents themselves.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*它们在自己的容器中渲染，这可能是由它们提供的，或者它们直接附加到文档上*。'
- en: '*They provide a well-defined API* to control their behaviors.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*它们提供了一个定义良好的API来控制它们的行为*。'
- en: '*They avoid corrupting the host page* by keeping their JavaScript, data, and
    CSS carefully isolated.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*它们通过仔细隔离它们的JavaScript、数据和CSS来避免污染宿主页面*。'
- en: 'Third-party modules have some disadvantages. The primary problem is that the
    “third-party” has its own business goals, which may be at odds with our own. This
    can manifest itself in many ways:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方模块有一些缺点。主要问题是“第三方”有自己的商业目标，这可能与我们的目标相冲突。这可以以许多方式表现出来：
- en: '*We’re dependent on their code and services.* If they fail or go out of business,
    their service can be lost. If they screw up a release, they can even prevent our
    site from working. Sadly, this happens a lot more often than it should.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*我们依赖于它们的代码和服务。* 如果它们失败或停业，它们的服务可能会丢失。如果它们在发布时出错，甚至可能阻止我们的网站工作。遗憾的是，这种情况比应该发生的要频繁得多。'
- en: '*They’re often slower* than custom modules due to server chatter or feature
    bloat. If one third-party module is slow, it may slow down our entire application.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*它们通常比自定义模块慢*，因为服务器嘈杂或功能膨胀。如果一个第三方模块运行缓慢，它可能会减慢我们整个应用程序的速度。'
- en: '*Privacy is a concern* because each third-party module has its own Terms of
    Service, in which their lawyers almost always reserve the right to change at a
    moment’s notice.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*隐私是一个关注点*，因为每个第三方模块都有自己的服务条款，其中他们的律师几乎总是保留在第一时间改变的权利。'
- en: '*Features often don’t integrate seamlessly* due to a mismatch of data, style,
    or lack of flexibility.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于数据、样式不匹配或缺乏灵活性，*功能往往无法无缝集成*。
- en: '*Cross-feature communication* may be difficult or impossible if we can’t integrate
    their third-party data to our SPA.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们不能将它们的第三方数据集成到我们的SPA中，*跨功能通信*可能很困难或不可能。
- en: '*Customization* of the module may be difficult or impossible.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模块的定制*可能很困难或不可能。'
- en: Our feature modules keep the positive characteristics of third-party modules,
    but because there is no third party, we avoid their disadvantages. This means
    that for a given feature, the Shell provides a container that the feature module
    populates and controls, as shown in [figure 4.2](#ch04fig02). The feature module
    provides a consistent API to the Shell for configuration, initialization, and
    use. The feature is kept isolated from other features by using unique and coordinated
    JavaScript and CSS namespaces, and by not allowing any external calls except to
    shared utilities.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的功能模块保留了第三方模块的积极特性，但由于没有第三方，我们避免了它们的缺点。这意味着对于给定的功能，Shell提供了一个容器，功能模块填充并控制它，如图4.2所示。[figure
    4.2](#ch04fig02)。功能模块为Shell提供了一致的API，用于配置、初始化和使用。通过使用独特和协调的JavaScript和CSS命名空间，并且不允许调用任何外部调用（除了共享工具），功能与其他功能保持隔离。
- en: Figure 4.2\. Shell and feature module responsibilities
  id: totrans-308
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.2\. Shell和功能模块的责任
- en: '![](04fig02_alt.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![04fig02_alt.jpg](04fig02_alt.jpg)'
- en: 'Developing feature modules as if they were a third-party module allows us to
    take advantage of the benefits of third-party-style JavaScript:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 将功能模块开发成第三方模块的样子，让我们能够利用第三方风格JavaScript的好处：
- en: '*Teams can be more effective* because developers can distribute responsibility
    based on the module. Let’s face it: if you’re working on a team, the only module
    that isn’t third-party to you is the one for which you’re responsible. Team members
    who aren’t responsible for a module only need to know its API to use it.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*团队可以更有效率*，因为开发者可以根据模块分配责任。让我们面对现实：如果你在一个团队中工作，唯一不是第三方模块的就是你负责的那个模块。不负责模块的团队成员只需要了解它的API就能使用它。'
- en: '*The application tends to perform well* as the modules manage only the portion
    of the application for which they’re responsible, and they’re optimized for our
    use without the bloat of unused or unwanted capabilities.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当模块只管理它们负责的应用程序部分，并且它们针对我们的使用进行了优化，没有未使用或不想要的特性的冗余时，*应用程序往往表现良好*。
- en: '*Code maintenance and reuse is much easier* because modules are kept neatly
    isolated. Many of the more sophisticated jQuery plugins, such as a date picker,
    are effectively third-party applications. Think of how much easier it is to use
    a date picker plugin than it is to write your own.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*代码维护和重用要容易得多*，因为模块被整齐地隔离。许多更复杂的 jQuery 插件，如日期选择器，实际上是第三方应用程序。想想使用日期选择器插件有多容易，而不是自己编写一个。'
- en: 'And, of course, there’s one other, *huge* advantage to developing our feature
    modules like third-party modules: we’re well positioned to use third-party modules
    for non-core features of our web application, and then selectively replace them—as
    time and resources allow—with our own feature modules, which can be better integrated,
    faster, less invasive, or all of the above.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，开发我们的功能模块像第三方模块一样，还有一个其他巨大的优势：我们很好地定位了使用第三方模块来处理我们网络应用的非核心功能，然后根据时间和资源的允许，选择性地用我们自己的功能模块替换它们，这些模块可以更好地集成、更快、更少侵入性，或者以上所有。
- en: 4.1.2\. Feature modules and fractal MVC pattern
  id: totrans-315
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.2\. 功能模块和分形 MVC 模式
- en: Many web developers are familiar with the *Model-View-Controller (MVC)* design
    pattern because it’s presented in many frameworks such as Ruby on Rails, Django
    (Python), Catalyst (Perl), Spring MVC (Java), or MicroMVC (PHP). Because so many
    readers are familiar with this pattern, we’ll explain how our SPA architecture
    relates to it, particularly to the feature modules.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 许多网络开发者熟悉 *模型-视图-控制器 (MVC)* 设计模式，因为它在许多框架中都有介绍，如 Ruby on Rails、Django（Python）、Catalyst（Perl）、Spring
    MVC（Java）或 MicroMVC（PHP）。由于许多读者熟悉这个模式，我们将解释我们的 SPA 架构如何与之相关，特别是与功能模块相关。
- en: 'Let’s recall that MVC is a pattern used to develop an application. Its parts
    include:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下 MVC 是一种用于开发应用程序的模式。它的部分包括：
- en: The *Model*, which provides the data and business rules of the application.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模型*，它提供应用程序的数据和业务规则。'
- en: The *View*, which provides the sensory (usually visual, but also often audio)
    representation of the Model’s data.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*视图*，它提供了模型数据的感官（通常是视觉的，但也很常见的是音频）表示。'
- en: The *Controller*, which converts requests from the user into commands that update
    the Model and/or View of an application.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*控制器*，它将用户的请求转换为更新应用程序的模型和/或视图的命令。'
- en: 'Developers familiar with a web MVC framework should be comfortable with most
    of this chapter. The greatest difference between a traditional web developer’s
    view of an MVC framework and our SPA architecture is as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉网络 MVC 框架的开发者应该对这一章的大部分内容感到舒适。传统网络开发者对 MVC 框架的看法与我们的 SPA 架构之间最大的区别如下：
- en: Our SPA moves as much of the application to the browser as possible.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的 SPA 尽可能地将应用程序移动到浏览器中。
- en: We recognize the MVC pattern is repeated as if in a fractal.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们认识到 MVC 模式就像在分形中一样重复。
- en: A *fractal* is a pattern that displays self-similarity on all levels. A simple
    example is illustrated in [figure 4.3](#ch04fig03), where from a distance we see
    a general pattern, and as we look closer we see the pattern repeating at finer
    levels of detail.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '*分形* 是一种在所有级别上显示自相似性的模式。一个简单的例子在[图 4.3](#ch04fig03) 中展示，从远处看，我们看到一个一般模式，当我们更仔细地看时，我们看到模式在更精细的细节级别上重复。'
- en: Figure 4.3\. Box fractal
  id: totrans-325
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.3\. 箱形分形
- en: '![](04fig03.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![图片](04fig03.jpg)'
- en: Our SPA architecture employs a repeating MVC pattern at multiple levels, so
    we call it *Fractal Model-View-Controller*, or FMVC. This concept isn’t new, and
    developers have been discussing it with the same name for at least a decade. How
    much of the fractal we see is a matter of perspective. When we view our web application
    from a distance, as in [figure 4.4](#ch04fig04), we see a single MVC pattern—the
    Controller handles the URI and user input, interacts with the Model, and provides
    us with a View in the browser.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 SPA 架构在多个级别上采用重复的 MVC 模式，所以我们称之为 *分形模型-视图-控制器*，或 FMVC。这个概念并不新鲜，开发者们至少已经讨论了十年。我们看到的分形有多少是一个视角问题。当我们从远处看我们的网络应用，如[图
    4.4](#ch04fig04) 所示，我们看到一个单独的 MVC 模式——控制器处理 URI 和用户输入，与模型交互，并在浏览器中提供视图。
- en: Figure 4.4\. Our web application from a distance
  id: totrans-328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.4\. 从远处看我们的网络应用
- en: '![](04fig04.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![图片](04fig04.jpg)'
- en: 'When we zoom in a bit, as seen in [figure 4.5](#ch04fig05), we see that the
    web application is split into two parts: the server side, which employs an MVC
    pattern to feed data to the client, and an SPA, which employs MVC to allow the
    user to view and interact with the browser Model. The server’s Model includes
    the data from the database, whereas the View is the presentation of the data that
    gets sent to the browser, and the Controller is the code that orchestrates data
    management and communication with the browser. On the client, the Model includes
    the data that’s been received from the server, the View is the user interface,
    and the Controller is the logic that orchestrates the client data with the interface.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们稍微放大一些，如图[图4.5](#ch04fig05)所示，我们看到Web应用程序被分为两部分：服务器端，它使用MVC模式向客户端提供数据，以及SPA，它使用MVC允许用户查看和与浏览器模型交互。服务器的模型包括数据库中的数据，而视图是发送到浏览器的数据表示，控制器是协调数据管理和与浏览器通信的代码。在客户端，模型包括从服务器接收到的数据，视图是用户界面，控制器是协调客户端数据与界面的逻辑。
- en: Figure 4.5\. Our web application a little closer
  id: totrans-331
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.5\. 我们的Web应用稍微近一点
- en: '![](04fig05_alt.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig05_alt.jpg)'
- en: When we zoom in closer still, as in [figure 4.6](#ch04fig06), we see yet more
    MVC patterns. The server application, for example, employs an MVC pattern to provide
    an HTTP data API. The database that the server application uses employs its own
    MVC pattern. On the client, the client application uses an MVC pattern, yet the
    Shell calls subordinate feature modules, which themselves use MVC patterns.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进一步放大，如图[图4.6](#ch04fig06)所示，我们看到了更多的MVC模式。例如，服务器应用程序使用MVC模式提供HTTP数据API。服务器应用程序使用的数据库也采用自己的MVC模式。在客户端，客户端应用程序使用MVC模式，而Shell调用从属功能模块，这些模块本身也使用MVC模式。
- en: Figure 4.6\. Our web application up close and personal
  id: totrans-334
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.6\. 我们的Web应用近距离观察
- en: '![](04fig06_alt.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig06_alt.jpg)'
- en: Almost all modern websites fit this pattern, even if the developers don’t recognize
    it. For example, once a developer adds a commenting feature from *DisQus* or *LiveFyre*
    to their blog—or virtually any other third-party module—they’re adding another
    MVC pattern.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有现代网站都符合这种模式，即使开发者没有意识到这一点。例如，一旦开发者从*DisQus*或*LiveFyre*添加评论功能到他们的博客——或者几乎任何其他第三方模块——他们就在添加另一个MVC模式。
- en: Our SPA architecture embraces this fractal MVC pattern. In other words, our
    SPA works nearly the same way whether integrating a third-party feature or a feature
    module we write ourselves. [Figure 4.7](#ch04fig07) shows how our Chat module
    will employ its own MVC pattern.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的SPA架构采用了这种分形MVC模式。换句话说，无论整合第三方功能还是我们自己编写的功能模块，我们的SPA工作方式几乎相同。[图4.7](#ch04fig07)显示了我们的聊天模块将如何使用自己的MVC模式。
- en: Figure 4.7\. The MVC pattern as it appears in our Chat feature module
  id: totrans-338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.7\. MVC模式在我们聊天功能模块中的体现
- en: '![](04fig07.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig07.jpg)'
- en: We’ve covered where feature modules fit into our architecture, how they’re similar
    to third-party modules, and how they employ fractal MVC. In the next section,
    we’ll put these concepts to use and create our first feature module.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了功能模块在我们架构中的位置，它们与第三方模块的相似之处，以及它们如何采用分形MVC。在下一节中，我们将应用这些概念并创建我们的第一个功能模块。
- en: 4.2\. Set up feature module files
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2\. 设置功能模块文件
- en: The first SPA feature module we’ll create will be the chat feature module, which
    we’ll refer to as *Chat* for the remainder of the chapter. We chose this feature
    because we already have completed significant work on it in [chapter 3](kindle_split_014.html#ch03),
    and because the conversion helps highlight the defining characteristics of a feature
    module.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的第一个SPA功能模块将是聊天功能模块，我们将在此章节中将其称为 *Chat*。我们选择这个功能是因为我们在[第3章](kindle_split_014.html#ch03)中已经对其进行了大量工作，并且转换有助于突出功能模块的定义特征。
- en: 4.2.1\. Plan the file structure
  id: totrans-343
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.1\. 规划文件结构
- en: 'We recommend you copy the whole directory structure you created in [chapter
    3](kindle_split_014.html#ch03) into a new “chapter_4” directory so we may update
    them there. Let’s review our file structure as we left it in [chapter 3](kindle_split_014.html#ch03)
    as shown in [listing 4.1](#ch04list01):'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您将[第3章](kindle_split_014.html#ch03)中创建的整个目录结构复制到一个新的“chapter_4”目录中，这样我们就可以在那里更新它们。让我们回顾一下我们在[第3章](kindle_split_014.html#ch03)中留下的文件结构，如[列表4.1](#ch04list01)所示：
- en: Listing 4.1\. File structure from [chapter 3](kindle_split_014.html#ch03)
  id: totrans-345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.1\. [第3章](kindle_split_014.html#ch03)中的文件结构
- en: '[PRE15]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here are the changes we wish to make:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们希望做出的更改：
- en: Create a namespaced stylesheet for Chat.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Chat创建一个命名空间样式表。
- en: Create a namespaced JavaScript module for Chat.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 Chat 创建一个命名空间 JavaScript 模块。
- en: Create a stub for the browser Model.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为浏览器模型创建一个占位符。
- en: Create a utility module that provides common routines for use by all other modules.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个为所有其他模块提供常用例程的实用模块。
- en: Modify the *browser document* to include the new files.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改*浏览器文档*以包含新文件。
- en: Delete the file we used to develop the layout.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除我们用来开发布局的文件。
- en: 'When we’re finished, our updated files and directories should look like [listing
    4.2](#ch04list02). All the files we’ll have to create or modify are shown in **bold**:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成时，我们的更新后的文件和目录应该看起来像[列表 4.2](#ch04list02)。所有我们需要创建或修改的文件都显示为**粗体**：
- en: Listing 4.2\. Revised file structure for Chat
  id: totrans-355
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.2\. Chat 的修订版文件结构
- en: '![](101fig01_alt.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![图片](101fig01_alt.jpg)'
- en: Now that we’ve identified the files we want to add or modify, let’s fire up
    our trusty text editor and get the job done. We’re going to consider each file
    exactly in the order we’ve presented it.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经确定了要添加或修改的文件，让我们启动我们信任的文本编辑器并完成工作。我们将按照我们展示的顺序逐一考虑每个文件。
- en: 4.2.2\. Populate the files
  id: totrans-358
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.2\. 填充文件
- en: Our first file to consider is the Chat stylesheet, spa/css/spa.chat.css. We’ll
    create a file and populate it with the contents shown in [listing 4.3](#ch04list03).
    Initially, it will be a *stub*:^([[4](#ch04fn04)])
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要考虑的第一个文件是 Chat 风格表，spa/css/spa.chat.css。我们将创建一个文件，并用[列表 4.3](#ch04list03)中显示的内容填充它。最初，它将是一个*占位符*:^([[4](#ch04fn04)])
- en: ⁴ A *stub* is purposely incomplete or a placeholder resource. For example, in
    [chapter 5](kindle_split_016.html#ch05) we create a “stub” data module that fakes
    communication with the server.
  id: totrans-360
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴ *占位符*是有意不完整或占位符资源。例如，在[第 5 章](kindle_split_016.html#ch05)中，我们创建了一个“占位符”数据模块，它模拟与服务器的通信。
- en: Listing 4.3\. Our stylesheet (stub)—spa/css/spa.chat.css
  id: totrans-361
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.3\. 我们的风格表（占位符）—spa/css/spa.chat.css
- en: '[PRE16]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next let’s create our Chat feature module, spa/js/spa.chat.js, as shown in
    [listing 4.4](#ch04list04), using our module template from [appendix A](kindle_split_022.html#app01).
    This is just the first pass, and we’ll have it fill the chat slider container
    with some trivial HTML:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建我们的 Chat 功能模块，spa/js/spa.chat.js，如[列表 4.4](#ch04list04)所示，使用我们的模块模板[附录
    A](kindle_split_022.html#app01)。这只是一个初步的版本，我们将让它填充聊天滑块容器中的某些简单 HTML：
- en: Listing 4.4\. Our Chat module, with limited capability—spa/js/spa.chat.js
  id: totrans-364
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.4\. 我们的 Chat 模块，功能有限—spa/js/spa.chat.js
- en: '![](ch04list04-0.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch04list04-0.jpg)'
- en: '![](ch04list04-1.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch04list04-1.jpg)'
- en: 'Now let’s create our Model as shown in [listing 4.5](#ch04list05). This is
    also a stub. Like all our modules, the file name (spa.model.js) indicates the
    namespace it provides (`spa.model`):'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的模型，如[列表 4.5](#ch04list05)所示。这同样是一个占位符。像所有我们的模块一样，文件名（spa.model.js）表示它提供的命名空间（`spa.model`）：
- en: Listing 4.5\. Our model (stub)—spa/js/spa.model.js
  id: totrans-368
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.5\. 我们的模型（占位符）—spa/js/spa.model.js
- en: '[PRE17]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let’s create a general utility module so we may share common routines across
    all modules as shown in [listing 4.6](#ch04list06). The `makeError` method can
    be used to easily create error objects. The `setConfigMap` method provides an
    easy and consistent way to change settings for modules. Because these are public
    methods, we detail their use for the benefit of other developers:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个通用实用模块，这样我们就可以在所有模块之间共享常用例程，如[列表 4.6](#ch04list06)所示。`makeError`方法可以用来轻松创建错误对象。`setConfigMap`方法提供了一种简单且一致的方式来更改模块的设置。因为这些是公共方法，我们详细说明它们的使用，以供其他开发者参考：
- en: Listing 4.6\. Common utilities—spa/js/spa.util.js
  id: totrans-371
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.6\. 公共实用工具—spa/js/spa.util.js
- en: '[PRE18]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, we can tie all of these changes together by modifying our browser
    document to load the new JavaScript and CSS files. First we’ll load our stylesheets
    and then our JavaScript. JavaScript library inclusion order *is* important: third-party
    libraries should be loaded first as they’re often a prerequisite, and this practice
    also helps overcome occasional bone-headed third-party namespace snafus (see the
    sidebar “Why our libraries are loaded last”). Our libraries come next, and must
    be ordered by namespace hierarchy—for example, modules that supply the namespaces
    of `spa`, `spa.model`, and `spa.model.user` must be loaded in that order. Any
    ordering beyond that is convention and isn’t a requirement. We like this convention:
    root -> core utilities -> Model -> browser utilities -> Shell -> feature modules.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过修改我们的浏览器文档来加载新的 JavaScript 和 CSS 文件，将这些更改全部结合起来。首先我们将加载我们的样式表，然后是我们的
    JavaScript。JavaScript 库的包含顺序 *确实* 重要：第三方库应该首先加载，因为它们通常是先决条件，这种做法也有助于克服偶尔的第三方命名空间混乱（见侧边栏“为什么我们的库最后加载”）。我们的库接下来，必须按命名空间层次结构排序——例如，提供
    `spa`、`spa.model` 和 `spa.model.user` 命名空间的模块必须按此顺序加载。任何超出此范围的排序都是惯例，并不是必需的。我们喜欢这种惯例：根
    -> 核心工具 -> 模型 -> 浏览器工具 -> Shell -> 功能模块。
- en: '|  |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Why our libraries are loaded last**'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么我们的库最后加载**'
- en: We like our libraries to have final claim on namespaces, and so we load them
    last. If some rogue third-party library claims the `spa.model` namespace, our
    libraries will “take it back” when they load. If this happens, our SPA has a good
    chance to continue functioning, although the third-party feature probably wouldn’t
    work. If the library order were reversed, our SPA would almost certainly be *completely*
    hosed. We’d rather fix a problem with, say, a third-party comments feature than
    explain to the CEO why our website *completely stopped working* at midnight.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们喜欢我们的库对命名空间拥有最终决定权，因此我们最后加载它们。如果某些流氓第三方库声称 `spa.model` 命名空间，我们的库在加载时会“取回”它。如果发生这种情况，我们的单页应用（SPA）有很大机会继续运行，尽管第三方功能可能不会工作。如果库的顺序被颠倒，我们的
    SPA 几乎肯定会被完全破坏。我们宁愿修复第三方评论功能的问题，也不愿向 CEO 解释为什么我们的网站在午夜时分 *完全停止工作*。
- en: '|  |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Let’s update our browser document as shown in [listing 4.7](#ch04list07). Changes
    from [chapter 3](kindle_split_014.html#ch03) are shown in **bold**:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新我们的浏览器文档，如 [列表 4.7](#ch04list07) 所示。从 [第 3 章](kindle_split_014.html#ch03)
    的更改以粗体显示：
- en: Listing 4.7\. Changes to the browser document—spa/spa.html
  id: totrans-379
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.7\. 浏览器文档的更改—spa/spa.html
- en: '![](ch04list07-0.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![](ch04list07-0.jpg)'
- en: '![](ch04list07-1.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![](ch04list07-1.jpg)'
- en: '![](106fig01_alt.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![](106fig01_alt.jpg)'
- en: 'Now let’s have the Shell configure and initialize Chat as shown in [listing
    4.8](#ch04list08). All changes are shown in **bold**:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们按照 [列表 4.8](#ch04list08) 中的说明配置和初始化 Shell。所有更改都以粗体显示：
- en: Listing 4.8\. Shell revision—spa/js/spa.shell.js
  id: totrans-384
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.8\. Shell 修订版—spa/js/spa.shell.js
- en: '[PRE19]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We’re now finished with our first pass. Although this is a fair amount of work,
    many of these steps won’t be needed for future feature modules. Now let’s take
    a look at what we’ve created.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在完成了第一次遍历。尽管这是一项相当多的工作，但其中许多步骤对于未来的功能模块可能不再需要。现在让我们看看我们创造了什么。
- en: 4.2.3\. What we’ve wrought
  id: totrans-387
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.3\. 我们所造成的
- en: When we load our browser document ([spa/spa.html](http://spa/spa.html)), the
    chat slider should look like [figure 4.8](#ch04fig08).
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们加载我们的浏览器文档 ([spa/spa.html](http://spa/spa.html)) 时，聊天滑块应看起来像 [图 4.8](#ch04fig08)。
- en: Figure 4.8\. Our updated browser document—spa/spa.html
  id: totrans-389
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.8\. 我们更新的浏览器文档—spa/spa.html
- en: '![](04fig08_alt.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig08_alt.jpg)'
- en: The `Say` `hello` `to` `chat` text shows that Chat was configured and initiated
    properly and that it has provided the chat slider content. But this presentation
    is far from impressive. In the next section, we’ll significantly improve the chat
    interface.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`Say` `hello` `to` `chat` 文本显示 Chat 已正确配置和启动，并且它已提供了聊天滑块内容。但这次展示远非令人印象深刻。在下一节中，我们将显著改进聊天界面。'
- en: 4.3\. Design method APIs
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3\. 设计方法 API
- en: According to our architecture, the Shell can call any subordinate module in
    the SPA. Feature modules should only call shared utility modules; calls *between*
    feature modules are *not* allowed. The only other source of data or capabilities
    for the feature module should come from the Shell in the form of arguments provided
    to the module’s public methods, like during configuration or initialization. [Figure
    4.9](#ch04fig09) illustrates this layering.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的架构，Shell 可以调用 SPA 中的任何从属模块。功能模块应该只调用共享实用模块；功能模块之间的调用是不允许的。功能模块所需的数据或能力只能来自
    Shell，以模块公共方法提供的参数形式，例如在配置或初始化期间。[图 4.9](#ch04fig09) 展示了这种分层结构。
- en: Figure 4.9\. Feature modules close up—allowable calls
  id: totrans-394
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.9\. 功能模块的近距离视图—允许的调用
- en: '![](04fig09.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig09.jpg)'
- en: This isolation is deliberate as it helps prevent feature-specific flaws from
    propagating to the application level or to other features.^([[5](#ch04fn05)])
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这种隔离是故意的，因为它有助于防止特定功能的缺陷传播到应用层或其他功能。[5](#ch04fn05)
- en: ⁵ Communication between feature modules should always be coordinated by the
    Shell or the Model.
  id: totrans-397
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵ 功能模块之间的通信应始终由 Shell 或模型协调。
- en: 4.3.1\. The anchor interface pattern
  id: totrans-398
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.1\. 锚接口模式
- en: Recall in [chapter 3](kindle_split_014.html#ch03) that we want the URI anchor
    to always drive page state, and not the other way around. Sometimes the execution
    path can seem hard to follow, as the Shell is responsible for the URI anchor management,
    yet Chat is responsible for the slider presentation. We rely on the *anchor interface
    pattern* to support URI anchor *and* user-event-driven states *using the same
    jQuery* `hashchange` *event* in both cases. This single path to change application
    state ensures history-safe URLs,^([[6](#ch04fn06)]) consistent behavior, and helps
    accelerate development because there is only one state change mechanism. The pattern
    is shown in [figure 4.10](#ch04fig10).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下 [第 3 章](kindle_split_014.html#ch03) 中我们希望 URI 锚始终驱动页面状态，而不是相反。有时执行路径可能难以追踪，因为
    Shell 负责URI 锚的管理，而 Chat 负责滑块展示。我们依靠 *锚接口模式* 来支持 URI 锚和用户事件驱动的状态，在两种情况下都使用相同的 jQuery
    `hashchange` 事件。这种单一的应用程序状态更改路径确保了历史安全 URL、一致的行为，并有助于加速开发，因为只有一个状态更改机制。该模式在 [图
    4.10](#ch04fig10) 中展示。
- en: ⁶ “History-safe” means the browser history controls, like the Forward, Back,
    bookmarks, and browser history, all work as the user expects.
  id: totrans-400
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶ “历史安全”意味着浏览器历史控制，如前进、后退、书签和浏览器历史，都按用户期望的方式工作。
- en: Figure 4.10\. The anchor interface pattern for Chat
  id: totrans-401
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.10\. Chat 的锚接口模式
- en: '![](04fig10_alt.jpg)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig10_alt.jpg)'
- en: We already implemented much of the behavior of Chat in the last chapter. Now
    let’s move the remaining chat code to its own module. Let’s also specify the APIs
    that both Chat and the Shell will use to communicate. This will benefit us immediately
    and also make code reuse much simpler. The API specifications need to detail which
    resources are required and which capabilities will be provided. They should be
    considered “living documents” and be updated whenever an API is changed.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一章中实现了 Chat 的许多行为。现在，让我们将剩余的聊天代码移动到它自己的模块中。同时，我们也要指定 Chat 和 Shell 将用于通信的
    API。这将立即为我们带来好处，并使代码重用变得更加简单。API 规范需要详细说明所需的资源以及将提供的功能。它们应被视为“活文档”，并在 API 发生更改时进行更新。
- en: One common public method that we want Chat to provide is `configModule`, which
    we’ll use to change settings prior to initialization. Chat, like every feature
    module, should usually have an initialization method, `initModule`, that we’ll
    then use to direct the module to offer its capability to the user. We also want
    Chat to provide a `setSliderPosition` method so the Shell may request a slider
    position. We’ll design the APIs for these methods in the following sections.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望 Chat 提供的一个常见公共方法是 `configModule`，我们将使用它来在初始化之前更改设置。Chat，像每个功能模块一样，通常应该有一个初始化方法
    `initModule`，然后我们将使用它来指导模块向用户提供其功能。我们还想让 Chat 提供一个 `setSliderPosition` 方法，以便 Shell
    可以请求滑块位置。我们将在以下部分设计这些方法的 API。
- en: 4.3.2\. Chat configuration APIs
  id: totrans-405
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.2\. Chat 配置 API
- en: 'When we *configure* a module, we adjust settings that we don’t expect to change
    during a user session. With Chat the following settings fit that criteria:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们 *配置* 一个模块时，我们调整那些我们希望在用户会话期间不会改变的设置。使用 Chat，以下设置符合这一标准：
- en: A function that provides the capability to adjust the `chat` URI anchor parameter.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个提供调整 `chat` URI 锚参数能力的函数。
- en: An object that provides methods for sending and receiving messages (from the
    Model).
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供发送和接收消息方法的对象（来自模型）。
- en: An object that provides methods to interact with a list of users (from the Model).
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供与用户列表交互方法的对象（来自模型）。
- en: Any number of behavior settings such as slider opened height, slider open time,
    and slider close time.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何数量的行为设置，如滑块打开高度、滑块打开时间和滑块关闭时间。
- en: '|  |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**The dirt on JavaScript arguments**'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript参数的真相**'
- en: Remember that only simple values—strings, numbers, and booleans—are passed directly
    to functions. All complex data types in JavaScript (like objects, arrays, and
    functions) are *passed by reference*. This means they are *never* copied as they
    can be in some other languages. Instead, a memory location value is passed. This
    is usually much faster than copying, but the downside is that it’s easy to accidentally
    change an object or array that has been passed in by reference.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，只有简单的值——字符串、数字和布尔值——是直接传递给函数的。JavaScript中的所有复杂数据类型（如对象、数组和函数）都是*按引用传递的*。这意味着它们*永远不会*像某些其他语言中那样被复制。相反，传递一个内存位置值。这通常比复制要快得多，但缺点是很容易意外更改通过引用传递的对象或数组。
- en: When a function expects a reference to a function as an argument, the reference
    is commonly called a *callback*. Callbacks are powerful, but they can become difficult
    to manage. We show how one can reduce the use of callbacks in [chapters 5](kindle_split_016.html#ch05)
    and [6](kindle_split_017.html#ch06) by using jQuery global custom events instead.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数期望一个函数引用作为参数时，这个引用通常被称为*回调*。回调功能强大，但它们可能变得难以管理。我们通过使用jQuery全局自定义事件在[第5章](kindle_split_016.html#ch05)和[第6章](kindle_split_017.html#ch06)中展示了如何减少回调的使用。
- en: '|  |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Based on these expectations, we can devise the Chat `configModule` API specification
    shown in [listing 4.9](#ch04list09). This documentation isn’t used by JavaScript:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些预期，我们可以制定Chat `configModule` API规范，如[列表4.9](#ch04list09)所示。此文档不用于JavaScript：
- en: Listing 4.9\. Chat API specification for configModule—spa/js/spa.chat.js
  id: totrans-417
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.9\. Chat API规范——spa/js/spa.chat.js
- en: '[PRE20]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now that we have an API for our Chat configuration, let’s work on a specification
    for the `setChatAnchor` callback in the Shell. [Listing 4.10](#ch04list10) is
    a good start. This documentation isn’t used by JavaScript:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了Chat配置的API，让我们为Shell中的`setChatAnchor`回调制定一个规范。[列表4.10](#ch04list10)是一个很好的起点。此文档不用于JavaScript：
- en: Listing 4.10\. Shell API specification for `setChatAnchor` callback—spa/js/spa.shell.js
  id: totrans-420
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.10\. Shell API规范——`setChatAnchor`回调——spa/js/spa.shell.js
- en: '[PRE21]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that we’ve completed designing the Chat configuration API and the Shell
    callback API, let’s move on to Chat initialization.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了Chat配置API和Shell回调API的设计，让我们继续到Chat初始化。
- en: 4.3.3\. The Chat initialization API
  id: totrans-423
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.3\. Chat初始化API
- en: 'When we *initialize* one of our feature modules, we ask it to render HTML and
    begin offering its capabilities to the user. Unlike configuration, we expect that
    a feature module may be initialized many times during a user session. In the case
    of Chat, we want to send a single jQuery collection as the argument. The jQuery
    collection will contain one element—the one to which we want to append the chat
    slider. Let’s sketch the API as shown in [listing 4.11](#ch04list11). This documentation
    isn’t used by JavaScript:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们*初始化*我们的功能模块之一时，我们要求它渲染HTML并开始向用户提供其功能。与配置不同，我们预计功能模块在用户会话期间可能会被初始化多次。在Chat的情况下，我们希望发送一个jQuery集合作为参数。jQuery集合将包含一个元素——我们想要附加聊天滑块的元素。让我们绘制如[列表4.11](#ch04list11)所示的API。此文档不用于JavaScript：
- en: Listing 4.11\. Chat API specification for initModule—spa/js/spa.chat.js
  id: totrans-425
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.11\. Chat API规范——spa/js/spa.chat.js
- en: '[PRE22]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The last API we’ll specify in this chapter will be for the Chat `setSliderPosition`
    method. This will be used to open and close the chat slider. We’ll work on this
    in the next section.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将指定的最后一个API将是Chat `setSliderPosition`方法。这将用于打开和关闭聊天滑块。我们将在下一节中处理这个问题。
- en: 4.3.4\. The Chat setSliderPosition API
  id: totrans-428
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.4\. Chat setSliderPosition API
- en: 'We’ve decided to have Chat provide a public method, `setSliderPosition`, that
    will enable the Shell to request a slider position. Our decision to tie the slider
    position into the URI anchor raises some interesting issues we need to address:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定让Chat提供公共方法`setSliderPosition`，这将使Shell能够请求滑块位置。我们将滑块位置与URI锚点关联的决定引发了一些我们需要解决的问题：
- en: Chat may not always be able to adjust the slider to the requested position.
    For example, it may decide that the slider can’t be opened because the user isn’t
    signed in. We’ll have `setSliderPosition` return `true` or `false` so the Shell
    will know if the request succeeded.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聊天可能无法总是调整滑块到请求的位置。例如，它可能决定滑块不能打开，因为用户未登录。我们将`setSliderPosition`返回`true`或`false`，这样Shell就会知道请求是否成功。
- en: If the Shell invokes a `setSliderPosition` callback, and the callback can’t
    honor the request (in other words, it returns `false`), the Shell will need to
    revert the URI anchor `chat` parameter to the value prior to the request.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果Shell调用`setSliderPosition`回调，并且回调无法满足请求（换句话说，它返回`false`），Shell需要将URI锚点`chat`参数重置为请求之前的值。
- en: 'Let’s specify an API, as shown in [listing 4.12](#ch04list12), that meets these
    requirements. This documentation isn’t used by JavaScript:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们指定一个符合这些要求的API，如[列表4.12](#ch04list12)所示。这份文档不用于JavaScript：
- en: Listing 4.12\. Chat API specification for `setSliderPosition`—spa/js/spa.chat.js
  id: totrans-433
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.12\. `setSliderPosition`的聊天API规范——spa/js/spa.chat.js
- en: '[PRE23]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With this API defined, we’re almost ready to write some code. But before we
    do, let’s look at how configuration and initialization will cascade through our
    application.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了这个API之后，我们几乎准备好编写一些代码了。但在我们这样做之前，让我们看看配置和初始化是如何通过我们的应用程序级联的。
- en: 4.3.5\. Configuration and initialization cascade
  id: totrans-436
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.5\. 配置和初始化级联
- en: Our configuration and initialization follow a common pattern. First, a script
    tag in our browser document configures and initializes our *root namespace* module,
    `spa.js`. Then our root module then configures and initializes the Shell module,
    `spa.shell.js`. The Shell module then configures and initializes our feature module,
    `spa.chat.js`. This cascade of configuration and initialization is shown in [figure
    4.11](#ch04fig11).
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的配置和初始化遵循一个常见的模式。首先，我们浏览器文档中的一个脚本标签配置和初始化我们的根命名空间模块`spa.js`。然后我们的根模块配置和初始化Shell模块`spa.shell.js`。然后Shell模块配置和初始化我们的功能模块`spa.chat.js`。这种配置和初始化的级联在[图4.11](#ch04fig11)中显示。
- en: Figure 4.11\. Configuration and initialization cascade
  id: totrans-438
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.11\. 配置和初始化级联
- en: '![](04fig11_alt.jpg)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
  zh: '![04fig11_alt.jpg]'
- en: All of our modules provide a public `initModule` method. We provide a `config-Module`
    method only if we need to support settings. At this stage of development, only
    Chat can be configured.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的所有模块都提供了一个公共的`initModule`方法。我们只提供`config-Module`方法，如果我们需要支持设置。在开发这个阶段，只有聊天可以配置。
- en: 'When we load the browser document ([spa/spa.html](http://spa/spa.html)), it
    loads all our CSS and JavaScript files. Next a script in the page does the initial
    housekeeping and initializes the root namespace module (spa/js/spa.js), presenting
    it a page element (the `spa div)` for it to use:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们加载浏览器文档([spa/spa.html](http://spa/spa.html))时，它会加载我们所有的CSS和JavaScript文件。接下来页面中的一个脚本执行初始维护并初始化根命名空间模块（spa/js/spa.js），向它提供一个页面元素（`spa
    div`）供其使用：
- en: '[PRE24]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When initialized, the root namespace module (spa/js/spa.js) does any root-level
    housekeeping, then configures and initializes the Shell (spa/js/spa.shell.js),
    providing it with a page element (`$container`) for it to use:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 当初始化时，根命名空间模块（spa/js/spa.js）执行任何根级别的维护工作，然后配置和初始化Shell（spa/js/spa.shell.js），为它提供一个页面元素（`$container`）供其使用：
- en: '[PRE25]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The Shell (spa/js/spa.shell.js) then does any Shell-level housekeeping and
    configures and initializes all its feature modules, like Chat (spa/js/spa.chat.js),
    providing it with a page element (`jqueryMap.$chat`) for it to use:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: Shell（spa/js/spa.shell.js）随后执行任何Shell级别的维护工作，并配置和初始化所有其功能模块，例如聊天（spa/js/spa.chat.js），为它提供一个页面元素（`jqueryMap.$chat`）供其使用：
- en: '[PRE26]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It’s important that we’re comfortable with this cascade because it’s the same
    for all feature modules. We may, for example, wish to split some function of Chat
    (spa/js/ spa.chat.js) into a subordinate module that handles the online user list—we’ll
    call it the Roster—and create its file at spa/js/spa.chat.roster.js. We’d then
    have Chat use the `spa.chat.roster.configModule` method to configure the module,
    and the `spa.chat.roster.initModule` method to initialize it. Chat would also
    provide a jQuery container to the Roster, where it would show the list of users.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对这个级联感到舒适，因为所有功能模块都是一样的。例如，我们可能希望将聊天（spa/js/spa.chat.js）的一些功能拆分到一个从属模块中，该模块处理在线用户列表——我们将它称为名单——并在spa/js/spa.chat.roster.js中创建其文件。然后我们将让聊天使用`spa.chat.roster.configModule`方法配置该模块，并使用`spa.chat.roster.initModule`方法初始化它。聊天还会向名单提供一个jQuery容器，名单将在其中显示用户列表。
- en: Now that we have reviewed the cascade of configuration and initialization, we’re
    ready to update our application to the APIs we’ve designed. We’re going to make
    some changes that will break things for a bit, so if you’re playing along at home
    don’t panic—we’ll get things fixed soon enough.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了配置和初始化的级联过程，我们准备将我们的应用程序更新到我们设计的API。我们将进行一些改动，这可能会暂时破坏一些功能，所以如果你在家中进行操作，请不要慌张——我们很快就会修复这些问题。
- en: 4.4\. Implement the feature API
  id: totrans-449
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4\. 实现功能API
- en: 'Our primary goal in this section is to implement the API we’ve defined. And,
    because we’ll have the “code up on blocks” as they say, we’d like to take care
    of a few secondary objectives as well:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的主要目标是实现我们定义的API。而且，正如他们所说，“代码已经准备好”，我们还想处理一些次要目标：
- en: Complete moving Chat configuration and implementation to its own module. The
    only aspect of Chat that the Shell should have to worry about is the URI anchor
    management.
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成将Chat配置和实现移动到其自己的模块。Shell唯一需要担心的是Chat的URI锚管理。
- en: Update the chat feature to look more, well, *chatty*.
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新聊天功能，使其看起来更“健谈”。
- en: The files we’ll need to update and a summary of how they’ll need to change are
    presented in [listing 4.13](#ch04list13).
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更新的文件以及它们需要如何更改的总结在[列表4.13](#ch04list13)中展示。
- en: Listing 4.13\. Files we’ll be changing during our API implementation
  id: totrans-454
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.13\. 我们在API实现过程中将更改的文件
- en: '[PRE27]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We’ll modify these files in exactly the order presented.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照展示的顺序修改这些文件。
- en: 4.4.1\. The stylesheets
  id: totrans-457
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.1\. 样式表
- en: We want to move all our Chat styles to their own stylesheet (spa/css/spa.chat.css)
    and improve our layout as we do so. Our local CSS layout specialist has provided
    a nice plan, as shown in [figure 4.12](#ch04fig12).
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将所有Chat样式移动到它们自己的样式表（spa/css/spa.chat.css）中，并在这样做的同时改进我们的布局。我们的本地CSS布局专家提供了一个很好的计划，如图4.12所示。
- en: Figure 4.12\. 3D view of elements and selectors—spa/css/spa.chat.css
  id: totrans-459
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.12\. 元素和选择器的3D视图—spa/css/spa.chat.css
- en: '![](04fig12_alt.jpg)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
  zh: '![图片](04fig12_alt.jpg)'
- en: 'Note how we namespaced our CSS as we did with our JavaScript. This has numerous
    advantages:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何像处理JavaScript一样命名空间我们的CSS。这有诸多优点：
- en: 'We don’t need to worry about collisions with our other modules because we’re
    guaranteeing a unique prefix for all class names: `spa-chat`.'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不需要担心与其他模块发生冲突，因为我们保证所有类名都有一个唯一的前缀：`spa-chat`。
- en: Collisions with third-party packages are almost always avoided. And even if
    by some odd chance they aren’t, the fix (changing a prefix) is trivial.
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与第三方包的冲突几乎总是可以避免。即使有些奇怪的情况它们没有避免，修复（更改前缀）也是微不足道的。
- en: It helps debugging a great deal, because when we inspect an element controlled
    by Chat, its class name points us to the originating feature module, `spa.chat`.
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这对调试非常有帮助，因为当我们检查由Chat控制的元素时，其类名会指引我们到原始的功能模块，`spa.chat`。
- en: The names indicate what contains (and therefore controls) what. For example,
    note how `spa-chat-head-toggle` is contained within `spa-chat-head`, which is
    contained within `spa-chat`.
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称表明了什么包含（因此控制）什么。例如，注意`spa-chat-head-toggle`包含在`spa-chat-head`中，而`spa-chat-head`又包含在`spa-chat`中。
- en: Most of this styling is boilerplate stuff (sorry, CSS-layout-specialist-guy).
    But we have a few points that will make our work special. First, the `spa-chat-sizer`
    element needs to have a fixed height. This will provide room for the chat and
    message areas even when the slider retracts. If this element isn’t included, the
    slider contents get “scrunched” when the slider is retracted, and this is at best
    confusing to the user. Second, our layout guy wants us to remove all references
    to absolute pixels in favor of relative measurements such as `em`s and percentages.
    This will enable our SPA to present equally well on low-density and high-density
    displays.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分样式大多是样板代码（抱歉，CSS布局专家）。但我们有几个点会使我们的工作变得特别。首先，`spa-chat-sizer`元素需要有一个固定的高度。这将即使在滑块缩回时也为聊天和消息区域提供空间。如果没有这个元素，当滑块缩回时，滑块内容会被“挤压”，这对用户来说至多也是令人困惑的。其次，我们的布局专家希望我们移除所有对绝对像素的引用，转而使用相对测量，如`em`和百分比。这将使我们的SPA在低密度和高密度显示上都能同样良好地展示。
- en: '|  |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Pixels versus relative units**'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '**像素与相对单位**'
- en: 'HTML gurus often go through serious contortions to use relative measurements
    when developing CSS, eschewing the use of *px* units altogether so that their
    creation can work well on any size display. We’ve observed a phenomenon that’s
    making us reconsider the value of such an effort: browsers lie about their pixel
    dimensions.'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: HTML专家在开发CSS时经常采取严肃的扭曲来使用相对度量，完全避免使用*px*单位，以便他们的创作可以在任何尺寸的显示上良好工作。我们已经观察到一种现象，这让我们重新考虑了这种努力的价值：浏览器对其像素维度撒谎。
- en: Consider the latest ultra-high resolution displays on laptops, tablets, and
    smart-phones. The browsers on these devices don’t correlate *px* in the browser
    directly with the physical screen pixels available. Instead, they normalize the
    *px* unit so the viewing experience approximates a traditional desktop monitor
    with a pixel density somewhere between 96 and 120 pixels per inch.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑最新的超高清分辨率笔记本电脑、平板电脑和智能手机的显示器。这些设备上的浏览器不会直接将浏览器中的*px*与物理屏幕像素相关联。相反，它们将*px*单位标准化，以便观看体验近似于具有每英寸96到120像素密度的传统桌面显示器。
- en: The result is that a *10 px* square box rendered on a smart phone browser may
    actually be 15 or 20 physical pixels on each side. This means *px* has become
    a relative unit as well, and compared to all the other units (*%, in, cm, mm,
    em, ex, pt, pc*) it’s often more reliable. We have, among other devices, a 10.1-inch
    and 7-inch tablet with the exact same resolution of 1280 by 800 and the same OS.
    A *400 px* square box fits onto the 10.1-inch tablet screen; it doesn’t on the
    7-inch tablet though. Why? Because the amount of physical pixels used per *px*
    is higher on the smaller tablet. It appears the scaling is 1.5 pixels per *px*
    for the larger tablet, and 2 pixels per *px* for the smaller tablet.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，在智能手机浏览器上渲染的*10 px*正方形框实际上每边可能有15或20个物理像素。这意味着*px*也已成为一个相对单位，与其他所有单位（*%，in，cm，mm，em，ex，pt，pc*）相比，它通常更可靠。我们拥有其他设备，例如10.1英寸和7英寸的平板电脑，它们具有相同的1280
    x 800分辨率和相同的操作系统。一个*400 px*的正方形框可以适应10.1英寸的平板电脑屏幕；但在7英寸的平板电脑上则不行。为什么？因为每个*px*使用的物理像素数量在较小的平板电脑上更高。看起来较大平板电脑的缩放比例是每*px*
    1.5像素，而较小平板电脑是每*px* 2像素。
- en: We don’t know what the future holds, but we’ve recently felt a lot less guilty
    when using the *px* unit.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不知道未来会怎样，但最近我们在使用*px*单位时感到的罪恶感少了很多。
- en: '|  |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'With all that planning behind us, we can now add the CSS that meets the specifications
    into spa.chat.css, as shown in [listing 4.14](#ch04list14):'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些计划之后，我们现在可以将符合规格的CSS添加到spa.chat.css中，如[列表4.14](#ch04list14)所示：
- en: Listing 4.14\. Adding enhanced Chat styles—spa/css/spa.chat.css
  id: totrans-475
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.14\. 添加增强的Chat样式—spa/css/spa.chat.css
- en: '![](ch04list14-0.jpg)'
  id: totrans-476
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch04list14-0.jpg)'
- en: '![](ch04list14-1.jpg)'
  id: totrans-477
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch04list14-1.jpg)'
- en: 'Now that we have the stylesheet for Chat, we can remove prior definitions in
    the Shell’s stylesheet at spa/css/spa.shell.css. First, let’s remove `.spa-shell-chat`
    from the list of absolute position selectors. The change should look like the
    following (we can omit the comment):'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了Chat的样式表，我们可以从spa/css/spa.shell.css中的Shell样式表中移除之前的定义。首先，让我们从绝对定位选择器的列表中移除`.spa-shell-chat`。更改应如下所示（我们可以省略注释）：
- en: '[PRE28]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We also want to remove any .`spa-shell-chat` classes in spa/css/spa.shell.css.
    There are two to delete, as the following shows:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望从spa/css/spa.shell.css中移除任何`.spa-shell-chat`类。如下所示，有两个要删除：
- en: '[PRE29]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, let’s hide the modal container so it doesn’t get in the way of our
    chat slider:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们隐藏模态容器，以免它妨碍我们的聊天滑块：
- en: '[PRE30]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: At this point, we should be able to open our browser document ([spa/spa.html](http://spa/spa.html))
    and not see any errors in the Chrome Developer Tools JavaScript console. But the
    chat slider will no longer be visible. Stay calm and carry on—we’ll fix this when
    we finish modifying Chat in the next section.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应该能够打开我们的浏览器文档([spa/spa.html](http://spa/spa.html))，在Chrome开发者工具的JavaScript控制台中看不到任何错误。但聊天滑块将不再可见。保持冷静，继续前进——我们将在下一节完成修改Chat时修复这个问题。
- en: 4.4.2\. Modify Chat
  id: totrans-485
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.2\. 修改Chat
- en: 'We’ll now modify Chat to implement the APIs we designed earlier. Here are the
    changes we have planned:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将修改Chat以实现我们之前设计的API。以下是我们的计划更改：
- en: Add the HTML for our more detailed chat slider.
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加我们更详细的聊天滑块的HTML。
- en: Expand the configuration to include settings like slider height and retract
    time.
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将配置扩展以包括滑块高度和缩回时间等设置。
- en: Create the `getEmSize` utility that converts `em` units to `px` (pixels).
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建将`em`单位转换为`px`（像素）的`getEmSize`实用工具。
- en: Update `setJqueryMap` to cache many of the new elements of the updated chat
    slider.
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新`setJqueryMap`以缓存更新聊天滑块的许多新元素。
- en: Add the `setPxSizes` method that sets the slider dimensions using pixel units.
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加`setPxSizes`方法，使用像素单位设置滑块尺寸。
- en: Implement the `setSliderPosition` public method to match our API.
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现与我们的API匹配的`setSliderPosition`公共方法。
- en: Create the `onClickToggle` event handler to change the URI anchor and promptly
    return.
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`onClickToggle`事件处理器以更改URI锚点并立即返回。
- en: Update the `configModule` public method documentation to match our API.
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新`configModule`公共方法文档以匹配我们的API。
- en: Update the `initModule` public method to match our API.
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新`initModule`公共方法以匹配我们的API。
- en: 'Let’s update Chat to implement these changes as shown in [listing 4.15](#ch04list15).
    The API specifications we designed earlier were copied into this file and used
    as a guideline during implementation. This accelerated development *and* ensured
    accurate documentation for future maintenance. All changes are shown in **bold**:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新Chat以实现这些更改，如[列表4.15](#ch04list15)所示。我们之前设计的API规范已复制到该文件中，并在实现过程中用作指南。这加速了开发并确保了未来维护的准确文档。所有更改均以**粗体**显示：
- en: Listing 4.15\. Modify Chat to meet API specifications—spa/js/spa.chat.js
  id: totrans-497
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.15\. 修改Chat以符合API规范—spa/js/spa.chat.js
- en: '![](ch04list15-0.jpg)'
  id: totrans-498
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch04list15-0.jpg)'
- en: '![](ch04list15-1.jpg)'
  id: totrans-499
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch04list15-1.jpg)'
- en: At this point we should be able to load our browser document ([spa/spa.html](http://spa/spa.html))
    and not see any errors in the Chrome Developer Tools JavaScript console. We should
    see the top portion of the chat slider. But if we click on it we should see an
    error message like “`set_chat_anchor` *is not a function*” in the console. We’ll
    fix that next when we clean up the Shell.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应该能够加载浏览器文档([spa/spa.html](http://spa/spa.html))，并且在Chrome开发者工具的JavaScript控制台中不会看到任何错误。我们应该看到聊天滑块的上部。但如果我们点击它，我们应该在控制台中看到类似于“`set_chat_anchor`
    *不是函数*”的错误消息。我们将在清理Shell时修复这个问题。
- en: 4.4.3\. Clean up the Shell
  id: totrans-501
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.3\. 清理Shell
- en: 'We’ll now finish our changes with an update to the Shell. Here’s what we want
    to do:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过更新Shell来完成我们的更改。这是我们想要做的事情：
- en: Remove most chat slider settings and capabilities, as these have been moved
    to Chat.
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除大多数聊天滑块设置和功能，因为这些已移动到Chat。
- en: Revise the `onHashchange` event handler to fall back to a valid position if
    it can’t set a requested slider position.
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改`onHashchange`事件处理器，如果无法设置请求的滑块位置，则回退到有效位置。
- en: Add the `setChatAnchor` method to meet the API we designed earlier.
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加`setChatAnchor`方法以满足我们之前设计的API。
- en: Improve the `initModule` documentation.
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改善`initModule`文档。
- en: Update `initModule` to configure Chat using the API we designed earlier.
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`initModule`更新为使用我们之前设计的API配置Chat。
- en: 'Let’s modify the Shell as shown in [listing 4.16](#ch04list16). Note how any
    new API specifications we developed earlier were placed directly in this file
    and used as a guideline during implementation. All changes are shown in **bold**:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照[列表4.16](#ch04list16)所示修改Shell。注意，我们之前开发的所有新API规范都直接放置在这个文件中，并在实现过程中用作指南。所有更改均以**粗体**显示：
- en: Listing 4.16\. Clean up the Shell—spa/js/spa.shell.js
  id: totrans-509
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.16\. 清理Shell—spa/js/spa.shell.js
- en: '![](ch04list16-0.jpg)'
  id: totrans-510
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch04list16-0.jpg)'
- en: '![](ch04list16-1.jpg)'
  id: totrans-511
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch04list16-1.jpg)'
- en: When we open the browser document ([spa/spa.html](http://spa/spa.html)) we should
    now see something similar to [figure 4.13](#ch04fig13). We think this revised
    chat slider is significantly more dashing. It doesn’t display messages yet—we’ll
    get to that capability in [chapter 6](kindle_split_017.html#ch06).
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打开浏览器文档([spa/spa.html](http://spa/spa.html))时，我们现在应该看到类似于[图4.13](#ch04fig13)的内容。我们认为这个修订后的聊天滑块显著更炫酷。它还没有显示消息——我们将在[第6章](kindle_split_017.html#ch06)中介绍这一功能。
- en: Figure 4.13\. Our more dashing Chat slider
  id: totrans-513
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.13\. 我们更炫酷的Chat滑块
- en: '![](04fig13.jpg)'
  id: totrans-514
  prefs: []
  type: TYPE_IMG
  zh: '![图片](04fig13.jpg)'
- en: Now that the code is working nicely, let’s analyze some key revisions by walking
    through the execution of our application.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码运行良好，让我们通过分析应用程序的执行过程来查看一些关键修订。
- en: 4.4.4\. Walk through the execution
  id: totrans-516
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.4\. 执行过程
- en: This section highlights the revisions we made to our application in the last
    section. We look at how the application is configured and initialized, and then
    explore what happens when a user clicks on the chat slider.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 本节突出了我们在上一节中对应用程序所做的修订。我们查看应用程序的配置和初始化方式，然后探索当用户点击聊天滑块时会发生什么。
- en: 'When we load our browser document ([spa/spa.html](http://spa/spa.html)), a
    script initializes our root namespace (spa/js/spa.js), presenting it with a page
    element (the `#spa` `div`) for it to use:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们加载浏览器文档([spa/spa.html](http://spa/spa.html))时，一个脚本初始化我们的根命名空间(spa/js/spa.js)，向它提供一个页面元素（`#spa`
    `div`）供其使用：
- en: '[PRE31]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The root namespace module (spa/js/spa.js) then initializes the Shell (spa/js/
    spa.shell.js), presenting it with a page element (`$container`) for it to use:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 根命名空间模块（spa/js/spa.js）随后初始化 Shell（spa/js/spa.shell.js），向它提供一个页面元素（`$container`）供其使用：
- en: '[PRE32]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The Shell (spa/js/spa.shell.js) then configures and initializes Chat (spa/js/
    spa.chat.js). But this time both steps are a bit different. The configuration
    now matches the API we defined earlier. The `set_chat_anchor` configuration is
    the callback that follows the specification we created earlier:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: Shell（spa/js/spa.shell.js）随后配置并初始化 Chat（spa/js/spa.chat.js）。但这次这两个步骤都有点不同。配置现在与之前定义的
    API 匹配。`set_chat_anchor` 配置是遵循我们之前创建的规范的回调：
- en: '[PRE33]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Chat initialization is also subtly different: instead of providing a container
    to use, the Shell now provides a container to which Chat will *append* a chat
    slider. This is a good arrangement if you trust the module author. And we do.'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: Chat 初始化也有细微的不同：Shell 现在提供的是一个容器，Chat 将会将其聊天滑块 *附加* 到这个容器上。如果你信任模块作者，这是一个很好的安排。我们确实信任他们。
- en: '[PRE34]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When the user clicks on the slider toggle button, Chat uses the `set_chat_anchor`
    callback to request that the URI anchor `chat` parameter be changed to *opened*
    or *closed*, and then returns. The Shell still handles `hashchange` events, as
    we see in spa/js/ spa.shell.js:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击滑块切换按钮时，Chat 使用 `set_chat_anchor` 回调请求将 URI 锚点的 `chat` 参数更改为 *打开* 或 *关闭*，然后返回。Shell
    仍然处理 `hashchange` 事件，如我们在 spa/js/spa.shell.js 中看到的：
- en: '[PRE35]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'So when the user clicks on the slider, the `hashchange` event is caught by
    the Shell, which dispatches to the `onHashchange` event handler. If the chat component
    of the URI anchor has changed, this routine calls `spa.chat.setSliderPosition`
    to request the new position:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当用户点击滑块时，`hashchange` 事件被 Shell 捕获，它将调度到 `onHashchange` 事件处理器。如果 URI 锚点的聊天组件已更改，此例程将调用
    `spa.chat.setSliderPosition` 请求新的位置：
- en: '[PRE36]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If the position is valid, the slider moves to the requested position and the
    URI anchor `chat` parameter is changed.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 如果位置有效，滑块将移动到请求的位置，并将 URI 锚点的 `chat` 参数更改为。
- en: The changes we’ve made result in an implementation that meets our design goals.
    The URI controls the chat slider state, and we’ve also moved all Chat UI logic
    and code to our new feature module. The slider also looks and works better. Now
    let’s add some other public methods that are commonly found in many feature models.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的更改导致了一个符合我们设计目标实现。URI 控制聊天滑块状态，我们还把所有 Chat UI 逻辑和代码移动到了我们的新功能模块中。滑块看起来和运行得都更好。现在让我们添加一些在许多功能模块中常见的其他公共方法。
- en: 4.5\. Add frequently needed methods
  id: totrans-532
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5. 添加常用方法
- en: 'A few public methods are needed frequently enough in feature modules that they’re
    worth discussing in their own right. The first is a reset method (`removeSlider`);
    the second is a window resize method (`handleResize`). We’re going to implement
    both. First, let’s declare these method names in Chat at the bottom of the Module
    Scope Variables section, and also export them as public methods at the end of
    the module, as shown in [listing 4.17](#ch04list17). Changes are shown in **bold**:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 在功能模块中，一些公共方法被频繁使用，因此它们值得单独讨论。第一个是一个重置方法（`removeSlider`）；第二个是一个窗口调整大小方法（`handleResize`）。我们将实现这两个方法。首先，让我们在模块作用域变量部分的底部在
    Chat 中声明这些方法名称，并在模块末尾将它们作为公共方法导出，如[列表 4.17](#ch04list17)所示。变化以粗体显示：
- en: Listing 4.17\. Declare method function names—spa/js/spa.chat.js
  id: totrans-534
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.17. 声明方法函数名称——spa/js/spa.chat.js
- en: '[PRE37]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now with the method names declared, we’ll implement them in the following sections,
    starting with the remove method.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 现在方法名称已声明，我们将在以下部分实现它们，从移除方法开始。
- en: 4.5.1\. The removeSlider method
  id: totrans-537
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.5.1. 移除滑块方法
- en: We find that we want a `remove` method for many of our feature modules. If we
    implement authentication, for example, we may want to completely remove the chat
    slider when a user signs out. Usually, this sort of action is taken either to
    improve performance or enhance security—assuming the `remove` method does a good
    job of deleting obsolete data structures.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现我们想要为许多功能模块实现一个 `remove` 方法。例如，如果我们实现身份验证，我们可能希望在用户登出时完全移除聊天滑块。通常，这种动作是为了提高性能或增强安全性——假设
    `remove` 方法能够很好地删除过时的数据结构。
- en: 'Our method will need to delete the DOM container that Chat has appended and
    otherwise *unwind* our initialization and configuration, in that order. [Listing
    4.18](#ch04list18) contains the code changes for the `removeSlider` method. Changes
    are shown in **bold**:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法需要删除 Chat 添加的 DOM 容器，并按照顺序*撤销*我们的初始化和配置。[列表 4.18](#ch04list18) 包含了 `removeSlider`
    方法的代码更改。更改内容以**粗体**显示：
- en: Listing 4.18\. `removeSlider` method—spa/js/spa.chat.js
  id: totrans-540
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.18\. `removeSlider` 方法——spa/js/spa.chat.js
- en: '[PRE38]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We don’t try to get too clever with any `remove` method. The point is to lay
    waste to any prior configuration and initialization, and that’s it. We carefully
    ensure that data pointers are removed. This is important so that reference counts
    to data structures can drop to 0, which allows garbage collection to do its job.
    *This is one reason why we always list potential configMap and stateMap keys at
    the top of the module*—so we can see what we need to clean up.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不试图在任何一个 `remove` 方法上表现得过于聪明。目的是破坏任何先前的配置和初始化，仅此而已。我们仔细确保数据指针被移除。这是很重要的，因为这样可以让数据结构的引用计数降到
    0，从而允许垃圾回收完成其工作。*这就是为什么我们总是在模块的顶部列出潜在的 configMap 和 stateMap 键的原因之一——这样我们可以看到我们需要清理什么*。
- en: 'We can test the `removeSlider` method by opening the Chrome Developer Tools
    JavaScript console and entering the following (don’t forget to press Return!):'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过打开 Chrome 开发者工具的 JavaScript 控制台并输入以下内容来测试 `removeSlider` 方法（别忘了按 Return！）：
- en: '[PRE39]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When we inspect the browser window we can see the chat slider has been removed.
    If we want to get it back, we can enter the following lines into the JavaScript
    console:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检查浏览器窗口时，我们可以看到聊天滑块已经被移除。如果我们想将其恢复，我们可以将以下几行代码输入到 JavaScript 控制台中：
- en: '[PRE40]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The chat slider we “restored” with the JavaScript console isn’t fully functional,
    as we have provided a `null` function for the `set_chat_anchor` callback. In real
    use, we would always reenable the chat module from the Shell where we have access
    to the required callback.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 JavaScript 控制台“恢复”的聊天滑块并不完全功能，因为我们为 `set_chat_anchor` 回调提供了 `null` 函数。在实际使用中，我们总是会从
    Shell 中重新启用聊天模块，在那里我们可以访问所需的回调。
- en: We could do a lot more with this method—like having the slider disappear grace-fully—but
    we’ll leave that as an exercise for the reader. Let’s now implement another method
    which is commonly required by feature modules, `handleResize`.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用这个方法做更多的事情——比如让滑块优雅地消失——但我们将其留作读者的练习。现在让我们实现另一个通常由功能模块所需的方法，`handleResize`。
- en: 4.5.2\. The handleResize method
  id: totrans-549
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.5.2\. 处理 `handleResize` 方法
- en: 'The second method common to many feature modules is `handleResize`. With good
    use of CSS, most content in an SPA can be made to work within a window that’s
    a reasonable size. But there are some cases where *most* doesn’t work and some
    recalculation is required. Let’s first implement the `handleResize` method as
    shown in [listing 4.19](#ch04list19) and then discuss its use. Changes are shown
    in **bold**:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个在许多功能模块中常见的通用方法是 `handleResize`。通过良好的 CSS 使用，大多数内容在 SPA 中都可以在合理大小的窗口中工作。但有些情况下*大多数*是不行的，需要一些重新计算。让我们首先实现如[列表
    4.19](#ch04list19)所示的 `handleResize` 方法，然后讨论其用法。更改内容以**粗体**显示：
- en: Listing 4.19\. Add the `handleResize` method—spa/js/spa.chat.js
  id: totrans-551
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.19\. 添加 `handleResize` 方法——spa/js/spa.chat.js
- en: '![](ch04list19-0.jpg)'
  id: totrans-552
  prefs: []
  type: TYPE_IMG
  zh: '![](ch04list19-0.jpg)'
- en: '![](ch04list19-1.jpg)'
  id: totrans-553
  prefs: []
  type: TYPE_IMG
  zh: '![](ch04list19-1.jpg)'
- en: The `handleResize` event doesn’t call itself. Now we might be tempted to implement
    a `window.resize` event handler for every feature module, but that would be a
    *bad idea*. The trouble is that the frequency at which a `window.resize` event
    fires varies wildly by browser. Let’s say we have five feature modules, all of
    which have `window.resize` event handlers, and our user decided to resize the
    browser. If the `window.resize` event fires every 10 milliseconds, and the resulting
    graphical changes are sufficiently complex, this can easily bring an SPA—and possibly
    the entire browser and OS it’s running on—to its knees.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleResize` 事件不会调用自身。现在我们可能会想为每个功能模块实现一个 `window.resize` 事件处理器，但这不是一个好主意。问题是
    `window.resize` 事件触发的频率因浏览器而异。假设我们有五个功能模块，它们都拥有 `window.resize` 事件处理器，并且用户决定调整浏览器的大小。如果
    `window.resize` 事件每 10 毫秒触发一次，并且产生的图形变化足够复杂，这很容易将单页应用（SPA）——以及可能运行在其上的整个浏览器和操作系统——拖垮。'
- en: 'A better approach is to have a Shell event handler capture resize events and
    then have it call all subordinate feature module `handleResize` methods. This
    allows us to throttle the resize handling and dispatch from one event handler.
    Let’s implement this strategy in the Shell as shown in [listing 4.20](#ch04list20).
    Changes are shown in **bold**:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的方法是让 Shell 事件处理器捕获调整大小事件，然后调用所有从属功能模块的 `handleResize` 方法。这允许我们限制调整大小处理和从单个事件处理器分发。让我们在
    Shell 中实现此策略，如 [代码清单 4.20](#ch04list20) 所示。更改以粗体显示：
- en: Listing 4.20\. Add the onResize event handler—spa/js/spa.shell.js
  id: totrans-556
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 代码清单 4.20\. 添加 onResize 事件处理器——spa/js/spa.shell.js
- en: '![](ch04list20-0.jpg)'
  id: totrans-557
  prefs: []
  type: TYPE_IMG
  zh: '![](ch04list20-0.jpg)'
- en: '![](ch04list20-1.jpg)'
  id: totrans-558
  prefs: []
  type: TYPE_IMG
  zh: '![](ch04list20-1.jpg)'
- en: 'We want to adjust our stylesheet so we can better see the fruits of our labor.
    In [listing 4.21](#ch04list21) we adjust spa.css to decrease the minimal window
    size, move to relative units, and remove the gratuitous border around the content.
    Changes are shown in **bold**:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想调整我们的样式表，以便更好地看到我们劳动的成果。在 [代码清单 4.21](#ch04list21) 中，我们调整 spa.css 以减小最小窗口大小，改为使用相对单位，并移除内容周围的冗余边框。更改以粗体显示：
- en: Listing 4.21\. Style changes to emphasize `onResize`—spa/css/spa.css
  id: totrans-560
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 代码清单 4.21\. 对 `onResize` 进行样式更改——spa/css/spa.css
- en: '![](ch04list21-0.jpg)'
  id: totrans-561
  prefs: []
  type: TYPE_IMG
  zh: '![](ch04list21-0.jpg)'
- en: '![](ch04list21-1.jpg)'
  id: totrans-562
  prefs: []
  type: TYPE_IMG
  zh: '![](ch04list21-1.jpg)'
- en: 'We can now watch the resize event work by opening our browser document ([spa/spa.html](http://spa/spa.html))
    and then increasing or decreasing the browser window height. [Figure 4.14](#ch04fig14)
    compares the slider presentation before and after the threshold has been reached:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过打开我们的浏览器文档 ([spa/spa.html](http://spa/spa.html)) 并增加或减少浏览器窗口高度来观察调整大小事件的工作。![图
    4.14](#ch04fig14) 比较了达到阈值前后滑块的展示：
- en: Figure 4.14\. A comparison of chat slider sizes before and after threshold
  id: totrans-564
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.14\. 阈值前后聊天滑块大小的比较
- en: '![](04fig14_alt.jpg)'
  id: totrans-565
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig14_alt.jpg)'
- en: Of course, there’s always room for more flourish. A nice enhancement would be
    to have the slider maintain a minimum distance from the top border. For example,
    if the window were 0.5 em over the threshold, the slider could be made to be precisely
    0.5 em shorter than normal. This would provide a better user experience with optimal
    chat space and a smoother adjustment during resizing. The implementation isn’t
    hard and is left as an exercise for the reader.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，总有更多的改进空间。一个很好的增强是让滑块保持与顶部边界的最小距离。例如，如果窗口超过阈值 0.5 em，滑块可以精确地比正常短 0.5 em。这将提供更好的用户体验，最佳的聊天空间，并在调整大小时更加平滑。实现并不困难，留给读者作为练习。
- en: 4.6\. Summary
  id: totrans-567
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6\. 摘要
- en: This chapter showed how feature modules can be employed to take advantage of
    the good aspects of third-party modules without all of their disadvantages. We
    defined what feature modules are, compared them to third-party modules, and discussed
    how they fit into our architecture. We explored how our application—and that of
    most websites—contains a fractal repetition of MVC patterns, and how this manifests
    itself in feature modules. We then created a feature module starting with the
    code we developed in [chapter 3](kindle_split_014.html#ch03). In our first pass,
    we added all the files we needed and added basic capabilities. Then we designed
    our APIs and implemented them during a second pass. Finally, we added some frequently
    needed feature module methods and detailed their use.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了如何利用功能模块利用第三方模块的优点，而不必承担所有缺点。我们定义了功能模块是什么，将它们与第三方模块进行比较，并讨论了它们如何适应我们的架构。我们探讨了我们的应用程序——以及大多数网站——如何包含
    MVC 模式的分形重复，以及这在功能模块中的表现。然后，我们从 [第 3 章](kindle_split_014.html#ch03) 中开发的代码开始创建一个功能模块。在我们的第一次遍历中，我们添加了所有需要的文件并添加了基本功能。然后我们在第二次遍历中设计了我们的
    API 并实现了它们。最后，我们添加了一些常用的功能模块方法并详细说明了它们的用法。
- en: Now it’s time to centralize our business logic into the Model. In the next few
    chapters we develop the Model and show how to embody the business logic for the
    user, people, and chat. We use jQuery events to trigger DOM changes instead of
    relying on fragile callbacks, and we simulate a “live” chat session. Stick with
    us—this is where we take our SPA from a fancy demo to a near-complete client application.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将我们的业务逻辑集中到模型中。在接下来的几章中，我们将开发模型并展示如何体现用户、人员和聊天的业务逻辑。我们使用 jQuery 事件来触发 DOM
    变化，而不是依赖于脆弱的回调，并模拟一个“实时”的聊天会话。请继续跟随我们——这是我们如何将我们的 SPA 从一个花哨的演示转变为一个几乎完整的客户端应用程序。
- en: Chapter 5\. Build the Model
  id: totrans-570
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 5 章\. 构建模型
- en: '|  |'
  id: totrans-571
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**This chapter covers**'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Defining the Model and how it fits into our architecture
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义模型及其在架构中的位置
- en: The relationship between the Model, Data, and Fake modules
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型、数据和模拟模块之间的关系
- en: Setting up files for the Model
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为模型设置文件
- en: Enabling touch devices
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用触摸设备
- en: Designing the `people` object
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计`people`对象
- en: Building the `people` object and testing the API
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建`people`对象并测试API
- en: Updating the Shell so users may sign in and sign out
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新Shell以便用户可以登录和注销
- en: '|  |'
  id: totrans-580
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: This chapter builds on code we’ve written in [chapters 3](kindle_split_014.html#ch03)
    and [4](kindle_split_015.html#ch04) of this book. Before starting, you should
    have the project files from [chapter 4](kindle_split_015.html#ch04), as we’ll
    be adding to them. We recommend you copy the entire directory structure you created
    in [chapter 4](kindle_split_015.html#ch04) into a new “chapter_5” directory and
    update it there.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 本章基于本书第3章和第4章中编写的代码。在开始之前，你应该有第4章的项目文件，因为我们将在此基础上添加内容。我们建议你将第4章中创建的整个目录结构复制到一个新的“chapter_5”目录中，并在那里更新它。
- en: In this chapter we design and build the `people` object portion of the Model.
    The Model provides the business logic and data to the Shell and feature modules.
    The Model is independent of the user interface (UI) and isolates it from logic
    and data management. The Model is itself isolated from the web server through
    the use of a *Data* module.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们设计和构建模型中`people`对象的部分。模型为Shell和功能模块提供业务逻辑和数据。模型独立于用户界面（UI），并将其从逻辑和数据管理中隔离。模型本身通过使用数据模块与Web服务器隔离。
- en: We want our SPA to use the `people` object to manage a list of people, which
    includes the user as well as people with whom they’re chatting. After we modify
    and test the Model, we update the Shell so that a user may sign in and sign out.
    Along the way, we add touch controls so we can use our SPA on a smart phone or
    tablet. Let’s get started by getting a better understanding of what the Model
    does and how it fits into our architecture.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的SPA使用`people`对象来管理人员列表，包括用户以及他们正在聊天的人。在修改和测试模型后，我们更新Shell，以便用户可以登录和注销。在此过程中，我们添加了触摸控制，这样我们就可以在智能手机或平板电脑上使用我们的SPA。让我们先更好地了解模型的作用以及它如何融入我们的架构。
- en: 5.1\. Understand the Model
  id: totrans-584
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1. 理解模型
- en: In [chapter 3](kindle_split_014.html#ch03) we introduced the Shell module, which
    is responsible for application-wide tasks like URI anchor management and application
    layout. The Shell dispatches feature-specific tasks to carefully isolated feature
    modules that we introduced in [chapter 4](kindle_split_015.html#ch04). These modules
    have their own View, Controller, and a slice of the Model that the Shell shares
    with them. An overview of the architecture is shown in [figure 5.1](#ch05fig01).^([[1](#ch05fn01)])
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](kindle_split_014.html#ch03)中，我们介绍了Shell模块，该模块负责应用范围内的任务，如URI锚点管理和应用布局。Shell将特定功能的任务调度到我们在[第4章](kindle_split_015.html#ch04)中引入的精心隔离的功能模块。这些模块有自己的视图、控制器，以及Shell与它们共享的模型的一部分。架构概述如图5.1所示。[图5.1](#ch05fig01).^([[1](#ch05fn01)])
- en: ¹ Groups of modules that use shared utilities are surrounded by a dashed-line
    box. For example, the Chat, Avatar, and Shell modules all use the “Browser utilities”
    and the “Base utilities,” whereas the Data and Model modules use only the “Base
    utilities.”
  id: totrans-586
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ 使用共享工具的模块组被虚线框包围。例如，聊天、头像和Shell模块都使用“浏览器工具”和“基本工具”，而数据和模型模块只使用“基本工具”。
- en: Figure 5.1\. The Model in our SPA architecture
  id: totrans-587
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.1. 我们SPA架构中的模型
- en: '![](05fig01_alt.jpg)'
  id: totrans-588
  prefs: []
  type: TYPE_IMG
  zh: '![图片](05fig01_alt.jpg)'
- en: The Model consolidates all business logic and data in one namespace. The Shell
    or feature modules never communicate with the web server directly, but instead
    interact with the Model. The Model is itself isolated from the web server through
    the use of the Data module. This isolation results in faster development *and*
    higher quality, as we shall soon see.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 模型将所有业务逻辑和数据集中在一个命名空间中。Shell或功能模块从不直接与Web服务器通信，而是与模型交互。模型本身通过使用数据模块与Web服务器隔离。这种隔离导致开发速度更快，质量更高，正如我们很快将看到的。
- en: This chapter begins the development and use of the Model. In [chapter 6](kindle_split_017.html#ch06),
    we’ll complete this work. Let’s look at what we’ll accomplish over these two chapters
    and the corresponding capabilities the Model will need to have.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开始介绍模型的发展和运用。在[第6章](kindle_split_017.html#ch06)中，我们将完成这项工作。让我们看看在这两章中我们将取得什么成果，以及模型将需要具备的相应能力。
- en: 5.1.1\. What we’re going to build
  id: totrans-591
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.1. 我们将要构建的内容
- en: 'Before we discuss the Model, it’s useful to refer to an example application.
    [Figure 5.2](#ch05fig02) illustrates the capabilities we plan to add to our SPA
    by the end of [chapter 6](kindle_split_017.html#ch06). The Shell will manage the
    sign-in process—we can see the signed-in user in the top right. The Chat feature
    module will manage the chat window, which is shown at bottom right. And the *Avatar*
    feature module will manage the colored boxes representing people shown on the
    left. Let’s consider the business logic and data we’ll need per module:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论模型之前，参考一个示例应用是有用的。[图 5.2](#ch05fig02) 展示了我们计划在[第 6 章](kindle_split_017.html#ch06)结束时添加到我们的
    SPA 中的功能。Shell 将管理登录过程——我们可以在右上角看到已登录的用户。聊天功能模块将管理聊天窗口，它显示在右下角。而 *头像* 功能模块将管理代表左侧显示的人的彩色框。让我们考虑每个模块所需的业务逻辑和数据：
- en: Figure 5.2\. A vision of the our SPA in the near future
  id: totrans-593
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.2\. 我们近未来 SPA 的一个愿景
- en: '![](05fig02_alt.jpg)'
  id: totrans-594
  prefs: []
  type: TYPE_IMG
  zh: '![图片](05fig02_alt.jpg)'
- en: The Shell will need a representation of the current user to manage the sign-in
    and sign-out process. It’ll need methods to determine who the current user is,
    and to change the user if desired.
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shell 需要表示当前用户以管理登录和登出过程。它需要方法来确定当前用户是谁，并在需要时更改用户。
- en: The Chat feature module will also need to be able to inspect the current user
    (“Josh” in this example), and determine if he is authorized to send or receive
    messages. It’ll need to determine the person with whom the user is chatting—if
    any. It’ll need to inquire about the list of online people so it may show them
    on the left of the chat slider. Finally, it’ll need methods to send messages and
    to select a person to chat with.
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聊天功能模块还需要能够检查当前用户（例如，本例中的“Josh”），并确定他是否有权发送或接收消息。它还需要确定用户正在与哪个人聊天（如果有的话）。它还需要查询在线人员名单，以便在聊天滑块的左侧显示他们。最后，它还需要发送消息和选择聊天对象的方法。
- en: The Avatar feature module will also need to inspect the current user (“Josh”),
    and determine if he is authorized to see and interact with the avatars. It’ll
    also need the current user identification so it may outline the associated avatar
    in blue. It’ll also need to determine the person with whom the user is chatting
    (“Betty”) so it may outline this person’s avatar in green. Finally, it’ll need
    methods to set and retrieve avatar details (such as color and position) for all
    people currently online.
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头像功能模块还需要检查当前用户（“Josh”），并确定他是否有权查看和交互头像。它还需要当前用户标识，以便在蓝色中突出显示相关的头像。它还需要确定用户正在与哪个人聊天（“Betty”），以便在绿色中突出显示此人的头像。最后，它还需要为所有当前在线的人设置和检索头像细节（如颜色和位置）的方法。
- en: 'We have a lot of overlap in the business logic and data our modules require.
    For example, we know the current user object is required by the Shell as well
    as the Chat and Avatar modules. We also know we’ll need to provide a roster of
    online users to both Chat and Avatar. A few strategies come to mind on how we
    might manage this overlap:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 我们模块所需的企业逻辑和数据有很多重叠。例如，我们知道 Shell、聊天和头像模块都需要当前用户对象。我们还知道我们需要为聊天和头像提供在线用户名单。关于如何管理这种重叠，有几个策略浮现在脑海中：
- en: Build the required logic and data in every feature module.
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个功能模块中构建所需的逻辑和数据。
- en: Build parts of the logic and data in different feature modules. For example,
    we might consider Chat to be the owner of the `people` object, and the Avatar
    to be the owner of the `chat` object. We would then make calls between our modules
    to share information.
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同的功能模块中构建逻辑和数据的一部分。例如，我们可能会考虑聊天是 `people` 对象的所有者，而头像是 `chat` 对象的所有者。然后我们将在模块之间进行调用以共享信息。
- en: Build a central Model to consolidate our logic and data.
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立一个中心模型来整合我们的逻辑和数据。
- en: The first option of maintaining parallel data and methods in different modules
    is amusingly error-prone and labor intensive. If we do this, we might rather seek
    an exciting career flipping burgers. And yes, I *would* like fries with that.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同模块中维护并行数据和方法的第一个选项既有趣又容易出错，而且劳动密集。如果我们这样做，我们可能会更愿意寻找一个令人兴奋的炸薯条翻工的工作。而且是的，我
    *确实* 想要薯条。
- en: The second option works better, but only for a while. Once logic and data reach
    a moderate level of complexity, the amount of cross-module dependencies results
    in the dreaded “SPA-ghetti” code.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项效果更好，但只能维持一段时间。一旦逻辑和数据达到中等复杂度，跨模块的依赖关系数量就会导致令人恐惧的“SPA-意大利面”代码。
- en: The final option, using a Model, is by far the best option in our experience,
    and also provides benefits which aren’t immediately obvious. Let’s take a look
    at what a well-written Model should do.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的经验中，使用模型是迄今为止最好的选择，同时也提供了不那么明显的益处。让我们看看一个写得好的模型应该做什么。
- en: 5.1.2\. What the Model does
  id: totrans-605
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.2\. 模型做什么
- en: The Model is where the Shell and all of our feature modules access data and
    business logic in our SPA. If we need to sign in, we invoke a method provided
    by the Model. If we want to get a list of people, we get it from the Model. If
    we want to get avatar information... well, you get the idea. Any data or logic
    that we want to share between feature modules, or is central to the application,
    should go into the Model. If you’re comfortable with Model-View-Controller (MVC)
    architecture, you should be comfortable with the Model.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是Shell和我们的所有功能模块访问SPA中数据和业务逻辑的地方。如果我们需要登录，我们就调用模型提供的方法。如果我们想要获取人员列表，我们就从模型中获取。如果我们想要获取头像信息...嗯，你明白了。任何我们想要在功能模块之间共享的数据或逻辑，或者对于应用程序来说是核心的，都应该放入模型中。如果你对模型-视图-控制器（MVC）架构感到舒适，那么你对模型也应该感到舒适。
- en: Just because all business logic and data are accessed through the Model doesn’t
    mean we have to use only one (potentially huge) JavaScript file to provide it.
    We can use namespacing to break up our Model into more manageable parts. For example,
    if we have a Model that has a `people` object and a `chat` object, we could place
    the `people` logic in spa.model.people.js, and the `chat` logic in spa.model.chat.js,
    and then consolidate them in our main Model file, spa.model.js. Using such a technique,
    the interface presented to the Shell doesn’t change, regardless of the number
    of files used by the Model.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然所有业务逻辑和数据都是通过模型访问的，但这并不意味着我们必须只使用一个（可能非常大的）JavaScript文件来提供它。我们可以使用命名空间将模型拆分成更易于管理的部分。例如，如果我们有一个包含`people`对象和`chat`对象的模型，我们可以将`people`逻辑放在spa.model.people.js中，将`chat`逻辑放在spa.model.chat.js中，然后在我们的主模型文件spa.model.js中合并它们。使用这种技术，无论模型使用的文件数量如何，Shell看到的接口都不会改变。
- en: 5.1.3\. What the Model does not do
  id: totrans-608
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.3\. 模型不做什么
- en: '*The Model doesn’t require a browser.* This means the Model must not assume
    the presence of a `document` object or that browser-specific methods like `document.location`
    are available. It’s good MVC hygiene to have the Shell and (especially) the feature
    modules render the representation of Model data. And this separation makes automated
    unit and regression testing much simpler. We’ve found that as you get into browser
    interaction, the value of automated testing diminishes greatly as the cost of
    implementation rises. But by avoiding the DOM, we can test everything up to the
    UI without having to run a browser.'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '*模型不需要浏览器。* 这意味着模型不能假设存在`document`对象或浏览器特定的方法，如`document.location`可用。Shell和（特别是）功能模块渲染模型数据的表示是良好的MVC卫生习惯。这种分离使得自动化单元和回归测试变得简单得多。我们发现，随着你进入浏览器交互，自动化测试的价值随着实现成本的上升而大大降低。但通过避免DOM，我们可以测试到UI的所有内容，而无需运行浏览器。'
- en: '|  |'
  id: totrans-610
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Unit and regression testing**'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元和回归测试**'
- en: Development teams must decide when to invest in automated testing. Automating
    the tests of Model API is almost always a good investment because the tests can
    be isolated to use the same data for each API call. Automating the tests of a
    UI is much more expensive due to the many variables that aren’t easily controlled
    or predicted. For example, it can be difficult and expensive to simulate how quickly
    a user might click on one button and then another, or to foresee how data will
    propagate through the system when a user is involved, or to know how fast a network
    will perform. For these reasons, web page testing is often performed manually,
    with the help of a few tools like HTML validators and link checkers.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 开发团队必须决定何时投资于自动化测试。自动化模型API的测试几乎总是好的投资，因为测试可以隔离以使用每个API调用相同的数据。自动化UI的测试要昂贵得多，因为有许多变量不容易控制或预测。例如，模拟用户可能点击一个按钮然后另一个按钮的速度可能既困难又昂贵，或者预见当用户参与时数据如何在系统中传播，或者知道网络性能有多快可能很难。出于这些原因，网页测试通常是通过一些工具如HTML验证器和链接检查器手动进行的。
- en: A well designed SPA has independent Data, Model, and feature module (View +
    Controller) layers. We ensure our Data and Model have well-defined APIs and are
    isolated from the feature modules, and as a result we don’t have to use a browser
    to test these layers. Instead we can inexpensively employ automated unit and regression
    testing using a JavaScript execution environment like Node.js or Java’s Rhino.
    In our experience, the View and Controller layers are still best tested manually
    by real people.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 一个设计良好的 SPA 应该有独立的 Data、Model 和功能模块（视图 + 控制器）层。我们确保我们的 Data 和 Model 有明确定义的 API，并且与功能模块隔离，因此我们不需要使用浏览器来测试这些层。相反，我们可以使用
    Node.js 或 Java 的 Rhino 等JavaScript 执行环境以低成本地执行自动单元和回归测试。根据我们的经验，视图和控制层仍然最好由真实的人手动测试。
- en: '|  |'
  id: totrans-614
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '*The Model doesn’t provide general purpose utilities.* Instead, we use a general
    utility library (spa/js/spa.util.js) that doesn’t require the DOM. We package
    these utilities separately because we’ll use them with multiple SPAs. The Model,
    on the other hand, is often tailored for a specific SPA.'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '*模型不提供通用工具*。 相反，我们使用一个不需要 DOM 的通用工具库（spa/js/spa.util.js）。我们单独打包这些工具，因为我们将在多个
    SPA 中使用它们。另一方面，模型通常是为特定的 SPA 定制的。'
- en: '*The Model doesn’t communicate directly with the server*. We have a separate
    module for that called Data. The Data module is responsible for getting all the
    data the Model requires from the server.'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '*模型不直接与服务器通信*。 我们有一个名为 Data 的单独模块来处理这个问题。Data 模块负责从服务器获取模型所需的所有数据。'
- en: Now that we have a better understanding of the Model’s role in our architecture,
    let’s set up the files we’ll need in this chapter.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对我们架构中模型的作用有了更好的理解，让我们设置本章所需的文件。
- en: 5.2\. Set up the Model and other files
  id: totrans-618
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2\. 设置模型和其他文件
- en: We need to add and modify a number of files to support building our Model. We
    also want to add the Avatar feature module files now, as we’ll need them soon
    enough.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加和修改一些文件来支持构建我们的模型。我们还希望现在就添加 Avatar 功能模块的文件，因为我们很快就会需要它们。
- en: 5.2.1\. Plan the file structure
  id: totrans-620
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.1\. 规划文件结构
- en: 'We recommend you copy the whole directory structure you created in [chapter
    4](kindle_split_015.html#ch04) into a new “chapter_5” directory so we can update
    them there. Let’s review our file structure as we left it in [chapter 4](kindle_split_015.html#ch04),
    as shown in [listing 5.1](#ch05list01):'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您将第 4 章中创建的整个目录结构复制到一个新的“chapter_5”目录中，这样我们就可以在那里更新它们。让我们回顾一下我们在[第 4 章](kindle_split_015.html#ch04)中留下的文件结构，如[列表
    5.1](#ch05list01)所示：
- en: Listing 5.1\. File structure from Chapter 4
  id: totrans-622
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.1\. 第 4 章的文件结构
- en: '[PRE41]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here are the modifications we plan to make:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们计划进行的修改：
- en: '*Create* our namespaced CSS stylesheet for Avatar.'
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建* 我们命名的 Avatar CSS 样式表。'
- en: '*Modify* our namespaced CSS stylesheet for the Shell to support user sign-in.'
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*修改* 我们命名的 Shell CSS 样式表以支持用户登录。'
- en: '*Include* the jQuery plugin for unified touch and mouse input.'
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*包含* jQuery 插件以实现统一的触摸和鼠标输入。'
- en: '*Include* the jQuery plugin for global custom events.'
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*包含* jQuery 插件以实现全局自定义事件。'
- en: '*Include* the JavaScript library for the browser database.'
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*包含* 浏览器数据库的 JavaScript 库。'
- en: '*Create* our namespaced Avatar module. This is a placeholder for [chapter 6](kindle_split_017.html#ch06).'
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建* 我们命名的 Avatar 模块。这是[第 6 章](kindle_split_017.html#ch06)的占位符。'
- en: '*Create* our namespaced Data module. This will provide an interface to “real”
    data from the server.'
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建* 我们命名的 Data 模块。这将提供一个接口来访问“真实”数据。'
- en: '*Create* our namespaced Fake module. This will provide an interface to “fake”
    data that we use for testing.'
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建* 我们命名的 Fake 模块。这将提供一个接口来访问我们用于测试的“虚假”数据。'
- en: '*Create* our namespaced browser utilities modules so we can share common routines
    that require a browser.'
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建* 我们命名的浏览器实用工具模块，以便我们可以共享需要浏览器的通用例程。'
- en: '*Modify* our namespaced Shell module to support user sign-in.'
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*修改* 我们命名的 Shell 模块以支持用户登录。'
- en: '*Modify* our browser document to include the new CSS and JavaScript files.'
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*修改* 浏览器文档以包含新的 CSS 和 JavaScript 文件。'
- en: 'Our updated files and directories should look like [listing 5.2](#ch05list02).
    We show all files we’ll have to create or modify in **bold**:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更新的文件和目录应该看起来像[列表 5.2](#ch05list02)。我们用粗体标出我们将要创建或修改的所有文件：
- en: Listing 5.2\. Updated file structure
  id: totrans-637
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.2\. 更新的文件结构
- en: '![](144fig01_alt.jpg)'
  id: totrans-638
  prefs: []
  type: TYPE_IMG
  zh: '![144fig01_alt.jpg]'
- en: Now that we’ve identified the files we want to add or modify, let’s fire up
    our trusty text editor and get the job done. It turns out the best order to consider
    each file in is exactly the order presented. If you’re playing along at home,
    you can build the files as we walk through the code.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经确定了要添加或修改的文件，让我们启动我们信任的文本编辑器并完成工作。结果，考虑每个文件的顺序正好是呈现的顺序。如果您在家中参与，可以在我们遍历代码时构建文件。
- en: 5.2.2\. Populate the files
  id: totrans-640
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.2\. 填充文件
- en: 'Our first file to consider is spa/css/spa.avtr.css. We’ll create the file and
    populate it with the contents shown in [listing 5.3](#ch05list03). Initially,
    it’ll be a *stub*:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先考虑的文件是 spa/css/spa.avtr.css。我们将创建该文件，并用 [列表 5.3](#ch05list03) 中显示的内容填充它。最初，它将是一个
    *占位符*：
- en: Listing 5.3\. Our *Avatar* stylesheet (stub)—spa/css/spa.avtr.css
  id: totrans-642
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.3\. 我们的 *Avatar* 样式表（占位符）—spa/css/spa.avtr.css
- en: '[PRE42]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The next three files are libraries. Let’s download them into the spa/js/jq directory.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三个文件是库文件。让我们将它们下载到 spa/js/jq 目录中。
- en: The spa/js/jq/jquery.event.ue-0.3.2.js file is available at [https://github.com/mmikowski/jquery.event.ue](https://github.com/mmikowski/jquery.event.ue).
    It provides unified touch and mouse input.
  id: totrans-645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: spa/js/jq/jquery.event.ue-0.3.2.js 文件可在 [https://github.com/mmikowski/jquery.event.ue](https://github.com/mmikowski/jquery.event.ue)
    获取。它提供统一的触摸和鼠标输入。
- en: The spa/js/jq/jquery.event.gevent-0.1.9.js file is available at [https://github.com/mmikowski/jquery.event.gevent](https://github.com/mmikowski/jquery.event.gevent)
    and is required to use global custom events.
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: spa/js/jq/jquery.event.gevent-0.1.9.js 文件可在 [https://github.com/mmikowski/jquery.event.gevent](https://github.com/mmikowski/jquery.event.gevent)
    获取，并且是使用全局自定义事件所必需的。
- en: The spa/js/jq/taffydb-2.6.2.js file provides our client database. It may be
    found at [https://github.com/typicaljoe/taffydb](https://github.com/typicaljoe/taffydb).
    It’s not a jQuery plugin, and if we were dealing with a larger project we’d place
    this in a separate spa/js/lib directory.
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: spa/js/jq/taffydb-2.6.2.js 文件提供我们的客户端数据库。它可能位于 [https://github.com/typicaljoe/taffydb](https://github.com/typicaljoe/taffydb)。它不是一个
    jQuery 插件，如果我们处理的是一个更大的项目，我们会将其放在一个单独的 spa/js/lib 目录中。
- en: 'The next three JavaScript files—spa/js/spa.avtr.js, spa/js/spa.data.js, and
    spa/js/ spa.fake.js—will be stubs. Their contents are shown in [listings 5.4](#ch05list04),
    [5.5](#ch05list05), and [5.6](#ch05list06). They’re mostly identical—each has
    a header, followed by our JSLint options, and then a namespace declaration that
    is congruent with the file name. We’ve shown the unique parts in **bold**:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三个 JavaScript 文件—spa/js/spa.avtr.js、spa/js/spa.data.js 和 spa/js/spa.fake.js—将是占位符。它们的内容显示在
    [列表 5.4](#ch05list04)、[5.5](#ch05list05) 和 [5.6](#ch05list06) 中。它们大部分是相同的——每个都有一个标题，然后是我们的
    JSLint 选项，然后是一个与文件名一致的命名空间声明。我们用 **粗体** 标出了独特部分：
- en: Listing 5.4\. Create the Avatar feature module—spa/js/spa.avtr.js
  id: totrans-649
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.4\. 创建头像功能模块—spa/js/spa.avtr.js
- en: '[PRE43]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Listing 5.5\. Create the Data module—spa/js/spa.data.js
  id: totrans-651
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.5\. 创建数据模块—spa/js/spa.data.js
- en: '[PRE44]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Listing 5.6\. Create the Fake data module—spa/js/spa.fake.js
  id: totrans-653
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.6\. 创建模拟数据模块—spa/js/spa.fake.js
- en: '[PRE45]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Recall that the `/*jslint` `...*/` and `/*global` `...*/` sections are used
    when we run JSLint to check our code for common errors. The `/*jslint` `...*/`
    section sets preferences for validation. For example, `browser` `:` `true` tells
    the JSLint validator to assume that we’ll run this JavaScript in a browser, and
    therefore we’ll have a `document` object (among other things). The `/*global`
    `$, spa */` section tells the JSLint validator that the variables `$` and `spa`
    are defined outside of this module. Without this information, the validator would
    complain that these variables aren’t defined before being used. See [appendix
    A](kindle_split_022.html#app01) for a full discussion of our JSLint settings.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`/*jslint` `...*/` 和 `/*global` `...*/` 部分是在我们运行 JSLint 检查代码中的常见错误时使用的。`/*jslint`
    `...*/` 部分设置验证的首选项。例如，`browser` `:` `true` 告诉 JSLint 验证器假设我们将在此浏览器中运行此 JavaScript，因此我们将有一个
    `document` 对象（以及其他事物）。`/*global` `$, spa */` 部分告诉 JSLint 验证器变量 `$` 和 `spa` 是在此模块外部定义的。如果没有这些信息，验证器会抱怨这些变量在使用之前没有被定义。参见
    [附录 A](kindle_split_022.html#app01) 以获取我们 JSLint 设置的完整讨论。
- en: Next we can add our browser utilities file, spa/js/spa.util_b.js. This module
    provides common routines that work only in a browser environment. In other words,
    the browser utilities won’t normally work with Node.js, whereas our standard utilities
    (spa/js/spa.util.js) will. [Figure 5.3](#ch05fig03) shows this module in our architecture.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们可以添加我们的浏览器工具文件，spa/js/spa.util_b.js。此模块提供仅在浏览器环境中工作的常用例程。换句话说，浏览器工具通常不会与
    Node.js 一起工作，而我们的标准工具 (spa/js/spa.util.js) 会。![图 5.3](#ch05fig03) 显示了该模块在我们的架构中。
- en: Figure 5.3\. The browser utilities module provides utilities that require a
    browser to run
  id: totrans-657
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.3. 浏览器实用工具模块提供了需要浏览器运行的实用工具
- en: '![](05fig03_alt.jpg)'
  id: totrans-658
  prefs: []
  type: TYPE_IMG
  zh: '![图片 5.3](05fig03_alt.jpg)'
- en: 'Our browser utilities will provides the `encodeHtml` and `decodeHtml` utilities
    which, not surprisingly, can be used to encode and decode special characters used
    in HTML like `&` or `<`.^([[2](#ch05fn02)]) It’ll also provide the `getEmSize`
    utility, which can calculate the number of pixels for the `em` unit in the browser.
    Sharing these utilities ensures they’re implemented consistently and also minimizes
    the amount of code we need to write. Let’s fire up our text editor and create
    the file as shown in [listing 5.7](#ch05list07). The methods are shown in **bold**:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的浏览器实用工具将提供`encodeHtml`和`decodeHtml`实用工具，不出所料，这些工具可以用来编码和解码 HTML 中使用的特殊字符，如`&`或`<`。它还将提供`getEmSize`实用工具，可以计算浏览器中`em`单位像素的数量。共享这些实用工具确保它们得到一致的实施，同时也最小化了我们需要编写的代码量。让我们启动我们的文本编辑器并创建如图
    5.7 所示的文件。方法以粗体显示：
- en: ² These methods are important to prevent cross-site-scripting attacks when we
    present data that comes from user input.
  id: totrans-660
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ² 这些方法对于防止当我们展示来自用户输入的数据时的跨站脚本攻击非常重要。
- en: Listing 5.7\. Create the browser utilities module—spa/js/spa.util_b.js
  id: totrans-661
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.7. 创建浏览器实用工具模块—spa/js/spa.util_b.js
- en: '![](ch05list07-0.jpg)'
  id: totrans-662
  prefs: []
  type: TYPE_IMG
  zh: '![图片 5.7](ch05list07-0.jpg)'
- en: '![](ch05list07-1.jpg)'
  id: totrans-663
  prefs: []
  type: TYPE_IMG
  zh: '![图片 5.7](ch05list07-1.jpg)'
- en: 'The final file to consider is the browser document. We’ll update it to use
    all our new CSS and JavaScript files, as shown in [listing 5.8](#ch05list08).
    The changes from [chapter 4](kindle_split_015.html#ch04) are shown in **bold**:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的最后一个文件是浏览器文档。我们将更新它以使用所有新的 CSS 和 JavaScript 文件，如[列表 5.8](#ch05list08)所示。从[第
    4 章](kindle_split_015.html#ch04)的更改以粗体显示：
- en: Listing 5.8\. Update the browser document—spa/spa.html
  id: totrans-665
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.8. 更新浏览器文档—spa/spa.html
- en: '![](ch05list08-0.jpg)'
  id: totrans-666
  prefs: []
  type: TYPE_IMG
  zh: '![图片 5.8](ch05list08-0.jpg)'
- en: '![](ch05list08-1.jpg)'
  id: totrans-667
  prefs: []
  type: TYPE_IMG
  zh: '![图片 5.8](ch05list08-1.jpg)'
- en: Now that everything is in place, let’s talk about adding touch controls to our
    SPA.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切准备就绪，让我们来谈谈如何将触摸控制添加到我们的 SPA 中。
- en: 5.2.3\. Use the unified touch-mouse library
  id: totrans-669
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.3. 使用统一的触摸鼠标库
- en: Smartphones and tablets are currently outselling traditional laptops and desktops
    worldwide. We expect the mobile device sales to continue to exceed traditional
    computing devices and grow as a percentage of active SPA-capable devices. Soon
    the majority of potential customers who wish to use our site may be using a touch
    device.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 智能手机和平板电脑目前在全球范围内销量超过传统的笔记本电脑和台式电脑。我们预计移动设备销量将继续超过传统计算设备，并作为活跃的 SPA-兼容设备百分比的增长。不久，大多数希望使用我们网站的潜在客户可能都在使用触摸设备。
- en: We recognize this trend and have included the unified touch-mouse interface
    library—`jquery.event.ue-0.3.2.js`—in this chapter. This library, although not
    perfect, does a lot of magic in making an application work seamlessly across touch
    and pointer interfaces; it handles multi-touch, pinch-to-zoom, drag-and-drop,
    and long-press along with the more pedestrian events. We’ll detail its use as
    we update our UI in this and future chapters.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认识到这一趋势，并在本章中包含了统一的触摸鼠标界面库—`jquery.event.ue-0.3.2.js`。这个库，尽管并不完美，但在使应用程序在触摸和指针界面之间无缝工作方面做了很多魔法；它处理了多点触控、捏合缩放、拖放和长按，以及更常见的其他事件。我们将详细说明它在本章和未来章节中更新我们的
    UI 时的使用方法。
- en: We’ve now readied our files for the changes we’ll be applying. When we load
    our browser document ([spa/spa.html](http://spa/spa.html)), we should see the
    same page as we left it in [chapter 4](kindle_split_015.html#ch04) without any
    errors. Now let’s start building our Model.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经准备好了将要应用更改的文件。当我们加载我们的浏览器文档([spa/spa.html](http://spa/spa.html))时，我们应该看到与我们在[第
    4 章](kindle_split_015.html#ch04)中离开时相同的页面，没有任何错误。现在让我们开始构建我们的模型。
- en: 5.3\. Design the people object
  id: totrans-673
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3. 设计人员对象
- en: In this chapter we’ll build the `people` object portion of the Model, as shown
    in [figure 5.4](#ch05fig04).
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建模型中的人员对象部分，如图 5.4 所示。
- en: Figure 5.4\. In this section we start the design of our Model with the `people`
    object
  id: totrans-675
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.4. 在本节中，我们以人员对象开始我们的模型设计
- en: '![](05fig04_alt.jpg)'
  id: totrans-676
  prefs: []
  type: TYPE_IMG
  zh: '![图片 5.4](05fig04_alt.jpg)'
- en: 'We expect our model to be split into two sections: a `chat` object and a `people`
    object. Here is the specification we first sketched in [chapter 4](kindle_split_015.html#ch04):'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 我们预计我们的模型将分为两个部分：一个`chat`对象和一个`people`对象。这是我们在[第 4 章](kindle_split_015.html#ch04)中首先草拟的规范：
- en: '[PRE46]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The description provided for the `people` object—“an object that provides methods
    to interact with the list of people the Model maintains”—is a good start, but
    it’s not detailed enough for implementation. Let’s design the `people` object
    starting with the objects we will use to represent each person in our list.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 为`people`对象提供的描述——“一个提供与Model维护的人员列表交互方法的对象”——是一个好的开始，但它对于实现来说还不够详细。让我们从我们将用来表示我们列表中每个人员的对象开始设计`people`对象。
- en: 5.3.1\. Design the person objects
  id: totrans-680
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.1\. 设计人员对象
- en: 'We’ve decided that the `people` object should manage a list of persons. Experience
    has shown us that a person is well represented by an object. Therefore our `people`
    object will manage many `person` objects. Here are the minimal properties we think
    each `person` object should have:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经决定`people`对象应该管理一个人员列表。经验表明，一个人可以用一个对象很好地表示。因此，我们的`people`对象将管理许多`person`对象。以下是我们认为每个`person`对象应该拥有的最小属性：
- en: '`id`—The server ID. This will be defined for all objects sent from the backend.'
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`—服务器ID。这将定义所有从后端发送的对象。'
- en: '`cid`—The client ID. This should always be defined, and usually will be the
    same as the ID; but if we create a new `person` object on the client and the backend
    has not yet been updated, the server ID will be undefined.'
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cid`—客户端ID。这应该始终定义，通常将与ID相同；但如果我们在客户端创建一个新的`person`对象而后端尚未更新，则服务器ID将是未定义的。'
- en: '`name`—The name of the person.'
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`—人员的姓名。'
- en: '`css_map`—A map of display properties. We’ll need this to support avatars.'
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`css_map`—显示属性的映射。我们需要这个来支持头像。'
- en: 'A UML class diagram of a `person` object is shown in [table 5.1](#ch05table01):'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`person`对象的UML类图显示在[表5.1](#ch05table01)中：
- en: Table 5.1\. A UML class diagram of a person object
  id: totrans-687
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表5.1\. 人员对象的UML类图
- en: '| person |'
  id: totrans-688
  prefs: []
  type: TYPE_TB
  zh: '| person |'
- en: '| --- |'
  id: totrans-689
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| **Attribute name** | **Attribute type** |'
  id: totrans-690
  prefs: []
  type: TYPE_TB
  zh: '| **属性名称** | **属性类型** |'
- en: '| id | string |'
  id: totrans-691
  prefs: []
  type: TYPE_TB
  zh: '| id | 字符串 |'
- en: '| cid | string |'
  id: totrans-692
  prefs: []
  type: TYPE_TB
  zh: '| cid | 字符串 |'
- en: '| name | string |'
  id: totrans-693
  prefs: []
  type: TYPE_TB
  zh: '| name | 字符串 |'
- en: '| css_map | map |'
  id: totrans-694
  prefs: []
  type: TYPE_TB
  zh: '| css_map | 字典 |'
- en: '| **Method name** | **Return type** |'
  id: totrans-695
  prefs: []
  type: TYPE_TB
  zh: '| **方法名称** | **返回类型** |'
- en: '| get_is_user() | boolean |'
  id: totrans-696
  prefs: []
  type: TYPE_TB
  zh: '| get_is_user() | 布尔 |'
- en: '| get_is_anon() | boolean |'
  id: totrans-697
  prefs: []
  type: TYPE_TB
  zh: '| get_is_anon() | 布尔 |'
- en: '|  |'
  id: totrans-698
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Doing without a client ID property**'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: '**不使用客户端ID属性**'
- en: These days, we rarely use a separate property for client ID. Instead we use
    a single ID property and apply a unique prefix for IDs that are client-generated.
    For example, a client ID might look like `x23`, whereas an ID that originated
    from the backend might look like `50a04142c692d1fd18000003` (especially if you’re
    using MongoDB). Because the backend-generated ID can never start with an `x`,
    it’s easy to determine where any ID was generated. Most of the application logic
    doesn’t need to worry about where an ID originated. The only time it becomes important
    is when we sync to the backend.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 这些天，我们很少使用单独的客户端ID属性。相反，我们使用一个单一的ID属性，并为客户端生成的ID应用一个唯一的前缀。例如，一个客户端ID可能看起来像`x23`，而一个来自后端的ID可能看起来像`50a04142c692d1fd18000003`（特别是如果你在使用MongoDB）。因为后端生成的ID永远不会以`x`开头，所以很容易确定任何ID的生成位置。大多数应用程序逻辑不需要担心ID的来源。唯一变得重要的时候是我们与后端同步时。
- en: '|  |'
  id: totrans-701
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Before we consider what methods a `person` object should have, let’s consider
    the types of persons our `people` object might need to manage. [Figure 5.5](#ch05fig05)
    shows a mockup of what we’d like our user to see, with some notes about people.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们考虑`person`对象应该有哪些方法之前，让我们考虑`people`对象可能需要管理的用户类型。[图5.5](#ch05fig05)显示了我们希望用户看到的内容草稿，以及一些关于人员的注释。
- en: Figure 5.5\. A mockup of our SPA with notes about people
  id: totrans-703
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.5\. 我们SPA的草稿以及关于人员的注释
- en: '![](05fig05_alt.jpg)'
  id: totrans-704
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig05_alt.jpg)'
- en: 'It appears the `people` object will need to identify four types of persons:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来`people`对象需要识别四种类型的人员：
- en: The current user person
  id: totrans-706
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前用户
- en: The anonymous person
  id: totrans-707
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 匿名人士
- en: The person with whom the user is chatting
  id: totrans-708
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与用户聊天的人员
- en: Other online persons
  id: totrans-709
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他在线人士
- en: 'At present we’re only concerned with the current user person and the anonymous
    person—we’ll worry about online persons in the next chapter. We should like to
    have methods to help us identify these types of users:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们只关注当前用户和匿名人士——我们将在下一章中关注在线人士。我们希望有方法帮助我们识别这些类型的用户：
- en: '`get_is_user()`—Return `true` if the `person` object is the current user.'
  id: totrans-711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_is_user()`—如果`person`对象是当前用户，则返回`true`。'
- en: '`get_is_anon()`—Return `true` if the `person` object is anonymous.'
  id: totrans-712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_is_anon()`—如果`person`对象是匿名的，则返回`true`。'
- en: Now that we’ve detailed `person` objects, let’s consider how the `people` object
    will manage them.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经详细说明了`person`对象，让我们考虑`people`对象将如何管理它们。
- en: 5.3.2\. Design the people object API
  id: totrans-714
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.2\. 设计人员对象 API
- en: The `people` object API will consist of methods and jQuery global custom events.
    We’ll consider method calls first.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '`people` 对象 API 将由方法和 jQuery 全局自定义事件组成。我们首先考虑方法调用。'
- en: Design People Method Calls
  id: totrans-716
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设计人员方法调用
- en: 'We want our Model to always have a current user object available. If a person
    isn’t signed in, the user object should be the *anonymous* `person` object. Of
    course, this implies we should provide a means for a person to sign in and sign
    out. The list of people on the left column of the chat slider indicates we’d like
    to maintain a list of online people with whom we can chat, and that we’d like
    them returned in alphabetical order. Given these requirements, this list of methods
    seems about right:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的模型始终有一个当前用户对象可用。如果某人未登录，则用户对象应该是 *匿名* 的 `person` 对象。当然，这暗示我们应该提供一种让某人登录和注销的方法。聊天滑块左侧列出的人员列表表明我们希望维护一个可以与之聊天的在线人员列表，并且我们希望他们按字母顺序返回。考虑到这些要求，这个方法列表似乎是合适的：
- en: '`get_user()`—Return the current user `person` object. If the current user isn’t
    signed in, return the anonymous `person` object.'
  id: totrans-718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_user()`—返回当前用户 `person` 对象。如果当前用户未登录，则返回匿名 `person` 对象。'
- en: '`get_db()`—Get the collection of all the `person` objects including the current
    user. We’d like the person list to always be in alphabetical order.'
  id: totrans-719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_db()`—获取包括当前用户在内的所有 `person` 对象的集合。我们希望人员列表始终按字母顺序排列。'
- en: '`get_by_cid( <client_id> )`—Get the `person` object associated with a unique
    client ID. Though the same could be accomplished by getting the collection and
    searching for the `person` object by client ID, we expect this capability to be
    used often enough that a dedicated method can help avoid errors and provide opportunity
    for optimization.'
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_by_cid( <client_id> )`—获取与唯一客户端 ID 关联的 `person` 对象。虽然可以通过获取集合并通过客户端 ID
    搜索 `person` 对象来实现相同的功能，但我们预计这个功能会被频繁使用，因此一个专用方法可以帮助避免错误并提供优化机会。'
- en: '`login( <user_name> )`—Sign in as the user with the specified user name. We’ll
    avoid the complexity of sign-in authentication as it’s outside the scope of this
    book, and there are many examples to be had elsewhere. When a user signs in, the
    current user object should change to reflect the new identity. We should also
    publish an event called `spa-login` with the current user object as data.'
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`login( <user_name> )`—以指定的用户名登录。我们将避免在本书范围内讨论登录认证的复杂性，因为其他地方有许多示例。当用户登录时，当前用户对象应更改为反映新的身份。我们还应该发布一个名为
    `spa-login` 的事件，并将当前用户对象作为数据。'
- en: '`logout()`—Revert the current user object to the anonymous person. We should
    publish an event called `spa-logout` with the former user object as data.'
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logout()`—将当前用户对象重置为匿名人员。我们应该发布一个名为 `spa-logout` 的事件，并将前一个用户对象作为数据。'
- en: Both the `login()` and `logout()` method descriptions state that we’ll publish
    events as part of their response. The next section discusses what these events
    are and why we use them.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: '`login()` 和 `logout()` 方法描述都指出，我们将作为它们响应的一部分发布事件。下一节将讨论这些事件是什么以及为什么使用它们。'
- en: Design People Events
  id: totrans-724
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设计人员事件
- en: We use events to publish data asynchronously. For example, if the people list
    changes, the Model may want to publish a `spa-listchange` event which shares an
    updated list of people.^([[3](#ch05fn03)]) Methods in our feature modules or the
    Shell that are interested in this event may register with the Model to receive
    it—this is often called *subscribing to an event*. When the `spa-listchange` event
    occurs, the subscribing methods are notified and receive the data that the Model
    publishes. For example, we may have a method in Avatar to add a new graphical
    avatar, and a method in Chat to add to the list of persons shown in the chat slider.
    [Figure 5.6](#ch05fig06) shows how events are broadcast to subscribing feature
    modules and the Shell.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用事件来异步发布数据。例如，如果人员列表发生变化，模型可能希望发布一个 `spa-listchange` 事件，该事件共享更新的人员列表。[图 5.6](#ch05fig06)
    展示了事件是如何广播给订阅的功能模块和 Shell 的。
- en: ³ Other names for the event mechanism include *push communications*, or *pub-sub*
    (short for *publish-subscribe*).
  id: totrans-726
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³ 事件机制的其他名称包括 *推送通信* 或 *pub-sub*（即 *发布-订阅*）。
- en: Figure 5.6\. Events are broadcast from our Model and can be received by subscribed
    methods in our feature modules or the Shell
  id: totrans-727
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.6\. 事件从我们的模型中广播，可以被我们的功能模块或 Shell 中的订阅方法接收
- en: '![](05fig06.jpg)'
  id: totrans-728
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](05fig06.jpg)'
- en: We’d like the Model to publish at least two event types as part of the `people`
    object API:^([[4](#ch05fn04)])
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望模型至少发布两种事件类型作为 `people` 对象 API 的一部分^([[4](#ch05fn04)])。
- en: ⁴ We use a namespace prefix (`spa-`) for all published event names. This helps
    avoid potential conflicts with third-party JavaScript and libraries.
  id: totrans-730
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴ 我们为所有发布的事件名称使用命名空间前缀 (`spa-`)。这有助于避免与第三方 JavaScript 和库潜在的冲突。
- en: '`spa-login` should be published when the sign-in process is complete. This
    won’t happen right away, as the sign-in process usually requires a round-trip
    to the backend. The updated current user object should be supplied as the event
    data.'
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当登录过程完成时，应发布 `spa-login` 事件。这不会立即发生，因为登录过程通常需要与后端进行往返。应将更新后的当前用户对象作为事件数据提供。
- en: '`spa-logout` should be published when the sign-out process is complete. The
    previous user object should be supplied as the event data.'
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当注销过程完成时，应发布 `spa-logout` 事件。应将前一个用户对象作为事件数据提供。
- en: Events are often a preferable manner to distribute asynchronous data. The classic
    JavaScript implementation uses callbacks, and this results in a tangle of code
    that’s hard to debug and keep modular. Events allow module code to remain independent
    yet use the same data. For these reasons, we strongly prefer events when distributing
    asynchronous data from the Model.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 事件通常是一种更佳的方式用于异步数据的分发。经典的 JavaScript 实现使用回调函数，这会导致代码变得混乱，难以调试和模块化。事件允许模块代码保持独立，同时使用相同的数据。出于这些原因，我们在从模型分发异步数据时强烈倾向于使用事件。
- en: 'Since we’re already using jQuery, it’s a wise choice to use jQuery global custom
    events as our publishing mechanism. We have created a global custom event plugin
    to provide this capability.^([[5](#ch05fn05)]) jQuery global custom events perform
    well and have the same familiar interface as other jQuery events. Any jQuery collection
    may subscribe to a specific global custom event and invoke a function when it
    occurs. An event often has data associated with it. A `spa-login` event, for example,
    may pass along the freshly updated user object. When an element is removed from
    the document, any function that is subscribed “on” that deleted element is automatically
    removed. [Listing 5.9](#ch05list09) illustrates these concepts. We can open the
    browser document ([spa/spa.html](http://spa/spa.html)), open the JavaScript console,
    and test:'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在使用 jQuery，因此使用 jQuery 全局自定义事件作为发布机制是一个明智的选择。我们已经创建了一个全局自定义事件插件来提供这种功能^([[5](#ch05fn05)])。jQuery
    全局自定义事件性能良好，并且与其他 jQuery 事件具有相同的熟悉界面。任何 jQuery 集合都可以订阅特定的全局自定义事件，并在事件发生时调用一个函数。事件通常与数据相关联。例如，`spa-login`
    事件可能会传递最新的用户对象。当一个元素从文档中移除时，任何订阅在该删除元素上的函数将自动移除。[列表 5.9](#ch05list09) 说明了这些概念。我们可以打开浏览器文档
    ([spa/spa.html](http://spa/spa.html))，打开 JavaScript 控制台，并测试：
- en: ⁵ Prior to version 1.9.0, jQuery supported this natively. Of course, they removed
    it shortly before we went to press just to make our lives more, um, interesting.
  id: totrans-735
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵ 在版本 1.9.0 之前，jQuery 本地支持此功能。当然，他们在我们即将付印之前将其移除，只是为了让我们的生活更有趣。
- en: Listing 5.9\. Use of jQuery global custom events
  id: totrans-736
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.9\. 使用 jQuery 全局自定义事件
- en: '![](ch05list09-0.jpg)'
  id: totrans-737
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](ch05list09-0.jpg)'
- en: '![](ch05list09-1.jpg)'
  id: totrans-738
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](ch05list09-1.jpg)'
- en: '![](155fig01_alt.jpg)'
  id: totrans-739
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](155fig01_alt.jpg)'
- en: If you’re already comfortable with jQuery event handling, this is probably all
    old news, and that’s good news. If not, don’t worry about it too much. Just be
    glad that this behavior is consistent with all other jQuery events. It’s also
    powerful, exceedingly well tested, and leverages the same code as jQuery internal
    methods. *Why learn two event mechanisms when you can use just one?* That’s a
    strong argument for using jQuery global custom events—and a strong argument against
    using a “framework” library that introduces a redundant and subtly different event
    mechanism.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经熟悉 jQuery 事件处理，这可能是老生常谈，但这是个好消息。如果不熟悉，也不要过于担心。只需高兴这种行为与其他所有 jQuery 事件保持一致。它也非常强大，经过充分的测试，并且利用了与
    jQuery 内部方法相同的代码。*为什么要在可以使用一个事件机制的情况下学习两个呢？* 这就是使用 jQuery 全局自定义事件的强大论据——也是反对使用引入冗余且细微不同的事件机制的“框架”库的强大论据。
- en: 5.3.3\. Document the people object API
  id: totrans-741
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.3\. 记录 people 对象 API
- en: 'Let’s now consolidate all of this thinking to a relatively terse format that
    we can put into our Model module for reference. The [Listing 5.10](#ch05list10)
    is a good first attempt:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将所有这些思考整合到一个相对简洁的格式中，我们可以将其放入我们的Model模块以供参考。[列表5.10](#ch05list10)是一个很好的初次尝试：
- en: Listing 5.10\. The people object API
  id: totrans-743
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.10. people对象API
- en: '[PRE47]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now that we’ve completed a specification for the `people` object, let’s build
    it and test the API. After that, we’ll adjust the Shell to use the API so a user
    may sign in and sign out.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为`people`对象完成了一个规范，让我们构建它并测试API。之后，我们将调整Shell以使用API，这样用户就可以登录和登出了。
- en: 5.4\. Build the people object
  id: totrans-746
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4. 构建people对象
- en: Now that we’ve designed the `people` object, we can build it. We’re going to
    use a Fake module to provide mock data to the Model. This will allow us to proceed
    without having a server or feature module in place. Fake is a key enabler of rapid
    development, and we’re going to fake it until we make it.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设计了`people`对象，我们可以开始构建它了。我们将使用Fake模块为Model提供模拟数据。这将使我们能够在没有服务器或功能模块的情况下继续进行。Fake是快速开发的关键推动者，我们将继续模拟直到我们真正实现。
- en: Let’s revisit our architecture and see how Fake can help improve development.
    Our fully implemented architecture is shown in [figure 5.7](#ch05fig07).
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视我们的架构，看看Fake如何能帮助我们提高开发效率。我们的完整实现架构如图5.7所示。[figure 5.7](#ch05fig07)。
- en: Figure 5.7\. The Model in our SPA architecture
  id: totrans-749
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.7. 我们SPA架构中的Model
- en: '![](05fig07_alt.jpg)'
  id: totrans-750
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig07_alt.jpg)'
- en: Well, that’s *nice*, but we can’t get there in one pass. We’d rather develop
    without requiring a web server or a UI. We want to focus on the Model at this
    stage and not be distracted by other modules. We can use the Fake module to emulate
    Data and the server connection, and we can use the JavaScript console to make
    API calls directly instead of using the browser window. [Figure 5.8](#ch05fig08)
    illustrates what modules we need when we develop in this manner.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这很棒，但我们不能一步到位。我们更愿意在没有要求网络服务器或UI的情况下进行开发。我们希望在现阶段专注于Model，不被其他模块分散注意力。我们可以使用Fake模块来模拟数据和服务器连接，并可以使用JavaScript控制台直接进行API调用，而不是使用浏览器窗口。[图5.8](#ch05fig08)说明了我们以这种方式开发时所需的模块。
- en: Figure 5.8\. We use a mock data module called Fake during development
  id: totrans-752
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.8. 我们在开发过程中使用了一个名为Fake的模拟数据模块
- en: '![](05fig08_alt.jpg)'
  id: totrans-753
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig08_alt.jpg)'
- en: Let’s sweep away all the unused code and see what modules are left, as shown
    in [figure 5.9](#ch05fig09).
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们清除所有未使用的代码，看看剩下哪些模块，如图5.9所示。[figure 5.9](#ch05fig09)。
- en: Figure 5.9\. Here are all the modules we use to develop and test our Model
  id: totrans-755
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.9. 这里是我们用于开发和测试Model的所有模块
- en: '![](05fig09_alt.jpg)'
  id: totrans-756
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig09_alt.jpg)'
- en: Through the use of the Fake module and the JavaScript console, we’re able to
    focus solely on the development and testing of the Model. This is especially beneficial
    for a module as important as the Model. *As we progress, we should keep in mind
    that the “backend” is emulated by the Fake module in this chapter.* Now that we’ve
    outlined a development strategy, let’s start work on the Fake module.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用Fake模块和JavaScript控制台，我们能够专注于Model的开发和测试。这对于像Model这样重要的模块特别有益。*随着我们的进展，我们应该记住，在本章中，“后端”是由Fake模块模拟的。*现在我们已经概述了开发策略，让我们开始着手Fake模块的开发。
- en: 5.4.1\. Create a fake people list
  id: totrans-758
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.1. 创建一个模拟的people列表
- en: What we call “real” data is usually sent from the web server to the browser.
    But what if we’re tired and had a long day at work, and don’t have the energy
    for “real” data? That’s all right—sometimes it’s OK to fake it. We discuss how
    to fake data openly and honestly in this section. We hope we’ll provide everything
    you ever wanted to know about fake data but may have been to afraid to ask.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所说的“真实”数据通常是从网络服务器发送到浏览器的。但如果我们工作了一整天，感到疲惫，没有精力处理“真实”数据怎么办？没关系——有时模拟一下是可以的。在本节中，我们将公开、诚实地讨论如何模拟数据。我们希望提供您想知道的所有关于模拟数据的信息，但可能因为害怕而不敢询问。
- en: 'We’ll use a module called Fake during development to provide mock data and
    methods to the application. We’ll set an `isFakeData` flag in our Model to instruct
    it to use the Fake module instead of using “real” web server data and methods
    from the Data module. This enables rapid, focused development that’s independent
    of the server. Because we’ve done a good job outlining how `person` objects are
    going to behave, we should be able to fake our data pretty easily. First we’d
    like to create a method that returns data for a list of fake persons. Let’s fire
    up our text editor and create `spa.fake.getPeopleList` as shown in [listing 5.11](#ch05list11):'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，我们将使用名为 Fake 的模块来为应用程序提供模拟数据和函数。我们将在模型中设置一个`isFakeData`标志，以指示它使用 Fake
    模块而不是使用来自数据模块的“真实”Web 服务器数据和函数。这使我们可以独立于服务器进行快速、专注的开发。因为我们已经很好地概述了`person`对象将如何表现，我们应该能够很容易地伪造我们的数据。首先，我们想创建一个返回假人列表数据的方法。让我们打开我们的文本编辑器并创建`spa.fake.getPeopleList`，如[列表
    5.11](#ch05list11)所示：
- en: Listing 5.11\. Add a mock user list to Fake—spa/js/spa.fake.js
  id: totrans-761
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.11\. 将模拟用户列表添加到 Fake—spa/js/spa.fake.js
- en: '[PRE48]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We introduced the `'use strict'` pragma in this module as shown in **bold**.
    If you’re serious about large-scale JavaScript projects—and we know you are—we
    encourage you to consider using the strict pragma *within a namespace function
    scope*. When in strict mode, JavaScript is more likely to throw exceptions when
    unsafe actions are taken, such as using undeclared global variables. It also disables
    confusing or poorly considered features. Though it’s tempting, *don’t* use the
    strict pragma in the global scope, as it can break the JavaScript of other, lesser
    third-party developers who aren’t as enlightened as you. Now let’s use this fake
    person list in our Model.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个模块中引入了`'use strict'`指令，如**粗体**所示。如果你对大规模 JavaScript 项目认真负责——我们知道你是——我们鼓励你考虑在**命名空间函数作用域**内使用严格指令。在严格模式下，JavaScript
    更有可能在执行不安全操作时抛出异常，例如使用未声明的全局变量。它还禁用了令人困惑或考虑不周的功能。虽然很诱人，**不要**在全局作用域中使用严格指令，因为它可能会破坏其他，不那么有远见的第三方开发者的
    JavaScript，他们不像你那样开明。现在让我们使用这个假人列表在我们的模型中。
- en: 5.4.2\. Start the people object
  id: totrans-764
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.2\. 开始构建人对象
- en: We’ll now start building the `people` object in the Model. When it’s initialized
    (using the `spa.model.initModule()` method), we’ll first create the anonymous
    `person` object using the same `makePerson` constructor as we used to create other
    `person` objects. This ensures that this object has the same methods and attributes
    of other `person` objects regardless of future changes to the constructor.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将开始在模型中构建`people`对象。当它初始化时（使用`spa.model.initModule()`方法），我们将首先使用与创建其他`person`对象相同的`makePerson`构造函数创建匿名`person`对象。这确保了这个对象具有与其他`person`对象相同的方法和属性，无论构造函数的未来变化如何。
- en: 'Next we’ll use the fake people list provided by `spa.fake.getPeopleList()`
    to create a TaffyDB collection of `person` objects. TaffyDB is a JavaScript data
    store designed for use in a browser. It provides many database-style capabilities,
    like selecting an array of objects by matching properties. For example, if we
    have a TaffyDB collection of `person` objects named `people_db`, we might select
    an array of persons with the name of Pebbles like so:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`spa.fake.getPeopleList()`提供的假人列表来创建一个包含`person`对象的 TaffyDB 集合。TaffyDB
    是一个为在浏览器中使用而设计的 JavaScript 数据存储库。它提供了许多数据库式功能，例如通过匹配属性选择对象数组。例如，如果我们有一个名为`people_db`的
    TaffyDB `person`对象集合，我们可以这样选择具有名为 Pebbles 的人的数组：
- en: '[PRE49]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '|  |'
  id: totrans-768
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Why we like TaffyDB**'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么我们喜欢 TaffyDB**'
- en: We like TaffyDB because it’s focused on providing rich data management capabilities
    in the browser, and it doesn’t try to do anything else (like introducing a subtly
    different event model that’s redundant with jQuery). We like to use optimal, focused
    tools like TaffyDB. If, for some reason, we need different data management capabilities,
    we can swap it out with another tool (or write our own) without having to refactor
    our entire application. Please see [http://www.taffydb.com](http://www.taffydb.com)
    for thorough documentation on this handy tool.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 我们喜欢 TaffyDB，因为它专注于在浏览器中提供丰富的数据管理功能，并且它不会尝试做其他任何事情（比如引入一个与 jQuery 冗余的不同的事件模型）。我们喜欢使用像
    TaffyDB 这样的最优、专注的工具。如果出于某种原因，我们需要不同的数据管理功能，我们可以用另一个工具（或自己编写）替换它，而无需重构整个应用程序。请参阅[http://www.taffydb.com](http://www.taffydb.com)以获取关于这个实用工具的详细文档。
- en: '|  |'
  id: totrans-771
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Finally, we’ll export the `people` object so that we can test our API. At this
    time we’ll provide two methods to interact with `person` objects: `spa.model.people.get_db()`
    will return the TaffyDB people collection, and `spa.model.people.get_cid_map()`
    will return a map with the client IDs as the keys. Let’s fire up the trusty text
    editor and start our Model as shown in [listing 5.12](#ch05list12). This is just
    our first pass, so don’t feel you have to understand everything yet:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将导出 `people` 对象，以便我们可以测试我们的 API。在此阶段，我们将提供两种与 `person` 对象交互的方法：`spa.model.people.get_db()`
    将返回 TaffyDB 人员集合，而 `spa.model.people.get_cid_map()` 将返回一个以客户端 ID 为键的映射。让我们启动信任的文本编辑器并开始我们的模型，如
    [列表 5.12](#ch05list12) 所示。这只是我们的第一次尝试，所以不要觉得你必须现在就理解一切：
- en: Listing 5.12\. Start building the Model—spa/js/spa.model.js
  id: totrans-773
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.12\. 开始构建模型—spa/js/spa.model.js
- en: '![](ch05list12-0.jpg)'
  id: totrans-774
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch05list12-0.jpg)'
- en: '![](ch05list12-1.jpg)'
  id: totrans-775
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch05list12-1.jpg)'
- en: 'Of course, nothing calls `spa.model.initModule()` yet. Let’s fix that by updating
    our root namespace module, spa/js/spa.js, as shown in [listing 5.13](#ch05list13):'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还没有调用 `spa.model.initModule()`。让我们通过更新我们的根命名空间模块 spa/js/spa.js 来修复它，如 [列表
    5.13](#ch05list13) 所示：
- en: Listing 5.13\. Add Model initialization to root namespace module—spa/js/spa.js
  id: totrans-777
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.13\. 将模型初始化添加到根命名空间模块—spa/js/spa.js
- en: '![](162fig01_alt.jpg)'
  id: totrans-778
  prefs: []
  type: TYPE_IMG
  zh: '![图片](162fig01_alt.jpg)'
- en: 'Now let’s load our browser document ([spa/spa.html](http://spa/spa.html)) to
    make sure that the page works as before—if it does *not* or there are errors in
    the console, we did something wrong and should retrace our steps to here. Although
    it might look the same, under the hood the code is working differently. Let’s
    open the Chrome Developer Tools JavaScript console to test the `people` API. We
    can get the people collection and explore some of the benefits of TaffyDB as shown
    in [listing 5.14](#ch05list14). Typed input is shown in **bold**; output is shown
    in *italics*:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们加载我们的浏览器文档 ([spa/spa.html](http://spa/spa.html))，以确保页面与之前一样工作——如果它没有工作或控制台中有错误，我们做错了什么，应该回溯到这一步。尽管它可能看起来一样，但底层代码正在以不同的方式工作。让我们打开
    Chrome 开发者工具 JavaScript 控制台来测试 `people` API。我们可以获取人员集合并探索 TaffyDB 的一些好处，如 [列表
    5.14](#ch05list14) 所示。类型输入以 **粗体** 显示；输出以 *斜体* 显示：
- en: Listing 5.14\. Playing with fake people and liking it
  id: totrans-780
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.14\. 与模拟人员互动并喜欢它
- en: '![](ch05list14-0.jpg)'
  id: totrans-781
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch05list14-0.jpg)'
- en: '![](ch05list14-1.jpg)'
  id: totrans-782
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch05list14-1.jpg)'
- en: This testing shows that we’ve been successful in building part of the `people`
    object. In the next section we’ll finish the job.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 这项测试表明，我们已经成功构建了 `people` 对象的一部分。在下一节中，我们将完成这项工作。
- en: 5.4.3\. Finish the people object
  id: totrans-784
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.3\. 完成人员对象
- en: We need to update both the Model and the Fake modules to ensure the `people`
    object API meets the specifications we wrote earlier. Let’s update the Model first.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更新模型和 Fake 模块，以确保 `people` 对象 API 符合我们之前编写的规范。让我们先更新模型。
- en: Update the Model
  id: totrans-786
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 更新模型
- en: 'We want our `people` object to fully support the concept of a `user`. Let’s
    consider the new methods we’ll need to add:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望 `people` 对象完全支持 `user` 的概念。让我们考虑我们需要添加的新方法：
- en: '`login( <user_name> )` will start the sign-in process. We’ll need to create
    a new `person` object and add it to the people list. When the sign-in process
    is complete, we’ll emit an `spa-login` event that publishes the current user object
    as data.'
  id: totrans-788
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`login( <用户名> )` 将启动登录过程。我们需要创建一个新的 `person` 对象并将其添加到人员列表中。当登录过程完成后，我们将发出一个
    `spa-login` 事件，该事件将当前用户对象作为数据发布。'
- en: '`logout()` will start the sign-out process. When a user signs out, we’ll delete
    the user `person` object from the people list. When the sign-out process is complete,
    we’ll emit an `spa-logout` event with the prior user object as data.'
  id: totrans-789
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logout()` 将启动登出过程。当用户登出时，我们将从人员列表中删除用户 `person` 对象。当登出过程完成后，我们将发出一个带有先前用户对象作为数据的
    `spa-logout` 事件。'
- en: '`get_user()` will return the current user `person` object. If someone has not
    signed in, the user object will be the anonymous `person` object. We’ll use a
    module state variable (`stateMap.user`) to store the current user `person` object.'
  id: totrans-790
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_user()` 将返回当前用户 `person` 对象。如果有人尚未登录，用户对象将是匿名 `person` 对象。我们将使用模块状态变量
    (`stateMap.user`) 来存储当前用户 `person` 对象。'
- en: 'We need to add a number of other capabilities to support these methods:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加其他一些功能来支持这些方法：
- en: Because we’ll be using a Socket.IO connection to send and receive messages to
    the Fake module, we’ll use a mock `sio` object in the `login( <user_name> )` method.
  id: totrans-792
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们将使用 Socket.IO 连接向 Fake 模块发送和接收消息，因此我们将在 `login( <用户名> )` 方法中使用模拟的 `sio`
    对象。
- en: Because we’ll be creating a new `person` object with `login( <username> )`,
    we’ll use the `makeCid()` method to create a client ID for the signed-in user.
    We’ll use a module state variable (`stateMap.cid_serial`) to store a serial number
    used to create this ID.
  id: totrans-793
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们将使用 `login( <username> )` 创建一个新的 `person` 对象，我们将使用 `makeCid()` 方法为已登录用户创建一个客户端
    ID。我们将使用模块状态变量 (`stateMap.cid_serial`) 来存储创建此 ID 所使用的序列号。
- en: Because we’ll be removing the user `person` object from the people list, we’ll
    need a method to remove a user. We’ll use a `removePerson( <client_id> )` method
    to do this.
  id: totrans-794
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们将从人员列表中移除用户 `person` 对象，我们需要一个方法来移除用户。我们将使用 `removePerson( <client_id> )`
    方法来完成这个操作。
- en: Because the sign-in process is asynchronous (it only completes when the Fake
    module returns a `userupdate` message), we’ll use a `completeLogin` method to
    finish the process.
  id: totrans-795
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于登录过程是异步的（它只在假模块返回 `userupdate` 消息时完成），我们将使用 `completeLogin` 方法来完成这个过程。
- en: 'Let’s update the Model with these changes as shown in [listing 5.15](#ch05list15).
    All changes are shown in **bold**:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照 [列表 5.15](#ch05list15) 中的说明更新模型。所有更改都以 **粗体** 显示：
- en: Listing 5.15\. Finish the `people` object of the Model—spa/js/spa.model.js
  id: totrans-797
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.15\. 完成模型中的 `people` 对象——spa/js/spa.model.js
- en: '![](ch05list15-0.jpg)'
  id: totrans-798
  prefs: []
  type: TYPE_IMG
  zh: '![](ch05list15-0.jpg)'
- en: '![](ch05list15-1.jpg)'
  id: totrans-799
  prefs: []
  type: TYPE_IMG
  zh: '![](ch05list15-1.jpg)'
- en: Now that we’ve updated the Model, we can proceed with the Fake module.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经更新了模型，我们可以继续进行假模块的更新。
- en: Update the Fake Module
  id: totrans-801
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 更新假模块
- en: 'Our Fake module needs to be updated to provide a mock Socket.IO connection
    object, `sio`. We want this to emulate the capabilities we need to sign in and
    sign out:'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的假模块需要更新以提供模拟 Socket.IO 连接对象 `sio`。我们希望它能够模拟我们需要的登录和登出功能：
- en: The mock `sio` object must provide the ability to register callbacks for a message.
    We only need to support a callback for a single message, `userupdate`, to test
    sign-in and sign-out. In the Model we register the `completeLogin` method for
    this message.
  id: totrans-803
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟的 `sio` 对象必须提供注册消息回调的能力。我们只需要支持单个消息 `userupdate` 的回调来测试登录和登出。在模型中，我们为此消息注册了
    `completeLogin` 方法。
- en: When a user signs in, the mock `sio` object will receive an `adduser` message
    from the Model along with the a map of user data as its argument. We emulate a
    server response by waiting three seconds and then executing the `userupdate` callback.
    We purposely delay this response so we might spot any race conditions in the sign-in
    process.
  id: totrans-804
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户登录时，模拟的 `sio` 对象将从模型接收到一个 `adduser` 消息，以及一个包含用户数据的映射作为其参数。我们通过等待三秒钟然后执行 `userupdate`
    回调来模拟服务器响应。我们故意延迟这个响应，以便我们可能发现登录过程中的任何竞争条件。
- en: We don’t need to worry about sign-out with the mock `sio` object just yet, as
    the Model currently handles that condition.
  id: totrans-805
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前我们不需要担心使用模拟的 `sio` 对象进行登出，因为模型目前处理这个条件。
- en: 'Let’s update the Fake module with these changes as shown in [listing 5.16](#ch05list16).
    All changes are shown in **bold**:'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照 [列表 5.16](#ch05list16) 中的说明更新假模块。所有更改都以 **粗体** 显示：
- en: Listing 5.16\. Add a mock socket object with latency to Fake—spa/js/spa.fake.js
  id: totrans-807
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.16\. 在假数据中添加带有延迟的模拟套接字对象——spa/js/spa.fake.js
- en: '![](ch05list16-0.jpg)'
  id: totrans-808
  prefs: []
  type: TYPE_IMG
  zh: '![](ch05list16-0.jpg)'
- en: '![](ch05list16-1.jpg)'
  id: totrans-809
  prefs: []
  type: TYPE_IMG
  zh: '![](ch05list16-1.jpg)'
- en: Now that we’ve completed updating the Model and Fake, we can test sign-in and
    sign-out.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了模型和假数据的更新，我们可以测试登录和登出了。
- en: 5.4.4\. Test the people object API
  id: totrans-811
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.4\. 测试人员对象 API
- en: As we planned, isolating the Model allows us to test the sign-in and sign-out
    process without the time and expense of setting up a server or preparing a UI.
    Beyond the saved expense, it ensures higher quality because our test results aren’t
    distorted by interface or data bugs, and we’re testing a known data set. This
    method also allows us to proceed without needing other development groups to complete
    their components.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们计划的那样，隔离模型使我们能够在不设置服务器或准备用户界面的时间和成本的情况下测试登录和登出过程。除了节省成本之外，它还确保了更高的质量，因为我们的测试结果不会受到接口或数据错误的扭曲，并且我们在测试已知的数据集。这种方法还允许我们在不需要其他开发小组完成其组件的情况下继续进行。
- en: 'Let’s load our browser document ([spa/spa.html](http://spa/spa.html)) to ensure
    the application works as before. We can then open the JavaScript console and test
    the `login`, `logout`, and other methods as shown in [listing 5.17](#ch05list17).
    Typed input is shown in **bold**; output is shown in *italics*:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们加载我们的浏览器文档 ([spa/spa.html](http://spa/spa.html)) 来确保应用程序像以前一样工作。然后我们可以打开
    JavaScript 控制台并测试 `login`、`logout` 和其他方法，如 [列表 5.17](#ch05list17) 所示。输入的文本以 **粗体**
    显示；输出以 *斜体* 显示：
- en: Listing 5.17\. Test sign-in and sign-out using the JavaScript console
  id: totrans-814
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.17\. 使用 JavaScript 控制台测试登录和登出
- en: '![](ch05list17-0.jpg)'
  id: totrans-815
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10](ch05list17-0.jpg)'
- en: '![](ch05list17-1.jpg)'
  id: totrans-816
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10](ch05list17-1.jpg)'
- en: This testing is reassuring. We’ve shown that the `people` object does a good
    job of meeting its goals. We can sign in and sign out and the Model behaves as
    defined. And because the Model doesn’t require a UI or a server, it’s easy to
    create a test suite to ensure all methods meet their design specification. This
    suite can be run without a browser by using jQuery with Node.js. See [appendix
    B](kindle_split_023.html#app02) for a review of how this can be accomplished.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 这项测试令人放心。我们已经证明 `people` 对象很好地实现了其目标。我们可以登录和注销，并且模型的行为符合定义。而且由于模型不需要 UI 或服务器，因此很容易创建一个测试套件来确保所有方法都符合其设计规范。这个套件可以通过使用
    jQuery 和 Node.js 在没有浏览器的情况下运行。请参阅[附录 B](kindle_split_023.html#app02)，了解如何实现这一点。
- en: This might be a good time to take a break. In the next section we’ll update
    our interface so the user may sign in and sign out.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一个休息的好时机。在下一节中，我们将更新我们的界面，以便用户可以登录和注销。
- en: 5.5\. Enable sign-in and sign-out in the Shell
  id: totrans-819
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5\. 在 Shell 中启用登录和注销
- en: 'Up to this point we’ve isolated our Model development from the UI as shown
    in [figure 5.10](#ch05fig10):'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经将模型开发与 UI 隔离，如图 5.10 所示：
- en: Figure 5.10\. Testing the Model using the JavaScript console
  id: totrans-821
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.10\. 使用 JavaScript 控制台测试模型
- en: '![](05fig10_alt.jpg)'
  id: totrans-822
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10](05fig10_alt.jpg)'
- en: Now that we’ve tested the Model thoroughly, we want a user to sign in and sign
    out through the UI instead of the JavaScript console. We’ll now employ the Shell
    to do just that, as shown in [figure 5.11](#ch05fig11).
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经彻底测试了模型，我们希望用户通过 UI 而不是 JavaScript 控制台进行登录和注销。我们现在将使用 Shell 来实现这一点，如图
    5.11 所示。
- en: Figure 5.11\. In this section we add a graphical sign-in capability to the Shell
  id: totrans-824
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.11\. 在本节中，我们向 Shell 添加图形登录功能
- en: '![](05fig11_alt.jpg)'
  id: totrans-825
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10](05fig11_alt.jpg)'
- en: Of course, before we can build the UI, we must agree on how it should work.
    We’ll do that next.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在我们能够构建 UI 之前，我们必须就其工作方式达成一致。我们将在下一节中这样做。
- en: 5.5.1\. Design the user sign-in experience
  id: totrans-827
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.1\. 设计用户登录体验
- en: We’d like to keep the user experience simple and familiar. As is the popular
    convention, we’d like the user to click on the top-right of the page to begin
    the sign-in process. The steps we envision are illustrated in [figure 5.12](#ch05fig12).
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望保持用户体验简单且熟悉。按照流行的惯例，我们希望用户点击页面右上角开始登录过程。我们设想的步骤如图 5.12 所示。
- en: Figure 5.12\. The sign-in process as seen by the user
  id: totrans-829
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.12\. 用户看到的登录过程
- en: '![](05fig12_alt.jpg)'
  id: totrans-830
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10](05fig12_alt.jpg)'
- en: If the user isn’t signed in, the top-right area (the “user area”) will prompt
    *Please Sign-in*. When the user clicks on this text, a sign-in dialog will appear.
  id: totrans-831
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户未登录，右上角（“用户区域”）将提示“请登录”。当用户点击此文本时，将出现登录对话框。
- en: Once the user completes the dialog form and clicks on the OK button, the sign-in
    processing begins.
  id: totrans-832
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦用户完成对话框表单并点击“确定”按钮，登录处理就开始了。
- en: The sign-in dialog is removed, and the user area shows *... processing ...*
    while the sign-in is underway (our Fake module always takes three seconds for
    this step).
  id: totrans-833
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录对话框被移除，用户区域在登录过程中显示“...处理中...”（我们的 Fake 模块总是需要三秒钟来完成这一步骤）。
- en: Once the sign-in process is complete, the user area shows the name of the signed-in
    user.
  id: totrans-834
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦登录过程完成，用户区域将显示已登录用户的姓名。
- en: A signed-in user may sign out by clicking on the user area. This will revert
    the text back to *Please Sign-in*.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 已登录用户可以通过点击用户区域来注销。这将文本恢复为“请登录”。
- en: Now that we have the user experience designed, we can update the Shell to make
    it happen.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设计了用户体验，我们可以更新 Shell 来实现它。
- en: 5.5.2\. Update the Shell JavaScript
  id: totrans-837
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.2\. 更新 Shell JavaScript
- en: 'Because we put all of our data handling and logic into our Model, we can have
    the Shell handle the view and control roles only. While we’re under the hood,
    as they say, we can also easily add support for touch devices (such as tablets
    and mobile phones). Let’s modify the Shell as shown in [listing 5.18](#ch05list18).
    Changes are shown in **bold**:'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们把所有数据处理和逻辑都放在了我们的模型中，所以 Shell 只需处理视图和控制角色。正如他们所说，我们还可以轻松添加对触摸设备（如平板电脑和手机）的支持。让我们按照[列表
    5.18](#ch05list18)所示修改 Shell。更改以粗体显示：
- en: Listing 5.18\. Update the Shell to add sign-in—spa/js/spa.shell.js
  id: totrans-839
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.18\. 更新 Shell 以添加登录—spa/js/spa.shell.js
- en: '![](ch05list18-0.jpg)'
  id: totrans-840
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10](ch05list18-0.jpg)'
- en: '![](ch05list18-1.jpg)'
  id: totrans-841
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10](ch05list18-1.jpg)'
- en: The changes we made are easy to understand once we’re comfortable with the publish-subscribe
    nature of jQuery global custom events. Now let’s tweak the CSS to show our user
    area correctly.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们熟悉了 jQuery 全局自定义事件的发布-订阅特性，我们做出的更改就很容易理解了。现在让我们调整 CSS，以正确显示用户区域。
- en: 5.5.3\. Update the Shell stylesheet
  id: totrans-843
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.3\. 更新 Shell 样式表
- en: 'Our stylesheet changes aren’t anything fancy. We add or modify a few selectors
    to make the user area look nice, and we clean up some cruft along the way. [Listing
    5.19](#ch05list19) shows the changes we need in **bold**:'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的样式表更改并不复杂。我们添加或修改了一些选择器，使用户区域看起来更美观，并在过程中清理了一些冗余。[列表 5.19](#ch05list19) 显示了我们需要在
    **粗体** 中进行的更改：
- en: Listing 5.19\. Add styles for user area in the Shell stylesheet—spa/css/spa.shell.css
  id: totrans-845
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.19\. 在 Shell 样式表中添加用户区域样式—spa/css/spa.shell.css
- en: '![](ch05list19-0.jpg)'
  id: totrans-846
  prefs: []
  type: TYPE_IMG
  zh: '![](ch05list19-0.jpg)'
- en: '![](ch05list19-1.jpg)'
  id: totrans-847
  prefs: []
  type: TYPE_IMG
  zh: '![](ch05list19-1.jpg)'
- en: Now with our CSS in place, let’s test the changes.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了 CSS，让我们测试一下这些更改。
- en: 5.5.4\. Test sign-in and sign-out using the UI
  id: totrans-849
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.4\. 使用 UI 测试登录和登出
- en: When we load our browser document ([spa/spa.html](http://spa/spa.html)), we
    should see a page with “Please sign in” in the user area in the top-right of the
    window. When we click on this, we should be presented with a dialog as shown in
    [figure 5.13](#ch05fig13).
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们加载浏览器文档 ([spa/spa.html](http://spa/spa.html)) 时，我们应该在窗口右上角的用户区域看到一个“请登录”的页面。当我们点击这个按钮时，我们应该看到一个如图
    [图 5.13](#ch05fig13) 所示的对话框。
- en: Figure 5.13\. Screenshot of sign-in dialog
  id: totrans-851
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.13\. 登录对话框截图
- en: '![](05fig13.jpg)'
  id: totrans-852
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig13.jpg)'
- en: Once we enter a user name and click OK, the dialog should close and we should
    see “... processing ...”^([[6](#ch05fn06)]) for three seconds in the user area,
    after which the `spa-login` event should be published. The handler in the Shell
    subscribed to this event should then update the user name in the upper-right of
    the window, as shown in [figure 5.14](#ch05fig14).
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们输入用户名并点击“确定”，对话框应该关闭，我们将在用户区域看到“...处理中...”^([[6](#ch05fn06)]) 三秒钟，之后应该发布
    `spa-login` 事件。Shell 中订阅此事件的处理器应该更新窗口右上角的用户名，如图 [图 5.14](#ch05fig14) 所示。
- en: ⁶ Before we went public with the site, we’d probably use a nice “in-progress”
    animated graphic instead of the text. A number of web sites provide quality custom
    in-progress graphics for free.
  id: totrans-854
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶ 在我们公开网站之前，我们可能会使用一个漂亮的“进行中”动画图形来代替文本。许多网站提供免费的高质量自定义“进行中”图形。
- en: Figure 5.14\. Screenshot after completion of sign-in
  id: totrans-855
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.14\. 登录完成后的截图
- en: '![](05fig14.jpg)'
  id: totrans-856
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig14.jpg)'
- en: We ensure a good experience by keeping the user apprised of what’s happening
    throughout the process. This is a hallmark of good design—consistently providing
    immediate feedback can make even a relatively slow application seem snappy and
    responsive.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在整个过程中让用户了解正在发生的事情，我们确保了良好的用户体验。这是良好设计的标志——始终如一地提供即时反馈可以使即使是相对较慢的应用程序看起来更加敏捷和响应。
- en: 5.6\. Summary
  id: totrans-858
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6\. 总结
- en: In this chapter we introduced the Model and discussed how it fits into our architecture.
    We outlined what the Model should and should *not* do. We then set up the files
    required to build and test the Model.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了模型，并讨论了它如何融入我们的架构。我们概述了模型应该做什么以及不应该做什么。然后我们设置了构建和测试模型所需的文件。
- en: We designed, specified, developed, and tested one part of the Model—the `people`
    object. We used a Fake module to provide a controlled data set to the Model, and
    we used the JavaScript console to test the `people` object API. Isolating the
    Model in this way resulted in faster development and more controlled testing.
    We also modified our SPA to use a mouse-touch plugin so that mobile users may
    use it.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计、指定、开发和测试了模型的一部分——`people` 对象。我们使用 Fake 模块为模型提供受控的数据集，并使用 JavaScript 控制台测试
    `people` 对象 API。以这种方式隔离模型导致了更快的开发和更受控的测试。我们还修改了我们的 SPA，以使用鼠标触摸插件，以便移动用户可以使用它。
- en: In the final section we modified the Shell to present the sign-in and sign-out
    capabilities to the user. We used the API provided by the `people` object to provide
    this capability. We also ensured a positive user experience by having our SPA
    provide feedback immediately after user input.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我们修改了 Shell，向用户展示了登录和登出功能。我们使用了 `people` 对象提供的 API 来实现这一功能。我们还确保了通过我们的单页应用（SPA）在用户输入后立即提供反馈，从而保证了良好的用户体验。
- en: In the next chapter, we’ll add the `chat` object to the Model. This will allow
    us to complete the Chat feature module and create an Avatar feature module. Then
    we’ll prepare the client to work with a real web server.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将向模型添加 `chat` 对象。这将使我们能够完成聊天功能模块并创建头像功能模块。然后，我们将准备客户端以与真实网络服务器一起工作。
- en: Chapter 6\. Finish the Model and Data modules
  id: totrans-863
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 6 章. 完成模型和数据模块
- en: '|  |'
  id: totrans-864
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**This chapter covers**'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Designing the `chat` object portion of the Model
  id: totrans-866
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计模型中的 `chat` 对象部分
- en: Implementing the `chat` object and testing its API
  id: totrans-867
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `chat` 对象并测试其 API
- en: Completing the Chat feature module
  id: totrans-868
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成聊天功能模块
- en: Creating a new Avatar feature module
  id: totrans-869
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的头像功能模块
- en: Using jQuery for data binding
  id: totrans-870
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 jQuery 进行数据绑定
- en: Communicating with the server using the Data module
  id: totrans-871
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据模块与服务器通信
- en: '|  |'
  id: totrans-872
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This chapter concludes the work on the Model and feature modules begun in [chapter
    5](kindle_split_016.html#ch05). Before starting, you should have the project files
    from [chapter 5](kindle_split_016.html#ch05), as we’ll be adding to them. We recommend
    you copy the entire directory structure you created in [chapter 5](kindle_split_016.html#ch05)
    into a “chapter_6” directory and update them there.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 本章完成了在第 5 章开始的工作，即模型和功能模块。在开始之前，你应该拥有第 5 章的项目文件[kindle_split_016.html#ch05]，因为我们将在其基础上添加内容。我们建议你将第
    5 章中创建的整个目录结构复制到“chapter_6”目录中，并在那里更新它们。
- en: In this chapter we design and build the `chat` object portion of the Model.
    We then complete the Chat slider UI by having it use and respond to the `chat`
    object API. We also add an Avatar feature module which also uses the `chat` object
    API to display on-screen representations of online people. We discuss how we accomplish
    data binding using jQuery. Finally, we complete the client portion of the SPA
    with the addition of the Data module.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们设计并构建了模型中的 `chat` 对象部分。然后，通过使其使用并响应 `chat` 对象 API 来完成聊天滑块 UI。我们还添加了一个头像功能模块，它也使用
    `chat` 对象 API 来显示在线人员的屏幕表示。我们讨论了如何使用 jQuery 实现数据绑定。最后，我们通过添加数据模块来完成 SPA 的客户端部分。
- en: Let’s start by designing the `chat` object.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从设计 `chat` 对象开始。
- en: 6.1\. Design the chat object
  id: totrans-876
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1\. 设计聊天对象
- en: In this chapter we will build the `chat` object portion of the Model as shown
    in [figure 6.1](#ch06fig01).
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建模型中的 `chat` 对象部分，如图 6.1[第 6 章](#ch06fig01)所示。
- en: Figure 6.1\. We’ll work the Model’s `chat` object in this chapter
  id: totrans-878
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.1\. 我们将在本章中处理模型的 `chat` 对象
- en: '![](06fig01_alt.jpg)'
  id: totrans-879
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig01_alt.jpg)'
- en: 'In the last chapter we designed, built, and tested the `people` object portion
    of the Model. In this chapter we’ll design, build, and test the `chat` object.
    Let’s revisit the API specification we first presented in [chapter 4](kindle_split_015.html#ch04):'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们设计了、构建并测试了模型中的 `people` 对象部分。在这一章中，我们将设计、构建并测试 `chat` 对象。让我们回顾一下我们在第
    4 章首次提出的 API 规范[第 4 章](kindle_split_015.html#ch04)：
- en: '[PRE50]'
  id: totrans-881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The description provided for the `chat` object—“an object that provides methods
    to interact with our instant messaging”—is a good start but too broad for implementation.
    Let’s design the `chat` object by first analyzing what we’d like it to accomplish.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 提供给 `chat` 对象的描述——“一个提供与即时通讯交互的方法的对象”——是一个良好的开端，但对于实现来说过于宽泛。让我们首先通过分析我们希望它实现什么来设计
    `chat` 对象。
- en: 6.1.1\. Design methods and events
  id: totrans-883
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.1\. 设计方法和事件
- en: We know we want the `chat` object to provide instant messaging capabilities,
    but we need to determine what those capabilities are in detail. Let’s consider
    [figure 6.2](#ch06fig02), which shows a mockup of the SPA with some notes about
    our chat interface.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们希望 `chat` 对象提供即时通讯功能，但我们需要详细确定这些功能是什么。让我们考虑[图 6.2](#ch06fig02)，它显示了带有关于我们聊天界面一些注释的
    SPA 模拟。
- en: Figure 6.2\. A mockup of our SPA—chat focus
  id: totrans-885
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.2\. 我们单页应用（SPA）的模拟——聊天焦点
- en: '![](06fig02_alt.jpg)'
  id: totrans-886
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig02_alt.jpg)'
- en: 'We know from experience that we’ll probably need to initialize a chat room.
    We also expect that the user may change the *chatee* (the person with whom they’re
    chatting), and may send messages to this person. And from our discussion about
    avatars, we know the user may update avatar information. The user won’t be the
    only source driving the UI, as we expect other people to join and leave the chat
    room, send and receive messages, and change avatar information. Based on this
    analysis, we can list the capabilities that we need to be exposed by the `chat`
    object API:'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 根据经验，我们知道我们可能需要初始化一个聊天室。我们还预计用户可能会更改*聊天对象*（他们正在与之聊天的人），并可能向这个人发送消息。根据我们对头像的讨论，我们知道用户可能会更新头像信息。用户不会是唯一驱动UI的来源，因为我们预计其他人会加入和离开聊天室，发送和接收消息，以及更改头像信息。基于这种分析，我们可以列出需要通过`chat`对象API公开的能力：
- en: Provide methods to join or leave a chat room.
  id: totrans-888
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供加入或离开聊天室的方法。
- en: Provide a method to change the chatee.
  id: totrans-889
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个方法来更改聊天对象。
- en: Provide a method to send messages to other people.
  id: totrans-890
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个方法向其他人发送消息。
- en: Provide a method to tell the server that an avatar has been updated by the user.
  id: totrans-891
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个方法告诉服务器用户已更新头像。
- en: Publish an event if the chatee is changed for any reason. For example, if the
    chatee goes offline or a new chatee is selected by the user.
  id: totrans-892
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果聊天对象因任何原因更改，发布一个事件。例如，如果聊天对象离线或用户选择了新的聊天对象。
- en: Publish an event when the message pane needs to change for any reason. For example,
    if the user sends or receives a message.
  id: totrans-893
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当消息面板需要因任何原因更改时，发布一个事件。例如，如果用户发送或接收消息。
- en: Publish an event if the list of online persons changes for any reason. For example,
    if a person joins or leaves the chat room, or if an avatar is moved by any user.
  id: totrans-894
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在线人员列表因任何原因发生变化，发布一个事件。例如，如果有人加入或离开聊天室，或者如果某个用户的头像被移动。
- en: Our `chat` object API will use two channels of communication. One channel is
    the classic method-return-value mechanism. This channel is *synchronous*—the data
    transfer happens in a known sequence. The `chat` object may invoke external methods
    and receive information as return values. And other code may invoke the `chat`
    object’s public methods and receive information from the return values.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`chat`对象API将使用两个通信通道。一个通道是经典的方法-返回值机制。这个通道是**同步**的——数据传输按照已知的顺序进行。`chat`对象可以调用外部方法并接收返回值。其他代码可以调用`chat`对象的公共方法并从返回值中获取信息。
- en: The other channel of communication that will be used by the chat object is the
    event mechanism. This channel is *asynchronous*—events may happen at any time
    regardless of the actions of the `chat` object. The `chat` object will receive
    events (like messages from the server) and publish events for use by the UI.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天对象将使用的另一个通信通道是事件机制。这个通道是**异步**的——事件可能在任何时间发生，无论`chat`对象的操作如何。`chat`对象将接收事件（如来自服务器的消息）并为UI发布事件。
- en: Let’s start designing the `chat` object by first considering the synchronous
    methods we will provide.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先考虑我们将提供的同步方法，开始设计`chat`对象。
- en: Design Chat Methods
  id: totrans-898
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设计聊天方法
- en: 'As we discussed in [chapter 5](kindle_split_016.html#ch05), a method is a publicly
    exposed function, like `spa.model`**.chat.get_chatee**, which can be used to perform
    an action and return data synchronously. Given our requirements, this list of
    methods seems about right:'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第5章](kindle_split_016.html#ch05)中讨论的那样，方法是一个公开暴露的函数，如`spa.model.chat.get_chatee`，它可以用来执行操作并同步返回数据。根据我们的要求，这个方法列表似乎是合适的：
- en: '`join()`—Join the chat. If the user is anonymous, this method should abort
    and return `false`.'
  id: totrans-900
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`join()`——加入聊天。如果用户是匿名的，则此方法应终止并返回`false`。'
- en: '`get_chatee()`—Return the `person` object of the user with whom we’re chatting.
    If there’s no chatee, return `null`.'
  id: totrans-901
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_chatee()`——返回我们正在与之聊天的人的`person`对象。如果没有聊天对象，则返回`null`。'
- en: '`set_chatee( <person_id> )`—Set the chatee to the `person` object uniquely
    identified by `person_id`. This method should publish an `spa-setchatee` event
    with chatee information provided as data. If a matching `person` object can’t
    be found in the collection of online people, set the chatee to `null`. If the
    requested person is already the chatee, return `false`.'
  id: totrans-902
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_chatee( <person_id> )`——将聊天对象设置为唯一由`person_id`标识的`person`对象。此方法应发布一个包含聊天对象信息的`spa-setchatee`事件。如果在在线人员集合中找不到匹配的`person`对象，则将聊天对象设置为`null`。如果请求的人已经是聊天对象，则返回`false`。'
- en: '`send_message( <msg_text> )`—Send a message to the chatee. We should publish
    an `spa-updatechat` event with message information provided as data. If the user
    is anonymous or the chatee is `null`, this method should take no action and return
    `false`.'
  id: totrans-903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`send_message( <msg_text> )`—向聊天对象发送消息。我们应该发布一个包含消息信息的`spa-updatechat`事件作为数据。如果用户是匿名或聊天对象为`null`，此方法不应采取任何操作并返回`false`。'
- en: '`update_avatar( <update_avatar_map> )`—Adjust avatar information for a `person`
    object. The argument (`update_avatar_map`) should include the properties `person_id`
    and `css_map`.'
  id: totrans-904
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update_avatar( <update_avatar_map> )`—调整`person`对象的头像信息。参数（`update_avatar_map`）应包括`person_id`和`css_map`属性。'
- en: These methods appear to meet our requirements. Now let’s consider in more detail
    the events that the `chat` object should publish.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法似乎符合我们的要求。现在让我们更详细地考虑`chat`对象应该发布的事件。
- en: Design Chat Events
  id: totrans-906
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设计聊天事件
- en: As we discussed earlier, events are used to publish data asynchronously. For
    example, if a message is received, the `chat` object will need to notify subscribed
    jQuery collections of the change and provide the data necessary to update the
    presentation.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，事件用于异步发布数据。例如，如果收到消息，`chat`对象需要通知订阅的jQuery集合更改，并提供更新展示所需的数据。
- en: 'We expect that the collection of online people, and the chatee, will change
    often. These changes won’t always be due to the user’s actions—for example, a
    chatee may send a message at any time. Here are the events that should communicate
    these changes to the feature modules:'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 我们预计在线人员集合和聊天对象会经常变化。这些变化不一定是由用户的行为引起的——例如，聊天对象可能随时发送消息。以下是应将这些更改通知给功能模块的事件：
- en: '`spa-listchange` should be published when the list of online people changes.
    An updated people collection should be provided as data.'
  id: totrans-909
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在线人员列表更改时，应发布`spa-listchange`。应提供更新的人员集合作为数据。
- en: '`spa-setchatee` should be published when the chatee changes. A map of the old
    and new chatee should be provided as data'
  id: totrans-910
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当聊天对象更改时，应发布`spa-setchatee`。应提供包含旧聊天对象和新聊天对象的映射作为数据。
- en: '`spa-updatechat` should be published when a new message is sent or received.
    A map of message information should be provided as data.'
  id: totrans-911
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当发送或接收新消息时，应发布`spa-updatechat`。应提供包含消息信息的映射作为数据。
- en: As we did in [chapter 5](kindle_split_016.html#ch05), we’ll use jQuery global
    events as our publishing mechanism. Now that we’ve thought through the methods
    and events we will need, let’s proceed to documentation and implementation.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第5章](kindle_split_016.html#ch05)中所做的那样，我们将使用jQuery全局事件作为我们的发布机制。现在我们已经考虑了我们需要的方法和事件，让我们继续进行文档和实现。
- en: 6.1.2\. Document the chat object API
  id: totrans-913
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.2\. 记录聊天对象API
- en: Let’s consolidate our plans into an API specification that we can place into
    the Model code for reference.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的计划整合成一个API规范，我们可以将其放入模型代码中供参考。
- en: Listing 6.1\. The `chat` object API—spa/js/spa.model.js
  id: totrans-915
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.1\. `chat`对象API—spa/js/spa.model.js
- en: '[PRE51]'
  id: totrans-916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now that we’ve completed a specification for the `chat` object, let’s implement
    it and test the API. After that, we’ll adjust the Shell and the feature modules
    to use the `chat` object API to provide new capabilities.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了`chat`对象的规范，让我们实现它并测试API。之后，我们将调整Shell和功能模块以使用`chat`对象API提供新的功能。
- en: 6.2\. Build the chat object
  id: totrans-918
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2\. 构建聊天对象
- en: Now that we’ve designed the `chat` object API we can build it. As in [chapter
    5](kindle_split_016.html#ch05), we’re going to use the Fake module and the JavaScript
    console to avoid the use of a web server or a UI. *As we progress, we should keep
    in mind that the “backend” is emulated by the Fake module in this chapter.*
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设计了`chat`对象API，我们可以构建它。正如[第5章](kindle_split_016.html#ch05)中所述，我们将使用假模块和JavaScript控制台来避免使用Web服务器或UI。*随着我们的进展，我们应该记住，在本章中，“后端”是由假模块模拟的。*
- en: 6.2.1\. Start the chat object with the join method
  id: totrans-920
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.1\. 使用加入方法启动聊天对象
- en: 'In this section we’ll create the `chat` object in the Model so that we may:'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在模型中创建`chat`对象，以便我们：
- en: Sign in using the `spa.model.people.login(<username>)` method.
  id: totrans-922
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`spa.model.people.login(<username>)`方法登录。
- en: Join the chat room using the `spa.model.chat.join()` method.
  id: totrans-923
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`spa.model.chat.join()`方法加入聊天室。
- en: Register a callback to publish an `spa-listchange` event whenever the Model
    receives a `listchange` message from the backend. This indicates the list of users
    has changed.
  id: totrans-924
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册一个回调，每当模型从后端接收到`listchange`消息时，发布一个`spa-listchange`事件。这表示用户列表已更改。
- en: 'Our `chat` object will rely on the `people` object to handle the sign-in and
    to maintain the list of online people. It won’t allow an anonymous user to `join`
    a chat room. Let’s start building the `chat` object in the Model as shown in [listing
    6.2](#ch06list02). Changes are shown in **bold**:'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`chat`对象将依赖于`people`对象来处理登录并维护在线人员列表。它不会允许匿名用户`join`聊天室。让我们按照[列表6.2](#ch06list02)中的说明在模型中开始构建`chat`对象。更改以**粗体**显示：
- en: Listing 6.2\. Start our `chat` object—spa/js/spa.model.js
  id: totrans-926
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.2\. 开始我们的`chat`对象—spa/js/spa.model.js
- en: '![](ch06list02-0.jpg)'
  id: totrans-927
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06list02-0.jpg)'
- en: '![](ch06list02-1.jpg)'
  id: totrans-928
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06list02-1.jpg)'
- en: This is our first pass implementation of the `chat` object. Instead of adding
    more methods, we want to test the ones we’ve created so far. In the next section
    we’ll update the Fake module to emulate the server interaction we need for testing.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`chat`对象的第一版实现。我们不想添加更多方法，而是想测试我们迄今为止创建的方法。在下一节中，我们将更新Fake模块以模拟我们需要测试的服务器交互。
- en: 6.2.2\. Update Fake to respond to chat.join
  id: totrans-930
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.2\. 更新Fake以响应chat.join
- en: 'Now we need to update the Fake module so it can emulate the server responses
    we need to test the `join` method. The changes we need include:'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要更新Fake模块，使其能够模拟我们需要测试`join`方法的服务器响应。我们需要做的更改包括：
- en: Include the signed-in user in the mock people list.
  id: totrans-932
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将已登录用户包含在模拟人员列表中。
- en: Emulate the receipt of a `listchange` message from the server.
  id: totrans-933
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟从服务器接收`listchange`消息。
- en: 'The first step is simple: we create a person map and push it into the people
    list that Fake manages. The second step is trickier, so stick with me here: the
    `chat` object registers a handler for a `listchange` message from the backend
    *only after the user has signed in and joined a chat*. Therefore, we can add a
    private `send_listchange` function that will send a mock people list only once
    this handler is registered. Let’s employ these changes as shown in [listing 6.3](#ch06list03).
    Changes are shown in **bold**:'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步很简单：我们创建一个人员映射并将其推入Fake管理的人员列表中。第二步更复杂，所以请跟我来：`chat`对象仅在用户登录并加入聊天后才会注册一个处理程序来处理来自后端的`listchange`消息。因此，我们可以添加一个私有的`send_listchange`函数，只有在这个处理程序注册后才会发送模拟的人员列表。让我们按照[列表6.3](#ch06list03)中的说明应用这些更改。更改以**粗体**显示：
- en: Listing 6.3\. Update Fake to simulate join server messages—spa/js/spa.fake.js
  id: totrans-935
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.3\. 更新Fake以模拟加入服务器消息—spa/js/spa.fake.js
- en: '![](ch06list03-0.jpg)'
  id: totrans-936
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06list03-0.jpg)'
- en: '![](ch06list03-1.jpg)'
  id: totrans-937
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06list03-1.jpg)'
- en: Now that we’ve completed part of the `chat` object, let’s test it as we did
    with the `people` object in [chapter 5](kindle_split_016.html#ch05).
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了`chat`对象的一部分，让我们像在[第5章](kindle_split_016.html#ch05)中处理`people`对象那样对其进行测试。
- en: 6.2.3\. Test the chat.join method
  id: totrans-939
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.3\. 测试chat.join方法
- en: 'Before we continue building our `chat` object, we should ensure the capabilities
    we have implemented so far work as expected. First let’s load our browser document
    ([spa/spa.html](http://spa/spa.html)), open the JavaScript console, and ensure
    that the SPA shows no JavaScript errors. Then, using the console, we may test
    our methods as shown in [listing 6.4](#ch06list04). Typed input is shown in **bold**;
    output is shown in *italics*:'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续构建`chat`对象之前，我们应该确保我们迄今为止已实现的特性按预期工作。首先，让我们加载我们的浏览器文档([spa/spa.html](http://spa/spa.html))，打开JavaScript控制台，并确保SPA没有显示JavaScript错误。然后，使用控制台，我们可以像[列表6.4](#ch06list04)中所示测试我们的方法。输入的文本以**粗体**显示；输出以*斜体*显示：
- en: Listing 6.4\. Test `spa.model.chat.join()` without a UI or server
  id: totrans-941
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.4\. 在没有UI或服务器的情况下测试spa.model.chat.join()
- en: '![](ch06list04-0.jpg)'
  id: totrans-942
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06list04-0.jpg)'
- en: '![](ch06list04-1.jpg)'
  id: totrans-943
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06list04-1.jpg)'
- en: We’ve completed and tested the first installment of the `chat` object, where
    we may sign in, join a chat, and inspect the people list. Now we want the `chat`
    object to handle sending and receiving messages.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成并测试了`chat`对象的第一部分，其中我们可以登录、加入聊天并检查人员列表。现在我们希望`chat`对象能够处理发送和接收消息。
- en: 6.2.4\. Add messaging to the chat object
  id: totrans-945
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.4\. 向聊天对象添加消息功能
- en: 'Sending and receiving messages aren’t quite as simple as they seem. As FedEx
    will tell you, we have to deal with *logistics*—the management of the transfer
    and receipt of the message. We’ll need to:'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 发送和接收消息并不像看起来那么简单。正如FedEx会告诉你的，我们必须处理*物流*——消息的传输和接收管理。我们需要做的是：
- en: Maintain a record of the *chatee*—the person with whom the user is chatting.
  id: totrans-947
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护一个记录*chatee*（用户正在与之聊天的人）的记录。
- en: Send metadata such as the sender ID, name, and the recipient ID along with the
    message.
  id: totrans-948
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将发送者ID、姓名和接收者ID等元数据与消息一起发送。
- en: Gracefully handle the condition where a latent connection might result in our
    user sending a message to an offline person.
  id: totrans-949
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优雅地处理可能由于潜在连接而导致我们的用户向离线人员发送消息的情况。
- en: Publish jQuery custom global events when messages are received from the backend
    so that our jQuery collections may subscribe to these events and have functions
    act upon them.
  id: totrans-950
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当从后端接收到消息时发布jQuery自定义全局事件，以便我们的jQuery集合可以订阅这些事件并对其执行操作。
- en: 'First let’s update our Model as shown in [listing 6.5](#ch06list05). Changes
    are shown in **bold**:'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们按照[列表6.5](#ch06list05)所示更新我们的模型。更改以**粗体**显示：
- en: Listing 6.5\. Add messaging to the Model--spa/js/spa.model.js
  id: totrans-952
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.5\. 向模型添加消息功能--spa/js/spa.model.js
- en: '![](ch06list05-0.jpg)'
  id: totrans-953
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06list05-0.jpg)'
- en: '![](ch06list05-1.jpg)'
  id: totrans-954
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06list05-1.jpg)'
- en: We’ve completed our second-pass implementation of the `chat` object, where we
    added messaging capabilities. As before, we want to check our work before adding
    more capabilities. In the next section we’ll update the Fake module to emulate
    the server interaction we need.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了`chat`对象的第二次实现，其中我们添加了消息功能。和以前一样，我们在添加更多功能之前想要检查我们的工作。在下一节中，我们将更新Fake模块以模拟所需的服务器交互。
- en: 6.2.5\. Update Fake to emulate messaging
  id: totrans-956
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.5\. 更新Fake以模拟消息
- en: 'Now we need to update the Fake module so it can emulate the server responses
    we need to test the messaging methods. The changes we need include:'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要更新Fake模块，以便它可以模拟我们测试消息方法所需的服务器响应。我们需要进行的更改包括：
- en: Emulate the response to an outgoing `updatechat` message by responding with
    an incoming `updatechat` message from the current chatee.
  id: totrans-958
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过回复一个来自当前聊天对象的`updatechat`消息来模拟对发出的`updatechat`消息的响应。
- en: Emulate an unsolicited incoming `updatechat` message coming from the Wilma person.
  id: totrans-959
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟来自Wilma人员的未经请求的`updatechat`消息。
- en: Emulate the response to an outgoing `leavechat` message. This message is sent
    when the user signs out. We can unbind chat message callbacks at this point.
  id: totrans-960
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟对发出的`leavechat`消息的响应。当用户注销时发送此消息。我们可以在这一点上解绑聊天消息回调。
- en: 'Let’s update Fake to employ these changes as shown in [listing 6.6](#ch06list06).
    Changes are shown in **bold**:'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新Fake以采用这些更改，如[列表6.6](#ch06list06)所示。更改以**粗体**显示：
- en: Listing 6.6\. Add mock messages to Fake—spa/js/spa.fake.js
  id: totrans-962
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.6\. 向Fake添加模拟消息—spa/js/spa.fake.js
- en: '![](ch06list06-0.jpg)'
  id: totrans-963
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06list06-0.jpg)'
- en: '![](ch06list06-1.jpg)'
  id: totrans-964
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06list06-1.jpg)'
- en: Now that we have the `chat` object and Fake updated, we can test messaging.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经更新了`chat`对象和Fake，我们可以测试消息功能。
- en: 6.2.6\. Test chat messaging
  id: totrans-966
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.6\. 测试聊天消息
- en: 'Now we can test setting the chatee, sending messages, and receiving them. Let’s
    load our browser document ([spa/spa.html](http://spa/spa.html)) and open the JavaScript
    console and ensure there are no errors. We can then test as shown in [listing
    6.7](#ch06list07). Typed input is shown in **bold**; output is shown in *italics*:'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以测试设置聊天对象、发送消息和接收消息。让我们加载我们的浏览器文档([spa/spa.html](http://spa/spa.html))并打开JavaScript控制台，确保没有错误。然后我们可以按照[列表6.7](#ch06list07)所示进行测试。输入的文本以**粗体**显示；输出以*斜体*显示：
- en: Listing 6.7\. Test the exchange of messages
  id: totrans-968
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.7\. 测试消息交换
- en: '![](ch06list07-0.jpg)'
  id: totrans-969
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06list07-0.jpg)'
- en: '![](ch06list07-1.jpg)'
  id: totrans-970
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06list07-1.jpg)'
- en: Our `chat` object is nearly complete. All we need now is to add the Avatar support.
    Once we have accomplished that, we’ll update the user interface.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`chat`对象几乎完成了。我们现在需要添加头像支持。一旦我们完成了这个，我们将更新用户界面。
- en: 6.3\. Add Avatar support to the Model
  id: totrans-972
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3\. 将头像支持添加到模型
- en: The Avatar capability is relatively easy to add because we can build on the
    messaging infrastructure of the `chat` object. The primary reason we present this
    capability is to show other uses for near-real-time messaging. The fact that it
    shows well at conferences is just icing on the cake. First we’ll update the Model.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以构建在`chat`对象的消息基础设施之上，因此添加头像功能相对简单。我们提出这一功能的主要原因是展示近实时消息的其他用途。它在会议上的良好表现只是锦上添花。首先，我们将更新模型。
- en: 6.3.1\. Add Avatar support to the chat object
  id: totrans-974
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.1\. 将头像支持添加到聊天对象
- en: The changes we require for the `chat` object to support avatars are relatively
    modest. We only need to add the `update_avatar` method, which will send an `updateavatar`
    message to the backend with a map describing which avatar changed and how. We
    expect the backend to send a `listchange` message when an avatar is updated, and
    the code to handle *that* message is already written and tested.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 `chat` 对象支持头像，我们需要做的更改相对较小。我们只需要添加 `update_avatar` 方法，该方法将发送一个包含描述哪个头像更改以及如何更改的映射的
    `updateavatar` 消息到后端。我们期望后端在头像更新时发送 `listchange` 消息，处理该消息的代码已经编写并测试过了。
- en: 'Let’s update the Model as shown in [listing 6.8](#ch06list08). Changes are
    shown in **bold**:'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新模型，如 [列表 6.8](#ch06list08) 所示。更改以 **粗体** 显示：
- en: Listing 6.8\. Update the Model to support avatars—spa/js/spa.model.js
  id: totrans-977
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.8\. 更新模型以支持头像—spa/js/spa.model.js
- en: '![](ch06list08-0.jpg)'
  id: totrans-978
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06list08-0.jpg)'
- en: '![](ch06list08-1.jpg)'
  id: totrans-979
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06list08-1.jpg)'
- en: We’ve completed adding all the methods and events we designed for the `chat`
    object. In the next section we’ll update the Fake module to emulate the server
    interaction to support avatars.
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了为 `chat` 对象添加的所有方法和事件。在下一节中，我们将更新 Fake 模块以模拟服务器交互以支持头像。
- en: 6.3.2\. Modify Fake to emulate avatars
  id: totrans-981
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.2\. 修改 Fake 以模拟头像
- en: 'Our next step is to modify the Fake module to support sending an `updateavatar`
    message to the backend whenever the user drops an avatar to a new location or
    clicks on the avatar to change its color. When Fake receives this message, it
    should:'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步是修改 Fake 模块以支持在用户将头像拖动到新位置或点击头像以更改其颜色时向后端发送 `updateavatar` 消息。当 Fake 收到此消息时，它应该：
- en: Simulate sending an `updateavatar` message to the server.
  id: totrans-983
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟向服务器发送 `updateavatar` 消息。
- en: Simulate receiving a `listchange` message from the server with an updated people
    list.
  id: totrans-984
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟从服务器接收一个包含更新人员列表的 `listchange` 消息。
- en: Execute the callback registered for the `listchange` message, providing it the
    updated people list.
  id: totrans-985
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行为 `listchange` 消息注册的回调，并提供更新的人员列表。
- en: 'These three steps can be accomplished as shown in [listing 6.9](#ch06list09).
    Changes are shown in **bold**:'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 这些三个步骤可以按照 [列表 6.9](#ch06list09) 所示完成。更改以 **粗体** 显示：
- en: Listing 6.9\. Modify Fake to support avatars—spa/js/spa.fake.js
  id: totrans-987
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.9\. 修改 Fake 以支持头像—spa/js/spa.fake.js
- en: '![](ch06list09-0.jpg)'
  id: totrans-988
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06list09-0.jpg)'
- en: '![](ch06list09-1.jpg)'
  id: totrans-989
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06list09-1.jpg)'
- en: Now that we have the `chat` object and Fake updated, we can test avatars.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了 `chat` 对象和 Fake 的更新，我们可以测试头像了。
- en: 6.3.3\. Test avatar support
  id: totrans-991
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.3\. 测试头像支持
- en: 'This is our final bit of Model testing. Again, let’s load our browser document
    ([spa/spa.html](http://spa/spa.html)) and ensure the SPA works as before. We’ll
    open the JavaScript console and test our `update_avatar` method as shown in [listing
    6.10](#ch06list10). Typed input is shown in **bold**; output is shown in *italics*:'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的最终模型测试。再次，让我们加载我们的浏览器文档 ([spa/spa.html](http://spa/spa.html)) 并确保单页应用 (SPA)
    仍然像以前一样工作。我们将打开 JavaScript 控制台并测试我们的 `update_avatar` 方法，如 [列表 6.10](#ch06list10)
    所示。输入的文本以 **粗体** 显示；输出以 *斜体* 显示：
- en: Listing 6.10\. Test the update_avatar method
  id: totrans-993
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.10\. 测试 update_avatar 方法
- en: '![](ch06list10-0.jpg)'
  id: totrans-994
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06list10-0.jpg)'
- en: '![](ch06list10-1.jpg)'
  id: totrans-995
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06list10-1.jpg)'
- en: We’ve completed the `chat` object. As with the `people` object from [chapter
    5](kindle_split_016.html#ch05), the testing is reassuring, and we can add to a
    test suite for use without a server or browser.
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了 `chat` 对象。与第 5 章中的 `people` 对象一样，测试令人放心，我们可以添加一个测试套件，用于在没有服务器或浏览器的情况下使用。
- en: 6.3.4\. Test-driven development
  id: totrans-997
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.4\. 测试驱动开发
- en: All those test-driven development (TDD) freaks out there are probably looking
    at all this manual testing and thinking “Gosh, why not just put this into a test
    suite that can run automatically?” Being aspiring freaks ourselves, we can—and
    we did. Check out [appendix B](kindle_split_023.html#app02) to see how one can
    use Node.js to automate this process.
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 所有那些测试驱动开发 (TDD) 狂热者可能都在看着所有这些手动测试，想着“天哪，为什么不直接将其放入一个可以自动运行的测试套件中呢？”作为有抱负的狂热者，我们可以，我们也做到了。查看
    [附录 B](kindle_split_023.html#app02) 了解如何使用 Node.js 自动化此过程。
- en: 'We actually found a few issues as the result of the test suite. Most were specific
    to testing, so we will leave *those* to the appendix. But there were two bona
    fide bugs we needed to fix: our sign-out mechanism wasn’t quite right, as it wasn’t
    clearing the user list properly, and the `chatee` object wasn’t being updated
    properly after an `spa.model.chat.update_avatar` method call. Let’s fix both of
    those now as shown in [listing 6.11](#ch06list11). Changes are shown in **bold**:'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上在测试套件中发现了一些问题。大多数都是针对测试的，所以我们将在附录中留下 *那些*。但有两个真正的错误我们需要修复：我们的注销机制并不完全正确，因为它没有正确清除用户列表，并且在调用
    `spa.model.chat.update_avatar` 方法后，`chatee` 对象没有被正确更新。现在让我们修复这两个问题，如 [列表 6.11](#ch06list11)
    所示。更改以粗体显示：
- en: Listing 6.11\. Fix sign-out and chatee object update—spa/js/spa.model.js
  id: totrans-1000
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.11\. 修复注销和聊天对象更新—spa/js/spa.model.js
- en: '![](ch06list11-0.jpg)'
  id: totrans-1001
  prefs: []
  type: TYPE_IMG
  zh: '![图片 ch06list11-0](ch06list11-0.jpg)'
- en: '![](ch06list11-1.jpg)'
  id: totrans-1002
  prefs: []
  type: TYPE_IMG
  zh: '![图片 ch06list11-1](ch06list11-1.jpg)'
- en: This is a good point to take a break. In the remainder of the chapter we’ll
    return to the UI and finish the Chat feature module using the `chat` and `people`
    object APIs provided by the Model. We’ll also create an Avatar feature module.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个休息的好时机。在本章的剩余部分，我们将回到 UI，使用模型提供的 `chat` 和 `people` 对象 API 完成聊天功能模块。我们还将创建一个头像功能模块。
- en: 6.4\. Complete the Chat feature module
  id: totrans-1004
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4\. 完成聊天功能模块
- en: 'In this section we’ll update the Chat feature module shown in [figure 6.3](#ch06fig03).
    We can now take advantage of the Model’s `chat` and `people` objects to provide
    a simulated chat experience. Let’s revisit the Chat UI we mocked up earlier and
    decide how to modify it to work with the `chat` object. [Figure 6.4](#ch06fig04)
    shows what we’d like to accomplish. We can distill this mockup into a list of
    capabilities that we’d like to add to the Chat feature module. These include:'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更新图 6.3 中所示的聊天功能模块。现在我们可以利用模型的 `chat` 和 `people` 对象来提供模拟的聊天体验。让我们回顾一下我们之前模拟的聊天界面，并决定如何修改它以与
    `chat` 对象一起工作。[图 6.4](#ch06fig04) 展示了我们想完成的内容。我们可以将这个模拟提炼成我们希望添加到聊天功能模块的功能列表。这些包括：
- en: Figure 6.3\. The Chat feature module in our SPA architecture
  id: totrans-1006
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.3\. 我们 SPA 架构中的聊天功能模块
- en: '![](06fig03_alt.jpg)'
  id: totrans-1007
  prefs: []
  type: TYPE_IMG
  zh: '![图片 06fig03_alt](06fig03_alt.jpg)'
- en: Figure 6.4\. What we want in the Chat UI
  id: totrans-1008
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.4\. 我们想要的聊天界面
- en: '![](06fig04_alt.jpg)'
  id: totrans-1009
  prefs: []
  type: TYPE_IMG
  zh: '![图片 06fig04_alt](06fig04_alt.jpg)'
- en: Change the design of the chat slider to include the people list.
  id: totrans-1010
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将聊天滑块的样式设计改为包含人员列表。
- en: 'When the user signs in, perform the following actions: join the chat, open
    the chat slider, change the chat slider title, and display the list of online
    people.'
  id: totrans-1011
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户登录时，执行以下操作：加入聊天，打开聊天滑块，更改聊天滑块标题，并显示在线人员列表。
- en: Update the online people list whenever it changes.
  id: totrans-1012
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在在线人员列表更改时更新在线人员列表。
- en: Highlight the chatee in the online people list and update the display whenever
    the list changes.
  id: totrans-1013
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在在线人员列表中突出显示聊天对象，并在列表更改时更新显示。
- en: Empower the user to send a message and select a chatee from the online people
    list.
  id: totrans-1014
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋予用户发送消息和从在线人员列表中选择聊天对象的能力。
- en: Display messages from the user, other people, and the system in the message
    log. These messages should all look different, and the message log should scroll
    smoothly from the bottom up.
  id: totrans-1015
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在消息日志中显示用户、其他人和系统的消息。这些消息都应该看起来不同，并且消息日志应该从底部向上平滑滚动。
- en: Revise the interface to support touch controls.
  id: totrans-1016
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改界面以支持触摸控制。
- en: 'When the user signs out, perform the following actions: change the title of
    the chat slider, erase the message log, and retract the slider.'
  id: totrans-1017
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户注销时，执行以下操作：更改聊天滑块的标题，清除消息日志，并收回滑块。
- en: Let’s start by updating the JavaScript.
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从更新 JavaScript 开始。
- en: 6.4.1\. Update the Chat JavaScript
  id: totrans-1019
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.1\. 更新聊天 JavaScript
- en: 'We need to update the Chat JavaScript to add the capabilities we just discussed.
    The primary changes include:'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更新聊天 JavaScript 以添加我们刚刚讨论的功能。主要更改包括：
- en: Revise the HTML template to include the people list.
  id: totrans-1021
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改 HTML 模板以包含人员列表。
- en: Create the `scrollChat`, `writeChat`, `writeAlert`, and `clearChat` methods
    to manage the message log.
  id: totrans-1022
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `scrollChat`、`writeChat`、`writeAlert` 和 `clearChat` 方法来管理消息日志。
- en: Create user input event handlers, `onTapList` and `onSubmitMsg`, to allow the
    user to select a chatee from the people list and send a message. Ensure that touch
    events are supported.
  id: totrans-1023
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用户输入事件处理器 `onTapList` 和 `onSubmitMsg`，允许用户从人员列表中选择聊天对象并发送消息。确保支持触摸事件。
- en: Create the `onSetchatee` method to handle the Model-published `spa-setchatee`
    event. This will change the display of the chatee, change the chat slider title,
    and provide a system alert in the message window.
  id: totrans-1024
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `onSetchatee` 方法来处理模型发布的 `spa-setchatee` 事件。这将改变聊天对象的显示，更改聊天滑块的标题，并在消息窗口中提供系统警报。
- en: Create the `onListchange` method to handle the Model-published `spalistchange`
    event. This will render the people list with the chatee highlighted.
  id: totrans-1025
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `onListchange` 方法来处理模型发布的 `spalistchange` 事件。这将渲染带有高亮聊天对象的名单。
- en: Create the `onUpdatechat` method to handle the Model-published `spa-update-chat`
    event. This will display new messages sent by the user, the server, or other people.
  id: totrans-1026
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `onUpdatechat` 方法来处理模型发布的 `spa-update-chat` 事件。这将显示用户、服务器或其他人发送的新消息。
- en: Create the `onLogin` and `onLogout` methods to handle the Model-published `spa-login`
    and `spa-logout` events. The `onLogin` handler will open the chat slider when
    a user signs in. The `onLogout` handler will clear the message log, reset the
    title, and close the chat slider.
  id: totrans-1027
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `onLogin` 和 `onLogout` 方法来处理模型发布的 `spa-login` 和 `spa-logout` 事件。`onLogin`
    处理器将在用户登录时打开聊天滑块。`onLogout` 处理器将清除消息记录，重置标题，并关闭聊天滑块。
- en: Subscribe to all Model-published events and then bind all user input events.
  id: totrans-1028
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅所有模型发布的事件，然后绑定所有用户输入事件。
- en: '|  |'
  id: totrans-1029
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**About those event handler names**'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于那些事件处理器名称**'
- en: We know some of you out there are thinking “Is there a reason why the method
    name `onSetchatee` isn’t `onSetChatee`?” Well, there is.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道有些人可能会想，“为什么方法名 `onSetchatee` 不是 `onSetChatee`？” 好吧，确实有原因。
- en: Our naming convention for event handlers is `on<Event>[<Modifier>]`, where the
    *Modifier* is an option. This usually works great, as most events are single syllables.
    Examples include `onTap` or `onTapAvatar`. This convention is handy so we can
    trace the handler precisely to the *event* that it’s handling.
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为事件处理器命名的约定是 `on<Event>[<Modifier>]`，其中 *Modifier* 是一个可选参数。这通常工作得很好，因为大多数事件都是单音节词。例如包括
    `onTap` 或 `onTapAvatar`。这个约定很方便，这样我们就可以精确地追踪处理器所处理的事件。
- en: 'Like all conventions, there are edge cases that can get confusing. In the case
    of `onListchange`, for example, we’ve followed our convention: the event name
    is `listchange`, *not*`listChange`. Thus `onListchange` is correct, whereas `onListChange`
    is not. The same holds true for `onSetchatee` and `onUpdatechat`.'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 就像所有约定一样，总有一些边缘情况可能会让人困惑。例如，在 `onListchange` 的情况下，我们遵循了我们的约定：事件名是 `listchange`，而不是
    `listChange`。因此 `onListchange` 是正确的，而 `onListChange` 则不是。同样的规则也适用于 `onSetchatee`
    和 `onUpdatechat`。
- en: '|  |'
  id: totrans-1034
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Let’s update the JavaScript file as shown in [listing 6.12](#ch06list12). Changes
    are shown in **bold**:'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新JavaScript文件，如[列表6.12](#ch06list12)所示。更改以**粗体**显示：
- en: Listing 6.12\. Update the Chat JavaScript file—spa/js/spa.chat.js
  id: totrans-1036
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.12\. 更新聊天JavaScript文件—spa/js/spa.chat.js
- en: '![](ch06list12-0.jpg)'
  id: totrans-1037
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06list12-0.jpg)'
- en: '![](ch06list12-1.jpg)'
  id: totrans-1038
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06list12-1.jpg)'
- en: '|  |'
  id: totrans-1039
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Template systems and you**'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: '**模板系统与您**'
- en: Our SPA uses simple string concatenation to generate HTML, which is perfectly
    acceptable for our purposes. But there comes a time when we require more sophisticated
    HTML generation. That’s when it’s time to consider a template system.
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的SPA使用简单的字符串连接来生成HTML，这对于我们的目的来说完全是可以接受的。但总有需要更复杂HTML生成的时候。那就是考虑使用模板系统的时候了。
- en: Template systems convert data into display elements. We can divide template
    systems broadly by the language the developer uses to direct element generation.
    The *Embedded style* allows us to embed the host language—in our case, JavaScript—directly
    in the template. The *Toolkit style* provides a domain-specific template language
    (DSL) independent of the host language.
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 模板系统将数据转换为显示元素。我们可以根据开发者用来指导元素生成的语言来广泛地划分模板系统。*嵌入式风格*允许我们直接在模板中嵌入宿主语言——在我们的例子中，是JavaScript。*工具箱风格*提供了一种独立于宿主语言的特定领域模板语言（DSL）。
- en: We don’t recommend use of any *Embedded style* systems because they make it
    far too easy to intermingle business logic with display logic. The most popular
    JavaScript *Embedded style* system is probably provided by *underscore.js*’s *template*
    method, but there are many others.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不推荐使用任何 *嵌入式风格* 系统，因为它们使得将业务逻辑与显示逻辑混合变得过于容易。最流行的JavaScript *嵌入式风格* 系统可能是由
    *underscore.js* 的 *template* 方法提供的，但还有很多其他的选择。
- en: We’ve noticed that *Toolkit style* systems in other languages have tended to
    become preferred over time. This is probably because these systems tend to encourage
    clean segregation of display and business logic. Many good *Toolkit style* template
    systems are available for SPAs. At the time of this writing, popular and well-tested
    Toolkit style template systems include *Handlebars*, *Dust*, and *Mustache*. We
    feel they’re all worthy of your consideration.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到，在其他语言中，*工具包样式*系统随着时间的推移逐渐变得受欢迎。这可能是因为这些系统倾向于鼓励显示和业务逻辑的清晰分离。许多好的*工具包样式*模板系统可用于SPA。在撰写本文时，流行的、经过良好测试的工具包样式模板系统包括*Handlebars*、*Dust*和*Mustache*。我们认为它们都值得你考虑。
- en: '|  |'
  id: totrans-1045
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now that we have the JavaScript in place, let’s revise the stylesheets to match.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经放置了JavaScript，让我们修改样式表以匹配。
- en: 6.4.2\. Update the stylesheets
  id: totrans-1047
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.2\. 更新样式表
- en: 'We now will update the stylesheets for our enhanced interface. First we wish
    to update our root stylesheet to prevent selection of text on most elements. This
    removes an annoying user experience that’s especially noticeable on touch devices.
    The update is shown in [listing 6.13](#ch06list13). Changes are shown in **bold**:'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将更新增强界面的样式表。首先，我们希望更新我们的根样式表，以防止在大多数元素上选择文本。这消除了在触摸设备上特别明显的令人烦恼的用户体验。更新显示在[列表6.13](#ch06list13)。更改以**粗体**显示：
- en: Listing 6.13\. Update the root stylesheet—spa/css/spa.css
  id: totrans-1049
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.13\. 更新根样式表—spa/css/spa.css
- en: '![](ch06list13-0.jpg)'
  id: totrans-1050
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06list13-0.jpg)'
- en: '![](ch06list13-1.jpg)'
  id: totrans-1051
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06list13-1.jpg)'
- en: 'We now need to update our Chat stylesheet. The primary changes include:'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要更新我们的聊天样式表。主要更改包括：
- en: Style an online people list to be shown on the left side of the slider.
  id: totrans-1053
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个在线人员列表，显示在滑块的左侧。
- en: Make the slider wider to accommodate the people list.
  id: totrans-1054
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使滑块更宽，以容纳人员列表。
- en: Style the message window.
  id: totrans-1055
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计消息窗口样式。
- en: Remove all `spa-chat-box*` and `spa-chat-msgs*` selectors.
  id: totrans-1056
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除所有`spa-chat-box*`和`spa-chat-msgs*`选择器。
- en: Add styles for messages received from the user, the chatee, and the system.
  id: totrans-1057
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为从用户、聊天对象和系统接收的消息添加样式。
- en: 'These updates are shown in [listing 6.14](#ch06list14). Changes are shown in
    **bold**:'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更新显示在[列表6.14](#ch06list14)。更改以**粗体**显示：
- en: Listing 6.14\. Update the Chat stylesheet—spa/css/spa.chat.css
  id: totrans-1059
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.14\. 更新聊天样式表—spa/css/spa.chat.css
- en: '![](ch06list14-0.jpg)'
  id: totrans-1060
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06list14-0.jpg)'
- en: '![](ch06list14-1.jpg)'
  id: totrans-1061
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06list14-1.jpg)'
- en: Now with our stylesheet in place, let’s see how well our updated Chat UI works.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经放置了样式表，让我们看看我们的更新后的聊天用户界面工作得怎么样。
- en: 6.4.3\. Test the Chat UI
  id: totrans-1063
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.3\. 测试聊天UI
- en: When we load our browser document ([spa/spa.html](http://spa/spa.html)), we
    should now see a page with “Please sign in” in the user area on the upper-right.
    When we click on this, we can sign in as before. The user area will present “...
    processing ...” for 3 seconds, and then show the user name in the user area. At
    that time, the chat slider should open and the interface should look like that
    shown in [Figure 6.5](#ch06fig05).
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们加载浏览器文档([spa/spa.html](http://spa/spa.html))时，现在我们应该在右上角的用户区域看到一个显示“请登录”的页面。当我们点击这个按钮时，我们可以像以前一样登录。用户区域将显示“...处理中...”3秒钟，然后显示用户名在用户区域。那时，聊天滑块应该打开，界面应该看起来像[图6.5](#ch06fig05)中所示。
- en: Figure 6.5\. Our updated chat interface after sign-in
  id: totrans-1065
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.5\. 登录后的更新聊天界面
- en: '![](06fig05_alt.jpg)'
  id: totrans-1066
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig05_alt.jpg)'
- en: After a few seconds, we’ll receive our first message from Wilma. We can respond,
    and then select Pebbles and send her a message. The chat interface should look
    similar to [figure 6.6](#ch06fig06).
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，我们将收到Wilma的第一条消息。我们可以回复，然后选择Pebbles并发送给她一条消息。聊天界面应该类似于[图6.6](#ch06fig06)。
- en: Figure 6.6\. The chat slider after a bit of use
  id: totrans-1068
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.6\. 使用一段时间后的聊天滑块
- en: '![](06fig06_alt.jpg)'
  id: totrans-1069
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig06_alt.jpg)'
- en: We have now used the Model’s `chat` and `people` APIs to provide all the capabilities
    we want in our Chat feature module. Now we’d like to add the Avatar feature module.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经使用模型的`chat`和`people`API提供了我们在聊天功能模块中想要的所有功能。现在我们想添加头像功能模块。
- en: 6.5\. Create the Avatar feature module
  id: totrans-1071
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5\. 创建头像功能模块
- en: In this section we create the Avatar feature module as shown in [figure 6.7](#ch06fig07).
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们创建如图6.7所示的头像功能模块。
- en: Figure 6.7\. The Avatar feature module in our SPA architecture
  id: totrans-1073
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.7\. 我们SPA架构中的头像功能模块
- en: '![](06fig07_alt.jpg)'
  id: totrans-1074
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig07_alt.jpg)'
- en: The `chat` object already provides for managing avatar information. We just
    need to decide on some details. Let’s revisit the Avatar UI as shown in [figure
    6.8](#ch06fig08).
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: '`chat`对象已经提供了管理头像信息的功能。我们只需要决定一些细节。让我们回顾一下如图6.8所示的头像UI。'
- en: Figure 6.8\. Avatars as we’d like them presented
  id: totrans-1076
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.8\. 我们希望展示的化身
- en: '![](06fig08_alt.jpg)'
  id: totrans-1077
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig08_alt.jpg)'
- en: Each online person has an avatar that’s shaped like a box with a thick border
    and with their name displayed in the center. The avatar that represents the user
    should have a blue border. The avatar for the chatee should have a green border.
    When we tap or click on an avatar, it should change color. After a long press
    or touch on an avatar, its appearance should change and we should be able to drag
    it to a new location.
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 每个在线人物都有一个形状像盒子、带有粗边框并在中心显示其名字的化身。代表用户的化身应该有蓝色边框。聊天对象的化身应该有绿色边框。当我们轻触或点击一个化身时，它应该改变颜色。在长按或触摸化身后，其外观应该改变，并且我们应该能够将其拖动到新的位置。
- en: 'We will develop our Avatar module using the typical process for feature modules:'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用功能模块的典型流程来开发我们的化身模块：
- en: Create a JavaScript file for the feature module using an isolated namespace.
  id: totrans-1080
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用隔离的命名空间为功能模块创建一个 JavaScript 文件。
- en: Create the stylesheet file for the feature module with classes prefixed by the
    namespace.
  id: totrans-1081
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为功能模块创建一个以命名空间为前缀的样式表文件。
- en: Update the browser document to include the new JavaScript and stylesheet files.
  id: totrans-1082
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新浏览器文档以包含新的 JavaScript 和样式表文件。
- en: Adjust the Shell to configure and initialize the new module.
  id: totrans-1083
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整外壳以配置和初始化新模块。
- en: We’ll follow these steps in the following sections.
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将遵循以下步骤。
- en: 6.5.1\. Create the Avatar JavaScript
  id: totrans-1085
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.5.1\. 创建化身 JavaScript
- en: 'Our first step in adding the Avatar feature module is to create the JavaScript
    file. Since the module uses many of the same events as the Chat module, we can
    copy spa/js/ spa.chat.js to spa/js/spa.avtr.js and then adjust accordingly. [Listing
    6.15](#ch06list15) is our freshly minted feature module file. Because this is
    so similar to Chat, we don’t offer an in-depth discussion. But the interesting
    parts have been annotated:'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加化身功能模块的第一步是创建 JavaScript 文件。由于该模块使用了与聊天模块相同的许多事件，我们可以将 spa/js/spa.chat.js
    复制到 spa/js/spa.avtr.js，然后相应地进行调整。[列表 6.15](#ch06list15) 是我们新创建的功能模块文件。由于它与聊天模块非常相似，我们不提供深入的讨论。但有趣的部分已经进行了注释：
- en: Listing 6.15\. Create the Avatar JavaScript—spa/js/spa.avtr.js
  id: totrans-1087
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.15\. 创建化身 JavaScript—spa/js/spa.avtr.js
- en: '![](ch06list15-0.jpg)'
  id: totrans-1088
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06list15-0.jpg)'
- en: '![](ch06list15-1.jpg)'
  id: totrans-1089
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06list15-1.jpg)'
- en: Now that we have the JavaScript portion of the module complete, we can create
    the associated stylesheet.
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了模块的 JavaScript 部分，我们可以创建相关的样式表。
- en: 6.5.2\. Create the Avatar stylesheet
  id: totrans-1091
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.5.2\. 创建化身样式表
- en: 'Our Avatar module draws boxes to graphically represent a user. We can define
    a single class (`spa-avtr-box`) to style the box. This class can then be modified
    to highlight the user (`spa-x-is-user`), highlight the chatee (`spa-x-is-chatee`),
    or highlight a box that’s being dragged (`spa-x-is-drag`). These selectors are
    shown in [listing 6.16](#ch06list16):'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的化身模块通过绘制矩形来图形化地表示用户。我们可以定义一个单独的类 (`spa-avtr-box`) 来设置矩形的样式。然后，我们可以修改这个类来突出显示用户
    (`spa-x-is-user`)，突出显示聊天对象 (`spa-x-is-chatee`)，或者突出显示正在拖动的矩形 (`spa-x-is-drag`)。这些选择器在
    [列表 6.16](#ch06list16) 中展示：
- en: Listing 6.16\. Create the Avatar stylesheet—spa/css/spa.avtr.css
  id: totrans-1093
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.16\. 创建化身样式表—spa/css/spa.avtr.css
- en: '![](ch06list16-0.jpg)'
  id: totrans-1094
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06list16-0.jpg)'
- en: '![](ch06list16-1.jpg)'
  id: totrans-1095
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06list16-1.jpg)'
- en: 'With the module files complete, we now need to adjust two additional files:
    the Shell and the browser document.'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 模块文件完成后，我们现在需要调整两个额外的文件：外壳和浏览器文档。
- en: 6.5.3\. Update the Shell and the browser document
  id: totrans-1097
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.5.3\. 更新外壳和浏览器文档
- en: 'If we want to use the newly created feature module, we need to update the Shell
    to configure and initialize it, as shown in [listing 6.17](#ch06list17):'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用新创建的功能模块，我们需要更新外壳以配置和初始化它，如 [列表 6.17](#ch06list17) 所示：
- en: Listing 6.17\. Update the Shell to configure and initialize Avatar—spa/js/spa.shell.js
  id: totrans-1099
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.17\. 更新外壳以配置和初始化化身—spa/js/spa.shell.js
- en: '![](220fig02_alt.jpg)'
  id: totrans-1100
  prefs: []
  type: TYPE_IMG
  zh: '![](220fig02_alt.jpg)'
- en: 'The last step when creating a feature module is to update the browser document
    to include the JavaScript and stylesheet files. This step was already accomplished
    in [chapter 5](kindle_split_016.html#ch05), but for the sake of completeness,
    the changes are shown again in [listing 6.18](#ch06list18):'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 创建功能模块的最后一步是更新浏览器文档以包含 JavaScript 和样式表文件。这一步在 [第 5 章](kindle_split_016.html#ch05)
    中已经完成，但为了完整性，这里再次展示 [列表 6.18](#ch06list18) 中的更改：
- en: Listing 6.18\. Update the browser document for avatars—spa/spa.html
  id: totrans-1102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.18\. 更新浏览器文档以包含化身—spa/spa.html
- en: '[PRE52]'
  id: totrans-1103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The creation and integration of the Avatar feature module is complete. Now let’s
    test it out.
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 化身功能模块的创建和集成已完成。现在让我们测试一下。
- en: 6.5.4\. Test the Avatar feature module
  id: totrans-1105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.5.4\. 测试头像功能模块
- en: When we load our browser document ([spa/spa.html](http://spa/spa.html)), we
    should see a page with “Please sign in” in the user area on the upper-right. When
    we click on this, we can sign in as before. Once the chat slider opens, we should
    see an interface that looks like [figure 6.9](#ch06fig09).
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们加载浏览器文档([spa/spa.html](http://spa/spa.html))时，我们应该在右上角的用户区域看到一个显示“请登录”的页面。当我们点击这个按钮时，我们可以像以前一样登录。一旦聊天滑块打开，我们应该看到一个类似于[图6.9](#ch06fig09)的界面。
- en: Figure 6.9\. Avatars shown after sign-in
  id: totrans-1107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.9\. 登录后的头像显示
- en: '![](06fig09_alt.jpg)'
  id: totrans-1108
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig09_alt.jpg)'
- en: 'We can now drag the avatars around (they all start in the top-left corner)
    by hold-dragging them. A tap on an avatar will result in a color change. After
    a little tapping and dragging, we should see the interface look something like
    [figure 6.10](#ch06fig10). The user avatar has a blue border, the chatee has a
    green border, and any avatar that is being dragged has a black-white-red color
    scheme:'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过按住并拖动它们来拖动头像（它们都从左上角开始）。轻触头像会导致颜色变化。经过一些点击和拖动后，我们应该看到一个类似于[图6.10](#ch06fig10)的界面。用户头像有一个蓝色边框，聊天对象的头像有一个绿色边框，任何正在被拖动的头像都有一个黑白红配色方案：
- en: Figure 6.10\. Avatars at play
  id: totrans-1110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.10\. 活跃的头像
- en: '![](06fig10_alt.jpg)'
  id: totrans-1111
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig10_alt.jpg)'
- en: We’ve implemented all the features we discussed at the beginning of this chapter.
    Now let’s look at how we accomplished one facet of our work that is a popular
    topic these days—data binding.
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了本章开头讨论的所有功能。现在让我们看看我们是如何完成我们工作的一个方面，这个方面是当今的一个热门话题——数据绑定。
- en: 6.6\. Data binding and jQuery
  id: totrans-1113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6\. 数据绑定和jQuery
- en: '*Data binding* is a mechanism to ensure that when Model data changes, the interface
    is changed to reflect it; and, conversely, when the user changes the interface,
    the Model data is updated accordingly. This is nothing new—if you’ve ever worked
    on a UI you’ve implemented data binding as a matter of course.'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据绑定*是一种机制，确保当模型数据发生变化时，界面会相应地改变以反映它；反之，当用户更改界面时，模型数据也会相应更新。这并不新鲜——如果你曾经从事过UI工作，你肯定已经作为常规实现了数据绑定。'
- en: We implemented data binding in this chapter using jQuery methods. When the Model
    data changes in our SPA, we publish jQuery global custom events. Our jQuery collections
    subscribe to specific custom global events and invoke functions to update their
    presentation when the events occur. And when the users modify data on-screen,
    they trigger event handlers that invoke methods to update the Model. It’s simple
    and provides a good deal of flexibility in how and when the data and presentation
    are updated. Data binding using jQuery isn’t hard, and it isn’t mysteriously magical
    either—which is a good thing.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中使用了jQuery方法来实现数据绑定。当我们的SPA中的模型数据发生变化时，我们发布jQuery全局自定义事件。我们的jQuery集合订阅特定的自定义全局事件，并在事件发生时调用函数来更新它们的展示。当用户在屏幕上修改数据时，他们会触发事件处理器，调用方法来更新模型。这很简单，并且在如何以及何时更新数据和展示方面提供了相当大的灵活性。使用jQuery进行数据绑定并不难，也不是神秘神奇的——这是一个好事。
- en: '|  |'
  id: totrans-1116
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Beware SPA “framework” libraries bearing gifts**'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: '**警惕携带礼物的SPA“框架”库**'
- en: 'Some SPA “framework” libraries promise “automatic two-way data binding” which
    certainly sounds good. But we’ve learned a few points of caution about such promises
    in spite of the impressive canned demos:'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 一些SPA“框架”库承诺“自动双向数据绑定”，这听起来确实不错。但尽管有令人印象深刻的演示，我们还是学到了一些关于这种承诺的注意事项：
- en: We’ll need to learn the language of the library—its API and terminology to make
    it do the things a well-groomed presenter can do. This can be a significant investment.
  id: totrans-1119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要学习库的语言——它的API和术语，以便让它做那些一个精心打扮的演讲者能做的事情。这可能是一个重大的投资。
- en: The library author often has a vision of how an SPA is supposed to be structured.
    If our SPA *doesn’t* meet that vision, retrofitting can get expensive.
  id: totrans-1120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库的作者通常有一个关于SPA应该如何构建的愿景。如果我们的SPA*不符合*这个愿景，那么改造可能会变得昂贵。
- en: Libraries can be big, buggy, and offer another layer of complexity where things
    can go wrong.
  id: totrans-1121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库可能很大、有bug，并且提供了一个可能出错的新层级的复杂性。
- en: The library’s data binding may often not meet our SPA requirements.
  id: totrans-1122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库的数据绑定可能往往不符合我们的SPA要求。
- en: Let’s focus on that last point. Perhaps we’d like a user to be able to edit
    a row in a table, and when finished, either accept the entire row or cancel (in
    which case the row should revert back to old values). And, when the user is done
    editing rows, we’d like to have the user accept or cancel the entire edited table.
    And only then would we even consider saving the table to the backend.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关注最后一点。也许我们希望用户能够编辑表格中的一行，并在完成编辑后，要么接受整个行，要么取消（在这种情况下，行应恢复到旧值）。此外，当用户完成编辑行后，我们希望用户接受或取消整个编辑过的表格。然后我们才会考虑将表格保存到后端。
- en: The probability of a framework library supporting this kind of reasonable interaction
    “out-of-the-box” is low. So if we go with a library, we’ll need to create a custom
    override method to circumvent the default behavior. If we have to do that just
    a few times, we can easily end up with *more* code, *more* layers, *more* files,
    and *more* complexity than if we’d written the damn thing ourselves in the first
    place.
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 框架库支持这种合理交互“开箱即用”的概率很低。因此，如果我们选择一个库，我们需要创建一个自定义覆盖方法来绕过默认行为。如果我们不得不这样做几次，我们很容易就会得到更多的代码、更多的层、更多的文件和更多的复杂性，比我们最初自己编写这个该死的东西还要多。
- en: After a few well-intended attempts, we’ve learned to approach framework libraries
    with caution. We’ve found they can add complexity to an SPA rather than making
    development better, faster, or easier to understand. That doesn’t mean we should
    never use framework libraries—they have their place. But our example SPAs (and
    quite a few in production) work fine with just jQuery, some plugins, and a few
    specialized tools like TaffyDb. Often, simpler is better.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 经过几次良好的尝试后，我们学会了谨慎地对待框架库。我们发现它们可能会给单页应用（SPA）增加复杂性，而不是使开发变得更好、更快或更容易理解。这并不意味着我们永远不应该使用框架库——它们有自己的位置。但我们的示例
    SPAs（以及生产中的许多）仅使用 jQuery、一些插件和一些专门的工具（如 TaffyDb）就能很好地工作。通常，简单更好。
- en: '|  |'
  id: totrans-1126
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Now let’s finish the client portion of the SPA by adding the Data module and
    making a few minor tweaks.
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过添加数据模块并进行一些小的调整来完成单页应用（SPA）的客户端部分。
- en: 6.7\. Create the Data module
  id: totrans-1128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.7\. 创建数据模块
- en: In this section we create the Data module as shown in [figure 6.11](#ch06fig11).
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们创建了如图 6.11 所示的数据模块 [链接](#ch06fig11)。
- en: Figure 6.11\. The Data model in our SPA architecture
  id: totrans-1130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.11\. 我们单页应用（SPA）架构中的数据模型
- en: '![](06fig11_alt.jpg)'
  id: totrans-1131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig11_alt.jpg)'
- en: This will prepare the client to use “real” data and services from the server
    instead of our Fake module. The application will *not* work after we have completed
    this section, as the required server capabilities aren’t yet in place. That will
    come in [chapters 7](kindle_split_019.html#ch07) and [8](kindle_split_020.html#ch08).
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为客户端准备使用来自服务器的“真实”数据和服务的功能，而不是我们的模拟模块。完成本节后，应用程序将无法工作，因为所需的网络功能尚未到位。这将在第 7
    章 [链接](kindle_split_019.html#ch07) 和第 8 章 [链接](kindle_split_020.html#ch08) 中介绍。
- en: 'We’ll need to add the Socket.IO library to the list of libraries we load, as
    this will be our message transport mechanism. This is accomplished as shown in
    [listing 6.19](#ch06list19). Changes are shown in **bold**:'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将 Socket.IO 库添加到我们加载的库列表中，因为这将是我们消息传输机制。这如列表 6.19 所示完成。变化以粗体显示：
- en: Listing 6.19\. Include the Socket.IO library in the browser document—spa/spa.html
  id: totrans-1134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.19\. 在浏览器文档中包含 Socket.IO 库—spa/spa.html
- en: '[PRE53]'
  id: totrans-1135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We wish to ensure that the Data module is initialized prior to the Model or
    the Shell, as shown in [listing 6.20](#ch06list20). Changes are shown in **bold**:'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望确保在模型或外壳之前初始化数据模块，如图 6.20 所示 [列表](#ch06list20)。变化以粗体显示：
- en: Listing 6.20\. Initialize Data in the root namespace module—spa/js/spa.js
  id: totrans-1137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.20\. 在根命名空间模块中初始化数据—spa/js/spa.js
- en: '![](224fig01_alt.jpg)'
  id: totrans-1138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](224fig01_alt.jpg)'
- en: 'Next we update the Data module as shown in [listing 6.21](#ch06list21). This
    module manages *all* the connections to the server in our architecture, and *all*
    data communicated between the client and server flows through this module. All
    that this module does may not be clear at present, but don’t worry—we’ll cover
    Socket.IO in further detail in the next chapter. Changes are shown in **bold**:'
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们更新数据模块，如图 6.21 所示 [列表](#ch06list21)。此模块管理我们架构中与服务器所有的连接，并且客户端和服务器之间所有的数据通信都通过此模块进行。这个模块所做的一切可能目前还不清楚，但不用担心——我们将在下一章中更详细地介绍
    Socket.IO。变化以粗体显示：
- en: Listing 6.21\. Update the Data module—spa/js/spa.data.js
  id: totrans-1140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.21\. 更新数据模块—spa/js/spa.data.js
- en: '![](ch06list21-0.jpg)'
  id: totrans-1141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch06list21-0.jpg)'
- en: '![](ch06list21-1.jpg)'
  id: totrans-1142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch06list21-1.jpg)'
- en: 'Our final step in preparation to use server data is to tell the Model to stop
    using fake data, as shown in [listing 6.22](#ch06list22). Changes are shown in
    **bold**:'
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 在准备使用服务器数据的过程中，我们的最后一步是告诉模型停止使用假数据，如[列表6.22](#ch06list22)所示。更改以粗体显示：
- en: Listing 6.22\. Update the Model to use “real” data—spa/js/spa.model.js
  id: totrans-1144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.22. 更新模型以使用“真实”数据—spa/js/spa.model.js
- en: '[PRE54]'
  id: totrans-1145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: After this last change, when we load our browser document ([spa/spa.html](http://spa/spa.html))
    we’ll find our SPA won’t function as before, and we’ll see errors in the console.
    If we want to continue development without the server, we can easily “flip the
    switch” and revert the `isFakeData` assignment to `true`.^([[1](#ch06fn01)]) Now
    we’re ready to add the server to our SPA.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次最后的更改之后，当我们加载我们的浏览器文档([spa/spa.html](http://spa/spa.html))时，我们会发现我们的单页应用(SPA)将无法像以前那样工作，我们会在控制台中看到错误。如果我们想在没有服务器的情况下继续开发，我们可以轻松地“切换开关”，将`isFakeData`赋值还原为`true`。[1](#ch06fn01)
    现在，我们已经准备好将服务器添加到我们的SPA中。
- en: ¹ Our browser may complain about not being able to find the Socket.IO library,
    but this should be harmless.
  id: totrans-1147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ 浏览器可能会抱怨找不到Socket.IO库，但这应该是无害的。
- en: 6.8\. Summary
  id: totrans-1148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.8. 摘要
- en: In this chapter we concluded our work on the Model. We methodically designed,
    specified, developed, and tested the `chat` object. As in [chapter 5](kindle_split_016.html#ch05),
    we used mock data from a Fake module to speed development. We then updated the
    Chat feature module to use the `chat` and `people` object APIs provided by the
    Model. We also created the Avatar feature module, which also used the same APIs.
    We then discussed data binding using jQuery. Finally, we added a Data module that
    will communicate with the Node.js server using Socket.IO. In [chapter 8](kindle_split_020.html#ch08)
    we’ll set up the server to work with the Data module. In the next chapter, we’ll
    get familiar with Node.js.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: '在本章中，我们完成了对模型的工作。我们系统地设计、指定、开发和测试了`chat`对象。与[第5章](kindle_split_016.html#ch05)一样，我们使用来自假模块的模拟数据来加速开发。然后，我们更新了聊天功能模块，使其使用模型提供的`chat`和`people`对象API。我们还创建了头像功能模块，它也使用了相同的API。然后，我们讨论了使用jQuery进行数据绑定。最后，我们添加了一个数据模块，该模块将使用Socket.IO与Node.js服务器通信。在第8章[8](kindle_split_020.html#ch08)中，我们将设置服务器以与数据模块协同工作。在下一章中，我们将熟悉Node.js。 '
