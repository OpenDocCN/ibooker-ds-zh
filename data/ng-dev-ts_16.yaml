- en: Appendix B. TypeScript essentials
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录B. TypeScript基础知识
- en: TypeScript was released in 2012 by Microsoft, and its core developer was Anders
    Hejlsberg. He’s also one of the authors of Turbo Pascal and Delphi, and is a lead
    architect of C#. In this appendix, we’ll cover main elements of the TypeScript
    syntax.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript由微软于2012年发布，其核心开发者是Anders Hejlsberg。他也是Turbo Pascal和Delphi的作者之一，并且是C#的首席架构师。在本附录中，我们将介绍TypeScript语法的核心元素。
- en: We’ll also show you how to turn TypeScript code into JavaScript (ES5) so it
    can be executed by any web browser or a standalone JavaScript engine. This appendix
    doesn’t offer a complete coverage of TypeScript. Refer to the TypeScript documentation
    at [www.typescriptlang.org/docs/home.html](http://www.typescriptlang.org/docs/home.html)
    for complete coverage. Also, TypeScript supports all syntax constructs described
    in [appendix A](kindle_split_025.xhtml#app01), so we don’t repeat those here.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将向您展示如何将TypeScript代码转换为JavaScript（ES5），以便它可以在任何Web浏览器或独立的JavaScript引擎中执行。本附录并不提供TypeScript的完整覆盖。有关完整信息，请参阅[www.typescriptlang.org/docs/home.html](http://www.typescriptlang.org/docs/home.html)上的TypeScript文档。此外，TypeScript支持附录A中描述的所有语法结构，因此我们在此不再重复。
- en: B.1\. The role of transpilers
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.1\. 转译器的作用
- en: Web browsers don’t understand any language but JavaScript. If the source code
    is written in TypeScript, it has to be *transpiled* into JavaScript before you
    can run it in a JavaScript engine, whether browser or standalone.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Web浏览器不理解任何语言，除了JavaScript。如果源代码是用TypeScript编写的，那么在您可以在JavaScript引擎（无论是浏览器还是独立引擎）中运行它之前，必须将其*转译*为JavaScript。
- en: '*Transpiling* means converting the source code of a program in one language
    into source code in another language. Many developers prefer to use the word *compiling*,
    so phrases like “TypeScript compiler” and “compile TypeScript into JavaScript”
    are also valid.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*转译*意味着将一种语言的程序源代码转换为另一种语言的源代码。许多开发者更喜欢使用“编译”这个词，所以像“TypeScript编译器”和“将TypeScript编译成JavaScript”这样的短语也是有效的。'
- en: '[Figure B.1](#app02fig01) shows TypeScript code on the left and its equivalent
    in an ES5 version of JavaScript generated by the TypeScript transpiler on the
    right. In TypeScript, we declared a variable `foo` of type `string`, but the transpiled
    version doesn’t have the type information. In TypeScript, we declared a class
    `Bar`, which was transpiled in a class-like pattern in the ES5 syntax.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[图B.1](#app02fig01)展示了左侧的TypeScript代码及其由TypeScript转译器生成的右侧ES5版本的JavaScript代码。在TypeScript中，我们声明了一个类型为`string`的变量`foo`，但转译后的版本没有类型信息。在TypeScript中，我们声明了一个名为`Bar`的类，它在ES5语法中以类似类的模式转译。'
- en: Figure B.1\. Transpiling TypeScript into ES5
  id: totrans-7
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图B.1\. 将TypeScript转换为ES5
- en: '![](Images/bfig01_alt.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/bfig01_alt.jpg)'
- en: You can try it for yourself by visiting the TypeScript playground at [www.typescriptlang.org/play](http://www.typescriptlang.org/play).
    If we had specified ES6 as a target for transpiling, the generated JavaScript
    code would look different; you’d see the `let` and `class` keywords on the right
    side as well.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问TypeScript playground在[www.typescriptlang.org/play](http://www.typescriptlang.org/play)来亲自尝试。如果我们指定ES6作为转换的目标，生成的JavaScript代码将会有所不同；您将在右侧看到`let`和`class`关键字。
- en: A combination of Angular with statically typed TypeScript simplifies the development
    of web applications. Good tooling and a static type analyzer substantially decrease
    the number of runtime errors and shorten the time to market. When complete, your
    Angular application will have lots of JavaScript code; and although developing
    in TypeScript may require you to write a little more code, you’ll reap benefits
    by saving time on testing and refactoring and minimizing the number of runtime
    errors.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 将Angular与静态类型的TypeScript结合使用可以简化Web应用程序的开发。良好的工具和静态类型分析器可以显著减少运行时错误数量并缩短上市时间。当您的Angular应用程序完成时，将包含大量的JavaScript代码；尽管在TypeScript中开发可能需要您编写更多的代码，但通过节省测试和重构的时间以及最小化运行时错误数量，您将获得收益。
- en: B.2\. Getting started with TypeScript
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.2\. 开始使用TypeScript
- en: Microsoft has open sourced TypeScript and hosts the TypeScript repository on
    GitHub at [https://github.com/Microsoft/TypeScript/wiki/Roadmap](https://github.com/Microsoft/TypeScript/wiki/Roadmap).
    You can install the TypeScript compiler using npm. The TypeScript site [www.typescriptlang.org](http://www.typescriptlang.org)
    has the language documentation and has a web-hosted TypeScript compiler (under
    the Playground menu), where you can enter TypeScript code and compile it to JavaScript
    interactively, as shown in [figure B.1](#app02fig01). Enter TypeScript code on
    the left, and its JavaScript version (ES5) is displayed on the right. Click the
    Run button to execute the transpiled code (open the browser console to see the
    output produced by your code, if any).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 微软已经开源了TypeScript，并在GitHub上托管了TypeScript仓库，网址为[https://github.com/Microsoft/TypeScript/wiki/Roadmap](https://github.com/Microsoft/TypeScript/wiki/Roadmap)。你可以使用npm安装TypeScript编译器。TypeScript网站[www.typescriptlang.org](http://www.typescriptlang.org)提供了语言文档，并有一个托管在网页上的TypeScript编译器（在Playground菜单下），你可以在这里交互式地输入TypeScript代码并将其编译为JavaScript，如图B.1所示。在左侧输入TypeScript代码，其JavaScript版本（ES5）将在右侧显示。点击运行按钮执行转换后的代码（如果代码有输出，可以在浏览器控制台查看）。
- en: Such interactive tools will suffice for learning the language syntax, but for
    real-world development, you’ll need better tooling to be productive. You may decide
    to use an IDE or a text editor, but having the TypeScript compiler installed locally
    is a must for development. We’ll show you how to install the TypeScript compiler
    and run code samples in this appendix, using the Node JavaScript engine.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的交互式工具足以学习语言语法，但为了实际开发，你需要更好的工具以提高生产力。你可能决定使用IDE或文本编辑器，但本地安装TypeScript编译器对于开发是必须的。我们将在附录中向你展示如何安装TypeScript编译器并运行代码示例，使用的是Node
    JavaScript引擎。
- en: We assume that you have Node.js and npm installed on your computer. If you don’t
    have them yet, refer to [appendix C](kindle_split_027.xhtml#app03).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设你已经在计算机上安装了Node.js和npm。如果你还没有安装，请参阅[附录C](kindle_split_027.xhtml#app03)。
- en: B.2.1\. Installing and using the TypeScript compiler
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: B.2.1\. 安装和使用TypeScript编译器
- en: 'We’ll use Node.js’s npm package manager to install the TypeScript compiler.
    To install it globally, run the following npm command in the Terminal window:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Node.js的npm包管理器来安装TypeScript编译器。要在全局范围内安装，请在终端窗口中运行以下npm命令：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `-g` option installs the TypeScript compiler globally on your computer,
    so it’s available from the Terminal window in all your projects. To check the
    version of your TypeScript compiler, run the following command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`-g`选项将在你的计算机上全局安装TypeScript编译器，因此它可以从终端窗口中的所有项目中访问。要检查TypeScript编译器的版本，请运行以下命令：'
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As mentioned earlier, code written in TypeScript has to be transpiled into
    JavaScript so web browsers can execute it. TypeScript code is saved in files with
    the .ts extension. Say you write a script and save it in the main.ts file. The
    following command will transpile main.ts into main.js:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，用TypeScript编写的代码必须转换为JavaScript，以便网页浏览器能够执行它。TypeScript代码保存在以.ts扩展名命名的文件中。假设你编写了一个脚本并将其保存到main.ts文件中。以下命令将main.ts转换为main.js：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can also generate source map files that map lines in the TypeScript program
    to corresponding lines in the generated JavaScript. With source maps, you can
    place breakpoints in your TypeScript code while running it in the browser, even
    though it executes JavaScript. To compile main.ts into main.js while also generating
    the source map file main.js.map, run the following command:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以生成源映射文件，将TypeScript程序中的行映射到生成的JavaScript中的对应行。有了源映射，你可以在浏览器中运行TypeScript代码时设置断点，即使它执行的是JavaScript。要将main.ts转换为main.js并生成源映射文件main.js.map，请运行以下命令：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If a browser has the Developer Tools panel open, it loads the source map file
    along with the JavaScript file, and you can debug your TypeScript code there as
    if the browser runs TypeScript.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果浏览器打开了开发者工具面板，它将加载源映射文件以及JavaScript文件，你可以在那里调试TypeScript代码，就像浏览器运行TypeScript一样。
- en: During compilation, TypeScript’s compiler removes from the generated code all
    TypeScript types, interfaces, and keywords not supported by JavaScript. By providing
    compiler options, you can generate JavaScript compliant with ES3, ES5, ES6, or
    newer syntax.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译过程中，TypeScript编译器会从生成的代码中移除所有不被JavaScript支持的TypeScript类型、接口和关键字。通过提供编译器选项，你可以生成符合ES3、ES5、ES6或更新语法的JavaScript。
- en: 'Here’s how to transpile the code to ES5-compatible syntax (the `--t` option
    specifies the target syntax):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将代码转换为ES5兼容语法的步骤（`--t`选项指定目标语法）：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can start your TypeScript compiler in watch mode by providing the `-w`
    option. In this mode, whenever you modify and save your code, it’s automatically
    transpiled into corresponding JavaScript files. To compile and watch all .ts files
    from the current directory, run the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过提供`-w`选项来以监视模式启动TypeScript编译器。在此模式下，每次您修改并保存代码时，它都会自动转换为相应的JavaScript文件。要编译并监视当前目录中的所有.ts文件，请运行以下命令：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The compiler will compile all the TypeScript files, print error messages (if
    any) on the console, and continue watching the files for changes. As soon as a
    file changes, `tsc` will immediately recompile it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将编译所有TypeScript文件，打印错误消息（如果有）到控制台，并继续监视文件的变化。一旦文件发生变化，`tsc`将立即重新编译它。
- en: '|  |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Typically, we turn off TypeScript autocompilation in the IDE. With Angular apps,
    we use Angular CLI to compile and bundle the entire project. The IDEs use the
    TypeScript code analyzer to highlight errors even without compilation.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们在IDE中关闭TypeScript自动编译。对于Angular应用程序，我们使用Angular CLI来编译和打包整个项目。IDE使用TypeScript代码分析器来突出显示错误，即使没有编译。
- en: '|  |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`tsc` offers dozens of compilation options described at [http://mng.bz/rf14](http://mng.bz/rf14).
    You can preconfigure the process of compilation (specifying the source and destination
    directories, source map generation, and so on). The presence of the tsconfig.json
    file in the project directory means you can enter `tsc` on the command line, and
    the compiler will read all the options from tsconfig.json. A sample tsconfig.json
    file from one of the Angular projects is shown in the following listing.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`tsc`提供了数十种编译选项，描述在[http://mng.bz/rf14](http://mng.bz/rf14)。您可以预先配置编译过程（指定源和目标目录、生成源映射等）。项目目录中存在tsconfig.json文件意味着您可以在命令行中输入`tsc`，编译器将读取所有选项从tsconfig.json。以下是一个Angular项目的tsconfig.json文件示例。'
- en: Listing B.1\. tsconfig.json
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表B.1\. tsconfig.json
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* Transpiles .ts files located in the src directory**'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将位于src目录中的.ts文件转换为**'
- en: '***2* Saves the generated .js files in the dist directory**'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将生成的.js文件保存到dist目录**'
- en: '***3* Generates sourcemaps**'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 生成源映射**'
- en: '***4* Looks for modules according to the structure of Node-based projects**'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 根据基于Node的项目结构查找模块**'
- en: '***5* If any of the files has compilation errors, doesn’t generate JavaScript
    files**'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 如果任何文件有编译错误，则不会生成JavaScript文件**'
- en: '***6* Transpiles the .ts file into ES5 syntax**'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 将.ts文件转换为ES5语法**'
- en: '***7* Required to support decorators**'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 必须支持装饰器**'
- en: Every Angular/TypeScript app uses *decorators* with classes or class members
    (such as `@Component()` and `@Input()`). We’ll discuss decorators later in this
    appendix.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Angular/TypeScript应用程序都使用与类或类成员（如`@Component()`和`@Input()`）一起的装饰器。我们将在本附录的后面讨论装饰器。
- en: 'If you want to exclude some of your project files from compilation, add the
    `exclude` property to tsconfig.json. This is how you can exclude the entire content
    of the node_modules directory:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想排除项目中的一些文件不进行编译，请向tsconfig.json添加`exclude`属性。这样您可以排除node_modules目录的全部内容：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: B.2.2\. TypeScript as a superset of JavaScript
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: B.2.2\. TypeScript作为JavaScript的超集
- en: TypeScript supports ES5, ES6, and newer ECMAScript syntax. Just change the name
    extension of a file with JavaScript code from .js to .ts, and it’ll become valid
    TypeScript code. Being a superset of JavaScript, TypeScript adds a number of useful
    features to JavaScript. We’ll review them next.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript支持ES5、ES6和更新的ECMAScript语法。只需将具有JavaScript代码的文件名扩展名从.js更改为.ts，它就会成为有效的TypeScript代码。作为JavaScript的超集，TypeScript为JavaScript添加了多个有用的功能。我们将在下面回顾它们。
- en: B.3\. How to run the code samples
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.3\. 如何运行代码示例
- en: 'To run the code samples from this appendix locally on your computer, perform
    the following steps:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的计算机上本地运行此附录中的代码示例，请执行以下步骤：
- en: '**1**.  Install Node.js from [https://nodejs.org/en/download/](https://nodejs.org/en/download/)
    (use the current version).'
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  从[https://nodejs.org/en/download/](https://nodejs.org/en/download/)安装Node.js（使用当前版本）。'
- en: '**2**.  Clone or download the [https://github.com/Farata/angulartypescript](https://github.com/Farata/angulartypescript)
    repository into any directory.'
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  将[https://github.com/Farata/angulartypescript](https://github.com/Farata/angulartypescript)存储库克隆或下载到任何目录。'
- en: '**3**.  In the command window, change into this directory, and then go to the
    code-samples/appendixB subdirectory.'
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**.  在命令窗口中，切换到该目录，然后转到code-samples/appendixB子目录。'
- en: '**4**.  Install the project dependencies (the TypeScript compiler) *locally*
    by running `npm install`.'
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**.  通过运行`npm install`在本地安装项目依赖项（TypeScript编译器）。'
- en: '**5**.  Use the locally installed TypeScript compiler to compile all code samples
    into the dist directory by running `npm run tsc`, which will transpile all code
    samples from the src directory into the dist directory.'
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**.  使用本地安装的 TypeScript 编译器将所有代码示例编译到 dist 目录，通过运行 `npm run tsc` 实现，这将把
    src 目录中的所有代码示例转换到 dist 目录。'
- en: '**6**.  To run a particular code sample (such as fatArrow.js) use the following
    command: `node dist/fatArrow`.'
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**6**.  要运行特定的代码示例（例如 fatArrow.js），请使用以下命令：`node dist/fatArrow`。'
- en: B.4\. Optional types
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.4\. 可选类型
- en: 'You can declare variables and provide types for all or some of them. The following
    two lines are valid TypeScript syntax:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以声明变量并为所有或其中一些变量提供类型。以下两行是有效的 TypeScript 语法：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|  |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Tip
- en: In the second line, specifying the type `string` is unnecessary. Since the variable
    is initialized with the string, TypeScript will guess (infer) that the type of
    `name2` is `string`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行，指定类型 `string` 是不必要的。因为变量是用字符串初始化的，TypeScript 会推断出 `name2` 的类型是 `string`。
- en: '|  |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If you use types, TypeScript’s transpiler can detect mismatched types during
    development, and IDEs will offer code completion and refactoring support. This
    will increase your productivity on any decent-sized project. Even if you don’t
    use types in declarations, TypeScript will guess the type based on the assigned
    value and will still do type checking afterward. This is called type *inference*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用类型，TypeScript 的转换器可以在开发过程中检测到类型不匹配，IDE 将提供代码补全和重构支持。这将提高你在任何中等规模项目上的生产力。即使你不在声明中使用类型，TypeScript
    也会根据分配的值猜测类型，并在之后进行类型检查。这被称为类型 *推断*。
- en: 'The following fragment of TypeScript code shows that you can’t assign a numeric
    value to a `name1` variable that was meant to be a `string`, even though it was
    initially declared without a type (JavaScript syntax). After initializing this
    variable with a `string` value, the inferred typing won’t let you assign the numeric
    value to `name1`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 TypeScript 代码片段显示，你不能将数值赋给原本打算为 `string` 的 `name1` 变量，即使它最初没有声明类型（JavaScript
    语法）。在用字符串值初始化这个变量之后，推断类型不会让你将数值赋给 `name1`：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* Assigning a value of a different type to a variable is valid in JavaScript
    but invalid in TypeScript because of the inferred type.**'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将不同类型的值赋给变量在 JavaScript 中是有效的，但在 TypeScript 中由于推断类型的原因是无效的。**'
- en: 'In TypeScript, you can declare typed variables, function parameters, and return
    values. There are four keywords for declaring basic types: `number`, `boolean`,
    `string`, and `void`. The last one indicates the absence of a return value in
    a function declaration. A variable can have a value of type `null` or `undefined`,
    similar to JavaScript.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，你可以声明具有类型的变量、函数参数和返回值。有四个关键字用于声明基本类型：`number`、`boolean`、`string`
    和 `void`。最后一个表示函数声明中没有返回值。变量可以具有 `null` 或 `undefined` 类型的值，类似于 JavaScript。
- en: 'Here are some examples of variables declared with explicit types:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些使用显式类型声明的变量的例子：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|  |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Starting from TypeScript 2.7, you need to either initialize variables during
    declaration or initialize (member variables) in the constructor.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从 TypeScript 2.7 版本开始，你需要在声明时初始化变量，或者在构造函数中初始化（成员变量）。
- en: '|  |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'All of these types are subtypes of the `any` type. You may as well explicitly
    declare a variable, specifying `any` as its type. In this case, inferred typing
    isn’t applied. Both of these declarations are valid:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些类型都是 `any` 类型的子类型。你也可以显式声明一个变量，指定 `any` 作为其类型。在这种情况下，不会应用推断类型。这两个声明都是有效的：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If variables are declared with explicit types, the compiler will check their
    values to ensure that they match the declarations. TypeScript includes other types
    that are used in interactions with the web browser, such as `HTMLElement` and
    `Document`. If you define a class or an interface, it can be used as a custom
    type in variable declarations. We’ll introduce classes and interfaces later, but
    first let’s get familiar with TypeScript functions, which are the most-used constructs
    in JavaScript.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果变量使用显式类型声明，编译器将检查它们的值以确保它们与声明匹配。TypeScript 包含其他在浏览器交互中使用的类型，例如 `HTMLElement`
    和 `Document`。如果你定义了一个类或接口，它可以用作变量声明中的自定义类型。我们将在后面介绍类和接口，但首先让我们熟悉 TypeScript 函数，这是
    JavaScript 中最常用的结构。
- en: B.5\. Functions
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.5\. 函数
- en: TypeScript functions and function expressions are similar to JavaScript functions,
    but you can explicitly declare parameter types and return values. Let’s write
    a JavaScript function that calculates tax. It’ll have three parameters and will
    calculate tax based on the state, income, and number of dependents. For each dependent,
    the person is entitled to a $500 or $300 tax deduction, depending on the state
    the person lives in. The function is shown in the following listing.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 函数和函数表达式与 JavaScript 函数类似，但你可以显式声明参数类型和返回值。让我们编写一个 JavaScript 函数来计算税费。它将有三个参数，并将根据州、收入和受抚养人数来计算税费。对于每个受抚养人，根据个人居住的州，个人有权获得
    500 美元或 300 美元的税费减免。该函数如下所示。
- en: Listing B.2\. Calculating tax in JavaScript
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 B.2\. 在 JavaScript 中计算税费
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Say a person with an income of $50,000 lives in the state of New Jersey and
    has two dependents. Let’s invoke `calcTax()`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个收入为 50,000 美元的人居住在新泽西州，并且有两个受抚养人。让我们调用 `calcTax()`：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `tax` variable gets the value of `1,900`, which is correct. Even though
    `calcTax()` doesn’t declare any types for the function parameters, you can guess
    them based on the parameter names. Now let’s invoke it the wrong way, passing
    a `string` value for a number of dependents:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`tax` 变量得到 `1,900` 的值，这是正确的。即使 `calcTax()` 没有为函数参数声明任何类型，你也可以根据参数名称猜测它们。现在让我们以错误的方式调用它，为受抚养人数传递一个
    `string` 类型的值：'
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You won’t know there’s a problem until you invoke this function. The `tax` variable
    will have a `NaN` value (not a number). A bug sneaked in just because you didn’t
    have a chance to explicitly specify the types of the parameters. The next listing
    rewrites this function in TypeScript, declaring types for parameters and the return
    value.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你只有在调用此函数时才会发现问题。`tax` 变量将具有 `NaN` 值（不是一个数字）。仅仅因为你没有机会显式指定参数的类型，就悄悄地引入了一个错误。下一个列表将此函数重写为
    TypeScript，为参数和返回值声明类型。
- en: Listing B.3\. Calculating tax in TypeScript
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 B.3\. 在 TypeScript 中计算税费
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now there’s no way to make the same mistake and pass a `string` value for the
    number of dependents:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在没有任何方法可以犯同样的错误，并为受抚养人数传递一个 `string` 类型的值：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The TypeScript compiler will display an error saying, “Argument of type `string`
    is not assignable to parameter of type `number`.” Moreover, the return value of
    the function is declared as `number`, which stops you from making another mistake
    and assigning the result of the tax calculations to a non-numeric variable:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 编译器将显示一个错误信息，说“类型 `string` 的参数不能分配给类型 `number` 的参数。”此外，函数的返回值声明为
    `number`，这阻止你将税费计算的结果分配给非数字变量：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The compiler will catch this, producing the error “The type ‘number’ is not
    assignable to type ‘string’: var tax: string.” This kind of type checking during
    compilation can save you a lot of time on any project.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '编译器会捕获这个错误，产生错误信息“类型‘number’不能分配给类型‘string’：var tax: string。”这种在编译期间进行的类型检查可以在任何项目中为你节省大量时间。'
- en: B.5.1\. Default parameters
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: B.5.1\. 默认参数
- en: 'While declaring a function, you can specify default parameter values. For example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明函数时，你可以指定默认参数值。例如：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There’s no need to change even one line of code in the body of `calcTax()`.
    You now have the freedom to invoke it with either two or three parameters:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至不需要更改 `calcTax()` 函数体中的任何一行代码。现在你可以自由地用两个或三个参数调用它：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The results of both invocations will be the same.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 两次调用的结果将相同。
- en: B.5.2\. Optional parameters
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: B.5.2\. 可选参数
- en: In TypeScript, you can easily mark function parameters as optional by appending
    a question mark to the parameter name. The only restriction is that optional parameters
    must come last in the function declaration. When you write code for functions
    with optional parameters, you need to provide application logic that handles the
    cases when the optional parameters aren’t provided.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，你可以通过在参数名称后附加一个问号来轻松地将函数参数标记为可选。唯一的限制是可选参数必须在函数声明中最后出现。当你为具有可选参数的函数编写代码时，你需要提供应用程序逻辑来处理可选参数未提供的情况。
- en: 'Let’s modify the tax-calculation function in the following listing: if no dependents
    are specified, it won’t apply any deduction to the calculated tax.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改以下列表中的税费计算函数：如果没有指定受抚养人，则不会对计算出的税费应用任何减免。
- en: Listing B.4\. Calculating tax in TypeScript, modified
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 B.4\. 在 TypeScript 中计算税费，已修改
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Note the question mark in `dependents?: number`. Now the function checks whether
    the value for dependents was provided. If it wasn’t, you assign 0 to the `deduction`
    variable; otherwise, you deduct 500 for each dependent.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '注意`dependents?: number`中的问号。现在函数会检查`dependents`的值是否提供。如果没有提供，则将0赋值给`deduction`变量；否则，每个受抚养人扣除500。'
- en: 'Running the preceding script will produce the following output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的脚本将产生以下输出：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|  |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: TypeScript supports the syntax of fat-arrow expressions described in [section
    A.5](kindle_split_025.xhtml#app01lev1sec5) in [appendix A](kindle_split_025.xhtml#app01).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 支持附录A中[第A.5节](kindle_split_025.xhtml#app01lev1sec5)中描述的胖箭头表达式语法。
- en: '|  |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Function overloading**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数重载**'
- en: JavaScript doesn’t support function overloading, so having several functions
    with the same name but different lists of arguments isn’t possible. TypeScript
    supports function overloading, but because the code has to be transpiled into
    a single JavaScript function, the syntax for overloading isn’t elegant.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 不支持函数重载，因此不可能有多个具有相同名称但参数列表不同的函数。TypeScript 支持函数重载，但由于代码必须转换为单个 JavaScript
    函数，因此重载的语法并不优雅。
- en: 'You can declare several signatures of a function with one and only one body,
    where you need to check the number and types of the arguments and execute the
    appropriate portion of the code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以声明一个只有一个主体且只有一个签名的函数，其中需要检查参数的数量和类型，并执行相应的代码部分：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '|  |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: B.6\. Classes
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.6\. 类
- en: If you have Java or C# experience, you’ll be familiar with the concepts of classes
    and inheritance in their classical form. In those languages, the definition of
    a class is loaded in memory as a separate entity (like a blueprint) and is shared
    by all instances of this class. If a class is inherited from another one, the
    object is instantiated using the combined blueprint of both classes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 Java 或 C#，你将熟悉它们经典形式的类和继承概念。在这些语言中，类的定义作为单独的实体（如蓝图）加载到内存中，并由该类的所有实例共享。如果一个类从另一个类继承，则使用两个类的组合蓝图来实例化对象。
- en: TypeScript is a superset of JavaScript, which only supports *prototypal inheritance*,
    where you can create an inheritance hierarchy by attaching one object to the *prototype*
    property of another. In this case, an inheritance (or rather, a linkage) of *objects*
    is created dynamically.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 是 JavaScript 的超集，它只支持*原型继承*，你可以通过将一个对象附加到另一个对象的*原型*属性来创建继承层次结构。在这种情况下，创建了一个动态的*对象*继承（或更确切地说，是链接）。
- en: In TypeScript, the `class` keyword is syntactic sugar to simplify coding. In
    the end, your classes will be transpiled into JavaScript objects with prototypal
    inheritance. In JavaScript, you can declare a constructor function and instantiate
    it with the `new` keyword. In TypeScript, you can also declare a class and instantiate
    it with the `new` operator.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，`class`关键字是简化编码的语法糖。最终，你的类将被转换为具有原型继承的 JavaScript 对象。在 JavaScript
    中，你可以声明一个构造函数并使用`new`关键字来实例化它。在 TypeScript 中，你也可以声明一个类并使用`new`运算符来实例化它。
- en: A class can include a constructor, fields (properties), and methods. Declared
    properties and methods are often referred to as *class members*. We’ll illustrate
    the syntax of TypeScript classes by showing you a series of code samples and comparing
    them with the equivalent ES5 syntax.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以包含构造函数、字段（属性）和方法。声明的属性和方法通常被称为*类成员*。我们将通过一系列代码示例来展示 TypeScript 类的语法，并将它们与等效的
    ES5 语法进行比较。
- en: Let’s create a simple `Person` class that contains four properties to store
    the first and last name, age, and Social Security number (a unique identifier
    assigned to citizens and residents of the United States). At left in [figure B.2](#app02fig02),
    you can see the TypeScript code that declares and instantiates the `Person` class;
    on the right is a JavaScript closure generated by the `tsc` compiler. By creating
    a closure for the `Person` function, the TypeScript compiler enables the mechanism
    for exposing and hiding the elements of the `Person` object.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的`Person`类，该类包含四个属性以存储姓名、年龄和社会安全号码（美国公民和居民的唯一标识符）。在[图B.2](#app02fig02)的左侧，你可以看到声明和实例化`Person`类的
    TypeScript 代码；在右侧是`tsc`编译器生成的 JavaScript 闭包。通过为`Person`函数创建闭包，TypeScript 编译器启用了暴露和隐藏`Person`对象元素的功能。
- en: Figure B.2\. Transpiling a TypeScript class into a JavaScript closure
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图B.2\. 将 TypeScript 类转换为 JavaScript 闭包
- en: '![](Images/bfig02_alt.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/bfig02_alt.jpg)'
- en: TypeScript also supports class constructors that allow you to initialize object
    variables while instantiating the object. A class constructor is invoked only
    once during object creation. The left side of [figure B.2](#app02fig02) shows
    the `Person` class, which uses the `constructor` keyword that initializes the
    fields of the class with the values given to the constructor.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 还支持类构造函数，允许你在创建对象时初始化对象变量。类构造函数在对象创建期间只调用一次。图 B.2 的左侧显示了 `Person`
    类，它使用 `constructor` 关键字用构造函数提供的值初始化类的字段。
- en: B.6.1\. Access modifiers
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: B.6.1\. 访问修饰符
- en: JavaScript doesn’t have a way to declare a variable or a method as *private*
    (hidden from external code). To hide a property (or a method) in an object, you
    need to create a closure that neither attaches this property to the `this` variable
    nor `returns` it in the closure’s return statement.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 没有声明变量或方法为 *私有*（对外部代码隐藏）的方式。要隐藏对象中的属性（或方法），你需要创建一个闭包，该闭包既不将此属性附加到
    `this` 变量，也不在闭包的返回语句中 `returns` 它。
- en: TypeScript provides `public`, `protected`, and `private` keywords to help you
    control access to object members during the development phase. By default, all
    class members have public access, and they’re visible from outside the class.
    If a member is declared with the `protected` modifier, it’s visible in the class
    and its subclasses. Class members declared as `private` are visible only in the
    class.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 提供了 `public`、`protected` 和 `private` 关键字，以帮助你在开发阶段控制对对象成员的访问。默认情况下，所有类成员都具有公共访问权限，并且可以从类外部可见。如果一个成员用
    `protected` 修饰符声明，它在类及其子类中可见。声明为 `private` 的类成员仅在类内部可见。
- en: Let’s use the `private` keyword to hide the value of the `_ssn` property so
    it can’t be directly accessed from outside of the `Person` object. We’ll show
    you two versions of declaring a class with properties that use access modifiers.
    The longer version of the class looks like the following listing.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `private` 关键字隐藏 `_ssn` 属性的值，使其不能从 `Person` 对象外部直接访问。我们将向您展示两种声明使用访问修饰符的类的版本。类的较长版本如下所示。
- en: Listing B.5\. Using a private property
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 B.5\. 使用私有属性
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Note that the name of the private variable starts with an underscore: `_ssn`.
    This is a naming convention for private properties.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，私有变量的名称以下划线开头：`_ssn`。这是私有属性的命名约定。
- en: 'The last line of [listing B.5](#app02ex05) attempts to access the `_ssn` private
    property from outside, so the TypeScript code analyzer will give you a compilation
    error: “Property ‘_ssn’ is private and is only accessible in class ‘Person’.”
    But unless you use the `--noEmitOnError` compiler option, the erroneous code will
    still be transpiled into JavaScript:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 B.5](#app02ex05) 的最后一行尝试从外部访问 `_ssn` 私有属性，因此 TypeScript 代码分析器会给你一个编译错误：“属性
    ‘_ssn’ 是私有的，并且只能在类 ‘Person’ 中访问。”但除非你使用 `--noEmitOnError` 编译器选项，否则有错误的代码仍然会被转换为
    JavaScript：'
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `private` keyword only makes it private in the TypeScript code, but the
    generated JavaScript code will treat all properties and methods of the class as
    public anyway.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`private` 关键字只在 TypeScript 代码中使其私有，但生成的 JavaScript 代码仍然会将类的所有属性和方法视为公共的。'
- en: TypeScript also allows you to provide access modifiers with constructor arguments,
    as shown in the short version of the `Person` class in the following listing.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 还允许你在构造函数参数中提供访问修饰符，如下列 `Person` 类的简短版本所示。
- en: Listing B.6\. Using access modifiers
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 B.6\. 使用访问修饰符
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When you use a constructor with access modifiers, the TypeScript compiler takes
    it as an instruction to create and retain class properties matching the constructor
    arguments. You don’t need to explicitly declare and initialize them. Both the
    short and long versions of the `Person` class generate the same JavaScript, but
    we recommend using the shorter syntax as shown in [figure B.3](#app02fig03).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用具有访问修饰符的构造函数时，TypeScript 编译器将其视为创建并保留与构造函数参数匹配的类属性的指令。你不需要显式声明和初始化它们。`Person`
    类的简短和长版本生成相同的 JavaScript，但我们建议使用如 [图 B.3](#app02fig03) 所示的较短的语法。
- en: Figure B.3\. Transpiling a TypeScript class with `constructor`
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 B.3\. 使用 `constructor` 转译 TypeScript 类
- en: '![](Images/bfig03_alt.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/bfig03_alt.jpg)'
- en: B.6.2\. Methods
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: B.6.2\. 方法
- en: When a function is declared in a class, it’s called a *method*. In JavaScript,
    you need to declare methods on the prototype of an object, but with a class, you
    declare a method by specifying a name followed by parentheses and curly braces,
    as you would in other object-oriented languages.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当在类中声明一个函数时，它被称为*方法*。在JavaScript中，你需要在对象的原型上声明方法，但使用类时，你通过指定一个名称后跟括号和花括号来声明方法，就像在其他面向对象的语言中一样。
- en: The next code listing shows how you can declare and use a `MyClass` class with
    a `doSomething()` method that has one argument and no return value.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码列表显示了如何声明和使用一个具有一个参数且没有返回值的`doSomething()`方法的`MyClass`类。
- en: Listing B.7\. Creating a method
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表B.7\. 创建一个方法
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|  |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Static and instance members**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态和实例成员**'
- en: 'The code in listing B 7, as well as the class shown in [figure B.2](#app02fig02),
    creates an instance of the class first and then accesses its members using a reference
    variable that points at this instance:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 列表B 7中的代码以及[图B.2](#app02fig02)中显示的类首先创建了一个类的实例，然后使用指向此实例的引用变量来访问其成员：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If a class property or method were declared with the `static` keyword, its
    values would be shared between all instances of the class, and you wouldn’t need
    to create an instance to access static members. Instead of using a reference variable
    (such as `mc`), you’d use the name of the class:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`static`关键字声明了一个类属性或方法，其值将在类的所有实例之间共享，并且你不需要创建一个实例来访问静态成员。而不是使用引用变量（例如`mc`），你将使用类的名称：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you instantiate a class and need to invoke a class method from within another
    method declared in the same class, don’t use the `this` keyword (as in, `this.doSomething(5)`),
    but still use the class name, as in `MyClass.doSomething(10);`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你实例化了一个类，并且需要在同一类中声明的另一个方法中调用类方法，不要使用`this`关键字（例如，`this.doSomething(5)`），但仍然使用类名，例如`MyClass.doSomething(10);`。
- en: '|  |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: B.6.3\. Inheritance
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: B.6.3\. 继承
- en: JavaScript supports prototypal *object-based* inheritance, where one object
    can assign another object as its prototype, and this happens during runtime. TypeScript
    has the `extends` keyword for inheritance of classes, like ES6 and other object-oriented
    languages. But during transpiling to JavaScript, the generated code uses the syntax
    of prototypal inheritance.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript支持基于原型的*对象继承*，其中一个对象可以将另一个对象作为其原型，这发生在运行时。TypeScript有`extends`关键字用于类的继承，就像ES6和其他面向对象的语言一样。但在转换为JavaScript时，生成的代码使用原型继承的语法。
- en: '[Figure B.4](#app02fig04) shows how to create an `Employee` class (line 9)
    that extends the `Person` class. On the right, you can see the transpiled JavaScript
    version, which uses prototypal inheritance. The TypeScript version of the code
    is more concise and easier to read.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[图B.4](#app02fig04)显示了如何创建一个扩展`Person`类的`Employee`类（第9行）。在右侧，你可以看到转换后的JavaScript版本，它使用原型继承。TypeScript代码版本更简洁，更容易阅读。'
- en: Figure B.4\. Class inheritance in TypeScript
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图B.4\. TypeScript中的类继承
- en: '![](Images/bfig04_alt.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/bfig04_alt.jpg)'
- en: Let’s add a constructor and a `department` property to the `Employee` class
    in the next listing.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一个列表中向`Employee`类添加一个构造函数和一个`department`属性。
- en: Listing B.8\. Using inheritance
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表B.8\. 使用继承
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '***1* Declares a property department**'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明一个属性部门**'
- en: '***2* Creates a constructor that has an additional department argument**'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建一个具有额外部门参数的构造函数**'
- en: '***3* A subclass that declares a constructor must invoke the constructor of
    the superclass using super().**'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 声明构造函数的子类必须使用super()调用超类的构造函数。**'
- en: If you invoke a method declared in a superclass on the object of the subclass
    type, you can use the name of this method as if it were declared in the subclass.
    But sometimes you want to specifically call the method of the superclass, and
    that’s when you should use the `super` keyword.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个子类类型的对象上调用在超类中声明的函数，你可以使用这个方法的名字，就像它在子类中声明的一样。但有时你想要特别调用超类的方法，这时你应该使用`super`关键字。
- en: 'The `super` keyword can be used two ways. In the constructor of a derived class,
    you invoke it as a method. You can also use the `super` keyword to specifically
    call a method of the superclass. It’s typically used with method overriding. For
    example, if both a superclass and its descendant have a `doSomething()` method,
    the descendant can reuse the functionality programmed in the superclass and add
    other functionality as well:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`super` 关键字有两种用法。在派生类的构造函数中，你可以将其作为方法调用。你还可以使用 `super` 关键字来特别调用超类的方法。它通常与方法重写一起使用。例如，如果超类及其子类都有
    `doSomething()` 方法，子类可以重用超类中编写的功能，并添加其他功能：'
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: B.7\. Interfaces
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.7\. 接口
- en: JavaScript doesn’t support interfaces, which, in other object-oriented languages,
    are used to introduce a *code contract* that an API has to abide by. An example
    of a contract can be class X declaring that it implements interface Y. If class
    X won’t include an implementation of the methods declared in interface Y, it’s
    considered a violation of the contract and won’t compile.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 不支持接口，在其他面向对象的语言中，接口用于引入一个 API 必须遵守的 *代码契约*。契约的一个例子可以是类 X 声明它实现了接口
    Y。如果类 X 没有实现接口 Y 中声明的方法，则视为违反契约且无法编译。
- en: TypeScript includes the keywords `interface` and `implements` to support interfaces,
    but interfaces aren’t transpiled into JavaScript code. They just help you avoid
    using the wrong types during development.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 包含了 `interface` 和 `implements` 关键字来支持接口，但接口不会转换成 JavaScript 代码。它们只是帮助你在开发过程中避免使用错误的数据类型。
- en: 'In TypeScript, we use interfaces for two reasons:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，我们使用接口有两个原因：
- en: Declare an interface that defines a custom type containing a number of properties.
    Then declare a method that has an argument of such a type. The compiler will check
    that the object given as an argument includes all the properties declared in the
    interface.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个定义包含多个属性的定制类型的接口。然后声明一个具有这种类型参数的方法。编译器将检查作为参数给出的对象是否包含接口中声明的所有属性。
- en: Declare an interface that includes abstract (non-implemented) methods. When
    a class declares that it implements this interface, the class must provide an
    implementation for all the abstract methods.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个包含抽象（未实现）方法的接口。当一个类声明实现了这个接口时，该类必须为所有抽象方法提供实现。
- en: Let’s apply these two patterns by example.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过示例应用这两种模式。
- en: B.7.1\. Declaring custom types with interfaces
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: B.7.1\. 使用接口声明自定义类型
- en: When you use JavaScript frameworks, you may run into an API that requires some
    sort of configuration object as a function parameter. To figure out which properties
    must be provided in this object, either open the documentation for the API or
    read the source code of the framework. In TypeScript, you can declare an interface
    that includes all the properties, and their types, that must be present in a configuration
    object.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 JavaScript 框架时，你可能会遇到需要某种配置对象作为函数参数的 API。为了找出这个对象中必须提供哪些属性，要么打开 API 的文档，要么阅读框架的源代码。在
    TypeScript 中，你可以声明一个包含所有必须存在于配置对象中属性及其类型的接口。
- en: 'Let’s see how to do this in the `Person` class, which contains a constructor
    with four arguments: `firstName`, `lastName`, `age`, and `ssn`. This time, in
    the following listing, you’ll declare an `IPerson` interface that contains the
    four members, and you’ll modify the constructor of the `Person` class to use an
    object of this custom type as an argument.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在 `Person` 类中实现这一点，该类包含一个带有四个参数的构造函数：`firstName`、`lastName`、`age` 和 `ssn`。这次，在下面的列表中，你将声明一个包含这四个成员的
    `IPerson` 接口，并且你将修改 `Person` 类的构造函数以使用这种自定义类型的对象作为参数。
- en: Listing B.9\. Declaring an interface
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 B.9\. 声明一个接口
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '***1* Declares an IPerson interface with ssn as an optional member (note the
    question mark)**'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明一个带有 ssn 作为可选成员（注意问号）的 IPerson 接口**'
- en: '***2* The Person class has a constructor with one argument of type IPerson.**'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* Person 类有一个类型为 IPerson 的参数的构造函数。**'
- en: '***3* creates an aPerson object literal with members compatible with IPerson**'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 创建一个与 IPerson 兼容的 aPerson 对象字面量**'
- en: '***4* Instantiates the Person object, providing an object of type IPerson as
    an argument**'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 实例化 Person 对象，提供一个类型为 IPerson 的对象作为参数**'
- en: TypeScript has a structural type system, which means that if two different types
    include the same members, the types are considered compatible. In [listing B.9](#app02ex09),
    even if you didn’t specify the type of the `aPerson` variable, it still would
    be considered compatible with `IPerson` and could be used as a constructor argument
    while instantiating the `Person` object. If you change the name or type of one
    of the members of `IPerson`, the TypeScript compiler will report an error.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 具有结构化类型系统，这意味着如果两个不同的类型包含相同的成员，则认为这些类型是兼容的。在 [列表 B.9](#app02ex09)
    中，即使你没有指定 `aPerson` 变量的类型，它仍然会被认为与 `IPerson` 兼容，并可以在实例化 `Person` 对象时用作构造函数参数。如果你更改
    `IPerson` 的任何一个成员的名称或类型，TypeScript 编译器将报告错误。
- en: The `IPerson` interface didn’t define any methods, but TypeScript interfaces
    can include method signatures without implementations.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`IPerson` 接口没有定义任何方法，但 TypeScript 接口可以包含方法签名而不包含实现。'
- en: B.7.2\. Using the implements keyword
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: B.7.2\. 使用 `implements` 关键字
- en: 'The `implements` keyword can be used with a class declaration to announce that
    the class will implement a particular interface. Say you have an `IPayable` interface
    declared as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在类声明中使用 `implements` 关键字来宣布该类将实现特定的接口。假设你有一个如下声明的 `IPayable` 接口：
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now the `Employee` class can declare that it implements `IPayable`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `Employee` 类可以声明它实现了 `IPayable` 接口：
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Before going into details, let’s answer this question: why not just write all
    required code in the class rather than separating a portion of the code into an
    interface? Let’s say you need to write an application that allows increasing salaries
    for the employees of your organization.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入细节之前，让我们回答这个问题：为什么不在类中直接编写所有必要的代码，而不是将部分代码分离到一个接口中？假设你需要编写一个应用程序，允许为你的组织中的员工增加薪酬。
- en: You can create an `Employee` class (that extends `Person`) and include the `increaseSalary()`
    method there. Then the business analysts may ask you to add the ability to increase
    pay to contractors who work for your firm. But contractors are represented by
    their company names and IDs; they have no notion of salary and are paid on an
    hourly basis.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个 `Employee` 类（它扩展了 `Person` 类）并在其中包含 `increaseSalary()` 方法。然后业务分析师可能会要求你添加为为你的公司工作的承包商增加薪酬的能力。但承包商由他们的公司名称和ID表示；他们没有薪酬的概念，并且按小时支付工资。
- en: 'You can create another class, `Contractor` (not inherited from `Person`), that
    includes some properties and an `increaseHourlyRate()` method. Now you have two
    different APIs: one for increasing the salary of employees, and another for increasing
    the pay for contractors. A better solution is to create a common `IPayable` interface
    and have `Employee` and `Contractor` classes provide *different implementations*
    of `IPayable` for these classes, as illustrated in the following listing.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建另一个类，`Contractor`（不是从 `Person` 继承），它包含一些属性和一个 `increaseHourlyRate()` 方法。现在你有两个不同的
    API：一个用于增加员工的薪酬，另一个用于增加承包商的薪酬。更好的解决方案是创建一个通用的 `IPayable` 接口，并让 `Employee` 和 `Contractor`
    类为这些类提供不同的 `IPayable` 实现，如下面的列表所示。
- en: Listing B.10\. Using multiple interface implementations
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 B.10\. 使用多个接口实现
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '***1* The IPayable interface includes the signature of the increasePay() method
    that will be implemented by the Employee and Contractor classes.**'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1**  `IPayable` 接口包含了 `increasePay()` 方法的签名，该签名将由 `Employee` 和 `Contractor`
    类实现。'
- en: '***2* The Person class serves as a base class for Employee.**'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2**  `Person` 类作为 `Employee` 类的基类。'
- en: '***3* The Employee class inherits from Person and implements the IPayable interface.
    A class can implement multiple interfaces.**'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3**  `Employee` 类从 `Person` 继承并实现了 `IPayable` 接口。一个类可以实现多个接口。'
- en: '***4* The Employee class implements the increasePay() method. The salary of
    an employee can be increased by any amount, so the method prints the message on
    the console and returns true (allowing the increase).**'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**4**  `Employee` 类实现了 `increasePay()` 方法。员工的薪酬可以增加任何金额，因此该方法将在控制台上打印消息并返回
    true（允许增加）。'
- en: '***5* The Contractor class includes a property that places a cap of 20% on
    pay increases.**'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**5**  `Contractor` 类包含一个属性，将薪酬增加的上限设置为 20%。'
- en: '***6* The implementation of increasePay() in the Contractor class is different,
    invoking increasePay() with an argument that’s more than 20 results in the “Sorry”
    message and a return value of false.**'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**6**  `Contractor` 类中 `increasePay()` 方法的实现不同，使用超过 20 的参数调用 `increasePay()`
    将导致显示“Sorry”消息并返回 false。'
- en: '***7* Declaring an array of type IPayable lets you place any objects that implement
    the IPayable type there.**'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 声明IPayable类型的数组允许你放置任何实现了IPayable类型的对象。**'
- en: '***8* Now you can invoke the increasePay() method on any object in the workers
    array. Note that you don’t use parentheses with the fat-arrow expression that
    has a single worker argument.**'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 现在你可以对workers数组中的任何对象调用increasePay()方法。注意，使用具有单个worker参数的胖箭头表达式时，不需要使用括号。**'
- en: 'Running the preceding script produces the following output on the browser console:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的脚本会在浏览器控制台产生以下输出：
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '|  |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Why declare classes with the implements keyword?**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么使用implements关键字声明类？**'
- en: If you remove `implements Payable` from the declaration of either `Employee`
    or `Contractor`, the code will still work, and the compiler won’t complain about
    lines that add these objects to the `workers` array. The compiler is smart enough
    to see that even if the class doesn’t explicitly declare `implements IPayable`,
    it implements `increasePay()` properly.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从`Employee`或`Contractor`的声明中移除`implements Payable`，代码仍然可以工作，编译器也不会对向`workers`数组添加这些对象的行提出抱怨。编译器足够智能，能够看到即使类没有显式声明`implements
    IPayable`，它也正确地实现了`increasePay()`。
- en: But if you remove `implements IPayable` and try to change the signature of the
    `increasePay()` method from any of the classes, you won’t be able to place such
    an object into the `workers` array, because that object would no longer be of
    the `IPayable` type. Also, without the `implements` keyword, IDE support (such
    as for refactoring) will be broken.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你移除`implements IPayable`并尝试更改任何类中`increasePay()`方法的签名，你将无法将此类对象放入`workers`数组中，因为该对象将不再是`IPayable`类型。此外，没有`implements`关键字，IDE支持（如重构）将会失效。
- en: '|  |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: B.8\. Generics
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.8\. 泛型
- en: TypeScript supports parameterized types, also known as *generics*, which can
    be used in a variety of scenarios. For example, you can create a function that
    can take values of any type; but during its invocation, in a particular context,
    you can explicitly specify a concrete type.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript支持参数化类型，也称为**泛型**，可以在各种场景中使用。例如，你可以创建一个可以接受任何类型值的函数；但在调用时，在特定的上下文中，你可以显式指定一个具体类型。
- en: 'Take another example: an array can hold objects of any type, but you can specify
    which particular object types (for example, instances of `Person`) are allowed
    in an array. If you were to try to add an object of a different type, the TypeScript
    compiler would generate an error.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 再举一个例子：一个数组可以存储任何类型的对象，但你可以在数组中指定允许的特定对象类型（例如，`Person`类的实例）。如果你尝试添加不同类型的对象，TypeScript编译器将生成一个错误。
- en: The following code listing declares a `Person` class and its descendant, `Employee`,
    and an `Animal` class. Then it instantiates each class and tries to store them
    in the `workers` array declared with the generic type. Generic types are denoted
    by placing them in angle brackets (as in `<Person>`).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例声明了一个`Person`类及其子类`Employee`和一个`Animal`类。然后它实例化每个类并尝试将它们存储在声明为泛型类型的`workers`数组中。泛型类型通过将它们放在尖括号中（如`<Person>`）来表示。
- en: Listing B.11\. Using a generic type
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表B.11\. 使用泛型类型
- en: '[PRE36]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: By declaring the `workers` array with the generic type `<Person>`, you announce
    your plan to store only instances of the `Person` class or its descendants. An
    attempt to store an instance of `Animal` in the same array will result in a compile-time
    error.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`workers`数组声明为泛型类型`<Person>`，你宣布了你的计划只存储`Person`类或其子类的实例。尝试将`Animal`类的实例存储在同一个数组中会导致编译时错误。
- en: '|  |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Nominal and structural type systems**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**名义和结构类型系统**'
- en: If you’re familiar with generics in Java or C#, you may get a feeling that you
    already understand this syntax. There’s a caveat, though. Though Java and C# use
    a *nominal* type system, TypeScript uses a *structural* one. In a nominal system,
    types are checked against their names, but in a structural system, by their structure.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉Java或C#中的泛型，你可能觉得你已经理解了这个语法。但是有一个注意事项。虽然Java和C#使用的是**名义**类型系统，TypeScript使用的是**结构**类型系统。在名义类型系统中，类型是根据它们的名称进行检查的，但在结构类型系统中，是根据它们的结构进行检查的。
- en: 'With a nominal type system, the following line would result in an error:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在名义类型系统中，以下行将导致错误：
- en: '[PRE37]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: With a structural type system, as long as the structures of the type are similar,
    you may get away with assigning an object of one type to a variable of another.
    Let’s illustrate it by adding the `name` property to the `Animal` class.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在结构化类型系统中，只要类型的结构相似，你就可以将一个类型的对象赋值给另一个类型的变量。让我们通过向 `Animal` 类添加 `name` 属性来举例说明。
- en: '![](Images/f0481-01_alt.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f0481-01_alt.jpg)'
- en: Structural type system in action
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化类型系统在行动
- en: 'Now the TypeScript compiler doesn’t complain about assigning an `Animal` object
    to a variable of type `Person`. The variable of type `Person` expects an object
    that has a `name` property, and the `Animal` object has it. This is not to say
    that `Person` and `Animal` represent the same types, but these types are compatible.
    On the other hand, trying to assign the `Person` object to a variable of type
    `Animal` will result in the compilation error “Property breed is missing in type
    Person”:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在TypeScript编译器不会对将 `Animal` 对象赋值给类型为 `Person` 的变量而报错。类型为 `Person` 的变量期望一个具有
    `name` 属性的对象，而 `Animal` 对象恰好有这个属性。这并不是说 `Person` 和 `Animal` 代表了相同的类型，但这两个类型是兼容的。另一方面，尝试将
    `Person` 对象赋值给类型为 `Animal` 的变量将导致编译错误“类型 Person 中缺少属性 breed”：
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '|  |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Can you use generic types with any object or function? No. The creator of the
    object or function has to allow this feature. If you open TypeScript’s type definition
    file (lib.d.ts) on GitHub at [http://mng.bz/I3V7](http://mng.bz/I3V7) and search
    for “interface Array,” you’ll see the declaration of the `Array`, as shown in
    [figure B.5](#app02fig05). Type definition files are explained later in this appendix.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用泛型类型与任何对象或函数吗？不。对象或函数的创建者必须允许这个特性。如果你在 GitHub 上打开 TypeScript 的类型定义文件 (lib.d.ts)
    并搜索“interface Array”，你将看到 `Array` 的声明，如图 [B.5](#app02fig05) 所示。类型定义文件将在本附录的后面进行解释。
- en: Figure B.5\. The fragment of lib.d.ts describing the `Array` API
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 B.5\. 描述 `Array` API 的 lib.d.ts 片段
- en: '![](Images/bfig05_alt.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/bfig05_alt.jpg)'
- en: 'The `<T>` in line 1008 serves as a placeholder for the actual type. It means
    TypeScript allows you to declare a type parameter with `Array`, and the compiler
    will check for the specific type provided in your program. Earlier in this section,
    we specified a generic `<T>` parameter as `<Person>` in `let workers: Array<Person>`.
    But because generics aren’t supported in JavaScript, you won’t see them in the
    code generated by the transpiler. It’s just an additional safety net for developers
    at compile time.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '第 1008 行的 `<T>` 作为一个占位符用于实际类型。这意味着 TypeScript 允许你使用 `Array` 声明一个类型参数，编译器将检查你在程序中提供的特定类型。在本节前面，我们指定了
    `<Person>` 作为 `let workers: Array<Person>` 中的泛型 `<T>` 参数。但由于 JavaScript 不支持泛型，你不会在转译器生成的代码中看到它们。这只是一种在编译时为开发者提供额外安全网的机制。'
- en: 'You can see another `T` in line 1022 in [figure B.5](#app02fig05). When generic
    types are specified with function arguments, no angle brackets are needed. But
    there’s no `T` type in TypeScript. The `T` here means the `push` method lets you
    push objects of a specific type into an array, as in the following example:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [图 B.5](#app02fig05) 的第 1022 行看到另一个 `T`。当泛型类型与函数参数一起指定时，不需要使用尖括号。但在 TypeScript
    中没有 `T` 类型。这里的 `T` 意味着 `push` 方法允许你将特定类型的对象推入数组，如下面的示例所示：
- en: '[PRE39]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You can create your own classes and functions that support generics, as well.
    The next listing defines a `Comparator<T>` interface that declares a `compareTo()`
    method, expecting the concrete type to be provided during method invocation.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以创建自己的支持泛型的类和函数。接下来的列表定义了一个 `Comparator<T>` 接口，它声明了一个 `compareTo()` 方法，在方法调用期间期望提供具体的类型。
- en: Listing B.12\. Creating an interface that uses generics
  id: totrans-239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 B.12\. 创建一个使用泛型的接口
- en: '[PRE40]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '***1* Declares a Comparator interface with a generic type**'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明一个具有泛型类型的 Comparator 接口**'
- en: '***2* Creates a class that implements Comparator, specifying the concrete type
    Rectangle**'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建一个实现 Comparator 的类，指定具体的类型为 Rectangle**'
- en: '***3* Implements the method for comparing rectangles**'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 实现比较矩形的函数**'
- en: '***4* Compares rectangles (the type T is erased and replaced with Rectangle)**'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 比较矩形（类型 T 被擦除并替换为 Rectangle）**'
- en: '***5* Creates a class that implements Comparator, specifying the concrete type
    Programmer**'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 创建一个实现 Comparator 的类，指定具体的类型为 Programmer**'
- en: '***6* Implements the method for comparing programmers**'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 实现比较程序员的函数**'
- en: '***7* Compares programmers (the type T is erased and replaced with Programmer)**'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 比较程序员（类型 T 被擦除并替换为 Programmer）**'
- en: B.9\. The readonly modifier
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.9\. 只读修饰符
- en: 'ES6 introduced the `const` keyword that you can apply to variables, but not
    to properties of a class or interface. You can’t write this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 引入了可以应用于变量的 `const` 关键字，但不能应用于类或接口的属性。你不能这样写：
- en: '[PRE41]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'TypeScript adds a `readonly` keyword that can be applied to class properties:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 添加了一个可以应用于类属性的 `readonly` 关键字：
- en: '[PRE42]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can initialize a `readonly` property only during its declaration or in
    the class constructor. Now if you’ll try to write the code that modifies the value
    of the `name` property, the TypeScript compiler (or static analyzer) will report
    an error:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能在声明时或类构造函数中初始化 `readonly` 属性。现在，如果你尝试编写修改 `name` 属性值的代码，TypeScript 编译器（或静态分析器）将报告一个错误：
- en: '[PRE43]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'But creating an immutable object is a more interesting use case for applying
    the `readonly` modifier. In some cases, especially in Angular apps, you may want
    to ensure that an object is immutable, and you can’t mutate the object by mistake.
    Let’s try to apply `readonly` to an object property:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，创建一个不可变对象是应用 `readonly` 修饰符的一个更有趣的使用场景。在某些情况下，尤其是在 Angular 应用中，你可能想确保一个对象是不可变的，并且不小心修改对象。让我们尝试将
    `readonly` 应用到一个对象属性上：
- en: '[PRE44]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'An attempt to assign another object to the `bestFriend` variable results in
    a compilation error, because `bestFriend` is marked as `readonly`. But changing
    the internal property of the object represented by `bestFriend` is still allowed.
    To prohibit this, use the `readonly` modifier with each property of the object:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将另一个对象分配给 `bestFriend` 变量会导致编译错误，因为 `bestFriend` 被标记为 `readonly`。但是，更改由 `bestFriend`
    表示的对象的内部属性仍然是允许的。为了禁止这样做，使用 `readonly` 修饰符对对象的每个属性进行修饰：
- en: '[PRE45]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In Angular apps, you may want to store application state in an immutable object
    bound to the input property of a component. To enforce the creation of a new object
    instance whenever its properties change, write a function that creates a copy
    of the object with modification of the properties (see code samples in [section
    A.7](kindle_split_025.xhtml#app01lev1sec7) in [appendix A](kindle_split_025.xhtml#app01)).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 应用中，你可能希望将应用程序状态存储在一个绑定到组件输入属性的不可变对象中。为了强制在属性更改时创建一个新的对象实例，编写一个函数来创建一个带有属性修改的对象副本（参见[附录
    A 中的 A.7 节](kindle_split_025.xhtml#app01lev1sec7)中的代码示例）。
- en: 'If an object has multiple properties, adding the `readonly` modifier to each
    of them is a tedious job, and you can use a read-only mapped type instead. The
    following example uses the `type` keyword to define a new type and generics to
    provide a concrete object to the `Readonly` class:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个对象有多个属性，为它们中的每一个添加 `readonly` 修饰符是一项繁琐的工作，你可以使用只读映射类型来代替。以下示例使用 `type` 关键字定义一个新的类型，并使用泛型为
    `Readonly` 类提供一个具体的对象：
- en: '[PRE46]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: B.10\. Decorators
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.10\. 装饰器
- en: There are different definitions of the term *metadata*. The popular definition
    is that metadata is data about data. We think of metadata as data that describes
    and enhances code. Internally, TypeScript decorators are special functions that
    add metadata enhancing the functionality of a class, property, method, or parameter.
    TypeScript decorators start with an `@` sign.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: “元数据”这个术语有不同的定义。流行的定义是元数据是关于数据的数据。我们将元数据视为描述和增强代码的数据。在内部，TypeScript 装饰器是特殊的函数，用于添加增强类、属性、方法或参数功能的元数据。TypeScript
    装饰器以一个 `@` 符号开始。
- en: 'Decorators exist in Typescript, and they are proposed in ECMAScript. To properly
    transpile them, turn on experimental features in the Typescript transpiler by
    adding the following line in the tsconfig.json file:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器存在于 TypeScript 中，并且是在 ECMAScript 中提出的。为了正确地转译它们，在 tsconfig.json 文件中添加以下行以在
    TypeScript 转译器中启用实验性功能：
- en: '[PRE47]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this section, we’ll show you how to create a simple decorator that will print
    the information about the class it’s attached to.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您展示如何创建一个简单的装饰器，该装饰器将打印它附加到的类的信息。
- en: Imagine that you want to create a decorator, `UIComponent()`, that can accept
    an HTML fragment as a parameter. The decorator should be able to print the received
    HTML and understand the properties of the attached artifact—for example, a class.
    The following listing does this.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想创建一个装饰器 `UIComponent()`，它可以接受一个 HTML 片段作为参数。装饰器应该能够打印接收到的 HTML 并理解附加实体的属性——例如，一个类。以下列表实现了这一点。
- en: Listing B.13\. A custom `UIComponent` decorator
  id: totrans-268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 B.13\. 一个自定义的 `UIComponent` 装饰器
- en: '[PRE48]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `UIComponent()` function has one `string` parameter and returns another
    function that prints the content of the implicit variable `target`, which knows
    the artifact the decorator is attached to. If you compile this code into ES5 syntax
    and run it, the output on your console will look as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIComponent()` 函数有一个 `string` 参数，并返回另一个函数，该函数打印隐含变量 `target` 的内容，该变量知道装饰器附加到的工件。如果您将此代码编译成
    ES5 语法并运行它，控制台上的输出将如下所示：'
- en: '[PRE49]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If you compile the same code into ES6, the output will be different, because
    ES6 supports classes:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将相同的代码编译成 ES6，输出将不同，因为 ES6 支持类：
- en: '[PRE50]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Under the hood, TypeScript uses the `reflect-metadata` library to query the
    structure of the artifact the decorator is attached to. This simple decorator
    knows what HTML you want to render and that your class has a member variable `name`.
    If you’re a developer of a framework that needs to render UI, the code of this
    decorator can come in handy. The process of creating custom decorators is described
    in the TypeScript documentation at [http://mng.bz/gz6R](http://mng.bz/gz6R).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，TypeScript 使用 `reflect-metadata` 库来查询装饰器附加到的工件的结构。这个简单的装饰器知道您想要渲染的 HTML
    以及您的类有一个名为 `name` 的成员变量。如果您是框架的开发者，需要渲染 UI，这个装饰器的代码可能会很有用。创建自定义装饰器的过程在 TypeScript
    文档中描述，请参阅 [http://mng.bz/gz6R](http://mng.bz/gz6R)。
- en: 'To turn a TypeScript class into an Angular component, you need to decorate
    it with the `@Component()` decorator. Angular will internally parse your annotations
    and generate code that adds the requested behavior to the TypeScript class. To
    turn a class variable into a component property that can receive values, you use
    the `@Input()` decorator:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 TypeScript 类转换为 Angular 组件，您需要使用 `@Component()` 装饰器对其进行装饰。Angular 将内部解析您的注解并生成代码，将所需的行为添加到
    TypeScript 类中。要将类变量转换为可以接收值的组件属性，您使用 `@Input()` 装饰器：
- en: '[PRE51]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In this example, the `@Component()` decorator defines the selector and a template
    (UI) for the `OrderComponent` class. The `@Input()` decorator enables the `quantity`
    property to receive values from the parent component via binding. When you use
    decorators, there should be a decorator processor that can parse the decorator
    content and turn it into code that the runtime (the browser’s JavaScript engine)
    understands. Angular includes the `ngc` compiler that performs the duties of a
    decorator processor.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`@Component()` 装饰器定义了 `OrderComponent` 类的选择器和模板（UI）。`@Input()` 装饰器使 `quantity`
    属性能够通过绑定从父组件接收值。当您使用装饰器时，应该有一个装饰器处理器可以解析装饰器内容并将其转换为运行时（浏览器 JavaScript 引擎）可以理解的代码。Angular
    包含 `ngc` 编译器，它执行装饰器处理器的职责。
- en: 'To use Angular decorators, import their implementation in your application
    code. For example, import the `@Component()` decorator as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Angular 装饰器，请在您的应用程序代码中导入它们的实现。例如，如下导入 `@Component()` 装饰器：
- en: '[PRE52]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Angular comes with a set of decorators, but TypeScript allows you to create
    your own decorators regardless of whether you use Angular or not.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 内置了一套装饰器，但 TypeScript 允许您创建自己的装饰器，无论您是否使用 Angular。
- en: B.11\. The union type
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.11\. 联合类型
- en: 'In TypeScript, you can declare a new type based on two or more existing types.
    For example, you can declare a variable that can accept either a string value
    or a number:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，您可以根据两个或多个现有类型声明一个新的类型。例如，您可以声明一个变量，它可以接受字符串值或数字：
- en: '[PRE53]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Although TypeScript supports the `any` type, the preceding declaration provides
    some benefits compared to the declaration `let padding: any`. In the following
    listing, we’ll review the code of one of the code samples from the TypeScript
    documentation at [http://mng.bz/5742](http://mng.bz/5742). This function can add
    left padding to the provided string. The padding can be specified either as a
    string that has to prepend the provided argument or the number of spaces that
    should prepend the string.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '虽然 TypeScript 支持 `any` 类型，但前面的声明与 `let padding: any` 的声明相比提供了一些好处。在下面的列表中，我们将回顾
    TypeScript 文档中 [http://mng.bz/5742](http://mng.bz/5742) 中的一个代码示例。此函数可以向提供的字符串添加左填充。填充可以是字符串，该字符串必须预接在提供的参数之前，或者是指定预接字符串的空格数。'
- en: Listing B.14\. union.ts with any type
  id: totrans-285
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 B.14\. `union.ts` 与 `any` 类型
- en: '[PRE54]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '***1* Provides the string and the padding of type any**'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 提供字符串和类型为 any 的填充**'
- en: '***2* For a numeric argument, generates spaces**'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 对于数字参数，生成空格**'
- en: '***3* For a string, uses concatenation**'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 对于字符串，使用连接**'
- en: '***4* If the second argument is neither a string nor a number, throws an error**'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 如果第二个参数既不是字符串也不是数字，则抛出错误**'
- en: 'The following are examples of invoking `padLeft()`:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些调用 `padLeft()` 的示例：
- en: '[PRE55]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: But if you change the type of the `padding` to the union of a string or a number,
    the compiler will report an error if you try to invoke `padLeft()` providing anything
    other than a string or a number. This will also eliminate the need to throw an
    exception. The new version of the `padLeft()` function is more bulletproof, as
    you can see in the following listing.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你将 `padding` 的类型改为字符串或数字的联合类型，当你尝试使用除了字符串或数字之外的任何内容调用 `padLeft()` 时，编译器将报告错误。这也会消除抛出异常的需要。新的
    `padLeft()` 函数版本更加健壮，如下面的列表所示。
- en: Listing B.15\. union.ts with a union type
  id: totrans-294
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 B.15\. union.ts 使用联合类型
- en: '[PRE56]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '***1* Allows only a string or a number as a second argument**'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 只允许将字符串或数字作为第二个参数**'
- en: 'Now invoking `padLeft()` with the wrong type (for example, `true`) of the second
    argument returns a compilation error:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用错误的类型（例如，`true`）调用 `padLeft()` 作为第二个参数将返回编译错误：
- en: '[PRE57]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Another benefit of using a union type is that IDEs have an autocomplete feature
    that will prompt you with allowed argument types, so you won’t even have a chance
    to make such a mistake. In [section 15.2.3](kindle_split_024.xhtml#ch15lev2sec5)
    in [chapter 15](kindle_split_024.xhtml#ch15), there’s another practical example
    of using a union type.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 使用联合类型的另一个好处是 IDE 具有自动完成功能，它会提示你允许的参数类型，因此你甚至没有机会犯这样的错误。在 [第 15 章](kindle_split_024.xhtml#ch15)
    的 [15.2.3 节](kindle_split_024.xhtml#ch15lev2sec5) 中，还有一个使用联合类型的实际示例。
- en: B.12\. Using type definition files
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.12\. 使用类型定义文件
- en: The purpose of type definition files is to describe an API of a JavaScript library
    (or a script) providing types offered by this API. Say you want to use the popular
    JavaScript library Lodash in your Typescript code. If you have a Lodash type definition
    file in your project, the TypeScript static analyzer will know what types are
    expected by Lodash functions, and if you provide wrong types, you’ll get a compile-time
    error. Also, an IDE will offer autocomplete for the Lodash API.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 类型定义文件的目的在于描述一个 JavaScript 库（或脚本）的 API，并提供该 API 所提供的类型。比如说，你想要在你的 TypeScript
    代码中使用流行的 JavaScript 库 Lodash。如果你的项目中有一个 Lodash 类型定义文件，TypeScript 静态分析器就会知道 Lodash
    函数期望的类型，如果你提供了错误类型，你将得到编译时错误。此外，IDE 也会为 Lodash API 提供自动完成功能。
- en: Initially, a TypeScript community created a repository of TypeScript definition
    files called *DefinitelyTyped* at [http://definitelytyped.org](http://definitelytyped.org).
    In 2016, Microsoft created an organization, `@types`, at npmjs.org, and this is
    what we use now. This organization has more than 5,000 type definition files for
    various JavaScript libraries.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，一个 TypeScript 社区在 [http://definitelytyped.org](http://definitelytyped.org)
    创建了一个名为 *DefinitelyTyped* 的 TypeScript 定义文件仓库。2016 年，微软在 npmjs.org 上创建了一个名为 `@types`
    的组织，我们现在使用的就是这个组织。这个组织拥有超过 5,000 个针对各种 JavaScript 库的类型定义文件。
- en: 'The suffix of any type definition filename is *d.ts*, and you install type
    definition files using npm. For example, to install type definition files for
    Lodash, run the following command:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 任何类型定义文件名的后缀都是 *d.ts*，你使用 npm 安装类型定义文件。例如，要安装 Lodash 的类型定义文件，请运行以下命令：
- en: '[PRE58]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This will download the Lodash definitions in the node_modules/@types directory
    of your project and will also update the package.json file, so you won’t need
    to run this command again.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在你的项目 node_modules/@types 目录中下载 Lodash 定义，并更新 package.json 文件，因此你不需要再次运行此命令。
- en: When you install Angular, you’re getting the definition files in Angular modules
    in the subfolders of the node_modules/@angular folder after running `npm install`,
    as explained in [chapter 1](kindle_split_010.xhtml#ch01). All required d.ts files
    are bundled with Angular npm packages, and there’s no need to install them separately.
    The presence of definition files in your project will allow the TypeScript compiler
    to ensure that your code uses the correct types while invoking the Angular API.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 当你安装 Angular 时，你会在运行 `npm install` 命令后，在 node_modules/@angular 文件夹的子文件夹中找到 Angular
    模块中的定义文件，如 [第 1 章](kindle_split_010.xhtml#ch01) 中所述。所有必需的 d.ts 文件都包含在 Angular
    npm 包中，因此不需要单独安装。在你的项目中存在定义文件将允许 TypeScript 编译器确保在调用 Angular API 时你的代码使用正确的类型。
- en: 'For example, Angular applications are launched by invoking the `bootstrapModule()`
    method, giving it the root module for your application as an argument. The application_ref.d.ts
    file includes the following definition for this function:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Angular 应用程序是通过调用 `bootstrapModule()` 方法启动的，将应用程序的根模块作为参数传递给它。application_ref.d.ts
    文件包含以下对该函数的定义：
- en: '[PRE59]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: By reading this definition, you (and the `tsc` compiler) know that this function
    can be invoked with one mandatory module parameter of type `Type<M>` and an optional
    array of compiler options. If application_ref.d.ts wasn’t a part of your project,
    TypeScript’s compiler would let you invoke the `bootstrapModule` function with
    a wrong parameter type, or without any parameters at all, which would result in
    a runtime error. But application_ref.d.ts is present, so TypeScript would generate
    a compile-time error reading “Supplied parameters do not match any signature of
    call target.” Type definition files also allow IDEs to show context-sensitive
    help when you’re writing code that invokes Angular functions or assigns values
    to object properties.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 通过阅读此定义，您（以及`tsc`编译器）知道此函数可以通过一个必需的模块参数`Type<M>`和一个可选的编译器选项数组来调用。如果application_ref.d.ts不是您项目的一部分，TypeScript编译器会允许您使用错误的参数类型调用`bootstrapModule`函数，或者完全不传递任何参数，这会导致运行时错误。但是，由于存在application_ref.d.ts，TypeScript会在编译时生成错误，显示“提供的参数与调用目标签名不匹配。”类型定义文件还允许IDE在您编写调用Angular函数或分配对象属性值的代码时显示上下文相关的帮助。
- en: '|  |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Specifying type definition files explicitly**'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**显式指定类型定义文件**'
- en: 'To explicitly specify the type definition files located in the node_modules/@types
    directory, add the required files to the `types` section of tsconfig.json. Here’s
    an example:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 要显式指定位于node_modules/@types目录中的类型定义文件，请将所需的文件添加到tsconfig.json的`types`部分。以下是一个示例：
- en: '[PRE60]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '|  |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In the past, we used special type definition managers `tsd` and `Typings` to
    install type definition files, but these managers are no longer needed. If your
    application uses other third-party JavaScript libraries, install their type definition
    files with npm to get compiler help and autocomplete in your IDE.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，我们使用特殊的类型定义管理器`tsd`和`Typings`来安装类型定义文件，但这些管理器不再需要。如果您的应用程序使用其他第三方JavaScript库，请使用npm安装它们的类型定义文件，以获取编译器帮助和IDE中的自动完成功能。
- en: B.13\. Controlling code style with TSLint
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.13\. 使用TSLint控制代码风格
- en: Linters help to ensure that code complies with the accepted coding style. With
    TSLint, you can enforce specified rules and coding styles for TypeScript. For
    example, you can configure TSLint to check that the TypeScript code in your project
    is properly aligned and indented, that the names of all interfaces start with
    a capital I, that class names use CamelCase notation, and so on.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 代码检查器有助于确保代码符合接受的编码风格。使用TSLint，您可以强制执行指定的规则和编码风格。例如，您可以将TSLint配置为检查您的项目中的TypeScript代码是否正确对齐和缩进，所有接口的名称是否以大写I开头，类名是否使用驼峰式命名法，等等。
- en: 'You can install TSLint globally using the following command:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令全局安装TSLint：
- en: '[PRE61]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To install the TSLint node module in your project directory, run the following
    command:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 要在项目目录中安装TSLint节点模块，请运行以下命令：
- en: '[PRE62]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The rules you want to apply to your code are specified in a tslint.json configuration
    file, which is generated by running `tslint init`:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要应用到代码中的规则在tslint.json配置文件中指定，该文件是通过运行`tslint init`生成的：
- en: '[PRE63]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: A file with recommended rules comes with TSLint, but you can use custom rules
    of your preference. You can check the recommended rules in the node_modules/tslint/lib/configs/recommended.js
    file. The core TSLint rules are documented at [http://mng.bz/xx6B](http://mng.bz/xx6B).
    Your IDE may support linting with TSLint out of the box. If you generated your
    project with Angular CLI, it already includes TSLint.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: TSLint附带了一个包含推荐规则的文件，但您可以使用您偏好的自定义规则。您可以在node_modules/tslint/lib/configs/recommended.js文件中查看推荐规则。核心TSLint规则在[http://mng.bz/xx6B](http://mng.bz/xx6B)上有文档说明。您的IDE可能默认支持使用TSLint进行代码检查。如果您使用Angular
    CLI生成了项目，它已经包含了TSLint。
