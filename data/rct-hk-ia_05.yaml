- en: 4 Working with side effects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 处理副作用
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Recognizing types of side effects in components
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件中识别副作用的类型
- en: Wrapping side effects with the `useEffect` hook
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `useEffect` 钩子包裹副作用
- en: Controlling when an effect runs by specifying a dependency list
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过指定依赖项列表来控制效果何时运行
- en: Returning a cleanup function from an effect
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从效果中返回一个清理函数
- en: Using an effect to fetch data for a component
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用效果为组件获取数据
- en: React transforms our data into UI. Each component plays its part, returning
    its contribution to the overall user interface. React builds the tree of elements,
    compares it with what’s already rendered, and commits any necessary changes to
    the DOM. When the state changes, React goes through the process again to update
    the UI. React is really good at efficiently deciding what should update and scheduling
    any changes.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: React 将我们的数据转换为 UI。每个组件都扮演自己的角色，将其对整体用户界面的贡献返回。React 构建元素树，将其与已渲染的内容进行比较，并将任何必要的更改提交到
    DOM。当状态发生变化时，React 会再次执行此过程以更新 UI。React 在高效地决定应该更新什么以及安排任何更改方面做得非常好。
- en: 'Sometimes, however, we need our components to reach outside this data-flow
    process and directly interact with other APIs. An action that impinges on the
    outside world in some way is called a *side effect*. Common side effects include
    the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时我们需要我们的组件超出这个数据流过程，并直接与其他 API 交互。以某种方式影响外部世界的行为称为 *副作用*。常见的副作用包括以下内容：
- en: Setting the page title imperatively
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令式设置页面标题
- en: Working with timers like `setInterval` or `setTimeout`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 `setInterval` 或 `setTimeout` 等定时器一起工作
- en: Measuring the width, height, or position of elements in the DOM
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量 DOM 中元素的宽度、高度或位置
- en: Logging messages to the console or other service
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将消息记录到控制台或其他服务
- en: Setting or getting values in local storage
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地存储中设置或获取值
- en: Fetching data or subscribing and unsubscribing to services
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取数据或订阅和取消订阅服务
- en: Whatever our components are trying to achieve, it would be risky for them to
    simply ignore React and try to perform their tasks blindly. It’s much better to
    enlist React’s help to schedule such side effects effectively, considering when
    and how often they should run, even as React does its job of rendering each component
    and committing changes to the screen. React provides the `useEffect` hook so that
    we can better control side effects and integrate them into the life cycles of
    our components.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们的组件试图实现什么，它们简单地忽略 React 并盲目地执行任务都是一种风险。更好的做法是请求 React 的帮助，有效地安排这些副作用，考虑它们何时以及多久运行一次，即使
    React 在渲染每个组件并将更改提交到屏幕的过程中也在工作。React 提供了 `useEffect` 钩子，以便我们更好地控制副作用并将它们集成到组件的生命周期中。
- en: In this chapter, we come to grips with how the `useEffect` hook works. We start,
    in section 4.1, by trying out simple examples that highlight calling the hook,
    controlling when it runs, and specifying how to clean up any effects when a component
    unmounts. In section 4.2, we set up a simple server for data in the bookings app
    example and create components to practice fetching that data. Finally, in section
    4.3, we switch our bookings app over from importing database files to fetching
    data from a server.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入了解 `useEffect` 钩子的工作原理。我们从第 4.1 节开始，尝试一些简单的示例，突出调用钩子、控制其运行时机以及指定在组件卸载时清理任何效果的方法。在第
    4.2 节中，我们在预订应用程序示例中设置一个简单的服务器用于数据，并创建组件来练习获取这些数据。最后，在第 4.3 节中，我们将预订应用程序从导入数据库文件切换到从服务器获取数据。
- en: The `useEffect` hook is our gateway to safe interactions with the outside world.
    Let’s take our first steps on the path.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect` 钩子是我们与外部世界安全交互的门户。让我们踏上这条道路的第一步。'
- en: 4.1 Exploring the useEffect API with simple examples
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 使用简单示例探索 useEffect API
- en: 'Some of our React components are super friendly, reaching out to say “hi” to
    APIs and services outside React. Although these components are eternally optimistic
    and like to think the best of all those they meet, there are some safeguards to
    be followed. In this section, we look at setting up side effects in ways that
    won’t get out of hand. In particular, we explore these four scenarios:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的一些 React 组件非常友好，它们会主动向 React 之外的 API 和服务打招呼。尽管这些组件永远乐观，喜欢对所有遇到的人抱最好的期望，但还有一些安全措施需要遵循。在本节中，我们探讨以不会失控的方式设置副作用。特别是，我们探索以下四种场景：
- en: Running side effects after every render
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每次渲染后运行副作用
- en: Running an effect only when a component mounts
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅在组件挂载时运行效果
- en: Cleaning up side effects by returning a function
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过返回一个函数来清理副作用
- en: Controlling when an effect runs by specifying dependencies
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过指定依赖项来控制效果运行的时间
- en: To focus on the API, we’ll create some super-simple component examples, rather
    than jumping straight into the bookings app as a context. First up, let’s say,
    “Bonjour, les side-effects.”
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了专注于API，我们将创建一些超级简单的组件示例，而不是直接跳入预订应用作为上下文。首先，让我们说，“Bonjour, les side-effects。”
- en: 4.1.1 Running side effects after every render
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 在每次渲染后运行副作用
- en: Say you want to add a random greeting to the page’s title in the browser. Clicking
    your friendly component’s Say Hi button should generate a new greeting and update
    the title. Three such greetings are shown in figure 4.1.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想在浏览器页面的标题中添加一个随机的问候语。点击你友好的组件的“说你好”按钮应该生成一个新的问候语并更新标题。图4.1显示了三个这样的问候语。
- en: '![](../Images/4-1.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/4-1.png)'
- en: Figure 4.1 Clicking the Say Hi button updates the page title with a random greeting.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 点击“说你好”按钮使用随机的问候语更新页面标题。
- en: 'The document title isn’t part of the document body and isn’t rendered by React.
    But the title is accessible via the `document` property of the window. You can
    set the title like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 文档标题不是文档正文的一部分，并且不会被React渲染。但是标题可以通过窗口的`document`属性访问。你可以这样设置标题：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Reaching out to a browser API in this way is considered a side effect. We can
    make that explicit by wrapping the code in the `useEffect` hook:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式访问浏览器API被认为是副作用。我们可以通过将代码包裹在`useEffect`钩子中来使其明确：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The following listing shows a `SayHello` component that updates the page title
    with a random greeting whenever the user clicks the Say Hi button.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了一个`SayHello`组件，当用户点击“说你好”按钮时，它会使用随机的问候语更新页面标题。
- en: '*Live*: [https://jhijd.csb.app](https://jhijd.csb.app), *Code*: [https://codesandbox.io/s/sayhello-jhijd](https://codesandbox.io/s/sayhello-jhijd)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*直播*: [https://jhijd.csb.app](https://jhijd.csb.app), *代码*: [https://codesandbox.io/s/sayhello-jhijd](https://codesandbox.io/s/sayhello-jhijd)'
- en: Listing 4.1 Updating the browser title
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.1 更新浏览器标题
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Import the useEffect hook.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入`useEffect`钩子。
- en: ❷ Pass the useEffect hook a function, the effect.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将函数，即效果，传递给`useEffect`钩子。
- en: ❸ Update the browser title from inside the effect.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在效果内部更新浏览器标题。
- en: The component uses a randomly generated index to pick a greeting from an array.
    Whenever the `updateGreeting` function calls `setIndex`, React re-renders the
    component (unless the index value doesn’t change).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 组件使用随机生成的索引从数组中选择一个问候语。每当`updateGreeting`函数调用`setIndex`时，React会重新渲染组件（除非索引值没有变化）。
- en: React runs the effect function within the `useEffect` hook *after* every render,
    once the browser has repainted the page, updating the page title as required.
    Notice that the effect function has access to the variables within the component
    because it’s in the same scope. In particular, it uses the values of the `greetings`
    and `index` variables. Figure 4.2 shows how you pass an effect function as the
    first argument to the `useEffect` hook.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: React在每次渲染后，在浏览器重新绘制页面后，在`useEffect`钩子内运行效果函数，以更新页面标题。注意，效果函数可以访问组件内的变量，因为它处于相同的范围。特别是，它使用了`greetings`和`index`变量的值。图4.2显示了如何将效果函数作为第一个参数传递给`useEffect`钩子。
- en: '![](../Images/4-2.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/4-2.png)'
- en: Figure 4.2 Passing an effect function to the `useEffect` hook
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 将效果函数传递给`useEffect`钩子
- en: When you call the `useEffect` hook in this way, without a second argument, React
    runs the effect after every render. But what if you want to run an effect only
    when a component mounts?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当你以这种方式调用`useEffect`钩子时，没有第二个参数，React会在每次渲染后运行效果。但如果你只想在组件挂载时运行一个效果怎么办？
- en: 4.1.2 Running an effect only when a component mounts
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.2 仅在组件挂载时运行效果
- en: Say you want to use the width and height of the browser window, maybe for a
    groovy animation effect. To test out reading the dimensions, you create a little
    component that displays the current width and height, just as in figure 4.3.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想使用浏览器窗口的宽度和高度，可能用于一个酷炫的动画效果。为了测试读取尺寸，你创建了一个小组件来显示当前的宽度和高度，就像图4.3所示。
- en: '![](../Images/4-3.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/4-3.png)'
- en: Figure 4.3 Displaying the width and height of a window as it’s resized
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 显示窗口的宽度和高度，当它被调整大小时
- en: The following listing shows the code for the component. It reaches out to read
    the `innerWidth` and `innerHeight` properties of the `window` object, so, once
    again, we use the `useEffect` hook.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了组件的代码。它尝试读取`window`对象的`innerWidth`和`innerHeight`属性，因此，我们再次使用`useEffect`钩子。
- en: '*Live*: [https://gn80v.csb.app/](https://gn80v.csb.app/), *Code*: [https://codesandbox.io/s/windowsize-gn80v](https://codesandbox.io/s/windowsize-gn80v)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*实时预览*: [https://gn80v.csb.app/](https://gn80v.csb.app/)，*代码*: [https://codesandbox.io/s/windowsize-gn80v](https://codesandbox.io/s/windowsize-gn80v)'
- en: Listing 4.2 Resizing the window
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.2 调整窗口大小
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Define a function that returns the dimensions of the window.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义一个返回窗口尺寸的函数。
- en: ❷ Read the dimensions from the window object.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从窗口对象中读取尺寸。
- en: ❸ Update the state, triggering a re-render.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 更新状态，触发重新渲染。
- en: ❹ Register an event listener for the resize event.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 注册调整大小事件的监听器。
- en: ❺ Pass an empty array as the dependency argument.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将空数组作为依赖参数传递。
- en: 'Within `useEffect`, the component registers an event listener for resize events:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在`useEffect`内部，组件注册了一个用于调整大小事件的监听器：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Whenever the user resizes the browser, the handler, `handleResize`, updates
    the state with the new dimensions by calling `setSize`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户调整浏览器窗口大小时，`handleResize`处理程序通过调用`setSize`来更新状态，以获取新的尺寸：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By calling the updater function, the component kicks off a re-render. We don’t
    want to keep reregistering the event listener every time React calls the component.
    So how do we prevent the effect from running after every render? The trick is
    the empty array passed as the second argument to `useEffect`, as illustrated in
    figure 4.4.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用更新器函数，组件会启动重新渲染。我们不希望每次React调用组件时都重新注册事件监听器。那么我们如何防止效果在每次渲染后都运行呢？秘诀是将空数组作为`useEffect`的第二个参数传递，如图4.4所示。
- en: '![](../Images/4-4.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-4.png)'
- en: Figure 4.4 Passing an empty dependency array causes the effect function to run
    once, when the component mounts.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 通过传递空依赖项数组，使效果函数在组件挂载时运行一次。
- en: As we see in section 4.1.4, the second argument is for a list of dependencies.
    React determines whether to run an effect by checking if the values in the list
    have changed since the last time the component called the effect. By setting the
    list to an empty array, the list will never change, and we cause the effect to
    run only once, when the component first mounts.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在4.1.4节中看到的，第二个参数是用于依赖项列表的。React通过检查列表中的值自上次组件调用效果以来是否已更改来确定是否运行效果。通过将列表设置为空数组，列表将永远不会更改，我们导致效果仅在组件首次挂载时运行一次。
- en: But hang on a second; alarm bells should be ringing. We registered an event
    listener . . . we shouldn’t just leave that listener listening away, like a zombie
    shambling in a crypt for all eternity. We need to perform some cleaning up and
    unregister the listener. Let’s wrangle those zombies.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等；警钟应该已经响起。我们注册了一个事件监听器……我们不应该让那个监听器一直监听，就像一个僵尸在墓穴中永远蹒跚而行。我们需要进行一些清理并注销监听器。让我们驯服那些僵尸。
- en: 4.1.3 Cleaning up side effects by returning a function
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.3 通过返回函数清理副作用
- en: We have to be careful not to make a mess when we set up long-running side effects
    like subscriptions, data requests, timers, and event listeners. To avoid zombies
    eating our brains so our memories start to leak, or ghosts shifting the furniture
    unexpectedly, we should carefully undo any effects that may cause undead echoes
    of our actions to live on.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在设置长时间运行的副作用，如订阅、数据请求、计时器和事件监听器时必须小心，以免弄乱。为了避免僵尸吞噬我们的大脑，我们的记忆开始泄漏，或者幽灵意外地移动家具，我们应该仔细撤销可能引起我们行动的幽灵般回声的任何效果。
- en: The `useEffect` hook incorporates a simple mechanism for cleaning up our effects.
    Just return a function from the effect. React runs the returned function when
    it’s time to tidy up. The following listing updates our window-measuring app to
    remove the resize listener when it’s no longer needed.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect`钩子包含一个简单的清理我们效果的机制。只需从效果中返回一个函数。React在需要整理时运行返回的函数。以下列表更新了我们的窗口测量应用程序，以便在不再需要时移除调整大小监听器。'
- en: '*Live*: [https://b8wii.csb.app/](https://b8wii.csb.app/), *Code*: [https://codesandbox.io/s/windowsizecleanup-b8wii](https://codesandbox.io/s/windowsizecleanup-b8wii)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*实时预览*: [https://b8wii.csb.app/](https://b8wii.csb.app/)，*代码*: [https://codesandbox.io/s/windowsizecleanup-b8wii](https://codesandbox.io/s/windowsizecleanup-b8wii)'
- en: Listing 4.3 Returning a cleanup function to remove a listener
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.3 返回清理函数以移除监听器
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Return a cleanup function from the effect.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从效果中返回一个清理函数。
- en: Because the code passes `useEffect` an empty array as the second argument, the
    effect will run only once. When the effect runs, it registers an event listener.
    React keeps ahold of the function the effect returns and calls it when it’s time
    to clean up. In listing 4.3, the returned function removes the event listener.
    Our memory won’t leak. Our brains are safe from zombie effects.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因为代码将空数组作为第二个参数传递给 `useEffect`，所以效果只会运行一次。当效果运行时，它会注册一个事件监听器。React 保留效果返回的函数，并在需要清理时调用它。在列表
    4.3 中，返回的函数移除了事件监听器。我们的内存不会泄漏。我们的思维不会受到僵尸效果的影响。
- en: 'Figure 4.5 shows this latest step in our evolving knowledge of the `useEffect`
    hook: returning a cleanup function.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 展示了我们对 `useEffect` 钩子最新了解的这一步：返回一个清理函数。
- en: '![](../Images/4-5.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-5.png)'
- en: Figure 4.5 Return a function from the effect. React will run the function to
    clean up after the effect.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 从效果中返回一个函数。React 将运行该函数来清理效果。
- en: 'Because the cleanup function is defined within the effect, it has access to
    the variables within the effect’s scope. In listing 4.3, the cleanup function
    can remove the `handleResize` function because `handleResize` was also defined
    within the same effect:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因为清理函数是在效果内部定义的，所以它可以访问效果作用域内的变量。在列表 4.3 中，清理函数可以移除 `handleResize` 函数，因为 `handleResize`
    也是在同一个效果内部定义的：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Define the handleResize function.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义 `handleResize` 函数。
- en: ❷ Reference the handleResize function from the cleanup function.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在清理函数中引用 `handleResize` 函数。
- en: The React Hooks approach, in which components and hooks are just functions,
    makes good use of the inherent nature of JavaScript, rather than too heavily relying
    on a layer of idiosyncratic APIs conceptually divorced from the underlying language.
    That does mean, however, that you need a good grasp of scope and closures to best
    understand where to put your variables and functions.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: React Hooks 方法，其中组件和钩子只是函数，很好地利用了 JavaScript 的固有特性，而不是过度依赖与底层语言概念上分离的特异 API
    层。但这确实意味着，你需要很好地掌握作用域和闭包，以最好地理解在哪里放置你的变量和函数。
- en: React runs the cleanup function when it unmounts the component. But that’s not
    the only time it runs it. Whenever the component re-renders, React calls the cleanup
    function before running the effect function, *if the effect runs again*. If multiple
    effects need to run again, React calls all of the cleanup functions for those
    effects. Once the cleanup is finished, React reruns the effect functions as needed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当 React 卸载组件时，它会运行清理函数。但这并不是它运行清理函数的唯一时间。每当组件重新渲染时，React 都会在运行效果函数之前调用清理函数，*如果效果需要再次运行的话*。如果有多个效果需要再次运行，React
    会调用那些效果的清理函数。清理完成后，React 会根据需要重新运行效果函数。
- en: 'We’ve seen the two extremes: running an effect only once and running an effect
    after every render. What if we want more control over when an effect runs? There’s
    one more case to cover. Let’s populate that dependency array.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了两种极端情况：只在第一次运行效果和每次渲染后都运行效果。如果我们想要对效果运行的时间有更多的控制呢？还有一个情况需要考虑。让我们填充那个依赖数组。
- en: 4.1.4 Controlling when an effect runs by specifying dependencies
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.4 通过指定依赖项来控制效果运行的时间
- en: Figure 4.6 is our final illustration of the `useEffect` API, including dependency
    values in the array we pass as the second argument.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 是我们对 `useEffect` API 的最终说明，包括作为第二个参数传递的数组中的依赖值。
- en: '![](../Images/4-6.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-6.png)'
- en: Figure 4.6 When calling `useEffect`, you can specify a list of dependencies
    and return a cleanup function.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 当调用 `useEffect` 时，你可以指定一个依赖项列表并返回一个清理函数。
- en: Each time React calls a component, it keeps a record of the values in the dependency
    arrays for calls to `useEffect`. If the array of values has changed since the
    last call, React runs the effect. If the values are unchanged, React skips the
    effect. This saves the effect from running when the values it depends on are unchanged
    and so the outcome of its task will be unchanged.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 每次 React 调用一个组件时，它都会记录 `useEffect` 调用的依赖数组中的值。如果自上次调用以来值数组已更改，React 会运行效果。如果值未更改，React
    会跳过效果。这可以防止效果在它依赖的值未更改且任务结果将保持不变时运行。
- en: Let’s look at an example. Say you have a user picker that lets you select a
    user from a drop-down menu. You want to store the selected user in the browser’s
    local storage so that the page remembers the selected user from visit to visit,
    as shown in figure 4.7.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子。假设你有一个用户选择器，允许你从下拉菜单中选择一个用户。你想要将选定的用户存储在浏览器的本地存储中，以便页面能够记住每次访问时选定的用户，如图
    4.7 所示。
- en: '![](../Images/4-7.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-7.png)'
- en: Figure 4.7 Once you select a user, refreshing the page automatically reselects
    the same user.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 一旦选择了一个用户，刷新页面会自动重新选择相同的用户。
- en: The following listing shows the code to achieve the desired effect. It includes
    two calls to `useEffect`, one to get any stored user from local storage, and one
    to save the selected user whenever that value changes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了实现所需效果的代码。它包括对`useEffect`的两个调用，一个用于从本地存储获取任何存储的用户，另一个用于在值更改时保存所选用户。
- en: '*Live*: [https://c987h.csb.app/](https://c987h.csb.app/), *Code*: [https://codesandbox.io/s/userstorage-c987h](https://codesandbox.io/s/userstorage-c987h)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*实时*: [https://c987h.csb.app/](https://c987h.csb.app/)，*代码*: [https://codesandbox.io/s/userstorage-c987h](https://codesandbox.io/s/userstorage-c987h)'
- en: Listing 4.4 Using local storage
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.4 使用本地存储
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Read the user from local storage.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从本地存储读取用户。
- en: ❷ Run this effect only when the component first mounts.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 仅当组件首次挂载时运行此效果。
- en: ❸ Specify a second effect.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 指定第二个效果。
- en: ❹ Save the user to local storage.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将用户保存到本地存储。
- en: ❺ Run this effect whenever the user changes.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 当用户更改时运行此效果。
- en: The component works as expected, saving changes to local storage and automatically
    selecting the saved user when the page is reloaded.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 组件按预期工作，将更改保存到本地存储，并在页面重新加载时自动选择保存的用户。
- en: 'But to get a better feel for how the function component and its hooks manage
    all the pieces, let’s run through the steps for the component as it renders and
    re-renders and a visitor to the page selects a user from the list. We look at
    two key scenarios:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 但为了更好地理解函数组件及其钩子如何管理所有这些部分，让我们按照组件渲染和重新渲染的步骤以及页面访问者从列表中选择用户的步骤来运行。我们关注两个关键场景：
- en: The visitor first loads the page. There is no user value in local storage. The
    visitor selects a user from the list.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问者首先加载页面。本地存储中没有用户值。访问者从列表中选择一个用户。
- en: The visitor refreshes the page. There is a user value in local storage.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问者刷新页面。本地存储中有一个用户值。
- en: As we go through the steps, notice how the dependency lists for the two effects
    determine when the effect functions run.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们通过步骤进行时，注意两个效果依赖列表如何确定效果函数的运行时机。
- en: The visitor first loads the page
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者首先加载页面
- en: 'When the component first runs, it renders the drop-down list of users with
    Sanjiv selected. Then the first effect runs. No user is in local storage, so nothing
    happens. Then the second effect runs. It saves Sanjiv to local storage. Here are
    the steps:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件首次运行时，它渲染带有Sanjiv选择的用户下拉列表。然后第一个效果运行。本地存储中没有用户，所以没有发生任何事情。然后第二个效果运行。它将Sanjiv保存到本地存储。以下是步骤：
- en: The user loads the page.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户加载页面。
- en: React calls the component.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React调用组件。
- en: The `useState` call sets the value of `user` to `Sanjiv`. (It’s the first time
    the component has called `useState`, so the initial value is used.)
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`useState`调用将`user`的值设置为`Sanjiv`。（这是组件第一次调用`useState`，所以使用初始值。）'
- en: React renders the list of users with Sanjiv selected.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React渲染带有Sanjiv选择的用户列表。
- en: Effect 1 runs, but there is no stored user.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 效果1运行，但没有存储的用户。
- en: Effect 2 runs, saving `Sanjiv` to local storage.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 效果2运行，将`Sanjiv`保存到本地存储。
- en: React calls the effect functions in the order they appear in the component code.
    When the effects run, React keeps a record of the values in the dependency lists,
    `[]` and `["Sanjiv``"]` in this case.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: React按照组件代码中出现的顺序调用效果函数。当效果运行时，React会记录依赖列表中的值，在这个例子中是`[]`和`["Sanjiv"]`。
- en: 'When the visitor selects a new user (say, Akiko), the `onChange` handler calls
    the `setUser` updater function. React updates the state and calls the component
    again. This time, effect 1 doesn’t run because its dependency list hasn’t changed;
    it’s still `[]`. But the dependency list for effect 2 has changed from `["Sanjiv``"]`
    to `["Akiko``"]`, so effect 2 runs again, updating the value in local storage.
    The steps continue as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问者选择一个新的用户（比如Akiko）时，`onChange`处理程序调用`setUser`更新函数。React更新状态并再次调用组件。这次，效果1没有运行，因为它的依赖列表没有变化；它仍然是`[]`。但效果2的依赖列表已从`["Sanjiv"]`变为`["Akiko"]`，所以效果2再次运行，更新本地存储中的值。以下步骤继续：
- en: The user selects Akiko.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户选择Akiko。
- en: The updater function sets the user state to Akiko.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新函数将用户状态设置为Akiko。
- en: React calls the component.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React调用组件。
- en: The `useState` call sets the value of `user` to Akiko. (It’s the second time
    the component has called `useState`, so the latest value, set in step 8, is used.)
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`useState`调用将`user`的值设置为Akiko。（这是组件第二次调用`useState`，所以使用第8步设置的最新值。）'
- en: React renders the list of users with Akiko selected.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React渲染带有Akiko选择的用户列表。
- en: Effect 1 doesn’t run (`[]` = `[])`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Effect 1 不会运行（`[]` = `[]`）。
- en: Effect 2 runs (`["Sanjiv"]` != `["Akiko"])`, saving `Akiko` to local storage.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Effect 2 运行（`["Sanjiv"]` != `["Akiko"]`），将 `Akiko` 保存到本地存储。
- en: The visitor refreshes the page
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者刷新页面
- en: 'With local storage set to Akiko, if the user reloads the page, effect 1 will
    set the user state to the stored value, Akiko, as we saw in figure 4.7\. But before
    React calls the component with the new state value, effect 2 still has to run
    with the old value. Here are the steps:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当本地存储设置为 Akiko 时，如果用户重新加载页面，effect 1 将用户状态设置为存储的值，Akiko，正如我们在图 4.7 中所看到的。但在
    React 调用组件的新状态值之前，effect 2 仍然需要使用旧值运行。以下是步骤：
- en: The user refreshes the page.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户刷新页面。
- en: React calls the component.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React 调用组件。
- en: The `useState` call sets the value of `user` to `Sanjiv`. (It’s the first time
    the component has called `useState`, so the initial value is used.)
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`useState` 调用将 `user` 的值设置为 `Sanjiv`。（这是组件第一次调用 `useState`，因此使用初始值。）'
- en: React renders the list of users with Sanjiv selected.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React 渲染带有 Sanjiv 选择的用户列表。
- en: Effect 1 runs, loading Akiko from local storage and calling `setUser`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Effect 1 运行，从本地存储中加载 Akiko 并调用 `setUser`。
- en: Effect 2 runs, saving Sanjiv to local storage.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Effect 2 运行，将 Sanjiv 保存到本地存储。
- en: React calls the component (because effect 1 called setUser, changing the state).
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React 调用组件（因为 effect 1 调用了 `setUser`，改变了状态）。
- en: The `useState` call sets the value of `user` to `Akiko`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`useState` 调用将 `user` 的值设置为 `Akiko`。'
- en: React renders the list of users with Akiko selected.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React 渲染带有 Akiko 选择的用户列表。
- en: Effect 1 doesn’t run (`[]` = `[])`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Effect 1 不会运行（`[]` = `[]`）。
- en: Effect 2 runs (`["Sanjiv"]` != `["Akiko"])`, saving `Akiko` to local storage.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Effect 2 运行（`["Sanjiv"]` != `["Akiko"]`），将 `Akiko` 保存到本地存储。
- en: In step 6, effect 2 was defined as part of the initial render, so it still uses
    the initial `user` value, `Sanjiv`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 6 中，effect 2 被定义为初始渲染的一部分，因此它仍然使用初始的 `user` 值，`Sanjiv`。
- en: 'By including `user` in the list of dependencies for effect 2, we’re able to
    control when effect 2 runs: only when the value of `user` changes.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 `user` 包含在 effect 2 的依赖项列表中，我们能够控制 effect 2 的运行时机：只有当 `user` 的值发生变化时才会运行。
- en: 4.1.5 Summarizing the ways to call the useEffect hook
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.5 总结调用 useEffect 钩子的方式
- en: Table 4.1 collects the various use cases for the `useEffect` hook into one place,
    showing how the different code patterns lead to different execution patterns.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1 收集了 `useEffect` 钩子的各种用例到一个地方，展示了不同的代码模式如何导致不同的执行模式。
- en: Table 4.1 The various use cases for the `useEffect` hook
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1 `useEffect` 钩子的各种用例
- en: '| Call pattern | Code pattern | Execution pattern |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 调用模式 | 代码模式 | 执行模式 |'
- en: '| No second argument | `useEffect(() => {``// perform effect``});` | Run after
    every render. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 没有第二个参数 | `useEffect(() => {``// 执行效果``});` | 在每次渲染后运行。|'
- en: '| Empty array as second argument | `useEffect(() => {``// perform effect``},
    []);` | Run once, when the component mounts. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 作为第二个参数的空数组 | `useEffect(() => {``// 执行效果``}, []);` | 只运行一次，当组件挂载时。|'
- en: '| Dependency array as second argument | `useEffect(() => {``// perform effect``//
    that uses dep1 and dep2``}, [dep1, dep2]);` | Run whenever a value in the dependency
    array changes. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 作为第二个参数的依赖数组 | `useEffect(() => {``// 执行效果``// 使用 dep1 和 dep2``}, [dep1,
    dep2]);` | 当依赖数组中的任何值发生变化时运行。|'
- en: '| Return a function | `useEffect(() => {``// perform effect``return () => {/*
    clean-up */};``}, [dep1, dep2]);` | React will run the cleanup function when the
    component unmounts and before rerunning the effect. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 返回一个函数 | `useEffect(() => {``// 执行效果``return () => {/* 清理 */};``}, [dep1,
    dep2]);` | React 将在组件卸载时运行清理函数，并在重新运行效果之前。|'
- en: Challenge 4.1
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战 4.1
- en: On CodeSandbox (or anywhere you prefer), create an app that updates the document
    title as the window is resized. It should say “Small” or “Medium” or “Large,”
    depending on the size of the window.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CodeSandbox（或你喜欢的任何地方），创建一个应用，当窗口大小调整时更新文档标题。它应该显示“小”、“中等”或“大”，具体取决于窗口的大小。
- en: 4.1.6  Calling useLayoutEffect to run an effect before the browser repaints
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.6 在浏览器重绘之前调用 useLayoutEffect 来运行效果
- en: Most of the time, we synchronize side effects with state by calling `useEffect`.
    React runs the effects after the component has rendered and the browser has repainted
    the screen. Occasionally, we might want to make further changes to state after
    React has updated the DOM but before the browser has repainted. We might want
    to use the dimensions of DOM elements to set state in some way, for example. Making
    changes in `useEffect` will show users an intermediate state that’ll immediately
    be updated.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，我们通过调用 `useEffect` 来同步副作用和状态。React 在组件渲染后和浏览器重绘屏幕之前运行效果。偶尔，我们可能在 React
    更新 DOM 但浏览器尚未重绘之前想要对状态进行进一步的更改。我们可能想以某种方式使用 DOM 元素的尺寸来设置状态，例如。在 `useEffect` 中进行更改将使用户看到中间状态，该状态将立即更新。
- en: We can avoid such flashes of changing state by calling the `useLayoutEffect`
    hook instead of `useEffect`. This hook has the same API as `useEffect` but runs
    synchronously after React updates the DOM and before the browser repaints. If
    the effect makes further updates to the state, the intermediate state isn’t painted
    to the screen. You generally won’t need `useLayoutEffect`, but if you come across
    problems (maybe with an element flickering between states), you could try switching
    from `useEffect` for the suspect effect.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用 `useLayoutEffect` 钩子而不是 `useEffect` 来避免这种状态变化的闪烁。这个钩子具有与 `useEffect`
    相同的 API，但在 React 更新 DOM 和浏览器重绘之前同步运行。如果效果对状态进行了进一步的更新，中间状态不会被绘制到屏幕上。通常你不需要 `useLayoutEffect`，但如果遇到问题（可能是一个元素在状态之间闪烁），你可以尝试将
    `useEffect` 更换为有问题的效果。
- en: Now that we’ve seen what the `useEffect` hook can do, it’s time to fetch some
    data. Let’s make our app data available via a server rather than as a file import.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看到了 `useEffect` 钩子能做什么，是时候获取一些数据了。让我们让我们的应用数据通过服务器而不是文件导入的方式变得可用。
- en: 4.2 Fetching data
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 获取数据
- en: 'So far in this book, we’ve been importing data for the bookings app example
    from the static.json file. But it’s more common to fetch data from a server. To
    make our examples a little more realistic, let’s start doing just that. Rather
    than reach out to a public server, we’ll run a JSON server locally, using a new
    db.json file outside the src folder. We’ll then create a component that fetches
    data from that server. We cover the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，我们一直在从 static.json 文件导入预订应用示例的数据。但通常情况下，我们会从服务器获取数据。为了让我们的示例更加真实，让我们开始这样做。我们不会连接到公共服务器，而是在本地运行一个
    JSON 服务器，使用位于 src 文件夹外的新的 db.json 文件。然后我们将创建一个从该服务器获取数据的组件。我们将涵盖以下内容：
- en: Creating the new db.json file
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的 db.json 文件
- en: Setting up a JSON server using the `json-server` package
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `json-server` 包设置 JSON 服务器
- en: Building a component to fetch data from our server, displaying a list of users
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个组件从我们的服务器获取数据，显示用户列表
- en: Taking care when using `async` and `await` within an effect
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在效果中使用 `async` 和 `await` 时要注意
- en: 4.2.1 Creating the new db.json file
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 创建新的 db.json 文件
- en: In chapters 2 and 3, we imported data from the static.json file. For our server,
    copy across the bookings, users, and bookables data to a new db.json file in the
    root of the project. Don’t copy the `days` and `sessions` arrays in static.json;
    we treat that as config information and continue to import it. (We’ll remove the
    duplicated data from static.json after we’ve updated the components that are currently
    using it.)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 2 章和第 3 章中，我们从 static.json 文件中导入数据。对于我们的服务器，将预订、用户和可预订数据复制到项目根目录下的新的 db.json
    文件中。不要复制 static.json 中的 `days` 和 `sessions` 数组；我们将这些视为配置信息，并继续导入。（在我们更新了当前正在使用它的组件之后，我们将从
    static.json 中删除重复的数据。）
- en: '[PRE9]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In later chapters, we’ll start updating the database file by sending POST and
    PUT requests. The `create-react-app` development server restarts whenever files
    within the src folder change. Having the db.json file outside src avoids unnecessary
    restarts as we test adding new bookables and making bookings.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的章节中，我们将开始通过发送 POST 和 PUT 请求来更新数据库文件。`create-react-app` 开发服务器在 src 文件夹内的文件更改时重启。将
    db.json 文件放在 src 文件夹之外可以避免在测试添加新的可预订项目和进行预订时发生不必要的重启。
- en: 4.2.2 Setting up a JSON server
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 设置 JSON 服务器
- en: 'Until now, we’ve been importing data for the `BookablesList`, `UsersList`,
    and `UserPicker` components from a JSON file, static.json:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直从 JSON 文件 static.json 中导入 `BookablesList`、`UsersList` 和 `UserPicker`
    组件的数据：
- en: '[PRE10]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To better exemplify the kinds of data-fetching tasks we perform in a real application,
    we want to make our data available via HTTP. Luckily, we don’t need to spin up
    a real database for our data. We can instead use the `json-server` npm package.
    This package is a really handy, easy way of serving up JSON data as a mock REST
    API. There’s a user guide at [https://github.com/typicode/json-server](https://github.com/typicode/json-server),
    where you can see just how flexible the package is. To install the package globally
    using npm, enter this command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地展示我们在实际应用中执行的数据获取任务，我们希望通过 HTTP 提供我们的数据。幸运的是，我们不需要为我们的数据启动一个真实的数据库。我们可以使用
    `json-server` npm 包。这个包是一个非常方便、简单的方式来提供 JSON 数据作为模拟 REST API。在 [https://github.com/typicode/json-server](https://github.com/typicode/json-server)
    有一个用户指南，您可以查看这个包的灵活性。要使用 npm 全局安装此包，请输入以下命令：
- en: '[PRE11]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, from within the root of our project, start the server with this command:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从我们项目的根目录开始，使用以下命令启动服务器：
- en: '[PRE12]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You should be able to query our database on `localhost:3001`. Figure 4.8 shows
    the terminal output on my machine when I start up the server.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够在 `localhost:3001` 上查询我们的数据库。图 4.8 显示了我启动服务器时机器上的终端输出。
- en: '![](../Images/4-8.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-8.png)'
- en: Figure 4.8 The output when running `json-server`. Properties from within the
    db.json file have been turned into endpoints for fetchable resources.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 运行 `json-server` 的输出。`db.json` 文件中的属性已被转换为可获取资源的端点。
- en: We’ve made our db.json file JSON data available over HTTP via URL endpoints.
    Comparing the data from the file to figure 4.8, you can see that the server has
    turned each property from the JSON object into an endpoint. For example, to get
    the list of users, navigate to `localhost:3001/users`; and to get the user with
    an ID of 1, navigate to `localhost:3001/users/1`. Nice!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过 URL 端点将 `db.json` 文件中的 JSON 数据公开。将文件中的数据与图 4.8 进行比较，您可以看到服务器已经将 JSON
    对象的每个属性转换为端点。例如，要获取用户列表，请导航到 `localhost:3001/users`；要获取 ID 为 1 的用户，请导航到 `localhost:3001/users/1`。太棒了！
- en: 'You can test out the requests in a browser. The results of the two requests
    just mentioned are shown in figure 4.9: first, the list of user objects in an
    array, and second, the user object with an ID of 1.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在浏览器中测试这些请求。前面提到的两个请求的结果如图 4.9 所示：首先是数组中的用户对象列表，其次是具有 ID 为 1 的用户对象。
- en: '![](../Images/4-9.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-9.png)'
- en: Figure 4.9 Two browser responses showing our bookings app data is now available
    via HTTP
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 显示两个浏览器响应，我们的预订应用数据现在可以通过 HTTP 获取
- en: Let’s try out our server and fetch some data from within a `useEffect` hook.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试我们的服务器，并从 `useEffect` 钩子中获取一些数据。
- en: 4.2.3 Fetching data within a useEffect hook
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 在 useEffect 钩子中获取数据
- en: To introduce data fetching from within a `useEffect` hook, we update the `UserPicker`
    component to fetch the users from our JSON database. Figure 4.10 shows the expanded
    drop-down list with the four users.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了介绍从 `useEffect` 钩子中进行数据获取，我们更新了 `UserPicker` 组件，从我们的 JSON 数据库中获取用户。图 4.10
    显示了包含四个用户的展开下拉列表。
- en: '![](../Images/4-10.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-10.png)'
- en: Figure 4.10 Displaying a list of users fetched from the database
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 显示从数据库中获取的用户列表
- en: Remember, React calls effect functions after rendering, so the data won’t be
    available for the first render; we set an empty list of users as the initial value
    and return alternative UI, a new `Spinner` component, for the loading state. The
    following listing shows the code to fetch the list of users and display it in
    the drop-down.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，React 在渲染后调用 effect 函数，因此数据在第一次渲染时不可用；我们将用户列表的空列表设置为初始值，并返回替代 UI，一个新的 `Spinner`
    组件，用于加载状态。以下列表显示了获取用户列表并将其显示在下拉列表中的代码。
- en: 'Branch: 0401-user-picker, File: /src/components/Users/UserPicker.js'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0401-user-picker，文件：/src/components/Users/UserPicker.js
- en: Listing 4.5 The `UserPicker` component fetching data
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.5 `UserPicker` 组件获取数据
- en: '[PRE13]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Fetch the data from inside an effect function.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在 effect 函数内部获取数据。
- en: ❷ Make the request to the database by using the browser’s fetch API.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用浏览器的 fetch API 向数据库发送请求。
- en: ❸ Convert the JSON string returned into a JavaScript object.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将返回的 JSON 字符串转换为 JavaScript 对象。
- en: ❹ Update the state with the loaded users.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 更新状态以包含已加载的用户。
- en: ❺ Include an empty dependency array to load the data once, when the component
    is first mounted.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 包含一个空的依赖数组，以便在组件首次挂载时加载数据。
- en: ❻ Return alternative UI while the users load.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 在用户加载时返回替代 UI。
- en: 'The `UserPicker` code uses the browser’s fetch API to retrieve the list of
    users from the database, parses the response as JSON by using the `resp.json`
    method, and calls `setUsers` to update the local state with the result. The component
    initially renders a `Spinner` placeholder (from the new /src/components/UI folder
    in the repo), before replacing it with the list of users. If you want to add latency
    to the fetch calls, to better see any loading states, start the JSON server with
    a `delay` flag. This snippet delays responses for 3000 milliseconds, or 3 seconds:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserPicker` 代码使用浏览器的 fetch API 从数据库中检索用户列表，通过使用 `resp.json` 方法将响应解析为 JSON，并调用
    `setUsers` 以更新本地状态。组件最初渲染一个 `Spinner` 占位符（来自存储库中新的 /src/components/UI 文件夹），然后将其替换为用户列表。如果您想向
    fetch 调用添加延迟，以更好地查看任何加载状态，请使用带有 `delay` 标志启动 JSON 服务器。此代码片段将响应延迟 3000 毫秒，即 3 秒：'
- en: '[PRE14]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The effect in listing 4.5 runs only once, when the component mounts. We’re
    not expecting the list of users to change, so there’s no need to manage the reloading
    of the list. The following list shows the sequence of steps for fetching data
    from an effect in this way:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.5 中的效果只在其组件挂载时运行一次。我们预计用户列表不会改变，因此不需要管理列表的重新加载。以下列表显示了以这种方式从效果中获取数据的步骤：
- en: React calls the component.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React 调用组件。
- en: The `useState` call sets the `users` variable to `null`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`useState` 调用将 `users` 变量设置为 `null`。'
- en: The `useEffect` call registers the data-fetching effect function with React.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`useEffect` 调用将数据获取效果函数注册到 React 中。'
- en: The `users` variable is `null`, so the component returns the spinner icon.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`users` 变量是 `null`，因此组件返回旋转图标。'
- en: React runs the effect, requesting data from the server.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React 运行效果，从服务器请求数据。
- en: The data arrives, and the effect calls the `setUsers` updater function, triggering
    a re-render.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据到达，效果调用 `setUsers` 更新器函数，触发重新渲染。
- en: React calls the component.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React 调用组件。
- en: The `useState` call sets the `users` variable to the returned list of users.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`useState` 调用将 `users` 变量设置为返回的用户列表。'
- en: The empty dependency array, `[]`, for `useEffect` is unchanged, so the hook
    call does not reregister the effect.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`useEffect` 的空依赖数组 `[]` 未改变，因此钩子调用不会重新注册效果。'
- en: The `users` array has four elements (it’s not `null`), so the component returns
    the drop-down UI.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`users` 数组有四个元素（它不是 `null`），因此组件返回下拉 UI。'
- en: This method of fetching data, in which the component renders before it kicks
    off a request for data, is called *fetch on render*. Other methods can sometimes
    offer a smoother experience for your users, and we’ll take a look at some of those
    in part 2\. But depending on the complexity and stability of the data source and
    your application’s needs, the simplicity of fetching within a call to the `useEffect`
    hook might be perfectly adequate and quite appealing.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这种在组件渲染之前启动数据请求的获取数据方法被称为 *渲染时获取*。其他方法有时可以为用户提供更平滑的体验，我们将在第 2 部分中查看其中一些。但根据数据源复杂性和稳定性以及应用程序需求，在
    `useEffect` 钩子调用中获取数据的简单性可能完全足够，并且非常吸引人。
- en: Challenge 4.2
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战 4.2
- en: Update the `UsersList` component on the `UsersPage` to fetch the users data
    from the server. The 0402-users-list branch has the challenge solution code for
    the updated component.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 `UsersPage` 上的 `UsersList` 组件以从服务器获取用户数据。0402-users-list 分支包含更新组件的挑战解决方案代码。
- en: 4.2.4 Working with async and await
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.4 使用 async 和 await
- en: 'The `fetch` call in listing 4.5 returns a promise, and the listing uses the
    promise’s `then` method to process the response:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.5 中的 `fetch` 调用返回一个承诺，列表使用承诺的 `then` 方法来处理响应：
- en: '[PRE15]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'JavaScript also offers `async` functions and the `await` keyword for working
    with asynchronous responses, but there are some caveats when combining them with
    the `useEffect` hook. As an initial attempt to convert our data-fetching to async-await,
    we might try this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 还提供了 `async` 函数和 `await` 关键字来处理异步响应，但与 `useEffect` 钩子结合使用时有一些注意事项。作为将我们的数据获取转换为
    async-await 的初始尝试，我们可能会尝试这样做：
- en: '[PRE16]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: But that approach provokes React to show a warning on the console, as shown
    in figure 4.11.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种方法会触发 React 在控制台显示警告，如图 4.11 所示。
- en: '![](../Images/4-11.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-11.png)'
- en: Figure 4.11 Our async-await data-fetching effect causes React to issue some
    warnings.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 我们使用 async-await 的数据获取效果导致 React 发布了一些警告。
- en: 'The key message from the browser is as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器传来的关键信息如下：
- en: Effect callbacks are synchronous to prevent race conditions. Put the async function
    inside.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 效果回调是同步的，以防止竞争条件。将异步函数放在里面。
- en: '`async` functions return a promise by default. Setting the effect function
    as `async` will cause trouble because React is looking for the return value of
    an effect to be a cleanup function. To solve the issues, remember to put the `async`
    function inside the effect function, rather than making the effect function `async`
    itself:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`async` 函数默认返回一个承诺。将效果函数设置为 `async` 会导致问题，因为 React 正在寻找效果返回值应该是一个清理函数。为了解决问题，请记住将
    `async` 函数放在效果函数内部，而不是使效果函数本身 `async`：'
- en: '[PRE17]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Define an async function.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义一个异步函数。
- en: ❷ Wait for asynchronous results.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 等待异步结果。
- en: ❸ Call the async function.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 调用异步函数。
- en: Now that we’ve set up the JSON server, tried an example of the fetch-on-render
    data-fetching method with the `useEffect` hook, and taken a moment to consider
    async-await syntax, we’re ready to update the bookings app to fetch data for the
    `BookablesList` component.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了 JSON 服务器，尝试了使用 `useEffect` 钩子的 fetch-on-render 数据获取方法的示例，并花了一点时间考虑
    async-await 语法，我们准备更新预订应用程序以获取 `BookablesList` 组件的数据。
- en: 4.3 Fetching data for the BookablesList component
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 为 `BookablesList` 组件获取数据
- en: In the preceding section, we saw how a component can load data after its initial
    render by including the fetching code within a call to the `useEffect` hook. More-complicated
    applications consist of many components and multiple queries for data that could
    use multiple endpoints. You might try to smooth that complexity by moving the
    state and its associated data-fetching actions into a separate data store and
    then connecting components to the store. But situating the data fetching within
    the components that consume the data may be a more direct and understandable approach
    for your app. We’ll consider different approaches in chapter 9, when we look at
    custom hooks, and in part 2, when we look at models for data fetching.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了一个组件如何在初始渲染后通过在 `useEffect` 钩子调用中包含获取代码来加载数据。更复杂的应用程序由许多组件和多个数据查询组成，这些查询可能使用多个端点。您可能会尝试通过将状态及其相关数据获取操作移动到单独的数据存储中，然后连接组件到存储来简化这种复杂性。但对于您的应用程序，将数据获取放在消耗数据的组件中可能是一个更直接和易于理解的方法。我们将在第
    9 章中考虑不同的方法，当时我们将查看自定义钩子，以及在第二部分中查看数据获取的模型。
- en: 'For now, we’ll keep things simple and get the `BookablesList` component to
    load its own data. We’ll develop its data-fetching capability over four steps:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将保持简单，让 `BookablesList` 组件加载自己的数据。我们将通过四个步骤开发其数据获取功能：
- en: Examining the data-loading process
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查数据加载过程
- en: Updating the reducer to manage loading and error states
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新 reducer 以管理加载和错误状态
- en: Creating a helper function to load data
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个辅助函数来加载数据
- en: Loading the bookables
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载可预订项
- en: 4.3.1 Examining the data-loading process
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 检查数据加载过程
- en: The `UserPicker` component, in section 4.2, used the fetch API to load the list
    of users from the JSON database server. For the `BookablesList` component, we
    consider loading and error states as well as the bookables themselves. What exactly
    do we want the updated component to do?
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在 4.2 节中，`UserPicker` 组件使用了 fetch API 从 JSON 数据库服务器加载数据列表。对于 `BookablesList`
    组件，我们考虑了加载和错误状态以及可预订项本身。我们希望更新的组件具体做什么？
- en: After the component first renders, it will fire off a request for the data it
    needs. At this point, before any data has loaded, we have no bookables or groups
    to display, so the component will show a loading indicator, as shown in figure
    4.12.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件首次渲染后，它将发出对所需数据的请求。在此阶段，在任何数据加载之前，我们没有可预订项或组来显示，因此组件将显示一个加载指示器，如图 4.12 所示。
- en: '![](../Images/4-12.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-12.png)'
- en: Figure 4.12 The `BookablesList` component shows a loading indicator while the
    data is loading.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 当数据正在加载时，`BookablesList` 组件显示一个加载指示器。
- en: If a problem loading the data occurs—maybe network, server, authorization, or
    missing file issues—the component will display an error message like the one in
    figure 4.13.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在加载数据时出现问题——可能是网络、服务器、授权或缺少文件问题——组件将显示如图 4.13 所示的错误消息。
- en: '![](../Images/4-13.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-13.png)'
- en: Figure 4.13 The `BookablesList` component shows an error message if there was
    a problem loading data.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 `BookablesList` 组件在加载数据时显示错误消息。
- en: If everything goes well and the data arrives, it’ll be displayed in the UI we
    developed in chapters 2 and 3\. The Meeting Room bookable from the Rooms group
    is selected, and its details are showing. Figure 4.14 shows the expected result.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利并且数据到达，它将在我们第 2 章和第 3 章中开发的 UI 中显示。来自“房间”组的“会议室”可预订项被选中，其详细信息正在显示。图 4.14
    显示了预期的结果。
- en: '![](../Images/4-14.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-14.png)'
- en: Figure 4.14 The `BookablesList` component shows the list of bookables after
    the data has loaded.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14 `BookablesList`组件显示了数据加载后的可预订项列表。
- en: At this point, the user will be able to interact with the app, selecting groups
    and bookables, cycling through the bookables with the Next button, and toggling
    bookable details with the Show Details check box.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个时候，用户将能够与应用程序交互，选择组和可预订项，使用“下一步”按钮遍历可预订项，以及使用“显示详细信息”复选框切换可预订项的详细信息。
- en: In chapter 3, we created a reducer to help manage the `BookablesList` component’s
    state. How should we update the reducer to cope with the new functionality?
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章中，我们创建了一个reducer来帮助管理`BookablesList`组件的状态。我们应该如何更新reducer以应对新的功能？
- en: 4.3.2 Updating the reducer to manage loading and error states
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 更新reducer以管理加载和错误状态
- en: 'We’ve seen what we’re trying to achieve. Now we must consider the component
    state needed to drive such an interface. To enable the loading indicator and the
    error message, we add two more properties to the state: `isLoading` and `error`.
    We also set the bookables as an empty array. The full initial state now looks
    like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了我们试图实现的目标。现在我们必须考虑驱动此类界面的组件状态。为了启用加载指示器和错误消息，我们在状态中添加了两个额外的属性：`isLoading`和`error`。我们还把可预订项设置为空数组。完整的初始状态现在看起来是这样的：
- en: '[PRE18]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The component will start loading data *after* the first render, so we set `isLoading`
    to `true` right from the start. Our initial UI will be the loading indicator.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 组件将在第一次渲染后开始加载数据，所以我们从一开始就将`isLoading`设置为`true`。我们的初始UI将是加载指示器。
- en: 'To change the state in response to data-fetching events, we add three new action
    types to the reducer:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了响应数据获取事件而更改状态，我们在reducer中添加了三个新的动作类型：
- en: '`FETCH_BOOKABLES_REQUEST`—The component initiates the request.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FETCH_BOOKABLES_REQUEST`—组件初始化请求。'
- en: '`FETCH_BOOKABLES_SUCCESS`—The bookables arrive from the server.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FETCH_BOOKABLES_SUCCESS`—可预订项从服务器到达。'
- en: '`FETCH_BOOKABLES_ERROR`—Something went wrong.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FETCH_BOOKABLES_ERROR`—出了些问题。'
- en: We discuss the new action types further after the following listing, which shows
    them in our updated reducer.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表之后，我们进一步讨论了新的动作类型，它们在我们的更新reducer中显示。
- en: 'Branch: 0403-bookables-list, File: /src/components/Bookables/reducer.js'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0403-bookables-list，文件：/src/components/Bookables/reducer.js
- en: Listing 4.6 Managing loading and error states in the reducer
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.6 在reducer中管理加载和错误状态
- en: '[PRE19]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Clear the bookables when requesting new data.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 请求新数据时清除可预订项。
- en: ❷ Pass the loaded bookables to the reducer via the payload.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 通过负载将加载的可预订项传递给reducer。
- en: ❸ Pass the error to the reducer via the payload.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 通过负载将错误传递给reducer。
- en: FETCH_BOOKABLES_REQUEST
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: FETCH_BOOKABLES_REQUEST
- en: When the component sends off its request for the bookables data, we want to
    show the loading indicator in the UI. In addition to setting `isLoading` to `true`,
    we make sure there are no existing bookables and clear out any error message.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件发送其请求获取可预订项数据时，我们希望在UI中显示加载指示器。除了将`isLoading`设置为`true`外，我们确保没有现有的可预订项，并清除任何错误消息。
- en: FETCH_BOOKABLES_SUCCESS
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: FETCH_BOOKABLES_SUCCESS
- en: Woo-hoo! The bookables have arrived and are in the action’s payload. We want
    to display them, so set `isLoading` to `false` and assign the payload to the `bookables`
    state property.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 哇哦！可预订项已经到达，并且位于动作的负载中。我们希望显示它们，所以将`isLoading`设置为`false`并将负载分配给`bookables`状态属性。
- en: FETCH_BOOKABLES_ERROR
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: FETCH_BOOKABLES_ERROR
- en: Boo! Something went wrong, and the error message is in the action’s payload.
    We want to display the error message, so set `isLoading` to `false` and assign
    the payload to the `error` state property.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 哎！出了些问题，错误消息在动作的负载中。我们希望显示错误消息，所以将`isLoading`设置为`false`并将负载分配给`error`状态属性。
- en: You can see that a lot of interrelated state changes are going on for each action;
    having a reducer to group and centralize those changes is really helpful.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，对于每个动作，都有很多相互关联的状态变化在进行；有一个reducer来分组和集中这些变化是非常有帮助的。
- en: 4.3.3 Creating a helper function to load data
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.3 创建一个辅助函数来加载数据
- en: 'When the `UserPicker` component fetched its data, it didn’t worry about loading
    states or error messages; it just went right ahead and called `fetch` from within
    a `useEffect` hook. Now that we’re doing a bit more to give users some feedback
    while data is loading, it might be better to create some dedicated data-fetching
    functions. We want our data code to perform three key tasks:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当`UserPicker`组件获取其数据时，它没有担心加载状态或错误消息；它直接在`useEffect`钩子内部调用`fetch`。现在我们做了一些更多的事情，在数据加载时给用户一些反馈，可能最好创建一些专门的数据获取函数。我们希望我们的数据代码执行三个关键任务：
- en: Send the request
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送请求
- en: Check the response for errors
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查响应是否存在错误
- en: Convert the response to a JavaScript object
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将响应转换为JavaScript对象
- en: The `getData` function in the following listing performs the three tasks, as
    required. We discuss each task in more detail after the listing. The file api.js
    has been added in the utils folder.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表中的`getData`函数执行了所需的三个任务。在列表之后，我们将更详细地讨论每个任务。在utils文件夹中已添加文件api.js。
- en: 'Branch: 0403-bookables-list, File: /src/utils/api.js'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0403-bookables-list，文件：/src/utils/api.js
- en: Listing 4.7 A function for fetching data
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.7 获取数据的函数
- en: '[PRE20]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Accept a URL argument.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 接受一个URL参数。
- en: ❷ Pass the URL on to the browser’s fetch function.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将URL传递给浏览器的fetch函数。
- en: ❸ Check if there is a problem with the response.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查响应是否存在问题。
- en: ❹ Throw an error for any problems.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 对于任何问题抛出错误。
- en: ❺ Convert the response JSON string into a JavaScript object.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将响应的JSON字符串转换为JavaScript对象。
- en: Send the request
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 发送请求
- en: 'The `getData` function accepts one argument, the `url`, and passes it on to
    the `fetch` function. (The `fetch` function also accepts a second argument, an
    `init` object, but we won’t be using that for now.) You can find out more about
    the fetch API on MDN: [http://mng.bz/1r81](http://mng.bz/1r81). `fetch` returns
    a promise that should resolve to a response object from which we can get our data.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`getData`函数接受一个参数，即`url`，并将其传递给`fetch`函数。（`fetch`函数还接受第二个参数，即`init`对象，但我们现在不会使用它。）您可以在MDN上了解更多关于fetch
    API的信息：[http://mng.bz/1r81](http://mng.bz/1r81)。`fetch`返回一个promise，它应该解析为从响应对象中获取我们的数据。'
- en: Check the response for errors
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 检查响应是否存在错误
- en: 'We call `then` on the promise that `fetch` returns, setting up a function to
    do some initial processing of the response:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在fetch返回的promise上调用`then`，设置一个函数来对响应进行一些初始处理：
- en: '[PRE21]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'First, we check the status of the response and throw an error if it’s not `ok`
    (the HTTP status code is not in the range 200 to 299):'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查响应的状态，如果状态不是`ok`（HTTP状态码不在200到299的范围内），则抛出错误：
- en: '[PRE22]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Responses with status codes outside the 200 to 299 range are valid, and `fetch`
    doesn’t automatically throw any errors for them. We do our own check and throw
    an error if necessary. We don’t catch any errors here; the calling code should
    set up any `catch` blocks it needs.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 状态码不在200到299范围内的响应是有效的，`fetch`不会自动为它们抛出任何错误。我们进行自己的检查，并在必要时抛出错误。我们在这里不捕获任何错误；调用代码应设置它需要的任何`catch`块。
- en: Convert the response to a JavaScript object
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 将响应转换为JavaScript对象
- en: 'If the response passes muster, we convert the JSON string the server has returned
    into a JavaScript object by calling the response’s `json` method. The `json` method
    returns a promise that resolves to our data object, and we return that promise
    from the function:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果响应通过检查，我们将服务器返回的JSON字符串转换为JavaScript对象，通过调用响应的`json`方法。`json`方法返回一个promise，它解析为我们的数据对象，然后我们从函数中返回这个promise：
- en: '[PRE23]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `getData` function does some preprocessing of the response from `fetch`,
    a little like a piece of middleware. Components that use `getData` won’t need
    to make these preprocessing checks and changes themselves. Let’s see how the `BookablesList`
    component can use our data-fetching function to load the bookables for display.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`getData`函数对`fetch`的响应进行了一些预处理，有点像中间件。使用`getData`的组件不需要自己进行这些预处理检查和更改。让我们看看`BookablesList`组件如何使用我们的数据获取函数来加载用于显示的bookables。'
- en: 4.3.4 Loading the bookables
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.4 加载bookables
- en: It’s time to reap the benefits of all those preparations. Listing 4.8 shows
    the latest `BookablesList` component file. The code imports our new `getData`
    function and uses it within a `useEffect` hook that runs once, when the component
    first mounts. It also includes the `isLoading` and `error` state values and some
    associated UI for when data is loading or there is an error message to display.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候享受所有这些准备带来的好处了。列表4.8显示了最新的`BookablesList`组件文件。代码导入了我们新的`getData`函数，并在组件首次挂载时运行的`useEffect`钩子中使用它。它还包括`isLoading`和`error`状态值以及一些相关的UI，用于数据加载或显示错误消息时。
- en: 'Branch: 0403-bookables-list, File: /src/components/Bookables/BookablesList.js'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0403-bookables-list，文件：/src/components/Bookables/BookablesList.js
- en: Listing 4.8 The `BookablesList` component loading its own data
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.8 `BookablesList`组件加载其自身的数据
- en: '[PRE24]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ No longer import bookables.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 不再导入bookables。
- en: ❷ Import the getData function.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 导入getData函数。
- en: ❸ Set bookables to an empty array.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将bookables设置为空数组。
- en: ❹ Add the new properties to the initial state.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将新属性添加到初始状态中。
- en: ❺ Destructure the new properties from state.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 从状态中解构新属性。
- en: ❻ Dispatch an action for the start of the data fetching.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 分发一个动作以开始数据获取。
- en: ❼ Fetch the data.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 获取数据。
- en: ❽ Save the loaded bookables in state.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 在状态中保存加载的预订项。
- en: ❾ Update state with any error.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 更新状态以包含任何错误。
- en: ❿ Return some simple error UI if there’s an error.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 如果有错误，返回一些简单的错误UI。
- en: ⓫ Return some simple loading UI while waiting for data.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 在等待数据时返回一些简单的加载UI。
- en: The call to `getData` is in the effect function. In section 4.3.3, we saw how
    `getData` returns a promise and can throw an error. So, in listing 4.8, we use
    both a `then` and a `catch` method, dispatching the appropriate actions, discussed
    in section 4.3.2, from each. Finally, we use `if` statements to return UI for
    loading and error conditions. If there’s no error and `isLoading` is `false`,
    we return our existing UI for the list of bookables and bookable details.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`getData`的调用在效果函数中。在第4.3.3节中，我们看到了`getData`如何返回一个promise并可以抛出错误。因此，在第4.8节中，我们使用了`then`和`catch`方法，从每个中分发适当的动作，这些动作在第4.3.2节中进行了讨论。最后，我们使用`if`语句来返回加载和错误条件下的UI。如果没有错误且`isLoading`为`false`，我们返回现有的可预订列表和可预订详情的UI。'
- en: Challenge 4.3
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战4.3
- en: Update the `UsersList` component to use the `getData` function and to manage
    loading and error states. Possible solution code is on the 0404-users-errors branch.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`UsersList`组件以使用`getData`函数并管理加载和错误状态。可能的解决方案代码位于0404-users-errors分支。
- en: 'We’ll return to data fetching in chapter 6, when we expand our roster of components
    in the bookings app. Before that, in the next chapter, we’ll investigate another
    way of managing state in components: the `useRef` hook.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第6章回到数据获取，当我们扩展预订应用中的组件列表时。在那之前，在下一章中，我们将研究在组件中管理状态的另一种方法：`useRef`钩子。
- en: Summary
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Sometimes our components reach outside the React data-flow process and directly
    interact with other APIs, most commonly in the browser. An action that impinges
    on the outside world in some way is called a *side effec*t.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时我们的组件会超出React数据流过程，直接与其他API交互，最常见的是在浏览器中。以某种方式影响外部世界的动作被称为*副作用*。
- en: Common side effects include setting the page title imperatively, working with
    timers like `setInterval` or `setTimeout`, measuring the width or height or position
    of elements in the DOM, logging messages to the console, setting or getting values
    in local storage, and fetching data or subscribing and unsubscribing to services.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的副作用包括强制设置页面标题、使用定时器如`setInterval`或`setTimeout`、测量DOM中元素的宽度或高度或位置、将消息记录到控制台、在本地存储中设置或获取值、获取数据或订阅和取消订阅服务。
- en: 'Wrap side effects inside an effect function as the first argument to the `useEffect`
    hook:'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将副作用放在效果函数内部，作为`useEffect`钩子的第一个参数：
- en: '[PRE25]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: React runs the effect function after every render.
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: React在每次渲染后都会运行效果函数。
- en: To manage when an effect function runs, pass a dependencies array as the second
    argument to the `useEffect` hook.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要管理效果函数何时运行，将依赖项数组作为`useEffect`钩子的第二个参数传递。
- en: 'Pass an empty dependencies array to make React run the effect function once,
    when the component mounts:'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递一个空的依赖项数组，使React在组件挂载时运行一次效果函数：
- en: '[PRE26]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Include all of the effect function’s dependencies in the dependencies array
    to make React run the effect function whenever the values of the specified dependencies
    change:'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在依赖数组中包含效果函数的所有依赖项，以便React在指定依赖项的值发生变化时运行效果函数：
- en: '[PRE27]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Return a cleanup function from the effect that React will run before rerunning
    the effect function and when the component unmounts:'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从效果中返回一个清理函数，React将在重新运行效果函数之前以及组件卸载时运行此函数：
- en: '[PRE28]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Fetch data from within an effect if you’re using the fetch-on-render approach.
    React will render the component and then fire the data-fetching code. It will
    re-render the component when the data arrives:'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您使用的是渲染时获取数据的方法，请在效果内部获取数据。React将渲染组件，然后触发数据获取代码。当数据到达时，它将重新渲染组件：
- en: '[PRE29]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To avoid race conditions and to follow the convention of returning nothing
    or a cleanup function from the effect function, put `async` functions inside the
    effect function. You can call them immediately, as necessary:'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了避免竞争条件和遵循从效果函数返回空或清理函数的约定，将`async`函数放在效果函数内部。根据需要，您可以立即调用它们：
- en: '[PRE30]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Put separate side effects into separate calls to `useEffect`. It will be easier
    to understand what each effect does, easier to control when the effects run by
    using separate dependencies lists, and easier to extract the effects into custom
    hooks.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将单独的副作用放入单独的 `useEffect` 调用中。这样会更易于理解每个副作用的作用，更易于通过使用单独的依赖项列表来控制副作用何时运行，并且更易于将副作用提取到自定义钩子中。
- en: If, on re-render, multiple effects are going to run, React will call all of
    the cleanup functions for the rerunning effects before it runs any effects themselves.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在重新渲染时，多个副作用将要运行，React 将在运行任何自身效果之前，调用所有正在重新运行的效果的清理函数。
