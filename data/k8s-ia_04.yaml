- en: 'Chapter 3\. Pods: running containers in Kubernetes'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章\. Pods：在Kubernetes中运行容器
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Creating, running, and stopping pods
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建、运行和停止Pod
- en: Organizing pods and other resources with labels
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标签组织Pod和其他资源
- en: Performing an operation on all pods with a specific label
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对具有特定标签的所有Pod执行操作
- en: Using namespaces to split pods into non-overlapping groups
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命名空间将Pod分成非重叠组
- en: Scheduling pods onto specific types of worker nodes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Pod调度到特定类型的Worker节点上
- en: The previous chapter should have given you a rough picture of the basic components
    you create in Kubernetes and at least an outline of what they do. Now, we’ll start
    reviewing all types of Kubernetes objects (or resources) in greater detail, so
    you’ll understand when, how, and why to use each of them. We’ll start with pods,
    because they’re the central, most important, concept in Kubernetes. Everything
    else either manages, exposes, or is used by pods.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章应该已经为您提供了一个关于在Kubernetes中创建的基本组件的大致轮廓以及它们至少的概述。现在，我们将更详细地回顾所有类型的Kubernetes对象（或资源），以便您了解何时、如何以及为什么使用它们。我们将从Pod开始，因为它们是Kubernetes中中心、最重要的概念。其他所有内容要么管理、公开，要么被Pod使用。
- en: 3.1\. Introducing pods
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 3.1\. Pod简介
- en: You’ve already learned that a pod is a co-located group of containers and represents
    the basic building block in Kubernetes. Instead of deploying containers individually,
    you always deploy and operate on a pod of containers. We’re not implying that
    a pod always includes more than one container—it’s common for pods to contain
    only a single container. The key thing about pods is that when a pod does contain
    multiple containers, all of them are always run on a single worker node—it never
    spans multiple worker nodes, as shown in [figure 3.1](#filepos273245).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经了解到Pod是一组位于同一位置的容器，并且代表Kubernetes中的基本构建块。您不是单独部署容器，而是始终部署和操作容器Pod。我们并不是暗示Pod总是包含多个容器——Pod只包含单个容器是很常见的。关于Pod的关键点是，当Pod确实包含多个容器时，所有这些容器都总是在单个Worker节点上运行——它永远不会跨越多个Worker节点，如图3.1所示。
- en: Figure 3.1\. All containers of a pod run on the same node. A pod never spans
    two nodes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1\. Pod中的所有容器都在同一个节点上运行。Pod永远不会跨越两个节点。
- en: '![](images/00186.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00186.jpg)'
- en: 3.1.1\. Understanding why we need pods
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 3.1.1\. 理解为什么我们需要Pod
- en: But why do we even need pods? Why can’t we use containers directly? Why would
    we even need to run multiple containers together? Can’t we put all our processes
    into a single container? We’ll answer those questions now.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么我们甚至需要Pod？为什么我们不能直接使用容器？为什么我们甚至需要一起运行多个容器？我们不能把所有进程都放入一个容器中吗？我们现在就来回答这些问题。
- en: Understanding why multiple containers are better than one contain- ner running
    multiple processes
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 理解为什么多个容器比一个容器运行多个进程更好
- en: Imagine an app consisting of multiple processes that either communicate through
    IPC (Inter-Process Communication) or through locally stored files, which requires
    them to run on the same machine. Because in Kubernetes you always run processes
    in containers and each container is much like an isolated machine, you may think
    it makes sense to run multiple processes in a single container, but you shouldn’t
    do that.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个由多个进程组成的app，这些进程要么通过IPC（进程间通信）通信，要么通过本地存储的文件通信，这要求它们在同一台机器上运行。因为在Kubernetes中，您总是运行容器中的进程，每个容器都类似于一个隔离的机器，您可能会认为在单个容器中运行多个进程是有意义的，但您不应该这样做。
- en: Containers are designed to run only a single process per container (unless the
    process itself spawns child processes). If you run multiple unrelated processes
    in a single container, it is your responsibility to keep all those processes running,
    manage their logs, and so on. For example, you’d have to include a mechanism for
    automatically restarting individual processes if they crash. Also, all those processes
    would log to the same standard output, so you’d have a hard time figuring out
    what process logged what.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 容器被设计为每个容器只运行一个进程（除非进程本身产生子进程）。如果您在单个容器中运行多个不相关的进程，那么您有责任保持所有这些进程的运行，管理它们的日志等。例如，如果您必须包括一个机制来自动重启崩溃的个别进程。此外，所有这些进程都会记录到相同的标准输出，因此您很难弄清楚哪个进程记录了什么。
- en: Therefore, you need to run each process in its own container. That’s how Docker
    and Kubernetes are meant to be used.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您需要为每个进程运行其自己的容器。这就是Docker和Kubernetes被设计成使用的样子。
- en: 3.1.2\. Understanding pods
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 3.1.2\. 理解Pod
- en: Because you’re not supposed to group multiple processes into a single container,
    it’s obvious you need another higher-level construct that will allow you to bind
    containers together and manage them as a single unit. This is the reasoning behind
    pods.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你不应该将多个进程组合到一个容器中，显然你需要另一个更高级的结构，这样你就可以将容器绑定在一起，并将它们作为一个单一单元来管理。这就是 pod 的推理依据。
- en: A pod of containers allows you to run closely related processes together and
    provide them with (almost) the same environment as if they were all running in
    a single container, while keeping them somewhat isolated. This way, you get the
    best of both worlds. You can take advantage of all the features containers provide,
    while at the same time giving the processes the illusion of running together.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 容器 pod 允许你将紧密相关的进程一起运行，并为它们提供（几乎）与它们都在单个容器中运行时相同的环境，同时保持它们在一定程度上隔离。这样，你就可以兼得两者之利。你可以利用容器提供的所有功能，同时同时给进程一种它们在一起运行的错觉。
- en: Understanding the partial isolation between containers of the same pod
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 理解同一 pod 中容器之间的部分隔离
- en: In the previous chapter, you learned that containers are completely isolated
    from each other, but now you see that you want to isolate groups of containers
    instead of individual ones. You want containers inside each group to share certain
    resources, although not all, so that they’re not fully isolated. Kubernetes achieves
    this by configuring Docker to have all containers of a pod share the same set
    of Linux namespaces instead of each container having its own set.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你了解到容器是完全相互隔离的，但现在你看到你想要隔离容器组而不是单个容器。你希望组内的容器共享某些资源，尽管不是全部，这样它们就不会完全隔离。Kubernetes
    通过配置 Docker，让 pod 中的所有容器共享同一组 Linux 命名空间来实现这一点，而不是每个容器都有自己的命名空间集。
- en: Because all containers of a pod run under the same Network and UTS namespaces
    (we’re talking about Linux namespaces here), they all share the same hostname
    and network interfaces. Similarly, all containers of a pod run under the same
    IPC namespace and can communicate through IPC. In the latest Kubernetes and Docker
    versions, they can also share the same PID namespace, but that feature isn’t enabled
    by default.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因为一个 pod 中的所有容器都在相同的网络和 UTS 命名空间下运行（这里我们谈论的是 Linux 命名空间），它们都共享相同的主机名和网络接口。同样，一个
    pod 中的所有容器都在相同的 IPC 命名空间下运行，并且可以通过 IPC 进行通信。在最新的 Kubernetes 和 Docker 版本中，它们还可以共享相同的
    PID 命名空间，但这个功能默认是未启用的。
- en: '|  |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When containers of the same pod use separate PID namespaces, you only see the
    container’s own processes when running `ps aux` in the container.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当同一 pod 中的容器使用单独的 PID 命名空间时，你在容器中运行 `ps aux` 命令时只能看到容器的自身进程。
- en: '|  |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: But when it comes to the filesystem, things are a little different. Because
    most of the container’s filesystem comes from the container image, by default,
    the filesystem of each container is fully isolated from other containers. However,
    it’s possible to have them share file directories using a Kubernetes concept called
    a Volume, which we’ll talk about in [chapter 6](index_split_055.html#filepos588298).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当涉及到文件系统时，情况就有些不同了。因为大多数容器的文件系统来自容器镜像，默认情况下，每个容器的文件系统与其他容器完全隔离。然而，可以使用 Kubernetes
    的一个概念——Volume，让它们共享文件目录，我们将在第 6 章（[index_split_055.html#filepos588298]）中讨论。
- en: Understanding how containers share the same IP and port space
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 理解容器如何共享相同的 IP 和端口空间
- en: One thing to stress here is that because containers in a pod run in the same
    Network namespace, they share the same IP address and port space. This means processes
    running in containers of the same pod need to take care not to bind to the same
    port numbers or they’ll run into port conflicts. But this only concerns containers
    in the same pod. Containers of different pods can never run into port conflicts,
    because each pod has a separate port space. All the containers in a pod also have
    the same loopback network interface, so a container can communicate with other
    containers in the same pod through localhost.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要强调的一点是，因为 pod 中的容器运行在相同的网络命名空间中，它们共享相同的 IP 地址和端口空间。这意味着在相同 pod 的容器中运行的过程需要注意不要绑定到相同的端口，否则会遇到端口冲突。但这只涉及同一
    pod 中的容器。不同 pod 的容器永远不会遇到端口冲突，因为每个 pod 都有独立的端口空间。pod 中的所有容器也具有相同的回环网络接口，因此一个容器可以通过
    localhost 与同一 pod 中的其他容器通信。
- en: Introducing the flat inter-pod network
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍扁平的 pod 间网络
- en: All pods in a Kubernetes cluster reside in a single flat, shared, network-address
    space (shown in [figure 3.2](#filepos279224)), which means every pod can access
    every other pod at the other pod’s IP address. No NAT (Network Address Translation)
    gateways exist between them. When two pods send network packets between each other,
    they’ll each see the actual IP address of the other as the source IP in the packet.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes集群中的所有Pod都位于一个单一的、共享的、网络地址空间中（如图3.2所示[figure 3.2](#filepos279224)），这意味着每个Pod都可以通过其他Pod的IP地址访问其他Pod。它们之间不存在NAT（网络地址转换）网关。当两个Pod之间发送网络数据包时，它们各自都会看到对方实际的IP地址作为数据包中的源IP。
- en: Figure 3.2\. Each pod gets a routable IP address and all other pods see the
    pod under that IP address.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2\. 每个Pod都分配一个可路由的IP地址，所有其他Pod都能看到该IP地址下的Pod。
- en: '![](images/00007.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](images/00007.jpg)'
- en: Consequently, communication between pods is always simple. It doesn’t matter
    if two pods are scheduled onto a single or onto different worker nodes; in both
    cases the containers inside those pods can communicate with each other across
    the flat NAT-less network, much like computers on a local area network (LAN),
    regardless of the actual inter-node network topology. Like a computer on a LAN,
    each pod gets its own IP address and is accessible from all other pods through
    this network established specifically for pods. This is usually achieved through
    an additional software-defined network layered on top of the actual network.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Pod之间的通信总是简单的。无论两个Pod是否被调度到同一个或不同的工作节点上，在这两种情况下，Pod内部的容器都可以通过扁平的、无NAT的网络相互通信，就像局域网（LAN）中的计算机一样，无论实际的节点间网络拓扑结构如何。就像局域网中的计算机一样，每个Pod都有自己的IP地址，并且可以通过为Pod专门建立的这一网络从所有其他Pod访问。这通常是通过在真实网络之上添加一个额外的软件定义网络来实现的。
- en: 'To sum up what’s been covered in this section: pods are logical hosts and behave
    much like physical hosts or VMs in the non-container world. Processes running
    in the same pod are like processes running on the same physical or virtual machine,
    except that each process is encapsulated in a container.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 总结本节所涵盖的内容：Pod是逻辑主机，在非容器世界中表现得就像物理主机或虚拟机。在同一Pod中运行的进程就像在同一个物理或虚拟机上运行的进程一样，只是每个进程都被封装在一个容器中。
- en: 3.1.3\. Organizing containers across pods properly
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 3.1.3\. 正确组织Pod间的容器
- en: You should think of pods as separate machines, but where each one hosts only
    a certain app. Unlike the old days, when we used to cram all sorts of apps onto
    the same host, we don’t do that with pods. Because pods are relatively lightweight,
    you can have as many as you need without incurring almost any overhead. Instead
    of stuffing everything into a single pod, you should organize apps into multiple
    pods, where each one contains only tightly related components or processes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该将Pod视为独立的机器，但每个机器只托管特定的应用程序。与过去我们经常将各种应用程序挤在同一台主机上的做法不同，我们不会这样做Pod。因为Pod相对较轻量级，你可以拥有你需要的任意多个，而几乎不会产生任何开销。而不是将所有内容都塞入一个Pod中，你应该将应用程序组织到多个Pod中，其中每个Pod只包含紧密相关的组件或进程。
- en: Having said that, do you think a multi-tier application consisting of a frontend
    application server and a backend database should be configured as a single pod
    or as two pods?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，你认为一个由前端应用服务器和后端数据库组成的多层应用程序应该配置为一个Pod还是两个Pod？
- en: Splitting multi-tier apps into multiple pods
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 将多层应用程序拆分为多个Pod
- en: Although nothing is stopping you from running both the frontend server and the
    database in a single pod with two containers, it isn’t the most appropriate way.
    We’ve said that all containers of the same pod always run co-located, but do the
    web server and the database really need to run on the same machine? The answer
    is obviously no, so you don’t want to put them into a single pod. But is it wrong
    to do so regardless? In a way, it is.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有阻止你在单个Pod中使用两个容器同时运行前端服务器和数据库，但这并不是最合适的方式。我们说过，同一个Pod中的所有容器总是运行在同一个位置，但网页服务器和数据库真的需要运行在同一台机器上吗？答案显然是否定的，所以你不希望将它们放入同一个Pod中。但这样做是否错误呢？从某种意义上说，是的。
- en: If both the frontend and backend are in the same pod, then both will always
    be run on the same machine. If you have a two-node Kubernetes cluster and only
    this single pod, you’ll only be using a single worker node and not taking advantage
    of the computational resources (CPU and memory) you have at your disposal on the
    second node. Splitting the pod into two would allow Kubernetes to schedule the
    frontend to one node and the backend to the other node, thereby improving the
    utilization of your infrastructure.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前端和后端都在同一个 Pod 中，那么它们将始终在同一个机器上运行。如果你有一个两节点 Kubernetes 集群，并且只有一个这个单独的 Pod，那么你将只使用一个工作节点，而不会利用你在第二个节点上可用的计算资源（CPU
    和内存）。将 Pod 拆分为两个将允许 Kubernetes 将前端调度到一个节点，而后端调度到另一个节点，从而提高你的基础设施利用率。
- en: Splitting into multiple pods to enable individual scaling
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 将其拆分为多个 Pod 以实现单独扩展
- en: Another reason why you shouldn’t put them both into a single pod is scaling.
    A pod is also the basic unit of scaling. Kubernetes can’t horizontally scale individual
    containers; instead, it scales whole pods. If your pod consists of a frontend
    and a backend container, when you scale up the number of instances of the pod
    to, let’s say, two, you end up with two frontend containers and two backend containers.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 不应该将它们都放入同一个 Pod 的另一个原因是扩展。Pod 也是扩展的基本单位。Kubernetes 无法水平扩展单个容器；相反，它扩展整个 Pod。如果你的
    Pod 由前端和后端容器组成，当你将 Pod 实例的数量扩展到，比如说两个时，你最终会得到两个前端容器和两个后端容器。
- en: Usually, frontend components have completely different scaling requirements
    than the backends, so we tend to scale them individually. Not to mention the fact
    that backends such as databases are usually much harder to scale compared to (stateless)
    frontend web servers. If you need to scale a container individually, this is a
    clear indication that it needs to be deployed in a separate pod.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，前端组件的扩展需求与后端完全不同，所以我们倾向于单独扩展它们。更不用说后端（如数据库）通常比（无状态的）前端 Web 服务器更难扩展。如果你需要单独扩展容器，这清楚地表明它需要部署在单独的
    Pod 中。
- en: Understanding when to use multiple containers in a pod
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 理解何时在 Pod 中使用多个容器
- en: The main reason to put multiple containers into a single pod is when the application
    consists of one main process and one or more complementary processes, as shown
    in [figure 3.3](#filepos283783).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 将多个容器放入单个 Pod 的主要原因是当应用程序由一个主进程和一个或多个补充进程组成时，如图 3.3 所示。
- en: Figure 3.3\. Pods should contain tightly coupled containers, usually a main
    container and containers that support the main one.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3\. Pod 应该包含紧密耦合的容器，通常是一个主容器和支撑主容器的容器。
- en: '![](images/00024.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00024.jpg)'
- en: For example, the main container in a pod could be a web server that serves files
    from a certain file directory, while an additional container (a sidecar container)
    periodically downloads content from an external source and stores it in the web
    server’s directory. In [chapter 6](index_split_055.html#filepos588298) you’ll
    see that you need to use a Kubernetes Volume that you mount into both containers.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Pod 中的主容器可能是一个从特定文件目录提供文件的 Web 服务器，而一个附加容器（边车容器）会定期从外部源下载内容并将其存储在 Web 服务器的目录中。在[第
    6 章](index_split_055.html#filepos588298)中，你会看到你需要使用一个 Kubernetes 卷，并将其挂载到两个容器中。
- en: Other examples of sidecar containers include log rotators and collectors, data
    processors, communication adapters, and others.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 边车容器的其他例子包括日志轮换器和收集器、数据处理程序、通信适配器等。
- en: Deciding when to use multiple containers in a pod
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 决定何时在 Pod 中使用多个容器
- en: 'To recap how containers should be grouped into pods—when deciding whether to
    put two containers into a single pod or into two separate pods, you always need
    to ask yourself the following questions:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回顾容器应该如何分组到 Pod 中——在决定是否将两个容器放入同一个 Pod 还是两个独立的 Pod 中时，你总是需要问自己以下问题：
- en: Do they need to be run together or can they run on different hosts?
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是否需要一起运行，或者是否可以在不同的主机上运行？
- en: Do they represent a single whole or are they independent components?
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是否代表一个整体或独立的组件？
- en: Must they be scaled together or individually?
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是否需要一起扩展或单独扩展？
- en: Basically, you should always gravitate toward running containers in separate
    pods, unless a specific reason requires them to be part of the same pod. [Figure
    3.4](#filepos285614) will help you memorize this.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，你应该始终倾向于在单独的 Pod 中运行容器，除非有特定的原因要求它们成为同一个 Pod 的一部分。[图 3.4](#filepos285614)
    将帮助你记住这一点。
- en: Figure 3.4\. A container shouldn’t run multiple processes. A pod shouldn’t contain
    multiple containers if they don’t need to run on the same machine.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4\. 容器不应该运行多个进程。如果不需要在同一个机器上运行，pod 不应包含多个容器。
- en: '![](images/00045.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](images/00045.jpg)'
- en: Although pods can contain multiple containers, to keep things simple for now,
    you’ll only be dealing with single-container pods in this chapter. You’ll see
    how multiple containers are used in the same pod later, in [chapter 6](index_split_055.html#filepos588298).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 pods 可以包含多个容器，但为了保持简单，你将在本章中只处理单容器 pod。你将在第 6 章（index_split_055.html#filepos588298）中看到如何在同一个
    pod 中使用多个容器。
- en: 3.2\. Creating pods from YAML or JSON descriptors
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 3.2\. 从 YAML 或 JSON 描述符创建 pod
- en: Pods and other Kubernetes resources are usually created by posting a JSON or
    YAML manifest to the Kubernetes REST API endpoint. Also, you can use other, simpler
    ways of creating resources, such as the `kubectl run` command you used in the
    previous chapter, but they usually only allow you to configure a limited set of
    properties, not all. Additionally, defining all your Kubernetes objects from YAML
    files makes it possible to store them in a version control system, with all the
    benefits it brings.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Pods 和其他 Kubernetes 资源通常是通过向 Kubernetes REST API 端点发送 JSON 或 YAML 清单来创建的。此外，你也可以使用其他更简单的方式来创建资源，例如你在上一章中使用的
    `kubectl run` 命令，但它们通常只允许你配置一组有限的属性，而不是全部。此外，将所有 Kubernetes 对象定义在 YAML 文件中，使得可以将它们存储在版本控制系统（VCS）中，从而带来所有这些好处。
- en: To configure all aspects of each type of resource, you’ll need to know and understand
    the Kubernetes API object definitions. You’ll get to know most of them as you
    learn about each resource type throughout this book. We won’t explain every single
    property, so you should also refer to the Kubernetes API reference documentation
    at [http://kubernetes.io/docs/reference/](http://kubernetes.io/docs/reference/)
    when creating objects.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置每种类型资源的所有方面，你需要了解和理解 Kubernetes API 对象定义。随着你在本书中学习每种资源类型，你将了解其中大部分。我们不会解释每个属性，因此当创建对象时，你也应参考
    Kubernetes API 参考文档 [http://kubernetes.io/docs/reference/](http://kubernetes.io/docs/reference/)。
- en: 3.2.1\. Examining a YAML descriptor of an existing pod
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 3.2.1\. 检查现有 pod 的 YAML 描述符
- en: You already have some existing pods you created in the previous chapter, so
    let’s look at what a YAML definition for one of those pods looks like. You’ll
    use the `kubectl get` command with the `-o yaml` option to get the whole YAML
    definition of the pod, as shown in the following listing.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在上一章创建了一些现有的 pod，所以让我们看看其中一个 pod 的 YAML 定义是什么样的。你可以使用带有 `-o yaml` 选项的 `kubectl
    get` 命令来获取 pod 的完整 YAML 定义，如下所示。
- en: Listing 3.1\. Full YAML of a deployed pod
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.1\. 已部署 pod 的完整 YAML
- en: '`$ kubectl get po kubia-zxzij -o yaml` `apiVersion: v1` `1` `kind: Pod` `2`
    `metadata:` `3` `annotations:` `3` `kubernetes.io/created-by: ...` `3` `creationTimestamp:
    2016-03-18T12:37:50Z` `3` `generateName: kubia-` `3` `labels:` `3` `run: kubia`
    `3` `name: kubia-zxzij` `3` `namespace: default` `3` `resourceVersion: "294"`
    `3` `selfLink: /api/v1/namespaces/default/pods/kubia-zxzij` `3` `uid: 3a564dc0-ed06-11e5-ba3b-42010af00004`
    `3` `spec:` `4` `containers:` `4` `- image: luksa/kubia` `4` `imagePullPolicy:
    IfNotPresent` `4` `name: kubia` `4` `ports:` `4` `- containerPort: 8080` `4` `protocol:
    TCP` `4` `resources:` `4` `requests:` `4` `cpu: 100m` `4` `terminationMessagePath:
    /dev/termination-log` `4` `volumeMounts:` `4` `- mountPath: /var/run/secrets/k8s.io/servacc`
    `4` `name: default-token-kvcqa` `4` `readOnly: true` `4` `dnsPolicy: ClusterFirst`
    `4` `nodeName: gke-kubia-e8fe08b8-node-txje` `4` `restartPolicy: Always` `4` `serviceAccount:
    default` `4` `serviceAccountName: default` `4` `terminationGracePeriodSeconds:
    30` `4` `volumes:` `4` `- name: default-token-kvcqa` `4` `secret:` `4` `secretName:
    default-token-kvcqa` `4` `status:` `5` `conditions:` `5` `- lastProbeTime: null`
    `5` `lastTransitionTime: null` `5` `status: "True"` `5` `type: Ready` `5` `containerStatuses:`
    `5` `- containerID: docker://f0276994322d247ba...` `5` `image: luksa/kubia` `5`
    `imageID: docker://4c325bcc6b40c110226b89fe...` `5` `lastState: {}` `5` `name:
    kubia` `5` `ready: true` `5` `restartCount: 0` `5` `state:` `5` `running:` `5`
    `startedAt: 2016-03-18T12:46:05Z` `5` `hostIP: 10.132.0.4` `5` `phase: Running`
    `5` `podIP: 10.0.2.3` `5` `startTime: 2016-03-18T12:44:32Z` `5`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get po kubia-zxzij -o yaml` `apiVersion: v1` `1` `kind: Pod` `2`
    `metadata:` `3` `annotations:` `3` `kubernetes.io/created-by: ...` `3` `creationTimestamp:
    2016-03-18T12:37:50Z` `3` `generateName: kubia-` `3` `labels:` `3` `run: kubia`
    `3` `name: kubia-zxzij` `3` `namespace: default` `3` `resourceVersion: "294"`
    `3` `selfLink: /api/v1/namespaces/default/pods/kubia-zxzij` `3` `uid: 3a564dc0-ed06-11e5-ba3b-42010af00004`
    `3` `spec:` `4` `containers:` `4` `- image: luksa/kubia` `4` `imagePullPolicy:
    IfNotPresent` `4` `name: kubia` `4` `ports:` `4` `- containerPort: 8080` `4` `protocol:
    TCP` `4` `resources:` `4` `requests:` `4` `cpu: 100m` `4` `terminationMessagePath:
    /dev/termination-log` `4` `volumeMounts:` `4` `- mountPath: /var/run/secrets/k8s.io/servacc`
    `4` `name: default-token-kvcqa` `4` `readOnly: true` `4` `dnsPolicy: ClusterFirst`
    `4` `nodeName: gke-kubia-e8fe08b8-node-txje` `4` `restartPolicy: Always` `4` `serviceAccount:
    default` `4` `serviceAccountName: default` `4` `terminationGracePeriodSeconds:
    30` `4` `volumes:` `4` `- name: default-token-kvcqa` `4` `secret:` `4` `secretName:
    default-token-kvcqa` `4` `status:` `5` `conditions:` `5` `- lastProbeTime: null`
    `5` `lastTransitionTime: null` `5` `status: "True"` `5` `type: Ready` `5` `containerStatuses:`
    `5` `- containerID: docker://f0276994322d247ba...` `5` `image: luksa/kubia` `5`
    `imageID: docker://4c325bcc6b40c110226b89fe...` `5` `lastState: {}` `5` `name:
    kubia` `5` `ready: true` `5` `restartCount: 0` `5` `state:` `5` `running:` `5`
    `startedAt: 2016-03-18T12:46:05Z` `5` `hostIP: 10.132.0.4` `5` `phase: Running`
    `5` `podIP: 10.0.2.3` `5` `startTime: 2016-03-18T12:44:32Z` `5`'
- en: 1 Kubernetes API version used in this YAML descriptor
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 在此YAML描述符中使用的Kubernetes API版本
- en: 2 Type of Kubernetes object/resource
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 Kubernetes对象/资源的类型
- en: 3 Pod metadata (name, labels, annotations, and so on)
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 Pod元数据（名称、标签、注解等）
- en: 4 Pod specification/contents (list of pod’s containers, volumes, and so on)
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 Pod规范/内容（Pod的容器、卷等的列表）
- en: 5 Detailed status of the pod and its containers
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5 Pod及其容器的详细状态
- en: I know this looks complicated, but it becomes simple once you understand the
    basics and know how to distinguish between the important parts and the minor details.
    Also, you can take comfort in the fact that when creating a new pod, the YAML
    you need to write is much shorter, as you’ll see later.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这看起来很复杂，但一旦你了解了基础知识并且知道如何区分重要部分和细节，它就会变得简单。此外，你可以放心，当你创建一个新的Pod时，你需要编写的YAML文件会短得多，就像你稍后将会看到的那样。
- en: Introducing the main parts of a pod definition
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍Pod定义的主要部分
- en: 'The pod definition consists of a few parts. First, there’s the Kubernetes API
    version used in the YAML and the type of resource the YAML is describing. Then,
    three important sections are found in almost all Kubernetes resources:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Pod定义由几个部分组成。首先，是YAML中使用的Kubernetes API版本以及YAML描述的资源类型。然后，在几乎所有的Kubernetes资源中都可以找到三个重要的部分：
- en: Metadata includes the name, namespace, labels, and other information about the
    pod.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元数据包括名称、命名空间、标签以及其他关于Pod的信息。
- en: Spec contains the actual description of the pod’s contents, such as the pod’s
    containers, volumes, and other data.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spec包含Pod内容的实际描述，例如Pod的容器、卷和其他数据。
- en: Status contains the current information about the running pod, such as what
    condition the pod is in, the description and status of each container, and the
    pod’s internal IP and other basic info.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态包含关于运行Pod的当前信息，例如Pod的状态、每个容器的描述和状态，以及Pod的内部IP和其他基本信息。
- en: '[Listing 3.1](#filepos287828) showed a full description of a running pod, including
    its status. The `status` part contains read-only runtime data that shows the state
    of the resource at a given moment. When creating a new pod, you never need to
    provide the `status` part.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3.1](#filepos287828) 展示了一个正在运行的 pod 的完整描述，包括其状态。`status` 部分包含只读的运行时数据，显示了资源在某一时刻的状态。在创建新的
    pod 时，您永远不需要提供 `status` 部分。'
- en: The three parts described previously show the typical structure of a Kubernetes
    API object. As you’ll see throughout the book, all other objects have the same
    anatomy. This makes understanding new objects relatively easy.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 之前描述的三个部分展示了 Kubernetes API 对象的典型结构。正如您将在本书的其余部分看到的那样，所有其他对象都具有相同的结构。这使得理解新对象相对容易。
- en: Going through all the individual properties in the previous YAML doesn’t make
    much sense, so, instead, let’s see what the most basic YAML for creating a pod
    looks like.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的 YAML 中逐个检查所有单个属性没有太多意义，所以，让我们看看创建 pod 的最基本 YAML 看起来是什么样子。
- en: 3.2.2\. Creating a simple YAML descriptor for a pod
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 3.2.2\. 创建一个简单的 YAML 描述符用于 pod
- en: You’re going to create a file called kubia-manual.yaml (you can create it in
    any directory you want), or download the book’s code archive, where you’ll find
    the file inside the Chapter03 directory. The following listing shows the entire
    contents of the file.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您将创建一个名为 kubia-manual.yaml 的文件（您可以在任何目录中创建它），或者下载本书的代码存档，您将在 Chapter03 目录中找到该文件。以下列表显示了文件的全部内容。
- en: 'Listing 3.2\. A basic pod manifest: kubia-manual.yaml'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.2\. 基本 pod 清单：kubia-manual.yaml
- en: '`apiVersion: v1` `1` `kind: Pod` `2` `metadata:   name: kubia-manual` `3` `spec:
      containers:   - image: luksa/kubia` `4` `name: kubia` `5` `ports:     - containerPort:
    8080` `6` `protocol: TCP`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiVersion: v1` `1` `kind: Pod` `2` `metadata:   name: kubia-manual` `3` `spec:
      containers:   - image: luksa/kubia` `4` `name: kubia` `5` `ports:     - containerPort:
    8080` `6` `protocol: TCP`'
- en: 1 Descriptor conforms to version v1 of Kubernetes API
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 描述符符合 Kubernetes API 的 v1 版本
- en: 2 You’re describing a pod.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 您正在描述一个 pod。
- en: 3 The name of the pod
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 pod 的名称
- en: 4 Container image to create the container from
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 从容器创建的容器镜像
- en: 5 Name of the container
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5 容器的名称
- en: 6 The port the app is listening on
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 6 应用程序监听的端口
- en: I’m sure you’ll agree this is much simpler than the definition in [listing 3.1](#filepos287828).
    Let’s examine this descriptor in detail. It conforms to the `v1` version of the
    Kubernetes API. The type of resource you’re describing is a `pod`, with the name
    `kubia-manual`. The pod consists of a single container based on the `luksa/kubia`
    image. You’ve also given a name to the container and indicated that it’s listening
    on port `8080`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信您会同意这比 [列表 3.1](#filepos287828) 中的定义要简单得多。让我们详细检查这个描述符。它符合 Kubernetes API
    的 `v1` 版本。您所描述的资源类型是 `pod`，名称为 `kubia-manual`。该 pod 由基于 `luksa/kubia` 镜像的单个容器组成。您还为容器命名，并指明它正在监听端口
    `8080`。
- en: Specifying container ports
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 指定容器端口
- en: Specifying ports in the pod definition is purely informational. Omitting them
    has no effect on whether clients can connect to the pod through the port or not.
    If the container is accepting connections through a port bound to the 0.0.0.0
    address, other pods can always connect to it, even if the port isn’t listed in
    the pod spec explicitly. But it makes sense to define the ports explicitly so
    that everyone using your cluster can quickly see what ports each pod exposes.
    Explicitly defining ports also allows you to assign a name to each port, which
    can come in handy, as you’ll see later in the book.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在 pod 定义中指定端口纯粹是信息性的。省略它们不会影响客户端是否可以通过端口连接到 pod。如果容器通过绑定到 0.0.0.0 地址的端口接受连接，其他
    pod 总是能够连接到它，即使该端口没有在 pod 规范中明确列出。但是，明确定义端口是有意义的，这样每个人都可以快速看到每个 pod 公开的端口。明确定义端口还允许您为每个端口分配一个名称，这在本书后面的内容中会很有用。
- en: '|  |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Using kubectl explain to discover possible API object fields
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 kubectl explain 来发现可能的 API 对象字段
- en: When preparing a manifest, you can either turn to the Kubernetes reference documentation
    at [http://kubernetes.io/docs/api](http://kubernetes.io/docs/api) to see which
    attributes are supported by each API object, or you can use the `kubectl explain`
    command.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在准备清单时，您可以选择查阅 Kubernetes 参考文档 [http://kubernetes.io/docs/api](http://kubernetes.io/docs/api)，以查看每个
    API 对象支持哪些属性，或者您可以使用 `kubectl explain` 命令。
- en: 'For example, when creating a pod manifest from scratch, you can start by asking
    `kubectl` to explain pods:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当从头开始创建 pod 清单时，您可以首先让 `kubectl` 解释 pods：
- en: '`$ kubectl explain pods` `DESCRIPTION: Pod is a collection of containers that
    can run on a host. This resource              is created by clients and scheduled
    onto hosts. FIELDS:    kind      <string>      Kind is a string value representing
    the REST resource this object      represents...    metadata  <Object>      Standard
    object''s metadata...    spec      <Object>      Specification of the desired
    behavior of the pod...    status    <Object>      Most recently observed status
    of the pod. This data may not be up to      date...`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl explain pods` `描述：Pod是一组可以在主机上运行的容器。该资源由客户端创建并调度到主机上。    字段：    kind     
    <字符串>    类型是一个字符串值，表示此对象表示的REST资源...    metadata  <对象>    标准对象元数据...    spec     
    <对象>    pod的期望行为规范...    status    <对象>    pod最近观察到的状态。这些数据可能不是最新的...`'
- en: 'Kubectl prints out the explanation of the object and lists the attributes the
    object can contain. You can then drill deeper to find out more about each attribute.
    For example, you can examine the `spec` attribute like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Kubectl打印出对象的说明并列出对象可以包含的属性。然后你可以深入了解以了解更多关于每个属性的信息。例如，你可以像这样检查`spec`属性：
- en: '`$ kubectl explain pod.spec` `RESOURCE: spec <Object>  DESCRIPTION:     Specification
    of the desired behavior of the pod...     podSpec is a description of a pod.  FIELDS:
       hostPID   <boolean>      Use the host''s pid namespace. Optional: Default to
    false.    ...     volumes   <[]Object>      List of volumes that can be mounted
    by containers belonging to the      pod.     Containers  <[]Object> -required-
         List of containers belonging to the pod. Containers cannot currently     
    Be added or removed. There must be at least one container in a pod.      Cannot
    be updated. More info:      http://releases.k8s.io/release-1.4/docs/user-guide/containers.md`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl explain pod.spec` `资源：spec <对象>  描述：    pod的期望行为规范...    podSpec是pod的描述。    字段：    hostPID  
    <布尔型>    使用主机的pid命名空间。可选：默认为false。    ...    volumes   <[]对象>    pod中容器可以挂载的卷列表。    Containers 
    <[]对象> -必需-    pod中属于容器的列表。容器目前不能添加或删除。pod中必须至少有一个容器。    不能更新。更多信息：    http://releases.k8s.io/release-1.4/docs/user-guide/containers.md`'
- en: '|  |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 3.2.3\. Using kubectl create to create the pod
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 3.2.3\. 使用kubectl create创建pod
- en: 'To create the pod from your YAML file, use the `kubectl create` command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要从你的YAML文件创建pod，请使用`kubectl create`命令：
- en: '`$ kubectl create -f kubia-manual.yaml` `pod "kubia-manual" created`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl create -f kubia-manual.yaml` `pod "kubia-manual" 已创建`'
- en: The `kubectl create -f` command is used for creating any resource (not only
    pods) from a YAML or JSON file.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl create -f` 命令用于从YAML或JSON文件创建任何资源（不仅仅是pod）。'
- en: Retrieving the whole definition of a running pod
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 获取正在运行的pod的整个定义
- en: 'After creating the pod, you can ask Kubernetes for the full YAML of the pod.
    You’ll see it’s similar to the YAML you saw earlier. You’ll learn about the additional
    fields appearing in the returned definition in the next sections. Go ahead and
    use the following command to see the full descriptor of the pod:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建pod之后，你可以向Kubernetes请求pod的完整YAML。你会看到它与之前看到的YAML类似。你将在下一节中了解返回定义中出现的附加字段。请使用以下命令查看pod的完整描述符：
- en: '`$ kubectl get po kubia-manual -o yaml`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get po kubia-manual -o yaml`'
- en: 'If you’re more into JSON, you can also tell `kubectl` to return JSON instead
    of YAML like this (this works even if you used YAML to create the pod):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢JSON，你也可以让`kubectl`返回JSON而不是YAML，如下所示（即使你使用YAML创建了pod，这也适用）：
- en: '`$ kubectl get po kubia-manual -o json`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get po kubia-manual -o json`'
- en: Seeing your newly created pod in the list of pods
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在pod列表中查看你新创建的pod
- en: 'Your pod has been created, but how do you know if it’s running? Let’s list
    pods to see their statuses:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你的pod已经创建，但你怎么知道它在运行呢？让我们列出pod以查看它们的状态：
- en: '`$ kubectl get pods` `NAME            READY   STATUS    RESTARTS   AGE kubia-manual   
    1/1     Running   0          32s kubia-zxzij     1/1     Running   0         
    1d`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get pods` `名称            就绪   状态    重启次数   年龄 kubia-manual    1/1    
    运行中   0          32秒 kubia-zxzij     1/1     运行中   0          1天`'
- en: There’s your `kubia-manual` pod. Its status shows that it’s running. If you’re
    like me, you’ll probably want to confirm that’s true by talking to the pod. You’ll
    do that in a minute. First, you’ll look at the app’s log to check for any errors.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你的`kubia-manual` pod。其状态显示它正在运行。如果你像我一样，你可能想通过与pod通信来确认这一点。你将在下一分钟这样做。首先，你将查看应用程序日志以检查是否有任何错误。
- en: 3.2.4\. Viewing application logs
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 3.2.4\. 查看应用程序日志
- en: Your little Node.js application logs to the process’s standard output. Containerized
    applications usually log to the standard output and standard error stream instead
    of writing their logs to files. This is to allow users to view logs of different
    applications in a simple, standard way.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你小巧的Node.js应用程序将日志记录到进程的标准输出。容器化应用程序通常将日志记录到标准输出和标准错误流，而不是将日志写入文件。这是为了让用户能够以简单、标准的方式查看不同应用程序的日志。
- en: The container runtime (Docker in your case) redirects those streams to files
    and allows you to get the container’s log by running
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 容器运行时（在你的情况下是Docker）将这些流重定向到文件，并允许你通过运行以下命令来获取容器的日志
- en: '`$ docker logs <container id>`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker logs <容器ID>`'
- en: You could use `ssh` to log into the node where your pod is running and retrieve
    its logs with `docker logs`, but Kubernetes provides an easier way.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`ssh`登录到你的Pod运行的节点，并使用`docker logs`检索其日志，但Kubernetes提供了一个更简单的方法。
- en: Retrieving a pod’s log with kubectl logs
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用kubectl logs检索Pod的日志
- en: 'To see your pod’s log (more precisely, the container’s log) you run the following
    command on your local machine (no need to `ssh` anywhere):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看你的Pod日志（更准确地说，是容器的日志），你需要在本地机器上运行以下命令（无需`ssh`到任何地方）：
- en: '`$ kubectl logs kubia-manual` `Kubia server starting...`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl logs kubia-manual` `Kubia服务器启动...`'
- en: You haven’t sent any web requests to your Node.js app, so the log only shows
    a single log statement about the server starting up. As you can see, retrieving
    logs of an application running in Kubernetes is incredibly simple if the pod only
    contains a single container.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你还没有向你的Node.js应用程序发送任何Web请求，所以日志只显示一条关于服务器启动的单个日志语句。正如你所见，如果Pod只包含一个容器，那么在Kubernetes中检索运行的应用程序的日志非常简单。
- en: '|  |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Container logs are automatically rotated daily and every time the log file reaches
    10MB in size. The `kubectl logs` command only shows the log entries from the last
    rotation.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 容器日志会自动每天轮换，并且每当日志文件达到10MB大小时也会轮换。`kubectl logs`命令只显示上一次轮换后的日志条目。
- en: '|  |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Specifying the container name when getting logs of a multi-container pod
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取多容器Pod的日志时指定容器名称
- en: 'If your pod includes multiple containers, you have to explicitly specify the
    container name by including the `-c <container name>` option when running `kubectl
    logs`. In your `kubia-manual` pod, you set the container’s name to `kubia`, so
    if additional containers exist in the pod, you’d have to get its logs like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的Pod包含多个容器，你必须在使用`kubectl logs`时显式指定容器名称，包括`-c <容器名称>`选项。在你的`kubia-manual`
    Pod中，你将容器的名称设置为`kubia`，所以如果Pod中存在其他容器，你必须像这样获取其日志：
- en: '`$ kubectl logs kubia-manual -c kubia` `Kubia server starting...`'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl logs kubia-manual -c kubia` `Kubia服务器启动...`'
- en: Note that you can only retrieve container logs of pods that are still in existence.
    When a pod is deleted, its logs are also deleted. To make a pod’s logs available
    even after the pod is deleted, you need to set up centralized, cluster-wide logging,
    which stores all the logs into a central store. [Chapter 17](index_split_123.html#filepos1548600)
    explains how centralized logging works.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你只能检索仍然存在的Pod的容器日志。当一个Pod被删除时，其日志也会被删除。为了在Pod删除后仍然可以访问Pod的日志，你需要设置集中式、集群范围内的日志记录，将所有日志存储到中央存储中。[第17章](index_split_123.html#filepos1548600)解释了集中式日志记录是如何工作的。
- en: 3.2.5\. Sending requests to the pod
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 3.2.5. 向Pod发送请求
- en: The pod is now running—at least that’s what `kubectl get` and your app’s log
    say. But how do you see it in action? In the previous chapter, you used the `kubectl
    expose` command to create a service to gain access to the pod externally. You’re
    not going to do that now, because a whole chapter is dedicated to services, and
    you have other ways of connecting to a pod for testing and debugging purposes.
    One of them is through port forwarding.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Pod现在正在运行——至少`kubectl get`和你的应用程序日志是这样说的。但你是如何看到它在实际中的运行情况的？在前一章中，你使用了`kubectl
    expose`命令来创建一个服务以外部访问Pod。现在你不会这样做，因为整章都致力于服务，而且你有其他方法连接到Pod进行测试和调试。其中之一是通过端口转发。
- en: Forwarding a local network port to a port in the pod
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将本地网络端口转发到Pod中的端口
- en: 'When you want to talk to a specific pod without going through a service (for
    debugging or other reasons), Kubernetes allows you to configure port forwarding
    to the pod. This is done through the `kubectl port-forward` command. The following
    command will forward your machine’s local port `8888` to port `8080` of your `kubia-manual`
    pod:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想与特定的Pod通信而不通过服务（用于调试或其他原因）时，Kubernetes允许你配置到Pod的端口转发。这是通过`kubectl port-forward`命令完成的。以下命令将你的机器的本地端口`8888`转发到`kubia-manual`
    Pod的端口`8080`：
- en: '`$ kubectl port-forward kubia-manual 8888:8080` `... Forwarding from 127.0.0.1:8888
    -> 8080 ... Forwarding from [::1]:8888 -> 8080`'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl port-forward kubia-manual 8888:8080` `... 正在转发从 127.0.0.1:8888 到
    8080 ... 正在转发从 [::1]:8888 到 8080`'
- en: The port forwarder is running and you can now connect to your pod through the
    local port.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 端口转发器正在运行，你现在可以通过本地端口连接到你的Pod。
- en: Connecting to the pod through the port forwarder
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过端口转发器连接到Pod
- en: 'In a different terminal, you can now use `curl` to send an HTTP request to
    your pod through the `kubectl port-forward` proxy running on `localhost:8888`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的终端中，你现在可以使用`curl`通过运行在`localhost:8888`上的`kubectl port-forward`代理向你的Pod发送HTTP请求：
- en: '`$ curl localhost:8888` `You''ve hit kubia-manual`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ curl localhost:8888` `您已访问kubia-manual`'
- en: '[Figure 3.5](#filepos312158) shows an overly simplified view of what happens
    when you send the request. In reality, a couple of additional components sit between
    the `kubectl` process and the pod, but they aren’t relevant right now.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.5](#filepos312158)显示了一个过于简化的视图，展示了发送请求时会发生什么。实际上，在`kubectl`进程和Pod之间有几个额外的组件，但它们现在并不相关。'
- en: Figure 3.5\. A simplified view of what happens when you use curl with `kubectl
    port-forward`
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5. 使用`kubectl port-forward`与curl一起使用时的简化视图
- en: '![](images/00063.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](images/00063.jpg)'
- en: Using port forwarding like this is an effective way to test an individual pod.
    You’ll learn about other similar methods throughout the book.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方式进行端口转发是测试单个Pod的有效方法。你将在本书的其余部分了解其他类似的方法。
- en: 3.3\. Organizing pods with labels
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 3.3. 组织带有标签的Pod
- en: At this point, you have two pods running in your cluster. When deploying actual
    applications, most users will end up running many more pods. As the number of
    pods increases, the need for categorizing them into subsets becomes more and more
    evident.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你的集群中已经运行了两个Pod。在部署实际应用程序时，大多数用户最终会运行更多的Pod。随着Pod数量的增加，将它们分类到子集的需求变得越来越明显。
- en: For example, with microservices architectures, the number of deployed microservices
    can easily exceed 20 or more. Those components will probably be replicated (multiple
    copies of the same component will be deployed) and multiple versions or releases
    (stable, beta, canary, and so on) will run concurrently. This can lead to hundreds
    of pods in the system. Without a mechanism for organizing them, you end up with
    a big, incomprehensible mess, such as the one shown in [figure 3.6](#filepos313727).
    The figure shows pods of multiple microservices, with several running multiple
    replicas, and others running different releases of the same microservice.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在微服务架构中，部署的微服务数量很容易超过20个或更多。这些组件可能会被复制（将部署相同组件的多个副本）并且会同时运行多个版本或发布（稳定版、测试版、金丝雀版等）。这可能导致系统中出现数百个Pod。如果没有组织它们的机制，你最终会得到一个庞大且难以理解的一团糟，就像[图3.6](#filepos313727)中所示的那样。该图显示了多个微服务的Pod，其中一些运行多个副本，而其他则运行同一微服务的不同版本。
- en: Figure 3.6\. Uncategorized pods in a microservices architecture
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6. 微服务架构中的未分类Pod
- en: '![](images/00083.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](images/00083.jpg)'
- en: It’s evident you need a way of organizing them into smaller groups based on
    arbitrary criteria, so every developer and system administrator dealing with your
    system can easily see which pod is which. And you’ll want to operate on every
    pod belonging to a certain group with a single action instead of having to perform
    the action for each pod individually.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你需要一种方法将它们根据任意标准组织成更小的组，这样每个处理你系统的开发人员和系统管理员都可以轻松地看到哪个Pod是哪个。你还将希望对属于某个组的每个Pod执行单个操作，而不是对每个Pod单独执行操作。
- en: Organizing pods and all other Kubernetes objects is done through labels.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 组织Pod和所有其他Kubernetes对象是通过标签完成的。
- en: 3.3.1\. Introducing labels
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 3.3.1. 介绍标签
- en: Labels are a simple, yet incredibly powerful, Kubernetes feature for organizing
    not only pods, but all other Kubernetes resources. A label is an arbitrary key-value
    pair you attach to a resource, which is then utilized when selecting resources
    using label selectors (resources are filtered based on whether they include the
    label specified in the selector). A resource can have more than one label, as
    long as the keys of those labels are unique within that resource. You usually
    attach labels to resources when you create them, but you can also add additional
    labels or even modify the values of existing labels later without having to recreate
    the resource.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 标签是 Kubernetes 中一个简单而又极其强大的功能，用于组织不仅限于 Pod，还包括所有其他 Kubernetes 资源。标签是你附加到资源上的任意键值对，然后在使用标签选择器选择资源时被利用（资源根据是否包含选择器中指定的标签进行过滤）。一个资源可以有多个标签，只要这些标签的键在该资源内是唯一的。你通常在创建资源时附加标签，但也可以稍后添加额外的标签或甚至修改现有标签的值，而无需重新创建资源。
- en: 'Let’s turn back to the microservices example from [figure 3.6](#filepos313727).
    By adding labels to those pods, you get a much-better-organized system that everyone
    can easily make sense of. Each pod is labeled with two labels:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到图 3.6 中的微服务示例。通过向这些 Pod 添加标签，你将得到一个组织得更好、大家都能轻松理解的系统。每个 Pod 都被标记为两个标签：
- en: '`app`, which specifies which app, component, or microservice the pod belongs
    to.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app`，它指定 Pod 属于哪个应用程序、组件或微服务。'
- en: '`rel`, which shows whether the application running in the pod is a stable,
    beta, or a canary release.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rel`，它显示 Pod 中运行的应用程序是稳定版、测试版还是金丝雀发布。'
- en: '|  |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Definition
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 定义
- en: A canary release is when you deploy a new version of an application next to
    the stable version, and only let a small fraction of users hit the new version
    to see how it behaves before rolling it out to all users. This prevents bad releases
    from being exposed to too many users.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 金丝雀发布是指你在稳定版本旁边部署应用程序的新版本，并且只让一小部分用户访问新版本，以观察其行为，然后再将其推广给所有用户。这可以防止不良发布版本暴露给太多用户。
- en: '|  |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: By adding these two labels, you’ve essentially organized your pods into two
    dimensions (horizontally by app and vertically by release), as shown in [figure
    3.7](#filepos316615).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加这两个标签，你实际上已经将你的 Pod 组织成两个维度（水平方向按应用程序，垂直方向按发布），如图 3.7 所示。
- en: Figure 3.7\. Organizing pods in a microservices architecture with pod labels
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7\. 使用 Pod 标签组织微服务架构中的 Pod
- en: '![](images/00101.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00101.jpg)'
- en: Every developer or ops person with access to your cluster can now easily see
    the system’s structure and where each pod fits in by looking at the pod’s labels.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每个有权访问你的集群的开发者或运维人员都可以通过查看 Pod 的标签，轻松地看到系统的结构和每个 Pod 的位置。
- en: 3.3.2\. Specifying labels when creating a pod
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 3.3.2\. 在创建 Pod 时指定标签
- en: Now, you’ll see labels in action by creating a new pod with two labels. Create
    a new file called kubia-manual-with-labels.yaml with the contents of the following
    listing.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将通过创建一个带有两个标签的新 Pod 来看到标签的实际应用。创建一个名为 kubia-manual-with-labels.yaml 的新文件，并包含以下内容的列表。
- en: 'Listing 3.3\. A pod with labels: kubia-manual-with-labels.yaml'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.3\. 带有标签的 Pod：kubia-manual-with-labels.yaml
- en: '`apiVersion: v1 kind: Pod metadata:   name: kubia-manual-v2   labels:     creation_method:
    manual` `1` `env: prod` `1` `spec:   containers:   - image: luksa/kubia     name:
    kubia     ports:     - containerPort: 8080       protocol: TCP`'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiVersion: v1 kind: Pod metadata:   name: kubia-manual-v2   labels:     creation_method:
    manual` `1` `env: prod` `1` `spec:   containers:   - image: luksa/kubia     name:
    kubia     ports:     - containerPort: 8080       protocol: TCP`'
- en: 1 Two labels are attached to the pod.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 附加了两个标签到 Pod 上。
- en: 'You’ve included the labels `creation_method=manual` and `env=data.labels` section.
    You’ll create this pod now:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经包含了 `creation_method=manual` 和 `env=data.labels` 部分。你现在将创建这个 Pod：
- en: '`$ kubectl create -f kubia-manual-with-labels.yaml` `pod "kubia-manual-v2"
    created`'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl create -f kubia-manual-with-labels.yaml` `pod "kubia-manual-v2"
    created`'
- en: 'The `kubectl get pods` command doesn’t list any labels by default, but you
    can see them by using the `--show-labels` switch:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`kubectl get pods` 命令不会列出任何标签，但你可以通过使用 `--show-labels` 开关来查看它们：
- en: '`$ kubectl get po --show-labels` `NAME            READY  STATUS   RESTARTS 
    AGE LABELS kubia-manual    1/1    Running  0         16m <none> kubia-manual-v2
    1/1    Running  0         2m  creat_method=manual,env=prod kubia-zxzij     1/1   
    Running  0         1d  run=kubia`'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get po --show-labels` `NAME            READY  STATUS   RESTARTS 
    AGE LABELS kubia-manual    1/1    Running  0         16m <none> kubia-manual-v2
    1/1    Running  0         2m  creat_method=manual,env=prod kubia-zxzij     1/1   
    Running  0         1d  run=kubia`'
- en: 'Instead of listing all labels, if you’re only interested in certain labels,
    you can specify them with the `-L` switch and have each displayed in its own column.
    List pods again and show the columns for the two labels you’ve attached to your
    `kubia-manual-v2` pod:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只对某些标签感兴趣，而不是列出所有标签，您可以使用 `-L` 开关指定它们，并将每个标签单独显示在其自己的列中。再次列出 pods 并显示您附加到
    `kubia-manual-v2` pod 的两个标签的列：
- en: '`$ kubectl get po -L creation_method,env` `NAME            READY   STATUS   
    RESTARTS   AGE   CREATION_METHOD   ENV kubia-manual    1/1     Running   0         
    16m   <none>            <none> kubia-manual-v2 1/1     Running   0          2m   
    manual            prod kubia-zxzij     1/1     Running   0          1d    <none>           
    <none>`'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get po -L creation_method,env` `NAME            READY   STATUS   
    RESTARTS   AGE   CREATION_METHOD   ENV kubia-manual    1/1     Running   0         
    16m   <none>            <none> kubia-manual-v2 1/1     Running   0          2m   
    manual            prod kubia-zxzij     1/1     Running   0          1d    <none>           
    <none>`'
- en: 3.3.3\. Modifying labels of existing pods
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 3.3.3\. 修改现有 pods 的标签
- en: 'Labels can also be added to and modified on existing pods. Because the `kubia-manual`
    pod was also created manually, let’s add the `creation_method=manual` label to
    it:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 标签还可以添加到现有 pods 上并对其进行修改。因为 `kubia-manual` pod 也是手动创建的，所以让我们向它添加 `creation_method=manual`
    标签：
- en: '`$ kubectl label po kubia-manual creation_method=manual` `pod "kubia-manual"
    labeled`'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl label po kubia-manual creation_method=manual` `pod "kubia-manual"
    labeled`'
- en: Now, let’s also change the `env=prod` label to `env=debug` on the `kubia-manual-v2`
    pod, to see how existing labels can be changed.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们也将 `kubia-manual-v2` pod 上的 `env=prod` 标签更改为 `env=debug`，以查看现有标签如何更改。
- en: '|  |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You need to use the `--overwrite` option when changing existing labels.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 更改现有标签时，需要使用 `--overwrite` 选项。
- en: '|  |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`$ kubectl label po kubia-manual-v2 env=debug --overwrite` `pod "kubia-manual-v2"
    labeled`'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl label po kubia-manual-v2 env=debug --overwrite` `pod "kubia-manual-v2"
    labeled`'
- en: 'List the pods again to see the updated labels:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 再次列出 pods 以查看更新的标签：
- en: '`$ kubectl get po -L creation_method,env` `NAME            READY   STATUS   
    RESTARTS   AGE   CREATION_METHOD   ENV kubia-manual    1/1     Running   0         
    16m` `manual``<none> kubia-manual-v2 1/1     Running   0          2m    manual`
    `debug` `kubia-zxzij     1/1     Running   0          1d    <none>           
    <none>`'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get po -L creation_method,env` `NAME            READY   STATUS   
    RESTARTS   AGE   CREATION_METHOD   ENV kubia-manual    1/1     Running   0         
    16m` `manual``<none> kubia-manual-v2 1/1     Running   0          2m    manual`
    `debug` `kubia-zxzij     1/1     Running   0          1d    <none>           
    <none>`'
- en: As you can see, attaching labels to resources is trivial, and so is changing
    them on existing resources. It may not be evident right now, but this is an incredibly
    powerful feature, as you’ll see in the next chapter. But first, let’s see what
    you can do with these labels, in addition to displaying them when listing pods.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，将标签附加到资源是微不足道的，更改现有资源上的标签也是如此。现在可能还不明显，但这是一个非常强大的功能，您将在下一章中看到。但首先，让我们看看除了在列出
    pods 时显示它们之外，您还可以用这些标签做什么。
- en: 3.4\. Listing subsets of pods through label selectors
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 3.4\. 通过标签选择器列出 pods 的子集
- en: Attaching labels to resources so you can see the labels next to each resource
    when listing them isn’t that interesting. But labels go hand in hand with label
    selectors. Label selectors allow you to select a subset of pods tagged with certain
    labels and perform an operation on those pods. A label selector is a criterion,
    which filters resources based on whether they include a certain label with a certain
    value.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 将标签附加到资源以便在列出时可以看到每个资源旁边的标签并不那么有趣。但标签与标签选择器密不可分。标签选择器允许您选择带有特定标签的 pod 的子集，并对这些
    pod 执行操作。标签选择器是一个标准，它根据资源是否包含具有特定值的特定标签来过滤资源。
- en: A label selector can select resources based on whether the resource
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 标签选择器可以根据资源是否包含具有特定值的特定标签来选择资源
- en: Contains (or doesn’t contain) a label with a certain key
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含（或不包含）具有特定键的标签
- en: Contains a label with a certain key and value
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含具有特定键和值的标签
- en: Contains a label with a certain key, but with a value not equal to the one you
    specify
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含具有特定键但值不等于您指定的标签
- en: 3.4.1\. Listing pods using a label selector
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 3.4.1\. 使用标签选择器列出 pods
- en: 'Let’s use label selectors on the pods you’ve created so far. To see all pods
    you created manually (you labeled them with `creation_method=manual`), do the
    following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用标签选择器来查看您迄今为止创建的 pods。要查看您手动创建的所有 pods（您用 `creation_method=manual` 标记了它们），请执行以下操作：
- en: '`$ kubectl get po -l creation_method=manual` `NAME              READY     STATUS   
    RESTARTS   AGE kubia-manual      1/1       Running   0          51m kubia-manual-v2  
    1/1       Running   0          37m`'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get po -l creation_method=manual` `NAME              READY     STATUS   
    RESTARTS   AGE kubia-manual      1/1       运行中   0          51分钟 kubia-manual-v2  
    1/1       运行中   0          37分钟`'
- en: 'To list all pods that include the `env` label, whatever its value is:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出所有包含`env`标签的Pod，无论其值是什么：
- en: '`$ kubectl get po -l env` `NAME              READY     STATUS    RESTARTS  
    AGE kubia-manual-v2   1/1       Running   0          37m`'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get po -l env` `NAME              READY     STATUS    RESTARTS  
    AGE kubia-manual-v2   1/1       运行中   0          37分钟`'
- en: 'And those that don’t have the `env` label:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以及那些没有`env`标签的Pod：
- en: '`$ kubectl get po -l ''!env''` `NAME           READY     STATUS    RESTARTS  
    AGE kubia-manual   1/1       Running   0          51m kubia-zxzij    1/1      
    Running   0          10d`'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get po -l ''!env''` `NAME           READY     STATUS    RESTARTS  
    AGE kubia-manual   1/1       运行中   0          51分钟 kubia-zxzij    1/1       运行中  
    0          10天`'
- en: '|  |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure to use single quotes around `!env`, so the bash shell doesn’t evaluate
    the exclamation mark.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保在`!env`周围使用单引号，这样bash shell就不会评估感叹号。
- en: '|  |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Similarly, you could also match pods with the following label selectors:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，你也可以使用以下标签选择器来匹配Pod：
- en: '`creation_method!=manual` to select pods with the `creation_method` label with
    any value other than `manual`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`creation_method!=manual` 用于选择标签`creation_method`设置为除`manual`之外任何值的Pod'
- en: '`env in (prod,devel)` to select pods with the `env` label set to either `prod`
    or `devel`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`env in (prod,devel)` 用于选择标签`env`设置为`prod`或`devel`的Pod'
- en: '`env notin (prod,devel)` to select pods with the `env` label set to any value
    other than `prod` or `devel`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`env notin (prod,devel)` 用于选择标签`env`设置为除`prod`或`devel`之外任何值的Pod'
- en: Turning back to the pods in the microservices-oriented architecture example,
    you could select all pods that are part of the product catalog microservice by
    using the `app=pc` label selector (shown in the following figure).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 回到面向微服务的架构示例中的Pod，你可以通过使用`app=pc`标签选择器（如图所示）来选择所有属于产品目录微服务的Pod。
- en: Figure 3.8\. Selecting the product catalog microservice pods using the “app=pc”
    label selector
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8\. 使用“app=pc”标签选择器选择产品目录微服务的Pod
- en: '![](images/00120.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00120.jpg)'
- en: 3.4.2\. Using multiple conditions in a label selector
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 3.4.2\. 在标签选择器中使用多个条件
- en: 'A selector can also include multiple comma-separated criteria. Resources need
    to match all of them to match the selector. If, for example, you want to select
    only pods running the beta release of the product catalog microservice, you’d
    use the following selector: `app=pc,rel=beta` (visualized in [figure 3.9](#filepos326611)).'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器也可以包含多个以逗号分隔的标准。资源需要匹配所有这些标准才能匹配选择器。例如，如果你想选择仅运行产品目录微服务beta版本的Pod，你会使用以下选择器：`app=pc,rel=beta`（如图3.9所示）。
- en: Figure 3.9\. Selecting pods with multiple label selectors
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9\. 使用多个标签选择器选择Pod
- en: '![](images/00137.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00137.jpg)'
- en: Label selectors aren’t useful only for listing pods, but also for performing
    actions on a subset of all pods. For example, later in the chapter, you’ll see
    how to use label selectors to delete multiple pods at once. But label selectors
    aren’t used only by `kubectl`. They’re also used internally, as you’ll see next.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 标签选择器不仅对列出Pod有用，还可以用于对所有Pod的子集执行操作。例如，在本章的后面，你会看到如何使用标签选择器一次性删除多个Pod。但标签选择器不仅被`kubectl`使用，它们也被内部使用，你将在下面看到。
- en: 3.5\. Using labels and selectors to constrain pod scheduling
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 3.5\. 使用标签和选择器来约束Pod调度
- en: All the pods you’ve created so far have been scheduled pretty much randomly
    across your worker nodes. As I’ve mentioned in the previous chapter, this is the
    proper way of working in a Kubernetes cluster. Because Kubernetes exposes all
    the nodes in the cluster as a single, large deployment platform, it shouldn’t
    matter to you what node a pod is scheduled to. Because each pod gets the exact
    amount of computational resources it requests (CPU, memory, and so on) and its
    accessibility from other pods isn’t at all affected by the node the pod is scheduled
    to, usually there shouldn’t be any need for you to tell Kubernetes exactly where
    to schedule your pods.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你迄今为止创建的所有Pod都已被随机调度到你的工作节点上。正如我在上一章提到的，这是在Kubernetes集群中工作的正确方式。因为Kubernetes将集群中的所有节点暴露为一个单一的、大型的部署平台，所以你不需要关心Pod被调度到哪个节点。因为每个Pod都获得了它请求的确切计算资源（CPU、内存等），并且它从其他Pod的访问性并不受Pod被调度到的节点的影响，通常你不需要告诉Kubernetes确切地在哪里调度你的Pod。
- en: Certain cases exist, however, where you’ll want to have at least a little say
    in where a pod should be scheduled. A good example is when your hardware infrastructure
    isn’t homogenous. If part of your worker nodes have spinning hard drives, whereas
    others have SSDs, you may want to schedule certain pods to one group of nodes
    and the rest to the other. Another example is when you need to schedule pods performing
    intensive GPU-based computation only to nodes that provide the required GPU acceleration.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，你可能希望至少对 Pod 应该调度到哪个位置有少许发言权。一个很好的例子是当你的硬件基础设施不均匀时。如果你的部分工作节点有旋转硬盘，而其他节点有
    SSD，你可能希望将某些 Pod 调度到一组节点，其余的调度到另一组。另一个例子是当你需要将执行基于 GPU 的密集计算的 Pod 调度到提供所需 GPU
    加速的节点上。
- en: You never want to say specifically what node a pod should be scheduled to, because
    that would couple the application to the infrastructure, whereas the whole idea
    of Kubernetes is hiding the actual infrastructure from the apps that run on it.
    But if you want to have a say in where a pod should be scheduled, instead of specifying
    an exact node, you should describe the node requirements and then let Kubernetes
    select a node that matches those requirements. This can be done through node labels
    and node label selectors.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你永远不希望明确指出 Pod 应该调度到哪个节点，因为这会将应用程序与基础设施耦合在一起，而 Kubernetes 整个理念是隐藏实际基础设施，使其对在其上运行的应用程序不可见。但如果你想对
    Pod 应该调度到哪个位置有发言权，而不是指定一个确切的节点，你应该描述节点需求，然后让 Kubernetes 选择一个符合这些需求的节点。这可以通过节点标签和节点标签选择器来实现。
- en: 3.5.1\. Using labels for categorizing worker nodes
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 3.5.1\. 使用标签对工作节点进行分类
- en: As you learned earlier, pods aren’t the only Kubernetes resource type that you
    can attach a label to. Labels can be attached to any Kubernetes object, including
    nodes. Usually, when the ops team adds a new node to the cluster, they’ll categorize
    the node by attaching labels specifying the type of hardware the node provides
    or anything else that may come in handy when scheduling pods.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如你之前所学的，Pod 不是唯一可以附加标签的 Kubernetes 资源类型。标签可以附加到任何 Kubernetes 对象，包括节点。通常，当运维团队向集群添加新节点时，他们会通过附加标签来对节点进行分类，这些标签指定了节点提供的硬件类型或其他可能在调度
    Pod 时有用的任何内容。
- en: 'Let’s imagine one of the nodes in your cluster contains a GPU meant to be used
    for general-purpose GPU computing. You want to add a label to the node showing
    this feature. You’re going to add the label `gpu=true` to one of your nodes (pick
    one out of the list returned by `kubectl get nodes`):'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设你的集群中的一个节点包含一个用于通用 GPU 计算的 GPU。你想要给这个节点添加一个标签来显示这个特性。你将向你的一个节点添加标签 `gpu=true`（从
    `kubectl get nodes` 返回的列表中选择一个）：
- en: '`$ kubectl label node gke-kubia-85f6-node-0rrx gpu=true` `node "gke-kubia-85f6-node-0rrx"
    labeled`'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl label node gke-kubia-85f6-node-0rrx gpu=true` `node "gke-kubia-85f6-node-0rrx"
    labeled`'
- en: 'Now you can use a label selector when listing the nodes, like you did before
    with pods. List only nodes that include the label `gpu=true`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在列出节点时使用标签选择器，就像之前列出 Pod 时所做的那样。仅列出包含标签 `gpu=true` 的节点：
- en: '`$ kubectl get nodes -l gpu=true` `NAME                      STATUS AGE gke-kubia-85f6-node-0rrx 
    Ready  1d`'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get nodes -l gpu=true` `NAME                      STATUS AGE gke-kubia-85f6-node-0rrx 
    Ready  1d`'
- en: As expected, only one node has this label. You can also try listing all the
    nodes and tell `kubectl` to display an additional column showing the values of
    each node’s `gpu` label (`kubectl get nodes -L gpu`).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，只有一个节点有这个标签。你也可以尝试列出所有节点，并告诉 `kubectl` 显示每个节点的 `gpu` 标签值（`kubectl get
    nodes -L gpu`）。
- en: 3.5.2\. Scheduling pods to specific nodes
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 3.5.2\. 将 Pod 调度到特定节点
- en: Now imagine you want to deploy a new pod that needs a GPU to perform its work.
    To ask the scheduler to only choose among the nodes that provide a GPU, you’ll
    add a node selector to the pod’s YAML. Create a file called kubia-gpu.yaml with
    the following listing’s contents and then use `kubectl create -f kubia-gpu.yaml`
    to create the pod.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你想要部署一个新的 Pod，该 Pod 需要 GPU 来执行其工作。为了要求调度器只从提供 GPU 的节点中选择，你将在 Pod 的 YAML
    中添加一个节点选择器。创建一个名为 kubia-gpu.yaml 的文件，包含以下内容的列表，然后使用 `kubectl create -f kubia-gpu.yaml`
    来创建 Pod。
- en: 'Listing 3.4\. Using a label selector to schedule a pod to a specific node:
    kubia-gpu.yaml'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.4\. 使用标签选择器将 Pod 调度到特定节点：kubia-gpu.yaml
- en: '`apiVersion: v1 kind: Pod metadata:   name: kubia-gpu spec:   nodeSelector:`
    `1` `gpu: "true"` `1` `containers:   - image: luksa/kubia     name: kubia`'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiVersion: v1 kind: Pod metadata:   name: kubia-gpu spec:   nodeSelector:`
    `1` `gpu: "true"` `1` `containers:   - image: luksa/kubia     name: kubia`'
- en: 1 nodeSelector tells Kubernetes to deploy this pod only to nodes containing
    the gpu=true label.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个`nodeSelector`告诉Kubernetes只将此Pod部署到包含`gpu=true`标签的节点。
- en: You’ve added a `nodeSelector` field under the `spec` section. When you create
    the pod, the scheduler will only choose among the nodes that contain the `gpu=true`
    label (which is only a single node in your case).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 您在`spec`部分下添加了一个`nodeSelector`字段。当您创建Pod时，调度器将只从包含`gpu=true`标签的节点中选择（在这种情况下，只有一个节点）。
- en: 3.5.3\. Scheduling to one specific node
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 3.5.3\. 将调度指定到特定节点
- en: Similarly, you could also schedule a pod to an exact node, because each node
    also has a unique label with the key `kubernetes.io/hostname` and value set to
    the actual hostname of the node. But setting the `nodeSelector` to a specific
    node by the hostname label may lead to the pod being unschedulable if the node
    is offline. You shouldn’t think in terms of individual nodes. Always think about
    logical groups of nodes that satisfy certain criteria specified through label
    selectors.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，您也可以将Pod调度到特定的节点，因为每个节点都有一个唯一的标签，键为`kubernetes.io/hostname`，值为节点的实际主机名。但通过主机名标签将`nodeSelector`设置为特定节点可能会导致节点离线时Pod不可调度。您不应该从单个节点的角度思考。始终考虑满足通过标签选择器指定的某些标准节点的逻辑组。
- en: This was a quick demonstration of how labels and label selectors work and how
    they can be used to influence the operation of Kubernetes. The importance and
    usefulness of label selectors will become even more evident when we talk about
    Replication-Controllers and Services in the next two chapters.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个快速演示，说明了标签和标签选择器的工作原理以及如何使用它们来影响Kubernetes的操作。在下一章讨论Replication-Controllers和Services时，标签选择器的重要性和实用性将变得更加明显。
- en: '|  |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Additional ways of influencing which node a pod is scheduled to are covered
    in [chapter 16](index_split_118.html#filepos1486732).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 影响Pod调度到哪个节点的方法的其他方式在[第16章](index_split_118.html#filepos1486732)中介绍。
- en: '|  |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 3.6\. Annotating pods
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 3.6\. 注解Pod
- en: In addition to labels, pods and other objects can also contain annotations.
    Annotations are also key-value pairs, so in essence, they’re similar to labels,
    but they aren’t meant to hold identifying information. They can’t be used to group
    objects the way labels can. While objects can be selected through label selectors,
    there’s no such thing as an annotation selector.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标签外，Pod和其他对象还可以包含注解。注解也是键值对，因此本质上与标签相似，但它们不是为了持有标识信息而设计的。它们不能像标签那样用于分组对象。虽然可以通过标签选择器选择对象，但不存在注解选择器。
- en: On the other hand, annotations can hold much larger pieces of information and
    are primarily meant to be used by tools. Certain annotations are automatically
    added to objects by Kubernetes, but others are added by users manually.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，注解可以包含大量信息，主要用于工具使用。某些注解是由Kubernetes自动添加到对象中的，但其他注解则是由用户手动添加的。
- en: Annotations are also commonly used when introducing new features to Kubernetes.
    Usually, alpha and beta versions of new features don’t introduce any new fields
    to API objects. Annotations are used instead of fields, and then once the required
    API changes have become clear and been agreed upon by the Kubernetes developers,
    new fields are introduced and the related annotations deprecated.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入Kubernetes的新功能时，注解也经常被使用。通常，新功能的alpha和beta版本不会向API对象引入任何新字段。注解代替字段使用，一旦所需的API更改变得明确并被Kubernetes开发者同意，就会引入新字段，并弃用相关的注解。
- en: A great use of annotations is adding descriptions for each pod or other API
    object, so that everyone using the cluster can quickly look up information about
    each individual object. For example, an annotation used to specify the name of
    the person who created the object can make collaboration between everyone working
    on the cluster much easier.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用注解的一个很好的用途是为每个Pod或其他API对象添加描述，这样集群中的每个人都可以快速查找有关每个单独对象的信息。例如，用于指定创建对象的人名的注解可以使在集群上工作的每个人的协作变得更加容易。
- en: 3.6.1\. Looking up an object’s annotations
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 3.6.1\. 查找对象的注解
- en: Let’s see an example of an annotation that Kubernetes added automatically to
    the pod you created in the previous chapter. To see the annotations, you’ll need
    to request the full YAML of the pod or use the `kubectl describe` command. You’ll
    use the first option in the following listing.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Kubernetes自动添加到上一章创建的Pod中的注解示例。要查看注解，您需要请求Pod的完整YAML文件或使用`kubectl describe`命令。以下列表中将使用第一种方法。
- en: Listing 3.5\. A pod’s annotations
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.5\. Pod的注解
- en: '`$ kubectl get po kubia-zxzij -o yaml` `apiVersion: v1 kind: pod metadata:
      annotations:     kubernetes.io/created-by: |       {"kind":"SerializedReference",
    "apiVersion":"v1",       "reference":{"kind":"ReplicationController", "namespace":"default",
    ...`'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get po kubia-zxzij -o yaml` `apiVersion: v1 kind: pod metadata:
      annotations:     kubernetes.io/created-by: |       {"kind":"SerializedReference",
    "apiVersion":"v1",       "reference":{"kind":"ReplicationController", "namespace":"default",
    ...`'
- en: Without going into too many details, as you can see, the `kubernetes.io/created-by`
    annotation holds JSON data about the object that created the pod. That’s not something
    you’d want to put into a label. Labels should be short, whereas annotations can
    contain relatively large blobs of data (up to 256 KB in total).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入细节的话，如您所见，`kubernetes.io/created-by` 注解包含有关创建容器的对象的 JSON 数据。这不是您想放入标签中的内容。标签应该是简短的，而注解可以包含相对较大的数据块（总大小最多为
    256 KB）。
- en: '|  |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `kubernetes.io/created-by` annotations was deprecated in version 1.8 and
    will be removed in 1.9, so you will no longer see it in the YAML.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubernetes.io/created-by` 注解在版本 1.8 中已被弃用，并在 1.9 中将被移除，因此您在 YAML 中将不再看到它。'
- en: '|  |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 3.6.2\. Adding and modifying annotations
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 3.6.2\. 添加和修改注解
- en: Annotations can obviously be added to pods at creation time, the same way labels
    can. They can also be added to or modified on existing pods later. The simplest
    way to add an annotation to an existing object is through the `kubectl annotate`
    command.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 注解显然可以在创建容器时添加，就像标签一样。它们也可以在现有的容器中添加或修改。向现有对象添加注解的最简单方法是使用 `kubectl annotate`
    命令。
- en: 'You’ll try adding an annotation to your `kubia-manual` pod now:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您将尝试向您的 `kubia-manual` 容器添加一个注解：
- en: '`$ kubectl annotate pod kubia-manual mycompany.com/someannotation="foo bar"`
    `pod "kubia-manual" annotated`'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl annotate pod kubia-manual mycompany.com/someannotation="foo bar"`
    `pod "kubia-manual" annotated`'
- en: You added the annotation `mycompany.com/someannotation` with the value `foo
    bar`. It’s a good idea to use this format for annotation keys to prevent key collisions.
    When different tools or libraries add annotations to objects, they may accidentally
    override each other’s annotations if they don’t use unique prefixes like you did
    here.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 您已添加注解 `mycompany.com/someannotation`，其值为 `foo bar`。使用这种格式作为注解键是一个好主意，以防止键冲突。当不同的工具或库向对象添加注解时，如果它们没有使用像您在这里使用的唯一前缀，它们可能会意外地覆盖彼此的注解。
- en: 'You can use `kubectl describe` to see the annotation you added:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `kubectl describe` 来查看您添加的注解：
- en: '`$ kubectl describe pod kubia-manual` `... Annotations:    mycompany.com/someannotation=foo
    bar ...`'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl describe pod kubia-manual` `... Annotations:    mycompany.com/someannotation=foo
    bar ...`'
- en: 3.7\. Using namespaces to group resources
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 3.7\. 使用命名空间来分组资源
- en: Let’s turn back to labels for a moment. We’ve seen how they organize pods and
    other objects into groups. Because each object can have multiple labels, those
    groups of objects can overlap. Plus, when working with the cluster (through `kubectl`
    for example), if you don’t explicitly specify a label selector, you’ll always
    see all objects.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时回到标签。我们已经看到它们如何将容器和其他对象组织成组。因为每个对象可以有多个标签，这些对象组可能会重叠。此外，当通过 `kubectl` 等工具与集群交互时，如果您没有明确指定标签选择器，您将始终看到所有对象。
- en: But what about times when you want to split objects into separate, non-overlapping
    groups? You may want to only operate inside one group at a time. For this and
    other reasons, Kubernetes also groups objects into namespaces. These aren’t the
    Linux namespaces we talked about in [chapter 2](index_split_022.html#filepos185841),
    which are used to isolate processes from each other. Kubernetes namespaces provide
    a scope for objects names. Instead of having all your resources in one single
    namespace, you can split them into multiple name-spaces, which also allows you
    to use the same resource names multiple times (across different namespaces).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时您可能想要将对象分成单独的、不重叠的组？您可能只想一次操作一个组。出于这些和其他原因，Kubernetes 还将对象分组到命名空间中。这些不是我们在第
    2 章中讨论的 Linux 命名空间，它们用于隔离进程。Kubernetes 命名空间为对象名称提供了作用域。您可以将所有资源放在一个命名空间中，也可以将它们分成多个命名空间，这还允许您在不同命名空间中使用相同的资源名称多次。
- en: 3.7.1\. Understanding the need for namespaces
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 3.7.1\. 理解命名空间的需求
- en: Using multiple namespaces allows you to split complex systems with numerous
    components into smaller distinct groups. They can also be used for separating
    resources in a multi-tenant environment, splitting up resources into production,
    development, and QA environments, or in any other way you may need. Resource names
    only need to be unique within a namespace. Two different namespaces can contain
    resources of the same name. But, while most types of resources are namespaced,
    a few aren’t. One of them is the Node resource, which is global and not tied to
    a single namespace. You’ll learn about other cluster-level resources in later
    chapters.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个命名空间允许你将具有许多组件的复杂系统分割成更小的独立组。它们也可以用于在多租户环境中分离资源，将资源分割成生产、开发和QA环境，或者以任何其他你可能需要的方式。资源名称只需要在命名空间内是唯一的。两个不同的命名空间可以包含具有相同名称的资源。但是，尽管大多数类型的资源都是命名空间化的，但有一些资源不是。其中之一是Node资源，它是全局的，不与单个命名空间绑定。你将在后面的章节中了解其他集群级资源。
- en: Let’s see how to use namespaces now.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何使用命名空间。
- en: 3.7.2\. Discovering other namespaces and their pods
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 3.7.2\. 发现其他命名空间及其Pod
- en: 'First, let’s list all namespaces in your cluster:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们列出你集群中的所有命名空间：
- en: '`$ kubectl get ns` `NAME          LABELS    STATUS    AGE default       <none>   
    Active    1h kube-public   <none>    Active    1h kube-system   <none>    Active   
    1h`'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get ns` `NAME          LABELS    STATUS    AGE default       <none>   
    Active    1h kube-public   <none>    Active    1h kube-system   <none>    Active   
    1h`'
- en: 'Up to this point, you’ve operated only in the `default` namespace. When listing
    resources with the `kubectl get` command, you’ve never specified the namespace
    explicitly, so `kubectl` always defaulted to the `default` namespace, showing
    you only the objects in that namespace. But as you can see from the list, the
    `kube-public` and the `kube-system` namespaces also exist. Let’s look at the pods
    that belong to the `kube-system` namespace, by telling `kubectl` to list pods
    in that namespace only:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你只在使用`default`命名空间。当使用`kubectl get`命令列出资源时，你从未明确指定命名空间，所以`kubectl`总是默认使用`default`命名空间，只显示该命名空间中的对象。但是，正如你所看到的列表，`kube-public`和`kube-system`命名空间也存在。让我们通过告诉`kubectl`只在该命名空间中列出Pod来查看属于`kube-system`命名空间的Pod：
- en: '`$ kubectl get po --namespace kube-system` `NAME                                
    READY     STATUS    RESTARTS   AGE fluentd-cloud-kubia-e8fe-node-txje   1/1      
    Running   0          1h heapster-v11-fz1ge                   1/1       Running  
    0          1h kube-dns-v9-p8a4t                    0/4       Pending   0         
    1h kube-ui-v4-kdlai                     1/1       Running   0          1h l7-lb-controller-v0.5.2-bue96       
    2/2       Running   92         1h`'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get po --namespace kube-system` `NAME                                
    READY     STATUS    RESTARTS   AGE fluentd-cloud-kubia-e8fe-node-txje   1/1      
    Running   0          1h heapster-v11-fz1ge                   1/1       Running  
    0          1h kube-dns-v9-p8a4t                    0/4       Pending   0         
    1h kube-ui-v4-kdlai                     1/1       Running   0          1h l7-lb-controller-v0.5.2-bue96       
    2/2       Running   92         1h`'
- en: '|  |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can also use `-n` instead of `--namespace`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`-n`代替`--namespace`。
- en: '|  |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: You’ll learn about these pods later in the book (don’t worry if the pods shown
    here don’t match the ones on your system exactly). It’s clear from the name of
    the namespace that these are resources related to the Kubernetes system itself.
    By having them in this separate namespace, it keeps everything nicely organized.
    If they were all in the default namespace, mixed in with the resources you create
    yourself, you’d have a hard time seeing what belongs where, and you might inadvertently
    delete system resources.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本书的后面部分了解这些Pod（如果这里显示的Pod与你的系统中的Pod不完全匹配，请不要担心）。从命名空间的名字可以看出，这些是与Kubernetes系统本身相关的资源。通过将它们放在这个独立的命名空间中，可以保持一切井然有序。如果它们都在默认命名空间中，与你自己创建的资源混合在一起，你将很难看到哪些属于哪里，你可能会意外删除系统资源。
- en: Namespaces enable you to separate resources that don’t belong together into
    non-overlapping groups. If several users or groups of users are using the same
    Kubernetes cluster, and they each manage their own distinct set of resources,
    they should each use their own namespace. This way, they don’t need to take any
    special care not to inadvertently modify or delete the other users’ resources
    and don’t need to concern themselves with name conflicts, because namespaces provide
    a scope for resource names, as has already been mentioned.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间允许你将不属于一起的资源分离成不重叠的组。如果多个用户或用户组正在使用同一个 Kubernetes 集群，并且他们各自管理自己独特的一组资源，那么他们应该各自使用自己的命名空间。这样，他们不需要特别注意不要无意中修改或删除其他用户的资源，也不需要担心名称冲突，因为命名空间为资源名称提供了范围，正如之前提到的。
- en: Besides isolating resources, namespaces are also used for allowing only certain
    users access to particular resources and even for limiting the amount of computational
    resources available to individual users. You’ll learn about this in [chapters
    12](index_split_095.html#filepos1145244) through [14](index_split_105.html#filepos1325290).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 除了隔离资源外，命名空间还用于仅允许某些用户访问特定的资源，甚至可以限制分配给单个用户的计算资源量。你将在第 [12](index_split_095.html#filepos1145244)
    章到 [14](index_split_105.html#filepos1325290) 章中了解这一点。
- en: 3.7.3\. Creating a namespace
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 3.7.3\. 创建命名空间
- en: A namespace is a Kubernetes resource like any other, so you can create it by
    posting a YAML file to the Kubernetes API server. Let’s see how to do this now.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间就像 Kubernetes 中的任何其他资源一样，因此你可以通过向 Kubernetes API 服务器提交 YAML 文件来创建它。现在让我们看看如何做。
- en: Creating a namespace from a YAML file
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 从 YAML 文件创建命名空间
- en: First, create a custom-namespace.yaml file with the following listing’s contents
    (you’ll find the file in the book’s code archive).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个包含以下内容的 custom-namespace.yaml 文件（你可以在本书的代码存档中找到该文件）。
- en: 'Listing 3.6\. A YAML definition of a namespace: custom-namespace.yaml'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.6\. 命名空间的 YAML 定义：custom-namespace.yaml
- en: '`apiVersion: v1 kind: Namespace` `1` `metadata:   name: custom-namespace` `2`'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiVersion: v1 kind: Namespace` `1` `metadata:   name: custom-namespace` `2`'
- en: 1 This says you’re defining a namespace.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 这表示你正在定义一个命名空间。
- en: 2 This is the name of the namespace.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 这是命名空间的名字。
- en: 'Now, use `kubectl` to post the file to the Kubernetes API server:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 `kubectl` 将文件提交到 Kubernetes API 服务器：
- en: '`$ kubectl create -f custom-namespace.yaml` `namespace "custom-namespace" created`'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl create -f custom-namespace.yaml` `namespace "custom-namespace" created`'
- en: Creating a namespace with kubectl create namespace
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 kubectl create namespace 创建命名空间
- en: Although writing a file like the previous one isn’t a big deal, it’s still a
    hassle. Luckily, you can also create namespaces with the dedicated `kubectl create
    namespace` command, which is quicker than writing a YAML file. By having you create
    a YAML manifest for the namespace, I wanted to reinforce the idea that everything
    in Kubernetes has a corresponding API object that you can create, read, update,
    and delete by posting a YAML manifest to the API server.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然编写像之前的文件这样的内容并不是什么大事，但仍然有些麻烦。幸运的是，你还可以使用专门的 `kubectl create namespace` 命令来创建命名空间，这比编写
    YAML 文件要快。通过让你为命名空间创建 YAML 清单，我想强调在 Kubernetes 中，所有内容都有一个相应的 API 对象，你可以通过向 API
    服务器提交 YAML 清单来创建、读取、更新和删除。
- en: 'You could have created the namespace like this:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像这样创建命名空间：
- en: '`$ kubectl create namespace custom-namespace` `namespace "custom-namespace"
    created`'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl create namespace custom-namespace` `namespace "custom-namespace"
    created`'
- en: '|  |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Although most objects’ names must conform to the naming conventions specified
    in RFC 1035 (Domain names), which means they may contain only letters, digits,
    dashes, and dots, namespaces (and a few others) aren’t allowed to contain dots.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数对象的名称必须符合 RFC 1035（域名）中指定的命名约定，这意味着它们可能只包含字母、数字、破折号和点，但命名空间（以及其他一些对象）不允许包含点。
- en: '|  |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 3.7.4\. Managing objects in other namespaces
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 3.7.4\. 管理其他命名空间中的对象
- en: 'To create resources in the namespace you’ve created, either add a `namespace:
    custom-namespace` entry to the `metadata` section, or specify the namespace when
    creating the resource with the `kubectl create` command:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '要在创建的资源中创建资源，你可以在 `metadata` 部分添加 `namespace: custom-namespace` 条目，或者在使用 `kubectl
    create` 命令创建资源时指定命名空间：'
- en: '`$ kubectl create -f kubia-manual.yaml -n custom-namespace` `pod "kubia-manual"
    created`'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl create -f kubia-manual.yaml -n custom-namespace` `pod "kubia-manual"
    created`'
- en: You now have two pods with the same name (`kubia-manual`). One is in the `default`
    namespace, and the other is in your `custom-namespace`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在有两个具有相同名称（`kubia-manual`）的 pod。一个在 `default` 命名空间中，另一个在你的 `custom-namespace`
    中。
- en: When listing, describing, modifying, or deleting objects in other namespaces,
    you need to pass the `--namespace` (or `-n`) flag to `kubectl`. If you don’t specify
    the namespace, `kubectl` performs the action in the default namespace configured
    in the current `kubectl` context. The current context’s namespace and the current
    context itself can be changed through `kubectl config` commands. To learn more
    about managing `kubectl` contexts, refer to [appendix A](index_split_135.html#filepos1721130).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当在其它命名空间中列出、描述、修改或删除对象时，您需要向 `kubectl` 命令传递 `--namespace`（或 `-n`）标志。如果您没有指定命名空间，`kubectl`
    将在当前 `kubectl` 上下文中配置的默认命名空间中执行操作。当前上下文的命名空间和当前上下文本身可以通过 `kubectl config` 命令进行更改。要了解更多关于管理
    `kubectl` 上下文的信息，请参阅[附录 A](index_split_135.html#filepos1721130)。
- en: '|  |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'To quickly switch to a different namespace, you can set up the following alias:
    `alias kcd=''kubectl config set-context $(kubectl config current-context) --namespace
    ''`. You can then switch between namespaces using `kcd some-namespace`.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 要快速切换到不同的命名空间，您可以设置以下别名：`alias kcd='kubectl config set-context $(kubectl config
    current-context) --namespace '`。然后您可以使用 `kcd some-namespace` 在命名空间之间切换。
- en: '|  |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 3.7.5\. Understanding the isolation provided by namespaces
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 3.7.5\. 理解命名空间提供的隔离
- en: To wrap up this section about namespaces, let me explain what namespaces don’t
    provide—at least not out of the box. Although namespaces allow you to isolate
    objects into distinct groups, which allows you to operate only on those belonging
    to the specified namespace, they don’t provide any kind of isolation of running
    objects.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结关于命名空间的部分，让我解释一下命名空间不提供什么——至少不是默认提供的。尽管命名空间允许您将对象隔离到不同的组中，从而允许您仅操作指定命名空间中的对象，但它们不提供对运行对象的任何隔离。
- en: For example, you may think that when different users deploy pods across different
    namespaces, those pods are isolated from each other and can’t communicate, but
    that’s not necessarily the case. Whether namespaces provide network isolation
    depends on which networking solution is deployed with Kubernetes. When the solution
    doesn’t provide inter-namespace network isolation, if a pod in namespace `foo`
    knows the IP address of a pod in namespace `bar`, there is nothing preventing
    it from sending traffic, such as HTTP requests, to the other pod.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可能会认为当不同用户在不同命名空间中部署 Pod 时，这些 Pod 之间是隔离的，并且不能相互通信，但这并不一定正确。命名空间是否提供网络隔离取决于与
    Kubernetes 一起部署的网络解决方案。当解决方案不提供命名空间间的网络隔离时，如果 `foo` 命名空间中的 Pod 知道 `bar` 命名空间中
    Pod 的 IP 地址，那么没有任何东西可以阻止它向另一个 Pod 发送流量，例如 HTTP 请求。
- en: 3.8\. Stopping and removing pods
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 3.8\. 停止和删除 Pod
- en: You’ve created a number of pods, which should all still be running. You have
    four pods running in the `default` namespace and one pod in `custom-namespace`.
    You’re going to stop all of them now, because you don’t need them anymore.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 您已创建了许多 Pod，它们都应该仍在运行。您在 `default` 命名空间中有四个 Pod，在 `custom-namespace` 中有一个 Pod。您现在将停止所有这些
    Pod，因为您不再需要它们。
- en: 3.8.1\. Deleting a pod by name
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 3.8.1\. 通过名称删除 Pod
- en: 'First, delete the `kubia-gpu` pod by name:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过名称删除 `kubia-gpu` Pod：
- en: '`$ kubectl delete po kubia-gpu` `pod "kubia-gpu" deleted`'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl delete po kubia-gpu` `pod "kubia-gpu" 已删除`'
- en: By deleting a pod, you’re instructing Kubernetes to terminate all the containers
    that are part of that pod. Kubernetes sends a `SIGTERM` signal to the process
    and waits a certain number of seconds (30 by default) for it to shut down gracefully.
    If it doesn’t shut down in time, the process is then killed through `SIGKILL`.
    To make sure your processes are always shut down gracefully, they need to handle
    the `SIGTERM` signal properly.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 通过删除 Pod，您指示 Kubernetes 终止该 Pod 中所有容器的运行。Kubernetes 向进程发送 `SIGTERM` 信号并等待一定时间（默认为
    30 秒）以优雅地关闭。如果它没有及时关闭，则通过 `SIGKILL` 杀死进程。要确保您的进程始终优雅地关闭，它们需要正确处理 `SIGTERM` 信号。
- en: '|  |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: You can also delete more than one pod by specifying multiple, space-separated
    names (for example, `kubectl delete po pod1 pod2`).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过指定多个以空格分隔的名称来删除多个 Pod（例如，`kubectl delete po pod1 pod2`）。
- en: '|  |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 3.8.2\. Deleting pods using label selectors
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 3.8.2\. 使用标签选择器删除 Pod
- en: 'Instead of specifying each pod to delete by name, you’ll now use what you’ve
    learned about label selectors to stop both the `kubia-manual` and the `kubia-manual-v2`
    pod. Both pods include the `creation_method=manual` label, so you can delete them
    by using a label selector:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 与通过名称指定每个要删除的 Pod 相比，您现在将使用您所学的标签选择器来停止 `kubia-manual` 和 `kubia-manual-v2` Pod。这两个
    Pod 都包含 `creation_method=manual` 标签，因此您可以使用标签选择器来删除它们：
- en: '`$ kubectl delete po -l creation_method=manual` `pod "kubia-manual" deleted
    pod "kubia-manual-v2" deleted`'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl delete po -l creation_method=manual` `pod "kubia-manual" deleted
    pod "kubia-manual-v2" deleted`'
- en: 'In the earlier microservices example, where you had tens (or possibly hundreds)
    of pods, you could, for instance, delete all canary pods at once by specifying
    the `rel=canary` label selector (visualized in [figure 3.10](#filepos352054)):'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的微服务示例中，您有数十（或可能数百）个pods，例如，您可以通过指定`rel=canary`标签选择器（如图3.10所示）一次性删除所有金丝雀pods：
- en: '`$ kubectl delete po -l rel=canary`'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl delete po -l rel=canary`'
- en: Figure 3.10\. Selecting and deleting all canary pods through the `rel=canary`
    label selector
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10\. 通过`rel=canary`标签选择器选择和删除所有金丝雀pods
- en: '![](images/00155.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00155.jpg)'
- en: 3.8.3\. Deleting pods by deleting the whole namespace
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 3.8.3\. 通过删除整个命名空间来删除pods
- en: 'Okay, back to your real pods. What about the pod in the `custom-namespace`?
    You no longer need either the pods in that namespace, or the namespace itself.
    You can delete the whole namespace (the pods will be deleted along with the namespace
    automatically), using the following command:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，回到您的真实pods。关于`custom-namespace`中的pods怎么办？您不再需要该命名空间中的pods，或者命名空间本身。您可以使用以下命令删除整个命名空间（pods将随着命名空间的删除而自动删除）：
- en: '`$ kubectl delete ns custom-namespace` `namespace "custom-namespace" deleted`'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl delete ns custom-namespace` `namespace "custom-namespace" deleted`'
- en: 3.8.4\. Deleting all pods in a namespace, while keeping the namespace
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 3.8.4\. 删除命名空间中的所有pods，同时保留命名空间
- en: 'You’ve now cleaned up almost everything. But what about the pod you created
    with the `kubectl run` command in [chapter 2](index_split_022.html#filepos185841)?
    That one is still running:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在几乎清理了一切。但是，关于您在[第2章](index_split_022.html#filepos185841)中使用`kubectl run`命令创建的pods怎么办？它仍在运行：
- en: '`$ kubectl get pods` `NAME            READY   STATUS    RESTARTS   AGE kubia-zxzij    
    1/1     Running   0          1d`'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get pods` `NAME            READY   STATUS    RESTARTS   AGE kubia-zxzij    
    1/1     Running   0          1d`'
- en: 'This time, instead of deleting the specific pod, tell Kubernetes to delete
    all pods in the current namespace by using the `--all` option:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，不是删除特定的pods，而是告诉Kubernetes使用`--all`选项删除当前命名空间中的所有pods：
- en: '`$ kubectl delete po --all` `pod "kubia-zxzij" deleted`'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl delete po --all` `pod "kubia-zxzij" deleted`'
- en: 'Now, double check that no pods were left running:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请再次确认没有pods仍在运行：
- en: '`$ kubectl get pods` `NAME            READY   STATUS        RESTARTS   AGE
    kubia-09as0     1/1     Running       0          1d kubia-zxzij     1/1     Terminating  
    0          1d`'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get pods` `NAME            READY   STATUS        RESTARTS   AGE
    kubia-09as0     1/1     Running       0          1d kubia-zxzij     1/1     Terminating  
    0          1d`'
- en: Wait, what!?! The `kubia-zxzij` pod is terminating, but a new pod called `kubia-09as0`,
    which wasn’t there before, has appeared. No matter how many times you delete all
    pods, a new pod called kubia-something will emerge.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 等等！？！`kubia-zxzij` pods正在终止，但一个名为`kubia-09as0`的新pods出现了，之前并不存在。无论您删除所有pods多少次，都会出现一个名为kubia-something的新pods。
- en: You may remember you created your first pod with the `kubectl run` command.
    In [chapter 2](index_split_022.html#filepos185841), I mentioned that this doesn’t
    create a pod directly, but instead creates a ReplicationController, which then
    creates the pod. As soon as you delete a pod created by the ReplicationController,
    it immediately creates a new one. To delete the pod, you also need to delete the
    ReplicationController.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能记得您是使用`kubectl run`命令创建的第一个pods。在[第2章](index_split_022.html#filepos185841)中，我提到这并不直接创建pods，而是创建一个ReplicationController，然后它再创建pods。一旦您删除由ReplicationController创建的pods，它立即创建一个新的。要删除pods，您还需要删除ReplicationController。
- en: 3.8.5\. Deleting (almost) all resources in a namespace
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 3.8.5\. 删除命名空间中的（几乎）所有资源
- en: 'You can delete the ReplicationController and the pods, as well as all the Services
    you’ve created, by deleting all resources in the current namespace with a single
    command:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过删除当前命名空间中的所有资源，使用单个命令来删除ReplicationController、pods以及您创建的所有服务：
- en: '`$ kubectl delete all --all` `pod "kubia-09as0" deleted replicationcontroller
    "kubia" deleted service "kubernetes" deleted service "kubia-http" deleted`'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl delete all --all` `pod "kubia-09as0" deleted replicationcontroller
    "kubia" deleted service "kubernetes" deleted service "kubia-http" deleted`'
- en: The first `all` in the command specifies that you’re deleting resources of all
    types, and the `--all` option specifies that you’re deleting all resource instances
    instead of specifying them by name (you already used this option when you ran
    the previous delete command).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 命令中的第一个 `all` 指定您正在删除所有类型的资源，而 `--all` 选项指定您正在删除所有资源实例，而不是按名称指定它们（您在运行上一个删除命令时已经使用了此选项）。
- en: '|  |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Deleting everything with the `all` keyword doesn’t delete absolutely everything.
    Certain resources (like Secrets, which we’ll introduce in [chapter 7](index_split_063.html#filepos687721))
    are preserved and need to be deleted explicitly.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `all` 关键字删除所有内容并不会删除所有内容。某些资源（如我们在[第 7 章](index_split_063.html#filepos687721)中将要介绍的
    Secrets）被保留，需要显式删除。
- en: '|  |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: As it deletes resources, `kubectl` will print the name of every resource it
    deletes. In the list, you should see the `kubia` ReplicationController and the
    `kubia-http` Service you created in [chapter 2](index_split_022.html#filepos185841).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在删除资源时，`kubectl` 将打印出它删除的每个资源的名称。在列表中，您应该看到您在[第 2 章](index_split_022.html#filepos185841)中创建的
    `kubia` ReplicationController 和 `kubia-http` 服务。
- en: '|  |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `kubectl delete all --all` command also deletes the `kubernetes` Service,
    but it should be recreated automatically in a few moments.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl delete all --all` 命令也会删除 `kubernetes` 服务，但它应该会在几秒钟内自动重新创建。'
- en: '|  |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 3.9\. Summary
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 3.9. 摘要
- en: After reading this chapter, you should now have a decent knowledge of the central
    building block in Kubernetes. Every other concept you’ll learn about in the next
    few chapters is directly related to pods.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章之后，您现在应该对 Kubernetes 的核心构建块有了一定的了解。您在接下来的几章中学习的每个其他概念都与 Pod 直接相关。
- en: In this chapter, you’ve learned
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经学习了
- en: How to decide whether certain containers should be grouped together in a pod
    or not.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何决定某些容器是否应该在一个 Pod 中分组在一起。
- en: Pods can run multiple processes and are similar to physical hosts in the non-container
    world.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pod 可以运行多个进程，在非容器世界中类似于物理主机。
- en: YAML or JSON descriptors can be written and used to create pods and then examined
    to see the specification of a pod and its current state.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: YAML 或 JSON 描述符可以编写并用于创建 Pod，然后检查 Pod 的规范及其当前状态。
- en: Labels and label selectors should be used to organize pods and easily perform
    operations on multiple pods at once.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签和标签选择器应用于组织 Pod 并轻松地对多个 Pod 同时执行操作。
- en: You can use node labels and selectors to schedule pods only to nodes that have
    certain features.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用节点标签和选择器来调度仅具有特定功能的节点上的 Pod。
- en: Annotations allow attaching larger blobs of data to pods either by people or
    tools and libraries.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释允许通过人员或工具和库将更大的数据块附加到 Pod 上。
- en: Namespaces can be used to allow different teams to use the same cluster as though
    they were using separate Kubernetes clusters.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间可用于允许不同的团队使用同一个集群，就像他们使用单独的 Kubernetes 集群一样。
- en: How to use the `kubectl explain` command to quickly look up the information
    on any Kubernetes resource.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 `kubectl explain` 命令快速查找任何 Kubernetes 资源的信息。
- en: In the next chapter, you’ll learn about ReplicationControllers and other resources
    that manage pods.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习关于 ReplicationController 和其他管理 Pod 的资源。
