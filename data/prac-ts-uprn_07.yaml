- en: Chapter 7\. State Space Models for Time Series
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。时间序列的状态空间模型
- en: State space models are similar to the statistical models we looked at in the
    previous chapter but with a more “real-world” motivation. They address concerns
    that emerge in real-world engineering problems, such as how to factor in measurement
    error when making estimates and how to inject prior knowledge or belief into estimates.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 状态空间模型与我们在前一章中研究的统计模型类似，但更具有“现实世界”的动机。它们解决了在真实世界工程问题中出现的问题，例如在进行估计时如何考虑测量误差以及如何将先验知识或信念注入估计中。
- en: State space models posit a world in which the true state cannot be measured
    directly but only inferred from what can be measured. State space models also
    rely on specifying the dynamics of a system, such as how the true state of the
    world evolves over time, both due to internal dynamics and the external forces
    that are applied to a system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 状态空间模型假设一个世界，其中真实状态不能直接测量，而只能从可测量的内容推断。状态空间模型还依赖于指定系统的动态，例如世界真实状态如何随时间演变，既受内部动态的影响，也受到施加在系统上的外部力量的影响。
- en: While you may not have seen state space models before in a mathematical context,
    you have likely used them in your day-to-day life. For example, imagine you see
    a driver weaving in traffic. You try to determine where the driver is going and
    how you can best defend yourself. If the driver might be intoxicated, you would
    consider calling the police, whereas if the driver was temporarily distracted
    for a reason that won’t repeat itself, you’d probably mind your own business.
    In the next few seconds or minutes you would update your own state space model
    of that driver before deciding what to do.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在数学背景下你可能之前没见过状态空间模型，但你可能在日常生活中使用过它们。例如，想象一下你看到一名司机在交通中迂回。你试图确定司机要去哪里以及如何最好地保护自己。如果司机可能醉酒，你会考虑报警，而如果司机因一时分心而不会重复的原因，你可能会顾及自己的事务。在接下来的几秒或几分钟内，你将更新你对该司机的状态空间模型，然后决定该做什么。
- en: A classic example of where you would use a state space model is a rocket ship
    launched into space. We know Newton’s laws, so we can write the rules for the
    dynamics of the system and what the motion should look like over time. We also
    know that our GPS or sensors or whatever we use to track location will have some
    measurement error that we can quantify and attempt to factor into the uncertainty
    about our calculations. Finally, we know that we can’t account for all the forces
    in the world acting on a particular rocket as there are many unknowns in the system,
    so we want a process that is robust to other unknown sources of noise, perhaps
    solar wind or earthly wind or both. As it turns out, statistical and engineering
    advances in the last 50 years have proven quite useful for tackling these sorts
    of situations.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 使用状态空间模型的一个经典例子是发射到太空的火箭。我们知道牛顿定律，因此我们可以编写系统动态的规则以及随时间应该看起来如何运动。我们还知道我们的GPS或传感器或者我们用于跟踪位置的任何东西都会有一些测量误差，我们可以量化并试图考虑到我们计算不确定性的这种影响。最后，我们知道我们无法解释作用在特定火箭上的世界上所有力量，因为系统中存在许多未知因素，所以我们希望这个过程对其他未知噪声源具有鲁棒性，也许是太阳风或地球风或两者兼而有之。事实证明，在过去50年的统计和工程进步中，这些方法已被证明非常有用。
- en: Two different historical trends led to the development of state space models
    and interest in the kinds of problems they address. First, around the middle of
    the 20th century, we entered an age of mechanical automation. There were rockets
    and spaceships in the sky, navigation systems for submarines, and all sorts of
    other automated inventions that required estimation of a system state that could
    not be measured. As researchers thought about how to estimate system state, they
    began developing state space methods, most importantly to disambiguate measurement
    errors from other kinds of uncertainty in the system. This led to the first uses
    of state space methods.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 两种不同的历史趋势导致了状态空间模型的发展以及对它们所处理问题种类的兴趣。首先，在20世纪中期左右，我们进入了一个机械自动化的时代。天空中有火箭和航天器，潜艇的导航系统以及所有种类的其他自动发明，这些发明需要估计无法测量的系统状态。当研究人员考虑如何估计系统状态时，他们开始开发状态空间方法，最重要的是区分测量误差和系统中其他类型的不确定性。这导致了状态空间方法的首次应用。
- en: During this time period, too, recordkeeping technology and associated computing
    were also developing. This led to the creation of much larger data sets for time
    series, including much longer or more detailed time series data sets. As more
    time series data became available, more data-intensive methods could be developed
    for them in conjunction with the new thinking about state space modeling.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在此期间，记录技术和相关计算也在发展。这导致了时间序列的数据集变得更大，包括更长或更详细的时间序列数据集。随着更多时间序列数据的可用性，可以与状态空间建模的新思维一起为其开发更多数据密集型方法。
- en: 'In this chapter we will study these commonly used state space methods:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习这些常用的状态空间方法：
- en: The Kalman filter applied to a linear Gaussian model
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用于线性高斯模型的卡尔曼滤波器
- en: Hidden Markov Models
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐马尔可夫模型
- en: Bayesian structural time series
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 贝叶斯结构时间序列
- en: In each of these cases, the use of such models is quite accessible and well
    implemented. For each model, we will develop some intuition for the mathematics
    and discuss what kind of data is appropriate for use with the method. Finally,
    we will see code examples for each method.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，使用这些模型是相当简便和良好实施的。对于每个模型，我们将对数学提出一些直觉，并讨论适合使用该方法的数据类型。最后，我们将看到每种方法的代码示例。
- en: 'In each case we will distinguish between what we observe and the state that
    produced our observations. In estimating the underlying state based on observations,
    we can divide our work into different stages or categories:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，我们将区分我们观察到的内容和产生我们观察结果的状态。在基于观察结果估计基础状态时，我们可以将我们的工作划分为不同的阶段或类别：
- en: Filtering
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 滤波
- en: Using the measurement at time *t* to update our estimation of the state at time
    *t*
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 利用时间 *t* 处的测量更新我们对时间 *t* 处状态的估计
- en: Forecasting
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 预测
- en: Using the measurement at time *t* – 1 to generate a prediction for the expected
    state at time *t* (allowing us to infer the expected measurement at time *t* as
    well)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 利用时间 *t* - 1 处的测量生成时间 *t* 处预期状态的预测（同时允许我们推断时间 *t* 处的预期测量）
- en: Smoothing
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 平滑
- en: Using measurement during a range of time that includes *t*, both before and
    after it, to estimate what the true state at time *t* was
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 利用包括 *t* 时间点之前和之后的时间范围内的测量来估计时间 *t* 处的真实状态
- en: The mechanics of these operations will often be similar, but the distinctions
    are important. Filtering is a way of deciding how to weigh the most recent information
    against past information in updating our estimate of state. Forecasting is the
    prediction of the future state without any information about the future. Smoothing
    is the use of future and past information in making a best estimate of the state
    at a given time.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作的机制通常相似，但区别很重要。**滤波**是一种决定如何将最新信息与过去信息进行权衡，以更新我们对状态估计的方法。**预测**是在没有未来信息的情况下预测未来状态。**平滑**是在制定给定时间点状态的最佳估计时利用未来和过去信息的方法。
- en: 'State Space Models: Pluses and Minuses'
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态空间模型：优缺点
- en: State space models can be used for both deterministic and stochastic applications,
    and they can be applied to both continuously sampled data and discretely sampled
    data.^([1](ch07.html#idm45576035168648))
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 状态空间模型可用于确定性和随机应用，并且可以应用于连续采样数据和离散采样数据。^([1](ch07.html#idm45576035168648))
- en: This alone gives you some inkling of their utility and tremendous flexibility.
    The flexibility of state space models is what drives both the advantages and disadvantages
    of this class of models.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点单独就能让你对它们的效用和极大的灵活性有所了解。状态空间模型的灵活性是驱动这一类模型优缺点的根源。
- en: 'There are many strengths of a state space model. A state space model allows
    for modeling what is often most interesting in a time series: the dynamic process
    and states producing the noisy data being analyzed, rather than just the noisy
    data itself. With a state space model, we inject a model of *causality* into the
    modeling process to explain what is generating a process in the first place. This
    is useful for cases where we have strong theories or reliable knowledge about
    how a system works, and where we want our model to help us suss out more details
    about general dynamics with which we are already familiar.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 状态空间模型有许多优势。状态空间模型允许对时间序列中通常最有趣的内容进行建模：产生被分析的嘈杂数据的动态过程和状态，而不仅仅是嘈杂数据本身。通过状态空间模型，我们在建模过程中注入了一个解释生成过程的模型，以解释首次产生过程的动因。这对于我们已经对系统如何运作有强有力理论或可靠知识的情况非常有用，而我们希望我们的模型帮助我们探索我们已经熟悉的一般动态的更多细节。
- en: A state space model allows for changing coefficients and parameters over time,
    which means that it allows for changing behavior over time. We did not impose
    a condition of stationarity on our data when using state space models. This is
    quite different from the models we examined in [Chapter 6](ch06.html#statistical_model_for_time_series),
    in which a stable process is assumed and modeled with only one set of coefficients
    rather than time-varying coefficients.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 状态空间模型允许随时间改变系数和参数，这意味着它允许随时间改变的行为。在使用状态空间模型时，我们没有对数据施加平稳性条件。这与我们在[第6章](ch06.html#statistical_model_for_time_series)中检验的模型有很大不同，那里假设了一个稳定的过程，并且只用一个系列的系数来建模，而不是时间变化的系数。
- en: 'Nonetheless, there are also some disadvantages to a state space model, and
    sometimes the strength of the state space model is also its weakness:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，状态空间模型也有一些缺点，有时状态空间模型的优点也是它的弱点：
- en: Because state space models are so flexible, there are many parameters to be
    set and many forms a state space model can take. This means that the properties
    of a particular state space model have often not been well studied. When you formulate
    a state space model tailored to your time series data, you will rarely have statistical
    textbooks or academic research papers in which others have studied the model too.
    This leaves you in less certain territory as far as understanding how your model
    performs or where you may have committed errors.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于状态空间模型如此灵活，需要设置许多参数，并且状态空间模型可以采取许多形式。这意味着特定状态空间模型的性质通常未被充分研究。当你制定一个适合你时间序列数据的状态空间模型时，你很少会在统计教科书或学术研究论文中找到其他人已经研究过该模型。这使得你在理解模型性能或可能出现错误的地方时，往往处于不太确定的领域。
- en: State space models can be very taxing computationally because there are many
    parameters. Also, the very high number of parameters for some kinds of state space
    models can leave you vulnerable to overfitting, particularly if you don’t have
    much data.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态空间模型在计算上可能非常耗费资源，因为涉及到许多参数。此外，某些类型的状态空间模型的参数数量非常庞大，这可能使你容易过拟合，特别是如果数据量不足的话。
- en: The Kalman Filter
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 卡尔曼滤波器
- en: The Kalman filter is a well-developed and widely deployed method for incorporating
    new information from a time series and incorporating it in a smart way with previously
    known information to estimate an underlying state. One of first uses of the Kalman
    filter was on the Apollo 11 mission—the filter was chosen when NASA engineers
    realized that the onboard computing elements would not allow other, more memory-intensive
    techniques of position estimation. As you will see in this section, the benefits
    of the Kalman filter are that it is relatively easy to compute and does not require
    storage of past data to make present estimates or future forecasts.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 卡尔曼滤波器是一种成熟并广泛应用的方法，用于从时间序列中获得新信息，并与先前已知的信息以智能方式结合，以估计潜在状态。卡尔曼滤波器最初的应用之一是在阿波罗11号任务中，当NASA工程师意识到机载计算元件无法支持其他更耗费内存的位置估计技术时，选择了该滤波器。正如您将在本节中看到的那样，卡尔曼滤波器的优点在于它相对容易计算，并且不需要存储过去的数据来进行现在或未来的预测。
- en: Overview
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: The mathematics of the Kalman filter can be intimidating to a newcomer, not
    because it is especially difficult but because there are a fair number of quantities
    to keep track of, and it’s an iterative, somewhat circular process with many related
    quantities. For this reason, we will not derive the Kalman filter equations here,
    but instead go through a high-level overview of those equations to get a sense
    of how they work.^([2](ch07.html#idm45576035151256))
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于初学者来说，卡尔曼滤波器的数学可能有些令人望而却步，不是因为它特别困难，而是因为需要跟踪相当数量的量，并且这是一个迭代的、有些循环的过程，涉及许多相关的量。因此，我们在这里不会推导卡尔曼滤波器的方程式，而是通过对这些方程式的高级概述来了解它们的工作原理。^([2](ch07.html#idm45576035151256))
- en: 'We begin with a linear Gaussian model, positing that our state and our observations
    have the following dynamics:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从线性高斯模型开始，假设我们的状态和观察具有以下动态：
- en: '*x[t] = F × x[t–1] + B × u[t] + w[t]*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*x[t] = F × x[t–1] + B × u[t] + w[t]*'
- en: '*y[t] = A × x[t] + v[t]*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*y[t] = A × x[t] + v[t]*'
- en: That is, the state at time t is a function of the state at the previous time
    step (*F* × *x*[*t*–1]), an external force term (*B* × *u[t]*), and a stochastic
    term (*w[t]*). Likewise, the measurement at time *t* is a function of the state
    at time *t* and a stochastic error term, measurement error.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，时间*t*的状态是前一个时间步骤的状态(*F* × *x*[*t*–1])、外部力项(*B* × *u[t]*)和随机项(*w[t]*)的函数。同样，时间*t*的测量是状态在时间*t*和随机误差项、测量误差的函数。
- en: 'Let’s imagine that *x[t]* is the real position of a spaceship, while *y[t]*
    is the position we measure with a sensor. *v[t]* is the measurement error in our
    sensor device (or range of devices). The fundamental equation applicable to the
    Kalman filter is this equation illustrating how to update our estimation given
    new information for time *t*:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象*x[t]*是宇宙飞船的实际位置，而*y[t]*是我们用传感器测量的位置。*v[t]*是我们传感器设备（或多个设备的范围）的测量误差。卡尔曼滤波器适用的基本方程是这个方程，它展示了如何在时间*t*给出新信息后更新我们的估计：
- en: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mover><mi>x</mi><mi>^</mi></mover></math>*[t]*
    = *K[t]* × *y[t]* + (1 – *K[t]*) × <math xmlns="http://www.w3.org/1998/Math/MathML"
    display="inline"><mover><mi>x</mi><mi>^</mi></mover></math>[*t*–1]
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mover><mi>x</mi><mi>^</mi></mover></math>*[t]*
    = *K[t]* × *y[t]* + (1 – *K[t]*) × <math xmlns="http://www.w3.org/1998/Math/MathML"
    display="inline"><mover><mi>x</mi><mi>^</mi></mover></math>*[*t*–1]
- en: What we see here is a filtering step—that is, a decision about how to use the
    measurement at time *t* to update our state estimation at time *t*. Remember,
    we have posited a situation in which we can observe only *y[t]* and make inferences
    about the state but can never be sure of the state exactly. We see above that
    the quantity *K[t]* establishes a balance in our estimation between old information
    (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mover><mi>x</mi><mi>^</mi></mover></math>[*t*–1])
    and new information (*y[t]*).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到的是一个滤波步骤，即如何使用时间*t*的测量来更新我们在时间*t*的状态估计的决策。请记住，我们假设的情况是我们只能观察*y[t]*并推断状态，但不能确切知道状态。从上面我们看到，数量*K[t]*在我们的估计中建立了旧信息(*<math
    xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mover><mi>x</mi><mi>^</mi></mover></math>*[*t*–1])和新信息(*y[t]*)之间的平衡。
- en: To go into the more detailed mechanics, we need to define some terms. We use
    P[t] to denote our estimate of the covariance of our state (this can be a scalar
    or a matrix, depending on whether the state is univariate or multivariate, the
    latter being more common). P^–[t] is the estimate for *t* before our measure at
    time *t* is taken into account.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解更详细的机制，我们需要定义一些术语。我们使用*P[t]*来表示我们状态协方差的估计（这可以是标量或矩阵，取决于状态是否单变量或多变量，后者更常见）。*P^–[t]*是在考虑时间*t*的测量之前的时间*t*的估计。
- en: We also use *R* to denote the measurement error variance, that is the variance
    of *v[t]*, which again can either be a scalar or a covariance matrix depending
    on the dimensionality of the measurements. *R* is generally well defined for a
    system, as it describes well-known physical properties of a particular sensor
    or measuring device. The apposite value for *w[t]*, *Q*, is less well defined
    and subject to tuning during the modeling process.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还用*R*来表示测量误差方差，即*v[t]*的方差，这可以是一个标量或协方差矩阵，具体取决于测量的维度。*R*通常对于一个系统是很好定义的，因为它描述了特定传感器或测量设备的已知物理特性。对于*w[t]*的适当值*Q*在建模过程中较少定义并且需要调整。
- en: 'Then we begin with a process such that we have known or estimated values for
    *x* and *P* at time 0\. Then, going forward for times after time 0, we follow
    an iterative process of a prediction and updating phase, with the prediction phase
    coming first, followed by the update/filtering phase, and so on:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们从一个过程开始，该过程使我们在时间0处已知或估计了*x*和*P*的值。然后，在时间0后，我们遵循预测和更新阶段的迭代过程，预测阶段首先进行，然后是更新/过滤阶段，如此循环。
- en: '*Prediction:*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*预测:*'
- en: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mover><mi>x</mi><mi>^</mi></mover></math>
    ^– [t] = F × <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mover><mi>x</mi><mi>^</mi></mover></math>[t–1]
    + B × u[t]
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mover><mi>x</mi><mi>^</mi></mover></math>
    ^– [t] = F × <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mover><mi>x</mi><mi>^</mi></mover></math>[t–1]
    + B × u[t]
- en: P^–[t] = F × P[t–1] × F^T + Q
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: P^–[t] = F × P[t–1] × F^T + Q
- en: '*Filtering:*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*滤波:*'
- en: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mover><mi>x</mi><mi>^</mi></mover></math>[t]
    = <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mover><mi>x</mi><mi>^</mi></mover></math>
    ^– [t] + K[t] × (y[t] – A × <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mover><mi>x</mi><mi>^</mi></mover></math>^-[t])
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mover><mi>x</mi><mi>^</mi></mover></math>[t]
    = <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mover><mi>x</mi><mi>^</mi></mover></math>
    ^– [t] + K[t] × (y[t] – A × <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mover><mi>x</mi><mi>^</mi></mover></math>^-[t])
- en: P[t] = (I – K[t] × A) × P^-[t]
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: P[t] = (I – K[t] × A) × P^-[t]
- en: 'where *K[t]*, the Kalman gain, is:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*K[t]*，即Kalman增益，为：
- en: K[t] = P ^– [t] × A^T × (A × P^-[t] × A^T + R) ^(– 1)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: K[t] = P ^– [t] × A^T × (A × P^-[t] × A^T + R) ^(– 1)
- en: You will see many visualizations of this recursive process. Some will break
    this into many steps, perhaps up to four or five, but the simplest way of thinking
    about it is that there are the computations undertaken to predict the values at
    time *t*, without a measurement for *y[t]* (the prediction), and then there are
    the steps undertaken at time *t*, after the measurement *y[t]* is known (the filtering).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到许多这种递归过程的可视化。有些将其分解为多个步骤，或许多达四到五步，但最简单的思考方式是：在没有*y[t]*（预测值）的测量的情况下，预测时间*t*的值，然后是在时间*t*，在已知测量*y[t]*后（过滤）所采取的步骤。
- en: 'To start, you need the following values:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，您需要以下值：
- en: Estimates for *R* and *Q*—your covariance matrices for measurement error (easy
    to know) and state stochasticity (usually estimated), respectively
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*R*和*Q*的估计值——分别是测量误差（易知）和状态随机性（通常估计）的协方差矩阵'
- en: Estimates or known values for your state at time 0, <math xmlns="http://www.w3.org/1998/Math/MathML"
    display="inline"><mover><mi>x</mi><mi>^</mi></mover></math>[0] (estimated based
    on *y*[0])
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 估计或已知的状态值在时间0，<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mover><mi>x</mi><mi>^</mi></mover></math>[0]（基于*y*[0]估计）
- en: Advance knowledge of what forces are planned to be applied at time t and how
    these impact state—that is, the matrix *B* and the value *u[t]*
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在时间*t*计划应用的力的预先知识以及这些如何影响状态——即矩阵*B*和值*u[t]*
- en: Knowledge of system dynamics that determine the state transition from one time
    step to another, namely *F*
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知识系统动态，决定从一个时间步骤到另一个时间步骤的状态转移，即*F*
- en: Knowledge of how the measurement depends on the state, namely *A*
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解测量如何依赖于状态的知识，即*A*
- en: There are many ways to derive the Kalman filter equations, including from a
    probabilistic perspective in expectation values, a least squares minimization
    problem, or as a maximum likelihood estimation problem. Derivations of the Kalman
    filter are widely available, and the interested reader can pursue this topic with
    a few internet searches.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以推导Kalman滤波器方程，包括从期望值的概率视角、最小二乘最小化问题，或作为最大似然估计问题。Kalman滤波器的推导广泛可得，有兴趣的读者可以通过几次互联网搜索来深入了解这个主题。
- en: Code for the Kalman Filter
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kalman滤波器的代码
- en: 'We consider a classic use case: trying to track an object subject to Newton’s
    mechanics with error-prone sensors. We generate a time series based on Newton’s
    laws of motion, namely that the position of an object is a function of its velocity
    and acceleration. We imagine taking discrete measurements even though the underlying
    movement is continuous. We first determine a series of accelerations, then assume
    that both position and velocity begin at 0\. While it is not physically realistic,
    we assume instant acceleration changes at the beginning of each time step, and
    a steady acceleration value:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们考虑一个经典的用例：试图跟踪一个受牛顿力学影响、带有误差传感器的物体。我们根据牛顿运动定律生成一个时间序列，即物体的位置是其速度和加速度的函数。尽管底层运动是连续的，但我们想象进行离散测量。我们首先确定一系列加速度，然后假设位置和速度都从0开始。虽然这不符合物理实际情况，我们假设每个时间步长开始时有即时的加速度变化，并且稳定的加速度值：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you don’t know or remember Newton’s laws of motion, you may wish to familiarize
    yourself with them, although you can also take these at face value for the current
    purposes (the computation of `x[ts]` and `v[ts]`).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不了解或不记得牛顿运动定律，您可能希望熟悉一下，尽管在当前目的（计算*x[ts]*和*v[ts]*）上，您也可以直接接受这些。
- en: 'A quick plotting exercise shows us the motion we have created with the acceleration
    structured as just shown (see [Figure 7-1](#fig-0701)):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一个快速的绘图练习向我们展示了我们通过结构化加速度所创建的运动（见[图7-1](#fig-0701)）：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We posit that these variables would represent a full description of the state,
    but that the only data available to us is the object’s position and that this
    data is available only from a noisy sensor. This sensor is `x` in the following
    code, and we plot how the measured value relates to the actual position in [Figure 7-2](#fig-0702):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设这些变量将代表状态的完整描述，但我们唯一可用的数据是物体的位置，并且此数据仅来自于一个嘈杂的传感器。这个传感器在下面的代码中表示为 `x`，我们绘制了测量值如何与实际位置相关联在
    [Figure 7-2](#fig-0702) 中：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In [Figure 7-2](#fig-0702) we see a constant acceleration (bottom plot) driving
    a linearly increasing velocity (middle plot) to produce a parabolic shape in displacement
    (top plot). If these mechanical relationships are not familiar, you can take them
    at face value or look for a quick review of basic mechanics in an introductory
    physics textbook.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Figure 7-2](#fig-0702) 中，我们看到一个恒定加速度（底部图）驱动线性增加的速度（中部图），从而在位移（顶部图）中产生一个抛物线形状。如果这些机械关系不熟悉，您可以接受它们或查阅物理入门教科书中关于基本力学的快速回顾。
- en: '![](assets/ptsa_0701.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ptsa_0701.png)'
- en: Figure 7-1\. The position, velocity, and acceleration of our rocket.
  id: totrans-68
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-1\. 我们火箭的位置、速度和加速度。
- en: '![](assets/ptsa_0702.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ptsa_0702.png)'
- en: Figure 7-2\. The true position (points) versus our noisy measurement (line).
    Notice that the position x does not reflect a perfect parabola due to the noise
    we put into the state transition equation.
  id: totrans-70
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-2\. 真实位置（点）与我们嘈杂的测量（线）的对比。请注意，位置 x 由于我们将噪声放入状态转移方程而不反映出完美的抛物线。
- en: 'Now we apply a Kalman filter. First, we code up a general function that reflects
    our discussion and derivation earlier in this section:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应用卡尔曼滤波器。首先，我们编写一个通用函数，反映了我们在本节早些时候讨论和推导的内容：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We apply this function, making only the rocket’s position measurable (so not
    the acceleration or velocity):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用这个函数，只测量火箭的位置（不包括加速度或速度）：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We plot the true position, the measured position, and the estimated position
    in [Figure 7-3](#fig-0703).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [Figure 7-3](#fig-0703) 中绘制了真实位置、测量位置和估计位置。
- en: '![](assets/ptsa_0703.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ptsa_0703.png)'
- en: 'Figure 7-3\. Many related quantities: the measured position, the actual/true
    position, the filtered estimation of the position (that is, best estimate for
    position at time t incorporating the measurement at time t), and the forecast
    of the position (that is, the best estimate for position at time t incorporating
    only the known system dynamics plus measurements up to time t – 1 and not including
    time t).'
  id: totrans-77
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-3\. 许多相关数量：测量位置、实际/真实位置、位置的滤波估计（即，在时间 t 时合并时间 t 的测量的位置的最佳估计）、位置的预测（即，在时间
    t 时仅合并已知系统动态加上时间 t - 1 之前的测量，而不包括时间 t）。
- en: The Kalman filter takes out much of the noise from the measurement error. How
    much it does so will depend on our value for *R*, the measurement noise parameter,
    which reflects how much the filter should weigh the most recent value relative
    to earlier values. As we can see, the filter does a satisfactory job of forecasting
    the data. In particular, note that there is not a lag between the forecast data
    and the actual data, which would suggest that the method is merely predicting
    the current value based on the last value.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 卡尔曼滤波器消除了大部分测量误差中的噪声。它的效果取决于我们对 *R* 的值，即测量噪声参数，它反映了滤波器在最近值相对较早值之间应如何权衡。正如我们所见，该滤波器对数据的预测效果令人满意。特别是，注意到预测数据和实际数据之间没有滞后，这表明该方法不仅仅是基于上一个值预测当前值。
- en: Here we have worked through a simple example of a Kalman filter. The Kalman
    filter is widely studied because it is so useful in a variety of applications,
    particularly those where the internal dynamics of the system are very well understood.
    This makes it an ideal tool in cases such as the simple rocket example, where
    we understand the dynamics that are driving the system.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经通过一个卡尔曼滤波器的简单例子进行了探讨。卡尔曼滤波器因其在各种应用中特别是在系统内部动态非常了解的情况下非常有用而广泛研究。这使得它成为像简单的火箭例子这样的情况下的理想工具，我们理解了驱动系统的动态。
- en: Note that in this simple example, the whole power and utility of the Kalman
    filter is not fully realized. It is particularly useful when we have multiple
    kinds of measurements, say measuring different quantities or measuring the same
    thing simultaneously with many devices. Also there are many extensions to the
    Kalman filter that are worth studying if this is a promising area for your domain
    of interest.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，请注意卡尔曼滤波器的全部威力和实用性尚未完全体现。当我们有多种测量方式时特别有用，比如同时使用多个设备测量不同量或同时测量相同物体。此外，如果您的领域很有前景，卡尔曼滤波器还有许多值得研究的扩展。
- en: One of the great benefits of the Kalman filter, as we’ve illustrated, is that
    it is recursive. This means that it is not necessary to look at all data points
    on each iteration of the process. Rather, at each time step, all the information
    from prior time steps is already incorporated in the best possible way in the
    few estimated parameters, namely the most recent state and covariance estimate.
    The beauty of this method is that we can update in a smart way just using these
    “summary statistics” like measures, and we already know how to weigh them intelligently
    relative to the most recent data. This makes the Kalman filter very useful for
    real-world applications where computational time or resources are at a premium.
    In many cases this also coincides with the dynamics of real systems, in that the
    processes are relatively Markovian (memoryless other than the immediately prior
    state), and a function of an underlying state that can only be measured with some
    error.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所示，卡尔曼滤波器的一个重要优点是它是递归的。这意味着在每个过程迭代中不必查看所有数据点。相反，在每个时间步，所有先前时间步骤的信息已经以最佳方式整合在少数估计参数中，即最近的状态和协方差估计。这种方法的美妙之处在于我们可以智能地更新，仅使用这些“摘要统计量”，并且我们已经知道如何相对于最新数据进行智能加权。这使得卡尔曼滤波器在计算时间或资源有限的实际应用中非常有用。在许多情况下，这也与真实系统的动态相一致，即过程相对马尔可夫（除了即时前状态外无记忆），并且是基于仅能以一定误差测量的基础状态的函数。
- en: There are many useful extensions to the Kalman filter that we have not discussed
    here. One principal use of the Kalman filter is to adapt it to *smoothing*, which
    means using data both before and after time *t* to make the best estimate of the
    true state at time *t*. The mathematics and code are similar to what has been
    presented already. Also similar is the Extended Kalman Filter (EKF), which adapts
    the Kalman filter to data with nonlinear dynamics. This is also relatively straightforward
    to implement and is widely available in a variety of R and Python packages.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 关于卡尔曼滤波器，还有许多有用的扩展我们这里没有讨论。卡尔曼滤波器的一个主要用途是将其适应于*平滑*，这意味着使用时间*t*之前和之后的数据来最佳估计时间*t*处的真实状态。数学和代码与已经呈现的内容类似。同样类似的是扩展卡尔曼滤波器（EKF），它将卡尔曼滤波器适应于具有非线性动态的数据。这也相对简单地实现，并且在各种R和Python软件包中广泛可用。
- en: The Kalman filter is *O(T)* with respect to the length of the time series but
    *O(d²)* with respect to *d*, the dimension of the state. For this reason, it is
    important not to over-specify the state when a more streamlined specification
    will do just as well. However, it is this linearity with respect to the length
    of the time series that makes the Kalman filter commonly used in real production
    scenarios and much more popular than other filters developed for the purpose of
    state space modeling of time series.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 卡尔曼滤波器在时间序列长度上是*O(T)*，但相对于状态维度*d*是*O(d²)*。因此，在不必要过度指定状态时，采用更简化的规范就足够了。然而，正是这种对时间序列长度的线性特性使得卡尔曼滤波器在实际生产场景中普遍使用，并比为时间序列状态空间建模开发的其他滤波器更受欢迎。
- en: Hidden Markov Models
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐马尔可夫模型
- en: Hidden Markov Models (HMMs) are a particularly useful and interesting way of
    modeling a time series because it is a rare instance of unsupervised learning
    in time series analysis, meaning there is no labeled correct answer against which
    to train. An HMM is motivated by an intuition similar to what we used when experimenting
    with the Kalman filter earlier in this chapter, namely the idea that the variables
    we are able to observe may not be the most descriptive variables of the system.
    As with the Kalman filter applied to a linear Gaussian model, we posit the idea
    that the process has a state, and our observations give information about this
    state. And again, as before, we need to have some opinion as to how the state
    variables influence what we can observe. In the case of an HMM, what we posit
    is that the process is a nonlinear one characterized by jumps between discrete
    states.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 隐马尔可夫模型（Hidden Markov Models，HMMs）是一种特别有用和有趣的时间序列建模方法，因为它是时间序列分析中无监督学习的一个罕见实例，意味着没有标记的正确答案可以用来训练。HMM受到与本章早期实验卡尔曼滤波器时类似的直觉驱使，即我们能够观察到的变量可能不是系统中最具描述性的变量。就像卡尔曼滤波器应用于线性高斯模型时一样，我们假设该过程具有状态，并且我们的观察结果提供关于此状态的信息。同样，我们需要对状态变量如何影响我们能观察到的内容有一些看法。在HMM的情况下，我们假设该过程是一个非线性过程，其特征是在离散状态之间跳跃。
- en: How the Model Works
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型工作原理
- en: An HMM posits a system in which there are states that are not directly observable.
    The system is a Markov process, which means that it is “memoryless” in the sense
    that the probabilities of future events can be fully calculated given only the
    system’s current state. That is, knowing the system’s current state and its previous
    states is no more useful than simply knowing the system’s current state.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: HMM假设存在一些不直接可观察的状态。该系统是马尔可夫过程，这意味着仅通过系统的当前状态可以完全计算未来事件的概率。也就是说，知道系统的当前状态及其先前状态并不比仅仅知道系统的当前状态更有用。
- en: 'Markov processes are often described in terms of matrices. For example, suppose
    there was a system that fluctuated between state A and state B. When in either
    state, the system was statistically more likely to remain in the same state than
    to flip to the other state at any distinct time step. One such system would be
    described by the following matrix:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 马尔可夫过程通常用矩阵来描述。例如，假设有一个在A状态和B状态之间波动的系统。在任一状态下，该系统统计上更有可能保持在相同状态，而不是在任何不同的时间步骤翻转到另一状态。一个这样的系统可以用以下矩阵描述：
- en: '|  | A | B |'
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  | A | B |'
- en: '| A | 0.7 | 0.3 |'
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| A | 0.7 | 0.3 |'
- en: '| B | 0.2 | 0.8 |'
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| B | 0.2 | 0.8 |'
- en: Let’s imagine that our system is in state A, namely (1, 0). (State B would be
    (0, 1).) In such a case, the probability that the system would remain in state
    A is 0.7, whereas the probability that the system would flip is 0.3\. We don’t
    need to know what states the system was in before its most recent moment in time.
    This is what it means to be a Markov process.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的系统处于A状态，即(1, 0)。在这种情况下，系统保持在A状态的概率为0.7，而系统翻转的概率为0.3。我们不需要知道系统在其最近时刻之前处于什么状态。这就是马尔可夫过程的含义。
- en: A Hidden Markov Model represents the same kind of system, except that we are
    not able to directly infer the state of the system from our observations. Instead,
    our observations offer clues as to the state of the system (see [Figure 7-4](#fig-0704)).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 隐马尔可夫模型表示的是同类系统，不同的是我们不能直接从观察中推断出系统的状态。相反，我们的观察提供了关于系统状态的线索（参见[图7-4](#fig-0704)）。
- en: '![](assets/ptsa_0704.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ptsa_0704.png)'
- en: Figure 7-4\. The process for an HMM. The actual states of the system at a given
    time are represented by x(t), whereas the observable data at a given time is represented
    by the y(t). Only x(t) is relevant to thinking about y(t). In other words, x(t
    − 1) offers no additional information to predict y(t) if we know x(t). Likewise,
    only x(t) has any bearing for predicting x(t + 1) and there is no additional information
    from knowing x(t – 1). This is the Markov aspect of the system.
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-4\. HMM的过程。在特定时间点系统的实际状态由x(t)表示，而在特定时间点可观察的数据由y(t)表示。仅x(t)与思考y(t)相关。换句话说，如果我们知道x(t)，则x(t
    − 1)不提供预测y(t)的任何额外信息。同样，仅x(t)与预测x(t + 1)有关，而知道x(t – 1)则不提供任何额外信息。这是系统的马尔可夫特性。
- en: Note that for realistic applications, the states will usually produce outputs
    that overlap, so that it is not 100% clear what state is producing output. For
    example, we are going to apply an HMM to data that looks like [Figure 7-5](#fig-0705).
    This is data simulated from four states, but it is not obvious from a simple visual
    inspection of the time series how many states there are, what their divisions
    are, or where the system transitions between states.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于实际应用，状态通常会产生互相重叠的输出，因此不清楚哪个状态产生了输出的情况并不罕见。例如，我们将会将HMM应用于类似于[图7-5](#fig-0705)的数据。这些数据是从四个状态模拟得到的，但是仅通过简单的视觉检查时间序列，并不明显有多少个状态，它们的划分在哪里，或者系统何时从一个状态转换到另一个状态。
- en: '![](assets/ptsa_0705.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/ptsa_0705.png)'
- en: Figure 7-5\. This time series was simulated with four states, but it’s not clear
    from a visual observation that there are four states, nor is it clear where one
    state ends and another begins.
  id: totrans-98
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-5\. 这个时间序列是用四个状态模拟的，但从视觉上观察并不清楚是否有四个状态，也不清楚一个状态何时结束以及另一个状态何时开始。
- en: 'Some examples of real-life use cases of HMMs are:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: HMM的一些现实应用示例包括：
- en: '[Identifying regime shifts in the financial markets](https://perma.cc/JRT2-ZDVJ)'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[识别金融市场中的制度转变](https://perma.cc/JRT2-ZDVJ)'
- en: '[Classifying, predicting, and correcting DNA sequencing information](https://perma.cc/4V4A-53TZ)'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[DNA测序信息的分类、预测和校正](https://perma.cc/4V4A-53TZ)'
- en: '[Recognizing stages of sleep as reflected in ECG data](https://perma.cc/G37Y-XBQH)'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[通过ECG数据反映的睡眠阶段识别](https://perma.cc/G37Y-XBQH)'
- en: How We Fit the Model
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们如何拟合模型
- en: 'We are positing that there is a state we cannot measure directly, and there
    is no way to get a demonstrably correct answer in many of the data sets where
    we could apply this technique. So how can this algorithm identify hidden states
    without knowing anything about them a priori? The answer is: iteratively. There
    is no magic bullet for deriving the most probable sequence of hidden states to
    explain the observations, but it is possible to edge our way toward an estimation
    once we have fully specified the system.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设存在一个无法直接测量的状态，并且在许多可以应用这种技术的数据集中，没有办法得到一个可以证明正确的答案。那么这种算法如何在不事先了解任何信息的情况下识别隐藏状态？答案是：迭代。没有一个万能方法能够推导出解释观察到的最可能的隐藏状态序列，但是一旦我们完全指定了系统，就可以逐步逼近一个估计。
- en: 'In an HMM, we posit that the system is fully described with the following information:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个HMM中，我们假设系统完全由以下信息描述：
- en: 'The *transition probability* of going from *x(t)* to *x*(*t*) + 1\. This is
    equivalent to specifying a matrix like the one just mentioned: transitioning between
    states A and B. The size of the matrix would depend on the number of hypothesized
    states.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 *x(t)* 转移到 *x*(*t*) + 1 的*转移概率*。这等效于指定一个类似刚才提到的矩阵：在状态A和B之间转换。矩阵的大小取决于假设状态的数量。
- en: The *emission probability*, or the probability of observation *y(t)* given *x(t)*.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*发射概率*，即给定 *x(t)* 后观察 *y(t)* 的概率。'
- en: The initial state of the system.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统的初始状态。
- en: 'More concretely, here is a listing of the variables needed to characterize
    and fit an HMM process:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地，以下是用于描述和拟合HMM过程所需的变量列表：
- en: '*Q* = *q*[1], *q*[2], …*q[N]* the distinct states of the system'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Q* = *q*[1], *q*[2], …*q[N]* 系统的不同状态'
- en: '*A* = *a[i,j]* = *a*[1,1], *a*[1,2], ...*a[N,N]* the transition probability
    matrix indicating the transition at any given time step of changing from state
    i to state j'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*A* = *a[i,j]* = *a*[1,1], *a*[1,2], ...*a[N,N]* 转移概率矩阵，指示在任何给定时间步骤中从状态i转移到状态j的转移概率'
- en: '*O* = *o*[1], *o*[2], …*o[T]* a sequence of observations sampled from this
    process in order, that is a time series of observations'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*O* = *o*[1], *o*[2], …*o[T]* 从这个过程中按顺序抽样得到的一系列观测值，即观测序列的时间序列'
- en: '*b[i(ot)]* indicating the emission probabilities, that is the probabilities
    of seeing a given observation value, *o[t]* if the state is *q[i]*'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*b[i(ot)]* 表示发射概率，即在状态为 *q[i]* 时观察到给定观察值 *o[t]* 的概率'
- en: '*p* = *p*[1], *p*[2], …*p[N]*, the initial probability distributions, namely
    the probability that the system will start in state *q*[1], *q*[2], …*q[N]*, respectively'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*p* = *p*[1], *p*[2], …*p[N]*，初始概率分布，即系统以状态 *q*[1], *q*[2], …*q[N]* 开始的概率'
- en: However, with real data generally none of these variables are known. All that
    is known is the actual sequence of observables *y*[1], *y*[2], …*y[t]*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于实际数据，一般都不知道这些变量中的任何一个。已知的只是实际可观测序列 *y*[1], *y*[2], …*y[t]*。
- en: Baum Welch algorithm
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Baum Welch算法
- en: 'In estimating the parameters of a Hidden Markov Model, we use the *Baum Welch
    algorithm*. This guides us in our complex task to estimate the values of all the
    parameters, as they were detailed in the previous section. Our task is multifold.
    We are seeking to:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在估计隐马尔可夫模型的参数时，我们使用*Baum Welch算法*。这指导我们在复杂任务中估计所有参数的值，就像前面章节详细描述的那样。我们的任务是多方面的。我们正在寻求：
- en: Identify the distinct emission probabilities for each possible hidden state
    and identify the transition probabilities from each possible hidden state to each
    other possible hidden state. For this we use the Baum-Welch algorithm.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定每个可能隐藏状态的不同发射概率，并确定从每个可能隐藏状态到每个其他可能隐藏状态的转移概率。我们使用Baum-Welch算法。
- en: Identify the most likely hidden state for each time step given the full history
    of observations. For this we use the Viterbi algorithm (described shortly).
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据观测历史的完整信息确定每个时间步的最可能的隐藏状态。我们使用维特比算法（稍后描述）。
- en: These are two related tasks, and each one is difficult and computationally taxing.
    What’s more, they are dependent. In the case of two interrelated tasks, parameter
    estimation and likelihood maximization, we can use the *expectation maximization*
    algorithm to iterate between these two steps until an acceptable solution is found.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是两个相关的任务，每个任务都很困难且计算量大。更重要的是，它们是相互依赖的。在两个相互关联的任务——参数估计和似然最大化——的情况下，我们可以使用*期望最大化算法*在这两个步骤之间迭代，直到找到一个可接受的解决方案。
- en: To apply the Baum Welch algorithm, the first step is to specify the likelihood
    function, which is the probability of observing a given sequence given the hypothesized
    parameters. In our case, the hypothesized parameters would be the mathematical
    parameters per postulated state.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用Baum Welch算法，第一步是指定似然函数，即给定假设参数的情况下观察到给定序列的概率。在我们的情况下，假设的参数将是假设状态每个数学参数。
- en: For example, if we assumed the states produced Gaussian outputs with distinct
    means and standard deviations of the observed values that depended on the state,
    and if we assumed a two-state model, we might describe the model in terms of μ[1],
    σ[1], μ[2], and σ[2], with μ[*u*=*i*] indicating the *i*th state’s mean and σ*[i]*
    indicating the *i*th state’s standard deviation. These could describe the emission
    probabilities, and we collectively denote them as θ. We could also posit the state
    sequence as *x*[1], *x*[2], …*x[t]* (I’ll summarize this as *X[t]* for shorthand),
    which we were not able to observe, but imagine for the moment that we could.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们假设状态产生具有不同均值和标准差的高斯输出，并且这些值取决于状态，并假设一个双状态模型，我们可能描述模型为μ[1], σ[1], μ[2],
    和 σ[2]，其中μ[*u*=*i*]表示第*i*个状态的均值，σ*[i]*表示第*i*个状态的标准差。这些可以描述发射概率，我们统称为θ。我们还可以将状态序列假设为*x*[1],
    *x*[2], …*x[t]*（我将其简记为*X[t]*），尽管我们无法观察到，但暂且假定我们能。
- en: Then the likelihood function would describe the likelihood of observing the
    sequence we had observed given the parameters of the emission probability (that
    is, the probability of a given observation given a specific state) and the sequence
    of hidden states as the integral over all possible *X[t]* of *p*(*y*[1], *y*[2],
    …*y[t]* |μ[1], σ[1], μ[2], σ[2], …μ[*N*], σ[*Nt*]) = *p*(*y*[1], *y*[2], …*y[t]*
    |μ[1], σ[1], μ[2], σ[2], …μ[*N*], σ[*N*]).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，似然函数将描述观察到的序列的可能性，给定发射概率的参数（即给定特定状态时观察到的给定观测的概率）和隐藏状态序列作为所有可能的*X[t]*的积分。*p*(*y*[1],
    *y*[2], …*y[t]* |μ[1], σ[1], μ[2], σ[2], …μ[*N*], σ[*Nt*]) = *p*(*y*[1], *y*[2],
    …*y[t]* |μ[1], σ[1], μ[2], σ[2], …μ[*N*], σ[*N*])。
- en: 'However, this is a difficult problem for several reasons, including the fact
    that the complexity grows exponentially with the number of time steps, meaning
    that an exhaustive grid search is not realistic. So, we simplify the task by applying
    the EM algorithm as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于复杂性随时间步数呈指数增长，意味着详尽的网格搜索并不现实。因此，我们通过以下方式简化任务，应用EM算法：
- en: Randomly initialize the emission probability variables.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机初始化发射概率变量。
- en: Compute the probability of each possible *X[t]*, assuming the emission probability
    values.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算每个可能*X[t]*的概率，假设了发射概率值。
- en: Use these values of *X[t]* to generate a better estimate of the emission probability
    variables.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这些*X[t]*的值生成发射概率变量的更好估计。
- en: Repeat steps 2 and 3 until convergence is reached.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤2和3直到收敛。
- en: What this means, more informally, is that in the event of positing (at random)
    two distributions, we would then look at each time step and determine the probability
    that for each time step a particular state was occupied (e.g., at time step *t*
    what was the probability of state A? of state B?) Once we had then assigned a
    putative state to each time step, we would use those labels to re-estimate the
    emission probabilities (zeroing in on a better mean and standard deviation for
    the state). Then we would repeat the process again, using the newly updated emission
    probability variables to improve our estimate of the *X[t]* trajectory.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，更不正式地说，如果随机提出两个分布，我们将查看每个时间步长，并确定每个时间步长中特定状态被占据的概率（例如，在时间步长*t*时，状态A的概率是多少？状态B呢？）一旦我们为每个时间步长分配了假设状态，我们将使用这些标签重新估计发射概率（聚焦于状态的更好均值和标准差）。然后，我们会再次重复这个过程，使用新更新的发射概率变量来改进我们对*X[t]*轨迹的估计。
- en: One important point to remember about such uses of the EM algorithm is that
    you are not guaranteed to find a globally optimal set of parameters. For this
    reason it’s worth running many fits to see what the global consensus is across
    numerous initializations. It’s also important to remember that a fit will require
    a burn-in period, the appropriate length of which will depend on the details of
    your data and model.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 关于EM算法的一个重要点要记住的是，不能保证找到全局最优的参数集。因此，值得运行多次适应以查看多次初始化时的全局共识。还重要的是要记住，适应会需要一个烧入期，其适当长度将取决于您的数据和模型的细节。
- en: Viterbi algorithm
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Viterbi算法
- en: Once the parameters of an HMM process have been estimated, as via the Baum Welch
    algorithm, the next question of interest is what the most likely series of underlying
    states was given the measured time series of observable values.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦通过Baum Welch算法估计出HMM过程的参数，下一个感兴趣的问题是，在给定可观察值时间序列的情况下，最可能的潜在状态序列是什么。
- en: Unlike the Baum Welch algorithm, the Viterbi algorithm is guaranteed to provide
    you with the best solution to the question you are asking. This is because it
    is a dynamic programming algorithm designed to fully and efficiently explore the
    range of possible fits by saving the solutions to portions of a path so that as
    the path is lengthened there’s no need to recompute all possible paths for all
    path lengths (see [Figure 7-6](#fig-07new06)).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与Baum Welch算法不同，Viterbi算法保证为您提供您所询问问题的最佳解决方案。这是因为它是一种动态规划算法，旨在通过保存路径的部分解决方案全面而有效地探索可能的拟合范围，因此随着路径长度的增加，无需重新计算所有路径的所有路径长度（参见[图7-6](#fig-07new06)）。
- en: '![](assets/ptsa_0706.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ptsa_0706.png)'
- en: Figure 7-6\. The Viterbi algorithm searches all possible paths that could explain
    a given observed time series, where a path indicates which state was occupied
    at each time step.
  id: totrans-135
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-6. Viterbi算法搜索所有可能解释给定观察时间序列的路径，其中路径表示每个时间步长占据的状态。
- en: Fitting an HMM in Code
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在代码中拟合HMM
- en: 'While the HMM fitting process is very complicated, it is implemented in a number
    of packages in R. Here we will work with the `depmixS4` package. First, we need
    to formulate an appropriate time series. We do that with the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然HMM拟合过程非常复杂，但它在R语言的多个软件包中实现。在这里，我们将使用`depmixS4`软件包。首先，我们需要制定一个适当的时间序列。我们可以通过以下代码来做到这一点：
- en: '[PRE5]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code we use a stock-market-inspired example, with bull, bear,
    neutral, and panic modes. A random number of days for a state to persist is selected,
    as are variables describing the emission probability distribution for each state
    (that is, the `_mu` and `_sd` variables, which indicate what kind of values we
    expect to see measured given a particular state).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们使用了一个受股市启发的例子，其中包含牛市、熊市、中性和恐慌模式。选择状态持续的随机天数，以及描述每个状态的发射概率分布的变量（即，_mu和_sd变量，它们指示给定特定状态时我们期望看到的测量值类型）。
- en: 'We can get a sense of what our generated time series looks like, and the frequency
    of each state, by seeing how many days in the sample correspond to each `true.mean`,
    which is the variable we are using to track state:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看在样本中有多少天对应于每个`true.mean`，我们可以了解生成的时间序列的外观和每个状态的频率：
- en: '[PRE6]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Catastrophe! Although we intended to include four states in the simulated series,
    only three are included. This is likely because the fourth state had a very low
    probability of inclusion (0.02). We see that the least probable state wasn’t even
    selected for inclusion in the series. We couldn’t always know that for a given
    time series—that not all possible states were actually included in a time series—which
    highlights part of why it’s difficult to fit HMMs and why things can be somewhat
    unfair to the algorithm. Nonetheless, we will move forward with the analysis specifying
    four groups, to see what this gives.^([3](ch07.html#idm45576033909992))
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 灾难！虽然我们打算在模拟系列中包含四个状态，但只包含了三个。这可能是因为第四个状态被包含的概率非常低（0.02）。我们看到，最不可能的状态甚至没有被选入系列。对于给定的时间序列，我们并不能总是知道并非所有可能的状态实际上都包含在时间序列中，这也说明了为什么拟合隐马尔可夫模型困难，并且对算法有些不公平。尽管如此，我们将继续进行分析，指定四个组，看看会得到什么结果。^([3](ch07.html#idm45576033909992))
- en: We still need to fit an HMM. The resulting HMM will provide a time series of
    posterior probabilities for each state for as many states as we indicate are desired.
    Consistent with the earlier description of the EM algorithm, nothing more than
    the number of putative states needs to be specified. The rest will be gradually
    determined via an iterative back-and-forth process.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍需要拟合一个隐马尔可夫模型（HMM）。所得的HMM将为我们提供每个状态的后验概率时间序列，数量与我们指定的状态数量相符。与EM算法的早期描述一致，只需指定潜在状态的数量。其余将通过逐步迭代的前后过程逐渐确定。
- en: 'As is often the case, with the right package, the difficult bit of the analysis
    is actually quite easy in terms of the amount of code that needs to be written.
    In this case we use the `depmixS4^([4](ch07.html#idm45576033901544))` package
    in R. The model is fit in two steps. First, it is specified with the `depmix()`
    function, which indicates the expected distribution, the number of states, and
    the input data to be used in fitting. Then the model is fit via the `fit` function,
    which takes the model specification as its input. Finally, to generate the posterior
    distribution of the state labels given the fit to the data, we use the `posterior()`
    function. At this point the model itself has already been fit, so this is a separate
    task to label the data now that the parameters describing the state distributions
    and transition likelihoods have been estimated:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，通过正确的软件包，分析中的难点实际上在需要编写的代码量方面非常简单。在这种情况下，我们使用R中的`depmixS4^([4](ch07.html#idm45576033901544))`包。该模型分为两步进行。首先，使用`depmix()`函数进行规定，指示预期分布、状态数量和用于拟合的输入数据。然后通过`fit`函数拟合模型，该函数以模型规范作为其输入。最后，为了生成状态标签的后验分布，我们使用`posterior()`函数。此时模型本身已经被拟合，因此这是一个将数据标记化的独立任务，现在可以估计状态分布和转移概率参数：
- en: '[PRE7]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here we produce an `hmm.model` where we indicate the observable is the `returns`
    vector. We also indicate the number of states (`4`) and that the emission probabilities
    come in a Gaussian distribution via our specification for the `family` parameter.
    We fit the model via a `fit()` function and then calculate the posterior probabilities
    with the `posterior()` function. The posterior probabilities give us the probability
    of a given state at a given time for the model parameters we have determined with
    the fitting process.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们生成一个`hmm.model`，指定可观察向量为`returns`。我们还指定状态数量为`4`，并通过`family`参数的规定说明发射概率遵循高斯分布。我们通过`fit()`函数拟合模型，然后使用`posterior()`函数计算后验概率。后验概率告诉我们在给定时间内，对于我们通过拟合过程确定的模型参数，某个状态的概率。
- en: 'Now we can visualize the states along with the measured values as follows (see
    [Figure 7-7](#fig-0706)):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以按如下方式可视化状态及其测量值（参见[图 7-7](#fig-0706)）：
- en: '[PRE8]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![](assets/ptsa_0707.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ptsa_0707.png)'
- en: Figure 7-7\. In this plot the background indicates a distinct state, and the
    solid black line depicts the actual values. The vertical white line sort of objects
    are actually very narrow slices that represent the times when the process is estimated
    to be in what turns out to be the rarest of the four states.
  id: totrans-150
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-7\. 在此图中，背景表示不同的状态，实线黑色线表示实际值。垂直白线显示的物体实际上是非常窄的切片，代表被估计处于四个状态中最罕见的状态的时间。
- en: 'We can access information about the hypothesized distributional parameters
    the model determined via its attributes. As we review this, let’s keep in mind
    our original data generation parameters:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看模型通过其属性确定的假设分布参数时，我们可以获取有关我们原始数据生成参数的信息。
- en: '[PRE9]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we were going to match (remembering that the panic regime didn’t make it
    into the data), it would look like, of the states actually present in the data,
    the following groups roughly correlated:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要匹配（记住恐慌状态没有出现在数据中），它会看起来像，实际上在数据中存在的状态组大致相关：
- en: '[PRE10]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: One possible reason the fit doesn’t line up better with our baseline hidden
    states is that we didn’t use a proper transition matrix, whereas the model used
    one for a fit. Our transitions between states were not properly Markovian, and
    this could impact the fit. Additionally, we fit to a relatively short time series
    with few transitions between states, whereas HMMs will perform better on longer
    time series with more opportunities to observe/infer state transitions. I’d recommend
    coming up with more realistic synthetic data to test a proposed HMM when you are
    experimenting with this technique and preparing to fit it to real data. Remember,
    in most cases of real data you are positing an unobservable state, so you want
    to think about the limits of the model performance in a more controlled setting
    (with synthetic data) before setting yourself up for more ambitious projects.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的拟合结果与我们的基线隐藏状态不太吻合，可能的原因之一是我们没有使用适当的转移矩阵，而模型用了一个适合拟合的转移矩阵。我们状态之间的转换不是真正的马尔可夫过程，这可能会影响拟合效果。此外，我们拟合的是一个相对较短的时间序列，状态之间的转换较少，而HMM在更长的时间序列上表现更好，有更多的机会观察/推断状态转换。当你在尝试这种技术并准备将其拟合到真实数据时，我建议你想出更加现实的合成数据来测试提议的HMM。请记住，在大多数真实数据情况下，你是在假设一个不可观测的状态，因此在更受控制的环境（使用合成数据）中思考模型性能的限制，然后再为更有野心的项目做准备。
- en: HMMs are apt for analyzing many kinds of data. HMMs have been used to model
    whether a financial market is in a growth or recession phase, determine what stage
    folding a protein within a cell is in, and describe human motion (before the arrival
    of deep learning). These models continue to be useful, more often for understanding
    the dynamics of a system than for making predictions. Also, HMMs provide more
    than just a point estimate or forecast. Finally, we can inject prior knowledge
    or beliefs into our model, such as by specifying the number of states used to
    fit our HMM. In this way, we reap the benefits of statistical methods but also
    have parameters to parameterize our prior knowledge about the system.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: HMM非常适合分析许多种类的数据。HMM已被用来模拟金融市场是处于增长还是衰退阶段，确定细胞内蛋白质折叠的阶段，以及描述人体运动（在深度学习出现之前）。这些模型继续是有用的，更多用于理解系统动态而非预测。此外，HMM提供的不仅仅是一个点估计或预测。最后，我们可以将先验知识或信念注入到我们的模型中，例如指定用于拟合我们的HMM的状态数量。通过这种方式，我们既可以利用统计方法的好处，又可以对系统的先验知识进行参数化。
- en: The mathematics and computation of HMMs are quite interesting and approachable.
    You can learn a lot of accessible programming techniques and numerical optimization
    algorithms by looking into the most common ways that HMMs are fit to data. You’ll
    also learn about dynamic programming techniques, which are helpful to a data scientist
    or a software engineer.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 隐马尔可夫模型（HMM）的数学和计算非常有趣且易于理解。通过研究HMM拟合数据的最常见方法，你可以学习许多易于理解的编程技术和数值优化算法。你还将学习到动态规划技术，这对数据科学家或软件工程师非常有帮助。
- en: 'As with a Kalman filter, HMMs can be used for a variety of tasks. In fact,
    the variety of inference problems related to HMM systems is even more complex
    due to the increased complexity of discrete states, each with its own emission
    probability. Some of the inference tasks you may face when using an HMM include:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与卡尔曼滤波器一样，HMM可用于各种任务。事实上，由于离散状态的增加复杂性，与HMM系统相关的推断问题的种类更加复杂。当使用HMM时，你可能会面临一些推断任务，其中包括：
- en: Determining the most likely description of the states producing a series of
    observations. This involves estimating the emission probabilities of these states
    as well as the transmission matrix that describes how likely one state is to lead
    to another. We did this, although we did not look explicitly at the transition
    probabilities.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定产生一系列观察结果的状态的最可能描述。这涉及估计这些状态的发射概率以及描述一个状态可能导致另一个状态的传输矩阵。我们做到了这一点，尽管我们没有明确看待过转移概率。
- en: Determining the most likely sequence of states given a series of observations
    and a description of the states and their emission and transition probabilities.
    We did this as well as part of the previous task. This is sometimes referred to
    as the “most likely explanation” and is commonly calculated with the Viterbi algorithm.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定在给定一系列观察和状态描述及其发射和转移概率的情况下，最可能的状态序列。我们在前一任务中也这样做过。这有时被称为“最可能的解释”，通常使用维特比算法计算。
- en: Filtering and smoothing. In this situation, filtering would correspond to estimating
    the hidden state of the most recent time step given the most recent observation.
    Smoothing would correspond to determining the most likely distribution of the
    hidden state in a particular time step given observations before, during, and
    after that time step.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤和平滑。在这种情况下，过滤将对应于估计最近观测的最新时间步的隐藏状态。平滑将对应于确定在特定时间步给定之前、期间和之后的观察时，隐藏状态的最可能分布。
- en: Bayesian Structural Time Series
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 贝叶斯结构时间序列
- en: Bayesian structural time series (BSTS) are related to the linear Gaussian model
    we worked through with Kalman filtering earlier. The main difference is that Bayesian
    structural time series provide a way to use preexisting components to build more
    complex models that can reflect known facts or interesting hypotheses about a
    system. We can then design the structure, use robust fitting techniques to estimate
    parameters for the built model in the case of our data, and see whether the model
    does a good job of describing and predicting a system’s behavior.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 贝叶斯结构时间序列（BSTS）与我们先前通过卡尔曼滤波处理的线性高斯模型相关。主要区别在于，贝叶斯结构时间序列提供了一种使用预先存在的组件构建更复杂模型的方式，可以反映关于系统已知事实或有趣假设的已知事实。然后我们设计结构，使用鲁棒拟合技术来估计我们数据模型的参数，并查看该模型是否能很好地描述和预测系统的行为。
- en: The mathematics of BSTS models is fairly complicated and computationally taxing
    compared to the linear Gaussian model we covered in our discussion of the Kalman
    filter. For this reason, we’ll stick to a general overview and then apply the
    code.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在卡尔曼滤波讨论中涵盖的线性高斯模型相比，BSTS 模型的数学和计算任务较为复杂。因此，我们将坚持概述一般情况，然后应用代码。
- en: 'There are four steps to fitting a BSTS model, carried out in the following
    order:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 拟合 BSTS 模型有四个步骤，按以下顺序进行：
- en: A structural model is defined, including specification of priors.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义了一个结构模型，包括先验的规定。
- en: A Kalman filter is applied to update estimates of state based on observed data.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用卡尔曼滤波器来更新基于观测数据的状态估计。
- en: The spike-and-slab method is used to perform variable selection within the structural
    model.^([5](ch07.html#idm45576033596520))
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于在结构模型内执行变量选择的尖峰与板条方法^([5](ch07.html#idm45576033596520))。
- en: Bayesian model averaging is applied to combine results for the purpose of generating
    a forecast.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 贝叶斯模型平均应用于合并结果以生成预测。
- en: In the next example we will focus only on steps 1 and 2, wherein we define a
    flexible model out of preexisting modular components and then use this to fit
    our data with a Bayesian method that updates parameter estimation as time passes.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将仅关注步骤 1 和 2，其中我们通过预先存在的模块化组件定义一个灵活的模型，然后使用这个模型通过贝叶斯方法来拟合我们的数据，随着时间的推移更新参数估计。
- en: Code for bsts
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: bsts 的代码
- en: Here we use a popular and powerful BSTS package from Google, `bsts`, and an
    open data set from [OpenEI.org](https://openei.org).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了来自谷歌的流行和强大的 BSTS 软件包 `bsts`，以及来自[OpenEI.org](https://openei.org)的开放数据集。
- en: 'We first plot the data to get a sense of what we are trying to model ([Figure 7-8](#fig-0707)):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先绘制数据以了解我们试图建模的内容（[图 7-8](#fig-0707)）：
- en: '[PRE11]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![](assets/ptsa_0708.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ptsa_0708.png)'
- en: Figure 7-8\. The full series we fit (two thousand consecutive hourly measurements)
    in the upper plot and a shorter, more understandable subset of the data in the
    lower plot. The plot makes more sense once we look at it in a way that makes the
    daily patterns evident.
  id: totrans-176
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-8\. 我们在上图中拟合的完整系列（两千个连续的小时测量），以及下图中更短、更易理解的数据子集。在查看日常模式时，图表更有意义。
- en: 'Looking at our data gives us a sense of how to model. We can see that there
    is certainly a daily pattern, and there may even be a day-of-week pattern. These
    reflect the seasonal behavior we will describe in our model. We also want to allow
    for a trend in the data given the nonstationary behavior we see when we plot the
    whole data in the upper panel of [Figure 7-8](#fig-0707):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看我们的数据，我们能够了解如何建模。我们可以看到肯定存在每日模式，甚至可能存在一周中每日的模式。这些反映了我们将在模型中描述的季节性行为。此外，考虑到我们在图7-8上部面板中绘制整体数据时看到的非平稳行为，我们还希望允许数据中的趋势。
- en: '[PRE12]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The local linear trend in this model assumes that both the mean and slope of
    a trend in the data follow a random walk.^([6](ch07.html#idm45576033460264))
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此模型中的局部线性趋势假设数据中的趋势的均值和斜率都遵循随机游走。^([6](ch07.html#idm45576033460264))
- en: The seasonal component of the model takes two arguments, one indicating the
    number of distinct seasons and one indicating the duration of the season. In the
    first seasonal component we add, which reflects a daily cycle, we want one season
    for each hour of the day, and each season lasts only the one hour. In the second
    seasonal component we add, which reflects a weekly cycle, we want one season for
    each day of the week and we want each season to last 24 hours.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 模型的季节性组件有两个参数，一个表示不同季节的数量，另一个表示季节的持续时间。在第一个季节性组件中，我们添加一个反映每天循环的组件，每小时一个季节，每个季节持续一小时。在第二个季节性组件中，我们添加一个反映每周循环的组件，每天一个季节，每个季节持续24小时。
- en: While you might wonder whether we are truly starting at 12:01 am on Monday (or
    however we want to define the week), being consistent is more important than is
    whether a seasonal label of day 1 exactly corresponds with a Monday. In the recurrent
    pattern we see here, it seems like any way of chopping the data into 24 hours
    would likely be acceptable for seasonality analysis.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可能会想知道我们是否确实从星期一的凌晨12:01开始（或者我们希望如何定义一周），但保持一致性比确切的一天季节性标签是否与星期一完全对应更重要。在这里看到的循环模式中，似乎任何将数据分割为24小时的方式都可能适用于季节性分析。
- en: 'The most taxing part of the code, computationally, is shown next. The beauty
    of the `bsts` package is that we are able to run a number of Markov Chain Monte
    Carlo (MCMC) computations of the posterior:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中最耗费计算资源的部分如下所示。`bsts` 包的优势在于我们能够运行多个马尔可夫链蒙特卡洛（MCMC）后验计算：
- en: '[PRE13]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can also inspect the seasonal components. For example, we inspect the day
    of the week seasonal component like so (see Figures [7-9](#fig-0708) and [7-10](#fig-0709)):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以检查季节性组件。例如，我们可以像这样检查一周中每天的季节性组件（参见图7-9和图7-10）：
- en: '[PRE14]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![](assets/ptsa_0709.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/ptsa_0709.png)'
- en: Figure 7-9\. The day of the week seasons, which show that there is a difference
    in different days of the week. It also shows that the day of the week parameter
    distributions are stable over time for each day of the week.
  id: totrans-187
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-9。显示一周中各天的季节性，显示不同天的差异。还显示了每天的参数分布在时间上保持稳定。
- en: '![](assets/ptsa_0710.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/ptsa_0710.png)'
- en: Figure 7-10\. Distributions of contributions from the trend of the data as well
    as the daily and day of week seasonal components. If you sum these three components,
    you will get the value for the prediction.
  id: totrans-189
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-10。数据趋势以及每日和每周季节性组件的贡献分布。如果将这三个组件相加，就可以得到预测值。
- en: The day of the week seasonal component shows great stability, whereas the hour
    of the day seasonality shown in the middle plot in [Figure 7-10](#fig-0709) tends
    to show trends over time, likely relating to changing daylight hours. In [Figure 7-10](#fig-0709)
    we also see the parameter fit for our local linear trend, which shows a decreasing
    pattern in electricity demand overall.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一周中每天的季节性组件显示出很高的稳定性，而在图7-10中间绘图中显示的每天小时季节性则倾向于显示随时间变化的趋势，可能与白昼时间的变化相关。在图7-10中，我们还可以看到局部线性趋势的参数拟合，显示出整体电力需求的下降趋势。
- en: 'Finally, we forecast, complete with a full graph of the posterior distribution
    of the predictions into the future (see [Figure 7-11](#fig-0710)). Notice that
    we have the flexibility up until the end of this modeling process to indicate
    how many time horizons we want to predict forward. Remember this is hourly data,
    so predicting 24 time horizons forward may seem quite ambitious but amounts to
    only one day. We also indicate that we want to see the 72 time periods prior to
    the prediction for context:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们预测，包括未来预测的完整后验分布图（见[图7-11](#fig-0710)）。请注意，我们在此建模过程结束前具有灵活性，可以指定我们希望向前预测多少个时间段。请记住，这是小时数据，因此向前预测24个时间段可能看起来很有野心，但只相当于一天。我们还指出，我们希望看到预测前的72个时间段以供参考：
- en: '[PRE15]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![](assets/ptsa_0711.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ptsa_0711.png)'
- en: Figure 7-11\. The last 72 hours in our data combined with a forecast for the
    next 24 hours as well as 5% and 95% quantile boundaries on the forecasts. Notice
    that the distribution of the forecast grows more spread out as we forecast further
    into the future.
  id: totrans-194
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-11。我们的数据最后72小时与未来24小时的预测，以及预测的5%和95%分位数边界。请注意，随着我们预测时间越来越远，预测的分布也变得更加散布。
- en: 'There is a fair amount of optionality in the `bsts` package and in Bayesian
    structural time series modeling that we haven’t even taken advantage of yet, namely:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `bsts` 软件包和贝叶斯结构时间序列建模中，我们甚至还未利用的可选功能有相当多。
- en: We did not specify nonstandard priors.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们没有指定非标准先验。
- en: We did not use the spike-and-slab method to select out regressors.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们没有使用尖峰和平板法来选择回归变量。
- en: We did not use Bayesian model averaging.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们没有使用贝叶斯模型平均。
- en: These are all possible to do with the `bsts` package, and you can readily find
    guidance in the documentation.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都可以通过 `bsts` 软件包完成，并且您可以在文档中找到详细指导。
- en: 'We have only scratched the surface in our example of what can be done with
    BSTS. Here are a few other important available options with BSTS:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们只是简单地介绍了BSTS的一些应用。以下是BSTS的其他几个重要选项：
- en: BSTS allow you to inject any kind of prior into your modeling. The standard
    linear Gaussian model we covered when discussing the Kalman filter is just one
    way of injecting a fairly vanilla prior, while BSTS offers many options (for example,
    nonsymmetric priors).
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BSTS 允许您在建模过程中注入任何类型的先验知识。在讨论卡尔曼滤波器时，我们介绍的标准线性高斯模型只是注入了一种相对基础的先验知识的一种方式，而BSTS提供了许多选项（例如，非对称先验）。
- en: BSTS models allow you to perform variable selection.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BSTS 模型允许您进行变量选择。
- en: BSTS models can be combined via Bayesian model averaging, which can help account
    for the uncertainty associated with selecting a model in the first place.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BSTS 模型可以通过贝叶斯模型平均进行组合，这有助于在首次选择模型时考虑与之相关的不确定性。
- en: While we did not make use of these options in our current modeling case, they
    are not difficult to incorporate when using the `bsts` package, and you can find
    many examples online.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在当前的建模案例中没有使用这些选项，但在使用 `bsts` 软件包时，它们并不难集成，并且您可以在网上找到许多示例。
- en: More Resources
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多资源
- en: 'On Kalman filters and linear Gaussian state space models:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于卡尔曼滤波器和线性高斯状态空间模型：
- en: Greg Welch and Gary Bishop, [“An Introduction to the Kalman Filter,”](https://perma.cc/ZCU8-MXEF)
    technical report, University of North Carolina at Chapel Hill, 1995, https://perma.cc/ZCU8-MXEF.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Greg Welch 和 Gary Bishop，《“卡尔曼滤波器介绍”》，北卡罗来纳大学教堂山分校，1995年技术报告，https://perma.cc/ZCU8-MXEF。
- en: This introductory overview of the Kalman filter offers a derivation and matrix-formulation
    of the filter. The introduction also discusses the Extended Kalman Filter, a more
    common filtering in real-life scenarios that can be used for nonlinear processes
    or nonlinear measurement errors.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这篇关于卡尔曼滤波器的介绍性概述提供了滤波器的推导和矩阵形式化。该介绍还讨论了扩展卡尔曼滤波器，在实际场景中更为常见，可用于非线性过程或非线性测量误差。
- en: 'R.E. Kalman, [“A New Approach to Linear Filtering and Prediction Problems,”](https://perma.cc/GNC4-YLEC)
    *Transactions of the ASME—Journal of Basic Engineering* 82, Series D (1960): 35–45,
    https://perma.cc/GNC4-YLEC.'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: R.E. 卡尔曼，《“线性滤波和预测问题的一种新方法”》，《ASME—基础工程杂志》82，D系列（1960年）：35–45，https://perma.cc/GNC4-YLEC。
- en: This 1960 research article is the original introduction of the Kalman filter.
    The mathematics is quite approachable with a basic background in statistics and
    calculus, and this is an interesting read to learn the original motivations for
    the Kalman filter and the intellectual context for its creator.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这篇1960年的研究文章是卡尔曼滤波器的最初介绍。如果具备统计学和微积分的基础，其数学内容是相当容易理解的，读起来很有趣，可以了解卡尔曼滤波器的原始动机及其创造者的智力背景。
- en: R. Labbe, [“Kalman and Bayesian Filters in Python,”](https://perma.cc/CMU5-Y94A)
    GitHub repository, https://perma.cc/CMU5-Y94A.
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: R. Labbe，[“Python中的卡尔曼和贝叶斯滤波器”](https://perma.cc/CMU5-Y94A)，GitHub仓库，https://perma.cc/CMU5-Y94A。
- en: This epic GitHub repository includes dozens of examples of using Kalman filters
    and related techniques of “filtering” more generally. The repository is textbook-like,
    featuring worked examples, a related PDF book, and exercises with solutions.
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个庞大的GitHub仓库包含数十个使用卡尔曼滤波器及相关“过滤”技术的例子。该仓库像教科书一样，提供了详细的案例、相关PDF书籍以及带解答的练习题。
- en: 'Marie Auger-Méthé et al., [“State-Space Models’ Dirty Little Secrets: Even
    Simple Linear Gaussian Models Can Have Estimation Problems,”](https://perma.cc/9D8V-Z7KJ)
    *Scientific Reports* 6, no. 26677 (2016), https://perma.cc/9D8V-Z7KJ.'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Marie Auger-Méthé等，[“状态空间模型的隐秘小秘密：即使是简单的线性高斯模型也可能存在估计问题”](https://perma.cc/9D8V-Z7KJ)，*科学报告*
    6卷，编号26677（2016年），https://perma.cc/9D8V-Z7KJ。
- en: This article highlights a case where even simple linear Gaussian models, such
    as those we used in our discussion of the Kalman filter, are easily prone to extreme
    misspecification, particularly in the case of a measurement error that is large
    relative to the values of a time series. The authors focus on this problem from
    the perspective of ecologists, but the general concern remains valid for a variety
    of data-driven disciplines and offers a counterbalancing view compared to the
    many advantages that are emphasized for this method.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这篇文章突出了一个案例，即使是简单的线性高斯模型（比如我们在卡尔曼滤波器讨论中使用的模型），在面对测量误差远大于时间序列数值的情况下，也很容易发生极端的错误规定化。作者从生态学家的角度探讨了这个问题，但这个一般性问题在各种数据驱动学科中依然具有普遍的重要性，并且提供了与强调该方法的众多优点相比的平衡视角。
- en: 'On Hidden Markov Models:'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于隐马尔可夫模型：
- en: Andrew Moore, [“Hidden Markov Models,”](https://perma.cc/K3HP-28T8) lecture
    notes, School of Computer Science, Carnegie Mellon University, https://perma.cc/K3HP-28T8.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Andrew Moore，[“隐马尔可夫模型”](https://perma.cc/K3HP-28T8)，卡内基梅隆大学计算机科学学院讲义，https://perma.cc/K3HP-28T8。
- en: These comprehensive lecture notes offer an overview of HMMs, complete with illustrations
    of estimation algorithms and examples from robotics of how HMMs are used in real
    applications.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些全面的讲义概述了HMM，包括估计算法的示例和机器人学中HMM在实际应用中的使用情况。
- en: 'Dan Klein, [“Artificial Intelligence: Hidden Markov Model,”](https://perma.cc/V7U4-WPUA)
    lecture notes, University of California Berkeley, https://perma.cc/V7U4-WPUA.'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Dan Klein，[“人工智能：隐马尔可夫模型”](https://perma.cc/V7U4-WPUA)，加州大学伯克利分校讲义，https://perma.cc/V7U4-WPUA。
- en: This is another set of accessible reference notes. These give examples of the
    usefulness of HMMs for digitizing speech and also for developing AI to play strategic
    games.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是另一组易于查阅的参考笔记。其中列举了HMM在语音数字化和发展AI玩策略游戏中的实用示例。
- en: user34790, [“What Is The Difference Between the Forward-Backward and Viterbi
    Algorithms?”](https://perma.cc/QNZ5-U3CN) question posted on Cross Validated,
    StackExchange, July 6, 2012, https://perma.cc/QNZ5-U3CN.
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: user34790，[“前向-后向和维特比算法之间的区别是什么？”](https://perma.cc/QNZ5-U3CN) 在交叉验证StackExchange上发布的问题，2012年7月6日，https://perma.cc/QNZ5-U3CN。
- en: This StackExchange post offers an interesting discussion and outline relating
    to the many estimation algorithms deployed for specific HMM use cases. This post
    will help you get a sense of the ways HMMs can be used to understand time series
    data even if you are not interested in the details of the related modeling algorithms.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这篇StackExchange帖子提供了一个有趣的讨论和大纲，涉及针对特定HMM用例部署的多种估计算法。即使你对相关建模算法的细节不感兴趣，这篇帖子也能帮助你理解HMM如何用于理解时间序列数据的方式。
- en: 'On Bayesian structural time series:'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于贝叶斯结构时间序列：
- en: 'Mark Steel, [“Bayesian Time Series Analysis,”](https://perma.cc/578D-XCVH)
    in *Macroeconometrics and Time Series Analysis*, ed. Steven N. Durlauf and Lawrence
    E. Blume (Basingstoke, UK: Palgrave Macmillan, 2010), 35–45, https://perma.cc/578D-XCVH.'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Mark Steel，[“贝叶斯时间序列分析”](https://perma.cc/578D-XCVH)，收录于*宏观计量经济学与时间序列分析*，编辑Steven
    N. Durlauf和Lawrence E. Blume（英国巴辛斯托克：Palgrave Macmillan，2010年），35–45页，https://perma.cc/578D-XCVH。
- en: This brief read offers a comprehensive overview of different techniques associated
    with Bayesian analysis of time series as well as concise commentary as to the
    strengths and weaknesses of each method.
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这篇简短的阅读提供了关于贝叶斯时间序列分析中不同技术的全面概述，以及对每种方法优劣的简明评论。
- en: Steven Scott and Hal Varian, [“Predicting the Present with Bayesian Structural
    Time Series,”](https://perma.cc/4EJX-6WGA) unpublished paper, June 28, 2013, https://perma.cc/4EJX-6WGA.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Steven Scott和Hal Varian，《用贝叶斯结构时间序列预测现在》，未发表论文，2013年6月28日，https://perma.cc/4EJX-6WGA。
- en: This Google paper based on economic time series presents an example of applying
    a time series forecasting problem to data about a given time that becomes available
    with different lags. In particular, the authors use current Google searches to
    predict unemployment rates where the latter rates are only published periodically,
    whereas the Google search counts were continuously available. This is an example
    of what is often called “nowcasting” to indicate a forecast that is actually being
    made about the present due to a reporting lag. The paper uses a combination of
    Bayesian structural time series and ensemble techniques.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这篇基于经济时间序列的Google论文展示了将时间序列预测问题应用于关于特定时间的数据的示例，这些数据随不同滞后期变得可用。特别地，作者使用当前的Google搜索来预测失业率，而后者只定期发布，而Google搜索计数则是持续可用的。这是通常所说的“现在预测”的一个例子，以指示实际上正在对当前情况进行的预测，因为有一个报告滞后。该论文使用贝叶斯结构时间序列和集成技术的组合。
- en: 'Jennifer Hoeting et al., [“Bayesian Model Averaging: A Tutorial,”](https://perma.cc/BRP8-Y33X)
    *Statistical Science* 14, no. 4 (1999): 382–401, https://perma.cc/BRP8-Y33X.'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Jennifer Hoeting等人，《贝叶斯模型平均：教程》，*统计科学* 14卷4期（1999年）：382–401，https://perma.cc/BRP8-Y33X。
- en: This article provides a comprehensive overview of how Bayesian model averaging
    works via several different methods. As this article describes, the purpose of
    Bayesian model averaging is to account for uncertainty in the modeling process
    due to model selection. Through worked examples, the authors provide a way to
    better estimate the uncertainty in predictions. A related, simpler summary is
    provided in an overview of [BMA](https://perma.cc/U7M4-PRMW), an R package for
    Bayesian Model Averaging.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本文全面介绍了贝叶斯模型平均如何通过几种不同方法工作。正如本文所述，贝叶斯模型平均的目的是为了在模型选择过程中考虑由于不确定性而引起的不确定性。通过实例讲解，作者提供了更好估计预测中不确定性的方法。与此相关的，还有一个简要概述[BMA](https://perma.cc/U7M4-PRMW)，这是用于贝叶斯模型平均的R包。
- en: ^([1](ch07.html#idm45576035168648-marker)) In this book we analyze discretely
    sampled data, which is most common in real-world applications.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch07.html#idm45576035168648-marker)) 在本书中，我们分析的是离散采样的数据，在现实世界的应用中最为常见。
- en: ^([2](ch07.html#idm45576035151256-marker)) I would also endorse reading many
    alternative simple explanations of the Kalman filter on [Mathematics StackExchange](https://perma.cc/27RK-YQ52).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch07.html#idm45576035151256-marker)) 我还建议阅读关于卡尔曼滤波器的许多替代简单解释，可以从[Mathematics
    StackExchange](https://perma.cc/27RK-YQ52)开始。
- en: ^([3](ch07.html#idm45576033909992-marker)) Notice that another problem with
    the simulated data is that we didn’t established a transition probability matrix
    to control the flow of the hidden state from one state to another. Essentially
    we built in the assumption that a state is much more likely to stay as is for
    many days in a row and then jump to any of the other states with equal probability.
    We left out the formal specification and use of a transition matrix simply to
    keep the code more simple.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch07.html#idm45576033909992-marker)) 注意到模拟数据的另一个问题是，我们没有建立转移概率矩阵来控制隐藏状态从一个状态到另一个状态的流动。实质上，我们内置了这样一种假设：一个状态在很多天内保持不变的可能性更大，然后以相等的概率跳转到任何其他状态。为了保持代码的简洁，我们省略了转移矩阵的正式规定和使用。
- en: ^([4](ch07.html#idm45576033901544-marker)) The name of this package reflects
    another name used for HMM, *dependent mixture models*.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch07.html#idm45576033901544-marker)) 此包的名称反映了HMM的另一个名称，*依赖混合模型*。
- en: ^([5](ch07.html#idm45576033596520-marker)) To read more about the spike-and-slab
    method, start with [Wikipedia](https://perma.cc/4GNC-VDQY). The math is fairly
    complicated, so we will not discuss it further here. The spike-and-slab method
    is most useful in cases where you have many inputs and need variable selection
    to simplify your model.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch07.html#idm45576033596520-marker)) 要了解更多关于尖峰与平板方法的信息，请从[Wikipedia](https://perma.cc/4GNC-VDQY)开始。数学相当复杂，所以我们不会在这里进一步讨论它。尖峰与平板方法在有许多输入并需要变量选择来简化模型的情况下最为有用。
- en: ^([6](ch07.html#idm45576033460264-marker)) More info in the [docs](https://perma.cc/2N77-ALJ4).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch07.html#idm45576033460264-marker)) 更多信息请参阅[文档](https://perma.cc/2N77-ALJ4)。
