- en: Lesson 32\. Working with your own object types
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 32\. 与你自己的对象类型一起工作
- en: After reading [lesson 32](#ch32), you’ll be able to
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读[第32课](#ch32)之后，你将能够
- en: Define a class to simulate a stack
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个类来模拟栈
- en: Use a class with other objects you define
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用你定义的其他对象类
- en: At this point, you know how to create a class. Formally, a class represents
    an object type in Python. Why do you want to make your own object types in the
    first place? Because an object type packages a set of properties and a set of
    behaviors in one data structure. With this nicely packaged data structure, you
    know that all objects that take on this type are consistent in the set of data
    that defines them, and consistent in the set of operations that they can perform.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你知道如何创建一个类。正式来说，一个类在Python中代表一个对象类型。你为什么要首先创建自己的对象类型呢？因为对象类型将一组属性和一组行为打包在一个数据结构中。有了这个很好地打包的数据结构，你知道所有承担这种类型的对象在定义它们的属性集合中是一致的，并且在它们可以执行的操作集合中也是一致的。
- en: The useful idea behind object types is that you can build upon object types
    you create to make objects that are more complex.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 对象类型背后的有用想法是，你可以基于你创建的对象类型构建更复杂的对象。
- en: '|  |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: 'Subdivide each of the following objects into smaller objects, and those into
    smaller objects, until you can define the smallest object by using a built-in
    type (`int`, `float`, `string`, `bool`):'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下每个对象细分到更小的对象，然后继续细分，直到你可以使用内置类型（`int`、`float`、`string`、`bool`）定义最小的对象：
- en: Snow
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 雪花
- en: Forest
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 森林
- en: 'Answer:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：
- en: Snow is made up of snowflakes. Snowflakes have six sides, and are made up of
    crystals. Crystals are made up of water molecules arranged in a certain configuration
    (a list).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 雪是由雪花组成的。雪花有六个面，由晶体组成。晶体是由按一定配置排列的水分子组成的（一个列表）。
- en: A forest is made up of trees. A tree has a trunk and leaves. A trunk has a length
    (float) and a diameter (float). Leaves have a color (string).
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 森林由树木组成。一棵树有一个树干和叶子。树干有长度（float）和直径（float）。叶子有颜色（string）。
- en: '|  |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 32.1\. Defining a stack object
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 32.1\. 定义栈对象
- en: 'In [lesson 26](kindle_split_041.html#ch26), you used lists along with a series
    of appends and pops to implement a stack of pancakes. As you were doing the operations,
    you were careful to make sure that the operations were in line with the behavior
    of a stack: add to the end of the list and remove from the end of the list.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第26课](kindle_split_041.html#ch26)中，你使用了列表以及一系列的追加和弹出操作来实现煎饼栈。在你执行操作时，你小心地确保操作符合栈的行为：在列表末尾添加并从列表末尾移除。
- en: Using classes, you can create a stack object that enforces the stack rules for
    you so you don’t have to keep track of them while the program runs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类，你可以创建一个栈对象，该对象为你强制执行栈规则，这样你就不需要在程序运行时跟踪它们。
- en: '|  |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Thinking like a programmer**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**像程序员一样思考**'
- en: Using a class, you hide implementation details from people using the class.
    You don’t need to spell out how you’ll do something, just that you want certain
    behaviors; for example, in a stack you can add/remove items. The implementation
    of these behaviors can be done in various ways, and these details aren’t necessary
    to understand what the object is and how to use it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类，你可以隐藏类的实现细节，对于使用类的人来说。你不需要详细说明你将如何做某事，只需说明你希望有某些行为；例如，在栈中你可以添加/移除项目。这些行为的实现可以以各种方式完成，而这些细节对于理解对象是什么以及如何使用它并不是必要的。
- en: '|  |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 32.1.1\. Choosing data attributes
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 32.1.1\. 选择数据属性
- en: 'You name the stack object type `Stack`. The first step is to decide how to
    represent a stack. In [lesson 26](kindle_split_041.html#ch26), you used a list
    to simulate the stack, so it makes sense to represent the stack by using one attribute:
    a list.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你将栈对象类型命名为`Stack`。第一步是决定如何表示栈。在[第26课](kindle_split_041.html#ch26)中，你使用列表来模拟栈，所以使用一个属性来表示栈是有意义的：一个列表。
- en: '|  |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Thinking like a programmer**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**像程序员一样思考**'
- en: 'When deciding which data attributes should represent an object type, it may
    be helpful to do one of two things:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定哪些数据属性应该代表对象类型时，做以下两件事之一可能会有所帮助：
- en: Write out which data types you know and whether each would be appropriate to
    use. Keep in mind that an object type can be represented by more than one data
    attribute.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出你所知道的数据类型，并考虑每种类型是否适合使用。请记住，一个对象类型可以由多个数据属性表示。
- en: Start with the behavior you’d like the object to have. Often, you can decide
    on data attributes by noticing that the behaviors you want can be represented
    by one or more data structures you already know.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从你希望对象具有的行为开始。通常，你可以通过注意到你想要的行为可以用一个或多个你已知的已知的数结构来表示，来决定数据属性。
- en: '|  |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'You typically define data attributes in the initialization method for your
    class:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常在类的初始化方法中定义数据属性：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The stack will be represented using a list. You can decide that initially a
    stack is empty, so you initialize a data attribute for the `Stack` object by using
    `self.stack = []`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 栈将使用列表来表示。你可以决定最初栈是空的，因此使用 `self.stack = []` 初始化 `Stack` 对象的数据属性。
- en: 32.1.2\. Implementing methods
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 32.1.2\. 实现方法
- en: After deciding on the data attributes that define an object type, you need to
    decide what behaviors your object type will have. You should decide how you want
    your object to behave and how others who want to use your class will interact
    with it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定定义对象类型的数据属性之后，你需要决定你的对象类型将具有哪些行为。你应该决定你希望你的对象如何表现，以及希望使用你的类的其他人如何与之交互。
- en: '[Listing 32.1](#ch32ex01) provides the full definition for the `Stack` class.
    Aside from the initialization method, seven other methods define ways in which
    you can interact with a stack-type object. The method `get_stack_elements` returns
    a copy of the data attribute, to prevent users from mutating the data attribute.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 32.1](#ch32ex01) 提供了 `Stack` 类的完整定义。除了初始化方法外，还有其他七个方法定义了你可以与栈类型对象交互的方式。`get_stack_elements`
    方法返回数据属性的副本，以防止用户修改数据属性。'
- en: The methods `add_one` and `remove_one` are consistent with the behavior of a
    stack; you add to one end of the list, and you remove from the same end. Similarly,
    the methods `add_many` and `remove_many` add and remove a certain number of times,
    from the same end. The method `size` returns the number of items in the stack.
    Finally, the method `prettyprint_stack` prints (and therefore returns `None`)
    each item in the stack on a line, with newer items at the top.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_one` 和 `remove_one` 方法与栈的行为一致；你在列表的一端添加元素，并从同一端移除。同样，`add_many` 和 `remove_many`
    方法多次添加和移除一定数量的元素，也是从同一端。`size` 方法返回栈中元素的数量。最后，`prettyprint_stack` 方法将栈中的每个元素打印（因此返回
    `None`）到一行上，较新的元素在顶部。'
- en: Listing 32.1\. Definition for the `Stack` class
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 32.1\. `Stack` 类的定义
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* A list data attribute defines the stack.**'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 列表数据属性定义了栈。**'
- en: '***2* Method to return a copy of the data attribute representing the stack**'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 返回表示栈的数据属性的副本**'
- en: '***3* Method to add one item to the stack; adds it to the end of the list**'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 向栈中添加一个项目的方 法；将其添加到列表的末尾**'
- en: '***4* Method to add n of the same item to the stack**'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 向栈中添加 n 个相同项目的方 法**'
- en: '***5* Method to remove one item from stack**'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 从栈中移除一个项目的方 法**'
- en: '***6* Method to remove n items from the stack**'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 从栈中移除 n 个项目的方 法**'
- en: '***7* Method to tell you the number of items in the stack**'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 告诉你栈中项目数量的方 法**'
- en: '***8* Method to print a stack with each item on a line, with newer items on
    top**'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 打印一个栈，每个项目在一行上，较新的项目在顶部**'
- en: One thing is important to note. In the implementation of the stack, you decided
    to add and remove from the end of the list. An equally valid design decision would
    have been to add and remove from the beginning of the list. Notice that as long
    as you’re consistent with your decisions and the object’s behavior that you’re
    trying to implement, more than one implementation may be possible.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点需要注意。在栈的实现中，你决定从列表的末尾添加和移除元素。一个同样有效的设计决策可能是从列表的起始位置添加和移除。请注意，只要你的决策和你要尝试实现的对象的行为保持一致，可能存在多种实现方式。
- en: '|  |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 32.1**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 32.1**'
- en: '**[Q1:](kindle_split_056.html#app01qa129q0a1)**'
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_056.html#app01qa129q0a1)**'
- en: ''
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a method for the `Stack` object, named `add_list`, which takes in a list
    as a parameter. Each element in the list is added to the stack, with items at
    the beginning of the list being added to the stack first.
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为 `Stack` 对象编写一个名为 `add_list` 的方法，该方法接受一个列表作为参数。列表中的每个元素都添加到栈中，列表开头的元素首先添加到栈中。
- en: '|  |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 32.2\. Using a Stack object
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 32.2\. 使用栈对象
- en: Now that you’ve defined a `Stack` object type with a Python class, you can start
    to make `Stack` objects and do operations with them.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经使用 Python 类定义了一个 `Stack` 对象类型，你可以开始创建 `Stack` 对象并使用它们进行操作。
- en: 32.2.1\. Make a stack of pancakes
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 32.2.1\. 制作煎饼堆
- en: 'You begin by tackling the traditional task of adding pancakes to your stack.
    Suppose a pancake is defined by a string representing the flavor of pancake: `"chocolate"`
    or `"blueberry"`.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先解决的是向你的栈中添加松饼的传统任务。假设一个松饼由表示松饼风味的字符串定义：`"chocolate"` 或 `"blueberry"`。
- en: 'The first step is to create a stack object to which you’ll add your pancakes.
    [Listing 32.2](#ch32ex02) shows a simple sequence of commands:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个栈对象，你将在其中添加你的松饼。[列表32.2](#ch32ex02)展示了简单的命令序列：
- en: Create an empty stack by initializing a `Stack` object.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过初始化一个 `Stack` 对象来创建一个空栈。
- en: Add one blueberry pancake by calling `add_one` on the stack.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在栈上调用 `add_one` 来添加一个蓝莓松饼。
- en: Add four chocolate pancakes by calling the `add_many` method on the stack.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在栈上调用 `add_many` 方法来添加四个巧克力松饼。
- en: The items added to the stack are strings to represent the pancake flavors. All
    methods you call are on the object you created, using dot notation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到栈中的项目是表示松饼风味的字符串。你调用的所有方法都是在你创建的对象上，使用点符号。
- en: Listing 32.2\. Making a `Stack` object and adding pancakes to it
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表32.2\. 创建 `Stack` 对象并向其中添加松饼
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* Creates a stack and binds the Stack object to a variable named pancakes**'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个栈并将 Stack 对象绑定到名为 pancakes 的变量**'
- en: '***2* Adds one blueberry pancake**'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 添加了一个蓝莓松饼**'
- en: '***3* Adds four chocolate pancakes**'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 添加了四个巧克力松饼**'
- en: '***4* Prints five**'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 打印五个**'
- en: '***5* Removes the string that was added last, a “chocolate” pancake**'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 移除了最后添加的字符串，一个“chocolate”松饼**'
- en: '***6* Prints four**'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 打印四个**'
- en: '***7* Prints each pancake flavor on a line: three chocolate ones on top, and
    one blueberry at the bottom**'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 在每行打印每个松饼的风味：顶部有三个巧克力松饼，底部有一个蓝莓松饼**'
- en: '[Figure 32.1](#ch32fig01) shows the steps to adding items to the stack and
    the value of the list data attribute, accessed by `self.stack`.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[图32.1](#ch32fig01) 展示了向栈中添加项目以及通过 `self.stack` 访问的列表数据属性的步骤。'
- en: 'Figure 32.1\. Starting from the left, the first panel shows an empty stack
    of pancakes. The second panel shows the stack when you add one item: one `"blueberry"`.
    The third panel shows the stack after you add four of the same item: four `"chocolate"`.
    The last panel shows the stack after you removed an item: the last one added,
    one `"chocolate"`.'
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图32.1\. 从左到右，第一个面板显示了一个空的松饼栈。第二个面板显示当你添加一个项目时栈的状态：一个 `"blueberry"`。第三个面板显示你添加了四个相同项目后的栈：四个
    `"chocolate"`。最后一个面板显示你移除一个项目后的栈：最后添加的一个 `"chocolate"`。
- en: '![](images/32fig01_alt.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](images/32fig01_alt.jpg)'
- en: 'Notice that in this code snippet, every method behaves exactly like a function:
    it takes in parameters, does work by executing commands, and returns a value.
    You can have methods that don’t return an explicit value, such as the `prettyprint`
    method. In this case, when you call the method, you don’t need to print the result
    because nothing interesting is returned; the method itself prints some values.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个代码片段中，每个方法的行为都完全像一个函数：它接受参数，通过执行命令来完成工作，并返回一个值。你可以有不需要返回显式值的函数，例如 `prettyprint`
    方法。在这种情况下，当你调用该方法时，你不需要打印结果，因为没有返回任何有趣的内容；方法本身打印了一些值。
- en: 32.2.2\. Make a stack of circles
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 32.2.2\. 创建一个圆圈栈
- en: Now that you have a `Stack` object, you can add any other type of object to
    the stack, not just atomic objects (`int`, `float`, or `bool`). You can add objects
    of a type that you created.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个 `Stack` 对象，你可以向栈中添加任何其他类型的对象，而不仅仅是原子对象（`int`、`float` 或 `bool`）。你可以添加你创建的对象类型。
- en: You wrote a class that represented a `Circle` object in [lesson 31](kindle_split_047.html#ch31),
    so now you can create a stack of circles. [Listing 32.3](#ch32ex03) shows you
    the code to do this. This is similar to the way you added pancakes in [listing
    32.2](#ch32ex02). The only difference is that instead of strings representing
    pancake flavors, you now have to initialize a circle object before adding it to
    the stack. If you’re running the following listing, you’ll have to copy the code
    that defines a `Circle` object into the same file so that Python knows what a
    `Circle` is.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第31课](kindle_split_047.html#ch31)中编写了一个表示 `Circle` 对象的类，所以现在你可以创建一个圆圈栈。[列表32.3](#ch32ex03)展示了如何做到这一点。这与你在[列表32.2](#ch32ex02)中添加松饼的方式类似。唯一的区别是，在将对象添加到栈中之前，你现在必须初始化一个圆圈对象。如果你正在运行以下列表，你必须将定义
    `Circle` 对象的代码复制到同一文件中，这样Python才知道什么是 `Circle`。
- en: Listing 32.3\. Making a `Stack` object and adding `Circle` objects to it
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表32.3\. 创建 `Stack` 对象并向其中添加 `Circle` 对象
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* Creates a stack and binds the Stack object to a variable named circles**'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建了一个栈并将 Stack 对象绑定到名为 circles 的变量**'
- en: '***2* Creates a new circle object, sets its radius to 2, and adds the circle
    to the stack**'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建一个新的圆形对象，将其半径设置为 2，并将圆形添加到栈中**'
- en: '***3* A loop to add five new circle objects**'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 循环以添加五个新的圆形对象**'
- en: '***4* Creates a new circle object each time through the loop, sets radius to
    1, and adds it to the stack**'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 在循环的每次迭代中创建一个新的圆形对象，将其半径设置为 1，并将其添加到栈中**'
- en: '***5* Prints six**'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 打印了 6**'
- en: '***6* Prints Python information related to each circle object (its type and
    location in memory)**'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 打印与每个圆形对象相关的 Python 信息（其类型和内存中的位置）**'
- en: '[Figure 32.2](#ch32fig02) shows how the stack of circles might look.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 32.2](#ch32fig02) 展示了圆形栈可能的外观。'
- en: Figure 32.2\. The circle with a radius of 2 is at the bottom because it’s added
    first. Then you make a new circle with a radius of 1, five times, and add each
    one to the stack.
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 32.2\. 半径为 2 的圆形位于底部，因为它是最先添加的。然后你创建一个半径为 1 的新圆形，重复五次，并将每个圆形添加到栈中。
- en: '![](images/32fig02.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](images/32fig02.jpg)'
- en: You may also notice that you have a method in the `Stack` class named `add_many`.
    Instead of a loop that adds one circle at a time, suppose you create one circle
    with radius 1 and call `add_many` on the stack with this object’s properties,
    as in the following listing, and illustrated in [figure 32.3](#ch32fig03).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还会注意到在 `Stack` 类中有一个名为 `add_many` 的方法。而不是一次添加一个圆形的循环，假设你创建了一个半径为 1 的圆形，并使用以下列表中的属性在栈上调用
    `add_many`，如图 32.3 所示。
- en: Listing 32.4\. Making a `Stack` object and adding the same circle object many
    times
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 32.4\. 创建 `Stack` 对象并多次添加相同的圆形对象
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* Same operations as [listing 32.3](#ch32ex03)**'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 与 [列表 32.3](#ch32ex03) 中的操作相同**'
- en: '***2* Creates a new circle object; sets its radius to 1**'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建一个新的圆形对象；将其半径设置为 1**'
- en: '***3* Adds the same circle object five times using a method defined in Stack
    class**'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用 `Stack` 类中定义的方法将相同的圆形对象添加五次**'
- en: '***4* Prints six, the total number of circles added at this point**'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 打印了 6，这是到目前为止添加的圆形总数**'
- en: '***5* Prints Python information related to each circle object (its type and
    location in memory)**'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 打印与每个圆形对象相关的 Python 信息（其类型和内存中的位置）**'
- en: Figure 32.3\. The circle with a radius of 2 is at the bottom because it’s added
    first. Then you make one circle with a radius of 1 and add this same circle object
    five times to the stack
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 32.3\. 半径为 2 的圆形位于底部，因为它是最先添加的。然后你创建一个半径为 1 的新圆形，并将这个相同的圆形对象添加到栈中五次
- en: '![](images/32fig03.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](images/32fig03.jpg)'
- en: 'Let’s compare how the two stacks look from [listings 32.3](#ch32ex03) and [32.4](#ch32ex04).
    In [listing 32.3](#ch32ex03), you created a new circle object each time through
    the loop. When you output your stack by using the `prettyprint` method, the output
    looks something like this, representing the type of the object being printed and
    its location in memory:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较一下 [列表 32.3](#ch32ex03) 和 [列表 32.4](#ch32ex04) 中的两个栈的外观。在 [列表 32.3](#ch32ex03)
    中，你在循环的每次迭代中创建了一个新的圆形对象。当你使用 `prettyprint` 方法输出你的栈时，输出看起来像这样，表示正在打印的对象的类型及其在内存中的位置：
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In [listing 32.4](#ch32ex04), you created only one new circle object and added
    that object five times. When you output your stack by using the `prettyprint`
    method, the output now looks something like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 32.4](#ch32ex04) 中，你只创建了一个新的圆形对象，并将其添加了五次。当你使用 `prettyprint` 方法输出你的栈时，输出现在看起来像这样：
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using the memory location printed by Python, you can see the difference between
    these two pieces of code. [Listing 32.3](#ch32ex03) creates a new object each
    time through the loop and adds it to the stack; it just so happens that each object
    has the same data associated with it, a radius of 1\. On the other hand, [listing
    32.4](#ch32ex04) creates one object and adds the same object multiple times.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python 打印的内存位置，你可以看到这两段代码之间的差异。[列表 32.3](#ch32ex03) 在循环的每次迭代中创建一个新的对象，并将其添加到栈中；恰好每个对象都关联着相同的数据，即半径为
    1。另一方面，[列表 32.4](#ch32ex04) 创建了一个对象，并将同一个对象多次添加。
- en: In [lesson 33](kindle_split_049.html#ch33), you’ll see how to write your own
    method to override the default Python `print` method so that you can print information
    related to your own objects instead of the memory location.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 33 课](kindle_split_049.html#ch33) 中，你将了解如何编写自己的方法来覆盖默认的 Python `print`
    方法，以便你可以打印与你的对象相关的信息，而不是内存位置。
- en: '|  |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 32.2**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 32.2**'
- en: '**[Q1:](kindle_split_056.html#app01qa130q0a1)**'
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[问题 1:](kindle_split_056.html#app01qa130q0a1)**'
- en: ''
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write code that creates two stacks. To one stack, the code adds three circle
    objects with radius 3, and to the other it adds five of the exact same rectangle
    object with width 1 and length 1\. Use the classes for `Circle` and `Rectangle`
    defined in [lesson 31](kindle_split_047.html#ch31).
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写代码创建两个栈。向一个栈中添加三个半径为3的圆形对象，向另一个栈中添加五个宽度为1、长度为1的相同矩形对象。使用[第31课](kindle_split_047.html#ch31)中定义的`Circle`和`Rectangle`类。
- en: '|  |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this lesson, my objective was to teach you how to define multiple objects
    and use them both in the same program. Here are the major takeaways:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，我的目标是教你如何定义多个对象，并在同一程序中使用它们。以下是主要收获：
- en: Defining a class requires deciding how to represent it.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个类需要决定如何表示它。
- en: Defining a class also requires deciding how to use it and what methods to implement.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个类还需要决定如何使用它以及实现哪些方法。
- en: A class packages properties and behaviors into one object type so that all objects
    of this type have the same data and methods in common.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类将属性和行为打包成一个对象类型，这样这个类型的所有对象都具有相同的数据和方法。
- en: Using the class involves creating one or more objects of that type and performing
    a sequence of operations with it.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用该类涉及创建一个或多个该类型的对象，并对其进行一系列操作。
- en: Let’s see if you got this...
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否掌握了这个...
- en: '**[Q32.1](kindle_split_056.html#app01qa131q0a1)**'
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q32.1](kindle_split_056.html#app01qa131q0a1)**'
- en: ''
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Write a class for a queue, in a similar way as that for the stack. Recall that
    items added to a queue are added to one end, and items removed from the queue
    are removed from the other end:'
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以类似栈的方式编写一个队列的类。回想一下，添加到队列中的项目被添加到一端，从队列中移除的项目从另一端移除：
- en: ''
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Decide which data structure will represent your queue.
  id: totrans-123
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定哪种数据结构将表示你的队列。
- en: Implement `__init__`.
  id: totrans-124
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`__init__`。
- en: Implement methods to get the size, add one, add many, remove one, remove many,
    and to show the queue.
  id: totrans-125
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现获取大小、添加一个、添加多个、移除一个、移除多个以及显示队列的方法。
- en: Write code to create queue objects and perform some of the operations on them.
  id: totrans-126
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写代码创建队列对象并对它们执行一些操作。
