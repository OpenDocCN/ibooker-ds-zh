- en: 5 Modeling an autoregressive process
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 建模自回归过程
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Illustrating an autoregressive process
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示自回归过程
- en: Defining the partial autocorrelation function (PACF)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义偏自相关函数（PACF）
- en: Using the PACF plot to determine the order of an autoregressive process
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PACF图确定自回归过程的阶数
- en: Forecasting a time series using the autoregressive model
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自回归模型预测时间序列
- en: In the previous chapter, we covered the moving average process, also denoted
    as MA(*q*)), where *q* is the order. You learned that in a moving average process,
    the present value is linearly dependent on current and past error terms. Therefore,
    if you predict more than *q* steps ahead, the prediction will fall flat and will
    return only the mean of the series, because the error terms are not observed in
    the data and must be recursively estimated. Finally, you saw that you can determine
    the order of a stationary MA(*q*) process by studying the ACF plot; the autocorrelation
    coefficients will be significant up until lag *q*. In the case where the autocorrelation
    coefficients slowly decay or exhibit a sinusoidal pattern, then you are possibly
    in the presence of an autoregressive process.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了移动平均过程，也称为MA(*q*)，其中*q*是阶数。您了解到在移动平均过程中，当前值是线性依赖于当前和过去误差项的。因此，如果您预测超过*q*步，预测将变得平淡，只会返回序列的均值，因为误差项在数据中未观察到，必须递归估计。最后，您看到可以通过研究ACF图来确定平稳的MA(*q*)过程的阶数；自相关系数将一直显著到滞后*q*。在自相关系数缓慢衰减或呈现正弦波模式的情况下，您可能处于自回归过程的存在。
- en: In this chapter, we will first define the autoregressive process. Then, we will
    define the partial autocorrelation function and use it to find the order of the
    underlying autoregressive process of a dataset. Finally, we will use the AR(*p*)
    model to produce forecasts.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先定义自回归过程。然后，我们将定义偏自相关函数，并使用它来找到数据集潜在自回归过程的阶数。最后，我们将使用AR(*p*)模型进行预测。
- en: 5.1 Predicting the average weekly foot traffic in a retail store
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 预测零售店平均每周客流量
- en: Suppose that you want to forecast the average weekly foot traffic in a retail
    store so that the store manager can better manage the staff’s schedule. If many
    people are expected to come to the store, more employees should be present to
    provide assistance. If fewer people are expected to visit the store, the manager
    can schedule fewer employees to work. That way the store can optimize its spending
    on salaries and ensure that employees are not overwhelmed or underwhelmed by store
    visitors.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想要预测零售店平均每周客流量，以便店长能更好地管理员工的工作时间表。如果预计很多人会来商店，应该有更多的员工在场提供帮助。如果预计来店的人较少，经理可以安排较少的员工工作。这样，商店可以优化其工资支出，并确保员工不会被商店的访客压倒或忽视。
- en: For this example, we have 1,000 data points, each representing the average weekly
    foot traffic at a retail store starting in the year 2000\. You can see the evolution
    of our data through time in figure 5.1.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们有1,000个数据点，每个数据点代表从2000年开始的零售店平均每周客流量。您可以在图5.1中看到数据随时间的变化。
- en: '![](../../OEBPS/Images/05-01.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/05-01.png)'
- en: Figure 5.1 Average weekly foot traffic in a retail store. The dataset contains
    1,000 data points, starting in the first week of 2000\. Note that this is fictional
    data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 零售店平均每周客流量。数据集包含1,000个数据点，从2000年的第一周开始。请注意，这是虚构数据。
- en: In figure 5.1 we can see a long-term trend with peaks and troughs along the
    way. We can intuitively say that this time series is not a stationary process,
    since we observe a trend over time. Furthermore, there is no apparent cyclical
    pattern in the data, so we can rule out any seasonal effects for now.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在图5.1中，我们可以看到一条带有沿途峰值和谷值的长期趋势。我们可以直观地说，这个时间序列不是一个平稳过程，因为我们观察到随着时间的推移存在趋势。此外，数据中没有任何明显的周期性模式，因此我们可以暂时排除任何季节性影响。
- en: Again, in order to forecast the average weekly foot traffic, we need to identify
    the underlying process. Thus, we must apply the same steps that we covered in
    chapter 4\. That way, we can verify whether we have a random walk or a moving
    average process at play. The steps are shown in figure 5.2.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，为了预测平均每周客流量，我们需要识别潜在的过程。因此，我们必须应用我们在第4章中介绍的同一步骤。这样，我们可以验证是否存在随机游走或移动平均过程。步骤在图5.2中显示。
- en: '![](../../OEBPS/Images/05-02.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/05-02.png)'
- en: Figure 5.2 Steps to identify the underlying process of a stationary time series.
    So far we can identify a random walk or a moving average process.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2识别平稳时间序列潜在过程的步骤。到目前为止，我们可以识别出随机游走或移动平均过程。
- en: In this example, the data is already collected, so we can move on to testing
    for stationarity. As mentioned previously, the presence of a trend over time means
    that our series is likely not stationary, so we will have to apply a transformation
    in order to make it stationary. Then we will plot the ACF. As we work through
    the chapter, you will see that not only is there autocorrelation, but the ACF
    plot will have a slowly decaying trend.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，数据已经收集完毕，因此我们可以继续测试平稳性。如前所述，时间序列中的趋势存在意味着我们的序列可能不是平稳的，因此我们必须应用转换使其平稳。然后我们将绘制自相关图。随着我们学习本章，您将看到不仅存在自相关，而且自相关图将有一个缓慢衰减的趋势。
- en: This is indicative of an autoregressive process of order *p*, also denoted as
    AR(*p*). In this case, we must plot the *partial autocorrelation function* (PACF)
    to find the order *p*. Just like the coefficients on an ACF plot for an MA(*q*)
    process, the coefficients on the PACF plot will become abruptly non-significant
    after lag *p*, hence determining the order of the autoregressive process.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明存在一个阶数为 *p* 的自回归过程，也称为 AR(*p*)。在这种情况下，我们必须绘制 *偏自相关函数* (PACF) 来找到阶数 *p*。就像
    MA(*q*) 过程的 ACF 图上的系数一样，PACF 图上的系数在滞后 *p* 后会突然变得不显著，从而确定自回归过程的阶数。
- en: Again, the order of the autoregressive process determines how many parameters
    must be included in the AR(*p*) model. Then we will be ready to make forecasts.
    In this example, we wish to forecast next week’s average foot traffic.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，自回归过程的阶数决定了 AR(*p*) 模型中必须包含多少参数。然后我们将准备好进行预测。在这个例子中，我们希望预测下周的平均人流量。
- en: 5.2 Defining the autoregressive process
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 定义自回归过程
- en: An autoregressive process establishes that the output variable depends linearly
    on its own previous values. In other words, it is a regression of the variable
    against itself.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 自回归过程表明输出变量与其自身的先前值线性相关。换句话说，它是对变量自身的回归。
- en: An *autoregressive process* is denoted as an AR(*p*) process, where *p* is the
    order. In such a process, the present value *y[t]* is a linear combination of
    a constant C, the present error term *ϵ[*t*]*, which is also white noise, and
    the past values of the series *y*[*t*–*p*]. The magnitude of the influence of
    the past values on the present value is denoted as ϕ[p], which represents the
    coefficients of the AR(*p*)) model. Mathematically, we express a general AR(*p*)
    model with equation 5.1.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 自回归过程表示为 AR(*p*) 过程，其中 *p* 是阶数。在这种情况下，当前值 *y[t]* 是一个常数 C、当前误差项 *ϵ[*t*]*（也是白噪声）以及序列的过去值
    *y*[*t*–*p*] 的线性组合。过去值对当前值影响的大小用 ϕ[p] 表示，它代表 AR(*p*) 模型的系数。数学上，我们用方程5.1表达一个一般的
    AR(*p*) 模型。
- en: '*y[t]* = C + ϕ[1]*y*[*t*–1] + ϕ[2]*y*[*t*–2] +⋅⋅⋅ ϕ[p]*y*[*t*–*p*] + *ϵ[*t*]*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*y[t]* = C + ϕ[1]*y*[*t*–1] + ϕ[2]*y*[*t*–2] +⋅⋅⋅ ϕ[p]*y*[*t*–*p*] + *ϵ[*t*]*'
- en: Equation 5.1
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 方程5.1
- en: Autoregressive process
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 自回归过程
- en: An autoregressive process is a regression of a variable against itself. In a
    time series, this means that the present value is linearly dependent on its past
    values.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 自回归过程是对一个变量对其自身的回归。在时间序列中，这意味着当前值线性依赖于其过去值。
- en: The autoregressive process is denoted as AR(*p*), where *p* is the order. The
    general expression of an AR(*p*) model is
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 自回归过程表示为 AR(*p*)，其中 *p* 是阶数。AR(*p*) 模型的一般表达式是
- en: '*y[t]* = C + ϕ[1]*y*[*t*–1] + ϕ[2]*y*[*t*–2] +⋅⋅⋅+ ϕ*[p]y*[*t*–*p*] + *ϵ[t]*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*y[t]* = C + ϕ[1]*y*[*t*–1] + ϕ[2]*y*[*t*–2] +⋅⋅⋅+ ϕ*[p]y*[*t*–*p*] + *ϵ[t]*'
- en: Similar to the moving average process, the order *p* of an autoregressive process
    determines the number of past values that affect the present value. If we have
    a first-order autoregressive process, also denoted as AR(1), then the present
    value *y[t]* is only dependent on a constant C, the value at the previous timestep
    ϕ[1]*y*[*t*–1], and some white noise *ϵ[*t*]*, as shown in equation 5.2.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 与移动平均过程类似，自回归过程的阶数 *p* 决定了影响当前值的过去值的数量。如果我们有一个一阶自回归过程，也称为AR(1)，那么当前值 *y[t]*
    只依赖于一个常数 C、前一个时间步的值 ϕ[1]*y*[*t*–1] 以及一些白噪声 *ϵ[*t*]*，如方程5.2所示。
- en: '*y[t]* = C + ϕ[1]*y*[*t*–1] + *ϵ[*t*]*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*y[t]* = C + ϕ[1]*y*[*t*–1] + *ϵ[*t*]*'
- en: Equation 5.2
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 方程5.2
- en: Looking at equation 5.2, you might notice that it is very similar to a random
    walk process, which we covered in chapter 3\. In fact, if ϕ[1] = 1, then equation
    5.2 becomes
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 观察方程式5.2，你可能会注意到它与我们在第3章中讨论的随机游走过程非常相似。事实上，如果 ϕ[1] = 1，那么方程式5.2就变成了
- en: '*y[t]* = C + *y*[*t*–1] + *ϵ[*t*]*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*y[t]* = C + *y*[*t*–1] + *ϵ[*t*]*'
- en: which is our random walk model. Therefore, we can say that the random walk is
    a special case of an autoregressive process, where the order *p* is 1 and ϕ[1]
    is equal to 1\. Notice also that if C is not equal to 0, then we have a random
    walk with drift.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的随机游走模型。因此，我们可以说随机游走是自回归过程的一个特例，其中阶数 *p* 为1，且 ϕ[1] 等于1。注意，如果 C 不等于0，那么我们有一个带有漂移的随机游走。
- en: In the case of a second-order autoregressive process, or AR(2), the present
    value *y[t]* is linearly dependent on a constant C, the value at the previous
    timestep ϕ[1]*y*[*t*–1], the value two timesteps prior ϕ[2]*y*[*t*–2], and the
    present error term *ϵ[*t*]*, as shown in equation 5.3.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在二阶自回归过程或AR(2)的情况下，当前值 *y[t]* 线性依赖于常数 C、前一个时间步的值 ϕ[1]*y*[*t*–1]、两个时间步之前的值 ϕ[2]*y*[*t*–2]，以及当前误差项
    *ϵ[*t*]*，如方程式5.3所示。
- en: '*y[t]* = C + ϕ[1]*y*[*t*–1] + ϕ[2]*y*[*t*–2] + *ϵ[*t*]*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*y[t]* = C + ϕ[1]*y*[*t*–1] + ϕ[2]*y*[*t*–2] + *ϵ[*t*]*'
- en: Equation 5.3
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 方程式5.3
- en: We see how the order *p* influences the number of parameters that must be included
    in our model. As with a moving average process, we must find the right order of
    an autoregressive process in order to build the appropriate model. This means
    that if we identify an AR(3) process, we will use a third-order autoregressive
    model to make forecasts.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到阶数 *p* 如何影响我们必须包含在模型中的参数数量。与移动平均过程一样，我们必须找到自回归过程的正确阶数，以便构建适当的模型。这意味着如果我们识别出一个AR(3)过程，我们将使用三阶自回归模型进行预测。
- en: 5.3 Finding the order of a stationary autoregressive process
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 寻找平稳自回归过程的阶数
- en: Just like with the moving average process, there is a way to determine the order
    *p* of a stationary autoregressive process. We can extend the steps needed to
    identify the order of a moving average, as shown in figure 5.3.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 就像移动平均过程一样，有一种方法可以确定平稳自回归过程的阶数 *p*。我们可以扩展识别移动平均阶数所需的步骤，如图5.3所示。
- en: '![](../../OEBPS/Images/05-03.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/05-03.png)'
- en: Figure 5.3 Steps to identify the order of an autoregressive process
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 识别自回归过程阶数的步骤
- en: The natural first step is to collect the data. Here we will work with the average
    weekly foot traffic dataset that you saw at the beginning of the chapter. We will
    read the data using `pandas` and store it as a `DataFrame`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 自然的第一步是收集数据。在这里，我们将使用本章开头看到的平均每周客流量数据集。我们将使用 `pandas` 读取数据并将其存储为 `DataFrame`。
- en: 'Note Feel free to consult the source code for this chapter on GitHub at any
    time: [https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH05](https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH05).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可以随时在GitHub上查看本章的源代码：[https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH05](https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH05)。
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Read the CSV file into a DataFrame.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将CSV文件读入DataFrame。
- en: ❷ Display the first five rows of data.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 显示数据的前五行。
- en: You’ll see that our data contains a single foot_traffic column in which the
    average weekly foot traffic at the retail store is recorded.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到我们的数据包含一个单独的 foot_traffic 列，其中记录了零售店的平均每周客流量。
- en: As always, we will plot our data to see if there are any observable patterns,
    such as a trend or seasonality. By now, you should be comfortable with plotting
    time series, so we will not dive deeply into the code that generates the graph.
    The result is the plot shown in figure 5.4.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，我们将绘制数据以查看是否存在任何可观察的模式，例如趋势或季节性。到目前为止，你应该已经熟悉了时间序列的绘制，因此我们不会深入探讨生成图表的代码。结果如图5.4所示。
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Plot the average weekly foot traffic at a retail store.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 绘制零售店的平均每周客流量图。
- en: ❷ Label the x-axis.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 标注x轴。
- en: ❸ Label the y-axis.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 标注y轴。
- en: ❹ Label the ticks on the x-axis.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 标注x轴的刻度。
- en: ❺ Tilt the labels on the x-axis ticks so that they display nicely.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将x轴刻度的标签倾斜，以便它们显示得更好。
- en: ❻ Remove extra whitespace around the figure.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 移除图周围的多余空白。
- en: Looking at figure 5.4, you’ll notice that there is no cyclical pattern, so we
    can rule out the presence of seasonality. As for the trend, it is sometimes positive
    and sometimes negative throughout the years, with the most recent trend being
    positive, since 2016.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 观察图 5.4，你会发现没有周期性模式，因此我们可以排除季节性的存在。至于趋势，它在过去几年中有时为正，有时为负，最近的趋势自 2016 年以来一直是正的。
- en: '![](../../OEBPS/Images/05-04.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/05-04.png)'
- en: Figure 5.4 Average weekly foot traffic in a retail store. The dataset contains
    1,000 data points, starting in the first week of 2000.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 零售店平均每周客流量。数据集包含 1,000 个数据点，始于 2000 年的第一周。
- en: The next step is to check for stationarity. As mentioned before, the presence
    of a trend means that our series is likely non-stationary. Let’s verify that using
    the ADF test. Again, you should be comfortable running this without a detailed
    explanation of the code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是检查平稳性。如前所述，趋势的存在意味着我们的序列很可能是非平稳的。让我们使用 ADF 测试来验证这一点。再次强调，你应该能够运行这个测试而不需要详细解释代码。
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Run the ADF test on the average weekly foot traffic, which is stored in the
    foot_traffic column.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对存储在 foot_traffic 列中的平均每周客流量运行 ADF 测试。
- en: ❷ Print the ADF statistic.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 打印 ADF 统计量。
- en: ❸ Print the p-value.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 打印 p 值。
- en: This prints out an ADF statistic of –1.18 along with a p-value of 0.68. Since
    the ADF statistic is not a large negative number, and it has a p-value greater
    than 0.05, we cannot reject the null hypothesis and our series is therefore non-stationary.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出 ADF 统计量为 –1.18 以及 p 值为 0.68。由于 ADF 统计量不是一个大的负数，并且它的 p 值大于 0.05，我们不能拒绝零假设，因此我们的序列是非平稳的。
- en: Hence, we must apply a transformation to make it stationary. To remove the effect
    of the trend and stabilize the mean of the series, we will use differencing.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须应用转换使其平稳。为了消除趋势的影响并稳定序列的均值，我们将使用差分。
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Apply a first-order differencing on the data and store the result in foot_traffic_diff.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对数据进行一阶差分，并将结果存储在 foot_traffic_diff 中。
- en: '![](../../OEBPS/Images/05-05.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/05-05.png)'
- en: Figure 5.5 Differenced average weekly foot traffic at a retail store. Notice
    that the trend effect has been removed, since the series starts and ends at roughly
    the same value.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 零售店差分平均每周客流量。注意，趋势效应已被消除，因为序列开始和结束的大致值相同。
- en: Optionally, we could plot our differenced series `foot_traffic_diff` to see
    if we successfully removed the effect of the trend. The differenced series is
    shown in figure 5.5\. We can see that we indeed removed the long-term trend, since
    the series starts and finishes roughly at the same value.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，我们可以绘制我们的差分序列 `foot_traffic_diff` 来查看我们是否成功消除了趋势的影响。差分序列显示在图 5.5 中。我们可以看到我们确实消除了长期趋势，因为序列开始和结束的大致值相同。
- en: Can you recreate figure 5.5?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你能重新创建图 5.5 吗？
- en: While optional, it is a good idea to plot your series as you apply transformations.
    This will give you a better intuition as to whether the series is stationary or
    not after a particular transformation. Try recreating figure 5.5 on your own.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是必须的，但在应用转换时绘制你的序列是一个好主意。这将帮助你更好地理解在特定转换后序列是否平稳。尝试自己重新创建图 5.5。
- en: With a transformation applied to the series, we can verify whether the series
    is stationary by running the ADF test on the differenced series.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对序列应用转换后，我们可以通过在差分序列上运行 ADF 测试来验证序列是否平稳。
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Run the ADF test on the differenced time series.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对差分时间序列运行 ADF 测试。
- en: This prints out an ADF statistic of –5.27 and a p-value of 6.36×10^(–6). With
    a p-value smaller than 0.05, we can reject the null hypothesis, meaning that we
    now have a stationary series.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出 ADF 统计量为 –5.27 和 p 值为 6.36×10^(–6)。由于 p 值小于 0.05，我们可以拒绝零假设，这意味着我们现在有一个平稳序列。
- en: The next step is to plot the ACF and see if there is autocorrelation and if
    the coefficients become abruptly non-significant after a certain lag. As we did
    in the two previous chapters, we will use the `plot_acf` function from `statsmodels`.
    The result is shown in figure 5.6.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是绘制 ACF 图，看看是否存在自相关，以及系数在某个滞后后是否突然变得不显著。正如我们在前两个章节中所做的那样，我们将使用 `statsmodels`
    中的 `plot_acf` 函数。结果显示在图 5.6 中。
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Plot the ACF of the differenced series.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 绘制差分序列的 ACF 图。
- en: '![](../../OEBPS/Images/05-06.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/05-06.png)'
- en: Figure 5.6 ACF plot of the differenced average weekly foot traffic at a retail
    store. Notice how the plot is slowly decaying. This is a behavior that we have
    not observed before, and it is indicative of an autoregressive process.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 零售店平均每周客流量差异的ACF图。注意该图是如何缓慢衰减的。这是我们以前没有观察到的一种行为，它表明了一个自回归过程。
- en: Looking at figure 5.6, you’ll notice that we have significant autocorrelation
    coefficients beyond lag 0\. Therefore, we know that our process is not a random
    walk. Furthermore, you’ll notice that the coefficients are decaying exponentially
    as the lag increases. Therefore, there is no lag at which the coefficients abruptly
    become non-significant. This means that we do not have a moving average process
    and that we are likely studying an autoregressive process.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 观察图5.6，你会注意到我们在滞后0之外有显著的自相关系数。因此，我们知道我们的过程不是一个随机游走。此外，你会注意到随着滞后的增加，系数呈指数衰减。这意味着不存在滞后使得系数突然变得不显著。这意味着我们没有一个移动平均过程，我们很可能在研究一个自回归过程。
- en: When the ACF plot of a stationary process exhibits a pattern of exponential
    decay, we probably have an autoregressive process in play, and we must find another
    way to identify the order *p* of the AR(*p*) process. Specifically, we must turn
    our attention to the *partial autocorrelation function*(PACF) plot.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个平稳过程的ACF图表现出指数衰减的模式时，我们可能有一个自回归过程在起作用，我们必须找到另一种方法来识别AR(*p*)过程的阶数*p*。具体来说，我们必须将注意力转向*偏自相关函数*(PACF)图。
- en: 5.3.1 The partial autocorrelation function (PACF)
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.1 偏自相关函数 (PACF)
- en: In an attempt to identify the order of a stationary autoregressive process,
    we used the ACF plot just as we did for a moving average process. Unfortunately,
    the ACF plot cannot give us this information, and we must turn to the *partial
    autocorrelation function* (PACF).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试识别一个平稳自回归过程的阶数时，我们像移动平均过程一样使用了ACF图。不幸的是，ACF图不能给我们提供这些信息，我们必须转向*偏自相关函数*(PACF)。
- en: Remember that the autocorrelation measures the linear relationship between lagged
    values of a time series. Consequently, the autocorrelation function measures how
    the correlation changes between two values as the lag is increased.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，自相关衡量的是时间序列滞后值之间的线性关系。因此，自相关函数衡量的是随着滞后的增加，两个值之间的相关性如何变化。
- en: 'To understand the partial autocorrelation function, let’s consider the following
    scenario. Suppose we have the following AR(2) process:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解偏自相关函数，让我们考虑以下场景。假设我们有一个以下AR(2)过程：
- en: '*y[t]* = 0.33*y*[*t*–1] + 0.50*y*[*t*–2]'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*y[t]* = 0.33*y*[*t*–1] + 0.50*y*[*t*–2]'
- en: Equation 5.4
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 方程 5.4
- en: We wish to measure how *y[t]* relates to *y*[*t*–2]; in other words, we want
    to measure their correlation. This is done with the autocorrelation function (ACF).
    However, from the equation, we can see that *y*[*t*–1] also has an influence on
    *y[t]*. Even more important, it also has an impact on the value of *y*[*t*–2],
    since in an AR(2) process, each value depends on the previous two values. Therefore,
    when we measure the autocorrelation between *y[t]* and *y*[*t*–2] using the ACF,
    we are not taking into account the fact that *y*[*t*–1] has an influence on both
    *y[t]* and *y*[*t*–2]. This means that we are not measuring the *true*impact of
    *y*[*t*–2] on *y[t]*. To do so, we must remove the effect of *y*[*t*–1]. Thus,
    we are measuring the partial autocorrelation between *y[t]* and *y*[*t*–2].
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望测量*y[t]*与*y*[*t*–2]之间的关系；换句话说，我们想要测量它们的关联性。这是通过自相关函数(ACF)来完成的。然而，从方程中我们可以看出*y*[*t*–1]也对*y[t]*有影响。更重要的是，它还对*y*[*t*–2]的值有影响，因为在AR(2)过程中，每个值都依赖于前两个值。因此，当我们使用ACF测量*y[t]*与*y*[*t*–2]之间的自相关时，我们没有考虑到*y*[*t*–1]对*y[t]*和*y*[*t*–2]都有影响这一事实。这意味着我们并没有测量*y*[*t*–2]对*y[t]*的*真正*影响。为了做到这一点，我们必须消除*y*[*t*–1]的影响。因此，我们正在测量*y[t]*与*y*[*t*–2]之间的偏自相关。
- en: In more formal terms, the partial autocorrelation measures the correlation between
    lagged values in a time series when we remove the influence of correlated lagged
    values in between. Those are known as *confounding variables*. The partial autocorrelation
    function will reveal how the partial autocorrelation varies when the lag increases.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在更正式的术语中，偏自相关衡量的是在去除中间相关滞后值影响的情况下，时间序列中滞后值之间的相关性。这些被称为*混杂变量*。偏自相关函数将揭示当滞后增加时，偏自相关如何变化。
- en: Partial autocorrelation
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 偏自相关
- en: Partial autocorrelation measures the correlation between lagged values in a
    time series when we remove the influence of correlated lagged values in between.
    We can plot the partial autocorrelation function to determine the order of a stationary
    AR(*p*) process. The coefficients will be non-significant after lag *p*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 部分自相关度衡量的是在移除介于相关滞后值之间的影响后，时间序列中滞后值之间的相关性。我们可以绘制部分自相关函数来确定平稳AR(*p*)过程的阶数。在滞后*p*之后，系数将不显著。
- en: Let’s verify whether plotting the PACF will reveal the order of the process
    shown in equation 5.4\. We know from equation 5.4 that we have a second-order
    autoregressive process, or AR(2). We will simulate it using the `ArmaProcess`
    function from `statsmodels`. The function expects an array containing the coefficients
    of an MA(*q*) process and an array containing the coefficients for an AR(*p*)
    process. Since we are only interested in simulating an AR(2) process, we will
    set the coefficients of the MA(*q*) process to 0\. Then, as specified by the `statsmodels`
    documentation, the coefficients of the AR(2) process must have opposite signs
    to those we wish to simulate. Therefore, the array will contain–0.33 and–0.50\.
    In addition, the function requires us to include the coefficient at lag 0, which
    is the number that multiplies *y[t]*. Here, that number is simply 1.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证绘制PACF是否能够揭示方程5.4中所示过程的阶数。从方程5.4中我们知道我们有一个二阶自回归过程，即AR(2)。我们将使用`statsmodels`库中的`ArmaProcess`函数来模拟它。该函数期望一个包含MA(*q*)过程系数的数组和一个包含AR(*p*)过程系数的数组。由于我们只对模拟AR(2)过程感兴趣，我们将MA(*q*)过程的系数设为0。然后，根据`statsmodels`文档的说明，AR(2)过程的系数必须与我们希望模拟的系数符号相反。因此，数组将包含-0.33和-0.50。此外，该函数要求我们包括滞后0的系数，即乘以*y[t]*的数字。在这里，这个数字是1。
- en: Once the arrays of coefficients are defined, we can feed them to the `ArmaProcess`
    function, and we will generate 1,000 samples. Make sure you set the random seed
    to 42 in order to reproduce the results shown here.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了系数数组，我们就可以将它们输入到`ArmaProcess`函数中，并将生成1,000个样本。确保将随机种子设置为42，以便重现这里显示的结果。
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Set the random seed to 42 in order to reproduce the results shown here.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将随机种子设置为42，以便重现这里显示的结果。
- en: ❷ Set the coefficients of the MA(q) process to 0, since we are only interested
    in simulating an AR(2) process. Note that the first coefficient is 1 for lag 0,
    and it must be provided as specified by the documentation.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将MA(q)过程的系数设为0，因为我们只对模拟AR(2)过程感兴趣。请注意，滞后0的第一个系数是1，必须按照文档规定提供。
- en: ❸ Set the coefficients for the AR(2) process. Again, the coefficient at lag
    0 is 1\. Then, write the coefficients with opposite signs to what was defined
    in equation 5.4, as specified by the documentation.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 设置AR(2)过程的系数。同样，滞后0的系数是1。然后，按照文档规定，将系数写成与方程5.4中定义的相反的符号。
- en: ❹ Simulate the AR(2) process and generate 1,000 samples.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 模拟AR(2)过程并生成1,000个样本。
- en: Now that we have a simulated AR(2) process, let’s plot the PACF and see if the
    coefficients become abruptly non-significant after lag 2\. If that is the case,
    we’ll know that we can use the PACF plot to determine the order of a stationary
    autoregressive process, just as we can use the ACF plot to determine the order
    of a stationary moving average process.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经模拟了一个AR(2)过程，让我们绘制PACF图，看看系数是否在滞后2后突然变得不显著。如果是这样，我们就知道我们可以使用PACF图来确定平稳自回归过程的阶数，就像我们可以使用ACF图来确定平稳移动平均过程的阶数一样。
- en: The `statsmodels` library allows us to plot the PACF rapidly. We can use the
    `plot_pacf` function, which simply requires our series and the number of lags
    to display on the plot.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`statsmodels`库允许我们快速绘制PACF图。我们可以使用`plot_pacf`函数，该函数只需要我们的序列和要在图上显示的滞后数。'
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Plot the PACF of our simulated AR(2) process.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 绘制我们模拟的AR(2)过程的PACF图。
- en: The resulting plot is shown in figure 5.7, and it shows that we have an autoregressive
    process of order 2.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图如图5.7所示，它显示我们有一个阶数为2的自回归过程。
- en: '![](../../OEBPS/Images/05-07.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/05-07.png)'
- en: Figure 5.7 Plot of the PACF for our simulated AR(2) process. You can clearly
    see here that after lag 2, the partial autocorrelation coefficients are not significantly
    different from 0\. Therefore, we can identify the order of a stationary AR(*p*)
    model using the PACF plot.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 模拟AR(2)过程的PACF图。你可以清楚地看到，在滞后2之后，部分自相关系数与0没有显著差异。因此，我们可以使用PACF图来识别平稳AR(*p*)模型的阶数。
- en: We now know that we can use the PACF plot to identify the order of a stationary
    AR(*p*) process. The coefficients in the PACF plot will be significant up until
    lag *p*. Afterward, they should not be significantly different from 0.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道我们可以使用PACF图来识别平稳AR(*p*)过程的阶数。PACF图中的系数将在滞后*p*之前是显著的。之后，它们应该不会与0显著不同。
- en: Let’s see if we can apply the same strategy to our average weekly foot traffic
    dataset. We made the series stationary and saw that the ACF plot exhibited a slowly
    decaying trend. Let’s plot the PACF to see if the lags become non-significant
    after a particular lag.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们是否可以将相同的策略应用到我们的平均每周客流量数据集上。我们使序列平稳，并看到ACF图显示了缓慢衰减的趋势。让我们绘制PACF图，看看在特定的滞后之后滞后是否变得不显著。
- en: The process is exactly the same as what we just did, but this time we will plot
    the PACF of our differenced series stored in `foot_traffic_diff`. You can see
    the resulting plot in figure 5.8.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程与我们刚才做的是一样的，但这次我们将绘制存储在`foot_traffic_diff`中的差分序列的PACF图。你可以看到结果图在图5.8中。
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Plot the PACF of our differenced series.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 绘制差分序列的PACF图。
- en: Looking at figure 5.8, you can see that there are no significant coefficients
    after lag 3\. Therefore, the differenced average weekly foot traffic is an autoregressive
    process of order 3, which can also be denoted as AR(3).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 观察图5.8，你可以看到在滞后3之后没有显著的系数。因此，差分的平均每周客流量是一个3阶的自回归过程，也可以表示为AR(3)。
- en: '![](../../OEBPS/Images/05-08.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/05-08.png)'
- en: Figure 5.8 The PACF of our differenced average weekly foot traffic in a retail
    store. You can see that the coefficients are non-significant after lag 3\. Therefore,
    we can say that our stationary process is a third-order autoregressive process,
    or an AR(3) process.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 零售店差分平均每周客流量的PACF图。你可以看到在滞后3之后系数不再显著。因此，我们可以说我们的平稳过程是一个三阶自回归过程，或者是一个AR(3)过程。
- en: 5.4 Forecasting an autoregressive process
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 预测自回归过程
- en: Once the order is determined, we can fit an autoregressive model to forecast
    our time series. In this case, the model is also termed AR(*p*), where *p* is
    still the order of the process.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了阶数，我们就可以拟合一个自回归模型来预测我们的时间序列。在这种情况下，该模型也称为AR(*p*)，其中*p*仍然是过程的阶数。
- en: We will forecast next week’s average foot traffic in a retail store using the
    same dataset we have been working with. In order to evaluate our forecasts, we
    will hold out the last 52 weeks of data for our test set, while the rest will
    be used for training. That way, we can evaluate the performance of our forecast
    over a period of 1 year.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们一直在使用的相同数据集来预测下周零售店的平均客流量。为了评估我们的预测，我们将保留最后52周的数据作为测试集，其余的将用于训练。这样，我们就可以评估我们的预测在1年期间的表现。
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Create a DataFrame from the differenced foot traffic data.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从差分客流量数据创建一个DataFrame。
- en: ❷ The training set is all the data except the last 52 data points.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 训练集是除了最后52个数据点之外的所有数据。
- en: ❸ The test set is the last 52 data points.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 测试集是最后52个数据点。
- en: ❹ Display how many data points are in the train set.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 显示训练集中有多少个数据点。
- en: ❺ Display how many data points are in the test set.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 显示测试集中有多少个数据点。
- en: You can see that our training set contains 947 data points, while the test set
    contains 52 data points as expected. Note that the sum of both sets gives 999,
    which is one less data point than our original series. This is normal, since we
    applied differencing to make the series stationary, and we know that differencing
    removes the first data point from the series.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们的训练集包含947个数据点，而测试集包含52个数据点，正如预期的那样。请注意，两个集合的总和为999，比我们原始序列少一个数据点。这是正常的，因为我们应用了差分来使序列平稳，而且我们知道差分会从序列中移除第一个数据点。
- en: Next, we will visualize the testing period for our scenario, in both the original
    series and the differenced series. The plot is shown in figure 5.9.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将可视化我们场景的测试期，包括原始序列和差分序列。该图显示在图5.9中。
- en: '![](../../OEBPS/Images/05-09.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/05-09.png)'
- en: Figure 5.9 Testing period for our forecasts on the original and differenced
    series. Keep in mind that our differenced series has lost its first data point.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 原始序列和差分序列的预测测试期。记住，我们的差分序列已经失去了第一个数据点。
- en: '[PRE10]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Specify the figure’s size using the figsize parameter. The first number is
    the height, and the second number is the width, both in inches.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用figsize参数指定图的大小。第一个数字是高度，第二个数字是宽度，两者都以英寸为单位。
- en: Given that our objective is to forecast next week’s average foot traffic at
    the retail store, we will perform rolling forecasts over our test set. Remember
    that our data was recorded over a weekly period, so predicting the next timestep
    means we’re forecasting next week’s average foot traffic.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的目标是预测下周零售店的平均客流量，我们将对测试集进行滚动预测。记住，我们的数据是在每周期间记录的，所以预测下一个时间步长意味着我们正在预测下周的平均客流量。
- en: We will forecast using three different methods. The historical mean method and
    the last known value method will act as baselines, and we will use an AR(3) model,
    since we previously established that we have a stationary third-order autoregressive
    process. As we did in the previous chapter, we will use the mean squared error
    (MSE) to evaluate the performance of each forecasting method.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用三种不同的方法进行预测。历史平均方法和最后已知值方法将作为基线，我们将使用 AR(3) 模型，因为我们之前已经确定我们有一个三阶自回归过程。正如我们在上一章所做的那样，我们将使用均方误差
    (MSE) 来评估每种预测方法的性能。
- en: Also, we will reuse the function we defined in the previous chapter to recursively
    forecast over the testing period. However, this time we must include a method
    to use an autoregressive model.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将重复使用我们在上一章中定义的函数，在测试期间进行递归预测。然而，这次我们必须包括一个使用自回归模型的方法。
- en: We will again use the SARIMAX function from `statsmodels`, as it encompasses
    an AR model. As mentioned previously, SARIMAX is a complex model that allows us
    to consider seasonal effects, autoregressive processes, non-stationary time series,
    moving average processes, and exogenous variables all in one single model. For
    now, we will disregard all factors except the moving autoregressive portion.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用 `statsmodels` 中的 SARIMAX 函数，因为它包含 AR 模型。如前所述，SARIMAX 是一个复杂的模型，它允许我们在一个单一模型中考虑季节效应、自回归过程、非平稳时间序列、移动平均过程和外生变量。现在，我们将忽略所有因素，除了移动自回归部分。
- en: Listing 5.1 A function for rolling forecasts on a horizon
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.1 用于在预测范围内进行滚动预测的函数
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ The order specifies an AR(3) model.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 指定 AR(3) 模型的阶数。
- en: Once our function is defined, we can use it to generate the predictions according
    to each method. We will assign them to their own column in `test`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的函数定义好了，我们就可以用它来根据每种方法生成预测。我们将它们分配给 `test` 中的各自列。
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Store the length of the training set. Note that constants are usually in capital
    letters in Python.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 存储训练集的长度。注意，在 Python 中，常量通常用大写字母表示。
- en: ❷ Store the length of the test set.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 存储测试集的长度。
- en: ❸ Since we wish to predict the next timestep, our window is 1.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 由于我们希望预测下一个时间步长，我们的窗口是 1。
- en: ❹ Store the predictions in their respective columns in test.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将预测存储在测试的相应列中。
- en: We can now visualize our predictions against the observed values in the test
    set. Note that we are working with the differenced series, so our predictions
    are also differenced values. The result is shown in figure 5.10.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以可视化我们的预测与测试集中的观测值。请注意，我们正在处理差分序列，因此我们的预测也是差分值。结果如图 5.10 所示。
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Plot part of the training set so we can see the transition from the training
    set to the test set.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 绘制训练集的一部分，以便我们可以看到从训练集到测试集的过渡。
- en: ❷ Plot the values from the test set.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 绘制测试集的值。
- en: ❸ Plot the predictions from the historical mean method.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 绘制历史平均方法预测的结果。
- en: ❹ Plot the predictions from the last known value method.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 绘制最后已知值方法的预测结果。
- en: ❺ Plot the predictions from the AR(3) model.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 绘制 AR(3) 模型的预测结果。
- en: '![](../../OEBPS/Images/05-10.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/05-10.png)'
- en: Figure 5.10 Forecasts of the differenced average weekly foot traffic in a retail
    store
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 零售店平均每周客流量差异的预测
- en: Looking at figure 5.10, you’ll see that, once again, using the historical mean
    produces a straight line, which is shown in the plot as a dotted line. As for
    the predictions from the AR(3) model and the last known value method, the curves
    are almost confounding with that of the test set, so we will have to measure the
    MSE to assess which method is the most performant. Again, we will use the `mean_squared_error`
    function from the `sklearn` library.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 观察图 5.10，你会看到，再次使用历史平均方法产生了一条直线，在图中以虚线表示。至于 AR(3) 模型和最后已知值方法的预测，曲线几乎与测试集混淆，因此我们必须测量
    MSE 来评估哪种方法性能最好。同样，我们将使用 `sklearn` 库中的 `mean_squared_error` 函数。
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This prints out an MSE of 3.11 for the historical mean method, 1.45 for the
    last known value method, and 0.92 for the AR(3) model. Since the MSE for the AR(3)
    model is the lowest of the three, we conclude that the AR(3) model is the best-performing
    method for forecasting next week’s average foot traffic. This is expected, since
    we established that our stationary process was a third-order autoregressive process.
    It makes sense that modeling using an AR(3) model will yield the best predictions.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这会输出历史平均方法为3.11的均方误差（MSE），最后已知值为1.45，AR(3)模型为0.92。由于AR(3)模型的MSE是三者中最低的，我们得出结论，AR(3)模型是预测下周平均客流量表现最好的方法。这是预期的，因为我们已经确定我们的平稳过程是一个三阶自回归过程。使用AR(3)模型建模产生最佳预测是有意义的。
- en: Since our forecasts are differenced values, we need to reverse the transformation
    in order to bring our forecasts back to the original scale of the data; otherwise,
    our predictions will not make sense in a business context. To do this, we can
    take the cumulative sum of our predictions and add it to the last value of our
    training set in the original series. This point occurs at index 948, since we
    are forecasting the last 52 weeks in a dataset containing 1,000 points.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的预测是差分值，我们需要进行逆变换，以便将我们的预测值恢复到原始数据尺度；否则，我们的预测在商业环境中将没有意义。为此，我们可以取我们预测值的累积和，并将其加到原始序列训练集的最后一个值上。这个点发生在索引948处，因为我们在一个包含1,000个点的数据集中预测了最后52周。
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Assign the undifferenced predictions to the pred_foot_traffic column in df.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将未微分预测分配给df中的pred_foot_traffic列。
- en: Now we can plot our undifferenced predictions against the observed values in
    the test set of the original series in its original scale.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将我们的未微分预测值与原始序列测试集中的观测值在其原始尺度下进行绘图。
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Plot the actual values.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 绘制实际值。
- en: ❷ Plot the undifferenced predictions.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 绘制未微分预测。
- en: In figure 5.11 you can see that our model (shown as a dashed line) follows the
    general trend of the observed values in the test set.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在图5.11中，你可以看到我们的模型（以虚线表示）遵循测试集中观测值的一般趋势。
- en: '![](../../OEBPS/Images/05-11.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/05-11.png)'
- en: Figure 5.11 Undifferenced forecasts from the AR(3) model
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.11 AR(3)模型的未微分预测
- en: Now we can measure the mean absolute error (MAE) on the original dataset to
    get its meaning in a business context. We’ll simply measure the MAE using the
    undifferenced predictions.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以对原始数据集测量平均绝对误差（MAE），以在商业环境中获得其意义。我们将简单地使用未微分预测来测量MAE。
- en: '[PRE17]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This prints out a mean absolute error of 3.45\. This means that our predictions
    are off by 3.45 people on average, either above or below the actual value for
    the week’s foot traffic. Note that we report the MAE because it has a simple business
    meaning that is easy to understand and interpret.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这会输出平均绝对误差为3.45。这意味着我们的预测值平均偏离实际值3.45人，无论是高于还是低于每周客流量。请注意，我们报告MAE是因为它具有简单易懂的商业意义，易于理解和解释。
- en: 5.5 Next steps
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5 下一步
- en: In this chapter, we covered the autoregressive process and how it can be modeled
    by an AR(*p*) model, where *p* is the order, and it determines how many lagged
    values are included in the model. We also saw how plotting the ACF cannot help
    us determine the order of a stationary AR(*p*) process. Instead, we must plot
    the PACF, in which the partial autocorrelation coefficients will be significant
    up until lag *p* only.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了自回归过程以及它如何通过AR(*p*)模型进行建模，其中*p*是阶数，它决定了模型中包含多少滞后值。我们还看到了如何绘制ACF不能帮助我们确定平稳AR(*p*)过程的阶数。相反，我们必须绘制PACF，其中偏自相关系数将在滞后*p*时显著。
- en: However, there might be a situation where neither the ACF nor PACF gives us
    information. What if both the ACF and PACF plots exhibit a slow decay or a sinusoidal
    pattern? In that case, there is no order for the MA(*q*) or AR(*p*) process that
    can be inferred. This means that we are facing a more complex process that is
    likely a combination of both an AR(*p*) process and an MA(*q*) process. This is
    called an *autoregressive moving average*(ARMA) process, or ARMA(*p*,*q*), and
    it will the subject of the next chapter.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可能存在一种情况，ACF和PACF都无法提供信息。如果ACF和PACF图都表现出缓慢衰减或正弦波模式，那会怎样？在这种情况下，无法推断出MA(*q*)或AR(*p*)过程的阶数。这意味着我们面临的是一个更复杂的过程，它很可能是AR(*p*)过程和MA(*q*)过程的组合。这被称为*自回归移动平均*(ARMA)过程，或ARMA(*p*,*q*)，它将是下一章的主题。
- en: 5.6 Exercises
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.6 练习
- en: 'Test your knowledge and mastery of the AR(*p*) model with these exercises.
    The solutions to all exercises are available on GitHub: [https://github.com/marcopeix/Time
    SeriesForecastingInPython/tree/master/CH05](https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH05).'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些练习测试你对AR(*p*)模型的知识和掌握。所有练习的解决方案都可以在GitHub上找到：[https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH05](https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH05)。
- en: 5.6.1 Simulate an AR(2) process and make forecasts
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6.1 模拟AR(2)过程并进行预测
- en: 'Simulate a stationary AR(2) process. Use the `ArmaProcess` function from the
    `statsmodels` library and simulate this process:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟一个平稳的AR(2)过程。使用`statsmodels`库中的`ArmaProcess`函数模拟此过程：
- en: '*y[t]* = 0.33*y*[*t*–1] + 0.50*y*[*t*–2]'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*y[t]* = 0.33*y*[*t*–1] + 0.50*y*[*t*–2]'
- en: For this exercise, generate 1,000 samples.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个练习，生成1,000个样本。
- en: '[PRE18]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Set the seed for reproducibility. Change the seed if you want to experiment
    with different values.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❶ 设置种子以实现可重复性。如果你想尝试不同的值，可以更改种子。
- en: Plot your simulated autoregressive process.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制你的模拟自回归过程图。
- en: Run the ADF test and check if the process is stationary. If not, apply differencing.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行ADF测试，检查过程是否平稳。如果不平稳，则应用差分。
- en: Plot the ACF. Is it slowly decaying?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制自相关函数（ACF）。它是缓慢衰减的吗？
- en: Plot the PACF. Are there significant coefficients after lag 2?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制PACF。在滞后2之后有显著的系数吗？
- en: Separate your simulated series into train and test sets. Take the first 800
    timesteps for the train set and assign the rest to the test set.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的模拟序列分为训练集和测试集。取前800个时间步长作为训练集，其余的分配给测试集。
- en: Make forecasts over the test set. Use the historical mean method, last known
    value method, and an AR(2) model. Use the `rolling_forecast` function, and use
    a `window` length of 2.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试集上进行预测。使用历史均值法、最后已知值法和AR(2)模型。使用`rolling_forecast`函数，并使用窗口长度为2。
- en: Plot your forecasts.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制你的预测图。
- en: Measure the MSE, and identify your champion model.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测量MSE，并确定你的冠军模型。
- en: Plot your MSEs in a bar plot.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在条形图中绘制你的MSE。
- en: 5.6.2 Simulate an AR(p) process and make forecasts
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6.2 模拟AR(p)过程并进行预测
- en: Recreate the previous exercise but simulate an AR(*p*) process of your choice.
    Experiment with a third- or fourth-order autoregressive process. I would recommend
    generating 10,000 samples.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 重新创建之前的练习，但模拟一个你选择的AR(*p*)过程。尝试使用三阶或四阶自回归过程。我建议生成10,000个样本。
- en: When forecasting, experiment with different values for the `window` parameter
    of your `rolling_forecast` function. How does it affect the model’s performance?
    Is there a value that minimizes the MSE?
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在预测时，尝试调整`rolling_forecast`函数的`window`参数的不同值。它如何影响模型的表现？是否存在一个值可以最小化均方误差（MSE）？
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: An autoregressive process states that the present value is linearly dependent
    on its past values and an error term.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自回归过程表明当前值与其过去值和一个误差项线性相关。
- en: If the ACF plot of a stationary process shows a slow decay, then you likely
    have an autoregressive process.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个平稳过程的ACF图显示缓慢衰减，那么你很可能有一个自回归过程。
- en: The partial autocorrelation measures the correlation between two lagged values
    of a time series when you remove the effect of the other autocorrelated lagged
    values.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分自相关衡量的是在移除其他自相关滞后值的影响后，时间序列两个滞后值之间的相关性。
- en: Plotting the PACF of a stationary autoregressive process will show the order
    *p* of the process. The coefficients will be significant up until lag *p* only.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制一个平稳自回归过程的PACF将显示过程的阶数*p*。系数将仅在滞后*p*时显著。
