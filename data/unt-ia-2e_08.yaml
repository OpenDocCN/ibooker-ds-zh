- en: 6 Creating a basic 2D platformer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 创建基本2D平台游戏
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Moving sprites around continuously
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续移动精灵
- en: Playing sprite-sheet animation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放精灵图集动画
- en: Working with 2D physics (collision, gravity)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用2D物理（碰撞、重力）
- en: Implementing camera control for side-scrolling games
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现侧滚动游戏的相机控制
- en: 'Let’s create a new game and continue learning about Unity’s 2D functionality.
    Chapter 5 covered the fundamental concepts, so this chapter builds on those to
    create a more elaborate game. Specifically, you are going to build the core functionality
    of a 2D platform game. Also called a *platformer*, this common type of 2D action
    game is best known for classics like *Super Mario Brothers*: a character viewed
    from the side runs and jumps on platforms, and the view scrolls around to follow.
    Figure 6.1 shows what the end result will be.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的游戏，继续学习Unity的2D功能。第五章介绍了基本概念，所以本章将在这些基础上创建一个更复杂的游戏。具体来说，你将构建一个2D平台游戏的核心功能。也称为*平台游戏机*，这种常见的2D动作游戏以经典游戏如*超级马里奥兄弟*最为知名：从侧面观看的角色在平台上奔跑和跳跃，视图滚动以跟随。图6.1显示了最终结果。
- en: '![CH06_F01_Hocking3](../Images/CH06_F01_Hocking3.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F01_Hocking3](../Images/CH06_F01_Hocking3.png)'
- en: Figure 6.1 The final product of this chapter
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1本章的最终产品
- en: This project will teach concepts like moving the player left and right, playing
    the sprite’s animation, and adding the ability to jump. We’ll also go over several
    special features common in platform games, like one-way floors and moving platforms.
    Going from this shell to a full game mostly means repeating those concepts over
    and over.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目将教授如何左右移动玩家、播放精灵动画以及添加跳跃能力等概念。我们还将介绍平台游戏中常见的几个特殊功能，如单向地板和移动平台。从这个外壳到完整游戏的过程基本上意味着反复重复这些概念。
- en: 'To get started, create a new project in 2D mode as in the last chapter: from
    Unity Hub, choose New, or from the File menu choose New Project; then select 2D
    in the window that appears. In the new project, create two folders, called Sprites
    and Scripts, to contain the various assets. You could adjust the camera as in
    chapter 5, but for now just reduce Size to 4. This project doesn’t require a perfect
    camera setup, although you would need to adjust the size for a polished game that’s
    ready for release.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请像上一章一样在2D模式下创建一个新项目：从Unity Hub中选择新建，或从文件菜单中选择新建项目；然后在出现的窗口中选择2D。在新项目中，创建两个文件夹，分别命名为
    Sprites 和 Scripts，以包含各种资源。你可以调整相机，就像第五章中那样，但现在只需将大小减少到4。这个项目不需要完美的相机设置，尽管你可能需要调整大小以制作一个准备发布的精良游戏。
- en: TIP The camera icon in the center of the screen can get in the way, so you can
    hide it by using the Gizmos menu. Along the top of the Scene view is a label for
    Gizmos. That term refers to the abstract shapes and icons in the editor. Click
    Gizmos for an alphabetical list and then click the icon next to Camera.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：屏幕中央的相机图标可能会碍事，因此您可以使用Gizmos菜单将其隐藏。在场景视图的顶部有一个Gizmos的标签。该术语指的是编辑器中的抽象形状和图标。点击Gizmos，然后点击旁边的Camera图标，即可看到一个按字母顺序排列的列表。
- en: Now save the empty scene (and of course click Save periodically while you work)
    to create the Scene asset in this project. Everything is empty at the moment,
    so the first step will be bringing in art assets.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在保存空场景（当然，在您工作时定期点击保存），以在这个项目中创建场景资产。目前一切都是空的，所以第一步将是引入艺术资产。
- en: 6.1 Setting up the graphics
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 设置图形
- en: Before you can program the functionality of a 2D platform game, you need to
    import images into the project (remember, images in a 2D game are referred to
    as *sprites* instead of *textures*) and then place those sprites into the scene.
    This game will be the shell of a 2D platform game, with a player-controlled character
    running around a basic and mostly empty scene, so all you need are a couple of
    sprites for the platforms and for the player. Let’s go over each separately, because
    although the images in this example are simple, some nonobvious considerations
    are involved.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在您能够编程2D平台游戏的功能之前，您需要将图像导入到项目中（记住，2D游戏中的图像被称为*精灵*而不是*纹理*），然后将这些精灵放置到场景中。这个游戏将是2D平台游戏的外壳，玩家控制的字符在一个基本且大部分为空的场景中奔跑，所以您只需要几个用于平台的精灵和用于玩家的精灵。让我们分别介绍每个，因为尽管这个例子中的图像很简单，但其中涉及一些不明显的考虑因素。
- en: 6.1.1 Placing the scenery
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.1 放置场景
- en: Simply put, you need a single blank white image to use here. An image called
    blank.png is included in the sample project for this chapter; download the sample
    project and copy blank.png from there. Then drag the PNG into the Sprites folder
    of your new project, and make sure in the Inspector that Import Settings indicate
    it’s a Sprite rather than a Texture (that should be automatic for a 2D project,
    but it’s worth double-checking).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，你需要一个单独的空白白色图像来使用。一个名为blank.png的图像包含在本章的示例项目中；下载示例项目，并从那里复制blank.png。然后将PNG拖入新项目的
    Sprites 文件夹中，并在检查器中确保导入设置表明它是一个精灵而不是纹理（对于2D项目应该是自动的，但值得再次检查）。
- en: What you’re doing now is essentially the same as the whiteboxing from chapter
    4, but in 2D instead of 3D. Whiteboxing in 2D is done with sprites rather than
    meshes but maintains the same activity of blocking out blank floors and walls
    for the player to move around.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在所做的是本质上与第4章中的白盒化相同，但是在2D而不是3D中。2D中的白盒化使用精灵而不是网格，但保持了为玩家阻挡空白地板和墙壁的活动。
- en: To place the floor object, drag the blank sprite into the scene as shown in
    figure 6.2 (around Position 0.15, -1.27, 0), set Scale to 50, 2, 1, and change
    its name to Floor. Then drag in another blank sprite, set its Scale to 6, 6, 1,
    place it on the floor off to the right (around Position 2, -0.63, 0), and name
    it Block
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要放置地板对象，将空白精灵拖动到场景中，如图6.2所示（大约位置0.15, -1.27, 0），将缩放设置为50, 2, 1，并将其名称更改为Floor。然后拖入另一个空白精灵，将其缩放设置为6,
    6, 1，将其放置在右侧的地板上（大约位置2, -0.63, 0），并将其命名为Block。
- en: '![CH06_F02_Hocking3](../Images/CH06_F02_Hocking3.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F02_Hocking3](../Images/CH06_F02_Hocking3.png)'
- en: Figure 6.2 Floor platform placement
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 地板平台放置
- en: Simple enough; now the floor and block are done. The other object you need is
    a character for the player.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 足够简单；现在地板和方块已经完成。你还需要另一个对象，即玩家的角色。
- en: 6.1.2 Importing sprite sheets
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.2 导入精灵图集
- en: 'The only other art asset you need is the player’s sprite, so also copy stickman.png
    from the sample project. But unlike the blank image, this PNG is a series of separate
    sprites assembled into one image. As shown in figure 6.3, the stickman image is
    the frames of two animations: standing idle and a walk cycle.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要的唯一其他艺术资产是玩家的精灵，因此也从示例项目中复制stickman.png。但与空白图像不同，这个PNG是一系列单独的精灵组合成的一个图像。如图6.3所示，stickman图像是两个动画的帧：站立空闲和行走循环。
- en: '![CH06_F03_Hocking3](../Images/CH06_F03_Hocking3.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F03_Hocking3](../Images/CH06_F03_Hocking3.png)'
- en: Figure 6.3 Stickman sprite sheet—six frames in a row
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 Stickman精灵图集——一行六帧
- en: We’re not going into detail on how to animate, but suffice to say that *idle*
    and *cycle* are both common terms used by game developers. Idle refers to subtle
    movement while doing nothing, and cycle is an animation that loops continuously.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细介绍如何动画化，但可以说*空闲*和*循环*是游戏开发者常用的术语。空闲指的是在无所事事时的微妙动作，而循环则是一个持续循环的动画。
- en: As explained in chapter 5, an image file may be a bunch of sprite images packed
    together, rather than just a single sprite. Images like this are called *sprite
    sheets* when the multiple sprite images are frames of an animation. In Unity,
    an image imported as multiple sprites will still appear in the Project view as
    a single asset, but if you click the arrow on the asset, it’ll expand and show
    all the individual sprite images. Figure 6.4 shows how that looks.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如第5章所述，一个图像文件可能是一系列精灵图像打包在一起，而不仅仅是一个精灵。当多个精灵图像是动画的帧时，这样的图像被称为*精灵图集*。在Unity中，作为多个精灵导入的图像在项目视图中仍然作为一个单一资产出现，但如果点击资产上的箭头，它将展开并显示所有单个精灵图像。图6.4显示了它的样子。
- en: '![CH06_F04_Hocking3](../Images/CH06_F04_Hocking3.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F04_Hocking3](../Images/CH06_F04_Hocking3.png)'
- en: Figure 6.4 Slicing a sprite sheet into separate frames
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 将精灵图集切割成单独的帧
- en: Drag stickman.png into the Sprites folder to import the image, but this time
    change a lot of Import Settings in the Inspector. Select the sprite asset, set
    Sprite Mode to Multiple, and then click Sprite Editor to open that window. Click
    Slice at the top left of the window, set Type to Grid By Cell Size (shown in figure
    6.4), use Size 32, 64 (this is the size of each frame in the sprite sheet), and
    click Slice to see the frames split up. Now close the Sprite Editor window and
    click Apply to keep the changes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 将stickman.png拖入 Sprites 文件夹以导入图像，但这次在检查器中更改许多导入设置。选择精灵资产，将精灵模式设置为多个，然后点击精灵编辑器打开该窗口。在窗口的左上角点击切片，将类型设置为按单元格大小网格（如图6.4所示），使用大小32,
    64（这是精灵图集中每个帧的大小），然后点击切片以查看帧被分割。现在关闭精灵编辑器窗口，并点击应用以保留更改。
- en: NOTE The Sprite Editor window requires the 2D Sprite package. Creating a new
    2D project should have automatically installed that package, but if not, then
    open Window > Package Manager and look for 2D Sprite in the list on the left side
    of the window. Select that package and then click the Install button.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Sprite 编辑器窗口需要 2D Sprite 包。创建新的 2D 项目应该会自动安装该包，但如果未安装，请打开“窗口”>“包管理器”，并在窗口左侧的列表中查找
    2D Sprite。选择该包，然后点击“安装”按钮。
- en: WARNING The buttons on top of the Sprite Editor window get hidden if the window
    is too small. If you don’t see the Slice button, try dragging the corner of the
    window to resize it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：如果窗口太小，Sprite 编辑器窗口顶部的按钮会被隐藏。如果您看不到“切片”按钮，请尝试拖动窗口的角落来调整大小。
- en: The sprite asset is now split up, so click the arrow to expand the frames. Drag
    one (probably the first) stickman sprite into the scene, place it standing on
    the middle of the floor, and name it Player. There, the player object is in the
    scene!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在精灵资产已被拆分，所以点击箭头展开帧。将一个（可能是第一个）棍子人精灵拖入场景，将其放置在地板中间，并命名为 Player。在那里，玩家对象已经出现在场景中！
- en: 6.2 Moving the player left and right
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 移动玩家左右
- en: Now that the graphics are set up, let’s start programming the player’s movement.
    First off, the player entity in the scene needs a couple of additional components
    for us to control. As mentioned briefly in previous chapters, the physics simulation
    in Unity acts on objects with the special Rigidbody component, and you want physics
    (collisions and gravity in particular) to act on the character.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在图形设置好了，让我们开始编写玩家的移动代码。首先，场景中的玩家实体需要一些额外的组件，以便我们控制。如前几章简要提到的，Unity 中的物理模拟作用于具有特殊
    Rigidbody 组件的对象，您希望物理（特别是碰撞和重力）作用于角色。
- en: 'Meanwhile, the character also needs a Collider component to define its boundaries
    for collision detection. The difference between these components is subtle but
    important: the Collider defines the shape for physics to act on, and the Rigidbody
    tells the physics simulation what objects to act on.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，角色还需要一个 Collider 组件来定义其碰撞检测的边界。这些组件之间的区别微妙但很重要：Collider 定义了物理作用的对象形状，而 Rigidbody
    告诉物理模拟哪些对象要作用。
- en: NOTE These components are kept separate (even though they are closely related)
    because many objects that don’t need the physics simulation themselves *do* need
    to collide with other objects that *are* acted on by physics.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这些组件被保留为独立（尽管它们密切相关），因为许多不需要物理模拟的对象确实需要与其他受物理作用的对象发生碰撞。
- en: One other subtlety to be aware of is that Unity has a separate physics system
    for 2D games instead of 3D physics. Thus, in this chapter you’ll be using components
    from the Physics 2D section instead of the regular Physics section of the list.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的微妙之处是，Unity 为 2D 游戏有一个独立的物理系统，而不是 3D 物理。因此，在本章中，您将使用来自 Physics 2D 部分的组件，而不是列表中的常规
    Physics 部分。
- en: Select Player in the scene. In the Inspector, click Add Component and then choose
    Physics 2D > Rigidbody 2D, as shown in figure 6.5\. Then click Add Component again
    to add Physics 2D > Box Collider 2D. The Rigidbody needs a small amount of fine-tuning,
    so in the Inspector set Collision Detection as Continuous, turn on Constraints
    > Freeze Rotation Z (normally, the physics simulation will attempt to rotate objects
    while moving them, but characters in games don’t behave like normal objects),
    and reduce Gravity Scale to 0 (you’ll reset this later, but for now you don’t
    want gravity). The player entity is now ready for the script that controls movement.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景中选择 Player。在检查器中，点击“添加组件”，然后选择“Physics 2D”>“Rigidbody 2D”，如图 6.5 所示。然后再次点击“添加组件”以添加“Physics
    2D”>“Box Collider 2D”。Rigidbody 需要一些微调，因此在检查器中将碰撞检测设置为连续，开启“约束”>“冻结旋转 Z”（通常，物理模拟在移动对象时会尝试旋转对象，但游戏中的角色不像普通对象那样表现），并将重力比例减少到
    0（您稍后会重置此设置，但现在您不希望有重力）。玩家实体现在已准备好控制移动的脚本。
- en: '![CH06_F05_Hocking3](../Images/CH06_F05_Hocking3.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F05_Hocking3](../Images/CH06_F05_Hocking3.png)'
- en: Figure 6.5 Add and adjust the Rigidbody 2D component
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 添加和调整 Rigidbody 2D 组件
- en: 6.2.1 Writing keyboard controls
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.1 编写键盘控制
- en: To begin, you’ll make the player move left and right; vertical movement is important
    also in a platformer, but you’ll deal with that later. Create a C# script called
    PlatformerPlayer in the Scripts folder, and then drag that onto the Player object
    in the scene. Open the script and write the code from this listing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要让玩家左右移动；在平台游戏中，垂直移动也很重要，但你可以稍后再处理。在 Scripts 文件夹中创建一个名为 PlatformerPlayer
    的 C# 脚本，然后将它拖放到场景中的 Player 对象上。打开脚本并从下面的列表中写入代码。
- en: Listing 6.1 PlatformerPlayer script to move with arrow keys
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.1 使用箭头键移动的 PlatformerPlayer 脚本
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Need this other component attached to this GameObject
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 需要将这个其他组件附加到这个 GameObject 上
- en: ❷ Set only horizontal movement; preserve preexisting vertical movement.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 仅设置水平移动；保留现有的垂直移动。
- en: After writing the code, click Play and you can move the player by using the
    arrow keys. The code is fairly similar to movement code in previous chapters,
    with the main difference being that it acts on Rigidbody2D instead of CharacterController.
    CharacterController is for 3D, so for a 2D game you use a Rigidbody component.
    Note that the movement is applied to Rigidbody’s velocity, rather than something
    like position.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码后，点击播放，你可以使用箭头键来移动玩家。这段代码与前面章节中的移动代码相当相似，主要区别在于它作用于 Rigidbody2D 而不是 CharacterController。CharacterController
    用于 3D 游戏中，所以对于 2D 游戏，你使用 Rigidbody 组件。请注意，移动是应用于 Rigidbody 的速度，而不是像位置这样的东西。
- en: NOTE This code doesn’t need to use delta time. In previous chapters, we needed
    to factor in the time between frames to achieve frame rate-independent movement,
    but we don’t need to do that in this chapter. Here, we are adjusting velocity,
    which is inherently frame-rate independent, rather than position. In previous
    chapters, we were adjusting position directly.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: NOTE 这段代码不需要使用 delta time。在前面章节中，我们需要考虑帧之间的时间来达到帧率无关的移动，但在这个章节中我们不需要这样做。在这里，我们正在调整速度，速度本身是帧率无关的，而不是位置。在前面章节中，我们直接调整位置。
- en: TIP By default, Unity applies a bit of acceleration to arrow key input. That
    can feel sluggish for a platformer, though. For snappier control, increase Sensitivity
    and Gravity of Horizontal input to 6. To find those settings, choose Edit > Project
    Settings > Input Manager; you’ll see a long list, but Horizontal is the first
    section.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 默认情况下，Unity 会为箭头键输入应用一点加速度。但对于平台游戏来说，这可能会感觉有点迟缓。为了获得更快的控制，将水平输入的灵敏度（Sensitivity）和重力（Gravity）增加到
    6。要找到这些设置，请选择 Edit > Project Settings > Input Manager；你将看到一个长长的列表，但水平输入是第一个部分。
- en: Great—this project is most of the way there for horizontal movement! You need
    to address only collision detection.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了——这个项目在水平移动方面已经完成了大部分！你只需要解决碰撞检测问题。
- en: 6.2.2 Colliding with the block
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.2 与方块碰撞
- en: 'As you’ve probably noticed, the player walks through the block right now. There
    are no colliders on the floor or block, so the player can move through them. To
    fix this, add Box Collider 2D to Floor and Block: select each object in the scene,
    click Add Component in the Inspector, and choose Physics 2D > Box Collider 2D.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，玩家现在可以直接穿过方块。地板和方块上没有碰撞器，所以玩家可以穿过它们。为了解决这个问题，将 Box Collider 2D 添加到 Floor
    和 Block 上：在场景中选择每个对象，在检查器中点击 Add Component，然后选择 Physics 2D > Box Collider 2D。
- en: And that’s all you need to do! Click Play now, and the player won’t be able
    to move through the block. As with moving the player in chapter 2, if you had
    adjusted the player’s position directly, collision detection wouldn’t work. But
    Unity’s built-in collision detection can work if you apply the movement to the
    player’s physics components. In other words, moving Transform .position would
    have ignored collision detection, so instead you manipulated Rigidbody2D .velocity
    in the movement script.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你需要做的全部！现在点击播放，玩家将无法穿过方块。与第 2 章中移动玩家一样，如果你直接调整了玩家的位置，碰撞检测将不会工作。但如果你将移动应用于玩家的物理组件，Unity
    的内置碰撞检测就可以工作。换句话说，移动 Transform.position 会忽略碰撞检测，所以在这里你是在移动脚本中操作 Rigidbody2D.velocity。
- en: Adding colliders to more complex art could be slightly trickier, but frankly
    not much harder in that case. Even if the art is not exactly a rectangle, you
    may still want to use box colliders and roughly surround the shape of obstacles
    in the scene. Alternatively, you could try other collider shapes, including arbitrary
    custom polygon shapes. Figure 6.6 illustrates how to work with polygon colliders
    for oddly shaped objects.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 将碰撞器添加到更复杂的艺术作品中可能稍微有点困难，但坦白说，在那个情况下并不难很多。即使艺术作品不是精确的矩形，你可能仍然想使用盒子碰撞器，并大致包围场景中障碍物的形状。或者，你也可以尝试其他碰撞器形状，包括任意的自定义多边形形状。图6.6说明了如何与奇形怪状的对象的多边形碰撞器一起工作。
- en: '![CH06_F06_Hocking3](../Images/CH06_F06_Hocking3.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F06_Hocking3](../Images/CH06_F06_Hocking3.png)'
- en: Figure 6.6 Edit the shape of the polygon collider with the Edit Collider button.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 使用编辑碰撞器按钮编辑多边形碰撞器的形状。
- en: Anyway, collision detection is now working, so the next step is making the player
    animate along with its movement.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，碰撞检测现在正在工作，所以下一步是让玩家在移动时进行动画。
- en: 6.3 Playing the sprite’s animation
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 播放精灵的动画
- en: When stickman.png was imported, it was split into multiple frames for animating.
    Now let’s *play* that animation, so that the player isn’t sliding around but appears
    to be walking.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当stickman.png被导入时，它被分割成多个帧以进行动画。现在让我们*播放*这个动画，这样玩家就不会滑动，而是看起来像在行走。
- en: 6.3.1 Explaining the Mecanim animation system
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.1 解释Mecanim动画系统
- en: As mentioned briefly in chapter 4, the animation system in Unity is called *Mecanim*.
    It’s designed so that you can visually set up a complex network of animations
    for a character and then control those animations with a minimum of code. The
    system is most useful for 3D characters (thus, we cover it in more detail in future
    chapters) but is still useful for 2D characters too.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如第4章简要提到的，Unity中的动画系统称为*Mecanim*。它设计得可以让你直观地为一个角色设置复杂的动画网络，然后用最少的代码来控制这些动画。该系统对3D角色最有用（因此，我们将在未来的章节中更详细地介绍它），但对2D角色也很有用。
- en: 'The heart of the animation system is composed of two kinds of assets: *animation*
    clips and *animator* controllers. Notice *animation* versus *animator* : clips
    are the individual animation loops to play, whereas the controller is the network
    controlling when to play animations. This network is a *state machine* diagram,
    and the states in the diagram are different animations that could be playing.
    The controller shifts between states in reaction to conditions it is watching,
    and plays a different animation in each state.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 动画系统的核心由两种类型的资产组成：*动画*剪辑和*动画器*控制器。注意*动画*与*动画器*的区别：剪辑是播放的单独动画循环，而控制器是控制何时播放动画的网络。这个网络是一个*状态机*图，图中的状态是可能播放的不同动画。控制器根据它观察到的条件在状态之间切换，并在每个状态下播放不同的动画。
- en: Unity will create both kinds of assets automatically when you drag a 2D animation
    into the scene. That is, when you drag the frames of an animation into the scene,
    Unity will automatically create an animation clip and an animator controller using
    those frames. As depicted in figure 6.7, expand all the frames of the sprite asset,
    select frames 0-1, drag them into the scene, and type the name stickman_idle in
    the confirmation window.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将2D动画拖入场景时，Unity会自动创建这两种类型的资产。也就是说，当你将动画的帧拖入场景时，Unity会自动使用这些帧创建一个动画剪辑和一个动画控制器。如图6.7所示，展开精灵资产的所有帧，选择帧0-1，将它们拖入场景，并在确认窗口中键入stickman_idle名称。
- en: '![CH06_F07_Hocking3](../Images/CH06_F07_Hocking3.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F07_Hocking3](../Images/CH06_F07_Hocking3.png)'
- en: Figure 6.7 Steps to use sprite-sheet frames in an Animator component
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 在动画组件中使用精灵图帧的步骤
- en: 'The action of dragging frames into the Scene view creates two things in the
    Asset view: a clip named stickman_idle and a controller named stickman_0. This
    action also creates an object called stickman_0 in the scene, but you don’t need
    that, so delete it. Rename the controller stickman with no suffix. Great—you created
    the character’s idle animation!'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 将框架拖入场景视图的动作在资产视图中创建了两个东西：一个名为stickman_idle的剪辑和一个名为stickman_0的控制器。这个动作还在场景中创建了一个名为stickman_0的对象，但你不需要它，所以删除它。将控制器stickman重命名为不带后缀的名称。太好了——你创建了角色的空闲动画！
- en: Now repeat the process for the walk animation. Select frames 2-5, drag them
    into the scene, and name the animation stickman_walk. This time, delete both stickman_2
    in the scene and the new controller in Assets; only one animator controller is
    needed to control both animation clips, so keep the old one and delete stickman_2,
    the newly created one.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重复此过程以进行行走动画。选择帧 2-5，将它们拖入场景，并将动画命名为 stickman_walk。这次，删除场景中的 stickman_2 和新控制器；只需要一个动画控制器来控制两个动画剪辑，因此保留旧的一个并删除
    stickman_2 和新创建的一个。
- en: To apply the controller to your player character, select Player in the scene
    and click Add Component to choose Miscellaneous > Animator. As shown in figure
    6.7, drag the stickman controller into the controller slot in the Inspector. With
    the Player still selected, open Window > Animation > Animator (shown in figure
    6.8). Animations in the Animator window are displayed as blocks, referred to as
    *states*, and the controller switches between states when running. This particular
    controller already has the idle state in it, but you need to add a walking state;
    drag the stickman_walk animation clip from Assets into the Animator window.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要将控制器应用于您的玩家角色，在场景中选择 Player，然后单击 Add Component 以选择 Miscellaneous > Animator。如图
    6.7 所示，将 stickman 控制器拖入检查器中的控制器槽。选择 Player 后，打开 Window > Animation > Animator（如图
    6.8 所示）。Animator 窗口中的动画显示为块，称为 *状态*，控制器在运行时在这些状态之间切换。这个特定的控制器已经包含空闲状态，但您需要添加一个行走状态；将
    stickman_walk 动画剪辑从 Assets 拖入 Animator 窗口。
- en: By default, the idle animation will play too fast. To decrease the idle speed,
    select the idle animation state, and in the right-hand panel set the Speed setting
    to 0.2. With that change, the animations are all set up for the next step.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，空闲动画会播放得太快。要降低空闲速度，选择空闲动画状态，并在右侧面板中将 Speed 设置为 0.2。此更改后，动画已全部设置好，以进行下一步操作。
- en: 6.3.2 Triggering animations from code
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.2 从代码中触发动画
- en: 'Now that you’ve set up animation states in the animator controller, you can
    switch between those states to play the different animations. As mentioned in
    the preceding section, a state machine switches states in reaction to conditions
    it is watching. In Unity’s animation controllers, those conditions are referred
    to as *parameters*, so let’s add one. Figure 6.8 pointed out the relevant controls:
    select the Parameters tab and click the + button for a menu of parameter types.
    Add a float parameter called speed.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经在动画控制器中设置了动画状态，您可以在这些状态之间切换以播放不同的动画。如前所述，状态机根据它所监视的条件来切换状态。在 Unity 的动画控制器中，这些条件被称为
    *参数*，因此让我们添加一个。图 6.8 指出了相关控件：选择 Parameters 选项卡，并单击 + 按钮以显示参数类型菜单。添加一个名为 speed
    的浮点参数。
- en: '![CH06_F08_Hocking3](../Images/CH06_F08_Hocking3.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F08_Hocking3](../Images/CH06_F08_Hocking3.png)'
- en: Figure 6.8 Animator window, showing animation states and transitions
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 动画窗口，显示动画状态和转换
- en: Next, you need to switch between animation states based on that parameter. Right-click
    stickman_idle and select Make Transition; that’ll start dragging out an arrow
    from the idle state. Click stickman_walk to connect to that state, and because
    transitions are unidirectional, also right-click stickman_walk to transition back.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要根据该参数在动画状态之间进行切换。右键单击 stickman_idle 并选择 Make Transition；这将开始从空闲状态拖出箭头。单击
    stickman_walk 以连接到该状态，由于转换是单向的，因此也右键单击 stickman_walk 以返回该状态。
- en: 'Now select the transition from idle (you can click the arrows themselves),
    uncheck Has Exit Time, and click the + at the bottom to add a condition (again,
    shown in figure 6.8). Make the condition speed Greater (than) 0.1 so the states
    will transition in that condition. Now do it again for the walk-to-idle transition:
    select the transition from walk, uncheck Has Exit Time, add a condition, and make
    the condition speed Less (than) 0.1.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在选择从空闲状态到转换（您可以直接单击箭头），取消选中 Has Exit Time，并在底部单击 + 以添加条件（如图 6.8 所示）。将条件设置为速度
    Greater（大于）0.1，以便在满足该条件时状态将进行转换。现在再次为 walk-to-idle 转换执行此操作：选择从 walk 的转换，取消选中 Has
    Exit Time，添加条件，并将条件设置为速度 Less（小于）0.1。
- en: Finally, the PlatformerPlayer script can manipulate the animator controller,
    as shown in this listing.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，PlatformerPlayer 脚本可以操作动画控制器，如本列表所示。
- en: Listing 6.2 Triggering animations along with moving
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.2 在移动过程中触发动画
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Existing code to help show where to position new code
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 现有代码以帮助显示新代码的位置
- en: ❷ Speed is greater than zero even if velocity is negative.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 即使速度为负，速度也大于零。
- en: ❸ Floats aren’t always exact, so compare using Approximately().
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 浮点数并不总是精确的，因此请使用 Approximately() 进行比较。
- en: ❹ When moving, scale positive or negative 1 to face right or left.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 移动时，将比例设置为正或负 1 以面向右或左。
- en: Wow, that was barely any code for controlling the animations! Most of the work
    is handled by Mecanim, and only a small amount of code is needed to operate the
    animations. Play the game and move around to watch the player sprite animate.
    This game is really coming along, so on to the next step!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，控制动画的代码几乎没多少！大部分工作都是由 Mecanim 处理的，只需要很少的代码来操作动画。玩玩游戏，四处移动，观察玩家精灵的动画。这个游戏真的进展得很快，所以接下来进行下一步！
- en: 6.4 Adding the ability to jump
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 添加跳跃能力
- en: The player can move back and forth but isn’t yet moving vertically. Vertical
    movement (both falling off ledges and jumping to higher platforms) is an important
    part of platform games, so let’s implement that next.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家可以来回移动，但还没有进行垂直移动。垂直移动（包括从边缘掉落和跳到更高的平台）是平台游戏的一个重要部分，所以让我们接下来实现它。
- en: 6.4.1 Falling from gravity
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.1 从重力中掉落
- en: 'Somewhat counterintuitively, before you can make the player jump, it needs
    gravity to jump against. As you may recall, earlier you set Gravity Scale to 0
    on the player’s Rigidbody. That was so the player wouldn’t fall because of gravity.
    Well, turn that back to 1 now: select the Player object in the scene, find Rigidbody
    in the Inspector, and then type 1 in Gravity Scale.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有些反直觉，在玩家能够跳跃之前，它需要重力来与之对抗。正如你可能记得的，你之前将玩家的 Rigidbody 的重力比例设置为 0。这样做是为了让玩家不会因为重力而掉落。现在，将其改回
    1：在场景中选择 Player 对象，在检查器中找到 Rigidbody，然后在重力比例中输入 1。
- en: Gravity is now affecting the player, but (assuming you had added a Box Collider
    to the Floor object) the floor is holding them up. Walk off the sides of the floor
    to fall into oblivion. By default, gravity affects the player somewhat weakly,
    so you’ll want to increase the magnitude of its effect. The physics simulation
    includes a global gravity setting, which you can adjust in the Edit menu. Specifically,
    choose Edit > Project Settings > Physics 2D. As shown in figure 6.9, at the top
    of the various controls and settings, you should see Gravity Y; change that to
    -40.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重力正在影响玩家，但（假设你已经向地板对象添加了 Box Collider）地板正在支撑他们。从地板的边缘走开，掉入虚无。默认情况下，重力对玩家的影响相对较弱，所以你将想要增加其影响的大小。物理模拟包括一个全局重力设置，你可以在编辑菜单中调整它。具体来说，选择编辑
    > 项目设置 > 物理设置 2D。如图 6.9 所示，在各个控制和设置的上端，你应该看到重力 Y；将其更改为 -40。
- en: '![CH06_F09_Hocking3](../Images/CH06_F09_Hocking3.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F09_Hocking3](../Images/CH06_F09_Hocking3.png)'
- en: Figure 6.9 Gravity intensity in Physics settings
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 物理设置中的重力强度
- en: 'You may have noticed one subtle issue: the falling player sticks to the side
    of the floor. To see this problem, walk off the edge of the platform and immediately
    reverse direction to move back toward the platform. Ugh, not good! Fortunately,
    Unity makes that easy to fix. Just add the Physics 2D > Platform Effector 2D components
    to Block and Floor. This effector makes objects in the scene behave more like
    platforms in a platform game. Figure 6.10 points out two settings to adjust: Set
    Used By Effector on the collider, and turn off Use One Way on the effector (we’ll
    use this latter setting for other platforms, but not now).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到一个微妙的问题：下落的角色会粘在地板的一侧。为了看到这个问题，从平台边缘走开，然后立即反向移动回到平台。哎呀，不太好！幸运的是，Unity
    使得修复这个问题变得很容易。只需将 Physics 2D > Platform Effector 2D 组件添加到 Block 和 Floor 上。这个效应用户场景中的对象表现得更像平台游戏中的平台。图
    6.10 指出了两个需要调整的设置：在碰撞器上设置 Used By Effector，并在效应用户上关闭 Use One Way（我们将使用这个后者的设置来处理其他平台，但现在不这么做）。
- en: '![CH06_F10_Hocking3](../Images/CH06_F10_Hocking3.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F10_Hocking3](../Images/CH06_F10_Hocking3.png)'
- en: Figure 6.10 Collider and effector settings in the Inspector
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10 检查器中的碰撞器和效应用户设置
- en: That takes care of the downward part of vertical movement, but you still need
    to take care of the upward part.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就处理了垂直运动的下落部分，但你仍然需要处理上升部分。
- en: 6.4.2 Applying an upward impulse
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.2 应用向上的冲量
- en: The next action you need is jumping. That is an upward jolt applied when the
    player clicks the Jump button (we’ll use the spacebar). Although your code directly
    changed the velocity for horizontal movement, you’re going to leave vertical velocity
    alone so gravity can do its work. Instead, objects can be influenced by other
    forces besides gravity, so you’ll add an upward force. Add this code to the PlatformerPlayer
    script.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个需要的行为是跳跃。当玩家点击跳跃按钮（我们将使用空格键）时，会应用一个向上的冲击。虽然你的代码直接改变了水平移动的速度，但你将保持垂直速度不变，以便重力可以发挥作用。相反，除了重力之外，物体还可以受到其他力的作用，所以你会添加一个向上的力。将此代码添加到
    PlatformerPlayer 脚本中。
- en: Listing 6.3 Jumping when pressing the spacebar
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.3 按下空格键时跳跃
- en: '[PRE2]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Existing code to help show where to position new code
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 现有代码以帮助显示新代码的位置
- en: ❷ Add force only when the spacebar is pressed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 仅当按下空格键时才添加力。
- en: The important line is the AddForce() command. The code adds an upward force
    to the Rigidbody and does so in impulse mode. An *impulse* is a sudden jolt, as
    opposed to a continuously applied force. This code, then, applies a sudden upward
    jolt when the spacebar is pressed.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的行是 AddForce() 命令。代码向 Rigidbody 添加向上的力，并以脉冲模式执行。*脉冲*是一种突然的冲击，与持续施加的力相对。因此，当按下空格键时，此代码会施加一个突然向上的冲击。
- en: Meanwhile, gravity continues to affect the jumping player, resulting in a nice
    arc when the player jumps. You may have noticed another issue, however, so let’s
    address that.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，重力继续影响跳跃的玩家，当玩家跳跃时形成了一个漂亮的弧线。然而，你可能已经注意到另一个问题，让我们来解决这个问题。
- en: 6.4.3 Detecting the ground
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.3 检测地面
- en: 'The jump control has one subtle problem: the player can jump in midair! If
    the player is already in midair (either because they jumped or because they are
    falling), pressing the spacebar applies an upward force, but it shouldn’t. Instead,
    the jump control should work only when the player is on the ground. You therefore
    need to detect when the player is on the ground.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 跳跃控制有一个微妙的问题：玩家可以在空中跳跃！如果玩家已经在空中（无论是由于跳跃还是由于下落），按下空格键会施加向上的力，但不应这样做。相反，跳跃控制应该只在玩家在地面上时工作。因此，你需要检测玩家是否在地面上。
- en: Listing 6.4 Checking if the player is on the ground
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.4 检查玩家是否在地面上
- en: '[PRE3]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Get this component to use the player’s collider as an area to check.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 让这个组件使用玩家的碰撞体作为一个检查区域。
- en: ❷ Check below the collider’s min Y values.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查碰撞体的最小 Y 值以下。
- en: ❸ If a collider was detected under the player . . .
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果检测到玩家下方有碰撞体 . . .
- en: ❹ . . . add grounded to the jump condition.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ . . . 将“接地”条件添加到跳跃条件中。
- en: With this code in place, the player can no longer jump in midair. This addition
    to the script checks for colliders below the player and takes them into account
    in the conditional statement for jumping. Specifically, the code first gets the
    bounds of the player’s collision box and then looks for overlapping colliders
    in an area of the same width just below the player. The result of that check is
    stored in the grounded variable and used in the conditional.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码到位后，玩家不能再空中跳跃。此脚本添加的修改检查玩家下方的碰撞体，并在跳跃的条件语句中考虑它们。具体来说，代码首先获取玩家的碰撞框边界，然后在玩家下方相同宽度的区域内寻找重叠的碰撞体。该检查的结果存储在
    grounded 变量中，并在条件语句中使用。
- en: 6.5 Additional features for a platform game
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5 平台游戏附加功能
- en: At this point, the most crucial aspects of the player’s movement, walking and
    jumping, are implemented. Let’s round out this platformer demo by adding new functionality
    to the environment around the player.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，玩家移动的最关键方面，即行走和跳跃，已经实现。让我们通过向玩家周围的环境添加新功能来完善这个平台游戏演示。
- en: Designing levels by using tilemaps
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用瓦片地图设计关卡
- en: For our project, the floors and platforms are blank, white rectangles. A finished
    game should have nicer graphics, but an image the size of a level would be way
    too big for the computer to handle. The most common solution to this problem is
    to use tilemaps. In a nutshell, that’s a technique for constructing a larger,
    combined image out of lots of small tiling images. This image shows an example
    of a tilemap.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的项目，地板和平台是空白、白色的矩形。一个完成的游戏应该有更漂亮的图形，但一个与关卡大小相当的图像对于电脑来说处理起来会太大。解决这个问题的最常见方法是使用瓦片地图。简单来说，这是一种通过许多小块瓦片图像构建一个较大、组合图像的技术。这张图片展示了瓦片地图的一个示例。
- en: '![CH06_UN01_Hocking3](../Images/CH06_UN01_Hocking3.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_UN01_Hocking3](../Images/CH06_UN01_Hocking3.png)'
- en: Tilemap
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 瓦片地图
- en: Note that the map is constructed of small blocks that are repeated throughout
    the map. In that way, no single image is very large, but the entire screen can
    be covered with custom artwork. An official tilemap system for Unity is available
    by looking for 2D Tilemap Editor in Window > Package Manager.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，地图由在整个地图中重复的小块组成。这样，没有单个图像非常大，但整个屏幕可以用自定义艺术作品覆盖。在 Unity 中，可以通过在“窗口”>“包管理器”中查找
    2D 瓦片地图编辑器来找到官方的瓦片地图系统。
- en: You can find details in the Unity documentation ([https://docs.unity3d.com/Manual/
    class-Tilemap.html](https://docs.unity3d.com/Manual/class-Tilemap.html)). Alternatively,
    you could use an external library like SuperTiled2Unity ([www.seanba.com/supertiled2unity)](https://seanba.com/supertiled2unity),
    which imports tilemaps created in Tiled, a popular (and free) tilemap editor.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Unity 文档中找到详细信息（[https://docs.unity3d.com/Manual/class-Tilemap.html](https://docs.unity3d.com/Manual/class-Tilemap.html)）。或者，您可以使用像
    SuperTiled2Unity ([www.seanba.com/supertiled2unity](https://seanba.com/supertiled2unity))
    这样的外部库，它导入在 Tiled 中创建的瓦片图，Tiled 是一个流行的（且免费）瓦片图编辑器。
- en: '6.5.1 Unusual floors: Slopes and one-way platforms'
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.1 不寻常的地面：斜坡和一维平台
- en: Right now, this demo has normal, level floors to stand on. Many interesting
    kinds of platforms are used in platform games, though, so let’s implement a few
    other options. The first unusual floor you’ll create is a slope. Duplicate the
    Floor object, set the duplicate’s rotation to 0, 0, -25, move it off to the left
    side (around -3.47, -1.27, 0), and name it Slope. Refer all the way back to figure
    6.1 to see what this looks like.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这个演示有正常的、可以站立的地面。然而，平台游戏中使用了许多有趣的平台类型，所以让我们实现一些其他选项。您将创建的第一个不寻常的地面是一个斜坡。复制
    Floor 对象，将复制的旋转设置为 0, 0, -25，将其移动到左侧（大约 -3.47, -1.27, 0），并将其命名为 Slope。参考图 6.1
    来查看其外观。
- en: If you play now, the player already slides up and down correctly when moving
    but slowly slides down because of gravity when idle. To address this, let’s turn
    off gravity for the player when the player is both standing on the ground and
    idle. Fortunately, you already detect the ground, so that can be reused in the
    new code. Indeed, only a single new line is needed.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在开始玩，玩家在移动时可以正确地上下滑动，但在空闲时由于重力会慢慢滑动。为了解决这个问题，让我们在玩家既站在地面上又空闲时关闭重力。幸运的是，您已经检测到地面，因此可以在新代码中重用它。实际上，只需要一行新代码。
- en: Listing 6.5 Turning off gravity when standing on the ground
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.5 在地面上站立时关闭重力
- en: '[PRE4]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Check both on ground and not moving.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查在地面上且未移动的状态。
- en: ❷ Existing code to help show where to position new code
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 用于帮助显示新代码位置的现有代码
- en: With that adjustment to the movement code, your player character correctly navigates
    slopes. Next, one-way platforms are another sort of unusual floor common in platformers.
    I’m talking about platforms that you can jump through but still stand on; the
    player bonks their head against the bottom of normal, fully solid platforms.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对移动代码的调整，您的玩家角色可以正确地导航斜坡。接下来，一维平台是平台游戏中常见的另一种不寻常的地面。我指的是你可以跳过但仍然可以站立的平台；玩家在正常完全实体的平台底部撞头。
- en: Because they’re fairly common in platform games, Unity provides functionality
    for one-way platforms. As you may recall, when you added the Platform Effector
    component earlier, a one-way setting was turned off. Now turn that on! To create
    a new platform, duplicate the Floor object, scale the duplicate 10, 1, 1, place
    it above the floor around position -1.68, 0.11, 0, and name the object Platform.
    Oh, and don’t forget to turn on Use One Way in the Platform Effector component.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它们在平台游戏中相当常见，Unity 提供了一维平台的功能。如您所回忆的，当您之前添加 Platform Effector 组件时，一维设置是关闭的。现在将其打开！要创建一个新的平台，复制
    Floor 对象，将其缩放为 10, 1, 1，放置在地板上方，位置约为 -1.68, 0.11, 0，并将对象命名为 Platform。哦，别忘了在 Platform
    Effector 组件中打开 Use One Way。
- en: The player jumps through the platform from below, but stands on it when coming
    down from above. We have one possible issue to fix, shown in figure 6.11\. Unity
    may display the platform sprite on top of the player (to see this more easily,
    test with Jump Force set to 7), but you probably want the player on top. You could
    adjust the player’s Z position as you did in chapter 5, but this time you’ll adjust
    something else to show another option. Sprite renderers have a sorting order that
    can be used to control which sprites appear on top. Set Order in Layer to 1 in
    the Player’s Sprite Renderer component.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家从平台下方跳过，但在从上方下来时站在上面。我们有一个可能需要解决的问题，如图 6.11 所示。Unity 可能会显示平台精灵在玩家精灵之上（为了更容易看到这一点，可以将跳跃力设置为
    7 进行测试），但您可能希望玩家在上方。您可以像在第 5 章中做的那样调整玩家的 Z 位置，但这次您将调整其他内容以展示另一种选项。精灵渲染器有一个排序顺序，可以用来控制哪些精灵出现在上方。在玩家的
    Sprite Renderer 组件中将 Order in Layer 设置为 1。
- en: '![CH06_F11_Hocking3](../Images/CH06_F11_Hocking3.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F11_Hocking3](../Images/CH06_F11_Hocking3.png)'
- en: Figure 6.11 Platform sprite overlapping the player sprite
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11 平台精灵与玩家精灵重叠
- en: That takes care of both sloped floors and one-way platforms. I’m going to cover
    one more sort of unusual floor, but it is significantly more complex to implement.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就处理了斜坡地板和单向平台。我将介绍另一种不寻常的地板，但实现起来要复杂得多。
- en: 6.5.2 Implementing moving platforms
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.2 实现移动平台
- en: A third sort of unusual floor common in platform games is the moving platform.
    Implementing one requires both a new script to control the platform itself and
    changes in the player’s movement script to handle moving platforms. You’re going
    to write a script that takes two positions, start and finish, and makes the platform
    bounce between them. First, create a new C# script called MovingPlatform and write
    this code in it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 平台游戏中最常见的第三种不寻常的地板是移动平台。实现它需要一个新的脚本来控制平台本身，以及更改玩家移动脚本来处理移动平台。你将编写一个脚本，它接受两个位置，即起点和终点，并使平台在这两者之间弹跳。首先，创建一个新的
    C# 脚本，命名为 MovingPlatform，并在其中编写此代码。
- en: Listing 6.6 MovingPlatform script for floors that move back and forth
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.6 用于移动地板的 MovingPlatform 脚本
- en: '[PRE5]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Position to move to
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 移动的位置
- en: ❷ How far along the “track” between start and finish
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从起点到终点的“轨道”上的距离
- en: ❸ Current movement direction
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 当前移动方向
- en: ❹ Placement in the scene is the position to move from
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 场景中的放置是移动的起始位置
- en: ❺ Change direction at both start and end.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在起点和终点改变方向。
- en: Drawing custom gizmos
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制自定义 gizmos
- en: The majority of the code you’ll write is for the running game, but Unity scripts
    can also affect Unity’s *editor*. An often-overlooked feature of Unity is the
    ability to add new menus and windows. Your scripts can also draw custom helper
    images in the Scene view; such helper images are called *gizmos*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要编写的代码大多数是用于运行游戏，但 Unity 脚本也可以影响 Unity 的 *编辑器*。Unity 常被忽视的功能之一是添加新菜单和窗口的能力。你的脚本也可以在场景视图中绘制自定义辅助图像；这类辅助图像被称为
    *gizmos*。
- en: You’re already familiar with gizmos like the green boxes to display colliders.
    Those are built into Unity, but you can also draw your own gizmos in scripts.
    For example, drawing a line that shows the movement path of the platform could
    be useful, as shown here.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经熟悉像显示碰撞器的绿色盒子这样的 gizmos。这些是内置在 Unity 中的，但你也可以在脚本中绘制自己的 gizmos。例如，绘制显示平台移动路径的线可能很有用，如这里所示。
- en: '![CH06_UN02_Hocking3](../Images/CH06_UN02_Hocking3.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_UN02_Hocking3](../Images/CH06_UN02_Hocking3.png)'
- en: A custom gizmo
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义 gizmo
- en: 'The code for drawing that line is simple. Usually, when writing code that affects
    Unity’s editing interface, you need to add using UnityEditor; at the top (because
    most editor functions reside in that namespace), but in this case, you don’t even
    need that. Add this method to the MovingPlatform script:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制该线的代码很简单。通常，当你编写影响 Unity 编辑界面的代码时，你需要在顶部添加 using UnityEditor;（因为大多数编辑器函数都位于该命名空间中），但在这个例子中，你甚至不需要这样做。将此方法添加到
    MovingPlatform 脚本中：
- en: '[PRE6]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You need to know a few things about this code. One, it all happens in a method
    called OnDrawGizmos(). Like Start() or Update(), OnDrawGizmos() is another method
    name Unity recognizes. Within the method are two lines of code: one sets the drawing
    color, and the other tells Unity to draw a line from the platform’s position to
    the finish position.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要了解一些关于此代码的知识。一是所有这些都在一个名为 OnDrawGizmos() 的方法中发生。像 Start() 或 Update() 一样，OnDrawGizmos()
    是 Unity 识别的另一个方法名。在方法内部有两行代码：一行设置绘图颜色，另一行告诉 Unity 从平台的位置绘制到终点位置。
- en: Similar commands are used for other gizmo shapes. DrawLine() is used to define
    a line by using start and end points, but the similar command DrawRay() is used
    to draw a line in a given direction. That’s handy for visualizing raycasts coming
    from AI characters.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的命令也用于其他 gizmo 形状。DrawLine() 通过使用起点和终点来定义一条线，但类似的命令 DrawRay() 用于在给定方向上绘制一条线。这对于可视化来自
    AI 角色的射线非常有用。
- en: Gizmos are visible only in the Scene view by default, but note that the Game
    view has a Gizmos button along the top. Oh, and although this project is a 2D
    game, drawing custom gizmos works just as well in 3D games.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Gizmos 默认情况下仅在场景视图中可见，但请注意，游戏视图中顶部有一个 Gizmos 按钮。哦，尽管这个项目是一个 2D 游戏，但在 3D 游戏中绘制自定义
    gizmos 的工作方式也是一样的。
- en: Drag this script onto the platform object. Great—the platform moves left and
    right when you play the scene! Now you need to adjust the player’s movement script
    to attach the player to the moving platform. Here are the changes to make.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 将此脚本拖放到平台对象上。太棒了——当你播放场景时，平台会左右移动！现在你需要调整玩家的移动脚本，以便将玩家附加到移动平台上。以下是需要进行的更改。
- en: Listing 6.7 Handling moving platforms in PlatformerPlayer
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.7 在 PlatformerPlayer 中处理移动平台
- en: '[PRE7]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Check whether the platform under the player is a moving platform.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查玩家下方的平台是否为移动平台。
- en: ❷ Either attach to the platform or clear transform.parent.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 要么将平台附加到平台上，要么清除transform.parent。
- en: ❸ Existing code to help show where to position new code
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 现有代码以帮助显示新代码的位置
- en: Now the player moves with the platform after jumping on it. This change mostly
    comes down to attaching the player as a child of the platform; remember, when
    you set a parent object, the child object moves with the parent. Listing 6.7 uses
    GetComponent() to check whether the ground detected is a moving platform. If so,
    it sets that platform as the player’s parent; otherwise, the player is detached
    from any parent.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在玩家在跳上平台后会随着平台移动。这个变化主要归结于将玩家作为平台的子对象；记住，当你设置父对象时，子对象会随着父对象移动。列表6.7使用GetComponent()检查检测到的地面是否为移动平台。如果是，则将该平台设置为玩家的父对象；否则，玩家将脱离任何父对象。
- en: 'There’s a big problem, though: the player inherits the platform’s scale, resulting
    in weird scaling. That can be fixed by counter-scaling (scaling the player down
    to counteract the platform’s scale up).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个大问题：玩家继承了平台的缩放，导致缩放异常。这可以通过反缩放（将玩家缩放以抵消平台缩放）来修复。
- en: Listing 6.8 Correcting scaling of the player
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.8纠正玩家缩放
- en: '[PRE8]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Default scale 1 if not on moving platform
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果不在移动平台上，则默认缩放为1
- en: ❷ Replace existing scaling with new code.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 用新代码替换现有的缩放。
- en: 'The math for counter-scaling is straightforward: set the player to 1 divided
    by the platform’s scale. When the player’s scale is then multiplied by the platform’s
    scale, that leaves a scale of 1\. The only tricky bit of this code is multiplying
    by the sign of the movement value; as you may recall from earlier, the player
    is flipped based on the movement direction.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 反缩放的数学很简单：将玩家设置为1除以平台的缩放。然后，当玩家的缩放乘以平台的缩放时，剩下的缩放为1。这个代码的唯一难点是乘以移动值的符号；如你之前所回忆的，玩家根据移动方向翻转。
- en: And that’s moving platforms fully implemented. This platformer demo needs only
    one final touch.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，移动平台就完全实现了。这个平台游戏演示只需要最后的润色。
- en: 6.5.3 Camera control
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.3 摄像机控制
- en: Moving the camera is the final feature you’ll add to this 2D platformer. Create
    a script called FollowCam, drag it onto the camera, and then write the following
    in it.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 将摄像机移动是您将添加到这个2D平台游戏的最后一个功能。创建一个名为FollowCam的脚本，将其拖放到摄像机上，然后在其中编写以下内容。
- en: Listing 6.9 FollowCam script to move with the player
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.9 FollowCam脚本以跟随玩家移动
- en: '[PRE9]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Preserve the Z position while changing X and Y.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在改变X和Y的同时保留Z位置。
- en: With that code written, drag the Player object to the script’s target slot in
    the Inspector. Play the scene, and the camera moves around, keeping the player
    at the center of the screen. You can see that the code applies the target object’s
    position to the camera, and you set the player as the target object. Note that
    the method name is LateUpdate() instead of Update(); that’s yet another name Unity
    recognizes. LateUpdate() also executes every frame, but it happens after Update()
    every frame.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 编写完代码后，将玩家对象拖动到检查器中脚本的目标槽位。播放场景，摄像机就会移动，将玩家保持在屏幕中心。你可以看到代码将目标对象的位子应用到摄像机上，并且你将玩家设置为目标对象。注意，方法名是LateUpdate()而不是Update()；这是Unity识别的另一个名称。LateUpdate()也会在每一帧执行，但它发生在每一帧的Update()之后。
- en: It’s slightly jarring that the camera moves *exactly* with the player at all
    times. The camera in most platformers has all kinds of subtle but complicated
    behavior, highlighting different parts of the level as the player moves around.
    In fact, camera control for platform games is a surprisingly deep topic; try searching
    for “platform game camera” and see all the results. In this case, though, you’re
    just going to make the camera’s movement smoother and less jarring; this listing
    makes that adjustment.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 摄像机始终与玩家**精确**同步移动，这有点令人不快。在大多数平台游戏中，摄像机都有各种微妙但复杂的动作，随着玩家的移动，突出显示不同部分的游戏级别。实际上，平台游戏的摄像机控制是一个令人惊讶的深入话题；尝试搜索“平台游戏摄像机”并查看所有结果。然而，在这种情况下，你只是要让摄像机的移动更平滑，不那么令人不快；这个列表进行了相应的调整。
- en: Listing 6.10 Smoothing the camera movement
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.10平滑摄像机移动
- en: '[PRE10]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Preserve Z position while changing X and Y.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在改变X和Y的同时保留Z位置。
- en: ❷ Smooth transition from current to target position
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从当前位置平滑过渡到目标位置
- en: The main change is calling a function called SmoothDamp(); the other changes
    (like adding time and velocity variables) are all to support that function. That’s
    a function Unity provides for making values smoothly transition to a new value.
    In this case, the values are the positions of the camera and target.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的改动是调用了一个名为SmoothDamp()的函数；其他改动（如添加时间和速度变量）都是为了支持这个函数。这是一个Unity提供的函数，用于使值平滑过渡到新值。在这种情况下，这些值是摄像机和目标的位置。
- en: The camera moves smoothly with the player now. You implemented the player’s
    movement, several kinds of platforms, and now camera control. Looks like this
    chapter’s project is finished!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在摄像机与玩家移动得更加平滑。你实现了玩家的移动、几种平台类型，现在又实现了摄像机控制。看起来这一章的项目已经完成了！
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: Sprite sheets are a common way to handle 2D animation.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图集是处理2D动画的常见方式。
- en: Characters in games don’t behave like objects in the real world, so you must
    adjust their physics accordingly.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏中的角色不会像现实世界中的物体那样行为，因此你必须相应地调整它们的物理属性。
- en: Rigidbody objects can be controlled either by applying forces or by setting
    their velocity directly.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rigidbody对象可以通过施加力或直接设置它们的速度来控制。
- en: Levels in 2D games are often constructed with tilemaps.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2D游戏中的关卡通常使用瓦片图来构建。
- en: A simple script can make the camera smoothly follow the player.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简单的脚本可以使摄像机平滑地跟随玩家。
