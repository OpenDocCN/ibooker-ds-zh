- en: 7 Communication using message passing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 使用消息传递进行通信
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Exchanging messages for thread communication
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于线程通信的消息交换
- en: Adopting Go’s channels for message passing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采用 Go 的通道进行消息传递
- en: Collecting asynchronous results using channels
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用通道收集异步结果
- en: Building our own channels
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建我们自己的通道
- en: So far, we have talked about having our goroutines solve problems by sharing
    memory and using synchronization controls to prevent them from stepping over each
    other. Message passing is another way to enable *inter-thread communication* (ITC),
    which is when goroutines send messages to or wait for messages from other goroutines.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了让我们的 goroutines 通过共享内存和使用同步控制来防止它们相互跨越来解决问题。消息传递是另一种实现 *线程间通信*（ITC）的方式，即
    goroutines 向其他 goroutines 发送消息或等待来自其他 goroutines 的消息。
- en: In this chapter, we will explore using Go’s channels to send and receive messages
    among our goroutines. This chapter will serve as an introduction to programming
    concurrency using an abstraction that takes ideas from a formal language called
    communicating sequential processes (CSP). We’ll go into more detail about CSP
    in the following chapters.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨使用 Go 的通道在我们的 goroutines 之间发送和接收消息。本章将作为使用来自形式化语言通信顺序进程（CSP）的抽象来编程并发的介绍。我们将在接下来的章节中更详细地介绍
    CSP。
- en: 7.1 Passing messages
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 传递消息
- en: Whenever we converse or communicate with friends, family, or colleagues, we
    do so by passing messages to each other. In speech, we say something and usually
    expect a reply or a reaction from whomever we’re speaking to. This expectation
    is also valid when we’re communicating by letter, email, or phone. Message passing
    between goroutines is similar. In Go, we can open a channel between two or more
    goroutines and then program the goroutines to send and receive messages among
    themselves (see figure 7.1).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们与朋友、家人或同事交谈或沟通，我们都是通过相互传递消息来进行的。在言语中，我们说些什么，通常期望从我们说话的人那里得到回复或反应。当我们通过信件、电子邮件或电话进行沟通时，这种期望也是有效的。goroutines
    之间的消息传递与此类似。在 Go 中，我们可以在两个或更多 goroutines 之间打开一个通道，然后编程 goroutines 在它们之间发送和接收消息（见图
    7.1）。
- en: '![](../../OEBPS/Images/CH07_F01_Cutajar.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F01_Cutajar.png)'
- en: Figure 7.1 Goroutines passing messages to each other
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 Goroutines 之间传递消息
- en: Message passing and distributed systems
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 消息传递和分布式系统
- en: When we have distributed applications running on multiple machines, message
    passing is the main way they can communicate. Since the applications are running
    on separate machines and are not sharing any memory, they share information by
    sending messages via common protocols, such as HTTP.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在多台机器上运行分布式应用程序时，消息传递是它们之间通信的主要方式。由于应用程序运行在不同的机器上，并且不共享任何内存，它们通过发送消息通过常见的协议（如
    HTTP）来共享信息。
- en: The advantage of using message passing is that we greatly reduce the risk of
    causing race conditions with our bad programming. Since we’re not modifying the
    contents of any shared memory, goroutines cannot step over each other in memory.
    Using message passing, each goroutine just works with its own isolated memory.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用消息传递的优势在于，我们大大降低了因编程错误而引起竞态条件的风险。由于我们不是在修改任何共享内存的内容，goroutines 在内存中不能相互跨越。使用消息传递，每个
    goroutine 只与自己的隔离内存进行工作。
- en: 7.1.1 Passing messages with channels
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.1 使用通道传递消息
- en: A Go channel lets two or more goroutines exchange messages. Conceptually, we
    can think of a channel as being a direct line between our goroutines, as shown
    in figure 7.2\. The goroutines can use the ends of the channel to send or receive
    messages.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Go 通道允许两个或更多 goroutines 交换消息。从概念上讲，我们可以将通道视为我们的 goroutines 之间的直接线路，如图 7.2 所示。goroutines
    可以使用通道的两端来发送或接收消息。
- en: '![](../../OEBPS/Images/CH07_F02_Cutajar.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F02_Cutajar.png)'
- en: Figure 7.2 A channel is a direct line between goroutines.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 通道是 goroutines 之间的直接线路。
- en: To use a channel, we first create one by using the `make()` built-in function.
    We can then pass it onward as an argument whenever we create goroutines. To send
    messages, we use the `<-` operator. In listing 7.1, we are initializing a channel
    of type `string`. The specified type of the channel allows us to send messages
    of the same type. As shown in this example, we can only send strings over this
    channel. After we create this channel, we pass it to a newly created goroutine
    called `receiver``()`. We then send three string messages over the channel.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用通道，我们首先使用`make()`内置函数创建一个通道。然后，每次我们创建协程时都可以将其作为参数传递。要发送消息，我们使用`<-`操作符。在列表7.1中，我们初始化了一个类型为`string`的通道。通道指定的类型允许我们发送相同类型的消息。正如这个例子所示，我们只能通过这个通道发送字符串。在创建这个通道后，我们将其传递给一个新创建的名为`receiver()`的协程。然后我们通过通道发送三个字符串消息。
- en: Listing 7.1 Creating and using a channel
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.1 创建和使用通道
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Creates a new channel of type string
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个新的字符串类型通道
- en: ❷ Starts a new goroutine with a reference to the channel
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用通道引用启动一个新的协程
- en: ❸ Sends three string messages over the channel
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 通过通道发送三个字符串消息
- en: To consume a message from a channel, we use the same `<-` operator. However,
    we put the channel to the right of the operator instead of to the left. This is
    shown in the following implementation of the `receiver ()` goroutine, which reads
    messages from the channel until it receives the message `STOP`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要从通道消费消息，我们使用相同的`<-`操作符。然而，我们将通道放在操作符的右边而不是左边。这在上面的`receiver()`协程实现中显示，它从通道读取消息，直到接收到消息`STOP`。
- en: Listing 7.2 Reading messages from a channel
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.2 从通道读取消息
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Continues while the message received is not STOP
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在接收到消息不是STOP时继续
- en: ❷ Reads the next message from the channel
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从通道读取下一个消息
- en: ❸ Outputs the message on the console
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在控制台上输出消息
- en: 'Putting listings 7.1 and 7.2 together results in the `main()` goroutine pushing
    messages on the common channel and the `receiver` goroutine consuming them. Once
    the `main()` goroutine sends the stop message, the receiver will exit the `for`
    loop and terminate. Here is the output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将列表7.1和7.2合并会导致`main()`协程在公共通道上推送消息，而`receiver`协程消费它们。一旦`main()`协程发送停止消息，接收器将退出`for`循环并终止。以下是输出：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice how on the output, we’re missing the final `STOP` message from the receiver.
    This is because the `main()` goroutine sends the stop message and then terminates.
    Once the `main` goroutine terminates, the entire process exits, and we never get
    to see the stop message printed on the console.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在输出中，我们缺少接收器的最终`STOP`消息。这是因为`main()`协程发送停止消息然后终止。一旦`main`协程终止，整个进程就会退出，我们永远不会看到在控制台上打印的停止消息。
- en: What would happen if a goroutine were to push a message on a channel without
    there being another goroutine to read that message? Go’s channels are synchronous
    by default, meaning that the sender goroutine will block until there is a receiver
    goroutine ready to consume the message. Figure 7.3 shows a goroutine sender blocked
    without a receiver.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个协程在没有任何其他协程读取该消息的情况下向通道推送消息会发生什么？Go的通道默认是同步的，这意味着发送者协程将阻塞，直到有接收者协程准备好消费消息。图7.3显示了没有接收者的协程发送者被阻塞。
- en: '![](../../OEBPS/Images/CH07_F03_Cutajar.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH07_F03_Cutajar.png)'
- en: Figure 7.3 Sending a message on a channel with no receiver
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3在无接收者的情况下向通道发送消息
- en: We can try this out by changing the receiver from listing 7.2 to the following.
    In this receiver, we wait for 5 seconds before terminating instead of consuming
    any messages from the channel.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将列表7.2中的接收器更改为以下内容来尝试这一点。在这个接收器中，我们在终止之前等待5秒钟，而不是从通道中消费任何消息。
- en: Listing 7.3 Receiver not consuming any messages
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.3 接收器不消费任何消息
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Waits for 5 seconds instead of reading messages from the channel
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 等待5秒钟而不是从通道读取消息
- en: 'When we run listing 7.3 with the `main()` function from listing 7.1, the `main()`
    goroutine blocks for 5 seconds. This is because there is nothing to consume the
    message that the `main()` goroutine is trying to place on the channel:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行列表7.1中的`main()`函数和列表7.3时，`main()`协程会阻塞5秒钟。这是因为没有东西可以消费`main()`协程试图放置在通道上的消息：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Since our `receiver ()` goroutine terminates after 5 seconds, no other goroutine
    is available to consume messages from the channel. Go’s runtime realizes this
    and raises the fatal error. Without this error, our program would stay blocked
    until we manually terminate it. The error message mentions that we have encountered
    a deadlock—we’ll explore how to deal with deadlocks in chapter 11.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的`receiver ()`协程在5秒后终止，没有其他协程可用于从通道中消费消息。Go的运行时意识到这一点，并引发致命错误。如果没有这个错误，我们的程序将保持阻塞状态，直到我们手动终止它。错误信息提到我们遇到了死锁——我们将在第11章探讨如何处理死锁。
- en: The same situation occurs if we have a receiver waiting for a message and no
    sender is available. The receiver’s goroutine will be suspended until a message
    is available (see figure 7.4).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个等待消息的接收者而没有发送者，也会出现相同的情况。接收者的协程将暂停，直到有消息可用（见图7.4）。
- en: '![](../../OEBPS/Images/CH07_F04_Cutajar.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4](../../OEBPS/Images/CH07_F04_Cutajar.png)'
- en: Figure 7.4 A receiver is blocked until a message is available.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 接收者被阻塞，直到有消息可用。
- en: In the following listing, we have a `sender``()` goroutine that, rather than
    write messages to the channel, sleeps for 5 seconds. The `main()` goroutine tries
    to consume a message from the same channel, but it will be blocked since nothing
    is sending messages.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的列表中，我们有一个`sender()`协程，它不是将消息写入通道，而是睡眠5秒。`main()`协程试图从同一个通道中消费一个消息，但它将被阻塞，因为没有发送者发送消息。
- en: Listing 7.4 Receiver blocked because sender is not sending any messages
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.4 接收者被阻塞，因为发送者没有发送任何消息
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Creates a new channel of type string
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个新的字符串类型通道
- en: ❷ Reads a message from channel
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从通道读取消息
- en: ❸ Sleeps for 5 seconds instead of sending any message
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 替代发送消息，睡眠5秒
- en: 'Running listing 7.4 produces results similar to listing 7.3\. We get a receiver
    waiting for messages, and when the `sender ()` goroutine terminates, Go’s runtime
    outputs an error. Here’s the console output:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 运行列表7.4会产生与列表7.3类似的结果。我们得到一个等待消息的接收者，当`sender()`协程终止时，Go的运行时会输出一个错误。以下是控制台输出：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The key idea here is that by default, Go’s channels are *synchronous*. A sender
    will block if there isn’t a goroutine consuming its message, and a receiver will
    similarly block if there isn’t a goroutine sending a message.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键思想是，默认情况下，Go的通道是**同步的**。如果没有协程消费其消息，发送者将阻塞，同样，如果没有协程发送消息，接收者也会阻塞。
- en: 7.1.2 Buffering messages with channels
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.2 使用通道缓冲消息
- en: Although channels are synchronous, we can configure them so that they store
    a number of messages before they block (see figure 7.5). When we use a buffered
    channel, the sender goroutine will not block as long as there is space available
    in the buffer.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通道是同步的，但我们可以配置它们，在它们阻塞之前存储一定数量的消息（见图7.5）。当我们使用带缓冲的通道时，只要缓冲区有空间，发送者协程就不会阻塞。
- en: '![](../../OEBPS/Images/CH07_F05_Cutajar.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5](../../OEBPS/Images/CH07_F05_Cutajar.png)'
- en: Figure 7.5 Using a buffered channel between goroutines
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 在协程之间使用带缓冲的通道
- en: When we create a channel, we can specify its buffer capacity. Then, whenever
    a sender goroutine writes a message without any receiver consuming the message,
    the channel will store the message (shown in figure 7.6). This means that as long
    as there is space in the buffer, our sender does not block, and we don’t have
    to wait for a receiver to read the message.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个通道时，可以指定其缓冲区容量。然后，每当发送者协程写入消息而没有接收者消费该消息时，通道将存储该消息（如图7.6所示）。这意味着只要缓冲区有空间，我们的发送者就不会阻塞，我们也不必等待接收者读取消息。
- en: '![](../../OEBPS/Images/CH07_F06_Cutajar.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6](../../OEBPS/Images/CH07_F06_Cutajar.png)'
- en: Figure 7.6 Messages are stored in the buffer when no receiver is consuming them.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 当没有接收者消费消息时，消息存储在缓冲区中。
- en: The channel will keep on storing messages as long as capacity remains in the
    buffer. Once the buffer is filled up, the sender will block again, as shown in
    figure 7.7\. This message buffer buildup can also happen if the receiving end
    is slow and does not consume the messages fast enough to keep up with the sender.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 只要缓冲区中还有容量，通道就会继续存储消息。一旦缓冲区被填满，发送者将再次阻塞，如图7.7所示。如果接收端响应慢，没有足够快地消费消息以跟上发送者，也可能发生这种消息缓冲区积累。
- en: '![](../../OEBPS/Images/CH07_F07_Cutajar.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图7.7](../../OEBPS/Images/CH07_F07_Cutajar.png)'
- en: Figure 7.7 A full buffer blocks the sender.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 一个满缓冲区阻止了发送者。
- en: Once a receiver goroutine is available to consume the messages, the messages
    are fed to the receiver in the same order they were sent. This happens even if
    the sender goroutine is no longer sending any new messages (shown in figure 7.8).
    As long as there are messages in the buffer, a receiver goroutine will not block.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦有接收器goroutine可以消费消息，消息将以与发送时相同的顺序被发送到接收器。即使发送器goroutine不再发送任何新消息（如图7.8所示），也是如此。只要缓冲区中有消息，接收器goroutine就不会阻塞。
- en: '![](../../OEBPS/Images/CH07_F08_Cutajar.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH07_F08_Cutajar.png)'
- en: Figure 7.8 A receiver consumes stored messages from the buffer even when there
    is no sender.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 接收器即使在没有发送者的情况下也会从缓冲区中消费存储的消息。
- en: Once the receiver goroutine consumes all the messages and the buffer is empty,
    the receiver goroutine will again block. When the buffer is empty, a receiver
    will block if we don’t have a sender or if the sender is producing messages at
    a slower rate than the receiver can read them. This is shown in figure 7.9.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦接收器goroutine消耗了所有消息并且缓冲区为空，接收器goroutine将再次阻塞。当缓冲区为空时，如果没有发送者或者发送者产生消息的速度比接收者读取它们的速度快，接收者将阻塞。这如图7.9所示。
- en: '![](../../OEBPS/Images/CH07_F09_Cutajar.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH07_F09_Cutajar.png)'
- en: Figure 7.9 An empty buffer with no sender will block the receiver.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 没有发送者的空缓冲区将阻塞接收器。
- en: Let’s now try this in practice. Listing 7.5 shows a slow message receiver that
    consumes messages from the integer channel at a rate of one per second. We use
    `time.Sleep()` to slow down the goroutine. Once the `receiver()` goroutine receives
    a `-1` value, it stops receiving messages and calls `Done()` on a waitgroup.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在尝试一下。列表7.5显示了一个慢速消息接收器，它以每秒一个消息的速率从整数通道中消费消息。我们使用`time.Sleep()`来减慢goroutine的速度。一旦`receiver()`
    goroutine接收到`-1`值，它就停止接收消息，并在waitgroup上调用`Done()`。
- en: Listing 7.5 Slow receiver reading a message every second
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.5 每秒读取一个消息的慢速接收器
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Keeps reading messages from the channel until it receives a -1
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从通道中读取消息，直到接收到-1
- en: ❷ Waits for 1 second
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 等待1秒
- en: ❸ Reads the next message from the channel
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从通道读取下一个消息
- en: ❹ Calls Done() on the waitgroup after reading all the messages
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在读取所有消息后在waitgroup上调用Done()
- en: We can now write a `main()` function that creates a buffered channel and feeds
    messages into the channel at a faster rate than our reader can consume them. In
    listing 7.6, we create a buffered channel with a capacity of three messages. We
    then use this channel to send six messages quickly, each containing the next number
    in the sequence from `1` to `6`. After this, we send a final message containing
    the value of `–1`. In the end, we wait for the `receiver``()` goroutine to be
    done by waiting on the waitgroup.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以编写一个`main()`函数，该函数创建一个带缓冲的通道，并以比我们的读者消费它们更快的速度将消息喂入通道。在列表7.6中，我们创建了一个容量为三个消息的带缓冲通道。然后我们使用这个通道快速发送六个消息，每个消息都包含从`1`到`6`的序列中的下一个数字。之后，我们发送一个包含`-1`值的最终消息。最后，我们通过等待waitgroup来等待`receiver()`
    goroutine完成。
- en: Listing 7.6 `main()` function sending messages on a buffered channel
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.6 `main()`函数在带缓冲的通道上发送消息
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Creates a new channel with a buffer capacity of 3 messages
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个容量为3个消息的新通道
- en: ❷ Creates a waitgroup with a size of 1
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个大小为1的waitgroup
- en: ❸ Starts the receiver goroutine with the buffered channel and waitgroup
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用带缓冲的通道和waitgroup启动接收器goroutine
- en: ❹ Reads the number of messages on the buffered channel
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 读取带缓冲通道中的消息数量
- en: ❺ Sends six integer messages from 1 to 6
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 发送从1到6的六个整数消息
- en: ❻ Sends a message containing –1
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 发送包含-1的消息
- en: ❼ Waits on the waitgroup until the receiver is finished
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 等待waitgroup直到接收器完成
- en: NOTE We can check how many messages are on the buffer by using the `len(buffer)`
    function.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们可以通过使用`len(buffer)`函数来检查缓冲区中有多少消息。
- en: 'Combining listings 7.5 and 7.6, we get a fast sender that is trying to send
    six messages. Since we have a much slower receiver, the `main()` goroutine will
    fill the channel buffer with three messages and then block. The receiver will
    consume a message every second, freeing a space in the buffer that the sender
    will quickly fill. Here is the output showing the timestamps of each send and
    receive operation:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 结合列表7.5和7.6，我们得到一个快速发送者，它试图发送六个消息。由于我们的接收者速度要慢得多，`main()` goroutine将用三个消息填满通道缓冲区，然后阻塞。接收者将每秒消费一个消息，为发送者快速填充缓冲区腾出空间。以下是显示每个发送和接收操作时间戳的输出：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 7.1.3 Assigning a direction to channels
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.3 为通道分配方向
- en: Go’s channels are *bidirectional* by default. This means that a goroutine can
    act as both a receiver and a sender of messages. However, we can assign a direction
    to a channel so that the goroutine using the channel can only send or receive
    messages.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的通道默认是 *双向的*。这意味着一个 goroutine 可以同时作为消息的接收者和发送者。然而，我们可以给通道指定一个方向，这样使用该通道的
    goroutine 就只能发送或接收消息。
- en: For example, when we declare a function’s parameters, we can specify the direction
    of the channel. Listing 7.7 declares receiver and sender functions that allow
    messages to go in only one direction. In the receiver, when we declare the channel
    as being `messages <-chan int`, we are saying that the channel is a receive-only
    channel. The declaration of `messages chan<-` `int` in the sender function is
    saying the opposite—that the channel can only be used to send messages.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们声明一个函数的参数时，我们可以指定通道的方向。列表 7.7 声明了接收者和发送者函数，允许消息只能单向流动。在接收者中，当我们声明通道为 `messages
    <-chan int` 时，我们是在说这个通道是一个只接收通道。发送者函数中 `messages chan<- int` 的声明则表示相反的意思——通道只能用来发送消息。
- en: Listing 7.7 Declaring channels with a direction
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.7 声明具有方向的通道
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Declares a receive-only channel
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 声明一个只接收通道
- en: ❷ Receives messages from the channel
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从通道接收消息
- en: ❸ Declares a send-only channel
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 声明一个只发送通道
- en: ❹ Sends a message on the channel every second
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 每秒在通道上发送一条消息
- en: In listing 7.7, if we try to use the receiver’s channel to send messages, we
    would get a compilation error. For example, if in the `receiver()` function we
    do this
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 7.7 中，如果我们尝试使用接收者的通道来发送消息，我们会得到一个编译错误。例如，如果在 `receiver()` 函数中我们这样做
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'we would get an error message when we compile:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译时我们会得到一个错误信息：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 7.1.4 Closing channels
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.4 关闭通道
- en: We’ve been using special value messages to signal that no more data is available
    on the channel. For example, in listing 7.6, the receiver is waiting for a `–1`
    value to appear on the channel. This signals to the receiver that it can stop
    consuming messages. This message contains what is known as a *sentinel value*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直使用特殊值消息来表示通道上没有更多数据可用。例如，在列表 7.6 中，接收者正在等待通道上出现 `–1` 值。这向接收者发出信号，表明它可以停止消费消息。这个消息包含了一个被称为
    *哨兵值* 的内容。
- en: Definition In software development, a *sentinel value* is a predefined value
    that signals to an execution, a process, or an algorithm that it should terminate.
    In the context of multithreading and a distributed system, this is sometimes referred
    to as a *poison pill* message.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 在软件开发中，*哨兵值* 是一个预定义的值，它向执行、进程或算法发出信号，表明它应该终止。在多线程和分布式系统的上下文中，这有时被称为 *毒药丸*
    消息。
- en: Instead of using this *sentinel value* message, Go allows us to close a channel.
    We can do this in code by calling the `close(channel)` function. Once we close
    a channel, we shouldn’t send any more messages to it because doing so raises errors.
    If we try to receive messages from a closed channel, we will get messages containing
    the default value for the channel’s data type. For example, if our channel is
    of integer type, reading from a closed channel will result in the read operation
    returning a `0` value. This is illustrated in figure 7.10.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用这个 *哨兵值* 消息，Go 允许我们关闭一个通道。我们可以通过调用 `close(channel)` 函数来实现。一旦我们关闭了通道，就不应该再向其发送任何消息，因为这样做会引发错误。如果我们尝试从已关闭的通道接收消息，我们会收到包含通道数据类型默认值的消息。例如，如果我们的通道是整型，从已关闭的通道读取将导致读取操作返回
    `0` 值。这如图 7.10 所示。
- en: '![](../../OEBPS/Images/CH07_F10_Cutajar.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH07_F10_Cutajar.png)'
- en: Figure 7.10 Closing a channel and continuing to consume messages
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10 关闭通道并继续消费消息
- en: We can show this by implementing a receiver that continually consumes messages
    even after we close the channel. The following listing shows a `receiver()` function
    with a loop that reads messages from the channel and outputs them on the console
    every second.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过实现一个在关闭通道后仍然持续消费消息的接收者来展示这一点。下面的列表显示了一个 `receiver()` 函数，其中包含一个循环，从通道读取消息并在每秒将其输出到控制台。
- en: Listing 7.8 Infinite channel receiver
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.8 无限通道接收器
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Declares a receive-only channel
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 声明一个只接收通道
- en: ❷ Reads one message from the channel
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从通道读取一条消息
- en: ❸ Waits for 1 second
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 等待 1 秒
- en: Next, we can implement a `main()` function that sends a few messages on the
    channel, after which it closes the channel. In the following listing, we send
    three messages, one per second, and then close the channel. We have also added
    a sleep of 3 seconds to show what the `receiver()` goroutine reads from the closed
    channel.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以实现一个`main()`函数，该函数在通道上发送几条消息，然后关闭通道。在下面的列表中，我们发送了三条消息，每秒一条，然后关闭了通道。我们还添加了3秒的休眠时间，以显示`receiver()`协程从关闭的通道中读取的内容。
- en: Listing 7.9 `main()` function sending messages and closing channel
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.9 `main()`函数发送消息并关闭通道
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Running listings 7.8 and 7.9 together, we get the receiver first outputting
    the messages from `1` to `3` and then reading `0`s for 3 seconds:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 将列表7.8和7.9一起运行，我们得到接收器首先输出从`1`到`3`的消息，然后读取3秒的`0`：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Can we use this default value to let the receiver know that the channel has
    been closed? Using the default value is not ideal because the default value might
    be a valid value for our use case. Imagine, for example, a weather forecasting
    application sending temperatures over a channel. In this scenario, the receiver
    would think the channel has been closed whenever the temperature drops to 0.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否使用这个默认值让接收器知道通道已被关闭？使用默认值并不理想，因为默认值可能对我们用例是有效的值。想象一下，例如，一个通过通道发送温度的天气预报应用程序。在这种情况下，当温度降到0时，接收器会认为通道已被关闭。
- en: Luckily, Go gives us a couple of ways to handle closed channels. Whenever we
    consume from a channel, an additional flag is returned, telling us the status
    of the channel. This flag is set to `false` only when the channel has been closed.
    The following listing shows how we can modify the receiver function in listing
    7.8 to read this flag. By using this flag, we can decide to stop reading from
    the channel.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Go提供了几种处理关闭通道的方法。每次我们从通道中消费时，都会返回一个额外的标志，告诉我们通道的状态。这个标志仅在通道被关闭时设置为`false`。下面的列表显示了如何修改列表7.8中的接收器函数来读取这个标志。通过使用这个标志，我们可以决定是否停止从通道读取。
- en: Listing 7.10 Receiver stopping when channel indicates that it’s closed
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.10 当通道指示已关闭时，接收器停止
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Reads message and an open channel flag, set to false when the channel is closed
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 读取消息和一个打开的通道标志，当通道关闭时该标志设置为false
- en: ❷ When there are no more messages, it stops consuming from the channel.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当没有更多消息时，它停止从通道中消费。
- en: 'As expected, when we run listing 7.10 with the `main()` function from listing
    7.9, we consume messages until the channel is closed. We can also see that when
    the channel is closed, the open channel flag is set to `false`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，当我们运行列表7.10与列表7.9中的`main()`函数时，我们会消费消息直到通道关闭。我们还可以看到，当通道关闭时，打开通道标志被设置为`false`：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As we shall see in the next chapter, this syntax is useful in certain situations,
    such as when it’s combined with the `select` statement. However, we can use a
    cleaner syntax to stop a receiver from reading on a closed channel. If we want
    to read all the messages until we close the channel, we can use the following
    `for` loop syntax:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在下一章中将要看到的，这种语法在特定情况下很有用，例如当它与`select`语句结合使用时。然而，我们可以使用更简洁的语法来停止接收器在关闭的通道上读取。如果我们想读取所有消息直到关闭通道，我们可以使用以下`for`循环语法：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, the `messages` variable is our channel. In this way, we can keep on iterating
    until the sender eventually closes the channel. The following listing shows how
    we can change the `receiver``()` function from listing 7.9 to use this new syntax.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`messages`变量是我们的通道。这样，我们可以继续迭代，直到发送者最终关闭通道。下面的列表显示了如何将列表7.9中的`receiver()`函数更改为使用这种新语法。
- en: Listing 7.11 Receiver iterating on messages from the channel
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.11 接收器迭代通道中的消息
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Consumes from the channel until it’s closed, assigning messages to the msg
    variable
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从通道中消费直到它关闭，将消息分配给msg变量
- en: 'Running listing 7.11 with the same `main()` function from listing 7.9, we end
    up consuming all the messages sent from the `main()` goroutine until the `main()`
    goroutine closes the channel. The listing outputs the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 将列表7.11与列表7.9中的相同`main()`函数一起运行，我们最终会消费来自`main()`协程的所有发送的消息。该列表输出以下内容：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 7.1.5 Receiving function results with channels
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.5 使用通道接收函数结果
- en: We can execute functions concurrently in the background and then collect their
    results via channels once they finish. Typically, in normal sequential programming,
    we call a function and expect it to return a result. In concurrent programming,
    we can call functions in separate goroutines and later pick up their return values
    from an output channel.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在后台并发执行函数，一旦完成，就可以通过通道收集它们的结果。通常，在正常的顺序编程中，我们调用一个函数并期望它返回一个结果。在并发编程中，我们可以在不同的goroutine中调用函数，稍后从输出通道中获取它们的返回值。
- en: Let’s explore this with a simple example. The following listing shows a function
    that finds the factors of an input number. For example, if we call `findFactors(6)`,
    it will return the values `[1 2 3 6]`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单的例子来探讨这个问题。以下列表显示了一个寻找输入数字因子的函数。例如，如果我们调用`findFactors(6)`，它将返回值`[1 2
    3 6]`。
- en: Listing 7.12 Function to find all factors of a number
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.12 寻找数字所有因子的函数
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Finds all the factors for the input number
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 寻找输入数字的所有因子
- en: 'If we call the `findFactors()` function twice for two different numbers, in
    sequential programming, we would have two calls, one after the other. For example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为两个不同的数字两次调用`findFactors()`函数，在顺序编程中，我们将有两个调用，一个接一个。例如：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: But what if we want to call the function with the first number, and while it’s
    computing those factors, we call the function a second time with the second number?
    If we have multiple cores available, executing the first `findFactors()` call
    in parallel with the second will speed up our program. Finding factors of large
    numbers can be a lengthy operation, so it would be good to farm out the work on
    multiple processing cores.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们想用第一个数字调用函数，同时它在计算这些因子时，我们再次用第二个数字调用该函数呢？如果我们有多个可用核心，将第一个`findFactors()`调用与第二个并行执行将加快我们的程序。寻找大数的因子可能是一个耗时的操作，因此将工作分配到多个处理核心上会更好。
- en: 'We can, of course, start a goroutine for the first call and then make the second
    call:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以启动一个goroutine来处理第一次调用，然后进行第二次调用：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'However, how do we wait and collect the results from the first call easily?
    We could use something like a shared variable and a waitgroup, but there is an
    easier way: using channels. In the next listing, we use an anonymous function,
    running as a goroutine and making the first `findFactors()` call.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们如何轻松地等待并收集第一次调用的结果呢？我们可以使用共享变量和waitgroup，但有一个更简单的方法：使用通道。在下一个列表中，我们使用一个匿名函数，作为一个goroutine运行，并执行第一次`findFactors()`调用。
- en: Listing 7.13 Collecting results using channels
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.13 使用通道收集结果
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Creates a new channel of type integer slice
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个新的整数切片类型的通道
- en: ❷ Calls the function in an anonymous goroutine and places the results onto the
    channel
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在匿名goroutine中调用函数并将结果放置到通道中
- en: ❸ Collects the results from the channel
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从通道中收集结果
- en: 'We use this anonymous goroutine to collect the results of the `findFactors()`
    function and write them on a channel. Later, after we finish the second call in
    our `main()` goroutine, we can read those results from the channel. If the first
    `findFactors()` call is not yet finished, reading from the channel will block
    the `main()` goroutine until we have the results. Here is the output showing all
    the factors:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个匿名goroutine来收集`findFactors()`函数的结果并将它们写入通道。在我们`main()` goroutine中完成第二次调用之后，我们可以从通道中读取这些结果。如果第一次`findFactors()`调用尚未完成，从通道中读取将阻塞`main()`
    goroutine，直到我们得到结果。以下是显示所有因子的输出：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 7.2 Implementing channels
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 实现通道
- en: What does the inner logic of a channel look like? In its basic form, a buffered
    channel is similar to a fixed-size queue data structure. The difference is that
    it can safely be used from multiple concurrent goroutines. In addition, the channel
    needs to block the receiver goroutine if the buffer is empty or to block the sender
    if the buffer is full. In this section, we’ll use concurrency primitives, built
    in previous chapters, to build the channel’s send and receive functions so that
    we can better understand how it works internally.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通道的内部逻辑是什么样的？在其基本形式中，一个带缓冲的通道类似于固定大小的队列数据结构。区别在于它可以安全地从多个并发goroutine中使用。此外，当缓冲区为空时，通道需要阻塞接收goroutine；当缓冲区满时，需要阻塞发送goroutine。在本节中，我们将使用之前章节中构建的并发原语来构建通道的发送和接收函数，以便我们更好地理解其内部工作原理。
- en: 7.2.1 Creating a channel with semaphores
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.1 使用信号量创建通道
- en: 'We need a number of elements to build the functionality of our channel:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些元素来构建我们频道的功能：
- en: A shared queue data structure that acts like a buffer to store the messages
    between sender and receiver
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个共享队列数据结构，它像一个缓冲区一样存储发送者和接收者之间的消息
- en: Concurrent access protection for the shared data structure so that multiple
    senders and receivers do not interfere with each other
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对共享数据结构的并发访问保护，以确保多个发送者和接收者不会相互干扰
- en: Access control that blocks the execution of a receiver when the buffer is empty
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当缓冲区为空时阻止接收器执行的访问控制
- en: Access control that blocks the execution of a sender when the buffer is full
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当缓冲区满时阻止发送器执行的访问控制
- en: We have several options for implementing our shared data structure where we’ll
    store our messages. We could, for example, build a queue structure on an array
    and use a Go slice or a linked list. Whatever tool we choose, it needs to give
    us the queue semantics—that is, first in, first out.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种实现我们的共享数据结构的方法，我们将在这里存储我们的消息。例如，我们可以在数组上构建一个队列结构，并使用 Go 切片或链表。无论我们选择哪种工具，它都需要给我们提供队列语义，即先进先出。
- en: To protect our shared data structure from concurrent access, we can use a simple
    mutex. When we add or remove a message from the queue, we need to ensure that
    the concurrent modifications to the queue do not interfere.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护我们的共享数据结构免受并发访问的影响，我们可以使用一个简单的互斥锁。当我们从队列中添加或删除消息时，我们需要确保对队列的并发修改不会相互干扰。
- en: To control access so that executions are blocked when the queue is full or empty,
    we can use semaphores. In this case, semaphores are a good base primitive since
    they allow concurrent access to a specific number of concurrent executions. From
    the receiver’s side, we can think of using a semaphore as having as many free
    permits as there are messages in the shared queue. Once the queue is empty, the
    semaphore will block the next request to consume a message since the number of
    free permits on the semaphore will be `0`. We can use the same trick on the sender’s
    side—we can use another semaphore that goes down to `0` when the queue gets full.
    Once this happens, the semaphore will block the next send request.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制访问，以便在队列满或空时阻塞执行，我们可以使用信号量。在这种情况下，信号量是一个很好的基本原语，因为它们允许对特定数量的并发执行进行并发访问。从接收者的角度来看，我们可以将使用信号量视为共享队列中消息数量的自由许可证。一旦队列空了，信号量将阻止下一个请求消费消息，因为信号量上的自由许可证数量将是
    `0`。我们可以在发送者的一侧使用同样的技巧——我们可以使用另一个信号量，当队列满时它将下降到 `0`。一旦发生这种情况，信号量将阻止下一个发送请求。
- en: These four elements make up our channel of buffer size 10 in figure 7.11\. We
    use two semaphores, the capacity and buffer size semaphores, to block goroutines
    when the capacity has been reached or when the buffer is empty, respectively.
    In the figure, we have three messages in the buffer, so the buffer size semaphore
    shows `3`. This means we have seven spaces left until the buffer is full, and
    the capacity semaphore is set to this value.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个元素构成了图 7.11 中的 10 个缓冲区大小的通道。我们使用两个信号量，容量和缓冲区大小信号量，分别用于在容量达到或缓冲区为空时阻塞 goroutines。在图中，缓冲区中有三个消息，因此缓冲区大小信号量显示为
    `3`。这意味着我们还有七个空间直到缓冲区满，容量信号量被设置为这个值。
- en: '![](../../OEBPS/Images/CH07_F11_Cutajar.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F11_Cutajar.png)'
- en: Figure 7.11 The structures and tools needed to build a channel
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11 构建通道所需的结构和工具
- en: We can translate this to code by creating a `channel` struct type with these
    four elements, as shown in listing 7.14\. For our buffer, we’ll use the linked
    list implementation from the `container` package. A linked list is an ideal structure
    for implementing a queue because we’re always adding and removing messages from
    the head or tail of our linked list. In the `channel` struct type, we are also
    using Go’s generics, which make our channel implementation easier to use with
    various data types.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个包含这四个元素的 `channel` struct 类型来将此转换为代码，如列表 7.14 所示。对于我们的缓冲区，我们将使用 `container`
    包中的链表实现。链表是实现队列的理想结构，因为我们总是在链表的头部或尾部添加和删除消息。在 `channel` struct 类型中，我们还使用了 Go 的泛型，这使得我们的通道实现更容易与各种数据类型一起使用。
- en: Listing 7.14 Type struct for the custom channel implementation
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.14 用于自定义通道实现的类型 struct
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Capacity semaphore to block sender when the buffer is full
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 容量信号量，当缓冲区满时阻止发送器
- en: ❷ Buffer size semaphore to block the receiver when the buffer is empty
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 缓冲区大小信号量，当缓冲区为空时阻止接收器
- en: ❸ Mutex protecting our shared list data structure
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 互斥锁保护我们的共享列表数据结构
- en: ❹ Linked list to be used as a queue data structure
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将用作队列数据结构的链表
- en: Next, we need a function to initialize the elements in the `struct` type with
    default empty values. When we create a new channel, we need the buffer to be empty,
    the buffer size semaphore to have `0` permits, and the capacity semaphore to have
    a permit count equal to the input capacity. This will ensure we allow senders
    to add messages but block receivers because the buffer is currently empty. The
    `NewChannel()` function in the following listing does this initialization.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个函数来初始化`struct`类型中的元素，使用默认空值。当我们创建一个新的通道时，我们需要缓冲区为空，缓冲区大小信号量具有`0`个许可，容量信号量的许可计数等于输入容量。这将确保我们允许发送者添加消息，但接收者因为缓冲区当前为空而被阻塞。以下列表中的`NewChannel()`函数执行此初始化。
- en: Listing 7.15 Function creating a new channel
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.15：创建新通道的函数
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Creates a new semaphore with the number of permits equal to the input capacity
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个许可数等于输入容量的新信号量
- en: ❷ Creates a new semaphore with the number of permits equal to 0
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个许可数为0的新信号量
- en: ❸ Creates a new, empty linked list
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建一个新的、空的链表
- en: 7.2.2 Implementing the Send() function in our channel
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.2 在我们的通道中实现Send()函数
- en: 'Let’s now explore how the semaphores, buffer, and mutex work together to give
    us the send functionality of the channel. The `Send(message)` function needs to
    fulfill these three requirements:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一下信号量、缓冲区和互斥锁如何协同工作，以给我们提供通道的发送功能。`Send(message)`函数需要满足以下三个要求：
- en: Block the goroutine if the buffer is full.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果缓冲区已满，阻止goroutine。
- en: Otherwise, safely add the `message` to the buffer.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，安全地将`message`添加到缓冲区。
- en: If any receiver goroutines are blocked, waiting for messages, resume one of
    them.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有任何接收者goroutine被阻塞，等待消息，恢复其中一个。
- en: '![](../../OEBPS/Images/CH07_F12_Cutajar.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH07_F12_Cutajar.png)'
- en: Figure 7.12 Sending messages on the channel
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12 在通道上发送消息
- en: 'We can meet all these requirements by performing the three steps outlined in
    fig- ure 7.12:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行图7.12中概述的三个步骤来满足所有这些要求：
- en: The sender acquires a permit from the capacity semaphore, reducing the permit
    count by `1`. This will meet the first requirement; if the buffer is full, the
    goroutine will block since no more permits will be available.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送者从容量信号量中获取一个许可，许可计数减少`1`。这将满足第一个要求；如果缓冲区已满，goroutine将因为不再有可用的许可而阻塞。
- en: The sender pushes the message onto the buffer data structure. In our implementation,
    this data structure is the linked list queue. To protect the queue from concurrent
    updates, we can use a mutex to synchronize access.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送者将消息推送到缓冲区数据结构中。在我们的实现中，这个数据结构是链表队列。为了保护队列免受并发更新，我们可以使用互斥锁来同步访问。
- en: The sender goroutine releases a permit on the buffer size semaphore by calling
    the `Release()` function on the semaphore. This meets the final requirement; if
    there is a blocked goroutine waiting for messages, it will be resumed.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送者goroutine通过在信号量上调用`Release()`函数来释放缓冲区大小信号量上的许可。这满足了最终要求；如果有阻塞的goroutine正在等待消息，它将被恢复。
- en: 'The next listing shows the implementation of the sender. The `Send(message)`
    function contains the three steps: reduce the permits on the capacity semaphore,
    push the message onto the queue, and increase the permits on the buffer size semaphore.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了发送者的实现。`Send(message)`函数包含三个步骤：减少容量信号量的许可数，将消息推送到队列中，并增加缓冲区大小信号量的许可数。
- en: Listing 7.16 The `Send()` function for the channel implementation
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.16：通道实现的`Send()`函数
- en: '[PRE28]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ Acquires one permit from the capacity semaphore
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从容量信号量中获取一个许可
- en: ❷ Adds a message to the buffer queue while protecting against race conditions
    by using a mutex
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在使用互斥锁保护以防止竞争条件的情况下，将消息添加到缓冲区队列中
- en: ❸ Releases one permit from the buffer size semaphore
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从缓冲区大小信号量中释放一个许可
- en: If the buffer is full, our capacity semaphore will not have any permits left,
    so the sender goroutine will be blocked on the first step (see figure 7.13). The
    sender will also block if we use a channel with an initial capacity of `0` and
    a receiver is not present, giving us the same synchronous functionality of the
    default channel in Go.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果缓冲区已满，我们的容量信号量将没有剩余的许可，因此发送者goroutine将在第一步（见图7.13）上被阻塞。如果使用初始容量为`0`的通道且没有接收者，发送者也会阻塞，这给我们提供了Go中默认通道的相同同步功能。
- en: '![](../../OEBPS/Images/CH07_F13_Cutajar.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH07_F13_Cutajar.png)'
- en: Figure 7.13 Blocking the sender when the buffer is full and we have `0` capacity
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13 当缓冲区已满且我们具有`0`容量时阻止发送者
- en: 7.2.3 Implementing the Receive() function in our channel
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.3 在我们的通道中实现Receive()函数
- en: 'Let’s now look at the receiving side of our channel implementation. The `Receive()`
    function needs to satisfy the following requirements:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们通道实现的接收端。`Receive()`函数需要满足以下要求：
- en: Unblock a sender waiting for capacity space.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解除等待容量空间的发送器的阻塞。
- en: If the buffer is empty, block the receiver.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果缓冲区为空，则阻塞接收器。
- en: Otherwise, safely consume the next message from the buffer.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，安全地消费缓冲区中的下一条消息。
- en: '![](../../OEBPS/Images/CH07_F14_Cutajar.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH07_F14_Cutajar.png)'
- en: Figure 7.14 Receiving messages from the channel
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14 从通道接收消息
- en: 'The steps needed to meet all these requirements are shown in figure 7.14:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 满足所有这些要求所需的步骤如图7.14所示：
- en: The receiver releases a permit on the capacity semaphore. This will unblock
    a sender that is waiting for capacity to place its message.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接收器在容量信号量上释放一个许可证。这将解除等待容量以放置其消息的发送器的阻塞。
- en: The receiver tries to acquire a permit from the buffer size semaphore. This
    will have the effect of blocking the receiver goroutine if the buffer is empty
    of messages, meeting the second requirement.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接收器尝试从缓冲区大小信号量中获取一个许可证。如果缓冲区中没有消息，这将导致接收器goroutine阻塞，满足第二个要求。
- en: Once the semaphore unblocks the receiver, the goroutine reads and removes the
    next message from the buffer. Here we should use the same mutex used in the sender
    function so that we protect the shared buffer from concurrent executions interfering
    with each other.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦信号量解除接收器的阻塞，goroutine将读取并从缓冲区中移除下一条消息。在这里，我们应该使用与发送器函数中相同的互斥锁，以确保我们保护共享缓冲区免受并发执行的干扰。
- en: NOTE The reason for releasing the permit on the capacity semaphore first is
    that we want the implementation to also work when we have a zero-buffer channel.
    This is when the sender and receiver wait until both are available together.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：首先释放容量信号量许可证的原因是我们希望实现也能在零缓冲区通道的情况下工作。这就是发送器和接收器都等待直到两者同时可用的情况。
- en: Listing 7.17 shows the implementation of the `Receive()` function, performing
    the three steps outlined in figure 7.14\. It releases the capacity semaphore,
    acquires the buffer semaphore, and pulls the first message from the linked list
    that implements the queue buffer. The function uses the same mutex as the `Send()`
    function to protect the linked list from concurrent interference.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.17显示了`Receive()`函数的实现，执行图7.14中概述的三个步骤。它释放容量信号量，获取缓冲区信号量，并从实现队列缓冲区的链表中提取第一条消息。该函数使用与`Send()`函数相同的互斥锁来保护链表免受并发干扰。
- en: Listing 7.17 The `Receive()` function for the channel implementation
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.17 通道实现的`Receive()`函数
- en: '[PRE29]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ Releases one permit from the capacity semaphore
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从容量信号量中释放一个许可证
- en: ❷ Acquires one permit from the buffer size semaphore
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从缓冲区大小信号量中获取一个许可证
- en: ❸ Removes one message from the buffer while protecting against race conditions
    using the mutex
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在使用互斥锁保护以防止竞态条件的同时，从缓冲区中移除一条消息
- en: ❹ Returns the message’s value
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 返回消息的值
- en: If our buffer is empty, the buffer size semaphore will have `0` permits available.
    In this scenario, when a receiver goroutine tries to acquire the permit, the buffer
    size semaphore will block until a sender pushes a message and calls `Release()`
    on the same semaphore. Figure 7.15 shows the receiver goroutine blocking on a
    buffer size semaphore with `0` permits.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的缓冲区为空，缓冲区大小信号量将没有可用的许可证。在这种情况下，当接收器goroutine尝试获取许可证时，缓冲区大小信号量将阻塞，直到发送器推送一条消息并调用同一信号量的`Release()`。图7.15显示了接收器goroutine在具有`0`个许可证的缓冲区大小信号量上阻塞的情况。
- en: '![](../../OEBPS/Images/CH07_F15_Cutajar.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH07_F15_Cutajar.png)'
- en: Figure 7.15 A receiver blocking when the buffer is empty and we have `0` permits
    on the buffer size semaphore
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15 当缓冲区为空且我们在缓冲区大小信号量上有`0`个许可证时，接收器阻塞
- en: This blocking logic using semaphores will also work when the channel capacity
    is set to `0`, as shown in figure 7.16\. This is the default behavior of Go’s
    channels. In such a case, the receiver would increase the permits on the capacity
    semaphore and block on acquiring the buffer size semaphore. Once a sender comes
    along, it will acquire the permit from the capacity semaphore, push a message
    onto the buffer, and release the buffer size semaphore. This will have the effect
    of unblocking the receiver goroutine. The receiver will then pull the message
    from the buffer.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 使用信号量的这种阻塞逻辑，当通道容量设置为 `0` 时也会工作，如图 7.16 所示。这是 Go 通道的默认行为。在这种情况下，接收者会增加容量信号量上的许可，并阻塞在获取缓冲区大小信号量上。一旦有发送者到来，它将从容量信号量获取许可，将一条消息推入缓冲区，并释放缓冲区大小信号量。这将导致接收者
    goroutine 被解除阻塞。然后接收者将从缓冲区中拉取消息。
- en: '![](../../OEBPS/Images/CH07_F16_Cutajar.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F16_Cutajar.png)'
- en: Figure 7.16 A zero-capacity channel blocking the receiver until the sender pushes
    a message
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.16 零容量通道阻塞接收者，直到发送者推送一条消息
- en: If a sender arrives before a receiver in a zero-capacity channel, the sender
    will be blocked when it tries to acquire the capacity semaphore until a receiver
    comes along and releases a permit on the same semaphore.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在零容量通道中发送者先于接收者到达，当发送者尝试获取容量信号量时，它将被阻塞，直到有接收者到来并释放同一信号量上的许可。
- en: How are Go channels implemented?
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Go 通道是如何实现的？
- en: The actual Go implementation of channels integrates with the runtime scheduler
    to improve performance. Unlike our implementation, it doesn’t use a two-semaphore
    system to suspend goroutines. Instead, it uses two linked lists that store references
    to the suspended receiver and sender goroutines.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的 Go 语言通道实现与运行时调度器集成，以提高性能。与我们的实现不同，它不使用双信号量系统来挂起 goroutines。相反，它使用两个链表来存储挂起的接收者和发送者
    goroutines 的引用。
- en: The implementation also has a buffer to store any pending messages. When this
    buffer is full or the channel is synchronous, any new sender goroutine is suspended
    and queued in the senders’ list. Conversely, when the buffer is empty, any new
    receiver goroutine is suspended and queued in the receivers’ list.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 实现还有一个缓冲区来存储任何挂起的消息。当这个缓冲区满了或者通道是同步的，任何新的发送者 goroutine 会被挂起并排队在发送者列表中。相反，当缓冲区为空时，任何新的接收者
    goroutine 会被挂起并排队在接收者列表中。
- en: These lists are then used when a goroutine needs to be resumed. When a message
    becomes available, the first goroutine in the receivers’ list is picked and resumed.
    When a new receiver becomes available, the first goroutine in the senders’ list
    is resumed (if there is one). Unlike our implementation, this system ensures fairness
    amongst the suspended goroutines; the first goroutine that gets suspended will
    also be the first that gets resumed.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要恢复 goroutine 时，这些列表会被使用。当有消息可用时，接收者列表中的第一个 goroutine 被选中并恢复。当有新的接收者可用时，发送者列表中的第一个
    goroutine 被恢复（如果有的话）。与我们的实现不同，这个系统确保了挂起 goroutines 之间的公平性；第一个挂起的 goroutine 也将是第一个被恢复的。
- en: The channel’s source code can be found in Go’s GitHub project under the `runtime`
    package located at [https://github.com/golang/go/blob/master/src/runtime/chan.go](https://github.com/golang/go/blob/master/src/runtime/chan.go).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 通道的源代码可以在 Go 的 GitHub 项目中找到，位于 `runtime` 包下，具体位置为 [https://github.com/golang/go/blob/master/src/runtime/chan.go](https://github.com/golang/go/blob/master/src/runtime/chan.go)。
- en: 7.3 Exercises
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 练习
- en: NOTE Visit [http://github.com/cutajarj/ConcurrentProgrammingWithGo](http://github.com/cutajarj/ConcurrentProgrammingWithGo)
    to see all the code solutions.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：访问 [http://github.com/cutajarj/ConcurrentProgrammingWithGo](http://github.com/cutajarj/ConcurrentProgrammingWithGo)
    查看所有代码解决方案。
- en: In listings 7.1 and 7.2, the receiver doesn’t output the last message `STOP`.
    This is because the `main()` goroutine terminates before the `receiver()` goroutine
    gets the chance to print out the last message. Can you change the logic, without
    using extra concurrency tools and without using the sleep function, so that the
    last message is printed?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表 7.1 和 7.2 中，接收者没有输出最后的消息 `STOP`。这是因为 `main()` goroutine 在 `receiver()` goroutine
    有机会打印最后一条消息之前就终止了。你能否在不使用额外的并发工具和不使用 sleep 函数的情况下改变逻辑，以便打印最后一条消息？
- en: In listing 7.8, the receiver reads a `0` when the channel is closed. Can you
    try it with different data types? What happens if the channel is of type string?
    What if it is of type slice?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表 7.8 中，当通道关闭时，接收者读取到 `0`。你能否尝试使用不同的数据类型？如果通道是字符串类型会发生什么？如果是切片类型呢？
- en: In listing 7.13, we use a child goroutine to calculate the factors of one number
    and the `main()` goroutine to work out the factors of the other. Modify this listing
    so that, using multiple goroutines, we collect the factors of 10 random numbers.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表7.13中，我们使用子goroutine来计算一个数的因子，而`main()` goroutine来计算另一个数的因子。修改这个列表，以便使用多个goroutine收集10个随机数的因子。
- en: Modify listings 7.14 through 7.17 to implement a channel using condition variables
    instead of semaphores. The implementation also needs to support channels with
    a zero-sized buffer.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将列表7.14至7.17修改为使用条件变量而不是信号量来实现通道。实现还需要支持零大小缓冲区的通道。
- en: Summary
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: Message passing is another way for concurrent executions to communicate.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息传递是并发执行之间通信的另一种方式。
- en: Message passing is similar to our everyday way of communicating by passing a
    message and expecting an action or a reply.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息传递类似于我们日常通过传递消息并期待行动或回复的方式进行沟通。
- en: In Go, we can use channels to pass messages between our goroutines.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Go中，我们可以使用通道在goroutine之间传递消息。
- en: Channels in Go are synchronous. By default, a sender will block if there is
    no receiver, and the receiver will also block if there is no sender.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go中的通道是同步的。默认情况下，如果没有接收者，发送者将会阻塞，如果没有发送者，接收者也会阻塞。
- en: We can configure buffers on channels to store messages if we want to allow senders
    to send *N* messages before blocking on a receiver.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想允许发送者在阻塞接收者之前发送*N*条消息，我们可以配置通道上的缓冲区来存储消息。
- en: With buffered channels, a sender can continue writing messages to the channel
    even without a receiver if the buffer has enough capacity. Once the buffer fills
    up, the sender will block.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用缓冲通道时，如果缓冲区有足够容量，发送者即使没有接收者也可以继续向通道中写入消息。一旦缓冲区填满，发送者将会阻塞。
- en: With buffered channels, a receiver can continue reading messages from the channel
    if the buffer is not empty. Once the buffer empties, the receiver will block.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用缓冲通道时，如果缓冲区不为空，接收者可以继续从通道中读取消息。一旦缓冲区清空，接收者将会阻塞。
- en: We can assign directions to channel declarations so that we can receive from
    or send to a channel, but not both.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以为通道声明分配方向，以便我们可以从通道接收或向通道发送，但不能同时进行。
- en: A channel can be closed by using the `close()` function.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过使用`close()`函数来关闭通道。
- en: The read operation on a channel returns a flag telling us whether the channel
    is still open.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道上的读操作会返回一个标志，告诉我们通道是否仍然打开。
- en: We can continue to consume messages from a channel by using a `for` `range`
    loop until the channel is closed.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`for` `range`循环继续从通道中消费消息，直到通道关闭。
- en: We can use channels to collect the result of a concurrent goroutine execution.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用通道收集并发goroutine执行的结果。
- en: We can implement the channel functionality by using a queue, two semaphores,
    and a mutex.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过使用队列、两个信号量和互斥锁来实现通道功能。
