- en: 3 Building a serverless image recognition system, part 2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 构建无服务器图像识别系统，第二部分
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Building a simple AI as a Service system
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建简单的 AI as a Service 系统
- en: Consuming an AI image recognition service
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费人工智能图像识别服务
- en: Implementing synchronous and asynchronous services
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现同步和异步服务
- en: Deploying a UI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署用户界面
- en: Deploying to the cloud
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署到云端
- en: In this chapter we will continue building our serverless image recognition system
    that we started in chapter 2\. We will add our image recognition service that
    will call AWS Rekognition to do the hard work for us. Once this is done, we will
    build a simple front end for our system that will allow us to test our image recognition
    capabilities.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续构建我们在第 2 章开始的服务器端无服务器图像识别系统。我们将添加我们的图像识别服务，该服务将调用 AWS Rekognition
    来为我们完成繁重的工作。一旦完成，我们将为我们的系统构建一个简单的前端，以便我们可以测试我们的图像识别能力。
- en: If you haven’t worked through chapter 2, you should go back and do so now before
    proceeding with this chapter, as we will be building directly on top of the work
    that we started there. If you’re good with the content from chapter 2, we can
    dive right in where we left off and deploy the analysis service.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有完成第 2 章的内容，你应该在继续本章之前返回并完成它，因为我们将直接基于那里开始的工作进行构建。如果你对第 2 章的内容感到满意，我们可以直接从我们离开的地方继续，并部署分析服务。
- en: 3.1 Deploying the asynchronous services
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 部署异步服务
- en: In chapter 2 we set up our development environment and deployed the crawler
    service. In this chapter we will continue with the deployment of the rest of the
    system, starting with the analysis service.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 2 章中，我们设置了我们的开发环境并部署了爬虫服务。在本章中，我们将继续部署系统的其余部分，从分析服务开始。
- en: 3.1.1 Analysis service
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1 分析服务
- en: Let’s take a look at the `analysis-service`. In a similar manner to the `crawler-service`,
    this service is triggered by a message from the Analysis SQS queue once there
    are images available for analysis in our S3 bucket. An outline of the logic for
    this service is depicted in figure 3.1.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 `analysis-service`。与 `crawler-service` 类似，当我们的 S3 存储桶中有可供分析图像时，该服务会由
    Analysis SQS 队列的消息触发。该服务的逻辑概述如图 3.1 所示。
- en: '![](../Images/CH03_F01_Elger.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F01_Elger.png)'
- en: Figure 3.1 Analysis service
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 分析服务
- en: In essence the `analysis-service` forms a bridge between the downloaded images
    and the Amazon Rekognition service. Each image downloaded by the `crawler-service`
    is fed into Rekognition, and a set of labels is returned. Each label is a word
    describing the object recognized by the model in the image and a confidence level
    (a number between 0 and 100, where 100 is full confidence in the image label).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，`analysis-service` 在下载的图像和亚马逊 Rekognition 服务之间形成了一座桥梁。`crawler-service`
    下载的每一张图像都会输入到 Rekognition 中，并返回一组标签。每个标签都是一个描述图像中由模型识别的对象的词，以及一个置信度水平（一个介于 0 和
    100 之间的数字，其中 100 表示对图像标签的完全置信）。
- en: Following this analysis, the service processes the returned data to create a
    set of word counts that can be fed into a word cloud generator. The idea behind
    this is to try to visually determine a common thread between the images available
    at the given URL.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在此分析之后，该服务处理返回的数据以创建一组词频，这些词频可以输入到词云生成器中。背后的想法是尝试在给定 URL 上可用的图像之间视觉上确定一个共同的主题。
- en: Let’s take a look at the code in the `analysis-service`, starting with the `serverless.yml`
    configuration to see how this is achieved. This is shown in the next listing.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 `analysis-service` 中的代码，从 `serverless.yml` 配置开始，看看这是如何实现的。这将在下一列表中展示。
- en: Figure 3.1 Analysis service `serverless.yml`
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 分析服务 `serverless.yml`
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Allow access to the Rekognition API.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 允许访问 Rekognition API。
- en: ❷ Define main entry point
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义主入口点
- en: We should note at this point that the `serverless.yml` configuration file for
    this service is very similar to the previous ones. The main difference is that
    it allows access from this Lambda function to the Rekognition API. Let’s see how
    this interface works. The file `handler.js` in the `analysis-service` code implements
    this interface.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意，这个服务的 `serverless.yml` 配置文件与之前的非常相似。主要区别在于它允许 Lambda 函数访问 Rekognition
    API。让我们看看这个接口是如何工作的。`analysis-service` 代码中的 `handler.js` 文件实现了这个接口。
- en: The following listing shows the `require` statements for the `analysis-service`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了 `analysis-service` 的 `require` 语句。
- en: Figure 3.2 Analysis service require
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 分析服务 require
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ The AWS SDK module is loaded.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ AWS SDK 模块已加载。
- en: ❷ The S3 interface is created for dealing with buckets and their objects.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ S3接口是为了处理存储桶及其对象而创建的。
- en: ❸ The Rekognition interface is created.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建Rekognition接口。
- en: The next listing shows how the Rekognition object is used in the function `analyzeImageLabels`
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了如何在`analyzeImageLabels`函数中使用Rekognition对象。
- en: Figure 3.3 Using the Rekognition API
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 使用Rekognition API
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ The Rekognition call parameters are created.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建Rekognition调用参数。
- en: ❷ Rekognition’s detectLabel API is invoked.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 调用Rekognition的detectLabel API。
- en: ❸ The promise resolves with the results.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 承诺解析为结果。
- en: This simple function achieves an awful lot! It triggers an image recognition
    AI service to run against an image file stored in an S3 bucket, and then returns
    a set of results for further processing. All of this in a rather small amount
    of code!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的函数实现了很多功能！它触发了一个图像识别AI服务对存储在S3存储桶中的图像文件进行运行，然后返回一组结果以供进一步处理。所有这些都在相当少的代码中完成！
- en: It should be noted that we can do a lot more with Rekognition; however, for
    the purposes of this code, we are just using the default settings. We will explore
    this in more detail in later chapters.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，我们可以用Rekognition做很多事情；然而，出于这个代码的目的，我们只是使用了默认设置。我们将在后面的章节中更详细地探讨这一点。
- en: Tip Rekognition works on video as well as still images, and can be used to detect
    a range of features within images, such as smiling or frowning faces, text in
    images, and well-known people. Can you think of applications that would benefit
    your end users? For example, we have recently used it for address and zip code
    detection in images.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：Rekognition不仅适用于视频，也适用于静态图像，并且可以用于检测图像中的各种特征，如微笑或皱眉的脸，图像中的文本，以及知名人士。你能想到哪些对你的最终用户有益的应用？例如，我们最近用它来检测图像中的地址和邮政编码。
- en: The final listing for the `analysis-service` shows the function `wordCloudList`.
    This computes the number of occurrences of a word across all of the detected labels.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`analysis-service`的最终列表显示了`wordCloudList`函数。该函数计算所有检测到的标签中单词出现的次数。'
- en: Figure 3.4 `wordCloudList` computation
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 `wordCloudList`计算
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ The function accepts an array of label objects.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 函数接受一个标签对象的数组。
- en: ❷ The label set in each label object is iterated to count label occurrences.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 遍历每个标签对象中设置的标签集以计算标签出现次数。
- en: ❸ The map of counts is converted to an array of word-count pairs represented
    as two-element arrays.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将计数映射转换为表示为两个元素数组的单词-计数对的数组。
- en: 'Let’s go ahead and deploy the analysis service using the Serverless Framework:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用Serverless Framework部署分析服务：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once the deployment has completed successfully, we can re-run our system by
    queuing up a test message into SQS through the AWS console. Go ahead and do this,
    sending the same JSON message as before:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦部署成功完成，我们可以通过AWS控制台将一个测试消息排队到SQS中，重新运行我们的系统。请继续这样做，发送与之前相同的JSON消息：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will cause the crawler service to run. Once complete, the crawler will
    post a message asking for an analysis of the downloaded images into the analysis
    SQS queue, which will trigger the analysis service. The net result will be a set
    of tags added to our `status.json` file in S3\. If you go ahead and open this
    file, you should see something similar to the following listing.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致爬虫服务运行。一旦完成，爬虫将向分析SQS队列发送一条消息，请求对下载的图像进行分析，这将触发分析服务。最终结果将是一组标签添加到S3中的`status.json`文件中。如果你打开这个文件，你应该会看到以下类似的列表。
- en: Figure 3.5 `wordCloudList` computation results
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 `wordCloudList`计算结果
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Image download results
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 图像下载结果
- en: ❷ Image analysis results
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 图像分析结果
- en: ❸ Word cloud computation
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 单词云计算
- en: For a more complete system, we might consider storing this information in a
    database or key/value store; however, for this first demonstration, S3 works just
    fine. This status file is used to drive the front end and UI services, and it
    is to these that we will now turn our attention.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个更完整的系统，我们可能会考虑将此信息存储在数据库或键/值存储中；然而，对于这个第一个演示，S3就足够好了。此状态文件用于驱动前端和UI服务，我们现在将关注这些服务。
- en: 3.2 Implementing the synchronous services
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 实现同步服务
- en: In this system, the synchronous services are comprised of the UI service and
    a front end. The front end renders and executes entirely in the browser, while
    the UI services execute as three Lambda functions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个系统中，同步服务由UI服务和前端组成。前端在浏览器中渲染和执行，而UI服务作为三个Lambda函数执行。
- en: 3.2.1 UI service
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 UI服务
- en: Figure 3.2 outlines the operation of the UI service.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2概述了UI服务的操作。
- en: 'As illustrated, the UI service exposes three end points:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，UI 服务公开了三个端点：
- en: '`url/list` lists all URLs that have been submitted for analysis.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url/list` 列出已提交进行分析的所有 URL。'
- en: '`image/list` lists all images that have been analyzed for a specific URL.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image/list` 列出针对特定 URL 已分析的所有图像。'
- en: '`url/analyze` submits a URL for analysis.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url/analyze` 提交 URL 以进行分析。'
- en: The Serverless Framework allows us to define multiple Lambda functions in a
    single configuration file, and we have used this in the configuration of the UI
    service. Let’s take a look at the `serverless.yml` file for the UI service, shown
    in the next listing.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Serverless 框架允许我们在单个配置文件中定义多个 Lambda 函数，我们已经在 UI 服务的配置中使用了这一点。让我们看一下 UI 服务的
    `serverless.yml` 文件，它将在下一个列表中展示。
- en: '![](../Images/CH03_F02_Elger.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F02_Elger.png)'
- en: Figure 3.2 UI service
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 UI 服务
- en: Figure 3.6 UI service `serverless.yml`
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 UI 服务 `serverless.yml`
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Domain plugin
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 域插件
- en: ❷ Custom domain settings
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 自定义域名设置
- en: ❸ Role permissions
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 角色权限
- en: ❹ Analyze URL Lambda HTTP POST
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 分析 URL Lambda HTTP POST
- en: ❺ List URLs lambda
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 列出 URL Lambda
- en: ❻ List images lambda
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 列出图像 Lambda
- en: This configuration introduces a few new elements over and above the previous
    configuration files. First we are using a custom plugin--`serverless-domain-manager`.
    We are using this to help us set up a custom domain for our service. If you recall,
    at the start of chapter 2, we set up a domain in Route53 and created a wild card
    certificate. In a moment, we will use this domain for our UI service.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置在之前的配置文件之上引入了一些新元素。首先，我们使用了一个自定义插件--`serverless-domain-manager`。我们使用它来帮助我们为我们的服务设置一个自定义域名。如果您还记得，在第
    2 章的开始，我们在 Route53 中设置了一个域名并创建了一个通配符证书。一会儿，我们将使用此域名来为我们的 UI 服务。
- en: The permissions section in the configuration should look familiar at this point.
    The functions section is a little different, in that there are three entries.
    Note that each entry is similar, in that it is tied to an `HTTP` event. This tells
    Serverless to tie the function to API Gateway and make the function available
    through the given route. The custom domain entry is used to create a DNS entry
    for the service, and to connect this to API Gateway. We’ll deploy this service
    in a moment, but first let’s take a look at the implementation, which is in the
    file `handler.js`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，配置中的权限部分应该看起来很熟悉。函数部分略有不同，因为它有三个条目。请注意，每个条目都是相似的，因为它与一个 `HTTP` 事件相关联。这告诉
    Serverless 将函数绑定到 API Gateway，并通过给定的路由使函数可用。自定义域名条目用于为服务创建 DNS 条目，并将其连接到 API Gateway。我们将在一会儿部署此服务，但首先让我们看看实现，它在
    `handler.js` 文件中。
- en: In what should now be a familiar pattern, we require the AWS SDK and then create
    the required objects for the service to consume, which in this case are S3 and
    SQS. This is shown in the following listing.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在现在应该已经熟悉的模式中，我们引入 AWS SDK 并创建服务所需的对象，在这种情况下是 S3 和 SQS。这将在以下列表中展示。
- en: Figure 3.7 UI service `require`
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 UI 服务 `require`
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ The url node module is loaded for URL parsing.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 加载 url 节点模块以进行 URL 解析。
- en: ❷ The AWS SDK is loaded with the S3 and SQS interfaces instantiated.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 加载 AWS SDK 并实例化 S3 和 SQS 接口。
- en: The service defines three entry points which will be deployed as three separate
    Lambda functions. The `listUrl` function is provided in the next listing.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务定义了三个入口点，它们将被部署为三个单独的 Lambda 函数。`listUrl` 函数将在下一个列表中提供。
- en: Figure 3.8 `listUrls` function
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 `listUrls` 函数
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Entry point
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 入口点
- en: ❷ List S3 objects
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 列出 S3 对象
- en: ❸ Respond with URL list
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 返回 URL 列表
- en: Note that the entry point to this function is exactly the same as for all of
    our other services, even though in this case the function will be executed through
    API Gateway as a HTTP GET request. The function is quite simple in that it merely
    lists the set of folders at the top level in our S3 bucket and returns the list
    as a JSON array.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此函数的入口点与我们的所有其他服务完全相同，尽管在这种情况下，该函数将通过 API Gateway 作为 HTTP GET 请求执行。该函数相当简单，它只是列出我们
    S3 存储桶顶层的一组文件夹，并将列表作为 JSON 数组返回。
- en: Our `listImages` function is simpler still, in that it reads the file `status.json`
    from S3 and returns the contents for display, so we won’t cover it in much detail
    here. Let’s instead take a look at the `analyzeUrl` function in the following
    code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `listImages` 函数更加简单，因为它从 S3 读取 `status.json` 文件并返回用于显示的内容，所以我们在这里不会详细说明它。相反，让我们看一下以下代码中的
    `analyzeUrl` 函数。
- en: Figure 3.9 `analyzeUrl`
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 `analyzeUrl`
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Build queue URL
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 构建队列 URL
- en: ❷ Send SQS Message
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 发送 SQS 消息
- en: Again, this function is fairly straightforward. It takes a URL as the event
    body and posts this URL as part of the message payload to our SQS queue for the
    crawler service to handle.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这个函数相当直接。它将URL作为事件体，并将此URL作为消息有效负载的一部分发布到我们的SQS队列，由爬虫服务处理。
- en: Single responsibility principle
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: 'The *single responsibility principle* or *SRP* is a powerful idea that helps
    us to keep our code decoupled and well maintained. As you can hopefully see, all
    of the code so far adheres to the SRP. We like to think of the SRP as something
    that applies at several levels:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*单一职责原则*或*SRP*是一个强大的理念，它帮助我们保持代码的解耦和良好的维护。希望你能看到，到目前为止的所有代码都遵循了SRP。我们喜欢将SRP视为适用于多个层面的东西：'
- en: At the architectural level, each service should have a single purpose.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在架构层面，每个服务应该有一个单一的目的。
- en: At the implementation level, each function should have a single purpose.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实现层面，每个函数应该有一个单一的目的。
- en: At the “line of code” level, each line should do one thing only.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在“代码行”级别，每一行只应该做一件事。
- en: 'What do we mean by the “line of code” level? Well, the following code does
    multiple things on one line, in that it gets a value for `bar` and tests it against
    `foo`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所说的“代码行”级别是什么意思呢？嗯，以下代码在一行中做了多件事，因为它获取了`bar`的值并对其与`foo`进行了测试：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A much clearer implementation would be to split the code into two lines, so
    that each line does one thing only:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更清晰的实现是将代码拆分为两行，这样每行只做一件事：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now that we understand the UI service code, let’s go ahead and deploy it. First
    we will need to create the custom domain entry. The `serverless.yml` file uses
    an environment variable `CHAPTER2_DOMAIN` as the base domain for the `ui-service`
    deployment. If you haven’t set this variable yet, you should do so now by adding
    the contents of the following listing to your shell startup script.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了UI服务代码，让我们继续部署它。首先，我们需要创建自定义域名条目。`serverless.yml`文件使用环境变量`CHAPTER2_DOMAIN`作为`ui-service`部署的基础域名。如果你还没有设置此变量，你应该现在设置它，通过将以下列表的内容添加到你的shell启动脚本中。
- en: Figure 3.10 Setting the environment variable for the base domain
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 设置基础域的环境变量
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Replace `<MY CUSTOM DOMAIN>` with the domain that you created at the start of
    the chapter.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将`<MY CUSTOM DOMAIN>`替换为章节开头创建的域名。
- en: 'Next we will need to install the supporting node modules. To do this, `cd`
    into the `ui-service` directory and install these dependencies:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要安装支持节点模块。为此，请使用`cd`命令进入`ui-service`目录，并安装以下依赖项：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will install all of the dependencies in `package.json` locally, including
    the `serverless-domain-manager`. To create our custom domain, run
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在本地安装`package.json`中的所有依赖项，包括`serverless-domain-manager`。要创建我们的自定义域名，请运行
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This command will cause the domain manager plugin to create the domain in `Route53`.
    For example, if your custom domain name were `example.com`, then this would create
    an `A` record for `chapter2api.example.com`, as specified in the `customDomain`
    section of `serverless.yml`. This section is shown in the next listing.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将导致域名管理器插件在`Route53`中创建域名。例如，如果你的自定义域名是`example.com`，那么这将创建一个指向`chapter2api.example.com`的`A`记录，如`serverless.yml`中的`customDomain`部分所述。此部分将在下一列表中展示。
- en: Figure 3.11 `serverless.yml` custom section for `ui-service`
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 `serverless.yml`中`ui-service`的定制部分
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Custom domain environment variable
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 自定义域环境变量
- en: ❷ Full domain name
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 完整域名
- en: ❸ Certificate reference
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 证书引用
- en: 'Note that you will need the `APIGatewayAdministrator` privilege for this to
    succeed. If you created a fresh AWS account, then this should be enabled by default.
    Finally we will need to deploy the service in the usual manner:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你需要`APIGatewayAdministrator`权限才能成功执行此操作。如果你创建了一个新的AWS账户，那么这应该默认启用。最后，我们还需要以通常的方式部署服务：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will deploy our UI endpoints as Lambda functions, configure API Gateway
    to call these functions, and tie our custom domain into API Gateway. The net result
    is that our functions are now available to call over HTTP as [https://chapter2api.<YOUR
    CUSTOM DOMAIN>/api/url/list](https://chapter2api.<YOUR%20CUSTOM%20DOMAIN%3E/api/url/list).
    To test this out, open a web browser and point it to that URL. You should see
    the following output:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这将部署我们的UI端点作为Lambda函数，配置API Gateway以调用这些函数，并将我们的自定义域名绑定到API Gateway。最终结果是，我们的函数现在可以通过HTTP进行调用，地址为[https://chapter2api.<YOUR
    CUSTOM DOMAIN>/api/url/list](https://chapter2api.<YOUR%20CUSTOM%20DOMAIN%3E/api/url/list)。要测试这一点，请打开网页浏览器并将它指向该URL。你应该会看到以下输出：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That’s because we have so far submitted a single URL for download and analysis,
    and the UI service is returning a list of one element.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们迄今为止只提交了一个用于下载和分析的单个URL，并且UI服务正在返回一个元素列表。
- en: 3.2.2 Front end service
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.2前端服务
- en: The final part of our system is the front end service. This is a little different
    from the rest of the system in that it is purely a front end component and executes
    entirely in the user’s browser. Figure 3.3 outlines the structure of the front
    end service.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们系统的最后一部分是前端服务。它与系统其他部分的不同之处在于，它纯粹是一个前端组件，并在用户的浏览器中完全执行。图3.3概述了前端服务的结构。
- en: '![](../Images/CH03_F03_Elger.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F03_Elger.png)'
- en: Figure 3.3 Front end
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3前端
- en: We will deploy this service as a set of static files to S3\. Let’s take a look
    at the code first. `cd` into the `frontend-service` directory. You should see
    the structure shown in the next listing.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个服务作为一组静态文件部署到S3。首先让我们看看代码。`cd`到`frontend-service`目录。您应该会看到下一列表中显示的结构。
- en: Listing 3.12 Front end structure
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.12前端结构
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this case we don’t require a serverless.yml configuration, as we are just
    going to deploy our front end to an S3 bucket. The code for the front end is contained
    in the `app` directory, which holds the HTML and JavaScript for our application.
    Our application in this case is an example of what is known as a *single-page
    application (SPA)*. There are many frameworks that help with the construction
    of large-scale SPA applications such as Angular, React, or Vue. For our simple
    application, we are just using jQuery, as this provides a simple lowest common
    denominator, and our application is simple enough not to require the support of
    a front end framework.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不需要serverless.yml配置，因为我们只是将前端部署到S3存储桶。前端代码包含在`app`目录中，该目录包含我们应用的HTML和JavaScript。在这个例子中，我们的应用是一个所谓的*单页应用（SPA）*的例子。有许多框架可以帮助构建大规模SPA应用，如Angular、React或Vue。对于我们的简单应用，我们只是使用了jQuery，因为它提供了一个简单的最低共同点，并且我们的应用足够简单，不需要前端框架的支持。
- en: Single-page application
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 单页应用
- en: The single-page application architecture is characterized by dynamically rewriting
    content into a single page, rather than reloading a web page in order to render
    new content. This approach has become increasingly popular and is used in most
    modern web applications. Indeed, it is the rise of this application model that
    has in part driven the development of many of the front end JavaScript frameworks
    that you may have come across, such as Angular, React, Vue, and so on.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 单页应用架构的特点是动态地将内容重写为单页，而不是重新加载网页以渲染新内容。这种方法越来越受欢迎，并被广泛应用于大多数现代网络应用中。实际上，正是这种应用模式的兴起，部分推动了您可能遇到的前端JavaScript框架（如Angular、React、Vue等）的发展。
- en: 'If you are unfamiliar with this approach, we recommend this e-book as a way
    to brush up on this topic: [https://github.com/mixu/singlepageappbook](https://github.com/mixu/singlepageappbook).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉这种方法，我们建议您阅读这本电子书来提高对这个主题的了解：[https://github.com/mixu/singlepageappbook](https://github.com/mixu/singlepageappbook)。
- en: Note For this example system, we will be using S3 directly to serve up our application.
    To operate at scale, it is common practice to use an S3 bucket as the origin for
    Amazon’s CloudFront CDN (content delivery network).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：对于这个示例系统，我们将直接使用S3来提供我们的应用。为了实现规模化的操作，通常的做法是将S3存储桶作为Amazon CloudFront CDN（内容分发网络）的源。
- en: The code that implements the front end is fairly simple, consisting of a single
    HTML page and some JavaScript. Let’s take a quick look at the index page, shown
    in the following listing.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 实现前端代码相对简单，仅由一个HTML页面和一些JavaScript组成。让我们快速查看以下列表中的索引页面。
- en: Figure 3.13 Front end i`ndex.html`
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13前端`index.html`
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ CDN libraries
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ CDN库
- en: ❷ Application code
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 应用代码
- en: ❸ Define navigation bar
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 定义导航栏
- en: ❹ Main content area
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 主要内容区域
- en: In the `head` section of the page, we load in some standard libraries such as
    jQuery and Bootstrap from a shared CDN. This is just a convenience. For a production
    web application, we would normally redistribute these libraries ourselves in order
    to ensure their integrity. The main markup in this page then defines a simple
    navigation bar, before declaring a content area which will be populated by the
    application code, the bulk of which is in the file `code.js`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面的 `head` 部分中，我们加载了一些标准库，如 jQuery 和 Bootstrap，来自共享 CDN。这只是方便一下。对于生产级 Web 应用程序，我们通常会自己重新分发这些库以确保它们的完整性。该页面的主要标记定义了一个简单的导航栏，然后声明一个内容区域，该区域将由应用程序代码填充，其中大部分代码在
    `code.js` 文件中。
- en: jQuery, Bootstrap, and CDN
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery、Bootstrap 和 CDN
- en: If you are unfamiliar with front end JavaScript development, you may be wondering
    about the links to Bootstrap and jQuery in the HTML file. As a convenience to
    their users, these projects both provide hosted, minified versions of major releases
    of their libraries on fast content-delivery networks for inclusion by external
    applications.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对前端 JavaScript 开发不熟悉，你可能想知道 HTML 文件中 Bootstrap 和 jQuery 的链接。为了方便用户，这两个项目都提供了它们库的主要版本的主机、压缩版本，并在快速内容分发网络上提供，以便外部应用程序使用。
- en: We have removed some of the detail from the code in the next listing for the
    sake of clarity. The full code is available in the Git repository.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，我们从下一列表中的代码中删除了一些细节。完整的代码可在 Git 仓库中找到。
- en: Figure 3.14 Main JavaScript for front-end application
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.14 前端应用程序的主要 JavaScript
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Define the bucket URL root.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义存储桶 URL 根。
- en: ❷ Define the UI API root.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义 UI API 根。
- en: ❸ Fetch and render URLs.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 获取并渲染 URL。
- en: ❹ Fetch and render images.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 获取并渲染图像。
- en: ❺ Send a URL for analysis.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 发送一个 URL 进行分析。
- en: 'The code uses standard jQuery functions to make AJAX requests to the UI service
    that we just deployed. It renders the list of URLs that have been analyzed on
    page load, and the list of images that have been analyzed for a particular URL.
    Finally, it allows the user to submit a new URL for analysis. Before we deploy
    the front end, you should edit the file `code.js` and replace the following lines:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用标准的 jQuery 函数向刚刚部署的 UI 服务发送 AJAX 请求。它在页面加载时渲染已分析的 URL 列表，以及针对特定 URL 分析的图像列表。最后，它允许用户提交新的
    URL 进行分析。在我们部署前端之前，你应该编辑 `code.js` 文件并替换以下行：
- en: '`const` `BUCKET_ROOT` `=` `''<YOUR` `BUCKET` `URL>''` should be replaced with
    the URL for your specific bucket; for example, [https://s3-eu-west-1.amazonaws.com
    /mybucket](https://s3-eu-west-1.amazonaws.com/mybucket).'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const` `BUCKET_ROOT` `=` `''<YOUR` `BUCKET` `URL>''` 应替换为你的特定存储桶的 URL；例如，[https://s3-eu-west-1.amazonaws.com
    /mybucket](https://s3-eu-west-1.amazonaws.com/mybucket)。'
- en: '`const` `API_ROOT` `=` `''https://chapter2api.<YOUR` `CUSTOM` `DOMAIN>/api/''`
    should be replaced with your specific custom domain.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const` `API_ROOT` `=` `''https://chapter2api.<YOUR` `CUSTOM` `DOMAIN>/api/''`
    应替换为你的特定自定义域名。'
- en: 'Now that’s done, so we can go ahead and deploy the front end. To do this, we
    are going to use the AWS command line that we set up at the start of the chapter.
    Run the following commands:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经完成了，我们可以继续部署前端。为此，我们将使用本章开头设置的 AWS 命令行。运行以下命令：
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note For this example we are deploying our front end into the same bucket as
    our scraped data. We don’t advise that you do this for a production system!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：对于这个例子，我们将前端部署到与我们的抓取数据相同的存储桶中。我们不建议你在生产系统中这样做！
- en: We have now built and deployed a full serverless AI system; in the next section
    we’ll give it a spin!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经构建并部署了一个完整的无服务器 AI 系统；在下一节中，我们将对其进行测试！
- en: 3.3 Running the system
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 运行系统
- en: Now that we have fully deployed our system, it’s time to give it a try. To do
    this, open a web browser and point it to [https://<YOURBUCKETNAME>.s3.amazonaws.com/index.html](https://<YOURBUCKETNAME%3E.s3.amazonaws.com/index.html).
    The index page should load and display a single URL that has been analyzed during
    our test deployments, as illustrated in figure 3.4.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完全部署了我们的系统，是时候尝试一下了。为此，打开一个网页浏览器并将其指向 [https://<YOURBUCKETNAME>.s3.amazonaws.com/index.html](https://<YOURBUCKETNAME%3E.s3.amazonaws.com/index.html)。索引页面应该加载并显示在测试部署期间分析的单个
    URL，如图 3.4 所示。
- en: '![](../Images/CH03_F04_Elger.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F04_Elger.png)'
- en: Figure 3.4 Default landing page with one URL
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 带有一个 URL 的默认着陆页
- en: Let’s see how our image analysis system gets on with some other images. Given
    that the internet runs on cat pictures, point your browser to Google and search
    for “cat pictures”--then click on the Images tab. It should look something like
    figure 3.5.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的图像分析系统在其他图像上的表现。鉴于互联网上充斥着猫图片，请将你的浏览器指向Google并搜索“猫图片”——然后点击“图片”标签。它应该看起来像图3.5。
- en: '![](../Images/CH03_F05_Elger.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F05_Elger.png)'
- en: Figure 3.5 Cat pictures on Google Images
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 Google Images上的猫图片
- en: 'Copy the URL from the address bar, go back to the landing page, and paste it
    into the target URL field. Then click the Analyze button. After a few seconds,
    refresh the page: you should see an entry in the list for `www.google.com` with
    a status of analyzed, as illustrated in figure 3.6.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 从地址栏复制URL，回到着陆页，将其粘贴到目标URL字段中。然后点击分析按钮。几秒钟后，刷新页面：你应该在列表中看到一个状态为已分析的`www.google.com`条目，如图3.6所示。
- en: '![](../Images/CH03_F06_Elger.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F06_Elger.png)'
- en: Figure 3.6 Landing page with Google Images analysis
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 带有Google Images分析的着陆页
- en: Click the link to the newly analyzed data set, and the system will display a
    list of images that were analyzed by Rekognition, and also a word cloud that we
    generated on our front end. This is shown in figure 3.7.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 点击新分析数据集的链接，系统将显示由Rekognition分析过的图像列表，以及我们在前端生成的词云。这如图3.7所示。
- en: '![](../Images/CH03_F07_Elger.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F07_Elger.png)'
- en: Figure 3.7 Landing page with Google Images analysis
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 带有Google Images分析的着陆页
- en: 'The system has been fairly successful in recognizing our feline images; however,
    in some cases it failed entirely. Each image that was successfully processed will
    have an associated tag list. Each tag has two components: a word and a score out
    of 100\. This number is the confidence level, and is a measure of how accurate
    a match the AI thinks the word is to the image. It is interesting to look at the
    images that failed recognition; for example, in figure 3.8\. It is probably unsurprising
    that no accurate determination could be made on the image of the cat stretched
    out on its back!'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 该系统在识别我们的猫图像方面相当成功；然而，在某些情况下，它完全失败了。每个成功处理的图像都将有一个相关的标签列表。每个标签有两个组成部分：一个单词和一个100分中的分数。这个数字是置信度，是AI认为单词与图像匹配准确性的度量。看看无法识别的图像很有趣；例如，图3.8中的图像。对于猫背部的图像无法做出准确判断可能并不令人惊讶！
- en: '![](../Images/CH03_F08_Elger.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F08_Elger.png)'
- en: Figure 3.8 Landing page with Google Images analysis
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../Images/CH03_F08_Elger.png)'
- en: Congratulations! You have now deployed and operated your first serverless AI
    system!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在已经部署并运行了你的第一个无服务器AI系统！
- en: We covered an awful lot of ground in this chapter, from a standing start to
    a fully working serverless AI system that can recognize images from arbitrary
    web pages. While this has been a bit of a whirlwind tour, we hope that it serves
    to illustrate that complex AI functionality is now available to developers with
    no specialized knowledge.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从零开始，构建了一个完全工作的无服务器AI系统，该系统能够从任意网页中识别图像。虽然这只是一场旋风般的游览，但我们希望这能说明，复杂的AI功能现在对没有专业知识的人来说也是可用的。
- en: Bear in mind that we only scratched the surface of what Rekognition and image
    recognition technology in general can do. Hopefully you are currently thinking
    of ways to use this functionality in your own work. Some use cases that we have
    come across include
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们只是触及了Rekognition和图像识别技术所能做到的一小部分。希望你现在正在思考如何在你的工作中使用这项功能。我们遇到的一些用例包括
- en: Extracting name and zip code information from images
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从图像中提取姓名和邮政编码信息
- en: Verifying that uploaded profile pictures are of valid human faces
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证上传的个人信息照片是否为有效的人类面部
- en: Helping blind or partially sighted people by describing objects in the current
    field of view
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过描述当前视野中的物体来帮助盲人或视力受损的人
- en: Google reverse image search, which allows one to search for visually similar
    images
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google反向图像搜索，允许人们搜索视觉上相似的图像
- en: Identification of wine by type, price, and value through taking a picture of
    the label on a bottle
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过拍摄瓶子上标签的图片来识别酒的类型、价格和价值
- en: The possibilities are endless, and we are certain to see new businesses spring
    up around this technology.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 可能性是无限的，我们肯定会在这一技术周围看到新的商业出现。
- en: Hopefully you will agree that we were able to achieve a lot of functionality
    with comparatively little code, allowing the cloud infrastructure to do the heavy
    lifting for us. We should also note that this image recognition system could be
    constructed with no specialized knowledge of neural networks or deep learning.
    We will expand upon this engineering approach to AI throughout the rest of this
    book.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你能同意，我们能够用相对较少的代码实现了很多功能，让云基础设施为我们承担重担。我们还应该指出，这个图像识别系统可以不使用神经网络或深度学习的专业知识来构建。我们将在本书的其余部分扩展这一AI工程方法。
- en: 3.4 Removing the system
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 移除系统
- en: Once you are done with testing the system, it should be removed entirely in
    order to avoid incurring additional charges. This can be achieved very simply
    by using the Serverless `remove` command. There is a script, `remove.sh`, in the
    `chapter2-3` code directory that does the removal for you. This will remove the
    front end from S3 and tear down all of the associated resources. To use it, run
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成对系统的测试，它应该被完全移除，以避免产生额外费用。这可以通过使用Serverless的`remove`命令非常简单地实现。在`chapter2-3`代码目录中有一个名为`remove.sh`的脚本，它会为你完成移除工作。这将从S3中移除前端，并拆除所有相关资源。要使用它，请运行
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you would like to redeploy the system at any time, there is an associated
    script called `deploy.sh` in the same folder. This will redeploy the entire system
    for you by automating the steps that we worked through in this chapter.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望在任何时候重新部署系统，同一文件夹中有一个名为`deploy.sh`的关联脚本。这将通过自动化我们在本章中工作的步骤为你重新部署整个系统。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: An analysis service consumes an image recognition AI service. We use the AWS
    Rekognition `detectLabels` API to detect labelled objects in each image.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个分析服务消费一个图像识别AI服务。我们使用AWS Rekognition的`detectLabels` API来检测每张图像中的标记对象。
- en: A simple API was created to interact with our analysis system. We use API Gateway
    to provide an external endpoint for the serverless services.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个简单的API来与我们的分析系统交互。我们使用API网关为无服务器服务提供外部端点。
- en: A front end single-page application can be deployed as part of a serverless
    application. Our single-page application is copied to a publicly accessible S3
    bucket.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端单页应用程序可以作为无服务器应用程序的一部分进行部署。我们的单页应用程序被复制到公开可访问的S3存储桶中。
- en: All infrastructure for this system is defined as code; at no point did we need
    to use the AWS web console to deploy our application.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该系统的所有基础设施都定义为代码；我们从未需要使用AWS网页控制台来部署我们的应用程序。
- en: Deployment and removal can be fully automated through a script that triggers
    the Serverless Framework.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署和移除可以通过触发Serverless框架的脚本实现完全自动化。
- en: Warning Please ensure that you fully remove all cloud resources deployed in
    this chapter in order to avoid additional charges!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 请确保你完全移除本章中部署的所有云资源，以避免产生额外费用！
