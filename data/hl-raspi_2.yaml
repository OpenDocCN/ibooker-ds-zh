- en: Part 3\. Pi and Python projects
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3部分。Pi和Python项目
- en: Let’s face it. Pressing buttons, playing sounds, and lighting up cool colored
    lights is fun! Now you get to use your Pi to make those things happen. You’re
    going to create interactive projects that use your Pi’s input and output pins.
    This makes your Pi a special type of computer that doesn’t just show images on
    the screen, but that can control and sense the world around it. This realm is
    called *physical computing*. Robotics is physical computing, but think about all
    the creative possibilities such as making interactive art, creating smart rooms
    that sense your presence and turn on a light or play music, or producing something
    that can alert you if it’s about to start raining or your pet is drinking water.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们面对现实。按按钮、播放声音和点亮酷炫的彩色灯是很有趣的！现在你可以用你的Pi来让这些事情发生。你将创建使用Pi的输入和输出引脚的交互式项目。这使得你的Pi成为一种特殊的计算机，它不仅能在屏幕上显示图像，还能控制和感知周围的世界。这个领域被称为*物理计算*。机器人技术是物理计算的一部分，但想想所有创造性的可能性，比如制作交互式艺术、创建能感知你的存在并打开灯光或播放音乐的智能房间，或者生产一些可以提醒你即将下雨或你的宠物正在喝水的物品。
- en: 'In [part 3](#part03), you’ll build projects that can interact with the world
    using Python and your Raspberry Pi. The projects will require some additional
    parts that you can purchase individually or as part of a kit, such as the CanaKit
    Ultimate Kit, Adafruit Starter Kit, or MCM Electronics Starter Kit:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3部分](#part03)中，你将构建可以使用Python和你的Raspberry Pi与世界交互的项目。这些项目可能需要一些额外的部件，你可以单独购买或作为套件的一部分购买，例如CanaKit终极套件、Adafruit入门套件或MCM
    Electronics入门套件：
- en: Raspberry Pi 2 Model B including SD card, power supply, cables, keyboard, and
    monitor
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含SD卡、电源、线缆、键盘和显示器的Raspberry Pi 2 Model B
- en: Breadboard
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面包板
- en: GPIO ribbon cable for the Model B+ (40 pin)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Model B+ (40引脚) 的GPIO排线
- en: GPIO breakout board
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GPIO扩展板
- en: 1 dozen jumper wires, male to male
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 12根跳线，公对公
- en: 1 red LED (light-emitting diode)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个红色LED（发光二极管）
- en: 1 green LED
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个绿色LED
- en: 1 blue LED
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个蓝色LED
- en: 3 push buttons
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3个按钮
- en: 3 resistors, 10K ohm
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3个10K欧姆电阻
- en: 3 resistors, 180 ohm (or between 100 and 300 ohms)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3个180欧姆电阻（或介于100到300欧姆之间）
- en: Headphones or powered computer speakers
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头戴式耳机或带电源的计算机扬声器
- en: You start in [chapter 6](kindle_split_016.html#ch06) by setting up your Pi with
    an electronics breadboard, building a simple circuit, and controlling an LED (light)
    using Python. You’ll learn how to communicate through your Pi’s output pins to
    make something happen. In this case, you’ll make an LED light up. [Chapter 7](kindle_split_017.html#ch07)
    dives into creating an interactive guessing game that uses lights to respond to
    a player’s input, letting them know with different colors whether their answer
    is right or wrong. In [chapter 8](kindle_split_018.html#ch08), you’ll learn how
    to listen to your Pi’s input pins by wiring up a push button on your breadboard
    and then responding when it’s pushed; and you’ll complete a project that combines
    buttons and sounds to make your own DJ Raspi sound mixer. By the end, the goal
    is for you to have the knowledge, skills, and confidence to think up and create
    your own Pi and Python projects.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你从[第6章](kindle_split_016.html#ch06)开始，通过使用电子面包板设置你的Pi，构建一个简单的电路，并使用Python控制LED（灯）。你将学习如何通过Pi的输出引脚进行通信，以使某些事情发生。在这种情况下，你将使LED灯亮。在[第7章](kindle_split_017.html#ch07)中，我们将深入探讨创建一个使用灯光响应玩家输入的交互式猜谜游戏，用不同的颜色告诉他们他们的答案是对是错。在[第8章](kindle_split_018.html#ch08)中，你将学习如何通过在面包板上连接一个按钮来监听你的Pi的输入引脚，并在按下时做出响应；你将完成一个结合按钮和声音来制作你自己的DJ
    Raspi声音混音器的项目。到那时，目标是让你拥有知识、技能和信心，能够想出并创建你自己的Pi和Python项目。
- en: Chapter 6\. Blinky Pi
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6章。闪烁的Pi
- en: '**In this chapter, you’ll be learning about**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**在本章中，你将学习的内容**'
- en: '*Giving your Pi the ability to talk to the outside world through connectors
    to anything*'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过连接器给你的Pi赋予与任何东西交流的能力*'
- en: '*Programming the world outside your Pi with simple electric/electronic circuits*'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用简单的电/电子电路编程你Pi之外的世界*'
- en: '*Programming the connectors using your previous Python knowledge to make light
    patterns*'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用你之前的Python知识编程连接器以创建灯光图案*'
- en: Setting robots in motion, creating smart homes with sensors, and designing an
    interactive electronic art exhibit sound like vastly different topics, but they’re
    all things you can do with your Raspberry Pi. In each case, the Pi can act as
    the brain and interact with the world by doing things like
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让机器人运动起来，创建带有传感器的智能家庭，以及设计一个交互式电子艺术展览听起来像是截然不同的主题，但这些都是你可以用你的Raspberry Pi做到的事情。在每种情况下，Pi都可以作为大脑，通过做一些事情与世界互动，比如
- en: Checking a robot’s sensors and controlling its motors
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查机器人的传感器和控制其电机
- en: Sensing a room’s occupants and adjusting the thermostat or lights
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 感知房间的居住者并调整恒温器或灯光
- en: Controlling sound, motion, and light as part of an art display
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为艺术展示的一部分控制声音、运动和灯光
- en: In this chapter, you’ll set up your Pi to control small light bulbs called *light-emitting
    diodes (LEDs)*. You’ll make the LEDs blink using Python. To do this, you’ll need
    to learn a bit about how to build electrical circuits on breadboards. If you’ve
    never heard of a breadboard, don’t worry! It’s a small board with lots of holes
    in it to make it easier to build electrical circuits. You’ll also be using short
    wires (called *jumper wires*) to connect certain holes. You’ll even learn how
    to add resistors that keep your LEDs from burning out. See [figure 6.1](#ch06fig01)
    for a list of parts and what they look like; gather the parts, and let’s get started!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将设置你的 Pi 来控制称为 *发光二极管 (LED)* 的小型灯泡。你将使用 Python 使 LED 闪烁。为此，你需要了解一些如何在面包板上构建电路的知识。如果你从未听说过面包板，不要担心！它是一个带有许多孔的小板，这使得构建电路更容易。你还将使用短导线（称为
    *跳线*）来连接某些孔。你甚至将学习如何添加电阻，以防止你的 LED 烧毁。参见[图 6.1](#ch06fig01) 了解所需部件及其外观；收集部件，让我们开始吧！
- en: Figure 6.1\. The Blinky Pi project requires parts that are commonly found in
    Raspberry Pi starter kits or that can be purchased online.
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.1\. Blinky Pi 项目需要一些在 Raspberry Pi 入门套件中常见或可以在线购买的部件。
- en: '![](06fig01_alt.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig01_alt.jpg)'
- en: Setting up your Pi for physical computing
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为物理计算设置你的 Pi
- en: Your Pi is unique compared to most computers because of its input and output
    pins, called *GPIO* pins. Let’s learn how to work with those pins.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数计算机相比，你的 Pi 由于其输入和输出引脚，称为 *GPIO* 引脚而独特。让我们学习如何与这些引脚一起工作。
- en: '|  |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Definition
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: GPIO stands for *general purpose input and output*. These are the pins on your
    Raspberry Pi that allow it to sense and control things around it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO 代表 *通用输入/输出*。这些是 Raspberry Pi 上的引脚，允许它感知和控制周围的事物。
- en: '|  |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: GPIO pins
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: GPIO 引脚
- en: The Raspberry Pi 2 Model B and Raspberry Pi 1 Model B+ have 40 pins located
    on the edge of the board, arranged in 2 rows of 20 pins each (see [figure 6.2](#ch06fig02)).
    Most of the pins on a Pi are used for input and output, so they’re often referred
    to as the Pi’s GPIO pins.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi 2 Model B 和 Raspberry Pi 1 Model B+ 在电路板的边缘有 40 个引脚，排列成两行，每行 20
    个引脚（见[图 6.2](#ch06fig02)）。Pi 上的大多数引脚都用于输入和输出，因此它们通常被称为 Pi 的 GPIO 引脚。
- en: Figure 6.2\. The Raspberry Pi 2 Model B has a set of pins arranged along the
    edge and corner of the Pi board.
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.2\. Raspberry Pi 2 Model B 在 Pi 板的边缘和角落有一组引脚。
- en: '![](06fig02_alt.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig02_alt.jpg)'
- en: '|  |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Warning
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: This project is written for Raspberry Pi 2 Model B. Earlier models of the Raspberry
    Pi have only 26 pins. See [appendix B](kindle_split_020.html#app02) for information
    about the differences from the more modern Pi boards. To complete this project
    with a Raspberry Pi 1 Model B, you may select different pins to light up your
    LEDs.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目是为 Raspberry Pi 2 Model B 编写的。较早的 Raspberry Pi 模型只有 26 个引脚。有关与较现代 Pi 板的差异信息，请参阅[附录
    B](kindle_split_020.html#app02)。要使用 Raspberry Pi 1 Model B 完成此项目，你可能需要选择不同的引脚来点亮你的
    LED。
- en: '|  |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Because all the pins look identical, you need a key or diagram to tell you what
    each one does. [Figure 6.3](#ch06fig03) shows the pins labeled.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有引脚看起来都相同，你需要一个钥匙或图表来告诉你每个引脚的作用。[图 6.3](#ch06fig03) 显示了标记的引脚。
- en: 'Figure 6.3\. The Raspberry Pi B+ has 40 pins. They do different things: some
    provide 5 volts or 3.3 volts, some are ground pins (0 volts), and many of them
    are input and output pins that you can program.'
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.3\. Raspberry Pi B+ 有 40 个引脚。它们执行不同的功能：一些提供 5 伏或 3.3 伏，一些是地线引脚（0 伏），而许多是输入和输出引脚，你可以编程。
- en: '![](06fig03_alt.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig03_alt.jpg)'
- en: '|  |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Physical pins vs. GPIO pin numbers**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**物理引脚与 GPIO 引脚编号**'
- en: In this book, we’ll always refer to the GPIO pin numbers, *not* the physical
    pin locations. The physical pins are numbered from 1 to 40 (shown in the circles
    in [figure 6.3](#ch06fig03)). The GPIO pin numbers go from 1 to 26, and those
    numbers don’t match the physical pin numbers. For example, GPIO 24 corresponds
    to physical pin 18\. By always using the GPIO numbering, it will be easier to
    wire your circuits and create programs.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们始终会提到 GPIO 引脚编号，*而不是* 物理引脚位置。物理引脚从 1 到 40 编号（如[图 6.3](#ch06fig03) 中的圆圈所示）。GPIO
    引脚编号从 1 到 26，这些编号与物理引脚编号不匹配。例如，GPIO 24 对应于物理引脚 18。始终使用 GPIO 编号，这将使你布线电路和创建程序更容易。
- en: '|  |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Wow, that’s a lot of pins! Some pins are for power and are labeled either 3V3
    or 5V. These produce 3.3 volts or 5 volts, respectively. There are also 8 ground
    pins and 26 GPIO pins^([[1](#ch06fn01)])—26 pins, just like there are 26 letters
    in the alphabet.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，引脚真多！一些引脚用于供电，标有 3V3 或 5V。它们分别产生 3.3 伏或 5 伏。还有 8 个接地引脚和 26 个 GPIO 引脚^([[1](#ch06fn01)])——26
    个引脚，就像字母表中26个字母一样。
- en: ¹
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Oddly, you’ll notice that the GPIO pins are numbered from 2 to 27\. Pins 0 and
    1 are used for communicating with other computer chips using a super-special protocol
    called I2C. These are labeled ID SDA and ID SCL in [figure 6.3](#ch06fig03).
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 奇怪的是，你会发现 GPIO 引脚从 2 号到 27 号编号。0 号和 1 号引脚用于通过一个称为 I2C 的超级特殊协议与其他计算机芯片通信。这些在[图
    6.3](#ch06fig03)中标有 ID SDA 和 ID SCL。
- en: The GPIO pins support sending out electrical signals (output) or listening for
    electrical signals from sensors (input). In your body, your brain can send signals
    to your hand to smack yourself on the forehead (try it!)—this is just like the
    output from a Pi. Signals are sent out of your Pi to make something happen in
    the world.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO 引脚支持发送电信号（输出）或监听来自传感器的电信号（输入）。在你的身体里，你的大脑可以向你的手发送信号，让你拍打自己的额头（试试看！）——这就像
    Pi 的输出一样。信号从 Pi 发出，以在世界上产生某种效果。
- en: The opposite of output is input. When someone pokes you, your body can detect
    that poke using nerves in your body. An electrical signal (input) is sent to your
    brain so you know you’ve been poked. This is like the way your Pi can be used
    to detect input or actions in the world.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的对立面是输入。当有人戳你时，你的身体可以通过体内的神经检测到这个戳。一个电信号（输入）被发送到你的大脑，让你知道你被戳了。这就像你的 Pi 可以用来检测世界中的输入或动作一样。
- en: You’ll learn how to output signals in this chapter and [chapter 7](kindle_split_017.html#ch07).
    [Chapter 8](kindle_split_018.html#ch08) will cover detecting input from the world,
    such as detecting when a button has been pressed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本章和[第 7 章](kindle_split_017.html#ch07)中学习如何输出信号。[第 8 章](kindle_split_018.html#ch08)将涵盖检测来自世界的外部输入，例如检测按钮是否被按下。
- en: 'Let’s get ready to connect some wires! But wait: connecting an LED directly
    to the GPIO pins on the board of your Raspberry Pi isn’t feasible, because the
    pins are so close together. What can you do? You need more space to build circuits.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们准备好连接一些电线！但是等等：直接将 LED 连接到 Raspberry Pi 板上的 GPIO 引脚是不可行的，因为引脚之间的距离太近了。你能做什么呢？你需要更多的空间来构建电路。
- en: Breaking out the GPIO pins to a breadboard
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将 GPIO 引脚扩展到面包板
- en: To give you room, you’ll move the GPIO pins over to a breadboard. This is called
    *breaking them out*. To do this, you need a ribbon cable, breakout board, and
    solderless breadboard (see [figure 6.4](#ch06fig04)).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给你留出空间，你需要将 GPIO 引脚移动到面包板上。这被称为*引脚扩展*。为此，你需要一根扁平电缆、扩展板和无焊面包板（见[图 6.4](#ch06fig04)）。
- en: Figure 6.4\. To easily create projects using your Pi’s GPIO pins, you can connect
    the Pi to a breadboard using a ribbon cable and breakout board. The parts shown
    are examples of the ones commonly found in many Raspberry Pi kits.
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.4\. 为了轻松使用 Pi 的 GPIO 引脚创建项目，你可以使用扁平电缆和扩展板将 Pi 连接到面包板。图中所示的部分是许多 Raspberry
    Pi 套件中常见的部件示例。
- en: '![](06fig04_alt.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![06fig04_alt.jpg](06fig04_alt.jpg)'
- en: Breadboards make it simple to prototype circuits. Like a park might provide
    large, open fields that make it easy to play sports, think of a breadboard as
    a nice, open electrical playing field where you can play with electrical parts.
    The breadboard allows you to plug wires and components into small holes. You can
    build and rebuild circuits on a breadboard with little effort.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 面包板使电路原型设计变得简单。就像公园可能提供宽敞的开放场地，使运动变得容易一样，把面包板想象成一个宽敞的电气运动场，你可以在这里玩电气部件。面包板允许你将电线和组件插入小孔。你可以在面包板上轻松构建和重建电路。
- en: Find your breakout board, and insert it into the top of the breadboard. Line
    up the pins before you push it down *hard* (see [figure 6.5](#ch06fig05)). Your
    particular breakout board may look a little different, but they all act the same.
    With the breakout board in place, it’ll be easier to build circuits with your
    GPIO pins.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 找到你的扩展板，并将其插入面包板的顶部。在按下*硬*之前对齐引脚（见[图 6.5](#ch06fig05)）。你的扩展板可能看起来略有不同，但它们的作用都是一样的。有了扩展板，使用
    GPIO 引脚构建电路会更容易。
- en: Figure 6.5\. Carefully line up the breakout board, and then press it firmly
    into the breadboard. The two rows of pins on the breakout board should straddle
    the center gap.
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.5\. 小心地对齐扩展板，然后将其牢固地压入面包板中。扩展板上的两排引脚应该跨越中心间隙。
- en: '![](06fig05_alt.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![06fig05_alt.jpg](06fig05_alt.jpg)'
- en: Connect one end of the ribbon cable to the Pi’s GPIO pins; line it up carefully
    before you push it down. Then connect the other end of the cable to the breakout
    board on your breadboard (see [figure 6.6](#ch06fig06)). A breakout board has
    a notch in it so the ribbon cable will only fit one way.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将带状电缆的一端连接到Pi的GPIO引脚；在按下之前仔细对齐。然后将电缆的另一端连接到面包板上的扩展板（见[图6.6](#ch06fig06)）。扩展板有一个缺口，这样带状电缆就只能以一个方向插入。
- en: Figure 6.6\. Connect one end of the ribbon cable to the breakout board. Connect
    the other end to your Raspberry Pi.
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.6\. 将带状电缆的一端连接到扩展板。将另一端连接到你的Raspberry Pi。
- en: '![](06fig06_alt.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig06_alt.jpg)'
- en: '|  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Ribbon cables usually have a stripe that marks the first wire. White or grey
    ribbon cables often use a red stripe. Black ribbon cables often have a white stripe.
    These mark the first wire on the cable. Make sure this first wire is connected
    toward the edge of your Pi’s board and away from the USB ports.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 带状电缆通常有一条标记第一条线的条纹。白色或灰色带状电缆通常使用红色条纹。黑色带状电缆通常有白色条纹。这些标记了电缆上的第一条线。确保这条第一条线连接到你的Pi板的边缘，远离USB端口。
- en: '|  |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Breadboard basics
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 面包板基础知识
- en: A breadboard^([[2](#ch06fn02)]) has a set of internal connections that you can’t
    see. But if you had X-ray vision, you’d see that certain holes are connected.
    Let’s look at the connections in your breadboard (see [figure 6.7](#ch06fig07)).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 面包板^([[2](#ch06fn02)])有一组内部连接，你无法看到。但如果你有X光视力，你会看到某些孔是相连的。让我们看看你的面包板上的连接（见[图6.7](#ch06fig07)）。
- en: ²
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Prior to the development of the kind of breadboards we’re using, people built
    circuits on pieces of wood that were used to cut bread on (hence the name). They
    needed a quick way to connect circuits, and by drilling holes and using nails
    and wires, they could use bread boards to try different circuits.
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在我们使用的面包板开发之前，人们会在用来切面包的木板上搭建电路（因此得名）。他们需要一个快速连接电路的方法，通过钻孔和使用钉子和电线，他们可以使用面包板尝试不同的电路。
- en: Figure 6.7\. Breadboards have internal connections. You need to know about them
    in order to build circuits. Rows of pins are connected horizontally, but not across
    the gap in the middle. Long rails called *power buses* run vertically along the
    sides of the board.
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.7\. 面包板有内部连接。你需要了解它们才能搭建电路。引脚行是水平相连的，但不是跨越中间的缝隙。称为*电源总线*的长轨垂直沿着板的两侧运行。
- en: '![](06fig07_alt.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig07_alt.jpg)'
- en: On this breadboard, rows are labeled with numbers (1–30), and the columns have
    letters (a–e on the left side and f–j on the right side). You can refer to a specific
    hole in the breadboard by saying its row number and letter. For example, if you
    wanted to refer to the hole located in row 25, column c, you could say 25c (see
    [figure 6.8](#ch06fig08)). Just as you might find your seat at a stadium by walking
    along the aisle to find the correct row, and then moving along the row to find
    the right seat, you’ll use the letters and numbers to guide you in building your
    circuits.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个面包板上，行用数字标记（1–30），列用字母标记（左侧为a–e，右侧为f–j）。你可以通过说出面包板上的特定孔的行号和字母来引用它。例如，如果你想引用位于第25行，c列的孔，你可以说25c（见[图6.8](#ch06fig08)）。就像你可能会通过走通道找到体育场中的座位，然后沿着行移动以找到正确的座位一样，你将使用字母和数字来指导你搭建电路。
- en: Figure 6.8\. To find a specific hole on a breadboard, use the row and column
    labels. This is a close-up of a breadboard, showing how you can find the location
    of hole 25c (we’ll refer to the hole as BB25c, where *BB* stands for *breadboard*).
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.8\. 要在面包板上找到特定的孔，请使用行和列标签。这是一张面包板的特写，显示了如何找到孔25c的位置（我们将把这个孔称为BB25c，其中*BB*代表*面包板*）。
- en: '![](06fig08_alt.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig08_alt.jpg)'
- en: Breadboard (BB) holes
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 面板孔（BB孔）
- en: We’ll refer to the row and column, but we’ll prepend the letters *BB* so you
    know it’s the breadboard location we’re talking about. [Figure 6.8](#ch06fig08)
    shows the location of BB25c. If we’re talking about a GPIO pin or connection,
    we’ll add *GP* before the number (GPIO pin 21 is GP21).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提到行和列，但我们会预先加上字母*BB*，这样你知道我们谈论的是面包板的位置。[图6.8](#ch06fig08)显示了BB25c的位置。如果我们谈论GPIO引脚或连接，我们将在数字前加上*GP*（GPIO引脚21是GP21）。
- en: Try to keep in mind what is connected in a breadboard and what isn’t. If you
    forget, you can always look back at [figure 6.7](#ch06fig07). For example, notice
    that BB25 a, b, c, d, and e are all connected. Similarly, BB30 f, g, h, i, and
    j are connected. But the left side of the board isn’t connected to the right.
    For example, BB25e isn’t connected to BB25f. To connect them, you’d put a jumper
    from BB25e to BB25f.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试记住面包板上哪些部分是连接的，哪些部分没有连接。如果你忘记了，你总是可以回顾一下[图6.7](#ch06fig07)。例如，注意BB25的a、b、c、d和e都是连接的。同样，BB30的f、g、h、i和j也是连接的。但是，板的左侧并没有连接到右侧。例如，BB25e并没有连接到BB25f。要连接它们，你需要在BB25e和BB25f之间放置一个跳线。
- en: You can see vertical columns of holes along the sides of the breadboard. These
    are the *power buses* and provide easy ways to connect electrical components to
    power (positive) and ground (negative).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在面包板的侧面看到垂直排列的孔。这些是*电源总线*，提供了将电气元件连接到电源（正极）和地（负极）的简便方法。
- en: '|  |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Circuits 101**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**电路101**'
- en: Let’s learn about electricity and circuits. At the simplest level, a *circuit*
    is a loop or path where the electrical power starts at a source (the positive
    side of a power source), goes through one or more electrical components (such
    as a light or motor), and then completes the loop (or path) by connecting back
    to the negative side of the source.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习关于电和电路的知识。在最简单的层面上，一个*电路*是一个回路或路径，其中电能从电源（电源的正极）开始，通过一个或多个电气元件（如灯或电机），然后通过连接回电源的负极来完成回路（或路径）。
- en: '**WHAT IS ELECTRICITY?**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是电？**'
- en: '*Electricity* is the flow of charge. Typically, it is the flow of electrons,
    which have a negative charge. To get electrons to flow, you need to have a difference
    in charges. Just as the north pole of a magnet is attracted to its opposite—the
    south pole of another magnet—positive and negative electric charges are attracted
    to one another. If the charge is free to move, it will move. We generally think
    of circuits as having electricity flowing from the positive (+) side of the source
    to the negative (-) side of the source. For your Pi, the power is coming from
    the power supply (Micro USB plug). The Pi as a power source can provide either
    +3.3 volts or +5 V (volts). It provides this power through the physical pins 1,
    2, and 4, but can also send +3.3 V out any of the 26 GPIO pins (you’ll program
    it to do that soon).'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*电*是电荷的流动。通常，它是电子的流动，电子带有负电荷。要使电子流动，你需要有电荷差异。就像磁铁的北极会被另一个磁铁的南极吸引一样——正负电荷也会相互吸引。如果电荷可以自由移动，它就会移动。我们通常认为电路中的电是从电源的正极（+）流向电源的负极（-）。对于你的Pi来说，电源来自电源适配器（Micro
    USB插头）。Pi作为电源可以提供+3.3伏或+5 V（伏特）。它通过物理引脚1、2和4提供这种电源，但也可以通过任何26个GPIO引脚发送+3.3 V（你很快就会编程使其这样做）。'
- en: '**VOLTAGE (VOLTS)**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**电压（伏特）**'
- en: '*Voltage* is a measure of the difference in electrical charge between the positive
    and negative source. When you have two different charges, they’re attracted to
    one another (positive and negative attract). The greater the difference in charge,
    the greater the force (or electrical pressure) wanting to move charges through
    the circuit from the positive side to the negative side.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*电压*是正负电源之间电电荷差异的度量。当你有两个不同的电荷时，它们会相互吸引（正负相吸）。电荷差异越大，推动电荷通过电路从正极到负极的力（或电压力）就越大。'
- en: Voltage is measured in volts (V), named after Alessandro Volta, who is credited
    with inventing the first battery. A 9 volt (or 9 V) battery has a greater electric
    force for moving charge than a AA battery, which only has a voltage of 1.5 V.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 电压以伏特（V）为单位测量，这个名字是为了纪念亚历山德罗·伏打，他被认为是第一个电池的发明者。9伏（或9 V）的电池比AA电池具有更大的推动电荷的电场，AA电池的电压仅为1.5
    V。
- en: '**CURRENT (AMPERES)**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**电流（安培）**'
- en: The *current* in a circuit is the amount of charge flowing. So whereas voltage
    is a measure of how badly charges *want* to flow, the current is a measure of
    how much charge is *actually* flowing.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 电路中的*电流*是流动的电荷量。所以，虽然电压是衡量电荷*想要*流动的程度，但电流是衡量实际流动电荷量的程度。
- en: Imagine that you could be inside a wire and see the charge flowing through it.
    A large current would mean a lot of charge (usually electrons) bumping along and
    through the wire over some period of time. A small current in that same wire would
    mean a lot less charge flowing over that same time period. Current is measured
    in amperes (A), named after André-Marie Ampère. A current of 1 ampere (or 1 A)
    is equivalent to the amount of charge of 6.241 × 10^(18) electrons flowing through
    a wire per second! That is a lot of charge flowing. You can decrease the current
    in a circuit by increasing the resistance of the circuit to the flow of electric
    charge.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你可以在导线内部，并看到电荷通过它流动。大电流意味着在一段时间内有大量的电荷（通常是电子）沿着导线碰撞并通过。在相同导线中的小电流意味着在相同时间内流动的电荷要少得多。电流以安培（A）为单位测量，以安德烈-玛丽·安培的名字命名。1安培（或1A）的电流相当于每秒通过导线的6.241
    × 10^(18)个电子的电荷量！这是大量的电荷流动。你可以通过增加电路对电荷流动的电阻来减少电路中的电流。
- en: '**RESISTANCE (OHMS)**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**电阻（欧姆）**'
- en: The *resistance* in a circuit is a measure of how much it opposes the flow of
    charge (current). A light bulb, a motor, and your body all have resistance. The
    opposite of resistance is *conductance*. Substances such as metal (copper, silver,
    and gold) are all good conductors, and this is why we build circuits with metal
    wires for the electricity to flow through.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 电路中的*电阻*是衡量它反对电荷流动（电流）的程度。灯泡、电机和你的身体都有电阻。电阻的相反是*电导*。金属（铜、银和金）等物质都是良好的导体，这就是为什么我们用金属线构建电路，让电流通过。
- en: Sometimes you need to control the current (the flow of charge). Resistors are
    used to do this; they’re made of materials that slow down the flow of charge.
    The most common ones are made out of carbon (you’ll be using these in your projects).
    The resistance of a circuit is measured in ohms, named after Georg Ohm, and is
    represented using the Greek symbol omega (Ω).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你需要控制电流（电荷的流动）。电阻用于此目的；它们由减缓电荷流动的材料制成。最常见的是由碳制成（你将在你的项目中使用这些）。电路的电阻以欧姆为单位测量，以乔治·欧姆的名字命名，并使用希腊符号omega（Ω）表示。
- en: '**PI CIRCUITS**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**PI电路**'
- en: You can think of your Pi as providing 3.3 V from the positive side of the Pi
    or, later, coming out of one of the GPIO pins. This +3.3 V is a force that is
    trying to push electric charge to the negative (-) side of your source. The negative
    side is sometimes called the *ground*—think of it as a big sink or reservoir to
    which electricity wants to flow if there is a path to get there. During the next
    few chapters, you’ll build circuits with LEDs and resistors. You use a resistor
    with an LED to decrease the flow of electric charge (the current) so it won’t
    be too large and burn out your LED. Burning an LED smells bad!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将树莓派视为从Pi的正极提供3.3V，或者稍后从GPIO引脚之一输出。这个+3.3V是一种试图将电荷推向源负极（-）的力。负极有时被称为*地*——想象它是一个大型的汇流排或水库，如果有一条路径到达那里，电流就会流向那里。在接下来的几章中，你将使用LED和电阻搭建电路。你使用电阻与LED一起减少电荷流动（电流），以防止电流过大烧毁LED。烧毁LED会发出难闻的气味！
- en: '|  |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: On your breadboard, think of all the GPIO pins as potential sources of voltage
    (positive). Circuits from the GPIO pins should end back at any one of the many
    ground (negative) connections.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的面包板上，将所有GPIO引脚都视为电压（正）的潜在来源。从GPIO引脚发出的电路应返回到任何一个多个地（负）连接中。
- en: Building the LED circuit
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搭建LED电路
- en: 'Your first project is to light up a red LED. You’ll control the LED using GPIO
    pin 21 (GPIO21). You need these parts:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你的第一个项目是点亮一个红色LED。你将使用GPIO引脚21（GPIO21）来控制LED。你需要以下这些部件：
- en: Raspberry Pi, ribbon cable, and breakout board connected to your breadboard
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树莓派、扁平电缆和连接到面包板上的扩展板
- en: 1 red LED (5 mm)
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个红色LED（5mm）
- en: 1 180 ohm resistor
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个180欧姆电阻
- en: 1 jumper wire (male-to-male)
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1根跳线（公对公）
- en: You’ll build the LED circuit on your breadboard and then program it to light
    up. [Figure 6.9](#ch06fig09) shows the circuit diagram. To light the LED, you’ll
    have electricity (+3.3 V) flow from your Pi’s GPIO pin 21 through the LED, through
    the resistor, and then to ground (0 V).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在面包板上搭建LED电路，然后编程使其点亮。[图6.9](#ch06fig09)显示了电路图。要点亮LED，你需要从树莓派的GPIO引脚21通过LED、通过电阻，然后到地（0V）流动电。
- en: Figure 6.9\. Circuit diagram for the blinking LED project
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.9\. 点亮LED项目的电路图
- en: '![](06fig09_alt.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig09_alt.jpg)'
- en: '[Figure 6.10](#ch06fig10) shows the LED circuit built on the breadboard. Note
    that there are many different ways to create this circuit—this is just one way.
    Let’s walk through the steps to build the circuit.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6.10](#ch06fig10)显示了在面包板上构建的LED电路。请注意，有多种不同的方法可以创建这个电路——这只是其中一种。让我们一步步来构建电路。'
- en: Figure 6.10\. LED circuit built on the breadboard. You’re using GPIO pin 21
    as the power source. The light won’t turn on until you program the voltage to
    come out of the pin.
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.10。在面包板上构建的LED电路。你正在使用GPIO引脚21作为电源。直到你编程使电压从引脚输出，灯不会亮。
- en: '![](06fig10_alt.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig10_alt.jpg)'
- en: '|  |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You may have a different breadboard than the one used in this book. If so, the
    numbering on your breadboard may be different than what is shown here. In that
    case, you’ll need to create the circuit following the same principles, but with
    different numbered holes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能使用的面包板与本书中使用的不同。如果是这样，你的面包板上的编号可能与这里显示的不同。在这种情况下，你需要根据相同的原则创建电路，但使用不同的编号孔。
- en: '|  |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Step 1\. Connect the jumper from GPIO pin 21
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第1步：连接GPIO引脚21的跳线
- en: Raspberry Pi GPIO pins can output 3.3 V. You could pick any pin, but this project
    uses GPIO pin 21.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派GPIO引脚可以输出3.3V。你可以选择任何引脚，但本项目使用GPIO引脚21。
- en: Connect a short piece of wire from GPIO21 on your breadboard to an empty row
    on the breadboard. Use row 25\. Firmly push the wire into the hole. The metal
    tip of the wire should go down into the hole, not sit on top.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 将你面包板上的GPIO21引脚连接到面包板上的一个空行。使用第25行。将电线牢固地推入孔中。电线的金属尖端应进入孔中，而不是放在上面。
- en: The breakout board pins are connected to rows on the breadboard. We’ll refer
    to the holes on the breadboard (see [figure 6.11](#ch06fig11)). Insert one end
    of the jumper into BB20i and the other end into BB25a.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 开关板引脚连接到面包板上的行。我们将参考面包板上的孔（见[图6.11](#ch06fig11)）。将跳线的一端插入BB20i，另一端插入BB25a。
- en: Figure 6.11\. The breakout board has labels that correspond to the pins on your
    Pi. To connect a wire to GP16, you plug it into the breadboard in the hole labelled
    BB18f or BB18j.
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.11。开关板有标签，与你的Pi引脚相对应。要将电线连接到GP16，将其插入标记为BB18f或BB18j的面包板孔中。
- en: '![](06fig11_alt.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig11_alt.jpg)'
- en: Step 2\. Add the red LED
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第2步：添加红色LED
- en: It’s time to connect the red LED. LEDs only let electricity flow through them
    one way, so it’s important to put them in the right way. LEDs have two wires or
    *legs*. The longer leg is called the *anode* and connects to the positive side
    of the circuit (see [figure 6.12](#ch06fig12)). The shorter leg, called the *cathode*,
    connects to the negative or ground side of the circuit.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候连接红色LED了。LED只允许电流单向通过，所以正确放置它们很重要。LED有两个电线或*腿*。较长的腿称为*阳极*，连接到电路的正极（见[图6.12](#ch06fig12)）。较短的腿，称为*阴极*，连接到电路的负极或地线。
- en: Figure 6.12\. LEDs have two legs (wires) coming out of them. The longer leg
    is called the anode and connects to the positive side of the circuit. The shorter
    one is called the cathode and connects to the negative side of a circuit.
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.12。LED有两个腿（电线）从它们中出来。较长的腿称为阳极，连接到电路的正极。较短的腿称为阴极，连接到电路的负极。
- en: '![](06fig12.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig12.jpg)'
- en: With the red LED, connect the longer leg to BB25e and the shorter leg to BB25f.
    You may need to bend the legs and push them a bit to get them into the holes.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用红色LED，将较长的腿连接到BB25e，将较短的腿连接到BB25f。你可能需要弯曲腿并稍微推一下，才能将它们插入孔中。
- en: Step 3\. Connect a resistor
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第3步：连接电阻
- en: Grab your 180 ohm resistor.^([[3](#ch06fn03)]) You can identify a resistor by
    its color-coded bands. A 180 ohm resistor has colored bands of brown, grey, and
    brown (see [figure 6.13](#ch06fig13)). They are followed by a fourth band that
    indicates the tolerance or quality of the resistor. Common colors for the fourth
    band are gold (±5% tolerance) and silver (±10% tolerance).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 拿起你的180欧姆电阻.^([[3](#ch06fn03)]) 你可以通过其颜色编码的带子来识别电阻。180欧姆的电阻有棕色、灰色和棕色的颜色带（见[图6.13](#ch06fig13)）。它们后面跟着一个第四个带子，表示电阻的公差或质量。第四个带子的常见颜色是金色（±5%公差）和银色（±10%公差）。
- en: ³
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you don’t have a 180 ohm resistor, you can use a resistor with a value between
    100 and 330 ohms. If you use a resistor with a value that is too large, the LED
    may not light up or will be dim. Try experimenting with different resistors to
    adjust the brightness.
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你没有180欧姆的电阻，你可以使用100到330欧姆之间的电阻。如果你使用值太大的电阻，LED可能不会亮起或会很暗。尝试使用不同的电阻来调整亮度。
- en: Figure 6.13\. The value of a resistor is determined by its colored bands. See
    the sidebar “[Resistor color codes](#ch06sb03)” for a chart; there are also many
    online color-code charts.
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.13\. 电阻的值由其彩色带决定。参见侧边栏“[电阻颜色代码](#ch06sb03)”中的图表；还有许多在线颜色代码图表。
- en: '![](06fig13.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig13.jpg)'
- en: The resistor prevents too much electric current^([[4](#ch06fn04)]) from passing
    through your LED and burning it out. Insert one end of the 180 ohm resistor into
    BB25j and the other end into the negative (-) power bus (or ground).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 电阻阻止过多的电流通过您的 LED，从而避免烧毁它。将 180 欧姆电阻的一端插入 BB25j，另一端插入负极（-）电源总线（或地）。
- en: ⁴
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Current is a measure of the flow of electric charges per second. If the current
    through an LED is too high, the LED will burn out.
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 电流是每秒电荷流动的量度。如果通过 LED 的电流过高，LED 将会烧毁。
- en: '*Electricity will flow either way through a resistor, so which way you connect
    it doesn’t matter*. Remember that the negative power bus or ground rail is running
    vertically along the right side of the breadboard. Most boards have a blue stripe
    next to it.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*电流将通过电阻双向流动，所以您连接的方向无关紧要*。记住，负电源总线或地线在面包板的右侧垂直运行。大多数板在其旁边都有一个蓝色条纹。'
- en: '|  |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Resistor color codes**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**电阻颜色代码**'
- en: Resistors have color codes that tell their value and tolerance. This chart shows
    you how to read the resistor color bands.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 电阻有颜色代码，可以告诉它们的值和公差。此图表显示了如何读取电阻颜色带。
- en: '![](165fig01.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](165fig01.jpg)'
- en: 'For example, consider a resistor with red, purple, red, and silver bands. Follow
    these steps to use the chart:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个带有红色、紫色、红色和银色带的电阻。按照以下步骤使用图表：
- en: 'Look up the digit for the first band and the digit for the second band, and
    put them together. In this case, the digits are 2 and 7: put them together, and
    you get 27\. Note that you don’t add the numbers; you treat them as the first
    and second digits of the resistor value.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找第一条带和第二条带的数字，并将它们组合起来。在这种情况下，数字是 2 和 7：将它们组合起来，得到 27。请注意，您不需要将数字相加；您将它们视为电阻值的第一个和第二个数字。
- en: Find the multiplier by looking up the color for the third band. In this case,
    it’s 100 ohms (red).
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过查找第三条带的颜色来找到乘数。在这种情况下，它是 100 欧姆（红色）。
- en: 'Put it all together: 27 × 100 ohms is 2,700 ohms or 2.7K ohms (K = 1,000).'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将它们全部组合起来：27 × 100 欧姆等于 2,700 欧姆或 2.7K 欧姆（K = 1,000）。
- en: The fourth band (silver) tells you the resistor has a tolerance of ±10%.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四条带（银色）表示电阻的公差为 ±10%。
- en: A red, purple, red, and silver resistor is a 2.7K ohm resistor with a ±10% tolerance.
    Use this handy chart any time you need to look up the value of a resistor.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一个红色、紫色、红色和银色的电阻是一个公差为 ±10% 的 2.7K 欧姆电阻。在需要查找电阻值时，随时使用这个方便的图表。
- en: '|  |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: That’s it! You have a completed LED circuit built on your breadboard. Now it’s
    time to program it!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！您已经在面包板上构建了一个完成的 LED 电路。现在，是时候编程它了！
- en: 'Software: blinkLED program'
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 软件：blinkLED 程序
- en: 'Open IDLE by choosing Python 3 under Menu > Programming. This opens IDLE to
    the Python 3.x Shell. In the Python Shell, let’s check to see if your Pi has the
    GPIO libraries you need already installed:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在菜单 > 编程下选择 Python 3 来打开 IDLE。这将在 Python 3.x Shell 中打开 IDLE。在 Python Shell
    中，让我们检查您的 Pi 是否已经安装了所需的 GPIO 库：
- en: '[PRE0]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you don’t see an error, you’re ready to go. If you see an error saying there
    is no module named `RPi.GPIO`, please refer to the sidebar “[Updating your Pi](#ch06sb04).”
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有看到错误，您就可以开始了。如果您看到错误消息说没有名为 `RPi.GPIO` 的模块，请参阅侧边栏“[更新您的 Pi](#ch06sb04)”。
- en: '|  |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Updating your Pi**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**更新您的 Pi**'
- en: Before programming, you need to check that your Pi is up to date. Make sure
    your Pi is connected to the internet. Open the Terminal program by going to Menu
    --> Accessories --> Terminal, and run the following commands to update your Raspberry
    Pi and be certain you have the Raspberry Pi GPIO packages you need.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程之前，您需要检查您的 Pi 是否已更新。确保您的 Pi 已连接到互联网。通过转到菜单 --> 附件 --> 终端来打开终端程序，并运行以下命令以更新
    Raspberry Pi 并确保您有所需的 Raspberry Pi GPIO 软件包。
- en: 'First, let’s update the `apt-get` database. The `apt-get` program handles installing
    and removing software from your Pi. In Terminal, enter this command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们更新 `apt-get` 数据库。`apt-get` 程序负责在您的 Pi 上安装和删除软件。在终端中输入以下命令：
- en: '[PRE1]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You’ll need to wait while a bunch of files are downloaded and installed. You’ll
    see lots of messages displayed in Terminal. When the command completes, you’ll
    see the Terminal `$` prompt again. Next, to get the latest Pi software, enter
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要等待一段时间，以便下载和安装一些文件。您将在终端中看到许多消息。当命令完成时，您将再次看到终端的`$`提示符。接下来，要获取最新的Pi软件，请输入
- en: '[PRE2]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once again, files will be downloaded and installed. After a series of messages,
    you’ll see a warning about the upgrade using additional disk space, and this prompt:
    “Do you want to continue [Y/n]?” Enter `Y` and press Enter to continue the upgrade.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，将下载并安装文件。在一系列消息之后，您将看到有关使用额外磁盘空间升级的警告，以及以下提示：“您想继续吗 [Y/n]？”输入`Y`并按Enter键继续升级。
- en: This is a great time to grab a sandwich and soda. It can take 15 minutes or
    more for the update to complete. When it’s finished, you’ll have the latest Raspberry
    Pi software and Python libraries, including the ones you need to communicate with
    and control the GPIO pins.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是抓一个三明治和汽水的好时机。更新可能需要15分钟或更长时间才能完成。完成之后，您将拥有最新的树莓派软件和Python库，包括您需要用于与GPIO引脚通信和控制所需的库。
- en: '|  |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You’re going to write a program that blinks an LED. It’ll send a voltage (+3.3
    V) out of a GPIO pin to light the LED, then turn it off, and repeat that over
    and over. Begin by creating the following new program in IDLE. In the Python Shell,
    start a new program by pressing Ctrl-N or selecting File > New Window.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您将要编写一个闪烁LED的程序。它将从GPIO引脚发送电压（+3.3 V）来点亮LED，然后关闭它，并重复此操作。首先，在IDLE中创建以下新程序。在Python
    Shell中，通过按Ctrl-N或选择文件 > 新窗口来启动新程序。
- en: Listing 6.1\. Blinking LED program
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.1\. 闪烁LED程序
- en: '![](167fig01_alt.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](167fig01_alt.jpg)'
- en: Save the program as blinkLED.py in your home folder. The program can’t be run
    the same ways you’ve run programs before using IDLE.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 将程序保存为blinkLED.py到您的家目录中。程序不能以您之前使用IDLE运行程序的方式运行。
- en: Running the program
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行程序
- en: 'Select Run > Run Module (or press F5) from the IDLE text editor to run your
    program. With older versions of Raspbian, programs using GPIO pins must be run
    from the Raspbian command prompt as the superuser (or root)^([[5](#ch06fn05)]).
    If you run the program at the Python Shell in IDLE, you’ll get an error:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 从IDLE文本编辑器中选择运行 > 运行模块（或按F5）来运行您的程序。在较旧的Raspbian版本中，使用GPIO引脚的程序必须以超级用户（或root）的身份从Raspbian命令提示符运行^([[5](#ch06fn05)]）。如果您在IDLE的Python
    Shell中运行程序，您将得到一个错误：
- en: ⁵
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵
- en: ''
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In October 2015, the Raspberry Pi Foundation released Raspbian version “Jessie,”
    which allows you to run programs using the GPIO pins directly from IDLE. With
    “Jessie” you don’t need to open the command prompt. Simply press F5 or select
    Run > Run Module from the IDLE text editor menu to run your programs.
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在2015年10月，树莓派基金会发布了Raspbian版本“Jessie”，允许您直接从IDLE使用GPIO引脚运行程序。使用“Jessie”，您不需要打开命令提示符。只需按F5或在IDLE文本编辑器菜单中选择运行
    > 运行模块即可运行您的程序。
- en: '[PRE3]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this case, you use the `sudo` command to do this. To run the blinkLED.py
    program, open LXTerminal and enter the following command:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您使用`sudo`命令来完成此操作。要运行blinkLED.py程序，打开LXTerminal并输入以下命令：
- en: '[PRE4]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Behold the blinking LED! Try making the light blink faster by adjusting the
    value in the `sleep` function. Use a smaller number of seconds, such as 0.5 or
    0.1.^([[6](#ch06fn06)]) To stop the program, press Ctrl-C.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 看看闪烁的LED灯！通过调整`sleep`函数中的值来尝试使灯光闪烁得更快。使用更小的秒数，例如0.5或0.1.^([[6](#ch06fn06)])
    要停止程序，请按Ctrl-C。
- en: ⁶
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶
- en: ''
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Too small a number may cause the light to appear to stay on, but more dimly.
    This is because your eyes can only perceive blinking that is greater than about
    1/25th of a second, or 0.04 of a second.
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 数字太小可能会导致灯光看起来一直亮着，但亮度较低。这是因为您的眼睛只能感知大于大约1/25秒的闪烁，或0.04秒。
- en: '|  |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Stopping the program with Ctrl-C may result in the light being left on (depending
    on when you press it). Also, the next time you run the program, you may see a
    runtime error, but the program still works. We don’t cover it here, but look online
    for the Python commands `try/except/finally` and the `GPIO.cleanup()` command.
    It’s a fancy way to make sure all the GPIO pins are reset when you exit the program.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ctrl-C停止程序可能会导致灯光保持开启状态（取决于您何时按下它）。此外，下次您运行程序时，您可能会看到运行时错误，但程序仍然可以工作。我们在这里不涉及它，但请在网上查找Python命令`try/except/finally`和`GPIO.cleanup()`命令。这是一种确保在退出程序时所有GPIO引脚都被重置的优雅方式。
- en: '|  |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Troubleshooting
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'If the light isn’t blinking, here are some things you can check:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果灯光没有闪烁，这里有一些您可以检查的事情：
- en: Are the on and off messages displaying on the screen? If so, it’s probably not
    your code that has a problem. Check the circuit on the breadboard. Make sure the
    ribbon cable is connected properly, with the first wire connected toward the edge
    of your Pi, away from the USB ports. Double-check that the jumper, LED, and resistor
    are connected to the correct holes.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏幕上是否显示了开和关的消息？如果是这样，可能不是你的代码有问题。检查面包板上的电路。确保扁平电缆连接正确，第一根线连接到Pi的边缘，远离USB端口。再次检查跳线、LED和电阻是否连接到正确的孔位。
- en: Could your LED be inserted the wrong way? Make sure the shorter leg is toward
    the negative or ground side. Try turning it around.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的LED是否插反了？确保较短的腿朝向负极或地线侧。试着把它转过来。
- en: Double-check the size of the resistor you used in the circuit. If the resistor
    is too large, the LED won’t light up. A resistor that is between 100 and 300 ohms
    should work.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仔细检查电路中使用的电阻值。如果电阻太大，LED灯将不会亮起。100到300欧姆之间的电阻应该可以工作。
- en: Look through your Python program for errors. Check that you have set `LED_pin_red`
    equal to 21 and that you’re setting it `HIGH` and then `LOW`.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的Python程序中查找错误。检查你是否已将`LED_pin_red`设置为21，并且你正在将其设置为`HIGH`然后设置为`LOW`。
- en: 'blinkLED: how it works'
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: blinkLED：它是如何工作的
- en: Let’s take a closer look at how the blinkLED.py code works.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看blinkLED.py代码是如何工作的。
- en: Loading libraries
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 加载库
- en: 'The `import` commands load the libraries or toolboxes you want to use in your
    program:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`命令加载了你在程序中想要使用的库或工具箱：'
- en: '[PRE5]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: These commands load the Python libraries for controlling the Pi’s GPIO pins.
    They also load the `time` library so you can use the `sleep` function to control
    the rate of blinking.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令加载了控制Pi GPIO引脚的Python库。它们还加载了`time`库，这样你就可以使用`sleep`函数来控制闪烁的速度。
- en: '|  |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Importing libraries with the as keyword**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用as关键字导入库**'
- en: Notice the `as` keyword in `import RPi.GPIO as GPIO`. Why can’t you just type
    `import RPi.GPIO`?
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`import RPi.GPIO as GPIO`中的`as`关键字。为什么不能直接输入`import RPi.GPIO`？
- en: The `as` keyword tells Python to load the library to a certain name you specify.
    It’s kind of like giving the whole library a nickname. In this case, it’s so you
    can refer to `RPi.GPIO` as simply `GPIO`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`as`关键字告诉Python将库加载到指定的某个名称下。这有点像给整个库起一个昵称。在这种情况下，是为了让你可以简单地用`GPIO`来引用`RPi.GPIO`。'
- en: An example will make it clearer. Once you’ve imported the `RPi.GPIO` library
    as `GPIO`, you can type `GPIO.setmode(GPIO.BCM)`. Without it, you would have to
    type `RPi.GPIO.setmode(RPi.GPIO.BCM)`. You can see how using `as GPIO` saves you
    some typing!
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子会使其更清晰。一旦你将`RPi.GPIO`库导入为`GPIO`，你可以输入`GPIO.setmode(GPIO.BCM)`。没有它，你将不得不输入`RPi.GPIO.setmode(RPi.GPIO.BCM)`。你可以看到使用`as
    GPIO`如何节省你一些输入时间！
- en: '|  |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Once the libraries are loaded, you can set up your GPIO pins.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦库加载完成，你就可以设置你的GPIO引脚。
- en: Setting up a GPIO pin for output
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设置GPIO引脚为输出
- en: 'To set up a GPIO pin, you first need to tell Python on your Pi that you’ll
    be referring to pins by the standard breakout numbering scheme. These are the
    numbers printed on the breakout board. You use the `setmode` function:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置GPIO引脚，你首先需要告诉Python Pi，你将按照标准断接器编号方案来引用引脚。这些是断接板上打印的数字。你使用`setmode`函数：
- en: '[PRE6]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'BCM stands for Broadcom—the maker of the computer chip that the Pi uses. Next
    you tell your Raspberry Pi that you’ll be using `LED_pin_red` (GP21) for output,
    meaning you’re planning to send some electricity out of it:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: BCM代表Broadcom——Pi使用的计算机芯片的制造商。接下来，你告诉你的Raspberry Pi，你将使用`LED_pin_red`（GP21）进行输出，这意味着你计划从它发送一些电流：
- en: '[PRE7]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`GPIO.OUT` prepares GP21 to send out +3.3 V of electricity.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`GPIO.OUT`将GP21准备好发送+3.3伏的电流。'
- en: Looping and blinking
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 循环和闪烁
- en: 'Finally, you create an infinite `while` loop and turn the LED on (set `GPIO.HIGH`)
    and off (set `GPIO.LOW`). You also add a delay using the `sleep` method found
    in Python’s `time` library. Notice how the `sleep` function takes a parameter
    that is the number of seconds to sleep or pause. In this case, you use 1 second:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你创建一个无限`while`循环，将LED打开（设置`GPIO.HIGH`）然后关闭（设置`GPIO.LOW`）。你还使用了Python的`time`库中的`sleep`方法来添加延迟。注意`sleep`函数接受一个参数，即休眠或暂停的秒数。在这种情况下，你使用1秒：
- en: '[PRE8]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `print` commands display messages to the screen. Although they aren’t necessary
    to blink the LED, they can help debug your program. If you do use them, the screen
    could quickly fill with messages. Set a longer delay time to prevent this. If
    you see the messages on the screen but your LED isn’t lighting up, then you probably
    have an error in your circuit and not in your program. Check your wiring, try
    turning around the LED, or try a different LED in case that one is defective.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`print`命令会在屏幕上显示消息。虽然它们对于使LED闪烁不是必需的，但可以帮助调试你的程序。如果你使用它们，屏幕可能会迅速充满消息。设置更长的延迟时间以防止这种情况。如果你在屏幕上看到消息，但LED没有点亮，那么你可能在电路中而不是在程序中存在错误。检查你的接线，尝试翻转LED，或者尝试使用不同的LED以检查是否损坏。'
- en: Adding more LEDs
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加更多LED
- en: 'One LED is fun, so three LEDs must be lots of fun. Let’s try adding green and
    blue LEDs and modify the program to control them. Here are the parts you need:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一个LED很有趣，所以三个LED肯定更有趣。让我们尝试添加绿色和蓝色LED，并修改程序来控制它们。以下是你需要的部分：
- en: Raspberry Pi and circuit from before
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之前的Raspberry Pi和电路
- en: 1 green LED
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个绿色LED
- en: 1 blue LED
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个蓝色LED
- en: 2 180 ohm resistors
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2个180欧姆电阻
- en: 2 jumper wires (male-to-male)
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2根公对公跳线
- en: Building the circuit
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建电路
- en: You’ll follow the same process as before to add the green and blue LEDs. [Figure
    6.14](#ch06fig14) shows what the circuit diagram looks like now, and [figure 6.15](#ch06fig15)
    shows the circuit on a breadboard.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你将遵循之前的过程来添加绿色和蓝色LED。[图6.14](#ch06fig14)显示了现在的电路图，[图6.15](#ch06fig15)显示了面包板上的电路。
- en: 'Figure 6.14\. Circuit diagram for three LEDs: red, green, and blue. You’ll
    use 180 ohm resistors like before. They will all be controlled by different GPIO
    pins. Red will use 21, green will use 22, and blue will be connected to pin 23\.
    You could use any of the 26 different GPIO pins.'
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.14。三个LED的电路图：红色、绿色和蓝色。你将像之前一样使用180欧姆的电阻。它们将由不同的GPIO引脚控制。红色将使用21，绿色将使用22，蓝色将连接到引脚23。你可以使用任何26个不同的GPIO引脚。
- en: '![](06fig14_alt.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig14_alt.jpg)'
- en: Figure 6.15\. The three-LED circuit is built on the breadboard. Each LED and
    its corresponding resistor are placed in a row together. This example uses rows
    25, 27, and 29.
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.15。三个LED电路在面包板上构建。每个LED及其相应的电阻都排成一行。本例使用第25、27和29行。
- en: '![](06fig15_alt.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig15_alt.jpg)'
- en: 'To add the green LED, follow these steps:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加绿色LED，请按照以下步骤操作：
- en: '**1**.  GP22 is located on the *left side of the breakout board in row 8* on
    the breadboard. Connect it to *row 27*: insert one end of the jumper into BB8c
    and the other end into BB27a.'
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. GP22位于面包板第8行的**左侧**的扩展板上。将其连接到**第27行**：将跳线的一端插入BB8c，另一端插入BB27a。'
- en: '**2**.  Connect the long leg of the green LED to BB27e and the shorter leg
    to BB27f. Bend the legs if needed.'
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 将绿色LED的长腿连接到BB27e，短腿连接到BB27f。如果需要，弯曲腿。'
- en: '**3**.  Connect a 180 ohm resistor (brown, grey, and brown) from BB27j to the
    closest hole in the negative power bus.'
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 将一个180欧姆的电阻（棕色、灰色和棕色）从BB27j连接到负电源总线上的最近孔。'
- en: 'Here are the steps to add the blue LED:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这是添加蓝色LED的步骤：
- en: '**1**.  GPIO23 is located on the *right side of the breakout board in row 8*
    on the breadboard. Connect it to *row 29*: insert one end of the jumper into BB8i
    and the other end into BB29a.'
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. GPIO23位于面包板第8行的**右侧**的扩展板上。将其连接到**第29行**：将跳线的一端插入BB8i，另一端插入BB29a。'
- en: '**2**.  Connect the long leg of the blue LED to BB29e and the shorter leg to
    BB29f. Bend the legs if needed.'
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 将蓝色LED的长腿连接到BB29e，短腿连接到BB29f。如果需要，弯曲腿。'
- en: '**3**.  Grab a 180 ohm resistor. You guessed it! It’s color-coded brown, grey,
    and brown. Connect it from BB29j to the closest hole in the negative power bus.'
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 拿一个180欧姆的电阻。没错！它是棕色、灰色和棕色的颜色编码。将其从BB29j连接到负电源总线上的最近孔。'
- en: 'Multiple LEDs: program it!'
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多个LED：编程它！
- en: You need to make a few changes to the program to add more LEDs and get them
    all blinking at the same time. The following listing shows the updated code.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要修改程序以添加更多LED，并使它们同时闪烁。以下列表显示了更新的代码。
- en: Listing 6.2\. Three blinking LEDs
  id: totrans-241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.2。三个闪烁的LED
- en: '![](ch06ex02-0.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06ex02-0.jpg)'
- en: '![](ch06ex02-1.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06ex02-1.jpg)'
- en: 'Save the code as blinkLED3.py, and try running it. Open LXTerminal, and enter
    the following command:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码保存为blinkLED3.py，并尝试运行它。打开LXTerminal，并输入以下命令：
- en: '[PRE9]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Fantastic! You have your own light show going on!
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你正在举办自己的灯光秀！
- en: '![](common03.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](common03.jpg)'
- en: Challenges
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挑战
- en: Try these challenges to practice controlling your Raspberry Pi’s GPIO pins.
    Each one provides a unique problem to solve.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这些挑战来练习控制你的树莓派的GPIO引脚。每个都提供了一个独特的问题来解决。
- en: Wave pattern
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 波浪模式
- en: 'Change the program to make each LED turn on, one at a time, until they’re all
    on. Then, turn each LED off, one at a time. Hint: play with where you put the
    `time.sleep(1)` command. Can you make the LEDs light up and turn off in a wave
    pattern?'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 修改程序，使每个LED依次打开，直到它们都打开。然后，依次关闭每个LED。提示：尝试调整`time.sleep(1)`命令的位置。你能使LED以波浪模式点亮和熄灭吗？
- en: Simon Says
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 西蒙说
- en: 'Write a function that blinks the LEDs and that can take five parameters representing
    a pattern of colorful blinks. Each parameter is a string representing a color:
    red, blue, or green. The function should blink the lights in the appropriate pattern.
    Here is a series of Simon Says patterns you should try to make your function produce:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，该函数可以闪烁LED，并接受五个参数，代表彩色闪烁的模式。每个参数都是一个表示颜色的字符串：红色、蓝色或绿色。该函数应该以适当的模式闪烁灯光。以下是一些你应该尝试使你的函数生成的西蒙说模式：
- en: Red, green, red, red, blue
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 红，绿，红，红，蓝
- en: Blue, green, blue, green, red
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝，绿，蓝，绿，红
- en: Green, blue, blue, red, green
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 绿，蓝，蓝，红，绿
- en: Random blinking
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 随机闪烁
- en: 'Create a program that generates random durations for how long the lights stay
    on and off. The durations should be random floating-point numbers between 0 and
    3 seconds. Hint: you can use the `random` method to generate a random floating-point
    number between 0 and 1.0\. Here is an example:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个程序，生成灯光保持开启和关闭的随机持续时间。持续时间应该是介于0到3秒之间的随机浮点数。提示：你可以使用`random`方法生成介于0和1.0之间的随机浮点数。以下是一个示例：
- en: '[PRE10]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To scale this number so that it’s between 0 and 3, you can multiply `off_random_time`
    by 3\. If you get stuck on the challenge, check [appendix C](kindle_split_021.html#app03)
    and the chapter source code for hints and solutions.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这个数字缩放到0到3之间，你可以将`off_random_time`乘以3。如果你在挑战中遇到困难，请查看[附录C](kindle_split_021.html#app03)和章节源代码以获取提示和解决方案。
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: 'In this chapter, you learned the following things:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了以下内容：
- en: A Pi is capable of interacting with the world around it. With a few extra parts,
    you can set it up for physical computing projects.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树莓派能够与周围的世界互动。通过添加一些额外的部件，你可以将其设置为物理计算项目。
- en: A Pi can send out electrical signals! You can send output through the GPIO pins,
    and this can be used to light up LEDs or control many other electronic components
    (motors, buzzers, relays, and so on).
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树莓派可以发送电信号！你可以通过GPIO引脚发送输出，这可以用来点亮LED或控制许多其他电子组件（电机、蜂鸣器、继电器等）。
- en: Breadboards are like playgrounds for electronics. They make it easy to create
    circuits for your Pi because you can easily build and take apart circuits for
    use with the Pi.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面板就像电子的游乐场。它们使创建用于Pi的电路变得容易，因为你可以轻松地构建和拆卸电路以用于Pi。
- en: The `RPi.GPIO` library has built-in functions to set up and control output (voltage)
    to GPIO pins with Python.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RPi.GPIO`库内置了使用Python设置和控制GPIO引脚输出（电压）的函数。'
- en: Just imagine the possibilities of controlling pretty much any electrical device
    using your Raspberry Pi. Even better, imagine making the device work based on
    sensors (inputs) so you can create smart devices programmed by you!
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下使用你的树莓派控制几乎任何电气设备的可能性。更好的是，想象一下根据传感器（输入）使设备工作，这样你就可以创建由你编程的智能设备！
- en: Chapter 7\. Light Up Guessing Game
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7章\. 点亮猜测游戏
- en: '**In this chapter, you’ll be learning about**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**在本章中，你将学习关于**'
- en: '*Simplifying and improving your code with more thoughtful design and use of
    functions*'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过更深思熟虑的设计和使用函数来简化和提高你的代码*'
- en: '*Building a circuit to control a special LED (light bulb) that can make and
    combine red, green, and blue light*'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*构建一个电路来控制一个特殊的LED（灯泡），可以产生并组合红、绿和蓝光*'
- en: '*Adding together colors of light to create new colors*'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将光的颜色相加以创建新的颜色*'
- en: '*Making your Pi come alive by having it respond using different colored light*'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过让树莓派使用不同颜色的灯光做出反应来使它生动起来*'
- en: Your Raspberry Pi has a unique ability to interact with the world around it.
    In the last chapter, you made lights blink based on a programmed pattern. Nice,
    but that isn’t truly interactive, because the Pi always blinks a pattern that
    you program it to do. In this chapter, let’s see if you can create an interactive
    project that *responds* to you through its GPIO pins. You’ll draw on what you’ve
    learned about conditional logic (`if`/`elif`/`else`) to have your Pi make decisions
    and respond. As you did in earlier chapters, you’ll need to gather input, use
    loops, and apply a few other programming techniques to get it done.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你的Raspberry Pi具有与周围世界互动的独特能力。在上一个章节中，你根据编程模式使灯光闪烁。不错，但这并不是真正的交互式，因为Pi总是闪烁你编程的模式。在本章中，让我们看看你是否能创建一个可以通过其GPIO引脚对你做出响应的交互式项目。你将利用你关于条件逻辑（`if`/`elif`/`else`）的知识，让你的Pi做出决策并做出响应。就像在早期章节中做的那样，你需要收集输入，使用循环，并应用一些其他编程技术来完成它。
- en: 'You’re making a Light Up Guessing Game, but not just any one: this game will
    illuminate a small light called an *RGB* (stands for red, green, blue) *LED*,
    which can make any color. You’ll use your Pi, breadboard, and electrical parts,
    along with a program you’re going to write. Your Pi will let the player know if
    they’re correct by flashing the RGB in different colors if their guess is too
    high or too low.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在制作一个点亮猜测游戏，但不仅仅如此：这个游戏将点亮一个小灯，称为*RGB*（代表红色、绿色、蓝色）*LED*，它可以产生任何颜色。你将使用你的Pi、面包板和电气部件，以及你将要编写的程序。如果你的猜测过高或过低，Pi将通过闪烁RGB
    LED的不同颜色来让玩家知道他们是否正确。
- en: '[Figure 7.1](#ch07fig01) shows the parts you need. You’ll notice that some
    of them are the same as in [chapter 6](kindle_split_016.html#ch06), but you’ll
    also need an RGB LED. Let’s get started!'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7.1](#ch07fig01)显示了所需的部件。你会注意到其中一些与[第6章](kindle_split_016.html#ch06)中的相同，但你还需要一个RGB
    LED。让我们开始吧！'
- en: Figure 7.1\. The Light Up Guessing Game uses a red, green, blue (RGB) LED. An
    RGB LED can produce many different colors because it has three LEDs (colored red,
    green, and blue) packed inside it.
  id: totrans-277
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.1\. 点亮猜测游戏使用红色、绿色、蓝色（RGB）LED。RGB LED可以产生许多不同的颜色，因为它内部有三个LED（红色、绿色和蓝色）。
- en: '![](07fig01_alt.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![07fig01_alt.jpg](07fig01_alt.jpg)'
- en: Guessing Game design
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 猜测游戏设计
- en: 'The object of the game is to guess a magic number. This time, the Pi will give
    feedback to the user by lighting up the RGB LED in different colors. Here are
    some game details:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的目标是猜测一个魔法数字。这次，Pi将通过点亮不同颜色的RGB LED来向用户提供反馈。以下是游戏的一些细节：
- en: The magic number is a randomly generated number between 1 and 20.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 魔法数字是1到20之间随机生成的数字。
- en: The player is given five tries to guess the number correctly.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家有五次猜测正确数字的机会。
- en: If they guess correctly, the RGB LED flashes green.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果他们猜对了，RGB LED会闪烁绿色。
- en: If the guess is too high, the RGB LED flashes red.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果猜测过高，RGB LED会闪烁红色。
- en: If the guess is too low, the RGB LED flashes blue.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果猜测过低，RGB LED会闪烁蓝色。
- en: The player is given the choice to play again.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家可以选择再次游戏。
- en: '[Figure 7.2](#ch07fig02) shows a sample of the game’s output.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7.2](#ch07fig02)显示了游戏的输出示例。'
- en: Figure 7.2\. The Light Up Guessing Game responds to the user after each guess.
    Lights on the breadboard light up to let the player know if their guess is too
    high or too low.
  id: totrans-288
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.2\. 点亮猜测游戏在每次猜测后对用户做出响应。面包板上的灯亮起，让玩家知道他们的猜测是过高还是过低。
- en: '![](07fig02_alt.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![07fig02_alt.jpg](07fig02_alt.jpg)'
- en: You’ll approach this project in two parts. The first part is to build the circuit
    (the hardware), and the second part is writing the program (the software).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你将分两部分来处理这个项目。第一部分是构建电路（硬件），第二部分是编写程序（软件）。
- en: 'Hardware: building the circuit'
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 硬件：构建电路
- en: Let’s get building! You’re building a circuit on your breadboard to control
    a new type of LED that can make any color you want. You’ll start by connecting
    your Pi’s GPIO pins to the breadboard using the ribbon cable and GPIO breakout
    board. Refer back to [chapter 6](kindle_split_016.html#ch06) (section 6.1) if
    you need a reminder about how to set this up. Your Pi and breadboard should look
    like [figure 7.3](#ch07fig03).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建！你将在面包板上构建一个电路来控制一种新型LED，它可以产生你想要的任何颜色。你将首先使用扁平电缆和GPIO扩展板将Pi的GPIO引脚连接到面包板上。如果你需要提醒如何设置，请参考[第6章](kindle_split_016.html#ch06)（6.1节）。你的Pi和面包板应该看起来像[图7.3](#ch07fig03)。
- en: Figure 7.3\. The Pi, breakout board, and breadboard setup. And you thought your
    desk was messy before!
  id: totrans-293
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.3\. Raspberry Pi、扩展板和面包板设置。在你之前，你以为你的桌子很乱！
- en: '![](07fig03_alt.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![07fig03_alt.jpg](07fig03_alt.jpg)'
- en: Numbers, numbers, numbers!
  id: totrans-295
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数字，数字，数字！
- en: As first explained in [chapter 6](kindle_split_016.html#ch06), you need a way
    to find a particular hole on your breadboard, and to do that you’ll use the numbers
    and letters. Remember, this is much like the way you might find your seat at a
    stadium for a concert or sporting event.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如在第6章[第6章](kindle_split_016.html#ch06)中首次解释的那样，你需要一种方法来找到面包板上的特定孔，为此，你将使用数字和字母。记住，这就像你可能在音乐会或体育赛事的体育场中找到你的座位一样。
- en: To refer to a specific hole on the breadboard, we’ll refer to the row and column,
    but we’ll add the letters *BB* to stand for *breadboard*. Not too hard, right?
    Finding breadboard holes involves searching for the row and then the column. When
    referring to a GPIO pin, we’ll add the letters *GP* in front. For example, GPIO
    pin 12 is referred to as GP12.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 要引用面包板上的特定孔，我们将引用行和列，但我们将添加字母*BB*来代表*面包板*。不太难，对吧？找到面包板孔涉及搜索行，然后是列。当引用GPIO引脚时，我们将在前面添加字母*GP*。例如，GPIO引脚12被称为GP12。
- en: Wiring an RGB LED
  id: totrans-298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 连接RGB LED
- en: You’re wiring up a new type of LED, called an RGB LED.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在连接一种新型LED，称为RGB LED。
- en: '|  |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Definition
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: 'An RGB LED is a light bulb that consists of three LEDs: one red (R), one green
    (G), and one blue (B), all in a single plastic LED bulb casing.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: RGB LED是一个由三个LED组成的光泡：一个红色（R）、一个绿色（G）和一个蓝色（B），所有这些都位于一个塑料LED灯泡外壳中。
- en: '|  |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The RGB LED can produce pretty much any color you want, using the three tiny
    LEDs inside it. By powering these in varying amounts, you can mix light to make
    colors.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: RGB LED几乎可以产生你想要的任何颜色，使用它内部的三个微小的LED。通过以不同的量供电，你可以混合光线来制造颜色。
- en: The RGB LED has four *legs* (or wires) coming out of it, so you’ll need to figure
    out how to wire it up. It’s a bit different than the single-color LEDs you wired
    up in [chapter 6](kindle_split_016.html#ch06), but it’s pretty easy to use.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: RGB LED有四条腿（或电线）从中伸出，所以你需要弄清楚如何连接它。它比你在第6章[第6章](kindle_split_016.html#ch06)中连接的单色LED要复杂一些，但使用起来相当简单。
- en: Circuit sketch
  id: totrans-306
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 电路草图
- en: The circuit diagram for the Light Up Guessing Game is shown in [Figure 7.4](#ch07fig04).
    To light the RGB LED, you’ll have electricity (+3.3 V) flow from your Pi’s GPIO
    pins 12, 16, and 21; through each resistor; through the LED; and then to ground
    (0 V).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 点亮猜测游戏项目的电路图显示在[图7.4](#ch07fig04)。要点亮RGB LED，你需要从你的Pi的GPIO引脚12、16和21流过电（+3.3
    V），通过每个电阻器，通过LED，然后到地（0 V）。
- en: Figure 7.4\. Circuit diagram for the Light Up Guessing Game project
  id: totrans-308
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.4\. 点亮猜测游戏项目的电路图
- en: '![](07fig04_alt.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig04_alt.jpg)'
- en: 'You’ll build the RGB LED circuit on the breadboard and then program it to light
    up. Wire it up in this order:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在面包板上构建RGB LED电路，然后编程使其点亮。按照以下顺序连接：
- en: '**1**.  Put the RGB LED into the breadboard.'
  id: totrans-311
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 将RGB LED放入面包板。'
- en: '**2**.  Connect the three jumper wires, which will connect the GPIO pins to
    the LED (one for each color).'
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 连接三条跳线，这些跳线将GPIO引脚连接到LED（每种颜色一条）。'
- en: '**3**.  Add the three resistors to connect the jumpers to the LED’s red, green,
    and blue legs.'
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 将三个电阻器添加到连接跳线到LED的红色、绿色和蓝色腿上。'
- en: '**4**.  Add the final jumper wire to connect the ground leg of the LED to the
    negative (ground) power bus.'
  id: totrans-314
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**. 添加最后的跳线，将LED的地线腿连接到负（地）电源总线。'
- en: When it’s done, the circuit will look like what you see in [figure 7.5](#ch07fig05).
    Let’s walk through the steps to build this circuit.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，电路将看起来像你在[图7.5](#ch07fig05)中看到的那样。让我们一步步来构建这个电路。
- en: Figure 7.5\. The RGB LED circuit you’re building on the breadboard uses GPIO
    pins 12, 16, and 21 to power the LEDs. The light won’t turn on until you program
    the voltage to come out of the pins.
  id: totrans-316
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.5\. 你在面包板上构建的RGB LED电路使用GPIO引脚12、16和21来供电LED。灯不会亮，直到你编程电压从引脚输出。
- en: '![](07fig05.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig05.jpg)'
- en: Step 1\. Add the RGB LED
  id: totrans-318
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第1步\. 添加RGB LED
- en: Before you can add it to the breadboard, let’s look a bit closer at the RGB
    LED. Remember that there are three tiny LEDs (red, green, and blue) inside it.
    You need to be able to figure out which leg is which color and which one is ground.
    [Figure 7.6](#ch07fig06) is a handy reference.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在你将其添加到面包板之前，让我们更仔细地看看RGB LED。记住，里面有三个微小的LED（红色、绿色和蓝色）。你需要能够弄清楚哪条腿是哪种颜色，哪条是地线。[图7.6](#ch07fig06)是一个方便的参考。
- en: Figure 7.6\. The RGB LED has lots of legs! The longest leg is the ground. The
    other ones are for red, green, and blue. This applies to what is called a *common
    cathode* RGB LED, which is what comes in Pi kits and what you’ll find most commonly
    at electronics suppliers.
  id: totrans-320
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.6\. RGB LED 有很多引脚！最长的引脚是地线。其他的分别是红色、绿色和蓝色。这适用于所谓的 *共阴极* RGB LED，这是 Pi 套件中包含的，也是你在电子供应商那里最常找到的。
- en: '![](07fig06_alt.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig06_alt.jpg)'
- en: '|  |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You’ll need to bend the RGB LED’s legs quite a bit to get them into the holes
    on the breadboard. Try to bend them to line up with the holes, and slowly push
    the legs in all at once.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要弯曲 RGB LED 的引脚，以便将它们插入面包板上的孔。尽量将它们弯曲成与孔对齐，然后一次性慢慢推入引脚。
- en: '|  |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Grab your RGB LED, and let’s insert it into the breadboard. You’re going to
    put it in rows 22, 24, 26, and 28 along column h on the breadboard. Here’s where
    to connect the legs:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 拿起你的 RGB LED，让我们将其插入面包板。你将把它放在面包板上的第 22、24、26 和 28 行，h 列。以下是连接引脚的位置：
- en: Red leg into hole BB22h
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红色引脚插入孔 BB22h
- en: Ground leg (longest leg) into hole BB24h
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地线引脚（最长引脚）插入孔 BB24h
- en: Green leg into hole BB26h
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绿色引脚插入孔 BB26h
- en: Blue leg (shortest) into hole BB28h
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝色引脚（最短）插入孔 BB28h
- en: When it’s inserted, it will look like [Figure 7.7](#ch07fig07). Double-check
    that it’s pushed down into the breadboard so all the legs will make a good connection.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 当它插入时，它将看起来像 [图 7.7](#ch07fig07)。检查一下是否已经压入面包板，以便所有引脚都能良好连接。
- en: Figure 7.7\. Bend the legs of the RGB LED, and insert it into the breadboard
    at BB22h, BB24h, BB26h, and BB28h. The longest leg goes into hole BB24h.
  id: totrans-332
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.7\. 弯曲 RGB LED 的引脚，并将其插入面包板上的 BB22h、BB24h、BB26h 和 BB28h。最长的引脚插入孔 BB24h。
- en: '![](07fig07_alt.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig07_alt.jpg)'
- en: Good job! You just completed the trickiest part.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！你刚刚完成了最困难的部分。
- en: Step 2\. Connect the GPIO jumper wires
  id: totrans-335
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第 2 步：连接 GPIO 跳线
- en: The breakout board has numbers on it that refer to the Raspberry Pi’s GPIO numbering
    system. Remember that we refer to GPIO pins by adding *GPIO* before the number
    of the pin. So if we’re talking about GPIO pin 12, it’s GPIO12.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 断线板上有数字，这些数字指的是 Raspberry Pi 的 GPIO 编号系统。记住，我们在引脚编号前加上 *GPIO* 来指代 GPIO 引脚。所以如果我们谈论
    GPIO 引脚 12，它就是 GPIO12。
- en: 'Question: What hole on your breadboard is next to *GPIO12* (GPIO pin 12)?'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：你的面包板上哪个孔紧挨着 *GPIO12*（GPIO 引脚 12）？
- en: 'Answer: Look closely, and you’ll see that the holes next to it are *BB16i*
    and *BB16j*.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：仔细观察，你会看到它旁边的孔是 *BB16i* 和 *BB16j*。
- en: '|  |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-340
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The color of the jumper wires doesn’t matter, but it’s sometimes helpful to
    pick ones that match the colors of the LED legs. When you’re troubleshooting problems,
    that can help you easily remember which GPIO pin is controlling each color of
    light coming out of the RGB LED.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 跳线颜色不重要，但有时选择与 LED 引脚颜色相匹配的跳线可能会有所帮助。当你解决问题时，这可以帮助你轻松记住哪个 GPIO 引脚控制着 RGB LED
    中的每种颜色的光。
- en: '|  |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Now that you’ve located the holes near the GPIO pins, you can start connecting
    jumper wires as follows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经找到了靠近 GPIO 引脚的孔，你可以开始按照以下步骤连接跳线：
- en: Jumper wire from BB16j to BB22a (connects GP12 to the red leg of the RGB LED)
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 BB16j 到 BB22a 的跳线（连接 GP12 到 RGB LED 的红色引脚）
- en: Jumper wire from BB18j to BB26a (connects GP16 to the green leg of the RGB LED)
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 BB18j 到 BB26a 的跳线（连接 GP16 到 RGB LED 的绿色引脚）
- en: Jumper wire from BB20j to BB28a (connects GP21 to the blue leg of the RGB LED)
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 BB20j 到 BB28a 的跳线（连接 GP21 到 RGB LED 的蓝色引脚）
- en: When you’ve added the wires, the circuit will look like [figure 7.8](#ch07fig08).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 当你添加了电线后，电路将看起来像 [图 7.8](#ch07fig08)。
- en: Figure 7.8\. The jumpers connect the GPIO pins from your Pi to the RGB LED.
    If you have an earlier model Pi, you can use other GPIO pins. Just remember which
    ones you’re using, and use these numbers when you program the Pi to turn the GPIO
    pins on and off.
  id: totrans-348
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.8\. 跳线将 Pi 的 GPIO 引脚连接到 RGB LED。如果你有更早的 Pi 模型，你可以使用其他 GPIO 引脚。只需记住你使用的是哪些引脚，并在编程
    Pi 时使用这些数字来打开和关闭 GPIO 引脚。
- en: '![](07fig08_alt.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig08_alt.jpg)'
- en: Step 3\. Add the three resistors
  id: totrans-350
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第 3 步：添加三个电阻
- en: It’s time to connect your 180 ohm resistors!^([[1](#ch07fn01)]) They should
    have bands of brown, grey, and brown, followed by a fourth gold or silver band.
    Remember that electricity will flow either way through a resistor, so the way
    you connect it doesn’t matter. [Figure 7.9](#ch07fig09) is a handy diagram that
    reminds you how you can figure out the value of a resistor by using the colored
    bands.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候连接你的180欧姆电阻了！^([[1](#ch07fn01)]) 它应该有棕色、灰色和棕色的条纹，然后是一个第四个金色或银色条纹。记住，电流可以通过电阻双向流动，所以连接的方式并不重要。[图7.9](#ch07fig09)是一个有用的图表，提醒你如何通过使用彩色条纹来计算电阻的值。
- en: ¹
  id: totrans-352
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is a safe value that won’t risk damage to your Pi and will keep things
    simple. For those of you who are into precision, technically you might want to
    use slightly different resistors for each color LED (red, green, and blue), because
    each one requires a different amount of electrical current (amps) to make it shine.
    Check out some of the online resistor calculators and Pi forums on RGB LEDs if
    you’re interested.
  id: totrans-354
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这是一个安全值，不会对你的Pi造成损害，并且会使事情变得简单。对于那些追求精度的人来说，从技术上讲，你可能想为每种颜色的LED（红色、绿色和蓝色）使用稍微不同的电阻，因为每个LED都需要不同数量的电流（安培）来使其发光。如果你对RGB
    LED感兴趣，可以查看一些在线电阻计算器和Pi论坛。
- en: Figure 7.9\. The colored bands on a resistor tell you how much resistance the
    resistor has. For this project, you want a brown (1), grey (8), brown (×10) resistor,
    or 18 × 10 = 180 ohm resistor. Don’t have one? Any resistor between about 100
    and 300 ohms should work well.
  id: totrans-355
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.9\. 电阻上的彩色条纹告诉你电阻有多少电阻。对于这个项目，你想要一个棕色（1）、灰色（8）、棕色（×10）电阻，或者18×10=180欧姆电阻。如果没有？任何大约100到300欧姆的电阻都应该工作得很好。
- en: '![](07fig09.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig09.jpg)'
- en: 'Connect the resistors as follows:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下方式连接电阻：
- en: Insert one end of the first resistor into BB22c and the other end into BB22f.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将第一个电阻的一端插入BB22c，另一端插入BB22f。
- en: Insert one end of the second resistor into BB26c and the other end into BB26f.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将第二个电阻的一端插入BB26c，另一端插入BB26f。
- en: Insert one end of the third resistor into BB28c and the other end into BB28f.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将第三个电阻的一端插入BB28c，另一端插入BB28f。
- en: Once they’re added, you’ll have something that looks like [figure 7.10](#ch07fig10).
    Now you’re ready for the final step!
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 添加完成后，你会得到一个看起来像[图7.10](#ch07fig10)的东西。现在你已经准备好进行最后一步了！
- en: Figure 7.10\. Add your resistors! Make sure you push them down into the breadboard
    holes. If you don’t like them sticking up so high, you can trim the ends using
    wire cutters.
  id: totrans-362
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.10\. 添加你的电阻！确保将它们推入面包板的孔中。如果你不喜欢它们立得那么高，你可以使用剪刀剪掉两端。
- en: '![](07fig10_alt.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig10_alt.jpg)'
- en: Step 4\. Add the jumper to ground
  id: totrans-364
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第4步\. 添加跳线到地
- en: Remember that a ground rail runs vertically along the right side of the breadboard,
    with a blue stripe next to it. Add a jumper from BB24j to the negative (-) power
    bus or ground rail (any hole next to the blue stripe will do). [Figure 7.11](#ch07fig11)
    shows how it looks.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，地线沿着面包板右侧垂直运行，旁边有一个蓝色条纹。从BB24j到负极（-）电源总线或地线（任何靠近蓝色条纹的孔都可以）添加一个跳线。[图7.11](#ch07fig11)显示了它的样子。
- en: Figure 7.11\. The jumper is added to connect the ground of the RGB LED to the
    ground of the Raspberry Pi. The jumper can connect anywhere along the ground rail
    (it usually has a blue stripe running next to it).
  id: totrans-366
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.11\. 跳线已添加，以连接RGB LED的地线与Raspberry Pi的地线。跳线可以连接到地线轨道上的任何位置（通常旁边有一个蓝色条纹）。
- en: '![](07fig11_alt.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig11_alt.jpg)'
- en: Wahoo! You’ve completed the RGB circuit on the breadboard. With the circuit
    complete, it’s time to write your program so you can test it.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 哇哦！你已经在面包板上完成了RGB电路。电路完成后，是时候编写你的程序来测试它了。
- en: '|  |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Color mixing with an RGB LED**'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用RGB LED进行颜色混合**'
- en: You can program your RGB LED to light up red, green, or blue by turning on or
    off GPIO pins 12, 16, and 21\. But RGB LEDs can make more colors by mixing different
    amounts of red, green, and blue light. For example, you can combine equal amounts
    of red and blue light to make a nice magenta color. Or to make your LED yellow,
    you can combine equal amounts of green and red. Televisions work on the same principle.
    This concept, called *additive color*, means mixing varying amounts of different
    colors of light to make new colors.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过打开或关闭GPIO引脚12、16和21来编程RGB LED，使其变红、绿或蓝。但RGB LED可以通过混合不同量的红、绿和蓝光来制造更多颜色。例如，你可以混合等量的红光和蓝光来制作漂亮的洋红色。或者，为了使LED变黄，你可以混合等量的绿光和红光。电视也是基于同样的原理。这个概念被称为*加色法*，意味着混合不同量的不同颜色的光来制造新的颜色。
- en: '![](188fig01_alt.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![图片](188fig01_alt.jpg)'
- en: Wait! Your Pi can only turn LEDs on or off (you set them to `HIGH` or `LOW`)!
    How can you make something like a raspberry red color that might be 80% red and
    20% blue? It’s possible, but you’ll need to learn how to very quickly pulse your
    Pi’s GPIO output. This is called *pulse width modulation (PWM)*. Check online
    for information on how you can use the `RPi.GPIO` module to do PWM and create
    almost any shade of color you want.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 等等！你的Pi只能打开或关闭LED（你将它们设置为`HIGH`或`LOW`）！你怎么能制作出可能是80%红色和20%蓝色的东西，比如树莓红色？这是可能的，但你需要学习如何快速脉冲Pi的GPIO输出。这被称为*脉冲宽度调制（PWM）*。在网上查找有关如何使用`RPi.GPIO`模块进行PWM以及创建你想要的几乎任何颜色的信息。
- en: '|  |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Software: LEDGuessingGame program'
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 软件：LEDGuessingGame程序
- en: 'You’re creating a game to guess a magic number. As mentioned at the start of
    the chapter, you’ll design the game play based on these simple rules (feel free
    to change them to your liking):'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在创建一个猜数字的游戏。正如本章开头所提到的，你将根据以下简单规则（你可以随意修改以符合你的喜好）来设计游戏玩法：
- en: The magic number is a randomly generated number between 1 and 20.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 魔法数字是1到20之间的随机生成的数字。
- en: The player is given five tries to guess the number correctly.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家有五次机会猜对数字。
- en: If they guess correctly, the RGB LED flashes green.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果他们猜对了，RGB LED会闪烁绿色。
- en: If they guess too high, the RGB LED flashes red.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果他们猜得太高，RGB LED会闪烁红色。
- en: If they guess too low, the RGB LED flashes blue.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果他们猜得太低，RGB LED会闪烁蓝色。
- en: After five guesses, the game is over.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 五次猜测后，游戏结束。
- en: The player is given the choice to play again.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家可以选择是否再次玩游戏。
- en: As you’ve seen in earlier chapters, programming is often about breaking down
    complex problems into smaller ones and then solving them. Let’s start by laying
    out a quick diagram outlining what the program should do (see [figure 7.12](#ch07fig12)).
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的章节中看到的，编程通常是将复杂问题分解成更小的问题，然后逐一解决。让我们先快速绘制一个程序应该做什么的示意图（见[图7.12](#ch07fig12)）。
- en: Figure 7.12\. Flow diagram showing how the guessing game should work. Notice
    how you’re blinking LEDs if the guess is too low, too high, or correct. You also
    give the player the choice of whether they’d like to play again.
  id: totrans-385
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.12\. 显示猜测游戏应该如何工作的流程图。注意，如果你猜得太低、太高或正确，你会闪烁LED。你还给玩家选择是否想要再次玩游戏的机会。
- en: '![](07fig12_alt.jpg)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig12_alt.jpg)'
- en: 'As you approach this program, let’s see if you can simplify the code by organizing
    it into *functions*, especially when you have chunks of code that can be easily
    separated. Remember that you can use functions to organize your code and simplify
    it. You’ll create three functions to handle each of the flashing lights, to simplify
    the main part of your program:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在接近这个程序时，让我们看看你是否可以通过将代码组织成*函数*来简化代码，特别是当你有可以轻松分离的代码块时。记住，你可以使用函数来组织代码并简化它。你将创建三个函数来处理每个闪烁灯，以简化程序的主要部分：
- en: '**`flash_red`** —Flashes the RGB LED red'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`flash_red`** —使RGB LED闪烁红色'
- en: '**`flash_blue`** —Flashes the RGB LED blue'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`flash_blue`** —使RGB LED闪烁蓝色'
- en: '**`flash_green`** —Flashes the RGB LED green'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`flash_green`** —使RGB LED闪烁绿色'
- en: You’ll also create a function to display a message when the game is over.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将创建一个函数，用于在游戏结束时显示一条消息。
- en: 'Now that you have a plan, let’s code it in this order:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了计划，让我们按照以下顺序编写代码：
- en: '**1**.  Import libraries, create the flashing and game-over functions, and
    set up the GPIO pins for RGB LED output.'
  id: totrans-393
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 导入库，创建闪烁和游戏结束函数，并设置RGB LED输出引脚。'
- en: '**2**.  Display the title and introduction, create a loop, and get and check
    up to five guesses.'
  id: totrans-394
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 显示标题和简介，创建循环，并获取和检查最多五次猜测。'
- en: '**3**.  Add logic to allow the user to decide if they want to play again.'
  id: totrans-395
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 添加逻辑，允许用户决定是否想要再次玩游戏。'
- en: Let’s begin! Open IDLE by choosing Python 3 under Menu > Programming. This opens
    IDLE to the Python 3.x Shell. In the Python Shell, start a new program by pressing
    Ctrl-N or selecting File > New Window.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！通过选择菜单>编程下的Python 3来打开IDLE。这将在Python 3.x Shell中打开IDLE。在Python Shell中，通过按Ctrl-N或选择文件>新建窗口来启动一个新程序。
- en: Setting up the GPIO pins for the RGB LED
  id: totrans-397
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置RGB LED的GPIO引脚
- en: In the IDLE 3 text editor, you’ll first load the Python libraries you need,
    create functions, and prepare your Pi to send electricity to the RGB LED (see
    [figure 7.13](#ch07fig13)).
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在IDLE 3文本编辑器中，你首先需要加载所需的Python库，创建函数，并准备你的Pi向RGB LED发送电流（见[图7.13](#ch07fig13)）。
- en: Figure 7.13\. The program starts by importing the Python libraries you’ll need
    to use, setting up your Pi’s GPIO pins for lighting up the LEDs, and defining
    the functions you’ll need.
  id: totrans-399
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.13\. 程序首先导入你将需要使用的 Python 库，设置 Pi 的 GPIO 引脚以点亮 LED，并定义你需要的函数。
- en: '![](07fig13_alt.jpg)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig13_alt.jpg)'
- en: Setting up your Pi’s GPIO pins
  id: totrans-401
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设置你的 Pi 的 GPIO 引脚
- en: 'You need to get your Pi ready for output to the GPIO pins and tell the Pi which
    pins you plan to use (see [listing 7.1](#ch07ex01)). If you recall from the earlier
    wiring, you’re using these pins to control the three LEDs that are inside the
    RGB LED:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要让你的 Pi 准备好输出到 GPIO 引脚，并告诉 Pi 你计划使用哪些引脚（参见 [清单 7.1](#ch07ex01)）。如果你还记得之前的接线，你正在使用这些引脚来控制
    RGB LED 内部的三个 LED：
- en: GP12 for the red LED
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GP12 用于红色 LED
- en: GP16 for the green LED
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GP16 用于绿色 LED
- en: GP21 for the blue LED
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GP21 用于蓝色 LED
- en: Later, you’ll write the code to control those pins. Let’s start by importing
    the GPIO library for the Raspberry Pi and setting up the GPIO pins so they can
    output a voltage to control the RGB LED.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你将编写控制这些引脚的代码。让我们先导入用于 Raspberry Pi 的 GPIO 库，并设置 GPIO 引脚，以便它们可以输出电压来控制 RGB
    LED。
- en: Listing 7.1\. Setting up the Pi’s GPIO pins
  id: totrans-407
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.1\. 设置 Pi 的 GPIO 引脚
- en: '![](ch07ex01-0.jpg)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![](ch07ex01-0.jpg)'
- en: '![](ch07ex01-1.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![](ch07ex01-1.jpg)'
- en: Great! You’ve started by importing the `time` and `random` libraries, because
    you’ll need them to flash the LED and help you generate a random number when the
    game starts. You define variables for the pins you’re using and even add a variable,
    `BlinkTime`, that says how much time you’ll blink the light on and off. Finally,
    you tell your Pi that you want to use three pins as output. Now let’s write the
    functions.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！你已经通过导入 `time` 和 `random` 库开始了，因为你将需要它们来闪烁 LED 并在游戏开始时帮助你生成随机数。你定义了你使用的引脚变量，甚至添加了一个变量
    `BlinkTime`，它说明了你将闪烁灯光的时间。最后，你告诉你的 Pi 你想要使用三个引脚作为输出。现在让我们编写函数。
- en: Creating functions to simplify the code
  id: totrans-411
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建函数以简化代码
- en: You need three functions to flash the three LEDs inside the RGB LED and one
    for game over. Name the flashing functions `flash_red`, `flash_blue`, and `flash_green`,
    as shown in the following listing.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要三个函数来闪烁 RGB LED 内部的三个 LED，以及一个用于游戏结束的函数。将闪烁函数命名为 `flash_red`、`flash_blue`
    和 `flash_green`，如下所示。
- en: Listing 7.2\. Functions that flash LEDs different colors
  id: totrans-413
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.2\. 闪烁不同颜色 LED 的函数
- en: '![](ch07ex02-0.jpg)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
  zh: '![](ch07ex02-0.jpg)'
- en: '![](ch07ex02-1.jpg)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![](ch07ex02-1.jpg)'
- en: 'In the code, you create four functions:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，你创建了四个函数：
- en: '`flash_red()`'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flash_red()`'
- en: '`flash_green()`'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flash_green()`'
- en: '`flash_blue()`'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flash_blue()`'
- en: '`game_over()`'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`game_over()`'
- en: The three flashing functions blink a different color LED in the RGB LED. The
    blinking is created by using a `for` loop and the `sleep` function while you switch
    the output from the GPIO pin from `HIGH` (on) to `LOW` (off). Think of this as
    being like standing at a light switch and flipping it on and then off, five times.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个闪烁函数在 RGB LED 中闪烁不同颜色的 LED。闪烁是通过使用 `for` 循环和 `sleep` 函数来实现的，同时将 GPIO 引脚的输出从
    `HIGH`（开）切换到 `LOW`（关）。想象一下，这就像站在一个开关旁边，打开然后关闭，五次。
- en: Before you go any farther, save the program as LEDGuessingGame.py in your home
    folder.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在你继续之前，请将程序保存为 LEDGuessingGame.py 到你的家目录中。
- en: '|  |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**When to use functions**'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '**何时使用函数**'
- en: 'Believe it or not, we don’t always know when to create a function. The ability
    to figure that out is a skill that comes with experience in writing programs and
    seeing patterns. Here are some tips for deciding what to make a function:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，我们并不总是知道何时创建一个函数。这种确定的能力是随着编写程序的经验和看到模式而获得的技能。以下是一些决定将什么做成函数的提示：
- en: Is there a group of instructions that you’ll need to use over and over again,
    with little variation?
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否需要重复使用一组指令，变化很小？
- en: Do you have large blocks of code that make your programs hard to read?
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否有大量代码块使你的程序难以阅读？
- en: Functions can simplify your code and make it easier to update.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以简化你的代码，并使其更容易更新。
- en: '|  |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Refactoring your functions
  id: totrans-430
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 重构你的函数
- en: Did you notice that the functions for flashing the LEDs are very similar? Most
    of the code in each function is the same except for the GPIO pin, so let’s see
    if you can improve this code to make it simpler. This process of simplifying code
    is called *refactoring*.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到闪烁 LED 的函数非常相似吗？每个函数中的大部分代码都是相同的，除了 GPIO 引脚，所以让我们看看你是否可以改进这段代码，使其更简单。这个过程称为
    *重构*。
- en: What if you rewrote the three functions as a single function, as shown in [listing
    7.3](#ch07ex03)? This new function takes one parameter, `LED_pin`, that represents
    the number of the GPIO pin you want to control. It can be any one of the GPIO
    pins you’re using for the colors of the RGB LED. For example, if `LED_pin` is
    16, this corresponds to GPIO pin 16, which should blink the green light.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将三个函数重写为一个单一函数，如[列表 7.3](#ch07ex03)所示，这个新函数接受一个参数`LED_pin`，它代表你想要控制的 GPIO
    引脚号。它可以是你用于 RGB LED 颜色的任何 GPIO 引脚。例如，如果`LED_pin`是 16，则对应于 GPIO 引脚 16，应该闪烁绿灯。
- en: Listing 7.3\. Refactoring the three flashing functions to a single function
  id: totrans-433
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.3\. 将三个闪烁函数重构为一个单一函数
- en: '![](194fig01_alt.jpg)'
  id: totrans-434
  prefs: []
  type: TYPE_IMG
  zh: '![图片](194fig01_alt.jpg)'
- en: In this case, you’re refactoring a set of functions that are very similar to
    a single function that takes a parameter (`LED_pin`). This parameter makes the
    function more flexible or dynamic so it can take the place of the three separate
    functions.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你正在重构一组非常相似的功能，这些功能可以合并为一个接受参数（`LED_pin`）的单个函数。这个参数使函数更加灵活或动态，因此它可以取代三个单独的函数。
- en: Main game loop and logic
  id: totrans-436
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 主游戏循环和逻辑
- en: 'The next part of the program creates the main game loop (see [figure 7.14](#ch07fig14)).
    You’ll do the following:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的下一部分创建主游戏循环（见[图 7.14](#ch07fig14)）。你将执行以下操作：
- en: Set up the game.
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置游戏。
- en: Display the title and instructions for the person playing.
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示给玩家看的标题和说明。
- en: Create some variables, and get a random number.
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一些变量，并获取一个随机数。
- en: Create the loop and guessing logic.
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建循环和猜测逻辑。
- en: Figure 7.14\. After displaying the game title and instructions, you need to
    define variables to store important game information, including a random number
    the player is trying to guess. The main loop in the game is repeated to allow
    the user to make five guesses; it also blinks the lights.
  id: totrans-442
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.14\. 在显示游戏标题和说明后，你需要定义变量来存储重要的游戏信息，包括玩家试图猜测的随机数。游戏的主循环被重复执行以允许用户进行五次猜测；它也会闪烁灯光。
- en: '![](07fig14_alt.jpg)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig14_alt.jpg)'
- en: Game setup
  id: totrans-444
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 游戏设置
- en: 'Let’s look at some of the variables you’ll need for the game:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你需要为游戏准备的一些变量：
- en: '`number_in_my_head` holds a random number (an integer between 1 and 20) that
    the player is trying to guess.'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number_in_my_head` 存储一个随机数（一个介于 1 和 20 之间的整数），玩家试图猜测这个数。'
- en: '`count_guesses` helps you count and keep track of how many guesses the player
    has made.'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count_guesses` 帮助你计数并跟踪玩家已经做了多少次猜测。'
- en: '`play_again` tracks the status of whether the player wants to play again. You’ll
    use a Boolean type for this, because it should always be True (yes, let’s play
    again) or False (no, let’s not play again).'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`play_again` 跟踪玩家是否想要再次玩的状态。你将使用布尔类型来表示这个，因为它应该始终是 True（是的，让我们再玩一次）或 False（不，我们不再玩）。'
- en: The next listing adds these three variables and sets them up. You also create
    and display the title and game instructions.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 下一列表添加了这三个变量并设置了它们。你还创建并显示了标题和游戏说明。
- en: Listing 7.4\. Creating variables and displaying the game title and instructions
  id: totrans-450
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.4\. 创建变量并显示游戏标题和说明
- en: '[PRE11]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Fantastic! The variables set the stage for the guessing-game logic. It’s a lot
    like the foundation of a house—you need it in order to build the rest.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！变量为猜测游戏逻辑奠定了基础。它就像房子的地基——你需要它来建造其余的部分。
- en: Guessing Game Loop and logic
  id: totrans-453
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 猜测游戏循环和逻辑
- en: The code features two loops, one inside the other. The outer loop gives the
    user the option of playing again—we’ll call this the Play Again Loop. Within that
    loop is another that gives the player five guesses—we’ll call this the Guessing
    Game Loop.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 代码包含两个循环，一个嵌套在另一个内部。外循环给用户提供了再次玩的机会——我们将其称为“再次玩循环”。在这个循环内部还有一个循环，给玩家五次猜测的机会——我们将其称为“猜测游戏循环”。
- en: The main game loop involves getting a guess, checking the guess, blinking the
    RGB LED the appropriate color, and then repeating until the player guesses right
    or has used all five guesses. The next listing shows the program for the Guessing
    Game Loop and the logic for checking guesses.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 主游戏循环包括获取猜测、检查猜测、闪烁 RGB LED 的适当颜色，然后重复直到玩家猜对或用完所有五次猜测。下一列表显示了猜测游戏循环的程序和检查猜测的逻辑。
- en: Listing 7.5\. Guessing Game Loop
  id: totrans-456
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.5\. 猜测游戏循环
- en: '![](197fig01_alt.jpg)'
  id: totrans-457
  prefs: []
  type: TYPE_IMG
  zh: '![图片](197fig01_alt.jpg)'
- en: The Guessing Game Loop contains the logic to
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 猜测游戏循环包含以下逻辑
- en: Keep track of the number of guesses.
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪猜测次数。
- en: Get a guess.
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取一个猜测。
- en: Check to see if a guess is correct, too high, or too low.
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查猜测是否正确、过高或过低。
- en: Where is the logic for responding to the player? It’s in the loop. Each time
    you get a guess, a series of `if`/`elif` statements checks whether the guess is
    correct, too high, or too low. Based on which of those cases is True, the `flash()`
    function is called to flash the appropriately colored LED on and off. If the user
    guesses the number correctly, the RGB LED will flash green, and then the `break`
    command will exit the `while` loop.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 响应玩家的逻辑在哪里？它在循环中。每次你得到一个猜测，一系列的`if`/`elif`语句会检查猜测是否正确、过高或过低。根据哪个情况为True，`flash()`函数会被调用以闪烁相应颜色的LED。如果用户猜对了数字，RGB
    LED会闪烁绿色，然后`break`命令会退出`while`循环。
- en: Notice that you add an `else` statement to the `while` loop. When the number
    of guesses has been exceeded (`count_guesses` is greater than 5), the `else` statement
    is triggered and the `game_over` function is called. The `else` block only happens
    when the `while` condition is checked and is False (in this case, when the number
    of guesses has exceeded 5).
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到你在`while`循环中添加了一个`else`语句。当猜测次数超过限制（`count_guesses`大于5）时，`else`语句会被触发，并调用`game_over`函数。`else`块仅在`while`条件检查为False时发生（在这种情况下，当猜测次数超过5时）。
- en: In the next section, you’ll see how to give the player the option of playing
    again.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将看到如何给玩家提供再次玩游戏的选择。
- en: Adding the Play Again Loop and logic
  id: totrans-465
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加再次游戏循环和逻辑
- en: You want to add a feature to the game that lets the user choose whether they
    want to play again. To do this, you need another loop that goes around the Guessing
    Game Loop (see [figure 7.15](#ch07fig15)). The Play Again Loop needs to repeat
    the Guessing Game Loop as long as the user answers that they want to play again.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要添加一个功能，让用户选择是否想要再次玩游戏。为此，你需要另一个循环，它围绕在猜数字游戏循环周围（参见[图7.15](#ch07fig15)）。再次游戏循环需要重复猜数字游戏循环，直到用户回答他们想要再次玩游戏。
- en: Figure 7.15\. The Play Again Loop is wrapped around the Guessing Game Loop.
    After the player has exhausted their guesses or guessed the number correctly,
    they’re asked if they want to play again. Depending on their answer, the game
    will either start over or end.
  id: totrans-467
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.15\. 再次游戏循环被包裹在猜数字游戏循环中。当玩家用完他们的猜测或猜对了数字后，他们会被告知是否想要再次玩游戏。根据他们的回答，游戏将重新开始或结束。
- en: '![](07fig15_alt.jpg)'
  id: totrans-468
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig15_alt.jpg)'
- en: Listing 7.6\. Play Again Loop
  id: totrans-469
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.6\. 再次游戏循环
- en: '![](ch07ex06-0.jpg)'
  id: totrans-470
  prefs: []
  type: TYPE_IMG
  zh: '![](ch07ex06-0.jpg)'
- en: '![](ch07ex06-1.jpg)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
  zh: '![](ch07ex06-1.jpg)'
- en: Awesome job! You have put together a circuit to control an RGB LED and written
    the Python code to make a game interact with it. Now, let’s test it.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你已经组装了一个控制RGB LED的电路，并编写了Python代码来使游戏与之交互。现在，让我们测试它。
- en: Playing the game
  id: totrans-473
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 玩游戏
- en: 'Save the code as LEDGuessingGame.py, and try running it. Select Run > Run Module
    (or press F5) from the IDLE text editor to run your program. If you have an older
    version of Raspbian (prior to October 2015), open Terminal and enter the following
    command:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码保存为LEDGuessingGame.py，并尝试运行它。从IDLE文本编辑器中选择运行 > 运行模块（或按F5）来运行你的程序。如果你有一个较旧的Raspbian版本（在2015年10月之前），打开终端并输入以下命令：
- en: '[PRE12]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Excellent! You should see your guessing game start up. Let’s test it to see
    if it works. Try seeing if you can guess the number. Try getting it wrong, just
    to make sure the `game_over` function works.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你应该能看到你的猜数字游戏启动。让我们测试一下它是否工作。尝试猜测数字。尝试猜错，只是为了确保`game_over`函数工作。
- en: '|  |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-478
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Remember that any programs that use GPIO pins must be run from the Raspbian
    command prompt as the superuser (or root). The `sudo` command lets you do this.
    If you try running the program at the Python Shell in IDLE, then you’ll get the
    error that ends “`RuntimeError: No access to /dev/mem. Try running as root!`”'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '记住，任何使用GPIO引脚的程序都必须以超级用户（或root）的身份从Raspbian命令提示符运行。`sudo`命令让你这样做。如果你尝试在IDLE的Python
    Shell中运行程序，那么你会得到一个以“`RuntimeError: No access to /dev/mem. Try running as root!`”结尾的错误。'
- en: '|  |'
  id: totrans-480
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Troubleshooting
  id: totrans-481
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'If the lights aren’t blinking after each guess is made, here are some things
    you can check:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每次猜测后灯光没有闪烁，这里有一些你可以检查的事情：
- en: Check the circuit on the breadboard. Is the ribbon cable connected properly,
    with the first wire connected toward the edge of the Pi, away from the USB ports?
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查面包板上的电路。扁平电缆是否正确连接，第一根线连接到Pi的边缘，远离USB端口？
- en: Double-check that the jumper, RGB LED, and resistors are connected to the correct
    holes on the breadboard. Could your RGB LED be inserted the wrong way (the shorter
    legs go toward the negative or ground side)? Try turning it around if you aren’t
    sure.
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请再次确认跳线、RGB LED 和电阻是否连接到面包板上的正确孔位。你的 RGB LED 是否插反了（较短的腿朝向负极或地线侧）？如果你不确定，可以试着将它翻转过来。
- en: 'Look through your Python program for errors. If necessary, edit the program
    to add some `print` statements so you can see which parts are working. For example,
    in the inner loop that handles the five guesses, you can use the `print` function
    to display the value of `count_guesses`:'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查你的 Python 程序中的错误。如有必要，编辑程序以添加一些 `print` 语句，以便你可以看到哪些部分正在工作。例如，在内层循环中处理五个猜测的部分，你可以使用
    `print` 函数显示 `count_guesses` 的值：
- en: '[PRE13]'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Try adding a `print` message in the `flash` function so you’re sure it’s being
    called. For example, you could add
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `flash` 函数中尝试添加一个 `print` 消息，以确保它被调用。例如，你可以添加
- en: '[PRE14]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you’ve enjoyed playing your game, try some additional challenges to increase
    the fun factor!
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢玩你的游戏，尝试一些额外的挑战来增加乐趣！
- en: '![](common03.jpg)'
  id: totrans-490
  prefs: []
  type: TYPE_IMG
  zh: '![](common03.jpg)'
- en: Challenges
  id: totrans-491
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挑战
- en: These challenges use the RGB LED that you’ve already wired up. If you can’t
    figure them out, check [appendix C](kindle_split_021.html#app03) for hints and
    solutions.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 这些挑战使用了你已经连接好的 RGB LED。如果你无法解决它们，请查看 [附录 C](kindle_split_021.html#app03) 以获取提示和解决方案。
- en: Game winner
  id: totrans-493
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 游戏赢家
- en: Write a function in the game that creates a flashing animation whenever the
    user correctly guesses the number. For example, you could try quickly flashing
    the RGB LED different colors.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中编写一个函数，当用户正确猜出数字时，该函数会创建一个闪烁动画。例如，你可以尝试快速闪烁 RGB LED 的不同颜色。
- en: Easter egg
  id: totrans-495
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 复活节彩蛋
- en: 'Was the last one too easy? Well, try this: create an Easter egg in your game.
    Create logic so that if someone types in a certain word (maybe *Spam*), the program
    displays a secret message and flashes the light in a crazy way.'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个是不是太简单了？那么，试试这个：在你的游戏中创建一个复活节彩蛋。创建逻辑，以便如果有人输入某个特定的词（可能是 *Spam*），程序会显示一条秘密消息并以疯狂的方式闪烁灯光。
- en: Warmer and colder
  id: totrans-497
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 温暖和寒冷
- en: Expand the logic of your program to make the speed of the blinking indicate
    whether the player’s guess is close to or far away from the correct answer. As
    a hint, think about the blinking speed you’ve set. Let’s say a guess is off by
    10 (the player guesses 15, and the magic number is 5). You want the light to blink
    slowly. You can take the difference (ignore any negative signs) and divide it
    by 10\. This will make the blinking speed one-tenth of the difference, or once
    every second if you’re off by 10 (pretty slow). If the player’s guess is off by
    2, the light will blink every two-tenths of a second (pretty fast). This way,
    the blinking speed tells the player if their guess is close or far away.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展你程序的逻辑，使闪烁的速度表明玩家的猜测是接近还是远离正确答案。作为一个提示，想想你设置的闪烁速度。比如说，一个猜测偏离了 10（玩家猜测 15，而魔法数字是
    5）。你希望灯光闪烁缓慢。你可以取差值（忽略任何负号）并除以 10。这将使闪烁速度是差值的十分之一，或者如果你偏离了 10（相当慢），每秒闪烁一次。如果玩家的猜测偏离了
    2，灯光将每二十分之一秒闪烁一次（相当快）。这样，闪烁速度就可以告诉玩家他们的猜测是接近还是远离。
- en: Darth Vader surprise
  id: totrans-499
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 达斯·维达惊喜
- en: 'Let’s see if you can get an image of Darth Vader to pop up if the player doesn’t
    correctly guess the number. Here’s a hint to get you started. Install the Linux
    image-viewing software called fim,^([[2](#ch07fn02)]) a program that allows you
    to open images from the Raspbian command line. To install fim, make sure your
    Pi is connected to the internet, and then open Terminal and use the following
    command:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否能在玩家没有正确猜出数字时，让达斯·维达的形象出现。这里有一个提示来帮助你开始。安装名为 fim 的 Linux 图像查看软件，^([[2](#ch07fn02)])，这是一个允许你从
    Raspbian 命令行打开图像的程序。要安装 fim，确保你的 Pi 已连接到互联网，然后打开终端并使用以下命令：
- en: ²
  id: totrans-501
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-502
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: fim is the improved version of fbi, image-viewing software for Linux that can
    be run from the command line.
  id: totrans-503
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: fim 是 fbi 的改进版本，是 Linux 上的图像查看软件，可以从命令行运行。
- en: '[PRE15]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, download an image of Darth Vader and have the game display it on the
    screen. Let’s say you’ve downloaded an image called Darth_Vader.jpg. You can display
    it with these commands in Python:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，下载达斯·维达的图片，让游戏在屏幕上显示它。假设你已经下载了一个名为 Darth_Vader.jpg 的图片。你可以使用以下 Python 命令来显示它：
- en: '[PRE16]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Good luck! May the Force be with you!
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 祝你好运！愿原力与你同在！
- en: Summary
  id: totrans-508
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned that
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了
- en: Pis can respond in rich and exciting ways by interacting through the GPIO pins
    in your programs.
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过程序中的GPIO引脚与Pi交互，Pi可以以丰富和令人兴奋的方式做出反应。
- en: Functions, loops, and conditional statements can be combined with your Pi’s
    output capabilities to create programs that react to people and the environment.
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数、循环和条件语句可以与你的Pi的输出能力结合，创建出能够对人和环境做出反应的程序。
- en: RGB LEDs are very cool because they can make different colors and are actually
    three LEDs packed into one small package.
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RGB LED非常酷，因为它们可以制造出不同的颜色，实际上是将三个LED封装在一个小包装中。
- en: A `while` loop can have an `else` statement that allows you to control what
    happens when the loop condition is no longer true.
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`while`循环可以有一个`else`语句，允许你在循环条件不再为真时控制发生的事情。
- en: A play again loop can be wrapped around a main game loop to allow users to play
    the game over and over again.
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将一个再次播放循环包裹在主游戏循环中，以便用户可以反复玩游戏。
- en: '*Refactoring* is a fancy word that just means simplifying or shortening your
    code by looking for ways to make it more efficient. Be careful, though—you don’t
    want to simplify something so much that it becomes too hard to understand (remember
    the Zen of Python)!'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*重构*是一个听起来很高级的词，实际上只是意味着通过寻找使代码更有效率的途径来简化或缩短你的代码。不过要小心，你不想简化得太多以至于代码变得难以理解（记住Python的禅宗！）'
- en: Chapter 8\. DJ Raspi
  id: totrans-516
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8章\. DJ Raspi
- en: '**In this chapter, you’ll be**'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '**在本章中，你将**'
- en: '*Giving your Pi the ability to respond to input signals by making it interact
    with you in response to button presses*'
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过让Pi在按钮按下时与你交互来响应输入信号*'
- en: '*Learning about electronic buttons and how to build circuits on a breadboard
    with them*'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*了解电子按钮以及如何使用它们在面包板上构建电路*'
- en: '*Running Raspbian operating system commands so your programs can play music,
    show videos, and more*'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*运行Raspbian操作系统命令，以便你的程序可以播放音乐、显示视频等*'
- en: '*Using Python to store sets of information called lists*'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Python存储称为列表的信息集合*'
- en: '*Exploring how you can play sounds on your Pi and make your Pi into a music
    machine*'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*探索如何在你的Pi上播放声音并将其变成音乐机器*'
- en: We don’t think about our five senses (taste, smell, touch, hearing, and sight),
    but without them we wouldn’t be able to feel, know, and interact with the world
    around us. Think of your Pi as a person who, until now, has had a limited set
    of senses. So far, your Pi has only been able to respond to keyboard keys being
    pressed and mouse clicks.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有考虑我们的五种感官（味觉、嗅觉、触觉、听觉和视觉），但没有它们，我们就无法感受到、了解并与周围的世界互动。想想你的Pi就像一个人，直到现在，他只有有限的感官。到目前为止，你的Pi只能对按键和鼠标点击做出反应。
- en: Like a mad scientist bringing something to life, in this chapter you’re going
    to embark on a project to wire up a new sense of touch for your Pi. Okay, maybe
    it won’t be as crazy as creating a bionic creature, but a button gives your Pi
    a sense of touch. You’ll wire a couple buttons to the Pi’s GPIO pins (recall that
    GPIO stands for general-purpose input/output, so this is how your Pi can sense
    and affect the environment). Then you’ll program your Pi to react to button presses.
    Exciting times are ahead!
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 就像疯狂科学家将某物带来生命一样，在本章中，你将开始一个项目，为你的Pi连接一个新的触觉感官。好吧，可能不会像创造一个仿生生物那样疯狂，但按钮给Pi带来了触觉。你将把几个按钮连接到Pi的GPIO引脚上（回想一下，GPIO代表通用输入/输出，因此这是Pi感知和影响环境的方式）。然后，你将编写程序让Pi对按钮按下做出反应。激动人心的时刻即将到来！
- en: 'This project is a small glimpse of all the different senses you could possibly
    give your Pi. Electronic components that can detect the environment around them
    are called *sensors*. A button is one of the simplest sensors, because it can
    detect touch. What other sensors could you add? How about some of these ideas:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目只是你为你的Pi提供各种不同感官体验的一个小缩影。能够检测周围环境的电子组件被称为*传感器*。按钮是最简单的传感器之一，因为它可以检测触摸。你还能添加哪些传感器呢？以下是一些想法：
- en: A camera that can track a ball or face using special software called *computer
    vision* that can recognize objects (this is similar to how a Microsoft Kinect
    works)
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可以使用称为*计算机视觉*的特殊软件跟踪球或人脸的摄像头，该软件可以识别物体（这与微软Kinect的工作方式类似）
- en: Super-human capabilities like a proximity sensor to detect when someone is walking
    nearby (like the ones used to trigger the doors to open at the grocery store)
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超人类能力，如接近传感器，可以检测附近有人行走（就像用来在杂货店开门时触发门的传感器）
- en: A microphone so it can hear
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个麦克风，以便它能听到
- en: All this is possible with a Pi, some determination to figure it out, and a bit
    of fearlessness about trying new things.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可以用Pi实现，一些解决问题的决心，以及一点尝试新事物的勇气。
- en: Project overview
  id: totrans-530
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目概述
- en: In this chapter, you’ll turn your Pi into DJ Raspi—a musical computer that plays
    different sounds when you press buttons. You’ll wire up two mini pushbuttons on
    your breadboard and figure out how to write the code to make the buttons play
    sounds. Later, if you want, you can add other sensors to your Pi and program them.
    This project will give you an example of how to work with input from sensors.
    [Figure 8.1](#ch08fig01) shows the parts you’ll need.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将把你的Pi变成DJ Raspi——一个当你按下按钮时播放不同声音的音乐电脑。你将在面包板上连接两个微型按钮，并找出如何编写代码使按钮播放声音。稍后，如果你想的话，你可以向你的Pi添加其他传感器并编程它们。这个项目将给你一个如何处理传感器输入的例子。[图8.1](#ch08fig01)显示了你需要准备的部件。
- en: Figure 8.1\. The DJ Raspi project requires several different parts to turn your
    Pi into a music player. The length and color of the jumper wires don’t matter.
  id: totrans-532
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.1。DJ Raspi项目需要几个不同的部件，将你的Pi变成音乐播放器。跳线长度和颜色无关紧要。
- en: '![](08fig01_alt.jpg)'
  id: totrans-533
  prefs: []
  type: TYPE_IMG
  zh: '![图片](08fig01_alt.jpg)'
- en: 'Gather the parts and get ready for some fun. You’ll notice that some of them
    are the same as in [chapters 6](kindle_split_016.html#ch06) and [7](kindle_split_017.html#ch07),
    but you’ll also need a few new items. Most of these are included in Raspberry
    Pi starter kits, but you can find them at online electronics retailers as well.
    You’ll approach this project in two parts: building the circuit (the hardware)
    and writing the program (the software). Let’s go!'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 收集所需部件，准备享受乐趣。你会发现其中一些与[第6章](kindle_split_016.html#ch06)和[第7章](kindle_split_017.html#ch07)中的相同，但你还需要一些新物品。这些大多数都包含在树莓派入门套件中，但你也可以在网上电子零售商那里找到它们。你将分两部分来完成这个项目：构建电路（硬件）和编写程序（软件）。让我们开始吧！
- en: Setting up your Pi to play sounds
  id: totrans-535
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置Pi以播放声音
- en: To start, let’s get your Pi ready to play sounds. A Pi can output sounds through
    the headphone jack (also called the *3.5 mm audio port*) or through HDMI. Before
    you start, plug in your headphones, powered computer speakers, or, alternatively,
    a TV with built-in speakers connected via an HDMI cable.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们让你的Pi准备好播放声音。Pi可以通过耳机插孔（也称为*3.5毫米音频端口*）或通过HDMI输出声音。在你开始之前，插入你的耳机、带电源的电脑扬声器，或者，如果你愿意，通过HDMI线连接内置扬声器的电视。
- en: '|  |'
  id: totrans-537
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**All sounds aren’t the same: audio formats**'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '**所有声音并不相同：音频格式**'
- en: If you wanted to leave a secret message for someone, you could choose several
    different ways to make the message into a secret code. You could use different
    symbols to represent words, or you might substitute letters or shift letters around.
    There are many different ways to encode something.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要给某人留一条秘密信息，你可以选择几种不同的方式将信息变成秘密代码。你可以使用不同的符号来代表单词，或者你可能替换字母或改变字母的位置。有无数种不同的编码方式。
- en: Similarly, people have come up with many different ways to store sounds (or
    audio files). These ways (called *formats*) are different ways of compressing
    or encoding the information in a sound to make it easy to store on a computer
    or music player. Sometimes sounds are encoded so they will only work on certain
    music players.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，人们想出了许多不同的方式来存储声音（或音频文件）。这些方式（称为*格式*）是压缩或编码声音信息的不同方式，以便于在计算机或音乐播放器上存储。有时声音被编码，只能在某些音乐播放器上播放。
- en: 'Here are some common formats:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些常见的格式：
- en: '***MP3*** —The most common audio file format used in most audio players. The
    files end in .mp3.'
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***MP3*** —在大多数音频播放器中最常用的音频文件格式。文件以 .mp3 结尾。'
- en: '***WAV or WAVE*** —Stands for Waveform Audio File Format. It’s used on many
    Windows computers. These files end in .wav.'
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***WAV或WAVE*** —代表波形音频文件格式。它在许多Windows计算机上使用。这些文件以 .wav 结尾。'
- en: '***Ogg*** —An open format that was developed for streaming applications. The
    files end in .ogg.'
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Ogg*** —一个为流媒体应用开发的开放格式。文件以 .ogg 结尾。'
- en: Each format uses a different method to compress or shrink a sound and make it
    smaller to store. The Pi has many different software applications for playing
    audio. Each one can play different formats. Check the Raspberry Pi forums if you
    want to learn more about the different players and what they’re best for.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 每种格式都使用不同的方法来压缩或缩小声音，使其更小以便存储。Pi有许多不同的软件应用程序用于播放音频。每个都可以播放不同的格式。如果你想了解更多关于不同播放器和它们最适合什么的信息，请查看树莓派论坛。
- en: '|  |'
  id: totrans-546
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You’ll be focusing on playing MP3s from your Pi, because that is a common audio
    file format. What can you use to play them?
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 你将专注于从你的 Pi 上播放 MP3，因为这是一种常见的音频文件格式。你能用什么来播放它们？
- en: OMXPlayer and MP3s
  id: totrans-548
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: OMXPlayer 和 MP3s
- en: When you watch movies or listen to music on a computer, you may use iTunes or
    Windows Media Player. Raspbian has its own equivalent called OMXPlayer that can
    play sounds or videos. Lucky for you, it’s capable of playing MP3 files (or MP3s)—one
    of the most common audio formats.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在电脑上观看电影或听音乐时，你可能使用 iTunes 或 Windows Media Player。Raspbian 有自己的等效程序，称为 OMXPlayer，可以播放声音或视频。幸运的是，它能够播放
    MP3 文件（或 MP3s）——这是最常见的音频格式之一。
- en: '|  |'
  id: totrans-550
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Definition
  id: totrans-551
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: OMXPlayer is a video and audio player that was created for Raspberry Pi.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: OMXPlayer 是为 Raspberry Pi 创建的视频和音频播放器。
- en: '|  |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'If you don’t have an MP3, you can test OMXPlayer using one of the sounds already
    on your Pi. There are quite a few MP3s in the folders included with the Scratch
    software. Open File Manager, and go to this folder to see some of them: /usr/share/scratch/Media/Sounds/Vocals/.
    In the folder, you’ll see both MP3 and WAV format files (see [figure 8.2](#ch08fig02)).'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有 MP3，你可以使用 Pi 上已有的声音测试 OMXPlayer。Scratch 软件附带的一些文件夹中包含相当多的 MP3 文件。打开文件管理器，转到此文件夹查看一些文件：/usr/share/scratch/Media/Sounds/Vocals/。在文件夹中，你会看到
    MP3 和 WAV 格式的文件（见[图 8.2](#ch08fig02)）。
- en: Figure 8.2\. When you install Raspbian on your Pi, it comes with Scratch, which
    has a number of sound files including vocals, sound effects, animal sounds, and
    drum beats.
  id: totrans-555
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.2\. 当你在 Pi 上安装 Raspbian 时，它附带 Scratch，其中包含许多声音文件，包括人声、音效、动物声音和鼓点。
- en: '![](08fig02_alt.jpg)'
  id: totrans-556
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig02_alt.jpg)'
- en: To play an MP3 using OMXPlayer, open Terminal, and enter
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 OMXPlayer 播放 MP3，请打开终端，并输入
- en: '[PRE17]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You should hear a short music clip of a woman singing. Enjoy the song!
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该听到一段女性演唱的简短音乐片段。享受这首歌吧！
- en: '|  |'
  id: totrans-560
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-561
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In Terminal, pressing the up and down arrows cycles through previous commands.
    Press the up arrow once and then press Enter to run the last command again.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，按上箭头和下箭头可以循环查看之前的命令。按一下上箭头然后按回车键可以再次运行最后一个命令。
- en: '|  |'
  id: totrans-563
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Fantastic! Your Pi can speak to you now.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你的 Pi 现在可以和你说话了。
- en: Troubleshooting
  id: totrans-565
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'What if you have speakers or headphones plugged in but don’t hear anything?
    OMXPlayer should automatically detect whether to output the sound to the 3.5 mm
    audio output or HDMI. If it doesn’t, try this command for the headphone jack (3.5
    mm audio output):'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的扬声器或耳机已经插上，但听不到任何声音？OMXPlayer 应该会自动检测是否将声音输出到 3.5 毫米音频输出或 HDMI。如果它没有这样做，请尝试以下命令用于耳机插孔（3.5
    毫米音频输出）：
- en: '[PRE18]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`–o` is a special switch or *flag* that lets OMXPlayer know that you want to
    tell it something. In this case,`–o` stands for *output*, and it tells OMXPlayer
    where you want to output the sound. In this case, you set it to `-o local`, which
    outputs sound to the 3.5 mm (headphone jack) output.'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '`–o` 是一个特殊的开关或 *标志*，它让 OMXPlayer 知道你想告诉它什么。在这种情况下，`–o` 代表 *输出*，它告诉 OMXPlayer
    你希望将声音输出到何处。在这种情况下，你将其设置为 `-o local`，这样声音就会输出到 3.5 毫米（耳机插孔）输出。'
- en: '|  |'
  id: totrans-569
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Switches (flags)**'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '**开关（标志）**'
- en: 'Switches, such as`–o` for output, act like options or special controls for
    a program. They’re common when using the command-line interface. You can usually
    get a list of what switches a program has by making the command print out its
    help information. Most programs that you can run at the command line will give
    you a list of all switches or flags when you type the name of the program and
    then `–h`. The `–h` switch- stands for *help*. Try it with OMXPlayer:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 开关，如用于输出的 `–o`，像选项或程序的特殊控制一样。在命令行界面中使用时很常见。通常，你可以通过让命令打印出其帮助信息来获取程序有哪些开关。大多数你可以在命令行中运行的程序，当你输入程序名然后
    `–h` 时，都会给你一个所有开关或标志的列表。`–h` 开关代表 *帮助*。尝试用 OMXPlayer 来试试：
- en: '[PRE19]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You’ll see a long list of options you can use to control how video and audio
    files are played. Try `-h` with other command-line programs to see what results
    you get.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到一系列你可以用来控制视频和音频文件播放方式的选项。尝试在其他命令行程序中使用 `-h` 来查看你得到的结果。
- en: '|  |'
  id: totrans-574
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'If you need to specify sending the sound to speakers in your monitor, then
    use the `–o` switch and specify `hdmi` for output to the HDMI port:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要指定将声音发送到显示器上的扬声器，那么请使用 `–o` 开关并指定 `hdmi` 以输出到 HDMI 端口：
- en: '[PRE20]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now that you know you can play music, let’s build the circuit and write some
    code to create your DJ Raspi!
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道你可以播放音乐，让我们构建电路并编写一些代码来创建你的 DJ Raspi！
- en: 'Hardware: building the circuit'
  id: totrans-578
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 硬件：构建电路
- en: Building time! You’re building a circuit on your breadboard to detect or listen
    to buttons. When a button is pressed, your circuit will send electricity flowing
    to a GPIO pin on your Pi. You’ll start by connecting the Pi’s GPIO pins to the
    breadboard using the ribbon cable and GPIO breakout board. Refer back to [chapter
    6](kindle_split_016.html#ch06) (section 6.1) if you need to recall how to set
    this up.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 建造时间！你正在面包板上构建一个电路来检测或监听按钮。当按钮被按下时，你的电路将向你的Pi的GPIO引脚发送电流。你将首先使用扁平电缆和GPIO扩展板将Pi的GPIO引脚连接到面包板。如果你需要回忆如何设置，请参阅[第6章](kindle_split_016.html#ch06)（6.1节）。
- en: '|  |'
  id: totrans-580
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**A reminder about numbers**'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于数字的提醒**'
- en: Like finding a seat in a stadium, we’ll refer to the holes on a breadboard using
    the prefix *BB*. So the hole located in row 25, column a, is *BB25a*. Similarly,
    we’ll refer to the Pi’s GPIO pins using the prefix *GP* and then the pin number.
    So GPIO pin 24 is called *GP24* for short.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在体育场里找座位一样，我们将使用前缀*BB*来指代面包板上的孔。所以位于第25行，第a列的孔是*BB25a*。同样，我们将使用前缀*GP*来指代Pi的GPIO引脚，然后是引脚号。所以GPIO引脚24简称为*GP24*。
- en: '|  |'
  id: totrans-583
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Wiring a button
  id: totrans-584
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 焊接按钮
- en: Let’s get busy wiring the buttons. There are many different types of buttons,
    but you’ll be using a mini pushbutton (see [figure 8.3](#ch08fig03)). These buttons
    commonly come in Raspberry Pi kits along with jumper wires, resistors, and LEDs.
    If you need to purchase them, you can find them at many online electronics retailers
    in packs of 10 or 20 for less than the cost of a cheeseburger. With the parts
    gathered, let’s assemble the circuit.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始焊接按钮。按钮有很多不同的类型，但你会使用一个迷你按钮（见[图8.3](#ch08fig03)）。这些按钮通常与跳线、电阻和LED一起出现在Raspberry
    Pi套件中。如果你需要购买，你可以在许多在线电子产品零售商那里以低于汉堡包的价格购买10个或20个的包装。收集好零件后，让我们组装电路。
- en: Figure 8.3\. The mini pushbutton makes a nice clicking sound when you press
    the black button in the middle. Pressing it acts like closing a switch to complete
    a circuit.
  id: totrans-586
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.3\. 当你按下中间的黑按钮时，迷你按钮会发出清脆的点击声。按下它就像闭合开关一样，完成电路。
- en: '![](08fig03.jpg)'
  id: totrans-587
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig03.jpg)'
- en: Circuit sketch
  id: totrans-588
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 电路草图
- en: The circuit diagram for the DJ Raspi is shown in [figure 8.4](#ch08fig04). To
    listen to whether a button is being pressed, you’ll have electricity (+3.3 V)
    flow from your Pi to the button. When the button is pressed, the electricity will
    flow through the button and then split. A small amount of electricity will flow
    to GPIO pin 6 (GP06) and the rest will flow through the 10K ohm resistor and then
    to ground (0 V). Let’s put it together on the breadboard.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: DJ Raspi的电路图显示在[图8.4](#ch08fig04)中。为了监听按钮是否被按下，你需要从你的Pi到按钮流动电（+3.3 V）。当按钮被按下时，电流将通过按钮并分流。一小部分电流将流向GPIO引脚6（GP06），其余的将通过10K欧姆电阻然后流向地（0
    V）。让我们在面包板上组装起来。
- en: Figure 8.4\. The circuit diagram for the first button in the DJ Raspi project
    shows how electricity will flow through the circuit. The button is a switch that
    allows electricity to flow to GP06 and ground (-) when it’s pressed or closed.
  id: totrans-590
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.4\. DJ Raspi项目中的第一个按钮的电路图显示了电流如何通过电路流动。按钮是一个开关，当按下或闭合时，允许电流流向GP06和地（-）。
- en: '![](08fig04_alt.jpg)'
  id: totrans-591
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig04_alt.jpg)'
- en: 'Let’s build the button circuit on the breadboard and program your Pi to know
    when the button is being pressed. You’ll give your Pi the ability to feel the
    button being pressed, by wiring up the button in this order:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在面包板上构建按钮电路，并编程你的Pi以知道何时按下按钮。你将通过以下顺序连接按钮，使你的Pi能够感觉到按钮被按下：
- en: '**1**.  Add the mini pushbutton to the breadboard.'
  id: totrans-593
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  将迷你按钮添加到面包板上。'
- en: '**2**.  Connect a jumper wire from 3.3 volts to the button. You’ll use the
    positive power bus (+) that runs along the side of the breadboard.'
  id: totrans-594
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  从3.3伏特连接一根跳线到按钮上。你将使用沿着面包板侧面的正电源总线（+）。'
- en: '**3**.  Add the resistor from the button to the negative power bus (-), also
    called ground.'
  id: totrans-595
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**.  将电阻从按钮连接到负电源总线（-），也称为地。'
- en: '**4**.  Connect the second jumper wire from the button to GP06 (GPIO pin 6).'
  id: totrans-596
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**.  将第二根跳线从按钮连接到GP06（GPIO引脚6）。'
- en: The completed circuit for one button will look like what you see in [figure
    8.5](#ch08fig05).
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 一个按钮的完整电路看起来就像你在[图8.5](#ch08fig05)中看到的那样。
- en: Figure 8.5\. The mini pushbutton will have 3.3 volts connected to it from the
    positive power rail. When the button is pressed, power flows through the button
    and splits. Some electrical current goes to GP06 (GPIO pin 6), and the rest goes
    through the resistor and then to the negative power bus (-).
  id: totrans-598
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.5。迷你按钮将从正电源轨连接到3.3伏特。当按钮被按下时，电流通过按钮并分流。一部分电流流向GP06（GPIO引脚6），其余的电流通过电阻然后流向负电源总线（-）。
- en: '![](08fig05_alt.jpg)'
  id: totrans-599
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig05_alt.jpg)'
- en: 'Don’t forget, nothing will happen when you press the button. You have to program
    your Pi to react to this new-found sense of touch. Let’s go through the steps
    to build the circuit:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，当你按下按钮时，什么也不会发生。你必须编程你的树莓派来响应这种新发现的触觉。让我们一步步来构建电路：
- en: Step 1\. Add the mini pushbutton
  id: totrans-601
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第1步。添加迷你按钮
- en: Let’s look at how pushbuttons work before we go on. If you had X-ray goggles,
    you would see that the left and right legs at the top of the button are connected.
    Similarly, the left and right legs along the bottom of the button are connected.
    The top and the bottom of the button aren’t connected.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们看看按钮是如何工作的。如果你有X光眼镜，你会看到按钮顶部的左右引脚是相连的。同样，按钮底部的左右引脚也是相连的。按钮的顶部和底部是不相连的。
- en: But when you press the button, [figure 8.6](#ch08fig06) shows what happens.
    Pressing the button pushes down a small metal bar so that the top and bottom are
    connected. We say the switch is *closed*. When you let go of the button, the spring
    in the button pushes the metal bar back up, and the switch is open again. Grab
    your mini pushbutton, and let’s insert it into the breadboard.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 但当你按下按钮时，[图8.6](#ch08fig06) 展示了会发生什么。按下按钮会使一个小金属棒向下移动，使得顶部和底部相连。我们说开关是*闭合*的。当你松开按钮时，按钮中的弹簧会将金属棒推回，开关再次打开。拿起你的迷你按钮，让我们将其插入到面包板上。
- en: Figure 8.6\. In a button, the legs are connected along the top and are separately
    connected along the bottom. When the button is pressed, the top and bottom are
    connected by a small metal bar.
  id: totrans-604
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.6。在按钮中，引脚在顶部相连，而在底部则是分别相连的。当按钮被按下时，顶部和底部通过一个小金属棒相连。
- en: '![](08fig06_alt.jpg)'
  id: totrans-605
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig06_alt.jpg)'
- en: '|  |'
  id: totrans-606
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-607
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You’ll need to push the button into the breadboard very firmly. If the button
    legs aren’t lined up with the breadboard holes, you may accidentally bend some
    of the button legs. Don’t worry—you can bend them back and try again. If a leg
    breaks off, use a new button.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将按钮非常牢固地推入面包板。如果按钮引脚没有与面包板孔对齐，你可能会不小心弯曲一些按钮引脚。不用担心——你可以将它们弯曲回来再试一次。如果引脚断裂，请使用新的按钮。
- en: '|  |'
  id: totrans-609
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'You’re going to put the button in rows 23 and 25 along columns d and g on the
    breadboard. Connect the legs:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 你将把按钮放在面包板列d和g的行23和25上。连接引脚：
- en: 'Top legs: *BB23d* and *BB23g*'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶部引脚：*BB23d* 和 *BB23g*
- en: 'Bottom legs: *BB25d* and *BB25g*'
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 底部引脚：*BB25d* 和 *BB25g*
- en: When the button is inserted, it will look like [figure 8.7](#ch08fig07). Double-check
    that it’s pushed down into the breadboard so that all the legs will make a good
    connection. Good job—you just completed the trickiest part!
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 当按钮插入时，它看起来像[图8.7](#ch08fig07)。再次确认它已经按下并推入面包板，以确保所有引脚都能良好连接。干得好——你刚刚完成了最棘手的部分！
- en: Figure 8.7\. Align the pushbutton with the breadboard holes, and then press
    it down into the breadboard. Make sure you press it so the button legs are down
    into the breadboard holes and make a good connection. If you accidentally bend
    the legs, don’t worry! Just bend them back and try again.
  id: totrans-614
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.7。将按钮与面包板孔对齐，然后按下它进入面包板。确保你按下它，使按钮引脚向下进入面包板孔并良好连接。如果你不小心弯曲了引脚，不用担心！只需将它们弯曲回来再试一次。
- en: '![](08fig07_alt.jpg)'
  id: totrans-615
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig07_alt.jpg)'
- en: Step 2\. Connect a jumper wire from 3.3 volts to the button.
  id: totrans-616
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第2步。从3.3伏特连接一根跳线到按钮。
- en: You need to connect the button to a source of electrical current. You’ll use
    the positive power rail along the edge of the breadboard as the source of power
    (you could also directly connect the jumper to the 3V3 pin on the breakout board).
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将按钮连接到电流源。你将使用面包板边缘的正电源轨作为电源（你也可以直接将跳线连接到扩展板上的3V3引脚）。
- en: Connect the jumper wire from the *positive power bus* (+) to *BB25a*. Remember,
    you can connect the jumper to any hole along the power rail (it has a red line
    next to it). When you’ve added the wire, it will look like [figure 8.8](#ch08fig08).
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 将跳线从*正电源总线*（+）连接到*BB25a*。记住，你可以将跳线连接到电源轨上的任何孔（它旁边有一条红线）。当你添加了电线后，它看起来像[图8.8](#ch08fig08)。
- en: Figure 8.8\. The jumper connects power (3.3 volts) to the bottom of the button.
  id: totrans-619
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.8\. 跳线将电源（3.3伏特）连接到按钮的底部。
- en: '![](08fig08_alt.jpg)'
  id: totrans-620
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig08_alt.jpg)'
- en: Fantastic! Now you have electricity reaching the bottom legs of the button.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在电流已经到达按钮的底部腿。
- en: Step 3\. Add the 10K ohm resistor
  id: totrans-622
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第3步\. 添加10K欧姆电阻
- en: Time to connect your 10K ohm resistor. It has bands of brown, black, and orange
    followed by a fourth gold or silver band. *Remember that electricity will flow
    either way through a resistor, so it doesn’t matter which way you place it.*
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候连接您的10K欧姆电阻了。它有棕色、黑色和橙色的带子，后面跟着一个金色或银色的第四个带子。*记住，电流可以通过电阻双向流动，所以您放置的方向无关紧要。*
- en: You’re connecting the resistor from the top of the button to the negative power
    bus (-). This is the set of holes with a blue stripe next to it running along
    the edge of the breadboard.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在将电阻从按钮的顶部连接到负电源总线（-）。这是一组带有蓝色条纹的孔，沿着面包板的边缘运行。
- en: Insert one end of the resistor into *BB23i* and the other end into the *negative
    power bus (-)*. You can choose any hole along the blue line. Once the resistor
    is added, you’ll have something that looks like [figure 8.9](#ch08fig09). Now
    you’re ready for the final step.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 将电阻的一端插入*BB23i*，另一端插入*负电源总线（-）*。您可以选择蓝色线上的任何孔。一旦添加了电阻，您将得到类似[图8.9](#ch08fig09)的外观。现在您已经准备好进行最后一步了。
- en: Figure 8.9\. Add the resistor. Make sure its ends are pushed down into the breadboard
    holes.
  id: totrans-626
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.9\. 添加电阻。确保其两端被推入面包板孔中。
- en: '![](08fig09_alt.jpg)'
  id: totrans-627
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig09_alt.jpg)'
- en: Step 4\. Add the jumper to a GPIO pin
  id: totrans-628
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第4步\. 将跳线添加到GPIO引脚
- en: A small amount of electricity needs to reach a GPIO pin (you’ll use GP06), so
    you need a jumper wire from the top of the button to a hole next to the GPIO pin.
    To make this connection, add a jumper from *BB23a* to *BB16a*. [Figure 8.10](#ch08fig10)
    shows how it looks.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一小部分电流到达一个GPIO引脚（您将使用GP06），因此您需要从按钮的顶部到GPIO引脚旁边的孔的跳线。为了建立这个连接，请从*BB23a*到*BB16a*添加一个跳线。[图8.10](#ch08fig10)显示了其外观。
- en: Figure 8.10\. The jumper connects the top of the button to GP06\. Later, you’ll
    set your Pi to listen for electrical input on this GPIO pin.
  id: totrans-630
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.10\. 跳线将按钮的顶部连接到GP06。稍后，您将设置您的Pi以监听此GPIO引脚上的电输入。
- en: '![](08fig10_alt.jpg)'
  id: totrans-631
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig10_alt.jpg)'
- en: When the button is pressed, a small amount of electricity will flow to GP06
    and through the resistor to ground. Nothing happens yet, but next you’ll write
    a Python program to detect that electricity and play some sounds.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 当按钮被按下时，一小部分电流将流向GP06并通过电阻流向地。目前还没有发生任何事情，但接下来您将编写一个Python程序来检测这种电流并播放一些声音。
- en: Adding the second button
  id: totrans-633
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加第二个按钮
- en: Let’s add a second button to the board. [Figure 8.11](#ch08fig11) shows what
    it will look like when it’s done.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在板上添加第二个按钮。[图8.11](#ch08fig11)显示了完成后的样子。
- en: Figure 8.11\. Add the second pushbutton just below the first one. The wiring
    is the same, but you’ll connect it to GP19 (GPIO pin 19). Any available GPIO pin
    will work, but remember that your code will have to reflect the GPIO pins you
    select.
  id: totrans-635
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.11\. 在第一个按钮下方添加第二个按钮。布线方式相同，但您将将其连接到GP19（GPIO引脚19）。任何可用的GPIO引脚都可以，但请记住，您的代码将必须反映您选择的GPIO引脚。
- en: '![](08fig11_alt.jpg)'
  id: totrans-636
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig11_alt.jpg)'
- en: To add another button, you’ll create the same circuit but place the button in
    rows 28 and 30 on your breadboards. You’ll wire the button to GP19.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加另一个按钮，您将创建相同的电路，但将按钮放置在面包板上的第28行和第30行。您将按钮连接到GP19。
- en: Step 1\. Add the mini pushbutton
  id: totrans-638
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第1步\. 添加迷你按钮
- en: Insert the button so that the top legs are in *BB28d* and *BB28g* and the bottom
    legs are in *BB30d* and *BB30g*.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 将按钮插入，使顶部腿位于*BB28d*和*BB28g*，底部腿位于*BB30d*和*BB30g*。
- en: Step 2\. Connect a jumper wire from 3.3 volts to the button
  id: totrans-640
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第2步\. 从3.3伏特连接跳线到按钮
- en: You need to connect power from the positive power bus to the bottom of the button.
    The power rail is the line of holes with a red line running next to it. Insert
    a jumper from anywhere along the *positive power bus (+)* to *BB30a*.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将来自正电源总线（+）的电源连接到按钮的底部。电源轨是带有红色线条的孔线。从正电源总线（+）的任何位置插入一个跳线到*BB30a*。
- en: Step 3\. Add the 10K ohm resistor
  id: totrans-642
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第3步\. 添加10K欧姆电阻
- en: To prevent too much electricity from flowing when the button is pressed, you
    need to add a resistor. As before, you’ll add a 10K ohm resistor (color bands
    are brown, black, and orange) to connect the top of the button to the negative
    power bus (-).
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止按下按钮时电流过多，您需要添加一个电阻。与之前一样，您将添加一个10K欧姆电阻（颜色带为棕色、黑色和橙色），将按钮的顶部连接到负电源总线（-）。
- en: Insert one end of the resistor into *BB28i* and the other end into the *negative
    power bus (-)*. Any hole along the blue line will work.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 将电阻的一端插入*BB28i*，另一端插入负电源总线（-）。蓝色线上的任何孔都可以。
- en: Step 4\. Add the jumper to a GPIO pin
  id: totrans-645
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 步骤4。将跳线连接到GPIO引脚
- en: Finally, when the button is pressed, you need electricity to flow to a GPIO
    pin. For the second button, you’re using GP19. Connect a jumper wire from *BB28a*
    to *BB18a* (GP19).
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当按钮被按下时，需要电流流向GPIO引脚。对于第二个按钮，您使用GP19。从*BB28a*连接跳线到*BB18a*（GP19）。
- en: Terrific! The second button is connected, and you’ve completed the button circuit.
    Let’s call the first button Button 1\. It’s wired to GP06\. The second button,
    Button 2, is wired to GP19\. Now that everything is wired up, let’s write code
    for it!
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！第二个按钮已连接，您已完成了按钮电路。让我们称第一个按钮为按钮1。它连接到GP06。第二个按钮，按钮2，连接到GP19。现在一切都已经连接好，让我们为它编写代码！
- en: 'Software: the DJ Raspi program'
  id: totrans-648
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 软件：DJ Raspi程序
- en: 'Your project is to turn your Pi into an awesome music player that is controlled
    by buttons. Here’s how it will work:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 您的项目是将您的树莓派变成一个由按钮控制的出色音乐播放器。以下是它的工作方式：
- en: Pressing Button 1 makes the Pi play random music clips.
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下按钮1使树莓派播放随机音乐片段。
- en: Pressing Button 2 makes the Pi play random vocal (singing) sounds.
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下按钮2使树莓派播放随机声乐（唱歌）声音。
- en: 'You’ll need one of the following to hear the sounds:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要以下设备之一来听到声音：
- en: Headphones
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 耳机
- en: Powered computer speakers
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有源电脑扬声器
- en: Your Pi connected via HDMI to a TV with built-in speakers
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的树莓派通过HDMI连接到内置扬声器的电视。
- en: Let’s think through how this program will work. [Figure 8.12](#ch08fig12) shows
    a quick diagram of the logic.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下这个程序将如何工作。[图8.12](#ch08fig12)显示了一个逻辑的快速图。
- en: Figure 8.12\. A flow diagram showing how the DJ Raspi program should work. The
    program must gather a list of sounds at the beginning and then check whether the
    buttons are pressed. The buttons will be checked over and over again.
  id: totrans-657
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.12。一个流程图，显示了DJ Raspi程序应该如何工作。程序必须在开始时收集声音列表，然后检查按钮是否被按下。按钮将反复检查。
- en: '![](08fig12_alt.jpg)'
  id: totrans-658
  prefs: []
  type: TYPE_IMG
  zh: '![图8.12](08fig12_alt.jpg)'
- en: 'Let’s write the code in this order:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按以下顺序编写代码：
- en: '**1**.  Set up your Pi to listen to input coming from the buttons.'
  id: totrans-660
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 设置您的树莓派以侦听来自按钮的输入。'
- en: '**2**.  Gather a list of music and vocal sounds.'
  id: totrans-661
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 收集音乐和声乐声音的列表。'
- en: '**3**.  Program a loop to check the buttons. If they’re pressed, then play
    random sounds.'
  id: totrans-662
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 编写一个循环来检查按钮。如果它们被按下，则播放随机声音。'
- en: You’ll try to use functions along the way to simplify your code.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在过程中尝试使用函数来简化您的代码。
- en: Let’s begin! Open IDLE by choosing Python 3 under Menu > Programming. In the
    Python Shell, start a new program by pressing Ctrl-N or selecting File > New Window.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始！通过选择菜单>编程下的Python 3来打开IDLE。在Python Shell中，通过按Ctrl-N或选择文件>新建窗口来启动一个新程序。
- en: 'Setting up the Pi: initializing the buttons'
  id: totrans-665
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置树莓派：初始化按钮
- en: In the IDLE text editor, you’ll start by loading the Python libraries you’ll
    need to use. You’ll also set up a couple of the Pi’s GPIO ports to listen for
    electrical signals coming in from the buttons being pressed. In the flow diagram,
    this is the first step of initializing the buttons (see [figure 8.13](#ch08fig13)).
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 在IDLE文本编辑器中，您将首先加载您将需要使用的Python库。您还将设置树莓派的几个GPIO端口以侦听来自按下按钮的电信号。在流程图中，这是初始化按钮的第一步（见[图8.13](#ch08fig13)）。
- en: Figure 8.13\. The first step is to set up the buttons as inputs. This will mean
    your Pi is ready to check whether it’s detecting any voltage coming in, which
    will happen when a button is pressed.
  id: totrans-667
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.13。第一步是设置按钮作为输入。这意味着您的树莓派将准备好检查是否检测到任何电压输入，这将在按钮被按下时发生。
- en: '![](08fig13_alt.jpg)'
  id: totrans-668
  prefs: []
  type: TYPE_IMG
  zh: '![图8.13](08fig13_alt.jpg)'
- en: 'When you set up the GPIO ports, you use `GPIO.IN` to tell the Pi that you plan
    to use that port as an input. To prepare your Pi for input to the GPIO pins, you
    need to tell it which pins you plan to use. Based on the circuit, you’re using
    these pins as inputs:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 当您设置GPIO端口时，您使用`GPIO.IN`来告诉树莓派您计划将该端口用作输入。为了准备树莓派以输入GPIO引脚，您需要告诉它您计划使用哪些引脚。根据电路，您正在使用以下引脚作为输入：
- en: GP06 for Button 1
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GP06用于按钮1
- en: GP19 for Button 2
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GP19用于按钮2
- en: The following listing shows how you can use the `GPIO.setup` command to set
    a GPIO pin to input.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了您如何使用`GPIO.setup`命令将GPIO引脚设置为输入。
- en: Listing 8.1\. Setting up GPIO pins for input
  id: totrans-673
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.1。设置GPIO引脚为输入
- en: '![](221fig01_alt.jpg)'
  id: totrans-674
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1](221fig01_alt.jpg)'
- en: You may notice that you import a new `os` module. We’ll talk about why you need
    that in the next section when you gather your lists of sound files.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到你导入了新的`os`模块。我们将在下一节讨论为什么你需要它，当你收集声音文件列表时。
- en: Getting a list of sounds
  id: totrans-676
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取声音列表
- en: Lists are everywhere around you. You make lists of things you need to do, gifts
    to buy, places you want to visit, and favorite things, such as your top-10 movies
    or books.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 列表无处不在。你列出你需要做的事情、要买的礼物、你想去的地方，以及你最喜欢的东西，比如你最喜欢的10部电影或书籍。
- en: 'Your DJ Raspi needs a *list* of sound files: one for music clips (or loops)
    and one for vocals. Based on the design, you need to get a list of files from
    a folder on your Pi, and then you need to select a random sound file from the
    list and play it (see [figure 8.14](#ch08fig14)).'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 你的DJ Raspi需要一个声音文件的*列表*：一个用于音乐片段（或循环）和一个用于人声。根据设计，你需要从你的Pi上的一个文件夹中获取文件列表，然后你需要从列表中选择一个随机声音文件并播放它（参见[图8.14](#ch08fig14)）。
- en: Figure 8.14\. The next step of the DJ Raspi program gets a list of sound files.
    Later, you’ll add the part that uses the button to trigger playing random sounds
    from the lists.
  id: totrans-679
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.14。DJ Raspi程序的下一步是获取一组声音文件。稍后，你将添加使用按钮触发从列表中播放随机声音的部分。
- en: '![](08fig14_alt.jpg)'
  id: totrans-680
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig14_alt.jpg)'
- en: In Python, you can create lists or groups of things easily. Let’s look at some
    examples.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，你可以轻松地创建列表或事物组。让我们看看一些例子。
- en: 'Let’s create a list of basketball player names. Open IDLE to the Python 3.x
    Shell by choosing Python 3 under Menu > Programming. In the Python Shell, make
    a list:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个篮球运动员名字的列表。通过在菜单>编程下选择Python 3.x Shell来打开IDLE。在Python Shell中，创建一个列表：
- en: '[PRE21]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Print out the list like this, and you’ll see what’s inside:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这种方式打印列表，你就会看到里面的内容：
- en: '[PRE22]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: To make a list of the items, put them in a set of square brackets (`[]`) and
    separate each item with a comma (see [figure 8.15](#ch08fig15)). For lists of
    strings, each item in the list has to have quotation marks around it. Pretty simple!
    That’s the Python way.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个项目列表，将它们放入一组方括号（`[]`）中，并用逗号分隔每个项目（参见[图8.15](#ch08fig15)）。对于字符串列表，列表中的每个项目都必须用引号包围。很简单！这就是Python的方式。
- en: Figure 8.15\. You make lists by using square brackets to enclose a set of things.
    Each thing in the list should be separated with a comma. Python will even let
    you make lists that combine different types of data, like strings and integers.
  id: totrans-687
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.15。你通过使用方括号括起来的一组事物来创建列表。列表中的每个项目都应该用逗号分隔。Python甚至允许你创建包含不同类型数据的列表，如字符串和整数。
- en: '![](08fig15_alt.jpg)'
  id: totrans-688
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig15_alt.jpg)'
- en: 'Try creating a list called `favorite_numbers`, like so:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试创建一个名为`favorite_numbers`的列表，如下所示：
- en: '[PRE23]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Display the contents of the list using `print`:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`print`显示列表的内容：
- en: '[PRE24]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '|  |'
  id: totrans-693
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-694
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: When making a list of numbers, you don’t use any quotation marks.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 当制作数字列表时，你不需要使用任何引号。
- en: '|  |'
  id: totrans-696
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Enjoy making lists of some of your favorite things!
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 享受制作你最喜欢的东西的列表！
- en: '|  |'
  id: totrans-698
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**More things you can do with lists**'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表可以做的更多事情**'
- en: There are lots of things you can do with lists! Let’s try a few.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用列表做很多事情！让我们试几个。
- en: 'You make a list longer by adding more items to it. To do this, use the `append`
    method. Let’s add the name Stephen Curry to the list of `basketball_players`.
    Here is how you can use `append` to do that:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过向列表中添加更多项目来使列表更长。为此，请使用`append`方法。让我们向`basketball_players`列表中添加Stephen
    Curry的名字。以下是使用`append`来完成此操作的方法：
- en: '[PRE25]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Use `print` to see the result:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`print`来查看结果：
- en: '[PRE26]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Excellent! To remove an item from a list you can use the `remove` method. If
    you wanted to take John Wall out of the list, write
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！要从列表中删除一个项目，你可以使用`remove`方法。如果你想从列表中移除John Wall，可以这样写
- en: '[PRE27]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Print the list again to see if it worked:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 再次打印列表以查看它是否工作：
- en: '[PRE28]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Wonderful! If you need to put a list in order alphabetically or from lowest
    to highest, you can use the `sort` method like so:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！如果你需要按字母顺序或从低到高对列表进行排序，你可以使用`sort`方法，如下所示：
- en: '[PRE29]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Check that it worked by printing the list to the screen:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将列表打印到屏幕上来检查它是否工作：
- en: '[PRE30]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The numbers are all sorted! This works on lists made of strings as well. If
    you sort the list of `basketball_players`, it puts them in alphabetical order
    based on the first letter of each string. Python has many built-in methods for
    lists.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 数字都排序了！这也适用于字符串列表。如果你对`basketball_players`列表进行排序，它将根据每个字符串的第一个字母按字母顺序排列。Python为列表提供了许多内置方法。
- en: Check the online Python documentation^([[a](#ch08fn01a)]) for more things you
    can do with lists. Then sit back and enjoy thinking about all you can do with
    them in your future programs.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 查阅在线Python文档^([[a](#ch08fn01a)])以获取更多关于列表的操作。然后坐下来享受思考你可以在未来的程序中使用它们的所有可能性。
- en: ^a
  id: totrans-715
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^a
- en: ''
  id: totrans-716
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Go to the Python website for more information on things you can do with lists:
    [https://docs.python.org/3.4/tutorial/datastructures.html](https://docs.python.org/3.4/tutorial/datastructures.html).'
  id: totrans-717
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 前往Python网站获取有关列表操作的信息：[https://docs.python.org/3.4/tutorial/datastructures.html](https://docs.python.org/3.4/tutorial/datastructures.html)。
- en: '|  |'
  id: totrans-718
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: For your DJ Raspi, let’s see how to
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的DJ Raspi，让我们看看如何
- en: Get the value of an item stored in a list.
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取列表中存储的项目值。
- en: Get the length of a list.
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取列表的长度。
- en: Getting a value of an item stored in a list
  id: totrans-722
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取列表中存储的项目值
- en: 'Let’s start with a fresh list of basketball players:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个新的篮球运动员列表开始：
- en: '[PRE31]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you’ve seen, lists store information. What you might not know is that each
    spot in a list is given a number called the *index*. The index of the first item
    in the list is zero (0). The second item has an index of 1\. The third item’s
    index is 2, and so on. To get the third item in the `basketball_players` list,
    you’d type
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，列表存储信息。你可能不知道的是，列表中的每个位置都有一个称为*索引*的数字。列表中第一个项目的索引是零（0）。第二个项目的索引是1。第三个项目的索引是2，以此类推。要获取`basketball_players`列表中的第三个项目，你将输入
- en: '[PRE32]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you want to search a list and have Python tell you the index of where an
    item first appears in the list, you use the `index` method:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要搜索列表，并让Python告诉你项目在列表中首次出现的位置索引，你可以使用`index`方法：
- en: '[PRE33]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If the item isn’t in the list, Python will give you an error saying so:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目不在列表中，Python会给出错误信息：
- en: '[PRE34]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '|  |'
  id: totrans-731
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-732
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that the index for lists starts counting at 0, not 1! For example,
    `basketball_players[1]` gives you `"Lebron James"`, the second item in the list.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，列表的索引从0开始计数，而不是1！例如，`basketball_players[1]`将给你“Lebron James”，这是列表中的第二个项目。
- en: '|  |'
  id: totrans-734
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[Figure 8.16](#ch08fig16) shows examples of the indexes for a list and how
    you can get a specific item in a list.'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8.16](#ch08fig16) 展示了列表的索引示例以及如何获取列表中的特定项。'
- en: Figure 8.16\. Sets of things can be stored in lists. You can retrieve items
    from the list using the index, which represents the position of an item in the
    list. The index of a list starts at 0.
  id: totrans-736
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.16\. 可以将事物集合存储在列表中。你可以使用索引从列表中检索项目，索引代表项目在列表中的位置。列表的索引从0开始。
- en: '![](08fig16_alt.jpg)'
  id: totrans-737
  prefs: []
  type: TYPE_IMG
  zh: '![图片](08fig16_alt.jpg)'
- en: Getting the length of a list
  id: totrans-738
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取列表的长度
- en: 'Finally, there are times when you’ve loaded information into a list and you
    need a way to check how long the list is. Use the `len()` function to do that:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有时你已经将信息加载到列表中，需要一种方法来检查列表的长度。使用`len()`函数来完成：
- en: '[PRE35]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Great job—you know the basics of lists. Now let’s see how you can create lists
    of MP3s.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好——你已掌握了列表的基础知识。现在让我们看看如何创建MP3列表。
- en: Building a list of sound files with the os library
  id: totrans-742
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用os库构建声音文件列表
- en: To make the DJ Raspi project work, you need to
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 要使DJ Raspi项目工作，你需要
- en: '**1**.  Grab two lists of sound files from folders on your Pi.'
  id: totrans-744
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 从你的Pi上的文件夹中抓取两组声音文件列表。'
- en: '**2**.  Make OMXPlayer play sound files from Python as part of the DJ Raspi
    program.'
  id: totrans-745
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 在DJ Raspi程序中，使用OMXPlayer从Python播放声音文件。'
- en: Let’s learn how.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何。
- en: The Pi has both these abilities through a Python module called the `os` module
    (OS stands for *operating system*). With it, you can run operating system commands
    (things you can type in the Terminal window) from your Python programs. This is
    fantastic, because it means you can get lists of files and also call OMXPlayer
    to play a certain file—exactly what you need!
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: Pi通过一个名为`os`模块（OS代表*操作系统*）的Python模块具有这两种能力。使用它，你可以从Python程序中运行操作系统命令（你可以在终端窗口中输入的命令）。这太棒了，因为它意味着你可以获取文件列表，也可以调用OMXPlayer来播放特定文件——这正是你所需要的！
- en: 'Getting a list of files from a folder: using listdir()'
  id: totrans-748
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从文件夹中获取文件列表：使用listdir()
- en: 'Your Pi has some sound files on it already, as you saw in section 8.1\. You’ll
    use the files in these two folders:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在第8.1节中看到的，你的Pi上已经有一些声音文件。你将使用这两个文件夹中的文件：
- en: /usr/share/scratch/Media/Sounds/Music Loops/
  id: totrans-750
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: /usr/share/scratch/Media/Sounds/Music Loops/
- en: /usr/share/scratch/Media/Sounds/Vocals/
  id: totrans-751
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: /usr/share/scratch/Media/Sounds/Vocals/
- en: 'The `os` library provides a built-in function, `os.listdir(some_path)`, to
    get a list of files at `some_path`. To get a list of Scratch music loops and vocals,
    use these commands:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: '`os`库提供了一个内置函数`os.listdir(some_path)`，用于获取`some_path`路径下的文件列表。要获取Scratch音乐循环和声乐的列表，使用以下命令：'
- en: '[PRE36]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If you print the lists, you’ll have something that looks like this:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打印列表，你将得到类似这样的内容：
- en: '[PRE37]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Wow—you have nice-looking lists! But wait: it looks like `sounds_vocals` has
    WAV (.wav) files and MP3s. Let’s filter out the WAVs so you only have MP3s.'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 哇——你有一些看起来很棒的列表！但是等等：看起来`sounds_vocals`有WAV（.wav）文件和MP3。让我们过滤掉WAV文件，这样你只剩MP3。
- en: Filtering for Only MP3s
  id: totrans-757
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 仅过滤MP3文件
- en: 'To filter a list, you can use Python’s *list-comprehension* feature. List comprehension
    is a quick way of creating lists. When you use it, you can include certain conditions
    or operations that are applied to the items in the list, such as making sure all
    the files in the list end with .mp3\. Let’s look at how you can use list comprehension
    to create a new list from your old list, but only keep the files in the list that
    end with .mp3:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 要过滤列表，你可以使用Python的*列表推导*功能。列表推导是一种快速创建列表的方法。当你使用它时，你可以包括某些条件或应用于列表项的操作，例如确保列表中的所有文件都以.mp3结尾。让我们看看如何使用列表推导从旧列表创建新列表，但只保留以.mp3结尾的文件：
- en: '[PRE38]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The list comprehension has a `for` loop inside it. In this case, Python is looping
    through the list of sound files in your original list of sounds. For each item
    in the list, Python only adds it to the new sounds list if it matches the condition
    of being a file ending with .mp3.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式内部有一个`for`循环。在这种情况下，Python正在遍历原始声音列表中的声音文件列表。对于列表中的每个项目，Python只有在它符合以.mp3结尾的条件时，才会将其添加到新的声音列表中。
- en: Playing a sound when a button is pressed
  id: totrans-761
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 按钮被按下时播放声音
- en: Next in your plan is to write the code that will play a random sound from your
    lists when a button is pressed. You’ll need this to be in a loop so the buttons
    are repeatedly checked to see whether they’re being pressed (see [figure 8.17](#ch08fig17)).
    Let’s start by creating the game’s title and creating the main game loop.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的计划中的下一步是编写代码，当按钮被按下时，将从你的列表中播放一个随机声音。你需要将其放在一个循环中，以便反复检查按钮是否被按下（见[图8.17](#ch08fig17)）。让我们首先创建游戏的标题和创建主游戏循环。
- en: Figure 8.17\. The main part of the DJ Raspi program is the loop to check the
    buttons. You’ll use a `while` loop to check the buttons over and over again. If
    one of them is pressed, you’ll tell Raspbian to play a random sound using OMXPlayer.
  id: totrans-763
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.17\. DJ Raspi程序的主要部分是检查按钮的循环。你将使用一个`while`循环来反复检查按钮。如果其中一个被按下，你将告诉Raspbian使用OMXPlayer播放一个随机声音。
- en: '![](08fig17_alt.jpg)'
  id: totrans-764
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig17_alt.jpg)'
- en: Loop to check the buttons
  id: totrans-765
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 检查按钮的循环
- en: First let’s add some code to display a title screen and the DJ Raspi instructions.
    Feel free to make the title screen fancier!
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们添加一些代码来显示标题屏幕和DJ Raspi的说明。你可以随意使标题屏幕更华丽！
- en: Listing 8.2\. DJ Raspi title screen
  id: totrans-767
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.2\. DJ Raspi标题屏幕
- en: '![](229fig01_alt.jpg)'
  id: totrans-768
  prefs: []
  type: TYPE_IMG
  zh: '![](229fig01_alt.jpg)'
- en: Now let’s write the code to loop over and over again to check whether either
    button is being pressed. When a button is pressed, the GPIO pin will give you
    a response of True, and you can then call a function to play a random MP3.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写代码来反复检查是否按下了任一按钮。当按钮被按下时，GPIO引脚将给你一个True的响应，然后你可以调用一个函数来播放一个随机的MP3。
- en: Listing 8.3\. DJ Raspi game loop
  id: totrans-770
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.3\. DJ Raspi游戏循环
- en: '![](230fig01_alt.jpg)'
  id: totrans-771
  prefs: []
  type: TYPE_IMG
  zh: '![](230fig01_alt.jpg)'
- en: The code repeatedly checks whether Button 1 or Button 2 is pressed. If Button
    1 is pressed, the code plays a random music sound. If Button 2 is pressed, the
    code plays a random vocals (singing) sound. If neither is pressed, the code loops
    around and checks them again. The loop never ends, so you’ll need to press Ctrl-C
    to exit the program.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 代码反复检查按钮1或按钮2是否被按下。如果按钮1被按下，代码将播放一个随机的音乐声音。如果按钮2被按下，代码将播放一个随机的声乐（唱歌）声音。如果两个都没有被按下，代码将循环回来再次检查。循环永远不会结束，所以你需要按Ctrl-C来退出程序。
- en: 'Playing sounds: using operating system commands from Python'
  id: totrans-773
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 播放声音：使用Python中的操作系统命令
- en: You’re ready to play your sounds! The `os` module will let you run operating
    system commands (ones you normally run using Terminal). To play the first sound
    in the `sounds_music` list, you could write
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经准备好播放你的声音了！`os`模块将允许你运行操作系统命令（你通常在终端中运行的命令）。要播放`sounds_music`列表中的第一个声音，你可以写
- en: '[PRE39]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Later in this chapter, we’ll explain why the end of that command has an ampersand
    (`&`). The result of this command would be the same as typing this at the Raspbian
    command line:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将解释为什么该命令的末尾有一个和号（`&`）。此命令的结果将与在Raspbian命令行中键入以下内容相同：
- en: '[PRE40]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '|  |'
  id: totrans-778
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-779
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Remember, if you’re outputting the sound to HDMI (if your TV has speakers),
    you need to change `–o local` to `–o hdmi`.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果你要将声音输出到HDMI（如果你的电视有扬声器），你需要将`–o local`更改为`–o hdmi`。
- en: '|  |'
  id: totrans-781
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Excellent! Let’s review what you’ve learned so far:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！让我们回顾一下你到目前为止学到的内容：
- en: Your Pi can play sounds that are in MP3 format using OMXPlayer.
  id: totrans-783
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的 Pi 可以使用 OMXPlayer 播放 MP3 格式的声音。
- en: Python can store sets of things as lists.
  id: totrans-784
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 可以将事物集合存储为列表。
- en: The Python `os` library has a function called `listdir(path)` that can give
    you a list of sounds in a folder.
  id: totrans-785
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 的 `os` 库有一个名为 `listdir(path)` 的函数，可以给你一个文件夹中的声音列表。
- en: Python’s `os` library has an `os.system(command)` function that can run operating
    system commands from Python, such as playing sounds with OMXPlayer.
  id: totrans-786
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 的 `os` 库中有一个 `os.system(command)` 函数，可以从 Python 中运行操作系统命令，例如使用 OMXPlayer
    播放声音。
- en: Functions!
  id: totrans-787
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 函数！
- en: 'Let’s think about how you can write the functions for DJ Raspi. You’ll want
    to create two functions:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下如何为 DJ Raspi 编写函数。你需要创建两个函数：
- en: '**`get_MP3_sounds`** —This function will get a list of sounds ending in .mp3
    from a specified folder. You’ll tell the function (pass it a parameter) the name
    of the folder where you want to get the MP3 sound files. The function will return
    a list of sounds.'
  id: totrans-789
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`get_MP3_sounds`** —此函数将从指定的文件夹中获取以 .mp3 结尾的声音列表。你将告诉该函数（传递一个参数）你想要获取 MP3
    声音文件的文件夹名称。该函数将返回一个声音列表。'
- en: '**`play_random_sound`** —This function will take a list of sounds, pick a random
    number, and then use `os.system` to tell Raspbian to play the sound with OMXPlayer.'
  id: totrans-790
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`play_random_sound`** —此函数将接受一个声音列表，随机选择一个数字，然后使用 `os.system` 告诉 Raspbian
    使用 OMXPlayer 播放声音。'
- en: '[Figure 8.18](#ch08fig18) shows where these functions fit into the flow diagram.'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8.18](#ch08fig18) 展示了这些函数在流程图中的位置。'
- en: Figure 8.18\. There are two places where you can create functions so you can
    reuse code. One function creates a list of sound files, and the other function
    plays a random sound when a button is pressed.
  id: totrans-792
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.18\. 有两个地方可以创建函数，以便你可以重用代码。一个函数创建声音文件列表，另一个函数在按下按钮时播放随机声音。
- en: '![](08fig18_alt.jpg)'
  id: totrans-793
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig18_alt.jpg)'
- en: Why not make this a single function? One reason is that you only need to load
    a list of sound files once, near the beginning of the program. You play the sound
    files every time a button is pressed. [Listing 8.4](#ch08ex04) shows the code
    for the `get_MP3_sounds` and `play_random_sound` functions.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不将其作为一个单独的函数呢？一个原因是你只需要在程序开始附近加载一次声音文件列表。每次按下按钮时，你都会播放声音文件。[列表 8.4](#ch08ex04)
    展示了 `get_MP3_sounds` 和 `play_random_sound` 函数的代码。
- en: '|  |'
  id: totrans-795
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-796
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Remember to put these functions near the beginning of the program. They must
    be added before they’re used for the first time.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 记得将这些函数放在程序的开头附近。它们必须在第一次使用之前添加。
- en: '|  |'
  id: totrans-798
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: At the end of this listing, you use (or call) `get_MP3_sounds` twice to get
    your lists of music and vocal sound files.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 在此列表的末尾，你使用（或调用）`get_MP3_sounds` 两次以获取你的音乐和声乐声音文件列表。
- en: Listing 8.4\. Functions for loading and playing sound files
  id: totrans-800
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.4\. 加载和播放声音文件的函数
- en: '![](233fig01_alt.jpg)'
  id: totrans-801
  prefs: []
  type: TYPE_IMG
  zh: '![](233fig01_alt.jpg)'
- en: 'You may have noticed that a few extra things are added to this line:'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，此行添加了一些额外的东西：
- en: '[PRE41]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This line joins the command to run OMXPlayer with the path to your sound files
    (`sound_path`) and the random sound file you want to play (`sound_filesound_files[random_sound_index]`).
    At the end, you add an ampersand (`&`). The ampersand tells Raspbian to run the
    command in the background. This is so you can quickly press one button and then
    the other.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 此行将运行 OMXPlayer 的命令与你的声音文件路径 (`sound_path`) 以及你想要播放的随机声音文件 (`sound_filesound_files[random_sound_index]`)
    相结合。在最后，你添加一个和号 (`&`)。和号告诉 Raspbian 在后台运行命令。这样你就可以快速按下一个按钮，然后按下另一个按钮。
- en: '|  |'
  id: totrans-805
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Doing multiple things at once: meet the ampersand (&)**'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: '**同时做多件事：遇到和号 (&)**'
- en: 'When you play sounds, you want to be able to press the buttons quickly, like
    a DJ, and have the sounds overlap to create interesting music. Normally, your
    Pi would play one sound, and, when it was finished playing, let you play another.
    Not what you want. Here is an example of playing two sounds. You can’t run the
    second command until the first one is finished:'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 当你播放声音时，你希望能够像 DJ 一样快速地按下按钮，并且让声音重叠以创建有趣的音乐。通常，你的 Pi 会播放一个声音，当它播放完毕后，让你播放另一个。这不是你想要的。以下是一个播放两个声音的例子。你只能在第一个命令完成后才能运行第二个命令：
- en: '[PRE42]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Luckily, your Pi can do a few things at once. You might have several different
    windows open at the same time. Each window is connected to some underlying code
    or set of instructions running on your Pi. These underlying sets of code are called
    *processes* or *threads*. Raspbian, like other modern operating systems, manages
    these processes and assigns each one its own unique ID number. An ampersand (`&`)
    placed at the end of a command tells your Pi to run the command as another process
    in the background alongside any other processes.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你的树莓派可以同时做几件事情。你可能同时打开几个不同的窗口。每个窗口都连接到在树莓派上运行的某些底层代码或指令集。这些底层代码集被称为*进程*或*线程*。Raspbian，像其他现代操作系统一样，管理这些进程并为每个进程分配其唯一的
    ID 号。命令末尾放置的符号“&”告诉你的树莓派以另一个进程的形式在后台运行该命令，与任何其他进程并行。
- en: 'Try these two commands again, but this time with ampersands:'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 再次尝试这两个命令，但这次使用符号“&”：
- en: '[PRE43]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Notice the ampersand (`&`) at the end of each command. In this way, the Pi will
    play your sound, but the code won’t make your Pi wait for the sound to finish
    before doing something else. Adding an ampersand at the end of the OMXPlayer command
    makes the button play each sound in the background. Remove the ampersand to play
    one sound at a time. Because this is a feature of the OS, the concept of using
    ampersands to execute commands as their own unique processes applies to other
    Linux commands that you know already or will learn.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每个命令末尾的符号“&”。这样，树莓派就会播放你的声音，但代码不会在播放声音之前等待，然后再做其他事情。在 OMXPlayer 命令末尾添加一个符号“&”会使按钮在后台播放每个声音。移除符号“&”可以一次播放一个声音。因为这是操作系统的一个特性，所以使用符号执行命令作为它们自己的独特进程的概念也适用于你已知或将要学习的其他
    Linux 命令。
- en: '|  |'
  id: totrans-813
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Great! You’re ready to test your project!
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！你已经准备好测试你的项目了！
- en: 'Testing: your first gig as DJ Raspi'
  id: totrans-815
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试：DJ Raspi 的第一次演出
- en: 'Save the code as DJRaspi.py, and try running it. Select Run > Run Module (or
    press F5) from the IDLE text editor to run your program. If you have an older
    version of Raspbian (prior to October 2015), programs that use the GPIO pins must
    be run from the Raspbian command prompt as the superuser (or root). Open Terminal,
    and enter the following command:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码保存为 DJRaspi.py，然后尝试运行它。从 IDLE 文本编辑器中选择运行 > 运行模块（或按 F5）来运行你的程序。如果你有较旧的 Raspbian
    版本（2015 年 10 月之前），使用 GPIO 引脚的程序必须以超级用户（或 root）的身份从 Raspbian 命令提示符运行。打开终端，并输入以下命令：
- en: '[PRE44]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You should see the title screen display. Test it by pressing the buttons to
    see if they work.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到标题屏幕显示。通过按按钮来测试它，看看它们是否工作。
- en: '|  |'
  id: totrans-819
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-820
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that any program that uses GPIO pins must be run from the Raspbian
    command prompt as the superuser (or root).
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，任何使用 GPIO 引脚的程序都必须以超级用户（或 root）的身份从 Raspbian 命令提示符运行。
- en: '|  |'
  id: totrans-822
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Believe it or not, it’s rare for a program to work perfectly the first time.
    If it doesn’t, read through the following “[Troubleshooting](#ch08lev1sec5)” section
    and review your circuit and program to try to figure out how to get it working.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，程序第一次就能完美运行的情况很少。如果它没有，请阅读以下“[故障排除](#ch08lev1sec5)”部分，并检查你的电路和程序，以尝试找出如何让它工作。
- en: Troubleshooting
  id: totrans-824
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'If sounds aren’t playing when you press the buttons, here are some things you
    can check:'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按下按钮时声音没有播放，这里有一些你可以检查的事情：
- en: Check the circuit on the breadboard. Is the ribbon cable connected properly,
    with the first wire connected toward the edge of your Pi, away from the USB ports?
  id: totrans-826
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查面包板上的电路。扁平电缆是否正确连接，第一根线是否连接到你的树莓派边缘，远离 USB 端口？
- en: Double-check that the jumpers, buttons, and resistors are in the right holes
    and pressed all the way into the breadboard.
  id: totrans-827
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仔细检查跳线、按钮和电阻是否在正确的孔中，并且完全压入面包板。
- en: 'Does your program print “You pressed #1!” and “You pressed #2!”? If it does,
    you know your circuit is working, and either it’s an issue with the code to load
    the sound files or your speakers or headphones aren’t working. Try running one
    of the following commands from Terminal to check whether the speakers are working.
    For headphones or speakers plugged into the 3.5 mm audio output:'
  id: totrans-828
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '你的程序是否打印了“你按了 #1！”和“你按了 #2！”？如果是这样，你就知道你的电路是正常工作的，要么是加载声音文件的代码有问题，要么是你的扬声器或耳机不工作。尝试从终端运行以下命令之一来检查扬声器是否工作。对于插入
    3.5 毫米音频输出的耳机或扬声器：'
- en: '[PRE45]'
  id: totrans-829
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'For TV speakers connected by HDMI:'
  id: totrans-830
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于通过 HDMI 连接的电视扬声器：
- en: '[PRE46]'
  id: totrans-831
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Look through your Python program for errors. Try adding some `print` statements
    to your functions to make sure they’re getting the list of MP3 files properly.
  id: totrans-832
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查你的 Python 程序中的错误。尝试在你的函数中添加一些 `print` 语句，以确保它们正确地获取 MP3 文件列表。
- en: If you’ve enjoyed creating DJ Raspi, check out the button challenges.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢创建 DJ Raspi，请查看按钮挑战。
- en: '![](common03.jpg)'
  id: totrans-834
  prefs: []
  type: TYPE_IMG
  zh: '![common03.jpg](common03.jpg)'
- en: Challenges
  id: totrans-835
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挑战
- en: Try some of these button activities for extra fun!
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这些按钮活动，增加乐趣！
- en: Double button press surprise
  id: totrans-837
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 双按钮按下惊喜
- en: Give your program a surprise button combination. See if you can make pressing
    both buttons at once play a new set of sound effects.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 给你的程序一个惊喜的按钮组合。看看你是否可以同时按下两个按钮来播放一组新的声音效果。
- en: 'Hint: When you want something to happen only if both conditions are True, you
    can use the ampersand (`&`). The `if` statement will only be True if both the
    first *and* second conditions are True. It looks like this:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：当你想要同时满足两个条件时，可以使用和号（`&`）。如果第一个和第二个条件都为真，`if` 语句才会为真。它看起来像这样：
- en: '[PRE47]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Here is the path to some Scratch sound effects on your Pi:'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Pi 上一些 Scratch 声音效果路径：
- en: '[PRE48]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Yoda Magic 8 Ball
  id: totrans-843
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 尤达魔法八球
- en: There is a great classic toy called the Magic 8 Ball. It’s a ball that displays
    an answer to a question when you shake it. Ask it a question, and you’ll get some
    truly magical advice. The Magic 8 Ball has 20 different answers, ranging from
    “It is certain” to “My sources say no.”
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个很经典的玩具叫做魔法八球。当你摇晃它时，它会显示一个问题的答案。问它一个问题，你会得到一些真正神奇的建议。魔法八球有 20 个不同的答案，从“肯定如此”到“我的消息来源说不是”。
- en: '|  |'
  id: totrans-845
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-846
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: I don’t recommend using the Magic 8 Ball to advise you on major life matters!
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 我不建议使用魔法八球来就重大生活问题提供建议！
- en: '|  |'
  id: totrans-848
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Your challenge is to make a Magic 8 Ball program:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 你的挑战是制作一个魔法八球程序：
- en: Ask a question aloud, and then press a button.
  id: totrans-850
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大声提出一个问题，然后按下一个按钮。
- en: Pressing the button makes your Pi select a random Yoda clip from a folder and
    play it.
  id: totrans-851
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下按钮会使你的 Pi 从文件夹中随机选择一个尤达剪辑并播放。
- en: To get started, find some short sound files of Yoda sayings. One place to find
    them is on [soundboard.com](http://soundboard.com). Search for “yoda” to see if
    you can locate some good clips (you’ll need to create an account to download them
    for your personal use).
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，找到一些尤达的简短语音文件。一个可以找到这些文件的地方是 [soundboard.com](http://soundboard.com)。搜索“yoda”看看是否能找到一些好的剪辑（你需要创建一个账户来下载它们供个人使用）。
- en: 'Bonus: Try to give your Pi a handy button that plays Monty Python sound clips
    whenever you press it.'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 奖励：尝试给你的 Pi 添加一个方便的按钮，每次按下它都会播放蒙提·派森的声音剪辑。
- en: Continuing to explore
  id: totrans-854
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 继续探索
- en: 'Now that you’ve given you Pi a new sense of touch, you’ll only need to change
    a few lines of code to make many other projects, such as these:'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经给了 Pi 一种新的触觉感知，你只需要更改几行代码就可以制作许多其他项目，例如这些：
- en: An interactive display that shows different digital photographs each time a
    button is pressed
  id: totrans-856
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次按下按钮时都会显示不同的数字照片的交互式显示屏
- en: Your own Raspberry Pi movie player that plays clips or movies at the press of
    a button
  id: totrans-857
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你自己的 Raspberry Pi 电影播放器，按下按钮即可播放剪辑或电影
- en: An MP3 music player that shuffles through your favorite songs
  id: totrans-858
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 MP3 音乐播放器，可以播放你最喜欢的歌曲
- en: You can also expand past buttons to sensors, such as passive infrared (PIR)
    sensors or cameras. For example, PIR sensors detect motion near the sensor. These
    are great for creating a Pi security system or something that scares people when
    they come to your door. Maybe you want to trigger a movie to make a frightening
    zombie head appear or generate a blood-curdling scream. Your only limit is your
    imagination and mischievous thoughts.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将按钮扩展到传感器，例如被动红外（PIR）传感器或摄像头。例如，PIR 传感器可以检测传感器附近的运动。这些非常适合创建 Pi 安全系统或在你家门口吓唬人的东西。也许你想触发一个电影，让一个恐怖的僵尸头出现，或者产生令人毛骨悚然的尖叫声。你唯一的限制是你的想象力和淘气的想法。
- en: Summary
  id: totrans-860
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you learned that
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了
- en: A Pi can sense the environment around it using the input capability of the GPIO
    pins. This creates incredible possibilities to make the Pi have human or even
    superhuman senses.
  id: totrans-862
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pi 可以通过 GPIO 引脚的输入能力感知其周围的环境。这为 Pi 拥有类似人类甚至超人的感官创造了无限可能。
- en: Python lists make it easy to store and retrieve sets of things like numbers,
    sound files, images, and videos.
  id: totrans-863
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 列表使得存储和检索诸如数字、声音文件、图像和视频等集合的事物变得容易。
- en: Buttons act as simple switches that send a small amount of electricity to your
    Pi’s GPIO pins, which it can detect. You have nothing to fear in wiring up buttons
    or other sensors!
  id: totrans-864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮作为简单的开关，向你的 Pi 的 GPIO 引脚发送少量电流，它可以检测到。在连接按钮或其他传感器时，你无需担心！
- en: Python programs can run Raspbian commands using the `os` library. This opens
    lots of possibilities for your programs, from playing music to showing or taking
    videos, displaying or taking pictures, and accessing information from websites.
  id: totrans-865
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 程序可以使用 `os` 库运行 Raspbian 命令。这为你的程序打开了众多可能性，从播放音乐到显示或录制视频，显示或拍照，以及从网站获取信息。
- en: You’ve completed a great adventure in learning Python programming and how to
    use your Raspberry Pi. But there is much more excitement ahead of you. Check out
    [appendix D](kindle_split_022.html#app04) for even more ideas of projects you
    can do with your Pi. With your Raspberry Pi, knowledge of Python, and a bit of
    fearlessness, the possibilities are endless!
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经完成了一次学习 Python 编程和如何使用你的 Raspberry Pi 的伟大冒险。但前方还有更多的兴奋等待着你。查看[附录 D](kindle_split_022.html#app04)以获取更多你可以用你的
    Pi 实现的项目想法。有了你的 Raspberry Pi、Python 知识以及一点无畏，可能性是无限的！
