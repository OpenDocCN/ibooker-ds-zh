- en: Appendix B. Exercise answers
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录 B. 练习答案
- en: B.1\. Chapter 4
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.1\. 第四章
- en: '|  |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Variables and expressions'
  id: totrans-3
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这样做：变量和表达式
- en: In the Python shell, create some variables. What happens when you try to put
    spaces, dashes, or other nonalphanumeric characters in the variable name? Play
    around with a few complex expressions, such as x = 2 + 4 * 5 – 6 / 3\. Use parentheses
    to group the numbers in different ways, and see how that changes the result compared
    with the original ungrouped expression.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 命令行中创建一些变量。尝试在变量名中放入空格、连字符或其他非字母数字字符会发生什么？尝试一些复杂的表达式，例如 x = 2 + 4 *
    5 – 6 / 3\. 使用括号以不同的方式分组数字，并查看这如何改变与原始未分组表达式的结果相比。
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '|  |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Manipulating strings and numbers'
  id: totrans-8
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这样做：操作字符串和数字
- en: In the Python shell, create some string and number variables (integers, floats,
    *and* complex numbers). Experiment a bit with what happens when you do operations
    with them, including across types. Can you multiply a string by an integer, for
    example, or by a float or complex number? Also, load the `math` module and try
    out a few of the functions; then load the `cmath` module and do the same. What
    happens if you try to use one of those functions on an integer or float after
    loading the `cmath` module? How might you get the `math` module functions back?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 命令行中，创建一些字符串和数字变量（整数、浮点数，*以及*复数）。尝试一下对这些变量进行操作时会发生什么，包括跨类型操作。例如，你能将一个字符串乘以一个整数，或者乘以一个浮点数或复数吗？此外，加载
    `math` 模块并尝试几个函数；然后加载 `cmath` 模块并做同样的操作。加载 `cmath` 模块后尝试使用这些函数对整数或浮点数进行操作会发生什么？你如何获取
    `math` 模块中的函数？
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To reconnect the first `sqrt` to your current namespace, you can reimport it.
    Note that this code doesn’t reload the file:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要将第一个 `sqrt` 重新连接到当前命名空间，你可以重新导入它。请注意，此代码不会重新加载文件：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|  |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Getting input'
  id: totrans-15
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这样做：获取输入
- en: Experiment with the `input()` function to get string and integer input. Using
    code similar to the code above, what is the effect of not using `int()` around
    the call to `input()`for integer input? Can you modify that code to accept a float,
    such as 28.5? What happens if you deliberately enter the “wrong” type of value,
    such as a float where an int is expected or a string where a number is expected,
    and vice versa?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用 `input()` 函数获取字符串和整数输入。使用与上面类似的代码，不使用 `int()` 来调用 `input()` 对整数输入有什么影响？你能修改该代码以接受浮点数，例如
    28.5 吗？如果你故意输入“错误”的类型值，例如在期望整数的地方输入浮点数或在期望数字的地方输入字符串，反之亦然，会发生什么？
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '|  |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: Pythonic style'
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：Pythonic 风格
- en: 'Which of the following variable and function names do you think are *not* good
    Pythonic style, and why?: `bar(`, `varName`, `VERYLONGVARNAME`, `foobar`, `longvarname`,
    `foo_bar()`, `really_very_long_var_name`'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为以下哪些变量和函数名不符合 Pythonic 风格，为什么？：`bar(`, `varName`, `VERYLONGVARNAME`, `foobar`,
    `longvarname`, `foo_bar()`, `really_very_long_var_name`
- en: '`bar(:` Not good, not legal, includes symbol'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`bar(:` 不好，不合法，包含符号'
- en: '`varName:` Not good, mixed case'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`varName:` Not good, mixed case'
- en: '`VERYLONGVARNAME: Not good, long, all caps,` hard to read'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`VERYLONGVARNAME: Not good, long, all caps,` hard to read'
- en: '`foobar: Good`'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`foobar: Good`'
- en: '`longvarname: Good, although underscores to separate words would be better`'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`longvarname: Good, although underscores to separate words would be better`'
- en: '`foo_bar(): Good`'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`foo_bar(): Good`'
- en: '`really_very_long_var_name: Long, but good if all of the words are needed,
    perhaps to distinguish among similar variables`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`really_very_long_var_name: Long, but good if all of the words are needed,
    perhaps to distinguish among similar variables`'
- en: '|  |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: B.2\. Chapter 5
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.2\. 第五章
- en: '|  |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: len()'
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：len()
- en: 'What would `len()` return for each of the following`: [0]; []; [[1, 3, [4,
    5], 6], 7]?`'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下各项，`len()` 会返回什么：[0]; []; [[1, 3, [4, 5], 6], 7]？
- en: '`len([0])` - 1'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`len([0])` - 1'
- en: '`len([])` - 0'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`len([])` - 0'
- en: '`len([[1, 3, [4, 5], 6], 7 s])` - 2'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`len([[1, 3, [4, 5], 6], 7 s])` - 2'
- en: '`([1, 3, [4, 5], 6]` is a list and a single item in the list before the second
    item, `7.`'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`([1, 3, [4, 5], 6]` 是一个列表，列表中的第二个项目之前有一个单独的项目，`7.`。'
- en: '|  |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: List slices and indexes'
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这样做：列表切片和索引
- en: Using what you know about the `len()` function and list slices, how would you
    combine the two to get the second half of a list when you don’t know what size
    it is? Experiment in the Python shell to confirm that your solution works.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你对 `len()` 函数和列表切片的了解，当你不知道列表的大小时要如何结合两者以获取列表的后半部分？在 Python 命令行中进行实验以确认你的解决方案是否有效。
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`len(my_list) // 2` is the halfway point; slice from there to the end.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`len(my_list) // 2` is the halfway point; slice from there to the end.'
- en: '|  |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Modifying lists'
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这样做：修改列表
- en: Suppose that you have a list 10 items long. How might you move the last three
    items from the end of the list to the beginning, keeping them in the same order?
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个长度为10的列表。你如何将列表末尾的最后三个元素移动到列表开头，同时保持它们的顺序？
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|  |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Try this: Sorting lists'
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：排序列表
- en: 'Suppose that you have a list in which each element is in turn a list: `[[1,
    2, 3], [2, 1, 3], [4, 0, 1]]`. If you want to sort this list by the second element
    in each list, so that the result is `[[4, 0, 1], [2, 1, 3], [1, 2, 3]]`, what
    function would you write to pass as the `key` value to the `sort()` method?'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个列表，其中每个元素依次是一个列表：`[[1, 2, 3], [2, 1, 3], [4, 0, 1]]`。如果你想按每个列表中的第二个元素对列表进行排序，以便结果是
    `[[4, 0, 1], [2, 1, 3], [1, 2, 3]]`，你应该编写什么函数作为 `sort()` 方法的 `key` 值？
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: or
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|  |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: List Operations'
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：列表操作
- en: What is the result of `len([[1,2]] * 3)`?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`len([[1,2]] * 3)` 的结果是什么？'
- en: '3'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: What are two differences between using the `in` operator and a list’s `index()`
    method?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `in` 操作符和列表的 `index()` 方法之间有两个区别是什么？
- en: index gives position; in gives a true/false answer.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引给出位置；in给出一个真/假答案。
- en: index gives an error if an element isn’t in the list.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果元素不在列表中，索引会引发错误。
- en: Which of the following raises an exception? `min(["a", "b", "c"])`; `max([1,
    2, "three"])`; `[1, 2, 3].count("one")`
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪个会引发异常？`min(["a", "b", "c"])`; `max([1, 2, "three"])`; `[1, 2, 3].count("one")`
- en: '`max([1, 2, "three"])`: Strings and ints can’t be compared, so it’s impossible
    to get a `max` value.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`max([1, 2, "three"])`：字符串和整数不能比较，因此无法得到 `max` 值。'
- en: '|  |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Try this: List operations'
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：列表操作
- en: If you have a list `x`, write the code to safely remove an item if and only
    if that value is in the list.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个列表 `x`，请编写代码以安全地删除列表中的项目，仅当该值在列表中时。
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Modify that code to remove the element only if the item occurs in the list more
    than once.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 将该代码修改为仅当项目在列表中多次出现时才删除元素。
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note: This code removes only the first occurrence of `element`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：此代码仅删除 `element` 的第一个出现。
- en: '|  |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Try this: List copies'
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：列表副本
- en: 'Suppose that you have the following list: `x = [[1, 2, 3], [4, 5, 6], [7, 8,
    9]]`. What code could you use to get a copy `y` of that list in which you could
    change its elements *without* the side effect of changing the contents of `x`?'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个以下列表：`x = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]`。你可以使用什么代码来获取该列表的副本 `y`，在其中你可以更改其元素，而不会改变
    `x` 的内容？
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|  |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: Tuples'
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：元组
- en: 'Explain why the following operations aren’t legal for the tuple `x = (1, 2,
    3, 4)`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 解释以下操作为什么对元组 `x = (1, 2, 3, 4)` 是非法的：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: All of these operations change the object in place, and tuples can’t be changed.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些操作都会就地更改对象，而元组不能更改。
- en: If you had a tuple `x = (3, 1, 4, 2)`, how might you end up with `x` sorted?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个元组 `x = (3, 1, 4, 2)`，你如何将其排序？
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|  |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: Sets'
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：集合
- en: 'If you were to construct a set from the following list, how many elements would
    it have?: `[1, 2, 5, 1, 0, 2, 3, 1, 1, (1, 2, 3)]`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从以下列表构造一个集合，它将有多少个元素？`[1, 2, 5, 1, 0, 2, 3, 1, 1, (1, 2, 3)]`
- en: 'Six unique elements: 1, 2, 5, 0, 3, and the tuple (1, 2, 3)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 六个独特的元素：1，2，5，0，3，以及元组（1，2，3）
- en: '|  |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Lab 5: Examining a List'
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实验五：检查列表
- en: 'In this lab, the task is to read a set of temperature data (in fact, the monthly
    high temperatures at Heathrow Airport for 1948–2016) from a file and then find
    some basic information: the highest and lowest temperatures, the mean (average)
    temperature, and the median temperature (the temperature in the middle if all
    of the temperatures are sorted).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，任务是读取一组温度数据（实际上是1948-2016年希思罗机场的月最高温度），然后找到一些基本信息：最高和最低温度，平均温度，以及中位数温度（如果所有温度都已排序，则位于中间的温度）。
- en: 'The temperature data is in the file lab_05.txt in the source code directory
    for this chapter. Because I’ve not yet discussed reading files, the code to read
    the files into a list is here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 温度数据存储在源代码目录中该章节的 `lab_05.txt` 文件中。因为我还没有讨论读取文件，所以将文件读取到列表中的代码如下：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As mentioned, you should find the highest and lowest temperature, the average,
    and the median. You’ll probably want to use `min()`, `max()`, `sum()`, `len()`,
    and `sort()`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你应该找到最高和最低温度，平均值，以及中位数。你可能需要使用 `min()`、`max()`、`sum()`、`len()` 和 `sort()`。
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|  |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Bonus: Determine how many unique temperatures are in the list.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 奖励：确定列表中有多少个独特的温度。
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: B.3\. Chapter 6
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.3\. 第六章
- en: '|  |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: split and join'
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：分割和连接
- en: How could you use `split` and join to change all of the whitespace in string
    x to dashes (such as `"this is a test"` to `"this-is-a-test"`)?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何使用 `split` 和 `join` 将字符串 x 中的所有空白字符替换为破折号（例如，将 `"this is a test"` 转换为 `"this-is-a-test"`）？
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|  |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: Strings to Numbers'
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：字符串转换为数字
- en: Which of the following will not be converted to numbers, and why?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪个不会转换为数字，为什么？
- en: '`int(''a1'')`'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`int(''a1'')`'
- en: '`int(''12G'', 16)`'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`int(''12G'', 16)`'
- en: '`float("12345678901234567890")`'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`float("12345678901234567890")`'
- en: '`int("12*2")`'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`int("12*2")`'
- en: 'Only #3 `float("12345678901234567890")` converts; all the others have a character
    that wouldn’t be allowed for conversion to an int.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '只有 #3 `float("12345678901234567890")` 可以转换；其他所有都有在转换为 int 时不允许的字符。'
- en: '|  |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: strip'
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：strip
- en: If the string `x` equals `"(name, date),\n"`, which of the following returns
    a string containing `"name, date"`?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符串 `x` 等于 `"(name, date),\n"`，以下哪个会返回包含 `"name, date"` 的字符串？
- en: '`x.rstrip("),")`'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`x.rstrip("),")`'
- en: '`x.strip("),\n")`'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`x.strip("),\n")`'
- en: '`x.strip("\n)(,")`'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`x.strip("\n)(,")`'
- en: '`x.strip("\n)(,")` will remove the newline as well as the comma and parentheses.'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`x.strip("\n)(,")` 将删除换行符以及逗号和括号。'
- en: '|  |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: String searching'
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：字符串搜索
- en: If you want to see whether a line ends with the string `"rejected"`, what string
    method would you use? Are there any other ways you could get the same result?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要查看一行是否以字符串 `"rejected"` 结尾，你会使用什么字符串方法？还有其他方法可以得到相同的结果吗？
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You could also do `line[:-8] == rejected`, but that wouldn’t be as clear or
    Pythonic.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以这样做 `line[:-8] == rejected`，但这不会那么清晰或 Pythonic。
- en: '|  |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: Modifying strings'
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：修改字符串
- en: What would be a quick way to change all punctuation in a string to spaces?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有什么快速的方法可以将字符串中的所有标点符号更改为空格？
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|  |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Try this: String operations'
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：字符串操作
- en: 'Suppose that you have a list of strings in which some (but not necessarily
    all) of the strings begin and end with the double quote character:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个字符串列表，其中一些（但不一定是所有）字符串以双引号字符开始和结束：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: What code would you use on each element to remove just the double quotes?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用什么代码对每个元素进行操作以仅删除双引号？
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: What code could you use to find the position of the *last* *p* in *Mississippi*?
    When you’ve found its position, what code would you use to remove just that letter?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用什么代码来找到 "Mississippi" 中最后一个 *p* 的位置？当你找到它的位置后，你会使用什么代码来仅删除那个字母？
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|  |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: the format() method'
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：format() 方法
- en: What will be in `x` when the following snippets of code are executed?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当以下代码片段执行后，`x` 中将会有什么内容？
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '|  |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: Formatting strings with %'
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：使用 % 格式化字符串
- en: What would be in the variable `x` after the following snippets of code have
    executed?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段执行后，变量 `x` 中会有什么内容？
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '|  |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: Bytes'
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：字节
- en: For which of the following kinds of data would you want to use a string? For
    which could you use bytes?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下哪种类型的数据，你会想使用字符串？对于哪种可以使用字节？
- en: (1) Data file storing binary data
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: (1) 存储二进制数据的文件
- en: Bytes. Because the data is binary, you’re more concerned with the contents as
    numbers rather than text. Therefore, it would make sense to use bytes.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 字节。因为数据是二进制的，你更关心的是作为数字的内容而不是文本。因此，使用字节是有意义的。
- en: (2) Text in a language with accented characters
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: (2) 使用带重音字符的语言的文本
- en: String. Python 3 strings are Unicode, so they can handle accented characters.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串。Python 3 的字符串是 Unicode，因此可以处理带重音的字符。
- en: (3) Text with only uppercase and lowercase roman characters
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: (3) 仅包含大写和小写罗马字符的文本
- en: String. Strings should be used for all text in Python 3.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串。在 Python 3 中，应该使用字符串来处理所有文本。
- en: (4) A series of integers no larger than 255
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: (4) 一系列不超过 255 的整数
- en: Bytes. A byte is an integer no larger than 255, so the bytes type is perfect
    for storing integers like this.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 字节。字节是一个不超过 255 的整数，因此字节类型非常适合存储这样的整数。
- en: '|  |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Lab 6: Preprocessing Text'
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实验室 6：文本预处理
- en: In processing raw text, it’s quite often necessary to clean and normalize the
    text before doing anything else. If you want to find the frequency of words in
    text, for example, you can make the job easier if, before you start counting,
    you make sure that everything is lowercase (or uppercase, if you prefer) and that
    all punctuation has been removed. It can also make things easier to break the
    text into a series of words.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理原始文本时，在执行其他任何操作之前清理和规范化文本通常是必要的。例如，如果你想找到文本中单词的频率，你可以在开始计数之前确保所有内容都是小写（或如果你更喜欢，大写），并且所有标点符号都已删除。这也可以使将文本分解成一系列单词更容易。
- en: In this lab, the task is to read an excerpt of the first chapter of *Moby Dick*,
    make sure that everything is one case, remove all punctuation, and write the words
    one per line to a second file. Again, because I haven’t yet covered reading and
    writing files, the code for those operations is supplied below.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: In this lab, the task is to read an excerpt of the first chapter of *Moby Dick*,
    make sure that everything is one case, remove all punctuation, and write the words
    one per line to a second file. Again, because I haven’t yet covered reading and
    writing files, the code for those operations is supplied below.
- en: 'Your task is to come up with the code to replace the commented lines in the
    sample below:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 'Your task is to come up with the code to replace the commented lines in the
    sample below:'
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '|  |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: B.4\. Chapter 7
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.4\. Chapter 7
- en: '|  |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Create a dictionary'
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 'Try this: Create a dictionary'
- en: Write the code to ask the user for three names and three ages. After the names
    and ages are entered, ask the user for one of the names, and print the correct
    age.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Write the code to ask the user for three names and three ages. After the names
    and ages are entered, ask the user for one of the names, and print the correct
    age.
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '|  |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: Dictionary operations'
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 'Quick Check: Dictionary operations'
- en: Assume that you have a dictionary `x = {'a':1, 'b':2, 'c':3, 'd':4}` and a dictionary
    `y = {'a':6, 'e':5, 'f':6}`. What would be the contents of `x` after the following
    snippets of code have executed?
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Assume that you have a dictionary `x = {'a':1, 'b':2,
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|  |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: What can be a key?'
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 'Quick Check: What can be a key?'
- en: 'Decide which of the following expressions can be a dictionary key`: 1; ''bob'';
    (''tom'', [1, 2, 3]); ["filename"]; "filename"; ("filename", "extension")`'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 'Decide which of the following expressions can be a dictionary key`: 1; ''bob'';
    (''tom'', [1, 2, 3]); ["filename"]; "filename"; ("filename", "extension")`'
- en: '`1`: Yes.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`1`: Yes.'
- en: '`''bob''`: Yes.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`''bob''`: Yes.'
- en: '`(''tom'', [1, 2, 3`]): No; it contains a list, which isn’t hashable.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`(''tom'', [1, 2, 3`]): No; it contains a list, which isn’t hashable.'
- en: '`["filename"]`: No; it’s a list, which isn’t hashable.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`["filename"]`: No; it’s a list, which isn’t hashable.'
- en: '`"filename"`: Yes.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`"filename"`: Yes.'
- en: '`("filename", "extension")`: Yes; it’s a tuple.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`("filename", "extension")`: Yes; it’s a tuple.'
- en: '|  |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Using dictionaries'
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 'Try this: Using dictionaries'
- en: Suppose that you’re writing a program that works like a spreadsheet. How might
    you use a dictionary to store the contents of a sheet? Write some sample code
    to both store a value and retrieve a value in a particular cell. What might be
    some drawbacks to this approach?
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Suppose that you’re writing a program that works like a spreadsheet. How might
    you use a dictionary to store the contents of a sheet? Write some sample code
    to both store a value and retrieve a value in a particular cell. What might be
    some drawbacks to this approach?
- en: You could use tuples of row, column values as keys to store the values in a
    dictionary. One drawback would be that the keys wouldn’t be sorted, so you’d have
    to manage that situation as you grabbed the keys/values to render as a spreadsheet.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: You could use tuples of row, column values as keys to store the values in a
    dictionary. One drawback would be that the keys wouldn’t be sorted, so you’d have
    to manage that situation as you grabbed the keys/values to render as a spreadsheet.
- en: '[PRE27]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '|  |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Lab 7: Word Counting'
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 'Lab 7: Word Counting'
- en: In Lab 6, you took the text of the first chapter of *Moby Dick*, normalized
    the case, removed punctuation, and wrote the separated words to a file. In this
    lab, you read that file, use a dictionary to count the number of times each word
    occurs, and report the most common and least common words.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: In Lab 6, you took the text of the first chapter of *Moby Dick*, normalized
    the case, removed punctuation, and wrote the separated words to a file. In this
    lab, you read that file, use a dictionary to count the number of times each word
    occurs, and report the most common and least common words.
- en: 'Use this code to read the words from the file into a list called moby_words:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 'Use this code to read the words from the file into a list called moby_words:'
- en: '[PRE28]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '|  |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: B.5\. Chapter 8
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.5\. Chapter 8
- en: '|  |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Looping and if statements'
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 'Try this: Looping and if statements'
- en: Suppose that you have a list `x = [1, 3, 5, 0, -1, 3, -2]`, and you need to
    remove all negative numbers from that list. Write the code to do this.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Suppose that you have a list `x = [1, 3, 5, 0, -1, 3, -2]`, and you need to
    remove all negative numbers from that list. Write the code to do this.
- en: '[PRE29]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How would you count the total number of negative numbers in a list `y = [[1,
    -1, 0], [2, 5, -9], [-2, -3, 0]]`?
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: How would you count the total number of negative numbers in a list `y = [[1,
    -1, 0], [2, 5, -9], [-2, -3, 0]]`?
- en: '[PRE30]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: What code would you use to print `"very low"` if the value of `x` is below -5,
    `"low"` if it’s from -4 up to 0, `"neutral"` if it’s equal to 0, `"high"` if it’s
    greater than 0 up to 4, and `"very high"` if it’s greater than 5?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: What code would you use to print `"very low"` if the value of `x` is below -5,
    `"low"` if it’s from -4 up to 0, `"neutral"` if it’s equal to 0, `"high"` if it’s
    greater than 0 up to 4, and `"very high"` if it’s greater than 5?
- en: '[PRE31]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '|  |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Comprehensions'
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 'Try this: Comprehensions'
- en: What list comprehension would you use to process the list `x` so that all negative
    values are removed?
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: What list comprehension would you use to process the list `x` so that all negative
    values are removed?
- en: '[PRE32]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create a generator that returns only odd numbers from 1 to 100\. (Hint: A number
    is odd if there’s a remainder when it’s divided by 2; use `% 2` to do this.)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个生成器，它只返回1到100之间的奇数。（提示：一个数是奇数，如果它除以2有余数；使用`% 2`来做这件事。）
- en: '[PRE33]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Write the code to create a dictionary of the numbers and their cubes from 11
    through 15.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码创建一个从11到15的数字及其立方体的字典。
- en: '[PRE34]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '|  |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: Booleans and truthiness'
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：布尔值和真值
- en: 'Decide whether the following statements are true or false: 1, 0, -1, [0], 1
    and 0, 1 > 0 or []'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 判断以下陈述是对还是错：1, 0, -1, [0], 1 and 0, 1 > 0 or []
- en: '1 ->: True.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '1 ->: True.'
- en: '0 ->: False.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '0 ->: False.'
- en: '-1: True.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '-1: True.'
- en: '[0]: True; it’s a list containing one item.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[0]: True；它是一个包含一个元素的列表。'
- en: '1 and 0: False.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '1 and 0: False.'
- en: '1 > 0 or []: True.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '1 > 0 或 []: True.'
- en: '|  |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Lab: Refactor word_count'
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实验室：重构word_count
- en: Rewrite the word-count program in [section 8.7](kindle_split_019.html#ch08lev1sec7)
    to make it shorter. You may want to look at the string and list operations already
    discussed, as well as think about different ways to organize the code. You may
    also want to make the program smarter so that only alphabetic strings (not symbols
    or punctuation) count as words.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 将单词计数程序重写为[第8.7节](kindle_split_019.html#ch08lev1sec7)，使其更短。你可能需要查看已讨论的字符串和列表操作，以及考虑不同的代码组织方式。你可能还想使程序更智能，以便只有字母字符串（不是符号或标点符号）被视为单词。
- en: '|  |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Listing B.1\. File: word_count_refactored.py'
  id: totrans-241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表B.1. 文件：word_count_refactored.py
- en: '[PRE35]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: B.6\. Chapter 9
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.6. 第9章
- en: '|  |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: Functions and parameters'
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：函数和参数
- en: How would you write a function that could take any number of unnamed arguments
    and print their values in reverse order?
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你会如何编写一个函数，它可以接受任意数量的未命名参数，并按相反顺序打印它们的值？
- en: '[PRE36]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: What do you need to do to create a procedure or void function—that is, a function
    with no return value?
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做什么来创建一个过程或void函数——即没有返回值的函数？
- en: Either don’t return a value (use a bare return) or don’t use a return statement
    at all.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要么不返回值（使用裸返回），要么根本不使用返回语句。
- en: What happens if you capture the return value of a function with a variable?
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用一个变量捕获函数的返回值会发生什么？
- en: The only result is that you can use that value, whatever it might be.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的结果是你可以使用那个值，无论它是什么。
- en: '|  |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: Mutable function parameters'
  id: totrans-254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：可变函数参数
- en: What would be the result of changing a list or dictionary that was passed into
    a function as a parameter value? Which operations would be likely to create changes
    that would be visible outside the function? What steps might you take to minimize
    that risk?
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 将列表或字典作为参数传递给函数时，修改这些列表或字典会产生什么结果？哪些操作可能会创建在函数外部可见的更改？你可以采取哪些步骤来最小化这种风险？
- en: The changes would persist for future uses of the default parameter. Operations
    such as adding and deleting elements, as well as changing the value of an element,
    are particularly likely to be problems. To minimize the risk, it’s better not
    to use mutable types as default parameters.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改将持久应用于默认参数的后续使用。添加和删除元素、以及更改元素值等操作尤其可能导致问题。为了最小化风险，最好不使用可变类型作为默认参数。
- en: '|  |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Global vs local variables'
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：全局变量与局部变量
- en: Assuming that `x = 5`, what will be the value of `x` after `funct_1()` below
    executes? After `funct_2()`?
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`x = 5`，下面`funct_1()`执行后`x`的值将会是什么？执行`funct_2()`后呢？
- en: '[PRE37]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: After calling `funct_1()`, `x` will be unchanged; after `funct_2()`, the value
    in the global `x` will be 2.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`funct_1()`后，`x`的值将保持不变；调用`funct_2()`后，全局变量`x`的值将变为2。
- en: '|  |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: Generator functions'
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：生成器函数
- en: What would you need to modify in the code for the function `four()` above to
    make it work for any number? What would you need to add to allow the starting
    point to also be set?
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要修改上面`four()`函数的代码以使其适用于任何数字吗？你需要添加什么来允许设置起点？
- en: '[PRE38]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '|  |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Decorators'
  id: totrans-270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：装饰器
- en: How would you modify the code for the decorator function above to remove unneeded
    messages and enclose the return value of wrapped function in `"<html>"` and `"</html>"`
    so that `myfunction ("hello")` would return `"<html>hello<html>"`?
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你会如何修改上面装饰器函数的代码，以删除不必要的消息，并将包装函数的返回值用`"<html>"`和`"</html>"`括起来，以便`myfunction
    ("hello")`返回`"<html>hello<html>"`？
- en: This exercise is a hard one, because to define a function that changes the return
    value, you need to add an inner wrapper function to call the original function
    and add to the return value.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这项练习很难，因为要定义一个改变返回值的函数，你需要添加一个内部包装函数来调用原始函数并添加到返回值中。
- en: '[PRE39]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '|  |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Lab 9: Useful functions'
  id: totrans-276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实验室 9：有用的函数
- en: Looking back at [chapters 6](kindle_split_017.html#ch06) and [7](kindle_split_018.html#ch07),
    refactor the code into functions for cleaning and processing the data. The goal
    should be that most of the logic is moved into functions. Use your own judgment
    as to the types of functions and parameters, but keep in mind that functions should
    do just one thing and that they shouldn’t have any side effects that carry over
    outside the function.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾 [第 6 章](kindle_split_017.html#ch06) 和 [第 7 章](kindle_split_018.html#ch07)，将代码重构为用于清理和处理数据的函数。目标应该是将大部分逻辑移动到函数中。根据你的判断来决定函数的类型和参数，但请记住，函数应该只做一件事，并且它们不应该有任何在函数外部延续的副作用。
- en: '[PRE40]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '|  |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: B.7\. Chapter 10
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.7\. 第十章
- en: '|  |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: Modules'
  id: totrans-282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：模块
- en: Suppose that you have a module called `new_math` that contains a function called
    `new_divide`. What are the ways that you might import and then use that function?
    What are the pros and cons of each way?
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个名为 `new_math` 的模块，其中包含一个名为 `new_divide` 的函数。你可能会用哪些方法来导入并使用该函数？每种方法有哪些优缺点？
- en: '[PRE41]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This solution is often preferred because there won’t be a clash between any
    identifiers in `new_module` and the importing namespace. This solution is less
    convenient to type, however.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案通常更受欢迎，因为 `new_module` 中的任何标识符都不会与导入命名空间中的标识符发生冲突。然而，这种解决方案不太方便输入。
- en: '[PRE42]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This version is more convenient to use but increases the chance of name clashes
    between identifiers in the module and the importing namespace.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本更方便使用，但增加了模块中的标识符和导入命名空间中的标识符之间发生名称冲突的机会。
- en: Suppose that the `new_math` module contains a function call `_helper_math()`.
    How will the underscore character affect the way that `_helper_math()` is imported?
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `new_math` 模块包含一个名为 `_helper_math()` 的函数调用。下划线字符将如何影响 `_helper_math()` 的导入方式？
- en: It won’t be imported if you `use from new_math import *`
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `use from new_math import *`，则不会导入。
- en: '|  |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: Namespaces and scope'
  id: totrans-292
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：命名空间和作用域
- en: Consider a variable width that’s in the module `make_window.py`. In which of
    the following contexts is width in scope?
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个位于 `make_window.py` 模块中的变量宽度。在以下哪个上下文中，宽度是作用域内的？
- en: (A) With the module itself
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: (A) 在模块本身中
- en: (B) Inside the `resize()` function in the module
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: (B) 在模块中的 `resize()` 函数内
- en: (C) Within the script that imported the `make_window.py` module
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: (C) 在导入 `make_window.py` 模块的脚本中
- en: A and B but not C
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: A 和 B 但不是 C
- en: '|  |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Lab 10: Create a module'
  id: totrans-300
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实验室 10：创建模块
- en: Package the functions that you created at the end of [chapter 9](kindle_split_020.html#ch09)
    as a standalone module. Although you can include code to run the module as the
    main program, the goal should be for the functions to be completely usable from
    another script.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 将你在 [第 9 章](kindle_split_020.html#ch09) 结尾创建的函数打包成一个独立的模块。虽然你可以包含代码以将模块作为主程序运行，但目标应该是使函数可以从另一个脚本完全使用。
- en: (no answer)
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: (无答案)
- en: '|  |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: B.8\. Chapter 11
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.8\. 第十一章
- en: '|  |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Try this: Making a script executable'
  id: totrans-306
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：使脚本可执行
- en: Experiment with executing scripts on your platform. Also try to redirect input
    and output into and out of your scripts.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的平台上尝试执行脚本。还尝试将输入和输出重定向到和从你的脚本中。
- en: (no answer)
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: (无答案)
- en: '|  |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: Programs and modules'
  id: totrans-311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：程序和模块
- en: What issue is the use of `if __name__ == "__main__":` meant to prevent, and
    how does it do that? Can you think of any other way to prevent this issue?
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`if __name__ == "__main__":` 的使用旨在防止什么问题，它是如何做到这一点的？你能想到其他防止此问题的方法吗？'
- en: When Python loads a module, all of its code is executed. By using the pattern
    above, you can have certain code run only if it’s being executed as the main script
    file.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Python 加载一个模块时，它的所有代码都会被执行。通过使用上述模式，你可以让某些代码仅在作为主脚本文件执行时运行。
- en: '|  |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Lab 11: Creating a program'
  id: totrans-316
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实验室 11：创建程序
- en: In [chapter 8](kindle_split_019.html#ch08), you created a version of the UNIX
    `wc` utility to count the lines, words, and characters in a file. Now that you
    have more tools at your disposal, refactor that program to make it work more like
    the original. In particular, it should have options to show only lines (`-l`),
    only words (`-w`), and only characters (`-c`). If none of those options is given,
    all three stats are displayed, but if any of them is present, only the specified
    stats are shown.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 8 章](kindle_split_019.html#ch08) 中，你创建了一个 UNIX `wc` 工具的版本来统计文件中的行、单词和字符。现在你有更多工具可用，重构该程序使其更像原始版本。特别是，它应该有选项仅显示行（`-l`）、仅显示单词（`-w`）和仅显示字符（`-c`）。如果没有给出这些选项中的任何一个，则显示所有三个统计信息，但如果任何一个选项存在，则仅显示指定的统计信息。
- en: For an extra challenge, look at the man page for `wc` on a Linux/UNIX system,
    and add the `-L` to show the longest line length. Feel free to try to implement
    the complete behavior as listed in the man page, and test it against your system’s
    `wc` utility.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外挑战，查看 Linux/UNIX 系统上 `wc` 的 man 页面，并添加 `-L` 以显示最长行长度。你可以自由尝试实现 man 页面上列出的完整行为，并对其进行系统
    `wc` 工具的测试。
- en: '[PRE43]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '|  |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: B.9\. Chapter 12
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.9\. 第 12 章
- en: '|  |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: Manipulating paths'
  id: totrans-323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：操作路径
- en: How would you use the `os` module’s functions to take a path to a file called
    test.log and create a new file path in the same directory for a file called test.log.old?
    How would you do the same thing by using the `pathlib` module?
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 你将如何使用 `os` 模块的功能从一个名为 test.log 的文件路径创建同一目录中名为 test.log.old 的新文件路径？你将如何使用 `pathlib`
    模块做同样的事情？
- en: '[PRE44]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: What path would you get if you created a pathlib `Path` object from `os .pardir`?
    Try it to find out.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从 `os.pardir` 创建一个 pathlib `Path` 对象，你会得到什么路径？尝试一下，看看结果。
- en: '[PRE45]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '|  |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Lab 12: More file operations'
  id: totrans-330
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 'Lab 12: 更多文件操作'
- en: How might you calculate the total size of all files ending with .txt that aren’t
    symlinks in a directory? If your first answer was using `os.path`, also try it
    with `pathlib`, and vice versa.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何计算目录中所有以 .txt 结尾且不是符号链接的文件的总体大小？如果你的第一个答案是使用 `os.path`，也尝试使用 `pathlib`，反之亦然。
- en: '[PRE46]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Write some code that builds off your solution above to move the same .txt files
    in the question above to a new directory called backup in the same directory.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一些代码，基于你上面的解决方案将上述问题中的相同 .txt 文件移动到同一目录中的新目录 backup。
- en: '[PRE47]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '|  |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: B.10\. Chapter 13
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.10\. 第 13 章
- en: '|  |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Quick Check
  id: totrans-338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查
- en: What is the significance of adding a `"b"` to the file open mode string?
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件打开模式字符串中添加 `"b"` 有什么意义？
- en: It makes the file open in binary mode, reading and writing bytes, not characters.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 它使得文件以二进制模式打开，读取和写入字节，而不是字符。
- en: Suppose that you want to open a file named myfile.txt and write some additional
    data at the end of it. What command would you use to open myfile.txt? What command
    would you use to reopen the file to read from the beginning?
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想打开一个名为 myfile.txt 的文件，并在其末尾写入一些额外的数据。你将使用什么命令来打开 myfile.txt？你将使用什么命令来重新打开文件以从开头读取？
- en: '[PRE48]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '|  |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Redirecting input and output'
  id: totrans-345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：重定向输入和输出
- en: Write some code to use the `mio.py` module above to capture all of the print
    output of a script to a file named myfile.txt, reset the standard output to the
    screen, and print that file to screen.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一些代码，使用上面的 `mio.py` 模块将脚本的全部打印输出捕获到名为 myfile.txt 的文件中，将标准输出重置到屏幕，并将该文件打印到屏幕。
- en: '[PRE49]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '|  |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: struct'
  id: totrans-350
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：结构体
- en: What use cases can you think of in which the `struct` module would be useful
    for either reading or writing binary data?
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想到哪些用例，其中 `struct` 模块对于读取或写入二进制数据是有用的？
- en: You’re trying to read/write from a binary-format application file or image file.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你正在尝试从二进制格式的应用程序文件或图像文件中读取/写入。
- en: You’re reading from some external interface, such as a thermometer or accelerometer,
    and you want to save the raw data exactly as it was transmitted.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你正在从某些外部接口读取，例如温度计或加速度计，并且你想将原始数据保存得与传输时完全相同。
- en: '|  |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: Pickles'
  id: totrans-356
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：Pickles
- en: 'Think about why a pickle would or wouldn’t be a good solution for the following
    use cases:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下用例中 pickle 是否是一个好的解决方案：
- en: (A) Saving some state variables from one run to the next
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: (A) 从一次运行保存到下一次运行的一些状态变量
- en: (B) Keeping a high-score list for a game
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: (B) 为游戏保持高分列表
- en: (C) Storing usernames and passwords
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: (C) 存储用户名和密码
- en: (D) Storing a large dictionary of English terms
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: (D) 存储一个包含大量英语术语的大字典
- en: A and B would be reasonable, although pickles aren’t secure.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: A 和 B 是合理的，尽管 pickle 不安全。
- en: C and D wouldn’t be good; the lack of security would be a big problem for C,
    and for D, there’d be a need to load the entire pickle into memory.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: C 和 D 不会很好；对于 C 来说，安全性的缺乏会是一个大问题，而对于 D 来说，需要将整个 pickle 加载到内存中。
- en: '|  |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: Shelve'
  id: totrans-366
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：Shelve
- en: Using a `shelf` object looks very much like using a dictionary. In what ways
    is using a `shelf` object different? What disadvantages would you expect there
    to be in using a `shelf` object?
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `shelf` 对象看起来非常像使用字典。使用 `shelf` 对象有哪些不同之处？你预计使用 `shelf` 对象会有哪些缺点？
- en: The key difference is that the objects are stored on disk, not in memory. With
    very large amounts of data, particularly with lots of inserts and/or deletes,
    you’d expect disk access to make things slow.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 关键区别在于对象存储在磁盘上，而不是内存中。在处理大量数据时，尤其是有很多插入和/或删除操作时，你会期望磁盘访问使事情变慢。
- en: '|  |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Lab: Final fixes to wc'
  id: totrans-371
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实验室：wc 的最终修复
- en: If you look at the man page for the `wc` utility, you see that two command-line
    options do very similar things. `-c` makes the utility count the bytes in the
    file, and `-m` makes it count characters (which in the case of some Unicode characters
    can be two or more bytes long). In addition, if a file is given, it should read
    from and process that file, but if no file is given, it should read from and process
    `stdin`.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 `wc` 工具的 man 页面，你会看到两个命令行选项做非常相似的事情。`-c` 让工具计算文件中的字节数，而 `-m` 让它计算字符数（在某些
    Unicode 字符的情况下，这可能需要两个或更多字节）。此外，如果提供了文件，它应该从该文件读取并处理，如果没有提供文件，它应该从标准输入读取并处理。
- en: Rewrite your version of the `wc` utility to implement both the distinction between
    bytes and characters and the ability to read from files and standard input.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 重新编写你的 `wc` 工具版本，以实现字节和字符之间的区别以及从文件和标准输入读取的能力。
- en: '[PRE50]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '|  |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: B.11\. Chapter 14
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.11\. 第14章
- en: '|  |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Try this: Catching exceptions'
  id: totrans-378
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：捕获异常
- en: Write some code that gets two numbers from the user and divides the first number
    by the second. Check for and catch the exception that occurs if the second number
    is zero (`ZeroDivisionError`).
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一些代码，从用户那里获取两个数字，并将第一个数字除以第二个数字。检查并捕获如果第二个数字为零时发生的异常（`ZeroDivisionError`）。
- en: '[PRE51]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '|  |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: Exceptions as classes'
  id: totrans-383
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：异常作为类
- en: If `MyError` inherits from `Exception`, what will be the difference between
    `except Exception as e` and `except MyError as e`?
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `MyError` 继承自 `Exception`，那么 `except Exception as e` 和 `except MyError as
    e` 之间会有什么区别？
- en: The first catches any exception that inherits from `Exception` (most of them),
    whereas the second catches only `MyError` exceptions.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个捕获继承自 `Exception` 的任何异常（大多数），而第二个只捕获 `MyError` 异常。
- en: '|  |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Try this: The assert statement'
  id: totrans-388
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：断言语句
- en: Write a simple program that gets a number from the user and then uses the `assert`
    statement to raise an exception if the number is zero. Test to make sure that
    the `assert` fires and then turn it off, using one of the methods mentioned above.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个简单的程序，从用户那里获取一个数字，然后使用 `assert` 语句在数字为零时抛出异常。测试以确保 `assert` 被触发，然后使用上述提到的方法之一将其关闭。
- en: '[PRE52]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '|  |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: Exceptions'
  id: totrans-393
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：异常
- en: Do Python exceptions force a program to halt?
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: Python 异常是否会导致程序停止？
- en: No. If exceptions are caught and handled correctly, the program won’t need to
    halt.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: No. 如果异常被捕获并正确处理，程序不需要停止。
- en: Suppose that you want accessing a dictionary `x` to always return `None` if
    a key doesn’t exist in the dictionary (that is, if a `KeyError` exception is raised).
    What code would you use to achieve that goal?
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想让字典 `x` 在键不存在时（即如果抛出 `KeyError` 异常）总是返回 `None`。你将使用什么代码来实现这个目标？
- en: '[PRE53]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '|  |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Try this: Exceptions'
  id: totrans-400
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：异常
- en: What code would you use to create a custom `ValueTooLarge` exception and raise
    that exception if the variable `x` is over 1000?
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用什么代码来创建一个自定义的 `ValueTooLarge` 异常，并在变量 `x` 超过 1000 时抛出该异常？
- en: '[PRE54]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '|  |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: Context managers'
  id: totrans-405
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：上下文管理器
- en: Assume that you’re using a context manager in a script that reads and/or writes
    several files. Which of the following approaches do you think would be best?
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在一个脚本中使用上下文管理器读取和/或写入几个文件。以下哪种方法你认为是最合适的？
- en: (A) Put the entire script in a block managed by a `with` statement.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: (A) 将整个脚本放在一个由 `with` 语句管理的块中。
- en: (B) Use one `with` statement for all file reads and another for all file writes.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: (B) 对于所有文件读取使用一个 `with` 语句，对于所有文件写入使用另一个 `with` 语句。
- en: (C) Use a `with` statement each time you read a file or write a file (that is,
    for each line).
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: (C) 每次读取文件或写入文件时使用一个 `with` 语句（即对于每一行）。
- en: (D) Use a `with` statement for each file that you read or write.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: (D) 对于你读取或写入的每个文件使用一个 `with` 语句。
- en: '|  |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Lab 14: Custom exceptions'
  id: totrans-413
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实验室 14：自定义异常
- en: Think about the module you wrote in [chapter 9](kindle_split_020.html#ch09)
    to count word frequencies. What errors might reasonably occur in those functions?
    Rewrite the code to handle those exception conditions appropriately.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑你在第 9 章编写的模块来计算单词频率。这些函数中可能发生哪些合理的错误？重新编写代码以适当地处理这些异常条件。
- en: '[PRE55]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '|  |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: B.12\. Chapter 15
  id: totrans-417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.12\. 第15章
- en: '|  |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Try this: Instance Variables'
  id: totrans-419
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：实例变量
- en: What code would you use to create a `Rectangle` class?
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 你会用什么代码来创建一个 `Rectangle` 类？
- en: '[PRE56]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '|  |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Instance variables and Methods'
  id: totrans-424
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：实例变量和方法
- en: Update the code for a `Rectangle` class so that you can set the dimensions when
    an instance is created, just as for the `Circle` class above. Also add an `area()`
    method.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 `Rectangle` 类的代码，以便在创建实例时可以设置维度，就像上面的 `Circle` 类一样。还要添加一个 `area()` 方法。
- en: '[PRE57]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '|  |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Class methods'
  id: totrans-429
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：类方法
- en: Write a class method that’s similar to `total_area()` but returns the total
    circumference of all circles.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个类似于 `total_area()` 的类方法，但返回所有圆的总周长。
- en: '[PRE58]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '|  |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Inheritance'
  id: totrans-434
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：继承
- en: Rewrite the code for a `Rectangle` class to inherit from `Shape`. Because squares
    and rectangles are related, would it make sense to inherit one from the other?
    If so, which would be the base class, and which would inherit?
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Rectangle` 类的代码重写为从 `Shape` 继承。因为正方形和矩形是相关的，从其中一个继承另一个是否有意义？如果有，哪个是基类，哪个继承？
- en: '[PRE59]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: It probably would make sense to inherit. Because squares are special kinds of
    rectangles, `Square` should inherit from the `Rectangle` class.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有意义进行继承。因为正方形是特殊类型的矩形，`Square` 应该从 `Rectangle` 类继承。
- en: If `Square` was specialized so that it had only one dimension x, you would write
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `Square` 被专门化，使其只有一个维度 x，你会写
- en: '[PRE60]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: How would you write the code to add an `area()` method for the `Square` class?
    Should the `area()` method be moved into the base `Shape` class and inherited
    by `Circle`, `Square`, and `Rectangle`? What issues would that change cause?
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 你会如何编写代码为 `Square` 类添加一个 `area()` 方法？是否应该将 `area()` 方法移动到基类 `Shape` 中，并由 `Circle`、`Square`
    和 `Rectangle` 继承？这种改变会引发哪些问题？
- en: It makes sense to put the `area()` method in a `Rectangle` class that `Square`
    inherits from, but putting it in `Shape` wouldn’t be very helpful, because different
    types of shapes have their own rules for calculating area. Every shape would be
    overriding the base `area()` method anyway.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `area()` 方法放在 `Rectangle` 类中，该类是 `Square` 继承自的，是有意义的，但将其放在 `Shape` 类中不会很有帮助，因为不同类型的形状有自己的计算面积规则。每个形状都会覆盖基类
    `area()` 方法。
- en: '|  |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Private instance variables'
  id: totrans-444
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：私有实例变量
- en: Modify the `Rectangle` class’s code to make the dimension variables private.
    What restriction will this change impose on using the class?
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 `Rectangle` 类的代码，使其维度变量为私有。这种改变会对使用该类施加什么限制？
- en: The dimension variables will no longer be accessible outside the class via `.x`
    and `.y`.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 维度变量将不再可以通过 `.x` 和 `.y` 在类外访问。
- en: '[PRE61]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '|  |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Properties'
  id: totrans-450
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：属性
- en: Update the dimensions of the `Rectangle` class to be properties with getters
    and setters that don’t allow negative sizes.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 `Rectangle` 类的维度为属性，具有不允许负大小的获取器和设置器。
- en: '[PRE62]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '|  |'
  id: totrans-453
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Lab 15: HTML classes'
  id: totrans-455
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实验室 15：HTML 类
- en: In this lab, you create classes to represent an HTML document. To keep things
    simple, assume that each element can contain only text and one subelement. So
    the `<html>` element contains only a `<body>` element, and the `<body>` element
    contains (optional) text and a `<p>` element, which contains only text.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，你创建类来表示 HTML 文档。为了使事情简单，假设每个元素只能包含文本和一个子元素。所以 `<html>` 元素只包含 `<body>`
    元素，而 `<body>` 元素包含（可选）文本和一个 `<p>` 元素，该元素只包含文本。
- en: The key feature to implement is the `__str__()` method, which in turn calls
    its subelement’s `__str__()` method so that the entire document is returned when
    the `str()` function is called on an `<html>` element. You can assume that any
    text comes before the subelement.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 实现的关键特性是 `__str__()` 方法，它反过来调用其子元素的 `__str__()` 方法，这样当在 `<html>` 元素上调用 `str()`
    函数时，整个文档就会被返回。你可以假设任何文本都在子元素之前。
- en: 'Following is example output from using the classes:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用这些类的示例输出：
- en: '[PRE63]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Answer:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：
- en: '[PRE64]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '|  |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: B.13\. Chapter 16
  id: totrans-463
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.13\. 第 16 章
- en: '|  |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: Special characters in regular expressions'
  id: totrans-465
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：正则表达式中的特殊字符
- en: What regular expression would you use to match strings that represent the numbers
    -5 through 5?
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 你会用什么正则表达式来匹配表示从 -5 到 5 的数字的字符串？
- en: '`` `r"-{0,1}[0-5]"` `` matches strings that represent the numbers -5 through
    5.'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `r"-{0,1}[0-5]"` `` 匹配表示从 -5 到 5 的数字的字符串。'
- en: What regular expression would you use to match a hexadecimal digit? Assume that
    the allowed hexadecimal digits are 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, A, a, B, b, C,
    c, D, d, E, e, F, and f.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 你会用什么正则表达式来匹配十六进制数字？假设允许的十六进制数字是 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, A, a, B, b, C,
    c, D, d, E, e, F, 和 f。
- en: '[PRE65]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '|  |'
  id: totrans-470
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-471
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Extracting matched text'
  id: totrans-472
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：提取匹配的文本
- en: Making international calls usually requires a plus sign (+) and the country
    code. Assuming that the country code is two digits, how would you modify the code
    above to extract the plus sign and the country code as part of the number? (Again,
    not all numbers have a country code.) How would you make the code handle country
    codes of one to three digits?
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 打国际电话通常需要加号（+）和国家代码。假设国家代码是两位数字，你将如何修改上面的代码以提取加号和国家代码作为号码的一部分？（再次提醒，并非所有号码都有国家代码。）你将如何使代码处理一位到三位数字的国家代码？
- en: '[PRE66]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: or
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE67]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'For one- to three-digit country codes:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一到三位数字的国家代码：
- en: '[PRE68]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '|  |'
  id: totrans-479
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-480
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Replacing text'
  id: totrans-481
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：替换文本
- en: In the checkpoint above, you extended a phone-number regular expression to also
    recognize a country code. How would you use a function to make any numbers that
    didn’t have a country code now have +1 (the country code for the United States
    and Canada)?
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的检查点中，你扩展了电话号码正则表达式，使其也能识别国家代码。你将如何使用函数来使现在没有国家代码的任何号码都带有+1（美国和加拿大的国家代码）？
- en: '[PRE69]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '|  |'
  id: totrans-484
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-485
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Lab 16: Phone Number normalizer'
  id: totrans-486
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实验室16：电话号码标准化器
- en: In the United States and Canada, phone numbers consist of 10 digits, usually
    separated into a 3-digit area code, a 3-digit exchange code, and a 4-digit station
    code. As mentioned above, phone numbers may or may not be preceded by +1, the
    country code. In practice, there are many ways of formatting a phone number, such
    as (NNN) NNN-NNNN, NNN-NNN-NNNN, NNN NNN-NNNN, NNN.NNN.NNNN, and NNN NNN NNNN.
    Also, the country code may not be present, may not have a plus sign, and is usually
    (not always) separated from the number by a space or dash. Whew!
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在美国和加拿大，电话号码由10位数字组成，通常分为3位区号、3位交换码和4位站点码。如上所述，电话号码可能带有也可能不带+1（国家代码）。在实践中，有许多格式电话号码的方式，例如（NNN）
    NNN-NNNN、NNN-NNN-NNNN、NNN NNN-NNNN、NNN.NNN.NNNN和NNN NNN NNNN。此外，国家代码可能不存在，可能没有加号，通常（但不总是）通过空格或破折号与号码分开。哇！
- en: In this lab, the task is to create a phone number normalizer that takes any
    of the formats mentioned above and returns a normalized phone number 1-NNN-NNN-NNNN.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验室中，任务是创建一个电话号码标准化器，它接受上述任何格式，并返回格式化为1-NNN-NNN-NNNN的电话号码。
- en: 'The following are all possible phone numbers:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 以下都是可能的电话号码：
- en: '| +1 223-456-7890 | 1-223-456-7890 | +1 223 456-7890 |'
  id: totrans-490
  prefs: []
  type: TYPE_TB
  zh: '| +1 223-456-7890 | 1-223-456-7890 | +1 223 456-7890 |'
- en: '| (223) 456-7890 | 1 223 456 7890 | 223.456.7890 |'
  id: totrans-491
  prefs: []
  type: TYPE_TB
  zh: '| (223) 456-7890 | 1 223 456 7890 | 223.456.7890 |'
- en: '*Bonus:* The first digit of the area code and the exchange code can be only
    2–9, and the second digit of an area code can’t be 9. Use this information to
    validate the input and return the message `"invalid phone number"` if the number
    is invalid.'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '*奖励:* 区号和交换码的第一位数字只能是2-9，区号的第二位数字不能是9。使用这些信息来验证输入，如果号码无效，则返回消息`"invalid phone
    number"`。'
- en: '[PRE70]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '|  |'
  id: totrans-494
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: B.14\. Chapter 17
  id: totrans-495
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.14\. 第17章
- en: '|  |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: Types'
  id: totrans-497
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：类型
- en: Suppose that you want to make sure that object `x` is a list before you try
    appending to it. What code would you use? What would be the difference between
    using `type()` and `isinstance()`? Would this be the LBYL (look before you leap)
    or EAFP (easier to ask forgiveness than permission) style of programming? What
    other options might you have besides checking the type explicitly?
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想在尝试向对象`x`中添加元素之前确保它是一个列表。你会使用什么代码？使用`type()`和`isinstance()`会有什么区别？这会是LBYL（先检查再行动）还是EAFP（请求原谅比请求许可更容易）风格的编程？除了显式检查类型之外，你还有哪些其他选择？
- en: '[PRE71]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Using type would get only lists, not anything that subclasses lists. Either
    way, it’s LBYL programming.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型只会得到列表，不会得到任何子类列表的内容。无论如何，这都是LBYL编程。
- en: You might also wrap the append in a `try... except` block and catch `TypeError`
    exceptions, which would be more EAFP.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将`append`包裹在`try...except`块中，并捕获`TypeError`异常，这将更加EAFP。
- en: '|  |'
  id: totrans-502
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-503
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: __getitem__'
  id: totrans-504
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：__getitem__
- en: The example use of `__getitem__` above is very limited and won’t work correctly
    in many situations. What are some cases in which the implementation above will
    fail or work incorrectly?
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的`__getitem__`示例非常有限，在许多情况下都不会正确工作。在哪些情况下，上述实现将失败或工作不正确？
- en: This implementation will not work if you try to access an item directly by index;
    neither can you move backward.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试直接通过索引访问项目，这个实现将不起作用；你也不能向后移动。
- en: '|  |'
  id: totrans-507
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-508
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Implementing list special methods'
  id: totrans-509
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：实现列表特殊方法
- en: Try implementing the `__len__` and `__delitem__` special methods listed earlier,
    as well as an `append` method. The implementation is in bold in the code.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试实现前面列出的 `__len__` 和 `__delitem__` 特殊方法，以及一个 `append` 方法。代码实现以粗体显示。
- en: '[PRE72]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '|  |'
  id: totrans-512
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: Special method attributes and subclassing existing types'
  id: totrans-514
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：特殊方法属性和现有类型的子类化
- en: Suppose that you want a dictionary like type that allows only strings as keys
    (maybe to make it work like a `shelf` object, as described in [Chapter 13](kindle_split_024.html#ch13)).
    What options would you have for creating such a class? What would be the advantages
    and disadvantages of each option?
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您需要一个类似于字典的类型，它只允许字符串作为键（可能为了使其像[第13章](kindle_split_024.html#ch13)中描述的`shelf`对象一样工作）。您有哪些创建此类类的选项？每种选项的优点和缺点是什么？
- en: You could use the same approach as you did for `TypedList` and inherit from
    the `UserDict` class. You could also inherit directly from `dict`, or you could
    implement all of the `dict` functionality yourself.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用与 `TypedList` 相同的方法，从 `UserDict` 类继承。您也可以直接从 `dict` 继承，或者您可以自己实现所有的 `dict`
    功能。
- en: Implementing everything yourself provides the most control but is the most work
    and most prone to bugs. If the changes you need to make are small (in this case,
    just checking the type before adding a key), it might make the most sense to inherit
    directly from `dict`. On the other hand, inheriting from `UserDict` is probably
    safest, because the internal `dict` object will continue to be a regular `dict`,
    which is a highly optimized and mature implementation.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 自己实现一切可以提供最多的控制，但也是最耗时和最容易出现错误的方法。如果您需要做的更改很小（在这种情况下，只是在添加键之前检查类型），直接从 `dict`
    继承可能最有意义。另一方面，从 `UserDict` 继承可能更安全，因为内部的 `dict` 对象将继续是一个常规的 `dict`，这是一个高度优化和成熟的实现。
- en: '|  |'
  id: totrans-518
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: B.15\. Chapter 18
  id: totrans-519
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.15\. 第18章
- en: '|  |'
  id: totrans-520
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: Packages'
  id: totrans-521
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：包
- en: Suppose that you’re writing a package that takes a URL, retrieves all images
    on the page pointed to by that URL, resizes them to a standard size, and stores
    them. Leaving aside the exact details of how each of these functions will be coded,
    how would you organize those features into a package?
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在编写一个包，该包接受一个URL，检索该URL指向页面上的所有图像，将它们调整到标准大小，并将它们存储起来。不考虑每个函数的确切编码细节，您会如何将这些功能组织到一个包中？
- en: 'The package will be performing three types of actions: fetching a page and
    parsing the HTML for image URLs, fetching the images, and resizing the images.
    For this reason, you might consider having three modules to keep the actions separate:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 该包将执行三种类型的操作：获取页面并解析HTML以获取图像URL，获取图像，并调整图像大小。因此，您可能考虑拥有三个模块以保持操作分离：
- en: '[PRE73]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '|  |'
  id: totrans-525
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-526
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Lab 18: Create a package'
  id: totrans-527
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实验室18：创建一个包
- en: In [chapter 14](kindle_split_025.html#ch14), you added error handling to the
    text cleaning and word frequency counting module you created in [chapter 11](kindle_split_022.html#ch11).
    Refactor that code into a package containing one module for the cleaning functions,
    one for the processing functions, and one for the custom exceptions. Then write
    a simple main function that uses all three modules.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第14章](kindle_split_025.html#ch14)中，您为在[第11章](kindle_split_022.html#ch11)中创建的文本清理和单词频率统计模块添加了错误处理。将此代码重构为一个包含一个用于清理函数的模块、一个用于处理函数的模块和一个用于自定义异常的模块的包。然后编写一个简单的main函数，使用这三个模块。
- en: '[PRE74]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '|  |'
  id: totrans-530
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: B.16\. Chapter 20
  id: totrans-531
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.16\. 第20章
- en: '|  |'
  id: totrans-532
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: Consider the choices'
  id: totrans-533
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：考虑选择
- en: Take a moment to consider your options for handling the tasks identified above.
    What modules in the standard library can you think of that will do the job? If
    you want to, you can even stop right now, work out the code to do it, and compare
    your solution with the one you’ll develop in the next section.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 花点时间考虑上述任务的解决方案。您能想到哪些标准库模块可以完成这项工作？如果您愿意，现在就可以停止，编写代码来完成这项工作，并将您的解决方案与下一节中开发的解决方案进行比较。
- en: From the standard library, use `datetime` for managing the dates/times of the
    files, and either `os.path` and `os` or `pathlib` for renaming and archiving the
    files.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 从标准库中，使用 `datetime` 来管理文件的日期/时间，以及使用 `os.path` 和 `os` 或 `pathlib` 来重命名和归档文件。
- en: '|  |'
  id: totrans-536
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-537
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: Potential Problems'
  id: totrans-538
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：潜在问题
- en: Because the previous solution is very simple, there are likely to be many situations
    that it won’t handle well. What are some potential issues or problems that might
    arise with the script above? How might you remedy these problems?
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前面的解决方案非常简单，可能存在许多它处理不好的情况。上述脚本可能会出现哪些潜在问题或问题？你将如何解决这些问题？
- en: Multiple files during the same day would be a problem, for one thing. If you
    have lots of files, navigating the archive directory will become increasingly
    difficult.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 同一天内的多个文件可能会成为一个问题。如果你有很多文件，导航存档目录将变得越来越困难。
- en: Consider the naming convention used for the files, which is based on the year,
    month and name, in that order. What advantages do you see in that convention?
    What might be the disadvantages? Can you make any arguments for putting the date
    string somewhere else in the filename, such as the beginning or the end?
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑文件使用的命名约定，该约定基于年份、月份和名称，顺序依次排列。你看到这个约定的哪些优点？可能存在哪些缺点？你能否为将日期字符串放在文件名中的其他位置（如开头或结尾）提出任何论点？
- en: Using year-month-day date formats makes a text-based sort of the files sort
    by date as well. Putting the date at the end of the filename but before the extension
    makes it more difficult to parse the date element visually.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 使用年-月-日日期格式会使基于文本的文件排序也按日期排序。将日期放在文件名末尾但扩展名之前会使视觉上解析日期元素更加困难。
- en: '|  |'
  id: totrans-543
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-544
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Implementation of multiple directories'
  id: totrans-545
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：实现多个目录
- en: Using the code you developed in the section above as a starting point, how would
    you modify it to implement archiving each set of files in subdirectories named
    according to the date received? Feel free to take the time to implement the code
    and test it.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 以上面章节中开发的代码为基础，你会如何修改它以实现将每组文件存档到按接收日期命名的子目录中？请随意花时间实现代码并测试它。
- en: '[PRE75]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '|  |'
  id: totrans-548
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-549
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: Alternate solutions'
  id: totrans-550
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：其他解决方案
- en: How might you create a script that does the same thing without using `pathlib`?
    What libraries and functions would you use?
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 你将如何创建一个不使用`pathlib`的脚本，以实现相同的功能？你会使用哪些库和函数？
- en: You’d use the `os.path` and `os` libraries—specifically, `os.path.join()`, `os.mkdir`(),
    and `os.rename()`.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 你会使用`os.path`和`os`库——具体来说，`os.path.join()`、`os.mkdir()`和`os.rename()`。
- en: '|  |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-554
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Archiving to zip files pseudocode'
  id: totrans-555
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：存档到zip文件的抽象代码
- en: Take a moment to write the pseudocode for a solution that stores data files
    in zip files as shown above. What modules and functions or methods do you intend
    to use? Try coding your solution to make sure that it works.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 花点时间编写一个解决方案的抽象代码，该方案将数据文件存储为上面所示的形式。你打算使用哪些模块、函数或方法？尝试编写你的解决方案以确保它有效。
- en: 'Pseudocode:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象代码：
- en: '[PRE76]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: (See the next section for sample code that does this.)
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: （有关实现此功能的示例代码，请参阅下一节。）
- en: '|  |'
  id: totrans-560
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-561
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: Consider different parameters'
  id: totrans-562
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：考虑不同的参数
- en: 'Take some time to consider different grooming options. How would you modify
    the code in the previous Try This to keep only one file a month? How would you
    change the code so that files from the previous month and older are groomed to
    save one a week? (Note: This is *not* the same as older than 30 days!)'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 花些时间考虑不同的整理选项。你将如何修改前面的“尝试这个”中的代码，以保留每月一个文件？你将如何修改代码，以便将上个月和更早的文件整理成每周保留一个？（注意：这不同于超过30天的情况！）
- en: You could use something similar to the code above but also check the month of
    the file against the current month.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用与上面代码类似的东西，但也要检查文件月份是否与当前月份相同。
- en: '|  |'
  id: totrans-565
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: B.17\. Chapter 21
  id: totrans-566
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.17\. 第21章
- en: '|  |'
  id: totrans-567
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: Normalization'
  id: totrans-568
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：规范化
- en: Look closely at the list of words generated above. Do you see any issues with
    the normalization so far? What other issues do you think you might encounter with
    a longer section of text? How do you think you might deal with those issues?
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看上面生成的单词列表。到目前为止，你看到任何规范化问题吗？你认为在较长的文本部分中可能会遇到哪些其他问题？你认为你将如何处理这些问题？
- en: Double hyphens for em dashes, hyphenation for line breaks and otherwise, and
    any other punctuation marks would all be potential problems.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 双破折号用于破折号，连字符用于换行，以及其他任何标点符号都可能成为潜在问题。
- en: Enhancing the word cleaning module you created in [chapter 18](kindle_split_030.html#ch18)
    would be a good way to cover most of the issues.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 通过增强你在[第18章](kindle_split_030.html#ch18)中创建的单词清洗模块，是解决大多数问题的好方法。
- en: '|  |'
  id: totrans-572
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-573
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Read A file'
  id: totrans-574
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：读取一个文件
- en: Write the code to read a text file (assume that it’s the file temp_data_00a.txt
    as shown in the example above), split each line of the file into a list of values,
    and add that list to a single list of records.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码来读取一个文本文件（假设它是上面示例中显示的temp_data_00a.txt文件），将文件的每一行拆分为值列表，并将该列表添加到单个记录列表中。
- en: (no answer)
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: (无答案)
- en: What issues or problems did you encounter in implementing this solution? How
    might you go about converting the last three fields to the correct date, real,
    and int types?
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施此解决方案时，你遇到了哪些问题或困难？你如何将最后三个字段转换为正确的日期、实数和整数类型？
- en: You could use a list comprehension to explicitly convert those fields.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用列表推导式显式地将这些字段转换。
- en: '|  |'
  id: totrans-579
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-580
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: Handling Quoting'
  id: totrans-581
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：处理引号
- en: 'Consider how you’d approach the problems of handling quoted fields and embedded
    delimiter characters if you didn’t have the `csv` library. Which is easier to
    handle: the quoting or the embedded delimiters?'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑如果没有`csv`库，你会如何处理处理引号字段和嵌入的分隔符字符的问题。哪个更容易处理：引号还是嵌入的分隔符？
- en: Without using the `csv` module, you’d have to check whether a field began and
    ended with the quote characters and then `strip()` them off.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用`csv`模块，你必须检查一个字段是否以引号字符开始和结束，然后使用`strip()`去除它们。
- en: To handle embedded delimiters without using the `csv` library, you’d have to
    isolate the quoted fields and treat them differently; then you’d split the rest
    of the fields by using the delimiter.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 要在不使用`csv`库的情况下处理嵌入的分隔符，你必须隔离引号字段，并对其进行不同的处理；然后你将使用分隔符拆分其余字段。
- en: '|  |'
  id: totrans-585
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-586
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Cleaning Data'
  id: totrans-587
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：清理数据
- en: How would you handle the fields with `'Missing'` as a possible value for math
    calculations? Can you write a snippet of code that averages one of those columns?
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 你会如何处理可能具有“缺失”值的字段进行数学计算？你能编写一个代码片段来计算这些列的平均值吗？
- en: '[PRE77]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: What would you do with the average column at the end so that you could also
    report the average coverage? In your opinion, would the solution to this problem
    be at all linked to the way that the `'Missing'` entries were handled?
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 你会如何处理末尾的平均列，以便也能报告平均覆盖率？在你看来，这个问题的解决方案是否与处理“缺失”条目的方式有任何关联？
- en: '[PRE78]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: It may not be done at the same time as the `'Missing'` values are handled.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不会与处理“缺失”值同时完成。
- en: '|  |'
  id: totrans-593
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-594
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Lab: Weather observations'
  id: totrans-595
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实验：天气观测
- en: The file of weather observations provided here is by month and then by county
    for the state of Illinois from 1979 to 2011. Write the code to process this file
    and extract the data for Chicago (Cook County) into a single CSV or spreadsheet
    file. This code includes replacing the `'Missing'` strings with empty strings
    and translating the percentage to a decimal. You may also consider what fields
    are repetitive and can be omitted or stored elsewhere. The proof that you’ve got
    it right occurs when you load the file into a spreadsheet. You can download a
    solution with the book’s source code.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供的天气观测文件是按月份和县份为伊利诺伊州1979年至2011年的数据。编写代码处理此文件，并将芝加哥（库克县）的数据提取到单个CSV或电子表格文件中。此代码包括将“缺失”字符串替换为空字符串，并将百分比转换为小数。你也可以考虑哪些字段是重复的，可以省略或存储在其他地方。当你将文件加载到电子表格中时，你会看到你做对了的证据。你可以下载带有书籍源代码的解决方案。
- en: '|  |'
  id: totrans-597
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: B.18\. Chapter 22
  id: totrans-598
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.18\. 第22章
- en: '|  |'
  id: totrans-599
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Retrieving A file'
  id: totrans-600
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：检索文件
- en: If you’re working with the data file above and want to break each line into
    separate fields, how might you do that? What other processing would you expect
    to do? Try writing some code to retrieve this file and calculate the average annual
    rainfall or, for more of a challenge, the average maximum and minimum temperature
    for each year.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理上面的数据文件，并想将每一行拆分为单独的字段，你该如何做？你预期还会进行哪些其他处理？尝试编写一些代码来检索此文件并计算平均年降雨量，或者作为一个更大的挑战，计算每年平均最高和最低温度。
- en: '[PRE79]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '|  |'
  id: totrans-603
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-604
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Accessing an API'
  id: totrans-605
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：访问API
- en: Write some code to fetch some data from the city of Chicago site used above.
    Look at the fields mentioned in the results, and see whether you can select on
    records based on another field in combination with the date range.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一些代码从上面使用的芝加哥市网站获取数据。查看结果中提到的字段，看看你是否可以根据日期范围结合另一个字段来选择记录。
- en: '[PRE80]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '|  |'
  id: totrans-608
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-609
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Saving some JSON crime data'
  id: totrans-610
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：保存一些JSON犯罪数据
- en: Modify the code you wrote to fetch Chicago crime data in [section 22.2](kindle_split_035.html#ch22lev1sec2)
    to convert the fetched data from a JSON-formatted string to a Python object. See
    whether you can save the crime events both as a series of separate JSON objects
    in one file and as one JSON object in another file. Then see what code is needed
    to load each file.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 修改你在[第22章第22.2节](kindle_split_035.html#ch22lev1sec2)中编写的用于获取芝加哥犯罪数据的代码，将其从JSON格式的字符串转换为Python对象。看看你是否可以将犯罪事件保存为一个文件中的多个单独的JSON对象，以及另一个文件中的一个JSON对象。然后看看加载每个文件所需的代码。
- en: '[PRE81]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '|  |'
  id: totrans-613
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-614
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Try this: Fetching and Parsing XML'
  id: totrans-615
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：获取和解析XML
- en: 'Write the code to pull the Chicago XML weather forecast from [http://mng.bz/103V](http://mng.bz/103V).
    Then use `xmltodict` to parse the XML into a Python dictionary and extract tomorrow’s
    forecast maximum temperature. Hint: To match up time layouts and values, compare
    the layout-key value of the first time-layout section and the time-layout attribute
    of the temperature element of the parameters element.'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码从[http://mng.bz/103V](http://mng.bz/103V)获取芝加哥XML天气预报。然后使用`xmltodict`将XML解析为Python字典，并提取明天的最高温度预报。提示：为了匹配时间布局和值，比较第一个时间布局部分的布局-key值和参数元素中温度元素的time-layout属性。
- en: '[PRE82]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '|  |'
  id: totrans-618
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-619
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Try this: Parsing HTML'
  id: totrans-620
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：解析HTML
- en: Given the file forecast.html (which you can find with the code on this book’s
    website), write a script using Beautiful Soup that extracts the data and saves
    it as a CSV file.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 给定文件forecast.html（你可以在本书的网站上找到相应的代码），编写一个使用Beautiful Soup提取数据并将其保存为CSV文件的脚本。
- en: '[PRE83]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '|  |'
  id: totrans-623
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-624
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Lab 22: Track Curiosity’s Weather'
  id: totrans-625
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实验室22：跟踪好奇号的天气
- en: 'Use the application programming interface (API) described in [section 22.2](kindle_split_035.html#ch22lev1sec2)
    of [chapter 22](kindle_split_035.html#ch22) to gather a weather history of *Curiosity*’s
    stay on Mars for a month. Hint: You can specify Martian days (sols) by adding
    `?sol=`*sol_number* to the end of the archive query like this:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[第22章第22.2节](kindle_split_035.html#ch22lev1sec2)中描述的应用程序编程接口（API）收集“好奇号”在火星上停留一个月的天气历史。提示：你可以在存档查询的末尾添加`?sol=`*sol_number*来指定火星日（sols），如下所示：
- en: '[http://marsweather.ingenology.com/v1/archive/?sol=155](http://marsweather.ingenology.com/v1/archive/?sol=155)'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://marsweather.ingenology.com/v1/archive/?sol=155](http://marsweather.ingenology.com/v1/archive/?sol=155)'
- en: Transform the data so that you can load it into a spreadsheet and graph it.
    For a version of this project, see the book’s source code.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据转换成可以加载到电子表格和图表中的形式。关于这个项目的某个版本，请参阅本书的源代码。
- en: '[PRE84]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '|  |'
  id: totrans-630
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: B.19\. Chapter 23
  id: totrans-631
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.19\. 第23章
- en: '|  |'
  id: totrans-632
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Try this: Creating and modifying Tables'
  id: totrans-633
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：创建和修改表
- en: Using sqlite3, write the code that creates a database table for the Illinois
    weather data you loaded from a flat file in [section 21.2](kindle_split_034.html#ch21lev1sec2)
    of [chapter 21](kindle_split_034.html#ch21). Suppose that you have similar data
    for more states and want to store more information about the states themselves.
    How could you modify your database to use a related table to store the state information?
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 sqlite3，编写代码创建一个数据库表，用于存储你在[第21章第21.2节](kindle_split_034.html#ch21lev1sec2)中从平面文件加载的伊利诺伊州天气数据。假设你还有更多州的类似数据，并想存储更多关于各州本身的信息。你如何修改数据库以使用相关表来存储州信息？
- en: '[PRE85]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '|  |'
  id: totrans-636
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: You could add a state table and store only each state’s ID field in the weather
    database.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在天气数据库中添加一个州表，并只存储每个州的ID字段。
- en: '|  |'
  id: totrans-638
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Try this: Using an ORM'
  id: totrans-639
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：使用ORM
- en: Using the database from [section 22.3](kindle_split_035.html#ch22lev1sec3),
    write a `SQLAlchemy` class to map to the data table and use it to read the records
    from the table.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[第22章第22.3节](kindle_split_035.html#ch22lev1sec3)中的数据库，编写一个`SQLAlchemy`类来映射数据表，并使用它来读取表中的记录。
- en: '[PRE86]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '|  |'
  id: totrans-642
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-643
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Try this: Modifying a database with Alembic'
  id: totrans-644
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：使用Alembic修改数据库
- en: Experiment with creating an a\Alembic upgrade that adds a state table to your
    database, with columns for ID, state name, and abbreviation. Upgrade and downgrade.
    What other changes would be necessary if you were going to use the state table
    along with the existing data table?
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试创建一个Alembic升级，向你的数据库添加一个州表，包含ID、州名和缩写列。升级和降级。如果你打算使用州表与现有数据表一起使用，还需要进行哪些其他更改？
- en: (no answer)
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: （无回答）
- en: '|  |'
  id: totrans-647
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-648
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: Uses of Key:Value stores'
  id: totrans-649
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：键值存储的使用
- en: What sorts of data and applications would benefit most from a key:value store
    like Redis?
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 哪些数据和应用程序最受益于像Redis这样的键值存储？
- en: Quick lookup of data
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速查找数据
- en: Caching
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存
- en: '|  |'
  id: totrans-653
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-654
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: Uses of MONGODB'
  id: totrans-655
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：MONGODB的使用
- en: Thinking back over the various data samples you’ve seen so far and other types
    of data in your experience, can you come up with any data that you think would
    be well suited to being stored in a database such as MongoDB? Would others clearly
    *not* be suited, and if so, why not?
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下你迄今为止看到的各个数据样本以及你经验中的其他类型的数据，你能想到任何你认为非常适合存储在像 MongoDB 这样的数据库中的数据吗？其他类型的数据显然*不*适合，如果是这样，为什么？
- en: Data that comes in large and/or more loosely organized chunks is suited to MongoDB,
    such as the contents of a web page or document.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 大量且/或组织较松散的数据块适合 MongoDB，例如网页或文档的内容。
- en: Data with a specific structure is better suited to relational data. The weather
    data you’ve seen is a good example.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 具有特定结构的数据更适合关系型数据。你看到的天气数据就是一个很好的例子。
- en: '|  |'
  id: totrans-659
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-660
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Lab 23: Create a database'
  id: totrans-661
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实验室 23：创建数据库
- en: Choose one of the datasets discussed in the past few chapters, and decide which
    type of database would be best to store that data. Create that database, and write
    the code to load the data into it. Then choose the two most common and/or likely
    types of search criteria, and write the code to retrieve both single and multiple
    matching records.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 选择过去几章中讨论的其中一个数据集，并决定哪种类型的数据库最适合存储该数据。创建该数据库，并编写代码将数据加载到其中。然后选择两种最常见和/或可能类型的搜索条件，并编写代码检索单个和多个匹配记录。
- en: (no answer)
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: （无回答）
- en: '|  |'
  id: totrans-664
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: B.20\. Chapter 24
  id: totrans-665
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.20\. 第 24 章
- en: '|  |'
  id: totrans-666
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Try this: Using Jupyter Notebook'
  id: totrans-667
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：使用 Jupyter Notebook
- en: Enter some code in the notebook, and experiment with running it. Check out the
    Edit, Cell, and Kernel menus to see what options are there. When you have a little
    code running, use the Kernel menu to restart the kernel, repeat your steps, and
    then use the cell menu to rerun the code in all of the cells.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 在笔记本中输入一些代码，并尝试运行它。查看编辑、单元格和内核菜单，看看有哪些选项。当你运行了一小段代码后，使用内核菜单来重启内核，重复你的步骤，然后使用单元格菜单在所有单元格中重新运行代码。
- en: (no answer)
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: （无回答）
- en: '|  |'
  id: totrans-670
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-671
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Try this: Cleaning Data with and without Pandas'
  id: totrans-672
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：使用和不用 Pandas 清洗数据
- en: Experiment with the operations mentioned above. When the final column has been
    converted to a fraction, can you think of a way to convert it back to a string
    with the trailing percentage sign?
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试上述操作。当最终列已转换为分数时，你能想到将其转换回带有百分号尾部的字符串的方法吗？
- en: By contrast, load the same data into a plain Python list by using the `csv`
    module, and apply the same changes by using plain Python.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，使用 `csv` 模块将相同的数据加载到普通的 Python 列表中，并使用纯 Python 应用相同的更改。
- en: '|  |'
  id: totrans-675
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-676
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: Merging data sets'
  id: totrans-677
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：合并数据集
- en: How would you go about actually merging to data sets like the above in Python?
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 你会如何在 Python 中合并像上述这样的数据集？
- en: If you’re sure that you have exactly the same number of items in each set and
    that the items are in the right order, you could use the `zip()` function. Otherwise,
    you could create a dictionary, with the keys being something common between the
    two data sets, and then append the date by key from both sets.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确定每个集合中恰好有相同数量的项目，并且项目顺序正确，你可以使用 `zip()` 函数。否则，你可以创建一个字典，键是两个数据集之间的共同点，然后从两个集合中按键追加日期。
- en: '|  |'
  id: totrans-680
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-681
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: Selecting in Python'
  id: totrans-682
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：在 Python 中选择
- en: What Python code structure would you use to select only rows that meet certain
    conditions?
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 你会使用哪种 Python 代码结构来选择满足特定条件的行？
- en: 'You’d probably use a list comprehension:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会使用列表推导式：
- en: '[PRE87]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '|  |'
  id: totrans-686
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-687
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Try this: Grouping and Aggregating'
  id: totrans-688
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：分组和聚合
- en: Experiment with pandas and the data above. Can you get the calls and amounts
    by both team member and month?
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 在 pandas 和上述数据上实验。你能根据团队成员和月份获取通话和金额吗？
- en: '[PRE88]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '|  |'
  id: totrans-691
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-692
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Try this: Plotting'
  id: totrans-693
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：绘图
- en: Plot a line graph of the monthly average amount per call.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制每月平均通话金额的折线图。
- en: '[PRE89]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '|  |'
  id: totrans-696
  prefs: []
  type: TYPE_TB
  zh: '|'
