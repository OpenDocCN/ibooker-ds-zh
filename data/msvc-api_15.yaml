- en: 11 API authorization and authentication
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 API授权和身份验证
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节涵盖了
- en: Using Open Authorization to allow access to our APIs
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用开放授权允许访问我们的API
- en: Using OpenID Connect to verify the identity of our API users
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OpenID Connect验证我们的API用户的身份
- en: What kinds of authorization flows exist, and which flow is more suitable for
    each authorization scenario
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在哪些类型的授权流程，以及每种授权场景更适合哪种流程
- en: Understanding JSON Web Tokens (JWT) and using Python’s PyJWT library to produce
    and validate them
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解JSON Web Tokens (JWT) 并使用Python的PyJWT库生成和验证它们
- en: Adding authentication and authorization middleware to our APIs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将身份验证和授权中间件添加到我们的API中
- en: In 2018, a weakness in the API authentication system of the US postal system
    ([https://usps.com](https://usps.com)) allowed hackers to obtain data from 60
    million users, including their email addresses, phone numbers, and other personal
    details.[¹](#pgfId-1111730) API security attacks like this have become more and
    more common, with an estimated growth of over 300% in the number of attacks in
    2021.[²](#pgfId-1111733) API vulnerabilities don’t only risk exposing sensitive
    data from your users; they can also put you out of business![³](#pgfId-1111736)
    The good news is there are steps you can take to reduce the risk of an API breach.
    The first line of defense is a robust authentication and authorization system.
    In this chapter, you’ll learn to prevent unauthorized access to your APIs by using
    standard authentication and authorization protocols.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 2018年，美国邮政系统API身份验证系统的一个弱点（[https://usps.com](https://usps.com)）允许黑客从6000万用户那里获取数据，包括他们的电子邮件地址、电话号码和其他个人信息。[¹](#pgfId-1111730)
    类似这样的API安全攻击变得越来越普遍，预计2021年攻击数量增长了300%以上。[²](#pgfId-1111733) API漏洞不仅可能暴露用户的敏感数据；它们也可能使你的业务陷入困境![³](#pgfId-1111736)
    好消息是，你可以采取一些措施来降低API泄露的风险。第一道防线是一个健壮的身份验证和授权系统。在本章中，你将学习如何通过使用标准的身份验证和授权协议来防止未授权访问你的API。
- en: In my experience, API authentication and authorization are two of the most confusing
    topics for developers, and they’re also areas where implementation mistakes happen
    often. Before you implement the security layer of your API, I highly recommend
    you read this chapter to make sure you know what you’re doing and know how to
    do it correctly. I’ve done my best to provide a comprehensive summary of how API
    authentication and authorization work, and by the end of this chapter you should
    be able to add a robust authorization flow to your own APIs.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，API身份验证和授权是开发者最困惑的两个主题，也是实施错误经常发生的领域。在你实现API的安全层之前，我强烈建议你阅读本章，以确保你知道自己在做什么，并且知道如何正确地做。我已经尽力提供了一个关于API身份验证和授权如何工作的全面总结，到本章结束时，你应该能够为自己的API添加一个健壮的授权流程。
- en: Authentication is the process of verifying the identity of a user, while authorization
    is the process of determining whether a user has access to certain resources or
    operations. The concepts and standards about authentication and authorization
    that you’ll learn in this chapter are applicable to all types of web APIs.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证是验证用户身份的过程，而授权是确定用户是否有权访问某些资源或操作的过程。在本章中你将学习的关于身份验证和授权的概念和标准适用于所有类型的Web
    API。
- en: You’ll learn different authentication and authorization protocols and flows
    and how to validate authorization tokens. You’ll also learn to use Python’s PyJWT
    library to produce signed tokens and to validate them. We’ll walk through a practical
    example of adding authentication and authorization to the orders API. We’ve got
    a lot to cover, so let’s get started!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习不同的身份验证和授权协议及流程，以及如何验证授权令牌。你还将学习如何使用Python的PyJWT库来生成签名令牌并验证它们。我们将通过一个实际示例来讲解如何向订单API添加身份验证和授权。我们有很多内容要介绍，所以让我们开始吧！
- en: 11.1 Setting up the environment for this chapter
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 设置本章的环境
- en: 'Let’s set up the environment for this chapter. The code for this chapter is
    available under the directory called ch11 in the GitHub repository for this book.
    In chapter 7, we implemented a fully functional orders service, complete with
    a business layer, database, and API. This chapter picks up the orders service
    from where we left it in chapter 7\. If you want to follow along with the changes
    in this chapter, copy over the code from chapter 7 into a new folder called ch11:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为本章设置环境。本章的代码可在本书 GitHub 仓库中名为 ch11 的目录下找到。在第 7 章中，我们实现了一个功能齐全的订单服务，包括业务层、数据库和
    API。本章从第 7 章中我们停止的地方继续订单服务。如果您想跟随本章的变化，请将第 7 章的代码复制到一个名为 ch11 的新文件夹中：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`cd` into ch11 and install the dependencies by running `pipenv` `install`.
    For this chapter, we need a few additional dependencies, so run the following
    command to install them:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ch11 目录下运行 `pipenv install` 来安装依赖项。对于本章，我们需要一些额外的依赖项，因此请运行以下命令来安装它们：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: PyJWT is a Python library that allows us to work with JSON Web Tokens, while
    `cryptography` will allow us to verify the tokens’ signatures. (For a list of
    alternative JWT libraries in the Python ecosystem, check out [https://jwt.io/libraries?language=Python](https://jwt.io/libraries?language=Python.).)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: PyJWT 是一个 Python 库，它允许我们处理 JSON Web Tokens，而 `cryptography` 将允许我们验证令牌的签名。（有关
    Python 生态系统中的替代 JWT 库列表，请参阅 [https://jwt.io/libraries?language=Python](https://jwt.io/libraries?language=Python)。）
- en: Our environment is now ready, so let’s begin our quest through the wondrous
    world of user authentication and authorization. It’s a journey full of pitfalls,
    but a necessary one. Hold tight, and watch carefully as we go along!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的环境现在已经准备好了，让我们开始我们的旅程，探索用户身份验证和授权的奇妙世界。这是一段充满陷阱的旅程，但却是必要的。请系好安全带，并仔细观察我们一路上的进展！
- en: 11.2 Understanding authentication and authorization protocols
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 理解身份验证和授权协议
- en: When it comes to API authentication, the two most important protocols you need
    to know are OAuth (Open Authorization) and OpenID Connect (OIDC). This section
    explains how each protocol works and how they fit within the authentication and
    authorization flows for our APIs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到 API 身份验证时，您需要了解的两个最重要的协议是 OAuth（开放授权）和 OpenID Connect（OIDC）。本节解释了每个协议的工作原理以及它们如何适合我们
    API 的身份验证和授权流程。
- en: 11.2.1 Understanding Open Authorization
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.1 理解开放授权
- en: OAuth is a standard protocol for access delegation.[⁴](#pgfId-1111761) As you
    can see in figure 11.1, OAuth allows a user to grant a third-party application
    access to protected resources they own in another website without having to share
    their credentials.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 是一种用于访问委派的标准化协议。[⁴](#pgfId-1111761) 如图 11.1 所示，OAuth 允许用户在不共享其凭证的情况下，授权第三方应用程序访问他们拥有的另一个网站上的受保护资源。
- en: '![](../Images/11-01.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-01.png)'
- en: Figure 11.1 With OAuth, a user can grant a third-party application access to
    their information on another website.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 使用 OAuth，用户可以授予第三方应用程序访问另一个网站上的其信息的权限。
- en: Definition *OAuth* is an open standard that allows users to grant access to
    third-party applications to their information on other websites. Typically, access
    is granted by issuing a token, which the third-party application uses to access
    the user’s information.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *OAuth* 是一种开放标准，允许用户授予第三方应用程序访问他们在其他网站上的信息。通常，通过发放令牌来授予访问权限，第三方应用程序使用该令牌来访问用户的信息。
- en: For example, let’s say Susan has a list of contacts in her Facebook account.
    One day, Susan signs into LinkedIn, and she wants to import her list of contacts
    from Facebook. To allow LinkedIn to import her Facebook contacts, Susan has to
    grant LinkedIn access to that resource. How can she grant LinkedIn access to her
    list of contacts? She could give LinkedIn her Facebook credentials to access her
    account. But that would be a major security risk. Instead, OAuth defines a protocol
    that allows Susan to tell Facebook that LinkedIn can access her list of contacts.
    With OAuth, Facebook issues a temporary token LinkedIn can use to import Susan’s
    contacts.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设苏珊在她的 Facebook 账户中有一个联系人列表。有一天，苏珊登录到 LinkedIn，并希望从 Facebook 导入她的联系人列表。为了允许
    LinkedIn 导入她的 Facebook 联系人，苏珊必须授予 LinkedIn 访问该资源的权限。她如何授予 LinkedIn 访问她联系人列表的权限？她可以给
    LinkedIn 她的 Facebook 凭证以访问她的账户。但那将是一个重大的安全风险。相反，OAuth 定义了一种协议，允许苏珊告诉 Facebook，LinkedIn
    可以访问她的联系人列表。通过 OAuth，Facebook 会发放一个 LinkedIn 可以用来导入苏珊联系人的临时令牌。
- en: 'OAuth distinguishes various roles in the process of granting access to a resource:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 在授予资源访问权限的过程中区分了不同的角色：
- en: '*Resource owner*—The user who’s granting access to the resource. In the previous
    example, Susan is the resource owner.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*资源所有者*——授予资源访问权限的用户。在先前的例子中，Susan是资源所有者。'
- en: '*Resource server*—The server hosting the user’s protected resources. In the
    previous example, Facebook is the resource server.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*资源服务器*——托管用户受保护资源的服务器。在先前的例子中，Facebook是资源服务器。'
- en: '*Client*—The application or server requesting access to the user’s resources.
    In the previous example, LinkedIn is the client.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*客户端*——请求访问用户资源的应用程序或服务器。在先前的例子中，LinkedIn是客户端。'
- en: '*Authorization server*—The server that grants the client access to the resources.
    In the previous example, Facebook is the authorization server.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*授权服务器*——授予客户端访问资源的服务器。在先前的例子中，Facebook是授权服务器。'
- en: 'OAuth offers four different flows to grant authorization to a user depending
    on the access conditions. It’s important to know how each flow works and in which
    scenarios you can use it in. In my experience, OAuth flows are one of the biggest
    areas of confusion around authorization, and one of the biggest sources of security
    problems in modern websites. These are the OAuth flows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth提供了四种不同的流程，根据访问条件授予用户授权。了解每个流程的工作原理以及在哪些场景下可以使用它们非常重要。根据我的经验，OAuth流程是围绕授权的最大困惑之一，也是现代网站中最大的安全问题的来源之一。这些是OAuth流程：
- en: Authorization code flow
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权码流
- en: PKCE flow
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PKCE流程
- en: Client credentials flow
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端凭证流
- en: Refresh token flow
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 刷新令牌流
- en: OAuth
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth
- en: 'OAuth flows are the strategies that a client application uses to authorize
    their access to an API. Best practices in OAuth change over time as we learn more
    about application vulnerabilities and we improve the protocol. Current best practices
    are described in IETF’s “OAuth 2.0 Security Best Current Practice” ([http://mng.bz/o58v](http://mng.bz/o58v)),
    written by T. Lodderstedt, J. Bradley, A. Labunets, and D. Fett. If you read about
    OAuth 2.0, you may encounter references to two flows that we don’t describe in
    this chapter: the resource owner password flow and the implicit flow. Both are
    now deprecated since they expose serious vulnerabilities, and therefore you shouldn’t
    use them.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth流程是客户端应用程序用来授权其访问API的策略。OAuth的最佳实践随着时间的推移而变化，因为我们更多地了解应用程序漏洞并改进了协议。当前的最佳实践在IETF的“OAuth
    2.0安全最佳当前实践”中有描述（[http://mng.bz/o58v](http://mng.bz/o58v)），由T. Lodderstedt，J.
    Bradley，A. Labunets和D. Fett撰写。如果你阅读关于OAuth 2.0的内容，可能会遇到我们本章未描述的两个流程的引用：资源所有者密码流和隐式流。这两个流程现在都已弃用，因为它们暴露了严重的漏洞，因此你不应该使用它们。
- en: Another popular extension that we don’t discuss in this chapter is the device
    authorization grant ([http://mng.bz/5mZD](http://mng.bz/5mZD)), which allows input-constrained
    devices such as smart TVs to obtain access tokens. The latest version of OAuth
    is 2.1, which is described in the IETF’s “The OAuth 2.1 Authorization Framework”
    ([http://mng.bz/69m6](http://mng.bz/69m6)).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本章未讨论的另一个流行扩展是设备授权授予（[http://mng.bz/5mZD](http://mng.bz/5mZD)），它允许输入受限的设备，如智能电视，获取访问令牌。OAuth的最新版本是2.1，它在IETF的“OAuth
    2.1授权框架”中有描述（[http://mng.bz/69m6](http://mng.bz/69m6)）。
- en: Let’s delve into each flow to understand how they work and when we use them!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解每个流程，了解它们是如何工作的以及何时使用它们！
- en: Authorization code flow
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 授权码流
- en: In the authorization code flow, the client server exchanges a secret with the
    authorization server to produce a signing URL. As you can see in figure 11.2,
    after the user signs in using this URL, the client server obtains a one-time code
    it can exchange for an access token. This flow uses a client secret, and therefore
    is only appropriate for applications in which the code is not publicly exposed,
    such as traditional web applications where the user interface is rendered in the
    backend. OAuth 2.1 recommends using the authorization code flow in combination
    with PKCE, which is described in the next section.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在授权码流中，客户端服务器与授权服务器交换一个秘密，以生成一个签名URL。如图11.2所示，用户使用此URL登录后，客户端服务器获得一个一次性代码，它可以用来交换访问令牌。此流程使用客户端秘密，因此仅适用于代码未公开暴露的应用程序，例如用户界面在后台渲染的传统Web应用程序。OAuth
    2.1建议结合使用PKCE（证明密钥编码挑战）的授权码流，这在下一节中将有描述。
- en: '![](../Images/11-02.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-02.png)'
- en: Figure 11.2 In the authorization code flow, the authorization server produces
    a signing URL, which the user can use to prove their identity and grant access
    to the third-party application.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 在授权码流中，授权服务器生成一个签名URL，用户可以使用它来证明自己的身份并授予第三方应用程序访问权限。
- en: Proof of Key for Code Exchange flow
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 代码交换密钥证明流程
- en: The *Proof of Key for Code Exchange* (PKCE, pronounced “pixie”) is an extension
    of the authorization code flow designed to protect applications whose source code
    is publicly exposed, such as mobile applications and single-page applications
    (SPAs).[⁵](#pgfId-1111807) Since the source is publicly exposed, the client cannot
    use a secret because it would also be publicly exposed.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码交换密钥证明*（PKCE，发音为“pixie”）是授权代码流程的扩展，旨在保护源代码公开的应用程序，如移动应用程序和单页应用程序（SPAs）。[⁵](#pgfId-1111807)
    由于源代码是公开的，客户端不能使用秘密，因为这也会被公开。'
- en: As you can see in figure 11.3, in the PKCE flow, the client generates a secret
    called the *code verifier*, and it encodes it. The encoded code is called the
    *code challenge*. When sending an authorization request to the server, the client
    includes both the code verifier and the code challenge in the request. In return,
    the server produces an *authorization code*, which the client can exchange for
    an access token. To get the access token, the client must send both the authorization
    code and the code challenge.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在图11.3中看到的，在PKCE流程中，客户端生成一个称为*代码验证器*的秘密，并将其编码。编码后的代码称为*代码挑战*。当向服务器发送授权请求时，客户端在请求中包含代码验证器和代码挑战。作为回报，服务器生成一个*授权代码*，客户端可以用它来交换访问令牌。为了获取访问令牌，客户端必须发送授权代码和代码挑战。
- en: Thanks to the code challenge, the PKCE flow also prevents authorization code
    injection attacks, in which a malicious user intercepts the authorization code
    and uses it to get hold of an access token. Due to the security benefits of this
    flow, PKCE is also recommended for server-side applications. We’ll see an example
    of this flow using an SPA in appendix C.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了代码挑战，PKCE流程还防止了授权代码注入攻击，在这种攻击中，恶意用户拦截授权代码并使用它来获取访问令牌。由于这种流程的安全优势，PKCE也推荐用于服务器端应用程序。我们将在附录C中看到一个使用SPA的此流程的示例。
- en: '![](../Images/11-03.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/11-03.png)'
- en: Figure 11.3 In the PKCE flow, an SPA served by the client requests access to
    the user’s data directly from the authorization server by exchanging a code verifier
    and a code challenge.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 在PKCE流程中，由客户端提供的单页应用（SPA）通过交换代码验证器和代码挑战，直接从授权服务器请求用户的访问权限。
- en: Client credentials flow
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端凭据流程
- en: The client credentials flow is aimed for server-to-server communication, and
    as you can see in figure 11.4, it involves the exchange of a secret to obtain
    an access token. This flow is suitable for enabling communication between microservices
    over a secure network. We’ll see an example of this flow in appendix C.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端凭据流程旨在用于服务器到服务器的通信，如您在图11.4中看到的，它涉及交换秘密以获取访问令牌。此流程适用于在安全网络上启用微服务之间的通信。我们将在附录C中看到一个此流程的示例。
- en: '![](../Images/11-04.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/11-04.png)'
- en: Figure 11.4 In the client credentials flow, a server application exchanges a
    secret with the authorization server to obtain an access token.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 在客户端凭据流程中，服务器应用程序与授权服务器交换秘密以获取访问令牌。
- en: Refresh token flow
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新令牌流程
- en: The refresh token flow allows clients to exchange a refresh token for a new
    access token. For security reasons, access tokens are valid for a limited period
    of time. However, API clients often need to be able to communicate with the API
    server after an access token has expired, and to obtain the new token they use
    the refresh token flow.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新令牌流程允许客户端用刷新令牌交换新的访问令牌。出于安全原因，访问令牌的有效期是有限的。然而，API客户端通常需要在访问令牌过期后能够与API服务器通信，并且为了获取新令牌，它们使用刷新令牌流程。
- en: As you can see in figure 11.5, API clients typically receive both an access
    token and a refresh token when they successfully gain access to the API. Refresh
    tokens are usually valid for a limited period of time, and they’re valid for one-time
    use. Every time you refresh your access token, you’ll get a new refresh token.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在图11.5中看到的，API客户端在成功访问API时通常会收到一个访问令牌和一个刷新令牌。刷新令牌通常只在有限的时间内有效，并且只能一次性使用。每次您刷新访问令牌时，您都会获得一个新的刷新令牌。
- en: '![](../Images/11-05.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/11-05.png)'
- en: Figure 11.5 To allow API clients to use refresh tokens to continue communicating
    with the API server after the access token has expired, the authorization server
    issues a new refresh token every time the client requests a new access token.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 为了允许API客户端在访问令牌过期后继续与API服务器通信，授权服务器每次客户端请求新的访问令牌时都会颁发一个新的刷新令牌。
- en: Now that we understand how OAuth works, let’s turn our attention to OpenID Connect!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了OAuth的工作原理，让我们将注意力转向OpenID Connect！
- en: 11.2.2 Understanding OpenID Connect
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.2 理解OpenID Connect
- en: OpenID Connect (OIDC) is an open standard for identity verification that’s built
    on top of OAuth. As you can see in figure 11.6, OIDC allows users to authenticate
    to a website by using a third-party identity provider. If you’ve used your Facebook,
    Twitter, or your Google account to sign into other websites, you’re already familiar
    with OIDC. In this case, Facebook, Twitter, and Google are identity providers.
    You use them to bring your identity to a new website. OIDC is a convenient authentication
    system since it allows users to use the same identity across different websites
    without having to create and manage new usernames and passwords.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: OpenID Connect (OIDC) 是一个建立在OAuth之上的开放标准，用于身份验证。如图11.6所示，OIDC允许用户通过使用第三方身份提供者来验证网站。如果您已经使用Facebook、Twitter或Google账户在其他网站上登录，您已经熟悉OIDC了。在这种情况下，Facebook、Twitter和Google是身份提供者。您使用它们将您的身份带到新的网站。OIDC是一个方便的认证系统，因为它允许用户在不同的网站上使用相同的身份，而无需创建和管理新的用户名和密码。
- en: '![](../Images/11-06.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/11-06.png)'
- en: Figure 11.6 With OIDC, a user signs in with an OIDC server. The OIDC server
    issues an ID token and an access token, which the user can use to access an application.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 在OIDC中，用户使用OIDC服务器登录。OIDC服务器颁发一个ID令牌和一个访问令牌，用户可以使用这些令牌来访问应用程序。
- en: Definition *OpenID Connect* (OIDC) is an identity verification protocol that
    allows users to bring their identity from one website (the identity provider)
    to another. OIDC is built on top of OAuth, and we can use the same flows defined
    by OAuth to authenticate users.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *OpenID Connect* (OIDC) 是一个允许用户将他们的身份从网站（身份提供者）带到另一个网站的身份验证协议。OIDC建立在OAuth之上，我们可以使用OAuth定义的相同流程来验证用户。
- en: 'Since OIDC is built on top of OAuth, we can use any of the authorization flows
    described in the previous section to authenticate and authorize users. As you
    can see in figure 11.6, when we authenticate using the OIDC protocol, we distinguish
    two types of tokens: ID tokens and access tokens. Both tokens come in the form
    of JSON Web Tokens, but they serve different purposes: *ID tokens* identify the
    user, and they contain information such as the user’s name, their email, and other
    personal details. You use ID tokens only to verify the user identity, and never
    to determine whether a user has access to an API. API access is validated with
    access tokens. *Access tokens* typically don’t contain user information but a
    set of claims about the access rights of the user.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于OIDC建立在OAuth之上，我们可以使用上一节中描述的任何授权流程来验证和授权用户。如图11.6所示，当我们使用OIDC协议进行认证时，我们区分两种类型的令牌：ID令牌和访问令牌。这两种令牌都采用JSON
    Web Tokens的形式，但它们有不同的用途：*ID令牌*用于识别用户，并包含诸如用户姓名、电子邮件和其他个人详细信息等信息。您仅使用ID令牌来验证用户身份，而永远不用于确定用户是否有权访问API。API访问通过访问令牌进行验证。*访问令牌*通常不包含用户信息，而是一组关于用户访问权利的声明。
- en: 'ID Tokens vs. Access Tokens A common security problem is the misuse of ID tokens
    and access tokens. ID tokens are tokens that carry the identity of the user. They
    must be used exclusively for verifying the user’s identity and not for validating
    access to an API. API access is validated through access tokens. Access tokens
    rarely contain a user’s identity details, and instead contain claims about the
    user’s right to access the API. A fundamental difference between ID tokens and
    access tokens is the audience: the ID token’s audience is the authorization server,
    while the access token’s audience is our API server.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ID令牌与访问令牌 比较常见的安全问题是对ID令牌和访问令牌的误用。ID令牌是携带用户身份信息的令牌。它们必须仅用于验证用户的身份，而不能用于验证对API的访问。API访问通过访问令牌进行验证。访问令牌很少包含用户的身份信息，而是包含关于用户访问API权利的声明。ID令牌和访问令牌之间的一个基本区别是受众：ID令牌的受众是授权服务器，而访问令牌的受众是我们的API服务器。
- en: 'Identity providers that offer OIDC integrations expose a `/.well-known/openid-configuration`
    endpoint (with a leading period!), also known as the *discovery endpoint*, which
    tells the API consumer how to authenticate and obtain their access tokens. For
    example, the OIDC’s well-known endpoint for Google Accounts is [https://accounts.google.com/.well-known/openid-configuration](https://accounts.google.com/.well-known/openid-configuration).
    If you call this endpoint, you’ll obtain the following payload (the example is
    truncated with an ellipsis):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 提供OIDC集成的身份提供者公开了一个`/.well-known/openid-configuration`端点（带有一个前置句点！），也称为*发现端点*，它告诉API消费者如何进行认证以及如何获取他们的访问令牌。例如，OIDC为Google账户的知名端点是[https://accounts.google.com/.well-known/openid-configuration](https://accounts.google.com/.well-known/openid-configuration)。如果你调用此端点，你会获得以下载荷（示例被省略号截断）：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, the well-known endpoint tells us which URL we must use to obtain
    the authorization access token, which URL returns user information, or which URL
    we use to revoke an access token. There are other bits of information in this
    payload, such as available claims or the JSON Web Keys URI (JWKS). Typically,
    you use a library to handle these endpoints on your behalf, or you use an identity-as-a-service
    provider to take care of these integrations. If you want to learn more about OpenID
    Connect, I recommend Prabath Siriwardena’s *OpenID Connect in Action* (Manning,
    2022).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，知名端点告诉我们必须使用哪个URL来获取授权访问令牌，哪个URL返回用户信息，或者我们使用哪个URL来撤销访问令牌。在此载荷中还有其他一些信息，例如可用的声明或JSON
    Web Keys URI（JWKS）。通常，您会使用库来代表您处理这些端点，或者您会使用身份即服务提供商来处理这些集成。如果您想了解更多关于OpenID Connect的信息，我推荐Prabath
    Siriwardena的*OpenID Connect in Action*（Manning，2022）。
- en: Now that we know how OAuth and OpenID Connect work, it’s time get into the details
    of how authentication and authorization work. We’ll start by studying what JSON
    Web Tokens are in the next section.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了OAuth和OpenID Connect的工作原理，是时候深入了解认证和授权的具体工作了。我们将在下一节研究JSON Web Tokens（JWT）是什么。
- en: 11.3 Working with JSON Web Tokens
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 与JSON Web Tokens一起工作
- en: In OAuth and OpenID Connect, user access is verified by means of a token known
    as *JSON Web Token*, or JWT. This section explains what JSON Web Tokens are, how
    they’re structured, what kinds of claims they contain, and how to produce and
    validate them.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在OAuth和OpenID Connect中，用户访问是通过一种称为*JSON Web Token*（JWT）的令牌来验证的。本节将解释JWT是什么，它们的结构是怎样的，它们包含哪些声明，以及如何生成和验证它们。
- en: 'A JWT is a token that represents a JSON document. The JSON document contains
    claims, such as who issued the token, the audience of the token, or when the token
    expires. The JSON document is typically encoded as a Base64 string. JWTs are normally
    signed with a private secret or a cryptographic key.[⁶](#pgfId-1111905) A typical
    JSON Web Token looks like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: JWT是一个代表JSON文档的令牌。该JSON文档包含声明，例如谁发行了令牌、令牌的受众或令牌何时过期。JSON文档通常编码为Base64字符串。JWT通常使用私有密钥或加密密钥进行签名。[⁶](#pgfId-1111905)一个典型的JWT看起来像这样：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you look closely at the example, you’ll see the string contains two periods.
    The periods act as delimiters that separate each component of the JSON Web Token.
    As you can see in figure 11.7, a JSON Web Token document has three sections:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察示例，你会看到字符串中包含两个句点。句点作为分隔符，将JWT的每个部分分开。如图11.7所示，一个JWT文档有三个部分：
- en: '*Header*—Identifies the type of token as well as the algorithm and the key
    that were used sign the token. We use this information to apply the right algorithm
    to verify the token’s signature.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*头部*——标识令牌的类型以及用于签名令牌的算法和密钥。我们使用这些信息来应用正确的算法以验证令牌的签名。'
- en: '*Payload*—Contains the document’s set of claims. The JWT specification includes
    a list of reserved claims that identify the issuer of the token (the authorization
    server), the token’s audience or intended recipient (our API server), and its
    expiry date, among other details. In addition to JWT’s standard claims, a payload
    can also include custom claims. We use this information to determine whether the
    user has access to the API.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*载荷*——包含文档的声明集。JWT规范包括一系列保留声明，用于标识令牌的发行者（授权服务器）、令牌的受众或预期接收者（我们的API服务器）以及其过期日期等详细信息。除了JWT的标准声明外，载荷还可以包含自定义声明。我们使用这些信息来确定用户是否有权访问API。'
- en: '*Signature*—A string representing the token’s signature.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*签名*——表示令牌签名的字符串。'
- en: '![](../Images/11-07.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-07.png)'
- en: 'Figure 11.7 A JWT is composed of three parts: a header that contains information
    about the token itself, a payload with claims about the user’s access to the website,
    and a signature that proves the authenticity of the token.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 JWT由三部分组成：包含令牌本身信息的头部，包含关于用户对网站访问声明的负载，以及证明令牌真实性的签名。
- en: Now that we understand what a JWT is and what its structure looks like, let’s
    delve deeper into its properties. The next sections explain the main types of
    claims and properties we can find in JWT payloads and headers and how we use them.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了JWT是什么以及它的结构看起来像什么，让我们更深入地探讨它的属性。接下来的几节将解释JWT负载和头部中我们可以找到的主要声明和属性类型，以及我们如何使用它们。
- en: 11.3.1 Understanding the JWT header
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.1 理解JWT头部
- en: JWTs contain a header that describes the type of token, as well as the algorithm
    and the key used to sign the token. JWTs are commonly signed using the HS256 and
    the RS256 algorithms. HS256 uses a secret to encrypt the token, while RS256 uses
    a private/public key pair to sign the token. We use this information to apply
    the right algorithm to verify the token’s signature.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: JWT包含一个描述令牌类型、签名算法以及用于签名字令牌的密钥的头部。JWT通常使用HS256和RS256算法进行签名。HS256使用密钥加密令牌，而RS256使用私钥/公钥对来签名字令牌。我们使用这些信息来应用正确的算法以验证令牌签名。
- en: Signing algorithms for JWTs
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: JWT的签名算法
- en: The two most common algorithms used for signing JWTs are HS256 and RS256\. HS256
    stands for HMAC-SHA256, and it’s a form of encryption that uses a key to produce
    a hash.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 用于签名字令牌的最常见的两种算法是HS256和RS256。HS256代表HMAC-SHA256，这是一种使用密钥生成哈希的加密形式。
- en: RS256 stands for RSA-SHA256\. RSA (Rivest-Shamir-Adleman) is a form of encryption
    that uses a private key to encrypt the payload. In this case, we can verify that
    the token’s signature is correct by using a public key.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: RS256代表RSA-SHA256。RSA（Rivest-Shamir-Adleman）是一种使用私钥加密负载的加密形式。在这种情况下，我们可以通过使用公钥来验证令牌签名是否正确。
- en: You can learn more about HMAC and RSA in David Wong’s *Real-World Cryptography*
    (Manning, 2021).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在David Wong的《现实世界密码学》（Manning, 2021）中了解更多关于HMAC和RSA的信息。
- en: 'A typical JWT header is the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的JWT头部如下所示：
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let’s analyze this header:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析这个头部：
- en: '`alg`—Tells us that the token was signed using the RS256 algorithm'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alg`—告诉我们令牌是使用RS256算法签名的'
- en: '`typ`—Tells us that this is a JWT token'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`typ`—告诉我们这是一个JWT令牌'
- en: '`kid`—Tells us that the key used to sign the token has the ID `ZweIFRR4l1dJlVPHOoZqf`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kid`—告诉我们用于签名字令牌的密钥具有ID `ZweIFRR4l1dJlVPHOoZqf`'
- en: A token’s signature can only be verified using the same secret or key that was
    used to sign it. For security, we often use a collection of secrets or keys to
    sign the tokens. The `kid` field tells us which secret or key to use to sign the
    token so that we can use the right value when verifying the token’s signature.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌的签名只能使用用于签名的相同密钥或密钥进行验证。出于安全考虑，我们通常使用一组密钥或密钥来签名字令牌。`kid`字段告诉我们使用哪个密钥或密钥来签名字令牌，以便在验证令牌签名时使用正确的值。
- en: Some tokens also contain a `nonce` field in the header. If you see one of those
    tokens, chances are the token isn’t for your API server unless you’re the creator
    of the token and you know what the value for `nonce` is. The `nonce` field typically
    contains an encrypted secret that adds an additional layer of security to the
    JWT. For example, the tokens issued by the Azure Active Directory to access its
    Graph API contain a `nonce` token, which means you shouldn’t use those tokens
    to authorize access to your custom APIs. Now that we understand the properties
    of a token’s header, the next section explains how to read the token’s claims.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一些令牌还在头部包含一个`nonce`字段。如果你看到这样的令牌，那么这个令牌可能不是为你自己的API服务器准备的，除非你是令牌的创建者并且知道`nonce`的值。`nonce`字段通常包含一个加密的密钥，为JWT添加额外的安全层。例如，Azure
    Active Directory发行的用于访问其Graph API的令牌包含一个`nonce`令牌，这意味着你不应该使用这些令牌来授权访问你的自定义API。现在我们已经了解了令牌头部的属性，下一节将解释如何读取令牌的声明。
- en: 11.3.2 Understanding JWT claims
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.2 理解JWT声明
- en: The payload of a JWT contains a set of claims. Since a JWT payload is a JSON
    document, the claims come in the form of key-value pairs.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: JWT的负载包含一组声明。由于JWT负载是一个JSON文档，声明以键值对的形式出现。
- en: 'There are two types of claims: *reserved claims*, which are part of the JWT
    specification, and *custom claims*, which are claims we can add to enrich the
    tokens with additional information.[⁷](#pgfId-1111956) The JWT specification defines
    seven reserved claims:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 声明有两种类型：*保留声明*，它是JWT规范的一部分，以及*自定义声明*，我们可以添加这些声明以丰富令牌并添加更多信息。[⁷](#pgfId-1111956)
    JWT规范定义了七个保留声明：
- en: '`iss` *(issuer)*—Identifies the issuer of the JWT. If you use an identity-as-a-service
    provider, the issuer identifies that service. It typically comes in the form of
    an ID or a URL.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iss` *(发行者)*—标识JWT的发行者。如果您使用身份即服务提供商，发行者标识该服务。它通常以ID或URL的形式出现。'
- en: '`sub` *(subject)*—Identifies the subject of the JWT (i.e., the user sending
    the request to the server). It typically comes in the form of an opaque ID (i.e.,
    an ID that doesn’t disclose the user’s personal details).'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sub` *(主题)*—标识JWT的主题（即向服务器发送请求的用户）。它通常以不透明的ID（即不披露用户个人详情的ID）的形式出现。'
- en: '`aud` *(audience)*—Indicates the recipient for which the JWT is intended. This
    is our API server. It typically comes in the form of an ID or a URL. It’s crucial
    to check this field to validate that the token is intended for our APIs. If we
    don’t recognize the value in this field, it means the token isn’t for us, and
    we must disregard the request.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aud` *(观众)*—表示JWT的目标接收者。这是我们API服务器。它通常以ID或URL的形式出现。检查此字段以验证令牌是否针对我们的API至关重要。如果我们不认识此字段中的值，则意味着令牌不是为我们准备的，我们必须忽略该请求。'
- en: '`exp` *(expiration time)*—A UTC timestamp that indicates when the JWT expires.
    Requests with expired tokens must be rejected.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exp` *(过期时间)*—一个UTC时间戳，表示JWT何时过期。带有过期令牌的请求必须被拒绝。'
- en: '`nbf` *(not before time)*—A UTC timestamp that indicates the time before which
    the JWT must not be accepted.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nbf` *(不早于时间)*—一个UTC时间戳，表示JWT必须在此时间之前不被接受。'
- en: '`iat` *(issued at time)*—A UTC timestamp that indicates when the JWT was issued.
    It can be used to determine the age of the JWT.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iat` *(签发时间)*—一个UTC时间戳，表示JWT签发的时间。它可以用来确定JWT的年龄。'
- en: '`jti` *(JWT ID)*—A unique identifier for the JWT.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jti` *(JWT ID)*—JWT的唯一标识符。'
- en: The reserved claims are not required in the JWT payload, but it’s recommended
    to include them to ensure interoperability with third-party integrations.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 保留声明在JWT有效载荷中不是必需的，但建议包括它们以确保与第三方集成的互操作性。
- en: Listing 11.1 Example of JWT payload claims
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.1 JWT有效载荷声明示例
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s dissect the claims in listing 11.1:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析列表11.1中的声明：
- en: '`iss` tells us that the token has been issued by the https://auth.coffeemesh.io
    server identity service.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iss`告诉我们，令牌是由https://auth.coffeemesh.io服务器身份服务签发的。'
- en: '`sub` tell us that the user has the identifier `ec7bbccf-ca89-4af3-82ac-b41e4831a962`.
    The value of this identifier is owned by the identity service. Our APIs can use
    this value to control access to the resources owned by this user in an opaque
    way. We say this ID is opaque because it doesn’t disclose any personal information
    about the user.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sub`告诉我们，用户具有标识符`ec7bbccf-ca89-4af3-82ac-b41e4831a962`。此标识符的值属于身份服务。我们的API可以使用此值以透明的方式控制对用户拥有的资源的访问。我们说此ID是透明的，因为它不披露任何关于用户的个人信息。'
- en: '`aud` tells us that this token has been issued to grant access to the orders
    API. If the value of this field is a different URL, the orders API will reject
    the request.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aud`告诉我们，此令牌已签发以授予对订单API的访问权限。如果此字段的值是不同的URL，则订单API将拒绝请求。'
- en: '`iat` tells us that the token was issued on the 30th of October of 2022 at
    6:50 p.m. UTC.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iat`告诉我们，令牌是在2022年10月30日晚上6:50 UTC签发的。'
- en: '`exp` tells us that the token expires on the 31st of October of 2022 at 5:50
    p.m. UTC.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exp`告诉我们，令牌在2022年10月31日晚上5:50 UTC到期。'
- en: '`azp` tells us that the token has been requested by an application with identifier
    `7c2773a4-3943-4711-8997-70570d9b099c`. This is typically a frontend application.
    This claim is common in tokens that have been issued using the OpenID Connect
    protocol.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`azp`告诉我们，令牌是由标识符为`7c2773a4-3943-4711-8997-70570d9b099c`的应用程序请求的。这通常是一个前端应用程序。此声明在已使用OpenID
    Connect协议签发的令牌中很常见。'
- en: The `scope` field tells us that this token was issued using the OpenID Connect
    protocol.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scope`字段告诉我们，此令牌是使用OpenID Connect协议签发的。'
- en: Now that we know how to work with token claims, let’s see how we produce and
    validate tokens!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何处理令牌声明，让我们看看我们如何生成和验证令牌！
- en: 11.3.3 Producing JWTs
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.3 生成JWT
- en: 'To form the final JWT, we encode the header, the payload, and the signature
    using base64url encoding. As documented in RFC 4648 ([http://mng.bz/aPRj](http://mng.bz/aPRj)),
    base64url encoding is similar to Base64, but it uses non-alphanumeric characters
    and omits padding. The header, payload, and signature are then concatenated using
    periods as separators. Libraries like PyJWT take care of the heavy lifting of
    producing a JWT. Let’s say we want to produce a token for the payload we saw in
    listing 11.1:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要形成最终的 JWT，我们需要使用 base64url 编码来编码头部、有效载荷和签名。如 RFC 4648 ([http://mng.bz/aPRj](http://mng.bz/aPRj))
    所述，base64url 编码类似于 Base64，但它使用非字母数字字符并省略填充。然后使用点作为分隔符将头部、有效载荷和签名连接起来。像 PyJWT 这样的库会处理生成
    JWT 的繁重工作。假设我们想要为列表 11.1 中看到的有效载荷生成一个令牌：
- en: '[PRE6]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To produce a signed token with this payload, we use PyJWT’s `encode()` function,
    passing in the token, the key to sign the token, and the algorithm we want to
    use to sign the token:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此有效载荷生成一个签名令牌，我们使用 PyJWT 的 `encode()` 函数，传入令牌、用于签名令牌的密钥以及我们想要用于签名令牌的算法：
- en: '[PRE7]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this case, we’re signing the token with a secret keyword using the HS256
    algorithm. For a more secure encryption, we use a private/public key pair to sign
    the token with the RS256 algorithm. To sign JWTs, we typically use certificates
    that follow the X.509 standard, which allows us to bind an identity to a public
    key. To generate a private/ public key pair, run the following command from your
    terminal:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用 HS256 算法使用一个秘密关键字来签名令牌。为了更安全的加密，我们使用私钥/公钥对来使用 RS256 算法签名令牌。为了签名
    JWT，我们通常使用遵循 X.509 标准的证书，这允许我们将一个身份绑定到一个公钥。要生成私钥/公钥对，请在您的终端中运行以下命令：
- en: '[PRE8]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The minimum input for an X.509 certificate is the subject’s common name (CN),
    which in this case we set to `coffeemesh`. If you omit the `-subj` flag, you’ll
    be prompted with a series of questions about the identity you want to bind the
    certificate to. This command produces a private key under a file named private_key.pem,
    and the corresponding public certificate under a file named public_key.pem. If
    you’re unable to run these commands, you can find a sample key pair in the GitHub
    repository provided with this book, under ch11/private_key.pem and ch11/public_key.pem.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: X.509 证书的最小输入是主题的通用名称（CN），在这种情况下我们将其设置为 `coffeemesh`。如果您省略了 `-subj` 标志，您将收到一系列关于您想要将证书绑定到的身份的问题。此命令在名为
    private_key.pem 的文件下生成一个私钥，以及相应的名为 public_key.pem 的公钥证书。如果您无法运行这些命令，您可以在本书提供的
    GitHub 存储库中找到示例密钥对，位于 ch11/private_key.pem 和 ch11/public_key.pem。
- en: 'Now that we have a private/public key pair, we can use them to sign our tokens
    and to validate them. Create a file named jwt_generator.py and paste into it the
    contents of listing 11.2, which shows how to generate JWT tokens signed with a
    private key. The listing defines a function, `generate_jwt``()`, which generates
    a JWT for the payload defined within the function. In the payload, we set the
    `iat` and the `exp` properties dynamically: `iat` is set to the current UTC time;
    `exp` is set to 24 hours from now. We load the private key using `cryptography`’s
    `serialization()` function, passing in as parameters the content of our private
    key file encoded in bytes, as well as the passphrase encoded in bytes. Finally,
    we encode the payload using PyJWT’s `encode()` function, passing in the payload,
    the loaded private key, and the algorithm we want to use to sign the token (RS256).'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了私钥/公钥对，我们可以使用它们来签名我们的令牌并验证它们。创建一个名为 jwt_generator.py 的文件，并将列表 11.2 的内容粘贴到其中，该列表显示了如何使用私钥生成
    JWT 令牌。该列表定义了一个名为 `generate_jwt()` 的函数，它为函数内部定义的有效载荷生成一个 JWT。在有效载荷中，我们动态设置 `iat`
    和 `exp` 属性：`iat` 设置为当前的 UTC 时间；`exp` 设置为从现在起 24 小时。我们使用 `cryptography` 的 `serialization()`
    函数加载私钥，传入参数是我们私钥文件的字节内容以及以字节编码的密码。最后，我们使用 PyJWT 的 `encode()` 函数对有效载荷进行编码，传入有效载荷、加载的私钥以及我们想要用于签名令牌的算法（RS256）。
- en: Listing 11.2 Generating JWTs signed with a private key
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.2 使用私钥生成 JWT
- en: '[PRE9]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To see this code at work, activate your virtual environment by running `pipenv`
    `shell`, and execute the following command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此代码的工作情况，通过运行 `pipenv shell` 激活您的虚拟环境，并执行以下命令：
- en: '[PRE10]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now you know how to generate JWTs! The JWT generator from listing 11.2 is handy
    for running tests, and we’ll use it in the upcoming sections to test our code.
    Now that we understand how JWTs are generated, let’s see how to inspect their
    payloads and how to validate them.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何生成 JWT 了！列表 11.2 中的 JWT 生成器非常适合运行测试，我们将在接下来的章节中使用它来测试我们的代码。现在我们了解了
    JWT 的生成方式，让我们看看如何检查它们的载荷以及如何验证它们。
- en: 11.3.4 Inspecting JWTs
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.4 检查 JWT
- en: 'Often when working with JWTs you’ll run into validation issues. To understand
    why a token validation is failing, it’s useful to inspect the payload and verify
    whether its claims are correct. In this section, you’ll learn to inspect JWTs
    using three different tools: jwt.io ([https://jwt.io](https://jwt.io)), the terminal’s
    `base64` command, and with Python. To try out these tools, run the jwt_generator.py
    script we created in section 11.3.3 to issue a new token.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理 JWT 时，你经常会遇到验证问题。要了解令牌验证失败的原因，检查载荷并验证其声明是否正确非常有用。在本节中，你将学习使用三种不同的工具来检查 JWT：jwt.io
    ([https://jwt.io](https://jwt.io))、终端的 `base64` 命令和 Python。要尝试这些工具，请运行我们在 11.3.3
    节中创建的 jwt_generator.py 脚本来发布新的令牌。
- en: '![](../Images/11-08.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图 11-08](../Images/11-08.png)'
- en: Figure 11.8 jwt.io is a tool that helps you to easily inspect and visualize
    JWTs. Simply paste the token on the left-side panel. You can also verify the token’s
    signature by pasting the public key in the VERIFY SIGNATURE box on the right.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8 jwt.io 是一个帮助你轻松检查和可视化 JWT 的工具。只需将令牌粘贴到左侧面板即可。你还可以通过在右侧的“验证签名”框中粘贴公钥来验证令牌的签名。
- en: 'jwt.io is an excellent tool that offers an easy way to inspect a JWT. As you
    can see in figure 11.8, all you need to do is paste the JWT in the input panel
    on the left. The display panel on the right will show you the contents of the
    token’s header and payload. You can also verify the token’s signature by providing
    your public key. To extract the public key from our public certificate, you can
    use the following command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: jwt.io 是一个优秀的工具，它提供了一种简单的方式来检查 JWT。如图 11.8 所示，你所需要做的就是将 JWT 粘贴到左侧的输入面板中。右侧的显示面板将显示令牌头部和载荷的内容。你还可以通过提供你的公钥来验证令牌的签名。要从我们的公钥证书中提取公钥，可以使用以下命令：
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This command outputs the public key to a file named pubkey.pem. You need to
    copy the contents of that file into the public key input panel in jwt.io to verify
    the token’s signature.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将公钥输出到名为 pubkey.pem 的文件中。你需要将文件内容复制到 jwt.io 的公钥输入面板中，以验证令牌的签名。
- en: 'You can also inspect the contents of the JWT by decoding the header and payload
    in the terminal using the `base64` command. For example, to decode the token’s
    header in the terminal, run the following command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过在终端中使用 `base64` 命令解码 JWT 的头部和载荷来检查 JWT 的内容。例如，要在终端中解码令牌的头部，运行以下命令：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can also inspect the contents of a JWT using Python’s `base64` library.
    To decode a JWT header with Python, open a Python shell and run the following
    code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 Python 的 `base64` 库来检查 JWT 的内容。要使用 Python 解码 JWT 头部，打开 Python 命令行并运行以下代码：
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Since the JWT payload is also base64url encoded, we use the same methods for
    decoding it. Now that we know how to inspect JWT payloads, let’s see how we validate
    them!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JWT 载荷也是 base64url 编码的，我们使用相同的方法来解码它。现在我们知道了如何检查 JWT 载荷，让我们看看如何验证它们！
- en: 11.3.5 Validating JWTs
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.5 验证 JWT
- en: There’re two parts to validating a JWT. On one hand, you must validate its signature,
    and on the other hand, you must validate that its claims are correct, for example,
    by ensuring that the token isn’t expired and that the audience is correct. This
    process must be clear; both steps of the validation process are required. An expired
    token with a valid signature shouldn’t be accepted by the API server, while an
    active token with an invalid signature isn’t any good either. Every user request
    to the server must carry a token, and the token must be validated on each request.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 验证 JWT 有两个部分。一方面，你必须验证其签名，另一方面，你必须验证其声明是否正确，例如，确保令牌未过期且受众正确。这个过程必须清晰；验证过程的两个步骤都是必需的。带有有效签名的过期令牌不应被
    API 服务器接受，而带有无效签名的活动令牌也没有任何价值。每个用户请求服务器都必须携带令牌，并且必须在每次请求中验证令牌。
- en: validate jwts on each request When a user interacts with our API server, they
    must send a JWT in each request, and we must validate the token on each request.
    Some implementations, especially those that use the authorization code flow we
    discussed in section 11.2.1, store tokens in a session cache and check the request’s
    token against the cache. That’s not how JWTs are meant to be used. JWTs are designed
    for stateless communication between the client and the server, and therefore must
    be validated using the methods we describe in this section.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个请求中验证 JWT 当用户与我们的 API 服务器交互时，他们必须在每个请求中发送一个 JWT，我们必须在每个请求中验证该令牌。一些实现，特别是那些使用我们在
    11.2.1 节中讨论的授权代码流，将令牌存储在会话缓存中，并将请求的令牌与缓存进行比较。这不是 JWT 应该被使用的方式。JWT 是为客户端和服务器之间的无状态通信而设计的，因此必须使用我们在本节中描述的方法进行验证。
- en: As we saw in section 11.3.3, tokens can be signed with a secret key or with
    a private/public key pair. For security, most websites use tokens that are signed
    with private/public keys, and to validate the signature of such tokens, we use
    the public key.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 11.3.3 节中看到的，令牌可以用秘密密钥或用私钥/公钥对进行签名。出于安全考虑，大多数网站使用用私钥/公钥签名的令牌，为了验证此类令牌的签名，我们使用公钥。
- en: Let’s see how we validate a token in code. We’ll use the signing key we created
    in section 11.3.3 to produce and validate the token. Activate your Pipenv environment
    by running `pipenv` `shell`, and execute the jwt_generator.py script to issue
    a new token.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在代码中验证令牌。我们将使用我们在 11.3.3 节中创建的签名密钥来生成和验证令牌。通过运行 `pipenv shell` 激活您的 Pipenv
    环境，并执行 jwt_generator.py 脚本来颁发新的令牌。
- en: 'To validate the token, we must first load the public key using the following
    code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证令牌，我们必须首先使用以下代码加载公钥：
- en: '[PRE14]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now that we have the public key available, we can use it to validate a token
    with the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了公钥，我们可以使用以下代码来验证令牌：
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, if the token is valid, we’ll get back the JWT payload. If the
    token is invalid, this code will raise an exception. Now that we know how to work
    with and validate JWTs, let’s see how we authorize requests in an API server.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，如果令牌有效，我们将返回 JWT 负载。如果令牌无效，此代码将引发异常。现在我们知道了如何处理和验证 JWT，让我们看看如何在 API 服务器中授权请求。
- en: 11.4 Adding authorization to the API server
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4 向 API 服务器添加授权
- en: Now that we know how to validate access tokens, let’s put all this code together
    in our API server. In this section, we add authorization to the orders API. Some
    endpoints of the orders API are protected, while others must be accessible to
    everyone. Our goal is to ensure that our server checks for valid access tokens
    under the protected endpoints.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何验证访问令牌，让我们将所有这些代码组合到我们的 API 服务器中。在本节中，我们向订单 API 添加授权。订单 API 的某些端点是受保护的，而其他端点必须对每个人可访问。我们的目标是确保我们的服务器在受保护端点下检查有效的访问令牌。
- en: We’ll allow public access to the /docs/orders and the /openapi/orders.json endpoints
    since they serve the API documentation that must be available for all consumers.
    All other endpoints require valid tokens. If the token is invalid or is missing
    in the request, we must reject the request with a 401 (Unauthorized) status code,
    which indicates that credentials are missing.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将允许公开访问 /docs/orders 和 /openapi/orders.json 端点，因为它们提供必须对所有消费者可用的 API 文档。所有其他端点都需要有效的令牌。如果令牌无效或请求中缺少令牌，我们必须以
    401（未授权）状态码拒绝请求，这表示凭证缺失。
- en: 'How do we add authorization to our APIs? There’re two major strategies: handling
    validation in an API gateway or handling validation in each service. An *API gateway*
    is a network layer that sits in front of our APIs.[⁸](#pgfId-1112127) The main
    role of an API gateway is to facilitate service discovery, but it can also be
    used to authorize user access, validate access tokens, and enrich the request
    with custom headers that add information about the user.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何向我们的 API 添加授权？有两种主要策略：在 API 网关中处理验证或在每个服务中处理验证。*API 网关* 是位于我们 API 前的网络层。[⁸](#pgfId-1112127)
    API 网关的主要作用是促进服务发现，但它也可以用于授权用户访问、验证访问令牌以及通过添加有关用户信息的自定义头来自定义请求。
- en: The second method is to handle authorization within each API. You’ll handle
    authorization at the service level when your API gateway can’t handle authorization
    or when an API gateway doesn’t fit in your architecture. In this section, we’ll
    learn to handle authorization within the service since we don’t have an API gateway.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是处理每个 API 内部的授权。当你的 API 网关无法处理授权或 API 网关不适合你的架构时，你将在服务级别处理授权。在本节中，我们将学习如何在服务内部处理授权，因为我们没有
    API 网关。
- en: A question that often comes up is, where exactly in our code do we handle authorization?
    Since authorization is needed to validate user access to the service through the
    API, we implement it in the API middleware. As you can see in figure 11.9, *middleware*
    is a layer of code that provides common functionality to process all our requests.
    Most web servers have a concept of middleware or request preprocessors, and that’s
    where our authorization code goes. Middleware components are usually executed
    in order, and typically we can choose the order in which they’re executed. Since
    authorization controls access to our server, the authorization middleware must
    be executed early.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 常常出现的一个问题是，我们的代码中在哪里处理授权？由于授权是验证用户通过 API 访问服务所必需的，我们将其实现为 API 中间件。如图 11.9 所示，*中间件*
    是一层代码，为处理所有请求提供通用功能。大多数 Web 服务器都有一个中间件或请求预处理器的概念，我们的授权代码就放在那里。中间件组件通常按顺序执行，我们通常可以选择它们的执行顺序。由于授权控制对服务器的访问，授权中间件必须尽早执行。
- en: '![](../Images/11-09.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片 11-09](../Images/11-09.png)'
- en: Figure 11.9 A request is first processed by the server middleware, such as the
    CORS and auth middleware, before making it to the router, which maps the request
    to the corresponding view function.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9 请求首先由服务器中间件处理，例如 CORS 和 auth 中间件，然后再到达路由器，路由器将请求映射到相应的视图函数。
- en: 11.4.1 Creating an authorization module
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.1 创建授权模块
- en: Let’s first create a module to encapsulate our authorization code. Create a
    file named orders/web/api/auth.py and copy the code in listing 11.3 into it. We
    start by loading the public key we created in section 11.3.3\. To validate the
    token, we first retrieve the headers and load the public key. We use PyJWT’s `decode()`
    function to validate the token, passing in as parameters the token itself, the
    public key required to validate the token, the expected list of audiences, and
    the algorithms used to sign the key.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个模块来封装我们的授权代码。创建一个名为 orders/web/api/auth.py 的文件，并将列表 11.3 中的代码复制进去。我们首先加载在
    11.3.3 节中创建的公钥。为了验证令牌，我们首先检索头信息并加载公钥。我们使用 PyJWT 的 `decode()` 函数来验证令牌，传入参数包括令牌本身、验证令牌所需的公钥、预期的受众列表以及用于签名密钥的算法。
- en: Listing 11.3 Adding an authorization module to the API
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.3 向 API 添加授权模块
- en: '[PRE16]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now that we created a module that encapsulates the functionality necessary to
    validate a JWT, let’s incorporate it into the API by adding a middleware that
    uses it to validate access to the API.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建了一个封装验证 JWT 所需功能的模块，让我们通过添加一个使用它来验证 API 访问的中间件将其集成到 API 中。
- en: 11.4.2 Creating an authorization middleware
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.2 创建授权中间件
- en: To add authorization to our API, we create an authorization middleware. Listing
    11.4 shows how to implement the authorization middleware. The code in listing
    11.4 goes into the orders/web/app.py file, with the newly added code in bold.
    We implement the middleware as a simple class called `AuthorizeRequestMiddleware`,
    which inherits from Starlette’s `BaseHTTPMiddleware` class. The entry point for
    the middleware must be implemented in a function called `dispatch``()`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要将授权添加到我们的 API 中，我们创建一个授权中间件。列表 11.4 展示了如何实现授权中间件。列表 11.4 中的代码放入 orders/web/app.py
    文件中，新添加的代码以粗体显示。我们将中间件实现为一个简单的类，称为 `AuthorizeRequestMiddleware`，它继承自 Starlette
    的 `BaseHTTPMiddleware` 类。中间件的入口点必须在名为 `dispatch()` 的函数中实现。
- en: We use a flag to determine whether we should enable authorization. The flag
    is an environment variable called `AUTH_ON`, and we set it to `False` by default.
    Often when working on a new feature or when debugging an issue in our API, it’s
    convenient to run the server locally without authorization. Using a flag allows
    us to switch authentication on and off according to our needs. If authorization
    is off, we add the default ID `test` for the request user.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个标志来确定是否应该启用身份验证。这个标志是一个名为`AUTH_ON`的环境变量，我们默认将其设置为`False`。通常在开发新功能或调试API中的问题时，在本地运行服务器而不进行身份验证是很方便的。使用标志允许我们根据需要切换身份验证的开启和关闭。如果身份验证关闭，我们为请求用户添加默认ID
    `test`。
- en: Next, we check whether the user is requesting the API documentation. In that
    case, we don’t block the request since we want to make the API documentation visible
    to all users; otherwise, they wouldn’t know how to form their requests correctly.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查用户是否请求API文档。如果是这种情况，我们不会阻止请求，因为我们希望让所有用户都能看到API文档；否则，他们不知道如何正确地构建他们的请求。
- en: We also check the request’s method. If it’s an OPTIONS request, we won’t attempt
    to authorize the request. OPTIONS requests are preflight requests, also known
    as cross-origin resource sharing (CORS) requests. The purpose of a preflight request
    is to check which origins, methods, and request headers are accepted by the API
    server, and according to W3’s specification, CORS requests must not require credentials
    ([https://www.w3.org/TR/2020/SPSD-cors-20200602/](https://www.w3.org/TR/2020/SPSD-cors-20200602/)).
    CORS requests are typically handled by the web server framework.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还检查请求的方法。如果是OPTIONS请求，我们不会尝试授权请求。OPTIONS请求是预检请求，也称为跨源资源共享（CORS）请求。预检请求的目的是检查API服务器接受哪些来源、方法和请求头，根据W3的规范，CORS请求不得要求凭据（[https://www.w3.org/TR/2020/SPSD-cors-20200602/](https://www.w3.org/TR/2020/SPSD-cors-20200602/)）。CORS请求通常由Web服务器框架处理。
- en: DEFINITION *CORS requests*, also known as preflight requests, are requests sent
    by the web browser to understand which methods, origins, and headers are accepted
    by the API server. If we don’t process CORS requests correctly, the web browser
    will abort communication with the API. Fortunately, most web frameworks contain
    plug-ins or extensions that handle CORS requests correctly. CORS requests aren’t
    authenticated, so when we add authorization to our server, we must ensure that
    preflight requests don’t require credentials.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**CORS请求**，也称为预检请求，是由网络浏览器发送的，以了解API服务器接受哪些方法、来源和头。如果我们没有正确处理CORS请求，网络浏览器将终止与API的通信。幸运的是，大多数Web框架都包含处理CORS请求的正确插件或扩展。CORS请求未进行身份验证，因此当我们向我们的服务器添加身份验证时，我们必须确保预检请求不需要凭据。'
- en: If it’s not a CORS request, we attempt to capture the token from the request
    headers. We expect the token under the Authorization header. If the Authorization
    header isn’t found, we reject the request with a 401 (Unauthorized) status code
    response. The format of the Authorization header’s value is `Bearer` `<ACCESS_TOKEN>`,
    so if the Authorization header is found, we capture the token by splitting the
    header value around the space, and we attempt to validate it. If the token is
    invalid, PyJWT will raise an exception. In our middleware, we capture PyJWT’s
    invalidation exceptions to make sure we can return a 401 status code response.
    If no exception is raised, it means the token is valid, and therefore we can process
    the request, so we return a call to the next callback. We also store the user
    ID from the token payload in the request’s `state` object so that we can access
    it later in the API views. Finally, to register the middleware, we use FastAPI’s
    `add_middleware()` method.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是CORS请求，我们尝试从请求头中捕获令牌。我们期望在“Authorization”头下找到令牌。如果找不到“Authorization”头，我们将以401（未授权）状态码响应拒绝请求。Authorization头的值格式为`Bearer`
    `<ACCESS_TOKEN>`，因此如果找到Authorization头，我们将通过在空格周围分割头值来捕获令牌，并尝试验证它。如果令牌无效，PyJWT将抛出异常。在我们的中间件中，我们捕获PyJWT的无效化异常，以确保我们可以返回401状态码响应。如果没有抛出异常，这意味着令牌是有效的，因此我们可以处理请求，所以返回对下一个回调的调用。我们还从令牌的有效载荷中捕获用户ID并将其存储在请求的`state`对象中，以便我们可以在API视图中稍后访问它。最后，为了注册中间件，我们使用FastAPI的`add_middleware()`方法。
- en: 'Where do json web tokens go? JWTs go in the request headers, typically under
    the Authorization header. An Authorization header with a JWT usually has the following
    format: `Authorization:` `Bearer` `<JWT>`.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: JSON Web 令牌去哪里了？JWTs 放在请求头中，通常在 Authorization 头下。带有 JWT 的 Authorization 头通常具有以下格式：`Authorization:`
    `Bearer` `<JWT>`。
- en: Listing 11.4 Adding an authorization middleware to the orders API
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.4 向订单 API 添加授权中间件
- en: '[PRE17]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ① We create a middleware class by inheriting from Starlette’s BaseHTTPMiddleware
    base class.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们通过从 Starlette 的 BaseHTTPMiddleware 基类继承来创建一个中间件类。
- en: ② We implement the middleware’s entry point.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们实现中间件的入口点。
- en: ③ We authorize the request if AUTH_ON is set to True.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 如果 AUTH_ON 设置为 True，我们授权请求。
- en: ④ If authorization is off, we bind a default user named test to the request.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 如果未启用授权，我们将默认用户 test 绑定到请求。
- en: ⑤ We return by calling the next callback.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 我们通过调用下一个回调来返回。
- en: ⑥ The documentation endpoints are publicly available, so we don’t authorize
    them.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 文档端点是公开可用的，所以我们不对它们进行授权。
- en: ⑦ We attempt to fetch the Authorization header.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 我们尝试获取 Authorization 头。
- en: ⑧ If the Authorization header isn’t set, we return a 401 response.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 如果没有设置 Authorization 头，我们返回一个 401 响应。
- en: ⑨ We capture the token from the Authorization header.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 我们从 Authorization 头中捕获令牌。
- en: ⑩ We validate and retrieve the token’s payload.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 我们验证并检索令牌的有效载荷。
- en: ⑪ If the token is invalid, we return a 401 response.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 如果令牌无效，我们返回一个 401 响应。
- en: ⑫ We capture the user ID from the token’s sub field.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ⑫ 我们从令牌的 sub 字段中捕获用户 ID。
- en: ⑬ We register the middleware using FastAPI’s add_middleware() method.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ⑬ 我们使用 FastAPI 的 add_middleware() 方法注册中间件。
- en: 'Our server is ready to start validating requests with JWTs! Let’s run a test
    to see our authorization code at work. Activate the virtual environment by running
    `pipenv` `shell`, and start the server with the following command:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器已准备好开始使用 JWT 验证请求！让我们运行一个测试来看看我们的授权代码是如何工作的。通过运行 `pipenv shell` 激活虚拟环境，并使用以下命令启动服务器：
- en: '[PRE18]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'From a different terminal, make an unauthenticated request using cURL (some
    of the output is truncated) with the `-i` flag, which displays additional information,
    such as the response status code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 从不同的终端，使用 cURL 发送一个未认证的请求（一些输出被截断），使用 `-i` 标志，它显示额外的信息，例如响应状态码：
- en: '[PRE19]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see, a request with a missing token is rejected with a 401 error
    and a message telling us that the access token is missing. Now generate a token
    using the jwt_ generator.py script we implemented in section 11.3.3, and use the
    token to make a new request:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，缺少令牌的请求被拒绝，并显示一个 401 错误和一个消息，告诉我们访问令牌缺失。现在使用我们在 11.3.3 节中实现的 jwt_generator.py
    脚本生成一个令牌，并使用该令牌发送一个新的请求：
- en: '[PRE20]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If the token is valid, this time you’ll get a successful response with a list
    of orders. Our authorization code is working! The next step is to ensure that
    users can access only their own resources in the server. Before we do that, though,
    let’s add one more piece of middleware to handle CORS requests.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果令牌有效，这次你会得到一个包含订单列表的成功响应。我们的授权代码正在工作！下一步是确保用户只能访问服务器上的自己的资源。在我们这样做之前，让我们再添加一个中间件来处理
    CORS 请求。
- en: 11.4.3 Adding CORS middleware
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.3 添加 CORS 中间件
- en: Since we’re going to allow interactions with a frontend application, we also
    need to enable the CORS middleware. As we saw in section 11.4.2, CORS requests
    are sent by the browser to know which headers, methods, and origins are allowed
    by the server. FastAPI’s CORS middleware takes care of populating our responses
    with the right information. Listing 11.5 shows how to modify the orders/web/app.py
    file to register the CORS middleware, with the newly added code in bold and omitting
    some of the code in listing 11.5 with an ellipsis.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们打算允许与前端应用程序进行交互，因此我们还需要启用 CORS 中间件。正如我们在 11.4.2 节中看到的，CORS 请求是由浏览器发送的，以了解服务器允许哪些头、方法和来源。FastAPI
    的 CORS 中间件负责用正确的信息填充我们的响应。列表 11.5 展示了如何修改 orders/web/app.py 文件以注册 CORS 中间件，其中加粗的新代码和省略号省略了列表
    11.5 中的部分代码。
- en: As we did previously, we use FastAPI’s `add_middleware()` method to register
    the CORS middleware, and we pass along the necessary configuration. For testing
    purposes, we’re using wildcards to allow all origins, methods, and headers, but
    in your production environment you must be more specific. In particular, you must
    restrict the allowed origins to your website’s domain and other trusted origins.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所做的那样，我们使用 FastAPI 的 `add_middleware()` 方法来注册 CORS 中间件，并传递必要的配置。出于测试目的，我们使用通配符来允许所有来源、方法和头部信息，但在您的生产环境中，您必须更加具体。特别是，您必须限制允许的来源为您的网站域名和其他受信任的来源。
- en: The order in which we register our middleware matters. Middleware is executed
    in reverse order of registration, so the latest registered middleware is executed
    first. Since the CORS middleware is required for all interactions between the
    frontend client and the API server, we register it last, which ensures it’s always
    executed.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注册中间件的顺序很重要。中间件是按照注册的逆序执行的，因此最新注册的中间件首先执行。由于 CORS 中间件对于前端客户端和 API 服务器之间的所有交互都是必需的，所以我们最后注册它，这确保了它总是被执行。
- en: Listing 11.5 Adding CORS middleware
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.5 添加 CORS 中间件
- en: '[PRE21]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ① We import Starlette’s CORSMiddleware class.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们导入 Starlette 的 CORSMiddleware 类。
- en: ② We register CORSMiddleware using FastAPI’s add_middleware() method.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们使用 FastAPI 的 add_middleware() 方法注册 CORSMiddleware。
- en: ③ We allow all origins.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们允许所有来源。
- en: ④ We support cookies for cross-origin requests.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 我们支持跨域请求的 cookies。
- en: ⑤ We allow all HTTP methods.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 我们允许所有 HTTP 方法。
- en: ⑥ We allow all headers.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 我们允许所有头部信息。
- en: We’re almost ready! Our server can now authorize users and handle CORS requests.
    The next step is to ensure each user can only access their data.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎准备好了！我们的服务器现在可以授权用户并处理 CORS 请求。下一步是确保每个用户只能访问他们的数据。
- en: 11.5 Authorizing resource access
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.5 授权资源访问
- en: We’ve protected our API by making sure only authenticated users can access it.
    Now we must ensure that the details of each order are only accessible to the user
    who placed it; we don’t want to allow users to access each other’s data. We call
    this type of validation *authorization*, and in this section, you’ll learn to
    add it to your APIs.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过确保只有经过身份验证的用户可以访问我们的 API 来保护了我们的 API。现在我们必须确保每个订单的详细信息只能由放置订单的用户访问；我们不希望允许用户访问彼此的数据。我们称这种类型的验证为
    *授权*，在本节中，您将学习如何将其添加到您的 API 中。
- en: 11.5.1 Updating the database to link users and orders
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.1 更新数据库以链接用户和订单
- en: 'We’ll start by removing the orders currently present in the database. Those
    orders are not associated with a user and therefore won’t work once we enforce
    an association between each order and a user. `cd` into the ch11 directory, activate
    the virtual environment by running `pipenv` `shell`, and open a Python shell by
    running the `python` command. Within the Python shell, run the following code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将数据库中现有的订单删除。这些订单没有与用户关联，因此一旦我们强制执行每个订单与用户的关联，它们将无法工作。进入 ch11 目录，通过运行 `pipenv
    shell` 激活虚拟环境，并通过运行 `python` 命令打开 Python shell。在 Python shell 中，运行以下代码：
- en: '[PRE22]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Our database is now clean, so we’re ready to get rolling. How do we associate
    each order with a user? A typical strategy is to create a user table and link
    our orders to user records via foreign keys. But does it really make sense to
    create a user table for the orders service? Do we want to have a user table per
    service?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据库名现在已清理，因此我们准备开始。我们如何将每个订单与用户关联起来？一种典型策略是创建一个用户表，并通过外键将我们的订单链接到用户记录。但为订单服务创建用户表真的有意义吗？我们想要为每个服务都有一个用户表吗？
- en: No, we don’t want to have a user table per service since it would involve lots
    of duplication. As you can see in figure 11.10, we want to have just one user
    table, and that table must be owned by the user service. Our user service is our
    identity-as-a-service provider, and therefore our user table already exists. Each
    user has already an ID, and as we saw in section 11.3.1, the ID is present in
    the JWT payload under the `sub` field. All we need to do is add a new column to
    the orders table to store the ID of the user who created the order.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 不，我们不想为每个服务都有一个用户表，因为这会涉及大量的重复。正如您在图 11.10 中所看到的，我们只想有一个用户表，并且该表必须由用户服务拥有。我们的用户服务是我们的身份即服务提供商，因此我们的用户表已经存在。每个用户都有一个
    ID，正如我们在 11.3.1 节中看到的，ID 存在于 JWT 有效载荷的 `sub` 字段下。我们所需做的只是向订单表添加一个新列来存储创建订单的用户
    ID。
- en: '![](../Images/11-10.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-10.png)'
- en: Figure 11.10 To avoid duplication, we keep only one user table under the identity
    service provider. And to avoid tight coupling between services, we avoid foreign
    keys between the tables owned by different services.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.10 为了避免重复，我们在身份服务提供程序下只保留一个用户表。为了避免服务之间的紧密耦合，我们避免在不同服务拥有的表之间使用外键。
- en: Linking users to their resources Two common anti-patterns in microservices architecture
    is to create one user table per service and to have a shared user table that is
    directly accessed by multiple services to create foreign keys between users and
    other resources. Having a user table per service is unnecessary and involves duplicates,
    while a shared user table across multiple services creates tight coupling between
    the services and risks breaking them the next time you change the user table’s
    schema. Since JWTs already contain opaque user IDs under the `sub` field, it’s
    good practice to rely on that identifier to link users to their resources.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 将用户与其资源关联起来 微服务架构中的两个常见反模式是每个服务创建一个用户表，以及有一个共享的用户表，该表被多个服务直接访问以创建用户与其他资源之间的外键。每个服务有一个用户表是不必要的，并且涉及重复，而多个服务之间的共享用户表会在服务之间创建紧密耦合，并冒着在更改用户表模式时破坏它们的危险。由于
    JWTs 已经在 `sub` 字段下包含不透明的用户 ID，因此依赖该标识符将用户与其资源关联起来是一个好的做法。
- en: Listing 11.6 shows how we add a `user_id` field to the `OrderModel` class. The
    following code goes in the orders/repository/models.py file, and the newly added
    code is highlighted in bold.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.6 展示了如何向 `OrderModel` 类添加 `user_id` 字段。以下代码位于 orders/repository/models.py
    文件中，新添加的代码以粗体突出显示。
- en: Listing 11.6 Adding a user ID foreign key to the order table
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.6 向订单表添加用户 ID 外键
- en: '[PRE23]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ① We add a new column called user_id.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们添加了一个名为 user_id 的新列。
- en: Now that we’ve updated the models, we need to update the database by running
    a migration. As we saw in chapter 7, running a migration is the process of updating
    the database schema. As we did in chapter 7, we use Alembic to manage our migrations,
    which is Python’s best database migration management library. Alembic checks the
    difference between the `OrderModel` model and the `order` table’s current schema,
    and it performs the necessary updates to add the `user_id` column.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经更新了模型，我们需要通过运行迁移来更新数据库。正如我们在第 7 章中看到的，运行迁移是更新数据库模式的过程。正如我们在第 7 章中所做的那样，我们使用
    Alembic 来管理我们的迁移，这是 Python 最好的数据库迁移管理库。Alembic 检查 `OrderModel` 模型和 `order` 表当前模式之间的差异，并执行必要的更新以添加
    `user_id` 列。
- en: ALTERING TABLES IN SQLITE SQLite has limited support for `ALTER` statements.
    For example, SQLite doesn’t support adding a new column to a table through an
    `ALTER` statement. As you can see in figure 11.11, to work around this problem,
    we need to copy the table’s data to a temporary table and drop the original table.
    Then we re-create the table with the new fields, copy the data from the temporary
    table, and drop the temporary table. Alembic handles these operations with its
    batch operations strategy.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLITE 中修改表 SQLite 对 `ALTER` 语句的支持有限。例如，SQLite 不支持通过 `ALTER` 语句向表中添加新列。如图
    11.11 所示，为了解决这个问题，我们需要将表的数据复制到临时表并删除原始表。然后我们使用新字段重新创建表，从临时表复制数据，并删除临时表。Alembic
    通过其批处理操作策略处理这些操作。
- en: '![](../Images/11-11.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/11-11.png)'
- en: Figure 11.11 When working with SQLite, we use batch operations to make changes
    to our tables. In a batch operation, we copy data from the original table to a
    temporary table; then, we drop the original table and re-create it with the new
    fields; and, finally, we copy back data from the temporary table.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.11 当与 SQLite 一起工作时，我们使用批处理操作来更改我们的表。在批处理操作中，我们从原始表复制数据到一个临时表；然后，我们删除原始表并使用新字段重新创建它；最后，我们从临时表复制数据回来。
- en: Before we can run the migration, we need to update the Alembic configuration.
    The change in listing 11.6 adds a new column to the order table, which translates
    into an `ALTER` `TABLE` SQL statement. For local development, we’re working with
    SQLite, which has limited support for `ALTER` statements. To ensure that Alembic
    generates the right migrations for SQLite, we need to update its configuration
    to run batch operations. *You only need to do this if you work with SQLite*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以运行迁移之前，我们需要更新 Alembic 配置。列表 11.6 中的更改向订单表添加了一个新列，这转化为一个 `ALTER` `TABLE`
    SQL 语句。对于本地开发，我们使用 SQLite，它对 `ALTER` 语句的支持有限。为了确保 Alembic 为 SQLite 生成正确的迁移，我们需要更新其配置以运行批处理操作。*只有当你使用
    SQLite 时才需要这样做*。
- en: 'To update the Alembic configuration so that we can run the migration, open
    the migrations/env.py file and search for a function called `run_migrations_online``()`.
    This is the function that runs the migrations against our database. Within that
    function, search for the following block:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新 Alembic 配置以便我们可以运行迁移，打开 migrations/env.py 文件并搜索一个名为 `run_migrations_online()`
    的函数。这个函数运行迁移以针对我们的数据库。在该函数内部，搜索以下代码块：
- en: '[PRE24]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And add the following line (highlighted in bold) within the call to the `configure()`
    method:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `configure()` 方法的内部添加以下行（以粗体突出显示）：
- en: '[PRE25]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now we can generate the Alembic migration and update the database. Run the
    following command to create the new migration:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以生成 Alembic 迁移并更新数据库。运行以下命令以创建新的迁移：
- en: '[PRE26]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we run the migration with the following command:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用以下命令运行迁移：
- en: '[PRE27]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Our database is now ready to start linking orders and users. The next section
    explains how we fetch the user ID from the `request` object and feed it to our
    data repositories.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据库名单现在已准备好开始链接订单和用户。下一节将解释我们如何从 `request` 对象中获取用户 ID 并将其传递给我们的数据存储库。
- en: 11.5.2 Restricting user access to their own resources
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.2 限制用户访问他们自己的资源
- en: Now that our database is ready, we need to update our API views to capture the
    user ID when creating or updating an order, or when retrieving the list of orders.
    Since the changes that we need to make to our view functions are all quite similar,
    we’ll illustrate how to apply the changes to some of the views. You can refer
    to the GitHub repository for this book for the full list of changes.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们数据库已准备好，我们需要更新我们的 API 视图以在创建或更新订单，或检索订单列表时捕获用户 ID。由于我们需要对视图函数进行的更改都非常相似，我们将展示如何将这些更改应用到一些视图中。你可以参考这本书的
    GitHub 仓库以获取更改的完整列表。
- en: Listing 11.7 shows how to update the `create_order()` view function to capture
    the user ID when placing the order. The newly added code is highlighted in bold.
    As we saw in section 11.4.2, we store the user ID under the request’s `state`
    property, so the first change we make is changing the signature of the `create_order()`
    function to include the `request` object. The second change is passing the user
    ID to the `OrderService`’s `place_order()` method.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.7 展示了如何更新 `create_order()` 视图函数以在下单时捕获用户 ID。新添加的代码以粗体突出显示。正如我们在 11.4.2
    节中看到的，我们在请求的 `state` 属性下存储用户 ID，所以我们做的第一个更改是将 `create_order()` 函数的签名更改以包括 `request`
    对象。第二个更改是将用户 ID 传递给 `OrderService` 的 `place_order()` 方法。
- en: Listing 11.7 Capturing the user ID when placing an order
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.7 在下单时捕获用户 ID
- en: '[PRE28]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ① We capture the request object in the function signature.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们在函数签名中捕获请求对象。
- en: ② We capture the user ID from the request’s state object.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们从请求的状态对象中捕获用户 ID。
- en: 'We also need to change the `OrdersService` and the `OrdersRepository` to ensure
    they too capture the user ID. The following code shows how to update the `OrdersService`
    to capture the user ID:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更改 `OrdersService` 和 `OrdersRepository` 以确保它们也能捕获用户 ID。以下代码展示了如何更新 `OrdersService`
    以捕获用户 ID：
- en: '[PRE29]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And the following code shows how to update the `OrdersRepository` to capture
    the user ID:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何更新 `OrdersRepository` 以捕获用户 ID：
- en: '[PRE30]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now that we know how to save an order with the user ID, let’s see how we make
    sure a user gets only a list of their own orders when they call the GET `/orders`
    endpoint. Listing 11.8 shows the changes required to the `get_orders()` function,
    which implements the GET `/orders` endpoint. The newly added code is shown in
    bold. As you can see, in this case we also need to change the function’s signature
    to capture the request object. Then we simply pass on the user ID as one of the
    query filters. No additional changes are required anywhere else in the code since
    both `OrdersService` and `OrdersRepository` are designed to accept arbitrary dictionaries
    of filters.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何使用用户 ID 保存订单，让我们看看我们如何确保当用户调用 GET `/orders` 端点时，他们只能获取他们自己的订单列表。列表
    11.8 展示了对 `get_orders()` 函数所需的更改，该函数实现了 GET `/orders` 端点。新添加的代码以粗体显示。正如你所见，在这种情况下，我们还需要更改函数的签名以捕获请求对象。然后我们简单地将用户
    ID 作为查询过滤器之一传递。由于 `OrdersService` 和 `OrdersRepository` 都被设计为接受任意字典的过滤器，所以代码的其他部分不需要任何额外更改。
- en: Listing 11.8 Ensuring a user only gets a list of their own orders
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.8 确保用户只能获取他们自己的订单列表
- en: '[PRE31]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let’s now turn our attention to the GET `/orders/{order_id}` endpoint. What
    happens if a user tries to retrieve the details of an order that doesn’t belong
    to them? We can respond with two strategies: return a 404 (Not Found) response
    indicating that the requested order doesn’t exist, or respond with a 403 (Forbidden)
    response, indicating that the user doesn’t have access to the requested resource.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将注意力转向GET `/orders/{order_id}`端点。如果用户尝试检索不属于他们的订单的详细信息会发生什么？我们可以采取两种策略：返回404（未找到）响应，表明请求的订单不存在，或者返回403（禁止）响应，表明用户没有访问请求资源的权限。
- en: Technically, a 403 response is more correct than a 404 when a user is trying
    to access a resource that doesn’t belong to them. But it also exposes unnecessary
    information. A malicious user who has valid credentials could leverage our 403
    responses to build a map of the existing resources in the server. To avoid that
    problem, we opt for disclosing less information and return a 404 response. The
    user ID will become an additional filter when we attempt to retrieve an order
    from the database.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上讲，当用户试图访问不属于他们的资源时，返回403响应比404响应更正确。但这也暴露了不必要的详细信息。一个拥有有效凭证的恶意用户可能会利用我们的403响应来构建服务器上现有资源的映射。为了避免这个问题，我们选择披露更少的信息，并返回404响应。当尝试从数据库中检索订单时，用户ID将变成一个额外的过滤器。
- en: The following code shows the changes required to the `get_order()` function
    to include the user ID in our queries, with the newly added code in bold. Again,
    we include the request object in the function signature, and we pass on the user
    ID to the `OrderService`’s `get_order()` method.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了`get_order()`函数所需的更改，以包括用户ID在我们的查询中，新添加的代码以粗体显示。同样，我们将请求对象包含在函数签名中，并将用户ID传递给`OrderService`的`get_order()`方法。
- en: Listing 11.9 Filtering orders with order ID and user ID
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.9 使用订单ID和用户ID过滤订单
- en: '[PRE32]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To be able to query orders by user ID as well, we also need to update the `OrdersService`
    and the `OrdersRepository` classes. We’ll change their methods to accept an optional
    dictionary of arbitrary filters. The `OrdersService`’s `get_order()` method changes
    like this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够按用户ID查询订单，我们还需要更新`OrdersService`和`OrdersRepository`类。我们将更改它们的方法以接受一个可选的任意过滤器字典。`OrdersService`的`get_order()`方法更改如下：
- en: '[PRE33]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And the `OrdersRepository`’s `get()` and `_get()` methods require the following
    changes:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 并且`OrdersRepository`的`get()`和`_get()`方法需要以下更改：
- en: '[PRE34]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The rest of the view functions in the orders/web/api/api.py file require changes
    similar to the ones we’ve seen in this section, and the same goes for the remaining
    methods of the `OrdersService` and the `OrdersRepository` classes. As an exercise,
    I recommend you try to complete the changes necessary to add authorization to
    the remaining API endpoints. The GitHub repository for this book contains the
    full list of changes, so feel free to check it out for guidance.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`orders/web/api/api.py`文件中其余的视图函数需要与这一节中看到的类似更改，同样适用于`OrdersService`和`OrdersRepository`类的其余方法。作为一个练习，我建议您尝试完成添加授权到剩余API端点所需的更改。本书的GitHub存储库包含了完整的更改列表，因此请随时查看以获取指导。'
- en: This concludes our journey through API authentication and authorization, and
    what a journey! You’ve learned what OAuth and OpenID Connect are and how they
    work. You’ve learned about OAuth flows and when to use each flow. You’ve learned
    what JWTs are, how to inspect their payloads, and how to produce and validate
    them. Finally, you’ve learned how to authorize API requests and how to authorize
    user access to specific resources. You’ve got all you need to start adding robust
    authentication and authorization to your own APIs!
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们通过API身份验证和授权的旅程结束，这是一段怎样的旅程！您已经学习了OAuth和OpenID Connect是什么以及它们是如何工作的。您已经了解了OAuth流程以及何时使用每个流程。您已经了解了JWT是什么，如何检查它们的负载，以及如何生成和验证它们。最后，您已经学习了如何授权API请求以及如何授权用户访问特定资源。您已经拥有了开始为您的API添加强大身份验证和授权所需的一切！
- en: Appendix C teaches you how to integrate with an identity provider such as Auth0\.
    You’ll also see practical examples of how to use the PKCE and client credentials
    flows, and you’ll learn to authorize your requests using a Swagger UI.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C教您如何与身份提供者（如Auth0）集成。您还将看到如何使用PKCE和客户端凭证流量的实际示例，并学习如何使用Swagger UI授权您的请求。
- en: Summary
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: We authorize access to our APIs using the standard protocols OAuth and OpenID
    Connect.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用标准的OAuth和OpenID Connect协议授权访问我们的API。
- en: 'OAuth is an access delegation protocol that allows a user to grant an application
    access to resources they own in a different website. It distinguishes four authorization
    flows:'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth 是一种访问委派协议，允许用户授予应用程序访问他们不同网站上的资源的权限。它区分了四种授权流程：
- en: '*Authorization code*—The API server exchanges a code with the authorization
    server to request the user’s access token.'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*授权代码*——API 服务器与授权服务器交换代码，以请求用户的访问令牌。'
- en: '*PKCE*—The client application, typically an SPA, uses a code verifier and a
    code challenge to obtain an access token from the authorization server.'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PKCE*——客户端应用程序（通常是单页应用程序）使用代码验证器和代码挑战从授权服务器获取访问令牌。'
- en: '*Client credentials*—The client, typically another microservice, exchanges
    a private secret in return for an access token.'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*客户端凭证*——客户端（通常是另一个微服务）通过交换一个私有密钥来换取访问令牌。'
- en: '*Refresh token*—A client obtains a new access token in exchange for a refresh
    token.'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*刷新令牌*——客户端通过交换刷新令牌来获取新的访问令牌。'
- en: OpenID Connect is an identity verification protocol that builds on top of OAuth.
    It helps users easily authenticate to new websites by bringing their identity
    from other websites, such as Google or Facebook.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenID Connect 是一个基于 OAuth 的身份验证协议，它帮助用户通过从其他网站（如 Google 或 Facebook）带来他们的身份，轻松地验证到新网站。
- en: JWTs are JSON documents that contain claims about the user’s access permissions.
    JWTs are encoded using base64url encoding and are typically signed using a private/public
    key.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JWT 是包含关于用户访问权限声明的 JSON 文档。JWT 使用 base64url 编码，通常使用私有/公钥进行签名。
- en: To authenticate a request, users send their access tokens in the request’s Authorization
    header. The expected format of this header is `Authorization:` `Bearer` `<ACCESS_TOKEN>`.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要验证请求，用户将在请求的授权头中发送他们的访问令牌。此头的预期格式为 `Authorization:` `Bearer` `<ACCESS_TOKEN>`。
- en: We use PyJWT to validate access tokens. PyJWT checks that the token isn’t expired,
    that the audience is correct, and that the signature can be verified with one
    of the available public keys. If the token is invalid, we reject the request with
    a 401 (Unauthorized) response.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 PyJWT 验证访问令牌。PyJWT 检查令牌是否未过期，受众是否正确，以及签名是否可以使用可用的公钥之一进行验证。如果令牌无效，我们以 401（未授权）响应拒绝请求。
- en: To link users to their resources, we use the user ID as represented in the `sub`
    claim of the JWT.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了将用户与其资源链接起来，我们使用 JWT 的 `sub` 声明中表示的用户 ID。
- en: If a user tries to access a resource that doesn’t belong to them, we respond
    with a 403 (Forbidden) response.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户尝试访问不属于他们的资源，我们将以 403（禁止）响应。
- en: OPTIONS requests are known as CORS requests or preflight requests. CORS requests
    must not be protected by credentials.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OPTIONS 请求被称为 CORS 请求或预检请求。CORS 请求不得由凭据保护。
- en: '* * *'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ¹ The issue was reported first by Brian Krebs, “USPS Site Exposed Data on 60
    Million Users,” KrebsOnSecurity, November 21, 2018, [https://krebsonsecurity.com/2018/11/usps-site-exposed-data-on-60-million-users/](https://krebsonsecurity.com/2018/11/usps-site-exposed-data-on-60-million-users/).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ 该问题首先由 Brian Krebs 报告，“USPS 网站泄露了 6000 万用户的个人信息”，KrebsOnSecurity，2018年11月21日，[https://krebsonsecurity.com/2018/11/usps-site-exposed-data-on-60-million-users/](https://krebsonsecurity.com/2018/11/usps-site-exposed-data-on-60-million-users/)。
- en: ² Bill Doerfeld, “API Attack Traffic Grew 300+% In the Last Six Months,” *Security
    Boulevard*, July 30, 2021, [https://securityboulevard.com/2021/07/api-attack-traffic-grew-300-in-the-last-six-months/](https://securityboulevard.com/2021/07/api-attack-traffic-grew-300-in-the-last-six-months/).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ² Bill Doerfeld，“过去六个月内 API 攻击流量增长了 300%以上”，*Security Boulevard*，2021年7月30日，[https://securityboulevard.com/2021/07/api-attack-traffic-grew-300-in-the-last-six-months/](https://securityboulevard.com/2021/07/api-attack-traffic-grew-300-in-the-last-six-months/)。
- en: ³ Joe Galvin, “60 Percent of Small Businesses Fold Within 6 Months of a Cyber
    Attack,” *Inc.*, May 7, 2018, [https://www.inc.com/joe-galvin/60-percent-of-small-businesses-fold-within-6-months-of-a-cyber-attack-heres-how-to-protect-yourself.html](https://www.inc.com/joe-galvin/60-percent-of-small-businesses-fold-within-6-months-of-a-cyber-attack-heres-how-to-protect-yourself.html).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ³ Joe Galvin，“60%的小企业在遭受网络攻击后的六个月内倒闭，”*Inc.*，2018年5月7日，[https://www.inc.com/joe-galvin/60-percent-of-small-businesses-fold-within-6-months-of-a-cyber-attack-heres-how-to-protect-yourself.html](https://www.inc.com/joe-galvin/60-percent-of-small-businesses-fold-within-6-months-of-a-cyber-attack-heres-how-to-protect-yourself.html)。
- en: ⁴ [https://oauth.net/](https://oauth.net/) is a pretty good website with tons
    of resources to learn more about the OAuth specification.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ⁴ [https://oauth.net/](https://oauth.net/) 是一个很好的网站，提供了大量关于 OAuth 规范的学习资源。
- en: ⁵ N. Sakimura, J. Bradley, and N. Agarwal, “Proof Key for Code Exchange by OAuth
    Public Clients,” IETF RFC 7636, September 2015, [https://datatracker.ietf.org/doc/html/rfc7636](https://datatracker.ietf.org/doc/html/rfc7636).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ⁵ N. Sakimura、J. Bradley和N. Agarwal，“OAuth公共客户端的代码交换证明密钥”，IETF RFC 7636，2015年9月，[https://datatracker.ietf.org/doc/html/rfc7636](https://datatracker.ietf.org/doc/html/rfc7636)。
- en: ⁶ The full specification for how JSON Web Tokens should be produced and validated
    is available under J. Jones, J. Bradley, and N. Sakimura, “JSON Web Token (JWT),”
    RFC-7519, May 2015, [https://datatracker.ietf.org/doc/html/rfc7519](https://datatracker.ietf.org/doc/html/rfc7519).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ⁶ JSON Web Tokens（JWT）的完整生成和验证规范可在J. Jones、J. Bradley和N. Sakimura的“JSON Web
    Token (JWT)”RFC-7519文档中找到，发布于2015年5月，[https://datatracker.ietf.org/doc/html/rfc7519](https://datatracker.ietf.org/doc/html/rfc7519)。
- en: ⁷ You can see a full list of the most commonly used JWT claims under [https://www.iana.org/assignments/jwt/jwt.xhtml](https://www.iana.org/assignments/jwt/jwt.xhtml).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://www.iana.org/assignments/jwt/jwt.xhtml](https://www.iana.org/assignments/jwt/jwt.xhtml)查看最常用的JWT声明的完整列表。
- en: '⁸ See Chris Richardson, “Pattern: API Gateway/Backends for Frontends,” [https://microservices.io/patterns/apigateway.html](https://microservices.io/patterns/apigateway.html).'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅Chris Richardson的“模式：API网关/前端后端”，[https://microservices.io/patterns/apigateway.html](https://microservices.io/patterns/apigateway.html)。
