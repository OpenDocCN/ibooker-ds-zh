- en: 6 Client-side GraphQL with React and Apollo Client
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 使用 React 和 Apollo 客户端进行客户端 GraphQL
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节涵盖
- en: Connecting a React application to a GraphQL endpoint, using Apollo Client
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Apollo 客户端连接 React 应用程序到 GraphQL 端点
- en: Caching and updating data on the client, using Apollo Client
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Apollo 客户端在客户端缓存和更新数据
- en: Updating data in the application, using GraphQL mutations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GraphQL 变更更新应用中的数据
- en: Using Apollo Client to manage React client state data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Apollo 客户端管理 React 客户端状态数据
- en: 'In the previous chapter, we created a React application, using Create React
    App, that allowed users to search for businesses by category. We used a single
    JavaScript object hardcoded into the application as the source of our data, so
    our application had limited functionality. In this chapter, we explore connecting
    our React application to the GraphQL API we created in previous chapters and introduce
    a new tool to our GraphQL toolbox: Apollo Client.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用 Create React App 创建了一个 React 应用程序，允许用户通过类别搜索企业。我们使用一个硬编码到应用程序中的单个
    JavaScript 对象作为我们数据源，因此我们的应用程序功能有限。在本章中，我们将探索将我们的 React 应用程序连接到我们在上一章中创建的 GraphQL
    API，并向我们的 GraphQL 工具箱引入一个新工具：Apollo 客户端。
- en: '*Apollo Client* is a data management JavaScript library that enables developers
    to manage both local and remote data with GraphQL. It is used to fetch, cache,
    and modify application data and offers a number of frontend framework integrations,
    including React, to enable updating your UI as data changes.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*Apollo 客户端* 是一个数据管理 JavaScript 库，使开发者能够使用 GraphQL 管理本地和远程数据。它用于获取、缓存和修改应用数据，并提供了一系列前端框架集成，包括
    React，以实现数据变化时更新您的 UI。'
- en: We’ll use the React Hooks API for Apollo Client to populate our React app with
    data from our GraphQL API, issuing data-fetching GraphQL queries using Apollo
    Client. We’ll then explore GraphQL mutation operations for updating data via our
    GraphQL API, seeing how to handle changing application data. Finally, we’ll see
    how to use Apollo Client for managing the local state of our React application,
    called *client state management*, by adding local-only fields to our GraphQL API.
    Let’s get started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Apollo 客户端的 React Hooks API 来用我们的 GraphQL API 中的数据填充我们的 React 应用程序，通过
    Apollo 客户端发出数据获取 GraphQL 查询。然后，我们将探索通过我们的 GraphQL API 更新数据的 GraphQL 变更操作，了解如何处理应用程序数据的变化。最后，我们将了解如何使用
    Apollo 客户端来管理我们的 React 应用程序的本地状态，称为 *客户端状态管理*，通过向我们的 GraphQL API 添加仅本地字段来实现。让我们开始吧！
- en: 6.1 Apollo Client
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 Apollo 客户端
- en: 'Apollo Client is much more than just a library that sends and receives graph
    data. As the Apollo Client docs say:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Apollo 客户端不仅仅是一个发送和接收图数据的库。正如 Apollo 客户端文档所说：
- en: '*Apollo Client is a comprehensive state management library for JavaScript that
    enables you to manage both local and remote data with GraphQL. Use it to fetch,
    cache, and modify application data, all while automatically updating your UI.
    ... Apollo Client helps you structure code in an economical, predictable, and
    declarative way that’s consistent with modern development practices. The core
    @apollo/client library provides built-in integration with React, and the larger
    Apollo community maintains integrations for other popular view layers.*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*Apollo 客户端是一个全面的 JavaScript 状态管理库，它使您能够使用 GraphQL 管理本地和远程数据。使用它来获取、缓存和修改应用数据，同时自动更新您的
    UI。... Apollo 客户端帮助您以经济、可预测和声明式的方式构建代码，这与现代开发实践保持一致。核心 @apollo/client 库提供了与 React
    的内置集成，而更大的 Apollo 社区维护了与其他流行视图层的集成。*'
- en: —[https://www.apollographql.com/docs/react/](https://www.apollographql.com/docs/react/)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: —[https://www.apollographql.com/docs/react/](https://www.apollographql.com/docs/react/)
- en: We’ll take advantage of these features of Apollo Client as we add it to our
    React application, first adding data-fetching logic, and then using Apollo Client
    to manage local state data in our React application.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在将 Apollo 客户端添加到我们的 React 应用程序时利用这些功能，首先添加数据获取逻辑，然后使用 Apollo 客户端来管理我们的 React
    应用程序中的本地状态数据。
- en: 6.1.1 Adding Apollo Client to our React Application
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.1 将 Apollo 客户端添加到我们的 React 应用程序中
- en: Since we’re using React, we’ll focus on the React-specific integration for Apollo
    Client. First, we’ll install Apollo Client using npm, create an Apollo Client
    instance connected to our GraphQL API, and then start issuing data-fetching queries
    in our React application, using the useQuery React Hook provided by Apollo Client.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用 React，我们将专注于 Apollo 客户端的 React 特定集成。首先，我们将使用 npm 安装 Apollo 客户端，创建一个连接到我们的
    GraphQL API 的 Apollo 客户端实例，然后在我们的 React 应用程序中开始发出数据获取查询，使用 Apollo 客户端提供的 useQuery
    React 钩子。
- en: Since we’ll be querying our GraphQL API, make sure that our Neo4j database and
    GraphQL API application from previous chapters are both running. If they are not,
    we’ll see errors indicating that Apollo Client isn’t able to reach the GraphQL
    endpoint.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将查询我们的 GraphQL API，请确保我们之前章节中的 Neo4j 数据库和 GraphQL API 应用程序都在运行。如果它们没有运行，我们将看到错误信息，表明
    Apollo Client 无法连接到 GraphQL 端点。
- en: Installing Apollo Client
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Apollo Client
- en: As of this writing, Apollo Client 3.5.5 is the latest release of Apollo Client,
    and most of the tools we need to add GraphQL support to our React application
    are included in a single package. Previous Apollo Client releases bundled React
    Hooks separately; however, the React integration is now included by default.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 到本文写作时，Apollo Client 3.5.5 是 Apollo Client 的最新版本，我们添加 GraphQL 支持所需的大部分工具都包含在一个单独的包中。之前的
    Apollo Client 版本将 React Hooks 单独打包；然而，React 集成现在默认包含在内。
- en: 'Open a terminal, make sure you’re in the web-react directory, and run the following
    command to install Apollo Client. We also need to install the graphql.js peer
    dependency for Apollo Client. We are using the most recent version of Apollo Client
    as of this writing, which is v3.5.5:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端，确保你处于 web-react 目录中，然后运行以下命令来安装 Apollo Client。我们还需要安装 Apollo Client 的 peer
    dependency graphql.js。我们使用的是本文写作时的最新版本 Apollo Client，即 v3.5.5：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now that Apollo Client is installed, we can create an Apollo Client instance
    and start issuing GraphQL queries. First, we’ll see how to do this in a generic
    way, and then we’ll add this functionality to our React application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Apollo Client 已经安装，我们可以创建一个 Apollo Client 实例并开始发出 GraphQL 查询。首先，我们将以通用方式展示如何做到这一点，然后我们将添加此功能到我们的
    React 应用程序中。
- en: Creating an Apollo Client instance
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 Apollo Client 实例
- en: To create a new Apollo Client instance, we need to pass the URI for the GraphQL
    API we’d like to connect to as well as the cache we’d like to use to the Apollo
    Client constructor, as the next listing shows. The most common cache type is Apollo’s
    InMemoryCache.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的 Apollo Client 实例，我们需要将我们想要连接的 GraphQL API 的 URI 以及我们想要使用的缓存传递给 Apollo
    Client 构造函数，如下一个列表所示。最常用的缓存类型是 Apollo 的 InMemoryCache。
- en: Listing 6.1 Creating an Apollo Client instance
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.1 创建 Apollo Client 实例
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can, then, use this client instance to execute GraphQL operations.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用这个客户端实例来执行 GraphQL 操作。
- en: Making a Query with Apollo Client
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Apollo Client 进行查询
- en: First, let’s look at listing 6.2 to see how to execute a GraphQL query using
    the client API. In our React application, most of the time we’ll want to take
    advantage of the React Hooks API for Apollo Client, so this code won’t be part
    of our application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们查看列表 6.2，看看如何使用客户端 API 执行 GraphQL 查询。在我们的 React 应用程序中，大多数情况下我们希望利用 Apollo
    Client 的 React Hooks API，因此这段代码不会成为我们应用程序的一部分。
- en: Listing 6.2 Executing a query using Apollo Client
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.2 使用 Apollo Client 执行查询
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that we wrap our GraphQL query with the gql template literal tag. The purpose
    of this is to parse GraphQL query strings into the standard GraphQL abstract syntax
    tree (AST) understood by GraphQL clients. Here we are executing a GraphQL query
    operation to fetch businesses, returning only the name of each business and logging
    to the console.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将我们的 GraphQL 查询包裹在 gql 模板字面量标签中。这样做是为了将 GraphQL 查询字符串解析成 GraphQL 客户端理解的标准的
    GraphQL 抽象语法树 (AST)。在这里，我们执行一个 GraphQL 查询操作来获取企业信息，只返回每个企业的名称，并将日志记录到控制台。
- en: This minimal Apollo Client example is depicted in figure 6.1\. Our Apollo Client
    instance sends a GraphQL query operation to the GraphQL server, which responds
    with data and is then stored in the Apollo Client cache. Subsequent requests for
    the same data will read from the cache instead of sending a request to the GraphQL
    server. Later in the chapter, we’ll cover how to work with the Apollo Client cache
    directly.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最小的 Apollo Client 示例在图 6.1 中展示。我们的 Apollo Client 实例向 GraphQL 服务器发送 GraphQL
    查询操作，服务器响应数据，然后存储在 Apollo Client 缓存中。后续对相同数据的请求将直接从缓存中读取，而不是发送请求到 GraphQL 服务器。在本章的后面部分，我们将介绍如何直接与
    Apollo Client 缓存交互。
- en: '![CH06_F01_Lyon](../../OEBPS/Images/CH06_F01_Lyon.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F01_Lyon](../../OEBPS/Images/CH06_F01_Lyon.png)'
- en: Figure 6.1 A minimal Apollo Client example
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 最小 Apollo Client 示例
- en: Now that we understand the basics of Apollo Client, let’s see how to implement
    them in our React application.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Apollo Client 的基础知识，让我们看看如何在我们的 React 应用程序中实现它们。
- en: Injecting Apollo Client into the component hierarchy
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Apollo Client 注入组件层次结构
- en: The first thing we’ll need to do is inject the client instance into the React
    component hierarchy, making it available in each of our components. To do this,
    we’ll make a few changes to the web-react/src/index.js file, which was generated
    by Create React App.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要做的是将客户端实例注入到 React 组件层次结构中，使其在各个组件中可用。为此，我们将对由 Create React App 生成的 web-react/src/index.js
    文件进行一些修改。
- en: 'Listing 6.3 web-react/src/index.js: Creating an Apollo Client instance'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6.3 web-react/src/index.js: 创建 Apollo 客户端实例'
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Create an Apollo Client instance.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个 Apollo 客户端实例。
- en: ❷ Use the Apollo Provider component to inject the client instance into the React
    component hierarchy.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 Apollo Provider 组件将客户端实例注入到 React 组件层次结构中。
- en: Once we create an Apollo Client instance that is connected to our GraphQL API,
    we wrap our App component with the Apollo Provider component, passing our client
    instance as a prop to the ApolloProvider component. This will allow any of the
    components in our React application to access the client instance and execute
    GraphQL operations. We’ll do that via the React Hooks API in any of our components
    that require data fetching logic (see figure 6.2).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了一个连接到我们的 GraphQL API 的 Apollo 客户端实例，我们就将我们的 App 组件包裹在 Apollo Provider
    组件中，将我们的客户端实例作为属性传递给 ApolloProvider 组件。这将允许我们的 React 应用程序中的任何组件访问客户端实例并执行 GraphQL
    操作。我们将在需要数据获取逻辑的任何组件中通过 React Hooks API 来做这件事（见图 6.2）。
- en: '![CH06_F02_Lyon](../../OEBPS/Images/CH06_F02_Lyon.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F02_Lyon](../../OEBPS/Images/CH06_F02_Lyon.png)'
- en: Figure 6.2 Injecting our Apollo Client instance into the React component hierarchy
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 将我们的 Apollo 客户端实例注入到 React 组件层次结构
- en: 6.1.2 Apollo Client hooks
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.2 Apollo 客户端钩子
- en: The Apollo Client React integration includes React hooks for working with data.
    The useQuery React hook is the primary method for executing GraphQL queries. To
    learn how to use the useQuery hooks, let’s start updating our App component to
    search data in the GraphQL API, instead of using the hardcoded data array.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Apollo Client React 集成包括用于处理数据的 React 钩子。useQuery React 钩子是执行 GraphQL 查询的主要方法。为了了解如何使用
    useQuery 钩子，让我们开始更新我们的 App 组件，以便在 GraphQL API 中搜索数据，而不是使用硬编码的数据数组。
- en: 'Listing 6.4 web-react/src/App.js: Adding a GraphQL query'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6.4 web-react/src/App.js: 添加 GraphQL 查询'
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Import the useQuery hook.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入 useQuery 钩子。
- en: ❷ Define the GraphQL query to search for businesses.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义 GraphQL 查询以搜索企业。
- en: ❸ The useQuery hook exposes the various lifecycle states of running the GraphQL
    operation.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ useQuery 钩子暴露了运行 GraphQL 操作的各种生命周期状态。
- en: ❹ We pass the GraphQL response to the BusinessResults component.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 我们将 GraphQL 响应传递给 BusinessResults 组件。
- en: 'First, we import the useQuery hook and gql template literal tag. Then, we define
    the GraphQL query to search for businesses and return the data we need to render
    the results in our results table. Next, we pass this GraphQL query to the useQuery
    hook, which returns state objects that let us inspect the various states of the
    GraphQL operation: loading, error, and data. While the query is loading, we can
    display an indication to the user that we’re fetching data. If our GraphQL query
    returned an error, we can render some error result to the user. Finally, once
    the data object is populated, we know that our GraphQL query has completed successfully,
    and we can pass that data as props to the BusinessResults component, which is
    responsible for rendering our results table (see figure 6.3).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入 useQuery 钩子和 gql 模板字面量标签。然后，我们定义一个 GraphQL 查询来搜索企业并返回我们需要在结果表中渲染的数据。接下来，我们将这个
    GraphQL 查询传递给 useQuery 钩子，它返回状态对象，让我们检查 GraphQL 操作的各种状态：加载、错误和数据。当查询正在加载时，我们可以向用户显示我们正在获取数据的指示。如果我们的
    GraphQL 查询返回了错误，我们可以向用户渲染一些错误结果。最后，一旦数据对象被填充，我们知道我们的 GraphQL 查询已成功完成，我们可以将那些数据作为属性传递给
    BusinessResults 组件，该组件负责渲染我们的结果表（见图 6.3）。
- en: '![CH06_F03_Lyon](../../OEBPS/Images/CH06_F03_Lyon.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F03_Lyon](../../OEBPS/Images/CH06_F03_Lyon.png)'
- en: Figure 6.3 Data flows through our React application using Apollo Client hooks.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 使用 Apollo Client 钩子数据在 React 应用程序中的流动。
- en: We’ll also need to make a slight adjustment to the BusinessResults component,
    since we now have multiple categories to display per business.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在需要显示每个企业的多个类别，我们还需要对 BusinessResults 组件进行一些微调。
- en: 'Listing 6.5 web-react/src/BusinessResults.js: Displaying business categories'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6.5 web-react/src/BusinessResults.js: 显示企业类别'
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ We use the reduce function to create a single string representation of our
    categories.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们使用 reduce 函数来创建我们类别的单个字符串表示。
- en: Now, if we take a look at our React application, we should see our business
    results table populated with businesses. The data is coming from the GraphQL API
    (see figure 6.4).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们看一下我们的 React 应用程序，我们应该看到我们的业务结果表已经填充了企业。数据来自 GraphQL API（见图 6.4）。
- en: '![CH06_F04_Lyon](../../OEBPS/Images/CH06_F04_Lyon.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F04_Lyon](../../OEBPS/Images/CH06_F04_Lyon.png)'
- en: Figure 6.4 Our React application after connecting to our GraphQL API
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 连接到我们的 GraphQL API 后的我们的 React 应用程序
- en: Of course, our application is not yet fully functional, since we’re just showing
    *all* businesses. Instead, we need to filter based on the user input of category.
    To do that, we’ll pass the selected category as a GraphQL variable.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们的应用还没有完全功能化，因为我们只是展示了*所有*企业。相反，我们需要根据用户输入的类别进行过滤。为此，我们将选择的类别作为 GraphQL
    变量传递。
- en: 6.1.3 GraphQL variables
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.3 GraphQL 变量
- en: '*GraphQL variables* allow us to pass dynamic arguments as part of our GraphQL
    operation. Let’s modify web-react/src/App.js to search for businesses that only
    match the category selected by the user, passing the selected category as a GraphQL
    variable. We’ll make use of the filtering functionality covered in chapter 4,
    using the where argument to filter for businesses with a connection to the user-selected
    category.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*GraphQL 变量*允许我们将动态参数作为我们的 GraphQL 操作的一部分传递。让我们修改 web-react/src/App.js 以搜索仅匹配用户选择的类别的企业，将选择的类别作为
    GraphQL 变量传递。我们将利用第 4 章中介绍过的过滤功能，使用 where 参数来过滤与用户选择类别相关联的企业。'
- en: 'Listing 6.6 web-react/src/App.js: Using GraphQL variables'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.6 web-react/src/App.js：使用 GraphQL 变量
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When working with GraphQL variables, we first need to replace the static value
    with $selectedCategory. Then, we declare $selectedCategory as one of the variables
    accepted by the query. We then pass the value for $selectedCategory in the call
    to useQuery. Now, our search results are updated when we change the selected category,
    showing only the results for that category (see figure 6.5).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当与 GraphQL 变量一起工作时，我们首先需要将静态值替换为 $selectedCategory。然后，我们将 $selectedCategory
    声明为查询接受的变量之一。然后，我们在调用 useQuery 时传递 $selectedCategory 的值。现在，当我们更改选择的类别时，搜索结果会更新，只显示该类别的结果（见图
    6.5）。
- en: '![CH06_F05_Lyon](../../OEBPS/Images/CH06_F05_Lyon.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F05_Lyon](../../OEBPS/Images/CH06_F05_Lyon.png)'
- en: Figure 6.5 Enabling filtering by category, using GraphQL
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 使用 GraphQL 启用按类别过滤
- en: 6.1.4 GraphQL fragments
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.4 GraphQL 片段
- en: So far, when creating a selection set, we’ve listed all the fields and nested
    fields we want to include in the query. Often, different components in our application
    use the same (or subsets of) selection sets in GraphQL queries. *GraphQL fragments*
    allow us to reuse selection sets, or pieces of selection sets, across GraphQL
    queries. To use fragments in our GraphQL queries, we first declare the fragment,
    assigning it a name and the type on which it is valid, as shown in the following
    listing.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在创建选择集时，我们已经列出了我们希望在查询中包含的所有字段和嵌套字段。通常，我们应用中的不同组件会使用相同的（或选择集的子集）在 GraphQL
    查询中。*GraphQL 片段*允许我们在 GraphQL 查询中重用选择集，或选择集的一部分。要在我们的 GraphQL 查询中使用片段，我们首先声明片段，给它一个名称和它有效的类型，如下面的列表所示。
- en: Listing 6.7 Declaring a GraphQL fragment
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.7 声明 GraphQL 片段
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here we’ve defined a fragment called businessDetails, which can be used to select
    fields of the Business type and includes all the fields needed to render our results
    table. Then, to use the fragment in a selection set, we include the fragment name
    in the selection set, preceded by ...., as the next listing shows.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为 businessDetails 的片段，它可以用来选择 Business 类型的字段，并包含渲染我们的结果表所需的所有字段。然后，为了在选择集中使用片段，我们在选择集中包含片段名称，前面加上
    ....，如下一个列表所示。
- en: Listing 6.8 Using a fragment in a GraphQL query
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.8 在 GraphQL 查询中使用片段
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Our query results will be the same, but we can now reuse this businessDetails
    fragment in other queries.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们查询的结果将保持不变，但现在我们可以将这个 businessDetails 片段重用在其他查询中。
- en: Using fragments with Apollo Client
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Apollo Client 的片段
- en: To use fragments with Apollo Client, we can declare our fragments in separate
    variables and include them in our GraphQL queries, using placeholders in the template
    literal. This allows us to store fragments and share them across components. If
    we need to change the fields in the selection set, we only need to do that where
    we declare the fragment, and then any queries using that fragment will be updated.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Apollo客户端的片段，我们可以在单独的变量中声明我们的片段，并在我们的GraphQL查询中使用模板字面量中的占位符将它们包含在内。这允许我们存储片段并在组件之间共享它们。如果我们需要更改选择集中的字段，我们只需在声明片段的地方进行更改，然后使用该片段的任何查询都将被更新。
- en: Next, we declare our businessDetails fragment in a BUSINESS_DETAILS_FRAGMENT
    variable, and we then include it in our GraphQL query, using a template literal
    placeholder, as shown in the next listing.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在BUSINESS_DETAILS_FRAGMENT变量中声明我们的businessDetails片段，然后我们使用模板字面量占位符将其包含在我们的GraphQL查询中，如下所示。
- en: 'Listing 6.9 web-react/src/App.js: Using a GraphQL fragment'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.9 web-react/src/App.js：使用GraphQL片段
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 6.1.5 Caching with Apollo Client
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.5 使用Apollo客户端进行缓存
- en: Apollo Client stores GraphQL results in a normalized, in-memory cache. This
    means that if the same GraphQL query is run again, instead of sending data to
    the server, the results from the cache will be read instead, reducing unnecessary
    network requests and improving the perceived performance of the application. We
    can verify that the results are cached by opening our browser’s developer tools
    and inspecting the network tab while selecting different categories from the dropdown.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Apollo客户端将GraphQL结果存储在规范化的内存缓存中。这意味着如果再次运行相同的GraphQL查询，而不是将数据发送到服务器，将读取缓存的结果，减少不必要的网络请求并提高应用程序的感知性能。我们可以通过打开浏览器开发者工具并检查网络选项卡来验证结果是否已缓存，同时从下拉菜单中选择不同的类别。
- en: Updating cached results
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 更新缓存结果
- en: 'Caching is great for performance when our application data isn’t changing very
    often, but how do we handle updating data that’s been cached? What if we don’t
    want to use cached data in our application and instead want to show fresh data
    from the server? Fortunately, Apollo Client has options for updating cached results.
    We’ll explore two options for updating cached query results: polling and refetching.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的应用程序数据变化不频繁时，缓存是提高性能的好方法，但我们如何处理更新已缓存的缓存数据？如果我们不想在我们的应用程序中使用缓存数据，而是想显示来自服务器的最新数据怎么办？幸运的是，Apollo客户端提供了更新缓存结果的选择。我们将探讨两种更新缓存查询结果的方法：轮询和重新获取。
- en: '*Polling* allows for synchronizing results periodically at a specified interval.
    With Apollo Client, polling can be enabled on a per-query basis by specifying
    a value for pollInterval, specified in milliseconds. Next, we set the query results
    to update every 500 milliseconds, as shown in the next listing.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*轮询*允许在指定的时间间隔定期同步结果。在Apollo客户端中，可以通过指定以毫秒为单位的pollInterval值来按查询启用轮询。接下来，我们将查询结果设置为每500毫秒更新一次，如下所示。'
- en: 'Listing 6.10 web-react/src/App.js: Setting a poll interval'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.10 web-react/src/App.js：设置轮询间隔
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Instead of updating results at a fixed interval, *refetching* allows us to update
    query results explicitly, often in response to a user action, such as clicking
    a button or submitting a form. To use refetching with Apollo client, call the
    refetch function returned by the useQuery hook, as the following listing shows
    .
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与在固定间隔更新结果不同，*重新获取*允许我们显式地更新查询结果，通常是对用户操作的反应，例如点击按钮或提交表单。要使用Apollo客户端的重新获取功能，请调用由useQuery钩子返回的重新获取函数，如下所示。
- en: 'Listing 6.11 web-react/src/App.js: Using the refetch function'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.11 web-react/src/App.js：使用重新获取函数
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ The refetch function is returned by the useQuery hook.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 重新获取函数是由useQuery钩子返回的。
- en: ❷ Calling the refetch function when the button is clicked
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 点击按钮时调用重新获取函数
- en: Now that we’re ready to handle changing data in our application, let’s see how
    to update our API data using GraphQL mutations.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好处理应用程序中的变化数据，让我们看看如何使用GraphQL突变更新我们的API数据。
- en: 6.2 GraphQL mutations
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 GraphQL突变
- en: '*GraphQL mutations* are GraphQL operations that can write or update data. We
    introduced the concept of mutations in chapter 2, but up until now, we haven’t
    actually used any mutations. In this section, we’ll explore the mutations generated
    by the Neo4j GraphQL library, allowing us to create, update, and delete nodes
    and relationships.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*GraphQL突变*是能够写入或更新数据的GraphQL操作。我们在第2章中介绍了突变的概念，但到目前为止，我们实际上还没有使用任何突变。在本节中，我们将探索由Neo4j
    GraphQL库生成的突变，允许我们创建、更新和删除节点和关系。'
- en: 6.2.1 Creating nodes
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.1 创建节点
- en: 'A create mutation is generated for each type in our GraphQL type definitions,
    mapping to a node label in Neo4j. To create nodes, we call the appropriate create
    mutation, passing in the property values for the new node as arguments. Note that
    if fields are defined using !, that means that the field is nonnullable and must
    be included in order to create the node. Let’s add a new business to the database:
    Philz Coffee.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们 GraphQL 类型定义中的每个类型，都会生成一个 create 变异，映射到 Neo4j 中的一个节点标签。要创建节点，我们调用适当的 create
    变异，并将新节点的属性值作为参数传入。注意，如果字段使用 ! 定义，这意味着该字段是非空白的，并且必须包含在内才能创建节点。让我们向数据库添加一个新的商业：Philz
    Coffee。
- en: Listing 6.12 GraphQL mutation to create business
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.12 创建商业的 GraphQL 变异
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Running this mutation in Apollo Studio will create a new business node in the
    database:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Apollo Studio 中运行此变异将在数据库中创建一个新的商业节点：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 6.2.2 Creating relationships
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.2 创建关系
- en: To create relationships in the database, we can use the update operations generated
    by the Neo4j GraphQL library. In the next listing, let’s connect our new Philz
    Coffee node to the Coffee category node. To do that, we use the IDbusinessID to
    refer to the business node in the input for the mutation.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要在数据库中创建关系，我们可以使用由 Neo4j GraphQL 库生成的更新操作。在下一个列表中，让我们将新的 Philz Coffee 节点连接到咖啡类别节点。为此，我们使用
    IDbusinessID 在变异的输入中引用业务节点。
- en: Listing 6.13 GraphQL mutation to create a relationship
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.13 创建关系的 GraphQL 变异
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Note the use of the connect argument. This argument allows us to create relationships
    between nodes that already exist. We could also create a new category node by
    using the create argument; however, in this case, our coffee category node already
    exists in the database. These connect and create arguments are also available
    when creating nodes and make up a powerful feature of the Neo4j GraphQL library,
    called *nested mutations*. By nesting create or connect operations, we can execute
    many write operations in a single GraphQL mutation:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用 connect 参数。此参数允许我们在已存在的节点之间创建关系。我们也可以通过使用 create 参数创建一个新的类别节点；然而，在这种情况下，我们的咖啡类别节点已经在数据库中存在。这些
    connect 和 create 参数在创建节点时也可用，并构成了 Neo4j GraphQL 库的一个强大功能，称为 *嵌套变异*。通过嵌套 create
    或 connect 操作，我们可以在单个 GraphQL 变异中执行多个写操作：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 6.2.3 Updating and deleting
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.3 更新和删除
- en: Let’s say the Philz Coffee shop moves from B St. to an address right next door
    to the Neo4j office, and we need to update the address. To do that, we use the
    updateBusinesses mutation, using the businessId field to reference the node and
    then passing in any values that need to be updated to the update argument, as
    shown next.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 Philz Coffee 店从 B 街搬迁到与 Neo4j 办公室相邻的地址，我们需要更新地址。为此，我们使用 updateBusinesses
    变异，使用 businessId 字段引用节点，然后将需要更新的任何值传递给 update 参数，如下所示。
- en: Listing 6.14 GraphQL mutation to update business address
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.14 更新商业地址的 GraphQL 变异
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Or if we need to delete the node from the database completely, we can use the
    deleteBusinesses mutation, as the following listing shows.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们需要从数据库中完全删除节点，我们可以使用 deleteBusinesses 变异，如下所示。
- en: Listing 6.15 GraphQL mutation to delete a business node
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.15 删除商业节点的 GraphQL 变异
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: While you execute these mutation operations in Apollo Studio, try the polling
    and refetching technique mentioned in the previous section to see how the React
    application reacts to changing backend data as the mutations are executed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Apollo Studio 中执行这些变异操作时，尝试上一节中提到的轮询和重新获取技术，以查看 React 应用程序如何响应变异执行时后端数据的更改。
- en: 6.3 Client state management with GraphQL
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 使用 GraphQL 进行客户端状态管理
- en: We said earlier that Apollo Client is a comprehensive data management library,
    and that includes not only working with data from our GraphQL server, but also
    managing local data. Local data can include the state of our React application—for
    example, user preferences that we don’t want to send to the server because they
    are only relevant to the client.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到 Apollo Client 是一个全面的数据管理库，这包括不仅与我们的 GraphQL 服务器中的数据一起工作，还包括管理本地数据。本地数据可以包括我们的
    React 应用程序的状态——例如，我们不希望发送到服务器的用户偏好，因为它们仅与客户端相关。
- en: 'Apollo Client allows us to add local-only fields to our GraphQL queries, which
    can then be managed and cached by Apollo Client to help manage the state of our
    React application. This is helpful because it allows us to use the same API for
    working with local data as we do for remote data: GraphQL!'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Apollo Client 允许我们在 GraphQL 查询中添加仅本地字段，然后由 Apollo Client 进行管理和缓存，以帮助管理我们的 React
    应用程序的状态。这很有用，因为它允许我们使用与远程数据相同的 API 来处理本地数据：GraphQL！
- en: 6.3.1 Local-only fields and reactive variables
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.1 仅本地字段和响应式变量
- en: In Apollo Client, *local-only fields* can be defined and included in our GraphQL
    schema. These fields are not defined in the server’s schema, but rather are specific
    to the client application only. The values for these fields are computed locally
    using logic that we can define, such as storing and reading from localStorage
    in the browser.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Apollo Client 中，*仅本地字段* 可以在我们的 GraphQL 模式中进行定义和包含。这些字段在服务器模式中未定义，而是仅针对客户端应用程序。这些字段的值是使用我们可以定义的逻辑在本地计算的，例如在浏览器中使用
    localStorage 进行存储和读取。
- en: '*Reactive variables* enable us to read and write local values outside of GraphQL.
    These are useful when we want to update their values without executing a GraphQL
    operation (e.g., in response to user action) but read local-only fields as part
    of a GraphQL data-fetching operation alongside other data-fetching logic from
    the GraphQL server. Also, modifying a reactive variable triggers an update of
    any query that uses its value.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*响应式变量* 使我们能够在 GraphQL 之外读取和写入本地值。当我们需要在不执行 GraphQL 操作（例如，对用户动作做出响应）的情况下更新它们的值，但作为
    GraphQL 数据获取操作的一部分读取仅本地字段时，这些变量很有用。此外，修改响应式变量会触发使用其值的任何查询的更新。'
- en: Let’s combine a local-only field with a reactive variable to add a *starred
    businesses* function to our application. We’ll add a *Stars* button next to each
    business in the results list, allowing the user to select their starred businesses.
    When a use has starred a business, it will show as bold, letting the user know
    it is one of their preferred businesses.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将仅本地字段与响应式变量结合起来，为我们的应用程序添加一个 *星标业务* 功能。我们将在结果列表中的每个业务旁边添加一个 *星标* 按钮，使用户能够选择他们的星标业务。当用户星标了一个业务时，它将以粗体显示，让用户知道它是他们偏好的业务之一。
- en: As shown in listing 6.16, to do this, we first add a *field policy* for a local-only
    field to the InMemoryCache instance that we’re using in Apollo Client. A field
    policy specifies how to compute a local-only field. Here we add an isStarred field
    that will be a local-only field. We also create a new reactive variable that will
    be used to store a list of starred businesses. In this case, the field policy
    for the isStarred field checks to see if the business being resolved is included
    in the list of starred businesses.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表 6.16 所示，为此，我们首先向 Apollo Client 中使用的 InMemoryCache 实例添加一个仅本地字段的政策。字段政策指定了如何计算仅本地字段。在这里，我们添加了一个
    isStarred 字段，它将是一个仅本地字段。我们还创建了一个新的响应式变量，它将用于存储星标业务列表。在这种情况下，isStarred 字段的字段政策会检查正在解析的业务是否包含在星标业务列表中。
- en: 'Listing 6.16 web-react/src/index.js: Using a reactive variable'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6.16 web-react/src/index.js: 使用响应式变量'
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Import the makeVar function to create a new reactive variable.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入 makeVar 函数以创建一个新的响应式变量。
- en: ❷ Create a new reactive variable, setting the initial value equal to an empty
    array.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个新的响应式变量，将初始值设置为空数组。
- en: ❸ Include a field policy in the InMemoryCache constructor arguments.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在 InMemoryCache 构造函数参数中包含一个字段政策。
- en: ❹ The field policy defines how the value is computed for a local-only field
    called isStarred on the business type.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 字段政策定义了在业务类型上名为 isStarred 的仅本地字段值的计算方式。
- en: ❺ Return true if the list of starred businesses includes the current business.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果星标业务列表中包含当前业务，则返回 true。
- en: Now, we can include the isStarred field in our GraphQL query, as shown in the
    next listing. We’ll need to include the @client directive to indicate this is
    a local-only field and won’t be fetched from the GraphQL server.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将 isStarred 字段包含在我们的 GraphQL 查询中，如下一列表所示。我们需要包含 @client 指令以指示这是一个仅本地字段，并且不会从
    GraphQL 服务器获取。
- en: 'Listing 6.17 web-react/src/App.js: Using a local-only GraphQL field'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6.17 web-react/src/App.js: 使用仅本地 GraphQL 字段'
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Add the isStarred field to the selection set, indicating this is a local-only
    field using the @client directive.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 isStarred 字段添加到选择集中，使用 @client 指令表示这是一个仅本地字段。
- en: Finally, we need a way to update the starredVar reactive variable. In the next
    listing, we add a *Star* button next to each business. When the user clicks this
    button, the value of starredVar is updated to include the businessId of the selected
    business.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一种方法来更新 starredVar 响应式变量。在下一个列表中，我们在每个业务旁边添加一个 *星号* 按钮。当用户点击此按钮时，starredVar
    的值会更新，以包含所选业务的 businessId。
- en: 'Listing 6.18 web-react/src/BusinessResults.js: Using our reactive variable'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.18 web-react/src/BusinessResults.js：使用我们的响应式变量
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ We fetch the value of starredVar to find all starred businesses.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们获取 starredVar 的值以找到所有已标记的业务。
- en: ❷ When clicked, add the businessId to the list of starred businesses.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 点击时，将 businessId 添加到已标记业务的列表中。
- en: ❸ If the business has been starred, then use a bold style for the business name.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果业务已被标记星号，那么为业务名称使用粗体样式。
- en: And because this is a reactive variable, any active query that depends on the
    isStarred local-only field is automatically updated in the UI (see figure 6.6)!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个响应式变量，任何依赖于 isStarred 本地字段的活跃查询都会在 UI 中自动更新（见图 6.6）！
- en: '![CH06_F06_Lyon](../../OEBPS/Images/CH06_F06_Lyon.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F06_Lyon](../../OEBPS/Images/CH06_F06_Lyon.png)'
- en: Figure 6.6 Our React application after connecting to our GraphQL API
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 连接到我们的 GraphQL API 后的 React 应用程序
- en: Now that we’ve explored mutations, we need to think about how we can secure
    our application, so not just anyone can add data and update our application. In
    the next chapter, we explore how to add authentication to secure our application,
    both on the frontend and backend.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了变更操作，我们需要考虑如何保护我们的应用程序，以便不是任何人都可以添加数据并更新我们的应用程序。在下一章中，我们将探讨如何添加身份验证来保护我们的应用程序，包括前端和后端。
- en: 6.4 Exercises
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 练习
- en: What other GraphQL fragments could we use across our application? Write some
    fragments, and try using them in your queries in Apollo Studio. When would it
    make sense to use multiple fragments in the same query?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在整个应用程序中使用哪些其他的 GraphQL 片段？编写一些片段，并在 Apollo Studio 中的查询中尝试使用它们。在什么情况下，在同一个查询中使用多个片段是有意义的？
- en: Using GraphQL mutations, create relationships connecting business and category
    nodes to add businesses to additional categories. For example, add the newly created
    Philz Coffee business to the Restaurant and Breakfast categories. Add your favorite
    business and corresponding categories to the graph.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 GraphQL 变更操作，创建连接业务和类别节点的关系，以将业务添加到额外的类别中。例如，将新创建的 Philz Coffee 业务添加到餐厅和早餐类别。将您喜欢的业务和相应的类别添加到图中。
- en: Turn the *Star* button into a toggle. If the business is already starred, remove
    it from the starred list.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 *星号* 按钮转换为切换按钮。如果业务已被标记星号，则从已标记列表中删除它。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Apollo Client is a data management library that enables developers to manage
    both local and remote data with GraphQL and includes integrations for frontend
    frameworks, like React.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apollo 客户端是一个数据管理库，它使开发者能够使用 GraphQL 管理本地和远程数据，并包括对前端框架（如 React）的集成。
- en: GraphQL mutations are operations that allow for creating and updating data and
    are generated for each type by the Neo4j GraphQL library.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL 变更操作是允许创建和更新数据的操作，由 Neo4j GraphQL 库为每个类型生成。
- en: Apollo Client can be used for managing local state by adding local-only fields
    to the GraphQL schema and by defining field policies that specify how to read,
    store, and update that local data.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apollo 客户端可以通过向 GraphQL 模式添加本地字段以及定义字段策略来管理本地状态，这些策略指定了如何读取、存储和更新这些本地数据。
