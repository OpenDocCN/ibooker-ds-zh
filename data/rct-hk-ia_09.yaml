- en: 8 Managing state with the Context API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 使用Context API管理状态
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Providing state via the Context API and its `Provider` component
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Context API及其`Provider`组件提供状态
- en: Consuming context state with the `useContext` hook
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`useContext`钩子消费上下文状态
- en: Avoiding unnecessary re-renders when updating state values
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在更新状态值时进行不必要的重新渲染
- en: Creating custom context providers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义上下文提供者
- en: Splitting shared state across multiple contexts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个上下文中分割共享状态
- en: We’ve seen state encapsulated within components, lifted to shared parents, in
    form fields, persisted across renders, and pulled in from a database, and we’ve
    used a whole bunch of hooks to help us set up and work with that state. Our approach
    has been to keep the state as close to the components that use it as possible.
    But it’s not uncommon for many components, nested on multiple branches, to hunger
    for the same juicy worms, the same tidbits of application state, like themes,
    localization info, or authenticated user details. Mmmmmmm, tidbits . . . React’s
    Context API is a way of delivering juicy state tidbits directly to your nest without
    passing them down through multiple layers of intermediaries who, preferring tacos
    to tidbits, have no interest in them.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到状态被封装在组件中，提升到共享父组件中，在表单字段中，跨渲染持久化，以及从数据库中拉取，我们使用了很多钩子来帮助我们设置和使用该状态。我们的方法是将状态尽可能靠近使用它的组件。但是，对于许多嵌套在多个分支上的组件来说，渴望同样的美味虫子，同样的应用状态碎片，如主题、本地化信息或认证用户详情，并不少见。嗯嗯，碎片……React的Context
    API是一种将美味的状态碎片直接送到你的巢穴而不通过多层中间代理传递的方法，这些中间代理更喜欢玉米卷而不是碎片。
- en: 'In this chapter, we introduce the Context API, its context objects, `Provider`
    components, and `useContext` hook. We focus on our bookings app example, where
    multiple components need the same juicy tidbit: details of the current user. That
    sets the scene for a rundown of the mechanics of the Context API and we see why,
    when, where, and how to provide values to whole subtrees of components, and how
    easy the `useContext` hook makes consuming those values. We finish by wrapping
    context functionality into our own custom contexts and provider components, and
    that discussion leads to a deeper understanding of React’s rendering behavior,
    particularly when working with the special `children` prop.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Context API、其上下文对象、`Provider`组件和`useContext`钩子。我们关注我们的预订应用示例，其中多个组件需要同样的美味碎片：当前用户的详细信息。这为Context
    API的机制概述设定了场景，我们看到为什么、何时、何地以及如何向组件子树提供值，以及`useContext`钩子如何简化这些值的消费。我们通过将上下文功能封装到我们自己的自定义上下文和提供者组件中结束，这讨论加深了对React渲染行为的理解，尤其是在使用特殊的`children`属性时。
- en: Can you hear that? It’s nested components chirping for tasty tidbits. It’s feeding
    time!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你能听到吗？那是嵌套组件在啁啾着寻找美味碎片。是喂食时间了！
- en: 8.1 Needing state from higher up the component tree
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 需要从组件树的上层获取状态
- en: The Bookings page in our example app lets visitors select a bookable and week.
    The bookings grid on the page then shows the available booking slots and populates
    the appropriate cells with any existing bookings. Figure 8.1 shows the Bookings
    page after a visitor has selected the Meeting Room bookable and then the Movie
    Pitch! booking.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例应用中，预订页面允许访客选择可预订的房间和周。页面上的预订网格随后显示可用的预订时段，并用任何现有的预订填充适当的单元格。图8.1显示了访客选择会议室可预订和电影提案！预订后的预订页面。
- en: '![](../Images/8-1.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8-1.png)'
- en: Figure 8.1 After the user selects a booking, the booking details component (on
    the right) shows information about the selected booking.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 用户选择预订后，预订详情组件（在右侧）显示所选预订的信息。
- en: 'In chapter 7, we worked with a placeholder for `BookingDetails`, the component
    that displays further information about the selected booking. Figure 8.1 also
    shows our aim for the `BookingDetails` component in this chapter: it lists a number
    of the selected booking’s properties, such as Title and Booking Date. But when
    the page first loads, no booking is selected, and the component shows a message
    encouraging the visitor to select a booking or a booking slot, as you can see
    in figure 8.2.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7章中，我们处理了`BookingDetails`组件的占位符，该组件用于显示关于所选预订的更多信息。图8.1也展示了本章中我们对`BookingDetails`组件的目标：列出所选预订的一些属性，如标题和预订日期。但是，当页面首次加载时，没有预订被选中，组件显示一条消息鼓励访客选择一个预订或预订时段，如图8.2所示。
- en: '![](../Images/8-2.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8-2.png)'
- en: Figure 8.2 Before the user selects a booking, the booking details component
    (on the right) shows the message “Select a booking or a booking slot.”
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 在用户选择预订之前，预订详情组件（在右侧）显示消息“选择一个预订或预订时段。”
- en: 'In this chapter, we relieve the `BookingDetails` component of its placeholder
    duties and promote it to perform these three tasks:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们减轻了`BookingDetails`组件的占位符职责，并提升其执行以下三个任务：
- en: Displaying a call-to-action message when the page first loads
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在页面首次加载时显示操作消息
- en: Displaying booking information when a visitor selects a booking
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当访客选择预订时显示预订信息
- en: Displaying an edit button for a user’s bookings
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示用户预订的编辑按钮
- en: The third task prompts our investigation of the Context API to make the current
    user value available to components across the app. Why does the `BookingDetails`
    component need to know the user? Let’s find out.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个任务促使我们研究Context API，以便将当前用户值传递给应用中的组件。为什么`BookingDetails`组件需要知道用户？让我们找出答案。
- en: 8.1.1 Displaying a call-to-action message when the page first loads
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.1 在页面首次加载时显示操作消息
- en: When the Bookings page loads, but before a visitor selects a booking, the `BookingDetails`
    component will display a call-to-action message, shown in figure 8.3.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当预订页面加载，但在访客选择预订之前，`BookingDetails`组件将显示操作消息，如图8.3所示。
- en: '![](../Images/8-3.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图8-3](../Images/8-3.png)'
- en: Figure 8.3 When the page first loads, the `BookingDetails` component shows a
    “Select a booking or a booking slot” message to the user.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 当页面首次加载时，`BookingDetails`组件向用户显示“选择一个预订或预订时段”的消息。
- en: Listing 8.1 shows how the `BookingDetails` component checks for a booking and
    either returns UI for the call-to-action message or for an existing booking. The
    UI for an existing booking is handled by another component, `Booking`; we look
    at that in section 8.1.2.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.1展示了`BookingDetails`组件如何检查预订并返回操作消息的UI或现有预订的UI。现有预订的UI由另一个组件`Booking`处理；我们将在8.1.2节中探讨这一点。
- en: 'Branch: 0801-booking-details, File: /src/components/Bookings/BookingDetails.js'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0801-预订详情，文件：/src/components/Bookings/BookingDetails.js
- en: Listing 8.1 The `BookingDetails` component shows a booking or a message
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.1 `BookingDetails`组件显示预订或消息
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Import the Booking component.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入`Booking`组件。
- en: ❷ Assign booking and bookable props to local variables.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将预订和可预订属性分配给局部变量。
- en: ❸ Show the booking info only if a booking is selected.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 仅当选择预订时显示预订信息。
- en: ❹ Use the Booking component to display the info.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用`Booking`组件来显示信息。
- en: ❺ If no booking is selected, show a message.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果没有选择预订，则显示消息。
- en: 'Listing 8.1 uses the JavaScript ternary operator ( `a` `?` `b` `:` `c` ) to
    return the appropriate UI, the booking, or the message:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.1使用JavaScript三元运算符（`a` `?` `b` `:` `c`）返回适当的UI，预订或消息：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In later chapters, we add the third UI possibility for a form with its input
    fields and submit button. For now, it’s an either/or situation: booking or message.
    Let’s see the code for the booking UI.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续章节中，我们将为带有输入字段和提交按钮的表单添加第三个UI可能性。目前，这是一个或/或的情况：预订或消息。让我们看看预订UI的代码。
- en: 8.1.2 Displaying booking information when a visitor selects a booking
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.2 当访客选择预订时显示预订信息
- en: Once the user heeds the call and selects an existing booking, the component
    displays its information; details for the Movie Pitch! booking are shown in figure
    8.4\. (If you don’t have any booking data, grab db.json from the repo. Get the
    latest App.css if you need that too.)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户注意并选择了一个现有预订，组件将显示其信息；电影提案！预订的详情如图8.4所示。（如果您没有预订数据，请从仓库中获取db.json。如果您也需要最新的App.css，请获取。）
- en: '![](../Images/8-4.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图8-4](../Images/8-4.png)'
- en: Figure 8.4 The `BookingDetails` component showing information about the selected
    booking and bookable
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 显示所选预订和可预订信息的`BookingDetails`组件
- en: The information includes a number of fields from the booking and one from the
    bookable. The following listing shows the `Booking` component receiving the selected
    booking and bookable as props and returning the booking details as a sequence
    of labels and paragraphs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 信息包括预订的多个字段和一个可预订的字段。以下列表显示了`Booking`组件接收所选预订和可预订作为属性，并以标签和段落序列返回预订详情。
- en: 'Branch: 0801-booking-details, File: /src/components/Bookings/Booking.js'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0801-预订详情，文件：/src/components/Bookings/Booking.js
- en: Listing 8.2 The `Booking` component
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.2 `Booking`组件
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Assign booking and bookable props to local variables.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将预订和可预订属性分配给局部变量。
- en: ❷ Assign booking properties to local variables.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将预订属性分配给局部变量。
- en: ❸ Show information from the selected bookable.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 显示所选可预订的信息。
- en: ❹ Format the date property nicely.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将日期属性格式化得更好。
- en: ❺ Show the Notes field only if the booking has notes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 仅当预订有备注时显示“备注”字段。
- en: The `BookingDetails` component now successfully switches between the call-to-action
    message when the user is yet to select a booking and the `Booking` component once
    they make their selection. That’s two of the component’s three tasks sorted. Good
    job! But the third task is trickier. What’s the problem?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookingDetails` 组件现在成功地在用户尚未选择预订时的行动号召信息与用户做出选择后的 `Booking` 组件之间切换。这是组件三个任务中的两个已经完成。做得好！但第三个任务更复杂。问题是什么？'
- en: '8.1.3 Displaying an edit button for a user’s bookings: The problem'
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.3 为用户的预订显示编辑按钮：问题
- en: Our newly minted `BookingDetails` component successfully displays information
    about the selected bookable. That’s great! But plans change, and meetings get
    cancelled or dates clash. A user should be able to edit their own bookings to
    update the details or delete them outright. We need to add a button, like the
    one next to the Booking Details heading on the right of figure 8.5, so the user
    can switch to editing a booking.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新创建的 `BookingDetails` 组件成功显示了所选可预订的信息。这很好！但计划可能会改变，会议可能会取消或日期冲突。用户应该能够编辑自己的预订以更新详细信息或直接删除它们。我们需要添加一个按钮，就像图
    8.5 右侧预订详情标题旁边的按钮一样，以便用户可以切换到编辑预订。
- en: '![](../Images/8-5.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/8-5.png)'
- en: Figure 8.5 When a user selects one of their own bookings, the booking details
    component (on the right) displays an edit button with an edit icon to the right
    of the heading.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 当用户选择自己的其中一个预订时，预订详情组件（在右侧）在标题右侧显示一个带有编辑图标的编辑按钮。
- en: Figure 8.6 isolates the `BookingDetails` component and shows the edit button
    (a document-edit icon) on the right of the component’s title. The problem is,
    we want to show the button only if the current user booked the selected booking
    themselves. For other users, the button should be hidden. The `BookingDetails`
    component needs to know the `id` of the current user so it can check it against
    the `bookerId` for the selected booking.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 将 `BookingDetails` 组件隔离出来，并显示组件标题右侧的编辑按钮（一个文档编辑图标）。问题是，我们只想在当前用户自己预订所选预订时显示该按钮。对于其他用户，按钮应该被隐藏。`BookingDetails`
    组件需要知道当前用户的 `id`，以便它可以与所选预订的 `bookerId` 进行比较。
- en: '![](../Images/8-6.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/8-6.png)'
- en: Figure 8.6 The booking details component with the edit button showing on the
    right of the heading
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 显示在标题右侧带有编辑按钮的预订详情组件
- en: The state for the current user lives all the way up at the top of the application
    component hierarchy, in the `App` component. We could pass the user down through
    the intermediate components (`App` to `BookingsPage` to `Bookings` to `BookingDetails`),
    but the components on the way aren’t interested in the user state, and it’s also
    needed by the `UserPicker` component (and will soon be used by the `UsersPage`
    component too). In this case, a piece of state is needed by several components
    spread across the app.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当前用户的状态位于应用程序组件层次结构的顶部，在 `App` 组件中。我们可以通过中间组件（`App` 到 `BookingsPage` 到 `Bookings`
    到 `BookingDetails`）向下传递用户，但这些组件对用户状态不感兴趣，而且 `UserPicker` 组件（以及很快还将被 `UsersPage`
    组件使用）也需要这个状态。在这种情况下，应用程序中分散的多个组件都需要一个状态。
- en: The Context API offers an alternative way of making the state available to multiple
    consumers. How do we provide the state we want to share?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Context API 提供了一种将状态提供给多个消费者的替代方法。我们如何提供我们想要共享的状态？
- en: '8.1.4 Displaying an edit button for a user’s bookings: The solution'
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.4 为用户的预订显示编辑按钮：解决方案
- en: We want to share the current user with all components that need that information,
    so let’s create a `UserContext` object with React’s Context API. We put the context
    to share in its own file, /src/components/Users/UserContext.js. The component
    that provides the user value, `App`, and the components that consume the user
    value, including `BookingDetails`, can import the context to set or read its value.
    The code is in the following listing.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将当前用户信息与所有需要该信息的功能组件共享，因此让我们使用 React 的 Context API 创建一个 `UserContext` 对象。我们将共享的上下文放在其自己的文件中，即
    /src/components/Users/UserContext.js。提供用户值的组件 `App` 以及消费用户值的组件，包括 `BookingDetails`，都可以导入上下文来设置或读取其值。代码如下所示。
- en: 'Branch: 0802-user-context, File: /src/components/Users/UserContext.js'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0802-user-context，文件：/src/components/Users/UserContext.js
- en: Listing 8.3 Creating and exporting a context object for our user value
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.3 创建并导出用于用户值的上下文对象
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Yes, that’s it! We use the `createContext` method and assign the context object
    it returns to the `UserContext` variable. That context object, `UserContext`,
    is the key to sharing the current user value across the app: the `App` component
    will use it to set the value, and consuming components will use it, along with
    the `useContext` hook, to read the value.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，就是这样！我们使用`createContext`方法并将它返回的上下文对象分配给`UserContext`变量。这个上下文对象，`UserContext`，是跨应用共享当前用户值的关键：`App`组件将使用它来设置值，而消费组件将使用它，以及`useContext`钩子，来读取值。
- en: 'To use the new context object to provide user state for the bookings app, we
    update the `App` component in three key ways:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用新的上下文对象为预订应用提供用户状态，我们以三种关键方式更新`App`组件：
- en: Import the context object.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入上下文对象。
- en: Manage state for the current user by calling the `useState` hook.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`useState`钩子来管理当前用户的状态。
- en: Use the context’s `Provider` component to wrap the `Router` component.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用上下文的`Provider`组件包裹`Router`组件。
- en: The following listing shows the updates in place.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了所做的更新。
- en: 'Branch: 0802-user-context, File: /src/components/App.js'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0802-user-context，文件：/src/components/App.js
- en: Listing 8.4 Importing the context object and providing its value in `App`
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.4 在`App`中导入上下文对象并提供其值
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Import the useState hook.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入useState钩子。
- en: ❷ Import the context to be shared.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 导入要共享的上下文。
- en: ❸ Manage the user state with the useState hook.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用useState钩子管理用户状态。
- en: ❹ Wrap the app UI in the context provider.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将应用UI包裹在上下文提供者中。
- en: ❺ Pass the user state and its updater function to UserPicker.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将用户状态及其更新函数传递给UserPicker。
- en: 'The `App` component imports the `UserContext` object and then wraps the UI
    in the context’s `Provider` component, making the `user` state value available
    to all components in the tree:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`App`组件导入`UserContext`对象，然后将其UI包裹在上下文的`Provider`组件中，使`user`状态值对所有树中的组件可用：'
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The provider doesn’t have to wrap the whole component tree. As the code stands,
    with the app passing `user` and `setUser` to the `UserPicker` component as props,
    we could wrap just the routes in the provider:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者不必包裹整个组件树。按照目前的代码，由于应用将`user`和`setUser`作为属性传递给`UserPicker`组件，我们只需将路由包裹在提供者中即可：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: But in a later section, we switch the user picker over to using the context
    rather than props, so it’s useful to wrap the whole component tree in the provider.
    For now, the `UserPicker` component receives the selected user, and its updater
    function as props. The following listing shows how it works with those props.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 但在后面的部分，我们将用户选择器切换到使用上下文而不是属性，因此将整个组件树包裹在提供者中是有用的。现在，`UserPicker`组件接收选定的用户及其更新函数作为属性。以下列表显示了它是如何使用这些属性的。
- en: 'Branch: 0802-user-context, File: /src/components/Users/UserPicker.js'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0802-user-context，文件：/src/components/Users/UserPicker.js
- en: Listing 8.5 Receiving the user and updater function in `UserPicker`
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.5 在`UserPicker`中接收用户和更新函数
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Assign the user and setUser props to local variables.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将用户和setUser属性分配给局部变量。
- en: ❷ Once the users have loaded, set the current user to the first.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一旦用户加载完成，将当前用户设置为第一个。
- en: ❸ Include setUser as a dependency.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将setUser作为依赖项包括在内。
- en: ❹ Use the id to find the selected user object.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用id查找选定的用户对象。
- en: ❺ Set the selected user.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 设置选定的用户。
- en: ❻ Specify an event handler for the drop-down.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 为下拉指定事件处理器。
- en: ❼ Set the current selection.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 设置当前选择。
- en: ❽ Set a value for each option.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 为每个选项设置一个值。
- en: The `UserPicker` component loads the user data from the database. Once it has
    the data, it calls `setUser`, received as a prop, to set the current user. Because
    of the updated state, the `App` component re-renders, setting the updated user
    as the value on the user context provider. Because `App` re-renders, all its children
    re-render too. That includes any descendant components that consume the context,
    and they’ll pick up the new context value. The `UserPicker` will also show the
    selected user, setting it as the value of the HTML `select` element in its UI.
    (Notice each `option` element now has a `value` attribute set to the user’s ID.)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserPicker`组件从数据库中加载数据。一旦它有了数据，它就会调用作为属性接收的`setUser`来设置当前用户。由于状态的更新，`App`组件会重新渲染，将更新的用户值作为用户上下文提供者的值。由于`App`重新渲染，它的所有子组件也会重新渲染。这包括任何消费上下文的子组件，它们将获取新的上下文值。《UserPicker》也会显示选定的用户，将其设置为UI中HTML
    `select`元素的值。（注意每个`option`元素现在都有一个`value`属性设置为用户的ID。）'
- en: '![](../Images/8-7.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/8-7.png)'
- en: Figure 8.7 The `BookingDetails` component shown again with the edit button to
    the right of the heading
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 再次显示带有标题右侧编辑按钮的`BookingDetails`组件
- en: To see the whole updated context process in action, we need a component that
    consumes the user context value. Let’s start with the `BookingDetails` component,
    as set out in the following listing. Remember, we need the user value to decide
    whether to show the edit button, shown again in figure 8.7.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看整个更新的上下文过程在实际中的应用，我们需要一个消费用户上下文值的组件。让我们从以下列表中所述的`BookingDetails`组件开始。记住，我们需要用户值来决定是否显示编辑按钮，如图8.7所示。
- en: 'Branch: 0802-user-context, File: /src/components/Bookings/BookingDetails.js'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0802-user-context，文件：/src/components/Bookings/BookingDetails.js
- en: Listing 8.6 The `BookingDetails` component reading the user from context
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.6 `BookingDetails`组件从上下文中读取用户
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Import the useContext hook.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入`useContext`钩子。
- en: ❷ Import the icon for the edit button.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 导入编辑按钮的图标。
- en: ❸ Import our shared context.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 导入我们的共享上下文。
- en: ❹ Call useContext with the shared context and assign the value to the user variable.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用共享上下文调用`useContext`并将值赋给`user`变量。
- en: ❺ Check if the booking belongs to the user.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 检查预订是否属于用户。
- en: ❻ Show the edit button only if the booking belongs to the user.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 仅当预订属于用户时才显示编辑按钮。
- en: ❼ Render a button, but don’t attach a handler yet.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 渲染一个按钮，但不要附加处理程序。
- en: ❽ Use the imported edit icon for the button.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 使用导入的编辑图标作为按钮。
- en: 'The component imports the `UserContext` context object and passes it to the
    `useContext` hook, assigning the value the hook returns to the `user` variable.
    Once `BookingDetails` has a user and a booking, it can check whether the booking
    was booked by the user:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 组件导入`UserContext`上下文对象并将其传递给`useContext`钩子，将钩子返回的值赋给`user`变量。一旦`BookingDetails`组件有了用户和预订信息，它就可以检查预订是否由该用户进行：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If the current user booked the booking, `isBooker` will be `true`, and the
    component will show the edit button after the heading:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前用户预订了该预订，`isBooker`将为`true`，组件将在标题后显示编辑按钮：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The button doesn’t do anything yet, but it should appear only when the current
    user (the one selected in the user picker) is the user who booked the selected
    booking. Test out the showing and hiding logic by selecting a different user and
    then selecting the different bookings. (When you load the Bookings page, clicking
    Go in the week picker will take you to the default date—it’s set up with some
    bookings, if you’re using db.json from the repo.)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮目前没有任何功能，但它应该只在当前用户（在用户选择器中选中的用户）是所选预订的预订者时出现。通过选择不同的用户然后选择不同的预订来测试显示和隐藏逻辑。（当你加载预订页面时，在周选择器中点击Go将带你到默认日期——如果你使用的是从仓库中的db.json，它将设置一些预订。）
- en: Challenge 8.1
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战8.1
- en: Update the Users page so that when you switch to the page, it automatically
    shows the details for the current user. For example, as shown in figure 8.8, if
    the current user is Clarisse and you switch to the Users page, the details for
    Clarisse will be shown and Clarisse is selected in the list of users.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 更新用户页面，以便在切换到页面时，它自动显示当前用户的详细信息。例如，如图8.8所示，如果当前用户是Clarisse，你切换到用户页面，将显示Clarisse的详细信息，并在用户列表中选择Clarisse。
- en: '![](../Images/8-8.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/8-8.png)'
- en: Figure 8.8 Clarisse is selected as the current user in the user picker (top
    right). When a visitor switches to the Users page, Clarisse is automatically selected
    in the user list (left) and her details are shown (right).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 在用户选择器（右上角）中选择了Clarisse作为当前用户。当访客切换到用户页面时，Clarisse会自动在用户列表（左侧）中选中，并显示其详细信息（右侧）。
- en: Use the same `UserContext` object we use with the `BookingDetails` component
    and call `useContext` to get the current user. The completed challenge is on the
    0803-users-page branch in the GitHub repo.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与`BookingDetails`组件相同的`UserContext`对象，并调用`useContext`以获取当前用户。完成的挑战位于GitHub仓库的0803-users-page分支。
- en: 'React’s Context API works well for sharing the selected user in the bookings
    app. But it raises a few questions: What if we have more than one value to share?
    Or a more complicated value with many properties? And can we avoid triggering
    a re-render of the whole component tree when calling `setUser`? Let’s dig a little
    deeper into the nuances of React rendering as we look for answers to those questions.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: React的上下文API在共享预订应用中选择的用户方面表现良好。但它引发了一些问题：如果我们有多个要共享的值怎么办？或者一个具有许多属性的更复杂值？我们能否在调用`setUser`时避免触发整个组件树的重新渲染？让我们在寻找这些问题的答案时，更深入地挖掘React渲染的细微差别。
- en: 8.2 Working with custom providers and multiple contexts
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 使用自定义提供者和多个上下文
- en: We’re successfully feeding tasty tidbits of shared state to components nested
    deep in our app’s tree. We use a context object’s `Provider` component to provide
    a value, and consumer components call `useContext` with the same context object
    to access the value. Whenever the value changes, the consumers re-render. It would
    be great if *only* the consumers re-rendered for the values shared via the context.
    In the bookings app, updating the user state in the `App` component causes the
    whole tree to re-render. It’s not just the tidbit tasters that update; it’s the
    taco munchers (the components that aren’t interested in the user) that update
    too.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地将共享状态的美味片段喂给了我们应用程序树中嵌套较深的组件。我们使用上下文对象的 `Provider` 组件来提供值，并且消费组件通过调用
    `useContext` 并传入相同的上下文对象来访问该值。每当值发生变化时，消费者会重新渲染。如果只有消费者重新渲染通过上下文共享的值，那就太好了。在预订应用程序中，`App`
    组件中更新用户状态会导致整个树重新渲染。不仅仅是品尝碎片的人更新；那些吃玉米卷的人（不关心用户的组件）也会更新。
- en: In this section, we look at four ways of extending our use of the context. The
    first, using objects as values, can cause problems. The second and third, using
    custom providers and multiple contexts, may help us solve those problems. And
    the last way lets us specify a default value for our context.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨扩展我们对上下文使用的方法。第一种，使用对象作为值，可能会引起问题。第二种和第三种，使用自定义提供者和多个上下文，可能有助于我们解决问题。最后一种方法允许我们为上下文指定一个默认值。
- en: 8.2.1 Setting an object as the context provider’s value
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.1 将对象作为上下文提供者的值
- en: 'In listing 8.4, our `App` component enlists the help of the `useState` hook
    to manage the current user state. It makes the `user` value available to descendant
    components by setting the `value` prop of a context object’s `Provider` component:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 8.4 中，我们的 `App` 组件利用 `useState` 钩子来管理当前用户状态。它通过设置上下文对象 `Provider` 组件的 `value`
    属性，使得 `user` 值可供子组件使用：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'One of those descendants, `UserPicker`, needs the `user` state value *and*
    its updater function, `setUser`. Because it needs more than just the `user` value,
    we use good old props to fulfill its desires:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些子组件之一，`UserPicker`，需要 `user` 状态值以及其更新函数 `setUser`。因为它需要的不仅仅是 `user` 值，所以我们使用传统的属性来满足其需求：
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There’s nothing wrong with passing props. The current version of the app works
    fine, and the data flow is easy to follow. But, seeing as we already have the
    `user` state value available in the context of the app, let’s update the `UserPicker`
    component to consume that state. We want this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 传递属性没有问题。当前版本的程序运行良好，数据流易于跟踪。但是，鉴于我们已经在应用程序的上下文中有了 `user` 状态值，让我们更新 `UserPicker`
    组件以消费该状态。我们想要的是：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: But the `UserPicker` needs the `user` value and the `setUser` function. Can
    we put them both in the context? Sure!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 但 `UserPicker` 需要的 `user` 值和 `setUser` 函数。我们能将它们两个都放在上下文中吗？当然可以！
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now that we assign a JavaScript object as the value on the provider, the components
    consuming the value must destructure the properties they need from the value object.
    For example, the `BookingDetails` component will grab the user value like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将 JavaScript 对象作为值赋给提供者，消费这些值的组件必须从值对象中解构它们需要的属性。例如，`BookingDetails` 组件将像这样获取用户值：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The assignment now has curly braces around the `user` variable name. That wasn’t
    so bad. But what about the `UsersPage` component (updated in challenge 8.1)? It
    previously assigned the context value to a `loggedInUser` variable. No problem:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在赋值时，`user` 变量名周围有花括号。这并不糟糕。但关于 `UsersPage` 组件（在挑战 8.1 中更新过）呢？它之前将上下文值分配给了一个
    `loggedInUser` 变量。没问题：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The colon syntax lets us assign a property to a differently named variable when
    destructuring an object. In the previous snippet, the `user` property of the context
    value is assigned to a variable named `loggedInUser`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号语法允许我们在解构对象时将属性分配给不同命名的变量。在上面的代码片段中，上下文值的 `user` 属性被分配给名为 `loggedInUser` 的变量。
- en: 'The final component to use the context value is the `UserPicker` component.
    In fact, because it wants the `user` and the `setUser` updater function, it’s
    the reason we switched to an object for the value. That’s okay; when destructuring,
    we can assign all the properties we need to local variables:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个使用上下文值的组件是 `UserPicker` 组件。实际上，因为它需要 `user` 和 `setUser` 更新函数，这也是我们为什么将值切换为对象的原因。这没问题；在解构时，我们可以将所有需要的属性分配给局部变量：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: That’s three different components using the context value in three different
    ways. In section 8.2.2, we take things a bit further and develop our own custom
    provider for the user context. If you want code for switching the context value
    to an object, as just discussed, check the solution branch for challenge 8.2.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个不同的组件以三种不同的方式使用上下文值。在第8.2.2节中，我们进一步发展，为用户上下文开发我们自己的自定义提供者。如果你想要切换上下文值到对象的代码，如刚才讨论的，请查看挑战8.2的解决方案分支。
- en: Challenge 8.2
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 8.2挑战
- en: Update App.js so that the `App` component sets an object, with `user` and `setUser`
    properties, as the `value` prop on the `Provider` component for the user context.
    Update the `BookingDetails`, `UsersPage`, and `UserPicker` components to use the
    new object value via destructuring. The code for the completed challenge is on
    the 0804-object-value branch in the GitHub repo.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`App.js`，使`App`组件将一个对象（包含`user`和`setUser`属性）作为`value`属性传递给用户上下文的`Provider`组件。更新`BookingDetails`、`UsersPage`和`UserPicker`组件，通过解构使用新的对象值。完成挑战的代码位于GitHub仓库的0804-object-value分支。
- en: 8.2.2 Moving the state to a custom provider
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.2 将状态移动到自定义提供者
- en: The current user for the booking app is determined by the `UserPicker` component
    (although in a real app, users would log in). The state value for the current
    user is managed by the `App` component; that’s where the context provider, `UserContext`
    `.Provider`, wraps the tree of components. When a visitor to the site chooses
    a user in the user picker, the `UserPicker` component calls `setUser` to update
    the `user` state value in the `App` component. React notices the state has changed
    and re-renders the component that manages that state, `App`. Because `App` re-renders,
    all of its children re-render, as shown in figure 8.9.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当前用户由预订应用的`UserPicker`组件确定（尽管在实际应用中，用户会进行登录）。当前用户的状态值由`App`组件管理；这就是上下文提供者`UserContext.Provider`包裹组件树的地方。当网站访客在用户选择器中选择用户时，`UserPicker`组件会调用`setUser`来更新`App`组件中的`user`状态值。React注意到状态已更改，并重新渲染管理该状态的组件`App`。因为`App`重新渲染，所以它的所有子组件也会重新渲染，如图8.9所示。
- en: '![](../Images/8-9.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/8-9.png)'
- en: 'Figure 8.9 Calling setUser in the `App` component re-renders the whole tree.
    The gray band around the components after the Provider represents the context:
    `UserPicker` and `BookingDetails` access the user value from the context.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 在`App`组件中调用`setUser`重新渲染整个树。Provider之后的组件周围的灰色带代表上下文：`UserPicker`和`BookingDetails`从上下文中访问用户值。
- en: Re-rendering is not inherently bad—we fixate on the state, and React calls the
    components, does its diffing, and tickles the DOM—and if your app is performing
    well, there’s no need to complicate the code. But, if slower, more involved components
    are in the tree, you might want to avoid re-renders that won’t change the UI.
    We want a way of updating the context provider value without setting off a cascade
    of updates all the way down the component tree. We want the context consumers
    (the components that call `useContext`) to re-render in response to a change of
    value on the provider, not just because the whole tree is re-rendering. Can we
    avoid updating the state in the `App` component?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 重新渲染本身并不是坏事——我们专注于状态，React调用组件，执行diffing操作，并刺激DOM——如果你的应用性能良好，就没有必要使代码复杂化。但是，如果树中有较慢、更复杂的组件，你可能想要避免不会改变UI的重新渲染。我们希望有一种方法来更新上下文提供者的值，而不会在整个组件树中引发一系列更新。我们希望上下文消费者（调用`useContext`的组件）在提供者值变化时重新渲染，而不仅仅是由于整个树重新渲染。我们能否避免在`App`组件中更新状态？
- en: 'Answering that question involves a good understanding of React’s rendering
    behavior. We discuss the concepts and how to apply them in the following four
    subsections:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 回答那个问题需要很好地理解React的渲染行为。我们将在以下四个小节中讨论这些概念以及如何应用它们：
- en: Creating a custom provider
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义提供者
- en: Using the `children` prop to render wrapped components
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`children`属性渲染包装组件
- en: Avoiding unnecessary re-renders
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免不必要的重新渲染
- en: Using the custom provider
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义提供者
- en: Creating a custom provider
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义提供者
- en: If `App` is managing the `user` state only so it can pass it to `UserContext.Provider`,
    and we already have a separate file for `UserContext`, why not manage the state
    in the same place as the context? Can we build a `UserProvider` component that
    we use to wrap the component tree and that manages the user state itself? You
    bet we can! The following listing shows our very own custom provider component,
    `UserProvider`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `App` 只管理 `user` 状态以便将其传递给 `UserContext.Provider`，而我们已经有了一个单独的 `UserContext`
    文件，为什么不在与上下文相同的地方管理状态呢？我们能构建一个 `UserProvider` 组件，用它来包裹组件树并管理用户状态本身吗？当然可以！下面的列表展示了我们自己的自定义提供者组件，`UserProvider`。
- en: 'Branch: 0805-custom-provider, File: /src/components/Users/UserContext.js'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0805-custom-provider，文件：/src/components/Users/UserContext.js
- en: Listing 8.7 Exporting a custom provider along with the user context
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.7 导出自定义提供者与用户上下文
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Export the context object so that other components can import it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导出上下文对象，以便其他组件可以导入它。
- en: ❷ Assign the special children prop to a local variable.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将特殊的 `children` 属性分配给一个局部变量。
- en: ❸ Manage the user state within the component.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在组件内管理用户状态。
- en: ❹ Set an object as the context value.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 设置一个对象作为上下文值。
- en: ❺ Render the children inside the provider.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在提供者内部渲染子组件。
- en: '`UserContext` is still the default export, so no files that import and use
    it directly need to change. But the context file now has a named export, `UserProvider`,
    our custom provider component. The custom provider calls `useState` to manage
    the user value and to get an updater function. It passes the value and function,
    wrapped in an object, to the `UserContext.Provider` component as the value to
    share for the context:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserContext` 仍然是默认导出，所以不需要更改直接导入和使用它的文件。但是，上下文文件现在有一个命名导出，`UserProvider`，我们的自定义提供者组件。自定义提供者调用
    `useState` 来管理用户值并获取一个更新函数。它将值和函数（封装在一个对象中）传递给 `UserContext.Provider` 组件作为上下文共享的值：'
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When we use our custom provider, we wrap it around part or all of our app in
    JSX. All of the wrapped components get access to the value set by the provider
    (if they call `useContext` with `UserContext`):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用我们的自定义提供者时，我们用 JSX 将它包裹在应用的部分或全部周围。所有被包裹的组件都可以访问提供者设置的值（如果它们使用 `UserContext`
    调用 `useContext`）：
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Let’s look at that `children` prop in a bit more detail.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看那个 `children` 属性。
- en: Using the children prop to render wrapped components
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `children` 属性渲染包裹的组件
- en: 'Whenever a component wraps other components, React assigns the wrapped components
    to the `children` prop of the wrapper. For example, here’s a `Wrapper` component
    with a `MyComponent` component as a child:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 每当组件包裹其他组件时，React 会将包裹的组件分配给包装器的 `children` 属性。例如，这里有一个 `Wrapper` 组件，它有一个作为子组件的
    `MyComponent` 组件：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When React calls `Wrapper` to get its UI, it passes `Wrapper` the child component,
    `MyComponent`, assigning it to the `children` prop. (React has always been doing
    this; we just haven’t used the `children` prop until now.)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当 React 调用 `Wrapper` 来获取其 UI 时，它将子组件 `MyComponent` 传递给 `Wrapper`，并将其分配给 `children`
    属性。（React 一直都在这样做；我们只是直到现在还没有使用 `children` 属性。）
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ React assigns any child components to the children prop.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ React 将任何子组件分配给 `children` 属性。
- en: ❷ Use the child components when returning the UI.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在返回 UI 时使用子组件。
- en: 'When returning its UI, `Wrapper` uses the components React has assigned to
    `children`. The UI becomes the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当返回其 UI 时，`Wrapper` 使用 React 分配给 `children` 的组件。UI 变成以下内容：
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For the `Wrapper` example, `children` is a single component. If `Wrapper` wraps
    multiple, sibling components, then `children` is an array of components. Find
    out more about working with the `children` prop in the React docs: [https://reactjs.org/docs/react-api.html#reactchildren](https://reactjs.org/docs/react-api.html#reactchildren).'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Wrapper` 示例，`children` 是一个单个组件。如果 `Wrapper` 包裹多个兄弟组件，那么 `children` 是组件数组。更多关于在
    React 文档中处理 `children` 属性的信息：[https://reactjs.org/docs/react-api.html#reactchildren](https://reactjs.org/docs/react-api.html#reactchildren)。
- en: 'Back in our `App` component, React assigns to the `children` prop of `UserProvider`,
    the components that `UserProvider` wraps. `UserProvider` uses the `children` prop
    to make sure the `UserContext.Provider` component still renders the components
    that our custom `UserProvider` component now wraps:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `App` 组件中，React 将 `UserProvider` 的 `children` 属性分配给 `UserProvider` 包裹的组件。`UserProvider`
    使用 `children` 属性确保 `UserContext.Provider` 组件仍然渲染我们的自定义 `UserProvider` 组件现在包裹的组件：
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ React assigns the wrapped components to the children prop.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ React 将包裹的组件分配给 `children` 属性。
- en: ❷ Render the wrapped components within the provider for a context.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在上下文中提供者内部渲染包裹的组件。
- en: It wraps the child components in the user context’s provider and sets the provider’s
    `value`, making the `user` value and `setUser` function available to the wrapped
    children. The context and the state are now in the same place. That’s nice for
    organization, understanding, and maintainability. But there’s an optimization
    benefit too.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 它将子组件包裹在用户上下文的提供者中，并设置提供者的`value`，使得`user`值和`setUser`函数对被包裹的子组件可用。现在上下文和状态在同一位置。这对组织、理解和可维护性来说是个优点。但还有优化好处。
- en: Avoiding unnecessary re-renders
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 避免不必要的重新渲染
- en: When a descendant (the user picker, for example) calls `setUser` to update the
    `user` state value in the `UserProvider` component, React notices the state has
    changed and re-renders the component that manages that state, `UserProvider`.
    But for `UserProvider`, all of its children don’t re-render, as illustrated in
    figure 8.10.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个后代（例如用户选择器）调用`setUser`来更新`UserProvider`组件中的`user`状态值时，React会注意到状态已更改并重新渲染管理该状态组件`UserProvider`。但对于`UserProvider`，所有子组件都不会重新渲染，如图8.10所示。
- en: '![](../Images/8-10.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/8-10.png)'
- en: Figure 8.10 When `UserProvider` re-renders, only the context consumers, not
    the whole tree, re-render.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 当`UserProvider`重新渲染时，只有上下文消费者，而不是整个树，会重新渲染。
- en: It may be unexpected, but it’s standard React rendering behavior; no special
    memoizing function is being applied here. What makes `UserProvider` behave differently
    from our `App` component, when `App` was managing the user state? What stops React
    from rendering the provider’s children?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能令人意外，但这是标准的React渲染行为；这里没有应用特殊的记忆化函数。是什么让`UserProvider`在`App`组件管理用户状态时表现得不同？什么阻止React渲染提供者的子组件？
- en: It’s because `UserProvider` accesses its children as a prop, and updating the
    state *within* the component doesn’t change its props. The identity of `children`
    doesn’t change when a descendant calls `setUser`. It’s exactly the same object
    as it was before. There’s no need to re-render all the children, so React doesn’t.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`UserProvider`将其子组件作为prop访问，并且在组件内部更新状态不会改变其props。当后代调用`setUser`时，`children`的身份不会改变。它正是之前相同的对象。没有必要重新渲染所有子组件，所以React不会。
- en: Except for the context consumers! Context consumers *always* re-render when
    the value of the closest provider for their context changes. Our custom provider
    provides an updater function to its consumers. When a component calls the updater
    function, the custom provider re-renders, updating its context value. React knows
    the provider’s children haven’t changed, so doesn’t re-render them. Any components
    that consume the context, however, do re-render in response to the change of value
    on the provider, not because the whole tree of components has re-rendered.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上下文消费者！上下文消费者在其上下文最近的提供者值更改时*总是*重新渲染。我们的自定义提供者为消费者提供了一个更新函数。当组件调用更新函数时，自定义提供者会重新渲染，更新其上下文值。React知道提供者的子组件没有变化，所以不会重新渲染它们。然而，任何消费上下文的组件都会在提供者值更改时重新渲染，而不是因为整个组件树已经重新渲染。
- en: Using the custom provider
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义提供者
- en: Now that our custom provider is looking after the user state, we can simplify
    the `App` component, removing the import and calling of `useState` and the need
    to set a value on the provider. The following listing shows the slimmer code.
    Notice, also, that we no longer set props on `UserPicker`; it was switched over
    to using context in challenge 8.2.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们自定义提供者负责用户状态，我们可以简化`App`组件，移除导入和调用`useState`以及设置提供者值的需求。下面的列表显示了更简洁的代码。注意，我们也不再在`UserPicker`上设置props；在挑战8.2中，它已经切换到使用上下文。
- en: 'Branch: 0805-custom-provider, File: /src/components/App.js'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0805-custom-provider，文件：/src/components/App.js
- en: Listing 8.8 Using the custom provider in the `App` component
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.8 在`App`组件中使用自定义提供者
- en: '[PRE25]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ Import the custom provider.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入自定义提供者。
- en: ❷ Wrap the app UI in the provider.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将应用UI包裹在提供者中。
- en: ❸ Don’t pass props to the user picker.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 不要向用户选择器传递props。
- en: ❹ Wrap the app UI in the provider.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将应用UI包裹在提供者中。
- en: Because, in the JSX, `UserProvider` wraps `Router`, the `Router` component is
    assigned to the `UserProvider` component’s `children` prop, and `UserProvider`,
    our custom provider, wraps it in `UserContext.Provider`, the actual context provider
    component. That way, every component in the app gets access to the user context.
    In chapter 9, we’ll see how custom hooks can be used to more easily work with
    the Context API from the consumers’ perspective.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在 JSX 中，`UserProvider` 包裹了 `Router`，所以 `Router` 组件被分配给 `UserProvider` 组件的
    `children` 属性，而我们的自定义提供者 `UserProvider` 则将其包裹在 `UserContext.Provider` 中，这就是实际的上下文提供组件。这样，应用中的每个组件都可以访问用户上下文。在第
    9 章中，我们将看到如何使用自定义钩子从消费者角度更轻松地与 Context API 一起工作。
- en: Our custom provider assigns an object, `{user,` `setUser}`, as the value for
    the context provider component. In the next section, we look at downsides to using
    an object in this way.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的定制提供者将一个对象 `{user, setUser}` 分配为上下文提供组件的值。在下一节中，我们将探讨以这种方式使用对象的不利之处。
- en: 8.2.3 Working with multiple contexts
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.3 与多个上下文一起工作
- en: Now that we have a mechanism for sharing values across the whole application,
    you may be tempted to create a single, monstrous store for the app’s state and
    let components anywhere consume the bloated, gassy value it provides. But—as you
    might have guessed from the previous sentence’s hyperbole—that’s not always the
    best idea. If a component needs some state, try to manage it in the component.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了在整个应用中共享值的方法，你可能会想创建一个单一、庞大的存储库来存储应用的状态，并让任何地方的组件消费它提供的庞大、有气味的值。但——正如你从上一句夸张的表述中猜到的——这并不总是最好的主意。如果一个组件需要一些状态，尽量在组件中管理它。
- en: 'Keeping the state with the component that uses it makes it easier to work with
    and reuse the component. If the app develops and a sibling now needs the same
    state, lift the state into a shared parent and pass it down via props. If extra
    levels of nested components are introduced between the state and some of the components
    that use it, consider c*omponent composition* before reaching for the Context
    API. The React docs have some information about composition: [http://mng.bz/PPjY](https://shortener.manning.com/PPjY).'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 将状态与使用它的组件保持在一起，使其更容易使用和重用组件。如果应用发展，并且一个兄弟组件现在需要相同的状态，将状态提升到共享父组件中，并通过属性传递下来。如果在状态和某些使用它的组件之间引入了额外的嵌套组件层级，在伸手去拿
    Context API 之前，考虑一下 *组件组合*。React 文档中有些关于组合的信息：[http://mng.bz/PPjY](https://shortener.manning.com/PPjY)。
- en: 'If you find you really do have state that doesn’t change often and that is
    used by many components at different levels across your app, the Context API sounds
    like a good fit. But even then, a single state object provided by context can
    be inefficient. Say your context state value looks like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现你确实有一些不经常改变且在应用的不同层级被多个组件使用的状态，那么 Context API 看起来是一个很好的选择。但即便如此，由上下文提供的单个状态对象可能效率不高。假设你的上下文状态值如下所示：
- en: '[PRE26]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Across your component hierarchy, some components use the theme, some the user,
    others the language, and yet others use the animal. The problem is, if a single
    property value changes (say the theme changes from `lava` to `cute`), *all* of
    the components that consume the context will re-render, even if they’re not interested
    in the changed value. A nested component with a craving for just the juiciest
    state tidbits gets tacos, tapioca, and a huge lamb tagine too! Fortunately, there’s
    an easy fix. (Although, if I can keep the tagine, I’ll be sorted for a few days.
    Mmmmmmm tagine . . .)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的组件层次结构中，一些组件使用主题，一些使用用户，其他使用语言，还有一些使用动物。问题是，如果单个属性值发生变化（比如主题从 `lava` 变为 `cute`），那么消费上下文的
    *所有* 组件都将重新渲染，即使它们对更改的值不感兴趣。一个渴望仅获取最精华状态片段的嵌套组件得到了玉米卷、木薯粉和一大块羊肉塔吉锅！幸运的是，有一个简单的解决办法。（尽管，如果我能保留塔吉锅，我会开心好几天。嗯嗯，塔吉锅……）
- en: Splitting the context values across multiple providers
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个提供者之间拆分上下文值
- en: 'You can use as many contexts as you need, and nested components can call the
    `useContext` hook on just the contexts they consume. Here’s what the providers
    look like if each shared value gets its own:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要使用任意多的上下文，嵌套组件只需在其消费的上下文中调用 `useContext` 钩子。如果每个共享值都有自己的提供者，那么提供者看起来是这样的：
- en: '[PRE27]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, nested components consume only the values they need and re-render when
    their selected values change. Here are two components that access a pair of context
    values each:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，嵌套组件只消费它们需要的值，并在所选值改变时重新渲染。这里有两组组件，每组访问一对上下文值：
- en: '[PRE28]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Using a custom provider for multiple contexts
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义提供者为多个上下文提供支持
- en: 'You want to put your providers as close to the components that consume their
    contexts as possible, wrapping subtrees rather than the whole app. Sometimes,
    however, the context really is used across the whole app, and the providers can
    go at or close to the root. The code at the root often doesn’t change much, so
    don’t worry about nesting multiple providers; you don’t have to see the nesting
    as “wrapper hell” or a “pyramid of doom.” If you prefer, and the providers are
    likely to stay together, you can always create a custom provider that groups multiple
    providers in one place, like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望将提供者尽可能靠近消费其上下文的组件，包装子树而不是整个应用。有时，上下文确实在整个应用中使用，提供者可以放在或接近根位置。根部的代码通常变化不大，所以不必担心嵌套多个提供者；你不必将嵌套视为“包装地狱”或“末日金字塔”。如果你愿意，并且提供者可能保持在一起，你始终可以创建一个自定义提供者，将多个提供者组合在一个地方，如下所示：
- en: '[PRE29]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then the app can use the custom provider(s):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然后应用可以使用自定义提供者（s）：
- en: '[PRE30]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As we saw in section 8.2.2, using a custom provider with a `children` prop can
    help with unnecessary child component re-renders too.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 8.2.2 节中看到的，使用具有 `children` 属性的自定义提供者也有助于减少不必要的子组件重新渲染。
- en: Using separate contexts for a state value and its updater function
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单独的上下文为状态值及其更新函数
- en: When a context provider’s value changes, its consumers re-render. A provider
    might also re-render as a result of its parent re-rendering. If the provider’s
    value is an object that the code creates every time the provider renders, the
    value changes on each render, even if the property values you assign to the object
    stay the same.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当上下文提供者的值发生变化时，其消费者会重新渲染。提供者也可能因为其父组件重新渲染而重新渲染。如果提供者的值是一个代码每次提供者渲染时都创建的对象，则值在每个渲染时都会变化，即使分配给对象的属性值保持不变。
- en: 'Take another look at our custom `UserProvider` component in the bookings app:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 再看看我们的预订应用中的自定义 `UserProvider` 组件：
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ A new object is assigned to the value prop on every render.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 每次渲染都会将一个新的对象分配给值属性。
- en: We assign an object, `{user,` `setUser}`, to the `value` prop of the provider.
    Every time the component renders, it’s a fresh object that’s assigned, even if
    the two properties, `user` and `setUser`, are the same. The consumers of the context—`UserPicker`,
    `UsersPage`, and `BookingDetails`—re-render whenever `UserProvider` re-renders.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个对象 `{user,` `setUser}` 分配给提供者的 `value` 属性。每次组件渲染时，都会分配一个新的对象，即使两个属性 `user`
    和 `setUser` 是相同的。上下文的消费者——`UserPicker`、`UsersPage` 和 `BookingDetails`——在 `UserProvider`
    重新渲染时也会重新渲染。
- en: Also, by using an object as the value, if a nested component uses only one of
    the properties on the object, it will still re-render when the other property
    changes (it’s tidbits and tacos again). In our case, that’s not a problem; `setUser`
    never changes, and the only component that uses it, `UserPicker`, also uses the
    `user` property. But if we were to build a proper login system, we could easily
    create a logout button that didn’t need the current user but that did need to
    call `setUser`. There’s no need to re-render the button every time the user changes.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过使用对象作为值，如果嵌套组件只使用对象上的一个属性，那么当其他属性变化时，它仍然会重新渲染（又是零碎和玉米卷）。在我们的例子中，这不是问题；`setUser`
    从不改变，唯一使用它的组件 `UserPicker` 也使用 `user` 属性。但如果我们构建一个合适的登录系统，我们可以轻松地创建一个不需要当前用户但需要调用
    `setUser` 的注销按钮。没有必要每次用户更改时都重新渲染按钮。
- en: 'So, we have two problems:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有两个问题：
- en: A new object is assigned to the provider value every render.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次渲染都会将一个新的对象分配给提供者值。
- en: Changing one property on the value re-renders consumers that may not consume
    that value.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在值上更改一个属性会重新渲染可能不会消费该值的消费者。
- en: We can solve both problems by using two contexts rather than one in our custom
    provider, as shown in the following listing.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在自定义提供者中使用两个上下文而不是一个来解决这两个问题，如下所示。
- en: 'Branch: 0806-multiple-contexts, File: /src/components/Users/UserContext.js'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0806-multiple-contexts，文件：/src/components/Users/UserContext.js
- en: Listing 8.9 Using separate providers for a value and its updater function
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.9 使用单独的提供者为值及其更新函数
- en: '[PRE32]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ Create a separate context for setting the current user.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为设置当前用户创建一个单独的上下文。
- en: ❷ Set the user as a value.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将用户设置为值。
- en: ❸ Set the updater function as a value on its own provider.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将更新函数作为值设置在其自己的提供者上。
- en: '`user` and `setUser` are not re-created every render, and we now use a separate
    context and provider for each value, so consumers of one value are not affected
    by changes to the other.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`user` 和 `setUser` 并不是每次渲染时都重新创建，我们现在为每个值使用单独的上下文和提供者，因此一个值的消费者不会受到另一个值变化的影响。'
- en: The latest branch also updates the consumer components; they don’t need to destructure
    values from a value object, and `UserPicker` imports and uses the new `UserSetContext`
    context object.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最新分支也更新了消费者组件；它们不需要从值对象中解构值，`UserPicker` 导入并使用了新的 `UserSetContext` 上下文对象。
- en: 8.2.4 Specifying a default value for a context
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.4 为上下文指定默认值
- en: 'Working with the Context API involves providers and consumers: the provider
    sets a value, and the consumer reads the value. But working with two separate
    parts can require a little trust. What if we call `useContext` with a context
    object, but no corresponding provider is set further up the tree? If appropriate,
    when creating a context object, we can specify a default value for just such an
    occurrence, like this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Context API 涉及提供者和消费者：提供者设置一个值，消费者读取这个值。但与两个独立部分一起工作可能需要一点信任。如果我们调用 `useContext`
    并传入一个上下文对象，但树中没有设置相应的提供者怎么办？如果适当，在创建上下文对象时，我们可以指定一个默认值以应对这种情况，如下所示：
- en: '[PRE33]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `useContext` hook will return the context object’s default value if no value
    is set by a corresponding provider for that context. This could be useful if your
    app uses a default language or theme; a provider could be used to override the
    default, but everything would still work if no provider was included.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有设置相应提供者来设置该上下文的值，`useContext` 钩子将返回上下文对象的默认值。如果您的应用程序使用默认语言或主题，这可能很有用；可以使用提供者来覆盖默认值，但如果未包含提供者，一切仍然可以正常工作。
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: For rarely changing values used by many components, consider using the Context
    API.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于许多组件使用的很少改变的价值，考虑使用 Context API。
- en: 'Create a context object to manage a particular value that components will access:'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个上下文对象来管理组件将要访问的特定值：
- en: '[PRE34]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Export the context object to make it available to other components. (Or create
    the context object in the same scope as the provider and consumer components.)
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出上下文对象以使其对其他组件可用。（或者创建与提供者和消费者组件相同作用域的上下文对象。）
- en: Import the context object into the provider and consumer component files.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将上下文对象导入提供者和消费者组件文件中。
- en: 'Wrap the component tree that needs access to the shared state value with the
    context object’s provider component, setting the value as a prop:'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将需要访问共享状态值的组件树包裹在上下文对象的提供者组件中，将值作为属性设置：
- en: '[PRE35]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Access context values with the `useContext` hook, passing it the context object:'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `useContext` 钩子访问上下文值，传入上下文对象：
- en: '[PRE36]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Whenever the context value changes, the consuming component will re-render.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每当上下文值发生变化时，消费组件将重新渲染。
- en: 'Optionally, specify a default value for a context when creating it:'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选地，在创建上下文时指定一个默认值：
- en: '[PRE37]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `useContext` hook will return the default value if no provider for the context
    is set further up the component tree.
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果在组件树中没有设置上下文的提供者，`useContext` 钩子将返回默认值。
- en: Use multiple contexts for values that aren’t usually consumed together. Consumer
    components that consume one value can re-render independently of those that consume
    another value.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于通常不一起消费的值，使用多个上下文。消费一个值的消费者组件可以独立于消费另一个值的组件重新渲染。
- en: Create custom providers to manage state for shared values.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义提供者来管理共享值的州。
- en: Use the `children` prop in custom components to avoid re-rendering descendants
    that don’t consume the context.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在自定义组件中使用 `children` 属性以避免重新渲染不消费上下文的子组件。
