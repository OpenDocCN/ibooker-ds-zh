- en: 5 Introduction to social network analysis
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 社交网络分析简介
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Presenting random and scale-free network degree distribution
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示随机和无尺度网络度分布
- en: Using metrics to characterize a network
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用度量来表征网络
- en: Introducing the Neo4j Graph Data Science library
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Neo4j图数据科学库
- en: Using native projection to project an in-memory graph
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原生投影来投影内存中的图
- en: Inspecting the community structure of a graph
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查图的社区结构
- en: Finding influencers in the network with PageRank
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PageRank在网络上查找影响者
- en: Social network analysis is a process of investigating network structures and
    node roles using graph theory and algorithms. One of the earliest network science
    writers was Hungarian author Frigyes Karinthy. One of his most important works
    is a short story, “Láncszemek,” in which he describes that even though we think
    the world is vast, it is, in fact, very tiny. The story was originally written
    in Hungarian, but Adam Makkai prepared an English translation ([http://mng.bz/E9ER](http://mng.bz/E9ER)).
    The short story describes an idea known today as the *small-world concept*. To
    demonstrate his claim, he presented how he could connect himself to someone far
    from his perspective in 1929\. In Karinthy’s example, he showed how he, being
    in Budapest, could connect to a worker in an American Ford factory. The worker
    in the Ford factory knows his manager, and that manager probably knows Henry Ford.
    Henry Ford probably knows an industrialist in Hungary, and that industrialist
    is, perhaps, a friend of a friend of Karinthy. This way, he demonstrated that
    a Ford company worker is probably four or five handshakes away from an author
    in Budapest. Over the years, the small-world concept has been rebranded and popularized
    as the *six degrees of separation*, from John Guare’s play *Six Degrees of Separation*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 社交网络分析是使用图理论和算法研究网络结构和节点角色的过程。最早的网络科学作家之一是匈牙利作家弗里吉斯·卡林蒂（Frigyes Karinthy）。他最重要的作品之一是短篇小说“Láncszemek”，在其中他描述了尽管我们认为世界很广阔，但实际上它非常小。这个故事最初是用匈牙利语写的，但亚当·马卡伊（Adam
    Makkai）准备了一个英文翻译([http://mng.bz/E9ER](http://mng.bz/E9ER))。这个短篇小说描述了一个今天被称为*小世界概念*的想法。为了证明他的观点，他展示了他在1929年如何将自己与他视角之外的人联系起来。在卡林蒂的例子中，他展示了作为布达佩斯人的他如何与一个美国福特工厂的工人联系起来。福特工厂的工人认识他的经理，而那位经理可能认识亨利·福特。亨利·福特可能认识一个在匈牙利的工业家，而这个工业家可能是卡林蒂的一个朋友的朋友。这样，他证明了福特公司的工人可能只隔四到五个握手就能与布达佩斯的作家联系起来。多年来，小世界概念被重新命名并普及为*六度分隔*，源自约翰·古尔（John
    Guare）的戏剧*六度分隔*。
- en: In the 1950s and ’60s, Paul Erdös and Alfréd Rényi started to work on language
    for describing a network. In their 1959 paper, they started to examine how large
    networks behave. Large networks look so complicated that one might assume they
    are random. Even in a social network, it is hard to predict who is connected to
    whom. They assumed those networks must be random, as people might randomly meet
    other people or molecules randomly interact with each other.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪50年代和60年代，保罗·埃尔德什（Paul Erdös）和阿夫拉姆·雷尼（Alfréd Rényi）开始研究用于描述网络的术语。在他们的1959年论文中，他们开始研究大型网络的行为。大型网络看起来如此复杂，以至于人们可能会认为它们是随机的。即使在社交网络中，也很难预测谁与谁相连。他们认为这些网络必须是随机的，因为人们可能会随机遇到其他人，或者分子可能会随机相互作用。
- en: An essential aspect of characterizing any network is to look at the node degree
    distribution. In simple terms, the node degree is the number of links each node
    has. In a random network, the degree distribution will follow the Gaussian distribution,
    as shown in figure 5.1\.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 任何网络的表征一个基本方面是查看节点度分布。简单来说，节点度是每个节点拥有的链接数量。在随机网络中，度分布将遵循高斯分布，如图5.1所示。
- en: '![05-01](../../OEBPS/Images/05-01.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![05-01](../../OEBPS/Images/05-01.png)'
- en: Figure 5.1 Random network degree distribution
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 随机网络度分布
- en: The vast majority of nodes have roughly the same number of links. There won’t
    be many hugely popular nodes, but there won’t be many isolated nodes either. However,
    the Gaussian distribution is most often used for independent observations. On
    the other hand, a graph consists of highly interconnected observations that are
    not independent. It turns out that almost no real-world network follows the random
    network degree distribution. The idea behind this claim is that networks have
    profound organizing principles. At about the same time, Google developed its famous
    graph algorithm PageRank (Brin & Page, 1998) and Albert Barabási and his colleagues
    examined the structure of the web (Albert et al. 1999). The web consists of web
    pages and URL links pointing to other sites. This is essentially a network, where
    nodes represent web pages and relationships represent their URL links. The assumption
    was that the web would turn out to be a random network as anyone can publish a
    web page and choose which sites they want to link to. They discovered that the
    web degree distribution follows a different pattern, as shown in figure 5.2.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数节点大致具有相同数量的链接。不会有很多非常受欢迎的节点，但也不会有很多孤立的节点。然而，高斯分布通常用于独立观测。另一方面，一个图由高度相互连接的观测组成，这些观测不是独立的。结果发现，几乎没有任何现实世界的网络遵循随机网络度分布。这个主张背后的想法是网络有深刻的组织原则。大约在同一时间，Google开发了其著名的图算法PageRank（Brin
    & Page，1998年），Albert Barabási和他的同事检查了网络的架构（Albert et al. 1999年）。网络由网页和指向其他网站的URL链接组成。这本质上是一个网络，其中节点代表网页，关系代表它们的URL链接。假设是，网络将变成一个随机网络，因为任何人都可以发布网页并选择他们想要链接的网站。他们发现，网络的度分布遵循不同的模式，如图5.2所示。
- en: '![05-02](../../OEBPS/Images/05-02.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![05-02](../../OEBPS/Images/05-02.png)'
- en: Figure 5.2 Scale-free network degree distribution
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 无标度网络度分布
- en: 'This is a very different degree distribution than expected. On the web, the
    vast majority of pages are very rarely, if ever, visited; they may have one or
    two links pointing to them. Then, there are some pages, such as Google, Amazon,
    Yahoo, and others, that have hundreds of millions of links pointing to them. Such
    a network is incredibly uneven and is, today, known as a *scale-free network*.
    It was later shown that most real-world networks are scale-free networks, where
    a few big hubs hold together many tiny nodes. Why is that so? The truth is that
    networks have profound organizing principles. For example, think of a group of
    people. Who is more likely to form new connections: a person with only a few friends
    or a person who already has many friends? It turns out that a person who already
    has many friends is more likely to form new relationships. A simple explanation
    is that they are likely to be invited to more events, at which they can mingle
    with new folks, due to their greater number of existing connections. Also, they
    are more likely to be introduced to new people by their existing contacts. This
    network organizing principle is known as the *preferential attachment model*,
    a term coined by Barabási and Albert (1999).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这与预期的度分布非常不同。在互联网上，绝大多数网页很少被访问，甚至从未被访问；它们可能只有一个或两个链接指向它们。然后，有一些网页，如Google、Amazon、Yahoo和其他，有数亿个链接指向它们。这样的网络极其不均匀，今天被称为*无标度网络*。后来发现，大多数现实世界的网络都是无标度网络，其中一些大型枢纽节点连接了许多微小的节点。为什么会这样呢？事实是网络有深刻的组织原则。例如，考虑一群人。谁更有可能建立新的联系：只有几个朋友的个人，还是已经有很多朋友的个人？结果是，已经有很多朋友的个人更有可能建立新的关系。一个简单的解释是，他们更有可能被邀请参加更多活动，在这些活动中，他们可以与新人交往，因为他们现有的联系数量更多。此外，他们更有可能通过现有的联系人介绍给新人。这种网络组织原则被称为*优先连接模型*，这是Barabási和Albert（1999年）提出的术语。
- en: Traditional analytical tools are frequently designed to work with independent
    observations that adhere to the Gaussian distribution. However, these tools might
    be troublesome for analyzing densely and unevenly connected data. Therefore, a
    set of graph analysis tools was designed to handle highly connected data that
    adheres to a power-law distribution.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 传统分析工具通常被设计用于处理遵循高斯分布的独立观测数据。然而，这些工具在分析密集且不均匀连接的数据时可能会遇到麻烦。因此，设计了一套图分析工具来处理高度连接且遵循幂律分布的数据。
- en: 5.1 Follower network
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 关注者网络
- en: Most graph algorithms were designed to be used on monopartite networks. If you
    recall, a monopartite network contains a single type of nodes and relationships.
    A typical example is a friendship network, where you only have people and their
    friendship relationships. Another frequently mentioned example is the web network,
    where you deal with web pages and hyperlinks connecting them. Even when dealing
    with a multipartite network, it is common to infer or project a monopartite network
    using various techniques. The next chapter will focus more on inferring monopartite
    networks.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数图算法都是设计用于单部分网络的。如果你还记得，单部分网络包含一种类型的节点和关系。一个典型的例子是友谊网络，其中你只有人和他们的友谊关系。另一个经常提到的例子是网络网络，其中你处理网页和连接它们的超链接。即使处理多部分网络，也常见使用各种技术推断或投影单部分网络。下一章将更多地关注推断单部分网络。
- en: Here, you will execute your first graph algorithms on the Twitter followers
    network. Even though the Twitter social graph contains multiple node types and
    relationships, you can focus your graph analysis on a specific subgraph. The followers
    network is monopartite, as it contains only `User` nodes and `FOLLOWS` relationships.
    I’ve chosen it so you don’t have to deal with monopartite projections just yet.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将在Twitter跟随者网络上执行你的第一个图算法。尽管Twitter社交图包含多种节点类型和关系，但你可以将你的图分析集中在特定的子图上。跟随者网络是单部分的，因为它只包含`User`节点和`FOLLOWS`关系。我选择它是因为你目前不需要处理单部分投影。
- en: A user can follow another user, but they don’t necessarily follow them back.
    This means you are dealing with a directed network. Also, the relationships don’t
    have any attribute or property that would quantify their strength, which implies
    you are dealing with an unweighted network.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用户可以关注另一个用户，但他们不一定回关。这意味着你正在处理一个有向网络。此外，关系没有任何属性或属性可以量化它们的强度，这意味着你正在处理一个无权网络。
- en: 'First, you will learn how to characterize the followers network in terms of
    connectedness and the density of links. For example, the Stanford Network Analysis
    Platform (SNAP) repository ([http://snap.stanford.edu/index.xhtml](http://snap.stanford.edu/index.xhtml))
    contains a variety of graph datasets. If you open the Pokec social network ([http://snap.stanford.edu/data/soc-Pokec.xhtml](http://snap.stanford.edu/data/soc-Pokec.xhtml))
    dataset web page, you can observe that the following characteristics of a network
    are given along with the data itself:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将学习如何从连通性和链接密度方面来描述跟随者网络。例如，斯坦福网络分析平台（SNAP）仓库（[http://snap.stanford.edu/index.xhtml](http://snap.stanford.edu/index.xhtml)）包含各种图数据集。如果你打开Pokec社交网络（[http://snap.stanford.edu/data/soc-Pokec.xhtml](http://snap.stanford.edu/data/soc-Pokec.xhtml)）数据集网页，你可以观察到网络的一些特征与数据本身一起给出：
- en: Number of nodes
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点数
- en: Number of relationships
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系数
- en: Number of nodes in the largest weakly connected component
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大的弱连接组件中的节点数
- en: Number of nodes in the largest strongly connected component
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大的强连接组件中的节点数
- en: Average local clustering coefficient
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平均局部聚类系数
- en: To characterize a network, you will be using Cypher query language and graph
    algorithms from the Neo4j Graph Data Science library. Specifically, in this chapter,
    you will learn to use some *community detection* and *centrality* graph algorithms.
    The community detection algorithms will be used to characterize the network and
    also find tightly connected groups of users. In the context of networks, a community
    refers to a densely connected group of nodes, whose members have comparatively
    fewer connections to other communities in the network. For example, think of a
    friendship network (figure 5.3).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了描述网络，你将使用Cypher查询语言和Neo4j图数据科学库中的图算法。具体来说，在本章中，你将学习如何使用一些*社区检测*和*中心性*图算法。社区检测算法将用于描述网络并找到紧密连接的用户组。在网络的背景下，社区指的是一个密集连接的节点组，其成员与其他网络中的社区相比具有较少的连接。例如，考虑一个友谊网络（图5.3）。
- en: '![05-03](../../OEBPS/Images/05-03.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![05-03](../../OEBPS/Images/05-03.png)'
- en: Figure 5.3 Friendship network with nodes with outlined communities
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3带有轮廓社区的友谊网络
- en: Figure 5.3 visualizes a network of eight people and their friendship connections.
    The communities are outlined with circles. You can observe that communities form
    between nodes that are densely interconnected. For example, there are three communities
    in figure 5.3; on the right side, Frodo, Samwise, and Jack form a community. They
    all have connections with each other, similar to what you would expect of a group
    of friends. Although Jack has a connection with Ganesh, they don’t belong to the
    same community, as Ganesh doesn’t share any ties to the other friends in Jack’s
    group.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3可视化了一个八人的网络及其友谊联系。社区用圆圈标出。你可以观察到，在节点之间紧密相连的地方形成了社区。例如，图5.3中有三个社区；在右侧，弗罗多、山姆维兹和杰克形成一个社区。他们彼此之间都有联系，就像你预期的一群朋友一样。尽管杰克和甘尼许有联系，但他们不属于同一个社区，因为甘尼许与杰克组中的其他朋友没有任何联系。
- en: This makes sense if you think about it in terms of real-life friend groups.
    Imagine you have a group of friends with whom you like to go hiking or play board
    games. Let’s call them your community of friends. Now, even though you might make
    a friend at your workplace, that doesn’t automatically make the work friend part
    of your community. And likely, the work friend also has a separate group of friends
    they engage in hobbies with. You could only consider the two communities to be
    merged and to form a single community with densely connected ties if your community
    and your work friend’s community joined to, for example, play board games or go
    hiking together. In that case, you would belong to the same community as your
    work friend, with whom you now also hang out in your free time.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从现实生活中的朋友圈的角度来考虑，这就有意义了。想象一下，你有一群喜欢一起去徒步或玩桌游的朋友。我们可以称他们为你的朋友圈。现在，尽管你可能在工作中交到朋友，但这并不意味着这个工作朋友自动成为你朋友圈的一部分。而且，很可能这个工作朋友也有一个他们一起参与爱好活动的独立朋友圈。只有当你的朋友圈和你的工作朋友的朋友圈一起，例如一起玩桌游或去徒步时，你才能考虑这两个朋友圈合并，形成一个紧密相连的单个朋友圈。在这种情况下，你将和你工作上的朋友属于同一个朋友圈，你们现在也会在空闲时间一起出去玩。
- en: Community detection techniques can be used to detect various segments of users,
    discover people with common interests, or recommend new connections within a community.
    Suppose you take a step away from social networks. In that case, you could use
    community detection algorithms to group proteins with similar roles (Pinkert et
    al., 2010) or identify physicians’ specialties based on prescription data (Shirazi
    et al., 2020). Another application for community detection algorithms is to examine
    the network structure of scientific collaboration networks (Newman, 2001; Piedra
    et al., 2017).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 社区检测技术可以用来检测用户的不同部分，发现有共同兴趣的人，或在社区内推荐新的联系。假设你从社交网络中退一步。在这种情况下，你可以使用社区检测算法将具有相似角色的蛋白质分组（Pinkert等人，2010年）或根据处方数据识别医生的专业领域（Shirazi等人，2020年）。社区检测算法的另一个应用是检查科学合作网络的网络结构（Newman，2001年；Piedra等人，2017年）。
- en: Now, think about what makes a node have influence over the network. There are
    a couple of procedures to determine whether a node is influential. The metrics
    used to identify important or influential nodes in the graph are called *centrality
    measures*, and the algorithms that calculate them are called *centrality algorithms*.
    For example, the most basic metric to determine a node’s importance is *degree
    centrality*, which simply counts the number of relationships a node has. The higher
    the count of relationships is, the more influential the node is in the network.
    Another example of node importance is to examine the amount of influence a node
    has over the flow of information in a network (figure 5.4).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们思考一下什么使一个节点对网络有影响力。有几个程序可以确定一个节点是否具有影响力。用于识别图中重要或具有影响力的节点的度量标准被称为*中心性度量*，而计算它们的算法被称为*中心性算法*。例如，确定一个节点重要性的最基本度量是*度中心性*，它简单地计算一个节点有多少关系。关系的数量越多，节点在网络中的影响力就越大。另一个节点重要性的例子是检查一个节点对网络中信息流的影响量（图5.4）。
- en: '![05-04](../../OEBPS/Images/05-04.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![05-04](../../OEBPS/Images/05-04.png)'
- en: Figure 5.4 Friendship network with node size corresponding to their influence
    over the information flow
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4展示了具有节点大小对应其信息流影响程度的友谊网络
- en: Figure 5.4 shows the same network as figure 5.3\. The only difference is that,
    now, the node size in the visualization corresponds to its influence over the
    information flow. Suppose the information can circulate only through friendship
    relationships. In that case, Ganesh is the most important node in the network,
    as he is the bridge between all three communities. Ganesh can be thought of as
    the gatekeeper of information between communities, allowing him to choose which
    data he wants to pass along and when. Another thing to note is that if Ganesh
    were removed from the network, it would be broken into three parts. The other
    two vital nodes are Ljubica and Jack, who connect their community with the rest
    of the network.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4显示了与图5.3相同的网络。唯一的区别是，现在可视化中的节点大小对应于其对信息流的影响力。假设信息只能通过友谊关系流通。在这种情况下，Ganesh是网络中最重要的节点，因为他连接了所有三个社区。Ganesh可以被看作是社区之间信息守门人，允许他选择想要传递的数据以及何时传递。还有一点需要注意，如果Ganesh从网络中移除，它将分成三个部分。其他两个关键节点是Ljubica和Jack，他们连接他们的社区与网络的其余部分。
- en: In the last part of this chapter, you will take advantage of centrality algorithms
    to find the most important or influential users. There are multiple variations
    of node influence measures. To calculate the influence over the information flow
    in the network you can use *betweenness centrality*. As mentioned, it has various
    applications in social network analysis, but it can also be used to predict congestions
    in a road network (Kirkley et al., 2018). The most famous node centrality algorithm
    is probably *PageRank*, which was developed to rank websites and use the ranking
    information to produce better search results (Brin & Page, 1998). The beauty of
    the PageRank algorithm is that it can be applied to other domains. For example,
    it has been used to rank research paper authors based on citations (Ying Ding
    et al., 2010). I’ve also found one example where PageRank is applied to evaluate
    user reputation on YouTube (Hanm Yo-Sub et al., 2009). Finally, it can also be
    utilized to analyze protein interaction networks (Iván & Grolmusz, 2011).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，你将利用中心性算法来寻找最重要或最具影响力的用户。节点影响力度量有多种变体。为了计算网络中信息流的影响力，你可以使用*介数中心性*。如前所述，它在社交网络分析中有多种应用，但也可以用来预测道路网络中的拥堵（Kirkley等人，2018年）。最著名的节点中心性算法可能是*PageRank*，它被开发出来用于对网站进行排名，并使用排名信息来产生更好的搜索结果（Brin
    & Page，1998年）。PageRank算法的美丽之处在于它可以应用于其他领域。例如，它已经被用来根据引用来对研究论文作者进行排名（Ying Ding等人，2010年）。我还发现了一个例子，其中PageRank被用来评估YouTube上的用户声誉（Hanm
    Yo-Sub等人，2009年）。最后，它还可以用来分析蛋白质相互作用网络（Iván & Grolmusz，2011年）。
- en: Now, we will complete some practical examples to learn how to utilize Cypher
    query language and graph algorithms to characterize and evaluate the community
    structure of the Twitter followers network, followed by identifying the most influential
    nodes. To follow along with the examples in this chapter, you must have a Neo4j
    database instance with Twitter network data imported, as described in chapter
    3\.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将完成一些实际例子，以学习如何利用Cypher查询语言和图算法来描述和评估Twitter关注者网络的社区结构，并随后识别最具影响力的节点。为了跟随本章中的示例，你必须拥有一个Neo4j数据库实例，并已按照第3章所述导入Twitter网络数据。
- en: 5.1.1 Node degree distribution
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.1 节点度分布
- en: One of the fundamental characteristics of a network is the node degree distribution.
    With a directed network, you can split the degree distribution into *in-degree*
    and *out-degree* distribution. The node in-degree counts the number of incoming
    relationships, and the out-degree counts the number of outgoing connections per
    node.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 网络的一个基本特征是节点度分布。在有向网络中，你可以将度分布分为*入度*和*出度*分布。节点入度计算进入关系的数量，而出度计算每个节点的输出连接数量。
- en: First, you will examine the out-degree distribution of the followers network.
    If you want to evaluate any distribution quickly in Neo4j Browser, you can use
    the `apoc.agg .statistics` function from the Awesome Procedures on Cypher (APOC)
    library.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将检查关注者网络的出度分布。如果你想在Neo4j浏览器中快速评估任何分布，你可以使用来自Awesome Procedures on Cypher（APOC）库的`apoc.agg.statistics`函数。
- en: Note The APOC library contains around 450 procedures and functions to help you
    with various tasks, ranging from data integration to batching and more. While
    it is not automatically incorporated with Neo4j, I recommend you include it in
    all your Neo4j projects. You can check out the official documentation to get a
    sense of all the procedures it features at [https://neo4j.com/docs/apoc/current/](https://neo4j.com/docs/apoc/current/).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：APOC 库包含约 450 个过程和函数，可以帮助你完成各种任务，从数据集成到批处理等。虽然它不是自动与 Neo4j 集成，但我建议你在所有 Neo4j
    项目中都包含它。你可以查看官方文档，了解它所提供的所有过程，网址为 [https://neo4j.com/docs/apoc/current/](https://neo4j.com/docs/apoc/current/)。
- en: The `apoc.agg.statistics` function returns statistical values, such as mean,
    max, and percentile values of given values. Since you are only counting the number
    of relationships per node, you simplify the query by using the `count` `{}` function.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`apoc.agg.statistics` 函数返回统计值，如平均值、最大值和给定值的百分位数。由于你只计算每个节点的连接数，因此你可以通过使用 `count`
    `{}` 函数简化查询。'
- en: Listing 5.1 Evaluating the node out-degree distribution with the `apoc.agg.statistics`
    function
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.1 使用 `apoc.agg.statistics` 函数评估节点出度分布
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Table 5.1 shows the final distribution.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.1 显示了最终的分布。
- en: Table 5.1 Out-degree distribution of the followers network
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.1 随机网络出度分布
- en: '| `total` | 3,594 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `total` | 3,594 |'
- en: '| `min` | 0 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `min` | 0 |'
- en: '| `minNonZero` | 1.0 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `minNonZero` | 1.0 |'
- en: '| `max` | 143 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `max` | 143 |'
- en: '| `mean` | 6.924874791318865 |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `mean` | 6.924874791318865 |'
- en: '| `0.5` | 2 |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `0.5` | 2 |'
- en: '| `0.99` | 57 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `0.99` | 57 |'
- en: '| `0.75` | 8 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `0.75` | 8 |'
- en: '| `0.9` | 21 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `0.9` | 21 |'
- en: '| `0.95` | 32 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `0.95` | 32 |'
- en: '| `stdev` | 11.94885358058576 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `stdev` | 11.94885358058576 |'
- en: There are 3,594 samples or nodes in the distribution. User nodes have, on average,
    around seven outgoing relationships. The `0.5` key represents the 50th percentile
    value, the `0.9` key represents the 90th percentile value, and so on. While the
    average value of outgoing relationships is almost 7, the median value is only
    2, which indicates that 50% of nodes have two or fewer outgoing connections. Around
    10% of users have more than 21 outgoing relationships.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 分布中有 3,594 个样本或节点。用户节点平均有大约七个出度关系。`0.5` 键代表第 50 个百分位数，`0.9` 键代表第 90 个百分位数，依此类推。虽然出度关系的平均值接近
    7，但中位数仅为 2，这表明 50% 的节点有两个或更少的出度连接。大约 10% 的用户有超过 21 个出度连接。
- en: You can always draw a histogram of out-degree distribution in your favorite
    visualization library if you are more visually oriented, like me. Figure 5.5 shows
    an example.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更倾向于视觉化，你可以像我一樣，在你的可视化库中绘制出度分布的直方图。图 5.5 展示了一个示例。
- en: '![05-05](../../OEBPS/Images/05-05.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![05-05](../../OEBPS/Images/05-05.png)'
- en: Figure 5.5 Out-degree distribution chart visualized with a seaborn histogram
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 使用 seaborn 直方图可视化的出度分布图
- en: Visualizing charts is beyond the scope of this chapter, so I won’t go into details
    of how I produced figure 5.5\. However, Jupyter notebooks for chapters 9 and 10
    contain code that draws histograms with the seaborn library in Python.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化图表超出了本章的范围，因此我不会详细介绍我是如何生成图 5.5 的。然而，第 9 章和第 10 章的 Jupyter 笔记本中包含使用 Python
    seaborn 库绘制直方图的代码。
- en: Interestingly, even a small subgraph of the Twitter network follows the power-law
    distribution, which is typical for real-world networks. I have limited the bin
    range to visualize only nodes with an out-degree of 60 or less, for chart readability.
    More than 1,000 nodes have zero outgoing connections, and most nodes have fewer
    than 10 links. You have previously observed that the highest out-degree is 143,
    and only 5% of nodes have the out-degree of greater than 32\.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，即使是 Twitter 网络的一个小子图也遵循幂律分布，这是现实世界网络的典型特征。为了使图表易于阅读，我已将箱范围限制在只有出度为 60 或更少的节点。超过
    1,000 个节点没有出度连接，大多数节点的链接数少于 10。你之前观察到最高的出度为 143，只有 5% 的节点的出度大于 32。
- en: Exercise 5.1
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 5.1
- en: Fetch the top five users with the highest out-degree. Use the `count` `{}` operator.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 获取出度最高的前五个用户。使用 `count` `{}` 操作符。
- en: Now, you will repeat the same process to evaluate the in-degree distribution.
    First, you will use the `apoc.agg.statistics` function to evaluate the in-degree
    distribution in Neo4j Browser, as shown in listing 5.2.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将重复相同的步骤来评估入度分布。首先，你将使用 `apoc.agg.statistics` 函数在 Neo4j 浏览器中评估入度分布，如列表 5.2
    所示。
- en: Listing 5.2 Evaluating the node out-degree distribution with the `apoc.agg.statistics`
    function
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.2 使用 `apoc.agg.statistics` 函数评估节点出度分布
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Table 5.2 shows the final distribution.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.2 显示了最终的分布。
- en: Table 5.2 Out-degree distribution of the followers network
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.2 关注者网络的出度分布
- en: '| `total` | 3594 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `total` | 3594 |'
- en: '| `min` | 0 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `min` | 0 |'
- en: '| `minNonZero` | 1.0 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `minNonZero` | 1.0 |'
- en: '| `max` | 540 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `max` | 540 |'
- en: '| `mean` | 6.924874791318865 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `mean` | 6.924874791318865 |'
- en: '| `0.5` | 0 |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `0.5` | 0 |'
- en: '| `0.99` | 112 |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `0.99` | 112 |'
- en: '| `0.75` | 4 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `0.75` | 4 |'
- en: '| `0.9` | 16 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `0.9` | 16 |'
- en: '| `0.95` | 35 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `0.95` | 35 |'
- en: '| `stdev` | 22.7640611678852 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `stdev` | 22.7640611678852 |'
- en: What immediately caught my eye is that the mean value is identical for out-
    and in-degree. This might make sense to you, as the total count of nodes and relationships
    is identical, so the mean values should be the same. More than half of the users
    have no incoming connections. While I have scraped the Twitter API for the follower
    relationships of all users, I have only included relationships between users who
    have either posted or were mentioned in the 12,000 scraped tweets. It looks like
    around half of the users don’t have any followers included in this subgraph. One
    outlier has 540 incoming relationships (followers count), meaning one in seven
    users follow them.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 立刻吸引我注意的就是出度和入度的平均值是相同的。这可能对你来说是有道理的，因为节点和关系的总数是相同的，所以平均值应该相同。超过一半的用户没有入站连接。虽然我已经抓取了所有用户的Twitter
    API关注者关系，但我只包括在12,000条抓取推文中发布或被提及的用户之间的关系。看起来大约一半的用户在这个子图中没有任何关注者。有一个异常值有540个入站关系（关注者数量），这意味着七分之一的用户关注他们。
- en: Again, I’ll show the in-degree distribution with the seaborn library (figure
    5.6). Though I did not aim to get the power-law distribution of node in- and out-degrees,
    most real-world networks tend to exhibit such a distribution. However, when dealing
    with smaller subsets of a graph, the node degree distribution is highly dependent
    on the sampling method used to retrieve the dataset. As the data sample grows,
    its node degree distribution will increasingly resemble the overall graph degree
    distribution (figure 5.6).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我将使用seaborn库展示入度分布（图5.6）。尽管我没有旨在获取节点入度和出度的幂律分布，但大多数现实世界的网络往往表现出这种分布。然而，当处理图的小子集时，节点度分布高度依赖于用于检索数据集的采样方法。随着数据样本的增长，其节点度分布将越来越接近整体图度分布（图5.6）。
- en: '![05-06](../../OEBPS/Images/05-06.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![05-06](../../OEBPS/Images/05-06.png)'
- en: Figure 5.6 In-degree distribution chart visualized with a seaborn histogram
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 使用seaborn直方图可视化的入度分布图
- en: Exercise 5.2
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 练习5.2
- en: Fetch the top five users with the highest in-degree (follower count). Use the
    `count` `{}` operator.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 获取具有最高入度（关注者数量）的前五名用户。使用`count` `{}`运算符。
- en: The solution to exercise 5.2 produces the output shown in table 5.3.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 练习5.2的解决方案生成了表5.3所示的输出。
- en: Table 5.3 Top five users with the highest in-degree
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.3 具有最高入度的前五名用户
- en: '| `user` | `inDegree` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `user` | `inDegree` |'
- en: '| "elonmusk" | 540 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| "elonmusk" | 540 |'
- en: '| "AndrewYNg" | 301 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| "AndrewYNg" | 301 |'
- en: '| "NASA" | 267 |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| "NASA" | 267 |'
- en: '| "OpenAI" | 265 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| "OpenAI" | 265 |'
- en: '| "GoogleAI" | 264 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| "GoogleAI" | 264 |'
- en: The highest in-degree users are pretty interesting. Elon Musk takes the crown.
    It seems that he is popular within the tech community, or at least in the given
    Twitter subgraph. In second place is none other than Andrew Ng. If you have dabbled
    with any machine learning, you have probably heard of him, as he is one of the
    most famous machine learning instructors.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 具有最高入度的用户非常有趣。Elon Musk位居榜首。看起来他在科技社区很受欢迎，或者至少在给定的Twitter子图中是这样。第二名是Andrew Ng。如果你接触过任何机器学习，你可能听说过他，因为他是最著名的机器学习讲师之一。
- en: Exercise 5.3
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 练习5.3
- en: Remember, I’ve only included users who either published a tweet or were mentioned
    in one. Pick one of the top five users with the highest in-degree and examine
    the tweets they published or were mentioned in.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我只包括发布推文或被提及的用户。选择具有最高入度的前五名用户之一，并检查他们发布的推文或被提及的推文。
- en: The solution Cypher statement to exercise 5.3 is shown in listing 5.3\.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 练习5.3的解决方案Cypher语句显示在列表5.3中。
- en: Listing 5.3 Examining mentions and published posts for NASA
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.3 检查NASA的提及和发布的帖子
- en: '[PRE2]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: I’ve chosen to explore NASA’s Twitter account. Note that I have used the `OPTIONAL`
    `MATCH`, as I don’t know beforehand if NASA both published a tweet and was mentioned
    in one. Again, you could use a couple of variations of the Cypher statement to
    produce the same results, so don’t worry if you got correct results but used a
    slightly different Cypher statement. The Cypher statement in listing 5.3 will
    produce the visualization shown in figure 5.7 in Neo4j Browser. NASA has published
    a single tweet and was mentioned in two other tweets in our dataset.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择探索NASA的Twitter账户。请注意，我使用了`OPTIONAL` `MATCH`，因为我事先不知道NASA是否发布了一条推文并被提及。再次强调，你可以使用Cypher语句的几个变体来产生相同的结果，所以如果你得到了正确的结果但使用了稍微不同的Cypher语句，请不要担心。列表5.3中的Cypher语句将在Neo4j浏览器中产生图5.7所示的可视化。在我们的数据集中，NASA发布了一条推文，并被提及在两条其他推文中。
- en: '![05-07](../../OEBPS/Images/05-07.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![05-07](../../OEBPS/Images/05-07.png)'
- en: Figure 5.7 Network visualization of tweets published by or mentioning NASA
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 发布或提及NASA的推文网络可视化
- en: 5.2 Introduction to the Neo4j Graph Data Science library
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 Neo4j图数据科学库简介
- en: Before continuing with network characterization, you should get familiar with
    the Neo4j Graph Data Science library (GDS). The GDS is a plugin for Neo4j that
    features more than 50 graph algorithms, ranging from community detection and centrality
    to node-embedding algorithms and link prediction pipelines—and more. You can get
    an overview of all available graph algorithms in the official documentation ([https://neo4j.com/docs/graph-data-science/current/](https://neo4j.com/docs/graph-data-science/current/)).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续进行网络特征化之前，你应该熟悉Neo4j图数据科学库（GDS）。GDS是Neo4j的一个插件，它包含超过50个图算法，从社区检测和中心性到节点嵌入算法和链接预测管道，以及更多。你可以在官方文档中找到所有可用图算法的概述（[https://neo4j.com/docs/graph-data-science/current/](https://neo4j.com/docs/graph-data-science/current/))。
- en: Graph algorithms in the GDS library are executed on a *projected in-memory graph*
    structure separate from the graph stored in the database (figure 5.8). To execute
    graph algorithms with the GDS library, you must first project an in-memory graph.
    The projected graph is stored entirely in-memory, using an optimized data structure
    for scalable and parallel graph algorithm execution. You can create a projected
    in-memory graph using either *native projection* or *Cypher projection*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: GDS库中的图算法是在一个与数据库中存储的图结构分开的*投影内存图*结构上执行的（图5.8）。要使用GDS库执行图算法，你必须首先投影一个内存图。投影图完全存储在内存中，使用优化的数据结构以实现可扩展和并行图算法执行。你可以使用*原生投影*或*Cypher投影*来创建一个投影内存图。
- en: '![05-08](../../OEBPS/Images/05-08.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![05-08](../../OEBPS/Images/05-08.png)'
- en: Figure 5.8 Graph Data Science library workflow
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 图数据科学库工作流程
- en: Native projection is a bit more limited in selecting or filtering a specific
    subgraph you want to project, as you can only filter based on node labels and
    relationship types. However, it is the recommended way of projecting a graph as
    it is highly performant due to reading data directly from Neo4j storage.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 原生投影在选择或过滤你想要投影的特定子图方面有限制，因为你只能根据节点标签和关系类型进行过滤。然而，它是推荐的方式来投影一个图，因为它由于直接从Neo4j存储中读取数据而具有高性能。
- en: The second available option for creating an in-memory graph is the Cypher projection.
    With it, you get all the flexibility of Cypher query language to select or filter
    any specific subgraph you might want to project. Of course, Cypher projection
    has a drawback, as it is slower than native projection and generally recommended
    only for the experimental or explorational phase of a project.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 创建内存图的第二种可用选项是Cypher投影。使用它，你将获得Cypher查询语言的全部灵活性来选择或过滤任何你想要投影的特定子图。当然，Cypher投影有一个缺点，即它比原生投影慢，通常只推荐用于项目的实验或探索阶段。
- en: As the in-memory graph projection can be costly when dealing with large graphs,
    the GDS library also features a *graph catalog*. The graph catalog comes in handy
    when you want to execute multiple graph algorithms on the same projected graph.
    Instead of having to create an in-memory graph for each algorithm execution separately,
    you can create an in-memory graph once and then execute multiple graph algorithms
    on it. The projected graph can then be accessed via its name when executing graph
    algorithms, so the term *named graph* stuck with projected graphs stored in a
    graph catalog. Once the in-memory graph is created, you can execute graph algorithms
    on top of it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在处理大型图时，内存图投影可能成本较高，因此 GDS 库还提供了一种 *图目录* 功能。当您想要在同一个投影图上执行多个图算法时，图目录就派上用场了。您不需要为每个算法执行单独创建内存图，而是一次创建一个内存图，然后在该图上执行多个图算法。投影图可以通过其名称在执行图算法时访问，因此术语
    *命名图* 就与存储在图目录中的投影图相关联。一旦创建了内存图，您就可以在其上执行图算法。
- en: 'Each algorithm has four modes of execution, depending on the use case:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 每个算法都有四种执行模式，具体取决于用例：
- en: '`stream`—Returns results as a stream of records and does not store results.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stream`—以记录流的形式返回结果，但不存储结果。'
- en: '`stats`—Returns a summary statistics of the result and does not store results.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stats`—返回结果的摘要统计信息，但不存储结果。'
- en: '`mutate`—Writes the results back to the projected in-memory graph. This mode
    can only be used in combination with a named graph stored in a graph catalog.
    It is very useful when you want to use an output of one graph algorithm as an
    input to another.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mutate`—将结果写回投影的内存图。此模式只能与存储在图目录中的命名图结合使用。当您想将一个图算法的输出用作另一个图算法的输入时，这非常有用。'
- en: '`write`—Writes the results back to the Neo4j database graph.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`write`—将结果写回 Neo4j 数据库图。'
- en: 5.2.1 Graph catalog and native projection
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.1 图目录和本地投影
- en: Let’s begin by reviewing a few examples covering network characterization and
    the GDS syntax and algorithm use cases. First off, you need to project an in-memory
    graph. You will use native projection to create an in-memory graph that consists
    of `User` nodes and `FOLLOWS` relationships. The native projection syntax is shown
    in the following listing.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从回顾一些涵盖网络特征化和 GDS 语法及算法用例的示例开始。首先，您需要投影一个内存图。您将使用本地投影来创建一个包含 `User` 节点和 `FOLLOWS`
    关系的内存图。本地投影语法如下所示。
- en: Listing 5.4 Native projection syntax to create a named graph in the graph catalog
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.4 在图目录中创建命名图的本地投影语法
- en: '[PRE3]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: GDS procedures are executed using the `CALL` clause in combination with the
    procedure name. The procedure to store a named graph in the graph catalog with
    native projection is called `gds.graph.project()`. It contains three mandatory
    and one optional parameter. The first parameter is used to name the graph, under
    which it will be accessed when executing graph algorithms. The second parameter,
    called `nodeProjection`, defines the subset of nodes you want to project. Similarly,
    the `relationshipProjection` parameter specifies which relationships should be
    considered when creating an in-memory graph. An important thing to note is that
    a relationship will be skipped during projection if both adjacent nodes are not
    described in the `nodeProjection` parameter. In GDS terms, the starting node of
    the relationship is called the *source node* and the end node is called the *target
    node*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `CALL` 子句与过程名称结合执行 GDS 程序。使用本地投影将命名图存储在图目录中的过程称为 `gds.graph.project()`。它包含三个必填参数和一个可选参数。第一个参数用于命名图，在执行图算法时将通过该名称访问。第二个参数，称为
    `nodeProjection`，定义了您想要投影的节点子集。同样，`relationshipProjection` 参数指定在创建内存图时应考虑哪些关系。需要注意的是，如果相邻节点在
    `nodeProjection` 参数中未描述，则关系将在投影期间被跳过。在 GDS 术语中，关系的前一个节点称为 *源节点*，后一个节点称为 *目标节点*。
- en: To project the followers network, you need to only include `User` nodes and
    `FOLLOWS` relationships, with no additional configuration. The Cypher statement
    in listing 5.5 uses native projection to store an in-memory graph. The first parameter
    specifies its name, which will be used to access it when executing graph algorithms.
    The second parameter defines which nodes you want to include in the projection.
    When you only want to project a single type of node, you can define the desired
    node label as a string. Similarly, when you only want to project one type of relationship
    in the third parameter, you can specify the type as a string.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要投影关注者网络，你只需要包括`User`节点和`FOLLOWS`关系，无需额外配置。列表5.5中的Cypher语句使用原生投影来存储内存中的图。第一个参数指定其名称，当执行图算法时将使用该名称来访问它。第二个参数定义了你想包含在投影中的节点。当你只想投影一种类型的节点时，你可以将所需的节点标签定义为字符串。同样，当你只想在第三个参数中投影一种类型的关系时，你可以指定类型为字符串。
- en: Listing 5.5 Projecting an in-memory graph consisting of `User` nodes and `FOLLOWS`
    relationships
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.5将内存中的由`User`节点和`FOLLOWS`关系组成的图进行投影
- en: '[PRE4]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In later chapters, you will learn more about native projection and how to create
    an in-memory graph consisting of multiple node labels and relationship types.
    The GDS library also supports projecting node and relationship properties, which
    is useful when dealing with weighted networks.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的章节中，你将了解更多关于原生投影以及如何创建由多个节点标签和关系类型组成的内存图。GDS库还支持投影节点和关系属性，这在处理加权网络时非常有用。
- en: 5.3 Network characterization
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 网络特征
- en: Next, you will use the GDS library to characterize the Twitter follower network.
    These network characterization metrics provide a holistic view of the network’s
    topology and can help in understanding the overall structure, efficiency of information
    flow, and level of interconnectedness among nodes in the network.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将使用GDS库来表征Twitter关注者网络。这些网络表征度量提供了对网络拓扑的全面视图，有助于理解整体结构、信息流效率以及网络中节点之间的互连程度。
- en: 5.3.1 Weakly connected component algorithm
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.1 弱连通分量算法
- en: The first graph algorithm you will execute is the *weakly connected component*
    (WCC) algorithm. A WCC is a set of nodes within the graph, where a path exists
    between all nodes in the set if the direction of relationships is ignored. A WCC
    can be considered an “island” that cannot be reached from other graph components.
    While the algorithm identifies connected sets of nodes, its output can help you
    evaluate how disconnected the overall graph is.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要执行的第一个图算法是*弱连通分量*（WCC）算法。WCC是图内的一组节点，如果忽略关系的方向，则该组内的所有节点之间都存在路径。WCC可以被认为是一个“岛屿”，无法从其他图组件中到达。虽然该算法识别了节点集的连通集，但其输出可以帮助你评估整体图的连通性程度。
- en: Starting any graph analysis with a WCC algorithm is beneficial, as it offers
    an overview of the graph’s structure, including connectivity and isolated parts.
    By identifying these disparate sections, you can concentrate further analysis
    on the most relevant components, simplifying the computational cost. Understanding
    the connectivity and how connected the overall graph is sets the stage for more
    detailed investigations, such as community detection or centrality analysis.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以WCC算法开始任何图分析是有益的，因为它提供了对图结构的概述，包括连通性和孤立部分。通过识别这些不同的部分，你可以将进一步的分析集中在最相关的组件上，从而简化计算成本。了解连通性和整体图的连通性为更详细的调查奠定了基础，例如社区检测或中心性分析。
- en: The WCC algorithm is probably a graph algorithm that should be executed as the
    first step of any graph analysis to evaluate graph connectivity. Figure 5.9 shows
    two WCCs. One component contains John, Alicia, and Amulya, and the other contains
    OpenAI, Google AI, NASA, and Andrew Ng.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: WCC算法可能是一种图算法，应该在任何图分析的第一步执行，以评估图的连通性。图5.9显示了两个WCC。一个组件包含John、Alicia和Amulya，另一个包含OpenAI、Google
    AI、NASA和Andrew Ng。
- en: '![05-09](../../OEBPS/Images/05-09.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![05-09](../../OEBPS/Images/05-09.png)'
- en: Figure 5.9 Network visualization of two WCCs
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9两个WCC的网络可视化
- en: Nodes within a single WCC can reach all the other nodes if you ignore the relationship
    direction. For example, John can reach Alicia, even though the relationship is
    pointed in the other direction. Effectively, you could say the relationships are
    treated as undirected. The algorithm treats all nodes within the same community
    as being able to reach each other if a path exists between them, irrespective
    of the relationship’s direction.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果忽略关系方向，单个WCC内的节点可以到达所有其他节点。例如，John可以到达Alicia，即使关系方向相反。实际上，可以说关系被当作无向处理。算法将同一社区内的所有节点视为如果它们之间存在路径，则可以相互到达，而不考虑关系的方向。
- en: You will execute the WCC algorithm using the `write` mode. As mentioned, the
    `write` mode stores the results back to the Neo4j database but also provides summary
    statistics of the algorithm result. The syntax for graph algorithm procedures
    in GDS is shown in the following listing.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用`write`模式执行WCC算法。如前所述，`write`模式将结果存储回Neo4j数据库，同时也提供了算法结果的摘要统计信息。GDS中图算法过程的语法在以下列表中显示。
- en: Listing 5.6 Graph algorithm procedure syntax
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.6图算法过程语法
- en: '[PRE5]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When using the `write` mode of an algorithm, you need to provide the mandatory
    `writeProperty` parameter, which specifies the name of the node property the algorithm
    results will be stored to. The procedure to execute the WCC algorithm is `gds.wcc`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用算法的`write`模式时，你需要提供强制性的`writeProperty`参数，该参数指定了算法结果将存储到的节点属性名称。执行WCC算法的过程是`gds.wcc`。
- en: You can execute the WCC algorithm on the followers network and store the results
    to Neo4j by using the Cypher statement in the following listing.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下列表中的Cypher语句在跟随者网络上执行WCC算法并将结果存储到Neo4j。
- en: Listing 5.7 Executing the WCC algorithm on the follower network and storing
    the results as a `followerWcc` node property
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.7在跟随者网络中执行WCC算法并将结果存储为`followerWcc`节点属性
- en: '[PRE6]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Table 5.4 shows the resulting statistics.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.4显示了结果统计信息。
- en: Table 5.4 Summary statistics for the WCC algorithm executed on the followers
    network
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.4在跟随者网络上执行WCC算法的摘要统计信息
- en: '| `componentCount` | `componentDistribution` |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `componentCount` | `componentDistribution` |'
- en: '| 547 | { "p99":”3,"min":”1,"max":”2997,"mean":”6.570383912248629,"p90":”1,"p50":”1,"p999":”5,"p95":”2,"p75":”1
    } |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 547 | { "p99":”3","min":”1","max":”2997","mean":”6.570383912248629","p90":”1","p50":”1","p999":”5","p95":”2","p75":”1”
    } |'
- en: The `write` mode of the algorithm stores the results to the Neo4j database and
    provides the summary statistics shown in table 5.4\. The node property that contains
    the algorithm results identifies the component ID to which the node belongs.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的`write`模式将结果存储到Neo4j数据库，并提供表5.4中所示的摘要统计信息。包含算法结果的节点属性标识了节点所属的组件ID。
- en: There are 547 disconnected components in the followers network, and the largest
    contains 2,997 members. Most real-world networks have a single connected component
    containing most of the nodes in the network and a couple of disconnected peripheral
    components. As the dataset you are analyzing is only a portion of a larger network,
    having a higher count of components is not unusual, due to many missing users
    and relationships that would otherwise connect various parts of the network if
    they were included. I’ve found one analysis on the Twitter network (Myers et al.,
    2014) where the authors analyzed a snapshot of the Twitter network from 2012 with
    175 million users and 20 billion follow relationships. The analysis revealed that
    around 93% of the users belong in the largest WCC. Another analysis examined the
    Facebook graph (Ugander et al., 2011), where they learned that the largest WCC
    contains more than 99% of all nodes.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 跟随者网络中有547个不连通的组件，其中最大的包含2,997个成员。大多数现实世界的网络都有一个包含网络中大多数节点的单个连通组件和一些不连通的边缘组件。由于你正在分析的只是更大网络的一部分，组件数量较多并不罕见，因为许多缺失的用户和关系如果包含在内，本应连接网络的各个部分。我发现了一项关于Twitter网络的（Myers等人，2014）分析，其中作者分析了2012年Twitter网络的快照，包含1.75亿用户和200亿个关注关系。分析显示，大约93%的用户属于最大的WCC。另一项分析检查了Facebook图（Ugander等人，2011），他们发现最大的WCC包含所有节点的99%以上。
- en: The `p90` result, or the 90th percentile of the component size, has a value
    of 1, which indicates that 90% of the components have only a single member. When
    a component contains only a single member, this means the node has no relationships.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`p90`结果，或组件大小的第90百分位数，其值为1，表示90%的组件只有一个成员。当一个组件只有一个成员时，这意味着该节点没有关系。'
- en: Exercise 5.4
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 练习5.4
- en: Count the number of members for the five largest WCCs. The component IDs are
    stored under the `followerWcc` property of the `User` nodes. Use the `followerWcc`
    property as a grouping key in combination with the `count()` function to count
    the number of members by component.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 计算五个最大WCC的成员数量。组件ID存储在`User`节点的`followerWcc`属性下。使用`followerWcc`属性作为分组键，结合`count()`函数来按组件计算成员数量。
- en: The solution to exercise 5.4 produces the output shown in table 5.5.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 练习5.4的解决方案产生了表5.5所示的输出。
- en: Table 5.5 Member count of the five largest WCCs
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.5 五个最大WCC的成员数量
- en: '| `componentId` | `countOfMembers` |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `componentId` | `countOfMembers` |'
- en: '| 0 | 2997 |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 2997 |'
- en: '| 1293 | 5 |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 1293 | 5 |'
- en: '| 1049 | 3 |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 1049 | 3 |'
- en: '| 269 | 3 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 269 | 3 |'
- en: '| 335 | 3 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 335 | 3 |'
- en: You can observe that there is a single component, which contains 85% of the
    nodes in the network. The component IDs are not deterministic, meaning you can
    get different values for the component IDs. However, the component member distribution
    should be identical.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以观察到存在一个单独的组件，它包含网络中85%的节点。组件ID不是确定的，这意味着您可以为组件ID得到不同的值。然而，组件成员分布应该是相同的。
- en: The second-largest component contains only five members. You can visualize the
    second-largest component in Neo4j Browser with the Cypher statement in the following
    listing (see also figure 5.10). If you have different component IDs, make sure
    to change the component ID in the `WHERE` clause.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 第二大的组件只包含五个成员。您可以使用以下列表中的Cypher语句在Neo4j浏览器中可视化第二大的组件（也请参阅图5.10）。如果您有不同的组件ID，请确保在`WHERE`子句中更改组件ID。
- en: '![05-10](../../OEBPS/Images/05-10.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![05-10](../../OEBPS/Images/05-10.png)'
- en: Figure 5.10 Network visualization of the second-largest WCC in the follower
    network
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10关注网络中第二大的WCC的网络可视化
- en: Listing 5.8 Retrieving `User` nodes that have no outgoing `FOLLOWS` relationships
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.8检索没有传出`FOLLOWS`关系的`User`节点
- en: '[PRE7]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: I’ve inspected the usernames shown in figure 5.10 on Twitter, and it seems they
    are some professors from Singapore and Kyoto universities. They follow each other
    but don’t have any connections to the rest of the network in our small Twitter
    snapshot.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经检查了图5.10中显示的用户名在Twitter上的情况，他们似乎是新加坡和京都大学的几位教授。他们相互关注，但与我们小型Twitter快照中的其他网络没有连接。
- en: Exercise 5.5
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 练习5.5
- en: Identify the number of WCCs that contain only one member. Remember, if a WCC
    contains only a single member, this effectively means that node has no incoming
    or outgoing relationships. Instead of using the `followerWcc` property to count
    those components, you can simply filter the `User` nodes with no `FOLLOWS` relationships
    and count them. The count will be identical to the number of WCCs with a single
    member.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 确定只包含一个成员的WCC数量。记住，如果一个WCC只包含一个成员，这实际上意味着该节点没有传入或传出的关系。与其使用`followerWcc`属性来计数这些组件，您可以直接过滤没有`FOLLOWS`关系的`User`节点并计数。计数将与只有一个成员的WCC数量相同。
- en: 5.3.2 Strongly connected components algorithm
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.2 强连通分量算法
- en: A *strongly connected component* (SCC) is a subgraph of a directed graph in
    which a path exists between all its nodes. The only difference between the WCC
    and SCC algorithms is that the SCC algorithm considers relationship directions.
    Therefore, the SCC algorithm is only applicable to a directed graph. If the relationship
    direction is ignored, then you are dealing with WCCs.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*强连通分量*（SCC）是有向图中所有节点之间都存在路径的子图。WCC算法和SCC算法之间的唯一区别是SCC算法考虑关系方向。因此，SCC算法仅适用于有向图。如果忽略关系方向，那么您正在处理WCC。'
- en: Figure 5.11 shows four SCCs. The first component contains NASA, Andrew Ng, and
    Google AI. You can notice that although OpenAI can reach all the nodes in the
    first component, the path from Google AI to OpenAI is not possible, as the SCC
    algorithm does not ignore the relationship direction. Similarly, Amulya in the
    third component can be reached by Alicia and John, but a directed path from Amulya
    to either John or Alicia does not exist.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.11显示了四个SCC。第一个组件包含NASA、Andrew Ng和Google AI。您会注意到，尽管OpenAI可以到达第一个组件中的所有节点，但Google
    AI到OpenAI的路径是不可能的，因为SCC算法不会忽略关系方向。同样，第三组件中的Amulya可以通过Alicia和John到达，但从Amulya到John或Alicia的定向路径不存在。
- en: '![05-11](../../OEBPS/Images/05-11.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![05-11](../../OEBPS/Images/05-11.png)'
- en: Figure 5.11 Network visualization of four SCCs
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.11四个SCC的网络可视化
- en: The SCC algorithm is useful when directed paths and reachability play an important
    role. For example, imagine a road network where the nodes represent intersections
    and relationships represent road connections. For example, many large city centers
    have a lot of one-way road connections. Using the SCC algorithm, you could evaluate
    the consequences of closing one or several road connections and how it would affect
    the reachability of places within the city.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: SCC 算法在有向路径和可达性起重要作用时很有用。例如，想象一个道路网络，其中节点代表交叉口，关系代表道路连接。例如，许多大城市中心有很多单向道路连接。使用
    SCC 算法，你可以评估关闭一个或多个道路连接的后果以及它会如何影响城市内地点的可达性。
- en: Figure 5.12 visualizes a toy road network, where the nodes represent intersections
    and the relationships between them represent the road connections. For example,
    nodes A and B are connected in both directions, while the link between B and E
    connects one way. Using the SCC algorithm, you can evaluate the reachability of
    nodes if a particular road is closed. For example, if the road between intersections
    D and C were to be closed due to maintenance, there would be no way to get from
    the right side of the network to the left. Specifically, you couldn’t get from
    nodes D, E, F, or G to nodes A, B, or C. Therefore, nodes A, B, and C would form
    the first SCC, while D, E, F, and G form the second.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12 可视化了一个玩具道路网络，其中节点代表交叉口，它们之间的关系代表道路连接。例如，节点 A 和 B 两个方向都相连，而 B 和 E 之间的链接是单向的。使用
    SCC 算法，你可以评估如果关闭特定的道路，节点的可达性。例如，如果由于维护而关闭交叉口 D 和 C 之间的道路，就无法从网络的右侧到达左侧。具体来说，你无法从节点
    D、E、F 或 G 到达节点 A、B 或 C。因此，节点 A、B 和 C 将形成第一个 SCC，而 D、E、F 和 G 将形成第二个。
- en: '![05-12](../../OEBPS/Images/05-12.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![05-12](../../OEBPS/Images/05-12.png)'
- en: Figure 5.12 An example SCC use case in a road network
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12 一个道路网络中的 SCC 用例示例
- en: In the context of Twitter, the SCC can be applied to identify smaller well-connected
    groups of nodes. One research paper (Swati et al., 2016) claims you could use
    the SCC algorithm to identify groups of users for more precise marketing targeting.
    Another article (Efstathiades, 2016) used the SCC algorithm to suggest a movement
    of the user only following popular users while not making many connections with
    other unpopular users. The result is an increased number of SCCs over time.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Twitter 的背景下，SCC 可以应用于识别更小的紧密连接的节点组。一篇研究论文（Swati 等人，2016）声称你可以使用 SCC 算法来识别用于更精确营销定位的用户组。另一篇文章（Efstathiades，2016）使用
    SCC 算法建议用户只跟随受欢迎的用户，而不与其他不受欢迎的用户建立太多联系。结果是 SCC 数量随时间增加。
- en: Again, you will use the `write` mode of the algorithm to store the results back
    to the Neo4j database.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你将使用算法的 `write` 模式将结果存储回 Neo4j 数据库。
- en: Listing 5.9 Executing the SCC algorithm on the follower network and storing
    the results as a `followerScc` node property
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.9 在跟随者网络上执行 SCC 算法并将结果存储为 `followerScc` 节点属性
- en: '[PRE8]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Table 5.6 shows the resulting statistics.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.6 显示了生成的统计信息。
- en: Table 5.6 Summary statistics for the SCC algorithm executed on the followers
    network
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.6 在跟随者网络上执行 SCC 算法后的摘要统计信息
- en: '| `componentCount` | `componentDistribution` |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `componentCount` | `componentDistribution` |'
- en: '| 2704 | (cf{ "min": 1,"p5": 1,"max": 796,"p999": 7,"p99": 2,"p1": 1,"p10":
    1,"p90": 1,"p50": 1,"p25": 1,"p75": 1,"p95": 1,"mean": 1.3291420118343196 } |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 2704 | (cf{ "min": 1,"p5": 1,"max": 796,"p999": 7,"p99": 2,"p1": 1,"p10":
    1,"p90": 1,"p50": 1,"p25": 1,"p75": 1,"p95": 1,"mean": 1.3291420118343196 } |'
- en: As expected, the count of SCCs is higher than the count of WCCs. There are 2,704
    SCCs, and the largest one contains 796 members.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，SCC 的数量高于 WCC 的数量。有 2,704 个 SCC，最大的一个包含 796 个成员。
- en: Exercise 5.6
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 5.6
- en: Count the number of members for the five largest SCCs. The component IDs are
    stored under the `followerScc` property of the `User` nodes.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 计算五个最大 SCC 的成员数量。组件 ID 存储在 `User` 节点的 `followerScc` 属性下。
- en: The solution to exercise 5.6 produces the output shown in table 5.7.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 5.6 的解决方案生成了表 5.7 所示的输出。
- en: Table 5.7 Member count for the five largest SCCs
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.7 五个最大 SCC 的成员数量
- en: '| `componentId` | `countOfMembers` |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `componentId` | `countOfMembers` |'
- en: '| 0 | 796 |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 796 |'
- en: '| 380 | 20 |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 380 | 20 |'
- en: '| 407 | 7 |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 407 | 7 |'
- en: '| 36 | 6 |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 36 | 6 |'
- en: '| 212 | 4 |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 212 | 4 |'
- en: Similarly, as with the WCC algorithm, the community IDs are not deterministic.
    You could get different community IDs but should get the same counts.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 WCC 算法，社区 ID 不是确定的。你可能会得到不同的社区 ID，但应该得到相同的计数。
- en: Exercise 5.7
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 5.7
- en: Visualize the second-largest SCC in Neo4j Browser. A node can have relationships
    to nodes in other SCCs, so you have to apply a filter to ensure all the nodes
    are in the second-largest SCC.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在Neo4j浏览器中可视化第二大SCC。一个节点可以与其他SCC中的节点建立关系，因此你必须应用一个过滤器来确保所有节点都在第二大SCC中。
- en: The solution to exercise 5.4 produces the network visualization shown in figure
    5.13 in Neo4j Browser. You can observe that this community is tightly knit, as
    there are many connections between the nodes in the group. Judging by the usernames,
    it seems they all come from the same part of the world. Unfortunately, I am not
    a language expert, so I have no idea which part of the world it is.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 练习5.4的解决方案在Neo4j浏览器中显示了图5.13所示的网络可视化。你可以观察到这个社区非常紧密，因为组内节点之间存在许多连接。根据用户名判断，他们似乎都来自同一个地区。不幸的是，我不是语言专家，所以我不知道是哪个地区。
- en: '![05-13](../../OEBPS/Images/05-13.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![05-13](../../OEBPS/Images/05-13.png)'
- en: Figure 5.13 Network visualization of the second-largest SCC in the follower
    network
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.13是跟随网络中第二大强连通分量（SCC）的网络可视化。
- en: 5.3.3 Local clustering coefficient
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.3 局部聚类系数
- en: The *local clustering coefficient* (LCC) is a metric that quantifies how connected
    or close the neighbors of a particular node are. The LCC (figure 5.14) measures
    the average probability that two neighbors of a node are connected. Therefore,
    the value of the LCC ranges from 0 to 1\. The LCC value of 0 indicates that the
    neighboring nodes have no connections between each other. On the other hand, the
    LCC value of 1 indicates that the network of neighbors forms a complete graph,
    where all the neighbors are connected.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*局部聚类系数*（LCC）是一个衡量特定节点的邻居之间连接程度或接近程度的指标。LCC（图5.14）衡量的是节点两个邻居之间连接的平均概率。因此，LCC的值介于0到1之间。LCC值为0表示相邻节点之间没有连接。另一方面，LCC值为1表示邻居的网络形成一个完全图，其中所有邻居都相互连接。'
- en: '![05-14](../../OEBPS/Images/05-14.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![05-14](../../OEBPS/Images/05-14.png)'
- en: Figure 5.14 LCC values for an undirected graph
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.14 无向图的LCC值
- en: The LCC is more easily understood on an undirected graph. For example, in figure
    5.14, Stu has three neighbors. When none of those neighbors have any connections
    to other neighbors, the LCC value is 0\. Thus, Stu has the LCC value of 0 in the
    left example of figure 5.14\. In the middle example, Stu has the LCC value of
    1/3 or 0.33\. Stu has three neighbors, so combinatorially, there are three possible
    relationships between them. As there is only one connection between Stu’s neighbors
    in the middle example of figure 5.14, the LCC value for Stu is 1/3\. The right-hand
    side example has two connections between Stu’s neighbors; consequently, the LCC
    value for Stu is 2/3\. If another relationship was created between Jack and Amy,
    then all the neighbors of the Stu node would form a complete graph, which would
    change Stu’s LCC value to 1.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在无向图上，LCC更容易理解。例如，在图5.14中，Stu有三个邻居。当这些邻居中的任何一个都没有与其他邻居建立连接时，LCC值为0。因此，图5.14左边的例子中，Stu的LCC值为0。在中间的例子中，Stu的LCC值为1/3或0.33。Stu有三个邻居，所以从组合学的角度来看，他们之间有三种可能的关系。在图5.14中间的例子中，Stu的邻居之间只有一个连接；因此，Stu的LCC值为1/3。右侧的例子中，Stu的邻居之间有两个连接；因此，Stu的LCC值为2/3。如果Jack和Amy之间再建立另一个关系，那么Stu节点的所有邻居就会形成一个完全图，这将改变Stu的LCC值到1。
- en: The LCC algorithm provides a metric to evaluate how strongly the neighbors of
    a node are connected. You can calculate the LCC value of a single node by dividing
    the number of existing links between neighbor nodes with the number of possible
    links between neighbor nodes. You can use the formula in figure 5.15 to calculate
    the LCC on a directed graph as well.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: LCC算法提供了一个指标来评估节点邻居之间的连接强度。你可以通过将相邻节点之间现有链接的数量除以相邻节点之间可能链接的数量来计算单个节点的LCC值。你还可以使用图5.15中的公式来计算有向图上的LCC。
- en: With a directed graph, the first difference is that a node has a neighboring
    node if it has at least a single connection to it. Even though Stu has four connections
    in figure 5.15, they only have three distinct neighbors. A neighbor of a node
    can have one incoming or outgoing connection to the original node or both. Only
    the count of distinct neighbors is important with the LCC algorithm. With a directed
    graph, each pair of neighbors can have up to two relationships between them, so
    the total possible number of connections between three neighbors is six. Again,
    you only need to count the number of existing connections between neighbors and
    divide it by the number of possible connections.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有向图，第一个区别是，如果一个节点至少有一个连接到它，那么它就有相邻节点。尽管Stu在图5.15中有四个连接，但它们只有三个不同的邻居。一个节点的邻居可以有一个指向原始节点的入站或出站连接，或者两者都有。在有向图中，每一对邻居之间可以有最多两个关系，所以三个邻居之间的可能连接总数是六。再次强调，你只需要计算邻居之间的现有连接数量，并将其除以可能连接的数量。
- en: '![05-15](../../OEBPS/Images/05-15.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![05-15](../../OEBPS/Images/05-15.png)'
- en: Figure 5.15 LCC values for a directed graph
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.15 有向图的LCC值
- en: Unfortunately, the GDS library only supports the LCC algorithm for an undirected
    graph. However, as the directed LCC only counts the number of neighboring nodes
    and their links, you can easily implement the algorithm using only Cypher query
    language. Use the following Cypher statement to calculate the directed LCC value
    of each node, and store the results under the `lcc` node property.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，GDS库仅支持无向图的LCC算法。然而，由于有向LCC仅计算相邻节点及其链接的数量，你可以很容易地仅使用Cypher查询语言实现该算法。使用以下Cypher语句计算每个节点的有向LCC值，并将结果存储在`lcc`节点属性下。
- en: Listing 5.10 Calculating the LCC on the directed followers network
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.10 在有向跟随者网络中计算LCC
- en: '[PRE9]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Matches all User nodes
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 匹配所有用户节点
- en: ❷ Counts the number of their distinct neighbors
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 计算它们不同邻居的数量
- en: ❸ Counts the number of distinct links between neighbors
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 计算邻居之间不同链接的数量
- en: ❹ Calculates the LCC value
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 计算LCC值
- en: ❺ Stores the LCC value under the lcc node property
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在lcc节点属性下存储LCC值
- en: 'You should already be familiar with most of the Cypher syntax in listing 5.10\.
    You start by matching all the users in the database. Next, you count the number
    of distinct neighbors. As some `User` nodes don’t have any `FOLLOWS` relationships,
    you must use the `OPTIONAL` `MATCH` clause. Using the `MATCH` clause would reduce
    the cardinality and effectively filter out all the `User` nodes that don’t have
    any `FOLLOWS` relationships. If you remember from the WCCs example, there are
    around 500 `User` nodes that don’t have any `FOLLOWS` relationships. Another small
    detail is that the Cypher pattern in the `OPTIONAL` `MATCH` does not provide a
    relationship direction. You want to count the number of distinct neighbors, irrespective
    of whether they have incoming, outgoing, or both types of relationships to the
    original node. As some neighbors can have both incoming and outgoing connections
    with the original `User` node, you need to use the `distinct` prefix within the
    `count()` function to get the correct result. The only variable missing before
    calculating the LCC is the count of existing links between neighbors. Again, you
    should use the `OPTIONAL` `MATCH` clause, as some neighbors might have zero connections,
    and you don’t want to filter those out. I really like the Cypher syntax expressivity
    of defining the graph pattern that will count the number of links between neighboring
    nodes:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经熟悉列表5.10中的大多数Cypher语法。你首先匹配数据库中的所有用户。接下来，计算不同邻居的数量。由于一些`User`节点没有任何`FOLLOWS`关系，你必须使用`OPTIONAL`
    `MATCH`子句。使用`MATCH`子句会减少基数并有效地过滤掉所有没有任何`FOLLOWS`关系的`User`节点。如果你还记得WCCs示例，大约有500个`User`节点没有任何`FOLLOWS`关系。另一个小细节是，`OPTIONAL`
    `MATCH`中的Cypher模式不提供关系方向。你想要计算不同邻居的数量，无论它们是否有指向原始节点的入站、出站或两者都有的关系。由于一些邻居可以与原始`User`节点同时有入站和出站连接，你需要在`count()`函数中使用`distinct`前缀来获取正确的结果。在计算LCC之前，唯一缺少的变量是邻居之间现有链接的数量。同样，你应该使用`OPTIONAL`
    `MATCH`子句，因为一些邻居可能有零连接，你不想过滤掉这些连接。我真的很喜欢Cypher语法的表达性，可以定义将计算相邻节点之间链接数量的图模式：
- en: '[PRE10]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can observe that I used the reference variable `u` twice in this pattern.
    Effectively, this graph pattern describes all triangles the `u` node participates
    in.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以观察到在这个模式中我使用了引用变量`u`两次。实际上，这个图模式描述了`u`节点参与的所有三角形。
- en: '![05-16](../../OEBPS/Images/05-16.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![05-16](../../OEBPS/Images/05-16.png)'
- en: Figure 5.16 Visualized Cypher pattern to identify triangles
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.16 用于识别三角形的可视化Cypher模式
- en: As you can see in figure 5.16, both the nodes must be adjacent to the node `u`,
    as described in the Cypher syntax. You are only interested in counting the `r`
    relationships between neighbors, so you combine the `count()` function and `distinct`
    prefix to fetch the count of existing links between neighbors. Similarly, as before,
    the `FOLLOWS` relationships in the specified graph pattern have no specified direction,
    as you want to consider all possible variations of relationship directions. Finally,
    you can use the LCC algorithm formula to calculate the LCC values for each node.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如图5.16所示，根据Cypher语法描述，两个节点都必须与节点`u`相邻。您只对计算邻居之间的`r`关系感兴趣，因此您结合`count()`函数和`distinct`前缀来获取邻居之间现有链接的数量。同样，正如之前一样，指定图模式中的`FOLLOWS`关系没有指定方向，因为您想考虑所有可能的关系方向变体。最后，您可以使用LCC算法公式来计算每个节点的LCC值。
- en: '![05-16-UN01](../../OEBPS/Images/05-16-UN01.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![05-16-UN01](../../OEBPS/Images/05-16-UN01.png)'
- en: 'The preceding equation can be used to calculate the directed LCC values. You
    take the count of existing links and divide it by the count of possible connections
    between neighbors, which is neighbors count times neighbors count minus 1\. The
    formula does not work for nodes with a neighbor count of 0 or 1, as you would
    end up dividing by 0\. By definition, the LCC value for nodes with less than 2
    neighbors is undefined. However, I’ve come across some implementations where 0
    is used instead of undefined for nodes with less than 2 neighbors, which is what
    I have also decided to use in this example. I’ve introduced the `CASE` statement
    to automatically assign the LCC value of 0 for nodes with less than 2 neighbors.
    If you have some experience with SQL query language, you will notice that the
    `CASE` statement is identical in Cypher. In any case, the Cypher syntax for the
    `CASE` clause is as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方程可以用来计算有向LCC值。您需要计算现有链接的数量，并将其除以邻居之间可能连接的数量，即邻居数量乘以邻居数量减1。当节点邻居数量为0或1时，该公式不适用，因为您最终会除以0。根据定义，少于2个邻居的节点的LCC值是未定义的。然而，我遇到过一些实现，它们在少于2个邻居的节点上使用0代替未定义，这也是我在这个例子中决定使用的。我引入了`CASE`语句来自动为少于2个邻居的节点分配LCC值为0。如果您对SQL查询语言有一些经验，您会注意到`CASE`语句在Cypher中是相同的。无论如何，`CASE`子句的Cypher语法如下：
- en: '[PRE11]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The predicate value should be a Boolean. You can then select the `x` value if
    the Boolean is true or the `y` value if the predicate is false.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 断言值应该是一个布尔值。然后，如果布尔值为真，则选择`x`值；如果断言为假，则选择`y`值。
- en: Finally, you store the calculated LCC value under the `lcc` property of `User`
    nodes. Now that the LCC values are stored in the database, you can go ahead and
    calculate the average LCC.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要将计算出的LCC值存储在`User`节点的`lcc`属性下。现在LCC值已经存储在数据库中，您可以继续计算平均LCC。
- en: Listing 5.11 Calculating the average LCC
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.11 计算平均LCC
- en: '[PRE12]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The average LCC is 0.06\. That’s quite close to 0\. One reason for such a small
    LCC value is that we only have a tiny snapshot of the Twitter network, so the
    information about followers is limited. Research on a more extensive Twitter network
    (Myers et al., 2014) demonstrates that the average LCC values are closer to between
    0.15 and 0.20\. It also seems that users on Twitter are less tightly knit than
    on Facebook (Ugander et al., 2011). That makes sense, as one typically connects
    with their friends and family on Facebook, which is a more strongly connected
    group of users. On the other hand, one study (Efstathiades et al., 2016) suggests
    Twitter users prefer to follow elite users or influencers rather than connecting
    with their family and real-life friends or neighbors as often.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 平均LCC为0.06。这相当接近0。如此小的LCC值的一个原因是，我们只有Twitter网络的微小快照，因此关于关注者的信息有限。对更大范围的Twitter网络的研究（Myers等人，2014年）表明，平均LCC值更接近于0.15到0.20之间。此外，似乎Twitter用户比Facebook（Ugander等人，2011年）上的用户联系得更松散。这很合理，因为人们通常在Facebook上与他们的朋友和家人联系，这是一个联系更紧密的用户群体。另一方面，一项研究（Efstathiades等人，2016年）表明，Twitter用户更喜欢关注精英用户或有影响力的人，而不是像经常与家人、现实生活中的朋友或邻居那样联系。
- en: 5.4 Identifying central nodes
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 识别中心节点
- en: In the last part of this chapter, you will learn how to identify the most central
    nodes. The group of graph algorithms designed to identify the most central nodes
    is called *centrality algorithms*, with PageRank being the most famous one.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，你将学习如何识别最中心的节点。用于识别最中心节点的图算法组被称为*中心性算法*，其中PageRank是最著名的一个。
- en: 5.4.1 PageRank algorithm
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.1 PageRank算法
- en: PageRank was designed by Larry Page and Sergey Brin (1999) and helped make Google
    search what it is today. PageRank measures the transitive or directional influence
    of nodes. For example, the node degree quantifies the influence or importance
    of a node by considering only its direct neighbors. In contrast, PageRank also
    considers the indirect relationships with other nodes in the graph spanning over
    multiple hops. To put it into our Twitter subgraph context, if, for example, Elon
    Musk or Andrew Ng follows you, you gain more influence than if I follow you. PageRank
    evaluates the number of followers a particular node has as well as how influential
    those followers are.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: PageRank是由拉里·佩奇和谢尔盖·布林（1999年）设计的，并帮助谷歌搜索成为今天的模样。PageRank衡量节点的传递或方向性影响力。例如，节点度通过仅考虑其直接邻居来量化节点的影响力或重要性。相比之下，PageRank还考虑了跨越多个跳转的图中其他节点的间接关系。以我们的Twitter子图为例，例如，如果埃隆·马斯克或安德鲁·吴关注你，你获得的影响力比如果我关注你时更多。PageRank评估特定节点拥有的关注者数量以及这些关注者的影响力。
- en: PageRank was initially developed for ranking web pages’ importance. The algorithm
    considers every relationship as a vote of influence (figure 5.17). I like to think
    that if a node is pointing to another node, it essentially states that the other
    node is important or influential.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: PageRank最初是为排名网页重要性而开发的。该算法将每个关系视为一种影响力投票（图5.17）。我喜欢这样想，如果一个节点指向另一个节点，它本质上表明另一个节点很重要或有影响力。
- en: '![05-17](../../OEBPS/Images/05-17.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![05-17](../../OEBPS/Images/05-17.png)'
- en: Figure 5.17 PageRank treats every relationship as a vote of influence.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.17 PageRank将每个关系视为一种影响力投票。
- en: You can then imagine how the votes flow throughout the network via directed
    relationships. Each node is initialized, with its score being equal to 1 divided
    by the number of nodes. Then, it passes its rank through its outgoing connections.
    The amount of influence passed through every relationship is equal to the node’s
    influence divided by the number of outgoing links. After the first iteration,
    the node’s rank is equal to the sum of incoming scores from other nodes. The algorithm
    then iterates this process until it converges or hits a predefined number of iterations
    (figure 5.18).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象，通过有向关系，投票如何在网络中流动。每个节点初始化时，其分数等于节点总数的倒数。然后，它通过其出链传递其排名。每条关系中传递的影响力等于节点影响力除以出链数量。第一次迭代后，节点的排名等于来自其他节点的输入分数之和。然后，算法重复此过程，直到收敛或达到预定义的迭代次数（图5.18）。
- en: '![05-18](../../OEBPS/Images/05-18.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![05-18](../../OEBPS/Images/05-18.png)'
- en: Figure 5.18 Simplified PageRank calculation based on network flow
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.18 基于网络流简化的PageRank计算
- en: However, the simplified PageRank calculation based on the network flow has a
    critical flaw. Node D in figure 5.17 has no outgoing links. A node without any
    outgoing connections is also known as a *dead end*. The presence of dead ends
    will cause the PageRank score of some or all nodes in the network to go down to
    zero, as it effectively leaks the rank score out of the network.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，基于网络流的简化PageRank计算存在一个关键缺陷。图5.17中的节点D没有出链。没有任何出链的节点也被称为*死胡同*。死胡同的存在会导致网络中某些或所有节点的PageRank分数下降到零，因为它实际上将排名分数泄露出了网络。
- en: The PageRank algorithm introduces the *teleportation* ability to avoid rank
    leaking. Teleportation introduces a small probability of jumping to a random node
    instead of following the outgoing links. In the context of exploring web pages,
    imagine a web surfer traversing the internet. They might follow outgoing links
    from a web page to a web page or get bored and jump to a random page. The constant
    that defines the probability a surfer will follow an outgoing link is called the
    *damping factor*. Consequently, the probability that they will jump to a random
    page is 1 minus the damping factor. The typical value of the damping factor is
    0.85, indicating a web surfer will jump to a random page about 15% of the time.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: PageRank算法引入了*teleportation*能力以避免排名泄露。Teleportation引入了跳转到随机节点的小概率，而不是跟随出链。在探索网页的上下文中，想象一个冲浪者穿越互联网。他们可能会跟随网页到网页的出链，或者感到无聊并跳转到随机页面。定义冲浪者跟随出链概率的常数称为*阻尼因子*。因此，他们跳转到随机页面的概率是1减去阻尼因子。阻尼因子的典型值是0.85，这意味着冲浪者大约有15%的时间会跳转到随机页面。
- en: With the standard PageRank algorithm, the jump to a random node is uniformly
    distributed between all nodes in the network, meaning a bored surfer an equal
    chance of jumping to any node in the graph, including the one they are currently
    visiting. In this case, the intermediate node’s rank after each iteration both
    sums the outgoing link’s rank, as shown in figure 5.18, and adds the probability
    that a surfer will randomly jump to that node. The teleportation ability fixes
    the scenario where a dead-end node leaks the whole network PageRank score, which
    would effectively be leaving all nodes at rank value zero. You can execute PageRank
    on the followers networks with the following Cypher statement.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准的PageRank算法，随机跳转到网络中任意节点的概率在所有节点之间均匀分布，这意味着一个无聊的冲浪者有同等的机会跳转到图中的任何节点，包括他们当前正在访问的节点。在这种情况下，中间节点在每次迭代后都会将出链的排名相加，如图5.18所示，并添加一个冲浪者随机跳转到该节点的概率。
    teleportation能力解决了死胡同节点泄露整个网络PageRank分数的情况，这实际上会导致所有节点的排名值为零。你可以使用以下Cypher语句在关注者网络上执行PageRank。
- en: Listing 5.12 Executing PageRank on the followers network
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.12 在关注者网络上执行PageRank
- en: '[PRE13]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The Cypher statement in listing 5.12 executes the PageRank algorithm on the
    projected follower network and stores the results back to the database as the
    `followerPageRank` property of the `User` nodes.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.12中的Cypher语句在投影关注者网络上执行PageRank算法，并将结果存储回数据库作为`User`节点的`followerPageRank`属性。
- en: Exercise 5.8
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 练习5.8
- en: Retrieve the top five users with the highest PageRank score. The PageRank score
    is stored under the `followerPageRank` node property.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 获取具有最高PageRank分数的前五个用户。PageRank分数存储在`followerPageRank`节点属性下。
- en: The solution to exercise 5.8 produces the output shown in table 5.8.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 练习5.8的解决方案产生了表5.8所示的输出。
- en: Table 5.8 The most important nodes by PageRank score
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.8 按PageRank分数排序的最重要节点
- en: '| `username` | `followerPageRank` |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `username` | `followerPageRank` |'
- en: '| "elonmusk" | 20.381862706745217 |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| "elonmusk" | 20.381862706745217 |'
- en: '| "NASA" | 8.653231888111382 |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| "NASA" | 8.653231888111382 |'
- en: '| "wmktech" | 6.937989377788902 |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| "wmktech" | 6.937989377788902 |'
- en: '| "Twitter" | 6.937989377788902 |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| "Twitter" | 6.937989377788902 |'
- en: '| "Wajdialkayal1" | 6.551413750286345 |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| "Wajdialkayal1" | 6.551413750286345 |'
- en: Elon Musk is by far the most influential user in our Twitter subgraph. Interestingly,
    Andrew Ng, Google AI, and OpenAI were all among the first five positions given
    the incoming degree but have lost their places when using the PageRank score.
    Remember, PageRank evaluates the number of incoming connections as well as how
    influential the nodes behind the links are. Sometimes, a node with a high PageRank
    score only has a small number of influential connections. You can examine the
    top followers of each user in table 5.8 with the following Cypher statement.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 伊隆·马斯克是我们Twitter子图中最有影响力的用户。有趣的是，安德鲁·吴、谷歌AI和OpenAI都曾在前五名，但在使用PageRank分数时失去了位置。记住，PageRank评估的是进入连接的数量以及链接背后的节点的影响力。有时，具有高PageRank分数的节点只有少量有影响力的连接。你可以使用以下Cypher语句检查每个用户的顶级关注者，如表5.8所示。
- en: Listing 5.13 Examining the top five followers for the highest-ranking users
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.13 检查排名最高的用户的顶级关注者
- en: '[PRE14]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Matches the group of users using the IN clause
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 匹配使用IN子句的用户组
- en: ❷ Orders the intermediate results by the followers PageRank score, descending
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 按关注者PageRank分数降序排列中间结果
- en: ❸ Collects the top five followers grouped by the original users
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 按原始用户分组收集前五个关注者
- en: 'The Cypher statement in listing 5.13 begins by matching the top five users
    by their `username` property. Instead of using multiple `OR` predicates, you can
    use the `IN` operator to specify a list of possible values. Then, you use the
    `WITH` statement to order the results by the followers’ PageRank score. Finally,
    you use the `collect()` function to produce an ordered list of followers by their
    PageRank score. The `collect()` function keeps the order of the input data. Because
    you first ordered the results in the `WITH` statement by the followers’ PageRank
    score, the list result of the `collect()` function will contain an ordered list
    of followers by their PageRank score. Returning only the top five followers per
    user was achieved with *list slicing*. You may have come across list or array
    slicing if you have ever done any programming or SQL analysis. The list slicing
    syntax in Cypher is as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.13中的Cypher语句首先通过`username`属性匹配排名前五的用户。您可以使用`IN`运算符指定可能值的列表，而不是使用多个`OR`谓词。然后，您使用`WITH`语句按关注者的PageRank分数对结果进行排序。最后，您使用`collect()`函数生成按PageRank分数排序的关注者有序列表。`collect()`函数保持输入数据的顺序。因为您首先在`WITH`语句中按关注者的PageRank分数对结果进行排序，所以`collect()`函数的列表结果将包含按PageRank分数排序的关注者列表。通过*列表切片*实现了每个用户只返回前五名关注者。如果您曾经进行过任何编程或SQL分析，您可能已经遇到过列表或数组切片。Cypher中的列表切片语法如下：
- en: '[PRE15]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The square brackets syntax will extract the array elements from the start index
    `from` and up to (but excluding) the end index `to`. Cypher has a `round()` function
    that allows you to specify to round any number to the specified precision or decimal
    point. The results of the Cypher statement in listing 5.13 are shown in table
    5.9.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号语法将从起始索引`from`提取数组元素，直到（但不包括）结束索引`to`。Cypher有一个`round()`函数，允许您指定将任何数字四舍五入到指定的精度或小数点。列表5.13中Cypher语句的结果显示在表5.9中。
- en: Table 5.9 The most important nodes by PageRank score
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.9 按PageRank分数排序的最重要节点
- en: '| `user` | `pagerankScore` | `topFiveFollowers` |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `用户` | `PageRank分数` | `前五名关注者` |'
- en: '| "elonmusk" | 20.38 | ["fchollet", "TheCuriousLuke", "DrLiMengYAN1", "douwekiela",
    "threadreaderapp"] |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| "elonmusk" | 20.38 | ["fchollet", "TheCuriousLuke", "DrLiMengYAN1", "douwekiela",
    "threadreaderapp"] |'
- en: '| "NASA" | 8.65 | ["BIBBI02374449", "Lucian2drei", "NYTScience", "CmccClimate",
    "abhibisht89"] |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| "NASA" | 8.65 | ["BIBBI02374449", "Lucian2drei", "NYTScience", "CmccClimate",
    "abhibisht89"] |'
- en: '| "wmktech" | 6.94 | ["Wajdialkayal1", "alkayal_wajdi", "Websystemer", "AlkayalWajdi",
    "SwissCognitive"] |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| "wmktech" | 6.94 | ["Wajdialkayal1", "alkayal_wajdi", "Websystemer", "AlkayalWajdi",
    "SwissCognitive"] |'
- en: '| "Twitter" | 6.66 | ["Lucian2drei", "Chuck_Moeller", "Omkar_Raii", "SportsCenter",
    "philipvollet"] |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| "Twitter" | 6.66 | ["Lucian2drei", "Chuck_Moeller", "Omkar_Raii", "SportsCenter",
    "philipvollet"] |'
- en: '| "Wajdialkayal1" | 6.55 | ["wmktech", "Websystemer", "taylorwfarley", "RiM2ww",
    "saye2018"] |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| "Wajdialkayal1" | 6.55 | ["wmktech", "Websystemer", "taylorwfarley", "RiM2ww",
    "saye2018"] |'
- en: 'I was hoping that Elon or NASA would appear under top followers, but unfortunately,
    they don’t follow anyone in our subgraph. The lack of follower relationships for
    Elon and NASA is not surprising, as they follow about 500 combined users but have
    more than 200 million followers themselves. If, for example, either Elon or NASA
    followed a user, their PageRank score would automatically be high because they
    would have one of the most influential nodes following them. A real-life analogy
    might be the following: imagine you just moved to Sweden and don’t know anyone
    except the president of the country. Even though you only have one connection,
    that connection is very influential, which automatically gives you a lot of influence
    over the network.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我原本希望Elon或NASA会出现在前关注者中，但不幸的是，他们在我们子图中没有关注任何人。Elon和NASA缺乏关注者关系并不令人惊讶，因为他们总共关注了约500个用户，但他们自己却有超过2亿的关注者。例如，如果Elon或NASA关注了一个用户，他们的PageRank分数将自动很高，因为他们将有一个最具影响力的节点在关注他们。一个现实生活中的类比可能是以下这样：想象你刚刚搬到瑞典，除了国家的总统外，你认识的人都不认识。尽管你只有一个联系，但这个联系非常有影响力，这会自动给你在网络中带来很多影响力。
- en: The only exciting follower pattern that can be found in table 5.9 is that users
    wmktech and Wajdialkayal1 follow each other. They are both influential but also
    contribute to each other’s importance by following one another.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.9中唯一令人兴奋的跟随模式是用户wmktech和Wajdialkayal1相互关注。他们两人都很有影响力，而且通过相互关注，彼此也增加了对方的重要性。
- en: 5.4.2 Personalized PageRank algorithm
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.2 个性化PageRank算法
- en: The Neo4j GDS library also supports the *personalized PageRank* variation. In
    the PageRank definition, a web surfer can get bored and randomly jump to other
    nodes. With the personalized PageRank algorithm, you can define which nodes the
    web surfer should jump to when they get bored. It can be said that by defining
    the `sourceNodes` to which the surfer is biased to jump, you are effectively inspecting
    the influence of nodes by looking through a particular node’s or multiple nodes’
    point of view.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j GDS库也支持*个性化PageRank*变体。在PageRank定义中，网络冲浪者可能会感到无聊并随机跳转到其他节点。通过个性化PageRank算法，你可以定义当网络冲浪者感到无聊时应该跳转到哪些节点。可以说，通过定义冲浪者倾向于跳转的`sourceNodes`，你实际上是通过特定节点或多个节点的视角来检查节点的影响。
- en: In this example, you will use the `stream` mode of the personalized PageRank
    algorithm. The `stream` mode returns the results of an algorithm as a stream of
    records. The syntax of the personalized PageRank algorithm is almost identical
    to the PageRank algorithm, except you are also providing the `sourceNodes` parameter.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，你将使用个性化PageRank算法的`stream`模式。`stream`模式将算法的结果作为记录流返回。个性化PageRank算法的语法几乎与PageRank算法相同，只是你还提供了`sourceNodes`参数。
- en: Listing 5.14 Running the personalized PageRank algorithm from the point of view
    of users who registered in 2016
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.14：从2016年注册的用户视角运行个性化PageRank算法
- en: '[PRE16]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Matches the source nodes to be used in Personalized PageRank algorithm
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 匹配用于个性化PageRank算法的源节点
- en: ❷ Executes the personalized PageRank algorithm
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 执行个性化PageRank算法
- en: ❸ Uses the gds.util.asNode function to match the specific node by its internal
    ID
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用gds.util.asNode函数通过其内部ID匹配特定节点
- en: 'First, you need to use the `MATCH` clause followed by the `collect()` function
    to produce a list of all users who registered in 2016\. You can then input the
    collected users as the `sourceNode` parameter. By defining the `sourceNode` parameter,
    you are instructing the procedure to execute the personalized PageRank algorithm
    and use the provided nodes as the restart nodes when teleporting. The `stream`
    mode of the PageRank algorithms outputs two columns: `nodeId` and `score`. The
    `nodeId` represents the Neo4j *internal node id*, which the database automatically
    generates for every node in the database. You can use the `gds.util.asNode()`
    function to map the `nodeId` value to the actual node instance. The `score` column
    represents the PageRank score for a particular node.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要使用`MATCH`子句后跟`collect()`函数来生成所有2016年注册用户的列表。然后，你可以将收集到的用户作为`sourceNode`参数输入。通过定义`sourceNode`参数，你是在指示程序执行个性化PageRank算法，并在teleport时使用提供的节点作为重启节点。PageRank算法的`stream`模式输出两列：`nodeId`和`score`。`nodeId`代表Neo4j的*内部节点ID*，数据库会自动为数据库中的每个节点生成。你可以使用`gds.util.asNode()`函数将`nodeId`值映射到实际的节点实例。`score`列代表特定节点的PageRank分数。
- en: The most important users from the point of view of users who registered in 2016
    are Elon Musk followed by Andrew Ng, Ian Goodfellow, Hugging Face, and NASA. While
    Elon Musk and NASA are also present in the top five users by overall PageRank
    score, you can observe that the Andrew Ng, Ian Goodfellow, and Hugging Face accounts
    gained importance when determining PageRank score through the viewpoint of users
    who registered in 2016.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 从2016年注册的用户角度来看，最重要的用户是埃隆·马斯克，其次是安德鲁·吴、伊恩·古德费洛、Hugging Face和NASA。虽然埃隆·马斯克和NASA也出现在整体PageRank分数排名前五的用户中，但你也可以观察到，当从2016年注册的用户视角来确定PageRank分数时，安德鲁·吴、伊恩·古德费洛和Hugging
    Face的账户获得了重要性。
- en: What would happen if you were to run personalized PageRank and use a node with
    no outgoing connections as the `sourceNodes` parameter? The following listing
    shows this process.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行个性化PageRank并使用没有出向连接的节点作为`sourceNodes`参数会发生什么？以下列表显示了此过程。
- en: Listing 5.15 Running the personalized PageRank algorithm from the point of view
    of NASA
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.15：从NASA视角运行个性化PageRank算法
- en: '[PRE17]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Table 5.10 shows the PageRank scores for this example.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.10显示了本例的PageRank分数。
- en: Table 5.10 The most important nodes by the PageRank score
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.10：按PageRank分数排序的最重要节点
- en: '| `user` | `score` |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| `user` | `score` |'
- en: '| "NASA" | 0.15000000000000002 |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| "NASA" | 0.15000000000000002 |'
- en: '| "ServerlessFan" | 0 |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| "ServerlessFan" | 0 |'
- en: '| "dr_sr_simpson" | 0 |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| "dr_sr_simpson" | 0 |'
- en: As there are no outgoing connections from the nodes specified in the `sourceNodes`
    parameter, the PageRank algorithm will keep on restarting at the selected source
    node, which will, in turn, leave all the other nodes with the PageRank score of
    0\. When running PageRank with default settings, all nodes with a PageRank score
    of 0.15 don’t have any incoming relationships. They only get their importance
    by the web surfer randomly jumping to them, but they have no votes of significance
    from other nodes. With the personalized PageRank variation, you can also specify
    which nodes to jump to when bored, which, in turn, means some nodes will not even
    get the PageRank score of 0.15, as the surfer doesn’t randomly jump to them.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `sourceNodes` 参数中指定的节点没有出链，PageRank 算法将不断在选定的源节点上重新启动，这反过来又会导致所有其他节点的 PageRank
    评分为 0。当使用默认设置运行 PageRank 时，所有 PageRank 评分为 0.15 的节点都没有任何进入关系。它们只通过网络浏览者随机跳转到它们而获得重要性，但它们没有来自其他节点的显著投票。在个性化
    PageRank 变体中，你也可以指定在无聊时跳转到哪些节点，这意味着一些节点甚至不会获得 0.15 的 PageRank 评分，因为浏览者不会随机跳转到它们。
- en: Exercise 5.9
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 5.9
- en: Execute the personalized PageRank algorithm, and use the `User` nodes who registered
    in the year 2019 as the `sourceNodes` parameter.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 执行个性化 PageRank 算法，并使用 2019 年注册的 `User` 节点作为 `sourceNodes` 参数。
- en: 5.4.3 Dropping the named graph
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.3 删除命名图
- en: Congratulations! You have now completed your first network analysis. After you
    have completed the planned graph algorithms execution sequence, it is recommended
    to drop the projected graph from memory. You can release the in-memory graph by
    using the `gds.graph.drop()` procedure.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在已经完成了你的第一次网络分析。在你完成计划的图算法执行序列后，建议删除投影图以节省内存。你可以通过使用 `gds.graph.drop()`
    程序来释放内存中的图。
- en: Listing 5.16 Releasing the follower-network graph from memory
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.16 从内存中释放 follower-network 图
- en: '[PRE18]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the next chapter, you will learn how to infer monopartite networks based
    on indirect relationships. You will run many of the graph algorithms you learned
    in this chapter to solidify your skills in executing them and understanding their
    results.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何根据间接关系推断单部分网络。你将运行本章中学到的许多图算法，以巩固执行它们和理解它们结果的能力。
- en: 5.5 Solutions to exercises
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5 练习解答
- en: The solution to exercise 5.1 is as follows.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 5.1 的解答如下。
- en: Listing 5.17 Fetching the users with the top five highest out-degrees
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.17 获取具有最高五个出度的用户
- en: '[PRE19]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The solution to exercise 5.2 is as follows.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 5.2 的解答如下。
- en: Listing 5.18 Fetching the users with the top five highest in-degrees
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.18 获取具有最高五个入度的用户
- en: '[PRE20]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The solution to exercise 5.3 is as follows.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 5.3 的解答如下。
- en: Listing 5.19 Examining mentions and published posts for NASA
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.19 检查 NASA 的提及和发布的帖子
- en: '[PRE21]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The solution to exercise 5.4 is as follows.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 5.4 的解答如下。
- en: Listing 5.20 Counting the number of users for the five largest WCCs
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.20 计算五个最大 WCC 的用户数量
- en: '[PRE22]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The solution to exercise 5.5 is as follows.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 5.5 的解答如下。
- en: Listing 5.21 Counting the number of WCCs that contain only one member
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.21 计算仅包含一个成员的 WCC 数量
- en: '[PRE23]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The solution to exercise 5.6 is as follows.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 5.6 的解答如下。
- en: Listing 5.22 Counting the number of members for the five largest SCCs
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.22 计算五个最大 SCC 的成员数量
- en: '[PRE24]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The solution to exercise 5.7 is as follows.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 5.7 的解答如下。
- en: Listing 5.23 Visualizing the second-largest SCC in Neo4j Browser
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.23 在 Neo4j 浏览器中可视化第二大 SCC
- en: '[PRE25]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Make sure you correct the `followerScc` value if needed in the `WHERE` clause.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在 `WHERE` 子句中根据需要更正 `followerScc` 值。
- en: The solution to exercise 5.8 is as follows.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 5.8 的解答如下。
- en: Listing 5.24 Retrieving the top five users with the highest PageRank score
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.24 获取具有最高 PageRank 评分的前五名用户
- en: '[PRE26]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The solution to exercise 5.9 is as follows.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 5.9 的解答如下。
- en: Listing 5.25 Executing the personalized PageRank algorithm and using the `User`
    nodes who registered in the year 2019 as the `sourceNodes` parameter
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.25 执行个性化 PageRank 算法，并使用 2019 年注册的 `User` 节点作为 `sourceNodes` 参数
- en: '[PRE27]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Summary
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Real-world networks follow the power-law distribution of node degree.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际网络遵循节点度数的幂律分布。
- en: For a directed network, the node degree can be split into in-degree, the count
    of incoming connections, and out-degree, which counts outgoing links.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于有向网络，节点度数可以分为入度，即进入连接的数量，和出度，即出链的数量。
- en: The Graph Data Science (GDS) library uses a projected in-memory graph to execute
    the graph algorithm on.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图数据科学（GDS）库使用投影的内存图来执行图算法。
- en: Native projection is the better performing variation of projecting in-memory
    graphs.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地投影是内存中图投影性能更好的变体。
- en: The `stream` mode of graph algorithms returns results as a stream of records
    and does not store results.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图算法的`stream`模式以记录流的形式返回结果，并不存储结果。
- en: The `stats` mode returns a summary statistics of the algorithm and does not
    store results.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stats`模式返回算法的摘要统计信息，并不存储结果。'
- en: The `mutate` mode of a graph algorithm stores the results of the algorithm back
    to the projected in-memory graph.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图算法的`mutate`模式将算法的结果存储回投影的内存图。
- en: The `write` mode stores the results of the algorithm to the database.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`write`模式将算法的结果存储到数据库中。'
- en: The weakly connected component (WCC) algorithm is used to identify disconnected
    parts or islands in the network.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弱连通分量（WCC）算法用于识别网络中的不连通部分或岛屿。
- en: The WCC algorithm is often used early in an analysis to evaluate the connectedness
    and structure of a graph.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WCC算法通常在分析早期使用，以评估图的连通性和结构。
- en: A strongly connected component (SCC) is a subgraph of a directed graph in which
    a path exists between all nodes.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强连通分量（SCC）是有向图中所有节点之间都存在路径的子图。
- en: The local clustering coefficient (LCC) examines how tightly knit the neighbors
    of a node are.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地聚类系数（LCC）检查一个节点的邻居是如何紧密相连的。
- en: The `CASE` clause can be used to specify generic conditional expressions.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`CASE`子句来指定通用条件表达式。
- en: PageRank treats each relationship as a vote of influence and can be used to
    find the most influential nodes in the graph.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PageRank将每个关系视为一个影响力投票，可以用来找到图中最有影响力的节点。
- en: PageRank has a damping factor parameter that specifies how often a random web
    surfer should follow an outgoing link as opposed to jumping to a random node.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PageRank有一个阻尼因子参数，指定随机网络冲浪者应该多频繁地跟随出站链接，而不是跳转到随机节点。
- en: When running the PageRank algorithm with the default damping factor parameter
    of 0.85, nodes with no incoming relationships will have a PageRank score of 0.15.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用默认的阻尼因子参数0.85运行PageRank算法时，没有传入关系的节点将具有0.15的PageRank得分。
- en: With the Personalized PageRank variation, you can specify which nodes the random
    surfer should teleport to, which gives you a view of the network from a specific
    point of view.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用个性化PageRank变体，您可以指定随机游走者应该跳转到的节点，这为您提供了一个从特定视角看网络的方式。
- en: After an analysis, make sure to release the projected graph from memory with
    the `gds.graph.drop` procedure.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析完成后，请确保使用`gds.graph.drop`过程从内存中释放投影图。
