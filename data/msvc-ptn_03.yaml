- en: Chapter 4\. Managing transactions with sagas
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4章\. 使用传奇管理事务
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Why distributed transactions aren’t a good fit for modern applications
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么分布式事务不适合现代应用程序
- en: Using the Saga pattern to maintain data consistency in a microservice architecture
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用传奇模式在微服务架构中保持数据一致性
- en: Coordinating sagas using choreography and orchestration
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用编排和协调来协调传奇
- en: Using countermeasures to deal with the lack of isolation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对策来处理隔离不足的问题
- en: When Mary started investigating the microservice architecture, one of her biggest
    concerns was how to implement transactions that span multiple services. Transactions
    are an essential ingredient of every enterprise application. Without transactions
    it would be impossible to maintain data consistency.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当玛丽开始研究微服务架构时，她最大的担忧之一是如何实现跨越多个服务的事务。事务是每个企业应用程序的基本组成部分。没有事务，就难以保持数据一致性。
- en: ACID (Atomicity, Consistency, Isolation, Durability) transactions greatly simplify
    the job of the developer by providing the illusion that each transaction has exclusive
    access to the data. In a microservice architecture, transactions that are within
    a single service can still use ACID transactions. The challenge, however, lies
    in implementing transactions for operations that update data owned by multiple
    services. For example, as described in [chapter 2](kindle_split_010.xhtml#ch02),
    the `createOrder()` operation spans numerous services, including `Order Service`,
    `Kitchen Service`, and `Accounting Service`. Operations such as these need a transaction
    management mechanism that works across services.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: ACID（原子性、一致性、隔离、持久性）事务通过提供每个事务对数据具有独占访问的错觉，极大地简化了开发者的工作。在微服务架构中，单个服务内的操作仍然可以使用ACID事务。然而，挑战在于实现更新多个服务拥有的数据的操作的事务。例如，正如[第2章](kindle_split_010.xhtml#ch02)中描述的，`createOrder()`操作跨越了多个服务，包括`Order
    Service`、`Kitchen Service`和`Accounting Service`。这类操作需要一个跨服务工作的交易管理机制。
- en: Mary discovered that, as mentioned in [chapter 2](kindle_split_010.xhtml#ch02),
    the traditional approach to distributed transaction management isn’t a good choice
    for modern applications. Instead of an ACID transactions, an operation that spans
    services must use what’s known as a *saga*, a message-driven sequence of local
    transactions, to maintain data consistency. One challenge with sagas is that they
    are ACD (Atomicity, Consistency, Durability). They lack the isolation feature
    of traditional ACID transactions. As a result, an application must use what are
    known as *countermeasures*, design techniques that prevent or reduce the impact
    of concurrency anomalies caused by the lack of isolation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 玛丽发现，正如[第2章](kindle_split_010.xhtml#ch02)中提到的，传统的分布式事务管理方法并不适合现代应用程序。与传统ACID事务不同，跨越服务的操作必须使用所谓的传奇，即本地事务的消息驱动序列，以保持数据一致性。传奇的一个挑战是它们是ACD（原子性、一致性、持久性）。它们缺乏传统ACID事务的隔离特性。因此，应用程序必须使用所谓的*对策*，即设计技术，以防止或减少由隔离不足引起的并发异常的影响。
- en: In many ways, the biggest obstacle that Mary and the FTGO developers will face
    when adopting microservices is moving from a single database with ACID transactions
    to a multi-database architecture with ACD sagas. They’re used to the simplicity
    of the ACID transaction model. But in reality, even monolithic applications such
    as the FTGO application typically don’t use textbook ACID transactions. For example,
    many applications use a lower transaction isolation level in order to improve
    performance. Also, many important business processes, such as transferring money
    between accounts at different banks, are eventually consistent. Not even Starbucks
    uses two-phase commit ([www.enterpriseintegrationpatterns.com/ramblings/18_starbucks.html](http://www.enterpriseintegrationpatterns.com/ramblings/18_starbucks.html)).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，玛丽和FTGO开发者采用微服务时将面临的最大障碍是从具有ACID事务的单数据库架构迁移到具有ACD（原子性、一致性、持久性）传奇的多数据库架构。他们习惯了ACID事务模型的简单性。但在现实中，即使是像FTGO这样的单体应用程序通常也不使用教科书中的ACID事务。例如，许多应用程序使用较低的事务隔离级别以提高性能。此外，许多重要的业务流程，如在不同银行账户之间转账，最终都是一致的。甚至星巴克也不使用两阶段提交([www.enterpriseintegrationpatterns.com/ramblings/18_starbucks.html](http://www.enterpriseintegrationpatterns.com/ramblings/18_starbucks.html))。
- en: 'I begin this chapter by looking at the challenges of transaction management
    in the microservice architecture and explain why the traditional approach to distributed
    transaction management isn’t an option. Next I explain how to maintain data consistency
    using sagas. After that I look at the two different ways of coordinating sagas:
    *choreography*, where participants exchange events without a centralized point
    of control, and *orchestration*, where a centralized controller tells the saga
    participants what operation to perform. I discuss how to use countermeasures to
    prevent or reduce the impact of concurrency anomalies caused by the lack of isolation
    between sagas. Finally, I describe the implementation of an example saga.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我以探讨微服务架构中事务管理的挑战开始本章，并解释为什么传统的分布式事务管理方法不是一个可行的选择。接下来，我解释如何使用sagas来维护数据一致性。之后，我查看协调sagas的两种不同方式：*编排*，其中参与者交换事件而没有集中的控制点，以及*编排*，其中集中的控制器告诉sagas参与者执行什么操作。我讨论了如何使用对策来防止或减少由于sagas之间缺乏隔离性而引起的并发异常的影响。最后，我描述了一个示例sagas的实现。
- en: Let’s start by taking a look at the challenge of managing transactions in a
    microservice architecture.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从探讨在微服务架构中管理事务的挑战开始。
- en: 4.1\. Transaction management in a microservice architecture
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1\. 微服务架构中的事务管理
- en: Almost every request handled by an enterprise application is executed within
    a database transaction. Enterprise application developers use frameworks and libraries
    that simplify transaction management. Some frameworks and libraries provide a
    programmatic API for explicitly beginning, committing, and rolling back transactions.
    Other frameworks, such as the Spring framework, provide a declarative mechanism.
    Spring provides an `@Transactional` annotation that arranges for method invocations
    to be automatically executed within a transaction. As a result, it’s straightforward
    to write transactional business logic.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个由企业应用程序处理的需求都在数据库事务中执行。企业应用程序开发者使用框架和库来简化事务管理。一些框架和库提供了用于显式开始、提交和回滚事务的程序化API。其他框架，例如Spring框架，提供了声明式机制。Spring提供了一个`@Transactional`注解，该注解安排方法调用在事务中自动执行。因此，编写事务性业务逻辑变得非常简单。
- en: Or, to be more precise, transaction management is straightforward in a monolithic
    application that accesses a single database. Transaction management is more challenging
    in a complex monolithic application that uses multiple databases and message brokers.
    And in a microservice architecture, transactions span multiple services, each
    of which has its own database. In this situation, the application must use a more
    elaborate mechanism to manage transactions. As you’ll learn, the traditional approach
    of using distributed transactions isn’t a viable option for modern applications.
    Instead, a microservices-based application must use sagas.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，更准确地说，在访问单个数据库的单体应用程序中，事务管理是直接的。在复杂单体应用程序中使用多个数据库和消息代理时，事务管理更具挑战性。在微服务架构中，事务跨越多个服务，每个服务都有自己的数据库。在这种情况下，应用程序必须使用更复杂的机制来管理事务。正如你将学到的，使用分布式事务的传统方法对于现代应用程序来说不是一个可行的选择。相反，基于微服务的应用程序必须使用sagas。
- en: Before I explain sagas, let’s first look at why transaction management is challenging
    in a microservice architecture.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释sagas之前，让我们首先看看为什么在微服务架构中事务管理具有挑战性。
- en: 4.1.1\. The need for distributed transactions in a microservice architecture
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.1\. 微服务架构中分布式事务的需求
- en: Imagine that you’re the FTGO developer responsible for implementing the `createOrder()`
    system operation. As described in [chapter 2](kindle_split_010.xhtml#ch02), this
    operation must verify that the consumer can place an order, verify the order details,
    authorize the consumer’s credit card, and create an `Order` in the database. It’s
    relatively straightforward to implement this operation in the monolithic FTGO
    application. All the data required to validate the order is readily accessible.
    What’s more, you can use an ACID transaction to ensure data consistency. You might
    use Spring’s `@Transactional` annotation on the `createOrder()` service method.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你是负责实现 `createOrder()` 系统操作的 FTGO 开发者。如第 2 章所述 [kindle_split_010.xhtml#ch02]，此操作必须验证消费者能否下单，验证订单详情，授权消费者的信用卡，并在数据库中创建一个
    `Order`。在单体 FTGO 应用程序中实现此操作相对简单。验证订单所需的所有数据都易于访问。更重要的是，你可以使用 ACID 事务来确保数据一致性。你可能会在
    `createOrder()` 服务方法上使用 Spring 的 `@Transactional` 注解。
- en: In contrast, implementing the same operation in a microservice architecture
    is much more complicated. As [figure 4.1](#ch04fig01) shows, the needed data is
    scattered around multiple services. The `createOrder()` operation accesses data
    in numerous services. It reads data from `Consumer Service` and updates data in
    `Order Service`, `Kitchen Service`, and `Accounting Service`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，在微服务架构中实现相同的操作要复杂得多。如图 4.1 所示，所需数据分散在多个服务中。`createOrder()` 操作访问多个服务中的数据。它从
    `Consumer Service` 读取数据，并在 `Order Service`、`Kitchen Service` 和 `Accounting Service`
    中更新数据。
- en: Figure 4.1\. The `createOrder()` operation updates data in several services.
    It must use a mechanism to maintain data consistency across those services.
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.1\. `createOrder()` 操作更新多个服务中的数据。它必须使用一种机制来维护这些服务之间的数据一致性。
- en: '![](Images/04fig01_alt.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1](Images/04fig01_alt.jpg)'
- en: Because each service has its own database, you need to use a mechanism to maintain
    data consistency across those databases.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个服务都有自己的数据库，你需要使用一种机制来维护这些数据库之间的数据一致性。
- en: 4.1.2\. The trouble with distributed transactions
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.2\. 分布式事务的问题
- en: The traditional approach to maintaining data consistency across multiple services,
    databases, or message brokers is to use distributed transactions. The de facto
    standard for distributed transaction management is the X/Open Distributed Transaction
    Processing (DTP) Model (X/Open XA—see [https://en.wikipedia.org/wiki/X/Open_XA](https://en.wikipedia.org/wiki/X/Open_XA)).
    XA uses *two-phase commit* (2PC) to ensure that all participants in a transaction
    either commit or rollback. An XA-compliant technology stack consists of XA-compliant
    databases and message brokers, database drivers, and messaging APIs, and an interprocess
    communication mechanism that propagates the XA global transaction ID. Most SQL
    databases are XA compliant, as are some message brokers. Java EE applications
    can, for example, use JTA to perform distributed transactions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个服务、数据库或消息代理之间维护数据一致性的传统方法是用分布式事务。分布式事务管理的既定标准是 X/Open 分布式事务处理 (DTP) 模型 (X/Open
    XA—见 [https://en.wikipedia.org/wiki/X/Open_XA](https://en.wikipedia.org/wiki/X/Open_XA))。XA
    使用 *两阶段提交* (2PC) 来确保事务中的所有参与者要么提交要么回滚。符合 XA 的技术堆栈包括符合 XA 的数据库和消息代理、数据库驱动程序和消息
    API，以及传播 XA 全局事务 ID 的进程间通信机制。大多数 SQL 数据库都符合 XA 标准，一些消息代理也是如此。例如，Java EE 应用程序可以使用
    JTA 来执行分布式事务。
- en: As simple as this sounds, there are a variety of problems with distributed transactions.
    One problem is that many modern technologies, including NoSQL databases such as
    MongoDB and Cassandra, don’t support them. Also, distributed transactions aren’t
    supported by modern message brokers such as RabbitMQ and Apache Kafka. As a result,
    if you insist on using distributed transactions, you can’t use many modern technologies.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然听起来很简单，但分布式事务存在各种问题。一个问题就是许多现代技术，包括 MongoDB 和 Cassandra 这样的 NoSQL 数据库，都不支持它们。此外，现代消息代理，如
    RabbitMQ 和 Apache Kafka，也不支持分布式事务。因此，如果你坚持使用分布式事务，你将无法使用许多现代技术。
- en: 'Another problem with distributed transactions is that they are a form of synchronous
    IPC, which reduces availability. In order for a distributed transaction to commit,
    all the participating services must be available. As described in [chapter 3](kindle_split_011.xhtml#ch03),
    the availability is the product of the availability of all of the participants
    in the transaction. If a distributed transaction involves two services that are
    99.5% available, then the overall availability is 99%, which is significantly
    less. Each additional service involved in a distributed transaction further reduces
    availability. There is even Eric Brewer’s CAP theorem, which states that a system
    can only have two of the following three properties: consistency, availability,
    and partition tolerance ([https://en.wikipedia.org/wiki/CAP_theorem](https://en.wikipedia.org/wiki/CAP_theorem)).
    Today, architects prefer to have a system that’s available rather than one that’s
    consistent.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式事务的另一个问题是，它们是一种同步 IPC 形式，这降低了可用性。为了使分布式事务提交，所有参与的服务都必须可用。如[第 3 章](kindle_split_011.xhtml#ch03)所述，可用性是事务中所有参与者可用性的乘积。如果一个分布式事务涉及两个
    99.5% 可用的服务，那么整体可用性将是 99%，这显著降低了。每个参与分布式事务的额外服务都会进一步降低可用性。甚至还有埃里克·布赖尔的 CAP 定理，该定理指出，一个系统只能拥有以下三个属性中的两个：一致性、可用性和分区容错性([https://en.wikipedia.org/wiki/CAP_theorem](https://en.wikipedia.org/wiki/CAP_theorem))。今天，架构师更倾向于拥有一个可用的系统，而不是一个一致的系统。
- en: On the surface, distributed transactions are appealing. From a developer’s perspective,
    they have the same programming model as local transactions. But because of the
    problems mentioned so far, distributed transactions aren’t a viable technology
    for modern applications. [Chapter 3](kindle_split_011.xhtml#ch03) described how
    to send messages as part of a database transaction without using distributed transactions.
    To solve the more complex problem of maintaining data consistency in a microservice
    architecture, an application must use a different mechanism that builds on the
    concept of loosely coupled, asynchronous services. This is where sagas come in.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，分布式事务很有吸引力。从开发者的角度来看，它们与本地事务具有相同的编程模型。但由于前面提到的问题，分布式事务并不是现代应用的可行技术。[第 3
    章](kindle_split_011.xhtml#ch03)描述了在不使用分布式事务的情况下，作为数据库事务一部分发送消息的方法。为了解决在微服务架构中维护数据一致性的更复杂问题，应用程序必须使用不同的机制，该机制建立在松散耦合、异步服务概念的基础上。这就是传说发挥作用的地方。
- en: 4.1.3\. Using the Saga pattern to maintain data consistency
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.3\. 使用传说模式来维护数据一致性
- en: '*Sagas* are mechanisms to maintain data consistency in a microservice architecture
    without having to use distributed transactions. You define a saga for each system
    command that needs to update data in multiple services. A saga is a sequence of
    local transactions. Each local transaction updates data within a single service
    using the familiar ACID transaction frameworks and libraries mentioned earlier.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*传说* 是在无需使用分布式事务的情况下，在微服务架构中维护数据一致性的机制。您为每个需要更新多个服务中数据的系统命令定义一个传说。传说是一系列本地事务。每个本地事务都使用前面提到的熟悉的
    ACID 事务框架和库在单个服务内更新数据。'
- en: '|  |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Pattern: Saga**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：传说**'
- en: Maintain data consistency across services using a sequence of local transactions
    that are coordinated using asynchronous messaging. See [http://microservices.io/patterns/data/saga.html](http://microservices.io/patterns/data/saga.html).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一系列由异步消息协调的本地事务来在服务之间维护数据一致性。请参阅[http://microservices.io/patterns/data/saga.html](http://microservices.io/patterns/data/saga.html)。
- en: '|  |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The system operation initiates the first step of the saga. The completion of
    a local transaction triggers the execution of the next local transaction. Later,
    in [section 4.2](#ch04lev1sec2), you’ll see how coordination of the steps is implemented
    using asynchronous messaging. An important benefit of asynchronous messaging is
    that it ensures that all the steps of a saga are executed, even if one or more
    of the saga’s participants is temporarily unavailable.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 系统操作启动传说的第一步。本地事务的完成触发下一个本地事务的执行。稍后，在[第 4.2 节](#ch04lev1sec2)中，您将看到如何使用异步消息实现步骤的协调。异步消息的一个重要好处是，它确保即使传说的一个或多个参与者暂时不可用，传说的所有步骤都会被执行。
- en: Sagas differ from ACID transactions in a couple of important ways. As I describe
    in detail in [section 4.3](#ch04lev1sec3), they lack the isolation property of
    ACID transactions. Also, because each local transaction commits its changes, a
    saga must be rolled back using compensating transactions. I talk more about compensating
    transactions later in this section. Let’s take a look at an example saga.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Sagas 在几个重要方面与 ACID 事务不同。正如我在 [第 4.3 节](#ch04lev1sec3) 中详细描述的那样，它们缺乏 ACID 事务的隔离属性。此外，由于每个本地事务都会提交其更改，因此必须使用补偿性事务来回滚
    Saga。我将在本节后面更多地讨论补偿性事务。让我们看看一个示例 Saga。
- en: 'An example saga: The Create Order saga'
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 一个示例 Saga：创建订单 Saga
- en: The example saga used throughout this chapter is the `Create Order Saga`, which
    is shown in [figure 4.2](#ch04fig02). The `Order Service` implements the `createOrder()`
    operation using this saga. The saga’s first local transaction is initiated by
    the external request to create an order. The other five local transactions are
    each triggered by completion of the previous one.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的示例 Saga 是 `Create Order Saga`，如图 4.2 所示。`订单服务` 使用这个 Saga 实现了 `createOrder()`
    操作。这个 Saga 的第一个本地事务是由创建订单的外部请求启动的。其他五个本地事务分别由前一个事务的完成触发。
- en: Figure 4.2\. Creating an `Order` using a saga. The `createOrder()` operation
    is implemented by a saga that consists of local transactions in several services.
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.2\. 使用 Saga 创建 `订单`。`createOrder()` 操作由一个由几个服务中的本地事务组成的 Saga 实现。
- en: '![](Images/04fig02_alt.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图像 4.2](Images/04fig02_alt.jpg)'
- en: 'This saga consists of the following local transactions:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Saga 包含以下本地事务：
- en: '**`Order Service`—** Create an `Order` in an `APPROVAL_PENDING` state.'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`订单服务`—** 在 `APPROVAL_PENDING` 状态下创建一个 `订单`。'
- en: '**`Consumer Service`—** Verify that the consumer can place an order.'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`消费者服务`—** 验证消费者能否下订单。'
- en: '**`Kitchen Service`—** Validate order details and create a `Ticket` in the
    `CREATE_PENDING`.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`厨房服务`—** 验证订单详情并在 `CREATE_PENDING` 状态下创建一个 `票据`。'
- en: '**`Accounting Service`—** Authorize consumer’s credit card.'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`会计服务`—** 授权消费者信用卡。'
- en: '**`Kitchen Service`—** Change the state of the `Ticket` to `AWAITING_ACCEPTANCE`.'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`厨房服务`—** 将 `票据` 的状态更改为 `AWAITING_ACCEPTANCE`。'
- en: '**`Order Service`—** Change the state of the `Order` to `APPROVED`.'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`订单服务`—** 将 `订单` 的状态更改为 `APPROVED`。'
- en: Later, in [section 4.2](#ch04lev1sec2), I describe how the services that participate
    in a saga communicate using asynchronous messaging. A service publishes a message
    when a local transaction completes. This message then triggers the next step in
    the saga. Not only does using messaging ensure the saga participants are loosely
    coupled, it also guarantees that a saga completes. That’s because if the recipient
    of a message is temporarily unavailable, the message broker buffers the message
    until it can be delivered.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 4.2 节](#ch04lev1sec2) 中，我描述了参与 Sagas 的服务如何使用异步消息进行通信。当本地事务完成时，服务会发布一条消息。然后，这条消息触发
    Saga 的下一步。使用消息不仅确保 Saga 参与者松散耦合，而且还保证了 Saga 的完成。这是因为如果消息的接收者暂时不可用，消息代理会缓冲该消息，直到可以交付。
- en: On the surface, sagas seem straightforward, but there are a few challenges to
    using them. One challenge is the lack of isolation between sagas. [Section 4.3](#ch04lev1sec3)
    describes how to handle this problem. Another challenge is rolling back changes
    when an error occurs. Let’s take a look at how to do that.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，Sagas 看起来很简单，但使用它们时存在一些挑战。一个挑战是 Sagas 之间缺乏隔离性。[第 4.3 节](#ch04lev1sec3)
    描述了如何处理这个问题。另一个挑战是在发生错误时回滚更改。让我们看看如何做到这一点。
- en: Sagas use compensating transactions to roll back changes
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Sagas 使用补偿性交易来回滚更改
- en: A great feature of traditional ACID transactions is that the business logic
    can easily roll back a transaction if it detects the violation of a business rule.
    It executes a `ROLLBACK` statement, and the database undoes all the changes made
    so far. Unfortunately, sagas can’t be automatically rolled back, because each
    step commits its changes to the local database. This means, for example, that
    if the authorization of the credit card fails in the fourth step of the `Create
    Order Saga`, the FTGO application must explicitly undo the changes made by the
    first three steps. You must write what are known as *compensating transactions*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 传统 ACID 事务的一个伟大特性是，如果业务逻辑检测到业务规则违规，它可以轻松地回滚事务。它执行一个 `ROLLBACK` 语句，数据库撤销迄今为止所做的所有更改。不幸的是，saga
    不能自动回滚，因为每个步骤都将更改提交到本地数据库。这意味着，例如，如果 `Create Order Saga` 的第四步中信用卡授权失败，FTGO 应用程序必须显式地撤销前三个步骤所做的更改。你必须编写所谓的
    *补偿事务*。
- en: Suppose that the (*n* + 1)^(th) transaction of a saga fails. The effects of
    the previous *n* transactions must be undone. Conceptually, each of those steps,
    T[i], has a corresponding compensating transaction, C[i], which undoes the effects
    of the T[i]. To undo the effects of those first *n* steps, the saga must execute
    each C[i] in reverse order. The sequence of steps is T[1] ... T[n], C[n] ... C[1],
    as shown in [figure 4.3](#ch04fig03). In this example, T[n+1] fails, which requires
    steps T[1] ... T[n] to be undone.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 saga 的第 (*n* + 1) 次事务失败。前 *n* 次事务的效果必须被撤销。从概念上讲，这些步骤中的每一个，T[i]，都有一个相应的补偿事务，C[i]，它撤销
    T[i] 的效果。为了撤销前 *n* 个步骤的效果，saga 必须以相反的顺序执行每个 C[i]。步骤的顺序是 T[1] ... T[n]，C[n] ...
    C[1]，如图 4.3 所示。在这个例子中，T[n+1] 失败，这要求撤销步骤 T[1] ... T[n]。
- en: Figure 4.3\. When a step of a saga fails because of a business rule violation,
    the saga must explicitly undo the updates made by previous steps by executing
    compensating transactions.
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.3\. 当一个 saga 的步骤因业务规则违规而失败时，saga 必须通过执行补偿事务显式地撤销之前步骤所做的更新。
- en: '![](Images/04fig03_alt.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig03_alt.jpg)'
- en: 'The saga executes the compensation transactions in reverse order of the forward
    transactions: C[n] ... C[1]. The mechanics of sequencing the C[i]s aren’t any
    different than sequencing the T[i]s. The completion of C[i] must trigger the execution
    of C[i-1].'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: saga 以正向事务的相反顺序执行补偿事务：C[n] ... C[1]。C[i] 的排序机制与 T[i] 的排序机制没有任何不同。C[i] 的完成必须触发
    C[i-1] 的执行。
- en: 'Consider, for example, the `Create Order Saga`. This saga can fail for a variety
    of reasons:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑 `Create Order Saga`。这个 saga 可能因多种原因而失败：
- en: The consumer information is invalid or the consumer isn’t allowed to create
    orders.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者信息无效或消费者不允许创建订单。
- en: The restaurant information is invalid or the restaurant is unable to accept
    orders.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 餐厅信息无效或餐厅无法接受订单。
- en: The authorization of the consumer’s credit card fails.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者的信用卡授权失败。
- en: If a local transaction fails, the saga’s coordination mechanism must execute
    compensating transactions that reject the `Order` and possibly the `Ticket`. [Table
    4.1](#ch04table01) shows the compensating transactions for each step of the `Create
    Order Saga`. It’s important to note that not all steps need compensating transactions.
    Read-only steps, such as `verifyConsumerDetails()`, don’t need compensating transactions.
    Nor do steps such as `authorizeCreditCard()` that are followed by steps that always
    succeed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果本地事务失败，saga 的协调机制必须执行补偿事务以拒绝 `Order` 和可能 `Ticket`。[表 4.1](#ch04table01) 显示了
    `Create Order Saga` 每个步骤的补偿事务。重要的是要注意，并非所有步骤都需要补偿事务。只读步骤，如 `verifyConsumerDetails()`，不需要补偿事务。也不需要像
    `authorizeCreditCard()` 这样的步骤，这些步骤后面总是跟随成功的步骤。
- en: Table 4.1\. The compensating transactions for the `Create Order Saga`
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 4.1\. `Create Order Saga` 的补偿事务
- en: '| Step | Service | Transaction | Compensating transaction |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 步骤 | 服务 | 事务 | 补偿事务 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 1 | Order Service | createOrder() | rejectOrder() |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 订单服务 | createOrder() | rejectOrder() |'
- en: '| 2 | Consumer Service | verifyConsumerDetails() | — |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 消费者服务 | verifyConsumerDetails() | — |'
- en: '| 3 | Kitchen Service | createTicket() | rejectTicket() |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 厨房服务 | createTicket() | rejectTicket() |'
- en: '| 4 | Accounting Service | authorizeCreditCard() | — |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 会计服务 | authorizeCreditCard() | — |'
- en: '| 5 | Kitchen Service | approveTicket() | — |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 厨房服务 | approveTicket() | — |'
- en: '| 6 | Order Service | approveOrder() | — |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 订单服务 | approveOrder() | — |'
- en: '[Section 4.3](#ch04lev1sec3) discusses how the first three steps of the `Create
    Order Saga` are termed *compensatable transactions* because they’re followed by
    steps that can fail, how the fourth step is termed the saga’s *pivot transaction*
    because it’s followed by steps that never fail, and how the last two steps are
    termed *retriable transactions* because they always succeed.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[第4.3节](#ch04lev1sec3) 讨论了为什么`创建订单史诗`的前三个步骤被称为*可补偿事务*，因为它们后面跟着可能会失败的步骤，第四步被称为史诗的*枢纽事务*，因为它后面跟着永远不会失败的步骤，以及最后两个步骤被称为*可重试事务*，因为它们总是成功的。'
- en: 'To see how compensating transactions are used, imagine a scenario where the
    authorization of the consumer’s credit card fails. In this scenario, the saga
    executes the following local transactions:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解补偿事务是如何使用的，想象一个场景，其中消费者的信用卡授权失败。在这个场景中，史诗执行以下本地事务：
- en: '**`Order Service`—** Create an `Order` in an `APPROVAL_PENDING` state.'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`订单服务`**— 在`APPROVAL_PENDING`状态下创建一个`Order`。'
- en: '**`Consumer Service`—** Verify that the consumer can place an order.'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`消费者服务`**— 验证消费者能否下订单。'
- en: '**`Kitchen Service`—** Validate order details and create a `Ticket` in the
    `CREATE_PENDING` state.'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`厨房服务`**— 验证订单详情并在`CREATE_PENDING`状态下创建一个`Ticket`。'
- en: '**`Accounting Service`—** Authorize consumer’s credit card, which fails.'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`会计服务`**— 授权消费者的信用卡，但失败了。'
- en: '**`Kitchen Service`—** Change the state of the `Ticket` to `CREATE_REJECTED`.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`厨房服务`**— 将`Ticket`的状态更改为`CREATE_REJECTED`。'
- en: '**`Order Service`—** Change the state of the `Order` to `REJECTED`.'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`订单服务`**— 将`Order`的状态更改为`REJECTED`。'
- en: The fifth and sixth steps are compensating transactions that undo the updates
    made by `Kitchen Service` and `Order Service`, respectively. A saga’s coordination
    logic is responsible for sequencing the execution of forward and compensating
    transactions. Let’s look at how that works.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第五步和第六步是补偿事务，分别撤销了`厨房服务`和`订单服务`所做的更新。史诗的协调逻辑负责序列化执行正向和补偿事务。让我们看看这是如何工作的。
- en: 4.2\. Coordinating sagas
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2\. 协调史诗
- en: 'A saga’s implementation consists of logic that coordinates the steps of the
    saga. When a saga is initiated by system command, the coordination logic must
    select and tell the first saga participant to execute a local transaction. Once
    that transaction completes, the saga’s sequencing coordination selects and invokes
    the next saga participant. This process continues until the saga has executed
    all the steps. If any local transaction fails, the saga must execute the compensating
    transactions in reverse order. There are a couple of different ways to structure
    a saga’s coordination logic:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一个史诗的实现包括协调史诗步骤的逻辑。当一个史诗被系统命令启动时，协调逻辑必须选择并告知第一个史诗参与者执行一个本地事务。一旦该事务完成，史诗的序列协调逻辑会选择并调用下一个史诗参与者。这个过程会一直持续到史诗执行了所有步骤。如果任何本地事务失败，史诗必须以相反的顺序执行补偿事务。有几种不同的方式来构建史诗的协调逻辑：
- en: '***Choreography*—** Distribute the decision making and sequencing among the
    saga participants. They primarily communicate by exchanging events.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***编排*—** 在史诗参与者之间分配决策和序列。他们主要通过交换事件进行通信。'
- en: '***Orchestration*—** Centralize a saga’s coordination logic in a saga orchestrator
    class. A saga *orchestrator* sends command messages to saga participants telling
    them which operations to perform.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***编排*—** 在史诗编排器类中集中史诗的协调逻辑。一个史诗*编排器*向史诗参与者发送命令消息，告诉他们要执行哪些操作。'
- en: Let’s look at each option, starting with choreography.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每个选项，从编排开始。
- en: 4.2.1\. Choreography-based sagas
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.1\. 基于编排的史诗
- en: One way you can implement a saga is by using choreography. When using choreography,
    there’s no central coordinator telling the saga participants what to do. Instead,
    the saga participants subscribe to each other’s events and respond accordingly.
    To show how choreography-based sagas work, I’ll first describe an example. After
    that, I’ll discuss a couple of design issues that you must address. Then I’ll
    discuss the benefits and drawbacks of using choreography.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 实现史诗的一种方式是使用编排。当使用编排时，没有中央协调器告诉史诗参与者做什么。相反，史诗参与者订阅彼此的事件并相应地做出反应。为了展示基于编排的史诗是如何工作的，我将首先描述一个例子。然后，我将讨论你必须解决的一些设计问题。然后，我将讨论使用编排的好处和缺点。
- en: Implementing the Create Order saga using choreography
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用编排实现创建订单史诗
- en: '[Figure 4.4](#ch04fig04) shows the design of the choreography-based version
    of the `Create Order Saga`. The participants communicate by exchanging events.
    Each participant, starting with the `Order Service`, updates its database and
    publishes an event that triggers the next participant.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.4](#ch04fig04)显示了基于编排的`创建订单叙事`的设计。参与者通过交换事件进行通信。每个参与者，从`订单服务`开始，更新其数据库并发布一个触发下一个参与者的事件。'
- en: Figure 4.4\. Implementing the `Create Order Saga` using choreography. The saga
    participants communicate by exchanging events.
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.4。使用编排实现`创建订单叙事`。叙事参与者通过交换事件进行通信。
- en: '![](Images/04fig04_alt.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig04_alt.jpg)'
- en: 'The happy path through this saga is as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个叙事的愉快路径如下：
- en: '`Order Service` creates an `Order` in the `APPROVAL_PENDING` state and publishes
    an `OrderCreated` event.'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`订单服务`在`APPROVAL_PENDING`状态下创建一个`订单`，并发布一个`OrderCreated`事件。'
- en: '`Consumer Service` consumes the `OrderCreated` event, verifies that the consumer
    can place the order, and publishes a `ConsumerVerified` event.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`消费者服务`消费`OrderCreated`事件，验证消费者能否下订单，并发布一个`ConsumerVerified`事件。'
- en: '`Kitchen Service` consumes the `OrderCreated` event, validates the `Order`,
    creates a `Ticket` in a `CREATE_PENDING` state, and publishes the `TicketCreated`
    event.'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`厨房服务`消费`OrderCreated`事件，验证`订单`，在`CREATE_PENDING`状态下创建一个`票据`，并发布`TicketCreated`事件。'
- en: '`Accounting Service` consumes the `OrderCreated` event and creates a `CreditCardAuthorization`
    in a `PENDING` state.'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`会计服务`消费`OrderCreated`事件，并在`PENDING`状态下创建一个`CreditCardAuthorization`。'
- en: '`Accounting Service` consumes the `TicketCreated` and `ConsumerVerified` events,
    charges the consumer’s credit card, and publishes the `CreditCardAuthorized` event.'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`会计服务`消费`TicketCreated`和`ConsumerVerified`事件，对消费者信用卡进行收费，并发布`CreditCardAuthorized`事件。'
- en: '`Kitchen Service` consumes the `CreditCardAuthorized` event and changes the
    state of the `Ticket` to `AWAITING_ACCEPTANCE`.'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`厨房服务`消费`CreditCardAuthorized`事件，并将`票据`的状态更改为`AWAITING_ACCEPTANCE`。'
- en: '`Order Service` receives the `CreditCardAuthorized` events, changes the state
    of the `Order` to `APPROVED`, and publishes an `OrderApproved` event.'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`订单服务`接收`CreditCardAuthorized`事件，将`订单`的状态更改为`APPROVED`，并发布一个`OrderApproved`事件。'
- en: The `Create Order Saga` must also handle the scenario where a saga participant
    rejects the `Order` and publishes some kind of failure event. For example, the
    authorization of the consumer’s credit card might fail. The saga must execute
    the compensating transactions to undo what’s already been done. [Figure 4.5](#ch04fig05)
    shows the flow of events when the `AccountingService` can’t authorize the consumer’s
    credit card.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`创建订单叙事`还必须处理叙事参与者拒绝`订单`并发布某种类型的失败事件的场景。例如，消费者信用卡的授权可能会失败。叙事必须执行补偿性交易以撤销已经完成的事情。[图4.5](#ch04fig05)显示了当`AccountingService`无法授权消费者信用卡时事件流。'
- en: Figure 4.5\. The sequence of events in the `Create Order Saga` when the authorization
    of the consumer’s credit card fails. `Accounting Service` publishes the `Credit
    Card Authorization Failed` event, which causes `Kitchen Service` to reject the
    `Ticket`, and `Order Service` to reject the `Order`.
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.5。当消费者信用卡授权失败时`创建订单叙事`的事件序列。`会计服务`发布`Credit Card Authorization Failed`事件，导致`厨房服务`拒绝`票据`，以及`订单服务`拒绝`订单`。
- en: '![](Images/04fig05_alt.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig05_alt.jpg)'
- en: 'The sequence of events is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 事件序列如下：
- en: '`Order Service` creates an `Order` in the `APPROVAL_PENDING` state and publishes
    an `OrderCreated` event.'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`订单服务`在`APPROVAL_PENDING`状态下创建一个`订单`，并发布一个`OrderCreated`事件。'
- en: '`Consumer Service` consumes the `OrderCreated` event, verifies that the consumer
    can place the order, and publishes a `ConsumerVerified` event.'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`消费者服务`消费`OrderCreated`事件，验证消费者能否下订单，并发布一个`ConsumerVerified`事件。'
- en: '`Kitchen Service` consumes the `OrderCreated` event, validates the `Order`,
    creates a `Ticket` in a `CREATE_PENDING` state, and publishes the `TicketCreated`
    event.'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`厨房服务`消费`OrderCreated`事件，验证`订单`，在`CREATE_PENDING`状态下创建一个`票据`，并发布`TicketCreated`事件。'
- en: '`Accounting Service` consumes the `OrderCreated` event and creates a `CreditCardAuthorization`
    in a `PENDING` state.'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`会计服务`消费`OrderCreated`事件，并在`PENDING`状态下创建一个`CreditCardAuthorization`。'
- en: '`Accounting Service` consumes the `TicketCreated` and `ConsumerVerified` events,
    charges the consumer’s credit card, and publishes a `Credit Card Authorization
    Failed` event.'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`会计服务`消费`TicketCreated`和`ConsumerVerified`事件，对消费者信用卡进行收费，并发布一个`Credit Card
    Authorization Failed`事件。'
- en: '`Kitchen Service` consumes the `Credit Card Authorization Failed` event and
    changes the state of the `Ticket` to `REJECTED`.'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`厨房服务`消费了`信用卡授权失败`事件，并将`票`的状态更改为`已拒绝`。'
- en: '`Order Service` consumes the `Credit Card Authorization Failed` event and changes
    the state of the `Order` to `REJECTED`.'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`订单服务`消费了`信用卡授权失败`事件，并将`订单`的状态更改为`已拒绝`。'
- en: As you can see, the participants of choreography-based sagas interact using
    publish/subscribe. Let’s take a closer look at some issues you’ll need to consider
    when implementing publish/subscribe-based communication for your sagas.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，基于编排的叙事的参与者通过发布/订阅进行交互。让我们更深入地了解一下在为你的叙事实现基于发布/订阅的通信时需要考虑的一些问题。
- en: Reliable event-based communication
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 可靠的事件驱动通信
- en: There are a couple of interservice communication-related issues that you must
    consider when implementing choreography-based sagas. The first issue is ensuring
    that a saga participant updates its database and publishes an event as part of
    a database transaction. Each step of a choreography-based saga updates the database
    and publishes an event. For example, in the `Create Order Saga`, `Kitchen Service`
    receives a `Consumer Verified` event, creates a `Ticket`, and publishes a `Ticket
    Created` event. It’s essential that the database update and the publishing of
    the event happen atomically. Consequently, to communicate reliably, the saga participants
    must use transactional messaging, described in [chapter 3](kindle_split_011.xhtml#ch03).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现基于编排的叙事时，你必须考虑一些与服务间通信相关的问题。第一个问题是确保叙事参与者更新其数据库并发布事件作为数据库事务的一部分。基于编排的叙事的每一步都会更新数据库并发布事件。例如，在`创建订单叙事`中，`厨房服务`接收到`消费者验证`事件，创建一个`票`，并发布一个`票已创建`事件。数据库更新和事件发布的原子性是至关重要的。因此，为了可靠地通信，叙事参与者必须使用事务消息，这在第3章中有所描述。[第3章](kindle_split_011.xhtml#ch03)。
- en: The second issue you need to consider is ensuring that a saga participant must
    be able to map each event that it receives to its own data. For example, when
    `Order Service` receives a `Credit Card Authorized` event, it must be able to
    look up the corresponding `Order.` The solution is for a saga participant to publish
    events containing a *correlation id*, which is data that enables other participants
    to perform the mapping.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个你需要考虑的问题是确保叙事参与者必须能够将接收到的每个事件映射到自己的数据。例如，当`订单服务`接收到`信用卡已授权`事件时，它必须能够查找相应的`订单`。解决方案是让叙事参与者发布包含*关联ID*的事件，这是一种数据，使其他参与者能够执行映射。
- en: For example, the participants of the `Create Order Saga` can use the `orderId`
    as a correlation ID that’s passed from one participant to the next. `Accounting
    Service` publishes a `Credit Card Authorized` event containing the `orderId` from
    the `TicketCreated` event. When `Order Service` receives a `Credit Card Authorized`
    event, it uses the `orderId` to retrieve the corresponding `Order`. Similarly,
    `Kitchen Service` uses the `orderId` from that event to retrieve the corresponding
    `Ticket`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`创建订单叙事`的参与者可以使用`orderId`作为从一位参与者传递到下一位参与者的关联ID。`会计服务`发布一个包含`orderId`的`信用卡已授权`事件，该`orderId`来自`票已创建`事件。当`订单服务`接收到`信用卡已授权`事件时，它使用`orderId`来检索相应的`订单`。同样，`厨房服务`使用该事件中的`orderId`来检索相应的`票`。
- en: Benefits and drawbacks of choreography-based sagas
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基于编排的叙事的优缺点
- en: 'Choreography-based sagas have several benefits:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 基于编排的叙事有以下几个好处：
- en: '***Simplicity*—** Services publish events when they create, update, or delete
    business objects.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***简单性*—** 服务在创建、更新或删除业务对象时发布事件。'
- en: '***Loose coupling*—** The participants subscribe to events and don’t have direct
    knowledge of each other.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***松散耦合*—** 参与者订阅事件，并不直接了解彼此。'
- en: 'And there are some drawbacks:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 并且还有一些缺点：
- en: '***More difficult to understand*—** Unlike with orchestration, there isn’t
    a single place in the code that defines the saga. Instead, choreography distributes
    the implementation of the saga among the services. Consequently, it’s sometimes
    difficult for a developer to understand how a given saga works.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***更难理解*—** 与编排不同，代码中没有单一的地方定义叙事。相反，编排将叙事的实现分布在各个服务中。因此，有时对于开发者来说，理解一个特定的叙事是如何工作的可能很困难。'
- en: '***Cyclic dependencies between the services*—** The saga participants subscribe
    to each other’s events, which often creates cyclic dependencies. For example,
    if you carefully examine [figure 4.4](#ch04fig04), you’ll see that there are cyclic
    dependencies, such as `Order Service` → `Accounting Service` → `Order Service`.
    Although this isn’t necessarily a problem, cyclic dependencies are considered
    a design smell.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***服务之间的循环依赖*—** 叙事参与者订阅彼此的事件，这通常会产生循环依赖。例如，如果你仔细检查[图4.4](#ch04fig04)，你会看到循环依赖，例如`Order
    Service` → `Accounting Service` → `Order Service`。尽管这不一定是一个问题，但循环依赖被认为是设计上的一个坏味道。'
- en: '***Risk of tight coupling*—** Each saga participant needs to subscribe to all
    events that affect them. For example, `Accounting Service` must subscribe to all
    events that cause the consumer’s credit card to be charged or refunded. As a result,
    there’s a risk that it would need to be updated in lockstep with the order lifecycle
    implemented by `Order Service`.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***紧密耦合的风险*—** 每个叙事参与者都需要订阅影响它们的所有事件。例如，`Accounting Service`必须订阅所有导致消费者信用卡被收费或退款的操作。因此，它可能需要与`Order
    Service`实现的订单生命周期同步更新。'
- en: Choreography can work well for simple sagas, but because of these drawbacks
    it’s often better for more complex sagas to use orchestration. Let’s look at how
    orchestration works.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 舞台编排（Choreography）对于简单的叙事可能效果很好，但由于这些缺点，对于更复杂的叙事，通常更好的做法是使用编排。让我们看看编排是如何工作的。
- en: 4.2.2\. Orchestration-based sagas
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.2\. 基于编排的叙事
- en: Orchestration is another way to implement sagas. When using orchestration, you
    define an orchestrator class whose sole responsibility is to tell the saga participants
    what to do. The saga orchestrator communicates with the participants using command/async
    reply-style interaction. To execute a saga step, it sends a command message to
    a participant telling it what operation to perform. After the saga participant
    has performed the operation, it sends a reply message to the orchestrator. The
    orchestrator then processes the message and determines which saga step to perform
    next.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 编排（Orchestration）是实现叙事（sagas）的另一种方式。当使用编排时，你定义一个编排器（orchestrator）类，其唯一责任是告诉叙事参与者他们应该做什么。叙事编排器通过命令/异步回复风格的交互与参与者进行通信。为了执行叙事步骤，它向参与者发送一个命令消息，告诉他们要执行的操作。在叙事参与者执行了操作之后，它向编排器发送一个回复消息。然后编排器处理该消息并确定下一个要执行的叙事步骤。
- en: To show how orchestration-based sagas work, I’ll first describe an example.
    Then I’ll describe how to model orchestration-based sagas as state machines. I’ll
    discuss how to make use of transactional messaging to ensure reliable communication
    between the saga orchestrator and the saga participants. I’ll then describe the
    benefits and drawbacks of using orchestration-based sagas.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示基于编排的叙事是如何工作的，我首先将描述一个示例。然后，我将描述如何将基于编排的叙事建模为状态机。我将讨论如何利用事务消息确保叙事编排器和叙事参与者之间可靠的通信。然后，我将描述使用基于编排的叙事的优缺点。
- en: Implementing the Create Order saga using orchestration
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用编排实现创建订单叙事（Create Order saga）
- en: '[Figure 4.6](#ch04fig06) shows the design of the orchestration-based version
    of the `Create Order Saga`. The saga is orchestrated by the `CreateOrderSaga`
    class, which invokes the saga participants using asynchronous request/response.
    This class keeps track of the process and sends command messages to saga participants,
    such as `Kitchen Service` and `Consumer Service`. The `CreateOrderSaga` class
    reads reply messages from its reply channel and then determines the next step,
    if any, in the saga.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.6](#ch04fig06)展示了基于编排的`Create Order Saga`的设计。叙事由`CreateOrderSaga`类编排，该类使用异步请求/响应调用叙事参与者。这个类跟踪流程并向叙事参与者发送命令消息，例如`Kitchen
    Service`和`Consumer Service`。`CreateOrderSaga`类从其回复通道读取回复消息，然后确定叙事中的下一步，如果有的话。'
- en: Figure 4.6\. Implementing the `Create Order Saga` using orchestration. `Order
    Service` implements a saga orchestrator, which invokes the saga participants using
    asynchronous request/response.
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.6\. 使用编排实现`Create Order Saga`。`Order Service`实现一个叙事编排器，使用异步请求/响应调用叙事参与者。
- en: '![](Images/04fig06_alt.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig06_alt.jpg)'
- en: '`Order Service` first creates an `Order` and a `Create Order Saga` orchestrator.
    After that, the flow for the happy path is as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`Order Service`首先创建一个`Order`和一个`Create Order Saga`编排器。之后，对于愉快的路径流程如下：'
- en: The saga orchestrator sends a `Verify Consumer` command to `Consumer Service`.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 叙事编排器向`Consumer Service`发送一个`Verify Consumer`命令。
- en: '`Consumer Service` replies with a `Consumer Verified` message.'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`消费者服务`回复一个`消费者已验证`的消息。'
- en: The saga orchestrator sends a `Create Ticket` command to `Kitchen Service`.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 叙事协调器向`厨房服务`发送一个`创建票据`的命令。
- en: '`Kitchen Service` replies with a `Ticket Created` message.'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`厨房服务`回复一个`创建票据`的消息。'
- en: The saga orchestrator sends an `Authorize Card` message to `Accounting Service`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 叙事协调器向`会计服务`发送一个`授权卡`的消息。
- en: '`Accounting Service` replies with a `Card Authorized` message.'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`会计服务`回复一个`卡已授权`的消息。'
- en: The saga orchestrator sends an `Approve Ticket` command to `Kitchen Service`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 叙事协调器向`厨房服务`发送一个`批准票据`的命令。
- en: The saga orchestrator sends an `Approve Order` command to `Order Service`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 叙事协调器向`订单服务`发送一个`批准订单`的命令。
- en: Note that in final step, the saga orchestrator sends a command message to `Order
    Service`, even though it’s a component of `Order Service`. In principle, the `Create
    Order Saga` could approve the `Order` by updating it directly. But in order to
    be consistent, the saga treats `Order Service` as just another participant.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在最后一步，叙事协调器向`订单服务`发送一个命令消息，即使它也是`订单服务`的一个组件。原则上，`创建订单叙事`可以通过直接更新来批准`订单`。但为了保持一致性，叙事将`订单服务`视为另一个参与者。
- en: Diagrams such as [figure 4.6](#ch04fig06) each depict one scenario for a saga,
    but a saga is likely to have numerous scenarios. For example, the `Create Order
    Saga` has four scenarios. In addition to the happy path, the saga can fail due
    to a failure in either `Consumer Service`, `Kitchen Service`, or `Accounting Service`.
    It’s useful, therefore, to model a saga as a state machine, because it describes
    all possible scenarios.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图4.6](#ch04fig06)所示的图表，每个都描述了一个叙事的场景，但一个叙事可能有许多场景。例如，`创建订单叙事`有四个场景。除了快乐路径外，叙事还可能因为`消费者服务`、`厨房服务`或`会计服务`中的任何一个失败而失败。因此，将叙事建模为状态机是有用的，因为它描述了所有可能的情况。
- en: Modeling saga orchestrators as state machines
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将叙事协调器建模为状态机
- en: A good way to model a saga orchestrator is as a state machine. A *state machine*
    consists of a set of states and a set of transitions between states that are triggered
    by events. Each transition can have an action, which for a saga is the invocation
    of a saga participant. The transitions between states are triggered by the completion
    of a local transaction performed by a saga participant. The current state and
    the specific outcome of the local transaction determine the state transition and
    what action, if any, to perform. There are also effective testing strategies for
    state machines. As a result, using a state machine model makes designing, implementing,
    and testing sagas easier.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个叙事协调器建模为一个状态机是一个好方法。一个*状态机*由一组状态和一组由事件触发的状态转换组成。每个转换可以有一个动作，对于一个叙事来说，这个动作就是调用一个叙事参与者。状态之间的转换是由一个叙事参与者执行的一个本地事务的完成触发的。当前状态和本地事务的具体结果决定了状态转换以及是否执行某个动作。对于状态机也有有效的测试策略。因此，使用状态机模型使得设计、实现和测试叙事变得更加容易。
- en: '[Figure 4.7](#ch04fig07) shows the state machine model for the `Create Order
    Saga`. This state machine consists of numerous states, including the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.7](#ch04fig07)显示了`创建订单叙事`的状态机模型。这个状态机由许多状态组成，包括以下内容：'
- en: '**`Verifying Consumer`—** The initial state. When in this state, the saga is
    waiting for the `Consumer Service` to verify that the consumer can place the order.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`验证消费者`—** 初始状态。当处于此状态时，叙事正在等待`消费者服务`验证消费者能否下订单。'
- en: '**`Creating Ticket`—** The saga is waiting for a reply to the `Create Ticket`
    command.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`创建票据`—** 叙事正在等待对`创建票据`命令的回复。'
- en: '**`Authorizing Card`—** Waiting for `Accounting Service` to authorize the consumer’s
    credit card.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`授权卡`—** 等待`会计服务`授权消费者的信用卡。'
- en: '**`Order Approved`—** A final state indicating that the saga completed successfully.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`订单批准`—** 表示叙事成功完成的最终状态。'
- en: '**`Order Rejected`—** A final state indicating that the `Order` was rejected
    by one of the participants.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`订单拒绝`—** 表示`订单`被参与者之一拒绝的最终状态。'
- en: Figure 4.7\. The state machine model for the `Create Order Saga`
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.7\. `创建订单叙事`的状态机模型
- en: '![](Images/04fig07_alt.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig07_alt.jpg)'
- en: The state machine also defines numerous state transitions. For example, the
    state machine transitions from the `Creating Ticket` state to either the `Authorizing
    Card` or the `Rejected Order` state. It transitions to the `Authorizing Card`
    state when it receives a successful reply to the `Create Ticket` command. Alternatively,
    if `Kitchen Service` couldn’t create the `Ticket`, the state machine transitions
    to the `Rejected Order` state.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机还定义了众多状态转换。例如，状态机从“创建票据”状态转换到“授权卡片”或“拒绝订单”状态。当它收到对“创建票据”命令的成功回复时，它转换到“授权卡片”状态。或者，如果“厨房服务”无法创建“票据”，状态机转换到“拒绝订单”状态。
- en: The state machine’s initial action is to send the `VerifyConsumer` command to
    `Consumer Service`. The response from `Consumer Service` triggers the next state
    transition. If the consumer was successfully verified, the saga creates the `Ticket`
    and transitions to the `Creating Ticket` state. But if the consumer verification
    failed, the saga rejects the `Order` and transitions to the `Rejecting Order`
    state. The state machine undergoes numerous other state transitions, driven by
    the responses from saga participants, until it reaches a final state of either
    `Order Approved` or `Order Rejected`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机的初始动作是向“消费者服务”发送“验证消费者”命令。来自“消费者服务”的回复触发下一个状态转换。如果消费者验证成功，叙事创建“票据”并转换到“创建票据”状态。但如果消费者验证失败，叙事拒绝“订单”并转换到“拒绝订单”状态。状态机经历众多其他状态转换，由叙事参与者的回复驱动，直到达到“订单批准”或“订单拒绝”的最终状态。
- en: Saga orchestration and transactional messaging
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 叙事编排和事务消息
- en: Each step of an orchestration-based saga consists of a service updating a database
    and publishing a message. For example, `Order Service` persists an `Order` and
    a `Create Order Saga` orchestrator and sends a message to the first saga participant.
    A saga participant, such as `Kitchen Service`, handles a command message by updating
    its database and sending a reply message. `Order Service` processes the participant’s
    reply message by updating the state of the saga orchestrator and sending a command
    message to the next saga participant. As described in [chapter 3](kindle_split_011.xhtml#ch03),
    a service must use transactional messaging in order to atomically update the database
    and publish messages. Later on in [section 4.4](#ch04lev1sec4), I’ll describe
    the implementation of the `Create Order Saga` orchestrator in more detail, including
    how it uses transaction messaging.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 基于编排的叙事的每一步都包括一个服务更新数据库并发布消息。例如，“订单服务”持久化“订单”和“创建订单叙事编排器”，并发送消息给第一个叙事参与者。叙事参与者，如“厨房服务”，通过更新其数据库并发送回复消息来处理命令消息。“订单服务”通过更新叙事编排器的状态并发送命令消息到下一个叙事参与者来处理参与者的回复消息。如[第3章](kindle_split_011.xhtml#ch03)所述，一个服务必须使用事务消息才能原子性地更新数据库并发布消息。稍后，在[第4.4节](#ch04lev1sec4)中，我将更详细地描述“创建订单叙事编排器”的实现，包括它如何使用事务消息。
- en: Let’s take a look at the benefits and drawbacks of using saga orchestration.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看使用叙事编排的优缺点。
- en: Benefits and drawbacks of orchestration-based sagas
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基于编排的叙事的优缺点
- en: 'Orchestration-based sagas have several benefits:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 基于编排的叙事有几个好处：
- en: '***Simpler dependencies*—** One benefit of orchestration is that it doesn’t
    introduce cyclic dependencies. The saga orchestrator invokes the saga participants,
    but the participants don’t invoke the orchestrator. As a result, the orchestrator
    depends on the participants but not vice versa, and so there are no cyclic dependencies.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***更简单的依赖关系*—**编排的一个好处是它不会引入循环依赖。叙事编排器调用叙事参与者，但参与者不会调用编排器。因此，编排器依赖于参与者，但反之则不然，因此没有循环依赖。'
- en: '***Less coupling*—** Each service implements an API that is invoked by the
    orchestrator, so it does not need to know about the events published by the saga
    participants.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***更少的耦合*—**每个服务实现了一个由编排器调用的API，因此它不需要了解叙事参与者发布的事件。'
- en: '***Improves separation of concerns and simplifies the business logic*—** The
    saga coordination logic is localized in the saga orchestrator. The domain objects
    are simpler and have no knowledge of the sagas that they participate in. For example,
    when using orchestration, the `Order` class has no knowledge of any of the sagas,
    so it has a simpler state machine model. During the execution of the `Create Order
    Saga`, it transitions directly from the `APPROVAL_PENDING` state to the `APPROVED`
    state. The `Order` class doesn’t have any intermediate states corresponding to
    the steps of the saga. As a result, the business is much simpler.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***提高关注点的分离并简化业务逻辑*—** 悲剧协调逻辑位于悲剧编排器中。领域对象更简单，并且不知道它们参与的悲剧。例如，当使用编排时，`Order`
    类不知道任何悲剧，因此它有一个更简单的状态机模型。在执行 `Create Order Saga` 的过程中，它直接从 `APPROVAL_PENDING`
    状态过渡到 `APPROVED` 状态。`Order` 类没有与悲剧步骤相对应的任何中间状态。因此，业务变得更加简单。'
- en: 'Orchestration also has a drawback: the risk of centralizing too much business
    logic in the orchestrator. This results in a design where the smart orchestrator
    tells the dumb services what operations to do. Fortunately, you can avoid this
    problem by designing orchestrators that are solely responsible for sequencing
    and don’t contain any other business logic.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 编排也有一个缺点：将过多的业务逻辑集中在编排器中的风险。这导致了一种设计，其中智能编排器告诉愚蠢的服务要执行的操作。幸运的是，你可以通过设计仅负责排序而不包含任何其他业务逻辑的编排器来避免这个问题。
- en: I recommend using orchestration for all but the simplest sagas. Implementing
    the coordination logic for your sagas is just one of the design problems you need
    to solve. Another, which is perhaps the biggest challenge that you’ll face when
    using sagas, is handling the lack of isolation. Let’s take a look at that problem
    and how to solve it.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议除了最简单的悲剧之外，都使用编排。实现你的悲剧的协调逻辑只是你需要解决的设计问题之一。另一个，可能是你在使用悲剧时面临的最大挑战，是处理缺乏隔离。让我们看看这个问题以及如何解决它。
- en: 4.3\. Handling the lack of isolation
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3\. 处理缺乏隔离
- en: The *I* in ACID stands for *isolation*. The isolation property of ACID transactions
    ensures that the outcome of executing multiple transactions concurrently is the
    same as if they were executed in some serial order. The database provides the
    illusion that each ACID transaction has exclusive access to the data. Isolation
    makes it a lot easier to write business logic that executes concurrently.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ACID中的*I*代表*隔离*。ACID事务的隔离属性确保并发执行多个事务的结果与它们按某种顺序执行的结果相同。数据库提供了每个ACID事务对数据具有独占访问的错觉。隔离使得编写并发执行的业务逻辑变得容易得多。
- en: 'The challenge with using sagas is that they lack the isolation property of
    ACID transactions. That’s because the updates made by each of a saga’s local transactions
    are immediately visible to other sagas once that transaction commits. This behavior
    can cause two problems. First, other sagas can change the data accessed by the
    saga while it’s executing. And other sagas can read its data before the saga has
    completed its updates, and consequently can be exposed to inconsistent data. You
    can, in fact, consider a saga to be ACD:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用悲剧的挑战在于它们缺乏ACID事务的隔离属性。这是因为悲剧的每个本地事务所做的更新一旦提交，就会立即对其他悲剧可见。这种行为可能导致两个问题。首先，其他悲剧可以在悲剧执行时更改悲剧访问的数据。并且其他悲剧可以在悲剧完成更新之前读取其数据，因此可能会暴露在不一致的数据中。实际上，你可以将悲剧视为ACD：
- en: '***Atomicity*—** The saga implementation ensures that all transactions are
    executed or all changes are undone.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***原子性*—** 悲剧式实现确保所有事务都执行或所有更改都撤销。'
- en: '***Consistency*—** Referential integrity within a service is handled by local
    databases. Referential integrity across services is handled by the services.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***一致性*—** 服务内的引用完整性由本地数据库处理。服务之间的引用完整性由服务处理。'
- en: '***Durability*—** Handled by local databases.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***耐用性*—** 由本地数据库处理。'
- en: This lack of isolation potentially causes what the database literature calls
    *anomalies*. An anomaly is when a transaction reads or writes data in a way that
    it wouldn’t if transactions were executed one at time. When an anomaly occurs,
    the outcome of executing sagas concurrently is different than if they were executed
    serially.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这种缺乏隔离可能导致数据库文献中称为*异常*的情况。异常是指事务以它不会在单个事务执行时的方式读取或写入数据。当发生异常时，并发执行悲剧的结果与它们按顺序执行的结果不同。
- en: On the surface, the lack of isolation sounds unworkable. But in practice, it’s
    common for developers to accept reduced isolation in return for higher performance.
    An RDBMS lets you specify the isolation level for each transaction ([https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html](https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html)).
    The default isolation level is usually an isolation level that’s weaker than full
    isolation, also known as serializable transactions. Real-world database transactions
    are often different from textbook definitions of ACID transactions.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，缺乏隔离性似乎不可行。但在实践中，开发者为了获得更高的性能，通常愿意接受降低隔离性。关系型数据库管理系统（RDBMS）允许你为每个事务指定隔离级别（[https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html](https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html)）。默认的隔离级别通常是一个比完全隔离更弱的隔离级别，也称为可序列化事务。现实世界的数据库事务通常与教科书中
    ACID 事务的定义不同。
- en: The next section discusses a set of saga design strategies that deal with the
    lack of isolation. These strategies are known as *countermeasures*. Some countermeasures
    implement isolation at the application level. Other countermeasures reduce the
    business risk of the lack of isolation. By using countermeasures, you can write
    saga-based business logic that works correctly.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将讨论一系列处理缺乏隔离性的 saga 设计策略。这些策略被称为*对策*。一些对策在应用层面实现隔离性。其他对策降低了缺乏隔离性的业务风险。通过使用对策，你可以编写基于
    saga 的业务逻辑，使其正确运行。
- en: I’ll begin the section by describing the anomalies that are caused by the lack
    of isolation. After that, I’ll talk about countermeasures that either eliminate
    those anomalies or reduce their business risk.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先描述由缺乏隔离性引起的异常。之后，我将讨论消除这些异常或降低其业务风险的对策。
- en: 4.3.1\. Overview of anomalies
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.1\. 异常概述
- en: 'The lack of isolation can cause the following three anomalies:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 缺乏隔离性可能导致以下三种异常：
- en: '***Lost updates*—** One saga overwrites without reading changes made by another
    saga.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***丢失更新*—** 一个 saga 在没有读取另一个 saga 所做的更改的情况下进行覆盖。'
- en: '***Dirty reads*—** A transaction or a saga reads the updates made by a saga
    that has not yet completed those updates.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***脏读*—** 一个事务或 saga 读取了尚未完成更新的 saga 所做的更新。'
- en: '***Fuzzy/nonrepeatable reads*—** Two different steps of a saga read the same
    data and get different results because another saga has made updates.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***模糊/不可重复读取*—** saga 的两个不同步骤读取相同的数据并得到不同的结果，因为另一个 saga 已经进行了更新。'
- en: All three anomalies can occur, but the first two are the most common and the
    most challenging. Let’s take a look at those two types of anomaly, starting with
    lost updates.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种异常都可能发生，但前两种最常见且最具挑战性。让我们先看看这两种类型的异常，从丢失更新开始。
- en: Lost updates
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 丢失更新
- en: 'A lost update anomaly occurs when one saga overwrites an update made by another
    saga. Consider, for example, the following scenario:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 saga 覆盖了另一个 saga 所做的更新时，就会发生丢失更新异常。例如，考虑以下场景：
- en: The first step of the `Create Order Saga` creates an `Order`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Create Order Saga` 的第一步是创建一个 `Order`。'
- en: While that saga is executing, the `Cancel Order Saga` cancels the `Order`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当那个 saga 执行时，`Cancel Order Saga` 取消了 `Order`。
- en: The final step of the `Create Order Saga` approves the `Order`.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Create Order Saga` 的最后一步是批准 `Order`。'
- en: In this scenario, the `Create Order Saga` ignores the update made by the `Cancel
    Order Saga` and overwrites it. As a result, the FTGO application will ship an
    order that the customer had cancelled. Later in this section, I’ll show how to
    prevent lost updates.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，`Create Order Saga` 忽略了 `Cancel Order Saga` 所做的更新并将其覆盖。因此，FTGO 应用程序将发货给客户已取消的订单。在本节稍后，我将展示如何防止丢失更新。
- en: Dirty reads
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 脏读
- en: 'A dirty read occurs when one saga reads data that’s in the middle of being
    updated by another saga. Consider, for example, a version of the FTGO application
    store where consumers have a credit limit. In this application, a saga that cancels
    an order consists of the following transactions:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 saga 读取另一个 saga 正在更新的数据时，就会发生脏读。例如，考虑一个 FTGO 应用程序存储版本，其中消费者有一个信用额度。在这个应用程序中，取消订单的
    saga 由以下事务组成：
- en: '**`Consumer Service`—** Increase the available credit.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`Consumer Service`—** 增加可用信用额度。'
- en: '**`Order Service`—** Change the state of the `Order` to cancelled.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`Order Service`—** 将 `Order` 的状态更改为已取消。'
- en: '**`Delivery Service`—** Cancel the delivery.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`Delivery Service`—** 取消配送。'
- en: 'Let’s imagine a scenario that interleaves the execution of the `Cancel Order`
    and `Create Order Saga`s, and the `Cancel Order Saga` is rolled back because it’s
    too late to cancel the delivery. It’s possible that the sequence of transactions
    that invoke the `Consumer Service` is as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个场景，其中`取消订单`和`创建订单叙事`的执行交织在一起，并且由于取消交货太晚，`取消订单叙事`被回滚。可能调用`消费者服务`的事务序列如下：
- en: '**`Cancel Order Saga`—** Increase the available credit.'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`取消订单叙事`—** 增加可用信用。'
- en: '**`Create Order Saga`—** Reduce the available credit.'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`创建订单叙事`—** 减少可用信用。'
- en: '**`Cancel Order Saga`—** A compensating transaction that reduces the available
    credit.'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`取消订单叙事`—** 减少可用信用的补偿性交易。'
- en: In this scenario, the `Create Order Saga` does a dirty read of the available
    credit that enables the consumer to place an order that exceeds their credit limit.
    It’s likely that this is an unacceptable risk to the business.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`创建订单叙事`对可用信用进行了脏读，使得消费者可以放置超过其信用额的订单。这很可能是对业务不可接受的风险。
- en: Let’s look at how to prevent this and other kinds of anomalies from impacting
    an application.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何防止这种情况以及其他类型的异常影响应用程序。
- en: 4.3.2\. Countermeasures for handling the lack of isolation
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.2\. 处理隔离不足的对策
- en: The saga transaction model is ACD, and its lack of isolation can result in anomalies
    that cause applications to misbehave. It’s the responsibility of the developer
    to write sagas in a way that either prevents the anomalies or minimizes their
    impact on the business. This may sound like a daunting task, but you’ve already
    seen an example of a strategy that prevents anomalies. An `Order`’s use of `*_PENDING`
    states, such as `APPROVAL_PENDING`, is an example of one such strategy. Sagas
    that update `Orders`, such as the `Create Order Saga`, begin by setting the state
    of an `Order` to `*_PENDING`. The `*_PENDING` state tells other transactions that
    the `Order` is being updated by a saga and to act accordingly.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 叙事事务模型是ACD，其隔离不足可能导致导致应用程序行为异常的异常。开发者有责任编写叙事，以防止异常或最小化其对业务的影响。这听起来可能是一项艰巨的任务，但你已经看到了一个防止异常的策略的例子。`订单`使用`*_PENDING`状态，例如`APPROVAL_PENDING`，是这种策略的一个例子。更新`订单`的叙事，如`创建订单叙事`，首先将`订单`的状态设置为`*_PENDING`。`*_PENDING`状态告诉其他事务，`订单`正在由叙事更新，并相应地采取行动。
- en: 'An `Order`’s use of `*_PENDING` states is an example of what the 1998 paper
    “Semantic ACID properties in multidatabases using remote procedure calls and update
    propagations” by Lars Frank and Torben U. Zahle calls a *semantic lock countermeasure*
    ([https://dl.acm.org/citation.cfm?id=284472.284478](https://dl.acm.org/citation.cfm?id=284472.284478)).
    The paper describes how to deal with the lack of transaction isolation in multi-database
    architectures that don’t use distributed transactions. Many of its ideas are useful
    when designing sagas. It describes a set of countermeasures for handling anomalies
    caused by lack of isolation that either prevent one or more anomalies or minimize
    their impact on the business. The countermeasures described by this paper are
    as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`订单`使用`*_PENDING`状态是Lars Frank和Torben U. Zahle于1998年发表的论文“使用远程过程调用和更新传播在多数据库中实现语义ACID属性”中称为*语义锁对策*的例子（[https://dl.acm.org/citation.cfm?id=284472.284478](https://dl.acm.org/citation.cfm?id=284472.284478)）。该论文描述了如何处理不使用分布式事务的多数据库架构中事务隔离不足的问题。其中许多想法在设计叙事时很有用。它描述了一系列处理由隔离不足引起的异常的对策，这些对策要么防止一个或多个异常，要么最小化其对业务的影响。该论文描述的对策如下：'
- en: '***Semantic lock*—** An application-level lock.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***语义锁*—** 应用级别的锁。'
- en: '***Commutative updates*—** Design update operations to be executable in any
    order.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***交换更新*—** 设计更新操作，使其可以按任何顺序执行。'
- en: '***Pessimistic view*—** Reorder the steps of a saga to minimize business risk.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***悲观视图*—** 重新排序叙事的步骤以最小化业务风险。'
- en: '***Reread value*—** Prevent dirty writes by rereading data to verify that it’s
    unchanged before overwriting it.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***重读值*—** 通过重新读取数据以验证在覆盖之前它未更改来防止脏写。'
- en: '***Version file*—** Record the updates to a record so that they can be reordered.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***版本文件*—** 记录记录的更新，以便可以重新排序。'
- en: '***By value*—** Use each request’s business risk to dynamically select the
    concurrency mechanism.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***按值*—** 使用每个请求的业务风险动态选择并发机制。'
- en: Later in this section, I describe each of these countermeasures, but first I
    want to introduce some terminology for describing the structure of a saga that’s
    useful when discussing countermeasures.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的后面部分，我将描述这些对策中的每一个，但首先我想介绍一些术语，用于描述 Saga 的结构，这在讨论对策时很有用。
- en: The structure of a saga
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Saga 的结构
- en: 'The countermeasures paper mentioned in the last section defines a useful model
    for the structure of a saga. In this model, shown in [figure 4.8](#ch04fig08),
    a saga consists of three types of transactions:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 上节中提到的对策论文定义了一个用于 Saga 结构的有用模型。在这个模型中，如图 4.8 所示，一个 Saga 由三种类型的事务组成：
- en: '***Compensatable transactions*—** Transactions that can potentially be rolled
    back using a compensating transaction.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***可补偿事务*—** 可以使用补偿事务潜在地回滚的事务。'
- en: '***Pivot transaction*—** The go/no-go point in a saga. If the pivot transaction
    commits, the saga will run until completion. A pivot transaction can be a transaction
    that’s neither compensatable nor retriable. Alternatively, it can be the last
    compensatable transaction or the first retriable transaction.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***枢纽事务*—** Saga 中的启动/停止点。如果枢纽事务提交，则 Saga 将运行至完成。枢纽事务可以既不是可补偿的也不是可重试的事务。或者，它可以是最后一个可补偿事务或第一个可重试事务。'
- en: '***Retriable transactions*—** Transactions that follow the pivot transaction
    and are guaranteed to succeed.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***可重试事务*—** 沿着枢纽事务进行的、有保证成功的事务。'
- en: 'Figure 4.8\. A saga consists of three different types of transactions: compensatable
    transactions, which can be rolled back, so have a compensating transaction, a
    pivot transaction, which is the saga’s go/no-go point, and retriable transactions,
    which are transactions that don’t need to be rolled back and are guaranteed to
    complete.'
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.8\. Saga 由三种不同类型的事务组成：可补偿事务，可以回滚，因此有补偿事务；枢纽事务，是 Saga 的启动/停止点；可重试事务，是不需要回滚且保证完成的事务。
- en: '![](Images/04fig08_alt.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/04fig08_alt.jpg)'
- en: In the `Create Order Saga`, the `createOrder()`, `verifyConsumerDetails()`,
    and `createTicket()` steps are compensatable transactions. The `createOrder()`
    and `createTicket()` transactions have compensating transactions that undo their
    updates. The `verifyConsumerDetails()` transaction is read-only, so doesn’t need
    a compensating transaction. The `authorizeCreditCard()` transaction is this saga’s
    pivot transaction. If the consumer’s credit card can be authorized, this saga
    is guaranteed to complete. The `approveTicket()` and `approveOrder()` steps are
    retriable transactions that follow the pivot transaction.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Create Order Saga` 中，`createOrder()`、`verifyConsumerDetails()` 和 `createTicket()`
    步骤是可补偿事务。`createOrder()` 和 `createTicket()` 事务有补偿事务来撤销它们的更新。`verifyConsumerDetails()`
    事务是只读的，因此不需要补偿事务。`authorizeCreditCard()` 事务是这个 Saga 的枢纽事务。如果消费者的信用卡可以被授权，那么这个
    Saga 就有保证完成。`approveTicket()` 和 `approveOrder()` 步骤是跟随枢纽事务的可重试事务。
- en: The distinction between compensatable transactions and retriable transactions
    is especially important. As you’ll see, each type of transaction plays a different
    role in the countermeasures. [Chapter 13](kindle_split_021.xhtml#ch13) states
    that when migrating to microservices, the monolith must sometimes participate
    in sagas and that it’s significantly simpler if the monolith only ever needs to
    execute retriable transactions.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 可补偿事务和可重试事务之间的区别特别重要。正如您将看到的，每种类型的事务在对策中扮演着不同的角色。[第 13 章](kindle_split_021.xhtml#ch13)
    指出，在迁移到微服务时，单体有时必须参与 Saga，如果单体只需要执行可重试事务，那么这会显著简化。
- en: Let’s now look at each countermeasure, starting with the semantic lock countermeasure.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来逐一查看每种对策，首先是语义锁对策。
- en: 'Countermeasure: Semantic lock'
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 对策：语义锁
- en: 'When using the semantic lock countermeasure, a saga’s compensatable transaction
    sets a flag in any record that it creates or updates. The flag indicates that
    the record isn’t *committed* and could potentially change. The flag can either
    be a lock that prevents other transactions from accessing the record or a warning
    that indicates that other transactions should treat that record with suspicion.
    It’s cleared by either a retriable transaction—saga is completing successfully—or
    by a compensating transaction: the saga is rolling back.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用语义锁对策时，叙事的可补偿性事务会在它创建或更新的任何记录中设置一个标志。该标志表示记录尚未*提交*并且可能发生变化。该标志可以是防止其他事务访问记录的锁，或者是一个警告，表明其他事务应该对该记录持怀疑态度。它可以通过可重试的事务（叙事成功完成）或补偿性事务（叙事正在回滚）来清除。
- en: The `Order.state` field is a great example of a semantic lock. The `*_PENDING`
    states, such as `APPROVAL_PENDING` and `REVISION_PENDING`, implement a semantic
    lock. They tell other sagas that access an `Order` that a saga is in the process
    of updating the `Order`. For instance, the first step of the `Create Order Saga`,
    which is a compensatable transaction, creates an `Order` in an `APPROVAL_PENDING`
    state. The final step of the `Create Order Saga`, which is a retriable transaction,
    changes the field to `APPROVED`. A compensating transaction changes the field
    to `REJECTED`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`Order.state`字段是语义锁的一个很好的例子。`*_PENDING`状态，如`APPROVAL_PENDING`和`REVISION_PENDING`，实现了语义锁。它们告诉访问`Order`的其他叙事，叙事正在更新`Order`。例如，`Create
    Order Saga`的第一个步骤，这是一个可补偿性事务，在`APPROVAL_PENDING`状态下创建一个`Order`。`Create Order Saga`的最终步骤，这是一个可重试的事务，将字段更改为`APPROVED`。补偿性事务将字段更改为`REJECTED`。'
- en: Managing the lock is only half the problem. You also need to decide on a case-by-case
    basis how a saga should deal with a record that has been locked. Consider, for
    example, the `cancelOrder()` system command. A client might invoke this operation
    to cancel an `Order` that’s in the `APPROVAL_PENDING` state.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 管理锁只是问题的一半。你还需要根据具体情况决定叙事应该如何处理被锁定的记录。例如，考虑`cancelOrder()`系统命令。客户端可能会调用此操作来取消处于`APPROVAL_PENDING`状态的`Order`。
- en: There are a few different ways to handle this scenario. One option is for the
    `cancelOrder()` system command to fail and tell the client to try again later.
    The main benefit of this approach is that it’s simple to implement. The drawback,
    however, is that it makes the client more complex because it has to implement
    retry logic.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这种场景有几种不同的方法。一个选项是让`cancelOrder()`系统命令失败，并告诉客户端稍后重试。这种方法的主要好处是易于实现。然而，缺点是它使客户端变得更加复杂，因为它必须实现重试逻辑。
- en: Another option is for `cancelOrder()` to block until the lock is released. A
    benefit of using semantic locks is that they essentially recreate the isolation
    provided by ACID transactions. Sagas that update the same record are serialized,
    which significantly reduces the programming effort. Another benefit is that they
    remove the burden of retries from the client. The drawback is that the application
    must manage locks. It must also implement a deadlock detection algorithm that
    performs a rollback of a saga to break a deadlock and re-execute it.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是让`cancelOrder()`方法阻塞，直到锁被释放。使用语义锁的好处是它们本质上重新创建了ACID事务提供的隔离性。更新相同记录的叙事是序列化的，这显著减少了编程工作量。另一个好处是它们从客户端移除了重试的负担。缺点是应用程序必须管理锁。它还必须实现一个死锁检测算法，该算法通过回滚叙事来打破死锁并重新执行它。
- en: 'Countermeasure: Commutative updates'
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 对策：交换更新
- en: One straightforward countermeasure is to design the update operations to be
    commutative. Operations are *commutative* if they can be executed in any order.
    An `Account`’s `debit()` and `credit()` operations are commutative (if you ignore
    overdraft checks). This countermeasure is useful because it eliminates lost updates.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 一个直接的对策是设计更新操作为可交换的。如果操作可以以任何顺序执行，则它们是*可交换的*。`Account`的`debit()`和`credit()`操作是可交换的（如果你忽略透支检查）。这种对策很有用，因为它消除了丢失的更新。
- en: Consider, for example, a scenario where a saga needs to be rolled back after
    a compensatable transaction has debited (or credited) an account. The compensating
    transaction can simply credit (or debit) the account to undo the update. There’s
    no possibility of overwriting updates made by other sagas.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑这样一个场景：在可补偿性事务已经借记（或贷记）一个账户之后，需要回滚一个叙事。补偿性事务可以简单地贷记（或借记）该账户以撤销更新。不可能覆盖其他叙事所做的更新。
- en: 'Countermeasure: Pessimistic view'
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 对策：悲观观点
- en: 'Another way to deal with the lack of isolation is the *pessimistic view* countermeasure.
    It reorders the steps of a saga to minimize business risk due to a dirty read.
    Consider, for example, the scenario earlier used to describe the dirty read anomaly.
    In that scenario, the `Create Order Saga` performed a dirty read of the available
    credit and created an order that exceeded the consumer credit limit. To reduce
    the risk of that happening, this countermeasure would reorder the `Cancel Order
    Saga`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 处理隔离不足的另一种方法是**悲观视图**对策。它重新排序叙事的步骤以最小化因脏读而导致的业务风险。例如，考虑之前用来描述脏读异常的场景。在那个场景中，`创建订单叙事`执行了对可用信用的脏读并创建了一个超出消费者信用额度的订单。为了降低这种情况发生的风险，这种对策会重新排序`取消订单叙事`：
- en: '**`Order Service`—** Change the state of the `Order` to cancelled.'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`订单服务`**—将`订单`的状态更改为已取消。'
- en: '**`Delivery Service`—** Cancel the delivery.'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`配送服务`**—取消配送。'
- en: '**`Customer Service`—** Increase the available credit.'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`客户服务`**—增加可用信用。'
- en: In this reordered version of the saga, the available credit is increased in
    a retriable transaction, which eliminates the possibility of a dirty read.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个重新排序的叙事版本中，可用信用通过可重试事务增加，从而消除了脏读的可能性。
- en: 'Countermeasure: Reread value'
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 对策：重读值
- en: The *reread value* countermeasure prevents lost updates. A saga that uses this
    countermeasure rereads a record before updating it, verifies that it’s unchanged,
    and then updates the record. If the record has changed, the saga aborts and possibly
    restarts. This countermeasure is a form of the Optimistic Offline Lock pattern
    ([https://martinfowler.com/eaaCatalog/optimisticOfflineLock.html](https://martinfowler.com/eaaCatalog/optimisticOfflineLock.html)).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**重读值**对策防止丢失更新。使用这种对策的叙事在更新记录之前会重新读取记录，验证其未改变，然后更新记录。如果记录已改变，叙事将中止并可能重新启动。这种对策是乐观离线锁模式（[https://martinfowler.com/eaaCatalog/optimisticOfflineLock.html](https://martinfowler.com/eaaCatalog/optimisticOfflineLock.html)）的一种形式。'
- en: The `Create Order Saga` could use this countermeasure to handle the scenario
    where the `Order` is cancelled while it’s in the process of being approved. The
    transaction that approves the `Order` verifies that the `Order` is unchanged since
    it was created earlier in the saga. If it’s unchanged, the transaction approves
    the `Order`. But if the `Order` has been cancelled, the transaction aborts the
    saga, which causes its compensating transactions to be executed.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`创建订单叙事`可以使用这种对策来处理在订单正在审批过程中被取消的场景。批准订单的事务验证订单自叙事早期创建以来是否未改变。如果未改变，事务批准订单。但如果订单已被取消，事务将中止叙事，这会导致其补偿事务被执行。'
- en: 'Countermeasure: version file'
  id: totrans-232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 对策：版本文件
- en: The *version file* countermeasure is so named because it records the operations
    that are performed on a record so that it can reorder them. It’s a way to turn
    noncommutative operations into commutative operations. To see how this countermeasure
    works, consider a scenario where the `Create Order Saga` executes concurrently
    with a `Cancel Order Saga`. Unless the sagas use the semantic lock countermeasure,
    it’s possible that the `Cancel Order Saga` cancels the authorization of the consumer’s
    credit card before the `Create Order Saga` authorizes the card.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**版本文件**对策之所以得名，是因为它记录了对记录执行的操作，以便可以重新排序它们。这是一种将非交换操作转换为交换操作的方法。要了解这种对策是如何工作的，可以考虑一个场景，其中`创建订单叙事`与`取消订单叙事`并发执行。除非叙事使用语义锁对策，否则`取消订单叙事`可能会在`创建订单叙事`授权卡片之前取消消费者的信用卡授权。'
- en: One way for the `Accounting Service` to handle these out-of-order requests is
    for it to record the operations as they arrive and then execute them in the correct
    order. In this scenario, it would first record the `Cancel Authorization` request.
    Then, when the `Accounting Service` receives the subsequent `Authorize Card` request,
    it would notice that it had already received the `Cancel Authorization` request
    and skip authorizing the credit card.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`会计服务`处理这些顺序错误的请求的一种方法是将操作按到达顺序记录下来，然后按正确的顺序执行它们。在这个场景中，它首先记录`取消授权`请求。然后，当`会计服务`收到随后的`授权卡片`请求时，它会注意到它已经收到了`取消授权`请求，并跳过授权信用卡。'
- en: 'Countermeasure: By value'
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 对策：按值
- en: The final countermeasure is the *by value* countermeasure. It’s a strategy for
    selecting concurrency mechanisms based on business risk. An application that uses
    this countermeasure uses the properties of each request to decide between using
    sagas and distributed transactions. It executes low-risk requests using sagas,
    perhaps applying the countermeasures described in the preceding section. But it
    executes high-risk requests involving, for example, large amounts of money, using
    distributed transactions. This strategy enables an application to dynamically
    make trade-offs about business risk, availability, and scalability.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种对策是 *值传递* 对策。这是一种根据业务风险选择并发机制的战略。使用这种对策的应用程序使用每个请求的属性来决定使用 sagas 还是分布式事务。它使用
    sagas 执行低风险请求，可能应用上一节中描述的对策。但对于涉及大量资金等高风险请求，它使用分布式事务。这种策略使应用程序能够动态地在业务风险、可用性和可伸缩性之间进行权衡。
- en: It’s likely that you’ll need to use one or more of these countermeasures when
    implementing sagas in your application. Let’s look at the detailed design and
    implementation of the `Create Order Saga`, which uses the semantic lock countermeasure.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现应用程序中的 sagas 时，你可能需要使用这些对策之一或多个。让我们看看使用语义锁对策的 `Create Order Saga` 的详细设计和实现。
- en: 4.4\. The design of the Order Service and the Create Order Saga
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4\. `Order Service` 和 `Create Order Saga` 的设计
- en: Now that we’ve looked at various saga design and implementation issues, let’s
    see an example. [Figure 4.9](#ch04fig09) shows the design of `Order Service`.
    The service’s business logic consists of traditional business logic classes, such
    as `Order Service` and the `Order` entity. There are also saga orchestrator classes,
    including the `CreateOrderSaga` class, which orchestrates `Create Order Saga`.
    Also, because `Order Service` participates in its own sagas, it has an `OrderCommandHandlers`
    adapter class that handles command messages by invoking `OrderService`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了各种 saga 设计和实现问题，让我们来看一个例子。[图 4.9](#ch04fig09) 展示了 `Order Service` 的设计。该服务的业务逻辑由传统的业务逻辑类组成，例如
    `Order Service` 和 `Order` 实体。还包括 saga 调度器类，例如 `CreateOrderSaga` 类，它调度 `Create
    Order Saga`。此外，因为 `Order Service` 参与其自身的 sagas，它有一个 `OrderCommandHandlers` 适配器类，该类通过调用
    `OrderService` 来处理命令消息。
- en: Figure 4.9\. The design of the `Order Service` and its sagas
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.9\. `Order Service` 及其 sagas 的设计
- en: '![](Images/04fig09_alt.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.9](Images/04fig09_alt.jpg)'
- en: Some parts of `Order Service` should look familiar. As in a traditional application,
    the core of the business logic is implemented by the `OrderService`, `Order`,
    and `OrderRepository` classes. In this chapter, I’ll briefly describe these classes.
    I describe them in more detail in [chapter 5](kindle_split_013.xhtml#ch05).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`Order Service` 的某些部分可能看起来很熟悉。就像在传统应用程序中一样，业务逻辑的核心是由 `OrderService`、`Order`
    和 `OrderRepository` 类实现的。在本章中，我将简要描述这些类。我在第 5 章[中更详细地描述了它们](kindle_split_013.xhtml#ch05)。'
- en: What’s less familiar about `Order Service` are the saga-related classes. This
    service is both a saga orchestrator and a saga participant. `Order Service` has
    several saga orchestrators, such as `CreateOrderSaga`. The saga orchestrators
    send command messages to a saga participant using a saga participant proxy class,
    such as `KitchenServiceProxy` and `OrderServiceProxy`. A saga participant proxy
    defines a saga participant’s messaging API. `Order Service` also has an `OrderCommandHandlers`
    class, which handles the command messages sent by sagas to `Order Service`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `Order Service` 的不太熟悉的部分是 saga 相关的类。这个服务既是 saga 调度器也是 saga 参与者。`Order Service`
    有几个 saga 调度器，例如 `CreateOrderSaga`。saga 调度器通过使用 saga 参与者代理类（如 `KitchenServiceProxy`
    和 `OrderServiceProxy`）向 saga 参与者发送命令消息。saga 参与者代理定义了 saga 参与者的消息 API。`Order Service`
    还有一个 `OrderCommandHandlers` 类，该类处理 sagas 发送给 `Order Service` 的命令消息。
- en: Let’s look in more detail at the design, starting with the `OrderService` class.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看设计，从 `OrderService` 类开始。
- en: 4.4.1\. The OrderService class
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.1\. `OrderService` 类
- en: The `OrderService` class is a domain service called by the service’s API layer.
    It’s responsible for creating and managing orders. [Figure 4.10](#ch04fig10) shows
    `OrderService` and some of its collaborators. `OrderService` creates and updates
    `Orders`, invokes the `OrderRepository` to persist `Orders`, and creates sagas,
    such as the `CreateOrderSaga`, using the `SagaManager`. The `SagaManager` class
    is one of the classes provided by the Eventuate Tram Saga framework, which is
    a framework for writing saga orchestrators and participants, and is discussed
    a little later in this section.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderService` 类是一个由服务的 API 层调用的领域服务。它负责创建和管理订单。[图 4.10](#ch04fig10) 显示了 `OrderService`
    及其一些协作者。`OrderService` 创建和更新 `Orders`，调用 `OrderRepository` 持久化 `Orders`，并使用 `SagaManager`
    创建 saga，例如 `CreateOrderSaga`。`SagaManager` 类是 Eventuate Tram Saga 框架提供的类之一，这是一个用于编写
    saga 调度器和参与者的框架，将在本节稍后进行讨论。'
- en: Figure 4.10\. `OrderService` creates and updates `Orders`, invokes the `OrderRepository`
    to persist `Orders`, and creates sagas, including the `CreateOrderSaga`.
  id: totrans-247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.10\. `OrderService` 创建和更新 `Orders`，调用 `OrderRepository` 持久化 `Orders`，并创建包括
    `CreateOrderSaga` 在内的 saga。
- en: '![](Images/04fig10_alt.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig10_alt.jpg)'
- en: I’ll discuss this class in more detail in [chapter 5](kindle_split_013.xhtml#ch05).
    For now, let’s focus on the `createOrder()` method. The following listing shows
    `OrderService`’s `createOrder()` method. This method first creates an `Order`
    and then creates an `CreateOrderSaga` to validate the order.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在第 5 章中更详细地讨论这个类。[第 5 章](kindle_split_013.xhtml#ch05)。现在，让我们专注于 `createOrder()`
    方法。以下列表显示了 `OrderService` 的 `createOrder()` 方法。此方法首先创建一个 `Order`，然后创建一个 `CreateOrderSaga`
    来验证订单。
- en: Listing 4.1\. The `OrderService` class and its `createOrder()` method
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.1\. `OrderService` 类及其 `createOrder()` 方法
- en: '[PRE0]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* Ensure that service methods are transactional.**'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 确保服务方法是事务性的。**'
- en: '***2* Create the Order.**'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建订单。**'
- en: '***3* Persist the Order in the database.**'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在数据库中持久化订单。**'
- en: '***4* Publish domain events.**'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 发布领域事件。**'
- en: '***5* Create a CreateOrderSaga.**'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 创建一个 CreateOrderSaga。**'
- en: The `createOrder()` method creates an `Order` by calling the factory method
    `Order.createOrder()`. It then persists the `Order` using the `OrderRepository`,
    which is a JPA-based repository. It creates the `CreateOrderSaga` by calling `SagaManager.create()`,
    passing a `CreateOrderSagaState` containing the ID of the newly saved `Order`
    and the `OrderDetails`. The `SagaManager` instantiates the saga orchestrator,
    which causes it to send a command message to the first saga participant, and persists
    the saga orchestrator in the database.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`createOrder()` 方法通过调用工厂方法 `Order.createOrder()` 创建一个 `Order`。然后使用 `OrderRepository`（一个基于
    JPA 的存储库）持久化 `Order`。通过调用 `SagaManager.create()` 创建 `CreateOrderSaga`，传递一个包含新保存的
    `Order` ID 和 `OrderDetails` 的 `CreateOrderSagaState`。`SagaManager` 实例化 saga 调度器，这导致它向第一个
    saga 参与者发送命令消息，并在数据库中持久化 saga 调度器。'
- en: Let’s look at the `CreateOrderSaga` and its associated classes.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `CreateOrderSaga` 及其相关类。
- en: 4.4.2\. The implementation of the Create Order Saga
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.2\. Create Order Saga 的实现
- en: '[Figure 4.11](#ch04fig11) shows the classes that implement the `Create Order
    Saga`. The responsibilities of each class are as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4.11](#ch04fig11) 显示了实现 `Create Order Saga` 的类。每个类的职责如下：'
- en: Figure 4.11\. The `OrderService`’s sagas, such as `Create Order Saga`, are implemented
    using the Eventuate Tram Saga framework.
  id: totrans-261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.11\. `OrderService` 的 saga，例如 `Create Order Saga`，是使用 Eventuate Tram Saga
    框架实现的。
- en: '![](Images/04fig11_alt.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig11_alt.jpg)'
- en: '`CreateOrderSaga`—A singleton class that defines the saga’s state machine.
    It invokes the `CreateOrderSagaState` to create command messages and sends them
    to participants using message channels specified by the saga participant proxy
    classes, such as `KitchenServiceProxy`.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateOrderSaga`—一个单例类，它定义了 saga 的状态机。它调用 `CreateOrderSagaState` 创建命令消息，并通过
    saga 参与者代理类（如 `KitchenServiceProxy`）指定的消息通道将它们发送给参与者。'
- en: '`CreateOrderSagaState`—A saga’s persistent state, which creates command messages.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateOrderSagaState`—一个 saga 的持久化状态，用于创建命令消息。'
- en: '*Saga participant proxy classes, such as* `KitchenServiceProxy`—Each proxy
    class defines a saga participant’s messaging API, which consists of the command
    channel, the command message types, and the reply types.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*saga 参与者代理类，例如* `KitchenServiceProxy`—每个代理类定义了一个 saga 参与者的消息 API，它包括命令通道、命令消息类型和回复类型。'
- en: These classes are written using the Eventuate Tram Saga framework.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类是使用 Eventuate Tram Saga 框架编写的。
- en: The Eventuate Tram Saga framework provides a domain-specific language (DSL)
    for defining a saga’s state machine. It executes the saga’s state machine and
    exchanges messages with saga participants using the Eventuate Tram framework.
    The framework also persists the saga’s state in the database.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Eventuate Tram Saga 框架提供了一个领域特定语言 (DSL) 来定义悲剧的状态机。它执行悲剧的状态机，并使用 Eventuate Tram
    框架与悲剧参与者交换消息。该框架还将悲剧的状态持久化到数据库中。
- en: Let’s take a closer look at the implementation of `Create Order Saga`, starting
    with the `CreateOrderSaga` class.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看 `Create Order Saga` 的实现，从 `CreateOrderSaga` 类开始。
- en: The CreateOrderSaga orchestrator
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`CreateOrderSaga` 协调器'
- en: The `CreateOrderSaga` class implements the state machine shown earlier in [figure
    4.7](#ch04fig07). This class implements `SimpleSaga`, a base interface for sagas.
    The heart of the `CreateOrderSaga` class is the saga definition shown in the following
    listing. It uses the DSL provided by the Eventuate Tram Saga framework to define
    the steps of the `Create Order Saga`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateOrderSaga` 类实现了前面在 [图 4.7](#ch04fig07) 中显示的状态机。这个类实现了 `SimpleSaga`，这是悲剧的基接口。`CreateOrderSaga`
    类的核心是以下列表中显示的悲剧定义。它使用 Eventuate Tram Saga 框架提供的 DSL 来定义 `Create Order Saga` 的步骤。'
- en: Listing 4.2\. The definition of the `CreateOrderSaga`
  id: totrans-271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.2\. `CreateOrderSaga` 的定义
- en: '[PRE1]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `CreateOrderSaga`’s constructor creates the saga definition and stores it
    in the `sagaDefinition` field. The `getSagaDefinition()` method returns the saga
    definition.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateOrderSaga` 的构造函数创建悲剧定义并将其存储在 `sagaDefinition` 字段中。`getSagaDefinition()`
    方法返回悲剧定义。'
- en: To see how `CreateOrderSaga` works, let’s look at the definition of the third
    step of the saga, shown in the following listing. This step of the saga invokes
    the `Kitchen Service` to create a `Ticket`. Its compensating transaction cancels
    that `Ticket`. The `step()`, `invokeParticipant()`, `onReply()`, and `withCompensation()`
    methods are part of the DSL provided by Eventuate Tram Saga.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解 `CreateOrderSaga` 的工作原理，让我们看看悲剧的第三步定义，如下所示。这一步的悲剧调用 `Kitchen Service` 来创建一个
    `Ticket`。它的补偿事务取消该 `Ticket`。`step()`、`invokeParticipant()`、`onReply()` 和 `withCompensation()`
    方法是 Eventuate Tram Saga 提供的 DSL 的一部分。
- en: Listing 4.3\. The definition of the third step of the saga
  id: totrans-275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.3\. 悲剧第三步的定义
- en: '[PRE2]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* Define the forward transaction.**'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1* 定义正向事务。**'
- en: '***2* Call handleCreateTicketReply() when a successful reply is received.**'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2* 当收到成功回复时调用 handleCreateTicketReply()。**'
- en: '***3* Define the compensating transaction.**'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3* 定义补偿事务。**'
- en: The call to `invokeParticipant()` defines the forward transaction. It creates
    the `CreateTicket` command message by calling `CreateOrderSagaState.makeCreateTicketCommand()`
    and sends it to the channel specified by `kitchenService.create`. The call to
    `onReply()` specifies that `CreateOrderSagaState.handleCreateTicketReply()` should
    be called when a successful reply is received from `Kitchen Service`. This method
    stores the returned `ticketId` in the `CreateOrderSagaState`. The call to `withCompensation()`
    defines the compensating transaction. It creates a `RejectTicketCommand` command
    message by calling `CreateOrderSagaState.makeCancelCreateTicket()` and sends it
    to the channel specified by `kitchenService.create`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`invokeParticipant()` 的调用定义了正向事务。它通过调用 `CreateOrderSagaState.makeCreateTicketCommand()`
    创建 `CreateTicket` 命令消息，并将其发送到由 `kitchenService.create` 指定的通道。`onReply()` 的调用指定当从
    `Kitchen Service` 收到成功回复时，应调用 `CreateOrderSagaState.handleCreateTicketReply()`。此方法将返回的
    `ticketId` 存储在 `CreateOrderSagaState` 中。`withCompensation()` 的调用定义了补偿事务。它通过调用
    `CreateOrderSagaState.makeCancelCreateTicket()` 创建 `RejectTicketCommand` 命令消息，并将其发送到由
    `kitchenService.create` 指定的通道。'
- en: The other steps of the saga are defined in a similar fashion. The `CreateOrderSagaState`
    creates each message, which is sent by the saga to the messaging endpoint defined
    by a `KitchenServiceProxy`. Let’s take a look at each of those classes, starting
    with `CreateOrderSagaState`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 悲剧的其他步骤以类似的方式定义。`CreateOrderSagaState` 创建每个消息，这些消息由悲剧发送到由 `KitchenServiceProxy`
    定义的 messaging 端点。让我们看看这些类中的每一个，从 `CreateOrderSagaState` 开始。
- en: The CreateOrderSagaState class
  id: totrans-282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`CreateOrderSagaState` 类'
- en: The `CreateOrderSagaState` class, shown in the following listing, represents
    the state of a saga instance. An instance of this class is created by `OrderService`
    and is persisted in the database by the Eventuate Tram Saga framework. Its primary
    responsibility is to create the messages that are sent to saga participants.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，`CreateOrderSagaState` 类代表 saga 实例的状态。该类的实例由 `OrderService` 创建，并由 Eventuate
    Tram Saga 框架保存在数据库中。其主要职责是创建发送给 saga 参与者的消息。
- en: Listing 4.4\. `CreateOrderSagaState` stores the state of a saga instance
  id: totrans-284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.4\. `CreateOrderSagaState` 存储saga实例的状态
- en: '[PRE3]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* Invoked by the OrderService to instantiate a CreateOrderSagaState**'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 由 OrderService 调用以实例化 CreateOrderSagaState**'
- en: '***2* Creates a CreateTicket command message**'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建一个 CreateTicket 命令消息**'
- en: '***3* Saves the ID of the newly created Ticket**'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 保存新创建的 Ticket 的 ID**'
- en: '***4* Creates CancelCreateTicket command message**'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 创建 CancelCreateTicket 命令消息**'
- en: 'The `CreateOrderSaga` invokes the `CreateOrderSagaState` to create the command
    messages. It sends those command messages to the endpoints defined by the `SagaParticipantProxy`
    classes. Let’s take a look at one of those classes: `KitchenServiceProxy`.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateOrderSaga` 调用 `CreateOrderSagaState` 来创建命令消息。它将这些命令消息发送到由 `SagaParticipantProxy`
    类定义的端点。让我们看看这些类中的一个：`KitchenServiceProxy`。'
- en: The KitchenServiceProxy class
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`KitchenServiceProxy` 类'
- en: 'The `KitchenServiceProxy` class, shown in [listing 4.5](#ch04ex05), defines
    the command message endpoints for `Kitchen Service`. There are three endpoints:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [列表 4.5](#ch04ex05) 所示，`KitchenServiceProxy` 类定义了 `Kitchen Service` 的命令消息端点。有三个端点：
- en: '**`create`—** Creates a `Ticket`'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`create`—** 创建一个 `Ticket`'
- en: '**`confirmCreate`—** Confirms the creation'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`confirmCreate`—** 确认创建'
- en: '**`cancel`—** Cancels a `Ticket`'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`cancel`—** 取消一个 `Ticket`'
- en: Each `CommandEndpoint` specifies the command type, the command message’s destination
    channel, and the expected reply types.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `CommandEndpoint` 指定命令类型、命令消息的目的地通道和预期的回复类型。
- en: Listing 4.5\. `KitchenServiceProxy` defines the command message endpoints for
    `Kitchen Service`
  id: totrans-297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.5\. `KitchenServiceProxy` 定义了 `Kitchen Service` 的命令消息端点
- en: '[PRE4]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Proxy classes, such as `KitchenServiceProxy`, aren’t strictly necessary. A saga
    could simply send command messages directly to participants. But proxy classes
    have two important benefits. First, a proxy class defines static typed endpoints,
    which reduces the chance of a saga sending the wrong message to a service. Second,
    a proxy class is a well-defined API for invoking a service that makes the code
    easier to understand and test. For example, [chapter 10](kindle_split_018.xhtml#ch10)
    describes how to write tests for `KitchenServiceProxy` that verify that `Order
    Service` correctly invokes `Kitchen Service`. Without `KitchenServiceProxy`, it
    would be impossible to write such a narrowly scoped test.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 代理类，如 `KitchenServiceProxy`，并非绝对必要。saga 可以直接将命令消息发送给参与者。但是代理类有两个重要的好处。首先，代理类定义了静态类型端点，这减少了
    saga 向服务发送错误消息的机会。其次，代理类是一个定义良好的 API，用于调用服务，这使得代码更容易理解和测试。例如，[第 10 章](kindle_split_018.xhtml#ch10)
    描述了如何为 `KitchenServiceProxy` 编写测试，以验证 `Order Service` 正确调用 `Kitchen Service`。没有
    `KitchenServiceProxy`，将无法编写如此范围狭窄的测试。
- en: The Eventuate Tram Saga framework
  id: totrans-300
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Eventuate Tram Saga 框架
- en: The Eventuate Tram Saga, shown in [figure 4.12](#ch04fig12), is a framework
    for writing both saga orchestrators and saga participants. It uses transactional
    messaging capabilities of Eventuate Tram, discussed in [chapter 3](kindle_split_011.xhtml#ch03).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图 4.12](#ch04fig12) 所示，Eventuate Tram Saga 是一个用于编写 saga 调度器和 saga 参与者的框架。它使用
    Eventuate Tram 的事务消息功能，这在 [第 3 章](kindle_split_011.xhtml#ch03) 中讨论过。
- en: Figure 4.12\. Eventuate Tram Saga is a framework for writing both saga orchestrators
    and saga participants.
  id: totrans-302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.12\. Eventuate Tram Saga 是一个用于编写 saga 调度器和 saga 参与者的框架。
- en: '![](Images/04fig12_alt.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig12_alt.jpg)'
- en: 'The `saga orchestration` package is the most complex part of the framework.
    It provides `SimpleSaga`, a base interface for sagas, and a `SagaManager` class,
    which creates and manages saga instances. The `SagaManager` handles persisting
    a saga, sending the command messages that it generates, subscribing to reply messages,
    and invoking the saga to handle replies. [Figure 4.13](#ch04fig13) shows the sequence
    of events when `OrderService` creates a saga. The sequence of events is as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`saga 协调` 包是框架中最复杂的一部分。它提供了一个 `SimpleSaga` 基础接口用于 saga，以及一个 `SagaManager` 类，用于创建和管理
    saga 实例。`SagaManager` 负责持久化 saga，发送它生成的命令消息，订阅回复消息，并调用 saga 处理回复。[图 4.13](#ch04fig13)
    展示了当 `OrderService` 创建 saga 时的事件序列。事件序列如下：'
- en: '`OrderService` creates the `CreateOrderSagaState`.'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OrderService` 创建 `CreateOrderSagaState`。'
- en: It creates an instance of a saga by invoking the `SagaManager`.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用 `SagaManager` 创建一个 saga 实例。
- en: The `SagaManager` executes the first step of the saga definition.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SagaManager` 执行 saga 定义的第一步。'
- en: The `CreateOrderSagaState` is invoked to generate a command message.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `CreateOrderSagaState` 生成一个命令消息。
- en: The `SagaManager` sends the command message to the saga participant (the `Consumer
    Service`).
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SagaManager` 将命令消息发送给 saga 参与者（`Consumer Service`）。'
- en: The `SagaManager` saves the saga instance in the database.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SagaManager` 将 saga 实例保存到数据库中。'
- en: Figure 4.13\. The sequence of events when `OrderService` creates an instance
    of `Create Order Saga`
  id: totrans-311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.13. 当 `OrderService` 创建 `Create Order Saga` 实例时的事件序列
- en: '![](Images/04fig13_alt.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/04fig13_alt.jpg)'
- en: '[Figure 4.14](#ch04fig14) shows the sequence of events when `SagaManager` receives
    a reply from `Consumer Service`.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4.14](#ch04fig14) 展示了当 `SagaManager` 从 `Consumer Service` 接收到回复时的事件序列。'
- en: Figure 4.14\. The sequence of events when the `SagaManager` receives a reply
    message from a saga participant
  id: totrans-314
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.14. 当 `SagaManager` 从 saga 参与者接收到回复消息时的事件序列
- en: '![](Images/04fig14_alt.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/04fig14_alt.jpg)'
- en: 'The sequence of events is as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 事件序列如下：
- en: Eventuate Tram invokes `SagaManager` with the reply from `Consumer Service`.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Eventuate Tram 使用 `Consumer Service` 的回复调用 `SagaManager`。
- en: '`SagaManager` retrieves the saga instance from the database.'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SagaManager` 从数据库中检索 saga 实例。'
- en: '`SagaManager` executes the next step of the saga definition.'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SagaManager` 执行 saga 定义的下一步。'
- en: '`CreateOrderSagaState` is invoked to generate a command message.'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `CreateOrderSagaState` 生成一个命令消息。
- en: '`SagaManager` sends the command message to the specified saga participant (`Kitchen
    Service`).'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SagaManager` 将命令消息发送给指定的 saga 参与者（`Kitchen Service`）。'
- en: '`SagaManager` saves the update saga instance in the database.'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SagaManager` 将更新后的 saga 实例保存到数据库中。'
- en: If a saga participant fails, `SagaManager` executes the compensating transactions
    in reverse order.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 saga 参与者失败，`SagaManager` 将以相反的顺序执行补偿事务。
- en: The other part of the Eventuate Tram Saga framework is the `saga participant`
    package. It provides the `SagaCommandHandlersBuilder` and `SagaCommandDispatcher`
    classes for writing saga participants. These classes route command messages to
    handler methods, which invoke the saga participants’ business logic and generate
    reply messages. Let’s take a look at how these classes are used by `Order Service`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: Eventuate Tram Saga 框架的另一部分是 `saga 参与者` 包。它提供了 `SagaCommandHandlersBuilder`
    和 `SagaCommandDispatcher` 类，用于编写 saga 参与者。这些类将命令消息路由到处理方法，调用 saga 参与者的业务逻辑并生成回复消息。让我们看看这些类是如何被
    `Order Service` 使用的。
- en: 4.4.3\. The OrderCommandHandlers class
  id: totrans-325
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.3. `OrderCommandHandlers` 类
- en: '`Order Service` participates in its own sagas. For example, `CreateOrderSaga`
    invokes `Order Service` to either approve or reject an `Order`. The `OrderCommandHandlers`
    class, shown in [figure 4.15](#ch04fig15), defines the handler methods for the
    command messages sent by these sagas.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`Order Service` 参与其自己的 saga。例如，`CreateOrderSaga` 调用 `Order Service` 来批准或拒绝一个
    `Order`。如图 4.15 所示的 `OrderCommandHandlers` 类定义了这些 saga 发送的命令消息的处理方法。'
- en: Figure 4.15\. `OrderCommandHandlers` implements command handlers for the commands
    that are sent by the various `Order Service` sagas.
  id: totrans-327
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.15. `OrderCommandHandlers` 实现了由各种 `Order Service` saga 发送的命令的处理程序。
- en: '![](Images/04fig15_alt.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/04fig15_alt.jpg)'
- en: Each handler method invokes `OrderService` to update an `Order` and makes a
    reply message. The `SagaCommandDispatcher` class routes the command messages to
    the appropriate handler method and sends the reply.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 每个处理方法调用 `OrderService` 更新一个 `Order` 并生成一个回复消息。`SagaCommandDispatcher` 类将命令消息路由到适当的处理方法并发送回复。
- en: The following listing shows the `OrderCommandHandlers` class. Its `commandHandlers()`
    method maps command message types to handler methods. Each handler method takes
    a command message as a parameter, invokes `OrderService`, and returns a reply
    message.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了`OrderCommandHandlers`类。它的`commandHandlers()`方法将命令消息类型映射到处理方法。每个处理方法接受一个命令消息作为参数，调用`OrderService`，并返回一个回复消息。
- en: Listing 4.6\. The command handlers for `Order Service`
  id: totrans-331
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.6。`订单服务`的命令处理程序
- en: '[PRE5]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* Route each command message to the appropriate handler method.**'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将每个命令消息路由到适当的处理方法。**'
- en: '***2* Change the state of the Order to authorized.**'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将订单的状态更改为已授权。**'
- en: '***3* Return a generic success message.**'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 返回一个通用的成功消息。**'
- en: '***4* Change the state of the Order to rejected.**'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将订单的状态更改为已拒绝。**'
- en: The `approveOrder()` and `rejectOrder()` methods update the specified `Order`
    by invoking `OrderService`. The other services that participate in sagas have
    similar command handler classes that update their domain objects.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`approveOrder()`和`rejectOrder()`方法通过调用`OrderService`来更新指定的`Order`。参与saga的其他服务也有类似的命令处理类，用于更新它们的领域对象。'
- en: 4.4.4\. The OrderServiceConfiguration class
  id: totrans-338
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.4。`OrderServiceConfiguration`类
- en: The `Order Service` uses the Spring framework. The following listing is an excerpt
    of the `OrderServiceConfiguration` class, which is an `@Configuration` class that
    instantiates and wires together the Spring `@Beans`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`订单服务`使用Spring框架。以下列表是`OrderServiceConfiguration`类的摘录，它是一个`@Configuration`类，用于实例化和连接Spring
    `@Beans`。'
- en: Listing 4.7\. The `OrderServiceConfiguration` is a Spring `@Configuration` class
    that defines the Spring `@Beans` for the `Order Service`.
  id: totrans-340
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.7。`OrderServiceConfiguration`是一个Spring `@Configuration`类，它定义了`订单服务`的Spring
    `@Beans`。
- en: '[PRE6]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This class defines several Spring `@Beans` including `orderService`, `createOrderSagaManager`,
    `createOrderSaga`, `orderCommandHandlers`, and `orderCommandHandlersDispatcher`.
    It also defines Spring `@Beans` for the various proxy classes, including `kitchenServiceProxy`
    and `orderServiceProxy`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 此类定义了多个Spring `@Beans`，包括`orderService`、`createOrderSagaManager`、`createOrderSaga`、`orderCommandHandlers`和`orderCommandHandlersDispatcher`。它还定义了各种代理类的Spring
    `@Beans`，包括`kitchenServiceProxy`和`orderServiceProxy`。
- en: '`CreateOrderSaga` is only one of `Order Service`’s many sagas. Many of its
    other system operations also use sagas. For example, the `cancelOrder()` operation
    uses a `Cancel Order Saga`, and the `reviseOrder()` operation uses a `Revise Order
    Saga`. As a result, even though many services have an external API that uses a
    synchronous protocol, such as REST or gRPC, a large amount of interservice communication
    will use asynchronous messaging.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateOrderSaga`只是`订单服务`众多saga之一。它的许多其他系统操作也使用saga。例如，`cancelOrder()`操作使用`取消订单saga`，而`reviseOrder()`操作使用`修改订单saga`。因此，尽管许多服务有一个使用同步协议的外部API，例如REST或gRPC，但大量的服务间通信将使用异步消息。'
- en: As you can see, transaction management and some aspects of business logic design
    are quite different in a microservice architecture. Fortunately, saga orchestrators
    are usually quite simple state machines, and you can use a saga framework to simplify
    your code. Nevertheless, transaction management is certainly more complicated
    than in a monolithic architecture. But that’s usually a small price to pay for
    the tremendous benefits of microservices.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，在微服务架构中，事务管理和业务逻辑设计的某些方面相当不同。幸运的是，saga编排器通常是相当简单的状态机，你可以使用saga框架来简化你的代码。然而，事务管理确实比在单体架构中更复杂。但这通常是为了微服务带来的巨大好处而付出的微小代价。
- en: Summary
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Some system operations need to update data scattered across multiple services.
    Traditional, XA/2PC-based distributed transactions aren’t a good fit for modern
    applications. A better approach is to use the Saga pattern. A saga is sequence
    of local transactions that are coordinated using messaging. Each local transaction
    updates data in a single service. Because each local transaction commits its changes,
    if a saga must roll back due to the violation of a business rule, it must execute
    compensating transactions to explicitly undo changes.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些系统操作需要更新多个服务中的分散数据。传统的基于XA/2PC的分布式事务并不适合现代应用。更好的方法是使用saga模式。saga是一系列使用消息协调的本地事务。每个本地事务更新单个服务中的数据。因为每个本地事务都会提交其更改，如果saga必须因为违反业务规则而回滚，它必须执行补偿事务来显式撤销更改。
- en: You can use either choreography or orchestration to coordinate the steps of
    a saga. In a choreography-based saga, a local transaction publishes events that
    trigger other participants to execute local transactions. In an orchestration-based
    saga, a centralized saga orchestrator sends command messages to participants telling
    them to execute local transactions. You can simplify development and testing by
    modeling saga orchestrators as state machines. Simple sagas can use choreography,
    but orchestration is usually a better approach for complex sagas.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用编排或编排来协调 Sagas 的步骤。在基于编排的 Sagas 中，本地事务发布事件，触发其他参与者执行本地事务。在基于编排的 Sagas 中，集中的
    Sagas 编排器向参与者发送命令消息，告诉他们执行本地事务。你可以通过将 Sagas 编排器建模为状态机来简化开发和测试。简单的 Sagas 可以使用编排，但对于复杂的
    Sagas，编排通常是一个更好的方法。
- en: Designing saga-based business logic can be challenging because, unlike ACID
    transactions, sagas aren’t isolated from one another. You must often use countermeasures,
    which are design strategies that prevent concurrency anomalies caused by the ACD
    transaction model. An application may even need to use locking in order to simplify
    the business logic, even though that risks deadlocks.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计基于 Sagas 的业务逻辑可能具有挑战性，因为与 ACID 事务不同，Sagas 之间并不是相互隔离的。你通常必须使用对策，这些对策是设计策略，用于防止由
    ACD 事务模型引起的并发异常。应用程序甚至可能需要使用锁定来简化业务逻辑，尽管这可能导致死锁。
