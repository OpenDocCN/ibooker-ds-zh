- en: 3 How bad is this code?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 这段代码有多糟糕？
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: HTTP routes, resources, and endpoints
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP路由、资源和端点
- en: Auto-properties and init-only setters
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动属性和仅初始化设置器
- en: Configuring an ASP.NET service
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置ASP.NET服务
- en: In this chapter, we’ll meet Flying Dutchman Airlines, who have hired us to refactor
    their legacy codebase. Flying Dutchman has told us their business needs and given
    us their requirements for the refactor. Their legacy application, which we’ll
    examine in this (and the next) chapter, is a backend web service developed on
    the .NET Framework following the Model-View-Controller (MVC) pattern. The code
    has many readability and security issues, so don’t be surprised if there are pieces
    of code in this chapter that you don’t like. The point of this chapter is for
    us to determine where we can change the existing codebase. We’ll look in-depth
    at the models, views, and configuration of the (messy) codebase in this chapter
    to prepare for refactoring the code in later chapters. Figure 3.1 shows where
    we are in the scheme of the book.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将遇到飞行荷兰人航空公司，他们雇佣我们重构他们的遗留代码库。飞行荷兰人告诉我们他们的商业需求和重构的要求。我们将在这（以及下一）章中检查的遗留应用程序是一个基于.NET
    Framework并遵循模型-视图-控制器（MVC）模式的后端Web服务。代码存在许多可读性和安全问题，所以如果你在本章中看到你不喜欢的代码片段，请不要感到惊讶。本章的目的是让我们确定我们可以改变现有代码库的地方。我们将深入查看本章中（混乱的）代码库的模型、视图和配置，为后续章节中重构代码做准备。图3.1显示了我们在本书结构中的位置。
- en: '![](../Images/03_01.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03_01.png)'
- en: 'Figure 3.1 In this chapter, we’ll start part 2: The existing codebase. We’ll
    look at what requirements are laid out for us to address in the rest of the book
    and what models and views the existing codebase contains.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 在本章中，我们将开始第二部分：现有的代码库。我们将查看在本书的其余部分我们需要解决的要求，以及现有代码库包含哪些模型和视图。
- en: Flying Dutchman Airlines, whose logo is shown in figure 3.2, is a low-cost airline
    based in Groningen, the Netherlands. The airline serves 20 destinations, including
    London, Paris, Prague, and Milan. Established in 1977, the company has had its
    difficulties in the marketplace. Flying Dutchman Airlines markets itself as an
    “ultra-low-cost airline.” Now that we are in the middle of the twenty-first century,
    management has decided it is time to bring the business into this century as well.
    This is where you come in. In this section, we’ll meet our new boss and get the
    specifications for the product we are to create.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 飞行荷兰人航空公司，其标志如图3.2所示，是一家以荷兰格罗宁根为基地的低成本航空公司。该航空公司服务20个目的地，包括伦敦、巴黎、布拉格和米兰。成立于1977年，该公司在市场上遇到了困难。飞行荷兰人航空公司将自己定位为“超低成本航空公司”。现在我们正处于21世纪的中期，管理层认为现在是时候将业务带入这个世纪了。这就是你发挥作用的地方。在本节中，我们将遇到我们的新老板，并获取我们即将创建的产品规格。
- en: '![](../Images/03_02.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03_02.png)'
- en: Figure 3.2 The Flying Dutchman Airlines logo. Flying Dutchman Airlines is the
    company we are working for in this book.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 飞行荷兰人航空公司标志。飞行荷兰人航空公司是我们在这本书中所工作的公司。
- en: 3.1 Introducing Flying Dutchman Airlines
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 介绍飞行荷兰人航空公司
- en: It is the first day at your new job, and you pull up ten minutes early into
    the parking lot. Your button-down shirt is washed, steamed, ironed, and pressed.
    You are ready for your first day at work. Your arrival is heavily anticipated,
    and the first order of the day, after the obligatory HR paperwork and ID badge
    photos, is to meet with the CEO. You are the first in-house software engineer
    they have hired in a long time and expectations are high.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你在新工作第一天，你提前10分钟到达停车场。你的衬衫已经洗净、蒸过、熨烫并压平。你准备好开始你的第一天工作了。你的到来备受期待，在例行的人事文件和身份证照片之后，第一件事就是与首席执行官会面。你是他们很久以来雇佣的第一个内部软件工程师，期望很高。
- en: The CEO strikes up a conversation and points you to a chair. He tells you that
    his name is Aljen van der Meulen and that he joined Flying Dutchman Airlines only
    recently, but he sees room for a lot of potential improvements at the airline,
    especially in the technology department. The Flying Dutchman Airlines website
    works fine, but there is no way for people to book a flight through a search aggregator.
    (An aggregator is a type of search engine that collects, or aggregates, information
    from specific sources. In this case, FlyTomorrow aggregates available flights
    for booking from airlines.)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首席执行官开始交谈，并指给你一个椅子。他告诉你他的名字是 Aljen van der Meulen，并且他最近才加入飞行荷兰人航空公司，但他看到航空公司在技术部门有很多改进的潜力。飞行荷兰人航空公司的网站运行良好，但人们无法通过搜索聚合器预订航班。（聚合器是一种收集或汇总来自特定来源信息的搜索引擎。在这种情况下，FlyTomorrow
    从航空公司汇总了可预订的航班信息。）
- en: As a result, Aljen signed a contract with the flight aggregator FlyTomorrow.com.
    FlyTomorrow is the most-visited airline-related website over the last year and
    has some specific requirements for airlines to abide by if they want to integrate
    with their search engine. The existing codebase for the airline’s internal systems
    does have an API for searching and booking flights, but it is a big mess and needs
    thorough refactoring. Aljen slides over a piece of paper and motions for you to
    take a look. As shown in figure 3.3, it is the part of the contract between FlyTomorrow
    and Flying Dutchman Airlines that highlights the technological requirements needed
    to fulfill the contract.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Aljen 与航班聚合器 FlyTomorrow.com 签署了一份合同。FlyTomorrow 是去年访问量最大的航空公司相关网站，并且对希望与其搜索引擎集成的航空公司有一些具体要求。航空公司内部系统的现有代码库确实有一个用于搜索和预订航班的
    API，但它非常混乱，需要进行彻底的重构。Aljen 把一张纸滑过来，示意你看看。如图 3.3 所示，这是 FlyTomorrow 和飞行荷兰人航空公司之间合同的一部分，突出了满足合同所需的技术要求。
- en: '![](../Images/03_03.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03_03.png)'
- en: Figure 3.3 Some of the API-related language in the contract between Flying Dutchman
    Airlines and FlyTomorrow. The contract contains information about the endpoints
    we need to implement to fulfill the requirements.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 飞行荷兰人航空公司与 FlyTomorrow 之间的合同中的一些与 API 相关的语言。该合同包含我们需要实现以满足要求的服务端点信息。
- en: The two most important requirements are the presence of `HTTP GET` and `HTTP
    POST` endpoints in the current API. FlyTomorrow uses these to query for available
    flights (`GET`) and book them (`POST`). Furthermore, the API has to return error
    codes where appropriate.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的两个需求是当前 API 中存在 `HTTP GET` 和 `HTTP POST` 端点。FlyTomorrow 使用这些端点来查询可用航班（`GET`）并预订它们（`POST`）。此外，API
    必须在适当的情况下返回错误代码。
- en: 'NOTE If you are unfamiliar with HTTP actions such as `POST` and `GET`, or HTTP
    and web development in general, you should consider exploring those topics a bit
    further. A fine resource is Mozilla’s documentation on HTTP request methods: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果你对 `POST` 和 `GET` 等HTTP操作不熟悉，或者对 HTTP 和网络开发总体上不太了解，你应该考虑进一步探索这些主题。一个很好的资源是Mozilla关于HTTP请求方法的文档：[https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods)。
- en: '3.2 Pieces of the puzzle: Taking a look at our requirements'
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 拼图碎片：审视我们的需求
- en: George, the CTO, steps into the office. Not wasting time, he launches into a
    discussion on the codebase. The existing codebase is small but messy. Everything
    is written in a prehistoric version of C# (C# 3.0, to be precise), and the version
    of .NET Framework used is 4.5\. The database runs on a locally hosted Microsoft
    SQL Server and is queried without an object-relational mapping (ORM) framework.
    George would love for the refactored version to run on .NET 5 and use the latest
    version of C#. Although we cannot change the database schema, we do have access
    to it. In fact, George has gone ahead and deployed it to Microsoft Azure.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 乔治，首席技术官，走进办公室。他没有浪费时间，直接开始讨论代码库。现有的代码库虽小但很混乱。所有内容都是用一种史前的 C# 版本（确切地说是 C# 3.0）编写的，使用的
    .NET Framework 版本是 4.5。数据库在本地托管的 Microsoft SQL Server 上运行，并且没有使用对象关系映射（ORM）框架。乔治希望重构后的版本能在
    .NET 5 上运行并使用最新的 C# 版本。虽然我们无法更改数据库模式，但我们确实可以访问它。实际上，乔治已经将其部署到了 Microsoft Azure。
- en: 3.2.1 Object-relational mapping
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 对象关系映射
- en: When you want to make changes to a database, you often use a database management
    tool such as SQL Server Management Studio (SSMS), MySQL Workbench, or Oracle SQL
    Developer. You can use these tools to write SQL queries and execute them against
    a database, as well as do things like set up stored procedures and perform backups.
    How can we query and interact with the database through the code at runtime? We
    can use a tool for object-relational mapping. ORM is a technique for mapping data
    from a database to a representation in your codebase and vice versa. In practical
    terms, imagine you have a database called BookShop. This database might have tables
    such as Books, Customers, and Orders. How would you model those in an object-oriented
    codebase? Likely by using models called `Books`, `Customers`, and `Orders`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想对数据库进行更改时，你通常会使用数据库管理工具，如SQL Server Management Studio (SSMS)、MySQL Workbench或Oracle
    SQL Developer。你可以使用这些工具编写SQL查询并在数据库上执行它们，以及设置存储过程和执行备份等操作。我们如何在运行时通过代码查询和与数据库交互呢？我们可以使用对象关系映射工具。ORM是一种将数据从数据库映射到代码库中的表示以及相反的技术。在实践中，假设你有一个名为BookShop的数据库。这个数据库可能包含Books、Customers和Orders等表。你如何在面向对象的代码库中建模这些表？很可能是通过使用名为`Books`、`Customers`和`Orders`的模型。
- en: DEFINITION An *entity* refers to a definition in a database that models the
    real world, whereas a *model* is a class representation of such a model (or any
    other real-world object). Just remember, entity is database, and model is code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：一个 *实体* 指的是数据库中对现实世界的一个定义，而一个 *模型* 是这种模型（或任何其他现实世界对象）的类表示。只需记住，实体是数据库，模型是代码。
- en: 'It is also a fair assumption that the developers have synchronized the fields
    to be the same in both the database and in the code. This does not mean that they
    are of the same type, however. Take Books, for example: when queried for a particular
    book, the database returns a record in Book as some sort of stream, often in JSON
    or binary. The model in the code is of the type `Book`, but we defined this class
    ourselves. The database does not know of the existence of this class. The database
    table and codebase model representations are not inherently compatible but do
    map to each other. This is an isomorphic relationship, something we’ll explore
    further in section 3.3.3.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 同样可以合理假设，开发者已经将字段在数据库和代码中同步为相同。但这并不意味着它们的类型相同。以书籍为例：当查询特定书籍时，数据库以某种流的形式返回一个Book记录，通常以JSON或二进制形式。代码中的模型是`Book`类型，但我们自己定义了这个类。数据库不知道这个类的存在。数据库表和代码库模型表示不是本质上兼容的，但它们确实相互映射。这是一种同构关系，我们将在3.3.3节中进一步探讨。
- en: 'George and Aljen see the contract with FlyTomorrow as an opportunity to revamp
    the existing codebase because the company intends to grow its user base and increase
    its scalability. FlyTomorrow has even provided the airline with an OpenAPI specification
    to check the endpoints against (an endpoint is an entry point for a different
    service calling our service into our codebase). FlyTomorrow requires the following
    three endpoints:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 乔治和阿尔金认为与FlyTomorrow的合同是一个重写现有代码库的机会，因为该公司打算扩大其用户群并提高其可扩展性。FlyTomorrow甚至为航空公司提供了一个OpenAPI规范来检查端点（端点是不同服务调用我们的服务到我们的代码库的入口点）。FlyTomorrow需要以下三个端点：
- en: '`GET /flight`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /flight`'
- en: '`GET /flight/{flightNumber}`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /flight/{flightNumber}`'
- en: '`POST /booking/{flightNumber}`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /booking/{flightNumber}`'
- en: DEFINITION OpenAPI (formerly Swagger) is an industry-standard way of specifying
    APIs. Within an OpenAPI specification, you often find the endpoints an API has
    and guidance on how to interact with an API.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：OpenAPI（以前称为Swagger）是指定API的行业标准方式。在OpenAPI规范中，你通常会找到API拥有的端点以及如何与API交互的指导。
- en: '3.2.2 The GET /flight endpoint: Retrieving information on all flights'
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.2 GET /flight端点：检索所有航班的详细信息
- en: 'In this section, we’ll explore the first endpoint: `GET /flight`. The `/flight`
    endpoint accepts a `GET` request and returns information about all flights in
    the database. Figure 3.4 tells our endpoint requirements story.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨第一个端点：`GET /flight`。`/flight`端点接受一个`GET`请求并返回数据库中所有航班的详细信息。图3.4讲述了我们的端点需求故事。
- en: '![](../Images/03_04.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03_04.png)'
- en: Figure 3.4 A screenshot of a generated OpenAPI `GET` `/flight` endpoint specification.
    It accepts a `GET` response and can return an HTTP status of 200 (along with information
    on all available flights), 404, or 500.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 生成的OpenAPI `GET` `/flight`端点规范截图。它接受一个`GET`响应，可以返回HTTP状态200（附带所有可用航班的详细信息）、404或500。
- en: According to the OpenAPI specification from FlyTomorrow, the `GET /flight` endpoint
    should return a list of all available flights. The flight data should contain
    the flight number and two pieces of airport metadata. The airport model contains
    the city the airport serves and the International Air Transport Association (IATA)
    airport code. When no flights are found (meaning no flights are in the database),
    we should return an HTTP code of 404 (not found). If an error occurred, whatever
    it may be, the return value should be an HTTP code 500 (internal server error)
    response.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 根据FlyTomorrow的OpenAPI规范，`GET /flight` 端点应返回所有可用航班的列表。航班数据应包含航班号和两份机场元数据。机场模型包含机场服务的城市和国际航空运输协会（IATA）机场代码。当没有找到航班（意味着数据库中没有航班）时，我们应该返回HTTP代码404（未找到）。如果发生错误，无论是什么错误，返回值应该是一个HTTP代码500（内部服务器错误）响应。
- en: '3.2.3 The GET /flight/{flightNumber} endpoint: Getting specific flight information'
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.3 GET /flight/{flightNumber} 端点：获取特定航班信息
- en: The second endpoint that FlyTomorrow requires is `GET /flight/{flightNumber}`.
    In figure 3.5, the OpenAPI specification shows us the expected input and outputs
    of the endpoint.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: FlyTomorrow需要的第二个端点是 `GET /flight/{flightNumber}`。在图3.5中，OpenAPI规范显示了端点的预期输入和输出。
- en: '![](../Images/03_05.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03_05.png)'
- en: Figure 3.5 A screenshot of a generated OpenAPI specification for the `GET` `/flight/{flightNumber}`
    endpoint. This endpoint returns detailed information about a specific flight in
    the database when given a flight number.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 为生成用于 `GET` `/flight/{flightNumber}` 端点的OpenAPI规范的屏幕截图。当提供航班号时，此端点返回数据库中特定航班的详细信息。
- en: This endpoint has a path parameter of `{flightNumber}`, specifying which flight’s
    details are returned to the caller.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此端点有一个路径参数 `{flightNumber}`，指定返回给调用者的哪个航班的详细信息。
- en: '![](../Images/03_05_UN01.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03_05_UN01.png)'
- en: The API should return an HTTP code 400 (bad request) if an invalid flight number
    is provided in the path. An invalid flight number could be a negative number or
    a string that contains only letters. If a requested flight number does not map
    to a flight in the database, then an HTTP code 404 (not found) is returned.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在路径中提供了无效的航班号，API应返回HTTP代码400（无效请求）。无效的航班号可能是一个负数或只包含字母的字符串。如果请求的航班号在数据库中没有对应航班，则返回HTTP代码404（未找到）。
- en: '3.2.4 The POST /booking/{flightNumber} endpoint: Booking a flight'
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.4 POST /booking/{flightNumber} 端点：预订航班
- en: The last required endpoint is a `POST` endpoint with the path `/booking/{flightNumber}`,
    as shown in figure 3.6.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后必需的端点是路径为 `/booking/{flightNumber}` 的 `POST` 端点，如图3.6所示。
- en: '![](../Images/03_06.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03_06.png)'
- en: Figure 3.6 The OpenAPI specification for the `POST` `/booking/{flightNumber}`
    endpoint. The endpoint requires us to pass in a first and last name, as well as
    use the flight number we wish to book as a path parameter. It returns an HTTP
    status code value 201 along with booking information on success. On failure, it
    returns an HTTP status code value of 404 or 500.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 `/booking/{flightNumber}` 的 `POST` 端点的OpenAPI规范。该端点要求我们传递一个名和姓，以及使用我们想要预订的航班号作为路径参数。在成功的情况下，它返回HTTP状态码201以及预订信息。在失败的情况下，它返回HTTP状态码404或500。
- en: 'The `POST` endpoint has a URL path parameter of `{flightNumber}` and requires
    a request body with two fields: `firstName` and `lastName`, both strings. The
    endpoint either returns an HTTP status code 201 (created) on success or an HTTP
    status code 500 on failure to book due to a logical or database error. See figure
    3.7.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST` 端点有一个URL路径参数 `{flightNumber}`，并需要一个包含两个字段（`firstName` 和 `lastName`）的请求体，这两个字段都是字符串。端点在成功预订时返回HTTP状态码201（已创建），或者在由于逻辑或数据库错误而无法预订时返回HTTP状态码500。见图3.7。'
- en: '![](../Images/03_07.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03_07.png)'
- en: Figure 3.7 The request-return life cycle of the `POST` `/booking/{flightNumber}`
    endpoint. On success, the endpoint returns an HTTP status of 201 along with a
    booking ID, flight information, and customer information. In case the service
    cannot find the appropriate flight, it returns an HTTP status 404\. When there
    is an internal error, it returns HTTP status 500.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 `POST` `/booking/{flightNumber}` 端点的请求-返回生命周期。在成功的情况下，端点返回HTTP状态201以及预订ID、航班信息和客户信息。如果服务找不到适当的航班，则返回HTTP状态404。当发生内部错误时，返回HTTP状态500。
- en: NOTE The full OpenAPI file can be viewed (in YAML format) in appendix D.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：完整的OpenAPI文件可以在附录D中查看（以YAML格式）。
- en: 'The workflow, as shown in figure 3.8, that FlyTomorrow uses to search and book
    flights is as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: FlyTomorrow用于搜索和预订航班的流程，如图3.8所示，如下所示：
- en: FlyTomorrow queries our `GET /flight` endpoint to list all the flights to the
    consumer.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FlyTomorrow查询我们的`GET /flight`端点以列出所有到消费者的航班。
- en: When the consumer selects a flight to get details for, FlyTomorrow queries our
    `GET /flight/{flightNumber}` endpoint with the flight number.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当消费者选择航班以获取详细信息时，FlyTomorrow使用航班号查询我们的`GET /flight/{flightNumber}`端点。
- en: When the customer is ready to book the flight, FlyTomorrow sends a `POST` request
    to `POST /booking/{flightNumber}` to book the flight.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当客户准备好预订航班时，FlyTomorrow向`POST /booking/{flightNumber}`发送`POST`请求以预订航班。
- en: '![](../Images/03_08.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03_08.png)'
- en: Figure 3.8 The Search -> Click -> Book workflow and API calls. This is the workflow
    used by our client and the one around which we model our codebase.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 搜索 -> 点击 -> 预订工作流程和API调用。这是我们客户使用的工作流程，也是我们围绕代码库建模的工作流程。
- en: 3.3 Coming to terms with the existing codebase
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 接受现有的代码库
- en: 'For the remainder of this chapter, we’ll walk through the part of the code
    we inherited: the models, views, and configuration code. We’ll discuss points
    of improvement, clean code, and security. We’ll also touch on the database schema
    and how the inherited code’s models compare to the schema.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将逐步介绍我们继承的代码部分：模型、视图和配置代码。我们将讨论改进点、清洁代码和安全问题。我们还将涉及数据库模式以及继承的代码的模型与模式如何比较。
- en: WARNING The rest of this chapter (and the next) deals with the existing codebase.
    This means that we will see sloppy and incorrect code, diversions from the given
    requirements, and all-around bad things. We will fix them all in later chapters.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：本章的其余部分（以及下一章）涉及现有的代码库。这意味着我们将看到混乱和不正确的代码、偏离给定要求的情况，以及所有不好的事情。我们将在后面的章节中修复它们。
- en: This chapter serves as the foundation on which we can build our improved service.
    After reading this chapter and the next, you’ll be intimately familiar with the
    codebase we are trying to improve and itching to start refactoring in part 3.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 本章作为我们构建改进服务的基础。阅读本章和下一章后，您将深入了解我们试图改进的代码库，并渴望在第三部分开始重构。
- en: 3.3.1 Assessing the existing database schema and its tables
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 评估现有的数据库模式和表
- en: 'Now that we have our OpenAPI file and know what is expected of us, it is time
    to look at the existing codebase and database. The code we have inherited has
    a lot of pain points that we can improve on. We can change anything we want, according
    to George and Aljen, but not the database. Because it is our only rock-solid foundation
    block, let’s start by looking at the database schema. The database is deployed
    to Microsoft Azure and is a regular, run-of-the-mill SQL database with only a
    couple of tables, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了OpenAPI文件并知道对我们有什么期望，是时候查看现有的代码库和数据库了。我们继承的代码有很多痛点可以改进。根据乔治和Aljen的说法，我们可以改变我们想要的任何东西，但不能改变数据库。因为它是我们唯一坚如磐石的基础块，让我们先从查看数据库模式开始。数据库部署到Microsoft
    Azure，是一个普通的、常规的SQL数据库，只有几张表，如下所示：
- en: Airport
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机场
- en: Booking
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预订
- en: Customer
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户
- en: Flight
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 航班
- en: In this section, we’ll look at the database schema, shown in figure 3.9, and
    dissect the key constraints the schema provides us.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看数据库模式，如图3.9所示，并分析该模式为我们提供的核心约束。
- en: '![](../Images/03_09.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03_09.png)'
- en: Figure 3.9 The database schema and foreign key constraints of the Flying Dutchman
    Airlines database hosted in Microsoft Azure. This schema shows the tables we use
    throughout the book.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 飞行荷兰人航空公司数据库的数据库模式和外键约束，该数据库托管在Microsoft Azure上。此模式显示了本书中使用的所有表。
- en: As George told us, no ORM is used in the existing codebase, but even without
    one, you would expect to see some objects modeled after these tables.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如乔治告诉我们，现有的代码库中没有使用ORM，但即使没有，您也会期望看到一些根据这些表建模的对象。
- en: NOTE If you are unfamiliar with databases and/or SQL in general, you may want
    to read up on the basics. Two good resources are Cornell University’s *Relational
    Databases Virtual Workshop* at [https://cvw.cac.cornell.edu/databases/](https://cvw.cac.cornell.edu/databases/)
    and *The Manga Guide to Databases* (No Starch Press, 2009) by Mana Takahashi,
    Shoko Azuma, and Trend-Pro Co., Ltd.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果您对数据库和/或SQL不太熟悉，您可能需要了解基础知识。两个很好的资源是康奈尔大学的*关系数据库虚拟工作坊*，网址为[https://cvw.cac.cornell.edu/databases/](https://cvw.cac.cornell.edu/databases/)，以及Mana
    Takahashi、Shoko Azuma和Trend-Pro Co., Ltd.所著的*数据库漫画指南*（No Starch Press，2009年）。
- en: '3.3.2 The existing codebase: Web service configuration files'
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.2 现有代码库：Web服务配置文件
- en: Looking at the solution’s structure gives us some insight into how the project
    was laid out. In this section, we are looking at the source files dealing with
    the configuration of the service, as shown in figure 3.10.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看解决方案的结构，我们可以对项目的布局有所了解。在本节中，我们正在查看处理服务配置的源文件，如图3.10所示。
- en: '![](../Images/03_10.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图3.10](../Images/03_10.png)'
- en: Figure 3.10 The folder structure of FlyingDutchmanAirlinesExisting.sln, as shown
    in the Solution Explorer in Visual Studio 2019\. This is the structure we’ll explore
    in the remainder of the chapter. The solution consists of a single project that
    has configuration, controller, object, and view files.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10展示了在Visual Studio 2019的解决方案资源管理器中显示的FlyingDutchmanAirlinesExisting.sln的文件夹结构。这是我们将在本章剩余部分探索的结构。该解决方案包含一个具有配置、控制器、对象和视图文件的单一项目。
- en: C# uses a hierarchical relationship for solutions and projects to organize its
    codebases. A solution can have many projects, but a project typically is part
    of only one solution. It is very much a parent (solution) -child (project) pattern.
    Note, however, that a project cannot contain subprojects. Figure 3.10 gives us
    a clear look at the layout of the codebase. We see folders with names such as
    App_Start, Controller, and Objects. These show the use of a Model-View-Controller
    pattern, albeit with slightly different terms.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: C#使用解决方案和项目之间的层次关系来组织其代码库。一个解决方案可以有多个项目，但一个项目通常只属于一个解决方案。这非常像一个父（解决方案）-子（项目）模式。然而，请注意，项目不能包含子项目。图3.10清楚地展示了代码库的布局。我们看到名为App_Start、Controller和Objects等文件夹。这些显示了使用模型-视图-控制器模式，尽管术语略有不同。
- en: The Model-View-Controller design pattern
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 模型-视图-控制器设计模式
- en: One of the most used design patterns in software development, the Model-View-Controller
    (MVC) pattern distances any user and external interfaces from the business logic
    and the stored data. The MVC pattern has grown in popularity in the last decade
    because it is immensely useful for both desktop and web development.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中最常用的设计模式之一，模型-视图-控制器（MVC）模式将任何用户和外部接口与业务逻辑和存储数据隔离开来。MVC模式在过去十年中越来越受欢迎，因为它对桌面和Web开发都非常有用。
- en: When using MVC, the model layer does most of the work. We store all our data
    in models and perform most necessary business logic in the models themselves.
    To interact with this data, we usually want some kind of user interaction. That
    is where the controller and view layers come in. A controller acts as a funnel,
    routing user requests to the model layer. The view layer consists of objects that
    represent specific “views” of the data in the model layer. The controller layer
    returns these views to the user.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用MVC时，模型层做大部分工作。我们将所有数据存储在模型中，并在模型本身执行大部分必要的业务逻辑。为了与这些数据交互，我们通常需要某种用户交互。这就是控制器和视图层发挥作用的地方。控制器充当漏斗，将用户请求路由到模型层。视图层由表示模型层中特定“视图”的对象组成。控制器层将这些视图返回给用户。
- en: Throughout this book, bit by bit, you will gain an in-depth understanding of
    how to use MVC-like patterns and models. After reading this book, you will be
    intimately familiar with models, views, and controllers.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，你将逐步深入理解如何使用类似MVC的模式和模型。阅读完本书后，你将对模型、视图和控制器有深刻的了解。
- en: 'Another good resource on the MVC pattern (and other design patterns) is Eric
    Freeman, Elisabeth Robson, Bert Bates, and Kathy Sierra’s *Head First: Design
    Patterns* (O’Reilly, 2004).'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '另一个关于MVC模式（以及其他设计模式）的好资源是Eric Freeman、Elisabeth Robson、Bert Bates和Kathy Sierra的《Head
    First: Design Patterns》（O’Reilly，2004年）。'
- en: 'Looking from the top, we see that the solution name is `FlyingDutchmanAirlinesExisting`
    and that it contains a project with the same name. That brings us to our first
    source code file: AssemblyInfo.cs. This file is in the project’s root folder,
    but Visual Studio visualizes it in a separate Properties category.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部看，我们看到解决方案的名称是`FlyingDutchmanAirlinesExisting`，并且它包含一个同名项目。这带我们来到了第一个源代码文件：AssemblyInfo.cs。此文件位于项目的根目录中，但Visual
    Studio将其可视化在单独的属性类别中。
- en: The AssemblyInfo file is not a file you venture into very much in daily life.
    It contains metadata about your assembly, such as the assembly title and version.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: AssemblyInfo文件不是你在日常生活中经常冒险进入的文件。它包含有关你的程序集的元数据，例如程序集标题和版本。
- en: In contrast to AssemblyInfo.cs, the next file is of much interest. Because we
    are dealing with a web service, we need to have some kind of routing for our endpoints.
    This is served by the `RouteConfig` class in the App_Start folder.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 与 AssemblyInfo.cs 相比，下一个文件更有趣。因为我们正在处理一个 Web 服务，我们需要对我们的端点进行某种路由。这由 App_Start
    文件夹中的 `RouteConfig` 类提供。
- en: Opening up the RouteConfig file
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 RouteConfig 文件
- en: 'As shown in the next listing, opening up `RouteConfig`, we see that the class
    only has one method: `RegisterRoutes`.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如下一个列表所示，打开 `RouteConfig`，我们看到该类只有一个方法：`RegisterRoutes`。
- en: Listing 3.1 RouteConfig.cs
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.1 RouteConfig.cs
- en: '[PRE0]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Listing 3.1 shows the `RouteConfig` class minus routine things such as a namespace
    declaration and package imports.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.1 显示了 `RouteConfig` 类，省略了诸如命名空间声明和包导入等常规事项。
- en: NOTE Most source code listings in this book do not include the required imports
    because they would take up a lot of space in every listing.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 备注：本书中的大多数源代码列表都没有包含所需的导入，因为它们会在每个列表中占用很多空间。
- en: The `RegisterRoutes` method allows us to specify a pattern for mapping incoming
    HTTP routes to endpoints in our code. `RegisterRoutes` returns no value (`void`)
    and takes in an instance of `RouteCollection`, a class of the ASP.NET Framework.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`RegisterRoutes` 方法允许我们指定一个模式，将传入的 HTTP 路由映射到我们代码中的端点。`RegisterRoutes` 返回无值（`void`），并接受一个
    `RouteCollection` 实例，这是 ASP.NET 框架中的一个类。'
- en: DEFINITION ASP.NET is a web framework that ties deeply into the .NET Framework,
    .NET Core, and .NET 5\. ASP.NET adds web development capabilities to C# such as
    WebAPI support and URL routing. Because of its deep integration into the .NET
    ecosystem, people sometimes do not realize they are calling libraries from ASP.NET.
    Throughout this book, we’ll use ASP.NET but won’t explicitly call out when we
    do. For more information on ASP.NET, see Andrew Lock’s excellent *ASP.NET Core
    in Action* (2nd edition; Manning, 2020).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：ASP.NET 是一个深度集成到 .NET Framework、.NET Core 和 .NET 5 的 Web 框架。ASP.NET 为 C#
    添加了 Web 开发功能，例如 WebAPI 支持 和 URL 路由。由于其深度集成到 .NET 生态系统，人们有时并没有意识到他们正在调用 ASP.NET
    的库。在这本书中，我们将使用 ASP.NET，但不会明确指出我们正在这样做。有关 ASP.NET 的更多信息，请参阅安德鲁·洛克编写的优秀的 *ASP.NET
    Core in Action*（第 2 版；Manning，2020年）。
- en: '| ![](../Images/ThumbsUp.png)   |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| ![点赞](../Images/ThumbsUp.png)   |'
- en: Should you avoid static?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该避免使用静态吗？
- en: Being able to access your methods or fields without having to create an instance
    of the class can be very useful. It certainly is easy to access your code wherever
    you want and whenever you want (assuming what you are trying to access is also
    public). But before you mark everything as static, I would urge you to reconsider.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在不创建类实例的情况下访问你的方法或字段可能非常有用。当然，在任何你想要和需要的时候访问你的代码都很容易（假设你试图访问的内容也是公共的）。但在你将所有内容标记为静态之前，我强烈建议你重新考虑。
- en: Yes, you can access a static method or field without creating an object instance,
    but so can somebody else. You are unlikely to be the only developer working in
    a given codebase, and as a result, you can’t predict their needs and assumptions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，你可以访问一个静态方法或字段，而不需要创建一个对象实例，但其他人也可以这样做。你不太可能是唯一一个在给定代码库中工作的开发者，因此你无法预测他们的需求和假设。
- en: 'For example, consider the following code found in an imaginary video game:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下在一个虚构的视频游戏中找到的代码：
- en: '[PRE1]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We have a record type called `Player` and a public static string field representing
    the player’s `health`. When the player’s health is damaged, the game loop logic
    calls as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为 `Player` 的记录类型，以及一个表示玩家 `health` 的公共静态字符串字段。当玩家的健康受到损害时，游戏循环逻辑调用如下：
- en: '[PRE2]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This decreases the health of the player by 1\. All is well for a single-player
    adventure, but what if we want multiple players, perhaps for a local co-op or
    split-screen feature? We’ll just instantiate another `Player`! But now we have
    two instances of `Player`, both using the same static Health field. When we now
    decrease health for one player, it’s decreased for all. This could be a neat game-play
    twist, but in general, we want to avoid changing the state across instances through
    `static`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这将玩家的健康减少 1。对于单人冒险来说一切都很顺利，但如果我们想有多个玩家，可能为了本地合作或分屏功能呢？我们只需实例化另一个 `Player`！但现在我们有两个
    `Player` 实例，它们都在使用相同的静态 Health 字段。当我们现在为一名玩家减少健康时，所有玩家的健康都会减少。这可能会是一个很酷的游戏玩法转折，但总的来说，我们想要避免通过
    `static` 在实例之间改变状态。
- en: '|'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'The only operation executed in the `RouteConfig.RegisterRoutes` method is the
    call to the `MapRoute` method, which is part of the `RouteCollection` instance
    passed into the `RegisterRoutes` method. `MapRoute` takes in two things: what
    we want to call the routing pattern (`Default`) and what the actual routing pattern
    is (`{controller}/ {action}/{id}`). When you add an ID to a routing pattern, as
    we have done, it becomes a URL path variable parameter. A common use case for
    a URL path variable is using them with HTTP `GET` calls to specify a specific
    resource to get by a resource ID, as shown in the next listing.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `RouteConfig.RegisterRoutes` 方法中执行的唯一操作是调用 `MapRoute` 方法，这是传递给 `RegisterRoutes`
    方法的 `RouteCollection` 实例的一部分。`MapRoute` 接收两个参数：我们想要命名的路由模式（`Default`）以及实际的路由模式（`{controller}/{action}/{id}`）。当你向路由模式添加一个
    ID，就像我们这样做，它就变成了一个 URL 路径变量参数。URL 路径变量的一个常见用例是使用 HTTP `GET` 调用来指定通过资源 ID 获取特定资源的操作，如下一列表所示。
- en: Listing 3.2 Setting up HTTP routes
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.2 设置 HTTP 路由
- en: '[PRE3]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ MapRoute scans the codebase for matching routes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ MapRoute 在代码库中扫描匹配的路由。
- en: ❷ We specify the name of the route as Default.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们将路由的名称指定为 Default
- en: ❸ The route we scan for is determined here.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们在这里确定要扫描的路由
- en: We’ll see more of this routing pattern and how it works in action when we look
    at the `FlightController` in chapter 4.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在第 4 章中查看 `FlightController` 时，我们将看到更多关于这种路由模式及其工作方式的示例。
- en: Looking at the WebApiConfig file
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 WebApiConfig 文件
- en: 'The next file we see is WebApiConfig.cs. When we open the file, we see something
    peculiar: there is another class inside of `WebApiConfig`, as shown in the next
    code sample.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来看到的文件是 WebApiConfig.cs。当我们打开文件时，我们看到一些特别的东西：在 `WebApiConfig` 中还有一个类，如下一代码示例所示。
- en: Listing 3.3 WebApiConfig.cs and its nested class, `Defaults`
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.3 WebApiConfig.cs 及其嵌套类，`Defaults`
- en: '[PRE4]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Defaults is a nested class.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Defaults 是一个嵌套类。
- en: ❷ The register method is part of the WebApiConfig class, not Defaults.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 注册方法属于 WebApiConfig 类，而不是 Defaults。
- en: ❸ Calling MapHttpAttributeRoutes enables attribute routing.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 调用 `MapHttpAttributeRoutes` 启用属性路由
- en: ❹ We map routes following the API/Controller/ID pattern.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 我们按照 API/Controller/ID 模式映射路由。
- en: ❺ Allows for JSON responses to be returned
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 允许返回 JSON 响应
- en: '| ![](../Images/LightBulb.png)   | In C#, you can have nested classes and access
    them just like regular classes (depending on their access modifier). Nested classes
    come in handy when creating a dedicated class file would bring more confusion
    to the overall project structure than you want. Sometimes, a “throw-away” class
    inside the only class you use the nested class in can be cleaner than creating
    a new file. We’ll discuss how to improve this code in section 5.2.3.DEFINITION
    The code in listing 3.3 has a keyword we haven’t seen yet: `readonly`. When something
    is designated as read-only in C#, it means the value is immutable after assignment.
    |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/LightBulb.png)   | 在 C# 中，你可以拥有嵌套类，并且可以像使用常规类一样访问它们（取决于它们的访问修饰符）。嵌套类在创建一个专门的类文件可能比你想的给整个项目结构带来更多混淆时非常有用。有时，在只使用嵌套类的唯一类中的“一次性”类可能比创建一个新文件更干净。我们将在
    5.2.3 节中讨论如何改进这段代码。定义：列表 3.3 中的代码有一个我们还没有见过的关键字：`readonly`。在 C# 中，当某物被指定为只读后，它的值在赋值后是不可变的。'
- en: To access a public nested class from outside the class it is nested in, use
    the enclosing class to access it. For example, we can access the nested defaults
    class by using `WebApiConfig.Defaults`. You can use a nested class with any access
    modifier, but you are still at the mercy of the outer class’s access modifier.
    If the outer class has an access modifier of `internal` and the nested class is
    `public`, you still need to meet the access requirements of the outer class before
    accessing the nested class.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要从嵌套类的外部访问公共嵌套类，请使用封装类来访问它。例如，我们可以通过使用 `WebApiConfig.Defaults` 来访问嵌套的 defaults
    类。你可以使用任何访问修饰符的嵌套类，但你仍然受外部类访问修饰符的支配。如果外部类的访问修饰符为 `internal` 且嵌套类为 `public`，你仍然需要在访问嵌套类之前满足外部类的访问要求。
- en: 'NOTE For developers coming from Java: nested classes in C# do not have an implicit
    reference to the outer class. This is a difference in the practice of static nested
    classes in Java and nested classes in C#. C# also allows multiple non-nested classes
    in one file, as opposed to Java. This is not good practice, but it is allowed.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：对于来自 Java 的开发者：C# 中的嵌套类没有对外部类的隐式引用。这是 Java 中静态嵌套类的实践与 C# 中嵌套类的实践之间的一个区别。C#
    还允许在一个文件中存在多个非嵌套类，而 Java 则不允许。这不是一个好的实践，但它是允许的。
- en: 'The `Register` method requires a parameter of type `HttpConfiguration`. It
    uses the `HttpConfiguration` instance to do the following two things:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`Register`方法需要一个类型为`HttpConfiguration`的参数。它使用`HttpConfiguration`实例执行以下两个操作：'
- en: The runtime scans and maps all endpoints with route method attributes.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时扫描并映射所有带有路由方法属性的端点。
- en: The runtime allows for routes with optional URL parameters.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时允许具有可选URL参数的路由。
- en: 'A method attribute (called a method annotation in Java) can mark any method
    and is used to give it some metadata. Some examples of when we would use attributes
    follow:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 方法属性（在Java中称为方法注解）可以标记任何方法，并用于给它一些元数据。以下是一些我们会使用属性的情况的例子：
- en: To mark which fields should be serialized
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记哪些字段应该被序列化
- en: To mark which methods are obsolete
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记哪些方法是过时的
- en: To mark whether the method has a specific HTTP route assigned to it
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记方法是否分配了特定的HTTP路由
- en: In the case of the existing code, we see method attributes with routing in the
    `FlightController` class. A method attribute comprises two enclosing brackets
    with the respective attribute sandwiched in (e.g., `[MyMethodAttribute]`).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于现有代码，我们在`FlightController`类中看到了带有路由的方法属性。一个方法属性由两个括号包围，其中包含相应的属性（例如，`[MyMethodAttribute]`）。
- en: The `config.Routes.MapHttpRoute` is similar to the `routes.MapRoute` method
    in `RouteConfig` (listing 3.1). The code in `RouteConfig` configured the routes
    for endpoints with URL path parameters, but now we need to also configure routes
    to allow for routes without them. Once again, we pass in a name (`DefaultApi`)
    and a template (`api/{controller}/{id}`), but this time we also pass in a new
    `Defaults` object with the `Id` set to `RouteParameter.Optional`. This allows
    us to route both endpoints with and without the parameter (because it is now optional).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`config.Routes.MapHttpRoute`与`RouteConfig`中的`routes.MapRoute`方法类似（列表3.1）。`RouteConfig`中的代码配置了具有URL路径参数的端点路由，但现在我们还需要配置允许没有这些参数的路由。再次，我们传递一个名称（`DefaultApi`）和一个模板（`api/{controller}/{id}`），但这次我们还传递了一个新的`Defaults`对象，其`Id`设置为`RouteParameter.Optional`。这使得我们可以路由带有和不带有参数的端点（因为它现在是可选的）。'
- en: Finally, we set the accepted `MediaTypeMappings` to application/json in the
    call to `GlobalConfiguration.Configuration.Formatters.JsonFormatter.MediaTypeM``appings`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在调用`GlobalConfiguration.Configuration.Formatters.JsonFormatter.MediaTypeMappings`时将接受的`MediaTypeMappings`设置为application/json。
- en: 'Charting ASP.NET and configuration files: global.asax, packages.config, and
    web.config'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制ASP.NET和配置文件：global.asax、packages.config和web.config
- en: 'Let’s skip the folders called Controller, Objects, and ReturnViews, and look
    at the three source files at the bottom of the solution in the next listing: Global.asax,
    packages.config, and Web.config.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳过名为Controller、Objects和ReturnViews的文件夹，在下一列表中查看解决方案底部的三个源文件：Global.asax、packages.config和Web.config。
- en: Listing 3.4 Global.asax
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.4 Global.asax
- en: '[PRE5]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: What is this strange file extension .asax? We have not seen this extension before.
    An .asax file indicates a global application class. These classes are used in
    an ASP.NET application to execute code in response to lower-level system events
    such as the launching or ending of the service. The logic inside a global application
    class is the very first piece of code executed that we can manipulate. We can
    execute code at the start of our application by creating an `Application_Start`
    method, as in listing 3.4\. To execute code at the end of an application, put
    it in an `Application_End` method.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个奇怪的文件扩展名.asax是什么？我们之前没有见过这个扩展名。一个.asax文件表示一个全局应用程序类。这些类用于ASP.NET应用程序中执行对服务启动或结束等低级系统事件的响应代码。全局应用程序类中的逻辑是我们可以操纵的第一段代码。我们可以在应用程序开始时通过创建一个`Application_Start`方法来执行代码，如列表3.4所示。要在应用程序结束时执行代码，将其放在`Application_End`方法中。
- en: The `Application_Start` method has an access modifier state of `protected` and
    returns nothing. The `GlobalConfiguration.Configure` call registers a callback
    to where the `WebApiConfig` registers its routes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`Application_Start`方法具有`protected`访问修饰符，不返回任何内容。`GlobalConfiguration.Configure`调用注册了一个回调，其中`WebApiConfig`注册其路由。'
- en: DEFinition A *callback* is a function that is slated to be executed after the
    execution of the current function. You can think of it as a queuing system where
    the callback is enqueued (or cuts in line, depending on your perspective) for
    execution right after the current method’s processing is done. A caller calls
    the callee, passing it back a callback, which the callee invokes after its work
    completes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**DEFinition** 一个 *回调* 是一个计划在当前函数执行之后执行的函数。你可以将其视为一个排队系统，其中回调被排队（或者从队列中插入，取决于你的视角）以便在当前方法处理完毕后立即执行。调用者调用被调用者，并传递一个回调，被调用者在工作完成后调用这个回调。'
- en: Following the registration of the callback to register the routes, `RegisterRoutes`
    is called on the `RouteConfig`, and the `RouteTable`’s routes are passed in. This
    results in the areas of the routes (things between slashes, e.g., “/`flight`/”
    means `flight` is an area) that are defined in the `RouteTable` being registered
    and usable. We need to register the callbacks and call `RouteConfig` at launch
    because we could not execute them otherwise. Because the routes would not be registered,
    we could not kick off any execution by triggering an endpoint.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册回调以注册路由之后，`RegisterRoutes` 在 `RouteConfig` 上被调用，并将 `RouteTable` 的路由传递进去。这导致在
    `RouteTable` 中定义的路由区域（例如，斜杠之间的内容，如“/`flight`/”表示`flight`是一个区域）被注册并可用。我们需要在启动时注册回调并调用
    `RouteConfig`，因为我们否则无法执行它们。因为路由没有被注册，我们无法通过触发端点来启动任何执行。
- en: 'Two other files remain that we can square into the configuration camp: packages.config
    and Web.config. Packages.config is a file tied to the NuGet package manager. The
    NuGet package manager is the default package manager for .NET and is deeply integrated
    with Visual Studio. The packages.config file specifies what packages (and versions
    of said packages) are referenced and installed in solutions and projects. A target
    ASP.NET Framework is also specified. For example, this being an ASP.NET application
    and ASP.NET being a framework separate from .NET (but with heavy integration and
    mostly automatic installation support), it is referenced in the packages .config
    file as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下两个文件可以归入配置类别：packages.config 和 Web.config。packages.config 是一个与 NuGet 包管理器相关的文件。NuGet
    包管理器是 .NET 的默认包管理器，并与 Visual Studio 深度集成。packages.config 文件指定了在解决方案和项目中引用和安装的哪些包（以及这些包的版本）。还指定了一个目标
    ASP.NET Framework。例如，这是一个 ASP.NET 应用程序，而 ASP.NET 是一个与 .NET（但具有深度集成和主要自动安装支持）分开的框架，它在
    packages.config 文件中如下引用：
- en: '[PRE6]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Web.Config provides us with settings that configure how the application is
    supposed to run, what version of the .NET Framework to use (remember, this codebase
    runs on the .NET Framework), and compiler settings. For example, the compile mode
    we are running under is debug (the default mode). This is defined in the following
    line:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Web.Config 为我们提供了配置应用程序如何运行、使用哪个版本的 .NET Framework（记住，此代码库运行在 .NET Framework
    上）以及编译器设置的设置。例如，我们正在运行的编译模式是调试（默认模式）。这定义在以下行：
- en: '[PRE7]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'That brings us to the end of the configuration files. We’ll skip the `FlightController`
    class for now and look at the models and views we were provided: Booking.cs, Customer.cs,
    Flight.cs, and FlightReturnView.cs.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这就带我们来到了配置文件的结尾。现在我们将跳过 `FlightController` 类，看看我们提供的模型和视图：Booking.cs，Customer.cs，Flight.cs，和
    FlightReturnView.cs。
- en: 3.3.3 Considering models and views in the existing codebase
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.3 考虑现有代码库中的模型和视图
- en: 'In the MVC pattern, models should mirror the structure of database tables,
    whereas views are driven by clients. Views act as a representation of the data,
    determined by the client. We’ll discuss what that means further in section 10.1.1\.
    In this section, we’ll look at the models and views that the inherited codebase
    contains. The project has the following three models:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MVC 模式下，模型应该反映数据库表的结构，而视图则由客户端驱动。视图充当数据的表示，由客户端决定。我们将在第 10.1.1 节进一步讨论这意味着什么。在本节中，我们将查看继承的代码库中包含的模型和视图。项目有以下三个模型：
- en: '`Booking`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`预订`'
- en: '`Customer`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`客户`'
- en: '`Flight`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flight`'
- en: 'The code also has one view: `FlightReturnView`. In an ideal world, the models
    closely resemble what is present in the database, but it looks like the existing
    code is not quite there yet.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 代码还有一个视图：`FlightReturnView`。在一个理想的世界里，模型与数据库中的内容非常相似，但看起来现有的代码还没有完全达到这一点。
- en: Uncovering the Booking model and its internal details
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 揭示预订模型及其内部细节
- en: 'Models represent an important cornerstone of a web service. They hold data
    that we can spin and twist into perspectives and show different angles through
    views. The first model we’ll look at is the `Booking` model. The idea behind this
    model is to provide an object to hold data about the booking of a flight, as shown
    in the next code sample:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 模型代表了一个网络服务的重要基石。它们持有我们可以旋转和扭曲成不同视角并通过视图展示不同角度的数据。我们将首先查看的模型是`Booking`模型。这个模型背后的想法是提供一个对象来保存有关航班预订的数据，如以下代码示例所示：
- en: '[PRE8]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We see that the `Booking` model is fairly simple and contains three fields (`OriginAirportIATA`,
    `DestinationAirportIATA`, and `Name`), all with a public access modifier. This
    would be an opportunity to introduce some encapsulation by adding a backing field,
    getter, and setter.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`Booking`模型相当简单，包含三个字段（`OriginAirportIATA`、`DestinationAirportIATA`和`Name`），所有字段都具有公共访问修饰符。这将是一个引入一些封装的机会，通过添加后置字段、获取器和设置器。
- en: Why getters and setters matter (auto-properties and init-only setters)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么获取器和设置器很重要（自动属性和仅初始化设置器）
- en: 'Encapsulation: you’ve heard the term many times before, but it is tricky to
    do it right. A major motivation for encapsulation is to provide controlled access
    to your code. You can fine tune how you want others to interact with your work
    and provide access guidelines through access modifiers. Opponents of getters and
    setters say it bloats the code and that it is time consuming to write getters
    and setters for every property. Proponents would counter by pointing out that
    controlling access to a property is not code bloat and that it increases speed
    in the long run.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 封装：你以前多次听说过这个术语，但正确实施它很棘手。封装的主要动机是提供对代码的受控访问。你可以微调其他人如何与你互动，并通过访问修饰符提供访问指南。获取器和设置器的反对者说，它们会使代码膨胀，并且为每个属性编写获取器和设置器很耗时。支持者会通过指出控制属性的访问不是代码膨胀，并且从长远来看它会增加速度来反驳。
- en: Imagine having a codebase like the one we are considering right now. Perhaps
    you are getting the `Booking.Name` string in 50 places by directly accessing it.
    What would happen if you need to change the original property’s name to `Booking.NewName`?
    You would have to change the call in 50 different locations, making your life
    miserable. Some IDEs do have functionality that can automate this process for
    you, but then you are relying on an IDE to fix your code smell. I prefer having
    the code be clean so we don’t have to use a tool to automate a fix for us.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你有一个像我们现在考虑的这样的代码库。也许你在50个地方直接访问`Booking.Name`字符串。如果你需要将原始属性的名字更改为`Booking.NewName`，会发生什么？你将不得不在50个不同的位置更改调用，这会让你感到非常痛苦。一些IDE确实具有自动化此过程的功能，但这样你就是在依赖IDE来修复你的代码问题。我更喜欢代码干净，这样我们就不需要使用工具来自动修复问题。
- en: 'Now imagine you write a (what some people call “Java-style”) getter (`Booking.GetName`)
    and a setter (`Booking.SetName(string name)`) and use those to access and change
    your property? You would need to change things in only one place: the original
    class. Getters and setters have another critical purpose: they control access
    to your property and dictate who can do what with it. Another use case for getters
    and setters is making your property `readonly` but only to outside classes. If
    you were to apply the `readonly` modifier to the field, it would hold for everybody.
    Instead, you can accomplish the same thing by being strategic with getters and
    setters. If you make the setter private but the getter public, code outside of
    the encapsulating class can access but not edit the property. You can also add
    logic inside the setters and getters. For example, do you need to do some validation
    of the passed-in arguments before setting the property to a new value? Add the
    logic in the setter.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，你编写了一个（有些人称之为“Java风格”）的获取器（`Booking.GetName`）和一个设置器（`Booking.SetName(string
    name)`），并使用它们来访问和更改你的属性？你只需要在一个地方更改内容：原始类。获取器和设置器还有一个关键用途：它们控制对属性的访问并规定谁可以做什么。获取器和设置器的另一个用例是使你的属性`readonly`，但仅限于外部类。如果你要将`readonly`修饰符应用于字段，它将对所有人有效。相反，你可以通过策略性地使用获取器和设置器来达到同样的效果。如果你将设置器设为私有但获取器为公共，封装类之外的外部代码可以访问但不能编辑该属性。你还可以在设置器和获取器中添加逻辑。例如，在设置属性为新值之前，你需要对传入的参数进行一些验证吗？在设置器中添加逻辑。
- en: 'Some of the ways you can use getters and setters in C# include the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在C#中使用获取器和设置器的一些方法包括以下内容：
- en: The traditional dual-method technique where you create two new methods (a dedicated
    getter and a dedicated setter method) and use those
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统的双重方法技术，其中你创建两个新方法（一个专门的获取器和专门的设置器方法）并使用这些方法
- en: Auto-properties
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动属性
- en: Init-only setters[¹](#pgfId-1178117)
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只初始化设置器[¹](#pgfId-1178117)
- en: With auto-properties, you can inline the getters and setters and let the compiler
    do the work of creating the methods under the hood. This is one place where you
    can take the abstraction .NET provides and use it to your advantage.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自动属性，你可以内联获取器和设置器，让编译器在幕后创建方法。这是你可以利用.NET提供的抽象并为你带来好处的一个地方。
- en: 'Let’s compare and contrast the two approaches by applying them to a `name`
    field. First up is the traditional dual-method option, shown here:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过将它们应用于一个`name`字段来比较和对比这两种方法。首先介绍的是传统的双重方法选项，如下所示：
- en: '[PRE9]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The field containing the value is private (in C#, private fields are often
    prefixed with an underscore) and named `_name`. This field is sometimes called
    a “backing field” because the field “backs” the getter and setter. Two methods
    are created to regulate setting and getting `_name: GetName` and `SetName`. In
    this example, everybody can get the name, but only this class and classes inheriting
    from this class can set the name field (protected). To better regulate access
    (and improve readability), we can use an auto-property as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 包含该值的字段是私有的（在C#中，私有字段通常以下划线开头）并命名为`_name`。这个字段有时被称为“后置字段”，因为该字段“支持”获取器和设置器。创建了两个方法来规范设置和获取`_name`：`GetName`和`SetName`。在这个例子中，每个人都可以获取名称，但只有这个类及其继承自这个类的类可以设置名称字段（受保护）。为了更好地规范访问（并提高可读性），我们可以使用如下所示的自动属性：
- en: '[PRE10]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The auto-property is only one line, yet it provides the same functionality as
    the dual-method technique. If no access modifier is provided, the getter or setter
    defaults to the property’s method accessor, as seen with `get` in this example.
    You can also provide method bodies to the getter and setter just by adding curly
    braces and a body.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 自动属性只有一行，但它提供了与双重方法技术相同的功能。如果没有提供访问修饰符，获取器或设置器的默认值是属性的方法访问器，如本例中的`get`所示。你还可以通过添加花括号和主体来为获取器和设置器提供方法体。
- en: '| ![](../Images/LightBulb.png)   | With C# 9, a new way of using setters was
    introduced: init-only setters. This technique allows you to create immutable properties
    (often wrapped in an object) by using the `init` keyword. We start as if we create
    an auto-property, but instead of specifying a getter, we use `init`. Let’s say
    the `Name` property we’ve been using is part of a class called `Person` and uses
    an init-only setter as follows: |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/LightBulb.png)   | 从C# 9开始，引入了一种使用设置器的新方法：只初始化设置器。这种技术允许你通过使用`init`关键字创建不可变属性（通常封装在对象中）。我们就像创建一个自动属性一样开始，但不是指定获取器，而是使用`init`。假设我们一直在使用的`Name`属性是`Person`类的一部分，并使用只初始化设置器如下所示：'
- en: '[PRE11]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can create an instance of `Person` pretty easily, but because we used the
    init-only setter for `Name`, we can’t come back and set a value for `Name` after
    instantiation, as shown here:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地创建`Person`的实例，但由于我们为`Name`使用了只初始化设置器，所以我们不能在实例化后返回并设置`Name`的值，如下所示：
- en: '[PRE12]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This puts us in a bit of a bind. If we try to assign a value to `Name`, we
    get a compiler error telling us we cannot assign to the init-only property unless
    we are in an object initializer, a constructor, or an init accessor. We’ll look
    at object initializers much further in section 6.2.5, but to give you a little
    preview, we can assign the initial value to `Person.Name` with an object initializer
    as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们陷入了一点困境。如果我们尝试将值分配给`Name`，我们会收到编译器错误，告诉我们除非我们处于对象初始化器、构造函数或初始化访问器中，否则不能将值分配给只初始化的属性。我们将在第6.2.5节中更深入地探讨对象初始化器，但为了给你一点预览，我们可以使用以下方式使用对象初始化器将初始值分配给`Person.Name`：
- en: '[PRE13]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This sets the value for `Name` to `"Sally"` at object creation rather than attempting
    to set the value after the object is created. This restriction forces you to assign
    to an init-only setter in a very specified way, and it stops people from overwriting
    the values after they are set.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这在对象创建时将`Name`的值设置为`"Sally"`，而不是在对象创建后尝试设置值。这个限制迫使你以非常具体的方式将值分配给只初始化的设置器，并阻止人们在值设置后覆盖这些值。
- en: Comparing the Booking model and table
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 比较预订模型和表格
- en: If we compare the `Booking` model with the Booking table in the database, we
    see some discrepancies, including one that would have a security engineer cry
    foul. None of the fields in the `Booking` model match the Booking table in the
    database. There even seem to be some erroneous additions, as shown in figure 3.11.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`Booking`模型与数据库中的Booking表进行比较，我们会发现一些差异，包括一些可能会让安全工程师感到不满的差异。`Booking`模型中的所有字段都与数据库中的Booking表不匹配。甚至似乎还有一些错误添加，如图3.11所示。
- en: '![](../Images/03_11.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03_11.png)'
- en: Figure 3.11 The isomorphic relationship between the `Booking` class and dbo.Booking.
    Every field is incorrect; this is not good. The Xs indicate fields with an incorrect
    isomorphic relationship.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 `Booking`类与dbo.Booking之间的同构关系。每个字段都是错误的；这并不好。X表示同构关系不正确的字段。
- en: 'There is one positive thing to say about the `Booking` class: it has the right
    name. But that is about it. As we can see, the model contains no representations
    of `FlightNumber`, `BookingID`, or `CustomerID`. Looking back at figure 3.9, we
    see that those fields are involved with key constraints (`BookingID` is a primary
    key. `FlightNumber` and `CustomerID` have foreign key relationships). The model
    contains fields for the origin airport IATA code, destination airport IATA code,
    and the customer name.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`Booking`类，有一件积极的事情可以说：它有一个正确的名字。但仅此而已。正如我们所见，该模型不包含`FlightNumber`、`BookingID`或`CustomerID`的表示。回顾图3.9，我们看到这些字段与关键约束有关（`BookingID`是主键。`FlightNumber`和`CustomerID`有外键关系）。模型包含出发机场IATA代码、目的地机场IATA代码和客户名称的字段。
- en: The Customer model and its internal details
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 客户模型及其内部细节
- en: 'With some hesitation, we look at the next model, which follows—`Customer`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有些犹豫地查看下一个模型，即接下来的`Customer`：
- en: '[PRE14]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The damage is fairly controlled in the `Customer` class. `Customer` also has
    good isomorphism between database tables, as shown in figure 3.12.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Customer`类中，损害得到了相当的控制。`Customer`与数据库表之间也有良好的同构性，如图3.12所示。
- en: '![](../Images/03_12.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03_12.png)'
- en: Figure 3.12 The isomorphic relationship between the (abbreviated) `Customer`
    class and dbo.Customer. CustomerID and Name map correctly.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 (缩略) `Customer`类与dbo.Customer之间的同构关系。CustomerID和Name映射正确。
- en: From what we can tell, no changes are needed to get `Customer` up to date with
    the database table.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的了解，为了使`Customer`与数据库表保持一致，不需要进行任何更改。
- en: Boarding the Flight class and its internal details
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 登上`Flight`类及其内部细节
- en: 'Turning to the `Flight` class, we see in the following code sample that `Flight`
    has three fields, all of them integers, which almost map completely to the database
    table Flight:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 转到`Flight`类，在下面的代码示例中我们可以看到`Flight`有三个字段，它们都是整数类型，几乎完全映射到数据库表Flight：
- en: '[PRE15]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Comparing the `Flight` class’s fields to the database table, we see that, in
    essence, the model is correct. But we are in the business of writing *clean code*,
    and that also means that we have consistency across the codebase and database
    when it comes to field names. It is also worth mentioning that the whole foundation
    of having database models in your codebase (be it through ORM or manually) relies
    on the practice of the closest interpretation of the isomorphic relationship between
    a database row and a class.[²](#pgfId-1178215) It’s important to keep in mind
    that even though the name of a field might be the same as the name of a column
    in the database, it is still an abstraction. They are not the same; yet to us,
    they are as close as they can get.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Flight`类的字段与数据库表进行比较，我们看到本质上模型是正确的。但我们从事的是编写*干净的代码*，这也意味着在代码库和数据库中，关于字段名，我们需要保持一致性。还值得一提的是，代码库中拥有数据库模型（无论是通过ORM还是手动）的整个基础都依赖于对数据库行与类之间同构关系的最接近解释的实践。[²](#pgfId-1178215)
    需要记住的是，尽管字段名可能与数据库中的列名相同，但它仍然是一个抽象。它们并不相同；然而，对我们来说，它们尽可能地接近。
- en: '| ![](../Images/LightBulb.png)   | Applying an isomorphic relationship to database
    and codebase communication makes a strong case for always using ORM, because you
    get the closest match between representation in code and representation in the
    database. |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/LightBulb.png)   | 将同构关系应用于数据库和代码库之间的通信，强烈建议始终使用ORM，因为您将获得代码表示和数据库表示之间最接近的匹配。|'
- en: 'As designated in figure 3.13 by the “?!” icons, we have a mismatch in two field
    names:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如图3.13中的“?!”图标所示，我们发现了两个字段名的不匹配：
- en: '`OriginID` versus Origin'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OriginID`与Origin的比较'
- en: '`DestinationID` versus Destination'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DestinationID`与Destination的比较'
- en: '![](../Images/03_13.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03_13.png)'
- en: Figure 3.13 The isomorphic relationship between the (abbreviated) `Flight` class
    and dbo.Flight. The Origin/`OriginID` and Destination/`DestinationID` are very
    close matches. FlightNumber is a solid match.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 （简化的）`Flight`类与dbo.Flight之间的同构关系。Origin/`OriginID`和Destination/`DestinationID`非常接近匹配。FlightNumber是一个完美的匹配。
- en: In situations like this, the database rules. When we start our work on the refactored
    version of the API, Entity Framework Core makes sure that these discrepancies
    do not occur.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，数据库规则。当我们开始对API重构版本的工作时，Entity Framework Core确保这些差异不会发生。
- en: Flight, Booking, and Customer make up the contents of the Models folder. But
    wait a second, let’s have another look at our database schema. It looks like there
    may be something missing ...
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flight`、`Booking`和`Customer`构成了`Models`文件夹的内容。但是等等，让我们再次看看我们的数据库模式。看起来可能有些东西缺失
    ...'
- en: As we can deduce from figure 3.14, we did not encounter any class that could
    be said to model the Airport table. So, does the code work?
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从图3.14中可以推断出的，我们没有遇到任何可以称为模拟机场表的类。那么，代码是否工作正常呢？
- en: '![](../Images/03_14.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03_14.png)'
- en: Figure 3.14 The database schema when contrasted to the codebase’s models. Models
    representing the tables Flight, Booking, and Customer are present in the codebase;
    Airport is not. This means there is an incomplete isomorphic relationship between
    the codebase and the database.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14 与代码库模型相比的数据库模式。代码库中存在代表Flight、Booking和Customer的模型；机场不存在。这意味着代码库与数据库之间存在不完整的同构关系。
- en: If we had some tests, we may have been able to say one way or the other, or
    if coverage was spotty and not in the right places, we could at the very least
    attempt a sort of proof by induction[³](#pgfId-1178238) based on the tests that
    do exist to prove the correct functionality of the methods. It might be very true
    that without the `Airport` class we can still perform all the functions we want
    and provide value to the customer. It is also true that the developers of this
    code have likely made their life harder by not sticking to the format of their
    source data.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有测试，我们可能能够确定一种方式或另一种方式，或者如果覆盖率零散且不在正确的位置，我们至少可以尝试一种基于现有测试的归纳证明[³](#pgfId-1178238)，以证明方法的正确功能。可能非常真实的是，没有`Airport`类，我们仍然可以执行我们想要的全部功能，并为客户提供服务。这也意味着，这个代码的开发者可能通过不坚持源数据格式而使自己的生活变得更难。
- en: The FlightReturnView view and its internal details
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`FlightReturnView` 视图及其内部细节'
- en: 'Having thoroughly explored the models and how they match up with the database,
    we turn our view to the ReturnViews folder. A `View` allows us to represent the
    data encapsulated in a model (or many models) in any way that we want. As shown
    next, there is only one view in the ReturnViews folder—`FlightReturnView`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在彻底探索了模型以及它们如何与数据库匹配之后，我们将目光转向`ReturnViews`文件夹。一个`View`允许我们以任何我们想要的方式表示模型（或多个模型）中封装的数据。如以下所示，`ReturnViews`文件夹中只有一个视图——`FlightReturnView`：
- en: '[PRE16]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`FlightReturnView` is a very simple class with just three fields: `FlightNumber`
    (integer), `Origin` (string), and `Destination` (string). A view is a slice of
    an object(s) molded to reflect only a subsection of details or a combination of
    details from many models (a denormalized view). Here, the developers wanted to
    return `FlightNumber`, `Origin`, and `Destination` fields to the user. Returning
    the `Flight` class would not be sufficient because that does not contain `Origin`
    or `Destination`. Likewise, returning the `Booking` class also would not have
    sufficed as it only contains `FlightNumber`, and not `Origin` or `Destination`.
    Using views to return data is a powerful design pattern often used in API development.
    It can be construed as having powers similar to the JOIN SQL operation, because
    you can join multiple datasets in any way you want. That being said, if we can
    get away with not using one, that would be better, because it increases the complexity
    of the codebase.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`FlightReturnView` 是一个非常简单的类，只有三个字段：`FlightNumber`（整数）、`Origin`（字符串）和`Destination`（字符串）。视图是对象（或多个对象）的一个切片，被塑造成仅反映细节的一个子集或多个模型细节的组合（一个非规范化视图）。在这里，开发者希望将`FlightNumber`、`Origin`和`Destination`字段返回给用户。返回`Flight`类是不够的，因为它不包含`Origin`或`Destination`。同样，返回`Booking`类也不够，因为它只包含`FlightNumber`，而不包含`Origin`或`Destination`。使用视图返回数据是一种强大的设计模式，常用于API开发。它可以被理解为具有类似于SQL
    JOIN操作的能力，因为你可以以任何方式连接多个数据集。话虽如此，如果我们能避免使用它，那就更好了，因为它增加了代码库的复杂性。'
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: An object-relational mapping tool allows us to deal with databases at a higher
    abstraction level than querying them directly with SQL.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个对象关系映射工具允许我们在比直接使用 SQL 查询数据库更高的抽象级别上处理数据库。
- en: A C# repository usually contains one solution, which in turn contains multiple
    projects. Keeping with this pattern makes your codebase easier to navigate for
    seasoned C# developers.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 C# 仓库通常包含一个解决方案，该解决方案又包含多个项目。遵循这种模式可以使你的代码库对经验丰富的 C# 开发者更容易导航。
- en: The ASP.NET Framework is a framework aimed at developing web services and is
    part of the .NET ecosystem. We can use ASP.NET in the .NET Framework, .NET Core,
    and .NET 5\. We use ASP.NET to create web services.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET 框架是一个旨在开发 Web 服务的框架，它是 .NET 生态系统的一部分。我们可以在 .NET 框架、.NET Core 和 .NET
    5 中使用 ASP.NET 来创建 Web 服务。
- en: We need to define and register HTTP routes through the use of a `RouteConfig`.
    If we do not do this, we cannot reach our endpoints.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要通过使用 `RouteConfig` 来定义和注册 HTTP 路由。如果我们不这样做，我们就无法到达我们的端点。
- en: We can attach attributes to methods, fields, and properties. An example of an
    attribute is `[FromBody]`.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以为方法、字段和属性附加属性。一个属性的例子是 `[FromBody]`。
- en: A callback is a function that is to be executed after the current function.
    We can use callbacks to queue certain methods to execute when we want them instead
    of immediately.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调是一个要在当前函数执行后执行的函数。我们可以使用回调来排队某些方法，以便在我们想要它们执行时而不是立即执行。
- en: The NuGet package manager is C#’s premier package manager. We can use it to
    install third-party packages or the packages of .NET that are not part of the
    regular SDK, such as ASP.NET.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NuGet 包管理器是 C# 的首选包管理器。我们可以用它来安装第三方包或不属于常规 SDK 的 .NET 包，例如 ASP.NET。
- en: '* * *'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^(1.)Init-only setters were introduced as part of C# 9\. Only .NET 5 (and later
    versions) support C# 9\. Init-only setters (and C# 9) are not supported on .NET
    Framework or .NET Core.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ^ (1.) 仅初始化设置器是在 C# 9 中引入的。只有 .NET 5（及以后的版本）支持 C# 9。仅初始化设置器（和 C# 9）在 .NET 框架或
    .NET Core 上不受支持。
- en: '^(2.)For more information on isomorphic relationships and how they map true
    statements to interpreted theorems (e.g., database schemas to models), see chapter
    2 (“Meaning and Form in Mathematics”) of Douglas R. Hofstadter’s Pulitzer Prize–winning
    *Gödel, Escher, Bach: An Eternal Golden Braid* (Basic Books, 1977) and Richard
    J. Trudeau’s *Introduction to Graph Theory* (2nd edition; Dover Publications,
    1994).'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ^ (2.) 关于同构关系及其如何将真实陈述映射到解释定理（例如，数据库模式到模型）的更多信息，请参阅道格拉斯·R·霍夫施塔特（Douglas R. Hofstadter）的普利策奖获奖作品
    *哥德尔、艾舍尔、巴赫：永恒的金色纽带*（Basic Books，1977）的第2章（“数学的意义与形式”）和理查德·J·特鲁多（Richard J. Trudeau）的
    *图论导论*（第2版；Dover Publications，1994）。
- en: '^(3.)If you want to learn more about proof by induction, I recommend two resources.
    First, watch the initial three video lectures (*Introduction and Proofs*, *Induction*,
    and *Strong Induction*) of MIT’s *Mathematics for Computer Science 6.042J* course
    (MIT OpenCourseWare, 2010) at [https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-fall-2010/index.htm](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-fall-2010/index.htm).
    Second, I recommend section 1.2.1 (“Mathematical Preliminaries / Mathematical
    Induction”) in Donald Knuth’s *The Art of Computer Programming, Volume 1: Fundamental
    Algorithms* (3rd edition; Addison Wesley Longman, 1977).'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ^ (3.) 如果你想了解更多关于归纳证明的信息，我推荐两个资源。首先，观看麻省理工学院 *计算机科学数学 6.042J 课程* 的前三场视频讲座（*引言与证明*、*归纳*和*强归纳*）（MIT
    OpenCourseWare，2010），网址为 [https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-fall-2010/index.htm](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-fall-2010/index.htm)。其次，我推荐唐纳德·E·克努特（Donald
    Knuth）的 *计算机程序设计艺术，第一卷：基本算法*（第3版；Addison Wesley Longman，1977）中的第1.2.1节（“数学预备知识/数学归纳法”）。
