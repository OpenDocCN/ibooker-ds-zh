- en: 5 Adding AI interfaces to a web application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 将人工智能界面添加到 Web 应用程序
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Speaking a note with Transcribe
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Transcribe 说话音符
- en: Reading back a schedule with Polly
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Polly 回读日程
- en: Adding a chatbot interface with Lex
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Lex 添加聊天机器人界面
- en: In this chapter we will build upon the to-do list application from chapter 4,
    adding off-the-shelf AI capability to the system. We will add natural language
    speech interfaces to record and transcribe text and to have the system tell us
    our daily schedule from our to-do list. Finally, we will add a conversational
    interface to the system, allowing us to interact entirely through a natural language
    interface. As we will see, this can be built very rapidly by harnessing cloud
    AI services to do the heavy lifting.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将基于第 4 章的待办事项应用程序进行构建，向系统中添加现成的 AI 功能。我们将添加自然语言语音接口来记录和转录文本，并让系统从我们的待办事项列表中告诉我们日常日程。最后，我们将向系统中添加一个对话界面，使我们能够完全通过自然语言界面进行交互。正如我们将看到的，这可以通过利用云
    AI 服务来完成，从而快速构建。
- en: If you haven’t worked through chapter 4, you should go back and do so now before
    proceeding with this chapter, as we will be building directly on top of the to-do
    list application that we deployed at the end of that chapter. If you’re good with
    the content from chapter 4, we can dive right in and add our note service. We
    will pick up where we left off, starting with step 3.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有完成第 4 章的内容，您应该在继续本章之前返回并完成它，因为我们将直接基于该章末尾部署的待办事项应用程序进行构建。如果您对第 4 章的内容感到满意，我们可以直接进入并添加我们的笔记服务。我们将从我们上次离开的地方开始，从步骤
    3 开始。
- en: '5.1 Step 3: Adding a speech-to-text interface'
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 步骤 3：添加语音到文本界面
- en: Now that we have a basic serverless application deployed and secured, it’s time
    to add in some AI features. In this section we are going to add a speech-to-text
    interface to allow us to dictate a note into the system rather than typing. We
    will use AWS Transcribe to do this. As we will see, adding in speech-to-text is
    actually not too hard for such an advanced feature.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经部署并安全了一个基本的无服务器应用程序，是时候添加一些人工智能功能了。在本节中，我们将添加一个语音到文本界面，使我们能够将笔记口述到系统中而不是键入。我们将使用
    AWS Transcribe 来实现这一点。正如我们将看到的，添加语音到文本实际上对于这样一个高级功能来说并不太难。
- en: Figure 5.1 shows how this feature will be implemented.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 显示了该功能的实现方式。
- en: '![](../Images/CH05_F01_Elger.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F01_Elger.png)'
- en: Figure 5.1 Step 3 architecture. The AWS Transcribe service is invoked from the
    note service. The front-end application uses Amplify to upload the file processed
    by Transcribe to S3.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 步骤 3 架构。AWS Transcribe 服务从笔记服务中调用。前端应用程序使用 Amplify 将 Transcribe 处理后的文件上传到
    S3。
- en: The system will use the browser to capture spoken audio and save it to S3 using
    the Amplify library. Once the audio file is uploaded, the note service is called.
    This will kick off a Transcribe job to convert the audio to text. The client will
    poll the note service periodically to determine when the conversion has been completed.
    Finally, the front end will populate the note field with the converted text.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 系统将使用浏览器捕获语音音频并将其保存到 S3，使用 Amplify 库。一旦音频文件上传，就会调用笔记服务。这将启动一个 Transcribe 任务将音频转换为文本。客户端将定期轮询笔记服务以确定转换何时完成。最后，前端将使用转换后的文本填充笔记字段。
- en: 5.1.1 Getting the code
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.1 获取代码
- en: The code for this step is in the directory `chapter5/step-3-note-service`. This
    directory contains all of the code from step 2, along with our audio transcription
    changes. As before, we will walk through the updates in turn first, and then deploy
    the changes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤的代码位于 `chapter5/step-3-note-service` 目录中。此目录包含步骤 2 的所有代码，以及我们的音频转录更改。与之前一样，我们将依次介绍更新，然后部署更改。
- en: 5.1.2 Note service
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.2 笔记服务
- en: 'Our note service follows what should by now be a familiar pattern: the code
    is in the `note-service` directory and contains a `serverless.yml` configuration
    file along with the implementation. Most of this is boilerplate: the main difference
    is that we configure the service to have access to an S3 data bucket and also
    access to the Transcribe service. This is in the `iamRoleStatements` section of
    our configuration, shown in the following listing.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的笔记服务遵循现在应该已经熟悉的模式：代码位于 `note-service` 目录中，包含一个 `serverless.yml` 配置文件和实现。大部分都是样板代码：主要区别在于我们配置服务以访问
    S3 数据桶和访问 Transcribe 服务。这位于我们的配置中的 `iamRoleStatements` 部分，如下所示。
- en: Listing 5.1 Role statements for note service
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.1 笔记服务角色声明
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Data bucket for audio files
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 音频文件数据桶
- en: ❷ Allow this service to access transcribe.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 允许此服务访问转录。
- en: 'The note service defines two routes: `POST` `/note` and `GET` `/note/{id}`
    to create and fetch a note respectively. As with the to-do CRUD routes, we are
    using our Cognito pool to lock down access to our note APIs, and we are using
    the same custom domain structure, just with a different base path of `noteapi`.
    Our handler code uses the AWS SDK to create transcription jobs, shown in the next
    listing.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记服务定义了两个路由：`POST` `/note` 和 `GET` `/note/{id}`，分别用于创建和获取笔记。与待办事项 CRUD 路由一样，我们使用我们的
    Cognito 池来锁定对笔记 API 的访问，并且我们使用相同的自定义域名结构，只是基础路径为 `noteapi`。我们的处理器代码使用 AWS SDK
    创建转录任务，如下所示。
- en: Listing 5.2 Note service handler
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.2 笔记服务处理器
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Create the transcription service object.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建转录服务对象。
- en: ❷ Start an asynchronous transcription job.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 开始异步转录任务。
- en: As you can see from the listing, the code is fairly simple in that it just calls
    a single API to kick the job off, passing in a link to our audio file. The code
    responds back to the client with a transcription job ID, which is used in the
    `poll` function. Check the code in detail to see the implementation of `poll`,
    which uses the `getTranscriptionJob` API to check the status of our running job.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表所示，代码相当简单，因为它只是调用单个 API 来启动任务，传递我们音频文件的链接。代码向客户端返回一个转录作业 ID，该 ID 在 `poll`
    函数中使用。详细检查代码以查看 `poll` 的实现，它使用 `getTranscriptionJob` API 检查我们正在运行的作业的状态。
- en: 5.1.3 Front-end updates
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.3 前端更新
- en: To provide the transcription functionality, we made a few updates to the front
    end. First, we have added some configuration to the Amplify library in `index.js`.
    This is shown in the next listing.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供转录功能，我们对前端进行了一些更新。首先，我们在 `index.js` 中添加了一些对 Amplify 库的配置。如下所示。
- en: Listing 5.3 Updated Amplify configuration
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.3 更新的 Amplify 配置
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Configure the S3 bucket used by the Amplify storage interface.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 配置 Amplify 存储接口使用的 S3 桶。
- en: This configuration tells Amplify to use our data bucket that we set up in step
    1\. Because we have already configured Amplify with our Cognito settings, we can
    access this bucket from the client once we are logged in.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置告诉 Amplify 使用我们在步骤 1 中设置的我们的数据桶。因为我们已经使用我们的 Cognito 设置配置了 Amplify，所以一旦登录，我们就可以从客户端访问此桶。
- en: We have added some code for audio handling in the directory `frontend/src/audio`.
    This uses the browser Media Stream Recording API to record audio into a buffer.
    We’ll treat this code as a black box for the purpose of this book.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `frontend/src/audio` 目录中添加了一些音频处理代码。它使用浏览器媒体流录制 API 将音频录制到缓冲区。为了本书的目的，我们将此代码视为黑盒。
- en: 'Note More information on the Media Stream Recording API can be found here:
    [http://mng.bz/X0AE](http://mng.bz/X0AE).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 更多关于媒体流录制 API 的信息可以在此处找到：[http://mng.bz/X0AE](http://mng.bz/X0AE)。
- en: 'The main note handling code is in `note.js` and `note-view.js`. The view code
    adds two buttons to the UI: one to start recording and one to stop recording.
    These map to the functions `startRecord` and `stopRecord` in `note.js`. The `stopRecord`
    function is shown in the following listing.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的笔记处理代码位于 `note.js` 和 `note-view.js` 文件中。视图代码向用户界面添加了两个按钮：一个用于开始录音，另一个用于停止录音。这些按钮分别对应
    `note.js` 中的 `startRecord` 和 `stopRecord` 函数。`stopRecord` 函数的代码如下所示。
- en: Listing 5.4 `stopRecord` function
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.4 `stopRecord` 函数
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Export recorded buffer to WAV format
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将录制缓冲区导出为 WAV 格式
- en: ❷ Save WAV file to S3 using Amplify
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 Amplify 将 WAV 文件保存到 S3。
- en: ❸ Submit the WAV file for processing.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 提交 WAV 文件进行处理。
- en: '`stopRecord` uses the `Storage` object from Amplify to write a WAV (Wave Audio
    file format) file directly to S3\. It then calls the `submitNote` function, which
    calls our note service API `/noteapi/note` to kick off the transcription job.
    The `submitNote` code is shown in the next listing.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`stopRecord` 函数使用 Amplify 的 `Storage` 对象将 WAV（波形音频文件格式）文件直接写入 S3。然后调用 `submitNote`
    函数，该函数调用我们的笔记服务 API `/noteapi/note` 来启动转录任务。`submitNote` 函数的代码如下所示。'
- en: Listing 5.5 `submitNote` function
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.5 `submitNote` 函数
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Call the note service.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用笔记服务。
- en: ❷ Enter polling
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 进入轮询状态
- en: Our poll function calls the note service on the back end to check the transcription
    job progress. The poll function code is shown in the following listing.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的轮询函数在后台调用笔记服务以检查转录任务的进度。轮询函数的代码如下所示。
- en: Listing 5.6 `note.js pollNote` function
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.6 `note.js pollNote` 函数
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Obtain the authenticated session with Cognito.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 Cognito 获取认证会话。
- en: ❷ Invoke the API to check the note status.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 调用 API 检查笔记状态。
- en: ❸ If the transcription is complete, render the transcribed note.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果转录完成，渲染转录的笔记。
- en: Once the job is complete, the resulting text will be rendered into the note
    input field on the page.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 作业完成后，生成的文本将被渲染到页面上的笔记输入字段中。
- en: Polling
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 投票
- en: Polling is generally an inefficient way to handle events, and certainly does
    not scale up well. Our use of polling here does expose a drawback with AWS Lambda,
    in that functions are generally expected to execute for a short period of time.
    This makes them unsuitable for applications that may require a long-lived connection.
    A better way to receive an update when a job has completed would be to establish
    a web socket connection and then push an update down to the browser. This is much
    more efficient and will scale well.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 轮询通常不是处理事件的有效方式，并且肯定不适合扩展。我们在这里使用轮询确实暴露了AWS Lambda的一个缺点，即函数通常预期在短时间内执行。这使得它们不适合可能需要长期连接的应用程序。当作业完成时，建立WebSocket连接并向下推送更新是一个更好的接收更新方式。这更有效率，并且可以很好地扩展。
- en: There are several better options that could be used here instead of polling,
    such as
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，有几个更好的选项可以用来代替轮询，例如
- en: Using AWS API Gateway with WebSockets--[http://mng.bz/yr2e](http://mng.bz/yr2e).
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AWS API Gateway和WebSockets——[http://mng.bz/yr2e](http://mng.bz/yr2e)。
- en: Using a third-party service such as Fanout--[https://fanout.io/](https://fanout.io/).
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用第三方服务，如Fanout——[https://fanout.io/](https://fanout.io/)。
- en: The best approach to use would, of course, depend on the specific system. Description
    of these methods is outside the scope of this book, which is why we have used
    a simple poll-based approach for our note service.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，最佳方法将取决于具体的系统。这些方法的描述超出了本书的范围，这就是为什么我们为笔记服务使用了简单的基于轮询的方法。
- en: 5.1.4 Deploying step 3
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.4 部署步骤3
- en: Let’s deploy our note functionality. First we will need to set up our environment.
    To do this simply copy your `.env` file from `step-2-cognito-login` to `step-3-note-service`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们部署笔记功能。首先，我们需要设置我们的环境。为此，只需将`step-2-cognito-login`中的`.env`文件复制到`step-3-note-service`。
- en: Next we will deploy our new note service. `cd` into the `step-3-note-service/note-service`
    directory and run
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将部署我们的新笔记服务。在`step-3-note-service/note-service`目录下使用`cd`命令，然后运行
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will create our note service endpoint in API Gateway and install our two
    Lambda functions. Next, deploy updates to the front end. `cd` in to the `step-3-note-service/frontend`
    directory and run
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在API Gateway中创建我们的笔记服务端点并安装我们的两个Lambda函数。接下来，部署前端更新。在`step-3-note-service/frontend`目录下使用`cd`命令并运行
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 5.1.5 Testing step 3
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.5 测试步骤3
- en: 'Let’s try out our new speech-to-text functionality. Open up the to-do application
    in a browser and log in as before. Hit the button to create a new to-do, and put
    in an action and a date. You should see two additional buttons as shown in figure
    5.2: a Record button and a Stop button.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一下我们新的语音转文字功能。在浏览器中打开待办事项应用并像之前一样登录。点击创建新待办事项的按钮，并输入一个动作和一个日期。你应该会看到如图5.2所示的额外两个按钮：一个录音按钮和一个停止按钮。
- en: '![](../Images/CH05_F02_Elger.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F02_Elger.png)'
- en: Figure 5.2 Record note
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 录音笔记
- en: Hit the Record button and start talking! Once you’ve finished, hit the Stop
    button. A few seconds later, you should see that the note you just dictated is
    rendered as text into the note field, allowing you to go ahead and save the new
    to-do, complete with transcribed note.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 点击录音按钮开始说话！说完后，点击停止按钮。几秒钟后，你应该会看到你刚才口述的笔记被渲染成文本，出现在笔记字段中，这样你就可以继续保存新的待办事项，包括转录的笔记。
- en: The time to transcribe audio to text is variable, depending on the current global
    number of transcription jobs in progress. At worst, it may take up to 20 to 30
    seconds for the transcription to complete. While a note on a to-do is a way to
    demonstrate AWS Transcribe, bear in mind that the API we are using is optimized
    for batch processing and can transcribe large audio files with multiple speakers--for
    example, a board meeting or an interview. We will introduce a faster conversational
    interface in step 5 later in the chapter. However, we should point out that in
    a recent update to the service, AWS Transcribe now supports real-time processing
    as well as batch mode.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 将音频转录成文本的时间是可变的，这取决于当前正在进行的全球转录作业数量。在最坏的情况下，转录完成可能需要20到30秒。虽然待办事项上的笔记是展示AWS
    Transcribe的一种方式，但请注意，我们使用的API是针对批量处理优化的，并且可以转录包含多个说话者的大型音频文件——例如，董事会会议或采访。我们将在本章后面的步骤5中介绍一个更快的对话界面。然而，我们应该指出，在最近的服务更新中，AWS
    Transcribe现在也支持实时处理以及批量模式。
- en: '5.2 Step 4: Adding text-to-speech'
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 步骤4：添加文本到语音
- en: The next AI feature that we are going to add to our to-do list is the reverse
    of the note service. Our schedule service will build a daily schedule from our
    to-do list and then read it out to us. We will be using AWS Polly to achieve this.
    Polly is the AWS speech-to-text service. We can plug this into our system in a
    similar manner to our note service, through the use of an API. Figure 5.3 depicts
    the architectural structure for the schedule service.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要添加到待办事项列表中的下一个AI功能是笔记服务的逆过程。我们的调度服务将从我们的待办事项列表中构建每日日程，然后将其读给我们听。我们将使用AWS
    Polly来实现这一点。Polly是AWS语音到文本服务。我们可以通过API的方式将其连接到我们的系统，类似于我们的笔记服务。图5.3描述了调度服务的架构结构。
- en: '![](../Images/CH05_F03_Elger.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F03_Elger.png)'
- en: Figure 5.3 Record note
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 记录笔记
- en: When a user of our system requests a schedule, a call is made to our schedule
    service that creates a schedule as text and then submits it to Amazon Polly. Polly
    interprets the text and converts it to audio. The audio file is written to our
    S3 data bucket, and once available, we play this back to our user. Again, we would
    note that this is a small amount of work for an advanced feature!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的系统用户请求日程时，会调用我们的调度服务，该服务创建文本形式的日程并将其提交给Amazon Polly。Polly解释文本并将其转换为音频。音频文件被写入我们的S3数据存储桶，一旦可用，我们就将其播放给我们的用户。再次强调，这对于一个高级功能来说工作量很小！
- en: 5.2.1 Getting the code
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.1 获取代码
- en: The code for this step is in the directory `chapter5/step-4-schedule-service`.
    This directory contains all of the code from step 3 along with our schedule service.
    As before, we will walk through the updates in turn and then deploy the changes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤的代码位于`chapter5/step-4-schedule-service`目录中。此目录包含步骤3的所有代码以及我们的调度服务。与之前一样，我们将依次介绍更新，然后部署更改。
- en: 5.2.2 Schedule service
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.2 调度服务
- en: 'Our schedule service is similar to the note service, in that it provides two
    API endpoints using the same domain manager structure as before:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的调度服务与笔记服务类似，因为它使用与之前相同的域管理器结构提供两个API端点：
- en: '`/schedule/day`--Creates a schedule for today and submits a text-to-speech
    job to Polly'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`/schedule/day`--为今天创建日程并提交文本到语音任务给Polly'
- en: '`/schedule/poll`--Checks on the status of the job and returns a reference to
    the audio file once completed'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`/schedule/poll`--检查作业状态，一旦完成返回音频文件的引用'
- en: This structure is reflected in the `serverless.yml` configuration, which should
    be very familiar at this stage. The implementation for these two endpoints, `day`
    and `poll`, is in `handler.js`. First, let’s look at the `buildSchedule` function
    used by the `day` handler. This is shown in the following listing.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构反映在`serverless.yml`配置中，在这个阶段应该非常熟悉。这两个端点`day`和`poll`的实现位于`handler.js`中。首先，让我们看看`day`处理程序使用的`buildSchedule`函数。如下列表所示。
- en: Listing 5.7 `buildSchedule` function in the schedule service `day` handler
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.7 调度服务`day`处理程序中的`buildSchedule`函数
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Create the SDK Polly object.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建SDK Polly对象。
- en: ❷ Get the to-do table from environment
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从环境中获取待办事项表。
- en: ❸ Define the function to build an SSML schedule.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 定义构建SSML日程的函数。
- en: ❹ Read schedule items from DynamoDB and create SSML for items that are due.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 从DynamoDB读取日程事项并创建到期事项的SSML。
- en: We have seen how the `buildSchedule` function reads to-do items for a given
    day and creates SSML. This is used by the `day` handler in the schedule service.
    The code for this handler is shown in the next listing.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到`buildSchedule`函数如何读取给定日期的待办事项并创建SSML。这被调度服务中的`day`处理程序使用。下一列表显示了此处理程序的代码。
- en: Listing 5.8 `day` handler for the schedule service
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.8 调度服务`day`处理程序
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Configure the voice and output bucket parameters for Polly.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 配置Polly的语音和输出存储桶参数。
- en: ❷ Start the Polly speech synthesis task.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 启动Polly语音合成任务。
- en: The `buildSchedule` function created a block of SSML to pass to Polly, which
    will convert this into an output `mp3` file. Our `day` function sets up a parameter
    block that specifies the output format, and the S3 bucket that Polly should place
    its output into. The code in the next listing shows the `poll` handler.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildSchedule`函数创建了一个SSML块，传递给Polly，Polly将将其转换为输出`mp3`文件。我们的`day`函数设置了一个参数块，指定输出格式，以及Polly应将输出放置的S3存储桶。下一列表中的代码显示了`poll`处理程序。'
- en: Listing 5.9 `poll` handler for the schedule service
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.9 调度服务的`poll`处理程序
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Check the status of the task.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查任务状态。
- en: ❷ Provide the task status to the API caller.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 向API调用者提供任务状态。
- en: The poll-handler code shows the Lambda function invoking the Polly service to
    retrieve the speech synthesis task. This is provided in the API response.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 检查处理器代码显示了 Lambda 函数调用 Polly 服务以检索语音合成任务。这包含在 API 响应中。
- en: SSML
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: SSML
- en: '*Speech Synthesis Markup Language (SSML)* is an XML dialect used for text-to-speech
    tasks. Whereas Polly can handle plain text, SSML can be used to provide additional
    context to speech synthesis tasks. For example, the following SSML uses the whisper
    effect:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*语音合成标记语言 (SSML)* 是一种用于文本到语音任务的 XML 方言。虽然 Polly 可以处理纯文本，但 SSML 可以用于为语音合成任务提供额外的上下文。例如，以下
    SSML 使用了耳语效果：'
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'More detail on SSML can be found here: [http://mng.bz/MoW8](http://mng.bz/MoW8).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 SSML 的信息可以在这里找到：[http://mng.bz/MoW8](http://mng.bz/MoW8)。
- en: Once our speech-to-text task had been initiated, we use the `poll` handler to
    check on the status. This calls `polly.getSpeechSynthesisTask` to determine the
    status of the task. Once our task is complete, we use `s3.getSignedUrl` to generate
    a temporary URL to access the resulting `mp3` file.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的语音到文本任务启动，我们使用 `poll` 处理器来检查状态。这调用 `polly.getSpeechSynthesisTask` 来确定任务的状态。一旦我们的任务完成，我们使用
    `s3.getSignedUrl` 生成一个临时 URL 来访问生成的 `mp3` 文件。
- en: 5.2.3 Front-end updates
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.3 前端更新
- en: To access our schedule service, we place a “schedule” button in the applications
    navigation bar, as illustrated in figure 5.4
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问我们的调度服务，我们在应用程序的导航栏中放置一个“调度”按钮，如图 5.4 所示。
- en: '![](../Images/CH05_F04_Elger.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F04_Elger.png)'
- en: Figure 5.4 Updated UI
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 更新后的用户界面
- en: This is connected to a front end handler in the file `frontend/src/schedule.js`,
    shown in the following listing.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这与文件 `frontend/src/schedule.js` 中的前端处理器相连，如下所示。
- en: Listing 5.10 `schedule.js`
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.10 `schedule.js`
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Play the schedule file.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 播放调度文件。
- en: ❷ Poll for schedule status.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查调度状态。
- en: ❸ Pass the signed URL to the player.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将签名 URL 传递给播放器。
- en: ❹ Start the schedule job.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 启动调度任务。
- en: Using a temporary signed URL from S3 allows the front-end code to use a standard
    audio element to play the schedule without compromising the security of our data
    bucket.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用来自 S3 的临时签名 URL 允许前端代码使用标准的音频元素播放调度，而不会损害我们数据桶的安全性。
- en: 5.2.4 Deploying step 4
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.4 部署步骤 4
- en: Deployment of this step should be very familiar by now. First, we need to copy
    our environment across from the previous step. Copy the file `step-3-note-service/.env`
    to `step-4-schedule-service`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，这一步骤的部署应该非常熟悉。首先，我们需要从上一个步骤复制我们的环境。将文件 `step-3-note-service/.env` 复制到
    `step-4-schedule-service`。
- en: 'Next, deploy the schedule service by executing the following commands:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过执行以下命令部署调度服务：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, deploy the front end updates as before:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，像之前一样部署前端更新：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 5.2.5 Testing step 4
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.5 测试步骤 4
- en: Let’s now get our to-do list to read out our schedule for the day. Open the
    application in a browser, log in, and then create some to-do entries for today’s
    date. Once you have entered one or two items, click the schedule button. This
    will trigger the schedule service to build and send our schedule to Polly. After
    a few seconds, the application will read out our schedule for us!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在让我们的待办事项列表读出我们当天的日程。在浏览器中打开应用程序，登录，并为今天的日期创建一些待办事项。一旦你输入了一到两个条目，点击调度按钮。这将触发调度服务构建并发送我们的日程到
    Polly。几秒钟后，应用程序将为我们读出我们的日程！
- en: We now have a to-do system that we can talk to, and that can talk back to us.
    Our to-dos are stored in a database, and the system is secured through a username
    and password. All of this without ever needing to boot up a server or get into
    the details of text/speech conversion!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个可以与之交谈的待办事项系统，并且它可以对我们说话。我们的待办事项存储在数据库中，系统通过用户名和密码进行安全保护。所有这些都不需要启动服务器或深入了解文本/语音转换的细节！
- en: In our final update to the to-do system, we will add a more conversational interface
    to the system by building a chatbot.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对待办事项系统的最终更新中，将通过构建聊天机器人来为系统添加一个更会话式的界面。
- en: '5.3 Step 5: Adding a conversational chatbot interface'
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 步骤 5：添加会话式聊天机器人界面
- en: In our final update to the to-do application, we will implement a chatbot. The
    chatbot will allow us to interact with the system via a text-based interface or
    through speech. We will use Amazon Lex to build our bot. Lex uses the same AI
    technology as Amazon Alexa. This means that we can use Lex to create a more natural
    human interface to our system. For example, we can ask our application to schedule
    a to-do for “tomorrow” or “next Wednesday.” While this is a natural way for a
    human to express dates, it is actually very complex for a computer to understand
    these ambiguous commands. Of course, by using Lex, we get all of this for free.
    Figure 5.5 illustrates how our chatbot integrates into our system.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对待办事项应用程序的最终更新中，我们将实现一个聊天机器人。聊天机器人将允许我们通过基于文本的界面或通过语音与系统交互。我们将使用 Amazon Lex
    来构建我们的机器人。Lex 使用与 Amazon Alexa 相同的 AI 技术。这意味着我们可以使用 Lex 为我们的系统创建一个更自然的人机界面。例如，我们可以要求我们的应用程序为“明天”或“下周三”安排待办事项。虽然这对人类来说是一种表达日期的自然方式，但实际上对计算机来说理解这些模糊的命令非常复杂。当然，通过使用
    Lex，我们可以免费获得所有这些功能。图 5.5 展示了我们的聊天机器人如何集成到我们的系统中。
- en: '![](../Images/CH05_F05_Elger.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F05_Elger.png)'
- en: Figure 5.5 Updated UI
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 更新后的用户界面
- en: Users can supply commands either through a chat window or by speaking. These
    commands are sent to our chatbot which is hosted by Lex, and a response is returned.
    At the end of the conversation, the bot will have gathered all of the information
    required to create or update a to-do item. The front end will then take this information
    and post it to the to-do API as before.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以通过聊天窗口或通过说话来提供命令。这些命令被发送到由 Lex 托管的我们的聊天机器人，并返回一个响应。在对话结束时，机器人将收集创建或更新待办事项所需的所有信息。然后前端将此信息发布到待办事项
    API，就像之前一样。
- en: It’s important to note at this point that we do not have to change our underlying
    to-do API in order to add a conversational interface to it. This can be layered
    on top with minimal disruption to existing code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上需要注意的是，我们不需要更改我们底层的待办事项 API，以便向其添加对话界面。这可以在现有代码的最小干扰上叠加。
- en: 5.3.1 Getting the code
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.1 获取代码
- en: The code for this step is in the directory `chapter5/step-5-chat-bot`. This
    directory contains all of the code from step 4 along with code to interface with
    our chatbot.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤的代码位于 `chapter5/step-5-chat-bot` 目录中。此目录包含步骤 4 的所有代码以及与我们的聊天机器人交互的代码。
- en: 5.3.2 Creating the bot
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.2 创建机器人
- en: We have created a command-line script to create our `todo` bot. The code for
    this is in the directory `chapter5/step-5-chat-bot/bot`. The file `create.sh`
    uses the AWS command line to set up the bot, as shown in the following listing.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个用于创建我们的 `todo` 机器人的命令行脚本。此代码位于 `chapter5/step-5-chat-bot/bot` 目录中。文件
    `create.sh` 使用 AWS 命令行设置机器人，如下所示。
- en: Listing 5.11 Chatbot creation script
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.11 创建聊天机器人的脚本
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Create service role if needed
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如有必要，创建服务角色
- en: ❷ Define the CreateTodo intent.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义创建待办事项的意图。
- en: ❸ Define the MarkDone intent.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 定义标记完成的意图。
- en: ❹ Define the bot.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 定义机器人。
- en: Note The `create.sh` script uses the `jq` command, which is a command-line utility
    for handling JSON data. If this is not on your development environment, you will
    need to install it using your system’s package manager.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`create.sh` 脚本使用 `jq` 命令，这是一个用于处理 JSON 数据的命令行工具。如果您的开发环境中没有安装它，您需要使用系统包管理器进行安装。
- en: This script uses some JSON files to define the characteristics of our chatbot.
    Go ahead and run the `create.sh` script. It will take several seconds for our
    bot to be created; we can check on progress by running the command
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本使用一些 JSON 文件来定义我们聊天机器人的特性。请运行 `create.sh` 脚本。创建我们的机器人可能需要几秒钟的时间；我们可以通过运行以下命令来检查进度：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Once the output from this command contains the output `"status":` `"READY"`,
    our bot is good to go. Open the AWS console in a web browser and select Lex from
    the list of services. Click on the link to the `todo` bot.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '一旦此命令的输出包含 `"status": "READY"`，我们的机器人就可以使用了。在网页浏览器中打开 AWS 控制台，并从服务列表中选择 Lex。点击
    `todo` 机器人的链接。'
- en: 'Note You may initially see an error message when first creating the bot of
    the form: `The` `role` `with` `name` `AWSServiceRoleForLexBots` `cannot` `be`
    `found`. This is because Lex creates this service role the first time that a bot
    is created in an account.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您在首次创建机器人时可能会看到错误消息，例如：“无法找到名为 `AWSServiceRoleForLexBots` 的角色”。这是因为 Lex 在账户中首次创建机器人时创建此服务角色。
- en: '![](../Images/CH05_F06_Elger.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F06_Elger.png)'
- en: Figure 5.6 Updated UI
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 更新后的用户界面
- en: 'Your console should look like figure 5.6\. This might look a little complex
    to begin with, but the configuration is really quite straightforward once we understand
    three key concepts: intents, utterances, and slots.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您的控制台应该看起来像图 5.6 所示。一开始这可能看起来有点复杂，但一旦我们理解了三个关键概念：意图、话语和插槽，配置实际上非常简单。
- en: Intents
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 意图
- en: An *intent* is a goal that we want to achieve; for example, “order pizza” or
    “book appointment.” Think of an intent as an overall task for the bot, for which
    it will need to gather additional data to fulfill. A bot can have multiple intents,
    but usually these are related to some central concept. For example, a pizza-ordering
    bot might have the intents “order pizza,” “check delivery time,” “cancel order,”
    “update order,” and so on.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**意图**是我们想要实现的目标；例如，“订购披萨”或“预约”。将意图视为机器人的整体任务，它将需要收集额外数据以完成任务。一个机器人可以有多个意图，但通常这些都与某个中心概念相关。例如，一个订购披萨的机器人可能有“订购披萨”、“检查配送时间”、“取消订单”、“更新订单”等意图。
- en: 'In the case of the `todo` bot, we have two intents: `CreateTodo` and `MarkDone`.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在`todo`机器人的情况下，我们有两个意图：`CreateTodo`和`MarkDone`。
- en: Utterances
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 话语
- en: 'An *utterance* is a phrase that is used to identify an intent. For our `CreateTodo`
    intent, we have defined the utterances `Create to-do` and `New to-do`. It is important
    to understand that an utterance is not a set of key words that must be provided
    exactly. Lex uses several AI techniques to match an utterance to an intent. For
    example, our create intent could be identified by any of the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**话语**是用来识别意图的短语。对于我们的`CreateTodo`意图，我们定义了`创建待办事项`和`新待办事项`这两个话语。重要的是要理解，话语不是一组必须精确提供的关键词。Lex使用多种AI技术来匹配话语和意图。例如，我们的创建意图可以通过以下任何一种方式被识别：
- en: “Initialize to-do”
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “初始化待办事项”
- en: “Get a to-do”
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “获取待办事项”
- en: “I’d like a new to-do, please”
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “我想要一个新的待办事项，请”
- en: “Make me a to-do”
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “为我创建待办事项”
- en: An utterance provides sample language to Lex, not keywords that need exact matching.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 话语为Lex提供示例语言，而不是需要精确匹配的关键词。
- en: Slots
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 插槽
- en: 'A *slot* can be thought of as an output variable from a Lex conversation. Lex
    will use the conversation to elicit slot information. For our `CreateTodo` intent,
    we have defined two slots: `dueDate` and `action`. We have used built-in slot
    types of `AMAZON.DATE` and `AMAZON.EventType` for these slots. In most cases,
    the built-in slot types provide enough context; however, it is possible to define
    custom slot types as required by the bot.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**插槽**可以被视为Lex对话的输出变量。Lex将使用对话来获取插槽信息。对于我们的`CreateTodo`意图，我们定义了两个插槽：`dueDate`和`action`。我们为这些插槽使用了内置的插槽类型`AMAZON.DATE`和`AMAZON.EventType`。在大多数情况下，内置的插槽类型提供了足够的信息；然而，根据机器人的需求，可以定义自定义的插槽类型。
- en: Lex will use the slot type as a means to help understand the response. For example,
    when Lex prompts us for a date, it can handle most reasonable responses such as
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Lex将使用插槽类型作为帮助理解响应的手段。例如，当Lex提示我们输入日期时，它可以处理大多数合理的响应，例如
- en: Tomorrow
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明天
- en: Thursday
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 星期四
- en: Next Wednesday
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下周三
- en: Christmas day
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圣诞节
- en: Labour day 2019
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2019 劳动节
- en: A month from today
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从今天起一个月
- en: This allows for a flexible conversational interface via text or speech
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许通过文本或语音实现灵活的对话界面
- en: Trying it out
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 尝试一下
- en: Let’s test out our bot! Click the Build button on the top right and wait for
    the build to complete. Then select the Test Chatbot link to bring up a message
    panel on the right side, and try creating some to-dos. Figure 5.7 shows a sample
    session.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下我们的机器人！点击右上角的构建按钮，等待构建完成。然后选择测试聊天机器人链接，在右侧弹出一个消息面板，并尝试创建一些待办事项。图 5.7
    展示了一个示例会话。
- en: '![](../Images/CH05_F07_Elger.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F07_Elger.png)'
- en: Figure 5.7 Updated UI
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 更新后的用户界面
- en: In addition to typing commands to the bot, you can also use the microphone button
    to speak voice commands to the bot and have it reply with audio. The key point
    to notice is that Lex has extracted structured information from a loosely structured
    conversation. We can then use the extracted, structured data in our code.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 除了向机器人输入命令外，您还可以使用麦克风按钮对机器人说出语音命令，并让它以音频形式回复。需要注意的是，Lex已从松散结构的对话中提取了结构化信息。然后我们可以将这些提取的结构化数据用于我们的代码中。
- en: 5.3.3 Front-end updates
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.3 前端更新
- en: Now that we have a working bot, it’s time to integrate it into our application.
    Code for the updated front end is in the directory `chapter5/step-5-chat-bot/frontend`.
    The main bot integration is in `src/bot.js`. First, let’s look at the `activate`
    function shown in the following listing.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个工作的机器人，是时候将其集成到我们的应用程序中了。更新前端的代码位于 `chapter5/step-5-chat-bot/frontend`
    目录中。主要的机器人集成在 `src/bot.js` 中。首先，让我们看看以下列表中所示的 `activate` 函数。
- en: Listing 5.12 `bot.js` activate function
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.12 `bot.js` activate 函数
- en: '[PRE17]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Import Lex API
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入 Lex API
- en: ❷ Configure Lex with region and credentials
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 配置 Lex 的区域和凭证
- en: ❸ Get typed input.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 获取输入的文本。
- en: ❹ Invoke pushChat with the entered text.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用输入的文本调用 pushChat。
- en: '`LexRuntime` is the AWS SDK service interface for dealing with the Lex chatbot
    service. It has two methods for sending user input to Lex. One method, `postContent`,
    supports audio and text streams. The simpler method, `postText`, supports sending
    user input as text only. In this application, we will use `postText`. The next
    listing shows the code for passing the entered text captured in the front end
    to Lex.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`LexRuntime` 是 AWS SDK 服务的接口，用于处理 Lex 聊天机器人服务。它有两个方法用于将用户输入发送到 Lex。一个方法 `postContent`
    支持音频和文本流。更简单的方法 `postText` 仅支持发送文本形式的用户输入。在这个应用程序中，我们将使用 `postText`。下一个列表显示了将前端捕获的输入文本传递给
    Lex 的代码。'
- en: Listing 5.13 `bot.js pushChat` function
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.13 `bot.js` pushChat 函数
- en: '[PRE18]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Configure parameters
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 配置参数
- en: ❷ Send text to bot
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 向机器人发送文本
- en: ❸ Create new to-do
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建新的待办事项
- en: '`bot.js`, along with some display functions in `bot-view.js`, implements a
    simple text-messaging interface to our bot through the API `postText`. This sends
    our user’s text input to Lex and elicits a response. Lex will set the response
    data `dialogState` to `ReadyForFulfillment` once our two slots, `dueDate` and
    `action`, have been populated. At this point, we can then read the slot data from
    the Lex response, create a JSON structure for our `to-do` item, and post it to
    our to-do API.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`bot.js`，以及 `bot-view.js` 中的某些显示函数，通过 `postText` API 实现了一个简单的文本消息接口到我们的机器人。这会将用户的文本输入发送到
    Lex 并引发响应。一旦我们的两个槽位 `dueDate` 和 `action` 被填充，Lex 将将响应数据 `dialogState` 设置为 `ReadyForFulfillment`。此时，我们可以从
    Lex 响应中读取槽位数据，为我们的 `to-do` 项创建一个 JSON 结构，并将其发布到我们的待办事项 API。'
- en: There is also a function `pushVoice` that we have wired into the browser audio
    system. This works in a similar manner to the `pushChat` function, except that
    it will push audio to the bot. In the case that we push audio (i.e. a spoken command)
    to the bot, it will respond with text as before, but will also include an audio
    response in the field `audioStream` that is attached to the response data object.
    The function `playResponse` takes this audio stream and simply plays it back,
    allowing us to have a voice-activated conversation with the bot.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个 `pushVoice` 函数，我们已经将其连接到浏览器音频系统。这个函数与 `pushChat` 函数类似，但它会将音频推送到机器人。如果我们向机器人推送音频（即语音命令），它将像以前一样以文本形式响应，但还会在附加到响应数据对象的
    `audioStream` 字段中包含音频响应。`playResponse` 函数接受这个音频流并简单地播放它，这样我们就可以与机器人进行语音激活的对话。
- en: 5.3.4 Deploying step 5
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.4 部署步骤 5
- en: As we have already deployed our bot, we only need to update the front end. As
    before, copy the `.env` file from step 4 into the step 5 directory and run the
    commands in the following listing to deploy a new version.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经部署了我们的机器人，我们只需要更新前端。像以前一样，将步骤 4 中的 `.env` 文件复制到步骤 5 目录中，并运行以下列表中的命令以部署新版本。
- en: Listing 5.14 Deploy commands to update the front end
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.14 将部署命令更新前端
- en: '[PRE19]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Install dependencies
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 安装依赖项
- en: ❷ Create a production build of the front-end static assets.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建前端静态资源的生产构建。
- en: ❸ Copy the static site to the S3 bucket.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将静态网站复制到 S3 桶中。
- en: The updated front end has now been deployed.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的前端现在已经部署完成。
- en: 5.3.5 Testing step 5
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.5 测试步骤 5
- en: Open up a browser and load up the latest changes. After logging in, you should
    see the chatbot interface on the right side of the page, as in figure 5.8.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器并加载最新更改。登录后，你应该能在页面右侧看到聊天机器人界面，如图 5.8 所示。
- en: '![](../Images/CH05_F08_Elger.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F08_Elger.png)'
- en: Figure 5.8 Updated UI
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 更新后的 UI
- en: You should now be able to go ahead and interact with the bot in the context
    of the to-do application. Once the conversation is complete, a new to-do item
    will be created in the to-do list!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能够在与待办事项应用程序的上下文中与机器人交互。一旦对话完成，待办事项列表中将会创建一个新的待办事项！
- en: Though we wrote a bunch of code to achieve this, the code was fairly simple
    to implement. Most of the time we were really just calling external APIs, a job
    that is familiar to most working programmers. By calling these APIs, we were able
    to add advanced AI functionality to our to-do list without needing to understand
    any of the science of natural language processing or speech-to-text translation.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们编写了大量代码来实现这一点，但代码实现起来相当简单。大多数时候我们只是在调用外部 API，这是大多数在职程序员熟悉的工作。通过调用这些 API，我们能够在待办事项列表中添加高级人工智能功能，而无需了解任何自然语言处理或语音到文本翻译的科学。
- en: Voice and chatbot interfaces are becoming increasingly common, particularly
    with mobile applications. Some great use cases that we have come across recently
    include
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 语音和聊天机器人界面变得越来越普遍，尤其是在移动应用程序中。我们最近遇到的一些很好的用例包括
- en: Web-integrated first line customer support and sales inquiries
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成在网页中的第一行客户支持和销售咨询
- en: Personal assistants for meeting schedules
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于安排会议的个人助理
- en: Travel assistance to help with booking flights and hotels
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旅行助手，帮助预订航班和酒店
- en: Personal shopping assistants for e-commerce sites
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子商务网站的个人购物助手
- en: Healthcare and motivational bots to promote lifestyle changes
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 医疗保健和激励型机器人，以促进生活方式的改变
- en: Hopefully this chapter will have inspired you to apply this technology to your
    own work!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这一章能激发你将这项技术应用到自己的工作中！
- en: 5.4 Removing the system
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 移除系统
- en: 'Once you are done with testing the system, it should be removed entirely in
    order to avoid incurring additional charges. This can be done manually with the
    `serverless remove` command. We have also provided a script to remove all of the
    deployed resources in chapters 4 and 5 in the `chapter5/step-5-chat-bot` directory.
    There is also a separate `remove.sh` script in the `bot` subdirectory. To use
    these scripts, execute the following commands:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您完成对系统的测试，应完全移除，以避免产生额外费用。这可以通过使用 `serverless remove` 命令手动完成。我们还在 `chapter5/step-5-chat-bot`
    目录中提供了一个脚本，用于删除第 4 章和第 5 章中部署的所有资源。在 `bot` 子目录中还有一个单独的 `remove.sh` 脚本。要使用这些脚本，请执行以下命令：
- en: '[PRE20]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you would like to redeploy the system at any time, there is an associated
    script called `deploy.sh` in the same folder. This will redeploy the entire system
    for you by automating the steps that we worked through in chapter 4 and this chapter.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在任何时候重新部署系统，同一文件夹中有一个名为 `deploy.sh` 的相关脚本。这将通过自动化第 4 章和本章中我们已执行的步骤为您重新部署整个系统。
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: AWS Transcribe is used to convert speech to text. Transcribe allows us to specify
    a file, a file format, and language parameters, and start a transcription job.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS Transcribe 用于将语音转换为文本。Transcribe 允许我们指定一个文件、文件格式和语言参数，并启动转录作业。
- en: Use AWS Amplify to upload data to an S3 bucket. We can save audio captured from
    the browser to a WAV file by using the Amplify `Storage` interface.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 AWS Amplify 将数据上传到 S3 桶。我们可以通过使用 Amplify 的 `Storage` 接口将浏览器捕获的音频保存为 WAV 文件。
- en: Speech Synthesis Markup Language (SSML) is used to define conversational speech.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语音合成标记语言 (SSML) 用于定义对话式语音。
- en: AWS Polly converts text to speech.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS Polly 用于将文本转换为语音。
- en: AWS Lex is used to create powerful chatbots.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS Lex 用于创建强大的聊天机器人。
- en: Lex utterances, intents, and slots are the components used to construct Lex
    chatbots.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lex 的语句、意图和槽位是构建 Lex 聊天机器人的组件。
- en: Warning Please ensure that you fully remove all cloud resources deployed in
    this chapter in order to avoid additional charges!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 请确保您完全移除本章中部署的所有云资源，以避免产生额外费用！
