- en: 7 Functional programming with comprehensions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 使用列表推导式进行函数式编程
- en: Programmers are always trying to do more with less code, while simultaneously
    making that code more reliable and easier to debug. And indeed, computer scientists
    have developed a number of techniques, each meant to bring us closer to that goal
    of short, reliable, maintainable, powerful code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员总是试图用更少的代码做更多的事情，同时使代码更可靠、更容易调试。确实，计算机科学家已经开发了许多技术，每种技术都旨在让我们更接近编写简短、可靠、可维护、强大的代码的目标。
- en: One set of techniques is known as *functional programming*. It aims to make
    programs more reliable by keeping functions short and data immutable. I think
    most developers would agree that short functions are a good idea, in no small
    part because they’re easier to understand, test, and maintain.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一组技术被称为 *函数式编程*。它旨在通过保持函数简短和数据不可变来使程序更可靠。我认为大多数开发者都会同意，简短函数是一个好主意，这在很大程度上是因为它们更容易理解、测试和维护。
- en: But how can you enforce the writing of short functions? Immutable data. If you
    can’t modify data from within a function, then the function will (in my experience)
    end up being shorter, with fewer potential paths to be tested. Functional programs
    thus end up having many short functions--in contrast with nonfunctional programs,
    which often have a smaller number of very long functions. Functional programming
    also assumes that functions can be passed as arguments to other functions, something
    that we’ve already seen to be the case in Python.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但如何强制编写简短函数呢？不可变数据。如果你不能在函数内部修改数据，那么根据我的经验，函数最终会变得更短，有更少的潜在路径需要测试。因此，函数式程序最终会有许多简短函数——与非函数式程序形成对比，后者通常有更少的非常长的函数。函数式编程还假设函数可以作为参数传递给其他函数，这在
    Python 中我们已经看到是可行的。
- en: The good news is that functional techniques have the potential to make code
    short and elegant. The bad news is that for many developers, functional techniques
    aren’t natural. Not modifying any values, and not keeping track of state, might
    be great ways to make your software more reliable, but they’re almost guaranteed
    to confuse and frustrate many developers.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，函数式技术有潜力使代码更简洁、更优雅。坏消息是，对于许多开发者来说，函数式技术并不自然。不修改任何值，不跟踪状态，可能是使你的软件更可靠的好方法，但它们几乎肯定会令许多开发者感到困惑和沮丧。
- en: Consider, for example, that you have a `Person` object in a purely functional
    language. If the person wants to change their name, you’re out of luck, because
    all data is immutable. Instead, you’ll have to create a new person object based
    on the old one, but with the name changed. This isn’t terrible in and of itself,
    but given that the real world changes, and that we want our programs to model
    the real world, keeping everything immutable can be frustrating.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你在一个纯函数式语言中有一个 `Person` 对象。如果这个人想要更改他们的名字，你就无能为力了，因为所有数据都是不可变的。相反，你将不得不基于旧对象创建一个新的个人对象，但名字已更改。这本身并不糟糕，但考虑到现实世界是不断变化的，我们希望我们的程序能够模拟现实世界，保持一切不可变可能会令人沮丧。
- en: Then again, because functional languages can’t modify data, they generally provide
    mechanisms for taking a sequence of inputs, transforming them in some way, and
    producing a sequence of outputs. We might not be able to modify one `Person` object,
    but we can write a function that takes a list of `Person` objects, applies a Python
    expression to each one, and then gets a new list of `Person` objects back. In
    such a scenario, we perhaps haven’t modified our original data, but we’ve accomplished
    the task. And the code needed to do this is generally quite short.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 再者，由于函数式语言不能修改数据，它们通常提供机制来处理一系列输入，以某种方式转换它们，并产生一系列输出。我们可能无法修改一个 `Person` 对象，但我们可以编写一个函数，该函数接受一个
    `Person` 对象列表，对每个对象应用一个 Python 表达式，然后返回一个新的 `Person` 对象列表。在这种情况下，我们可能没有修改原始数据，但我们已经完成了任务。而且完成这个任务所需的代码通常相当简短。
- en: Now, Python isn’t a functional language; we have mutable data types and assignment.
    But some functional techniques have made their way into the language and are considered
    standard Pythonic ways to solve some problems.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Python 不是一个函数式语言；我们有可变的数据类型和赋值操作。但一些函数式技术已经融入了这门语言，并被认为是一些标准 Pythonic 解决问题的方法。
- en: Specifically, Python offers *comprehensions*, a modern take on classic functions
    that originated in Lisp, one of the first high-level languages to be invented.
    Comprehensions make it relatively easy to create lists, sets, and dicts based
    on other data structures. The fact that Python’s functions are objects, and can
    thus be passed as arguments or stored in data structures, also comes from the
    functional world.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，Python提供了推导式，这是一种对起源于Lisp的经典函数的现代诠释，Lisp是第一个被发明的高级语言之一。推导式使得根据其他数据结构创建列表、集合和字典相对容易。Python的函数是对象，因此可以作为参数传递或存储在数据结构中，这也源于函数式世界。
- en: Some exercise solutions have already used, or hinted at, comprehensions. In
    this chapter, we’re going to concentrate on how and when to use these techniques,
    and expand on the ways we can use them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一些练习题的解决方案已经使用了，或者暗示了推导式。在这一章中，我们将集中讨论如何和何时使用这些技术，并扩展我们使用它们的方式。
- en: In my experience, it’s common to be indifferent to functional techniques, and
    particularly to comprehensions, when first learning about them. But over time--and
    yes, it can take years!--developers increasingly understand how, when, and why
    to apply them. So even if you can solve the problems in this chapter without using
    functional techniques, the point here is to get your hands dirty, try them, and
    start to see the logic and elegance behind this way of doing things. The benefits
    might not be immediately obvious, but they’ll pay off over time.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的经验中，当刚开始学习这些功能技术时，人们往往对它们漠不关心，尤其是对推导式。但随着时间的推移——是的，这可能需要几年时间！——开发者们越来越理解何时、如何以及为什么应用它们。所以即使你可以在不使用功能技术的情况下解决这一章的问题，这里的要点是动手实践，尝试它们，并开始看到这种做事方式的逻辑和优雅。这些好处可能不会立即显现，但它们会随着时间的推移而得到回报。
- en: If this all sounds very theoretical and you’d like to see some concrete examples
    of comprehensions versus traditional, procedural programming, then check out the
    “Writing comprehensions” sidebar coming up in this chapter, where I go through
    the differences more thoroughly.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这一切听起来非常理论化，你想要看到一些关于推导式与传统、过程式编程的实例，那么请查看本章即将出现的“编写推导式”边栏，我在那里更详细地阐述了这些差异。
- en: Table 7.1 What you need to know
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.1 你需要知道的内容
- en: '| Concept | What is it? | Example | To learn more |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 概念 | 它是什么？ | 示例 | 了解更多 |'
- en: '| List comprehension | Produces a list based on the elements of an iterable
    | `[x*x for x in range(5)]` | [http://mng.bz/lGpy](http://mng.bz/lGpy) |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 列表推导 | 根据可迭代对象的元素生成一个列表 | `[x*x for x in range(5)]` | [http://mng.bz/lGpy](http://mng.bz/lGpy)
    |'
- en: '| Dict comprehension | Produces a dict based on the elements of an iterable
    | `{x : 2*x for x in range(5)}` | [http://mng.bz/Vggy](http://mng.bz/Vggy) |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 字典推导 | 根据可迭代对象的元素生成一个字典 | `{x : 2*x for x in range(5)}` | [http://mng.bz/Vggy](http://mng.bz/Vggy)
    |'
- en: '| Set comprehension | Produces a set based on the elements of an iterable |
    `{x*x for x in range(5)}` | [http://mng.bz/GVxO](http://mng.bz/GVxO) |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 集合推导 | 根据可迭代对象的元素生成一个集合 | `{x*x for x in range(5)}` | [http://mng.bz/GVxO](http://mng.bz/GVxO)
    |'
- en: '| `input` | Prompts the user to enter a string, and returns a string | `input(''Name:
    '')` | [http://mng.bz/wB27](http://mng.bz/wB27) |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `input` | 提示用户输入一个字符串，并返回一个字符串 | `input(''Name: '')` | [http://mng.bz/wB27](http://mng.bz/wB27)
    |'
- en: '| `str.isdigit` | Returns `True` or `False`, if the string is nonempty and
    contains only 0-9 | `# returns True``''5''.isdigit()` | [http://mng.bz/oPVN](http://mng.bz/oPVN)
    |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `str.isdigit` | 如果字符串非空且只包含0-9，则返回`True`或`False` | `# 返回 True``''5''.isdigit()`
    | [http://mng.bz/oPVN](http://mng.bz/oPVN) |'
- en: '| `str.split` | Breaks strings apart, returning a list | `# Returns [''ab'',
    ''cd'', ''ef'']``''ab cd ef''.split()` | [http://mng.bz/aR4z](http://mng.bz/aR4z)
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `str.split` | 将字符串拆分，返回一个列表 | `# 返回 [''ab'', ''cd'', ''ef'']``''ab cd ef''.split()`
    | [http://mng.bz/aR4z](http://mng.bz/aR4z) |'
- en: '| `str.join` | Combines strings to create a new one | `# Returns ''ab*cd*ef''``''*''.join([''ab'',
    ''cd'', ''ef''])` | [http://mng.bz/gyYl](http://mng.bz/gyYl) |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `str.join` | 将字符串合并以创建一个新的字符串 | `# 返回 ''ab*cd*ef''``''*''.join([''ab'', ''cd'',
    ''ef''])` | [http://mng.bz/gyYl](http://mng.bz/gyYl) |'
- en: '| `string.ascii _lowercase` | All English lowercase letters | `string.ascii_lowercase`
    | [http://mng.bz/zjxQ](http://mng.bz/zjxQ) |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `string.ascii_lowercase` | 包含所有英文字母小写 | `string.ascii_lowercase` | [http://mng.bz/zjxQ](http://mng.bz/zjxQ)
    |'
- en: '| `enumerate` | Returns an iterator of two-element tuples, with an index |
    `enumerate(''abcd'')` | [http://mng.bz/qM1K](http://mng.bz/qM1K) |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `enumerate` | 返回一个包含两个元素的元组的迭代器，包含一个索引 | `enumerate(''abcd'')` | [http://mng.bz/qM1K](http://mng.bz/qM1K)
    |'
- en: Exercise 28 ■ Join numbers
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习28 ■ 连接数字
- en: People often ask me, “When should I use a comprehension, as opposed to a traditional
    `for` loop?”
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 人们经常问我，“我应该何时使用推导式，而不是传统的`for`循环？”
- en: 'My answer is basically as follows: when you want to transform an iterable into
    a list, you should use a comprehension. But if you just want to execute something
    for each element of an iterable, then a traditional `for` loop is better.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我的答案基本上是这样的：当你想要将可迭代转换为列表时，你应该使用列表推导式。但如果你只是想对可迭代中的每个元素执行一次操作，那么传统的`for`循环更好。
- en: Put another way, is the point of your `for` loop the creation of a new list?
    If so, then use a comprehension. But if your goal is to execute something once
    for each element in an iterable, throwing away or ignoring any return value, then
    a `for` loop is preferable.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，你的`for`循环的目的就是创建一个新的列表吗？如果是这样，那么使用列表推导式。但如果你的目标是针对可迭代中的每个元素执行一次操作，丢弃或忽略任何返回值，那么传统的`for`循环更合适。
- en: For example, I want to get the lengths of words in the string `s`. I can say
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我想获取字符串`s`中单词的长度。我可以这样说
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, I care about the list we’re creating, so I use a comprehension.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我关心我们创建的列表，所以我使用列表推导式。
- en: 'But if my string `s` contains a list of filenames, and I want to create a new
    file for each of these filenames, then I’m not interested in the return value.
    Rather, I want to iterate over the filenames and create a file, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我的字符串`s`包含一个文件名列表，并且我想为这些文件名中的每一个创建一个新的文件，那么我对返回值也不感兴趣。相反，我想遍历文件名并创建文件，如下所示：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, I open (and thus create) each file, and write to it the name
    of the file. Using a comprehension in this case would be inappropriate, because
    I’m not interested in the return value.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我打开（因此创建）每个文件，并将文件名写入其中。在这种情况下使用列表推导式是不合适的，因为我对返回值不感兴趣。
- en: '*Transformations* --taking values in a list, string, dict, or other iterable
    and producing a new list based on it--are common in programming. You might need
    to transform filenames into file objects, or words into their lengths, or usernames
    into user IDs. In all of these cases, a comprehension is the most Pythonic solution.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*转换* --在列表、字符串、字典或其他可迭代对象中取值，并基于它产生一个新的列表--在编程中很常见。你可能需要将文件名转换为文件对象，或将单词转换为它们的长度，或将用户名转换为用户ID。在这些所有情况下，列表推导式是最Pythonic的解决方案。'
- en: This exercise is meant to get your feet wet with comprehensions, and with implementing
    this idea. It might seem simple, but the underlying idea is deep and powerful
    and will help you to see additional opportunities to use comprehensions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的目的是让你对列表推导式和实现这个想法有所了解。这看起来可能很简单，但背后的思想是深刻而强大的，这将帮助你看到使用列表推导式的更多机会。
- en: 'For this exercise, write a function (`join_numbers`) that takes a `range` of
    integers. The function should return those numbers as a string, with commas between
    the numbers. That is, given `range(15)` as input, the function should return this
    string:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，编写一个函数（`join_numbers`），它接受一个整数范围。该函数应返回这些数字作为字符串，数字之间用逗号分隔。也就是说，给定`range(15)`作为输入，该函数应返回以下字符串：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Hint: if you’re thinking that `str.join` ([http://mng.bz/gyYl](http://mng.bz/gyYl))
    is a good idea here, then you’re mostly right--but remember that `str.join` won’t
    work on a list of integers.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果你认为在这里使用`str.join` ([http://mng.bz/gyYl](http://mng.bz/gyYl))是个好主意，那么你基本上是对的--但记住`str.join`不能在整数列表上工作。
- en: Working it out
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'In this exercise, we want to use `str.join` on a range, which is similar to
    a list of integers. If we try to invoke `str.join` right away, we’ll get an error:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们想要在整数范围内使用`str.join`，这类似于整数列表。如果我们立即调用`str.join`，我们会得到一个错误：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: That’s because `str.join` only works on a sequence of strings. We’ll thus need
    to convert each of the integers in our range (`numbers`) into a string. Then,
    when we have a list of strings based on our range of integers, we can run `str.join`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`str.join`只适用于字符串序列。因此，我们需要将我们范围内的每个整数（`numbers`）转换为字符串。然后，当我们有一个基于我们整数范围的字符串列表时，我们可以运行`str.join`。
- en: The solution is to use a list comprehension to invoke `str` on each of the numbers
    in the range. That will produce a list of strings, which is what `str.join` expects.
    How?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是使用列表推导式来对范围内的每个数字调用`str`。这将产生一个字符串列表，这正是`str.join`所期望的。怎么做？
- en: 'Consider this: a list comprehension says that we’re going to create a new list.
    The elements of the new list are all based on the elements in the source iterator,
    after an expression is run on them. What we’re doing is describing the new list
    in terms of the old one.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下：列表推导式表明我们将创建一个新的列表。新列表的元素都是基于源迭代器中的元素，在运行表达式后得到的。我们正在用旧列表的术语来描述新列表。
- en: 'Here are some examples that can help you to see where and how to use list comprehensions:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些示例，可以帮助你了解在哪里以及如何使用列表推导式：
- en: 'I want to know the age of each student in a class. So we’re starting with a
    list of student objects and ending up with a list of integers. You can imagine
    a `student` `_age` function being applied to each student to get their age:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我想了解班级中每个学生的年龄。所以我们从一个包含学生对象的列表开始，最终得到一个整数列表。你可以想象一个 `student_age` 函数被应用到每个学生上以获取他们的年龄：
- en: '[PRE4]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'I want to know how many mm of rain fell on each day of the previous month.
    So we’re starting with a list of days and ending with a list of floats. You can
    imagine a `daily_rain` function being applied to each day:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我想了解上个月每一天下了多少毫米的雨。所以我们从一个包含天数的列表开始，以一个浮点数列表结束。你可以想象一个 `daily_rain` 函数被应用到每一天：
- en: '[PRE5]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'I want to know how many vowels were used in a book. So we would apply a `number_of_vowels`
    function to each word in the book, and then run the `sum` function on the resulting
    list:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我想了解一本书中使用了多少个元音字母。所以我们将对书中的每个单词应用一个 `number_of_vowels` 函数，然后对结果列表运行 `sum` 函数：
- en: '[PRE6]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If these three examples look quite similar, that’s because they are; part of
    the power of list comprehensions is the simple formula that we repeat. Each list
    comprehension contains two parts:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这三个例子看起来非常相似，那是因为它们确实是；列表推导式的一部分力量在于我们重复的简单公式。每个列表推导式包含两个部分：
- en: The source iterable
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源可迭代对象
- en: The expression we’ll invoke once for each element
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将对每个元素调用一次的表达式
- en: In the case of our exercise here, we had a list of integers. By applying the
    `str` function on each int in the list, we got back a list of strings. `str.join`
    works fine on lists of strings.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这里的练习中，我们有一个整数列表。通过将 `str` 函数应用到列表中的每个整数上，我们得到了一个字符串列表。`str.join` 在字符串列表上运行得很好。
- en: '*Note* We’ll get into the specifics of the iterator protocol in chapter 10,
    which is dedicated to that subject. You don’t need to understand those details
    to use comprehensions. However, if you’re particularly interested in what counts
    as an “iterable,” go ahead and read the first part of that chapter before continuing
    here.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* 我们将在第 10 章详细介绍迭代器协议的具体内容，该章节专门讨论这个主题。你不需要理解这些细节就可以使用列表推导式。然而，如果你特别感兴趣于“可迭代”是什么，请在继续阅读这里之前先阅读该章节的第一部分。'
- en: Writing comprehensions
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 编写列表推导式
- en: 'Comprehensions are traditionally written on a single line:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式传统上是在单行上编写的：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'I find that especially for new Python developers, but even for experienced
    ones, it’s hard to figure out what’s going on. Things get even worse if you add
    a condition:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现，特别是对于新的 Python 开发者来说，即使是经验丰富的开发者，也很难弄清楚发生了什么。如果你添加一个条件，事情会变得更糟：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For this reason, I strongly suggest that Python developers break up their list
    comprehensions. Python is forgiving about whitespace if we’re inside of parentheses,
    which is always (by definition) the case when we’re in a comprehension. We can
    break up this comprehension as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我强烈建议 Python 开发者将他们的列表推导式拆分。Python 在括号内对空白字符很宽容，而括号（根据定义）总是存在于列表推导式中。我们可以这样拆分这个列表推导式：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Expression
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 表达式
- en: ❷ Iteration
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 迭代
- en: ❸ Condition
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 条件
- en: By separating the expression, iteration, and condition on different lines, the
    comprehension becomes more ... comprehensible. It’s also easier to experiment
    with the comprehension in this way. I’ll be writing most of my comprehensions
    in this book using this two- or three-line format, and I encourage you to do the
    same.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将表达式、迭代和条件分别放在不同的行上，列表推导式变得更加……易懂。以这种方式实验列表推导式也更容易。在这本书中，我将使用这种两行或三行的格式来编写大部分列表推导式，并鼓励你也这样做。
- en: 'Note that using this technique, nested list comprehensions also become easier
    to understand:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用这种技术，嵌套列表推导式也更容易理解：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Expression
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 表达式
- en: '❷ Iteration #1, from 0 through 4'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ 迭代 #1，从 0 到 4'
- en: '❸ Condition #1, ignoring even numbers'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '❸ 条件 #1，忽略偶数'
- en: '❹ Iteration #2, from 0 through 4'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '❹ 迭代 #2，从 0 到 4'
- en: '❺ Condition #2, ignore multiples of 3'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '❺ 条件 #2，忽略 3 的倍数'
- en: In other words, this list comprehension produces pairs of integers in which
    the first number must be odd, and the second number can’t be divisible by 3\.
    Nested comprehensions can be hard for anyone to understand, but when each of these
    sections appears on a line by itself, it’s easier to understand what’s happening.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这个列表推导式生成整数对，其中第一个数必须是奇数，第二个数不能被 3 整除。嵌套列表推导式对任何人来说都可能难以理解，但当每个部分单独出现在一行上时，理解起来就更容易了。
- en: 'Nested list comprehensions are great for working through complex data structures,
    such as lists of lists or lists of tuples. For example, let’s assume that I have
    a dict describing the countries and cities I’ve visited in the last year:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套列表推导式非常适合处理复杂的数据结构，例如列表的列表或列表的元组。例如，假设我有一个字典，描述了我去年访问过的国家和城市：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If I want a list of cities I’ve visited, ignoring the countries, I can use
    a nested list comprehension:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想得到一个只包含我去过的城市而不包含国家的列表，我可以使用嵌套列表推导式：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'I can also create a list of `(city,` `country)` tuples:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我还可以创建一个包含`(city,` `country)`元组的列表：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And of course, I can always sort them using `sorted`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我也可以使用`sorted`函数来排序：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, a list comprehension immediately produces a list--which, if you’re dealing
    with large quantities of data, can result in the use of a great deal of memory.
    For this reason, many Python developers would argue that we’d be better off using
    a generator expression ([http://mng.bz/K2M0](http://mng.bz/K2M0)).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，列表推导式立即生成一个列表——如果你处理大量数据，这可能会导致大量内存的使用。因此，许多Python开发者可能会认为我们最好使用生成器表达式([http://mng.bz/K2M0](http://mng.bz/K2M0))。
- en: 'Generator expressions look just like list comprehensions, except that instead
    of using square brackets, they use regular, round parentheses. However, this turns
    out to make a big difference: a list comprehension has to create and return its
    output list in one fell swoop, which can potentially use lots of memory. A generator
    expression, by contrast, returns its output one piece at a time.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式看起来就像列表推导式，除了它们使用的是常规的圆括号而不是方括号。然而，这实际上造成了很大的差异：列表推导式必须一次性创建并返回其输出列表，这可能会消耗大量内存。相比之下，生成器表达式一次返回一部分输出。
- en: For example, consider
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this code, `sum` is given one input, a list of integers. It iterates over
    the list of integers and sums them. But consider that before `sum` can run, the
    comprehension needs to finish creating the entire list of integers. This list
    can potentially be quite large and consume a great deal of memory.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，`sum`被赋予一个输入，一个整数列表。它遍历整数列表并求和。但是考虑在`sum`运行之前，推导式需要完成整个整数列表的创建。这个列表可能非常大，消耗大量内存。
- en: 'By contrast, consider this code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，考虑以下代码：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, the input to `sum` isn’t a list; it’s a generator, one that we created
    via our generator expression. `sum` will return precisely the same result as it
    did previously. However, whereas our first example created a list containing 100,000
    elements, the latter uses much less memory. The generator returns one element
    at a time, waiting for `sum` to request the next item in line. In this way, we’re
    only consuming one integer’s worth of memory at a time, rather than a huge list
    of integers’ memory. The bottom line, then, is that you can use generator expressions
    almost anywhere you can use comprehensions, but you’ll use much less memory.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`sum`的输入不是一个列表；它是一个生成器，我们通过生成器表达式创建的。`sum`将返回与之前相同的结果。然而，与我们的第一个例子创建了一个包含100,000个元素的列表不同，后者使用的内存要少得多。生成器一次返回一个元素，等待`sum`请求下一个元素。这样，我们每次只消耗一个整数的内存，而不是一个包含大量整数的内存。因此，最终结果是，你几乎可以在任何可以使用推导式的地方使用生成器表达式，但你将使用更少的内存。
- en: 'It turns out that when we put a generator expression in a function call, we
    can remove the inner parentheses:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，当我们把生成器表达式放在函数调用中时，我们可以移除内部括号：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And thus, here’s the syntax that you saw in the solution to this exercise,
    but using a generator expression:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里是你在这个练习的解决方案中看到的语法，但使用了生成器表达式：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Solution
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Applies str to each number and puts the new string in the output list
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将字符串`str`应用于每个数字，并将新的字符串放入输出列表中
- en: ❷ Iterates over the elements of numbers
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 遍历`numbers`的元素
- en: You can work through a version of this code in the Python Tutor at [http://mng.bz/
    zj4w](http://mng.bz/zj4w).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Python Tutor中尝试这个代码的版本：[http://mng.bz/zj4w](http://mng.bz/zj4w).
- en: Screencast solution
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 观看这个解决方案的简短视频教程：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout).
- en: Beyond the exercise
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超越练习
- en: 'Here are a few ways you might want to go beyond this exercise, and push yourself
    to use list comprehensions in new ways:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你可能想要超越这个练习的方法，并尝试以新的方式使用列表推导式：
- en: As in the exercise, take a list of integers and turn them into strings. However,
    you’ll only want to produce strings for integers between 0 and 10\. Doing this
    will require understanding the `if` statement in list comprehensions as well.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如同练习中一样，取一个整数列表，将它们转换为字符串。然而，你只希望为介于 0 到 10 之间的整数生成字符串。这样做将需要理解列表推导式中的 `if`
    语句。
- en: Given a list of strings containing hexadecimal numbers, sum the numbers together.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个包含十六进制数字的字符串列表，将这些数字相加。
- en: Use a list comprehension to reverse the word order of lines in a text file.
    That is, if the first line is `abc` `def` and the second line is `ghi` `jkl`,
    then you should return the list `['def` `abc',` `'jkl` `ghi']`.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用列表推导式来反转文本文件中行的单词顺序。也就是说，如果第一行是 `abc` `def`，第二行是 `ghi` `jkl`，那么你应该返回列表 `['def`
    `abc',` `'jkl` `ghi']`。
- en: '`map`, `filter`, and comprehensions'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`、`filter` 和推导式'
- en: 'Comprehensions, at their heart, do two different things. First, they transform
    one sequence into another, applying an expression on each element of the input
    sequence. Second, they filter out elements from the output. Here’s an example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 推导式在其核心上执行两件不同的事情。首先，它们将一个序列转换成另一个序列，对输入序列的每个元素应用一个表达式。其次，它们从输出中过滤出元素。以下是一个示例：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ x squared
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ x 的平方
- en: ❷ For each number from 0-9
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对于从 0 到 9 的每个数字
- en: ❸ But only if x is even
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 但只有当 x 是偶数时
- en: 'The first line is where the transformation takes place, and the third line
    is where the filtering takes place. Before Python’s comprehensions, these features
    were traditionally implemented using two functions: `map` and `filter`. Indeed,
    these functions continue to exist in Python, even if they’re not used all that
    often.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是转换发生的地方，第三行是过滤发生的地方。在 Python 的推导式出现之前，这些功能通常使用两个函数来实现：`map` 和 `filter`。确实，这些函数在
    Python 中仍然存在，即使它们并不经常使用。
- en: '`map` takes two arguments: a function and an iterable. It applies the function
    to each element of the iterable, returning a new iterable; for example'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 接受两个参数：一个函数和一个可迭代对象。它将函数应用于可迭代对象的每个元素，返回一个新的可迭代对象；例如'
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Creates a list of strings, and assigns it to “words”
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个字符串列表，并将其分配给“words”
- en: ❷ Applies the len function to each word, resulting in an iterable of integers
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对每个单词应用 len 函数，结果是一个整数可迭代对象
- en: ❸ Uses the sum function on x
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 对 x 使用求和函数
- en: Notice that `map` always returns an iterable that has the same length as its
    input. That’s because it doesn’t have a way to remove elements. It applies its
    input function once per input element. We can thus say that `map` transforms but
    doesn’t filter.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`map` 总是返回一个与输入具有相同长度的可迭代对象。这是因为它没有删除元素的方法。它对每个输入元素应用其输入函数一次。因此，我们可以这样说，`map`
    进行转换但不进行过滤。
- en: The function passed to `map` can be any function or method that takes a single
    argument. You can use built-in functions or write your own. The key thing to remember
    is that it’s the output from the function that’s placed in the output iterable.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `map` 的函数可以是任何接受单个参数的函数或方法。你可以使用内置函数或编写自己的函数。要记住的关键是，放置在输出可迭代对象中的是函数的输出。
- en: '`filter` also takes two arguments, a function and an iterable, and it applies
    the function to each element. But here, the output of the function determines
    whether the element will appear in the output--it doesn’t transform the element
    at all; for example'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter` 也接受两个参数，一个函数和一个可迭代对象，并将该函数应用于每个元素。但在这里，函数的输出决定了元素是否将出现在输出中——它根本不转换元素；例如'
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Creates a list of strings, and assigns it to “words”
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个字符串列表，并将其分配给“words”
- en: ❷ Defines a function that returns a True or False value, based on the word passed
    to it
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义一个函数，根据传递给它的单词返回 True 或 False 值
- en: ❸ Applies our function to each word in “words”
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将我们的函数应用于“words”中的每个单词
- en: ❹ Shows the words that passed through the filter
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 显示通过过滤器的单词
- en: While the function passed to `filter` doesn’t have to return a `True` or `False`
    value, its result will be interpreted as a Boolean and used to determine if the
    element is put into the output sequence. So it’s usually a good idea to pass a
    function that returns a `True` or `False`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然传递给 `filter` 的函数不必返回 `True` 或 `False` 值，但其结果将被解释为布尔值并用于确定元素是否被放入输出序列。因此，通常最好传递一个返回
    `True` 或 `False` 的函数。
- en: The combination of `map` and `filter` means that you can take an iterable, filter
    its elements, then apply a function to each of its elements. This turns out to
    be extremely useful and explains why `map` and `filter` have been around for so
    long--about 50 years, in fact.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`和`filter`的结合意味着你可以对一个可迭代对象进行过滤，然后对其元素应用函数。这证明是非常有用的，这也是为什么`map`和`filter`存在了这么久——实际上大约有50年。'
- en: The fact that functions can be passed as arguments is central to the ability
    of both `map` and `filter` to even execute. That’s one reason why these techniques
    are a core part of functional programming, because they require that functions
    can be treated as data.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以作为参数传递的事实是`map`和`filter`能够执行的核心。这也是为什么这些技术是函数式编程的核心部分之一，因为它们要求函数可以被当作数据来处理。
- en: That said, comprehensions are considered to be the modern way to do this kind
    of thing in Python. Whereas we pass functions to `map` and `filter`, we pass expressions
    to comprehensions.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，列表推导式被认为是Python中执行此类操作的现代方式。当我们向`map`和`filter`传递函数时，我们向列表推导式传递表达式。
- en: 'Why, then, do `map` and `filter` continue to exist in the language, if comprehensions
    are considered to be better? Partly for nostalgic and historical reasons, but
    also because they can sometimes do things you can’t easily do with comprehensions.
    For example, `map` can take multiple iterables in its input and then apply functions
    that will work with each of them:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么`map`和`filter`在语言中仍然存在，如果列表推导式被认为更好？部分原因是怀旧和历史原因，但也是因为它们有时可以做一些列表推导式难以轻松完成的事情。例如，`map`可以接受多个可迭代输入，然后对每个输入应用函数：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ We’ll use operator.mul as our map function.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们将使用`operator.mul`作为我们的`map`函数。
- en: ❷ Sets up a four-element string
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 设置一个包含四个元素的字符串
- en: ❸ Sets up a four-element integer range
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 设置一个包含四个元素的整数范围
- en: ❹ Applies operator.mul (multiply) to the corresponding elements of letters and
    numbers
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将`letters`和`numbers`的对应元素应用乘法运算符（multiply）
- en: ❺ Joins the strings together with spaces and prints the result
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用空格将字符串连接起来并打印结果
- en: 'This code prints the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将打印以下内容：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Using a comprehension, we could rewrite the code as
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表推导式，我们可以将代码重写为
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice that to iterate over both `letters` and `numbers` at the same time, I
    had to use `zip` here. By contrast, `map` can simply take additional iterable
    arguments.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，要同时遍历`letters`和`numbers`，我不得不在这里使用`zip`。相比之下，`map`可以简单地接受额外的可迭代参数。
- en: What is an expression?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是表达式？
- en: An *expression* is anything in Python that returns a value. If that seems a
    bit abstract to you, then you can just think of an expression as anything you
    can assign to a variable, or return from a function. So `5` is an expression,
    as is `5+3`, as is `len('abcd')`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，任何返回值的`expression`都是表达式。如果你觉得这有点抽象，那么你可以将表达式想象成你可以赋值给变量或从函数返回的任何东西。所以`5`是一个表达式，`5+3`也是一个表达式，`len('abcd')`同样是一个表达式。
- en: When I say that comprehensions use expressions, rather than functions, I mean
    that we don’t pass a function. Rather, we just pass the thing that we want Python
    to evaluate, akin to passing the body of the function without passing the formal
    function definition.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说列表推导式使用表达式而不是函数时，我的意思是我们不需要传递一个函数。相反，我们只是传递我们希望Python评估的东西，就像传递函数体而不传递正式的函数定义一样。
- en: Exercise 29 ■ Add numbers
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 29 ■ 添加数字
- en: In the previous exercise, we took a sequence of numbers and turned it into a
    sequence of strings. This time, we’ll do the opposite--take a sequence of strings,
    turn them into numbers, and then sum them. But we’re going to make it a bit more
    complicated, because we’re going to filter out those strings that can’t be turned
    into integers.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们将一个数字序列转换成了一个字符串序列。这次，我们将做相反的操作——将一个字符串序列转换成数字，然后求和。但是，我们会让它变得更复杂一些，因为我们将过滤掉那些无法转换为整数的字符串。
- en: Our function (`sum_numbers`) will take a string as an argument; for example
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的功能函数（`sum_numbers`）将接受一个字符串作为参数；例如
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Given that input, our function should return `100`. That’s because the function
    will ignore any word that contains nondigits.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这个输入，我们的函数应该返回`100`。这是因为函数将忽略任何包含非数字的单词。
- en: Ask the user to enter integers, all at once, using `input` ([http://mng.bz/wB27](http://mng.bz/wB27)).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请用户使用`input`一次性输入整数（[http://mng.bz/wB27](http://mng.bz/wB27)）。
- en: Working it out
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: In this exercise, we’re given a string, which we assume contains integers separated
    by spaces. We want to grab the individual integers from the string and then sum
    them together. The easiest way to do this is to invoke `str.split` on the string,
    which returns a list of strings. By invoking `str.split` without any parameters,
    we tell Python that any combination of whitespace should be used as a delimiter.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们得到一个字符串，我们假设它包含由空格分隔的整数。我们想要从字符串中提取单独的整数并将它们相加。最简单的方法是在字符串上调用 `str.split`，这将返回一个字符串列表。通过在没有任何参数的情况下调用
    `str.split`，我们告诉 Python 使用任何空白字符组合作为分隔符。
- en: Now we have a list of strings, rather than a list of integers. What we need
    to do is iterate over the strings, turning each one into an integer by invoking
    `int` on it. The easiest way to turn a list of strings into a list of integers
    is to use a list comprehension, as in the solution code. In theory, we could then
    invoke the built-in `sum` function on the list of integers, and we would be done.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个字符串列表，而不是整数列表。我们需要做的是遍历这些字符串，通过在它们上调用 `int` 来将每个字符串转换为整数。将字符串列表转换为整数列表的最简单方法就是使用列表推导式，正如解答代码中所展示的。从理论上讲，我们可以在整数列表上调用内置的
    `sum` 函数，然后我们就完成了。
- en: But there’s a catch. It’s possible that the user’s input includes elements that
    can’t be turned into integers. We need to get rid of those; if we try to run `int`
    on the string `abcd`, the program will exit with an error.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 但有一个问题。有可能用户的输入包含无法转换为整数的元素。我们需要去除这些元素；如果我们尝试在字符串 `abcd` 上运行 `int`，程序将因错误而退出。
- en: Fortunately, list comprehensions can help us here too. We can use the third
    (filtering) line of the comprehension to indicate that only those strings that
    can be turned into numbers will pass through to the first line. We do this with
    an `if` statement, applying the `str.isdigit` method to find out whether we can
    successfully turn the word into an integer.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，列表推导式也可以帮助我们。我们可以使用推导式的第三行（过滤行）来指示只有那些可以转换为数字的字符串才能通过第一行。我们通过一个 `if` 语句来完成这个操作，应用
    `str.isdigit` 方法来找出我们是否可以成功地将单词转换为整数。
- en: We then invoke `sum` on the generator expression, returning an integer. Finally,
    we print the sum using an f-string.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后在生成器表达式中调用 `sum`，返回一个整数。最后，我们使用 f-string 打印这个总和。
- en: Solution
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解答
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Creates an integer based on number
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 基于数字创建整数
- en: ❷ Iterates through each of the words in numbers
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 遍历数字中的每个单词
- en: ❸ Ignores words that can’t be turned into integers
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 忽略无法转换为整数的单词
- en: You can work through a version of this code in the Python Tutor at [http://mng.bz/
    046p](http://mng.bz/046p).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Python Tutor 中通过这个版本的工作代码 [http://mng.bz/ 046p](http://mng.bz/046p)。
- en: Screencast solution
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解答
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 观看这个关于解答的简短视频：[https://livebook.manning.com/ video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超越练习
- en: 'One of the most common uses for list comprehensions, at least in my experience,
    is for doing this combination of transformation and filtering. Here are a few
    additional exercises you could do to ensure that you understand not just the syntax,
    but also their potential:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式最常见的一种用途，至少在我的经验中，是用于这种转换和过滤的组合。以下是一些额外的练习，以确保你不仅理解了语法，还理解了它们的潜在用途：
- en: Show the lines of a text file that contain at least one vowel and contain more
    than 20 characters.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示包含至少一个元音字母且长度超过20个字符的文本文件的行。
- en: In the United States, phone numbers have 10 digits--a three-digit area code,
    followed by a seven-digit number. Several times during my childhood, area codes
    would run out of phone numbers, forcing half of the population to get a new area
    code. After such a split, XXX-YYY-ZZZZ might remain XXX-YYY-ZZZZ, or it might
    become NNN-YYY-ZZZZ, with NNN being the new area code. The decision regarding
    which numbers remained and which changed was often made based on the phone numbers’
    final seven digits. Use a list comprehension to return a new list of strings,
    in which any phone number whose YYY begins with the digits 0-5 will have its area
    code changed to XXX+1\. For example, given the list of strings `['123-456-7890',`
    `'123-333-4444',` `'123-777-8888']`, we want to convert them to `['124-456-7890',`
    `'124-333-4444',` `'124-777-8888']`.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在美国，电话号码有10位数字——一个三位数的区号，后面跟着一个七位数的电话号码。在我童年时期，有几个区号的电话号码会耗尽，迫使一半的人口获得一个新的区号。在这样的一次分割后，XXX-YYY-ZZZZ可能仍然是XXX-YYY-ZZZZ，或者它可能变成NNN-YYY-ZZZZ，其中NNN是新的区号。关于哪些号码保留以及哪些号码更改的决定通常是基于电话号码的最后七位数字做出的。使用列表推导式返回一个新的字符串列表，其中任何YYY以数字0-5开头的电话号码都将将其区号更改为XXX+1。例如，给定字符串列表`['123-456-7890',
    '123-333-4444', '123-777-8888']`，我们希望将它们转换为`['124-456-7890', '124-333-4444', '124-777-8888']`。
- en: 'Define a list of five dicts. Each dict will have two key-value pairs, `name`
    and `age`, containing a person’s name and age (in years). Use a list comprehension
    to produce a list of dicts in which each dict contains three key-value pairs:
    the original `name`, the original `age`, and a third `age_in_months` key, containing
    the person’s age in months. However, the output should exclude any of the input
    dicts representing people over 20 years of age.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个包含五个字典的列表。每个字典将包含两个键值对，`name` 和 `age`，包含一个人的姓名和年龄（以年为单位）。使用列表推导式生成一个字典列表，其中每个字典包含三个键值对：原始的
    `name`，原始的 `age`，以及第三个 `age_in_months` 键，包含人的年龄（以月为单位）。然而，输出应排除任何代表20岁以上的人的输入字典。
- en: Exercise 30 ■ Flatten a list
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 30 ■ 展平列表
- en: It’s pretty common to use complex data structures to store information in Python.
    Sure, we could create a new class, but why do that when we can just use combinations
    of lists, tuples, and dicts? This means, though, that you’ll sometimes need to
    unravel those complex data structures, turning them into simpler ones.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，使用复杂的数据结构来存储信息是很常见的。当然，我们可以创建一个新的类，但为什么我们要这样做，当我们可以使用列表、元组和字典的组合时呢？这意味着，然而，有时你需要解开这些复杂的数据结构，将它们转换成更简单的形式。
- en: In this exercise, we’ll practice doing such unraveling. Write a function that
    takes a list of lists (just one element deep) and returns a flat, one-dimensional
    version of the list. Thus, invoking
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将练习这样做。编写一个函数，它接受一个列表的列表（只有一层元素）并返回列表的平坦、一维版本。因此，调用
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: will return
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 将返回
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that there are several possible solutions to this problem; I’m asking you
    to solve it with list comprehensions. Also note that we only need to worry about
    flattening a two-level list.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个问题有几种可能的解决方案；我要求你使用列表推导式来解决这个问题。还请注意，我们只需要担心展平一个两层列表。
- en: Working it out
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: As we’ve seen, list comprehensions allow us to evaluate an expression on each
    element of an iterable. But in a normal list comprehension, you can’t return more
    elements than were in the input iterable. If the input iterable has 10 elements,
    for example, you can only return 10, or fewer than 10 if you use an `if` clause.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，列表推导式允许我们在可迭代对象的每个元素上评估一个表达式。但在正常的列表推导式中，你不能返回比输入可迭代对象更多的元素。例如，如果输入可迭代对象有10个元素，那么你只能返回10个，或者使用
    `if` 子句返回少于10个。
- en: 'Nested list comprehensions change this a bit, in that the result may contain
    as many elements as there are sub-elements of the input iterable. Given a list
    of lists, the first `for` loop will iterate over every element in `mylist`. But
    the second `for` loop will iterate over the elements of the inner list. We can
    produce one output element for each inner input element, and that’s what we do:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套列表推导式对此略有不同，因为结果可能包含与输入可迭代对象子元素一样多的元素。给定一个列表的列表，第一个 `for` 循环将遍历 `mylist` 中的每个元素。但第二个
    `for` 循环将遍历内部列表的元素。我们可以为每个内部输入元素生成一个输出元素，这就是我们做的：
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Solution
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ Iterates through each element of mylist
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 遍历mylist中的每个元素
- en: ❷ Iterates through each element of one_sublist
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 遍历one_sublist中的每个元素
- en: You can work through a version of this code in the Python Tutor at [http://mng.bz/
    jg4P](http://mng.bz/jg4P).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Python Tutor的版本中工作[http://mng.bz/ jg4P](http://mng.bz/jg4P)。
- en: Screencast solution
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 观看这个关于解决方案的简短视频：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超越练习
- en: 'Nested list comprehensions can be a bit daunting at first, but they can be
    quite helpful in many circumstances. Here are some exercises you can try to improve
    your understanding of how to use them:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套列表推导式一开始可能有点令人望而却步，但在许多情况下它们非常有用。以下是一些你可以尝试的练习，以加深你对如何使用它们的理解：
- en: Write a version of the `flatten` function mentioned earlier called `flatten_odd
    _ints`. It’ll do the same thing as `flatten`, but the output will only contain
    odd integers. Inputs that are neither odd nor integers should be excluded. Inputs
    containing strings that could be converted to integers should be converted; other
    strings should be excluded.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个名为`flatten_odd_ints`的函数，它是之前提到的`flatten`函数的版本。它将执行与`flatten`相同的功能，但输出将只包含奇数整数。既不是奇数也不是整数的输入应该被排除。包含可以转换为整数的字符串的输入应该被转换；其他字符串应该被排除。
- en: Define a dict that represents the children and grandchildren in a family. (See
    figure 7.1 for a graphic representation.) Each key will be a child’s name, and
    each value will be a list of strings representing their children (i.e., the family’s
    grandchildren). Thus the dict `{'A':['B',` `'C',` `'D'],` `'E':['F',` `'G']}`
    means that `A` and `E` are siblings; `A`’s children are `B`, `C`, and `D`; and
    `E`’s children are `F` and `G`. Use a list comprehension to create a list of the
    grandchildren’s names.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个字典，表示家庭中的子女和孙子女。 （见图7.1的图形表示。）每个键将是一个孩子的名字，每个值将是一个字符串列表，表示他们的孩子（即家庭的孙子女）。因此，字典`{'A':['B',
    'C', 'D'], 'E':['F', 'G']}`表示`A`和`E`是兄弟姐妹；`A`的孩子是`B`、`C`和`D`；`E`的孩子是`F`和`G`。使用列表推导式创建一个孙子女名字的列表。
- en: Redo this exercise, but replace each grandchild’s name (currently a string)
    with a dict. Each dict will contain two name-value pairs, `name` and `age`. Produce
    a list of the grandchildren’s names, sorted by age, from eldest to youngest.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新做这个练习，但将每个孙子的名字（目前是一个字符串）替换为一个字典。每个字典将包含两个键值对，`name`和`age`。生成一个按年龄排序的孙子名字列表，从年长的到年幼的。
- en: '![](../Images/7-1.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图片7-1](../Images/7-1.png)'
- en: Figure 7.1 Graph of the family for nested list comprehensions
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 嵌套列表推导式的家庭图
- en: Exercise 31 ■ Pig Latin translation of a file
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习31 ■ 文件的猪拉丁语翻译
- en: List comprehensions are great when you want to transform a list. But they can
    actually work on any iterable--that is, any Python object on which you can run
    a `for` loop. This means that the source data for a list comprehension can be
    a string, list, tuple, dict, set, or even a file.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式在你想转换列表时非常有用。但实际上，它们可以作用于任何可迭代对象——也就是说，任何你可以运行`for`循环的Python对象。这意味着列表推导式的源数据可以是字符串、列表、元组、字典、集合，甚至是文件。
- en: In this exercise, I want you to write a function that takes a filename as an
    argument. It returns a string with the file’s contents, but with each word translated
    into Pig Latin, as per our `plword` function in chapter 2 on “strings.” The returned
    translation can ignore newlines and isn’t required to handle capitalization and
    punctuation in any specific way.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我希望你编写一个函数，该函数接受一个文件名作为参数。它返回一个字符串，包含文件的内容，但每个单词都翻译成了猪拉丁语，正如我们在第2章“字符串”中提到的`plword`函数。返回的翻译可以忽略换行符，并且不需要以任何特定方式处理大小写和标点符号。
- en: Working it out
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: We’ve seen that nested list comprehensions can be used to iterate over complex
    data structures. In this case, we’re iterating over a file. And indeed, we could
    iterate over each line of the file.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到嵌套列表推导式可以用来遍历复杂的数据结构。在这种情况下，我们正在遍历一个文件。实际上，我们可以遍历文件的每一行。
- en: But we can break the problem down further, using a nested list comprehension
    to first iterate over each line of the file, and then over each word within the
    current line. Our `plword` function can then operate on a single word at a time.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可以进一步分解问题，使用嵌套列表推导式首先遍历文件的每一行，然后遍历当前行中的每个单词。然后我们的`plword`函数可以一次操作一个单词。
- en: I realize that nested list comprehensions can be hard, at least at first, to
    read and understand. But as you use them, you’ll likely find that they allow you
    to elegantly break down a problem into its components.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我意识到嵌套列表推导式可能很难阅读和理解，至少一开始是这样。但随着你使用它们，你可能会发现它们允许你优雅地将问题分解为其组成部分。
- en: There is a bit of a problem with what we’ve done here, but it might not seem
    obvious at first. List comprehensions, by their very nature, produce lists. This
    means that if we translate a large file into Pig Latin, we might find ourselves
    with a very long list. It would be better to return an iterator object that would
    save memory, only calculating the minimum necessary for each iteration.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做了一些事情，但一开始可能不明显。列表解析，由于其本质，会产生列表。这意味着如果我们把一个大文件翻译成猪拉丁语，我们可能会发现自己有一个非常长的列表。更好的做法是返回一个迭代器对象，它会节省内存，只为每次迭代计算必要的最小值。
- en: It turns out that doing so is quite easy. We can use a generator expression
    (as suggested in this chapter’s first exercise), which looks almost precisely
    like a list comprehension, but using round parentheses rather than square brackets.
    We can put a generator expression in a call to `str.join`, just as we could put
    in a list comprehension, saving memory in the process.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 结果证明，这样做相当简单。我们可以使用生成器表达式（如本章第一个练习中建议的），它看起来几乎与列表解析完全相同，但使用圆括号而不是方括号。我们可以将生成器表达式放入
    `str.join` 的调用中，就像我们可以放入列表解析一样，在这个过程中节省内存。
- en: 'Here’s how that code would look:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将看起来是这样的：
- en: '[PRE32]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'But wait--it turns out that if you have a generator expression inside a function
    call, you don’t actually need both sets of parentheses. You can leave one out,
    which means the code will look like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等--结果证明，如果你在函数调用内部有一个生成器表达式，实际上你不需要两组括号。你可以省略一个，这意味着代码将看起来像这样：
- en: '[PRE33]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We’ve now not only accomplished our original task, we’ve done so using less
    memory than a list comprehension requires. There might be a slight trade-off in
    terms of speed, but this is usually considered worthwhile, given the potential
    problems you’ll encounter reading a huge file into memory all at once.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅完成了原始任务，而且使用的内存比列表解析所需的还要少。在速度方面可能会有一些权衡，但考虑到一次性将大文件读入内存可能遇到的问题，这通常被认为是值得的。
- en: Solution
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ❶ Iterates through each line of filename
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 遍历文件名每一行
- en: ❷ Iterates through each word in the current line
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 遍历当前行中的每个单词
- en: You can work through a version of this code in the Python Tutor at [http://mng.bz/
    K2xP](http://mng.bz/K2xP).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Python Tutor 中尝试这个代码的版本：[http://mng.bz/K2xP](http://mng.bz/K2xP)。
- en: Note that because the Python Tutor doesn’t support working with external files,
    I used an instance of `StringIO` to simulate a file.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于 Python Tutor 不支持处理外部文件，我使用了一个 `StringIO` 实例来模拟文件。
- en: Screencast solution
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 观看此解决方案的简短视频教程：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 除此之外
- en: 'Whenever you’re transforming and/or filtering complex or nested data structures,
    or (as in the case of a file) something that can be treated as a nested data structure,
    it’s often useful to use a nested list comprehension:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当你正在转换和/或过滤复杂或嵌套的数据结构，或者（例如文件）可以被视为嵌套数据结构的东西时，使用嵌套列表解析通常很有用：
- en: In this exercise, `plfile` applied the `plword` function to every word in a
    file. Write a new function, `funcfile`, that will take two arguments--a filename
    and a function. The output from the function should be a string, the result of
    invoking the function on each word in the text file. You can think of this as
    a generic version of `plfile`, one that can return any string value.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个练习中，`plfile` 将 `plword` 函数应用于文件中的每个单词。编写一个新的函数 `funcfile`，它将接受两个参数--一个文件名和一个函数。该函数的输出应该是一个字符串，它是通过对文本文件中的每个单词调用该函数的结果。你可以将其视为
    `plfile` 的一个通用版本，它可以返回任何字符串值。
- en: Use a nested list comprehension to transform a list of dicts into a list of
    two-element (name-value) tuples, each of which represents one of the name-value
    pairs in one of the dicts. If more than one dict has the same name-value pair,
    then the tuple should appear twice.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用嵌套列表解析将字典列表转换为包含两个元素（名称-值）元组的列表，每个元组代表字典中的一个名称-值对。如果有多个字典具有相同的名称-值对，则该元组应出现两次。
- en: 'Assume that you have a list of dicts, in which each dict contains two name-value
    pairs: `name` and `hobbies`, where `name` is the person’s name and `hobbies` is
    a set of strings representing the person’s hobbies. What are the three most popular
    hobbies among the people listed in the dicts?'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设你有一个包含字典的列表，其中每个字典包含两个键值对：`name` 和 `hobbies`，其中 `name` 是人的名字，`hobbies` 是表示人的爱好的字符串集合。在字典中列出的人中，哪三个爱好最受欢迎？
- en: Exercise 32 ■ Flip a dict
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 32 ■ 翻转字典
- en: The combination of comprehensions and dicts can be quite powerful. You might
    want to modify an existing dict, removing or modifying certain elements. For example,
    you might want to remove all users whose ID number is lower than 500\. Or you
    might want to find the user IDs of all users whose names begin with the letter
    “A”.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 推导式和字典的组合可以非常强大。你可能想修改现有的字典，删除或修改某些元素。例如，你可能想删除所有ID号码低于500的用户。或者你可能想找到所有以字母“A”开头的用户ID。
- en: It’s also not uncommon to want to flip a dict--that is, to exchange its keys
    and values. Imagine a dict in which the keys are usernames and the values are
    user ID numbers; it might be useful to flip that so that you can search by ID
    number.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 想要翻转字典——即交换其键和值——的情况也并不少见。想象一个键是用户名，值是用户ID号的字典；翻转它可能有助于通过ID号进行搜索。
- en: 'For this exercise, first create a dict of any size, in which the keys are unique
    and the values are also unique. (A key may appear as a value, or vice versa.)
    Here’s an example:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，首先创建一个任何大小的字典，其中键是唯一的，值也是唯一的。（键可能作为值出现，反之亦然。）以下是一个例子：
- en: '[PRE35]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Turn the dict inside out, such that the keys and the values are reversed.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 将字典翻转过来，使得键和值是相反的。
- en: Working it out
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Just as list comprehensions provide an easy way to create lists based on another
    iterable, dict comprehensions provide an easy way to create a dict based on an
    iterable. The syntax is as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 正如列表推导式提供了一个基于另一个可迭代对象创建列表的简单方法一样，字典推导式提供了一个基于可迭代对象创建字典的简单方法。其语法如下：
- en: '[PRE36]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In other words
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说
- en: The source for our dict comprehension is an iterable--typically a string, list,
    tuple, dict, set, or file.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们字典推导式的来源是一个可迭代对象——通常是字符串、列表、元组、字典、集合或文件。
- en: We iterate over each such item in a `for` loop.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过 `for` 循环遍历每个这样的项目。
- en: For each item, we then output a key-value pair.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个项目，我们随后输出一个键值对。
- en: Notice that a colon (`:`) separates the key from the value. That colon is part
    of the syntax, which means that the expressions on either side of the colon are
    evaluated separately and can’t share data.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到冒号（`:`）将键与值分开。这个冒号是语法的一部分，这意味着冒号两边的表达式是分别评估的，它们不能共享数据。
- en: In this particular case, we’re looping over the elements of a dict named `d`.
    We use the `dict.items` method to do so, which returns two values--the key and
    value--with each iteration. These two values are passed by parallel assignment
    to the variables `key` and `value`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的情况下，我们正在遍历名为 `d` 的字典的元素。我们使用 `dict.items` 方法来这样做，该方法在每次迭代时返回两个值——键和值。这两个值通过并行赋值传递给变量
    `key` 和 `value`。
- en: 'Another way of solving this exercise is to iterate over `d`, rather than over
    the output of `d.items()`. That would provide us with the keys, requiring that
    we retrieve each value:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个练习的另一种方法是遍历 `d`，而不是遍历 `d.items()` 的输出。这将为我们提供键，需要我们检索每个值：
- en: '[PRE37]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In a comprehension, I’m trying to create a new object based on an old one. It’s
    all about the values that are returned by the expression at the start of the comprehension.
    By contrast, `for` loops are about commands, and executing those commands.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在推导式中，我试图基于一个旧对象创建一个新对象。这完全取决于推导式开始处的表达式返回的值。相比之下，`for` 循环是关于命令的，以及执行这些命令。
- en: Consider what your goal is, and whether you’re better served with a comprehension
    or a `for` loop; for example
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑你的目标是什么，以及你是否更适合使用推导式或 `for` 循环；例如
- en: Given a string, you want a list of the `ord` values for each character. This
    should be a list comprehension, because you’re creating a list based on a string,
    which is iterable.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个字符串，你想要一个包含每个字符的 `ord` 值的列表。这应该是一个列表推导式，因为你正在基于一个字符串（它是可迭代的）创建一个列表。
- en: You have a list of dicts, in which each dict contains your friends’ first and
    last names, and you want to insert this data into a database. In this case, you’ll
    use a regular `for` loop, because you’re interested in the side effects, not the
    return value.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有一个包含字典的列表，其中每个字典包含你朋友的姓氏和名字，你想将这些数据插入到数据库中。在这种情况下，你会使用一个普通的`for`循环，因为你对副作用感兴趣，而不是返回值。
- en: Solution
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE38]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ❶ All iterables are acceptable in a comprehension, even those that return two-element
    tuples, such as dict.items.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 所有可迭代对象都适用于推导式，甚至包括返回两个元素元组的那些，例如dict.items。
- en: You can work through this code in the Python Tutor at [http://mng.bz/905x](http://mng.bz/905x).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Python Tutor中运行此代码：[http://mng.bz/905x](http://mng.bz/905x)。
- en: Screencast solution
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 观看这个关于解决方案的简短视频：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超出练习范围
- en: 'Dict comprehensions provide us with a useful way to create new dicts. They’re
    typically used when you want to create a dict based on an iterable, such as a
    list or file. I’m especially partial to using them when I want to read from a
    file and turn the file’s contents into a dict. Here are some additional ideas
    for ways to practice the use of dict comprehensions:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 字典推导式为我们提供了一种创建新字典的有用方法。它们通常用于当你想根据可迭代对象创建字典时，例如列表或文件。我特别喜欢在我想从文件中读取并将其内容转换为字典时使用它们。以下是一些练习字典推导式使用的额外想法：
- en: Given a string containing several (space-separated) words, create a dict in
    which the keys are the words, and the values are the number of vowels in each
    word. If the string is “this is an easy test,” then the resulting dict would be
    `{'this':1,` `'is':1,` `'an':1,` `'easy':2,` `'test':1}`.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个包含多个（空格分隔）单词的字符串，创建一个字典，其中键是单词，值是每个单词中的元音数量。如果字符串是“this is an easy test”，那么生成的字典将是`{'this':1,
    'is':1, 'an':1, 'easy':2, 'test':1}`。
- en: Create a dict whose keys are filenames and whose values are the lengths of the
    files. The input can be a list of files from `os.listdir` ([http://mng.bz/YreB](http://mng.bz/YreB))
    or `glob.glob` ([http://mng.bz/044N](http://mng.bz/044N)).
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个字典，其键是文件名，其值是文件的长度。输入可以是来自`os.listdir` ([http://mng.bz/YreB](http://mng.bz/YreB))
    或 `glob.glob` ([http://mng.bz/044N](http://mng.bz/044N)) 的文件列表。
- en: Find a configuration file in which the lines look like “name=value.” Use a dict
    comprehension to read from the file, turning each line into a key-value pair.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在配置文件中找到一个看起来像“name=value”的行。使用字典推导式从文件中读取，将每一行转换成键值对。
- en: Exercise 33 ■ Transform values
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习33 ■ 转换值
- en: This exercise combines showing how you can receive a function as a function
    argument, and how comprehensions can help us to elegantly solve a wide variety
    of problems.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习结合了展示如何接收一个函数作为函数参数，以及推导式如何帮助我们优雅地解决各种问题。
- en: 'The built-in `map` ([http://mng.bz/Ed2O](http://mng.bz/Ed2O)) takes two arguments:
    (a) a function and (b) an iterable. It returns a new sequence, which is the result
    of applying the function to each element of the input iterable. A full discussion
    of `map` is in the earlier sidebar, “`map`, `filter`, and comprehensions.”'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的`map` ([http://mng.bz/Ed2O](http://mng.bz/Ed2O)) 函数接受两个参数：（a）一个函数和（b）一个可迭代对象。它返回一个新的序列，该序列是应用函数到输入可迭代对象每个元素的结果。关于`map`的完整讨论在早期的侧边栏“`map`、`filter`和推导式”。
- en: In this exercise, we’re going to create a slight variation on `map`, one that
    applies a function to each of the values of a dict. The result of invoking this
    function, `transform_values`, is a new dict whose keys are the same as the input
    dict, but whose values have been transformed by the function. (The name of the
    function comes from Ruby on Rails, which provides a function of the same name.)
    The function passed to `transform_values` should take a single argument, the dict’s
    value.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将对`map`进行轻微的修改，使其应用于字典的每个值。调用此函数`transform_values`的结果是一个新的字典，其键与输入字典相同，但其值已被函数转换。
    (函数的名称来自Ruby on Rails，它提供了一个同名的函数。)传递给`transform_values`的函数应接受单个参数，即字典的值。
- en: 'When your `transform_values` function works, you should be able to invoke it
    as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的`transform_values`函数正常工作时，你可以按以下方式调用它：
- en: '[PRE39]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The result of this call will be the following dict:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 此调用结果将是以下字典：
- en: '[PRE40]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Working it out
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'The idea of `transform_values` is a simple one: you want to invoke a function
    repeatedly on the values of a dict. This means that you must iterate over the
    dict’s key-value pairs. For each pair, you want to invoke a user-supplied function
    on the value.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`transform_values`的想法很简单：你想要反复在字典的值上调用一个函数。这意味着你必须遍历字典的键值对。对于每一对，你想要在值上调用用户提供的函数。'
- en: We know that functions can be passed as arguments, just like any other data
    types. In this case, we’re getting a function from the user so we can apply it.
    We apply functions with parentheses, so if we want to invoke the function `func`
    that the user passed to us, we simply say `func()`. Or in this case, since the
    function should take a single argument, we say `func(value)`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道函数可以作为参数传递，就像任何其他数据类型一样。在这种情况下，我们正在从用户那里获取一个函数，以便我们可以应用它。我们通过括号应用函数，所以如果我们想调用用户传递给我们的函数`func`，我们只需说`func()`。或者在这种情况下，由于函数应该接受单个参数，我们可以说`func(value)`。
- en: We can iterate over a dict’s key-value pairs with `dict.items` ([http://mng.bz/
    4AeV](http://mng.bz/4AeV)), which returns an iterator that provides, one by one,
    the dict’s key-value pairs. But that doesn’t solve the problem of how to take
    these key-value pairs and turn them back into a dict.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`dict.items`（[http://mng.bz/ 4AeV](http://mng.bz/4AeV)）遍历字典的键值对，它返回一个迭代器，逐个提供字典的键值对。但这并没有解决如何将这些键值对转换回字典的问题。
- en: The easiest, fastest, and most Pythonic way to create a dict based on an existing
    iterable is a dict comprehension. The dict we return from `transform_values` will
    have the same keys as our input dict. But as we iterate over the key-value pairs,
    we invoke `func(value)`, applying the user-supplied function to each value we
    get and using the output from that expression as our value. We don’t even need
    to worry about what type of value the user-supplied function will return, because
    dict values can be of any type.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 基于现有可迭代对象创建字典的最简单、最快且最符合Python风格的方法是使用字典推导式。我们从`transform_values`返回的字典将具有与输入字典相同的键。但是，当我们遍历键值对时，我们会调用`func(value)`，将用户提供的函数应用于我们得到的每个值，并使用该表达式的输出作为我们的值。我们甚至不需要担心用户提供的函数将返回什么类型的值，因为字典的值可以是任何类型。
- en: Solution
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE41]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ❶ Applies the user-supplied function to each value in the dict
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将用户提供的函数应用于字典中的每个值
- en: ❷ Iterates through each key-value pair in the dict
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 遍历字典中的每个键值对
- en: You can work through a version of this code in the Python Tutor at [http://mng.bz/
    jg2z](http://mng.bz/jg2z).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Python Tutor中查看这个代码的版本：[http://mng.bz/ jg2z](http://mng.bz/jg2z)。
- en: Screencast solution
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 观看这个关于解决方案的简短视频：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超越练习
- en: 'Dict comprehensions are a powerful tool in any Python developer’s arsenal.
    They allow us to create new dicts based on existing iterables. However, they can
    take some time to get used to, and to integrate into your development. Here are
    some additional exercises you can try to improve your understanding and use of
    dict comprehensions:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 字典推导式是任何Python开发者工具箱中的强大工具。它们允许我们根据现有可迭代对象创建新的字典。然而，它们可能需要一些时间来适应，并集成到你的开发中。以下是一些你可以尝试的附加练习，以提高你对字典推导式的理解和应用：
- en: Expand the `transform_values` exercise, taking two function arguments, rather
    than just one. The first function argument will work as before, being applied
    to the value and producing output. The second function argument takes two arguments,
    a key and a value, and determines whether there will be any output at all. That
    is, the second function will return `True` or `False` and will allow us to selectively
    create a key-value pair in the output dict.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展`transform_values`练习，接受两个函数参数，而不仅仅是单个参数。第一个函数参数将像以前一样工作，应用于值并产生输出。第二个函数参数接受两个参数，一个键和一个值，并确定是否会有任何输出。也就是说，第二个函数将返回`True`或`False`，并允许我们在输出字典中选择性地创建键值对。
- en: 'Use a dict comprehension to create a dict in which the keys are usernames and
    the values are (integer) user IDs, based on a Unix-style `/etc/passwd` file. Hint:
    in a typical `/etc/passwd` file, the usernames are the first field in a row (i.e.,
    index 0), and the user IDs are the third field in a row (i.e., index 2). If you
    need to download a sample `/etc/passwd` file, you can get it from [http://mng.bz/
    2XXg](http://mng.bz/2XXg). Note that this sample file contains comment lines,
    meaning that you’ll need to remove them when creating your dict.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字典推导式创建一个字典，其中键是用户名，值是基于Unix风格的`/etc/passwd`文件中的（整数）用户ID。提示：在典型的`/etc/passwd`文件中，用户名是每行中的第一个字段（即索引0），用户ID是每行中的第三个字段（即索引2）。如果你需要下载一个示例`/etc/passwd`文件，你可以从这里获取：[http://mng.bz/2XXg](http://mng.bz/2XXg)。请注意，这个示例文件包含注释行，这意味着在创建字典时你需要删除它们。
- en: Write a function that takes a directory name (i.e., a string) as an argument.
    The function should return a dict in which the keys are the names of files in
    that directory, and the values are the file sizes. You can use `os.listdir` or
    `glob .glob` to get the files, but because only regular files have sizes, you’ll
    want to filter the results using methods from `os.path`. To determine the file
    size, you can use `os.stat` or (if you prefer) just check the length of the string
    resulting from reading the file.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个函数，该函数接受一个目录名（即字符串）作为参数。该函数应该返回一个字典，其中键是该目录中文件的名称，值是文件大小。你可以使用`os.listdir`或`glob.glob`来获取文件，但由于只有常规文件才有大小，因此你将想要使用`os.path`中的方法来过滤结果。为了确定文件大小，你可以使用`os.stat`或（如果你愿意）只需检查从读取文件得到的字符串长度。
- en: Exercise 34 ■ (Almost) supervocalic words
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 34 ■ (几乎) 超音素单词
- en: Part of the beauty of Python’s basic data structures is that they can be used
    to solve a wide variety of problems. But it can sometimes be a challenge, especially
    at first, to decide which of the data structures is appropriate, and which of
    their methods will help you to solve problems most easily. Often, it’s a combination
    of techniques that will provide the greatest help.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Python的基本数据结构之美在于它们可以用来解决各种各样的问题。但有时，尤其是在一开始时，决定哪种数据结构是合适的，以及它们的方法将如何帮助你最轻松地解决问题，可能是一个挑战。通常，需要结合多种技术才能提供最大的帮助。
- en: 'In this exercise, I want you to write a `get_sv` function that returns a set
    of all “supervocalic” words in the dict. If you’ve never heard the term *supervocalic*
    before, you’re not alone: I only learned about such words several years ago. Simply
    put, such words contain all five vowels in English (a, e, i, o, and u), each of
    them appearing once and in alphabetical order.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我希望你编写一个`get_sv`函数，该函数返回字典中所有“超音素”单词的集合。如果你之前从未听说过这个术语*超音素*，你并不孤单：我只是在几年前才了解到这样的单词。简单来说，这样的单词包含英语中的所有五个元音（a,
    e, i, o 和 u），每个元音只出现一次，并且按字母顺序排列。
- en: For the purposes of this exercise, I’ll loosen the definition, accepting any
    word that has all five vowels, in any order and any number of times. Your function
    should find all of the words that match this definition (i.e., contain a, e, i,
    o, and u) and return a set containing them.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个练习，我会放宽定义，接受任何包含所有五个元音的单词，无论顺序如何以及出现次数多少。你的函数应该找到所有符合这个定义的单词（即包含a, e,
    i, o 和 u），并返回一个包含它们的集合。
- en: 'Your function should take a single argument: the name of a text file containing
    one word per line, as in a Unix/Linux dict. If you don’t have such a “words” file,
    you can download one from here: [http://mng.bz/D2Rw](http://mng.bz/D2Rw).'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 你的函数应该接受一个单一参数：包含每行一个单词的文本文件名，就像Unix/Linux字典一样。如果你没有这样的“单词”文件，你可以从这里下载一个：[http://mng.bz/D2Rw](http://mng.bz/D2Rw)。
- en: Working it out
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作原理
- en: Before we can create a set of supervocalic words, or read from a file, we need
    to find a way to determine if a word is supervocalic. (Again, this isn’t the precise,
    official definition.) One way would be to use `in` five times, once for each vowel.
    But this seems a bit extreme and inefficient.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够创建一个超音素单词的集合或从文件中读取之前，我们需要找到一种方法来确定一个单词是否是超音素。 (再次强调，这并不是精确的、官方的定义。) 一种方法是在每个元音上使用一次`in`，共使用五次。但这似乎有些极端且效率低下。
- en: What we can instead do is create a set from our word. After all, a string is
    a sequence, and we can always create a set from any sequence with the `set` built
    in.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做到的是从我们的单词中创建一个集合。毕竟，字符串是一个序列，我们可以始终使用内置的`set`从任何序列中创建集合。
- en: Fine, but how does that help us? If we already have a set of vowels, we can
    check to see if they’re all in the word with the `<` operator. Normally, `<` checks
    to see if one data point is less than another. But in the case of sets, it returns
    `True` if the item on the left is a subset of the item on the right.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，但这能帮我们什么忙呢？如果我们已经有一个元音的集合，我们可以使用`<`操作符来检查它们是否都在单词中。通常，`<`检查一个数据点是否小于另一个。但在集合的情况下，如果左边的项目是右边项目的子集，它返回`True`。
- en: 'This means that, given the word “superlogical,” I can do the following:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，给定单词“superlogical”，我可以做以下操作：
- en: '[PRE42]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is good for one word. But how can we do it for many words in a file? The
    answer could be a list comprehension. After all, we can think of our file as an
    iterator, one that returns strings. If the `words` file contains one word per
    line, then iterating over the lines of the file really means iterating over the
    different lines. If a set of the vowels is a set based on the current word, then
    we’ll consider it to be supervocalic and will include the current word in the
    output list.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这对单个单词来说很好。但对于文件中的多个单词，我们该如何处理呢？答案可能是一个列表推导。毕竟，我们可以把我们的文件看作是一个迭代器，它返回字符串。如果`words`文件每行包含一个单词，那么遍历文件的行实际上就是遍历不同的行。如果一组元音是基于当前单词的集合，那么我们将它视为超元音，并将当前单词包含在输出列表中。
- en: But we don’t want a list, we want a set! Fortunately, the difference between
    creating a list comprehension and a set comprehension is a pair of brackets. We
    use square brackets (`[]`) for a list comprehension and curly braces (`{}`) for
    a set comprehension. A comprehension with curly braces and a colon is a dict comprehension;
    without the colon, it’s a set comprehension.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们不想有一个列表，我们想要一个集合！幸运的是，创建列表推导和集合推导之间的区别是一对括号。我们使用方括号`[]`来表示列表推导，使用花括号`{}`来表示集合推导。带有冒号的括号内是一个字典推导；没有冒号的是集合推导。
- en: To summarize
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说
- en: We iterate over the lines of the file.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们遍历文件的行。
- en: We turn each word into a set and check that the vowels are a subset of our word’s
    letters.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将每个单词转换成一个集合，并检查元音是否是单词字母的子集。
- en: If the word passes this test, we include it (the word) in the output.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果单词通过了这个测试，我们就将其（单词）包含在输出中。
- en: The output is all put into a set, thanks to a set comprehension.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出全部放入了一个集合中，这是由于集合推导的功劳。
- en: Using sets as the basis for textual comparisons might not seem obvious, at least
    at first. But it’s good to learn to think in these ways, taking advantage of Python’s
    data structures in ways you never considered before.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 使用集合作为文本比较的基础可能一开始看起来不明显。但学习以这种方式思考，利用Python的数据结构以你从未考虑过的方式，是很有好处的。
- en: Solution
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE43]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ❶ Creates a set of the vowels
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个元音的集合
- en: ❷ Returns the word, without any whitespace on either side
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回单词，两侧没有任何空白
- en: ❸ Iterates through each line in “filename”
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 遍历“filename”中的每一行
- en: ❹ Does this word contain all of the vowels?
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 这个单词是否包含所有的元音？
- en: You can work through a version of this code in the Python Tutor at [http://mng.bz/
    lG18](http://mng.bz/lG18). Note that because the Python Tutor doesn’t support
    working with external files, I used an instance of `StringIO` to simulate a file.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Python Tutor中通过[http://mng.bz/lG18](http://mng.bz/lG18)版本的工作。请注意，因为Python
    Tutor不支持与外部文件一起工作，所以我使用了一个`StringIO`实例来模拟文件。
- en: Screencast solution
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 观看这个关于解决方案的简短视频：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 除此之外
- en: 'Set comprehensions are great in a variety of circumstances, including when
    you have inputs and you want to crunch them down to only have the distinct (unique)
    elements. Here are some additional ways for you to use and practice your set-comprehension
    chops:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 集合推导在多种情况下都很出色，包括当你有输入并且你想将它们压缩成只有唯一（不同）元素时。以下是一些你可以用来练习和提升你的集合推导技巧的额外方法：
- en: In the `/etc/passwd` file you used earlier, what different shells (i.e., command
    interpreters, named in the final field on each line) are assigned to users? Use
    a set comprehension to gather them.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你之前使用的`/etc/passwd`文件中，分配给用户的有哪些不同的shell（即命令解释器，在每一行的最后字段中命名）？使用集合推导来收集它们。
- en: Given a text file, what are the lengths of the different words? Return a set
    of different word lengths in the file.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个文本文件，不同单词的长度是多少？返回文件中不同单词长度的集合。
- en: Create a list whose elements are strings--the names of people in your family.
    Now use a set comprehension (and, better yet, a nested set comprehension) to find
    which letters are used in your family members’ names.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包含字符串元素的列表——你家庭成员的名字。现在使用集合推导（而且，更好的是，嵌套集合推导）来找出你家庭成员名字中使用了哪些字母。
- en: Exercise 35a ■ Gematria, part 1
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习35a ■ 数字密码，第一部分
- en: In this exercise, we’re going to again try something that sits at the intersection
    of strings and comprehensions. This time, it’s dict comprehensions.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将再次尝试位于字符串和推导之间的交集。这次是字典推导。
- en: When you were little, you might have created or used a “secret” code in which
    `a` was 1, `b` was 2, `c` was 3, and so forth, until z (which was 26). This type
    of code happens to be quite ancient and was used by a number of different groups
    more than 2,000 years ago. “Gematria,” ([http://mng.bz/B2R8](http://mng.bz/B2R8))
    as it is known in Hebrew, is the way in which biblical verses have long been numbered.
    And of course, it’s not even worth describing it as a secret code, despite what
    you might have thought while little.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当你很小的时候，你可能创建或使用了一种“秘密”代码，其中`a`代表1，`b`代表2，`c`代表3，以此类推，直到`z`（代表26）。这种代码恰好非常古老，并且早在2000多年前就被多个不同的群体所使用。“数字密码”，在希伯来语中被称为“Gematria”，是圣经经文长期以来被编号的方式。当然，尽管你可能小时候这么想过，但这甚至都不值得描述为一个秘密代码。
- en: This exercise, the result of which you’ll use in the next one, asks that you
    create a dict whose keys are the (lowercase) letters of the English alphabet,
    and whose values are the numbers ranging from 1 to 26\. And yes, you could simply
    type `{'a':1,` `'b':2,` `'c':3}` and so forth, but I’d like you to do this with
    a dict comprehension.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习要求你创建一个字典，其键是（小写）英语字母，值是1到26的数字。当然，你可以简单地输入`{'a':1,` `'b':2,` `'c':3}`等等，但我希望你能用字典推导来完成这个任务。
- en: Working it out
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: The solution uses a number of different aspects of Python, combining them to
    create a dict with a minimum of code.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案使用了Python的多个不同方面，将它们结合起来，用最少的代码创建了一个字典。
- en: First, we want to create a dict, and thus turn to a dict comprehension. Our
    keys are going to be the lowercase letters of the English alphabet, and the values
    are going to be the numbers from 1 to 26.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们想要创建一个字典，因此转向字典推导。我们的键将是英语字母表的小写字母，值将是1到26的数字。
- en: We could create the string of lowercase letters. But, rather than doing that
    ourselves, we can rely on the `string` module, and its `string.ascii_lowercase`
    attribute, which comes in handy in such situations.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建小写字母的字符串。但，而不是自己这样做，我们可以依赖`string`模块及其`string.ascii_lowercase`属性，这在这种情况下非常有用。
- en: 'But how can we number the letters? We can use the `enumerate` built-in iterator,
    which will number our characters one at a time. We can then catch the iterated
    tuples via unpacking, grabbing the index and character separately:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们如何给字母编号呢？我们可以使用内置迭代器`enumerate`，它会逐个编号我们的字符。然后我们可以通过解包来捕获迭代的元组，分别获取索引和字符：
- en: '[PRE44]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The only problem with doing this is that `enumerate` starts counting at 0,
    and we want to start counting at 1\. We could, of course, just add 1 to the value
    of `index`. However, we can do even better than that by asking `enumerate` to
    start counting at 1, and we do so by passing 1 to it as the second argument:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的问题是`enumerate`从0开始计数，而我们想要从1开始计数。当然，我们可以简单地将1加到`index`的值上。然而，我们可以做得更好，通过将1传递给`enumerate`作为第二个参数来让它从1开始计数：
- en: '[PRE45]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: And, sure enough, this produces the dict that we want. We’ll use it in the next
    exercise.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，确实如此，这产生了我们想要的字典。我们将在下一个练习中使用它。
- en: Solution
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE46]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ❶ Returns the key-value pair, with the character and an integer
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 返回键值对，字符和整数
- en: ❷ Iterates over lowercase letters with enumerate
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用enumerate遍历小写字母
- en: You can work through a version of this code in the Python Tutor at [http://mng.bz/
    WPx4](http://mng.bz/WPx4).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Python Tutor中运行这个代码的版本，网址为[http://mng.bz/ WPx4](http://mng.bz/WPx4)。
- en: Screencast solution
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 观看这个解决方案的简短视频：[https://livebook.manning.com/ video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习之外
- en: 'Dicts are also known as key-value pairs, for the simple reason that they contain
    keys and values--and because associations between two different types of data
    are extremely common in programming contexts. Often, if you can get your data
    into a dict, it becomes easier to work with and manipulate. For that reason, it’s
    important to know how to get information into a dict from a variety of different
    formats and sources. Here are some additional exercises to practice doing so:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 字典也被称为键值对，原因很简单，因为它们包含键和值——并且因为两种不同类型数据之间的关联在编程环境中极为常见。通常，如果你能将数据放入字典，它就会更容易处理和操作。因此，了解如何从各种不同的格式和来源将信息放入字典非常重要。以下是一些额外的练习，以练习这样做：
- en: Many programs’ functionality is modified via configuration files, which are
    often set using name-value pairs. That is, each line of the file contains text
    in the form of `name=value`, where the `=` sign separates the name from the value.
    I’ve prepared one such sample config file at [http://mng.bz/rryD](http://mng.bz/rryD).
    Download this file, and then use a dict comprehension to read its contents from
    disk, turning it into a dict describing a user’s preferences. Note that all of
    the values will be strings.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多程序的功能是通过配置文件修改的，这些配置文件通常使用名称-值对设置。也就是说，文件的每一行都包含形式为`name=value`的文本，其中`=`符号将名称与值分开。我已经准备了一个这样的样本配置文件在[http://mng.bz/rryD](http://mng.bz/rryD)。下载此文件，然后使用字典推导式从磁盘读取其内容，将其转换为描述用户偏好的字典。请注意，所有值都将为字符串。
- en: Create a dict based on the config file, as in the previous exercise, but this
    time, all of the values should be integers. This means that you’ll need to filter
    out (and ignore) those values that can’t be turned into integers.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据配置文件创建一个字典，就像之前的练习一样，但这次，所有的值都应该是整数。这意味着你需要过滤掉（并忽略）那些无法转换为整数的值。
- en: It’s sometimes useful to transform data from one format into another. Download
    a JSON-formatted list of the 1,000 largest cities in the United States from [http://mng.bz/Vgd0](http://mng.bz/Vgd0).
    Using a dict comprehension, turn it into a dict in which the keys are the city
    names, and the values are the populations of those cities. Why are there only
    925 key-value pairs in this dict? Now create a new dict, but set each key to be
    a tuple containing the state and city. Does that ensure there will be 1,000 key-value
    pairs?
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时将数据从一种格式转换为另一种格式是有用的。从[http://mng.bz/Vgd0](http://mng.bz/Vgd0)下载一个包含美国1,000个最大城市的JSON格式列表。使用字典推导式，将其转换为字典，其中键是城市名称，值是这些城市的人口。为什么这个字典中只有925个键值对？现在创建一个新的字典，但将每个键设置为包含州和城市的元组。这能确保有1,000个键值对吗？
- en: Exercise 35b ■ Gematria, part 2
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习35b ■ 基玛利亚，第二部分
- en: In the previous exercise, you created a dict that allows you to get the numeric
    value from any lowercase letter. As you can imagine, we can use this dict not
    only to find the numeric value for a single letter, but to sum the values from
    the letters in a word, thus getting the word’s “value.” One of the games that
    Jewish mystics enjoy playing (although they would probably be horrified to hear
    me describe it as a game) is to find words with the same gematria value. If two
    words have the same gematria value, then they’re linked in some way.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的练习中，你创建了一个字典，允许你从任何小写字母中获取数值。正如你可以想象的那样，我们可以使用这个字典不仅找到单个字母的数值，还可以从单词中的字母求和，从而得到单词的“值”。犹太神秘主义者喜欢玩的一种游戏（尽管他们可能不愿意听到我把它描述为游戏）是找到具有相同基玛利亚值的单词。如果两个单词具有相同的基玛利亚值，那么它们以某种方式相互关联。
- en: 'In this exercise, you’ll write two functions:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你需要编写两个函数：
- en: '`gematria_for`, which takes a single word (string) as an argument and returns
    the gematria score for that word'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gematria_for`，它接受一个单词（字符串）作为参数，并返回该单词的基玛利亚分数'
- en: '`gematria_equal_words`, which takes a single word and returns a list of those
    dict words whose gematria scores match the current word’s score.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gematria_equal_words`，它接受一个单词并返回那些字典单词的列表，其基玛利亚分数与当前单词的分数相匹配。'
- en: For example, if the function is called with the word `cat`, with a gematria
    value of 24 (3 + 1 + 20), then the function will return a list of strings, all
    of whose gematria values are also 24\. (This will be a long list!) Any nonlowercase
    characters in the user’s input should count 0 toward our final score for the word.
    Your source for the dict words will be the Unix file you used earlier in this
    chapter, which you can load into a list comprehension.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果函数被调用，单词为`cat`，基数字符得分为24（3 + 1 + 20），那么该函数将返回一个字符串列表，其中所有字符串的基数字符得分也都是24。（这将是一个很长的列表！）用户输入中的任何非小写字符都应计入单词的最终得分为0。你的字典单词来源将是本章前面使用的Unix文件，你可以将其加载到列表推导式中。
- en: Working it out
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决思路
- en: This solution combines a large number of techniques that we’ve discussed so
    far in this book, and that you’re likely to use in your Python programming work.
    (However, I do hope that you’re not doing too many gematria calculations.)
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案结合了我们在这本书中讨论过的许多技术，你很可能会在你的Python编程工作中使用这些技术。（然而，我确实希望你不要做太多的基数字符计算。）
- en: First, how do we calculate the gematria score for a word, given our `gematria`
    dict? We want to iterate through each letter in a word, grabbing the score from
    the dict. And if the letter isn’t in the dict, we’ll give it a value of 0.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们如何根据我们的`gematria`字典计算单词的基数字符得分？我们想要遍历单词中的每个字母，从字典中获取得分。如果字母不在字典中，我们将给它一个值为0。
- en: 'The standard way to do this would be with a `for` loop, using `dict.get`:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的标准方式是使用`for`循环，并使用`dict.get`：
- en: '[PRE47]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And there’s nothing wrong with this, per se. But comprehensions are usually
    your best bet when you’re starting with one iterable and trying to produce another
    iterable. And in this case, we can iterate over the letters in our word in a list
    comprehension, invoking `sum` on the list of integers that will result:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，这并没有什么问题。但是，当你从一个可迭代对象开始，试图生成另一个可迭代对象时，通常最佳选择是使用列表推导式。在这种情况下，我们可以通过列表推导式遍历单词中的字母，对整数列表调用`sum`函数：
- en: '[PRE48]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Once we can calculate the gematria for one word, we need to find all of the
    dict words that are equivalent to it. We can do that, once again, with a list
    comprehension--this time, using the `if` clause to filter out those words whose
    gematria isn’t equal:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们可以计算一个单词的基数字符得分，我们就需要找到所有与其等价的字典单词。我们可以再次使用列表推导式来完成这个任务，这次使用`if`子句来过滤掉那些基数字符得分不等的单词：
- en: '[PRE49]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As you can see, we’re forcing the words to be in lowercase. But we’re not modifying
    or otherwise transforming the word on the first line of our comprehension. Rather,
    we’re just filtering.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在强制将单词转换为小写。但我们不会修改或以其他方式转换我们理解的第一行的单词。相反，我们只是在过滤。
- en: Meanwhile, we’re iterating over each of the words in the dict file. Each word
    in that file ends with a newline, which doesn’t affect our gematria score but
    isn’t something we want to return to the user in our list comprehension.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们正在遍历字典文件中的每个单词。该文件中的每个单词都以换行符结尾，这不会影响我们的基数字符得分，但我们不希望在列表推导式中将其返回给用户。
- en: Finally, this exercise demonstrates that when you’re using a comprehension,
    and your output expression is a complex one, it’s often a good idea to create
    a separate function that you can repeatedly call.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个练习表明，当你使用列表推导式，并且你的输出表达式很复杂时，通常创建一个可以重复调用的单独函数是个好主意。
- en: Solution
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE50]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: ❶ Gets the value for the current character, or 0 if the character isn’t in the
    “GEMATRIA” dict
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取当前字符的值，如果字符不在“GEMATRIA”字典中则为0
- en: ❷ Iterates over the characters in “word”
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 遍历“word”中的字符
- en: ❸ Gets the total score for the input word
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 获取输入单词的总得分
- en: ❹ Removes leading and trailing whitespace from “one_word”
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 从“one_word”中删除前导和尾随空格
- en: ❺ Iterates over each word in the English-language dict
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 遍历英语字典中的每个单词
- en: ❻ Only adds the current word to our returned list if its gematria score matches
    ours
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 只有当当前单词的基数字符得分与我们的得分匹配时，才将其添加到我们的返回列表中
- en: 'Note: there is no Python Tutor link for this exercise, because it uses an external
    file.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：此练习没有Python Tutor链接，因为它使用外部文件。
- en: Screencast solution
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 观看此解决方案的简短视频：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超出练习范围
- en: 'Once you have data in a dict, you can often use a comprehension to transform
    it in various ways. Here are some additional exercises you can use to sharpen
    your skills with dicts and dict comprehensions:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有一个字典中的数据，你通常可以使用推导式以各种方式对其进行转换。以下是一些你可以用来提高你对字典和字典推导式技能的额外练习：
- en: Create a dict whose keys are city names, and whose values are temperatures in
    Fahrenheit. Now use a dict comprehension to transform this dict into a new one,
    keeping the old keys but turning the values into the temperature in degrees Celsius.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个字典，其键是城市名称，其值是华氏温度。现在使用字典推导式将此字典转换成一个新的字典，保留旧键，但将值转换为摄氏度温度。
- en: 'Create a list of tuples in which each tuple contains three elements: (1) the
    author’s first and last names, (2) the book’s title, and (3) the book’s price
    in U.S. dollars. Use a dict comprehension to turn this into a dict whose keys
    are the book’s titles, with the values being another (sub -) dict, with keys for
    (a) the author’s first name, (b) the author’s last name, and (c) the book’s price
    in U.S. dollars.'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包含元组的列表，其中每个元组包含三个元素：（1）作者的姓名，（2）书籍的标题，以及（3）书籍的美元价格。使用字典推导式将此转换为字典，其中键是书籍的标题，值是另一个（子）字典，其中键为（a）作者的名字，（b）作者的姓氏，以及（c）书籍的美元价格。
- en: Create a dict whose keys are currency names and whose values are the price of
    that currency in U.S. dollars. Write a function that asks the user what currency
    they use, then returns the dict from the previous exercise as before, but with
    its prices converted into the requested currency.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个字典，其键是货币名称，其值是该货币在美元中的价格。编写一个函数，询问用户他们使用哪种货币，然后返回上一个练习中的字典，但将其价格转换为请求的货币。
- en: Summary
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Comprehensions are, without a doubt, one of the most difficult topics for people
    to learn when they start using Python. The syntax is a bit weird, and it’s not
    even obvious where and when to use comprehensions. In this chapter, you saw many
    examples of how and when to use comprehensions, which will hopefully help you
    not only to use them, but also to see opportunities to do so.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 没有疑问，当人们开始使用 Python 时，理解列表推导式无疑是他们遇到的最困难的主题之一。其语法有点奇怪，甚至不明显在哪里以及何时使用推导式。在本章中，你看到了许多关于如何以及何时使用推导式的例子，这希望能帮助你不仅学会使用它们，还能看到使用它们的机会。
