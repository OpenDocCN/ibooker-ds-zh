- en: Appendix C. Introduction to NumPy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录C. NumPy简介
- en: 'We don’t expect any NumPy knowledge from the readers and try to put all the
    required information in the chapters as we go along. However, because the purpose
    of the book is to teach machine learning rather than NumPy, we couldn’t cover
    everything in great detail in the chapters. That’s the focus of this appendix:
    to give an overview of the most important concepts from NumPy in one centralized
    place.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不期望读者有任何NumPy知识，并试图在前进的过程中将所有必要的信息放入章节中。然而，因为本书的目的是教授机器学习而不是NumPy，所以我们无法在章节中详细涵盖所有内容。这就是附录的重点：在一个集中的地方概述NumPy最重要的概念。
- en: In addition to introducing NumPy, the appendix also covers a bit of linear algebra
    useful for machine learning, including matrix and vector multiplication, matrix
    inverse, and the normal equation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 除了介绍NumPy外，附录还涵盖了一些对机器学习有用的线性代数知识，包括矩阵和向量乘法、矩阵逆和正则方程。
- en: NumPy is a Python library, so if you’re not yet familiar with Python, check
    out appendix B.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy是一个Python库，所以如果你还不熟悉Python，请查看附录B。
- en: C.1 NumPy
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.1 NumPy
- en: 'NumPy is short for *Numerical Python*—it’s a Python library for numerical manipulations.
    NumPy plays a central role in the Python machine learning ecosystem: nearly all
    the libraries in Python depend on it. For example, Pandas, Scikit-learn, and TensorFlow
    all rely on NumPy for numerical operations.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy代表*数值Python*——它是一个用于数值操作的Python库。NumPy在Python机器学习生态系统中扮演着核心角色：Python中的几乎所有库都依赖于它。例如，Pandas、Scikit-learn和TensorFlow都依赖于NumPy进行数值运算。
- en: 'NumPy comes preinstalled in the Anaconda distribution of NumPy, so if you use
    it, you don’t need to do anything extra. But if you don’t use Anaconda, installing
    NumPy is quite simple with `pip`:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy在Anaconda的NumPy发行版中预先安装，所以如果你使用它，你不需要做任何额外的事情。但是如果你不使用Anaconda，使用`pip`安装NumPy相当简单：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To experiment with NumPy, let’s create a new Jupyter Notebook and name it appendix-c-numpy.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要实验NumPy，让我们创建一个新的Jupyter Notebook，并将其命名为appendix-c-numpy。
- en: To use NumPy, we need to import it. That’s why in the first cell we write
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用NumPy，我们需要导入它。这就是为什么在第一个单元中我们写下
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the scientific Python community, it’s common to use an alias when importing
    NumPy. That’s why we add `as` `np` in the installation code. This allows us to
    write `np` in the code instead of `numpy`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在科学Python社区中，导入NumPy时使用别名是很常见的。这就是为什么我们在安装代码中添加了`as np`。这允许我们在代码中使用`np`而不是`numpy`。
- en: 'We’ll start exploring NumPy from its core data structure: the NumPy array.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从NumPy的核心数据结构：NumPy数组开始探索。
- en: C.1.1 NumPy arrays
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.1.1 NumPy数组
- en: NumPy arrays are similar to Python lists, but they are better optimized for
    number-crunching tasks like machine learning.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy数组类似于Python列表，但它们在机器学习等数值计算任务上进行了更好的优化。
- en: 'To create an array of a predefined size filled with zeros, we use the `np.zeros`
    function:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个预定义大小且填充零的数组，我们使用`np.zeros`函数：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This creates an array with 10 zero elements (figure C.1).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个包含10个零元素的数组（图C.1）。
- en: '![](../Images/C-01.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/C-01.png)'
- en: Figure C.1 Creating a NumPy array of length 10 filled with zeros
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.1 创建一个长度为10且填充零的NumPy数组
- en: 'Likewise, we can create an array with ones using the `np.ones` function:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用`np.ones`函数创建一个包含1的数组：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It works exactly the same as zeros, except the elements are ones.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作方式与zeros完全相同，只是元素是1。
- en: 'Both functions are a shortcut for a more general function: `np.full`. It creates
    an array of a certain size filled with the specified element. For example, to
    create an array of size 10 filled with zeros, we do the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都是更通用函数的快捷方式：`np.full`。它创建一个特定大小的数组，并用指定的元素填充。例如，要创建一个大小为10且填充零的数组，我们执行以下操作：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can achieve the same result using the `np.repeat` function:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`np.repeat`函数达到相同的结果：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code produces the same result as the earlier code (figure C.2).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码产生的结果与早期代码（图C.2）相同。
- en: '![](../Images/C-02.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/C-02.png)'
- en: Figure C.2 To create an array filled with a particular number, use `np.full`
    or `np.repeat`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.2 要创建一个填充特定数字的数组，请使用`np.full`或`np.repeat`。
- en: 'Although in this example both functions produce the same code, `np.repeat`
    is actually more powerful. For example, we can use it to create an array where
    multiple elements are repeated one after another:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这个例子中两个函数都产生了相同的代码，但`np.repeat`实际上更强大。例如，我们可以使用它创建一个多个元素依次重复的数组：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It creates an array of size 10 where the number 0 is repeated five times, and
    then the number 1 is repeated five times (figure C.3):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 它创建了一个大小为10的数组，其中数字0重复了五次，然后数字1重复了五次（图C.3）：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](../Images/C-03.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/C-03.png)'
- en: 'Figure C.3 The `np.repeat` function is more flexible than `np.full`: it can
    create arrays by repeating multiple elements.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.3 `np.repeat`函数比`np.full`更灵活：它可以通过重复多个元素来创建数组。
- en: 'We can be even more flexible and specify how many times each element should
    be repeated:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以更加灵活，并指定每个元素应该重复多少次：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this case, 0.0 is repeated two times and 1.0 is repeated three times:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，0.0重复两次，1.0重复三次：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Like with lists, we can access an element of an array with square brackets:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 就像列表一样，我们可以使用方括号访问数组的元素：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code prints 0.0.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码打印0.0。
- en: 'Unlike the usual Python lists, we can access multiple elements of the array
    at the same time by using a list with indices in the square brackets:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与通常的Python列表不同，我们可以通过使用方括号中的索引列表同时访问数组的多个元素：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The result is another array of size 3 consisting of elements of the original
    array indexed by 4, 2, and 0, respectively:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是另一个大小为3的数组，包含原始数组中通过4、2和0分别索引的元素：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can also update the elements of the array using square brackets:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用方括号更新数组的元素：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Because we changed the element at index 1 from 0 to 1, it prints the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将索引1处的元素从0改为1，所以它打印以下内容：
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we already have a list with numbers, we can convert it to a NumPy array
    using `np.array`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已经有了一个包含数字的列表，我们可以使用`np.array`将其转换为NumPy数组：
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now `array` is a NumPy array of size 4 with the same elements as the original
    list:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`array`是一个大小为4的NumPy数组，其元素与原始列表相同：
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Another useful function for creating NumPy arrays is `np.arange`. It’s the
    NumPy equivalent of Python’s `range`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用于创建NumPy数组的非常有用的函数是`np.arange`。它是Python的`range`的NumPy等价物：
- en: '[PRE17]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It creates an array of length 10 with numbers from 0 to 9, and like in standard
    Python’s `range`, 10 is not included in the array:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 它创建了一个长度为10的数组，包含从0到9的数字，并且像标准Python的`range`一样，10不包括在数组中：
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Often we need to create an array of a certain size filled with numbers between
    some number *x* and some number *y*. For example, imagine that we need to create
    an array with numbers from 0 to 1:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 经常我们需要创建一个大小一定的数组，并用介于某个数字*x*和某个数字*y*之间的数字填充。例如，想象我们需要创建一个包含从0到1的数字的数组：
- en: 0.0, 0.1, 0.2, ..., 0.9, 1.0
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 0.0, 0.1, 0.2, ..., 0.9, 1.0
- en: 'We can use `np.linspace`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`np.linspace`：
- en: '[PRE19]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This function takes three parameters:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数有三个参数：
- en: 'The starting number: in our case, we want to start from 0.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 起始数字：在我们的例子中，我们希望从0开始。
- en: 'The last number: we want to finish with 1.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个数字：我们希望以1结束。
- en: 'The length of the resulting array: in our case, we want 11 numbers in the array.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果数组的长度：在我们的例子中，我们希望在数组中有11个数字。
- en: This code produces 11 numbers from 0 until 1 (figure C.4).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码生成从0到1（图C.4）的11个数字。
- en: '![](../Images/C-04.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/C-04.png)'
- en: Figure C.4 The function `linspace` from NumPy produces a sequence of specified
    length (11) that starts at 0 and ends at 1.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.4 NumPy的`linspace`函数生成一个指定长度的序列（11），从0开始，到1结束。
- en: 'Python lists can usually contain elements of any type. This is not the case
    for NumPy arrays: all elements of an array must have the same type. These types
    are called *dtypes*.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Python列表通常可以包含任何类型的元素。对于NumPy数组来说情况并非如此：数组中的所有元素必须具有相同的类型。这些类型被称为*dtype*。
- en: 'There are four broad categories of dtypes:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种广泛的dtype类别：
- en: 'Unsigned integers (uint): integers that are always positive (or zero)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无符号整数（uint）：始终为正数（或零）的整数
- en: 'Signed integers (int): integers that can be positive and negative'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有符号整数（int）：可以是正数和负数的整数
- en: 'Floats (float): real numbers'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点数（float）：实数
- en: 'Booleans (bool): only True and False values'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值（bool）：只有True和False值
- en: Multiple variations of each dtype exist, depending on the number of bits used
    for representing the value in memory.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 每种dtype都有多种变体，这取决于在内存中表示值所使用的位数。
- en: 'For uint we have four types: `uint8`, `uint16`, `uint32`, and `uint64` of size
    8, 16, 32, and 64 bits, respectively. Likewise, we have four types of int: `int8`,
    `int16`, `int32`, and `int64`. The more bits we use, the larger numbers we can
    store (table C.1).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于uint，我们有四种类型：`uint8`、`uint16`、`uint32`和`uint64`，分别具有8、16、32和64位大小。同样，我们有四种int类型：`int8`、`int16`、`int32`和`int64`。我们使用的位数越多，可以存储的数字就越大（表C.1）。
- en: 'Table C.1 Three common NumPy dtypes: uint, int, and float. Each dtype has multiple
    size https://variations ranging from 8 to 64 bits.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 表C.1 三种常见的NumPy dtype：uint、int和float。每种dtype都有多种大小从8到64位的变体。[链接](https://variations)
- en: '| Size (bits) | **uint** | **int** | **float** |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 大小（位） | **无符号整型** | **整型** | **浮点型** |'
- en: '| **8** | 0 .. 2⁸ – 1 | –2⁷ .. 2⁷ – 1 | – |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| **8** | 0 .. 2⁸ – 1 | –2⁷ .. 2⁷ – 1 | – |'
- en: '| **16** | 0 .. 2^(16) – 1 | –2^(15) .. 2^(15) – 1 | Half precision |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| **16** | 0 .. 2^(16) – 1 | –2^(15) .. 2^(15) – 1 | 半精度 |'
- en: '| **32** | 0 .. 2^(32) – 1 | –2^(31) .. 2^(31) – 1 | Single precision |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| **32** | 0 .. 2^(32) – 1 | –2^(31) .. 2^(31) – 1 | 单精度 |'
- en: '| **64** | 0 .. 2^(64) – 1 | –2^(63) .. 2^(63) – 1 | Double precision |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| **64** | 0 .. 2^(64) – 1 | –2^(63) .. 2^(63) – 1 | 双精度 |'
- en: 'In the case of floats, we have three types: `float16`, `float32`, and `float64`.
    The more bits we use, the more precise the float is.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于浮点数，我们有三种类型：`float16`、`float32`和`float64`。我们使用的位数越多，浮点数就越精确。
- en: You can check the full list of different dtypes in the official documentation
    ([https://docs.scipy.org/doc/numpy-1.13.0/user/basics.types.html](https://docs.scipy.org/doc/numpy-1.13.0/user/basics.types.html)).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在官方文档中查看不同数据类型的完整列表（[https://docs.scipy.org/doc/numpy-1.13.0/user/basics.types.html](https://docs.scipy.org/doc/numpy-1.13.0/user/basics.types.html)）。
- en: Note In NumPy, the default float dtype is `float64`, which uses 64 bits (8 bytes)
    for each number. For most machine learning applications, we don’t need such precision
    and can reduce the memory footprint two times by using `float32` instead of `float64`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 在NumPy中，默认的浮点数据类型是`float64`，每个数字使用64位（8字节）。对于大多数机器学习应用，我们不需要这样的精度，可以通过使用`float32`而不是`float64`来减少内存占用两倍。
- en: 'When creating an array, we can specify the dtype. For example, when using `np.zeros`
    and `np.ones`, the default dtype is `float64`. We can specify the dtype when creating
    an array (figure C.5):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建数组时，我们可以指定数据类型。例如，当使用`np.zeros`和`np.ones`时，默认数据类型是`float64`。我们可以在创建数组时指定数据类型（图C.5）：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![](../Images/C-05.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/C-05.png)'
- en: Figure C.5 We can specify the dtype when creating an array.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.5 我们可以在创建数组时指定数据类型。
- en: 'When we have an array with integers and assign a number outside of the range,
    the number is cut: only the least significant bits are kept.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个整数数组并赋值一个超出范围的数字时，数字会被截断：只保留最低有效位。
- en: 'For example, suppose we use the `uint8` array `zeros` we just created. Because
    the dtype is `uint8`, the largest number it can store is 255\. Let’s try to assign
    300 to the first element of the array:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们使用我们刚刚创建的`uint8`数组`zeros`。因为数据类型是`uint8`，它能够存储的最大数字是255。让我们尝试将300赋值给数组的第一个元素：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Because 300 is greater than 255, only the least significant bits are kept, so
    this code prints 44.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因为300大于255，所以只保留最低有效位，所以这段代码打印出44。
- en: Warning Be careful when choosing the dtype for an array. If you accidentally
    choose a dtype that’s too narrow, NumPy won’t warn you when you put in a big number.
    It will simply truncate them.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 在选择数组的数据类型时要小心。如果你不小心选择了一个过窄的数据类型，当你输入一个大的数字时，NumPy不会警告你。它将简单地截断它们。
- en: 'Iterating over all elements of an array is similar to list. We simply can use
    a `for` loop:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历数组中的所有元素与列表类似。我们只需使用一个`for`循环：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This code prints numbers from 0 to 4:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码打印从0到4的数字：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: C.1.2 Two-dimensional NumPy arrays
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.1.2 二维NumPy数组
- en: 'So far we have covered one-dimensional NumPy arrays. We can think of these
    arrays as vectors. However, for machine learning applications, having only vectors
    is not enough: we also often need matrices.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了NumPy的一维数组。我们可以将这些数组视为向量。然而，对于机器学习应用，仅仅有向量是不够的：我们还需要矩阵。
- en: In plain Python, we’d use a list of lists for that. In NumPy, the equivalent
    is a two-dimensional array.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯Python中，我们会使用列表的列表来表示。在NumPy中，等价的是二维数组。
- en: 'To create a two-dimensional array with zeros, we simply use a tuple instead
    of a number when invoking `np.zeros`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个全为零的二维数组，我们只需在调用`np.zeros`时使用一个元组而不是一个数字：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We use a tuple (5, 2), so it creates an array of zeros with five rows and two
    columns (figure C.6).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用元组（5, 2），因此它创建了一个有五行两列的全零数组（图C.6）。
- en: '![](../Images/C-06.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/C-06.png)'
- en: Figure C.6 To create a two-dimensional array, use a tuple with two elements.
    The first element specifies the number of rows, and the second, the number of
    columns.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.6 要创建一个二维数组，使用包含两个元素的元组。第一个元素指定行数，第二个元素指定列数。
- en: In the same way, we can use `np.ones` or `np.fill`—instead of a single number,
    we put in a tuple.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我们可以使用`np.ones`或`np.fill`——而不是一个单独的数字，我们放入一个元组。
- en: 'The dimensionality of an array is called *shape*. This is the first parameter
    we pass to the `np.zeros` function: it specifies how many rows and columns the
    array will have. To get the shape of an array, use the `shape` property:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的维度称为 *形状*。这是传递给 `np.zeros` 函数的第一个参数：它指定数组将有多少行和列。要获取数组的形状，使用 `shape` 属性：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When we execute it, we see (5, 2).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行它时，我们看到 (5, 2)。
- en: 'It’s possible to convert a list of lists to a NumPy array. As with usual lists
    of numbers, simply use `np.array` for that:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将列表的列表转换为 NumPy 数组。与通常的数字列表一样，只需使用 `np.array` 即可：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Creates a list of lists
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个列表的列表
- en: ❷ Converts the list to a two-dimensional array
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将列表转换为二维数组
- en: After executing this code, `numbers` becomes a NumPy array with shape (3, 3).
    When we print it, we get
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码后，`numbers` 变成了一个形状为 (3, 3) 的 NumPy 数组。当我们打印它时，我们得到
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To access an element of a two-dimensional array, we need to use two numbers
    inside the brackets:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问二维数组的一个元素，我们需要在括号内使用两个数字：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This code will access the row indexed by 0 and column indexed by 1\. So it will
    print 2.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将访问索引为 0 的行和索引为 1 的列。所以它将打印 2。
- en: 'As with one-dimensional arrays, we use the assignment operator (=) to change
    an individual value of a two-dimensional array:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 与一维数组一样，我们使用赋值运算符 (=) 来改变二维数组的一个单独的值：
- en: '[PRE29]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When we execute it, the content of the array changes:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行它时，数组的内容会改变：
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If instead of two numbers we put only one, we get the entire row, which is
    a one-dimensional NumPy array:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只放一个数字而不是两个，我们将得到整个行，这是一个一维的 NumPy 数组：
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This code returns the entire row indexed by 0:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码返回索引为 0 的整个行：
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To access a column of a two-dimensional array, we use a colon (:) instead of
    the first element. Like with rows, the result is also a one-dimensional NumPy
    array:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问二维数组的一列，我们使用冒号 (:) 而不是第一个元素。像行一样，结果也是一个一维的 NumPy 数组：
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When we execute it, we see the entire column:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行它时，我们看到整个列：
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It’s also possible to overwrite the content of the entire row or a column using
    the assignment operator. For example, suppose we want to replace a row in the
    matrix:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用赋值运算符覆盖整个行或列的内容。例如，假设我们想要替换矩阵中的一行：
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This results in the following change:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下变化：
- en: '[PRE36]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Likewise, we can replace the content of an entire column:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以替换整个列的内容：
- en: '[PRE37]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As a result, the last column changes:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最后一列改变了：
- en: '[PRE38]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: C.1.3 Randomly generated arrays
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.1.3 随机生成的数组
- en: Often it’s useful to generate arrays filled with random numbers. To do this
    in NumPy, we use the `np.random` module.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，生成填充随机数的数组很有用。在 NumPy 中，我们使用 `np.random` 模块来完成此操作。
- en: 'For example, to generate a 5 × 2 array of random numbers uniformly distributed
    between 0 and 1, use `np.random.rand`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要生成一个 5 × 2 的随机数数组，这些数在 0 和 1 之间均匀分布，使用 `np.random.rand`：
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When we run it, it generates an array that looks like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行它时，它生成一个看起来像这样的数组：
- en: '[PRE40]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Every time we run the code, it generates a different result. Sometimes we need
    the results to be reproducible, which means that if we want to execute this code
    later, we will get the same results. To achieve that, we can set the seed of the
    random-number generator. Once the seed is set, the random-number generator produces
    the same sequence every time we run the code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们运行代码，它都会生成不同的结果。有时我们需要结果可重复，这意味着如果我们稍后想要执行此代码，我们将得到相同的结果。为了实现这一点，我们可以设置随机数生成器的种子。一旦设置了种子，随机数生成器每次运行代码时都会产生相同的序列：
- en: '[PRE41]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'On Ubuntu Linux version 18.04 with NumPy version 1.17.2, it generates the following
    array:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu Linux 版本 18.04 和 NumPy 版本 1.17.2 上，它生成以下数组：
- en: '[PRE42]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: No matter how many times we re-execute this cell, the results are the same.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们重新执行这个单元格多少次，结果都是相同的。
- en: 'Warning Fixing the seed of the random-number generator guarantees that the
    generator produces the same results when executed on the same OS with the same
    NumPy version. However, there’s no guarantee that updating the NumPy version will
    not affect reproducibility: a change of version may result in changes in the random-number
    generator algorithm, and that may lead to different results across versions.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：固定随机数生成器的种子可以保证在相同的操作系统和相同的 NumPy 版本下执行时生成器产生相同的结果。然而，没有保证更新 NumPy 版本不会影响可重复性：版本的变化可能会导致随机数生成器算法的变化，这可能导致不同版本的结果不同。
- en: 'If instead of uniform distribution, we want to sample from the standard normal
    distribution, we use `np.random.randn`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要从标准正态分布中采样，而不是均匀分布，我们使用 `np.random.randn`：
- en: '[PRE43]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note Every time we generate a random array in this appendix, we make sure we
    fix the seed number before generating it, even if we don’t explicitly specify
    it in the code—we do it to ensure consistency. We use 2 as the seed. There’s no
    particular reason for this number.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：每次我们在附录中生成随机数组时，我们都会确保在生成之前固定种子数字，即使我们没有在代码中明确指定它——我们这样做是为了确保一致性。我们使用2作为种子。这个数字没有特别的原因。
- en: 'To generate uniformly distributed random integers between 0 and 100 (exclusive),
    we can use `np.random.randint`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成介于0和100（不包括100）之间的均匀分布随机整数，我们可以使用 `np.random.randint`：
- en: '[PRE44]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When executing the code, we get a 5 × 2 NumPy array of integers:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行代码时，我们得到一个5 × 2的整数NumPy数组：
- en: '[PRE45]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Another quite useful feature is shuffling an array—rearranging the elements
    of an array in random order. For example, let’s create an array with a range and
    then shuffle it:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有用的功能是打乱数组——以随机顺序重新排列数组的元素。例如，让我们创建一个范围数组并对其进行打乱：
- en: '[PRE46]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'When we run the code, we see the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行代码时，我们看到以下内容：
- en: '[PRE47]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: C.2 NumPy operations
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.2 NumPy操作
- en: NumPy comes with a wide range of operations that work with the NumPy arrays.
    In this section, we cover operations that we’ll need throughout the book.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy附带了一系列与NumPy数组一起工作的操作。在本节中，我们将介绍本书中需要用到的操作。
- en: C.2.1 Element-wise operations
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.2.1 逐元素操作
- en: 'NumPy arrays support all the arithmetic operations: addition (+), subtraction
    (–), multiplication (*), division (/) and others.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy数组支持所有算术运算：加法（+）、减法（–）、乘法（*）、除法（/）以及其他。
- en: 'To illustrate these operations, let’s first create an array using `arange`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这些操作，我们首先使用 `arange` 创建一个数组：
- en: '[PRE48]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This array contains five elements from 0 to 4:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数组包含从0到4的五个元素：
- en: '[PRE49]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To multiply every element of the array by two, we simply use the multiplication
    operator (*):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数组中的每个元素乘以2，我们只需使用乘法运算符 (*)：
- en: '[PRE50]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'As a result, we get a new array where each element from the original array
    is multiplied by two:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，我们得到一个新数组，其中每个原始数组的元素都乘以2：
- en: '[PRE51]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Note that we don’t need to explicitly write any loops here to apply the multiplication
    operation individually to each element: NumPy does it for us. We can say that
    the multiplication operation is applied *element-wise*—to all elements at once.
    The addition (+), subtraction (–) and division (/) operations are also element-wise
    and require no explicit loops.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要显式地编写任何循环来对每个元素单独应用乘法操作：NumPy为我们做了。我们可以说乘法操作是 *逐元素* 应用的——一次应用到所有元素。加法（+）、减法（–）和除法（/）操作也是逐元素的，不需要显式循环。
- en: 'Such element-wise operations are often called *vectorized*: the `for` loop
    happens internally in native code (written C and Fortran), so the operations are
    very fast!'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这种逐元素操作通常被称为 *向量化的*：`for` 循环在本地代码（用C和Fortran编写）中内部执行，因此操作非常快！
- en: 'Note Whenever possible, use vectorized operations from NumPy instead of loops:
    they are always a magnitude faster.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：尽可能使用NumPy的向量化操作而不是循环：它们总是快得多。
- en: 'In the previous code, we used only one operation. It’s possible to apply multiple
    operations at once in one expression:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们只使用了一个操作。在一个表达式中可以同时应用多个操作：
- en: '[PRE52]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This code creates a new array with the result:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个包含结果的新数组：
- en: '[PRE53]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note that the original array contains integers, but because we used the division
    operation, the result is an array with float numbers.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，原始数组包含整数，但由于我们使用了除法操作，结果是一个浮点数数组。
- en: Previously, our code involved an array and simple Python numbers. It’s also
    possible to do element-wise operations with two arrays if they have the same shape.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们的代码涉及一个数组和简单的Python数字。如果两个数组具有相同的形状，也可以对它们进行逐元素操作。
- en: 'For example, suppose we have two arrays, one containing numbers from 0 to 4,
    and another containing some random noise:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有两个数组，一个包含从0到4的数字，另一个包含一些随机噪声：
- en: '[PRE54]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We sometimes need to do that for modeling not-ideal real-life data: in reality
    there are always imperfections when data is collected, and we can model these
    imperfections by adding noise.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有时需要这样做来模拟不理想的真实数据：在现实中，收集数据时总是存在不完美，我们可以通过添加噪声来模拟这些不完美。
- en: 'We build the `noise` array by first generating numbers between 0 and 1 and
    then multiplying them by 0.01\. This effectively generates random numbers between
    0 and 0.01:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过首先生成0到1之间的数字，然后将它们乘以0.01来构建 `noise` 数组。这实际上生成了介于0和0.01之间的随机数：
- en: '[PRE55]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can then add these two arrays and get a third one with the sum:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将这两个数组相加，得到一个包含总和的第三个数组：
- en: '[PRE56]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In this array, each element of the result is the sum of the respective elements
    of the two other arrays:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在此数组中，结果中的每个元素是两个其他数组相应元素的总和：
- en: '[PRE57]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We can round the numbers to any precision using the `round` method:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`round`方法将数字四舍五入到任何精度：
- en: '[PRE58]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'It’s also an element-wise operation, so it’s applied to all the elements at
    once and the numbers are rounded to the fourth digit:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 它也是一个逐元素操作，因此它一次性应用于所有元素，并将数字四舍五入到第四位：
- en: '[PRE59]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Sometimes we need to square all the elements of an array. For that, we can
    simply multiply the array by itself. Let’s first generate an array:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要对数组的所有元素进行平方。为此，我们可以简单地乘以数组自身。让我们首先生成一个数组：
- en: '[PRE60]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This array contains three random numbers:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 此数组包含三个随机数：
- en: '[PRE61]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now we can multiply it by itself:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将它乘以自身：
- en: '[PRE62]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'As a result, we get a new array where each element of the original array is
    squared:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到一个新的数组，其中每个元素都是原始数组元素的平方：
- en: '[PRE63]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Alternatively, we can use the power operator (**):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用幂运算符（**）：
- en: '[PRE64]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Both approaches lead to the same results (figure C.7).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都会得到相同的结果（图C.7）。
- en: '![](../Images/C-07.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/C-07.png)'
- en: 'Figure C.7 There are two ways to square the elements of an array: multiply
    the array with itself or use the power operation (**).'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.7 有两种方法可以平方数组的元素：将数组与自身相乘或使用幂运算（**）。
- en: 'Other useful element-wise operations that we might need for machine learning
    applications are exponent, logarithm, and square root:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对于机器学习应用，我们可能需要的一些其他有用的逐元素操作包括指数、对数和平方根：
- en: '[PRE65]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: ❶ Computes the exponent
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 计算指数
- en: ❷ Computes the logarithm
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 计算对数
- en: ❸ Computes the square root
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 计算平方根
- en: 'Boolean operations can also be applied to NumPy arrays element-wise. To illustrate
    them, let’s again generate an array with some random numbers:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔操作也可以逐元素应用于NumPy数组。为了说明它们，让我们再次生成一个包含一些随机数的数组：
- en: '[PRE66]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This array contains the following numbers:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 此数组包含以下数字：
- en: '[PRE67]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We can see the elements that are greater than 0.5:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到大于0.5的元素：
- en: '[PRE68]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'As a result, we get an array with three Boolean values:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到一个包含三个布尔值的数组：
- en: '[PRE69]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We know that only the last element of the original array is greater than 0.5,
    so it’s `True` and the rest are `False`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道原始数组的最后一个元素大于0.5，所以它是`True`，其余都是`False`。
- en: 'As with arithmetic operations, we can apply Boolean operations on two NumPy
    arrays of the same shape. Let’s generate two random arrays:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 与算术运算一样，我们可以在形状相同的两个NumPy数组上应用布尔操作。让我们生成两个随机数组：
- en: '[PRE70]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The arrays have the following values:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 数组具有以下值：
- en: '[PRE71]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now we can use the greater-than-or-equal-to operator (>=) to compare the values
    of these arrays:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用大于等于运算符（>=）来比较这些数组的值：
- en: '[PRE72]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'As a result, we get an array with Booleans (figure C.8):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到一个包含布尔值的数组（图C.8）：
- en: '[PRE73]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '![](../Images/C-08.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/C-08.png)'
- en: Figure C.8 Boolean operations in NumPy are element-wise and can be applied to
    two arrays of the same shape for comparing values.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.8 NumPy中的布尔操作是逐元素的，并且可以应用于形状相同的两个数组以比较值。
- en: 'Finally, we can apply logical operations—like logical and (&) and or (|)—to
    Boolean NumPy arrays. Let’s again generate two random arrays:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将逻辑运算（如逻辑与（&）和逻辑或（|））应用于布尔NumPy数组。让我们再次生成两个随机数组：
- en: '[PRE74]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The generated arrays have the following values:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的数组具有以下值：
- en: '[PRE75]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Like arithmetical operations, logical operators are also element-wise. For
    example, to compute the element-wise and, we simply use the & operator with arrays
    (figure C.9):'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 与算术运算一样，逻辑运算符也是逐元素进行的。例如，为了计算逐元素与，我们只需使用数组中的&运算符（图C.9）：
- en: '[PRE76]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: As a result, we get
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到
- en: '[PRE77]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The logical or works in the same way (figure C.9):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑或以相同的方式工作（图C.9）：
- en: '[PRE78]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '![](../Images/C-09.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/C-09.png)'
- en: Figure C.9 Logic operations like logical and logical or can also be applied
    element-wise.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.9 逻辑运算，如逻辑与和逻辑或，也可以逐元素应用。
- en: 'This creates the following array:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建以下数组：
- en: '[PRE79]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: C.2.2 Summarizing operations
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.2.2 汇总操作
- en: Whereas element-wise operations take in an array and produce an array of the
    same shape, the summarizing operations take in an array and produce a single number.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 而逐元素操作接受一个数组并产生一个形状相同的数组，而汇总操作接受一个数组并产生一个单一数字。
- en: 'For example, we can generate an array and then calculate the sum of all elements:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以生成一个数组，然后计算所有元素的总和：
- en: '[PRE80]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: In this example, `pred` is
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`pred`是
- en: '[PRE81]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Then `pred_sum` is the sum of all three elements, which is 1.02:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`pred_sum`是所有三个元素的总和，即1.02：
- en: 0.44 + 0.03 + 0.55 = 1.02
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 0.44 + 0.03 + 0.55 = 1.02
- en: 'Other summarizing operations include `min`, `mean`, `max` and `std`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 其他汇总操作包括 `min`、`mean`、`max` 和 `std`：
- en: '[PRE82]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: After running this code, it produces
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码后，它产生
- en: '[PRE83]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: When we have a two-dimensional array, summarizing operations also produce a
    single number. However, it’s also possible to apply these operations to rows or
    columns separately.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个二维数组时，汇总操作也会产生一个数字。然而，我们也可以单独将这些操作应用于行或列。
- en: 'For example, let’s generate a 4 × 3 array:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们生成一个 4 × 3 的数组：
- en: '[PRE84]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'This generates an array:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个数组：
- en: '[PRE85]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'When we invoke the `max` method, it returns a single number:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `max` 方法时，它返回一个数字：
- en: '[PRE86]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The result is 0.62, which is the maximum number across all elements of the matrix.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是 0.62，这是矩阵所有元素中的最大数。
- en: '![](../Images/C-10.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/C-10.png)'
- en: 'Figure C.10 We can specify the axis along which we apply the operation: `axis=1`
    means applying it to rows, and `axis=0` means applying it to columns.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图 C.10 我们可以指定应用操作的轴：`axis=1` 表示应用于行，`axis=0` 表示应用于列。
- en: 'If we now want to find the largest number in each row, we can use the `max`
    method specifying the axis along which we apply this operation. When we want to
    do it for rows, we use `axis=1` (figure C.10):'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在想要找到每行的最大数，我们可以使用 `max` 方法并指定应用此操作的轴。当我们想要对行进行操作时，我们使用 `axis=1`（图 C.10）：
- en: '[PRE87]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'As a result, we get an array with four numbers—the largest number in each row:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到一个包含四个数字的数组——每行的最大数：
- en: '[PRE88]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Likewise, we can find the largest number in each column. For that, we use `axis=0`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以找到每列的最大数。为此，我们使用 `axis=0`：
- en: '[PRE89]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'This time the result is three numbers—the largest numbers in each column:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这次结果是三个数字——每列的最大数：
- en: '[PRE90]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Other operations—`sum`, `min`, `mean`, `std`, and many others—can also can
    take `axis` as an argument. For example, we can easily calculate the sum of elements
    of every row:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 其他操作——`sum`、`min`、`mean`、`std` 以及许多其他操作——也可以接受 `axis` 作为参数。例如，我们可以轻松计算每行的元素总和：
- en: '[PRE91]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'When executing it, we get four numbers:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，我们得到四个数字：
- en: '[PRE92]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: C.2.3 Sorting
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.2.3 排序
- en: 'Often we need to sort elements of an array. Let’s see how to do it in NumPy.
    First, let’s generate a one-dimensional array with four elements:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 经常我们需要对数组的元素进行排序。让我们看看如何在 NumPy 中进行操作。首先，让我们生成一个包含四个元素的数组：
- en: '[PRE93]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The array we generate contains the following elements:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生成的数组包含以下元素：
- en: '[PRE94]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'To create a sorted copy of the array, use `np.sort`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建数组的排序副本，请使用 `np.sort`：
- en: '[PRE95]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'It returns an array with all the elements sorted:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回一个包含所有元素排序的数组：
- en: '[PRE96]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Because it creates a copy and sorts it, the original array `pred` remains unchanged.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它创建了一个副本并对其进行排序，所以原始数组 `pred` 保持不变。
- en: 'If we want to sort the elements of the array in place without creating another
    array, we invoke the method `sort` on the array itself:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要就地排序数组的元素而不创建另一个数组，我们可以在数组本身上调用 `sort` 方法：
- en: '[PRE97]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Now the array `pred` is sorted.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，数组 `pred` 已经排序。
- en: 'When it comes to sorting, we have another useful thing: `argsort`. Instead
    of sorting an array, it returns the indices of the array in the sorted order (figure
    C.11):'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到排序时，我们还有另一个有用的工具：`argsort`。它不是对数组进行排序，而是返回排序后数组中的索引（图 C.11）：
- en: '[PRE98]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '![](../Images/C-11.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/C-11.png)'
- en: Figure C.11 The function `sort` sorts the array, whereas `argsort` produces
    an array of indices that sort the array.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图 C.11 `sort` 函数对数组进行排序，而 `argsort` 生成一个索引数组，该数组可以排序数组。
- en: 'Now the array `idx` contains indices in the sorted order:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，数组 `idx` 包含排序顺序的索引：
- en: '[PRE99]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Now we can use the array `idx` with indexes to get the original array in the
    sorted order:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用带索引的数组 `idx` 来获取排序后的原始数组：
- en: '[PRE100]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'As we see, it’s indeed sorted:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，它确实已经排序：
- en: '[PRE101]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: C.2.4 Reshaping and combining
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.2.4 重新塑形和组合
- en: 'Each NumPy array has a shape, which specifies its size. For a one-dimensional
    array, it’s the length of the array, and for a two-dimensional array, it’s the
    number of rows and columns. We already know that we can access the shape of an
    array by using the `shape` property:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 NumPy 数组都有一个形状，它指定了它的大小。对于一维数组，它是数组的长度，对于二维数组，它是行数和列数。我们已经知道，我们可以通过使用 `shape`
    属性来访问数组的形状：
- en: '[PRE102]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The shape of `rng` is (12), which means that it’s a one-dimensional array of
    length 12\. Because we used `np.arange` to create the array, it contains the numbers
    from 0 to 11 (inclusive):'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`rng` 的形状是 (12)，这意味着它是一个长度为 12 的一维数组。因为我们使用了 `np.arange` 来创建数组，它包含从 0 到 11（包含）的数字：'
- en: '[PRE103]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'It’s possible to change the shape of an array from one-dimensional to two-dimensional.
    We use the `reshape` method for that:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 将数组的形状从一维转换为二维是可能的。我们使用 `reshape` 方法来完成：
- en: '[PRE104]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'As a result, we get a matrix with four rows and three columns:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，我们得到一个四行三列的矩阵：
- en: '[PRE105]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The reshaping worked because it was possible to rearrange 12 original elements
    into four rows with three columns. In other words, the total number of elements
    didn’t change. However, if we attempt to reshape it to (4, 4), it won’t let us:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 重塑之所以成功，是因为可以将12个原始元素重新排列成四行三列。换句话说，元素的总数没有改变。然而，如果我们尝试将其重塑为(4, 4)，它将不允许我们这样做：
- en: '[PRE106]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'When we do it, NumPy raises a `ValueError`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，NumPy会引发一个`ValueError`：
- en: '[PRE107]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Sometimes we need to create a new NumPy array by putting multiple arrays together.
    Let’s see how to do it.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要通过将多个数组组合在一起来创建一个新的NumPy数组。让我们看看如何做。
- en: 'First, we create two arrays, which we’ll use for illustration:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建两个数组，我们将使用它们来演示：
- en: '[PRE108]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The first one, `vec`, is a one-dimensional array with three elements:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个，`vec`，是一个包含三个元素的向量：
- en: '[PRE109]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The second one, `mat`, is a two-dimensional one with three rows and two columns:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个，`mat`，是一个二维数组，有三行两列：
- en: '[PRE110]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The simplest way to combine two NumPy arrays is using the `np.concatenate`
    function:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个NumPy数组组合在一起的最简单方法是使用`np.concatenate`函数：
- en: '[PRE111]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'It takes in a list of one-dimensional arrays and combines them into one larger
    one-dimensional array. In our case, we pass `vec` two times, so as a result, we
    have an array of length six:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个一维数组列表并将它们组合成一个更大的数组。在我们的例子中，我们传递了两次`vec`，因此结果是一个长度为六的数组：
- en: '[PRE112]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'We can achieve the same result using `np.hstack`, which is short for horizontal
    stack:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`np.hstack`（水平堆叠的简称）达到相同的结果：
- en: '[PRE113]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'It again takes a list of arrays and stacks them horizontally, producing a larger
    array:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 它再次接受一个数组列表并将它们水平堆叠，产生一个更大的数组：
- en: '[PRE114]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'We can also apply `np.hstack` to two-dimensional arrays:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将`np.hstack`应用于二维数组：
- en: '[PRE115]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'The result is another matrix where the original matrices are stacked horizontally
    by columns:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是另一个矩阵，其中原始矩阵通过列水平堆叠：
- en: '[PRE116]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'However, in case of two-dimensional arrays, `np.concatenate` works differently
    from `np.hstack`:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于二维数组，`np.concatenate`的工作方式与`np.hstack`不同：
- en: '[PRE117]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'When we apply `np.concatenate` to matrices, it stacks them vertically, not
    horizontally, like one-dimensional arrays, creating a new matrix with six rows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将`np.concatenate`应用于矩阵时，它将它们垂直堆叠，而不是像一维数组那样水平堆叠，创建一个具有六行的新矩阵：
- en: '[PRE118]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Another useful method for combining NumPy arrays is `np.column_stack`: it allows
    us to stack vectors and matrices together. For example, suppose we want to add
    an extra column to our matrix. For that we simply pass a list that contains the
    vector and then the matrix:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 结合NumPy数组的另一种有用方法是`np.column_stack`：它允许我们将向量和矩阵堆叠在一起。例如，假设我们想要给我们的矩阵添加一个额外的列。为此，我们只需传递一个包含向量和矩阵的列表：
- en: '[PRE119]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'As a result, we have a new matrix, where `vec` becomes the first column, and
    the rest of the `mat` goes after it:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，我们得到一个新的矩阵，其中`vec`成为第一列，其余的`mat`跟在后面：
- en: '[PRE120]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'We can apply `np.column_stack` to two vectors:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`np.column_stack`应用于两个向量：
- en: '[PRE121]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'This produces a two-column matrix as a result:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个两列的矩阵：
- en: '[PRE122]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Like with `np.hstack`, which stacks arrays horizontally, there’s `np.vstack`
    that stacks arrays vertically:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 与`np.hstack`类似，它水平堆叠数组，存在`np.vstack`，它垂直堆叠数组：
- en: '[PRE123]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'When we vertically stack two vectors, we get a matrix with two rows:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们垂直堆叠两个向量时，我们得到一个有两行的矩阵：
- en: '[PRE124]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'We can also stack two matrices vertically:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以垂直堆叠两个矩阵：
- en: '[PRE125]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The result is the same as `np.concatenate([mat,` `mat])`—we get a new matrix
    with six rows:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与`np.concatenate([mat, mat])`相同——我们得到一个具有六行的新矩阵：
- en: '[PRE126]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The `np.vstack` function can also stack together vectors and matrices, in effect
    creating a matrix with new rows:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.vstack`函数也可以将向量和矩阵堆叠在一起，实际上创建了一个具有新行的矩阵：'
- en: '[PRE127]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'When we do it, `vec` becomes the first row in the new matrix:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，`vec`成为新矩阵的第一行：
- en: '[PRE128]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Note that in this code, we used the `T` property of `mat`. This is a matrix
    transposition operation, which changes rows of a matrix to columns:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这段代码中，我们使用了`mat`的`T`属性。这是一个矩阵转置操作，它将矩阵的行转换为列：
- en: '[PRE129]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Originally, `mat` has the following data:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的`mat`具有以下数据：
- en: '[PRE130]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'After transposition, what was a column becomes a row:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 经过转置后，原本是列的变成了行：
- en: '[PRE131]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: C.2.5 Slicing and filtering
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.2.5 切片和过滤
- en: 'Like with Python lists, we can also use slicing for accessing a part of a NumPy
    array. For example, suppose we have a 5 × 3 matrix:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python列表类似，我们也可以使用切片来访问NumPy数组的一部分。例如，假设我们有一个5 × 3的矩阵：
- en: '[PRE132]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'This matrix has five rows and three columns:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这个矩阵有五行三列：
- en: '[PRE133]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'We can access parts of this matrix by using slicing. For example, we can get
    the first free rows using the range operator (:):'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用切片操作来访问矩阵的某些部分。例如，我们可以使用范围操作符 (:) 获取第一行自由行：
- en: '[PRE134]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'It returns rows indexed by 0, 1, and 2 (3 is not included):'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回索引为 0、1 和 2 的行（不包括 3）：
- en: '[PRE135]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'If we need only rows 1 and 2, we specify both the beginning and the end of
    the range:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只需要第 1 行和第 2 行，我们指定范围的开头和结尾：
- en: '[PRE136]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'This gives us the rows we need:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们所需的行：
- en: '[PRE137]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Like with rows, we can select only some columns; for example, the first two
    columns:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 与行类似，我们也可以只选择一些列；例如，前两列：
- en: '[PRE138]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Here we have two ranges:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有两个范围：
- en: The first one is simply a colon (:) with no start and end, which means “include
    all rows.”
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是一个简单的冒号 (:)，没有起始和结束，这意味着“包含所有行。”
- en: The second one is a range that includes columns 0 and 1 (2 not included).
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个是一个包括列 0 和 1（不包括列 2）的范围。
- en: So as a result, we get
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到
- en: '[PRE139]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Of course, we can combine both and select any matrix part we want:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以将两者结合起来，选择任何我们想要的矩阵部分：
- en: '[PRE140]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'This gives us rows 1 and 2 and columns 0 and 1:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们第 1 行和第 2 行以及第 0 列和第 1 列：
- en: '[PRE141]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'If we don’t need a range, but rather some specific rows or columns, we can
    simply provide a list of indices:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不需要范围，而是需要一些特定的行或列，我们可以简单地提供一个索引列表：
- en: '[PRE142]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'This gives us three rows indexed at 3, 0, and 1:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们三个索引为 3、0 和 1 的行：
- en: '[PRE143]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Instead of individual indices, it’s possible to use a binary mask to specify
    which rows to select. For example, suppose we want to choose rows where the first
    element of a row is an odd number.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用单个索引，我们可以使用二进制掩码来指定要选择哪些行。例如，假设我们想要选择行中第一个元素是奇数的行。
- en: 'To check if the first element is odd, we need to do the following:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查第一个元素是否为奇数，我们需要做以下操作：
- en: Select the first column of the matrix.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择矩阵的第一列。
- en: Apply the mod 2 operation (%) to all the elements to compute the remainder of
    the division by 2.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将模 2 操作 (%) 应用于所有元素以计算除以 2 的余数。
- en: If the remainder is 1, then the number is odd, and if 0, the number is even.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果余数是 1，则该数字是奇数，如果是 0，则该数字是偶数。
- en: 'This translates to the following NumPy expression:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这对应于以下 NumPy 表达式：
- en: '[PRE144]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'At the end it produces an array with Booleans:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它产生一个布尔数组：
- en: '[PRE145]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: We see that the expression is `True` for rows 1 and 3 and `False` for rows 0,
    2, and 5.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，对于第 1 行和第 3 行表达式是 `True`，而对于第 0 行、第 2 行和第 5 行是 `False`。
- en: 'Now we can use this expression to select only rows where the expression is
    `True`:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用这个表达式来选择只包含 `True` 的行：
- en: '[PRE146]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'This gives us a matrix with only two rows: rows 1 and 3:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们一个只有两行的矩阵：第 1 行和第 3 行：
- en: '[PRE147]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: C.3 Linear algebra
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.3 线性代数
- en: One of the reasons NumPy is so popular is its support of linear algebra operations.
    NumPy delegates all the internal computations to BLAS and LAPACK—time-proven libraries
    for efficient low-level computations—and this is why it’s blazingly fast.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 非常受欢迎的原因之一是它支持线性代数操作。NumPy 将所有内部计算委托给 BLAS 和 LAPACK——经过时间考验的用于高效低级计算的库——这就是为什么它如此之快。
- en: 'In this section, we take a short overview of the linear algebra operations
    we need throughout the book. We start with the most common ones: matrix and vector
    multiplications.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们简要概述了本书中需要的线性代数操作。我们首先从最常见的开始：矩阵和向量乘法。
- en: C.3.1 Multiplication
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.3.1 乘法
- en: 'In linear algebra, we have multiple types of multiplication:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在线性代数中，我们有多种乘法类型：
- en: 'Vector-vector multiplication: multiplying a vector by another vector'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量-向量乘法：向量乘以另一个向量
- en: 'Matrix-vector multiplication: multiplying a matrix by a vector'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵-向量乘法：矩阵乘以向量
- en: 'Matrix-matrix multiplication: multiplying a matrix by another matrix'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵-矩阵乘法：矩阵乘以另一个矩阵
- en: Let’s take a closer look at each of them and see how to do them in NumPy.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看每一个，并看看如何在 NumPy 中实现它们。
- en: Vector-vector multiplication
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 向量-向量乘法
- en: Vector-vector multiplication involves two vectors. It’s typically called *dot
    product* or *scalar product* ; it takes two vectors and produces a *scalar*—a
    single number.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 向量-向量乘法涉及两个向量。它通常被称为 *点积* 或 *标量积*；它接受两个向量并产生一个 *标量*——一个单一的数字。
- en: Suppose we have two vectors, *u* and *v*, each of length *n* ; then the dot
    product between *u* and *v* is
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个向量，*u* 和 *v*，每个向量的长度为 *n*；那么 *u* 和 *v* 之间的点积是
- en: '![](../Images/C-11-Equation_C-1.png)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![方程 C-1](../Images/C-11-Equation_C-1.png)'
- en: 'Note In this appendix, the elements of a vector of length *n* are indexed from
    0 to *n*–1: this way it’s easier to map the concepts from the mathematical notation
    to NumPy.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在本附录中，长度为 *n* 的向量的元素从 0 到 *n*–1 编号：这样更容易将数学符号的概念映射到 NumPy。
- en: This directly translates to Python. If we have two NumPy arrays `u` and `v`,
    the dot product between them is
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 这直接转换为 Python。如果我们有两个 NumPy 数组 `u` 和 `v`，它们之间的点积是
- en: '[PRE148]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Of course, we can take advantage of vectorized operations in NumPy and calculate
    it with a one-line expression:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以利用 NumPy 中的向量运算功能，用一行表达式来计算它：
- en: '[PRE149]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'However, because it’s quite a common operation, it’s implemented inside NumPy
    in the `dot` method. So, to calculate the dot product, we simply invoke `dot`:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于这是一个相当常见的操作，它被实现为 NumPy 中的 `dot` 方法。因此，为了计算点积，我们只需调用 `dot`：
- en: '[PRE150]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Matrix-vector multiplication
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵-向量乘法
- en: Another type of multiplication is matrix-vector multiplication.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种乘法类型是矩阵-向量乘法。
- en: 'Suppose we have a matrix *X* of size *m* by *n* and a vector *u* of size *n*.
    If we multiply *X* by *u*, we get another vector of size *m* (figure C.12):'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个大小为 *m*×*n* 的矩阵 *X* 和一个大小为 *n* 的向量 *u*。如果我们用 *X* 乘以 *u*，我们得到另一个大小为 *m*
    的向量（图 C.12）：
- en: '![](../Images/C-11-Equation_C-2.png)'
  id: totrans-433
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/C-11-Equation_C-2.png)'
- en: '![](../Images/C-12.png)'
  id: totrans-434
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/C-12.png)'
- en: Figure C.12 When we multiply a 4 × 3 matrix by a vector of length 3, we get
    a vector of length 4.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 图 C.12 当我们将一个 4×3 矩阵乘以一个长度为 3 的向量时，我们得到一个长度为 4 的向量。
- en: We can think of the matrix *X* as a collection of *n* row-vectors *x[i]* , each
    of size *m* (figure C.13).
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将矩阵 *X* 视为一组 *n* 个行向量 *x[i]*，每个大小为 *m*（图 C.13）。
- en: '![](../Images/C-13.png)'
  id: totrans-437
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/C-13.png)'
- en: Figure C.13 We can think of the matrix X as of four row-vectors *x[i]*, each
    of size 3.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 图 C.13 我们可以将矩阵 X 视为四个行向量 *x[i]*，每个大小为 3。
- en: Then we can represent matrix-vector multiplication *Xu* as *m* vector-vector
    multiplications between each row *x[i]* and the vector *u*. The result is another
    vector—vector *v* (figure C.14).
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将矩阵-向量乘法 *Xu* 表示为 *m* 次向量-向量乘法，每次乘法都是矩阵的每一行 *x[i]* 与向量 *u* 之间的乘法。结果是另一个向量——向量
    *v*（图 C.14）。
- en: '![](../Images/C-14.png)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/C-14.png)'
- en: 'Figure C.14 The matrix-vector multiplication is a set of vector-vector multiplications:
    we multiply each row *x[i]* of the matrix *X* by the vector *u* and as a result
    get the vector *v.*'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 图 C.14 矩阵-向量乘法是一组向量-向量乘法：我们将矩阵 *X* 的每一行 *x[i]* 乘以向量 *u*，并得到向量 *v*。
- en: 'Translating this idea to Python is straightforward:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个想法转换为 Python 是直接的：
- en: '[PRE151]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: ❶ Creates an empty vector *v*
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个空向量 *v*
- en: ❷ For each row x[i] of *X*
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对于 *X* 的每一行 x[i]
- en: ❸ Computes the *i*th element of v as a dot product *x[i]* * *u*
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 计算向量 *v* 的第 *i* 个元素作为点积 *x[i]* * *u*
- en: 'Like with vector-vector multiplication, we can use the `dot` method of the
    matrix `X` (a two-dimensional array) to multiply it by vector `u` (a one-dimensional
    array):'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 就像向量-向量乘法一样，我们可以使用矩阵 `X`（一个二维数组）的 `dot` 方法来乘以向量 `u`（一个一维数组）：
- en: '[PRE152]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: The result is the vector `v`—a one-dimensional NumPy array.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是向量 `v`——一个一维的 NumPy 数组。
- en: Matrix-matrix multiplication
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵-矩阵乘法
- en: 'Finally, we have a matrix-matrix multiplication. Suppose we have two matrices,
    *X* of size *m* by *n* and *U* of size *n* by *k*. Then the result is another
    matrix *V* of size *m* by *k* (figure C.15):'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个矩阵-矩阵乘法。假设我们有两个矩阵，*X* 的大小为 *m*×*n* 和 *U* 的大小为 *n*×*k*。那么结果是另一个大小为 *m*×*k*
    的矩阵 *V*（图 C.15）：
- en: '![](../Images/C-14-Equation_C-3.png)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/C-14-Equation_C-3.png)'
- en: '![](../Images/C-15.png)'
  id: totrans-453
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/C-15.png)'
- en: Figure C.15 When we multiply a 4 × 3 matrix *X* by a 3 × 2 matrix *U*, we get
    a 4 × 2 matrix *V*.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 图 C.15 当我们将一个 4×3 矩阵 *X* 乘以一个 3×2 矩阵 *U* 时，我们得到一个 4×2 矩阵 *V*。
- en: 'The easiest way to understand matrix-matrix multiplication is to consider *U*
    as a set of columns: *u*[0]*, u*[1], ..., *u[k]*[-1] (figure C.16).'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 理解矩阵-矩阵乘法最简单的方法是将 *U* 视为一组列：*u*[0]*, *u*[1], ..., *u*[k]*[-1]（图 C.16）。
- en: '![](../Images/C-16.png)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/C-16.png)'
- en: 'Figure C.16 We can think of *U* as a collection of column vectors. In this
    case, we have two columns: *u*[0] and *u*[1].'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 图 C.16 我们可以将 *U* 视为一组列向量。在这种情况下，我们有两个列：*u*[0] 和 *u*[1]。
- en: 'Then matrix-matrix multiplication *XU* is a set of matrix-vector multiplications
    *Xu[i]*. The result of each multiplication is a vector *v[i]*, which is the *i*
    th column of the resulting matrix *V* (figure C.17):'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 然后矩阵-矩阵乘法 *XU* 是一系列矩阵-向量乘法 *Xu[i]*。每次乘法的结果是一个向量 *v[i]*，它是结果矩阵 *V* 的第 *i* 列（图
    C.17）：
- en: '![](../Images/C-16-Equation_C-4.png)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/C-16-Equation_C-4.png)'
- en: '![](../Images/C-17.png)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/C-17.png)'
- en: Figure C.17 We can think of matrix-matrix multiplication *XU* as a set of matrix-vector
    multiplications *v[i]* *= Xu[i]*, where *u[i]*s are the columns of *U*. The result
    is a matrix *V* with all the *v[i]*’s stacked together.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 图 C.17 我们可以将矩阵-矩阵乘法 *XU* 视为一组矩阵-向量乘法 *v[i]* *= Xu[i]*，其中 *u[i]*s 是 *U* 的列。结果是所有
    *v[i]* 的堆叠组成的矩阵 *V*。
- en: 'To implement it in NumPy, we can simply do this:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在 NumPy 中实现它，我们可以简单地这样做：
- en: '[PRE153]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: ❶ Creates an empty matrix *V*
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个空矩阵 *V*
- en: ❷ For each column *u*[i] of *U*
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对于矩阵 *U* 的每一列 *u*[i]
- en: ❸ Computes *v*[i] as matrix-vector multiplication *X * u*[i]
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 计算 *v*[i] 作为矩阵-向量乘法 *X * u*[i]
- en: ❹ Passing *v*[i] as the *i*th column of *V*
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将 *v*[i] 作为 *V* 的第 *i* 列传递
- en: Recall that `U[:,` `i]` means getting the *i* th column. Then we multiply `X`
    by that column and get `vi`. With `V[:,` `i]`, and because we have assignment
    (=), we overwrite the *i* th column of `V` with `vi`.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`U[:, i]` 表示获取第 *i* 列。然后我们用 `X` 乘以该列，得到 `vi`。使用 `V[:, i]`，并且因为我们有赋值（=），我们用
    `vi` 覆盖 `V` 的第 *i* 列。
- en: 'Of course, in NumPy there’s a shortcut for that—it’s again the `dot` method:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在 NumPy 中有一个快捷方式——又是 `dot` 方法：
- en: '[PRE154]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: C.3.2 Matrix inverse
  id: totrans-471
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.3.2 矩阵逆
- en: 'The inverse of a square matrix *X* is the matrix *X*^(–1) such that *X*^(–1)*X
    = I*, where *I* is the identity matrix. The identity matrix *I* doesn’t change
    a vector when we perform matrix-vector multiplication:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 方阵 *X* 的逆矩阵是矩阵 *X*^(–1)，使得 *X*^(–1)*X = I*，其中 *I* 是单位矩阵。单位矩阵 *I* 在进行矩阵-向量乘法时不会改变向量：
- en: '![](../Images/C-17-Equation_C-5.png)'
  id: totrans-473
  prefs: []
  type: TYPE_IMG
  zh: '![C-17-Equation_C-5.png](../Images/C-17-Equation_C-5.png)'
- en: 'Why do we need it? Suppose we have a system:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么需要它？假设我们有一个系统：
- en: '![](../Images/C-17-Equation_C-6.png)'
  id: totrans-475
  prefs: []
  type: TYPE_IMG
  zh: '![C-17-Equation_C-6.png](../Images/C-17-Equation_C-6.png)'
- en: We know the matrix *A* and the resulting vector *b*, but don’t know the vector
    *x*—we want to find it. In other words, we want to *solve* this system.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道矩阵 *A* 和结果向量 *b*，但不知道向量 *x*——我们想要找到它。换句话说，我们想要*解*这个系统。
- en: One of the possible ways of doing it is
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的一种可能方式是
- en: Compute *A*^(–1), which is the inverse of *A*, and then
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算 *A*^(–1)，即 *A* 的逆矩阵，然后
- en: Multiply both sides of the equation by the inverse *A*^(–1)
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将方程的两边乘以逆矩阵 *A*^(–1)
- en: When doing so, we get
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样做的时候，我们得到
- en: '![](../Images/C-17-Equation_C-7.png)'
  id: totrans-481
  prefs: []
  type: TYPE_IMG
  zh: '![C-17-Equation_C-7.png](../Images/C-17-Equation_C-7.png)'
- en: Because *A*^(–1)*A = I*, we have
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 *A*^(–1)*A = I*，所以我们有
- en: '![](../Images/C-17-Equation_C-8.png)'
  id: totrans-483
  prefs: []
  type: TYPE_IMG
  zh: '![C-17-Equation_C-8.png](../Images/C-17-Equation_C-8.png)'
- en: Or
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '![](../Images/C-17-Equation_C-9.png)'
  id: totrans-485
  prefs: []
  type: TYPE_IMG
  zh: '![C-17-Equation_C-9.png](../Images/C-17-Equation_C-9.png)'
- en: 'In NumPy, to compute the inverse, we use `np.linalg.inv`:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 在 NumPy 中，为了计算逆矩阵，我们使用 `np.linalg.inv`：
- en: '[PRE155]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'For this particular square matrix `A`, it’s possible to compute its inverse,
    so `Ainv` has the following values:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的方阵 `A`，可以计算其逆矩阵，所以 `Ainv` 有以下值：
- en: '[PRE156]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'We can verify that if we multiply the matrix with its inverse, we get the identity
    matrix:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以验证，如果我们用矩阵乘以其逆矩阵，我们得到单位矩阵：
- en: '[PRE157]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'The result is indeed the identity matrix:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 结果确实是单位矩阵：
- en: '[PRE158]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Note If all you want is to solve the equation *Ax = b*, then you don’t really
    have to compute the inverse. From a computational point of view, calculating the
    inverse is an expensive operation. Instead, we should use `np.linalg .solve`,
    which is a magnitude faster:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果你只想解方程 *Ax = b*，那么你实际上不需要计算逆矩阵。从计算的角度来看，计算逆矩阵是一个昂贵的操作。相反，我们应该使用 `np.linalg.solve`，这要快得多：
- en: '[PRE159]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'In this book, when computing the weights for linear regression, we use the
    inverse for simplicity: it makes the code easier to understand.'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，当计算线性回归的权重时，我们为了简单起见使用逆矩阵：这使得代码更容易理解。
- en: 'There are matrices for which there’s no inverse. First of all, it’s not possible
    to invert nonsquare matrices. Also, not all square matrices can be inverted: there
    are *singular* matrices—matrices for which there exists no inverse matrix.'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 有些矩阵没有逆矩阵。首先，非方阵无法求逆。此外，并非所有方阵都可以求逆：存在*奇异*矩阵——对于这些矩阵，不存在逆矩阵。
- en: 'When we try to invert a singular matrix in NumPy, we get an error:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试在 NumPy 中求一个奇异矩阵的逆时，我们会得到一个错误：
- en: '[PRE160]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'This code raises `LinAlgError`:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会引发 `LinAlgError`：
- en: '[PRE161]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: C.3.3 Normal equation
  id: totrans-502
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.3.3 正则方程
- en: In chapter 2, we used the normal equation to compute the weights vector for
    linear regression. In this section, we briefly outline how to arrive at the formula
    but without going into details. For more information, please refer to any linear
    algebra textbook.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章中，我们使用了正则方程来计算线性回归的权重向量。在本节中，我们简要概述了如何得到公式，但不深入细节。更多信息，请参阅任何线性代数教科书。
- en: 'This section may look math-heavy, but feel free to skip it: it will not affect
    your understanding of the book. If you studied the normal equation and linear
    regression in college, but already forgot most of it, this section should help
    you refresh your memory.'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节可能看起来数学性很强，但请随意跳过：它不会影响你对本书的理解。如果你在大学里学习过正则方程和线性回归，但现在已经忘记了大部分内容，这一节应该能帮助你刷新记忆。
- en: Suppose we have a matrix *X* with observations and a vector *y* with results.
    We want to find such vector *w* that
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个包含观测的矩阵 *X* 和一个包含结果的向量 *y*。我们想要找到一个向量 *w*，使得
- en: '![](../Images/C-17-Equation_C-10.png)'
  id: totrans-506
  prefs: []
  type: TYPE_IMG
  zh: '![C-17-Equation_C-10](../Images/C-17-Equation_C-10.png)'
- en: 'However, because *X* is not a square matrix, we cannot simply invert it, and
    the exact solution to this system doesn’t exist. We can try to find an inexact
    solution and do the following trick. We multiply both sides by the transpose of
    *X*:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，因为 *X* 不是一个方阵，我们无法简单地求逆，这个系统的精确解不存在。我们可以尝试找到一个不精确的解，并执行以下技巧。我们将两边乘以 *X* 的转置：
- en: '![](../Images/C-17-Equation_C-11.png)'
  id: totrans-508
  prefs: []
  type: TYPE_IMG
  zh: '![C-17-Equation_C-11](../Images/C-17-Equation_C-11.png)'
- en: 'Now *X^TX* is a square matrix, which should be possible to invert. Let’s call
    this matrix *C*:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 *X^TX* 是一个方阵，应该可以求逆。让我们称这个矩阵为 *C*：
- en: '![](../Images/C-17-Equation_C-12.png)'
  id: totrans-510
  prefs: []
  type: TYPE_IMG
  zh: '![C-17-Equation_C-12](../Images/C-17-Equation_C-12.png)'
- en: The equation becomes
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 该方程变为
- en: '![](../Images/C-17-Equation_C-13.png)'
  id: totrans-512
  prefs: []
  type: TYPE_IMG
  zh: '![C-17-Equation_C-13](../Images/C-17-Equation_C-13.png)'
- en: 'In this equation, *X^Ty* is also a vector: when we multiply a matrix by a vector,
    we get a vector. Let’s call it *z*. So now we have'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方程中，*X^Ty* 也是一个向量：当我们用一个矩阵乘以一个向量时，我们得到一个向量。让我们称它为 *z*。所以现在我们有
- en: '![](../Images/C-17-Equation_C-14.png)'
  id: totrans-514
  prefs: []
  type: TYPE_IMG
  zh: '![C-17-Equation_C-14](../Images/C-17-Equation_C-14.png)'
- en: This system now has an exact solution, which is the best approximation solution
    to the system we originally wanted to solve. Proving this is out of the scope
    of the book, so please refer to a textbook for more details.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统现在有一个精确解，这是我们最初想要解决的系统的最佳近似解。证明这一点超出了本书的范围，所以请参考教科书以获取更多细节。
- en: 'To solve the system, we can invert *C* and multiply both sides by it:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解这个系统，我们可以求逆 *C* 并将两边乘以它：
- en: '![](../Images/C-17-Equation_C-15.png)'
  id: totrans-517
  prefs: []
  type: TYPE_IMG
  zh: '![C-17-Equation_C-15](../Images/C-17-Equation_C-15.png)'
- en: Or
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '![](../Images/C-17-Equation_C-16.png)'
  id: totrans-519
  prefs: []
  type: TYPE_IMG
  zh: '![C-17-Equation_C-16](../Images/C-17-Equation_C-16.png)'
- en: 'Now we have the solution for *w*. Let’s rewrite it in terms of the original
    *X* and *y*:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经得到了 *w* 的解。让我们用原始的 *X* 和 *y* 来重新表示它：
- en: '![](../Images/C-17-Equation_C-17.png)'
  id: totrans-521
  prefs: []
  type: TYPE_IMG
  zh: '![C-17-Equation_C-17](../Images/C-17-Equation_C-17.png)'
- en: This is the normal equation, which finds the best approximate solution *w* to
    the original system *Xw = y*.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 这是正规方程，它找到原始系统 *Xw = y* 的最佳近似解 *w*。
- en: 'It’s quite simple to translate to NumPy:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 将其转换为 NumPy 非常简单：
- en: '[PRE162]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Now the array `w` contains the best approximate solution to the system.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数组 `w` 包含了该系统的最佳近似解。
