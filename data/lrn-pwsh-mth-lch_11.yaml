- en: '11 Formatting: And why it’s done on the right'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 格式化：为什么是在右边进行
- en: Let’s quickly review. You know that PowerShell cmdlets produce objects and that
    those objects often contain more properties than PowerShell shows by default.
    You know how to use `gm` to get a list of all of an object’s properties, and you
    know how to use `Select-Object` to specify the properties you want to see. Up
    to this point in the book, you’ve relied on PowerShell’s default configuration
    and rules to determine how the final output will appear on the screen (or in a
    file, or in hard-copy form). In this chapter, you’ll learn to override those defaults
    and create your own formatting for your commands’ output.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下。你知道 PowerShell 命令会产生对象，并且这些对象通常包含比 PowerShell 默认显示的更多属性。你知道如何使用 `gm`
    来获取一个对象的所有属性的列表，也知道如何使用 `Select-Object` 来指定你想要看到的属性。在本书的这一部分，你一直依赖于 PowerShell
    的默认配置和规则来确定最终输出在屏幕（或文件、或硬拷贝形式）上的显示方式。在本章中，你将学习如何覆盖这些默认设置，并为你的命令输出创建自己的格式。
- en: '11.1 Formatting: Making what you see prettier'
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 格式化：让你的显示更美观
- en: We don’t want to give the impression that PowerShell is a full-fledged management-reporting
    tool, because it isn’t. But PowerShell has good capabilities for collecting information,
    and, with the right output, you can certainly produce reports using that information.
    The trick is getting the right output, and that’s what formatting is all about.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想给人留下印象，认为 PowerShell 是一个完整的管理报告工具，因为它不是。但 PowerShell 在收集信息方面具有很好的能力，并且，通过正确的输出，你当然可以使用这些信息生成报告。关键是获取正确的输出，这正是格式化的全部内容。
- en: On the surface, PowerShell’s formatting system can seem easy to use—and for
    the most part that’s true. But the formatting system also contains some of the
    trickiest “gotchas” in the entire shell, so we want to make sure you understand
    how it works and why it does what it does. We’re not just going to show you a
    few new commands here; rather, we’ll explain how the entire system works, how
    you can interact with it, and what limitations you might run into.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，PowerShell 的格式化系统可能看起来很容易使用——大部分情况下确实如此。但是，格式化系统也包含了一些整个 shell 中最棘手的“陷阱”，因此我们想确保你理解它是如何工作的以及为什么它会这样做。我们不仅会向你展示一些新的命令；相反，我们将解释整个系统是如何工作的，你如何与之交互，以及你可能会遇到什么限制。
- en: 11.2 Working with the default formatting
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 使用默认格式化
- en: Run our old friend `Get-Process` again, and pay special attention to the column
    headers. Notice that they don’t exactly match the property names. Instead, each
    header has a specific width, alignment, and so forth. All that configuration stuff
    has to come from someplace, right? You’ll find it in one of the .format.ps1xml
    files that install with PowerShell. Specifically, formatting directions for process
    objects are in DotNetTypes.format.ps1xml.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行我们的老朋友 `Get-Process`，并特别注意列标题。注意，它们并不完全匹配属性名称。相反，每个标题都有特定的宽度、对齐方式等等。所有这些配置信息必须来自某个地方，对吧？你可以在与
    PowerShell 一起安装的 .format.ps1xml 文件中找到它。具体来说，进程对象的格式化方向在 DotNetTypes.format.ps1xml
    中。
- en: Try it Now You definitely want to have PowerShell open so that you can follow
    along with what we’re about to show you. This will help you understand what the
    formatting system is up to under the hood.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 你绝对需要打开 PowerShell，以便你可以跟随我们即将展示的内容。这将帮助你理解格式化系统在幕后是如何工作的。
- en: We’ll begin by changing to the PowerShell installation folder, specifically,
    where PSReadLine is, and opening PSReadLine.format.ps1xml. PSReadLine is a PowerShell
    module that provides the experience when you type in a PowerShell console. It
    adds a bunch of fancy keyboard shortcuts and syntax highlighting, and is customizable.
    Be careful not to save any changes to this file. It’s digitally signed, and any
    changes that you save—even a single carriage return or space added to the file—will
    break the signature and prevent PowerShell from using the file.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先切换到 PowerShell 安装文件夹，特别是 PSReadLine 的位置，并打开 PSReadLine.format.ps1xml。PSReadLine
    是一个 PowerShell 模块，它提供了在 PowerShell 控制台中输入时的体验。它添加了许多花哨的键盘快捷键和语法高亮，并且是可定制的。请小心不要保存对任何更改到这个文件。它是数字签名的，你保存的任何更改——即使是文件中添加的单个换行符或空格——都会破坏签名并阻止
    PowerShell 使用该文件。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'TIP You might get a warning code: `The` `term` `''code''` `is` `not` `recognized`
    `as` `a name` `of` `a` `cmdlet,` `function,` `script` `file,` `or` `executable`
    `program.` To fix this, open the command palette and run the following shell command:
    `Shell Command:` `Install` `''code''` `command` `in` `PATH`.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：您可能会收到一个警告代码：“`term` `'code'` `is` `not` `recognized` `as` `a name` `of`
    `a` `cmdlet,` `function,` `script` `file,` `or` `executable` `program.`”要修复此问题，请打开命令面板并运行以下
    shell 命令：“Shell Command：`Install` `'code'` `command` `in` `PATH`”。
- en: 'Next, find out the exact type of object returned by `Get-PSReadLineKeyHandler`:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，找出 `Get-PSReadLineKeyHandler` 返回的确切对象类型：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, follow these steps:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照以下步骤操作：
- en: Copy and paste the complete type name, `Microsoft.PowerShell.KeyHandler`, to
    the clipboard.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将完整的类型名称 `Microsoft.PowerShell.KeyHandler` 复制并粘贴到剪贴板。
- en: Switch over to Visual Studio Code and press Cmd-F (or Ctrl-F on Windows) to
    open the Search dialog.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 Visual Studio Code 并按 Cmd-F（或在 Windows 上按 Ctrl-F）打开搜索对话框。
- en: In the Search dialog, paste in the type name you copied to the clipboard. Press
    Enter.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索对话框中，粘贴您复制到剪贴板中的类型名称。按 Enter 键。
- en: You should see `Microsoft.PowerShell.KeyHandler` in the file. Figure 11.1 shows
    what you should find.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该在文件中看到 `Microsoft.PowerShell.KeyHandler`。图 11.1 展示了您应该找到的内容。
- en: '![](Images/CH11_F01_Plunk.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH11_F01_Plunk.png)'
- en: Figure 11.1 Locating the key handler view in Visual Studio Code
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 在 Visual Studio Code 中定位键处理器视图
- en: What you’re now looking at in Visual Studio Code is the set of directions that
    govern how a key handler is displayed by default. Scroll down, and you’ll see
    the definition for a *table view*, which you should expect because you already
    know that key handlers display in a multicolumn table. You’ll see the familiar
    column names, and if you scroll down a bit more, you’ll see where the file specifies
    which property will display in each column. You’ll see definitions for column
    widths and alignments too. When you’re finished browsing, close Visual Studio
    Code, being careful not to save any changes that you may have accidentally made
    to the file, and go back to PowerShell.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在在 Visual Studio Code 中看到的是一组指导如何默认显示键处理器的指令。向下滚动，您将看到 *表格视图* 的定义，这是您应该预期的，因为您已经知道键处理器以多列表格的形式显示。您将看到熟悉的列名，如果您再向下滚动一点，您将看到文件指定了哪些属性将在每个列中显示。您还将看到列宽和对齐的定义。浏览完毕后，请小心关闭
    Visual Studio Code，确保不要保存您可能意外修改的任何文件，然后返回 PowerShell。
- en: Try it Now You can also get this format data by running the following command.
    You can mess around with the object you get back, but we won’t be focusing on
    it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下：您也可以通过运行以下命令来获取此格式数据。您可以玩弄返回的对象，但我们不会专注于它。
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When you run `Get-PSReadLineKeyHandler`, here’s what happens in the shell:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行 `Get-PSReadLineKeyHandler` 时，shell 中会发生以下情况：
- en: The cmdlet places objects of the type `Microsoft.PowerShell.KeyHandler` into
    the pipeline.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该命令将 `Microsoft.PowerShell.KeyHandler` 类型的对象放入管道。
- en: At the end of the pipeline is an invisible cmdlet called `Out-Default`. It’s
    always there, and its job is to pick up whatever objects are in the pipeline after
    all of your commands have run.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在管道末尾是一个不可见的命令 `Out-Default`。它始终存在，其任务是收集在所有命令运行之后管道中的所有对象。
- en: '`Out-Default` passes the objects to `Out-Host`, because the PowerShell console
    is designed to use the screen (called the *host*) as its default form of output.
    In theory, someone could write a shell that uses files or printers as the default
    output instead, but nobody has (that we know of).'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Out-Default` 将对象传递给 `Out-Host`，因为 PowerShell 控制台被设计为使用屏幕（称为 *host*）作为其默认的输出形式。从理论上讲，有人可以编写一个使用文件或打印机作为默认输出的
    shell，但我们所知没有人这样做。'
- en: Most of the `Out-` cmdlets are incapable of working with standard objects. Instead,
    they’re designed to work with special formatting instructions. So, when `Out-Host`
    sees that it has been handed standard objects, it passes them to the formatting
    system.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大多数 `Out-` 命令无法与标准对象一起工作。相反，它们被设计为与特殊的格式化指令一起工作。因此，当 `Out-Host` 发现它被传递了标准对象时，它会将它们传递给格式化系统。
- en: The formatting system looks at the type of the object and follows an internal
    set of formatting rules (we’ll cover those in a moment). It uses those rules to
    produce formatting instructions, which are passed back to `Out-Host`.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 格式化系统查看对象的类型，并遵循一组内部格式化规则（我们将在稍后介绍这些规则）。它使用这些规则来生成格式化指令，并将这些指令传递回 `Out-Host`。
- en: Once `Out-Host` sees that it has formatting instructions, it follows those instructions
    to construct the onscreen display.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦 `Out-Host` 看到有格式化指令，它会遵循这些指令来构建屏幕显示。
- en: All of this happens whenever you manually specify an `Out-` cmdlet too. For
    example, run `Get-Process` `|` `Out-File procs.txt`, and `Out-File` will see that
    you’ve sent it some normal objects. It will pass those to the formatting system,
    which creates formatting instructions and passes them back to `Out-File`. `Out-File`
    then constructs the text file based on those instructions. So the formatting system
    becomes involved anytime objects need to be converted into human-readable textual
    output.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都会在你手动指定一个`Out-`命令时发生。例如，运行`Get-Process` `|` `Out-File procs.txt`，`Out-File`会看到你发送了一些普通对象。它会将这些对象传递给格式化系统，该系统创建格式化指令并将它们传递回`Out-File`。然后`Out-File`根据这些指令构建文本文件。所以，格式化系统在任何需要将对象转换为人类可读的文本输出时都会介入。
- en: 'What rules does the formatting system follow in step 5? For the first formatting
    rule, the system looks to see whether the type of object it’s dealing with has
    a predefined view. That’s what you saw in PSReadLine.format.ps1xml: a predefined
    view for a `KeyHandler` object. A few other .format.ps1xml files are installed
    with PowerShell, and they’re all loaded by default when the shell starts. You
    can create your own predefined views as well, although doing so is beyond the
    scope of this book.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化系统在步骤5中遵循哪些规则？对于第一条格式化规则，系统会查看它所处理的对象类型是否有预定义的视图。这就是你在PSReadLine.format.ps1xml中看到的：一个针对`KeyHandler`对象的预定义视图。一些其他的.format.ps1xml文件也随PowerShell一起安装，并且当shell启动时默认加载。你也可以创建自己的预定义视图，尽管这样做超出了这本书的范围。
- en: The formatting system looks for predefined views that specifically target the
    object type it’s dealing with. In this case, it’s looking for the view that handles
    `Microsoft .PowerShell.KeyHandler` objects.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化系统会寻找针对它所处理的特定对象类型的预定义视图。在这个例子中，它正在寻找处理`Microsoft .PowerShell.KeyHandler`对象的视图。
- en: 'What if there’s no predefined view? Let’s find out using the `System.Uri` type,
    which doesn’t have an entry in a format.ps1xml file (we promise!). Try running
    this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有预定义的视图会怎样？让我们使用`System.Uri`类型来找出答案，它没有在format.ps1xml文件中找到条目（我们保证！）。尝试运行以下命令：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is using a concept called “casting,” where we say, “Hey, PowerShell, I’ve
    got this string that looks like a URI. Can you just treat it like the type `System.Uri`?”
    And PowerShell replies, “You got it!” and gives you a `Uri` object. You might
    notice we didn’t have to specify `System` in the line that we ran. That’s because
    PowerShell tacks on `System` to the front if it can’t find a type just called
    `Uri`. Clever PowerShell! Anyway, the output of that is a long list of properties
    like so:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用一个叫做“铸造”的概念，我们说，“嘿，PowerShell，我有一个看起来像URI的字符串。你能把它当作`System.Uri`类型来处理吗？”PowerShell回答，“没问题！”然后给你一个`Uri`对象。你可能注意到，我们运行的那一行并没有指定`System`。这是因为如果PowerShell找不到只叫做`Uri`的类型，它就会在前面加上`System`。聪明的PowerShell！无论如何，输出的结果是一个长长的属性列表，如下所示：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The formatting is not too bad for something that doesn’t have any special formatting.
    That’s because PowerShell will look at the properties of the type and show them
    in a friendly view. We can control which properties we see here by introducing
    a format .ps1xml for this type, or we can allow the formatting system to take
    its next step, or what we call the *second formatting rule* : It looks to see
    whether anyone has declared a default display property set for that type of object.
    You’ll find those in a different configuration file, types.ps1xml. Since we’re
    not going to dive deep into writing our own format and types files, we’re going
    to give you one to load in, and we’ll just see how it affects the output. First,
    let’s create and open up a new file called Uri.Types.ps1xml file in Visual Studio
    Code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有特殊格式化的东西来说，格式化并不太差。这是因为PowerShell会查看类型的属性，并以友好的视图显示它们。我们可以通过为该类型引入一个format
    .ps1xml来控制我们在这里看到哪些属性，或者我们可以允许格式化系统进行下一步，或者我们称之为*第二个格式化规则*：它会查看是否有人为该类型的对象声明了一个默认显示属性集。你可以在不同的配置文件types.ps1xml中找到这些。由于我们不会深入探讨编写自己的格式和类型文件，我们将给你一个要加载的文件，并看看它如何影响输出。首先，让我们在Visual
    Studio Code中创建并打开一个名为Uri.Types.ps1xml的新文件：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, paste in the following content and save the file:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，粘贴以下内容并保存文件：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Excellent, now, see the `DefaultDisplayPropertySet`? Make a note of the five
    properties listed there. Then go back to PowerShell and run this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，现在，看到`DefaultDisplayPropertySet`了吗？记下那里列出的五个属性。然后回到PowerShell中运行以下命令：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We’ve just loaded that Types.ps1xml file we just created. Now let’s run the
    original line again and see what it gets us:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚加载了我们刚刚创建的Types.ps1xml文件。现在，让我们再次运行原始行，看看它会得到什么结果：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Do the results look familiar? They should—the properties you see are there solely
    because they’re listed as defaults in Types.ps1xml. If the formatting system finds
    a default display property set, it’ll use that set of properties for its next
    decision. If it doesn’t find one, the next decision will consider all of the object’s
    properties.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 结果看起来熟悉吗？应该是的——你看到的属性仅仅是因为它们在Types.ps1xml中列为默认值。如果格式化系统找到一个默认显示属性集，它将使用该属性集进行下一个决定。如果没有找到，下一个决定将考虑对象的所有属性。
- en: 'That next decision—the *third formatting rule*—is about the kind of output
    to create. If the formatting system displays four or fewer properties, it uses
    a table. If there are five or more properties, it uses a list. That’s why the
    `System.Uri` object wasn’t displayed as a table: its five properties trigger a
    list. The theory is that more than four properties might not fit well into an
    ad hoc table without truncating information.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 那个接下来的决定——*第三个格式化规则*——是关于要创建的输出类型。如果格式化系统显示四个或更少的属性，它将使用表格。如果有五个或更多的属性，它将使用列表。这就是为什么`System.Uri`对象没有以表格形式显示：它的五个属性触发了列表。理论上是说，超过四个属性可能不适合没有截断信息的临时表格。
- en: Now you know how the default formatting works. You also know that most `Out-`
    cmdlets automatically trigger the formatting system so that they can get the formatting
    instructions they need. Next let’s look at how to control that formatting system
    ourselves and override the defaults.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了默认格式化是如何工作的。你还知道大多数`Out-` cmdlet会自动触发格式化系统，以便它们可以获取所需的格式化指令。接下来，让我们看看如何自己控制该格式化系统并覆盖默认设置。
- en: Oh, and by the way, the formatting system is why PowerShell sometimes seems
    to “lie.” For example, run `Get-Process` and look at the column headers. See the
    one labeled `PM(K)`? Well that’s a lie, sort of, because there’s no property called
    `PM(K)`. There’s a property called `PM`. The lesson here is that formatted column
    headers are just that—column headers. They aren’t necessarily the same as the
    underlying property names. The only safe way to see property names is to use `Get-Member`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，顺便说一下，格式化系统是PowerShell有时似乎“撒谎”的原因。例如，运行`Get-Process`并查看列标题。看到标记为`PM(K)`的那个吗？嗯，那是一种谎言，因为不存在名为`PM(K)`的属性。有一个名为`PM`的属性。这里的教训是，格式化的列标题只是列标题。它们不一定与底层属性名称相同。查看属性名称的唯一安全方法是使用`Get-Member`。
- en: 11.3 Formatting tables
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 表格格式化
- en: PowerShell has four formatting cmdlets, and we’ll work with the three that provide
    the most day-to-day formatting capability (the fourth is briefly discussed in
    an “Above and beyond” sidebar near the end of this chapter). First up is `Format-Table`,
    which has an alias, `ft`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell有四个格式化cmdlet，我们将使用提供最多日常格式化能力的三个（第四个在章节末尾的“超越”侧边栏中简要讨论）。首先是`Format-Table`，它有一个别名，`ft`。
- en: 'If you read the help file for `Format-Table`, you’ll notice that it has several
    parameters. These are some of the most useful ones, along with examples of how
    to use them:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读了`Format-Table`的帮助文件，你会注意到它有几个参数。以下是一些最有用的参数，以及如何使用它们的示例：
- en: '`-Property`—This parameter accepts a comma-separated list of properties that
    should be included in the table. These properties aren’t case sensitive, but the
    shell will use whatever you type as the column headers, so you can get nicer-looking
    output by properly casing the property names (e.g., *CPU* instead of *cpu*). This
    parameter accepts wildcards, meaning you can specify `*` to include all properties
    in the table, or something like `c*` to include all properties starting with *c*.
    Notice that the shell will still display only the properties it can fit in the
    table, so not every property you specify may display. This parameter is positional,
    so you don’t have to type the parameter name, provided the property list is in
    the first position. Try these examples (the second example from the help file
    for `Format-Table` is shown here):'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Property`——此参数接受一个以逗号分隔的属性列表，这些属性应包含在表格中。这些属性不区分大小写，但shell将使用你输入的内容作为列标题，因此你可以通过正确的大小写属性名称（例如，*CPU*而不是*cpu*）来获得更美观的输出。此参数接受通配符，这意味着你可以指定`*`以包含表格中的所有属性，或者像`c*`这样的东西以包含以*c*开头的所有属性。请注意，shell仍然只会显示它可以在表格中容纳的属性，因此你指定的并非每个属性都会显示。此参数是位置参数，因此如果你将属性列表放在第一个位置，你不必输入参数名称。尝试以下示例（以下第二个示例来自`Format-Table`的帮助文件）：'
- en: '[PRE9]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`-GroupBy`—This parameter generates a new set of column headers each time the
    specified property value changes. This works well only when you’ve first sorted
    the objects on that same property. An example is the best way to show how this
    works (this one will group Azure VMs based on whether they are running or stopped):'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-GroupBy`参数会在指定的属性值更改时生成一组新的列标题。这仅在首先按该属性对对象进行排序时才有效。以下是一个示例（此示例将根据虚拟机是运行还是停止来对Azure
    VM进行分组）：'
- en: '[PRE10]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`-Wrap`—If the shell has to truncate information in a column, it’ll end that
    column with ellipses (`. . .`) to visually indicate that information was suppressed.
    This parameter enables the shell to wrap information, which makes the table longer
    but preserves all the information you want to display. Here’s an example:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Wrap`参数——如果shell需要在列中截断信息，它将以省略号（`. . .`）结束该列，以视觉上表示信息已被抑制。此参数使shell能够包装信息，这使得表格更长，但保留了你想显示的所有信息。以下是一个示例：'
- en: '[PRE11]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Try it Now You should run through all of these examples in the shell, and feel
    free to mix and match these techniques. Experiment to see what works and what
    sort of output you can create. These commands will only work if you have already
    connected to an Azure account and if you have existing virtual machines in Azure.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 你应该在shell中运行所有这些示例，并且可以自由混合和匹配这些技术。实验以查看哪些有效，以及你可以创建什么样的输出。这些命令仅在你已经连接到Azure帐户并且你有Azure中的现有虚拟机时才有效。
- en: 11.4 Formatting lists
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4 格式化列表
- en: Sometimes you need to display more information than will fit horizontally in
    a table, which can make a list useful. `Format-List` is the cmdlet you’ll turn
    to, or you can use its alias, `fl`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要显示比表格水平宽度更多的信息，这可以使列表变得有用。`Format-List`是你要使用的cmdlet，或者你可以使用它的别名`fl`。
- en: 'This cmdlet supports some of the same parameters as `Format-Table`, including
    `-Property`. In fact, `fl` is another way of displaying the properties of an object.
    Unlike `gm`, `fl` will also display the values for those properties so that you
    can see what kind of information each property contains:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此cmdlet支持与`Format-Table`相同的某些参数，包括`-Property`。实际上，`fl`是显示对象属性的另一种方式。与`gm`不同，`fl`还会显示这些属性的值，以便你可以看到每个属性包含的信息类型：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We often use `fl` as an alternative way of discovering the properties of an
    object.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常使用`fl`作为发现对象属性的一种替代方式。
- en: Try it Now Read the help for `Format-List`, and try experimenting with its parameters.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 Read the help for `Format-List`，并尝试使用其参数进行实验。
- en: 11.5 Formatting wide lists
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.5 格式化宽列表
- en: The last cmdlet, `Format-Wide` (or its alias, `fw`), displays a wider, multicolumn
    list. It’s able to display only the values of a single property, so its `-Property`
    parameter accepts only one property name, not a list, and it can’t accept wildcards.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个cmdlet是`Format-Wide`（或其别名`fw`），它显示一个更宽、多列的列表。它只能显示单个属性的值，因此其`-Property`参数只接受一个属性名称，不接受列表，也不接受通配符。
- en: 'By default, `Format-Wide` looks for an object’s `Name` property, because `Name`
    is a commonly used property and usually contains useful information. The display
    generally defaults to two columns, but a `-Columns` parameter can be used to specify
    more columns:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`Format-Wide`查找对象的`Name`属性，因为`Name`是一个常用的属性，通常包含有用的信息。显示通常默认为两列，但可以使用`-Columns`参数指定更多列：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Try it Now Read the help for `Format-Wide`, and try experimenting with its parameters.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 Read the help for `Format-Wide`，并尝试使用其参数进行实验。
- en: 11.6 Creating custom columns and list entries
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.6 创建自定义列和列表条目
- en: Flip back to the previous chapter and review section 10.5\. In that section,
    we showed you how to use a hash table construct to add custom properties to an
    object. Both `Format-Table` and `Format-List` can use those same constructs to
    create custom table columns or custom list entries.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 回到上一章，复习第10.5节。在该节中，我们向您展示了如何使用散列表结构向对象添加自定义属性。`Format-Table`和`Format-List`都可以使用这些相同的结构来创建自定义表列或自定义列表条目。
- en: 'You might do this to provide a column header that’s different from the property
    name being displayed:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能这样做是为了提供一个与显示的属性名称不同的列标题：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note This will only work if an Azure connection and storage account already
    exists.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这仅当已经存在Azure连接和存储帐户时才有效。
- en: 'Or, you might put a more complex mathematical expression in place:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可能需要放置一个更复杂的数学表达式：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We admit, we’re cheating a little bit by throwing in a bunch of stuff that
    we haven’t talked about yet. We might as well talk about it now:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们承认，我们通过引入一些尚未讨论的内容而有点作弊。我们不妨现在就谈谈：
- en: Obviously, we’re starting with `Get-Process`, a cmdlet you’re more than familiar
    with by now. If you run `Get-Process` `|` `fl` `*`, you’ll see that the `VM` property
    is in bytes, although that’s not how the default table view displays it.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显然，我们是从`Get-Process`开始，这是一个你现在非常熟悉的cmdlet。如果你运行`Get-Process` `|` `fl` `*`，你会看到`VM`属性以字节为单位，尽管默认的表格视图并不是这样显示的。
- en: We’re telling `Format-Table` to start with the process’s `Name` property.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们告诉`Format-Table`从进程的`Name`属性开始。
- en: Next we’re using a special hash table to create a custom column that will be
    labeled `VM(MB)`. That’s the first part up to the semicolon, which is a separator.
    The second part defines the value, or expression, for that column by taking the
    object’s normal `VM` property and dividing it by `1` `MB`. The slash is PowerShell’s
    division operator, and PowerShell recognizes the shortcuts `KB`, `MB`, `GB`, `TB`,
    and `PB` as denoting kilobyte, megabyte, gigabyte, terabyte, and petabyte, respectively.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们使用一个特殊的哈希表来创建一个自定义列，该列将被标记为`VM(MB)`。这是分号之前的第一个部分，它是一个分隔符。第二个部分通过将对象的正常`VM`属性除以`1`
    `MB`来定义该列的值或表达式。斜杠是PowerShell的除法运算符，PowerShell识别`KB`、`MB`、`GB`、`TB`和`PB`作为千字节、兆字节、吉字节、太字节和拍字节的代表。
- en: 'The result of that division operation will have a decimal component that we
    don’t want to see. The `-as` operator enables us to change the data type of that
    result from a floating-point value to, in this case, an integer value (specified
    by `[int]`). The shell will round up or down, as appropriate, when making that
    conversion. The result is a whole number with no fractional component:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那个除法操作的结果将有一个我们不想看到的十进制部分。`-as`运算符使我们能够将那个结果的数据类型从浮点值更改为，在这种情况下，一个整数值（由`[int]`指定）。在执行转换时，shell将根据需要向上或向下舍入。结果是没有任何分数部分的整数：
- en: '[PRE16]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We show you this little division-and-changing trick because it can be useful
    in creating nicer-looking output. We won’t spend much more time in this book on
    these operations (although we’ll tell you that `*` is used for multiplication,
    and as you might expect, `+` and `-` are for addition and subtraction, respectively).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向你展示这个小小的除法和转换技巧，因为它在创建更美观的输出时可能很有用。在这本书中，我们不会花太多时间在这些操作上（尽管我们会告诉你`*`用于乘法，而且正如你所预期的那样，`+`和`-`分别用于加法和减法）。
- en: Above and beyond
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外
- en: 'Try repeating this example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试重复这个例子：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: But this time don’t type it all on one line. Type it exactly as it’s shown here
    in the book, on three lines total. You’ll notice after typing the first line,
    which ends with a pipe character, that PowerShell changes its prompt. That’s because
    you ended the shell in a pipe, and the shell knows that more commands are coming.
    It will enter this same “waiting for you to finish” mode if you press Enter without
    properly closing all curly brackets, braces, quotation marks, and parentheses.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 但这次不要在一行中输入所有内容。按照书中所示，在总共三行中输入。你会注意到在输入以管道字符结尾的第一行之后，PowerShell会改变其提示符。这是因为你以管道结束了shell，shell知道还有更多的命令要来。如果你没有正确关闭所有花括号、大括号、引号和括号就按Enter键，shell会进入相同的“等待你完成”模式。
- en: If you didn’t mean to enter that extended-typing mode, press Ctrl-C to abort,
    and start over. In this case, you could type the second line of text and press
    Enter, and then type the third line and press Enter. In this mode, you’ll have
    to press Enter one last time, on a blank line, to tell the shell you’re finished.
    When you do so, it will execute the command as if it had been typed on a single,
    continuous line.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不是故意进入扩展输入模式，请按Ctrl-C来终止，然后重新开始。在这种情况下，你可以输入文本的第二行并按Enter键，然后输入第三行并按Enter键。在这个模式下，你将不得不在空白行上按最后一次Enter键，以告诉shell你已经完成。当你这样做时，它将像在单行上输入一样执行命令。
- en: 'Unlike `Select-Object`, whose hash tables can accept only a `Name` and `Expression`
    key (although they’ll also accept `N`, `L`, and `Label` for `Name`, and will accept
    `E` for `Expression`), the `Format-` commands can handle additional keys that
    are intended to control the visual display. These additional keys are most useful
    with `Format-Table`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与只能接受`Name`和`Expression`键（尽管它们也会接受`N`、`L`和`Label`作为`Name`，以及接受`E`作为`Expression`）的`Select-Object`不同，`Format-`命令可以处理额外的键，这些键旨在控制视觉显示。这些额外的键与`Format-Table`一起最有用：
- en: '`FormatString` specifies a formatting code, causing the data to be displayed
    according to the specified format. This is mainly useful with numeric and date
    data. Go to the documentation on formatting types at [http://mng.bz/XWy1](http://mng.bz/XWy1)
    to review the available codes for standard numeric and date formatting and for
    custom numeric and date formatting.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormatString` 指定一个格式化代码，导致数据根据指定的格式显示。这主要用于数值和日期数据。请访问格式化类型的文档 [http://mng.bz/XWy1](http://mng.bz/XWy1)，以查看标准数值和日期格式以及自定义数值和日期格式的可用代码。'
- en: '`Width` specifies the desired column width.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Width` 指定所需的列宽度。'
- en: '`Alignment` specifies the desired column alignment, either `Left` or `Right`.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Alignment` 指定所需的列对齐方式，可以是 `Left` 或 `Right`。'
- en: 'Using those additional keys makes it easier to achieve the previous example’s
    results, and even to improve them:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些额外的键可以更容易地实现前面的示例结果，甚至可以改进它们：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now we don’t have to do the division, because PowerShell will format the number
    as a fixed-point value having two decimal places, and it will right-align the
    result.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们不需要进行除法操作，因为 PowerShell 会将数字格式化为具有两位小数的定点值，并将结果右对齐。
- en: '11.7 Going out: To a file or to the host'
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.7 输出到：文件或主机
- en: 'Once something is formatted, you have to decide where it’ll go. If a command
    line ends in a `Format-` cmdlet, the formatting instructions created by the `Format-`
    cmdlet go to `Out-Default`, which forwards them to `Out-Host`, which displays
    them on the screen:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦格式化完成，您必须决定它将去往何处。如果命令行以 `Format-` cmdlet 结尾，则 `Format-` cmdlet 创建的格式化指令将发送到
    `Out-Default`，它将它们转发到 `Out-Host`，在屏幕上显示：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You could also manually pipe the formatting instructions to `Out-Host`, which
    accomplishes exactly the same thing:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以手动将格式化指令传递给 `Out-Host`，这会完成完全相同的事情：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Alternatively, you can pipe formatting instructions to `Out-File` to direct
    formatted output to a file. As you’ll read in section 11.9, only one of those
    two `Out-` cmdlets should ever follow a `Format-` cmdlet on the command line.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以将格式化指令通过管道传递给 `Out-File`，以将格式化后的输出直接指向文件。正如您将在第 11.9 节中读到的，命令行中只能有一个 `Out-`
    cmdlet 随后跟一个 `Format-` cmdlet。
- en: Keep in mind that `Out-File` defaults to a specific character width for output,
    which means a text file might look different from an onscreen display. The cmdlet
    has a `-Width` parameter that enables you to change the output width, if desired,
    to accommodate wider tables.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`Out-File` 默认使用特定的字符宽度进行输出，这意味着文本文件可能看起来与屏幕显示不同。该 cmdlet 有一个 `-Width` 参数，允许您根据需要更改输出宽度，以适应更宽的表格。
- en: '11.8 Another out: GridViews'
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.8 另一种输出：GridViews
- en: In the old days of Windows PowerShell, there was a cmdlet that was included
    called `Out-GridView``,` which provides another useful form of output—a graphical
    user interface (GUI). For PowerShell 6+, a cross-platform version of this cmdlet
    was created, but it exists in the PowerShell Gallery in the form of a module.
    You can install this cmdlet by running
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows PowerShell 的早期版本中，有一个名为 `Out-GridView` 的内置 cmdlet，它提供了一种有用的输出形式——图形用户界面（GUI）。对于
    PowerShell 6 及以上版本，创建了一个跨平台的版本，但它以模块的形式存在于 PowerShell Gallery 中。您可以通过运行以下命令来安装此
    cmdlet：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that `Out-GridView` isn’t technically formatting; in fact, `Out-GridView`
    entirely bypasses the formatting subsystem. No `Format-` cmdlets are called, no
    formatting instructions are produced, and no text output is displayed in the console
    window. `Out-GridView` can’t receive the output of a `Format-` cmdlet—it can receive
    only the regular objects output by other cmdlets.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Out-GridView` 并非技术上的格式化；实际上，`Out-GridView` 完全绕过了格式化子系统。没有调用 `Format-` cmdlet，没有生成格式化指令，也没有在控制台窗口中显示文本输出。`Out-GridView`
    不能接收 `Format-` cmdlet 的输出——它只能接收其他 cmdlet 输出的常规对象。
- en: Figure 11.2 shows what happens when we run the command `Get-Process | Out-GridView`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 展示了当我们运行 `Get-Process | Out-GridView` 命令时会发生什么。
- en: '![](Images/CH11_F02_Plunk.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH11_F02_Plunk.png)'
- en: Figure 11.2 The results of the `Out-GridView` cmdlet
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 `Out-GridView` cmdlet 的结果
- en: 11.9 Common points of confusion
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.9 常见混淆点
- en: As we mentioned at the start of this chapter, the formatting system has most
    of the gotchas that trip up PowerShell newcomers. They tend to run across two
    issues, so we’ll try to help you avoid them.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章开头提到的，格式化系统具有大多数会让 PowerShell 新手绊倒的陷阱。他们往往会遇到两个问题，所以我们将尽力帮助您避免这些问题。
- en: 11.9.1 Always format right
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.9.1 总是右对齐格式化
- en: 'It’s incredibly important that you remember one rule from this chapter: *format
    right*. Your `Format-` cmdlet should be the last thing on the command line, with
    `Out-File` as the only exception. The reason for this rule is that the `Format-`
    cmdlets produce formatting instructions, and only an `Out-` cmdlet can properly
    consume those instructions. If a `Format-` cmdlet is last on the command line,
    the instructions will go to `Out-Default` (which is always at the end of the pipeline),
    which will forward them to `Out-Host`, which is happy to work with formatting
    instructions. Try running this command to illustrate the need for this rule:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要，你需要记住本章的一个规则：*格式正确*。你的 `Format-` 命令应该是在命令行上的最后一项，只有 `Out-File` 是例外。这个规则的原因是
    `Format-` 命令生成格式化指令，只有 `Out-` 命令才能正确消费这些指令。如果一个 `Format-` 命令是命令行上的最后一项，指令将会发送到
    `Out-Default`（它总是在管道的末尾），然后它会将指令转发到 `Out-Host`，`Out-Host` 很乐意处理格式化指令。尝试运行以下命令来展示这个规则的需求：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You’ll notice that `gm` isn’t displaying information about your history objects
    because the `Format-Table` cmdlet doesn’t output history objects. It consumes
    the history objects you pipe in, and it outputs formatting instructions—which
    is what `gm` sees and reports on. Now try this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到 `gm` 并没有显示关于你的历史对象的信息，因为 `Format-Table` 命令不会输出历史对象。它消耗了你通过管道传递的历史对象，并输出格式化指令——这是
    `gm` 看到的并报告的内容。现在尝试这个命令：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Go ahead and open history.html in a browser, and you’ll see some crazy results.
    You didn’t pipe history objects to `ConvertTo-Html`; you piped formatting instructions,
    so that’s what got converted to HTML. This illustrates why a `Format-` cmdlet,
    if you use one, has to be either the last thing on the command line or the second-to-last,
    with the last cmdlet being `Out-File`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开 history.html，你会看到一些疯狂的结果。你没有将历史对象通过 `ConvertTo-Html` 进行管道传递；你传递了格式化指令，所以这就是被转换成
    HTML 的内容。这说明了为什么如果你使用 `Format-` 命令，它必须是命令行上的最后一项或者倒数第二项，最后一项命令是 `Out-File`。
- en: 'Also know that `Out-GridView` is unusual (for an `Out-` cmdlet, at least),
    in that it *won’t* accept formatting instructions and *will* accept only standard
    objects. Try these two commands to see the difference:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 还要知道，`Out-GridView` 对于一个 `Out-` 命令来说是不寻常的（至少是），它*不会*接受格式化指令，而只会接受标准对象。尝试运行以下两个命令来查看差异：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That’s why we explicitly mentioned `Out-File` as the only cmdlet that should
    follow a `Format-` cmdlet (technically, `Out-Host` can also follow a `Format-`
    cmdlet, but there’s no need because ending the command line with the `Format-`
    cmdlet will get the output to `Out-Host` anyway).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为这个原因，我们明确指出 `Out-File` 是唯一应该跟在 `Format-` 命令后面的命令（技术上，`Out-Host` 也可以跟在 `Format-`
    命令后面，但这是不必要的，因为以 `Format-` 命令结束命令行的话，输出还是会到达 `Out-Host`）。
- en: 11.9.2 One type of object at a time, please
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.9.2 请一次只处理一种类型的对象
- en: The next thing to avoid is putting multiple kinds of objects into the pipeline.
    The formatting system looks at the first object in the pipeline and uses the type
    of that object to determine what formatting to produce. If the pipeline contains
    two or more kinds of objects, the output won’t always be complete or useful.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个要避免的事情是将多种类型的对象放入管道中。格式化系统会查看管道中的第一个对象，并使用该对象的类型来确定要生成哪种格式。如果管道包含两种或更多种类的对象，输出可能不会总是完整或有用。
- en: 'For example, run this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，运行以下命令：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: That semicolon allows us to put two commands onto a single command line, without
    piping the output of the first cmdlet into the second one. This means both cmdlets
    run independently, but they put their output into the same pipeline. As you see,
    the output starts out fine, displaying process objects. But the output breaks
    down when it’s time to display the history objects. Rather than producing the
    table you’re used to, PowerShell reverts to a list. The formatting system isn’t
    designed to take multiple kinds of objects and make the results look as attractive
    as possible.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 那个分号允许我们将两个命令放在同一个命令行上，而不需要将第一个命令的输出通过管道传递给第二个命令。这意味着两个命令都是独立运行的，但它们将输出放入同一个管道中。正如你所看到的，输出一开始是好的，显示了进程对象。但当需要显示历史对象时，输出就崩溃了。PowerShell
    并没有设计成能够处理多种类型的对象，并尽可能使结果看起来更吸引人。
- en: What if you want to combine information drawn from two (or more) places into
    a single form of output? You absolutely can, and you can do so in a way that the
    formatting system can deal with nicely. But that’s an advanced topic that we won’t
    get to in this book.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将来自两个（或更多）地方的信息合并成单一形式的输出，你绝对可以，而且你可以以一种格式化系统可以很好地处理的方式做到这一点。但这是一个高级主题，我们在这本书中不会涉及。
- en: Above and beyond
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外
- en: Technically, the formatting system *can* handle multiple types of objects—if
    you tell it how. Run `Dir |` `gm`, and you’ll notice that the pipeline contains
    both `DirectoryInfo` and `FileInfo` objects (`gm` has no problem working with
    pipelines that contain multiple kinds of objects and will display member information
    for all of them.) When you run `Dir` by itself, the output is perfectly legible.
    That’s because Microsoft provides a predefined custom formatting view for `DirectoryInfo`
    and `FileInfo` objects, and that view is handled by the `Format-Custom` cmdlet.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，格式化系统*可以*处理多种类型的对象——如果你告诉它如何处理。运行`Dir | gm`，你会注意到管道中包含`DirectoryInfo`和`FileInfo`对象（`gm`没有问题处理包含多种对象的管道，并将显示所有对象的成员信息。）当你单独运行`Dir`时，输出是完全可以读的。这是因为微软为`DirectoryInfo`和`FileInfo`对象提供了预定义的定制格式化视图，该视图由`Format-Custom`
    cmdlet处理。
- en: '`Format-Custom` is mainly used to display various predefined custom views.
    You could technically create your own predefined custom views, but the necessary
    XML syntax is complicated and isn’t publicly documented at this time, so custom
    views are limited to what Microsoft provides.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`Format-Custom`主要用于显示各种预定义的定制视图。技术上你可以创建自己的预定义定制视图，但必要的XML语法很复杂，目前没有公开文档，因此定制视图仅限于微软提供的。'
- en: Microsoft’s custom views do get a lot of usage, though. PowerShell’s help information
    is stored as objects, for example, and the formatted help files you see on the
    screen are the result of feeding those objects into a custom view.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，微软的定制视图确实得到了很多使用。例如，PowerShell的帮助信息以对象的形式存储，你在屏幕上看到的格式化帮助文件就是将这些对象输入到定制视图的结果。
- en: 11.10 Lab
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.10 实验室
- en: Note For this lab, you need any computer running PowerShell 7.1 or later.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：对于这个实验室，你需要任何运行PowerShell 7.1或更高版本的计算机。
- en: 'See if you can complete the following tasks:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否能完成以下任务：
- en: Display a table of processes that includes only the process names, IDs, and
    whether they’re responding to Windows (the `Responding` property has that information).
    Have the table take up as little horizontal room as possible, but don’t allow
    any information to be truncated.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示一个仅包含进程名称、ID和它们是否响应Windows（`Responding`属性包含这些信息）的进程表。表格应尽可能占用较少的水平空间，但不要允许任何信息被截断。
- en: Display a table of processes that includes the process names and IDs. Also include
    columns for virtual and physical memory usage, expressing those values in megabytes
    (MB).
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示一个包含进程名称和ID的进程表。还包括虚拟和物理内存使用情况的列，这些值以兆字节（MB）为单位表示。
- en: Use `Get-Module` to get a list of loaded modules. Format the output as a table
    that includes, in this order, the module name and the version. The column headers
    must be `ModuleName` and `ModuleVersion`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Get-Module`获取已加载模块的列表。以表格形式格式化输出，按此顺序包括模块名称和版本。列标题必须是`ModuleName`和`ModuleVersion`。
- en: 'Use `Get-AzStorageAccount` and `Get-AzStorageContainer` to display *all* of
    your storage containers so that a separate table is displayed for storage containers
    that are accessible to the public and storage containers that are not. (Hint:
    Piping is your friend . . . use a `-GroupBy` parameter.)'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Get-AzStorageAccount`和`Get-AzStorageContainer`显示*所有*存储容器，以便为可公开访问的存储容器和不可公开访问的存储容器分别显示一个表格。（提示：管道是你的朋友……使用`-GroupBy`参数。）
- en: Display a four-column-wide list of all directories in the home directory.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示主目录中所有目录的四列宽列表。
- en: Create a formatted list of all .dll files in `$pshome`, displaying the name,
    version information, and file size. PowerShell uses the `Length` property, but
    to make it clearer, your output should show `Size`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个格式化的列表，列出`$pshome`中的所有.dll文件，显示名称、版本信息和文件大小。PowerShell使用`Length`属性，但为了更清晰，你的输出应显示`Size`。
- en: 11.11 Lab answers
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.11 实验室答案
- en: '`Get-Process | Format-Table Name,ID,Responding -Wrap`'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get-Process | Format-Table Name,ID,Responding -Wrap`'
- en: '`Get-Process | Format-Table Name,ID,`'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get-Process | Format-Table Name,ID,`'
- en: '`@{l=''VirtualMB'';e={$_.vm/1MB}},`'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`@{l=''VirtualMB'';e={$_.vm/1MB}},`'
- en: '`@{l=''PhysicalMB'';e={$_.workingset/1MB}}`'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`@{l=''PhysicalMB'';e={$_.workingset/1MB}}`'
- en: '`Get-Module| Format-Table @{l=''ModuleName'';e={$_.Name }},`'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get-Module| Format-Table @{l=''ModuleName'';e={$_.Name }},`'
- en: '`@{l=''ModuleVersion'';e={$_.Version}}`'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`@{l=''ModuleVersion'';e={$_.Version}}`'
- en: '`Get-AzStorageAccount | Get-AzStorageContainer | ft -GroupBy PublicAccess`'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`获取-AzStorageAccount | 获取-AzStorageContainer | ft -GroupBy 公共访问组`'
- en: '`gci ~ -Directory | format-wide –column 4`'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gci ~ -Directory | 格式化宽 -列 4`'
- en: '`gci $pshome/*.dll |`'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gci $pshome/*.dll |`'
- en: '`Format-List Name,VersionInfo,@{Name="Size";Expression={$_.length}}`'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`格式化列表名称，版本信息，@{名称="大小"；表达式={$_．length}}`'
- en: 11.12 Further exploration
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.12 进一步探索
- en: This is the perfect time to experiment with the formatting system. Try using
    the three main `Format-` cmdlets to create different forms of output. The labs
    in upcoming chapters will often ask you to use specific formatting, so you might
    as well hone your skills with these cmdlets and start memorizing the more-often-used
    parameters covered in this chapter.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是尝试格式化系统的完美时机。尝试使用三个主要的 `Format-` 命令来创建不同形式的输出。在接下来的章节中，实验室通常会要求你使用特定的格式化，所以你不妨用这些命令磨练你的技能，并开始记忆本章中涵盖的更常用参数。
