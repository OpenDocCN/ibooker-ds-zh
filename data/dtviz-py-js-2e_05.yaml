- en: Chapter 3\. Reading and Writing Data with Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章\. 使用Python读写数据
- en: One of the fundamental skills of any data visualizer is the ability to move
    data around. Whether your data is in an SQL database, a comma-separated value
    (CSV) file, or in some more esoteric form, you should be comfortable reading the
    data, converting it, and writing it into a more convenient form if need be. One
    of Python’s great strengths is how easy it makes manipulating data in this way.
    The focus of this chapter is to bring you up to speed with this essential aspect
    of our dataviz toolchain.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 任何数据可视化专家的基本技能之一是能够移动数据。无论您的数据是在SQL数据库中，CSV文件中，还是其他更奇特的形式中，您都应该能够舒适地读取数据，转换数据，并在需要时将其写入更方便的格式。Python在这方面的一个强大功能就是使得这样的数据操作变得异常简单。本章的重点是让您迅速掌握我们数据可视化工具链中这一关键部分。
- en: This chapter is part tutorial, part reference, and sections of it will be referred
    to in later chapters. If you know the fundamentals of reading and writing Python
    data, you can cherry-pick parts of the chapter as a refresher.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章既是教程，又是参考资料的一部分，并且后续章节将参考本章的部分内容。如果您了解Python数据读写的基础知识，您可以挑选本章的部分内容作为复习。
- en: Easy Does It
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容易上手
- en: 'I remember when I started programming back in the day (using low-level languages
    like C) how awkward data manipulation was. Reading from and writing to files was
    an annoying mixture of boilerplate code, hand-rolled improvisations, and the like.
    Reading from databases was equally difficult, and as for serializing data, the
    memories are still painful. Discovering Python was a breath of fresh air. It wasn’t
    a speed demon, but opening a file was pretty much as simple as it could be:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我还记得当年我开始编程（使用像C这样的低级语言），数据操作是多么的笨拙。从文件中读取和写入数据是样板式代码、临时 improvisations 等的令人讨厌的混合体。从数据库中读取同样困难，至于序列化数据，回忆起来仍然痛苦。发现Python就像是一阵清新的空气。它并非速度的鬼才，但打开一个文件几乎就是可以做到的最简单的事情了：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Back then, Python made reading from and writing to files refreshingly easy,
    and its sophisticated string processing made parsing the data in those files just
    as easy. It even had an amazing module called Pickle that could serialize pretty
    much any Python object.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 那时候，Python让从文件中读取和写入数据变得令人耳目一新，它复杂的字符串处理功能也使得解析这些文件中的数据变得同样简单。它甚至有一个叫做Pickle的神奇模块，可以序列化几乎任何Python对象。
- en: In the years since, Python has added robust, mature modules to its standard
    library that make dealing with CSV and JSON files, the standard for web dataviz
    work, just as easy. There are also some great libraries for interacting with SQL
    databases such as SQLAlchemy, my thoroughly recommended go-to. The newer NoSQL
    databases are also well served. MongoDB is the most popular of these newer document-based
    databases, and Python’s PyMongo library, which is demonstrated later in the chapter,
    makes interacting with it a relative breeze.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，Python已经在其标准库中添加了强大成熟的模块，使得处理CSV和JSON文件（Web数据可视化工作的标准）变得同样容易。还有一些很棒的库可以与SQL数据库进行交互，比如SQLAlchemy，我强烈推荐使用。新型NoSQL数据库也得到了很好的服务。MongoDB是这些新型基于文档的数据库中最流行的，Python的PyMongo库（稍后在本章中演示）使得与它的交互相对轻松。
- en: Passing Data Around
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传递数据
- en: A good way to demonstrate how to use the key data-storage libraries is to pass
    a single data packet among them, reading and writing it as we go. This will give
    us an opportunity to see in action the key data formats and databases employed
    by data visualizers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 展示如何使用关键数据存储库的一个好方法是在它们之间传递单个数据包，边读取边写入。这将让我们有机会看到数据可视化器使用的关键数据格式和数据库的实际操作。
- en: The data we’ll be passing around is probably the most commonly used in web visualizations,
    a list of dictionary-like objects (see [Example 3-1](#data_dummydata)). This dataset
    is transferred to the browser in [JSON form](https://oreil.ly/JgjAp), which is,
    as we’ll see, easily converted from a Python dictionary.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要传递的数据可能是在Web可视化中最常用的，是一组类似于字典的对象列表（见[示例 3-1](#data_dummydata)）。这个数据集以[JSON格式](https://oreil.ly/JgjAp)传输到浏览器，正如我们将看到的那样，可以轻松地从Python字典转换过来。
- en: Example 3-1\. Our target list of data objects
  id: totrans-11
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-1\. 我们的目标数据对象列表
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We’ll start by creating a CSV file from the Python list shown in [Example 3-1](#data_dummydata)
    as a demonstration of reading (opening) and writing system files.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从创建一个CSV文件开始，以Python列表的形式显示[示例 3-1](#data_dummydata)，作为打开和写入系统文件的演示。
- en: The following sections assume you’re in a working (root) directory with a *data*
    subdirectory at hand. You can run the code from a Python interpreter or file.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各节假定您处于具有*data*子目录的工作（根）目录中。您可以从Python解释器或文件中运行代码。
- en: Working with System Files
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用系统文件
- en: In this section, we’ll create a CSV file from a Python list of dictionaries
    ([Example 3-1](#data_dummydata)). Typically, you would do this using the `csv`
    module, which we’ll demonstrate after this section, so this is just a way of demonstrating
    basic Python file manipulation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从Python字典列表（[示例 3-1](#data_dummydata)）创建一个CSV文件。通常，您会使用`csv`模块来执行此操作，我们将在此节后演示，因此这只是演示基本的Python文件操作的一种方式。
- en: First, let’s open a new file, using `w` as a second argument to indicate we’ll
    be writing data to it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们打开一个新文件，使用`w`作为第二个参数表示我们将向其写入数据。
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now we’ll create our CSV file from the `nobel_winners` dictionary ([Example 3-1](#data_dummydata)):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将从`nobel_winners`字典（[示例 3-1](#data_dummydata)）创建我们的CSV文件：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](assets/1.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO1-1)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO1-1)'
- en: Gets our data columns from the keys of the first object (i.e., `['category',
    'name', ... ]`).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从第一个对象的键（即`['category', 'name', ... ]`）获取我们的数据列。
- en: '[![2](assets/2.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO1-2)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO1-2)'
- en: Sorts the columns in alphabetical order.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 按字母顺序对列进行排序。
- en: '[![3](assets/3.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO1-3)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO1-3)'
- en: Uses Python’s `with` statement to guarantee the file is closed on leaving the
    block or if any exceptions occur.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python的`with`语句来保证在离开块或发生任何异常时关闭文件。
- en: '[![4](assets/4.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO1-4)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO1-4)'
- en: '`join` creates a concatenated string from a list of strings (`cols` here),
    joined by the initial string (i.e., “category,name,..”).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`join`从字符串列表（这里是`cols`）创建一个连接字符串，由初始字符串（即“category,name,..”）连接。'
- en: '[![5](assets/5.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO1-5)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO1-5)'
- en: Creates a list using the column keys to the objects in `nobel_winners`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列键创建对象中的列表（`nobel_winners`）。
- en: 'Now that we’ve created our CSV file, let’s use Python to read it and make sure
    everything is correct:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的CSV文件，让我们使用Python读取它，确保一切都正确：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As the previous output shows, our CSV file is well formed. Let’s use Python’s
    built-in `csv` module to first read it and then create a CSV file the right way.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的输出所示，我们的CSV文件格式正确。让我们使用Python内置的`csv`模块首先读取它，然后正确创建CSV文件。
- en: CSV, TSV, and Row-Column Data Formats
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSV、TSV和行列数据格式
- en: 'Comma-separated values (CSV) or their tab-separated cousins (TSV) are probably
    the most ubiquitous file-based data formats and, as a data visualizer, these will
    often be the forms you’ll receive to work your magic with. Being able to read
    and write CSV files and their various quirky variants, such as pipe- or semicolon-separated
    or those using *`* in place of the standard double quotes, is a fundamental skill;
    Python’s `csv` module is capable of doing pretty much all your heavy lifting here.
    Let’s put it through its paces reading and writing our `nobel_winners` data:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号分隔值（CSV）或其制表符分隔的同类（TSV）可能是最普遍的基于文件的数据格式，作为数据可视化者，这些通常是你会收到的形式，用于处理你的数据。能够读取和写入CSV文件及其各种古怪的变体，比如以管道或分号分隔，或者使用*`*代替标准双引号的格式，是一项基本技能；Python的`csv`模块能够在这里做几乎所有的繁重工作。让我们通过读写我们的`nobel_winners`数据来展示它的功能：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Writing our `nobel_winners` data (see [Example 3-1](#data_dummydata)) to a
    CSV file is a pretty simple affair. `csv` has a dedicated `DictWriter` class that
    will turn our dictionaries into CSV rows. The only piece of explicit bookkeeping
    we have to do is write a header to our CSV file, using the keys of our dictionaries
    as fields (i.e., “category, name, nationality, gender”):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的`nobel_winners`数据（见[示例 3-1](#data_dummydata)）写入CSV文件非常简单。`csv`有一个专门的`DictWriter`类，它会将我们的字典转换为CSV行。我们唯一需要做的显式记录就是写入CSV文件的标题，使用我们字典的键作为字段（即“category,
    name, nationality, gender”）：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](assets/1.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO2-1)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO2-1)'
- en: You need to explicitly tell the writer which `fieldnames` to use (in this case,
    the `'category'`, `'name'`, etc., keys).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要明确告知写入器要使用哪些 `fieldnames`（在本例中是 `'category'`、`'name'` 等键）。
- en: '[![2](assets/2.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO2-2)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO2-2)'
- en: We’ll sort the CSV header fields alphabetically for readability.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 CSV 标题字段按字母顺序排序以提高可读性。
- en: '[![3](assets/3.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO2-3)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO2-3)'
- en: Writes the CSV-file header (“category, name,…​”).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 写入 CSV 文件的标题（“category, name,…​”）。
- en: You’ll probably be reading CSV files more often than writing them.^([1](ch03.xhtml#idm45607798394048))
    Let’s read back the *nobel_winners.csv* file we just wrote.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能经常读取 CSV 文件，而不是写入它们。^([1](ch03.xhtml#idm45607798394048)) 让我们读取刚刚写入的 *nobel_winners.csv*
    文件。
- en: 'If you just want to use `csv` as a superior and eminently adaptable file line
    reader, a couple of lines will produce a handy iterator, which can deliver your
    CSV rows as lists of strings:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想将 `csv` 作为一个优秀且非常适应的文件行读取器使用，几行代码将生成一个便捷的迭代器，可以将您的 CSV 行作为字符串列表传递：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](assets/1.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO3-1)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO3-1)'
- en: Iterates over the `reader` object, consuming the lines in the file.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历`reader`对象，消耗文件中的行。
- en: Note that the numbers are read in string form. If you want to manipulate them
    numerically, you’ll need to convert any numeric columns to their respective type,
    which is integer years in this case.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意数字以字符串形式读取。如果要对其进行数值操作，需要将任何数值列转换为其相应的类型，这种情况下是整数年份。
- en: 'A more convenient way to consume CSV data is to convert the rows into Python
    dictionaries. This *record* form is also the one we are using as our conversion
    target (a `list` of `dict`s). `csv` has a handy `DictReader` for just this purpose:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 更方便地消耗 CSV 数据的方法是将行转换为 Python 字典。这种*record*形式也是我们作为转换目标（`list` of `dict`）使用的形式。`csv`
    提供了一个方便的 `DictReader` 就是为了这个目的：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](assets/1.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO4-1)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO4-1)'
- en: Inserts all of the `reader` items into a list.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有 `reader` 项插入列表中。
- en: 'As the output shows, we just need to cast the `dict`s year attributes to integers
    to make `nobel_winners` conform to the chapter’s target data ([Example 3-1](#data_dummydata)),
    thus:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如输出所示，我们只需将 `dict` 的年份属性转换为整数，就可以使 `nobel_winners` 符合本章的目标数据（[示例 3-1](#data_dummydata)），如下：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For more flexibility we can easily create a Python `datetime` from the year
    column:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更灵活地创建 Python `datetime`，我们可以轻松从年份列创建它：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `csv` readers don’t infer datatypes from your file, and instead interpret
    everything as a string. pandas, Python’s preeminent data-hacking library, will
    try to guess the correct type of the data columns, usually successfully. We’ll
    see this in action in the later dedicated pandas chapters.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`csv`读取器不会从你的文件中推断数据类型，而是将所有内容解释为字符串。pandas，Python 中领先的数据处理库，会尝试猜测数据列的正确类型，通常能够成功。我们将在后面专门讲解
    pandas 的章节中看到这一点。'
- en: '`csv` has a few useful arguments to help parse members of the CSV family:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`csv` 有一些有用的参数来帮助解析 CSV 家族的成员：'
- en: '`dialect`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`dialect`'
- en: By default, `'excel'`; specifies a set of dialect-specific parameters. `excel-tab`
    is a sometimes-used alternative.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`'excel'`；指定了一组特定于方言的参数。`excel-tab` 是一种偶尔使用的替代方式。
- en: '`delimiter`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`delimiter`'
- en: Files are usually comma-separated, but they could use `|`, `:` or `' '` instead.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 文件通常是逗号分隔的，但也可以使用 `|`、`:` 或 `' '`。
- en: '`quotechar`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`quotechar`'
- en: By default, double quotes are used, but you occasionally find `|` or `` ` ``
    instead.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，使用双引号，但偶尔会使用 `|` 或 `` ` `` 替代。
- en: You can find the full set of `csv` parameters in the [online Python docs](https://oreil.ly/9zZvt).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [在线 Python 文档](https://oreil.ly/9zZvt) 中找到完整的 `csv` 参数集。
- en: Now that we’ve successfully written and read our target data using the `csv`
    module, let’s pass on our CSV-derived `nobel_winners` `dict` to the `json` module.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功地使用 `csv` 模块编写和读取了目标数据，让我们将我们的基于 CSV 的 `nobel_winners` `dict` 传递给 `json`
    模块。
- en: JSON
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON
- en: 'In this section, we’ll write and read our `nobel_winners` data using Python’s
    `json` module. Let’s remind ourselves of the data we’re using:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 Python 的 `json` 模块编写和读取我们的 `nobel_winners` 数据。让我们回顾一下我们使用的数据：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For data primitives such as strings, integers, and floats, Python dictionaries
    are easily saved (or *dumped*, in the JSON vernacular) into JSON files, using
    the `json` module. The `dump` method takes a Python container and a file pointer,
    saving the former to the latter:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于诸如字符串、整数和浮点数等数据原语，可以使用Python字典将其轻松保存（或在JSON术语中*转储*）到JSON文件中，使用`json`模块。`dump`方法接受一个Python容器和一个文件指针，将前者保存到后者：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Reading (or loading) a JSON file is just as easy. We just pass the opened JSON
    file to the `json` module’s `load` method:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 读取（或加载）JSON文件同样简单。我们只需将打开的JSON文件传递给`json`模块的`load`方法即可：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[![1](assets/1.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO5-1)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO5-1)'
- en: Note that, unlike in our CSV file conversion, the integer type of the year column
    is preserved.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与CSV文件转换不同，年列的整数类型被保留。
- en: '`json` has the methods `loads` and `dumps`, which are counterparts to the file
    access methods, loading JSON strings to Python containers and dumping Python containers
    to JSON strings.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`json`具有方法`loads`和`dumps`，它们分别对应于文件访问方法，将JSON字符串加载到Python容器中，并将Python容器转储为JSON字符串。'
- en: Dealing with Dates and Times
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理日期和时间
- en: 'Trying to dump a `datetime` object to `json` produces a `TypeError`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将`datetime`对象转储为`json`会产生`TypeError`：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When serializing simple datatypes such as strings or numbers, the default `json`
    encoders and decoders are fine. But for more specialized data such as dates, you
    will need to do your own encoding and decoding. This isn’t as hard as it sounds
    and quickly becomes routine. Let’s first look at encoding your Python [`datetime`s](https://oreil.ly/aHI4h)
    into sensible JSON strings.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当序列化诸如字符串或数字之类的简单数据类型时，默认的`json`编码器和解码器效果很好。但对于诸如日期之类的更专门化数据，您需要自己进行编码和解码。这并不像听起来那么难，并且很快就会变得日常。让我们首先看一下如何将您的Python
    [`datetime`s](https://oreil.ly/aHI4h)编码为明智的JSON字符串。
- en: The easiest way to encode Python data containing `datetime`s is to create a
    custom encoder like the one shown in [Example 3-2](#data_json_time), which is
    provided to the `json.dumps` method as a `cls` argument. This encoder is applied
    to each object in your data in turn and converts dates or datetimes to their ISO-format
    string (see [“Dealing with Dates, Times, and Complex Data”](#sect_datetimes)).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 编码Python数据中包含`datetime`的最简单方法是创建一个自定义编码器，就像在[示例 3-2](#data_json_time)中所示的一样，它作为`json.dumps`方法的`cls`参数提供。该编码器依次应用于数据中的每个对象，并将日期或日期时间转换为其ISO格式字符串（参见[“处理日期、时间和复杂数据”](#sect_datetimes)）。
- en: Example 3-2\. Encoding a Python `datetime` to JSON
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-2\. 将Python `datetime`编码为JSON
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[![1](assets/1.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO6-1)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO6-1)'
- en: Subclasses a `JSONEncoder` in order to create a customized date-handling one.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个定制的日期处理类，需要从`JSONEncoder`派生子类。
- en: '[![2](assets/2.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO6-2)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO6-2)'
- en: Tests for a `datetime` object and if true, returns the `isoformat` of any dates
    or datetimes (e.g., 2021-11-16T16:41:14.650802).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 测试`datetime`对象，如果为真，则返回任何日期或日期时间的`isoformat`（例如，2021-11-16T16:41:14.650802）。
- en: '[![3](assets/3.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO6-3)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO6-3)'
- en: Uses the `cls` argument to set a custom date encoder.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`cls`参数来设置自定义日期编码器。
- en: 'Let’s see how our new `dumps` method copes with some `datetime` data:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的新`dumps`方法如何处理一些`datetime`数据：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `time` field is correctly converted into an ISO-format string, ready to
    be decoded into a JavaScript `Date` object (see [“Dealing with Dates, Times, and
    Complex Data”](#sect_datetimes) for a demonstration).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`time`字段已正确转换为ISO格式字符串，准备解码为JavaScript的`Date`对象（参见[“处理日期、时间和复杂数据”](#sect_datetimes)进行演示）。'
- en: While you could write a generic decoder to cope with date strings in arbitrary
    JSON files,^([2](ch03.xhtml#idm45607797415616)) it’s probably not advisable. Date
    strings come in so many weird and wonderful varieties that this is a job best
    done by hand on what is pretty much always a known dataset.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以编写一个通用解码器来处理任意JSON文件中的日期字符串，^([2](ch03.xhtml#idm45607797415616))但这可能并不明智。日期字符串有各种各样的奇特变体，最好手动处理几乎总是已知的数据集。
- en: 'The venerable `strptime` method, part of the `datetime.datetime` package, is
    good for the job of turning a time string in a known format into a Python `datetime`
    instance:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 可靠的 `strptime` 方法，属于 `datetime.datetime` 包，非常适合将已知格式的时间字符串转换为 Python 的 `datetime`
    实例：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[![1](assets/1.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO7-1)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO7-1)'
- en: '`strptime` tries to match the time string to a format string using various
    directives such as `%Y` (year with century) and `%H` (hour as a zero-padded decimal
    number). If successful, it creates a Python `datetime` instance. See [the Python
    docs](https://oreil.ly/Fi40k) for a full list of the directives available.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`strptime` 尝试使用各种指令（例如 `%Y`（带世纪的年份）和 `%H`（零填充的小时））将时间字符串与格式字符串匹配。如果成功，它会创建一个
    Python 的 `datetime` 实例。请参阅 [Python 文档](https://oreil.ly/Fi40k) 查看所有可用指令的完整列表。'
- en: 'If `strptime` is fed a time string that does not match its format, it throws
    a handy `ValueError`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `strptime` 被传入一个与其格式不匹配的时间字符串，它会抛出一个便捷的 `ValueError`：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'So to convert date fields of a known format into `datetime`s for a `data` list
    of dictionaries, you could do something like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要将已知格式的日期字段转换为 `datetime`，并应用于一个由字典组成的 `data` 列表，您可以像这样做：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now that we’ve dealt with the two most popular data file formats, let’s shift
    to the big guns and see how to read our data from and write our data to SQL and
    NoSQL databases.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理了两种最流行的数据文件格式，让我们转向重点，看看如何从 SQL 和 NoSQL 数据库中读取和写入数据。
- en: SQL
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL
- en: For interacting with an SQL database, SQLAlchemy is the most popular and, in
    my opinion, best Python library. It allows you to use raw SQL instructions if
    speed and efficiency is an issue, but also provides a powerful object-relational
    mapping (ORM) that allows you to operate on SQL tables using a high-level, Pythonic
    API, treating them essentially as Python classes.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于与 SQL 数据库交互，SQLAlchemy 是最流行且在我看来是最好的 Python 库。它允许您在速度和效率是问题的情况下使用原始 SQL 指令，同时提供一个强大的对象关系映射（ORM），使您能够使用高级、Pythonic
    API 操作 SQL 表，本质上将其视为 Python 类。
- en: 'Reading and writing data using SQL while allowing the user to treat that data
    as a Python container is a complicated process, and though SQLAlchemy is considerably
    more user-friendly than a low-level SQL engine, it is still a fairly complex library.
    I’ll cover the basics here, using our data as a target, but encourage you to spend
    a little time reading some of the rather excellent documentation on [SQLAlchemy](https://oreil.ly/mCHr8).
    Let’s remind ourselves of the `nobel_winners` dataset we’re aiming to write and
    read:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SQL 进行数据读取和写入，同时允许用户将这些数据视为 Python 容器是一个复杂的过程，尽管 SQLAlchemy 比低级 SQL 引擎更加用户友好，但它仍然是一个相当复杂的库。我将在这里介绍基础知识，以我们的数据作为目标，但建议您花点时间阅读关于
    [SQLAlchemy](https://oreil.ly/mCHr8) 的出色文档。让我们先回顾一下我们打算读取和写入的 `nobel_winners`
    数据集：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let’s first write our target data to an SQLite file using SQLAlchemy, starting
    by creating the database engine.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用 SQLAlchemy 将目标数据写入 SQLite 文件，开始创建数据库引擎。
- en: Creating the Database Engine
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数据库引擎
- en: The first thing you need to do when starting an SQLAlchemy session is to create
    a database engine. This engine will establish a connection with the database in
    question and perform any conversions needed to the generic SQL instructions generated
    by SQLAlchemy and the data being returned.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始 SQLAlchemy 会话时，第一件事是创建一个数据库引擎。该引擎将与所需的数据库建立连接，并对SQLAlchemy生成的通用SQL指令和返回的数据执行任何所需的转换。
- en: There are engines for pretty much every popular database, as well as a *memory*
    option, which holds the database in RAM, allowing fast access for testing.^([3](ch03.xhtml#idm45607796976800))
    The great thing about these engines is that they are interchangeable, which means
    you could develop your code using the convenient file-based SQLite database and
    then switch during production to something a little more industrial, such as PostgreSQL,
    by changing a single config string. Check [SQLAlchemy](https://oreil.ly/QmIj6)
    for the full list of engines available.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每种流行的数据库都有相应的引擎，还有一个 *memory* 选项，将数据库保存在 RAM 中，用于快速访问测试。^([3](ch03.xhtml#idm45607796976800))
    这些引擎的伟大之处在于它们是可互换的，这意味着您可以使用方便的基于文件的 SQLite 数据库开发代码，然后通过更改单个配置字符串在生产环境中切换到一些更工业化的选项，如
    PostgreSQL。请查看 [SQLAlchemy](https://oreil.ly/QmIj6) 获取可用引擎的完整列表。
- en: 'The form for specifying a database URL is:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 指定数据库 URL 的格式如下：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: So, to connect to a `'nobel_winners'` MySQL database running on localhost requires
    something like the following. Note that `create_engine` does not actually make
    any SQL requests at this point, but merely sets up the framework for doing so:^([4](ch03.xhtml#idm45607796966400))
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要连接到运行在本地主机上的 `'nobel_winners'` MySQL 数据库，需要类似以下方式。请注意，在此时 `create_engine`
    并没有真正发出任何 SQL 请求，而只是为执行这些请求设置了框架:^([4](ch03.xhtml#idm45607796966400))
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We’ll use a file-based SQLite database, setting the `echo` argument to `True`,
    which will output any SQL instructions generated by SQLAlchemy. Note the use of
    three backslashes after the colon:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用基于文件的 SQLite 数据库，并将 `echo` 参数设置为 `True`，这样 SQLAlchemy 生成的任何 SQL 指令都会输出。请注意冒号后面的三个反斜杠的用法：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: SQLAlchemy offers various ways to engage with databases, but I recommend using
    the more recent declarative style unless there are good reasons to go with something
    more low-level and fine-grained. In essence, with declarative mapping, you subclass
    your Python SQL-table classes from a base, and SQLAlchemy introspects their structure
    and relationships. See [SQLAlchemy](https://oreil.ly/q3IZf) for more details.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 提供了多种与数据库交互的方式，但我建议使用更近代的声明式风格，除非有充分理由选择更低级和细粒度的方法。本质上，使用声明式映射，您可以从一个基类子类化您的
    Python SQL 表类，并让 SQLAlchemy 自动检查它们的结构和关系。详细信息请参阅 [SQLAlchemy](https://oreil.ly/q3IZf)。
- en: Defining the Database Tables
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义数据库表
- en: 'We first create a `Base` class using `declarative_base`. This base will be
    used to create table classes, from which SQLAlchemy will create the database’s
    table schemas. You can use these table classes to interact with the database in
    a fairly Pythonic fashion:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用 `declarative_base` 创建一个 `Base` 类。这个基类将用于创建表类，从而让 SQLAlchemy 创建数据库的表结构。您可以使用这些表类以相当
    Pythonic 的方式与数据库交互：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note that most SQL libraries require you to formally define table schemas. This
    is in contrast to such schema-less NoSQL variants as MongoDB. We’ll take a look
    at the Dataset library later in this chapter, which enables schemaless SQL.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，大多数 SQL 库要求您正式定义表结构。这与无模式 NoSQL 变体如 MongoDB 相反。本章后面我们将看到 Dataset 库，它支持无模式
    SQL。
- en: Using this `Base`, we define our various tables—in our case, a single `Winner`
    table. [Example 3-3](#data_sql_base) shows how to subclass `Base` and use SQLAlchemy’s
    datatypes to define a table schema. Note the `__tablename__` member, which will
    be used to name the SQL table and as a keyword to retrieve it, and the optional
    custom `__repr__` method, which will be used when printing a table row.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个 `Base`，我们定义我们的各种表，例如我们的单个 `Winner` 表。[示例 3-3](#data_sql_base) 展示了如何子类化
    `Base` 并使用 SQLAlchemy 的数据类型来定义表结构。请注意 `__tablename__` 成员，它将用于命名 SQL 表和作为检索它的关键字，还有可选的自定义
    `__repr__` 方法，用于在打印表行时使用。
- en: Example 3-3\. Defining an SQL database table
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-3\. 定义 SQL 数据库表
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Having declared our `Base` subclass in [Example 3-3](#data_sql_base), we supply
    its `metadata` `create_all` method with our database engine to create our database.^([5](ch03.xhtml#idm45607796702064))
    Because we set the `echo` argument to `True` when creating the engine, we can
    see the SQL instructions generated by SQLAlchemy from the command line:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 3-3](#data_sql_base) 中声明了我们的 `Base` 子类后，我们使用其 `metadata` 的 `create_all`
    方法和我们的数据库引擎来创建我们的数据库。因为在创建引擎时设置了 `echo` 参数为 `True`，所以我们可以从命令行看到 SQLAlchemy 生成的
    SQL 指令：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With our new `winners` table declared, we can start adding winner instances
    to it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们新声明的 `winners` 表，我们可以开始向其中添加获奖者实例。
- en: Adding Instances with a Session
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用会话添加实例
- en: 'Now that we have created our database, we need a session to interact with:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的数据库，我们需要一个会话来进行交互：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can now use our `Winner` class to create instances and table rows and add
    them to the session:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用我们的 `Winner` 类创建实例和表行，并将它们添加到会话中：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[![1](assets/1.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO8-1)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO8-1)'
- en: 'Python’s handy ** operator unpacks our first `nobel_winners` member into key-value
    pairs: `(name=''Albert Einstein'', category=''Physics''...)`.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的便捷 ** 操作符将我们的第一个 `nobel_winners` 成员解包为键值对：`(name='Albert Einstein',
    category='Physics'...)`。
- en: '[![2](assets/2.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO8-2)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO8-2)'
- en: '`new` is the set of any items that have been added to this session.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`new` 是任何已添加到此会话中的项目的集合。'
- en: Note that all database insertions and deletions take place in Python. It’s only
    when we use the `commit` method that the database is altered.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意所有的数据库插入和删除都是在 Python 中进行的。只有当我们使用 `commit` 方法时，数据库才会被修改。
- en: Tip
  id: totrans-141
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Use as few commits as possible, allowing SQLAlchemy to work its magic behind
    the scenes. When you commit, your various database manipulations should be summarized
    by SQLAlchemy and communicated in an efficient fashion. Commits involve establishing
    a database handshake and negotiating transactions, which is often a slow process
    and one you want to limit as much as possible, leveraging SQLAlchemy’s bookkeeping
    abilities to full advantage.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能少地提交，允许 SQLAlchemy 在后台完成其工作。当您提交时，SQLAlchemy 应该将您的各种数据库操作总结起来，并以高效的方式进行通信。提交涉及建立数据库握手和协商事务，这通常是一个缓慢的过程，您应尽可能地限制提交，充分利用
    SQLAlchemy 的簿记能力。
- en: 'As the `new` method shows, we have added a `Winner` to the session. We can
    remove the object using `expunge`, leaving an empty `IdentitySet`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如 `new` 方法所示，我们已将一个 `Winner` 添加到会话中。我们可以使用 `expunge` 移除对象，留下一个空的 `IdentitySet`：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[![1](assets/1.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO9-1)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO9-1)'
- en: Removes the instance from the session (there is an `expunge_all` method that
    removes all new objects added to the session).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从会话中移除实例（还有一个 `expunge_all` 方法，用于移除会话中添加的所有新对象）。
- en: 'At this point, no database insertions or deletions have taken place. Let’s
    add all the members of our `nobel_winners` list to the session and commit them
    to the database:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，还没有进行任何数据库插入或删除操作。让我们将我们的 `nobel_winners` 列表中的所有成员添加到会话并提交到数据库：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now that we’ve committed our `nobel_winners` data to the database, let’s see
    what we can do with it and how to re-create the target list in [Example 3-1](#data_dummydata).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已将我们的 `nobel_winners` 数据提交到数据库，让我们看看我们可以用它做些什么以及如何在 [Example 3-1](#data_dummydata)
    中重新创建目标列表。
- en: Querying the Database
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询数据库
- en: To access data, you use the `session`’s `query` method, the result of which
    can be filtered, grouped, and intersected, allowing the full range of standard
    SQL data retrieval. You can check out available querying methods in the [SQLAlchemy
    docs](https://oreil.ly/2rEB4). For now, I’ll quickly run through some of the most
    common queries on our Nobel dataset.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问数据，您可以使用 `session` 的 `query` 方法，其结果可以进行过滤、分组和交集操作，允许完整范围的标准 SQL 数据检索。您可以在
    [SQLAlchemy 文档](https://oreil.ly/2rEB4) 中查看可用的查询方法。现在，让我快速浏览一下我们诺贝尔数据集上一些最常见的查询。
- en: 'Let’s first count the number of rows in our winners table:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先计算一下我们获奖者表中的行数：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, let’s retrieve all Swiss winners:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们检索所有瑞士获奖者：
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[![1](assets/1.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO10-1)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO10-1)'
- en: '`filter_by` uses keyword expressions; its SQL expressions counterpart is `filter`—for
    example, `filter(Winner.nationality == *Swiss*)`. Note the Boolean equivalence
    `==` used in `filter`.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter_by` 使用关键字表达式；它的 SQL 表达式对应物是 `filter` ——例如，`filter(Winner.nationality
    == *Swiss*)`。请注意在 `filter` 中使用的布尔等价 `==`。'
- en: 'Now let’s get all non-Swiss physics winners:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们获取所有非瑞士物理学获奖者：
- en: '[PRE34]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here’s how to get a row based on ID number:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 ID 号获取行的方法如下：
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now let’s retrieve winners ordered by year:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们按年份排序获取获奖者：
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: To reconstruct our target list requires a little effort when converting the
    `Winner` objects returned by our session query into Python `dict`s. Let’s write
    a little function to create a `dict` from an SQLAlchemy class. We’ll use a little
    table introspection to get the column labels (see [Example 3-4](#data_to_dict)).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过会话查询返回的 `Winner` 对象转换为 Python `dict` 时，重建我们的目标列表需要一些努力。让我们写一个小函数来创建一个从
    SQLAlchemy 类到 `dict` 的映射。我们将使用一些表内省来获取列标签（参见 [Example 3-4](#data_to_dict)）。
- en: Example 3-4\. Converts an SQLAlchemy instance to a `dict`
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 3-4\. 将 SQLAlchemy 实例转换为 `dict`
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[![1](assets/1.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO11-1)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO11-1)'
- en: Accesses the instance’s table class to get a list of column objects.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 访问实例的表类以获取列对象的列表。
- en: '[![2](assets/2.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO11-2)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO11-2)'
- en: If `delete_id` is true, remove the SQL primary ID field.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `delete_id` 为 true，则删除 SQL 主 ID 字段。
- en: 'We can use [Example 3-4](#data_to_dict) to reconstruct our `nobel_winners`
    target list:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 [示例 3-4](#data_to_dict) 重建我们的 `nobel_winners` 目标列表：
- en: '[PRE38]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You can update database rows easily by changing the property of their reflected
    objects:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过更改其反映对象的属性轻松更新数据库行：
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[![1](assets/1.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO12-1)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO12-1)'
- en: Fetches Marie Curie, nationality Polish.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 获取 Marie Curie，国籍为波兰。
- en: '[![2](assets/2.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO12-2)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO12-2)'
- en: '`dirty` shows any changed instances not yet committed to the database.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`dirty` 显示尚未提交到数据库的任何已更改实例。'
- en: 'Let’s commit `Marie`’s changes and check that her nationality has changed from
    Polish to French:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们提交 `Marie` 的更改，并检查她的国籍是否从波兰变为法国：
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In addition to updating database rows, you can delete the results of a query:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更新数据库行外，你还可以删除查询结果：
- en: '[PRE41]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can also drop the whole table if required, using the declarative class’s
    `__table__` attribute:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，你也可以使用声明类的 `__table__` 属性删除整个表：
- en: '[PRE42]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this section, we’ve dealt with a single winners table, without any foreign
    keys or relationship to any other tables, akin to a CSV or JSON file. SQLAlchemy
    adds the same level of convenience in dealing with many-to-one, one-to-many, and
    other database table relationships as it does to basic querying using implicit
    joins, by supplying the `query` method with more than one table class or explicitly
    using the query’s `join` method. Check out the examples [in the SQLAlchemy docs](https://oreil.ly/6KFCf)
    for more details.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们处理了一个单独的获奖者表，没有任何外键或与其他表的关系，类似于 CSV 或 JSON 文件。SQLAlchemy 提供了相同的方便程度，用于处理多对一、一对多和其他数据库表关系，就像处理使用隐式连接进行基本查询一样，通过为查询提供多个表类或显式使用查询的
    `join` 方法。请查看 SQLAlchemy 文档中的示例以获取更多详细信息。
- en: Easier SQL with Dataset
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Dataset 更轻松的 SQL
- en: One library I’ve found myself using a fair deal recently is [Dataset](https://oreil.ly/aGqTL),
    a module designed to make working with SQL databases a little easier and more
    Pythonic than existing powerhouses like SQLAlchemy.^([6](ch03.xhtml#idm45607795314160))
    Dataset tries to provide the same degree of convenience you get when working with
    schema-less NoSQL databases such as MongoDB by removing a lot of the formal boilerplate,
    such as schema definitions, which are demanded by the more conventional libraries.
    Dataset is built on top of SQLAlchemy, which means it works with pretty much all
    major databases and can exploit the power, robustness, and maturity of that best-of-breed
    library. Let’s see how it deals with reading and writing our target dataset (from
    [Example 3-1](#data_dummydata)).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我最近发现自己经常使用的一个库是 [Dataset](https://oreil.ly/aGqTL)，这是一个设计用于使与 SQL 数据库的交互比现有的强大工具如
    SQLAlchemy 更容易和更符合 Python 风格的模块。 Dataset 尝试提供与无模式 NoSQL 数据库（如 MongoDB）工作时获得的便利程度相同，通过移除许多更传统库要求的形式化样板代码，比如模式定义。Dataset
    建立在 SQLAlchemy 之上，这意味着它可以与几乎所有主要数据库一起工作，并且可以利用该领域最佳的库的功能、健壮性和成熟性。让我们看看它如何处理读取和写入我们的目标数据集（来自
    [示例 3-1](#data_dummydata)）。
- en: 'Let’s use the SQLite *nobel_winners.db* database we’ve just created to put
    Dataset through its paces. First, we connect to our SQL database, using the same
    URL/file format as SQLAlchemy:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用刚刚创建的 SQLite *nobel_winners.db* 数据库来测试 Dataset 的功能。首先，我们连接到我们的 SQL 数据库，使用与
    SQLAlchemy 相同的 URL/文件格式：
- en: '[PRE43]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To get our list of winners, we grab a table from our `db` database, using its
    name as a key, and then use the `find` method without arguments to return all
    winners:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取我们的获奖者列表，我们从我们的 `db` 数据库中获取一个表，使用其名称作为键，然后使用不带参数的 `find` 方法返回所有获奖者：
- en: '[PRE44]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note that the instances returned by Dataset’s `find` method are `OrderedDict`s.
    These useful containers are an extension of Python’s `dict` class and behave just
    like dictionaries except that they remember the order in which items were inserted,
    meaning you can guarantee the result of iteration, pop the last item inserted,
    and more. This is a very handy additional functionality.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Dataset 的 `find` 方法返回的实例是 `OrderedDict`。这些有用的容器扩展了 Python 的 `dict` 类，并且行为类似于字典，只是它们记住了插入项的顺序，这意味着你可以保证迭代的结果，弹出最后插入的项等操作。这是一个非常方便的附加功能。
- en: Tip
  id: totrans-193
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: One of the most useful Python “batteries” for data manipulators is `collections`,
    which is where Dataset’s `OrderedDict`s come from. The `defaultdict` and `Counter`
    classes are particularly useful. Check out what’s available in the [Python docs](https://oreil.ly/Vh4EF).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据处理者来说，最有用的Python“内置工具”之一是`collections`，其中包括数据集的`OrderedDict`。`defaultdict`和`Counter`类特别有用。请查看[Python文档](https://oreil.ly/Vh4EF)中提供的内容。
- en: 'Let’s re-create our winners table with Dataset, first dropping the existing
    one:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Dataset重新创建我们的获奖者表，首先删除现有表：
- en: '[PRE45]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: To re-create our dropped winners table, we don’t need to define a schema as
    with SQLAlchemy (see [“Defining the Database Tables”](#sql_schema)). Dataset will
    infer that from the data we add, doing all the SQL creation implicitly. This is
    the kind of convenience one is used to when working with collection-based NoSQL
    databases. Let’s use our `nobel_winners` dataset ([Example 3-1](#data_dummydata))
    to insert some winner dictionaries. We use a database transaction and the `with`
    statement to efficiently insert our objects and then commit them:^([7](ch03.xhtml#idm45607795163536))
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要重新创建我们删除的获奖者表，我们不需要像SQLAlchemy那样定义模式（请参阅[“定义数据库表”](#sql_schema)）。Dataset将从我们添加的数据中推断出模式，并隐式执行所有SQL创建。这是在使用基于集合的NoSQL数据库时所习惯的方便之一。让我们使用我们的`nobel_winners`数据集（[示例 3-1](#data_dummydata)）来插入一些获奖者字典。我们使用数据库事务和`with`语句来高效地插入对象，然后提交它们：^([7](ch03.xhtml#idm45607795163536))
- en: '[PRE46]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[![1](assets/1.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO13-1)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO13-1)'
- en: Use the `with` statement to guarantee the transaction `tx` is committed to the
    database.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`with`语句确保事务`tx`提交到数据库。
- en: 'Let’s check that everything has gone well:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一切是否顺利进行：
- en: '[PRE47]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The winners have been correctly inserted and their order of insertion preserved
    by the `OrderedDict`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 获奖者已经被正确插入，并且它们的插入顺序被`OrderedDict`保留。
- en: Dataset is great for basic SQL-based work, particularly retrieving data you
    might wish to process or visualize. For more advanced manipulation, it allows
    you to drop down into SQLAlchemy’s core API using the `query` method.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集非常适合基于SQL的基本工作，特别是检索您可能希望处理或可视化的数据。对于更高级的操作，它允许您使用`query`方法进入SQLAlchemy的核心API。
- en: Now that we’ve covered the basics of working with SQL databases, let’s see how
    Python makes working with the most popular NoSQL database just as painless.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了使用SQL数据库的基础知识，让我们看看Python如何使得与最流行的NoSQL数据库一样轻松。
- en: MongoDB
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB
- en: Document-centric datastores like MongoDB offer a lot of convenience to data
    wranglers. As with all tools, there are good and bad use cases for NoSQL databases.
    If you have data that has already been refined and processed and don’t anticipate
    needing SQL’s powerful query language based on optimized table joins, MongoDB
    will probably prove easier to work with initially. MongoDB is a particularly good
    fit for web dataviz because it uses binary JSON (BSON) as its data format. An
    extension of JSON, BSON can deal with binary data and `datetime` objects, and
    plays very nicely with JavaScript.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 像MongoDB这样以文档为中心的数据存储为数据处理者提供了很多便利。与所有工具一样，NoSQL数据库有好的和坏的用例。如果您的数据已经经过精炼和处理，并且不预期需要基于优化表连接的SQL强大查询语言，那么MongoDB可能最初会更容易使用。MongoDB非常适合Web数据可视化，因为它使用二进制JSON（BSON）作为其数据格式。BSON是JSON的扩展，可以处理二进制数据和`datetime`对象，并且与JavaScript非常兼容。
- en: 'Let’s remind ourselves of the target dataset we’re aiming to write and read:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次回顾一下我们要写入和读取的目标数据集：
- en: '[PRE48]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Creating a MongoDB collection with Python is the work of a few lines:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python创建MongoDB集合只需几行代码：
- en: '[PRE49]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[![1](assets/1.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO14-1)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO14-1)'
- en: Creates a Mongo client, using the default host and ports.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Mongo客户端，使用默认主机和端口。
- en: '[![2](assets/2.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO14-2)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO14-2)'
- en: Creates or accesses the `nobel_prize` database.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 创建或访问`nobel_prize`数据库。
- en: '[![3](assets/3.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO14-3)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO14-3)'
- en: If a winners collection exists, this will retrieve it; otherwise (as in our
    case), it creates it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果获奖者集合存在，则将其检索出来；否则（如我们的情况），它会创建它。
- en: MongoDB databases run on localhost port 27017 by default but could be anywhere
    on the web. They also take an optional username and password. [Example 3-5](#data_get_mongo)
    shows how to create a simple utility function to access our database, with standard
    defaults.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 数据库默认在本地主机端口 27017 上运行，但也可能在网络上的任何地方。它们还可以使用可选的用户名和密码。[示例 3-5](#data_get_mongo)展示了如何创建一个简单的实用函数来访问我们的数据库，使用标准默认值。
- en: Example 3-5\. Accessing a MongoDB database
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-5\. 访问 MongoDB 数据库
- en: '[PRE50]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[![1](assets/1.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO15-1)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO15-1)'
- en: We specify the database name in the MongoDB URI (Uniform Resource Identifier)
    as the user may not have general privileges for the database.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 MongoDB URI（统一资源标识符）中指定数据库名称，因为用户可能没有对数据库的通用权限。
- en: 'We can now create a Nobel Prize database and add our target dataset ([Example 3-1](#data_dummydata)).
    Let’s first get a winners collection, using the string constants for access:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个诺贝尔奖数据库并添加我们的目标数据集（[示例 3-1](#data_dummydata)）。让我们首先获取一个获奖者集合，使用访问的字符串常量：
- en: '[PRE51]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Inserting our Nobel Prize dataset is then as easy as can be:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 插入我们的诺贝尔奖数据集就像变得如此容易：
- en: '[PRE52]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The resulting array of `ObjectId`s can be used for future retrieval, but MongoDB
    has already left its stamp on our `nobel_winners` list, adding a hidden `id` property.^([8](ch03.xhtml#idm45607794582448))
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 结果数组的`ObjectId`可以用于将来的检索，但 MongoDB 已经在我们的`nobel_winners`列表上留下了自己的印记，添加了一个隐藏的`id`属性。^([8](ch03.xhtml#idm45607794582448))
- en: Tip
  id: totrans-228
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'MongoDB’s `ObjectId`s have quite a bit of hidden functionality, being a lot
    more than a simple random identifier. You can, for example, get the generation
    time of the `ObjectId`, which gives you access to a handy timestamp:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 的`ObjectId`具有相当多的隐藏功能，不仅仅是一个简单的随机标识符。例如，您可以获取`ObjectId`的生成时间，这使您可以访问一个方便的时间戳：
- en: '[PRE53]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Find the full details in the [MongoDB BSON documentation](https://oreil.ly/NBwsk).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在[MongoDB BSON 文档](https://oreil.ly/NBwsk)中找到完整的详细信息。
- en: 'Now that we’ve got some items in our winners collection, MongoDB makes finding
    them very easy, with its `find` method taking a dictionary query:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在我们的获奖者集合中有了一些项目，使用它的`find`方法非常容易找到它们，使用一个字典查询：
- en: '[PRE54]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'There are a number of special dollar-prefixed operators that allow for sophisticated
    querying. Let’s find all the winners after 1930 using the `$gt` (greater-than)
    operator:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多特殊的以美元为前缀的运算符，允许进行复杂的查询。让我们使用`$gt`（大于）运算符找到 1930 年后的所有获奖者：
- en: '[PRE55]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You can also use a Boolean expression, for instance, to find all winners after
    1930 or all female winners:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用布尔表达式，例如，查找所有 1930 年后的获奖者或所有女性获奖者：
- en: '[PRE56]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: You can find the full list of available query expressions in the [MongoDB documentation](https://oreil.ly/1D2Sr).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[MongoDB 文档](https://oreil.ly/1D2Sr)中找到可用查询表达式的完整列表。
- en: 'As a final test, let’s turn our new winners collection back into a Python list
    of dictionaries. We’ll create a utility function for the task:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最终测试，让我们将我们的新获奖者集合转换回 Python 字典列表。我们将为此创建一个实用函数：
- en: '[PRE57]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[![1](assets/1.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO16-1)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_reading_and_writing_data__span_class__keep_together__with_python__span__CO16-1)'
- en: An empty `query dict {}` will find all documents in the collection. `del_id`
    is a flag to remove MongoDB’s `ObjectId`s from the items by default.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 一个空的`查询字典 {}`将在集合中找到所有文档。`del_id`是一个删除默认情况下项目中的 MongoDB`ObjectId`的标志。
- en: 'We can now create our target dataset:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建我们的目标数据集：
- en: '[PRE58]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: MongoDB’s schema-less databases are great for fast prototyping in solo work
    or small teams. There will probably come a point, particularly with large codebases,
    when a formal schema becomes a useful reference and sanity check; when you are
    choosing a data model, the ease with which document forms can be adapted is a
    bonus. Being able to pass Python dictionaries as queries to PyMongo and having
    access to client-side generated `ObjectId`s are a couple of other conveniences.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 的无模式数据库非常适合独自工作或小团队快速原型设计。可能会到达一个点，尤其是对于大型代码库，当正式模式成为一个有用的参考和理智检查时；在选择数据模型时，文档形式可以轻松适应的便利是一个优点。能够将
    Python 字典作为查询传递给 PyMongo 并且可以访问客户端生成的`ObjectId`是其他一些便利的例子。
- en: We’ve now passed the `nobel_winners` data in [Example 3-1](#data_dummydata)
    through all our required file formats and databases. Let’s consider the special
    case of dealing with dates and times before summing up.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经通过所有必需的文件格式和数据库传递了[示例 3-1](#data_dummydata)中的`nobel_winners`数据。让我们考虑处理日期和时间之前的特殊情况。
- en: Dealing with Dates, Times, and Complex Data
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理日期、时间和复杂数据
- en: 'The ability to deal comfortably with dates and times is fundamental to dataviz
    work but can be quite tricky. There are many ways to represent a date or datetime
    as a string, each one requiring a separate encoding or decoding. For this reason
    it’s good to settle on one format in your own work and encourage others to do
    the same. I recommend using the [International Standard Organization (ISO) 8601
    time format](https://oreil.ly/HePpN) as your string representation for dates and
    times, and using the [Coordinated Universal Time (UTC) form](https://oreil.ly/neP2I).^([9](ch03.xhtml#idm45607794006016))
    Here are a few examples of ISO 8601 date and datetime strings:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 舒适地处理日期和时间是数据可视化工作的基础，但可能会相当棘手。有许多方法可以将日期或日期时间表示为字符串，每种方法都需要单独的编码或解码。因此，在自己的工作中选择一个格式并鼓励其他人也这样做是很好的。我建议使用
    [国际标准化组织（ISO）8601 时间格式](https://oreil.ly/HePpN) 作为你的日期和时间的字符串表示，并使用 [协调世界时（UTC）形式](https://oreil.ly/neP2I)。^([9](ch03.xhtml#idm45607794006016))
    以下是几个 ISO 8601 日期和日期时间字符串的示例：
- en: '| 2021-09-23 | A date (Python/C format code `''%Y-%m-%d''`) |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| 2021-09-23 | 日期（Python/C 格式代码 `''%Y-%m-%d''`） |'
- en: '| 2021-09-23T16:32:35Z | A UTC (*Z* after time) date and time (`''T%H:%M:%S''`)
    |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| 2021-09-23T16:32:35Z | 一个 UTC（时间后加上 *Z*）日期和时间（`''T%H:%M:%S''`） |'
- en: '| 2021-09-23T16:32+02:00 | A positive two-hour (+02:00) offset from UTC (e.g.,
    Central European Time) |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| 2021-09-23T16:32+02:00 | 与协调世界时（UTC）相比为正两小时的时区偏移量（+02:00）（例如，中欧时间） |'
- en: Note the importance of being prepared to deal with different time zones. These
    are not always on lines of longitude (see [Wikipedia’s Time Zone entry](https://oreil.ly/NZyE4)),
    and often the best way to derive an accurate time is by using UTC time plus a
    geographic location.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意准备处理不同时区的重要性。时区并不总是在经线上（参见 [维基百科的时区条目](https://oreil.ly/NZyE4)），而通常推导出准确的时间的最佳方式是使用
    UTC 时间加上地理位置。
- en: ISO 8601 is the standard used by JavaScript and is easy to work with in Python.
    As web data visualizers, our key concern is in creating a string representation
    that can be passed between Python and JavaScript using JSON and encoded and decoded
    easily at both ends.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ISO 8601 是 JavaScript 使用的标准，也很容易在 Python 中使用。作为网络数据可视化者，我们的主要关注点是创建一个字符串表示，该表示可以在
    Python 和 JavaScript 之间通过 JSON 传递，并在两端轻松地编码和解码。
- en: Let’s take a date and time in the shape of a Python `datetime`, convert it into
    a string, and then see how that string can be consumed by JavaScript.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个 Python `datetime` 的形式取一个日期和时间，将其转换为字符串，然后看看该字符串如何被 JavaScript 使用。
- en: 'First, we produce our Python `datetime`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们生成我们的 Python `datetime`：
- en: '[PRE59]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This string can then be saved to JSON or CSV, read by JavaScript, and used
    to create a `Date` object:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这个字符串可以保存到 JSON 或 CSV 中，被 JavaScript 读取，并用于创建一个 `Date` 对象：
- en: '[PRE60]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We can return the datetime to ISO 8601 string form with the `toISOString` method:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `toISOString` 方法将日期时间返回为 ISO 8601 字符串形式：
- en: '[PRE61]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Finally, we can read the string back into Python.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将字符串读取回 Python。
- en: 'If you know that you’re dealing with an ISO-format time string, Python’s `dateutil`
    module should do the job.^([10](ch03.xhtml#idm45607793910272)) But you’ll probably
    want to sanity check the result:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道你正在处理的是 ISO 格式的时间字符串，Python 的 `dateutil` 模块应该可以胜任这个工作。^([10](ch03.xhtml#idm45607793910272))
    但你可能希望对结果进行一些合理性检查：
- en: '[PRE62]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Note that we’ve lost some resolution in the trip from Python to JavaScript and
    back again, the latter dealing in milliseconds, not microseconds. This is unlikely
    to be an issue in any dataviz work but is good to bear in mind just in case some
    strange temporal errors occur.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，从 Python 到 JavaScript 再返回时，我们丢失了一些分辨率，后者处理的是毫秒，而不是微秒。在任何数据可视化工作中，这不太可能成为问题，但需要记住，以防出现一些奇怪的时间错误。
- en: Summary
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter aimed to make you comfortable using Python to move data around
    the various file formats and databases that a data visualizer might expect to
    bump into. Using databases effectively and efficiently is a skill that takes a
    while to learn, but you should now be comfortable with basic reading and writing
    for the large majority of dataviz use cases.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在使您能够舒适地使用 Python 在各种文件格式和数据库之间传输数据，这是数据可视化者可能会遇到的。有效和高效地使用数据库是一个需要一段时间学习的技能，但现在您应该对大多数数据可视化用例的基本读写感到满意。
- en: Now that we have the vital lubrication for our dataviz toolchain, let’s get
    up to scratch on the basic web development skills you’ll need for the chapters
    ahead.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的数据可视化工具链提供了重要的润滑剂，让我们先快速掌握一下你在后面章节中所需的基本网络开发技能。
- en: ^([1](ch03.xhtml#idm45607798394048-marker)) I recommend using JSON over CSV
    as your preferred data format.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch03.xhtml#idm45607798394048-marker)) 我建议您将JSON作为首选数据格式，而不是CSV。
- en: ^([2](ch03.xhtml#idm45607797415616-marker)) The Python module `dateutil` has
    a parser that will parse most dates and times sensibly, and might be a good basis
    for this.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch03.xhtml#idm45607797415616-marker)) Python模块`dateutil`有一个解析器，可以合理地解析大多数日期和时间，可能是此操作的良好基础。
- en: ^([3](ch03.xhtml#idm45607796976800-marker)) On a cautionary note, it is probably
    a bad idea to use different database configurations for testing and production.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch03.xhtml#idm45607796976800-marker)) 值得注意的是，在测试和生产环境中使用不同的数据库配置可能是个坏主意。
- en: ^([4](ch03.xhtml#idm45607796966400-marker)) See details on [SQLAlchemy](https://oreil.ly/winYu)
    of this *lazy initialization*.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch03.xhtml#idm45607796966400-marker)) 查看关于[SQLAlchemy](https://oreil.ly/winYu)的详细信息，了解*延迟初始化*。
- en: ^([5](ch03.xhtml#idm45607796702064-marker)) This assumes the database doesn’t
    already exist. If it does, `Base` will be used to create new insertions and to
    interpret retrievals.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch03.xhtml#idm45607796702064-marker)) 这假设数据库尚不存在。如果存在，则将使用`Base`来创建新的插入和解释检索。
- en: '^([6](ch03.xhtml#idm45607795314160-marker)) Dataset’s official motto is “Databases
    for lazy people.” It is not part of the standard Anaconda package, so you’ll want
    to install it using `pip` from the command line: `$ pip install dataset`.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch03.xhtml#idm45607795314160-marker)) Dataset的官方座右铭是“懒人数据库”。它不是标准Anaconda包的一部分，因此您需要通过命令行使用`pip`进行安装：`$
    pip install dataset`。
- en: ^([7](ch03.xhtml#idm45607795163536-marker)) See [this documentation](https://oreil.ly/vqvbv)
    for further details of how to use transactions to group updates.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch03.xhtml#idm45607795163536-marker)) 详细了解如何使用事务来分组更新，请参阅[此文档](https://oreil.ly/vqvbv)。
- en: ^([8](ch03.xhtml#idm45607794582448-marker)) One of the cool things about MongoDB
    is that the `ObjectId`s are generated on the client side, removing the need to
    quiz the database for them.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch03.xhtml#idm45607794582448-marker)) MongoDB的一个很酷的特性是`ObjectId`在客户端生成，无需查询数据库获取它们。
- en: ^([9](ch03.xhtml#idm45607794006016-marker)) To get the actual local time from
    UTC, you can store a time zone offset or, better still, derive it from a geocoordinate;
    this is because time zones do not follow lines of longitude very exactly.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch03.xhtml#idm45607794006016-marker)) 要从UTC获取实际本地时间，可以存储时区偏移量或更好地从地理坐标派生；这是因为时区并不完全按经度线精确地遵循。
- en: ^([10](ch03.xhtml#idm45607793910272-marker)) To install, just run `pip install
    python-dateutil`. `dateutil` is a pretty powerful extension of Python’s `datetime`;
    check it out on [Read the Docs](https://oreil.ly/y6YWS).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch03.xhtml#idm45607793910272-marker)) 要安装，只需运行`pip install python-dateutil`。`dateutil`是Python的`datetime`的一个相当强大的扩展；详细信息请查看[Read
    the Docs](https://oreil.ly/y6YWS)。
