- en: Appendix C. NumPy crash course
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录C. NumPy快速入门
- en: The open source NumPy (Numerical Python) library is a dependency of pandas that
    exposes a powerful `ndarray` object for storing homogeneous, *n*-dimensional arrays.
    That’s quite a mouthful, so let’s break it down. An *array* is an ordered collection
    of values akin to a Python list. *Homogeneous* means that the values within the
    array are of the same data type. *N-dimensional* means that the array can hold
    any number of dimensions. (We’ll talk about dimensions in section C.1.) NumPy
    was developed by data scientist Travis Oliphant, who founded Anaconda, the company
    that builds the Python distribution we used to set up our development environment.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 开源NumPy（数值Python）库是pandas的依赖项，它公开了一个强大的`ndarray`对象，用于存储同质、*n*-维数组。这听起来有点复杂，所以让我们分解一下。*数组*是有序值集合，类似于Python列表。*同质*意味着数组中的值具有相同的数据类型。*n*-维意味着数组可以持有任意数量的维度。（我们将在C.1节中讨论维度。）NumPy是由数据科学家Travis
    Oliphant开发的，他创立了Anaconda公司，该公司构建了我们用来设置开发环境的Python发行版。
- en: We can use NumPy to generate randomized data sets of any size and shape; in
    fact, the official pandas documentation does so extensively. Basic knowledge of
    the library will help enhance our understanding of the underlying mechanics of
    pandas.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用NumPy生成任何大小和形状的随机数据集；事实上，官方的pandas文档广泛地这样做。对库的基本了解将有助于我们更好地理解pandas的底层机制。
- en: C.1 Dimensions
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.1 维度
- en: '*Dimensions* refers to the number of reference points needed to extract a single
    value from a data structure. Consider a collection of temperatures across several
    cities on a given day:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*维度*指的是从数据结构中提取单个值所需的参考点数量。考虑一个给定日期多个城市温度的集合：'
- en: '|  | Temperature |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|  | 温度 |'
- en: '| New York | 38 |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| 纽约 | 38 |'
- en: '| Chicago | 36 |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| 芝加哥 | 36 |'
- en: '| San Francisco | 51 |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| 旧金山 | 51 |'
- en: '| Miami | 73 |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| 迈阿密 | 73 |'
- en: 'If I asked you to find a specific temperature in this data set, you’d need
    only one point of reference: the city’s name (such as “San Francisco”) or its
    order (such as “the third city in the list”). Thus, the table depicts a one-dimensional
    data set.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我要求您在这个数据集中查找一个特定的温度，您只需要一个参考点：城市的名称（例如“旧金山”）或其顺序（例如“列表中的第三个城市”）。因此，这个表格描述了一个一维数据集。
- en: 'Compare that table with a data set of temperatures for multiple cities over
    multiple days:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 将此表与多个城市在多个日子温度的数据集进行比较：
- en: '|  | Monday | Tuesday | Wednesday | Thursday | Friday |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|  | 星期一 | 星期二 | 星期三 | 星期四 | 星期五 |'
- en: '| New York | 38 | 41 | 35 | 32 | 35 |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 纽约 | 38 | 41 | 35 | 32 | 35 |'
- en: '| Chicago | 36 | 39 | 31 | 27 | 25 |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 芝加哥 | 36 | 39 | 31 | 27 | 25 |'
- en: '| San Francisco | 51 | 52 | 50 | 49 | 53 |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 旧金山 | 51 | 52 | 50 | 49 | 53 |'
- en: '| Miami | 73 | 74 | 72 | 71 | 74 |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 迈阿密 | 73 | 74 | 72 | 71 | 74 |'
- en: How many points of reference do you need now to extract a specific value from
    this data set? The answer is 2\. We need a city and a day of the week (such as
    “San Francisco on Thursday”) or a row number and a column number (such as “row
    3 and column 4”). Neither the city nor the weekday is a sufficient identifier
    by itself, because each one associates with multiple values in the data set. The
    combination of a city and a weekday (or, equivalently, a row and a column) filters
    the results down to one value; thus, this data set is two-dimensional.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您需要多少个参考点才能从这个数据集中提取一个特定的值？答案是2。我们需要一个城市和一周中的某一天（例如“星期四的旧金山”）或行号和列号（例如“第3行第4列”）。城市或工作日本身不足以作为标识符，因为它们都与数据集中的多个值相关联。城市和工作日的组合（或等价的行和列）将结果过滤到一个值；因此，这个数据集是二维的。
- en: A data set’s number of rows and columns does not affect its number of dimensions.
    A table with 1 million rows and 1 million columns would still be two-dimensional.
    We would still need a combination of a row position and a column position to pull
    out a value.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集的行数和列数不影响其维度数。一个有100万行和100万列的表格仍然是二维的。我们仍然需要一个行位置和列位置的组合来提取一个值。
- en: 'Every additional point of reference adds another dimension. We might collect
    temperatures over two weeks:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每增加一个参考点，就增加一个维度。我们可能会收集两周的温度数据：
- en: Week 1
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第一周
- en: '|  | Monday | Tuesday | Wednesday | Thursday | Friday |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '|  | 星期一 | 星期二 | 星期三 | 星期四 | 星期五 |'
- en: '| New York | 38 | 41 | 35 | 32 | 35 |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 纽约 | 38 | 41 | 35 | 32 | 35 |'
- en: '| Chicago | 36 | 39 | 31 | 27 | 25 |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 芝加哥 | 36 | 39 | 31 | 27 | 25 |'
- en: '| San Francisco | 51 | 52 | 50 | 49 | 53 |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 旧金山 | 51 | 52 | 50 | 49 | 53 |'
- en: '| Miami | 73 | 74 | 72 | 71 | 74 |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 迈阿密 | 73 | 74 | 72 | 71 | 74 |'
- en: Week 2
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第二周
- en: '|  | Monday | Tuesday | Wednesday | Thursday | Friday |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '|  | 星期一 | 星期二 | 星期三 | 星期四 | 星期五 |'
- en: '| New York | 40 | 42 | 38 | 36 | 28 |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 纽约 | 40 | 42 | 38 | 36 | 28 |'
- en: '| Chicago | 32 | 28 | 25 | 31 | 25 |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 芝加哥 | 32 | 28 | 25 | 31 | 25 |'
- en: '| San Francisco | 49 | 55 | 54 | 51 | 48 |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 旧金山 | 49 | 55 | 54 | 51 | 48 |'
- en: '| Miami | 75 | 78 | 73 | 76 | 71 |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 迈阿密 | 75 | 78 | 73 | 76 | 71 |'
- en: The city and weekday are no longer sufficient to extract a single value. We
    now need three points of reference (Week, City, and Day), so we can classify this
    data set as being three-dimensional.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 城市和星期几已不再足够提取单个值。我们现在需要三个参考点（星期、城市和日期），因此我们可以将这个数据集分类为三维的。
- en: C.2 The ndarray object
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.2 ndarray对象
- en: 'Let’s begin by creating a new Jupyter Notebook and importing the NumPy library,
    which is typically assigned the alias `np`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个新的Jupyter Notebook并导入NumPy库，该库通常被分配别名`np`：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'NumPy excels at generating both random and nonrandom data. Let’s begin with
    a simple challenge: creating a sequential range of numbers.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy擅长生成随机和非随机数据。让我们从一项简单的挑战开始：创建一个连续的数字范围。
- en: C.2.1 Generating a numeric range with the arange method
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.2.1 使用arange方法生成数字范围
- en: 'The `arange` function returns a one-dimensional `ndarray` object with a range
    of sequential numeric values. When we invoke `arange` with one argument, NumPy
    will set `0` as the lower bound, the value at which the range begins. The first
    argument will set the upper bound, the number at which the range terminates. The
    upper bound is exclusive; NumPy will go up to that value but not include it. An
    argument of `3`, for example, will produce an `ndarray` holding the values `0`,
    `1`, and `2`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`arange`函数返回一个一维`ndarray`对象，包含一系列连续的数值。当我们用单个参数调用`arange`时，NumPy将`0`设置为下限，范围开始的位置。第一个参数将设置上限，范围结束的数字。上限是不包含的；NumPy将到达那个值但不包括它。例如，一个`3`的参数将产生一个包含值`0`、`1`和`2`的`ndarray`：'
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can also pass `arange` two arguments, which will declare the lower and upper
    bounds of the range. The lower bound is inclusive; the range will include its
    value. The endpoint remains exclusive. In the next example, notice that NumPy
    includes `2` but not `6`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以向`arange`传递两个参数，这将声明范围的上下限。下限是包含的；范围将包括其值。端点是不包含的。在下一个示例中，请注意NumPy包含`2`但不包含`6`：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The first two arguments to `arange` correspond to `start` and `stop` keyword
    parameters. We can write the keyword arguments out explicitly. The preceding and
    following code samples produce the same array:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`arange`的前两个参数对应于`start`和`stop`关键字参数。我们可以明确写出关键字参数。前面的和后面的代码示例产生相同的数组：'
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `arange` function’s optional third parameter, `step`, sets the interval
    between every two values. It helps to think about this concept mathematically.
    Start at the lower bound, and add the interval value until you reach the upper
    bound. The next example creates a range from `0` to `111` (exclusive) in gaps
    of 10:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`arange`函数的可选第三个参数`step`设置两个值之间的间隔。从数学的角度来考虑这个概念可能会有所帮助。从下限开始，并加上间隔值，直到达到上限。下一个示例创建一个从`0`到`111`（不包含）的间隔为10的范围：'
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let’s save that last `ndarray` to a tens variable:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将最后一个`ndarray`保存到`tens`变量中：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now the tens variable points to an `ndarray` object that holds 12 numbers.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`tens`变量指向一个包含12个数字的`ndarray`对象。
- en: C.2.2 Attributes on a ndarray object
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.2.2 ndarray对象上的属性
- en: The NumPy library’s `ndarray` object has its own set of attributes and methods.
    As a reminder, an *attribute* is a piece of data that belongs to an object. A
    *method* is a command we can send to an object.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy库的`ndarray`对象有一套自己的属性和方法。作为提醒，*属性*是属于对象的数据的一部分。*方法*是我们可以向对象发送的命令。
- en: 'The `shape` attribute returns a tuple with the array’s dimensions. The length
    of the `shape` tuple is equal to the `ndarray`’s number of dimensions. The following
    output communicates that `tens` is a one-dimensional array with 12 values:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`shape`属性返回一个元组，包含数组的维度。`shape`元组的长度等于`ndarray`的维度数。以下输出表明`tens`是一个包含12个值的一维数组：'
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can also ask for the `ndarray`’s number of dimensions with the `ndim` attribute:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`ndim`属性来询问`ndarray`的维度数：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `size` attribute returns the number of elements in the array:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`size`属性返回数组中的元素数量：'
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Next up, let’s see how we can manipulate the shape of the 12 elements in the
    array.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们如何可以操作数组中12个元素的形状。
- en: C.2.3 The reshape method
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.2.3 reshape方法
- en: 'Currently, our 12-element `tens` `ndarray` is one-dimensional. We can access
    any element with one reference point, its position in the array:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的12个元素的`tens` `ndarray`是一维的。我们可以通过一个参考点访问任何元素，即它在数组中的位置：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We may want to manipulate an existing one-dimensional array into a multidimensional
    one with a different shape. Let’s say that our 12 values represent a collection
    of 3 daily measurements captured across 4 days. It’s easier to think about the
    data in a 4 x 3 shape than in a 12 x 1 shape.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想要将现有的一个维度数组转换成具有不同形状的多维度数组。假设我们的 12 个值代表在 4 天内捕获的 3 次每日测量值。在 4 x 3 的形状中思考数据比在
    12 x 1 的形状中更容易。
- en: 'The `reshape` method uses its arguments to return a new `ndarray` object with
    a specified shape. The next example contorts `tens` into a new two-dimensional
    array with 4 rows and 3 columns:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`reshape` 方法使用其参数返回具有指定形状的新 `ndarray` 对象。下一个示例将 `tens` 变形为一个新的二维数组，具有 4 行 3
    列：'
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The number of arguments passed to `reshape` will equal the number of dimensions
    in the new `ndarray`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `reshape` 的参数数量将等于新 `ndarray` 的维度数：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We must ensure that the product of the arguments equals the number of elements
    within the original array. The values 4 and 3 are valid arguments because their
    product is 12, and `tens` has 12 values. Another valid example is a two-dimensional
    array with 2 rows and 6 columns:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保参数的乘积等于原始数组中的元素数量。值 4 和 3 是有效的参数，因为它们的乘积是 12，而 `tens` 有 12 个值。另一个有效示例是具有
    2 行 6 列的二维数组：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'NumPy raises a `ValueError` exception if it cannot contort the original array
    into the requested shape. In the next example, the library is unable to fit the
    12 values in `tens` into a 2 x 5 array:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 NumPy 无法将原始数组变形为所需的形状，则会引发 `ValueError` 异常。在下一个示例中，库无法将 `tens` 中的 12 个值拟合到
    2 x 5 的数组中：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Can an `ndarray` store more than two dimensions of data? Absolutely. Let’s
    provide a third argument to `reshape` to see it in action. The next example shapes
    the one-dimensional `tens` array into a three-dimensional array with a 2 x 3 x
    2 shape:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`ndarray` 能否存储超过两个维度的数据？当然可以。让我们通过传递第三个参数给 `reshape` 来看看它是如何工作的。下一个示例将一维的 `tens`
    数组形状调整为 2 x 3 x 2 的三维数组：'
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let’s access the `ndim` attribute on the new array. The data structure does
    indeed have three dimensions:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们访问新数组上的 `ndim` 属性。数据结构确实有三个维度：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can also pass an argument of `-1` to `reshape` to denote an unknown dimension.
    NumPy will infer the correct number of values to populate within that dimension.
    The next example passes arguments of `2` and `-1`. NumPy calculates that the new
    two-dimensional array should have a 2 x 6 shape:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以传递 `-1` 作为 `reshape` 的参数来表示一个未知维度。NumPy 将推断出在该维度中填充的正确值数。下一个示例传递了 `2` 和
    `-1` 作为参数。NumPy 计算出新的二维数组应该具有 2 x 6 的形状：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the next example, the library calculates that the returned `ndarray` should
    have a 2 x 3 x 2 shape:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，库计算返回的 `ndarray` 应该具有 2 x 3 x 2 的形状：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can pass only one unknown dimension into a `reshape` method invocation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能将一个未知维度传递给 `reshape` 方法调用。
- en: The `reshape` method returns a new `ndarray` object. The original array is not
    mutated. Thus, our `tens` array still has its original 1 x 12 shape.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`reshape` 方法返回一个新的 `ndarray` 对象。原始数组不会被修改。因此，我们的 `tens` 数组仍然保持其原始的 1 x 12 形状。'
- en: C.2.4 The randint function
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.2.4 `randint` 函数
- en: 'The `randint` function generates one or more random numbers between a range.
    When passed a single argument, it returns a random integer from `0` up to the
    value. The next example returns a random value between `0` and `5` (exclusive):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`randint` 函数生成一个或多个介于某个范围内的随机数。当传递单个参数时，它返回一个介于 `0` 到该值之间的随机整数。下一个示例返回一个介于
    `0` 和 `5`（不包括 `5`）之间的随机值：'
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can pass `randint` two arguments to declare an inclusive lower bound and
    an exclusive upper bound. NumPy will select a number from within the range:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向 `randint` 传递两个参数来声明一个包含下限（包括）和上限（不包括）的范围。NumPy 将在该范围内选择一个数字：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'What if we want to generate an array of random integers? We can pass a third
    argument to `randint` to specify the desired array shape. We can pass either a
    single integer or a one-element list to create a one-dimensional array:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要生成一个随机整数数组呢？我们可以传递第三个参数给 `randint` 来指定所需的数组形状。我们可以传递一个单个整数或一个单元素列表来创建一个一维数组：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To create a multidimensional `ndarray`, we pass a list specifying the number
    of values in each dimension. The following example populates a two-dimensional
    3 x 5 array of values between `1` and `10` (exclusive):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个多维 `ndarray`，我们传递一个列表来指定每个维度中的值数。以下示例填充了一个 3 x 5 的二维数组，其中的值介于 `1` 和 `10`（不包括
    `10`）之间：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can provide any number of values inside the list to create `ndarrays` with
    more dimensions. A list with three values, for example, will create a three-dimensional
    array.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在列表中提供任意数量的值来创建具有更多维度的 `ndarrays`。例如，一个包含三个值的列表将创建一个三维数组。
- en: C.2.5 The randn function
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.2.5 `randn` 函数
- en: 'The `randn` function returns an `ndarray` with random values from the standard
    normal distribution. Each sequential argument to the function sets the number
    of values to store in a dimension. If we pass one argument, the `ndarray` will
    have one dimension. The next example creates a 1 x 3 (1 row by 3 column) array:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`randn` 函数返回一个包含从标准正态分布中随机值的 `ndarray`。函数的每个连续参数设置一个维度中要存储的值的数量。如果我们传递一个参数，`ndarray`
    将有一个维度。下一个示例创建了一个 1 x 3（1 行 3 列）的数组：'
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If we pass two arguments to the `randn` function, the `ndarray` will have two
    dimensions, and so on. The next example creates a 2 x 4 two-dimensional array:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们向 `randn` 函数传递两个参数，`ndarray` 将有两个维度，依此类推。下一个示例创建了一个 2 x 4 的二维数组：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The next example creates a 3-dimensional array with a 2 x 4 x 3 shape. We can
    think of this shape as being two data sets, each with four rows and three columns:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例创建了一个形状为 2 x 4 x 3 的三维数组。我们可以将这个形状视为两个数据集，每个数据集都有四行和三列：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `rand` family of functions is a phenomenal way to generate fake numeric
    data. We can also create fake data of different types and categories such as names,
    addresses, or credit cards. For more on that topic, see appendix D.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`rand` 函数族是生成虚假数值数据的一个惊人的方法。我们还可以创建不同类型和类别的虚假数据，例如姓名、地址或信用卡。有关该主题的更多信息，请参阅附录
    D。'
- en: C.3 The nan object
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.3 `nan` 对象
- en: 'The NumPy library uses a special `nan` object to represent a missing or invalid
    value. The acronym `nan` is short for *not a number*, a generic catch-all term
    for missing data. We’ll be seeing `nan` frequently throughout the book as we import
    data sets with missing values into pandas. For now, we can access the `nan` object
    directly as a top-level attribute on the `np` package:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 库使用一个特殊的 `nan` 对象来表示缺失或无效的值。缩写 `nan` 代表 *not a number*，这是一个通用的通用术语，用于表示缺失数据。在我们将包含缺失值的数据集导入
    pandas 的过程中，本书中会频繁地遇到 `nan`。目前，我们可以直接通过 `np` 包的顶层属性访问 `nan` 对象：
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A `nan` object is not equal to any value:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `nan` 对象不等于任何值：
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: A `nan` value is also unequal to another `nan`. From NumPy’s perspective, `nan`
    values are missing or absent. We cannot say with certainty that they are the same,
    so we assume that they are different.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `nan` 值也不等于另一个 `nan`。从 NumPy 的角度来看，`nan` 值是缺失或缺失的。我们不能确定它们是否相同，所以我们假设它们是不同的。
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: And that’s it! Those are the most important details about the NumPy library,
    which pandas uses underneath its hood.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！这些是关于 NumPy 库最重要的细节，pandas 在其底层使用它。
- en: In your spare time, take a peek at the pandas documentation ([https://pandas.pydata.org/docs/user_guide/10min.html](https://pandas.pydata.org/docs/user_guide/10min.html)).
    You’ll likely see many examples that use NumPy to generate random data.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的空闲时间，浏览一下 pandas 文档（[https://pandas.pydata.org/docs/user_guide/10min.html](https://pandas.pydata.org/docs/user_guide/10min.html)）。你可能会看到许多使用
    NumPy 生成随机数据的示例。
