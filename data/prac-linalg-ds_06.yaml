- en: Chapter 6\. Matrices, Part 2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章\. 矩阵，第2部分
- en: Matrix multiplication is one of the most wonderful gifts that mathematicians
    have bestowed upon us. But to move from elementary to advanced linear algebra—and
    then to understand and develop data science algorithms—you need to do more than
    just multiply matrices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵乘法是数学家赋予我们的最美妙的礼物之一。但要从基础线性代数进阶到理解并开发数据科学算法，您需要做的不仅仅是进行矩阵乘法。
- en: We begin this chapter with discussions of matrix norms and matrix spaces. Matrix
    norms are essentially an extension of vector norms, and matrix spaces are essentially
    an extension of vector subspaces (which in turn are nothing more than linear weighted
    combinations). So you already have the necessary background knowledge for this
    chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从讨论矩阵范数和矩阵空间开始这一章。矩阵范数本质上是向量范数的延伸，而矩阵空间本质上是向量子空间的延伸（而向量子空间本质上仅仅是线性加权组合）。因此，您已经具备了本章所需的背景知识。
- en: Concepts like linear independence, rank, and determinant will allow you to transition
    from understanding elementary concepts like transpose and multiplication to understanding
    advanced topics like inverse, eigenvalues, and singular values. And those advanced
    topics unlock the power of linear algebra for applications in data science. Therefore,
    this chapter is a waypoint in your transformation from linear algebra newbie to
    linear algebra knowbie.^([1](ch06.xhtml#idm45733312155984))
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 线性无关性、秩和行列式等概念将使您能够从理解转置和乘法等基本概念过渡到理解像逆、特征值和奇异值等高级主题。这些高级主题为数据科学中线性代数的应用开启了新的篇章。因此，本章是您从线性代数新手向线性代数专家转变的一个关键过程。^([1](ch06.xhtml#idm45733312155984))
- en: Matrices seem like such simple things—just a spreadsheet of numbers. But you’ve
    already seen in the previous chapters that there is more to matrices than meets
    the eye. So, take a deep and calming breath and dive right in.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵看起来像是简单的东西——只是一堆数字的电子表格。但是在前几章中您已经看到矩阵远不止表面那么简单。所以，请深呼吸，放松心情，然后投入其中。
- en: Matrix Norms
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵范数
- en: 'You learned about vector norms in [Chapter 2](ch02.xhtml#Chapter_2): the norm
    of a vector is its Euclidean geometric length, which is computed as the square
    root of the sum of the squared vector elements.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 您在第2章([Chapter 2](ch02.xhtml#Chapter_2))学习了关于向量范数的知识：向量的范数是其欧几里得几何长度，计算方法是向量各元素平方和的平方根。
- en: Matrix norms are a little more complicated. For one thing, there is no “*the*
    matrix norm”; there are multiple distinct norms that can be computed from a matrix.
    Matrix norms are somewhat similar to vector norms in that each norm provides one
    number that characterizes a matrix, and that the norm is indicated using double-vertical
    lines, as in the norm of matrix <math alttext="bold upper A"><mi>𝐀</mi></math>
    is indicated as <math alttext="parallel-to bold upper A parallel-to"><mrow><mo>∥</mo>
    <mi>𝐀</mi> <mo>∥</mo></mrow></math> .
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵范数稍微复杂一些。首先，不存在“*the* 矩阵范数”；可以从矩阵计算多个不同的范数。矩阵范数与向量范数有些类似，每个范数提供一个数字来表征一个矩阵，使用双竖线表示，如矩阵
    <math alttext="bold upper A"><mi>𝐀</mi></math> 的范数表示为 <math alttext="parallel-to
    bold upper A parallel-to"><mrow><mo>∥</mo> <mi>𝐀</mi> <mo>∥</mo></mrow></math>。
- en: 'But different matrix norms have different meanings. The myriad of matrix norms
    can be broadly divided into two families: element-wise (also sometimes called
    entry-wise) and induced. Element-wise norms are computed based on the individual
    elements of the matrix, and thus these norms can be interpreted to reflect the
    magnitudes of the elements in the matrix.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的矩阵范数具有不同的含义。矩阵范数的多样性可以大致分为两类：逐元素（有时也称为入口方式）和诱导方式。逐元素范数基于矩阵的各个元素计算，因此这些范数可以用来反映矩阵中各元素的大小。
- en: 'Induced norms can be interpreted in the following way: one of the functions
    of a matrix is to encode a transformation of a vector; the induced norm of a matrix
    is a measure of how much that transformation scales (stretches or shrinks) that
    vector. This interpretation will make more sense in [Chapter 7](ch07.xhtml#Chapter_7)
    when you learn about using matrices for geometric transformations, and in [Chapter 14](ch14.xhtml#Chapter_14)
    when you learn about the singular value decomposition.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 诱导范数可以以下述方式解释：矩阵的一个功能是编码向量的变换；矩阵的诱导范数是衡量该变换对向量进行缩放（拉伸或收缩）的程度的指标。这种解释在第7章([Chapter 7](ch07.xhtml#Chapter_7))学习使用矩阵进行几何变换时会更加明了，在第14章([Chapter 14](ch14.xhtml#Chapter_14))学习奇异值分解时也是如此。
- en: In this chapter, I will introduce you to element-wise norms. I’ll start with
    the Euclidean norm, which is actually a direct extension of the vector norm to
    matrices. The Euclidean norm is also called the *Frobenius norm*, and is computed
    as the square root of the sum of all matrix elements squared ([Equation 6-1](#frobenius-norm)).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将向您介绍逐元素范数。我将从欧几里德范数开始，它实际上是向量范数对矩阵的直接扩展。欧几里德范数也称为*Frobenius范数*，计算方法是所有矩阵元素平方和的平方根（[公式
    6-1](#frobenius-norm)）。
- en: Equation 6-1\. The Frobenius norm
  id: totrans-11
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 公式 6-1. Frobenius范数
- en: <math alttext="parallel-to bold upper A parallel-to equals StartRoot sigma-summation
    Underscript i equals 1 Overscript upper M Endscripts sigma-summation Underscript
    j equals 1 Overscript upper N Endscripts a Subscript i j Superscript 2 Baseline
    EndRoot" display="block"><mrow><msub><mrow><mo>∥</mo><mi>𝐀</mi><mo>∥</mo></mrow>
    <mtext>F</mtext></msub> <mo>=</mo> <msqrt><mrow><msubsup><mo>∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>M</mi></msubsup> <msubsup><mo>∑</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>N</mi></msubsup> <msubsup><mi>a</mi> <mrow><mi>i</mi><mi>j</mi></mrow> <mn>2</mn></msubsup></mrow></msqrt></mrow></math>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="parallel-to bold upper A parallel-to equals StartRoot sigma-summation
    Underscript i equals 1 Overscript upper M Endscripts sigma-summation Underscript
    j equals 1 Overscript upper N Endscripts a Subscript i j Superscript 2 Baseline
    EndRoot" display="block"><mrow><msub><mrow><mo>∥</mo><mi>𝐀</mi><mo>∥</mo></mrow>
    <mtext>F</mtext></msub> <mo>=</mo> <msqrt><mrow><msubsup><mo>∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>M</mi></msubsup> <msubsup><mo>∑</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>N</mi></msubsup> <msubsup><mi>a</mi> <mrow><mi>i</mi><mi>j</mi></mrow> <mn>2</mn></msubsup></mrow></msqrt></mrow></math>
- en: The indices *i* and *j* correspond to the *M* rows and *N* columns. Also note
    the subscripted [F] indicating the Frobenius norm.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 指标*i*和*j*对应于*M*行和*N*列。还请注意带下标的[F]表示Frobenius范数。
- en: 'The Frobenius norm is also called the <math alttext="script l Baseline 2"><mrow><mi>ℓ</mi>
    <mn>2</mn></mrow></math> norm (the <math alttext="script l"><mi>ℓ</mi></math>
    is a fancy-looking letter L). And the <math alttext="script l Baseline 2"><mrow><mi>ℓ</mi>
    <mn>2</mn></mrow></math> norm gets its name from the general formula for element-wise
    *p*-norms (notice that you get the Frobenius norm when *p* = 2):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Frobenius范数也被称为<math alttext="script l Baseline 2"><mrow><mi>ℓ</mi> <mn>2</mn></mrow></math>范数（<math
    alttext="script l"><mi>ℓ</mi></math>是一个看起来很漂亮的字母）。而<math alttext="script l Baseline
    2"><mrow><mi>ℓ</mi> <mn>2</mn></mrow></math>范数的名称源自逐元素*p*-范数的一般公式（当*p*=2时，得到Frobenius范数）。
- en: <math alttext="parallel-to bold upper A parallel-to equals left-parenthesis
    sigma-summation Underscript i equals 1 Overscript upper M Endscripts sigma-summation
    Underscript j equals 1 Overscript upper N Endscripts StartAbsoluteValue a Subscript
    i j Baseline EndAbsoluteValue Superscript p Baseline right-parenthesis Superscript
    1 slash p" display="block"><mrow><msub><mrow><mo>∥</mo><mi>𝐀</mi><mo>∥</mo></mrow>
    <mi>p</mi></msub> <mo>=</mo> <msup><mfenced close=")" open="(" separators=""><munderover><mo>∑</mo>
    <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mi>M</mi></munderover> <munderover><mo>∑</mo>
    <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>N</mi></munderover> <msup><mrow><mo>|</mo><msub><mi>a</mi>
    <mrow><mi>i</mi><mi>j</mi></mrow></msub> <mo>|</mo></mrow> <mi>p</mi></msup></mfenced>
    <mrow><mn>1</mn><mo>/</mo><mi>p</mi></mrow></msup></mrow></math>
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="parallel-to bold upper A parallel-to equals left-parenthesis
    sigma-summation Underscript i equals 1 Overscript upper M Endscripts sigma-summation
    Underscript j equals 1 Overscript upper N Endscripts StartAbsoluteValue a Subscript
    i j Baseline EndAbsoluteValue Superscript p Baseline right-parenthesis Superscript
    1 slash p" display="block"><mrow><msub><mrow><mo>∥</mo><mi>𝐀</mi><mo>∥</mo></mrow>
    <mi>p</mi></msub> <mo>=</mo> <msup><mfenced close=")" open="(" separators=""><munderover><mo>∑</mo>
    <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mi>M</mi></munderover> <munderover><mo>∑</mo>
    <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>N</mi></munderover> <msup><mrow><mo>|</mo><msub><mi>a</mi>
    <mrow><mi>i</mi><mi>j</mi></mrow></msub> <mo>|</mo></mrow> <mi>p</mi></msup></mfenced>
    <mrow><mn>1</mn><mo>/</mo><mi>p</mi></mrow></msup></mrow></math>
- en: Matrix norms have several applications in machine learning and statistical analysis.
    One of the important applications is in regularization, which aims to improve
    model fitting and increase generalization of models to unseen data (you’ll see
    examples of this later in the book). The basic idea of regularization is to add
    a matrix norm as a cost function to a minimization algorithm. That norm will help
    prevent model parameters from becoming too large ( <math alttext="script l Baseline
    2"><mrow><mi>ℓ</mi> <mn>2</mn></mrow></math> reguarlization, also called *ridge
    regression*) or encouraging sparse solutions ( <math alttext="script l Baseline
    1"><mrow><mi>ℓ</mi> <mn>1</mn></mrow></math> regularization, also called *lasso
    regression*). In fact, modern deep learning architectures rely on matrix norms
    to achieve such impressive performance at solving computer vision problems.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵范数在机器学习和统计分析中有多种应用。其中一个重要应用是正则化，旨在改善模型拟合并增强模型对未见数据的泛化能力（您将在本书后面看到这方面的例子）。正则化的基本思想是将矩阵范数作为最小化算法的代价函数之一。这种范数有助于防止模型参数过大（<math
    alttext="script l Baseline 2"><mrow><mi>ℓ</mi> <mn>2</mn></mrow></math>正则化，也称为*岭回归*）或鼓励稀疏解（<math
    alttext="script l Baseline 1"><mrow><mi>ℓ</mi> <mn>1</mn></mrow></math>正则化，也称为*Lasso回归*）。事实上，现代深度学习架构依赖于矩阵范数来在解决计算机视觉问题时取得如此卓越的性能。
- en: Another application of the Frobenius norm is computing a measure of “matrix
    distance.” The distance between a matrix and itself is 0, and the distance between
    two distinct matrices increases as the numerical values in those matrices become
    increasingly dissimilar. Frobenius matrix distance is computed simply by replacing
    matrix <math alttext="bold upper A"><mi>𝐀</mi></math> with matrix <math alttext="bold
    upper C equals bold upper A minus bold upper B"><mrow><mi>𝐂</mi> <mo>=</mo> <mi>𝐀</mi>
    <mo>-</mo> <mi>𝐁</mi></mrow></math> in [Equation 6-1](#frobenius-norm).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Frobenius范数的另一个应用是计算“矩阵距离”的度量。矩阵与自身的距离为0，而两个不同矩阵之间的距离随着这些矩阵中的数值越来越不相似而增加。Frobenius矩阵距离的计算方法很简单，只需在[公式
    6-1](#frobenius-norm)中将矩阵<math alttext="bold upper A"><mi>𝐀</mi></math>替换为矩阵<math
    alttext="bold upper C equals bold upper A minus bold upper B"><mrow><mi>𝐂</mi>
    <mo>=</mo> <mi>𝐀</mi> <mo>-</mo> <mi>𝐁</mi></mrow></math>。
- en: This distance can be used as an optimization criterion in machine learning algorithms,
    for example, to reduce the data storage size of an image while minimizing the
    Frobenius distance between the reduced and original matrices. [Exercise 6-2](#exercise_6_2)
    will guide you through a simple minimization example.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个距离可以作为机器学习算法中的优化准则，例如，在最小化减少图像数据存储大小的同时，尽量减少减少矩阵和原始矩阵之间的Frobenius距离。[练习 6-2](#exercise_6_2)将引导您完成一个简单的最小化示例。
- en: Matrix Trace and Frobenius Norm
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 矩阵迹和Frobenius范数
- en: 'The *trace* of a matrix is the sum of its diagonal elements, indicated as <math
    alttext="t r left-parenthesis bold upper A right-parenthesis"><mrow><mi>t</mi>
    <mi>r</mi> <mo>(</mo> <mi>𝐀</mi> <mo>)</mo></mrow></math> , and exists only for
    square matrices. Both of the following matrices have the same trace (14):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的*迹* 是其对角元素的和，表示为 <math alttext="t r left-parenthesis bold upper A right-parenthesis"><mrow><mi>t</mi>
    <mi>r</mi> <mo>(</mo> <mi>𝐀</mi> <mo>)</mo></mrow></math>，仅适用于方阵。以下两个矩阵的迹相同（14）：
- en: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 4 2nd Column 5 3rd Column
    6 2nd Row 1st Column 0 2nd Column 1 3rd Column 4 3rd Row 1st Column 9 2nd Column
    9 3rd Column 9 EndMatrix comma Start 3 By 3 Matrix 1st Row 1st Column 0 2nd Column
    0 3rd Column 0 2nd Row 1st Column 0 2nd Column 8 3rd Column 0 3rd Row 1st Column
    1 2nd Column 2 3rd Column 6 EndMatrix" display="block"><mrow><mfenced close="]"
    open="["><mtable><mtr><mtd><mn>4</mn></mtd> <mtd><mn>5</mn></mtd> <mtd><mn>6</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mn>9</mn></mtd>
    <mtd><mn>9</mn></mtd> <mtd><mn>9</mn></mtd></mtr></mtable></mfenced> <mo>,</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>8</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd> <mtd><mn>6</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 4 2nd Column 5 3rd Column
    6 2nd Row 1st Column 0 2nd Column 1 3rd Column 4 3rd Row 1st Column 9 2nd Column
    9 3rd Column 9 EndMatrix comma Start 3 By 3 Matrix 1st Row 1st Column 0 2nd Column
    0 3rd Column 0 2nd Row 1st Column 0 2nd Column 8 3rd Column 0 3rd Row 1st Column
    1 2nd Column 2 3rd Column 6 EndMatrix" display="block"><mrow><mfenced close="]"
    open="["><mtable><mtr><mtd><mn>4</mn></mtd> <mtd><mn>5</mn></mtd> <mtd><mn>6</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mn>9</mn></mtd>
    <mtd><mn>9</mn></mtd> <mtd><mn>9</mn></mtd></mtr></mtable></mfenced> <mo>,</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>8</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd> <mtd><mn>6</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'Trace has some interesting properties. For example, the trace of a matrix equals
    the sum of its eigenvalues and therefore is a measure of the “volume” of its eigenspace.
    Many properties of the trace are less relevant for data science applications,
    but here is one interesting exception:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 迹有一些有趣的属性。例如，矩阵的迹等于其特征值的和，因此是其特征空间“体积”的度量。迹的许多属性对数据科学应用不那么重要，但有一个有趣的例外：
- en: <math alttext="parallel-to upper A parallel-to equals StartRoot sigma-summation
    Underscript i equals 1 Overscript upper M Endscripts sigma-summation Underscript
    j equals 1 Overscript upper N Endscripts a Subscript i j Superscript 2 Baseline
    EndRoot equals StartRoot t r left-parenthesis bold upper A Superscript upper T
    Baseline bold upper A right-parenthesis EndRoot" display="block"><mrow><msub><mrow><mo>∥</mo><mi>A</mi><mo>∥</mo></mrow>
    <mtext>F</mtext></msub> <mo>=</mo> <msqrt><mrow><msubsup><mo>∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>M</mi></msubsup> <msubsup><mo>∑</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>N</mi></msubsup> <msubsup><mi>a</mi> <mrow><mi>i</mi><mi>j</mi></mrow> <mn>2</mn></msubsup></mrow></msqrt>
    <mo>=</mo> <msqrt><mrow><mi>t</mi> <mi>r</mi> <mo>(</mo> <msup><mi>𝐀</mi> <mtext>T</mtext></msup>
    <mi>𝐀</mi> <mo>)</mo></mrow></msqrt></mrow></math>
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="parallel-to upper A parallel-to equals StartRoot sigma-summation
    Underscript i equals 1 Overscript upper M Endscripts sigma-summation Underscript
    j equals 1 Overscript upper N Endscripts a Subscript i j Superscript 2 Baseline
    EndRoot equals StartRoot t r left-parenthesis bold upper A Superscript upper T
    Baseline bold upper A right-parenthesis EndRoot" display="block"><mrow><msub><mrow><mo>∥</mo><mi>A</mi><mo>∥</mo></mrow>
    <mtext>F</mtext></msub> <mo>=</mo> <msqrt><mrow><msubsup><mo>∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>M</mi></msubsup> <msubsup><mo>∑</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>N</mi></msubsup> <msubsup><mi>a</mi> <mrow><mi>i</mi><mi>j</mi></mrow> <mn>2</mn></msubsup></mrow></msqrt>
    <mo>=</mo> <msqrt><mrow><mi>t</mi> <mi>r</mi> <mo>(</mo> <msup><mi>𝐀</mi> <mtext>T</mtext></msup>
    <mi>𝐀</mi> <mo>)</mo></mrow></msqrt></mrow></math>
- en: In other words, the Frobenius norm can be calculated as the square root of the
    trace of the matrix times its transpose. The reason why this works is that each
    diagonal element of the matrix <math alttext="bold upper A Superscript upper T
    Baseline bold upper A"><mrow><msup><mi>𝐀</mi> <mtext>T</mtext></msup> <mi>𝐀</mi></mrow></math>
    is defined by the dot product of each row with itself.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，Frobenius 范数可以计算为矩阵与其转置的迹的平方根。这种方法有效的原因在于矩阵 <math alttext="bold upper A
    Superscript upper T Baseline bold upper A"><mrow><msup><mi>𝐀</mi> <mtext>T</mtext></msup>
    <mi>𝐀</mi></mrow></math> 的每个对角元素由每行与自身的点积定义。
- en: '[Exercise 6-3](#exercise_6_3) will help you explore the trace method of computing
    the Frobenius norm.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[Exercise 6-3](#exercise_6_3) 将帮助您探索计算Frobenius范数的迹方法。'
- en: Matrix Spaces (Column, Row, Nulls)
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵空间（列、行、零空间）
- en: The concept of *matrix spaces* is central to many topics in abstract and applied
    linear algebra. Fortunately, matrix spaces are conceptually straightforward, and
    are essentially just linear weighted combinations of different features of a matrix.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*矩阵空间* 的概念是抽象和应用线性代数中许多主题的核心。幸运的是，矩阵空间在概念上很直观，本质上只是矩阵不同特征的线性加权组合。'
- en: Column Space
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列空间
- en: Remember that a linear weighted combination of vectors involves scalar multiplying
    and summing a set of vectors. Two modifications to this concept will extend linear
    weighted combination to the column space of a matrix. First, we conceptualize
    a matrix as a set of column vectors. Second, we consider the infinity of real-valued
    scalars instead of working with a specific set of scalars. An infinite number
    of scalars gives an infinite number of ways to combine a set of vectors. That
    resulting infinite set of vectors is called the *column space of a matrix*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，向量的线性加权组合涉及标量乘法和一组向量的求和。对这个概念的两种修改将线性加权组合扩展到矩阵的列空间。首先，我们将矩阵概念化为一组列向量。其次，我们考虑无穷多的实数标量而不是使用特定的标量集合。无限数量的标量给出了组合一组向量的无限方式。由此产生的无限向量集称为*矩阵的列空间*。
- en: 'Let’s make this concrete with some numerical examples. We’ll start simple—a
    matrix that has only one column (which is actually the same thing as a column
    vector). Its column space—all possible linear weighted combinations of that column—can
    be expressed like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些具体的数值示例来具体化这一点。我们从简单的开始——一个只有一列的矩阵（实际上与列向量相同）。它的列空间——所有可能的该列的线性加权组合——可以表示为：
- en: <math alttext="upper C left-parenthesis StartBinomialOrMatrix 1 Choose 3 EndBinomialOrMatrix
    right-parenthesis equals lamda StartBinomialOrMatrix 1 Choose 3 EndBinomialOrMatrix
    comma lamda element-of double-struck upper R" display="block"><mrow><mi>C</mi>
    <mfenced close=")" open="("><mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd></mtr>
    <mtr><mtd><mn>3</mn></mtd></mtr></mtable></mfenced></mfenced> <mo>=</mo> <mi>λ</mi>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>3</mn></mtd></mtr></mtable></mfenced>
    <mo>,</mo> <mi>λ</mi> <mo>∈</mo> <mi>ℝ</mi></mrow></math>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper C left-parenthesis StartBinomialOrMatrix 1 Choose 3 EndBinomialOrMatrix
    right-parenthesis equals lamda StartBinomialOrMatrix 1 Choose 3 EndBinomialOrMatrix
    comma lamda element-of double-struck upper R" display="block"><mrow><mi>C</mi>
    <mfenced close=")" open="("><mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd></mtr>
    <mtr><mtd><mn>3</mn></mtd></mtr></mtable></mfenced></mfenced> <mo>=</mo> <mi>λ</mi>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>3</mn></mtd></mtr></mtable></mfenced>
    <mo>,</mo> <mi>λ</mi> <mo>∈</mo> <mi>ℝ</mi></mrow></math>
- en: The <math alttext="upper C left-parenthesis bold upper A right-parenthesis"><mrow><mi>C</mi>
    <mo>(</mo> <mi>𝐀</mi> <mo>)</mo></mrow></math> indicates the column space of matrix
    <math alttext="bold upper A"><mi>𝐀</mi></math> , and the <math alttext="element-of"><mo>∈</mo></math>
    symbol means “is a member of” or “is contained in.” In this context, it means
    that <math alttext="lamda"><mi>λ</mi></math> can be any possible real-valued number.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper C left-parenthesis bold upper A right-parenthesis"><mrow><mi>C</mi>
    <mo>(</mo> <mi>𝐀</mi> <mo>)</mo></mrow></math> 表示矩阵 <math alttext="bold upper
    A"><mi>𝐀</mi></math> 的列空间，符号 <math alttext="element-of"><mo>∈</mo></math> 意味着“是”的成员或“包含于”。在这个上下文中，它意味着
    <math alttext="lamda"><mi>λ</mi></math> 可以是任意可能的实数值。
- en: 'What does this mathematical expression mean? It means that the column space
    is the set of all possible scaled versions of the column vector [1 3]. Let’s consider
    a few specific cases. Is the vector [1 3] in the column space? Yes, because you
    can express that vector as the matrix times <math alttext="lamda equals 1"><mrow><mi>λ</mi>
    <mo>=</mo> <mn>1</mn></mrow></math> . How about [−2 −6]? Also yes, because you
    can express that vector as the matrix times <math alttext="lamda equals negative
    2"><mrow><mi>λ</mi> <mo>=</mo> <mo>-</mo> <mn>2</mn></mrow></math> . How about
    [1 4]? The answer here is no: vector [1 4] is *not* in the column space of the
    matrix, because there is simply no scalar that can multiply the matrix to produce
    that vector.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数学表达式是什么意思？它意味着列空间是列向量[1 3]的所有可能比例版本的集合。让我们考虑几个具体的案例。向量[1 3]是否在矩阵的列空间中？是的，因为你可以将该向量表达为矩阵乘以<math
    alttext="lamda equals 1"><mrow><mi>λ</mi> <mo>=</mo> <mn>1</mn></mrow></math>
    。那么[−2 −6]呢？也是，因为你可以将该向量表达为矩阵乘以<math alttext="lamda equals negative 2"><mrow><mi>λ</mi>
    <mo>=</mo> <mo>-</mo> <mn>2</mn></mrow></math> 。那么[1 4]呢？答案是否定的：向量[1 4] *不*在该矩阵的列空间中，因为没有任何标量可以使该矩阵乘以后得到该向量。
- en: What does the column space look like? For a matrix with one column, the column
    space is a line that passes through the origin, in the direction of the column
    vector, and stretches out to infinity in both directions. (Technically, the line
    doesn’t stretch out to literal infinity, because infinity is not a real number.
    But that line is arbitrarily long—much longer than our limited human minds can
    possibly fathom—so for all intents and purposes, we can speak of that line as
    being infinitely long.) [Figure 6-1](#fig_6_1) shows a picture of the column space
    for this matrix.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 列空间是什么样的？对于一个只有一列的矩阵，列空间是通过原点、沿着列向量方向延伸至无穷远的一条直线。（严格来说，这条直线并不延伸至字面上的无穷远，因为无穷不是一个实数。但这条直线是任意长的——远远超出我们有限的人类思维可以理解的范围——因此在所有目的上，我们可以说这条直线是无限长的。）[图 6-1](#fig_6_1)
    展示了这个矩阵的列空间的图片。
- en: '![1D column space of a matrix.](assets/plad_0601.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵的一维列空间](assets/plad_0601.png)'
- en: Figure 6-1\. Visualization of the column space of a matrix with one column.
    This column space is a 1D subspace.
  id: totrans-36
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-1\. 单列矩阵的列空间可视化。这个列空间是一个一维子空间。
- en: 'Now let’s consider a matrix with more columns. We’ll keep the column dimensionality
    to two so we can visualize it on a 2D graph. Here’s our matrix and its column
    space:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑一个具有更多列的矩阵。我们将保持列的维度为两个，这样我们可以在二维图上进行可视化。这是我们的矩阵及其列空间：
- en: <math alttext="upper C Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 1
    2nd Row 1st Column 3 2nd Column 2 EndMatrix equals lamda 1 StartBinomialOrMatrix
    1 Choose 3 EndBinomialOrMatrix plus lamda 2 StartBinomialOrMatrix 1 Choose 2 EndBinomialOrMatrix
    comma lamda element-of double-struck upper R" display="block"><mrow><mi>C</mi>
    <mfenced close=")" open="("><mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>3</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced></mfenced>
    <mo>=</mo> <msub><mi>λ</mi> <mn>1</mn></msub> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd></mtr>
    <mtr><mtd><mn>3</mn></mtd></mtr></mtable></mfenced> <mo>+</mo> <msub><mi>λ</mi>
    <mn>2</mn></msub> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd></mtr></mtable></mfenced> <mo>,</mo> <mi>λ</mi> <mo>∈</mo>
    <mi>ℝ</mi></mrow></math>
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper C Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 1
    2nd Row 1st Column 3 2nd Column 2 EndMatrix equals lamda 1 StartBinomialOrMatrix
    1 Choose 3 EndBinomialOrMatrix plus lamda 2 StartBinomialOrMatrix 1 Choose 2 EndBinomialOrMatrix
    comma lamda element-of double-struck upper R" display="block"><mrow><mi>C</mi>
    <mfenced close=")" open="("><mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>3</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced></mfenced>
    <mo>=</mo> <msub><mi>λ</mi> <mn>1</mn></msub> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd></mtr>
    <mtr><mtd><mn>3</mn></mtd></mtr></mtable></mfenced> <mo>+</mo> <msub><mi>λ</mi>
    <mn>2</mn></msub> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd></mtr></mtable></mfenced> <mo>,</mo> <mi>λ</mi> <mo>∈</mo>
    <mi>ℝ</mi></mrow></math>
- en: We have two columns, so we allow for two distinct <math alttext="lamda"><mi>λ</mi></math>
    s (they’re both real-valued numbers but can be different from each other). Now
    the question is, what is the set of all vectors that can be reached by some linear
    combination of these two column vectors?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两列，所以我们允许两个不同的<math alttext="lamda"><mi>λ</mi></math> s（它们都是实数，但可以彼此不同）。现在的问题是，所有可以通过这两个列向量的线性组合达到的向量的集合是什么？
- en: 'The answer is: all vectors in <math alttext="double-struck upper R squared"><msup><mi>ℝ</mi>
    <mn>2</mn></msup></math> . For example, the vector [−4 3] can be obtained by scaling
    the two columns by, respectively, 11 and −15\. How did I come up with those scalar
    values? I used the least squares projection method, which you’ll learn about in
    [Chapter 11](ch11.xhtml#Chapter_11). For now, you can focus on the concept that
    these two columns can be appropriately weighted to reach any point in <math alttext="double-struck
    upper R squared"><msup><mi>ℝ</mi> <mn>2</mn></msup></math> .'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是：所有在<math alttext="double-struck upper R squared"><msup><mi>ℝ</mi> <mn>2</mn></msup></math>
    中的向量。例如，向量[−4 3]可以通过分别将这两列乘以11和−15来获得。我是如何得出这些标量值的？我使用了最小二乘投影方法，你将在[第 11 章](ch11.xhtml#Chapter_11)中学习到。现在，你可以专注于这两列可以适当加权以达到<math
    alttext="double-struck upper R squared"><msup><mi>ℝ</mi> <mn>2</mn></msup></math>
    中任何点的概念。
- en: Graph A in [Figure 6-2](#fig_6_2) shows the two matrix columns. I didn’t draw
    the column space of the matrix because it is the entirety of the axis.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A 在 [图 6-2](#fig_6_2) 中展示了这两个矩阵列。我没有画出矩阵的列空间，因为它是整个轴的空间。
- en: '![C(A)](assets/plad_0602.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![C(A)](assets/plad_0602.png)'
- en: Figure 6-2\. More examples of column spaces
  id: totrans-43
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-2\. 更多列空间的示例
- en: 'One more example in <math alttext="double-struck upper R squared"><msup><mi>ℝ</mi>
    <mn>2</mn></msup></math> . Here’s our new matrix for consideration:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在<math alttext="double-struck upper R squared"><msup><mi>ℝ</mi> <mn>2</mn></msup></math>
    中的另一个例子。这是我们要考虑的新矩阵：
- en: <math alttext="upper C Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 2
    2nd Row 1st Column 3 2nd Column 6 EndMatrix equals lamda 1 StartBinomialOrMatrix
    1 Choose 3 EndBinomialOrMatrix plus lamda 2 StartBinomialOrMatrix 2 Choose 6 EndBinomialOrMatrix
    comma lamda element-of double-struck upper R" display="block"><mrow><mi>C</mi>
    <mfenced close=")" open="("><mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>3</mn></mtd> <mtd><mn>6</mn></mtd></mtr></mtable></mfenced></mfenced>
    <mo>=</mo> <msub><mi>λ</mi> <mn>1</mn></msub> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd></mtr>
    <mtr><mtd><mn>3</mn></mtd></mtr></mtable></mfenced> <mo>+</mo> <msub><mi>λ</mi>
    <mn>2</mn></msub> <mfenced close="]" open="["><mtable><mtr><mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mn>6</mn></mtd></mtr></mtable></mfenced> <mo>,</mo> <mi>λ</mi> <mo>∈</mo>
    <mi>ℝ</mi></mrow></math>
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper C Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 2
    2nd Row 1st Column 3 2nd Column 6 EndMatrix equals lamda 1 StartBinomialOrMatrix
    1 Choose 3 EndBinomialOrMatrix plus lamda 2 StartBinomialOrMatrix 2 Choose 6 EndBinomialOrMatrix
    comma lamda element-of double-struck upper R" display="block"><mrow><mi>C</mi>
    <mfenced close=")" open="("><mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>3</mn></mtd> <mtd><mn>6</mn></mtd></mtr></mtable></mfenced></mfenced>
    <mo>=</mo> <msub><mi>λ</mi> <mn>1</mn></msub> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd></mtr>
    <mtr><mtd><mn>3</mn></mtd></mtr></mtable></mfenced> <mo>+</mo> <msub><mi>λ</mi>
    <mn>2</mn></msub> <mfenced close="]" open="["><mtable><mtr><mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mn>6</mn></mtd></mtr></mtable></mfenced> <mo>,</mo> <mi>λ</mi> <mo>∈</mo>
    <mi>ℝ</mi></mrow></math>
- en: What is the dimensionality of its column space? Is it possible to reach any
    point in <math alttext="double-struck upper R squared"><msup><mi>ℝ</mi> <mn>2</mn></msup></math>
    by some linear weighted combination of the two columns?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 其列空间的维数是多少？通过两列的某种线性加权组合是否可能到达 <math alttext="double-struck upper R squared"><msup><mi>ℝ</mi>
    <mn>2</mn></msup></math> 中的任意点？
- en: The answer to the second question is no. And if you don’t believe me, try to
    find a linear weighted combination of the two columns that produces vector [3
    5]. It is simply impossible. In fact, the two columns are collinear (graph B in
    [Figure 6-2](#fig_6_2)), because one is already a scaled version of the other.
    That means that the column space of this <math alttext="2 times 2"><mrow><mn>2</mn>
    <mo>×</mo> <mn>2</mn></mrow></math> matrix is still just a line—a 1D subspace.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个问题的答案是否定的。如果你不相信我，请试着找出产生向量 [3 5] 的两列的线性加权组合。这是不可能的。事实上，这两列是共线的（图 B 在 [图 6-2](#fig_6_2)
    中），因为其中一列已经是另一列的缩放版本。这意味着这个 <math alttext="2 times 2"><mrow><mn>2</mn> <mo>×</mo>
    <mn>2</mn></mrow></math> 矩阵的列空间仍然只是一条线——一个一维子空间。
- en: The take-home message here is that having *N* columns in a matrix does not guarantee
    that the column space will be *N*-D. The dimensionality of the column space equals
    the number of columns only if the columns form a linearly independent set. (Remember
    from [Chapter 3](ch03.xhtml#Chapter_3) that linear independence means a set of
    vectors in which no vector can be expressed as a linear weighted combination of
    other vectors in that set.)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的核心信息是，在一个矩阵中有 *N* 列并不保证列空间将是 *N* 维的。列空间的维数仅等于列数，当且仅当这些列形成一个线性无关的集合时。（从[第三章](ch03.xhtml#Chapter_3)记得，线性无关意味着一个向量集合中的向量不能表示为该集合中其他向量的线性加权组合。）
- en: 'One final example of column spaces, to see what happens when we move into 3D.
    Here’s our matrix and its column space:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个列空间的例子，看看当我们进入三维空间时会发生什么。这是我们的矩阵及其列空间：
- en: <math alttext="upper C Start 3 By 2 Matrix 1st Row 1st Column 3 2nd Column 0
    2nd Row 1st Column 5 2nd Column 2 3rd Row 1st Column 1 2nd Column 2 EndMatrix
    equals lamda 1 Start 3 By 1 Matrix 1st Row  1 2nd Row  5 3rd Row  1 EndMatrix
    plus lamda 2 Start 3 By 1 Matrix 1st Row  0 2nd Row  2 3rd Row  2 EndMatrix comma
    lamda element-of double-struck upper R" display="block"><mrow><mi>C</mi> <mfenced
    close=")" open="("><mfenced close="]" open="["><mtable><mtr><mtd><mn>3</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>5</mn></mtd> <mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced></mfenced>
    <mo>=</mo> <msub><mi>λ</mi> <mn>1</mn></msub> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd></mtr>
    <mtr><mtd><mn>5</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd></mtr></mtable></mfenced>
    <mo>+</mo> <msub><mi>λ</mi> <mn>2</mn></msub> <mfenced close="]" open="["><mtable><mtr><mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>2</mn></mtd></mtr></mtable></mfenced>
    <mo>,</mo> <mi>λ</mi> <mo>∈</mo> <mi>ℝ</mi></mrow></math>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper C Start 3 By 2 Matrix 1st Row 1st Column 3 2nd Column 0
    2nd Row 1st Column 5 2nd Column 2 3rd Row 1st Column 1 2nd Column 2 EndMatrix
    equals lamda 1 Start 3 By 1 Matrix 1st Row  1 2nd Row  5 3rd Row  1 EndMatrix
    plus lamda 2 Start 3 By 1 Matrix 1st Row  0 2nd Row  2 3rd Row  2 EndMatrix comma
    lamda element-of double-struck upper R" display="block"><mrow><mi>C</mi> <mfenced
    close=")" open="("><mfenced close="]" open="["><mtable><mtr><mtd><mn>3</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>5</mn></mtd> <mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced></mfenced>
    <mo>=</mo> <msub><mi>λ</mi> <mn>1</mn></msub> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd></mtr>
    <mtr><mtd><mn>5</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd></mtr></mtable></mfenced>
    <mo>+</mo> <msub><mi>λ</mi> <mn>2</mn></msub> <mfenced close="]" open="["><mtable><mtr><mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>2</mn></mtd></mtr></mtable></mfenced>
    <mo>,</mo> <mi>λ</mi> <mo>∈</mo> <mi>ℝ</mi></mrow></math>
- en: Now there are two columns in <math alttext="double-struck upper R cubed"><msup><mi>ℝ</mi>
    <mn>3</mn></msup></math> . Those two columns are linearly independent, meaning
    you cannot express one as a scaled version of the other. So the column space of
    this matrix is 2D, but it’s a 2D plane that is embedded in <math alttext="double-struck
    upper R cubed"><msup><mi>ℝ</mi> <mn>3</mn></msup></math> ([Figure 6-3](#fig_6_3)).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 <math alttext="double-struck upper R cubed"><msup><mi>ℝ</mi> <mn>3</mn></msup></math>
    中有两列。这两列是线性无关的，意味着你无法将其中一列表示为另一列的缩放版本。因此，这个矩阵的列空间是二维的，但它是嵌入在 <math alttext="double-struck
    upper R cubed"><msup><mi>ℝ</mi> <mn>3</mn></msup></math> 中的一个平面（[图 6-3](#fig_6_3)）。
- en: The column space of this matrix is an infinite 2D plane, but that plane is merely
    an infinitesimal slice of 3D. You can think of it like an infinitely thin piece
    of paper that spans the universe.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个矩阵的列空间是一个无限的二维平面，但是这个平面仅仅是三维空间的一个无限小切片。你可以将其想象成一张无限薄的纸片，横跨整个宇宙。
- en: '![Column space in 3D](assets/plad_0603.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![三维空间中的列空间](assets/plad_0603.png)'
- en: Figure 6-3\. The 2D column space of a matrix embedded in 3D. The two thick lines
    depict the two columns of the matrix.
  id: totrans-54
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-3\. 嵌入在三维空间中的矩阵的二维列空间。两条粗线代表矩阵的两列。
- en: There are many vectors on that plane (i.e., many vectors that can be obtained
    as a linear combination of the two column vectors), but many *more* vectors that
    are not on the plane. In other words, there are vectors in the column space of
    the matrix, and there are vectors outside the column space of the matrix.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个平面上有许多向量（即可以通过两个列向量的线性组合获得的向量），但是还有许多 *更多* 的向量不在这个平面上。换句话说，矩阵的列空间中有向量，也有不在矩阵列空间中的向量。
- en: How do you know if a vector is in the column space of a matrix? That is not
    at all a trivial question—in fact, that question is the foundation of the linear
    least squares method, and words cannot do justice to the importance of least squares
    in applied math and engineering. So how *do* you figure out if a vector is in
    the column space? In the examples so far, we just used some guessing, arithmetic,
    and visualization. The point of that approach was to instill intuition, but those
    are obviously not scalable methods for higher dimensions and for more complicated
    problems.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如何确定向量是否在矩阵的列空间中？这绝非一个微不足道的问题——事实上，这个问题是线性最小二乘法的基础，言语无法充分表达最小二乘法在应用数学和工程中的重要性。那么如何确定一个向量是否在列空间中呢？到目前为止的示例中，我们只是通过猜测、算术和可视化进行了一些操作。这种方法的目的在于培养直觉，但显然这些方法在更高维度和更复杂问题中是不可扩展的。
- en: Quantitative methods to determine whether a vector is in the column space of
    a matrix rely on the concept of matrix rank, which you’ll learn about later in
    this chapter. Until then, focus on the intuition that the columns of a matrix
    carve out a vector subspace, which may include the entire *M*-dimensional space
    or may be some smaller-dimensional subspace; and that an important question is
    whether some other vector is inside that subspace (meaning that vector can be
    expressed as a linear weighted combination of the columns of the matrix).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 确定向量是否在矩阵的列空间内的定量方法依赖于矩阵秩的概念，这是你将在本章后面学习的内容。在那之前，专注于矩阵的列切出一个向量子空间的直觉，该子空间可能包括整个*M*维空间或较小维度的子空间；一个重要的问题是是否有其他向量在该子空间内（意味着该向量可以表示为矩阵列的线性加权组合）。
- en: Row Space
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行空间
- en: Once you understand the column space of a matrix, the row space is really easy
    to understand. In fact, the row space of a matrix is the exact same concept but
    we consider all possible weighted combinations of the rows instead of the columns.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你理解了矩阵的列空间，矩阵的行空间就非常容易理解了。事实上，矩阵的行空间与此概念完全相同，但我们考虑的是行的所有可能加权组合，而不是列。
- en: Row space is indicated as <math alttext="upper R left-parenthesis bold upper
    A right-parenthesis"><mrow><mi>R</mi> <mo>(</mo> <mi>𝐀</mi> <mo>)</mo></mrow></math>
    . And because the transpose operation swaps rows and columns, you can also write
    that the row space of a matrix is the column space of the matrix transposed, in
    other words, <math alttext="upper R left-parenthesis bold upper A right-parenthesis
    equals upper C left-parenthesis bold upper A Superscript upper T Baseline right-parenthesis"><mrow><mi>R</mi>
    <mrow><mo>(</mo> <mi>𝐀</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>C</mi> <mrow><mo>(</mo>
    <msup><mi>𝐀</mi> <mtext>T</mtext></msup> <mo>)</mo></mrow></mrow></math> . There
    are a few differences between the row and column spaces of a matrix; for example,
    the row space (but not the column space) is invariant to row-reduction operations.
    But that is beyond the scope of this chapter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 行空间被表示为<math alttext="upper R left-parenthesis bold upper A right-parenthesis"><mrow><mi>R</mi>
    <mo>(</mo> <mi>𝐀</mi> <mo>)</mo></mrow></math>。由于转置操作交换了行和列，你也可以写成矩阵的行空间是其转置的列空间，换句话说，<math
    alttext="upper R left-parenthesis bold upper A right-parenthesis equals upper
    C left-parenthesis bold upper A Superscript upper T Baseline right-parenthesis"><mrow><mi>R</mi>
    <mrow><mo>(</mo> <mi>𝐀</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>C</mi> <mrow><mo>(</mo>
    <msup><mi>𝐀</mi> <mtext>T</mtext></msup> <mo>)</mo></mrow></mrow></math>。矩阵行空间和列空间之间有一些差异；例如，行空间（但不是列空间）对行约化操作是不变的。但这超出了本章的范围。
- en: Because the row space equals the column space of the matrix transpose, these
    two matrix spaces are identical for symmetric matrices.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因为行空间等于矩阵的转置的列空间，对于对称矩阵来说，这两个矩阵空间是相同的。
- en: Null Spaces
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空间零子句
- en: 'The null space is subtly but importantly different from the column space. The
    column space can be succintly summarized as the following equation:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 空间零子句与列空间微妙但重要的区别在于。列空间可以简洁地总结为以下方程：
- en: <math alttext="bold upper A bold x equals bold b" display="block"><mrow><mi>𝐀</mi>
    <mi>𝐱</mi> <mo>=</mo> <mi>𝐛</mi></mrow></math>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="bold upper A bold x equals bold b" display="block"><mrow><mi>𝐀</mi>
    <mi>𝐱</mi> <mo>=</mo> <mi>𝐛</mi></mrow></math>
- en: This can be translated into English as “Can we find some set of coefficients
    in <math alttext="bold x"><mi>𝐱</mi></math> such that the weighted combination
    of columns in <math alttext="bold upper A"><mi>𝐀</mi></math> produce vector <math
    alttext="bold b"><mi>𝐛</mi></math> ?” If the answer is yes, then <math alttext="bold
    b element-of upper C left-parenthesis bold upper A right-parenthesis"><mrow><mi>𝐛</mi>
    <mo>∈</mo> <mi>C</mi> <mo>(</mo> <mi>𝐀</mi> <mo>)</mo></mrow></math> and vector
    <math alttext="bold x"><mi>𝐱</mi></math> tells us how to weight the columns of
    <math alttext="bold upper A"><mi>𝐀</mi></math> to get to <math alttext="bold b"><mi>𝐛</mi></math>
    .
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以翻译成英文为“我们是否可以找到一些系数集在<math alttext="bold x"><mi>𝐱</mi></math>中，使得在<math alttext="bold
    upper A"><mi>𝐀</mi></math>的列的加权组合产生向量<math alttext="bold b"><mi>𝐛</mi></math>？”如果答案是肯定的，那么<math
    alttext="bold b element-of upper C left-parenthesis bold upper A right-parenthesis"><mrow><mi>𝐛</mi>
    <mo>∈</mo> <mi>C</mi> <mo>(</mo> <mi>𝐀</mi> <mo>)</mo></mrow></math>，并且向量<math
    alttext="bold x"><mi>𝐱</mi></math>告诉我们如何加权<math alttext="bold upper A"><mi>𝐀</mi></math>的列以获得<math
    alttext="bold b"><mi>𝐛</mi></math>。
- en: 'The null space, in contrast, can be succintly summarized as the following equation:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，空间零子句可以简洁地总结为以下方程：
- en: <math alttext="bold upper A bold y equals bold 0" display="block"><mrow><mi>𝐀</mi>
    <mi>𝐲</mi> <mo>=</mo> <mn mathvariant="bold">0</mn></mrow></math>
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="bold upper A bold y equals bold 0" display="block"><mrow><mi>𝐀</mi>
    <mi>𝐲</mi> <mo>=</mo> <mn mathvariant="bold">0</mn></mrow></math>
- en: This can be translated into English as “Can we find some set of coefficients
    in <math alttext="bold y"><mi>𝐲</mi></math> such that the weighted combination
    of columns in <math alttext="bold upper A"><mi>𝐀</mi></math> produces the zeros
    vector <math alttext="bold 0"><mn mathvariant="bold">0</mn></math> ?”
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以翻译成英文为“我们能找到一些系数<math alttext="bold y"><mi>𝐲</mi></math>，使得<math alttext="bold
    upper A"><mi>𝐀</mi></math>中列的加权组合产生零向量<math alttext="bold 0"><mn mathvariant="bold">0</mn></math>吗？”
- en: 'A moment’s inspection will reveal an answer that works for every possible matrix
    <math alttext="bold upper A"><mi>𝐀</mi></math> : set <math alttext="bold y equals
    bold 0"><mrow><mi>𝐲</mi> <mo>=</mo> <mn mathvariant="bold">0</mn></mrow></math>
    ! Obviously, multiplying all the columns by 0s will sum to the zeros vector. But
    that is a trivial solution, and we exclude it. Therefore, the question becomes
    “Can we find a set of weights—not all of which are 0—that produces the zeros vector?”
    Any vector <math alttext="bold y"><mi>𝐲</mi></math> that can satisfy this equation
    is in the null space of <math alttext="bold upper A"><mi>𝐀</mi></math> , which
    we write as <math alttext="upper N left-parenthesis bold upper A right-parenthesis"><mrow><mi>N</mi>
    <mo>(</mo> <mi>𝐀</mi> <mo>)</mo></mrow></math> .'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一瞬间的观察会揭示一个适用于任何可能的矩阵<math alttext="bold upper A"><mi>𝐀</mi></math>的答案：设置<math
    alttext="bold y equals bold 0"><mrow><mi>𝐲</mi> <mo>=</mo> <mn mathvariant="bold">0</mn></mrow></math>！显然，将所有列乘以0将得到零向量的和。但这是一个微不足道的解，我们排除它。因此，问题变成了“我们能找到一组权重——并非所有都是0——来产生零向量吗？”任何能满足这个方程的向量<math
    alttext="bold y"><mi>𝐲</mi></math>都在<math alttext="bold upper A"><mi>𝐀</mi></math>的零空间中，我们将其写为<math
    alttext="upper N left-parenthesis bold upper A right-parenthesis"><mrow><mi>N</mi>
    <mo>(</mo> <mi>𝐀</mi> <mo>)</mo></mrow></math>。
- en: 'Let’s start with a simple example. Before reading the following text, see if
    you can find such a vector <math alttext="bold y"><mi>𝐲</mi></math> :'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的例子开始。在阅读以下文本之前，看看你能否找到这样一个向量<math alttext="bold y"><mi>𝐲</mi></math>：
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column negative
    1 2nd Row 1st Column negative 2 2nd Column 2 EndMatrix" display="block"><mfenced
    close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>1</mn></mrow></mtd>
    <mtd><mrow><mo>-</mo> <mn>1</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>2</mn></mrow></mtd></mtr></mtable></mfenced></math>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column negative
    1 2nd Row 1st Column negative 2 2nd Column 2 EndMatrix" display="block"><mfenced
    close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>1</mn></mrow></mtd>
    <mtd><mrow><mo>-</mo> <mn>1</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>2</mn></mrow></mtd></mtr></mtable></mfenced></math>
- en: Did you come up with a vector? Mine is [7.34, 7.34]. I’m willing to wager a
    Vegas-sized bet that you did not come up with the same vector. You might have
    come up with [1, 1] or perhaps [−1, −1]. Maybe [2, 2]?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你找到一个向量了吗？我的是[7.34, 7.34]。我敢打赌，你没有找到同样的向量。你可能找到了[1, 1]或者[-1, -1]。也许是[2, 2]？
- en: 'I think you see where this is going—there is an infinite number of vectors
    <math alttext="bold y"><mi>𝐲</mi></math> that satisfy <math alttext="bold upper
    A bold y equals bold 0"><mrow><mi>𝐀</mi> <mi>𝐲</mi> <mo>=</mo> <mn mathvariant="bold">0</mn></mrow></math>
    for that specific matrix <math alttext="bold upper A"><mi>𝐀</mi></math> . And
    all of those vectors can be expressed as some scaled version of any of these choices.
    Thus, the null space of this matrix can be expressed as:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我想你已经看出这个问题的方向了——对于特定矩阵<math alttext="bold upper A"><mi>𝐀</mi></math>，存在无限多个能满足<math
    alttext="bold upper A bold y equals bold 0"><mrow><mi>𝐀</mi> <mi>𝐲</mi> <mo>=</mo>
    <mn mathvariant="bold">0</mn></mrow></math>的向量<math alttext="bold y"><mi>𝐲</mi></math>。所有这些向量都可以表达为这些选择的某种比例版本。因此，这个矩阵的零空间可以表示为：
- en: <math alttext="upper N left-parenthesis bold upper A right-parenthesis equals
    lamda StartBinomialOrMatrix 1 Choose 1 EndBinomialOrMatrix comma lamda element-of
    double-struck upper R" display="block"><mrow><mi>N</mi> <mrow><mo>(</mo> <mi>𝐀</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mi>λ</mi> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd></mtr>
    <mtr><mtd><mn>1</mn></mtd></mtr></mtable></mfenced> <mo>,</mo> <mi>λ</mi> <mo>∈</mo>
    <mi>ℝ</mi></mrow></math>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper N left-parenthesis bold upper A right-parenthesis equals
    lamda StartBinomialOrMatrix 1 Choose 1 EndBinomialOrMatrix comma lamda element-of
    double-struck upper R" display="block"><mrow><mi>N</mi> <mrow><mo>(</mo> <mi>𝐀</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mi>λ</mi> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd></mtr>
    <mtr><mtd><mn>1</mn></mtd></mtr></mtable></mfenced> <mo>,</mo> <mi>λ</mi> <mo>∈</mo>
    <mi>ℝ</mi></mrow></math>
- en: 'Here’s another example matrix. Again, try to find a set of coefficients such
    that the weighted sum of the columns produces the zeros vector (that is, find
    <math alttext="bold y"><mi>𝐲</mi></math> in <math alttext="bold upper A bold y
    equals bold 0"><mrow><mi>𝐀</mi> <mi>𝐲</mi> <mo>=</mo> <mn mathvariant="bold">0</mn></mrow></math>
    ):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有另一个示例矩阵。再次尝试找到一组系数，使得列的加权和产生零向量（也就是找到<math alttext="bold y"><mi>𝐲</mi></math>在<math
    alttext="bold upper A bold y equals bold 0"><mrow><mi>𝐀</mi> <mi>𝐲</mi> <mo>=</mo>
    <mn mathvariant="bold">0</mn></mrow></math>中）：
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column negative
    1 2nd Row 1st Column negative 2 2nd Column 3 EndMatrix" display="block"><mfenced
    close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>1</mn></mrow></mtd>
    <mtd><mrow><mo>-</mo> <mn>1</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>3</mn></mrow></mtd></mtr></mtable></mfenced></math>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column negative
    1 2nd Row 1st Column negative 2 2nd Column 3 EndMatrix" display="block"><mfenced
    close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>1</mn></mrow></mtd>
    <mtd><mrow><mo>-</mo> <mn>1</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>3</mn></mrow></mtd></mtr></mtable></mfenced></math>
- en: 'I’m willing to place an even larger bet that you couldn’t find such a vector.
    But it’s not because I don’t believe you could (I have a very high opinion of
    my readers!); it’s because this matrix has no null space. Formally, we say that
    the null space of this matrix is the empty set: <math alttext="upper N left-parenthesis
    bold upper A right-parenthesis equals StartSet EndSet"><mrow><mi>N</mi> <mo>(</mo>
    <mi>𝐀</mi> <mo>)</mo> <mo>=</mo> <mo>{</mo> <mo>}</mo></mrow></math> .'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我敢打一个更大的赌注，你找不到这样的向量。但并不是因为我不相信你能找到（我对我的读者评价很高！）；而是因为这个矩阵没有零空间。正式地说，我们说这个矩阵的零空间是空集：<math
    alttext="upper N left-parenthesis bold upper A right-parenthesis equals StartSet
    EndSet"><mrow><mi>N</mi> <mo>(</mo> <mi>𝐀</mi> <mo>)</mo> <mo>=</mo> <mo>{</mo>
    <mo>}</mo></mrow></math>。
- en: 'Look back at the two example matrices in this subsection. You’ll notice that
    the first matrix contains columns that can be formed as scaled versions of other
    columns, whereas the second matrix contains columns that form an independent set.
    That’s no coincidence: there is a tight relationship between the dimensionality
    of the null space and the linear independence of the columns in a matrix. The
    exact nature of that relationship is given by the rank-nullity theorem, which
    you’ll learn about in the next chapter. But they key point is this: the null space
    is empty when the columns of the matrix form a linearly independent set.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾本小节中的两个示例矩阵。你会注意到第一个矩阵包含可以形成其他列的缩放版本的列，而第二个矩阵包含形成独立集的列。这不是巧合：矩阵的列的线性无关性与零空间的维度有密切关系。这种关系的确切性质由秩-零度定理给出，你将在下一章学习。但关键点在于：当矩阵的列形成线性无关集时，零空间为空。
- en: 'At the risk of redundancy, I will repeat this important point: full-rank and
    full column-rank matrices have empty null spaces, whereas reduced-rank matrices
    have nonempty (nontrivial) null spaces.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 面对冗余，我将重申这一重要观点：满秩和列满秩矩阵具有空的零空间，而降秩矩阵具有非空（非平凡）的零空间。
- en: 'The Python SciPy library contains a function to compute the null space of a
    matrix. Let’s confirm our results using code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Python SciPy库包含一个计算矩阵零空间的函数。让我们使用代码确认我们的结果：
- en: '[PRE0]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here’s the output:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是输出：
- en: '[PRE1]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The second output (`[]`) is the empty set. Why did Python choose `0.70710678`
    as numerical values for the null space of `A`? Wouldn’t it be easier to read if
    Python chose `1`? Given the infinity of possible vectors, Python returned a *unit
    vector* (you can mentally compute the norm of that vector knowing that <math alttext="StartRoot
    1 slash 2 EndRoot almost-equals .7071"><mrow><msqrt><mrow><mn>1</mn> <mo>/</mo>
    <mn>2</mn></mrow></msqrt> <mo>≈</mo> <mo>.</mo> <mn>7071</mn></mrow></math> ).
    Unit vectors are convenient to work with and have several nice properties, including
    numerical stability. Therefore, computer algorithms will often return unit vectors
    as bases for subspaces. You’ll see this again with eigenvectors and singular vectors.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个输出（`[]`）是空集。Python为什么选择`0.70710678`作为矩阵`A`的零空间的数值？如果Python选择`1`会不会更容易阅读？考虑到可能的无限向量，Python返回了一个*单位向量*（你可以心算该向量的范数，知道<math
    alttext="StartRoot 1 slash 2 EndRoot almost-equals .7071"><mrow><msqrt><mrow><mn>1</mn>
    <mo>/</mo> <mn>2</mn></mrow></msqrt> <mo>≈</mo> <mo>.</mo> <mn>7071</mn></mrow></math>）。单位向量便于处理，并具有数值稳定性等多种优良性质。因此，计算算法通常会返回单位向量作为子空间的基向量。在特征向量和奇异向量中，你将再次看到这一点。
- en: What does the null space look like? [Figure 6-4](#fig_6_4) shows the row vectors
    and null space for matrix `A`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 零空间是什么样子？[图6-4](#fig_6_4)展示了矩阵`A`的行向量和零空间。
- en: Why did I plot the row vectors instead of the column vectors? It turns out that
    the row space is orthogonal to the null space. That’s not for some bizarre esoteric
    reason; instead, it’s written right into the definition of the null space as <math
    alttext="bold upper A bold y equals bold 0"><mrow><mi>𝐀</mi> <mi>𝐲</mi> <mo>=</mo>
    <mn mathvariant="bold">0</mn></mrow></math> . Rewriting that equation for each
    row of the matrix ( <math alttext="a Subscript i"><msub><mi>a</mi> <mi>i</mi></msub></math>
    ) leads to the expression <math alttext="a Subscript i Baseline bold y equals
    bold 0"><mrow><msub><mi>a</mi> <mi>i</mi></msub> <mi>𝐲</mi> <mo>=</mo> <mn mathvariant="bold">0</mn></mrow></math>
    ; in other words, the dot product between each row and the null space vector is
    0.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我绘制了行向量而不是列向量？原来行空间与零空间正交。这不是因为某种奇怪的外行原因；相反，它是根据零空间的定义写成 <math alttext="bold
    upper A bold y equals bold 0"><mrow><mi>𝐀</mi> <mi>𝐲</mi> <mo>=</mo> <mn mathvariant="bold">0</mn></mrow></math>
    的。为矩阵的每一行（<math alttext="a Subscript i"><msub><mi>a</mi> <mi>i</mi></msub></math>
    ）重写该方程得到表达式 <math alttext="a Subscript i Baseline bold y equals bold 0"><mrow><msub><mi>a</mi>
    <mi>i</mi></msub> <mi>𝐲</mi> <mo>=</mo> <mn mathvariant="bold">0</mn></mrow></math>
    ；换句话说，每行与零空间向量的点积为0。
- en: '![Null spaces.](assets/plad_0604.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![零空间。](assets/plad_0604.png)'
- en: Figure 6-4\. Visualization of the null space of a matrix
  id: totrans-88
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-4\. 矩阵零空间的可视化
- en: Why all the fuss about null spaces? It may seem odd to care about vectors that
    can multiply a matrix to produce the zeros vector. But the null space is the keystone
    of finding eigenvectors and singular vectors, as you will learn in [Chapter 13](ch13.xhtml#Chapter_13).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要如此关注零空间？关心能够使矩阵乘以零向量的向量似乎有些奇怪。但零空间是找到特征向量和奇异向量的基石，你将在[第13章](ch13.xhtml#Chapter_13)学习到这一点。
- en: 'Final thought for this section: every matrix has four associated subspaces;
    you’ve learned about three (column, row, null). The fourth subspace is called
    the *right null space*, and is the null space of the rows. It’s often written
    as the null space of the matrix transpose: <math alttext="upper N left-parenthesis
    bold upper A Superscript upper T Baseline right-parenthesis"><mrow><mi>N</mi>
    <mo>(</mo> <msup><mi>𝐀</mi> <mtext>T</mtext></msup> <mo>)</mo></mrow></math> .
    A traditional mathematics curriculum would now spend several weeks exploring the
    intricacies and relationships across the four subspaces. Matrix subspaces are
    worth studying for their fascinating beauty and perfection, but that’s a level
    of depth to which we will not plunge.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的最后一点思考：每个矩阵都有四个相关子空间；你已经了解了其中三个（列、行、零空间）。第四个子空间称为*右零空间*，是行的零空间。它通常写为矩阵转置的零空间：<math
    alttext="upper N left-parenthesis bold upper A Superscript upper T Baseline right-parenthesis"><mrow><mi>N</mi>
    <mo>(</mo> <msup><mi>𝐀</mi> <mtext>T</mtext></msup> <mo>)</mo></mrow></math> 。传统的数学课程现在将花费数周探索这四个子空间的复杂性和关系。矩阵子空间因其迷人的美和完美性而值得研究，但我们不会深入到那个层次。
- en: Rank
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 秩
- en: '*Rank* is a number associated with a matrix. It is related to the dimensionalities
    of matrix subspaces, and has important implications for matrix operations, including
    inverting matrices and determining the number of solutions to a system of equations.
    As with other topics in this book, there are rich and detailed theories of matrix
    rank, but here I will focus on what you need to know for data science and related
    applications.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*秩* 是与矩阵相关的一个数字。它与矩阵子空间的维度有关，并且对矩阵操作有重要影响，包括求逆矩阵和确定方程组解的数量。与本书中的其他主题一样，矩阵秩有丰富而详细的理论，但在这里我将侧重于数据科学及其相关应用中需要了解的内容。'
- en: 'I will begin by listing a few properties of rank. In no specific order of importance:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先列出秩的几个性质。没有特定的重要顺序：
- en: Rank is a nonnegative integer, so a matrix can have a rank of 0, 1, 2, …, but
    not −2 or 3.14.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秩是非负整数，因此矩阵的秩可以是0、1、2、…，但不可以是−2或3.14。
- en: Every matrix has one unique rank; a matrix cannot simultaneously have multiple
    distinct ranks. (This also means that rank is a feature of the matrix, not of
    the rows or the columns.)
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个矩阵有一个唯一的秩；一个矩阵不能同时具有多个不同的秩。（这也意味着秩是矩阵的特征，不是行或列的特征。）
- en: The rank of a matrix is indicated using <math alttext="r left-parenthesis bold
    upper A right-parenthesis"><mrow><mi>r</mi> <mo>(</mo> <mi>𝐀</mi> <mo>)</mo></mrow></math>
    or <math alttext="r a n k left-parenthesis bold upper A right-parenthesis"><mrow><mi>r</mi>
    <mi>a</mi> <mi>n</mi> <mi>k</mi> <mo>(</mo> <mi>𝐀</mi> <mo>)</mo></mrow></math>
    . Also appropriate is “ <math alttext="bold upper A"><mi>𝐀</mi></math> is a rank-*r*
    matrix.”
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵的秩可以用 <math alttext="r left-parenthesis bold upper A right-parenthesis"><mrow><mi>r</mi>
    <mo>(</mo> <mi>𝐀</mi> <mo>)</mo></mrow></math> 或 <math alttext="r a n k left-parenthesis
    bold upper A right-parenthesis"><mrow><mi>r</mi> <mi>a</mi> <mi>n</mi> <mi>k</mi>
    <mo>(</mo> <mi>𝐀</mi> <mo>)</mo></mrow></math> 表示。也适用的是“ <math alttext="bold upper
    A"><mi>𝐀</mi></math> 是一个秩-*r* 矩阵。”
- en: The maximum possible rank of a matrix is the smaller of its row or column count.
    In other words, the maximum possible rank is min{*M*,*N*}.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵的最大可能秩是其行数或列数中较小的那个。换句话说，最大可能秩是min{*M*,*N*}。
- en: A matrix with its maximum possible rank is called “full-rank.” A matrix with
    rank *r* < min{*M*,*N*} is variously called “reduced-rank,” “rank-deficient,”
    or “singular.”
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其最大可能秩的矩阵称为“满秩”。秩 *r* < min{*M*,*N*} 的矩阵被称为“降秩的”，“秩亏”，或“奇异的”。
- en: Scalar multiplication does not affect the matrix rank (with the exception of
    0, which transforms the matrix into the zeros matrix with a rank of 0).
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标量乘法不影响矩阵的秩（0除外，它将矩阵转换为秩为0的零矩阵）。
- en: 'There are several equivalent interpretations and definitions of matrix rank.
    Those include:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵秩有几种等价的解释和定义，其中包括：
- en: The largest number of columns (or rows) that form a linearly independent set.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构成线性无关集合的最大列（或行）数。
- en: The dimensionality of the column space (which is the same as the dimensionality
    of the row space).
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列空间的维度（与行空间的维度相同）。
- en: The number of dimensions containing information in the matrix. This is not the
    same as the total number of columns or rows in the matrix, because of possible
    linear dependencies.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵中包含信息的维度数。这与矩阵中的总列数或行数不同，因为可能存在线性依赖关系。
- en: The number of nonzero singular values of the matrix.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵的非零奇异值的数量。
- en: 'It may seem surprising that the definition of rank is the same for the columns
    and the rows: is the dimensionality really the same for the column space and the
    row space, even for a nonsquare matrix? Yes it is. There are various proofs of
    this, many of which are either fairly involved or rely on the singular value decomposition,
    so I won’t include a formal proof in this chapter.^([2](ch06.xhtml#idm45733311606896))
    But I will show an example of the row and column spaces of a nonsquare matrix
    as an illustration.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 或许令人惊讶的是，排名的定义在列和行上是相同的：即使对于非方阵，列空间和行空间的维数确实是相同的吗？确实如此。有多种证明方法，其中许多方法要么非常复杂，要么依赖于奇异值分解，因此我不会在本章中包含正式的证明。^([2](ch06.xhtml#idm45733311606896))
    但我会展示一个非方阵的行和列空间的例子作为说明。
- en: 'Here is our matrix:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的矩阵：
- en: <math alttext="Start 2 By 3 Matrix 1st Row 1st Column 1 2nd Column 1 3rd Column
    negative 4 2nd Row 1st Column 2 2nd Column negative 2 3rd Column 2 EndMatrix"
    display="block"><mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>1</mn></mrow></mtd> <mtd><mrow><mo>-</mo>
    <mn>4</mn></mrow></mtd></mtr> <mtr><mtd><mn>2</mn></mtd> <mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>2</mn></mrow></mtd></mtr></mtable></mfenced></math>
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 3 Matrix 1st Row 1st Column 1 2nd Column 1 3rd Column
    negative 4 2nd Row 1st Column 2 2nd Column negative 2 3rd Column 2 EndMatrix"
    display="block"><mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>1</mn></mrow></mtd> <mtd><mrow><mo>-</mo>
    <mn>4</mn></mrow></mtd></mtr> <mtr><mtd><mn>2</mn></mtd> <mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>2</mn></mrow></mtd></mtr></mtable></mfenced></math>
- en: The column space of the matrix is in <math alttext="double-struck upper R squared"><msup><mi>ℝ</mi>
    <mn>2</mn></msup></math> while the row space is in <math alttext="double-struck
    upper R cubed"><msup><mi>ℝ</mi> <mn>3</mn></msup></math> , so those two spaces
    need to be drawn in different graphs ([Figure 6-5](#fig_6_5)). The three columns
    do not form a linearly independent set (any one column can be described as a linear
    combination of the other two), but they do span all of <math alttext="double-struck
    upper R squared"><msup><mi>ℝ</mi> <mn>2</mn></msup></math> . Therefore, the column
    space of the matrix is 2D. The two rows do form a linearly independent set, and
    the subspace they span is a 2D plane in <math alttext="double-struck upper R cubed"><msup><mi>ℝ</mi>
    <mn>3</mn></msup></math> .
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的列空间在<math alttext="双击上R平方"><msup><mi>ℝ</mi> <mn>2</mn></msup></math>中，而行空间在<math
    alttext="双击上R立方"><msup><mi>ℝ</mi> <mn>3</mn></msup></math>中，因此这两个空间需要在不同的图表中绘制（[图6-5](#fig_6_5)）。这三列不构成线性独立集（任意一列可以描述为其他两列的线性组合），但它们确实张成了整个<math
    alttext="双击上R平方"><msup><mi>ℝ</mi> <mn>2</mn></msup></math>。因此，矩阵的列空间是2维的。这两行确实构成了线性独立集，它们张成的子空间是<math
    alttext="双击上R立方"><msup><mi>ℝ</mi> <mn>3</mn></msup></math>中的一个2维平面。
- en: 'To be clear: the column space and row space of the matrix are *different*.
    But the *dimensionality* of those matrix spaces is the same. And that dimensionality
    is the rank of the matrix. So this matrix has a rank of 2.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 明确一下：矩阵的列空间和行空间是*不同*的。但是这些矩阵空间的*维数*是相同的。而这个维数就是矩阵的排名。因此，这个矩阵的排名是2。
- en: '![Row and column space of a matrix.](assets/plad_0605.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵的行和列空间。](assets/plad_0605.png)'
- en: Figure 6-5\. The column and row spaces have different spans but the same dimensionalities
  id: totrans-111
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-5。列空间和行空间有不同的张成但相同的维数
- en: Following are some matrices. Although I haven’t yet taught you how to compute
    rank, try to guess the rank of each matrix based on the previous descriptions.
    The answers are in the footnote.^([3](ch06.xhtml#idm45733311575264))
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些矩阵。尽管我还没有教您如何计算排名，但请试着根据前面的描述猜测每个矩阵的排名。答案在脚注中。^([3](ch06.xhtml#idm45733311575264))
- en: <math display="block"><mrow><mi>𝐀</mi> <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>4</mn></mtd></mtr></mtable></mfenced>
    <mo>,</mo> <mi>𝐁</mi> <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mn>2</mn></mtd> <mtd><mn>6</mn></mtd></mtr>
    <mtr><mtd><mn>4</mn></mtd> <mtd><mn>12</mn></mtd></mtr></mtable></mfenced> <mo>,</mo>
    <mi>𝐂</mi> <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mrow><mn>3.1</mn></mrow></mtd></mtr> <mtr><mtd><mn>2</mn></mtd> <mtd><mn>6</mn></mtd></mtr>
    <mtr><mtd><mn>4</mn></mtd> <mtd><mn>12</mn></mtd></mtr></mtable></mfenced> <mo>,</mo>
    <mi>𝐃</mi> <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>3</mn></mtd> <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>6</mn></mtd> <mtd><mn>6</mn></mtd>
    <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>4</mn></mtd> <mtd><mn>2</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable></mfenced>
    <mo>,</mo> <mi>𝐄</mi> <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd>
    <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced>
    <mo>,</mo> <mi>𝐅</mi> <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mrow><mi>𝐀</mi> <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>4</mn></mtd></mtr></mtable></mfenced>
    <mo>,</mo> <mi>𝐁</mi> <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mn>2</mn></mtd> <mtd><mn>6</mn></mtd></mtr>
    <mtr><mtd><mn>4</mn></mtd> <mtd><mn>12</mn></mtd></mtr></mtable></mfenced> <mo>,</mo>
    <mi>𝐂</mi> <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mrow><mn>3.1</mn></mrow></mtd></mtr> <mtr><mtd><mn>2</mn></mtd> <mtd><mn>6</mn></mtd></mtr>
    <mtr><mtd><mn>4</mn></mtd> <mtd><mn>12</mn></mtd></mtr></mtable></mfenced> <mo>,</mo>
    <mi>𝐃</mi> <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>3</mn></mtd> <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>6</mn></mtd> <mtd><mn>6</mn></mtd>
    <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>4</mn></mtd> <mtd><mn>2</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable></mfenced>
    <mo>,</mo> <mi>𝐄</mi> <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd>
    <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced>
    <mo>,</mo> <mi>𝐅</mi> <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: I hope you managed to figure out the ranks, or at least weren’t shocked to see
    the answers in the footnote.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您已经设法弄清楚了排名，或者至少不会对脚注中的答案感到震惊。
- en: Needless to say, visual inspection and some intuition is not a scalable method
    for computing rank in practice. There are several methods to compute rank. For
    example, in [Chapter 10](ch10.xhtml#Chapter_10) you’ll learn that you can compute
    the rank by row reducing a matrix to its echelon form and counting the number
    of pivots. Computer programs like Python compute rank by counting the number of
    nonzero singular values of the matrix. You’ll learn about that in [Chapter 14](ch14.xhtml#Chapter_14).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 毋庸置疑，视觉检查和直觉并不是实际计算排名的可扩展方法。有几种计算排名的方法。例如，在[第10章](ch10.xhtml#Chapter_10)中，您将学习如何通过将矩阵行减少至梯形形式并计算主元的数量来计算排名。像Python这样的计算机程序通过计算矩阵的非零奇异值的数量来计算排名。您将在[第14章](ch14.xhtml#Chapter_14)中了解更多相关信息。
- en: For now, I would like you to focus on the idea that the rank corresponds to
    the largest number of columns that can form a linearly independent set, which
    also corresponds to the dimensionality of the column space of the matrix. (You
    can replace “column” with “row” in the previous sentence and it will be equally
    accurate.)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我希望您专注于这样一个观念：排名对应于可以形成线性独立集合的最大列数，这也对应于矩阵列空间的维数。（在前述句子中，您可以将“列”替换为“行”，其仍然是准确的。）
- en: Ranks of Special Matrices
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊矩阵的排名
- en: 'Some special matrices have ranks that are easy to compute or that are worth
    learning about:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一些特殊的矩阵有易于计算的或值得学习的排名：
- en: Vectors
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 向量
- en: All vectors have a rank of 1\. That’s because vectors—by definition—have only
    one column (or row) of information; the subspace they span is 1D. The only exception
    is the zeros vector.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 所有向量的秩都为1。这是因为向量——定义上——只包含一列（或行）信息；它们所张成的子空间是一维的。唯一的例外是零向量。
- en: Zeros matrices
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 零矩阵
- en: The zeros matrix of any size (including the zeros vector) has a rank of 0.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 任何大小的零矩阵（包括零向量）的秩为0。
- en: Identity matrices
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 单位矩阵
- en: The rank of the identity matrix equals the number of rows (which equals the
    number of columns). In other words, <math alttext="r left-parenthesis bold upper
    I Subscript upper N Baseline right-parenthesis equals upper N"><mrow><mi>r</mi>
    <mo>(</mo> <msub><mi>𝐈</mi> <mi>N</mi></msub> <mo>)</mo> <mo>=</mo> <mi>N</mi></mrow></math>
    . In fact, the identity matrix is simply a special case of a diagonal matrix.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 单位矩阵的秩等于行数（也等于列数）。换句话说，<math alttext="r left-parenthesis bold upper I Subscript
    upper N Baseline right-parenthesis equals upper N"><mrow><mi>r</mi> <mo>(</mo>
    <msub><mi>𝐈</mi> <mi>N</mi></msub> <mo>)</mo> <mo>=</mo> <mi>N</mi></mrow></math>
    。实际上，单位矩阵只是对角矩阵的一个特例。
- en: Diagonal matrices
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对角矩阵
- en: The rank of a diagonal matrix equals the number of nonzero diagonal elements.
    This is because each row contains maximum one nonzero element, and it is impossible
    to create a nonzero number through weighted combinations of zeros. This property
    becomes useful when solving systems of equations and interpreting the singular
    value decomposition.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对角矩阵的秩等于非零对角元素的数量。这是因为每行最多包含一个非零元素，通过零的加权组合不可能创建非零数。在解方程组和解释奇异值分解时，这个属性变得非常有用。
- en: Triangular matrices
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 三角矩阵
- en: A triangular matrix is full rank only if there are nonzero values in all diagonal
    elements. A triangular matrix with at least one zero in the diagonal will be reduced
    rank (the exact rank will depend on the numerical values in the matrix).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 三角矩阵仅在所有对角元素中有非零值时具有满秩。具有至少一个对角零的三角矩阵将是降秩的（确切的秩取决于矩阵中的数值）。
- en: Random matrices
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 随机矩阵
- en: The rank of a random matrix is impossible to know a priori, because it depends
    on the distribution of numbers from which the elements in the matrix were drawn
    and on the probability of drawing each number. For example, a <math alttext="2
    times 2"><mrow><mn>2</mn> <mo>×</mo> <mn>2</mn></mrow></math> matrix populated
    with either 0s or 1s could have a rank of 0 if the individual elements all equal
    0\. Or it could have a rank of 2, e.g., if the identity matrix is randomly selected.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 随机矩阵的秩是不可能事先知道的，因为它取决于从中提取矩阵元素的数字分布及每个数字提取的概率。例如，一个由0或1填充的<math alttext="2 times
    2"><mrow><mn>2</mn> <mo>×</mo> <mn>2</mn></mrow></math>矩阵如果每个元素都等于0，则其秩可能为0。或者，例如如果选择了单位矩阵，则其秩可能为2。
- en: But there is a way to create random matrices with guaranteed maximum possible
    rank. This is done by drawing floating-point numbers at random, e.g., from a Gaussian
    or uniform distribution. A 64-bit computer can represent <math alttext="2 Superscript
    64"><msup><mn>2</mn> <mn>64</mn></msup></math> numbers. Drawing a few dozen or
    hundred from that set to put in a matrix means that the likelihood of linear dependencies
    in the columns of the matrix is astronomically unlikely. So unlikely, in fact,
    that it could power the Infinite Improbability Drive of the *Heart of Gold*.^([4](ch06.xhtml#idm45733311477072))
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有一种方法可以创建具有保证最大可能秩的随机矩阵。这是通过随机抽取浮点数，例如从高斯或均匀分布中进行。64位计算机可以表示<math alttext="2
    Superscript 64"><msup><mn>2</mn> <mn>64</mn></msup></math>个数字。从该集合中抽取几十个或几百个放入矩阵中意味着矩阵列中的线性依赖性的可能性极其低。实际上，这种可能性如此之低，以至于可以驱动*Heart
    of Gold*上的无穷不可能驱动器。^([4](ch06.xhtml#idm45733311477072))
- en: The point is that matrices created via, e.g., `np.random.randn()` will have
    the maximum possible rank. This is useful for using Python to learn linear algebra,
    because you can create a matrix with any arbitrary rank (subject to constraints
    discussed earlier). [Exercise 6-5](#exercise_6_5) will guide you through the process.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于通过例如`np.random.randn()`创建的矩阵将具有可能的最大秩。这对使用Python学习线性代数非常有用，因为可以创建具有任意秩的矩阵（受前述约束的限制）。[Exercise
    6-5](#exercise_6_5)将指导您完成这个过程。
- en: Rank-1 matrices
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 秩为1的矩阵
- en: 'A rank-1 matrix has—you guessed it—a rank of 1\. This means that there is actually
    only one column’s worth of information (alternatively: there is only one row’s
    worth of information) in the matrix, and all other columns (or rows) are simply
    linear multiples. You saw a few examples of rank-1 matrices earlier in this chapter.
    Here are a few more:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一个秩-1矩阵有——你猜对了——秩为1。这意味着矩阵中实际上只有一列的信息（或者说只有一行的信息），而其他所有列（或行）都只是线性倍数。在本章的早些时候，你看到了一些秩-1矩阵的例子。以下是一些更多的例子：
- en: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column negative 2 2nd Column
    negative 4 3rd Column negative 4 2nd Row 1st Column negative 1 2nd Column negative
    2 3rd Column negative 2 3rd Row 1st Column 0 2nd Column 0 3rd Column 0 EndMatrix
    comma Start 4 By 2 Matrix 1st Row 1st Column 2 2nd Column 1 2nd Row 1st Column
    0 2nd Column 0 3rd Row 1st Column 2 2nd Column 1 4th Row 1st Column 4 2nd Column
    2 EndMatrix comma Start 3 By 5 Matrix 1st Row 1st Column 12 2nd Column 4 3rd Column
    4 4th Column 12 5th Column 4 2nd Row 1st Column 6 2nd Column 2 3rd Column 2 4th
    Column 6 5th Column 2 3rd Row 1st Column 9 2nd Column 3 3rd Column 3 4th Column
    9 5th Column 3 EndMatrix" display="block"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mrow><mo>-</mo> <mn>4</mn></mrow></mtd> <mtd><mrow><mo>-</mo>
    <mn>4</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>1</mn></mrow></mtd>
    <mtd><mrow><mo>-</mo> <mn>2</mn></mrow></mtd> <mtd><mrow><mo>-</mo> <mn>2</mn></mrow></mtd></mtr>
    <mtr><mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>0</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>0</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>0</mn></mrow></mtd></mtr></mtable></mfenced>
    <mo>,</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>2</mn></mtd> <mtd><mn>1</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>2</mn></mtd>
    <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>4</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced>
    <mo>,</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>12</mn></mtd> <mtd><mn>4</mn></mtd>
    <mtd><mn>4</mn></mtd> <mtd><mn>12</mn></mtd> <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mn>6</mn></mtd>
    <mtd><mn>2</mn></mtd> <mtd><mn>2</mn></mtd> <mtd><mn>6</mn></mtd> <mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mn>9</mn></mtd> <mtd><mn>3</mn></mtd> <mtd><mn>3</mn></mtd> <mtd><mn>9</mn></mtd>
    <mtd><mn>3</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column negative 2 2nd Column
    negative 4 3rd Column negative 4 2nd Row 1st Column negative 1 2nd Column negative
    2 3rd Column negative 2 3rd Row 1st Column 0 2nd Column 0 3rd Column 0 EndMatrix
    comma Start 4 By 2 Matrix 1st Row 1st Column 2 2nd Column 1 2nd Row 1st Column
    0 2nd Column 0 3rd Row 1st Column 2 2nd Column 1 4th Row 1st Column 4 2nd Column
    2 EndMatrix comma Start 3 By 5 Matrix 1st Row 1st Column 12 2nd Column 4 3rd Column
    4 4th Column 12 5th Column 4 2nd Row 1st Column 6 2nd Column 2 3rd Column 2 4th
    Column 6 5th Column 2 3rd Row 1st Column 9 2nd Column 3 3rd Column 3 4th Column
    9 5th Column 3 EndMatrix" display="block"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mrow><mo>-</mo> <mn>4</mn></mrow></mtd> <mtd><mrow><mo>-</mo>
    <mn>4</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>1</mn></mrow></mtd>
    <mtd><mrow><mo>-</mo> <mn>2</mn></mrow></mtd> <mtd><mrow><mo>-</mo> <mn>2</mn></mrow></mtd></mtr>
    <mtr><mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>0</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>0</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>0</mn></mrow></mtd></mtr></mtable></mfenced>
    <mo>,</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>2</mn></mtd> <mtd><mn>1</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>2</mn></mtd>
    <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>4</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced>
    <mo>,</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>12</mn></mtd> <mtd><mn>4</mn></mtd>
    <mtd><mn>4</mn></mtd> <mtd><mn>12</mn></mtd> <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mn>6</mn></mtd>
    <mtd><mn>2</mn></mtd> <mtd><mn>2</mn></mtd> <mtd><mn>6</mn></mtd> <mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mn>9</mn></mtd> <mtd><mn>3</mn></mtd> <mtd><mn>3</mn></mtd> <mtd><mn>9</mn></mtd>
    <mtd><mn>3</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: Rank-1 matrices can be square, tall, or wide; regardless of the size, each column
    is a scaled copy of the first column (or each row is a scaled copy of the first
    row).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 秩-1矩阵可以是方阵、长方阵或宽方阵；无论尺寸如何，每列都是第一列的缩放副本（或每行是第一行的缩放副本）。
- en: How does one create a rank-1 matrix? Actually, you already learned how in [Chapter 2](ch02.xhtml#Chapter_2)
    (although I only briefly mentioned it; you are forgiven for forgetting). The answer
    is by taking the outer product between two nonzeros vectors. For example, the
    third matrix above is the outer product of [4 2 3] <math alttext="Superscript
    upper T"><msup><mtext>T</mtext></msup></math> and [3 1 1 3 1].
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如何创建一个秩-1矩阵？实际上，你在[第2章](ch02.xhtml#Chapter_2)已经学过（尽管我只是简要提到了它；你原谅你忘记了）。答案是通过两个非零向量的外积。例如，上面的第三个矩阵是向量[4
    2 3]<math alttext="Superscript upper T"><msup><mtext>T</mtext></msup></math>和[3
    1 1 3 1]的外积。
- en: Rank-1 matrices are important in eigendecomposition and the singular value decomposition.
    You’ll encounter many rank-1 matrices in later chapters in this book—and in your
    adventures in applied linear algebra.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 秩-1矩阵在特征分解和奇异值分解中很重要。在本书的后面章节和你在应用线性代数中的冒险中，你会遇到许多秩-1矩阵。
- en: Rank of Added and Multiplied Matrices
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加和乘积矩阵的秩
- en: If you know the ranks of matrices <math alttext="bold upper A"><mi>𝐀</mi></math>
    and <math alttext="bold upper B"><mi>𝐁</mi></math> , do you automatically know
    the rank of <math alttext="bold upper A plus bold upper B"><mrow><mi>𝐀</mi> <mo>+</mo>
    <mi>𝐁</mi></mrow></math> or <math alttext="bold upper A bold upper B"><mrow><mi>𝐀</mi>
    <mi>𝐁</mi></mrow></math> ?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道矩阵<math alttext="bold upper A"><mi>𝐀</mi></math>和<math alttext="bold upper
    B"><mi>𝐁</mi></math>的秩，你是否自动知道<math alttext="bold upper A plus bold upper B"><mrow><mi>𝐀</mi>
    <mo>+</mo> <mi>𝐁</mi></mrow></math>或<math alttext="bold upper A bold upper B"><mrow><mi>𝐀</mi>
    <mi>𝐁</mi></mrow></math>的秩？
- en: 'The answer is no, you don’t. But, the ranks of the two individual matrices
    provide upper bounds for the maximum possible rank. Here are the rules:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是否定的，你不需要知道。但是，两个单独矩阵的秩提供了可能的最大秩的上限。以下是规则：
- en: <math alttext="r a n k left-parenthesis bold upper A plus bold upper B right-parenthesis
    less-than-or-equal-to r a n k left-parenthesis bold upper A right-parenthesis
    plus r a n k left-parenthesis bold upper B right-parenthesis" display="block"><mrow><mi>r</mi>
    <mi>a</mi> <mi>n</mi> <mi>k</mi> <mo>(</mo> <mi>𝐀</mi> <mo>+</mo> <mi>𝐁</mi> <mo>)</mo>
    <mo>≤</mo> <mi>r</mi> <mi>a</mi> <mi>n</mi> <mi>k</mi> <mo>(</mo> <mi>𝐀</mi> <mo>)</mo>
    <mo>+</mo> <mi>r</mi> <mi>a</mi> <mi>n</mi> <mi>k</mi> <mo>(</mo> <mi>𝐁</mi> <mo>)</mo></mrow></math><math
    alttext="r a n k left-parenthesis bold upper A bold upper B right-parenthesis
    less-than-or-equal-to min left-brace r a n k left-parenthesis bold upper A right-parenthesis
    comma r a n k left-parenthesis bold upper B right-parenthesis right-brace" display="block"><mrow><mi>r</mi>
    <mi>a</mi> <mi>n</mi> <mi>k</mi> <mo>(</mo> <mi>𝐀</mi> <mi>𝐁</mi> <mo>)</mo> <mo>≤</mo>
    <mo form="prefix" movablelimits="true">min</mo> <mo>{</mo> <mi>r</mi> <mi>a</mi>
    <mi>n</mi> <mi>k</mi> <mo>(</mo> <mi>𝐀</mi> <mo>)</mo> <mo>,</mo> <mi>r</mi> <mi>a</mi>
    <mi>n</mi> <mi>k</mi> <mo>(</mo> <mi>𝐁</mi> <mo>)</mo> <mo>}</mo></mrow></math>
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="r a n k left-parenthesis bold upper A plus bold upper B right-parenthesis
    less-than-or-equal-to r a n k left-parenthesis bold upper A right-parenthesis
    plus r a n k left-parenthesis bold upper B right-parenthesis" display="block"><mrow><mi>r</mi>
    <mi>a</mi> <mi>n</mi> <mi>k</mi> <mo>(</mo> <mi>𝐀</mi> <mo>+</mo> <mi>𝐁</mi> <mo>)</mo>
    <mo>≤</mo> <mi>r</mi> <mi>a</mi> <mi>n</mi> <mi>k</mi> <mo>(</mo> <mi>𝐀</mi> <mo>)</mo>
    <mo>+</mo> <mi>r</mi> <mi>a</mi> <mi>n</mi> <mi>k</mi> <mo>(</mo> <mi>𝐁</mi> <mo>)</mo></mrow></math><math
    alttext="r a n k left-parenthesis bold upper A bold upper B right-parenthesis
    less-than-or-equal-to min left-brace r a n k left-parenthesis bold upper A right-parenthesis
    comma r a n k left-parenthesis bold upper B right-parenthesis right-brace" display="block"><mrow><mi>r</mi>
    <mi>a</mi> <mi>n</mi> <mi>k</mi> <mo>(</mo> <mi>𝐀</mi> <mi>𝐁</mi> <mo>)</mo> <mo>≤</mo>
    <mo form="prefix" movablelimits="true">min</mo> <mo>{</mo> <mi>r</mi> <mi>a</mi>
    <mi>n</mi> <mi>k</mi> <mo>(</mo> <mi>𝐀</mi> <mo>)</mo> <mo>,</mo> <mi>r</mi> <mi>a</mi>
    <mi>n</mi> <mi>k</mi> <mo>(</mo> <mi>𝐁</mi> <mo>)</mo> <mo>}</mo></mrow></math>
- en: 'I don’t recommend memorizing these rules. But I do recommend memorizing the
    following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我不建议记忆这些规则。但我建议记忆以下内容：
- en: You cannot know the exact rank of a summed or product matrix based on knowing
    the ranks of the individual matrices (with a few exceptions, e.g., the zeros matrix);
    instead, the individual matrices provide upper bounds for the rank of the summed
    or product matrix.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你无法仅凭知道各个矩阵的秩来知道求和或乘积矩阵的确切秩（有少数例外，例如零矩阵）；相反，各个矩阵为求和或乘积矩阵的秩提供了上限。
- en: The rank of a summed matrix could be greater than the ranks of the individual
    matrices.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个求和矩阵的秩可能大于各个矩阵的秩。
- en: The rank of a product matrix cannot be greater than the largest rank of the
    multiplying matrices.^([5](ch06.xhtml#idm45733311375120))
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乘积矩阵的秩不可能大于相乘矩阵中的最大秩^([5](ch06.xhtml#idm45733311375120))
- en: In [Exercise 6-6](#exercise_6_6), you will have the opportunity to illustrate
    these two rules using random matrices of various ranks.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [练习6-6](#exercise_6_6) 中，你将有机会使用不同秩的随机矩阵来说明这两条规则。
- en: Rank of Shifted Matrices
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移位矩阵的秩
- en: 'Simply put: shifted matrices have full rank. In fact, one of the primary goals
    of shifting a square matrix is to increase its rank from *r* < *M* to *r* = *M*.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之：移位矩阵具有全秩。事实上，移位方形矩阵的主要目标之一是将其秩从 *r* < *M* 增加到 *r* = *M*。
- en: An obvious example is shifting the zeros matrix by the identity matrix. The
    rank of the resulting sum <math alttext="bold 0 plus bold upper I"><mrow><mn mathvariant="bold">0</mn>
    <mo>+</mo> <mi>𝐈</mi></mrow></math> is a full-rank matrix.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一个明显的例子是将零矩阵移位为单位矩阵。所得和的秩 <math alttext="bold 0 plus bold upper I"><mrow><mn
    mathvariant="bold">0</mn> <mo>+</mo> <mi>𝐈</mi></mrow></math> 是一个全秩矩阵。
- en: 'Here’s another, slightly less obvious, example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是另一个稍微不那么明显的例子：
- en: <math mode="display"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>3</mn></mtd> <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>5</mn></mtd> <mtd><mn>7</mn></mtd>
    <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>2</mn></mtd> <mtd><mn>2</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable></mfenced>
    <mo>+</mo> <mn>.01</mn> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mn>1.01</mn></mrow></mtd>
    <mtd><mn>3</mn></mtd> <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>5</mn></mtd> <mtd><mrow><mn>7.01</mn></mrow></mtd>
    <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>2</mn></mtd> <mtd><mn>2</mn></mtd> <mtd><mrow><mn>.01</mn></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: <math mode="display"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>3</mn></mtd> <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>5</mn></mtd> <mtd><mn>7</mn></mtd>
    <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>2</mn></mtd> <mtd><mn>2</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable></mfenced>
    <mo>+</mo> <mn>.01</mn> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mn>1.01</mn></mrow></mtd>
    <mtd><mn>3</mn></mtd> <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>5</mn></mtd> <mtd><mrow><mn>7.01</mn></mrow></mtd>
    <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>2</mn></mtd> <mtd><mn>2</mn></mtd> <mtd><mrow><mn>.01</mn></mrow></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'The leftmost matrix has a rank of 2; notice that the third column equals the
    second minus the first. But the rank of the summed matrix is 3: the third column
    can no longer be produced by some linear combination of the first two. And yet,
    the information in the matrix has hardly changed; indeed, the Pearson correlation
    between the elements in the original and shifted matrix is <math alttext="rho"><mi>ρ</mi></math>
    = 0.999997222233796\. This has significant implications: for example, the rank-2
    matrix cannot be inverted whereas the shifted matrix can. (You’ll learn why in
    [Chapter 8](ch08.xhtml#Chapter_08).)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最左边的矩阵的秩是2；注意第三列等于第二列减去第一列。但是求和矩阵的秩是3：第三列不再能由第一列和第二列的线性组合产生。然而，矩阵中的信息几乎没有改变；事实上，原始矩阵和移位后矩阵中元素的皮尔逊相关系数为
    <math alttext="rho"><mi>ρ</mi></math> = 0.999997222233796。这具有重要的含义：例如，秩为2的矩阵无法求逆，而移位后的矩阵可以。（在
    [第8章](ch08.xhtml#Chapter_08) 你将了解原因。）
- en: Theory and Practice
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理论与实践
- en: Understanding Singular Values Before Understanding Singular Values
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在理解奇异值之前理解奇异值
- en: It is impossible to learn mathematics in a purely monotonic fashion, meaning
    you fully understand concept *a* before fully learning about concept *b* and so
    on. A complete understanding of matrix rank requires knowing about the singular
    value decomposition (SVD), but the SVD doesn’t make sense until you know about
    rank. It’s a bit of a catch-22\. This is part of what makes math frustrating to
    learn. The good news is that pages in this book continue to exist after you read
    them, so if the following discussion isn’t completely sensible, come back after
    learning about the SVD.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 无法以纯单调的方式学习数学，这意味着你在完全理解概念 *a* 之前就完全学习了概念 *b* 等等。完全理解矩阵秩需要了解奇异值分解（SVD），但在了解秩之前理解SVD是没有意义的。这有点像一个进退两难的局面。这也是数学学习的一部分令人沮丧之处。好消息是，在你阅读后，本书的页面仍然存在，所以如果以下讨论不完全合理，学习了SVD后再回来看也不迟。
- en: 'Briefly: every <math alttext="upper M times upper N"><mrow><mi>M</mi> <mo>×</mo>
    <mi>N</mi></mrow></math> matrix has a set of min{*M*,*N*} nonnegative singular
    values that encode the “importance” or “spaciousness” of different directions
    in the column and row spaces of the matrix. Directions with a singular value of
    0 are in one of the null spaces.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之：每个 <math alttext="upper M times upper N"><mrow><mi>M</mi> <mo>×</mo> <mi>N</mi></mrow></math>
    矩阵具有一组编码矩阵列空间和行空间中不同方向“重要性”或“广阔性”的最小{*M*,*N*}个非负奇异值。奇异值为0的方向位于其中一个零空间中。
- en: In abstract linear algebra, the rank is a rock-solid concept. Each matrix has
    exactly one rank, and that’s the end of the story.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在抽象线性代数中，秩是一个非常坚实的概念。每个矩阵都恰好有一个秩，就是故事的结局。
- en: 'In practice, however, computing the matrix rank entails some uncertainty. Arguably,
    computers don’t even *compute* the rank; they *estimate* it to a reasonable degree
    of accuracy. I wrote earlier that rank can be computed as the number of nonzero
    singular values. But that’s not what Python does. Following are two key lines
    excerpted from `np.linalg.matrix_rank()` (I’ve dropped a few arguments to focus
    on the main point):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实际操作中，计算矩阵秩涉及一定的不确定性。可以说，计算机甚至不是在*计算*秩；它们*估算*到了一个合理的精度程度。我之前写道，秩可以被计算为非零奇异值的数量。但
    Python 并不是这么做的。以下是从 `np.linalg.matrix_rank()` 中摘录的两行关键内容（我省略了一些参数以便专注于主要内容）：
- en: '[PRE2]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`M` is the matrix in question, `S` is a vector of singular values, and `tol`
    is a tolerance threshold. This means that NumPy is not actually counting *nonzero*
    singular values; it is counting singular values that are larger than some threshold.
    The exact threshold value depends on the numerical values in the matrix, but is
    generally around 10 to 12 orders of magnitude smaller than the matrix elements.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`M` 是所讨论的矩阵，`S` 是奇异值的向量，`tol` 是一个容差阈值。这意味着 NumPy 实际上并不是在计算*非零*奇异值；它在计算大于某个阈值的奇异值。确切的阈值取决于矩阵中的数值，但通常比矩阵元素小约
    10 到 12 个数量级。'
- en: This means that NumPy makes a decision about what numbers are small enough to
    be considered “effectively zero.” I am certainly not criticizing NumPy—this is
    the right thing to do! (Other numerical processing programs like MATLAB and Julia
    compute rank in the same way.)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 NumPy 对哪些数字足够小以被视为“有效零”做出了决策。我当然不是在批评 NumPy —— 这是正确的做法！（其他数值处理程序如 MATLAB
    和 Julia 也以同样的方式计算秩。）
- en: But why do this? Why not simply count the nonzero singular values? The answer
    is that the tolerance absorbs small numerical inaccuracies that may arise due
    to computer rounding error. Having a tolerance also allows for ignoring tiny amounts
    of noise that might, for example, contaminate the data-acquisition sensors. This
    idea is used in data cleaning, compression, and dimension reduction. [Figure 6-6](#fig_6_6)
    illustrates the concept.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么要这样做？为什么不简单地计算非零奇异值的数量？答案是容差可以吸收由于计算机舍入误差而引起的小数值不准确性。容差还允许忽略可能污染数据采集传感器的微小噪声。这个思想被用于数据清理、压缩和降维。[图
    6-6](#fig_6_6)说明了这个概念。
- en: '![Noise can corrupt rank.](assets/plad_0606.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![噪声可能导致秩的破坏。](assets/plad_0606.png)'
- en: Figure 6-6\. A 3 × 3 matrix representing a 2D plane may be considered rank-3
    in the presence of a small amount of noise. The rightmost diagram shows the perspective
    of looking directly across the surface of the plane.
  id: totrans-165
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-6\. 一个代表 2D 平面的 3 × 3 矩阵，在存在少量噪声时可能被视为秩为 3。最右边的图表显示了直接从平面表面观察的视角。
- en: Rank Applications
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 秩的应用
- en: There are many applications of matrix rank. In this section, I will introduce
    two of them.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵秩有许多应用。在这一节中，我将介绍其中的两个。
- en: In the Column Space?
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在列空间中吗？
- en: In [Chapter 4](ch04.xhtml#Chapter_4), you learned about the column space of
    a matrix, and you learned that an important question in linear algebra is whether
    a vector is in the column space of a matrix (which can be mathematically written
    as <math alttext="bold v element-of upper C left-parenthesis bold upper A right-parenthesis
    question-mark"><mrow><mi>𝐯</mi> <mo>∈</mo> <mi>C</mi> <mo>(</mo> <mi>𝐀</mi> <mo>)</mo>
    <mo>?</mo></mrow></math> ). I also wrote that answering the question in a rigorous
    and scalable way depends on understanding matrix rank.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第四章](ch04.xhtml#Chapter_4)中，你学习了矩阵的列空间，并且学到了线性代数中一个重要的问题是一个向量是否在矩阵的列空间内（这可以用数学方式表达为
    <math alttext="bold v element-of upper C left-parenthesis bold upper A right-parenthesis
    question-mark"><mrow><mi>𝐯</mi> <mo>∈</mo> <mi>C</mi> <mo>(</mo> <mi>𝐀</mi> <mo>)</mo>
    <mo>?</mo></mrow></math> ）。我也写道，以严格且可扩展的方式回答这个问题取决于理解矩阵秩。
- en: Before telling you the algorithm for determining whether <math alttext="bold
    v element-of upper C left-parenthesis bold upper A right-parenthesis"><mrow><mi>𝐯</mi>
    <mo>∈</mo> <mi>C</mi> <mo>(</mo> <mi>𝐀</mi> <mo>)</mo></mrow></math> , I need
    to briefly introduce a procedure called *augmenting* a matrix.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在告诉你确定向量是否在矩阵的列空间内的算法之前，我需要简要介绍一个叫做*增广*矩阵的过程。
- en: To augment a matrix means to add extra columns to the right-hand side of the
    matrix. You start with the “base” <math alttext="upper M times upper N"><mrow><mi>M</mi>
    <mo>×</mo> <mi>N</mi></mrow></math> matrix and the “extra” <math alttext="upper
    M times upper K"><mrow><mi>M</mi> <mo>×</mo> <mi>K</mi></mrow></math> matrix.
    The augmented matrix is of size <math alttext="upper M times left-parenthesis
    upper N plus upper K right-parenthesis"><mrow><mi>M</mi> <mo>×</mo> <mo>(</mo>
    <mi>N</mi> <mo>+</mo> <mi>K</mi> <mo>)</mo></mrow></math> . Augmenting two matrices
    is valid as long as they have the same number of rows (they can have a different
    number of columns). You’ll see augmented matrices here in this section, and again
    in [Chapter 10](ch10.xhtml#Chapter_10) when solving systems of equations.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 增广矩阵意味着在矩阵的右侧添加额外的列。你从“基础” <math alttext="upper M times upper N"><mrow><mi>M</mi>
    <mo>×</mo> <mi>N</mi></mrow></math> 矩阵和“额外” <math alttext="upper M times upper
    K"><mrow><mi>M</mi> <mo>×</mo> <mi>K</mi></mrow></math> 矩阵开始。增广矩阵的大小为 <math alttext="upper
    M times left-parenthesis upper N plus upper K right-parenthesis"><mrow><mi>M</mi>
    <mo>×</mo> <mo>(</mo> <mi>N</mi> <mo>+</mo> <mi>K</mi> <mo>)</mo></mrow></math>
    。只要它们具有相同的行数（可以具有不同的列数），增广两个矩阵就是有效的。你将在本节中看到增广矩阵的示例，并在[第10章](ch10.xhtml#Chapter_10)中解决方程组时再次看到它们。
- en: 'Following is an example that illustrates the procedure:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个说明该过程的示例：
- en: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 4 2nd Column 5 3rd Column
    6 2nd Row 1st Column 0 2nd Column 1 3rd Column 2 3rd Row 1st Column 9 2nd Column
    9 3rd Column 4 EndMatrix square-cup Start 3 By 1 Matrix 1st Row  1 2nd Row  2
    3rd Row  3 EndMatrix equals Start 3 By 4 Matrix 1st Row 1st Column 4 2nd Column
    5 3rd Column 6 4th Column 1 2nd Row 1st Column 0 2nd Column 1 3rd Column 2 4th
    Column 2 3rd Row 1st Column 9 2nd Column 9 3rd Column 4 4th Column 3 EndMatrix"
    display="block"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mn>4</mn></mtd>
    <mtd><mn>5</mn></mtd> <mtd><mn>6</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd>
    <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>9</mn></mtd> <mtd><mn>9</mn></mtd> <mtd><mn>4</mn></mtd></mtr></mtable></mfenced>
    <mo>⊔</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>3</mn></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>4</mn></mtd> <mtd><mn>5</mn></mtd>
    <mtd><mn>6</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd>
    <mtd><mn>2</mn></mtd> <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>9</mn></mtd> <mtd><mn>9</mn></mtd>
    <mtd><mn>4</mn></mtd> <mtd><mn>3</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 4 2nd Column 5 3rd Column
    6 2nd Row 1st Column 0 2nd Column 1 3rd Column 2 3rd Row 1st Column 9 2nd Column
    9 3rd Column 4 EndMatrix square-cup Start 3 By 1 Matrix 1st Row  1 2nd Row  2
    3rd Row  3 EndMatrix equals Start 3 By 4 Matrix 1st Row 1st Column 4 2nd Column
    5 3rd Column 6 4th Column 1 2nd Row 1st Column 0 2nd Column 1 3rd Column 2 4th
    Column 2 3rd Row 1st Column 9 2nd Column 9 3rd Column 4 4th Column 3 EndMatrix"
    display="block"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mn>4</mn></mtd>
    <mtd><mn>5</mn></mtd> <mtd><mn>6</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd>
    <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>9</mn></mtd> <mtd><mn>9</mn></mtd> <mtd><mn>4</mn></mtd></mtr></mtable></mfenced>
    <mo>⊔</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>3</mn></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>4</mn></mtd> <mtd><mn>5</mn></mtd>
    <mtd><mn>6</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd>
    <mtd><mn>2</mn></mtd> <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>9</mn></mtd> <mtd><mn>9</mn></mtd>
    <mtd><mn>4</mn></mtd> <mtd><mn>3</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'With that prerequisite tangent out the way, here is the algorithm for determining
    whether a vector is in the column space of a matrix:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决向量是否在矩阵列空间中的算法之前，先来介绍一个先决条件的切入点：
- en: '**Augment the matrix with the vector**. Let’s call the original matrix <math
    alttext="bold upper A"><mi>𝐀</mi></math> and the augmented matrix <math alttext="bold
    upper A overTilde"><mover accent="true"><mi>𝐀</mi> <mo>˜</mo></mover></math> .'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将向量增广到矩阵**。我们将原始矩阵称为 <math alttext="bold upper A"><mi>𝐀</mi></math>，增广矩阵称为
    <math alttext="bold upper A overTilde"><mover accent="true"><mi>𝐀</mi> <mo>˜</mo></mover></math>。'
- en: '**Compute the ranks of the two matrices**.'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**计算这两个矩阵的秩**。'
- en: '**Compare the two ranks**. There will be one of two possible outcomes:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**比较这两个秩**。可能有两种结果之一：'
- en: <math alttext="r a n k left-parenthesis bold upper A right-parenthesis equals
    r a n k left-parenthesis bold upper A overTilde right-parenthesis"><mrow><mi>r</mi>
    <mi>a</mi> <mi>n</mi> <mi>k</mi> <mrow><mo>(</mo> <mi>𝐀</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>r</mi> <mi>a</mi> <mi>n</mi> <mi>k</mi> <mrow><mo>(</mo> <mover
    accent="true"><mi>𝐀</mi> <mo>˜</mo></mover> <mo>)</mo></mrow></mrow></math> Vector
    <math alttext="bold v"><mi>𝐯</mi></math> is in the column space of matrix <math
    alttext="bold upper A"><mi>𝐀</mi></math> .
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="r a n k left-parenthesis bold upper A right-parenthesis equals
    r a n k left-parenthesis bold upper A overTilde right-parenthesis"><mrow><mi>r</mi>
    <mi>a</mi> <mi>n</mi> <mi>k</mi> <mrow><mo>(</mo> <mi>𝐀</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>r</mi> <mi>a</mi> <mi>n</mi> <mi>k</mi> <mrow><mo>(</mo> <mover
    accent="true"><mi>𝐀</mi> <mo>˜</mo></mover> <mo>)</mo></mrow></mrow></math> 向量
    <math alttext="bold v"><mi>𝐯</mi></math> 在矩阵 <math alttext="bold upper A"><mi>𝐀</mi></math>
    的列空间中。
- en: <math alttext="r a n k left-parenthesis bold upper A right-parenthesis less-than
    r a n k left-parenthesis bold upper A overTilde right-parenthesis"><mrow><mi>r</mi>
    <mi>a</mi> <mi>n</mi> <mi>k</mi> <mrow><mo>(</mo> <mi>𝐀</mi> <mo>)</mo></mrow>
    <mo><</mo> <mi>r</mi> <mi>a</mi> <mi>n</mi> <mi>k</mi> <mrow><mo>(</mo> <mover
    accent="true"><mi>𝐀</mi> <mo>˜</mo></mover> <mo>)</mo></mrow></mrow></math> Vector
    <math alttext="bold v"><mi>𝐯</mi></math> is **not** in the column space of matrix
    <math alttext="bold upper A"><mi>𝐀</mi></math> .
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="r a n k left-parenthesis bold upper A right-parenthesis less-than
    r a n k left-parenthesis bold upper A overTilde right-parenthesis"><mrow><mi>r</mi>
    <mi>a</mi> <mi>n</mi> <mi>k</mi> <mrow><mo>(</mo> <mi>𝐀</mi> <mo>)</mo></mrow>
    <mo><</mo> <mi>r</mi> <mi>a</mi> <mi>n</mi> <mi>k</mi> <mrow><mo>(</mo> <mover
    accent="true"><mi>𝐀</mi> <mo>˜</mo></mover> <mo>)</mo></mrow></mrow></math> 向量
    <math alttext="bold v"><mi>𝐯</mi></math> **不在** 矩阵 <math alttext="bold upper A"><mi>𝐀</mi></math>
    的列空间中。
- en: What is the logic behind this test? If <math alttext="bold v element-of upper
    C left-parenthesis bold upper A right-parenthesis"><mrow><mi>𝐯</mi> <mo>∈</mo>
    <mi>C</mi> <mo>(</mo> <mi>𝐀</mi> <mo>)</mo></mrow></math> , then <math alttext="bold
    v"><mi>𝐯</mi></math> can be expressed as some linear weighted combination of the
    columns of <math alttext="bold upper A"><mi>𝐀</mi></math> (the columns of the
    augmented matrix <math alttext="bold upper A overTilde"><mover accent="true"><mi>𝐀</mi>
    <mo>˜</mo></mover></math> form a linearly dependent set). In terms of span, vector
    <math alttext="bold v"><mi>𝐯</mi></math> is redundant in <math alttext="bold upper
    A overTilde"><mover accent="true"><mi>𝐀</mi> <mo>˜</mo></mover></math> . Hence,
    the rank stays the same.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试背后的逻辑是什么？如果<math alttext="bold v element-of upper C left-parenthesis bold
    upper A right-parenthesis"><mrow><mi>𝐯</mi> <mo>∈</mo> <mi>C</mi> <mo>(</mo> <mi>𝐀</mi>
    <mo>)</mo></mrow></math> ，那么<math alttext="bold v"><mi>𝐯</mi></math> 可以被表示为<math
    alttext="bold upper A"><mi>𝐀</mi></math> 的列的某些线性加权组合（增广矩阵<math alttext="bold upper
    A overTilde"><mover accent="true"><mi>𝐀</mi> <mo>˜</mo></mover></math> 的列形成线性相关集）。在张成的意义上，向量<math
    alttext="bold v"><mi>𝐯</mi></math> 在<math alttext="bold upper A overTilde"><mover
    accent="true"><mi>𝐀</mi> <mo>˜</mo></mover></math> 中是冗余的。因此，秩保持不变。
- en: Conversely, if <math alttext="bold v not-an-element-of upper C left-parenthesis
    bold upper A right-parenthesis"><mrow><mi>𝐯</mi> <mo>∉</mo> <mi>C</mi> <mo>(</mo>
    <mi>𝐀</mi> <mo>)</mo></mrow></math> , then <math alttext="bold v"><mi>𝐯</mi></math>
    cannot be expressed as a linear weighted combination of the columns of <math alttext="bold
    upper A"><mi>𝐀</mi></math> , which means that <math alttext="bold v"><mi>𝐯</mi></math>
    has added new information into <math alttext="bold upper A overTilde"><mover accent="true"><mi>𝐀</mi>
    <mo>˜</mo></mover></math> . And that means that the rank will increase by 1.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 相反地，如果<math alttext="bold v not-an-element-of upper C left-parenthesis bold
    upper A right-parenthesis"><mrow><mi>𝐯</mi> <mo>∉</mo> <mi>C</mi> <mo>(</mo> <mi>𝐀</mi>
    <mo>)</mo></mrow></math> ，则<math alttext="bold v"><mi>𝐯</mi></math> 不能被表示为<math
    alttext="bold upper A"><mi>𝐀</mi></math> 的列的线性加权组合，这意味着<math alttext="bold v"><mi>𝐯</mi></math>
    在<math alttext="bold upper A overTilde"><mover accent="true"><mi>𝐀</mi> <mo>˜</mo></mover></math>
    中添加了新信息。这意味着秩会增加1。
- en: Determining whether a vector is in the column space of a matrix is not merely
    some esoteric academic exercise; it is part of the reasoning behind linear least
    squares modeling, which is the math that underlies ANOVAs, regressions, and general
    linear models. You’ll learn more about this in Chapters [10](ch10.xhtml#Chapter_10)
    and [11](ch11.xhtml#Chapter_11), but the basic idea is that we develop a model
    of how the world works and then translate that model into a matrix, which is called
    the *design matrix*. The data we measure from the world are stored in a vector.
    If that data vector is in the column space of the design matrix, then we have
    perfectly modeled the world. In nearly all cases, the data vector is not in the
    column space, and therefore we determine whether it is close enough to be considered
    statistically significant. Obviously, I will go into much greater detail in later
    chapters, but I’m foreshadowing here to keep up your enthusiasm for learning.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 确定向量是否在矩阵的列空间中不仅仅是一种学术上的习题；它是线性最小二乘建模背后的推理的一部分，该建模是方差分析（ANOVA）、回归和一般线性模型的数学基础。你将在第[10](ch10.xhtml#Chapter_10)章和第[11](ch11.xhtml#Chapter_11)章学到更多内容，但基本思想是我们建立一个描述世界如何运作的模型，然后将该模型转换为一个矩阵，称为*设计矩阵*。我们从世界测量的数据存储在一个向量中。如果该数据向量在设计矩阵的列空间中，那么我们完美地模拟了世界。几乎所有情况下，数据向量不在列空间中，因此我们确定它是否足够接近以被认为是统计显著的。显然，我会在后面的章节中详细讨论，但我在这里预示以保持你对学习的热情。
- en: Linear Independence of a Vector Set
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量集的线性独立性
- en: Now that you know about matrix rank, you are ready to understand an algorithm
    for determining whether a set of vectors is linearly independent. If you’d like
    to come up with such an algorithm on your own, then feel free to do so now before
    reading the rest of this section.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你了解了矩阵秩，可以理解用于确定一组向量是否线性无关的算法。如果你想自己想出这样的算法，那么现在可以在阅读本节剩余部分之前自由地这样做。
- en: 'The algorithm is straightforward: put the vectors into a matrix, compute the
    rank of the matrix, and then compare that rank to the maximum possible rank of
    that matrix (remember that this is min{*M*,*N*}; for convenience of discussion
    I will assume that we have a tall matrix). The possible outcomes are:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 算法很简单：将向量放入矩阵中，计算矩阵的秩，然后将该秩与该矩阵的最大可能秩（记住这是min{*M*, *N*}；为了讨论方便，我假设我们有一个高矩阵）。可能的结果有：
- en: '*r* = *M*: The vector set is linearly independent.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*r* = *M*：向量集是线性无关的。'
- en: '*r* < *M*: The vector set is linearly dependent.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*r* < *M*：向量集合线性相关。'
- en: 'The reasoning behind this algorithm should be clear: if the rank is smaller
    than the number of columns, then at least one column can be described as a linear
    combination of other columns, which is the definition of linear dependence. If
    the rank equals the number of columns, then each column contributes unique information
    to the matrix, which means that no column can be described as a linear combination
    of other columns.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法背后的推理应该是清楚的：如果秩小于列数，那么至少有一列可以被描述为其他列的线性组合，这就是线性相关的定义。如果秩等于列数，那么每一列对矩阵都提供独特的信息，这意味着没有一列可以被其他列的线性组合描述。
- en: 'There is a more general point I’d like to make here: many operations and applications
    in linear algebra are actually quite simple and sensible, but they require a significant
    amount of background knowledge to understand. That’s a good thing: the more linear
    algebra you know, the easier linear algebra becomes.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我想要表达一个更一般的观点：线性代数中的许多操作和应用实际上非常简单而合理，但需要大量的背景知识才能理解。这是件好事：你掌握的线性代数知识越多，线性代数就变得越容易。
- en: 'On the other hand, that statement is not universally true: there are operations
    in linear algebra that are so mind-numbingly tedious and complicated that I cannot
    bring myself to describe them in full detail in this book. Segue to the next section…'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，这个说法并不是普遍适用的：线性代数中有些操作非常令人沮丧和复杂，以至于我无法在本书中详细描述它们。继续到下一节...
- en: Determinant
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行列式
- en: The *determinant* is a number associated with a square matrix. In abstract linear
    algebra, the determinant is a keystone quantity in several operations, including
    the matrix inverse. But computing the determinant in practice can be numerically
    unstable for large matrices, due to underflow and overflow issues. You’ll see
    an illustration of this in the exercises.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*行列式*是与方阵相关联的一个数。在抽象的线性代数中，行列式是几个操作中的关键量，包括矩阵的逆运算。但是对于大矩阵来说，计算行列式在实践中可能会因为下溢和上溢问题而不稳定。你将在练习中看到这一点。'
- en: Nonetheless, you cannot understand the matrix inverse or eigendecomposition
    without understanding the determinant.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，你无法理解矩阵的逆或特征分解而不理解行列式。
- en: The two most important properties of the determinant—and the two most important
    take-home messages of this section—are (1) it is defined only for square matrices
    and (2) it is zero for singular (reduced-rank) matrices.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 行列式的两个最重要的性质——也是本节最重要的两个要点是（1）它只对方阵定义，以及（2）奇异（秩降低）矩阵的行列式为零。
- en: The determinant is notated as <math alttext="d e t left-parenthesis bold upper
    A right-parenthesis"><mrow><mi>d</mi> <mi>e</mi> <mi>t</mi> <mo>(</mo> <mi>𝐀</mi>
    <mo>)</mo></mrow></math> or <math alttext="StartAbsoluteValue bold upper A EndAbsoluteValue"><mrow><mo>|</mo>
    <mi>𝐀</mi> <mo>|</mo></mrow></math> (note the single vertical lines instead of
    the double vertical lines that indicate the matrix norm). The Greek capital delta
    <math alttext="normal upper Delta"><mi>Δ</mi></math> is used when you don’t need
    to refer to a specific matrix.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 行列式被标记为 <math alttext="d e t left-parenthesis bold upper A right-parenthesis"><mrow><mi>d</mi>
    <mi>e</mi> <mi>t</mi> <mo>(</mo> <mi>𝐀</mi> <mo>)</mo></mrow></math> 或 <math alttext="StartAbsoluteValue
    bold upper A EndAbsoluteValue"><mrow><mo>|</mo> <mi>𝐀</mi> <mo>|</mo></mrow></math>（注意单竖线代替双竖线，表示矩阵范数）。希腊大写
    delta <math alttext="normal upper Delta"><mi>Δ</mi></math> 在你不需要指代特定矩阵时使用。
- en: But what *is* the determinant? What does it mean, and how do we interpret it?
    The determinant has a geometric interpretation, which is related to how much the
    matrix stretches vectors during matrix-vector multiplication (recall from the
    previous chapter that matrix-vector multiplication is a mechanism of applying
    geometric transforms to a coordinate expressed as a vector). A negative determinant
    means that one axis is rotated during the transformation.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 但是行列式究竟是什么？它意味着什么，我们如何解释它？行列式有一个几何解释，与矩阵向量乘法中向量被拉伸的程度有关（回忆前一章中矩阵向量乘法是将坐标表示为向量的几何变换机制）。负行列式意味着在变换过程中一个坐标轴被旋转。
- en: However, in data-science-related applications, the determinant is used algebraically;
    these geometric explanations are not very insightful for how we use the determinant
    to find eigenvalues or invert a data covariance matrix. Therefore, suffice it
    to say that the determinant is a crucial step in advanced topics like the matrix
    inverse, eigendecomposition, and singular value decomposition, and that you might
    save yourself some stress and sleepless nights by simply accepting that the determinant
    is a tool in our toolbox without worrying so much about what it means.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在与数据科学相关的应用中，行列式是用代数方式使用的；这些几何解释对于我们如何使用行列式来找到特征值或求逆数据协方差矩阵并不具有洞察力。因此，可以简单地说行列式是高级主题（如矩阵逆、特征分解和奇异值分解）中的一个关键步骤，你可能会因接受行列式是我们工具箱中的一个工具而省去一些压力和失眠的夜晚，而不必过多担心其含义。
- en: Computing the Determinant
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算行列式
- en: Computing the determinant is time-consuming and tedious. If I live a thousand
    years and never hand-calculate the determinant of a <math alttext="5 times 5"><mrow><mn>5</mn>
    <mo>×</mo> <mn>5</mn></mrow></math> matrix, I will have lived a rich, full, meaningful
    life. That said, there is a shortcut for computing the determinant of a <math
    alttext="2 times 2"><mrow><mn>2</mn> <mo>×</mo> <mn>2</mn></mrow></math> matrix,
    which is shown in [Equation 6-2](#comp-determ).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 计算行列式是耗时且乏味的。如果我活一千年，也永远不会手动计算五阶矩阵的行列式，我将会过上富有、充实和有意义的生活。话虽如此，计算二阶矩阵的行列式有一个快捷方法，显示在[方程式6-2](#comp-determ)中。
- en: Equation 6-2\. Computing the determinant of a <math alttext="2 times 2"><mrow><mn>2</mn>
    <mo>×</mo> <mn>2</mn></mrow></math> matrix
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方程式6-2。计算二阶矩阵的行列式
- en: <math alttext="d e t Start 2 By 2 Matrix 1st Row 1st Column a 2nd Column b 2nd
    Row 1st Column c 2nd Column d EndMatrix equals Start 2 By 2 Determinant 1st Row
    a b 2nd Row c d EndDeterminant equals a d minus b c" display="block"><mrow><mi>d</mi>
    <mi>e</mi> <mi>t</mi> <mfenced close=")" open="("><mfenced close="]" open="["><mtable><mtr><mtd><mi>a</mi></mtd>
    <mtd><mi>b</mi></mtd></mtr> <mtr><mtd><mi>c</mi></mtd> <mtd><mi>d</mi></mtd></mtr></mtable></mfenced></mfenced>
    <mo>=</mo> <mfenced close="|" open="|"><mtable><mtr><mtd><mi>a</mi></mtd> <mtd><mi>b</mi></mtd></mtr>
    <mtr><mtd><mi>c</mi></mtd> <mtd><mi>d</mi></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mi>a</mi> <mi>d</mi> <mo>-</mo> <mi>b</mi> <mi>c</mi></mrow></math>
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="d e t Start 2 By 2 Matrix 1st Row 1st Column a 2nd Column b 2nd
    Row 1st Column c 2nd Column d EndMatrix equals Start 2 By 2 Determinant 1st Row
    a b 2nd Row c d EndDeterminant equals a d minus b c" display="block"><mrow><mi>d</mi>
    <mi>e</mi> <mi>t</mi> <mfenced close=")" open="("><mfenced close="]" open="["><mtable><mtr><mtd><mi>a</mi></mtd>
    <mtd><mi>b</mi></mtd></mtr> <mtr><mtd><mi>c</mi></mtd> <mtd><mi>d</mi></mtd></mtr></mtable></mfenced></mfenced>
    <mo>=</mo> <mfenced close="|" open="|"><mtable><mtr><mtd><mi>a</mi></mtd> <mtd><mi>b</mi></mtd></mtr>
    <mtr><mtd><mi>c</mi></mtd> <mtd><mi>d</mi></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mi>a</mi> <mi>d</mi> <mo>-</mo> <mi>b</mi> <mi>c</mi></mrow></math>
- en: You can see from this equation that the determinant is not limited to integers
    or positive values. Depending on the numerical values in the matrix, the determinant
    can be −1223729358 or +.00000002 or any other number. (For a real-valued matrix,
    the determinant will always be a real number.)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从这个方程式看出，行列式不限于整数或正值。根据矩阵中的数值，行列式可以是−1223729358或+0.00000002或任何其他数。对于实值矩阵，行列式始终是一个实数。
- en: 'Calculating the determinant is really simple, right? It’s just the product
    of the diagonal minus the product of the off-diagonal. For many matrices, you
    can compute the determinant in your head. The determinant is even simpler for
    a <math alttext="1 times 1"><mrow><mn>1</mn> <mo>×</mo> <mn>1</mn></mrow></math>
    matrix: it’s simply the absolute value of that number.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 计算行列式真的很简单，对吧？它只是对角线乘积减去非对角线乘积。对于许多矩阵，你可以在脑中计算行列式。对于一阶矩阵来说，行列式甚至更简单：它只是那个数的绝对值。
- en: You might now be doubting my claim that the determinant is numerically unstable.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能怀疑我的说法行列式在数值上是不稳定的。
- en: 'The thing is that the shortcut for computing the determinant of a <math alttext="2
    times 2"><mrow><mn>2</mn> <mo>×</mo> <mn>2</mn></mrow></math> matrix doesn’t scale
    up to larger matrices. There is a “shortcut” for <math alttext="3 times 3"><mrow><mn>3</mn>
    <mo>×</mo> <mn>3</mn></mrow></math> matrices, but it isn’t really a shortcut;
    it’s a visual mnemonic. I won’t show it here, but I will write out the upshot:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 计算行列式的快捷方法并不适用于更大的矩阵。有一个“快捷”方法用于三阶矩阵，但实际上不是快捷方法；它是一种视觉记忆法。我不会在这里展示它，但我会写出总结：
- en: <math alttext="Start 3 By 3 Determinant 1st Row a b c 2nd Row d e f 3rd Row
    g h i EndDeterminant equals a e i plus b f g plus c d h minus c e g minus b d
    i minus a f h" display="block"><mrow><mfenced close="|" open="|"><mtable><mtr><mtd><mi>a</mi></mtd>
    <mtd><mi>b</mi></mtd> <mtd><mi>c</mi></mtd></mtr> <mtr><mtd><mi>d</mi></mtd> <mtd><mi>e</mi></mtd>
    <mtd><mi>f</mi></mtd></mtr> <mtr><mtd><mi>g</mi></mtd> <mtd><mi>h</mi></mtd> <mtd><mi>i</mi></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mi>a</mi> <mi>e</mi> <mi>i</mi> <mo>+</mo> <mi>b</mi> <mi>f</mi> <mi>g</mi>
    <mo>+</mo> <mi>c</mi> <mi>d</mi> <mi>h</mi> <mo>-</mo> <mi>c</mi> <mi>e</mi> <mi>g</mi>
    <mo>-</mo> <mi>b</mi> <mi>d</mi> <mi>i</mi> <mo>-</mo> <mi>a</mi> <mi>f</mi> <mi>h</mi></mrow></math>
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 3 By 3 Determinant 1st Row a b c 2nd Row d e f 3rd Row
    g h i EndDeterminant equals a e i plus b f g plus c d h minus c e g minus b d
    i minus a f h" display="block"><mrow><mfenced close="|" open="|"><mtable><mtr><mtd><mi>a</mi></mtd>
    <mtd><mi>b</mi></mtd> <mtd><mi>c</mi></mtd></mtr> <mtr><mtd><mi>d</mi></mtd> <mtd><mi>e</mi></mtd>
    <mtd><mi>f</mi></mtd></mtr> <mtr><mtd><mi>g</mi></mtd> <mtd><mi>h</mi></mtd> <mtd><mi>i</mi></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mi>a</mi> <mi>e</mi> <mi>i</mi> <mo>+</mo> <mi>b</mi> <mi>f</mi> <mi>g</mi>
    <mo>+</mo> <mi>c</mi> <mi>d</mi> <mi>h</mi> <mo>-</mo> <mi>c</mi> <mi>e</mi> <mi>g</mi>
    <mo>-</mo> <mi>b</mi> <mi>d</mi> <mi>i</mi> <mo>-</mo> <mi>a</mi> <mi>f</mi> <mi>h</mi></mrow></math>
- en: Once you get to <math alttext="4 times 4"><mrow><mn>4</mn> <mo>×</mo> <mn>4</mn></mrow></math>
    matrices, the determinant becomes a real hassle to compute, unless the matrix
    has many carefully placed zeros. But I know you’re curious, so [Equation 6-3](#determ-4-4)
    shows the determinant of a <math alttext="4 times 4"><mrow><mn>4</mn> <mo>×</mo>
    <mn>4</mn></mrow></math> matrix.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你涉及到四阶矩阵，除非矩阵有许多精心放置的零，否则计算行列式将变得非常麻烦。但我知道你很好奇，所以[方程式6-3](#determ-4-4)展示了四阶矩阵的行列式。
- en: Equation 6-3\. Yeah, good luck with that
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方程式6-3。嗯，祝你好运
- en: <math alttext="Start 4 By 4 Determinant 1st Row a b c d 2nd Row e f g h 3rd
    Row i j k l 4th Row m n o p EndDeterminant equals StartLayout 1st Row  a f k p
    minus a f l o minus a g j p plus a g l n plus a h j o minus a h k n minus b e
    k p plus b e l o 2nd Row  plus b g i p minus b g l m minus b h i o plus b h k
    m plus c e j p minus c e l n minus c f i p plus c f l m 3rd Row  plus c h i n
    minus c h j m minus d e j o plus d e k n plus d f i o minus d f k m minus d g
    i n plus d g j m EndLayout" display="block"><mrow><mfenced close="|" open="|"><mtable><mtr><mtd><mi>a</mi></mtd>
    <mtd><mi>b</mi></mtd> <mtd><mi>c</mi></mtd> <mtd><mi>d</mi></mtd></mtr> <mtr><mtd><mi>e</mi></mtd>
    <mtd><mi>f</mi></mtd> <mtd><mi>g</mi></mtd> <mtd><mi>h</mi></mtd></mtr> <mtr><mtd><mi>i</mi></mtd>
    <mtd><mi>j</mi></mtd> <mtd><mi>k</mi></mtd> <mtd><mi>l</mi></mtd></mtr> <mtr><mtd><mi>m</mi></mtd>
    <mtd><mi>n</mi></mtd> <mtd><mi>o</mi></mtd> <mtd><mi>p</mi></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mtable><mtr><mtd><mrow><mi>a</mi> <mi>f</mi> <mi>k</mi> <mi>p</mi>
    <mo>-</mo> <mi>a</mi> <mi>f</mi> <mi>l</mi> <mi>o</mi> <mo>-</mo> <mi>a</mi> <mi>g</mi>
    <mi>j</mi> <mi>p</mi> <mo>+</mo> <mi>a</mi> <mi>g</mi> <mi>l</mi> <mi>n</mi> <mo>+</mo>
    <mi>a</mi> <mi>h</mi> <mi>j</mi> <mi>o</mi> <mo>-</mo> <mi>a</mi> <mi>h</mi> <mi>k</mi>
    <mi>n</mi> <mo>-</mo> <mi>b</mi> <mi>e</mi> <mi>k</mi> <mi>p</mi> <mo>+</mo> <mi>b</mi>
    <mi>e</mi> <mi>l</mi> <mi>o</mi></mrow></mtd></mtr> <mtr><mtd><mrow><mo>+</mo>
    <mi>b</mi> <mi>g</mi> <mi>i</mi> <mi>p</mi> <mo>-</mo> <mi>b</mi> <mi>g</mi> <mi>l</mi>
    <mi>m</mi> <mo>-</mo> <mi>b</mi> <mi>h</mi> <mi>i</mi> <mi>o</mi> <mo>+</mo> <mi>b</mi>
    <mi>h</mi> <mi>k</mi> <mi>m</mi> <mo>+</mo> <mi>c</mi> <mi>e</mi> <mi>j</mi> <mi>p</mi>
    <mo>-</mo> <mi>c</mi> <mi>e</mi> <mi>l</mi> <mi>n</mi> <mo>-</mo> <mi>c</mi> <mi>f</mi>
    <mi>i</mi> <mi>p</mi> <mo>+</mo> <mi>c</mi> <mi>f</mi> <mi>l</mi> <mi>m</mi></mrow></mtd></mtr>
    <mtr><mtd><mrow><mo>+</mo> <mi>c</mi> <mi>h</mi> <mi>i</mi> <mi>n</mi> <mo>-</mo>
    <mi>c</mi> <mi>h</mi> <mi>j</mi> <mi>m</mi> <mo>-</mo> <mi>d</mi> <mi>e</mi> <mi>j</mi>
    <mi>o</mi> <mo>+</mo> <mi>d</mi> <mi>e</mi> <mi>k</mi> <mi>n</mi> <mo>+</mo> <mi>d</mi>
    <mi>f</mi> <mi>i</mi> <mi>o</mi> <mo>-</mo> <mi>d</mi> <mi>f</mi> <mi>k</mi> <mi>m</mi>
    <mo>-</mo> <mi>d</mi> <mi>g</mi> <mi>i</mi> <mi>n</mi> <mo>+</mo> <mi>d</mi> <mi>g</mi>
    <mi>j</mi> <mi>m</mi></mrow></mtd></mtr></mtable></mrow></math>
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 4 By 4 Determinant 1st Row a b c d 2nd Row e f g h 3rd
    Row i j k l 4th Row m n o p EndDeterminant equals StartLayout 1st Row  a f k p
    minus a f l o minus a g j p plus a g l n plus a h j o minus a h k n minus b e
    k p plus b e l o 2nd Row  plus b g i p minus b g l m minus b h i o plus b h k
    m plus c e j p minus c e l n minus c f i p plus c f l m 3rd Row  plus c h i n
    minus c h j m minus d e j o plus d e k n plus d f i o minus d f k m minus d g
    i n plus d g j m EndLayout" display="block"><mrow><mfenced close="|" open="|"><mtable><mtr><mtd><mi>a</mi></mtd>
    <mtd><mi>b</mi></mtd> <mtd><mi>c</mi></mtd> <mtd><mi>d</mi></mtd></mtr> <mtr><mtd><mi>e</mi></mtd>
    <mtd><mi>f</mi></mtd> <mtd><mi>g</mi></mtd> <mtd><mi>h</mi></mtd></mtr> <mtr><mtd><mi>i</mi></mtd>
    <mtd><mi>j</mi></mtd> <mtd><mi>k</mi></mtd> <mtd><mi>l</mi></mtd></mtr> <mtr><mtd><mi>m</mi></mtd>
    <mtd><mi>n</mi></mtd> <mtd><mi>o</mi></mtd> <mtd><mi>p</mi></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mtable><mtr><mtd><mrow><mi>a</mi> <mi>f</mi> <mi>k</mi> <mi>p</mi>
    <mo>-</mo> <mi>a</mi> <mi>f</mi> <mi>l</mi> <mi>o</mi> <mo>-</mo> <mi>a</mi> <mi>g</mi>
    <mi>j</mi> <mi>p</mi> <mo>+</mo> <mi>a</mi> <mi>g</mi> <mi>l</mi> <mi>n</mi> <mo>+</mo>
    <mi>a</mi> <mi>h</mi> <mi>j</mi> <mi>o</mi> <mo>-</mo> <mi>a</mi> <mi>h</mi> <mi>k</mi>
    <mi>n</mi> <mo>-</mo> <mi>b</mi> <mi>e</mi> <mi>k</mi> <mi>p</mi> <mo>+</mo> <mi>b</mi>
    <mi>e</mi> <mi>l</mi> <mi>o</mi></mrow></mtd></mtr> <mtr><mtd><mrow><mo>+</mo>
    <mi>b</mi> <mi>g</mi> <mi>i</mi> <mi>p</mi> <mo>-</mo> <mi>b</mi> <mi>g</mi> <mi>l</mi>
    <mi>m</mi> <mo>-</mo> <mi>b</mi> <mi>h</mi> <mi>i</mi> <mi>o</mi> <mo>+</mo> <mi>b</mi>
    <mi>h</mi> <mi>k</mi> <mi>m</mi> <mo>+</mo> <mi>c</mi> <mi>e</mi> <mi>j</mi> <mi>p</mi>
    <mo>-</mo> <mi>c</mi> <mi>e</mi> <mi>l</mi> <mi>n</mi> <mo>-</mo> <mi>c</mi> <mi>f</mi>
    <mi>i</mi> <mi>p</mi> <mo>+</mo> <mi>c</mi> <mi>f</mi> <mi>l</mi> <mi>m</mi></mrow></mtd></mtr>
    <mtr><mtd><mrow><mo>+</mo> <mi>c</mi> <mi>h</mi> <mi>i</mi> <mi>n</mi> <mo>-</mo>
    <mi>c</mi> <mi>h</mi> <mi>j</mi> <mi>m</mi> <mo>-</mo> <mi>d</mi> <mi>e</mi> <mi>j</mi>
    <mi>o</mi> <mo>+</mo> <mi>d</mi> <mi>e</mi> <mi>k</mi> <mi>n</mi> <mo>+</mo> <mi>d</mi>
    <mi>f</mi> <mi>i</mi> <mi>o</mi> <mo>-</mo> <mi>d</mi> <mi>f</mi> <mi>k</mi> <mi>m</mi>
    <mo>-</mo> <mi>d</mi> <mi>g</mi> <mi>i</mi> <mi>n</mi> <mo>+</mo> <mi>d</mi> <mi>g</mi>
    <mi>j</mi> <mi>m</mi></mrow></mtd></mtr></mtable></mrow></math>
- en: 'I’m not even going to show the full procedure for computing the determinant
    of any size matrix, because, let’s be honest: you are reading this book because
    you’re interested in applied linear algebra; it’s important to understand how
    to use the determinant, not the full formula for computing it.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我甚至不打算展示计算任意大小矩阵行列式的完整过程，因为，坦白说：你正在阅读这本书是因为你对应用线性代数感兴趣；重要的是理解如何使用行列式，而不是完整的计算公式。
- en: Anyway, the point is that if you ever need to compute the determinant, you use
    `np.linalg.det()` or `scipy.linalg.det()`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，如果你需要计算行列式，可以使用`np.linalg.det()`或`scipy.linalg.det()`。
- en: Determinant with Linear Dependencies
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有线性依赖的行列式
- en: 'The second take-home message about determinants is that they are zero for any
    reduced-rank matrix. We can explore this with a <math alttext="2 times 2"><mrow><mn>2</mn>
    <mo>×</mo> <mn>2</mn></mrow></math> matrix. Remember that any reduced-rank matrix
    has at least one column that can be expressed as a linear combination of other
    columns:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 关于行列式的第二个要点是，任何降秩矩阵的行列式都为零。我们可以通过一个<math alttext="2 times 2"><mrow><mn>2</mn>
    <mo>×</mo> <mn>2</mn></mrow></math>矩阵来探讨这一点。请记住，任何降秩矩阵至少有一列可以表示为其他列的线性组合：
- en: <math alttext="Start 2 By 2 Determinant 1st Row 1st Column a 2nd Column lamda
    a 2nd Row 1st Column c 2nd Column lamda c EndDeterminant equals a c lamda minus
    a lamda c equals 0" display="block"><mrow><mfenced close="|" open="|"><mtable><mtr><mtd><mi>a</mi></mtd>
    <mtd><mrow><mi>λ</mi> <mi>a</mi></mrow></mtd></mtr> <mtr><mtd><mi>c</mi></mtd>
    <mtd><mrow><mi>λ</mi> <mi>c</mi></mrow></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mi>a</mi> <mi>c</mi> <mi>λ</mi> <mo>-</mo> <mi>a</mi> <mi>λ</mi> <mi>c</mi> <mo>=</mo>
    <mn>0</mn></mrow></math>
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Determinant 1st Row 1st Column a 2nd Column lamda
    a 2nd Row 1st Column c 2nd Column lamda c EndDeterminant equals a c lamda minus
    a lamda c equals 0" display="block"><mrow><mfenced close="|" open="|"><mtable><mtr><mtd><mi>a</mi></mtd>
    <mtd><mrow><mi>λ</mi> <mi>a</mi></mrow></mtd></mtr> <mtr><mtd><mi>c</mi></mtd>
    <mtd><mrow><mi>λ</mi> <mi>c</mi></mrow></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mi>a</mi> <mi>c</mi> <mi>λ</mi> <mo>-</mo> <mi>a</mi> <mi>λ</mi> <mi>c</mi> <mo>=</mo>
    <mn>0</mn></mrow></math>
- en: 'Here’s the determinant of a <math alttext="3 times 3"><mrow><mn>3</mn> <mo>×</mo>
    <mn>3</mn></mrow></math> singular matrix:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个<math alttext="3 times 3"><mrow><mn>3</mn> <mo>×</mo> <mn>3</mn></mrow></math>奇异矩阵的行列式：
- en: <math alttext="Start 3 By 3 Determinant 1st Row 1st Column a 2nd Column b 3rd
    Column lamda a 2nd Row 1st Column d 2nd Column e 3rd Column lamda d 3rd Row 1st
    Column g 2nd Column h 3rd Column lamda g EndDeterminant equals a e lamda g plus
    b lamda d g plus lamda a d h minus lamda a e g minus b d lamda g minus a lamda
    d h equals 0" display="block"><mrow><mfenced close="|" open="|"><mtable><mtr><mtd><mi>a</mi></mtd>
    <mtd><mi>b</mi></mtd> <mtd><mrow><mi>λ</mi> <mi>a</mi></mrow></mtd></mtr> <mtr><mtd><mi>d</mi></mtd>
    <mtd><mi>e</mi></mtd> <mtd><mrow><mi>λ</mi> <mi>d</mi></mrow></mtd></mtr> <mtr><mtd><mi>g</mi></mtd>
    <mtd><mi>h</mi></mtd> <mtd><mrow><mi>λ</mi> <mi>g</mi></mrow></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mi>a</mi> <mi>e</mi> <mi>λ</mi> <mi>g</mi> <mo>+</mo> <mi>b</mi> <mi>λ</mi>
    <mi>d</mi> <mi>g</mi> <mo>+</mo> <mi>λ</mi> <mi>a</mi> <mi>d</mi> <mi>h</mi> <mo>-</mo>
    <mi>λ</mi> <mi>a</mi> <mi>e</mi> <mi>g</mi> <mo>-</mo> <mi>b</mi> <mi>d</mi> <mi>λ</mi>
    <mi>g</mi> <mo>-</mo> <mi>a</mi> <mi>λ</mi> <mi>d</mi> <mi>h</mi> <mo>=</mo> <mn>0</mn></mrow></math>
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 3 By 3 Determinant 1st Row 1st Column a 2nd Column b 3rd
    Column lamda a 2nd Row 1st Column d 2nd Column e 3rd Column lamda d 3rd Row 1st
    Column g 2nd Column h 3rd Column lamda g EndDeterminant equals a e lamda g plus
    b lamda d g plus lamda a d h minus lamda a e g minus b d lamda g minus a lamda
    d h equals 0" display="block"><mrow><mfenced close="|" open="|"><mtable><mtr><mtd><mi>a</mi></mtd>
    <mtd><mi>b</mi></mtd> <mtd><mrow><mi>λ</mi> <mi>a</mi></mrow></mtd></mtr> <mtr><mtd><mi>d</mi></mtd>
    <mtd><mi>e</mi></mtd> <mtd><mrow><mi>λ</mi> <mi>d</mi></mrow></mtd></mtr> <mtr><mtd><mi>g</mi></mtd>
    <mtd><mi>h</mi></mtd> <mtd><mrow><mi>λ</mi> <mi>g</mi></mrow></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mi>a</mi> <mi>e</mi> <mi>λ</mi> <mi>g</mi> <mo>+</mo> <mi>b</mi> <mi>λ</mi>
    <mi>d</mi> <mi>g</mi> <mo>+</mo> <mi>λ</mi> <mi>a</mi> <mi>d</mi> <mi>h</mi> <mo>-</mo>
    <mi>λ</mi> <mi>a</mi> <mi>e</mi> <mi>g</mi> <mo>-</mo> <mi>b</mi> <mi>d</mi> <mi>λ</mi>
    <mi>g</mi> <mo>-</mo> <mi>a</mi> <mi>λ</mi> <mi>d</mi> <mi>h</mi> <mo>=</mo> <mn>0</mn></mrow></math>
- en: This concept generalizes to larger matrices. Thus, all reduced-rank matrices
    have a determinant of 0\. The actual rank doesn’t matter; if *r* < *M*, then <math
    alttext="normal upper Delta equals 0"><mrow><mi>Δ</mi> <mo>=</mo> <mn>0</mn></mrow></math>
    . All full-rank matrices have a nonzero determinant.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念推广到更大的矩阵。因此，所有降秩矩阵的行列式都为0。实际的秩并不重要；如果*r* < *M*，那么<math alttext="normal upper
    Delta equals 0"><mrow><mi>Δ</mi> <mo>=</mo> <mn>0</mn></mrow></math>。所有满秩矩阵的行列式都不为零。
- en: 'I’ve already written that I think geometric interpretations of the determinant
    have limited value to understanding why the determinant is important in data science.
    But <math alttext="normal upper Delta equals 0"><mrow><mi>Δ</mi> <mo>=</mo> <mn>0</mn></mrow></math>
    does have a nice geometric meaning: a matrix with <math alttext="normal upper
    Delta equals 0"><mrow><mi>Δ</mi> <mo>=</mo> <mn>0</mn></mrow></math> is a transformation
    in which at least one dimension gets flattened to have surface area but no volume.
    You can imagine squashing a ball down to an infinitely thin disk. You will see
    a visual example of this in the next chapter ([“Geometric Transformations via
    Matrix-Vector Multiplication”](ch07.xhtml#geometric-transforms)).'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经写过，我认为行列式的几何解释在理解行列式在数据科学中的重要性方面的价值有限。但是<math alttext="normal upper Delta
    equals 0"><mrow><mi>Δ</mi> <mo>=</mo> <mn>0</mn></mrow></math>确实有一个很好的几何意义：具有<math
    alttext="normal upper Delta equals 0"><mrow><mi>Δ</mi> <mo>=</mo> <mn>0</mn></mrow></math>的矩阵是一个变换，其中至少一个维度被压扁以具有表面积但没有体积。你可以想象将球压扁成一个无限薄的圆盘。你将在下一章看到这种视觉示例（[“通过矩阵-向量乘法进行几何变换”](ch07.xhtml#geometric-transforms)）。
- en: The Characteristic Polynomial
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特征多项式
- en: 'The equation for the determinant of a <math alttext="2 times 2"><mrow><mn>2</mn>
    <mo>×</mo> <mn>2</mn></mrow></math> matrix has five quantities: the four elements
    in the matrix and the determinant value. We can write them out in an equation
    as <math alttext="a d minus b c equals normal upper Delta"><mrow><mi>a</mi> <mi>d</mi>
    <mo>-</mo> <mi>b</mi> <mi>c</mi> <mo>=</mo> <mi>Δ</mi></mrow></math> . One of
    the great things about equations is that you can move quantities around and solve
    for different variables. Consider [Equation 6-4](#determ-miss); assume that *a*,
    *b*, *c*, and <math alttext="normal upper Delta"><mi>Δ</mi></math> are known,
    and <math alttext="lamda"><mi>λ</mi></math> is some unknown quantity.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="2 times 2"><mrow><mn>2</mn> <mo>×</mo> <mn>2</mn></mrow></math>
    矩阵行列式的方程包括五个量：矩阵中的四个元素和行列式的值。我们可以将它们写成方程：<math alttext="a d minus b c equals normal
    upper Delta"><mrow><mi>a</mi> <mi>d</mi> <mo>-</mo> <mi>b</mi> <mi>c</mi> <mo>=</mo>
    <mi>Δ</mi></mrow></math> 。方程的一个重要之处在于你可以移动量并解出不同的变量。考虑[方程 6-4](#determ-miss)；假设*a*、*b*、*c*和<math
    alttext="normal upper Delta"><mi>Δ</mi></math>都是已知的，*λ*是某个未知量。
- en: Equation 6-4\. Using the determinant to find a missing matrix element
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方程 6-4\. 使用行列式找到缺失的矩阵元素
- en: <math alttext="Start 2 By 2 Determinant 1st Row a b 2nd Row c lamda EndDeterminant
    right double arrow a lamda minus b c equals normal upper Delta" display="block"><mrow><mfenced
    close="|" open="|"><mtable><mtr><mtd><mi>a</mi></mtd> <mtd><mi>b</mi></mtd></mtr>
    <mtr><mtd><mi>c</mi></mtd> <mtd><mi>λ</mi></mtd></mtr></mtable></mfenced> <mo>⇒</mo>
    <mi>a</mi> <mi>λ</mi> <mo>-</mo> <mi>b</mi> <mi>c</mi> <mo>=</mo> <mi>Δ</mi></mrow></math>
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Determinant 1st Row a b 2nd Row c lamda EndDeterminant
    right double arrow a lamda minus b c equals normal upper Delta" display="block"><mrow><mfenced
    close="|" open="|"><mtable><mtr><mtd><mi>a</mi></mtd> <mtd><mi>b</mi></mtd></mtr>
    <mtr><mtd><mi>c</mi></mtd> <mtd><mi>λ</mi></mtd></mtr></mtable></mfenced> <mo>⇒</mo>
    <mi>a</mi> <mi>λ</mi> <mo>-</mo> <mi>b</mi> <mi>c</mi> <mo>=</mo> <mi>Δ</mi></mrow></math>
- en: A bit of middle-school algebra will enable you to solve for <math alttext="lamda"><mi>λ</mi></math>
    in terms of the other quantities. The solution itself is unimportant; the point
    is that *if we know the determinant of a matrix, we can solve for unknown variables
    inside the matrix.*
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一点初中代数就能让你解出<math alttext="lamda"><mi>λ</mi></math>与其他量的关系。解本身并不重要；重要的是*如果我们知道一个矩阵的行列式，我们可以解出矩阵内的未知变量*。
- en: 'Here’s a numerical example:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个数值示例：
- en: <math alttext="Start 2 By 2 Determinant 1st Row 2 7 2nd Row 4 lamda EndDeterminant
    equals 4 right double arrow 2 lamda minus 28 equals 4 right double arrow 2 lamda
    equals 32 right double arrow lamda equals 16" display="block"><mrow><mfenced close="|"
    open="|"><mtable><mtr><mtd><mn>2</mn></mtd> <mtd><mn>7</mn></mtd></mtr> <mtr><mtd><mn>4</mn></mtd>
    <mtd><mi>λ</mi></mtd></mtr></mtable></mfenced> <mo>=</mo> <mn>4</mn> <mo>⇒</mo>
    <mn>2</mn> <mi>λ</mi> <mo>-</mo> <mn>28</mn> <mo>=</mo> <mn>4</mn> <mo>⇒</mo>
    <mn>2</mn> <mi>λ</mi> <mo>=</mo> <mn>32</mn> <mo>⇒</mo> <mi>λ</mi> <mo>=</mo>
    <mn>16</mn></mrow></math>
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Determinant 1st Row 2 7 2nd Row 4 lamda EndDeterminant
    equals 4 right double arrow 2 lamda minus 28 equals 4 right double arrow 2 lamda
    equals 32 right double arrow lamda equals 16" display="block"><mrow><mfenced close="|"
    open="|"><mtable><mtr><mtd><mn>2</mn></mtd> <mtd><mn>7</mn></mtd></mtr> <mtr><mtd><mn>4</mn></mtd>
    <mtd><mi>λ</mi></mtd></mtr></mtable></mfenced> <mo>=</mo> <mn>4</mn> <mo>⇒</mo>
    <mn>2</mn> <mi>λ</mi> <mo>-</mo> <mn>28</mn> <mo>=</mo> <mn>4</mn> <mo>⇒</mo>
    <mn>2</mn> <mi>λ</mi> <mo>=</mo> <mn>32</mn> <mo>⇒</mo> <mi>λ</mi> <mo>=</mo>
    <mn>16</mn></mrow></math>
- en: 'Now let’s take this one step further:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们再进一步：
- en: <math alttext="Start 2 By 2 Determinant 1st Row lamda 1 2nd Row 3 lamda EndDeterminant
    equals 1 right double arrow lamda squared minus 3 equals 1 right double arrow
    lamda squared equals 4 right double arrow lamda equals plus-or-minus 2" display="block"><mrow><mfenced
    close="|" open="|"><mtable><mtr><mtd><mi>λ</mi></mtd> <mtd><mn>1</mn></mtd></mtr>
    <mtr><mtd><mn>3</mn></mtd> <mtd><mi>λ</mi></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mn>1</mn> <mo>⇒</mo> <msup><mi>λ</mi> <mn>2</mn></msup> <mo>-</mo> <mn>3</mn>
    <mo>=</mo> <mn>1</mn> <mo>⇒</mo> <msup><mi>λ</mi> <mn>2</mn></msup> <mo>=</mo>
    <mn>4</mn> <mo>⇒</mo> <mi>λ</mi> <mo>=</mo> <mo>±</mo> <mn>2</mn></mrow></math>
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Determinant 1st Row lamda 1 2nd Row 3 lamda EndDeterminant
    equals 1 right double arrow lamda squared minus 3 equals 1 right double arrow
    lamda squared equals 4 right double arrow lamda equals plus-or-minus 2" display="block"><mrow><mfenced
    close="|" open="|"><mtable><mtr><mtd><mi>λ</mi></mtd> <mtd><mn>1</mn></mtd></mtr>
    <mtr><mtd><mn>3</mn></mtd> <mtd><mi>λ</mi></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mn>1</mn> <mo>⇒</mo> <msup><mi>λ</mi> <mn>2</mn></msup> <mo>-</mo> <mn>3</mn>
    <mo>=</mo> <mn>1</mn> <mo>⇒</mo> <msup><mi>λ</mi> <mn>2</mn></msup> <mo>=</mo>
    <mn>4</mn> <mo>⇒</mo> <mi>λ</mi> <mo>=</mo> <mo>±</mo> <mn>2</mn></mrow></math>
- en: 'The same unknown <math alttext="lamda"><mi>λ</mi></math> was on the diagonal,
    which produced a second-order polynomial equation, and that produced two solutions.
    That’s no coincidence: the fundamental theorem of algebra tells us that an *n*th
    order polynomial has exactly *n* roots (though some may be complex valued).'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 对角线上同一个未知数<math alttext="lamda"><mi>λ</mi></math>产生了一个二阶多项式方程，从而产生了两个解。这不是巧合：代数基本定理告诉我们，一个*n*次多项式恰好有*n*个根（尽管有些可能是复数值）。
- en: 'Here is the key point that I’m working towards: combining matrix shifting with
    the determinant is called the *characteristic polynomial* of the matrix, as shown
    in [Equation 6-5](#char-poly).'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我正在努力达成的关键点：将矩阵移位与行列式结合起来称为矩阵的*特征多项式*，如[方程式 6-5](#char-poly)所示。
- en: Equation 6-5\. The characteristic polynomial of the matrix
  id: totrans-230
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方程式 6-5\. 矩阵的特征多项式
- en: <math alttext="d e t left-parenthesis bold upper A minus lamda bold upper I
    right-parenthesis equals normal upper Delta" display="block"><mrow><mi>d</mi>
    <mi>e</mi> <mi>t</mi> <mo>(</mo> <mi>𝐀</mi> <mo>-</mo> <mi>λ</mi> <mi>𝐈</mi> <mo>)</mo>
    <mo>=</mo> <mi>Δ</mi></mrow></math>
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="d e t left-parenthesis bold upper A minus lamda bold upper I
    right-parenthesis equals normal upper Delta" display="block"><mrow><mi>d</mi>
    <mi>e</mi> <mi>t</mi> <mo>(</mo> <mi>𝐀</mi> <mo>-</mo> <mi>λ</mi> <mi>𝐈</mi> <mo>)</mo>
    <mo>=</mo> <mi>Δ</mi></mrow></math>
- en: 'Why is it called a polynomial? Because the shifted <math alttext="upper M times
    upper M"><mrow><mi>M</mi> <mo>×</mo> <mi>M</mi></mrow></math> matrix has an <math
    alttext="lamda Superscript upper M"><msup><mi>λ</mi> <mi>M</mi></msup></math>
    term, and therefore has <math alttext="upper M"><mi>M</mi></math> solutions. Here’s
    what it looks like for <math alttext="2 times 2"><mrow><mn>2</mn> <mo>×</mo> <mn>2</mn></mrow></math>
    and <math alttext="3 times 3"><mrow><mn>3</mn> <mo>×</mo> <mn>3</mn></mrow></math>
    matrices:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么它被称为多项式？因为移位的<math alttext="upper M times upper M"><mrow><mi>M</mi> <mo>×</mo>
    <mi>M</mi></mrow></math>矩阵具有一个<math alttext="lamda Superscript upper M"><msup><mi>λ</mi>
    <mi>M</mi></msup></math>项，因此有<math alttext="upper M"><mi>M</mi></math>个解。这是<math
    alttext="2 times 2"><mrow><mn>2</mn> <mo>×</mo> <mn>2</mn></mrow></math>和<math
    alttext="3 times 3"><mrow><mn>3</mn> <mo>×</mo> <mn>3</mn></mrow></math>矩阵的情况：
- en: <math alttext="Start 2 By 2 Determinant 1st Row 1st Column a minus lamda 2nd
    Column b 2nd Row 1st Column c 2nd Column d minus lamda EndDeterminant equals 0
    right double arrow lamda squared minus left-parenthesis a plus d right-parenthesis
    lamda plus left-parenthesis a d minus b c right-parenthesis equals 0" display="block"><mrow><mfenced
    close="|" open="|"><mtable><mtr><mtd><mrow><mi>a</mi> <mo>-</mo> <mi>λ</mi></mrow></mtd>
    <mtd><mi>b</mi></mtd></mtr> <mtr><mtd><mi>c</mi></mtd> <mtd><mrow><mi>d</mi> <mo>-</mo>
    <mi>λ</mi></mrow></mtd></mtr></mtable></mfenced> <mo>=</mo> <mn>0</mn> <mo>⇒</mo>
    <msup><mi>λ</mi> <mn>2</mn></msup> <mo>-</mo> <mrow><mo>(</mo> <mi>a</mi> <mo>+</mo>
    <mi>d</mi> <mo>)</mo></mrow> <mi>λ</mi> <mo>+</mo> <mrow><mo>(</mo> <mi>a</mi>
    <mi>d</mi> <mo>-</mo> <mi>b</mi> <mi>c</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>0</mn></mrow></math><math
    alttext="Start 3 By 3 Determinant 1st Row 1st Column a minus lamda 2nd Column
    b 3rd Column c 2nd Row 1st Column d 2nd Column e minus lamda 3rd Column f 3rd
    Row 1st Column g 2nd Column h 3rd Column i minus lamda EndDeterminant equals 0
    right double arrow StartLayout 1st Row  minus lamda cubed plus left-parenthesis
    a plus e plus i right-parenthesis lamda squared 2nd Row  plus left-parenthesis
    minus a e plus b d minus a i plus c g minus e i plus f h right-parenthesis lamda
    3rd Row  plus a e i minus a f h minus b d i plus b f g plus c d h minus c e g
    equals 0 EndLayout" display="block"><mrow><mfenced close="|" open="|"><mtable><mtr><mtd><mrow><mi>a</mi>
    <mo>-</mo> <mi>λ</mi></mrow></mtd> <mtd><mi>b</mi></mtd> <mtd><mi>c</mi></mtd></mtr>
    <mtr><mtd><mi>d</mi></mtd> <mtd><mrow><mi>e</mi> <mo>-</mo> <mi>λ</mi></mrow></mtd>
    <mtd><mi>f</mi></mtd></mtr> <mtr><mtd><mi>g</mi></mtd> <mtd><mi>h</mi></mtd> <mtd><mrow><mi>i</mi>
    <mo>-</mo> <mi>λ</mi></mrow></mtd></mtr></mtable></mfenced> <mo>=</mo> <mn>0</mn>
    <mo>⇒</mo> <mtable><mtr><mtd><mrow><mo>-</mo> <msup><mi>λ</mi> <mn>3</mn></msup>
    <mo>+</mo> <mrow><mo>(</mo> <mi>a</mi> <mo>+</mo> <mi>e</mi> <mo>+</mo> <mi>i</mi>
    <mo>)</mo></mrow> <msup><mi>λ</mi> <mn>2</mn></msup></mrow></mtd></mtr> <mtr><mtd><mrow><mo>+</mo>
    <mo>(</mo> <mo>-</mo> <mi>a</mi> <mi>e</mi> <mo>+</mo> <mi>b</mi> <mi>d</mi> <mo>-</mo>
    <mi>a</mi> <mi>i</mi> <mo>+</mo> <mi>c</mi> <mi>g</mi> <mo>-</mo> <mi>e</mi> <mi>i</mi>
    <mo>+</mo> <mi>f</mi> <mi>h</mi> <mo>)</mo> <mi>λ</mi></mrow></mtd></mtr> <mtr><mtd><mrow><mo>+</mo>
    <mi>a</mi> <mi>e</mi> <mi>i</mi> <mo>-</mo> <mi>a</mi> <mi>f</mi> <mi>h</mi> <mo>-</mo>
    <mi>b</mi> <mi>d</mi> <mi>i</mi> <mo>+</mo> <mi>b</mi> <mi>f</mi> <mi>g</mi> <mo>+</mo>
    <mi>c</mi> <mi>d</mi> <mi>h</mi> <mo>-</mo> <mi>c</mi> <mi>e</mi> <mi>g</mi> <mo>=</mo>
    <mn>0</mn></mrow></mtd></mtr></mtable></mrow></math>
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Determinant 1st Row 1st Column a minus lamda 2nd
    Column b 2nd Row 1st Column c 2nd Column d minus lamda EndDeterminant equals 0
    right double arrow lamda squared minus left-parenthesis a plus d right-parenthesis
    lamda plus left-parenthesis a d minus b c right-parenthesis equals 0" display="block"><mrow><mfenced
    close="|" open="|"><mtable><mtr><mtd><mrow><mi>a</mi> <mo>-</mo> <mi>λ</mi></mrow></mtd>
    <mtd><mi>b</mi></mtd></mtr> <mtr><mtd><mi>c</mi></mtd> <mtd><mrow><mi>d</mi> <mo>-</mo>
    <mi>λ</mi></mrow></mtd></mtr></mtable></mfenced> <mo>=</mo> <mn>0</mn> <mo>⇒</mo>
    <msup><mi>λ</mi> <mn>2</mn></msup> <mo>-</mo> <mrow><mo>(</mo> <mi>a</mi> <mo>+</mo>
    <mi>d</mi> <mo>)</mo></mrow> <mi>λ</mi> <mo>+</mo> <mrow><mo>(</mo> <mi>a</mi>
    <mi>d</mi> <mo>-</mo> <mi>b</mi> <mi>c</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>0</mn></mrow></math><math
    alttext="Start 3 By 3 Determinant 1st Row 1st Column a minus lamda 2nd Column
    b 3rd Column c 2nd Row 1st Column d 2nd Column e minus lamda 3rd Column f 3rd
    Row 1st Column g 2nd Column h 3rd Column i minus lamda EndDeterminant equals 0
    right double arrow StartLayout 1st Row  minus lamda cubed plus left-parenthesis
    a plus e plus i right-parenthesis lamda squared 2nd Row  plus left-parenthesis
    minus a e plus b d minus a i plus c g minus e i plus f h right-parenthesis lamda
    3rd Row  plus a e i minus a f h minus b d i plus b f g plus c d h minus c e g
    equals 0 EndLayout" display="block"><mrow><mfenced close="|" open="|"><mtable><mtr><mtd><mrow><mi>a</mi>
    <mo>-</mo> <mi>λ</mi></mrow></mtd> <mtd><mi>b</mi></mtd> <mtd><mi>c</mi></mtd></mtr>
    <mtr><mtd><mi>d</mi></mtd> <mtd><mrow><mi>e</mi> <mo>-</mo> <mi>λ</mi></mrow></mtd>
    <mtd><mi>f</mi></mtd></mtr> <mtr><mtd><mi>g</mi></mtd> <mtd><mi>h</mi></mtd> <mtd><mrow><mi>i</mi>
    <mo>-</mo> <mi>λ</mi></mrow></mtd></mtr></mtable></mfenced> <mo>=</mo> <mn>0</mn>
    <mo>⇒</mo> <mtable><mtr><mtd><mrow><mo>-</mo> <msup><mi>λ</mi> <mn>3</mn></msup>
    <mo>+</mo> <mrow><mo>(</mo> <mi>a</mi> <mo>+</mo> <mi>e</mi> <mo>+</mo> <mi>i</mi>
    <mo>)</mo></mrow> <msup><mi>λ</mi> <mn>2</mn></msup></mrow></mtd></mtr> <mtr><mtd><mrow><mo>+</mo>
    <mo>(</mo> <mo>-</mo> <mi>a</mi> <mi>e</mi> <mo>+</mo> <mi>b</mi> <mi>d</mi> <mo>-</mo>
    <mi>a</mi> <mi>i</mi> <mo>+</mo> <mi>c</mi> <mi>g</mi> <mo>-</mo> <mi>e</mi> <mi>i</mi>
    <mo>+</mo> <mi>f</mi> <mi>h</mi> <mo>)</mo> <mi>λ</mi></mrow></mtd></mtr> <mtr><mtd><mrow><mo>+</mo>
    <mi>a</mi> <mi>e</mi> <mi>i</mi> <mo>-</mo> <mi>a</mi> <mi>f</mi> <mi>h</mi> <mo>-</mo>
    <mi>b</mi> <mi>d</mi> <mi>i</mi> <mo>+</mo> <mi>b</mi> <mi>f</mi> <mi>g</mi> <mo>+</mo>
    <mi>c</mi> <mi>d</mi> <mi>h</mi> <mo>-</mo> <mi>c</mi> <mi>e</mi> <mi>g</mi> <mo>=</mo>
    <mn>0</mn></mrow></mtd></mtr></mtable></mrow></math>
- en: Please don’t ask me to show you the characteristic polynomial for a <math alttext="4
    times 4"><mrow><mn>4</mn> <mo>×</mo> <mn>4</mn></mrow></math> matrix. Trust me,
    it will have a <math alttext="lamda"><mi>λ</mi></math> ⁴ term.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 请不要让我展示一个<math alttext="4 times 4"><mrow><mn>4</mn> <mo>×</mo> <mn>4</mn></mrow></math>矩阵的特征多项式。相信我，它将会有一个<math
    alttext="lamda"><mi>λ</mi></math>⁴项。
- en: 'Let’s return to the <math alttext="2 times 2"><mrow><mn>2</mn> <mo>×</mo> <mn>2</mn></mrow></math>
    case, this time using numbers instead of letters. The matrix below is full rank,
    meaning that its determinant is not 0 (it is <math alttext="normal upper Delta
    equals negative 8"><mrow><mi>Δ</mi><mo>=</mo><mrow><mo>-</mo><mn>8</mn></mrow></mrow></math>),
    but I’m going to assume that it has a determinant of 0 after being shifted by
    some scalar <math alttext="lamda"><mi>λ</mi></math> ; the question is, what values
    of <math alttext="lamda"><mi>λ</mi></math> will make this matrix reduced-rank?
    Let’s use the characteristic polynomial to find out:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到<math alttext="2 times 2"><mrow><mn>2</mn> <mo>×</mo> <mn>2</mn></mrow></math>的情况，这次使用数字而不是字母。下面的矩阵是满秩的，意味着其行列式不为0（为<math
    alttext="normal upper Delta equals negative 8"><mrow><mi>Δ</mi><mo>=</mo><mrow><mo>-</mo><mn>8</mn></mrow></mrow></math>），但我假设它在被某个标量<math
    alttext="lamda"><mi>λ</mi></math>移位后其行列式为0；问题是，什么值的<math alttext="lamda"><mi>λ</mi></math>会使得这个矩阵降秩？让我们使用特征多项式来找出答案：
- en: <math alttext="d e t left-parenthesis Start 2 By 2 Matrix 1st Row 1st Column
    1 2nd Column 3 2nd Row 1st Column 3 2nd Column 1 EndMatrix minus lamda bold upper
    I right-parenthesis equals 0" display="block"><mrow><mi>d</mi> <mi>e</mi> <mi>t</mi>
    <mfenced close=")" open="(" separators=""><mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mn>3</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced>
    <mo>-</mo> <mi>λ</mi> <mi>𝐈</mi></mfenced> <mo>=</mo> <mn>0</mn></mrow></math><math
    alttext="Start 2 By 2 Determinant 1st Row 1st Column 1 minus lamda 2nd Column
    3 2nd Row 1st Column 3 2nd Column 1 minus lamda EndDeterminant equals 0 right
    double arrow left-parenthesis 1 minus lamda right-parenthesis squared minus 9
    equals 0" display="block"><mrow><mfenced close="|" open="|"><mtable><mtr><mtd><mrow><mn>1</mn>
    <mo>-</mo> <mi>λ</mi></mrow></mtd> <mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mn>3</mn></mtd>
    <mtd><mrow><mn>1</mn> <mo>-</mo> <mi>λ</mi></mrow></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mn>0</mn> <mo>⇒</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow>
    <mn>2</mn></msup> <mo>-</mo> <mn>9</mn> <mo>=</mo> <mn>0</mn></mrow></math>
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="d e t left-parenthesis Start 2 By 2 Matrix 1st Row 1st Column
    1 2nd Column 3 2nd Row 1st Column 3 2nd Column 1 EndMatrix minus lamda bold upper
    I right-parenthesis equals 0" display="block"><mrow><mi>d</mi> <mi>e</mi> <mi>t</mi>
    <mfenced close=")" open="(" separators=""><mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mn>3</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced>
    <mo>-</mo> <mi>λ</mi> <mi>𝐈</mi></mfenced> <mo>=</mo> <mn>0</mn></mrow></math><math
    alttext="Start 2 By 2 Determinant 1st Row 1st Column 1 minus lamda 2nd Column
    3 2nd Row 1st Column 3 2nd Column 1 minus lamda EndDeterminant equals 0 right
    double arrow left-parenthesis 1 minus lamda right-parenthesis squared minus 9
    equals 0" display="block"><mrow><mfenced close="|" open="|"><mtable><mtr><mtd><mrow><mn>1</mn>
    <mo>-</mo> <mi>λ</mi></mrow></mtd> <mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mn>3</mn></mtd>
    <mtd><mrow><mn>1</mn> <mo>-</mo> <mi>λ</mi></mrow></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mn>0</mn> <mo>⇒</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow>
    <mn>2</mn></msup> <mo>-</mo> <mn>9</mn> <mo>=</mo> <mn>0</mn></mrow></math>
- en: 'After some algebra (which I encourage you to work through), the two solutions
    are <math alttext="lamda equals negative 2 comma 4"><mrow><mi>λ</mi><mo>=</mo><mrow><mo>-</mo><mn>2</mn></mrow><mo>,</mo><mn>4</mn></mrow></math>.
    What do these numbers mean? To find out, let’s plug them back into the shifted
    matrix:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些代数运算（我鼓励你自己计算），得到两个解为<math alttext="lamda equals negative 2 comma 4"><mrow><mi>λ</mi><mo>=</mo><mrow><mo>-</mo><mn>2</mn></mrow><mo>,</mo><mn>4</mn></mrow></math>。这些数字代表什么？为了弄清楚，让我们把它们代回到移位后的矩阵中：
- en: <math alttext="lamda equals negative 2 right double arrow Start 2 By 2 Matrix
    1st Row 1st Column 3 2nd Column 3 2nd Row 1st Column 3 2nd Column 3 EndMatrix"
    display="block"><mrow><mi>λ</mi> <mo>=</mo> <mrow><mo>-</mo> <mn>2</mn></mrow>
    <mo>⇒</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>3</mn></mtd> <mtd><mn>3</mn></mtd></mtr>
    <mtr><mtd><mn>3</mn></mtd> <mtd><mn>3</mn></mtd></mtr></mtable></mfenced></mrow></math><math
    alttext="lamda equals 4 right double arrow Start 2 By 2 Matrix 1st Row 1st Column
    negative 3 2nd Column 3 2nd Row 1st Column 3 2nd Column negative 3 EndMatrix"
    display="block"><mrow><mi>λ</mi> <mo>=</mo> <mn>4</mn> <mo>⇒</mo> <mfenced close="]"
    open="["><mtable><mtr><mtd><mrow><mo>-</mo> <mn>3</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>3</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>3</mn></mrow></mtd> <mtd><mrow><mo>-</mo> <mn>3</mn></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="lamda equals negative 2 right double arrow Start 2 By 2 Matrix
    1st Row 1st Column 3 2nd Column 3 2nd Row 1st Column 3 2nd Column 3 EndMatrix"
    display="block"><mrow><mi>λ</mi> <mo>=</mo> <mrow><mo>-</mo> <mn>2</mn></mrow>
    <mo>⇒</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>3</mn></mtd> <mtd><mn>3</mn></mtd></mtr>
    <mtr><mtd><mn>3</mn></mtd> <mtd><mn>3</mn></mtd></mtr></mtable></mfenced></mrow></math><math
    alttext="lamda equals 4 right double arrow Start 2 By 2 Matrix 1st Row 1st Column
    negative 3 2nd Column 3 2nd Row 1st Column 3 2nd Column negative 3 EndMatrix"
    display="block"><mrow><mi>λ</mi> <mo>=</mo> <mn>4</mn> <mo>⇒</mo> <mfenced close="]"
    open="["><mtable><mtr><mtd><mrow><mo>-</mo> <mn>3</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>3</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>3</mn></mrow></mtd> <mtd><mrow><mo>-</mo> <mn>3</mn></mrow></mtd></mtr></mtable></mfenced></mrow></math>
- en: Clearly, both matrices are rank-1\. Furthermore, both matrices have nontrivial
    null spaces, meaning you can find some nonzeros vector <math alttext="bold y"><mi>𝐲</mi></math>
    such that <math alttext="left-parenthesis bold upper A minus lamda bold upper
    I right-parenthesis bold y equals bold 0"><mrow><mo>(</mo> <mi>𝐀</mi> <mo>-</mo>
    <mi>λ</mi> <mi>𝐈</mi> <mo>)</mo> <mi>𝐲</mi> <mo>=</mo> <mn mathvariant="bold">0</mn></mrow></math>
    . I’m sure you can find a vector for each of those <math alttext="lamda"><mi>λ</mi></math>
    s on your own! But just in case you want to confirm your correct answer, check
    the footnote.^([6](ch06.xhtml#idm45733300001632))
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这两个矩阵都是秩为1的。此外，这两个矩阵都有非平凡的零空间，意味着你可以找到某些非零向量<math alttext="bold y"><mi>𝐲</mi></math>，使得<math
    alttext="left-parenthesis bold upper A minus lamda bold upper I right-parenthesis
    bold y equals bold 0"><mrow><mo>(</mo> <mi>𝐀</mi> <mo>-</mo> <mi>λ</mi> <mi>𝐈</mi>
    <mo>)</mo> <mi>𝐲</mi> <mo>=</mo> <mn mathvariant="bold">0</mn></mrow></math>。我相信你可以自己找到每个<math
    alttext="lamda"><mi>λ</mi></math>对应的向量！但是如果你想确认你的正确答案，检查一下脚注。^([6](ch06.xhtml#idm45733300001632))
- en: The characteristic polynomial is, to use a technical term, super awesome. For
    one thing, it provides the remarkable insight that every square *matrix* can be
    expressed as an *equation*. And not just any equation—an equation that directly
    links matrices to the fundamental theorem of algebra. And if that isn’t cool enough,
    the solutions to the characteristic polynomial set to <math alttext="normal upper
    Delta equals 0"><mrow><mi>Δ</mi> <mo>=</mo> <mn>0</mn></mrow></math> are the eigenvalues
    of the matrix (that’s the <math alttext="lamda"><mi>λ</mi></math> s we found above).
    I know that you have to wait until [Chapter 13](ch13.xhtml#Chapter_13) to understand
    what eigenvalues are and why they are important, but you can sleep well tonight
    knowing that today you learned how to uncover the eigenvalues of a matrix.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 特征多项式，用一个技术术语来说，非常棒。首先，它提供了这样一个深刻的洞见，即每个方阵都可以表示为一个方程。而且不仅仅是任何方程——一个直接将矩阵与代数基本定理联系起来的方程。如果这还不够酷，那么将特征多项式设为<math
    alttext="normal upper Delta equals 0"><mrow><mi>Δ</mi> <mo>=</mo> <mn>0</mn></mrow></math>的解就是矩阵的特征值（就是我们上面找到的<math
    alttext="lamda"><mi>λ</mi></math>）。我知道你得等到[第13章](ch13.xhtml#Chapter_13)才能理解什么是特征值以及它们为什么重要，但是今天你学会了如何发现矩阵的特征值，你今晚可以安心睡觉了。
- en: Summary
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Summary
- en: 'The goal of this chapter was to expand your knowledge of matrices to include
    several important concepts: norms, spaces, rank, and determinant. If this were
    a book on abstract linear algebra, this chapter could easily have been a hundred-plus
    pages. But I tried to focus the discussion on what you’ll need to know for linear
    algebra applications in data science and AI. You’ll discover more about matrix
    spaces in later chapters (in particular, least squares fitting in [Chapter 11](ch11.xhtml#Chapter_11)
    and the singular value decomposition in [Chapter 14](ch14.xhtml#Chapter_14)).
    In the meantime, here is a list of the most important points in this chapter:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是扩展你对矩阵的知识，包括几个重要概念：范数、空间、秩和行列式。如果这是一本抽象线性代数的书，这一章很容易就可以超过一百页。但我试图把讨论重点放在你在数据科学和人工智能中所需了解的内容上。你将在后续章节中了解更多关于矩阵空间的内容（特别是在[第11章](ch11.xhtml#Chapter_11)中的最小二乘拟合和[第14章](ch14.xhtml#Chapter_14)中的奇异值分解）。与此同时，这里列出了本章的最重要要点：
- en: There are many kinds of matrix norms, which can be broadly classified into *element-wise*
    and *induced*. The former reflects the magnitudes of the elements in the matrix
    while the latter reflects the geometric-transformative effect of the matrix on
    vectors.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵的范数有许多种类，可以大致分为*逐元素*和*诱导*两类。前者反映矩阵元素的大小，而后者反映矩阵对向量的几何变换效果。
- en: The most commonly used element-wise norm is called the Frobenius norm (a.k.a.
    the Euclidean norm or the <math alttext="script l Baseline 2"><mrow><mi>ℓ</mi>
    <mn>2</mn></mrow></math> norm) and is computed as the square root of the sum of
    squared elements.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最常用的逐元素范数被称为弗罗贝尼乌斯范数（也称为欧几里得范数或<math alttext="script l Baseline 2"><mrow><mi>ℓ</mi>
    <mn>2</mn></mrow></math>范数），计算方法是元素平方和的平方根。
- en: The trace of a matrix is the sum of the diagonal elements.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵的迹是对角线元素的总和。
- en: There are four matrix spaces (column, row, null, left-null), and they are defined
    as the set of linear weighted combinations of different features of the matrix.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵有四个空间（列空间、行空间、零空间、左零空间），它们被定义为矩阵不同特征的线性加权组合的集合。
- en: The column space of the matrix comprises all linear weighted combinations of
    the columns in the matrix and is written as <math alttext="upper C left-parenthesis
    bold upper A right-parenthesis"><mrow><mi>C</mi> <mo>(</mo> <mi>𝐀</mi> <mo>)</mo></mrow></math>
    .
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵的列空间包括矩阵列的所有线性加权组合，并写成<math alttext="upper C left-parenthesis bold upper A
    right-parenthesis"><mrow><mi>C</mi> <mo>(</mo> <mi>𝐀</mi> <mo>)</mo></mrow></math>。
- en: An important question in linear algebra is whether some vector <math alttext="bold
    b"><mi>𝐛</mi></math> is in the column space of a matrix; if it is, then there
    is some vector <math alttext="bold x"><mi>𝐱</mi></math> such that <math alttext="bold
    upper A bold x equals bold b"><mrow><mi>𝐀</mi> <mi>𝐱</mi> <mo>=</mo> <mi>𝐛</mi></mrow></math>
    . Answering that question forms the basis for many statistical model fitting algorithms.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线性代数中一个重要的问题是某个向量<math alttext="bold b"><mi>𝐛</mi></math>是否在矩阵的列空间中；如果是，那么存在某个向量<math
    alttext="bold x"><mi>𝐱</mi></math>使得<math alttext="bold upper A bold x equals
    bold b"><mrow><mi>𝐀</mi> <mi>𝐱</mi> <mo>=</mo> <mi>𝐛</mi></mrow></math>。回答这个问题是许多统计模型拟合算法的基础。
- en: The row space of a matrix is the set of linear weighted combintions of the rows
    of the matrix and is indicated as <math alttext="upper R left-parenthesis bold
    upper A right-parenthesis"><mrow><mi>R</mi> <mo>(</mo> <mi>𝐀</mi> <mo>)</mo></mrow></math>
    or <math alttext="upper C left-parenthesis bold upper A Superscript upper T Baseline
    right-parenthesis"><mrow><mi>C</mi> <mo>(</mo> <msup><mi>𝐀</mi> <mtext>T</mtext></msup>
    <mo>)</mo></mrow></math> .
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵的行空间是矩阵行的线性加权组合的集合，表示为<math alttext="upper R left-parenthesis bold upper A
    right-parenthesis"><mrow><mi>R</mi> <mo>(</mo> <mi>𝐀</mi> <mo>)</mo></mrow></math>或<math
    alttext="upper C left-parenthesis bold upper A Superscript upper T Baseline right-parenthesis"><mrow><mi>C</mi>
    <mo>(</mo> <msup><mi>𝐀</mi> <mtext>T</mtext></msup> <mo>)</mo></mrow></math>。
- en: The null space of a matrix is the set of vectors that linearly combines the
    columns to produce the zeros vector—in other words, any vector <math alttext="bold
    y"><mi>𝐲</mi></math> that solves the equation <math alttext="bold upper A bold
    y equals bold 0"><mrow><mi>𝐀</mi> <mi>𝐲</mi> <mo>=</mo> <mn mathvariant="bold">0</mn></mrow></math>
    . The trivial solution of <math alttext="bold y equals bold 0"><mrow><mi>𝐲</mi>
    <mo>=</mo> <mn mathvariant="bold">0</mn></mrow></math> is excluded. The null space
    is important for finding eigenvectors, among other applications.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵的零空间是线性组合列以生成零向量的向量集合——换句话说，任何解决方程 <math alttext="bold y"><mi>𝐲</mi></math>
    的向量 <math alttext="bold upper A bold y equals bold 0"><mrow><mi>𝐀</mi> <mi>𝐲</mi>
    <mo>=</mo> <mn mathvariant="bold">0</mn></mrow></math> 。排除 <math alttext="bold
    y equals bold 0"><mrow><mi>𝐲</mi> <mo>=</mo> <mn mathvariant="bold">0</mn></mrow></math>
    的平凡解。零空间对于找到特征向量等应用非常重要。
- en: Rank is a nonnegative integer associated with a matrix. Rank reflects the largest
    number of columns (or rows) that can form a linearly independent set. Matrices
    with a rank smaller than the maximum possible are called reduced-rank or singular.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秩是与矩阵相关的非负整数。秩反映可以形成线性无关集的最大列（或行）数。秩小于最大可能秩的矩阵称为降秩或奇异矩阵。
- en: Shifting a square matrix by adding a constant to the diagonal ensures full-rank.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在对角线上加上常数来平移方阵确保其完全秩。
- en: One (of many) applications of rank is to determine whether a vector is in the
    column space of a matrix, which works by comparing the rank of the matrix to the
    rank of the vector-augmented matrix.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排名的一个（众多）应用是确定向量是否在矩阵的列空间中，这通过比较矩阵的秩和向量增广矩阵的秩来实现。
- en: The determinant is a number associated with a square matrix (there is no determinant
    for rectangular matrices). It is tedious to compute, but the most important thing
    to know about the determinant is that it is zero for all reduced-rank matrices
    and nonzero for all full-rank matrices.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行列式是与方阵相关的一个数（矩形矩阵没有行列式）。计算起来很乏味，但关于行列式最重要的事情是，对于所有降秩矩阵，它都是零；对于所有满秩矩阵，它都是非零的。
- en: 'The characteristic polynomial transforms a square matrix, shifted by <math
    alttext="lamda"><mi>λ</mi></math> , into an equation that equals the determinant.
    Knowing the determinant allows you to solve for <math alttext="lamda"><mi>λ</mi></math>
    . I’ve only briefly hinted at why that is so important, but trust me: it’s important.
    (Or don’t trust me and see for yourself in [Chapter 13](ch13.xhtml#Chapter_13).)'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特征多项式将一个方阵，平移 <math alttext="lamda"><mi>λ</mi></math> ，转换为等于行列式的方程。了解行列式允许你解出
    <math alttext="lamda"><mi>λ</mi></math> 。我只是简单地暗示了为什么这很重要，但请相信我：这很重要（或者不要相信我，自己去看看
    [第13章](ch13.xhtml#Chapter_13)）。
- en: Code Exercises
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码练习
- en: Exercise 6-1\.
  id: totrans-257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习 6-1\.
- en: 'The norm of a matrix is related to the scale of the numerical values in the
    matrix. In this exercise, you will create an experiment to demonstrate this. In
    each of 10 experiment iterations, create a <math alttext="10 times 10"><mrow><mn>10</mn>
    <mo>×</mo> <mn>10</mn></mrow></math> random numbers matrix and compute its Frobenius
    norm. Then repeat this experiment 40 times, each time scalar multiplying the matrix
    by a different scalar that ranges between 0 and 50\. The result of the experiment
    will be a <math alttext="40 times 10"><mrow><mn>40</mn> <mo>×</mo> <mn>10</mn></mrow></math>
    matrix of norms. [Figure 6-7](#fig_6_7) shows the resulting norms, averaged over
    the 10 experiment iterations. This experiment also illustrates two additional
    properties of matrix norms: they are strictly nonnegative and can equal 0 only
    for the zeros matrix.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的范数与矩阵中数值的尺度有关。在这个练习中，你将创建一个实验来证明这一点。在每次的10个实验迭代中，创建一个 <math alttext="10 times
    10"><mrow><mn>10</mn> <mo>×</mo> <mn>10</mn></mrow></math> 的随机数矩阵，并计算其弗罗贝尼乌斯范数。然后重复这个实验40次，每次将矩阵乘以不同的标量，范围在0到50之间。实验的结果将是一个
    <math alttext="40 times 10"><mrow><mn>40</mn> <mo>×</mo> <mn>10</mn></mrow></math>
    的范数矩阵。 [图6-7](#fig_6_7) 展示了在10次实验迭代中求得的范数的平均值。这个实验还说明了矩阵范数的另外两个特性：它们严格非负，且只有在零矩阵的情况下才可能等于0。
- en: '![hello](assets/plad_0607.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![hello](assets/plad_0607.png)'
- en: Figure 6-7\. Solution to Exercise 6-1
  id: totrans-260
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-7\. 练习 6-1 的解答
- en: Exercise 6-2\.
  id: totrans-261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习 6-2\.
- en: In this exercise, you will write an algorithm that finds a scalar that brings
    the Frobenius distance between two matrices to 1\. Start by writing a Python function
    that takes two matrices (of the same size) as input and returns the Frobenius
    distance between them. Then create two <math alttext="upper N times upper N"><mrow><mi>N</mi>
    <mo>×</mo> <mi>N</mi></mrow></math> random numbers matrices (I used <math alttext="upper
    N equals 7"><mrow><mi>N</mi> <mo>=</mo> <mn>7</mn></mrow></math> in the solutions
    code, but you can use any other size). Create a variable `s = 1` that scalar multiplies
    both matrices. Compute the Frobenius distance between the scaled matrices. As
    long as that distance remains above 1, set the scalar to be .9 times itself and
    recompute the distance between the scaled matrices. This should be done in a `while`
    loop. When the Frobenius distance gets below 1, quit the `while` loop and report
    the number of iterations (which corresponds to the number of times that the scalar
    `s` was multiplied by .9) and the scalar value.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将编写一个算法，找到一个标量，使得两个矩阵之间的Frobenius距离为1。首先编写一个Python函数，该函数接受两个相同大小的矩阵作为输入，并返回它们之间的Frobenius距离。然后创建两个<math
    alttext="upper N times upper N"><mrow><mi>N</mi> <mo>×</mo> <mi>N</mi></mrow></math>随机数矩阵（在解决方案代码中我使用了<math
    alttext="upper N equals 7"><mrow><mi>N</mi> <mo>=</mo> <mn>7</mn></mrow></math>，但您可以使用其他任何大小）。创建一个变量`s
    = 1`，将其标量乘以两个矩阵。计算缩放后的矩阵之间的Frobenius距离。只要距离保持在1以上，将标量设置为其自身的0.9倍，并重新计算缩放后的矩阵之间的距离。这应在一个`while`循环中完成。当Frobenius距离低于1时，退出`while`循环，并报告迭代次数（即标量`s`乘以0.9的次数）和标量值。
- en: Exercise 6-3\.
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习6-3\.
- en: Demonstrate that the trace method and the Euclidean formula produce the same
    result (the Frobenius norm). Does the trace formula work only for <math alttext="bold
    upper A Superscript upper T Baseline bold upper A"><mrow><msup><mi>𝐀</mi> <mtext>T</mtext></msup>
    <mi>𝐀</mi></mrow></math> , or do you get the same result for <math alttext="bold
    upper A bold upper A Superscript upper T"><mrow><mi>𝐀</mi> <msup><mi>𝐀</mi> <mtext>T</mtext></msup></mrow></math>
    ?
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 演示迹方法和欧几里得公式产生相同结果（Frobenius范数）。迹公式仅适用于<math alttext="bold upper A Superscript
    upper T Baseline bold upper A"><mrow><msup><mi>𝐀</mi> <mtext>T</mtext></msup>
    <mi>𝐀</mi></mrow></math>，还是对于<math alttext="bold upper A bold upper A Superscript
    upper T"><mrow><mi>𝐀</mi> <msup><mi>𝐀</mi> <mtext>T</mtext></msup></mrow></math>也得到相同结果？
- en: Exercise 6-4\.
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习6-4\.
- en: 'This will be a fun exercise,^([7](ch06.xhtml#idm45733299930304)) because you’ll
    get to incorporate material from this and the previous chapters. You will explore
    the impact of shifting a matrix on the norm of that matrix. Start by creating
    a <math alttext="10 times 10"><mrow><mn>10</mn> <mo>×</mo> <mn>10</mn></mrow></math>
    random matrix and compute its Frobenius norm. Then code the following steps inside
    a `for` loop: (1) shift the matrix by a fraction of the norm, (2) compute the
    percent change in norm from the original, (3) compute the Frobenius distance between
    the shifted and original matrices, and (4) compute the correlation coefficient
    between the elements in the matrices (hint: correlate the vectorized matrices
    using `np.flatten()`). The fraction of the norm that you shift by should range
    from 0 to 1 in 30 linearly spaced steps. Make sure that at each iteration of the
    loop, you use the original matrix, not the shifted matrix from the previous iteration.
    You should get a plot that looks like [Figure 6-8](#fig_6_8).'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个有趣的练习^([7](ch06.xhtml#idm45733299930304))，因为您将能够结合本章和前几章的材料。您将探讨将矩阵移动到其范数的影响。首先创建一个<math
    alttext="10 times 10"><mrow><mn>10</mn> <mo>×</mo> <mn>10</mn></mrow></math>随机矩阵，并计算其Frobenius范数。然后在一个`for`循环中编写以下步骤：(1)
    将矩阵移动到范数的一部分，(2) 计算从原始矩阵到移动后矩阵的范数的百分比变化，(3) 计算移动后矩阵与原始矩阵之间的Frobenius距离，以及(4) 计算矩阵元素之间的相关系数（提示：使用`np.flatten()`对向量化的矩阵进行相关）。应该在每次循环迭代中使用原始矩阵，而不是前一次迭代中的移动矩阵。您应该得到一个类似于[Figure 6-8](#fig_6_8)的图形。
- en: '![Something](assets/plad_0608.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![Something](assets/plad_0608.png)'
- en: Figure 6-8\. Solution to Exercise 6-4
  id: totrans-268
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-8\. 练习6-4的解答
- en: Exercise 6-5\.
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习6-5\.
- en: I will now show you how to create random matrices with arbitrary rank (subject
    to the constraints about matrix sizes, etc.). To create an <math alttext="upper
    M times upper N"><mrow><mi>M</mi> <mo>×</mo> <mi>N</mi></mrow></math> matrix with
    rank *r*, multiply a random <math alttext="upper M times r"><mrow><mi>M</mi> <mo>×</mo>
    <mi>r</mi></mrow></math> matrix with an <math alttext="r times upper N"><mrow><mi>r</mi>
    <mo>×</mo> <mi>N</mi></mrow></math> matrix. Implement this in Python and confirm
    that the rank is indeed *r*. What happens if you set *r* > min{*M,N*}, and why
    does that happen?
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我将向你展示如何创建具有任意秩的随机矩阵（受矩阵大小等约束）。要创建一个秩为 *r* 的 <math alttext="上 M 乘以 上 N"><mrow><mi>M</mi>
    <mo>×</mo> <mi>N</mi></mrow></math> 矩阵，将一个随机的 <math alttext="上 M 乘以 r"><mrow><mi>M</mi>
    <mo>×</mo> <mi>r</mi></mrow></math> 矩阵与一个 <math alttext="r 乘以 上 N"><mrow><mi>r</mi>
    <mo>×</mo> <mi>N</mi></mrow></math> 矩阵相乘。在 Python 中实现这一点，并确认秩确实是 *r*。如果设置 *r*
    > min{*M,N*} 会发生什么，为什么会这样？
- en: Exercise 6-6\.
  id: totrans-271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习 6-6\.
- en: Demonstrate the addition rule of matrix rank (*r*(**A** + **B**) ≤ *r*(**A**)
    + *r*(**B**)) by creating three pairs of rank-1 matrices that have a sum with
    (1) rank-0, (2) rank-1, and (3) rank-2\. Then repeat this exercise using matrix
    multiplication instead of addition.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建三对秩为 1 的矩阵来演示矩阵秩的加法规则（*r*(**A** + **B**) ≤ *r*(**A**) + *r*(**B**)），这些矩阵的和具有
    (1) 秩 0、(2) 秩 1 和 (3) 秩 2。然后，使用矩阵乘法而不是加法重复此练习。
- en: Exercise 6-7\.
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习 6-7\.
- en: Put the code from [Exercise 6-5](#exercise_6_5) into a Python function that
    takes parameters *M* and *r* as input and provides a random <math alttext="upper
    M times upper M"><mrow><mi>M</mi> <mo>×</mo> <mi>M</mi></mrow></math> rank-*r*
    matrix as output. In a double `for` loop, create pairs of <math alttext="20 times
    20"><mrow><mn>20</mn> <mo>×</mo> <mn>20</mn></mrow></math> matrices with individual
    ranks varying from 2 to 15\. Add and multiply those matrices, and store the ranks
    of those resulting matrices. Those ranks can be organized into a matrix and visualized
    as a function of the ranks of the individual matrices ([Figure 6-9](#fig_6_9)).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 将来自 [练习 6-5](#exercise_6_5) 的代码放入一个 Python 函数中，该函数以 *M* 和 *r* 作为输入参数，并提供一个随机的
    <math alttext="上 M 乘以 上 M"><mrow><mi>M</mi> <mo>×</mo> <mi>M</mi></mrow></math>
    秩为 *r* 的矩阵作为输出。在双重 `for` 循环中，创建一对对 <math alttext="20 乘以 20"><mrow><mn>20</mn>
    <mo>×</mo> <mn>20</mn></mrow></math> 矩阵，其各自的秩从 2 变化到 15\. 将这些矩阵相加并相乘，将这些结果矩阵的秩存储起来。这些秩可以组织成一个矩阵，并按照各自矩阵的秩的函数进行可视化（[图
    6-9](#fig_6_9)）。
- en: '![Neato.](assets/plad_0609.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![优秀。](assets/plad_0609.png)'
- en: Figure 6-9\. Results of Exercise 6-7
  id: totrans-276
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-9\. 练习 6-7 的结果
- en: Exercise 6-8\.
  id: totrans-277
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习 6-8\.
- en: Interestingly, the matrices <math alttext="bold upper A"><mi>𝐀</mi></math> ,
    <math alttext="bold upper A Superscript upper T"><msup><mi>𝐀</mi> <mtext>T</mtext></msup></math>
    , <math alttext="bold upper A Superscript upper T Baseline bold upper A"><mrow><msup><mi>𝐀</mi>
    <mtext>T</mtext></msup> <mi>𝐀</mi></mrow></math> , and <math alttext="bold upper
    A bold upper A Superscript upper T"><mrow><mi>𝐀</mi> <msup><mi>𝐀</mi> <mtext>T</mtext></msup></mrow></math>
    all have the same rank. Write code to demonstrate this, using random matrices
    of various sizes, shapes (square, tall, wide), and ranks.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，矩阵 <math alttext="粗体上 A"><mi>𝐀</mi></math>，<math alttext="粗体上 A 上标 上 T"><msup><mi>𝐀</mi>
    <mtext>T</mtext></msup></math>，<math alttext="粗体上 A 上标 上 T 上标线 粗体上 A"><mrow><msup><mi>𝐀</mi>
    <mtext>T</mtext></msup> <mi>𝐀</mi></mrow></math> 和 <math alttext="粗体上 A 粗体上 A
    上标 上 T"><mrow><mi>𝐀</mi> <msup><mi>𝐀</mi> <mtext>T</mtext></msup></mrow></math>
    的秩都相同。编写代码来演示这一点，使用各种大小、形状（方形、高、宽）和秩的随机矩阵。
- en: Exercise 6-9\.
  id: totrans-279
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习 6-9\.
- en: The goal of this exercise is to answer the question <math alttext="bold v element-of
    upper C left-parenthesis bold upper A right-parenthesis"><mrow><mi>𝐯</mi> <mo>∈</mo>
    <mi>C</mi> <mo>(</mo> <mi>𝐀</mi> <mo>)</mo></mrow></math> ? Create a rank-3 matrix
    <math alttext="bold upper A element-of double-struck upper R Superscript 4 times
    3"><mrow><mi>𝐀</mi> <mo>∈</mo> <msup><mi>ℝ</mi> <mrow><mn>4</mn><mo>×</mo><mn>3</mn></mrow></msup></mrow></math>
    and vector <math alttext="bold v element-of double-struck upper R Superscript
    4"><mrow><mi>𝐯</mi> <mo>∈</mo> <msup><mi>ℝ</mi> <mn>4</mn></msup></mrow></math>
    using numbers randomly drawn from a normal distribution. Follow the algorithm
    described earlier to determine whether the vector is in the column space of the
    matrix. Rerun the code multiple times to see whether you find a consistent pattern.
    Next, use a <math alttext="bold upper A element-of double-struck upper R Superscript
    4 times 4"><mrow><mi>𝐀</mi> <mo>∈</mo> <msup><mi>ℝ</mi> <mrow><mn>4</mn><mo>×</mo><mn>4</mn></mrow></msup></mrow></math>
    rank-4 matrix. I’m willing to bet one million bitcoins^([8](ch06.xhtml#idm45733299873664))
    that you *always* find that <math alttext="bold v element-of upper C left-parenthesis
    bold upper A right-parenthesis"><mrow><mi>𝐯</mi> <mo>∈</mo> <mi>C</mi> <mo>(</mo>
    <mi>𝐀</mi> <mo>)</mo></mrow></math> when <math alttext="bold upper A"><mi>𝐀</mi></math>
    is a <math alttext="4 times 4"><mrow><mn>4</mn> <mo>×</mo> <mn>4</mn></mrow></math>
    random matrix (assuming no coding mistakes). What makes me confident about your
    answer?^([9](ch06.xhtml#idm45733299865712))
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这项练习的目标是回答问题 <math alttext="粗体 𝐯 ∈ 斜体 C ( 粗体 𝐀 )"><mrow><mi>𝐯</mi> <mo>∈</mo>
    <mi>C</mi> <mo>(</mo> <mi>𝐀</mi> <mo>)</mo></mrow></math>？创建一个秩为3的矩阵 <math alttext="粗体
    𝐀 ∈ 双黑体 R 上标 4 乘 3"><mrow><mi>𝐀</mi> <mo>∈</mo> <msup><mi>ℝ</mi> <mrow><mn>4</mn><mo>×</mo><mn>3</mn></mrow></msup></mrow></math>
    和向量 <math alttext="粗体 𝐯 ∈ 双黑体 R 上标 4"><mrow><mi>𝐯</mi> <mo>∈</mo> <msup><mi>ℝ</mi>
    <mn>4</mn></msup></mrow></math>，使用从正态分布随机抽取的数字。按照早期描述的算法确定向量是否在矩阵的列空间中。多次重新运行代码以查看是否找到一致的模式。接下来，使用一个秩为4的
    <math alttext="粗体 𝐀 ∈ 双黑体 R 上标 4 乘 4"><mrow><mi>𝐀</mi> <mo>∈</mo> <msup><mi>ℝ</mi>
    <mrow><mn>4</mn><mo>×</mo><mn>4</mn></mrow></msup></mrow></math> 矩阵。我愿意打赌一百万比特币^([8](ch06.xhtml#idm45733299873664))，你
    *总是* 发现当 <math alttext="粗体 𝐀"><mi>𝐀</mi></math> 是一个 <math alttext="4 times 4"><mrow><mn>4</mn>
    <mo>×</mo> <mn>4</mn></mrow></math> 随机矩阵时（假设没有编码错误），<math alttext="粗体 𝐯 ∈ 斜体 C
    ( 粗体 𝐀 )"><mrow><mi>𝐯</mi> <mo>∈</mo> <mi>C</mi> <mo>(</mo> <mi>𝐀</mi> <mo>)</mo></mrow></math>。是什么让我对你的答案充满信心？^([9](ch06.xhtml#idm45733299865712))
- en: For an extra challenge, put this code into a function that returns `True` or
    `False` depending on the outcome of the test, and that raises an exception (that
    is, a useful error message) if the size of the vector does not match for matrix
    augmentation.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 对于额外的挑战，将这段代码放入一个函数中，根据测试结果返回 `True` 或 `False`，并在向量的大小与矩阵增广的尺寸不匹配时引发异常（即有用的错误消息）。
- en: Exercise 6-10\.
  id: totrans-282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习 6-10\.
- en: 'Remember that the determinant of a reduced-rank matrix is—in theory—zero. In
    this exercise, you will put this theory to the test. Implement the following steps:
    (1) Create a square random matrix. (2) Reduce the rank of the matrix. Previously
    you’ve done this by multiplying rectangular matrices; here, set one column to
    be a multiple of another column. (3) Compute the determinant and store its absolute
    value.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，降秩矩阵的行列式在理论上是零。在这个练习中，你将测试这一理论。实施以下步骤：（1）创建一个方形随机矩阵。 （2）降低矩阵的秩。之前你已经通过乘以矩形矩阵来实现这一点；在这里，将一个列设置为另一个列的倍数。
    （3）计算行列式并存储其绝对值。
- en: 'Run these three steps in a double `for` loop: one loop over matrix sizes ranging
    from <math alttext="3 times 3"><mrow><mn>3</mn> <mo>×</mo> <mn>3</mn></mrow></math>
    to <math alttext="30 times 30"><mrow><mn>30</mn> <mo>×</mo> <mn>30</mn></mrow></math>
    and a second loop that repeats the three steps one hundred times (repeating an
    experiment is useful when simulating noise data). Finally, plot the determinant,
    averaged over the one hundred repeats, in a line plot as a function of the number
    of elements in the matrix. Linear algebra theory predicts that that line (that
    is, the determinants of all the reduced-rank matrices) is zero, regardless of
    the matrix size. [Figure 6-10](#fig_6_10) shows otherwise, reflecting the computational
    difficulties with accurately computing the determinant. I log transformed the
    data for increased visibility; you should inspect the plot using log scaling and
    linear scaling.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在双重`for`循环中运行这三个步骤：一个循环遍历矩阵大小从<math alttext="3 times 3"><mrow><mn>3</mn> <mo>×</mo>
    <mn>3</mn></mrow></math>到<math alttext="30 times 30"><mrow><mn>30</mn> <mo>×</mo>
    <mn>30</mn></mrow></math>，另一个循环重复这三步一百次（在模拟噪声数据时重复实验是有用的）。最后，将平均过的行列式绘制成线图，作为矩阵元素数量的函数。线性代数理论预测，所有降秩矩阵的行列式都为零，无论矩阵大小如何。[图 6-10](#fig_6_10)显示相反，反映了准确计算行列式的计算困难。我对数据进行了对数变换以增加可见性；你应该使用对数缩放和线性缩放检查图表。
- en: '![Neato.](assets/plad_0610.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![漂亮](assets/plad_0610.png)'
- en: Figure 6-10\. Results of Exercise 6-10
  id: totrans-286
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-10\. 练习 6-10 的结果
- en: ^([1](ch06.xhtml#idm45733312155984-marker)) The internet claims this is a real
    word; let’s see if I can get it past the O’Reilly editors.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch06.xhtml#idm45733312155984-marker)) 互联网声称这是一个真正的词；让我们看看我能否让它通过 O’Reilly
    编辑的审查。
- en: ^([2](ch06.xhtml#idm45733311606896-marker)) If you are already familiar with
    the SVD, then the short version is that the SVD of <math alttext="bold upper A"><mi>𝐀</mi></math>
    and <math alttext="bold upper A Superscript upper T"><msup><mi>𝐀</mi> <mtext>T</mtext></msup></math>
    swap row and column spaces, but the number of nonzero singular values remains
    the same.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch06.xhtml#idm45733311606896-marker)) 如果你已经熟悉奇异值分解（SVD），那么简短的版本是，奇异值分解（SVD）的<math
    alttext="bold upper A"><mi>𝐀</mi></math>和<math alttext="bold upper A Superscript
    upper T"><msup><mi>𝐀</mi> <mtext>T</mtext></msup></math>交换了行和列空间，但非零奇异值的数量保持不变。
- en: ^([3](ch06.xhtml#idm45733311575264-marker)) r(**A**) = 1, r(**B**) = 1, r(**C**)
    = 2, r(**D**) = 3, r(**E**) = 1, r(**F**) = 0
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch06.xhtml#idm45733311575264-marker)) r(**A**) = 1, r(**B**) = 1, r(**C**)
    = 2, r(**D**) = 3, r(**E**) = 1, r(**F**) = 0
- en: ^([4](ch06.xhtml#idm45733311477072-marker)) The Infinite Improbability Drive
    is a technology that allows the *Heart of Gold* spaceship to traverse impossible
    distances in space. If you don’t know what I’m talking about, then you haven’t
    read *Hitchhiker’s Guide to the Galaxy* by Douglas Adams. And if you haven’t read
    that book, then you’re really missing out on one of the greatest, most thought-provoking,
    and funniest intellectual achievements of the 20th century.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch06.xhtml#idm45733311477072-marker)) 无限不可能驱动器是一种技术，允许*金心号*飞船在太空中穿越不可能的距离。如果你不知道我在说什么，那么你还没有阅读道格拉斯·亚当斯的《银河系漫游指南》。如果你还没有读过那本书，那么你真的错过了20世纪最伟大、最发人深省和最有趣的智力成就之一。
- en: ^([5](ch06.xhtml#idm45733311375120-marker)) This rule explains why the outer
    product always produces a rank-1 matrix.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch06.xhtml#idm45733311375120-marker)) 这个规则解释了为什么外积总是产生一个秩为1的矩阵。
- en: ^([6](ch06.xhtml#idm45733300001632-marker)) Any scaled version of [1 −1] and
    [1 1].
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch06.xhtml#idm45733300001632-marker)) 任何[1 −1]和[1 1]的缩放版本。
- en: ^([7](ch06.xhtml#idm45733299930304-marker)) *All* of these exercises are fun,
    but some more than others.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch06.xhtml#idm45733299930304-marker)) *所有*这些练习都很有趣，但有些比其他的更有趣。
- en: ^([8](ch06.xhtml#idm45733299873664-marker)) *n.b.* I don’t have that many bitcoins,
    ¯\_(ツ)_/¯.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch06.xhtml#idm45733299873664-marker)) *n.b.* 我没有那么多比特币，¯\_(ツ)_/¯。
- en: ^([9](ch06.xhtml#idm45733299865712-marker)) Because the column space of a full-rank
    matrix spans all of <math alttext="double-struck upper R Superscript upper M"><msup><mi>ℝ</mi>
    <mi>M</mi></msup></math> , and therefore *all* vectors in <math alttext="double-struck
    upper R Superscript upper M"><msup><mi>ℝ</mi> <mi>M</mi></msup></math> are necessarily
    in the column space.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch06.xhtml#idm45733299865712-marker)) 因为全秩矩阵的列空间跨越了<math alttext="double-struck
    upper R Superscript upper M"><msup><mi>ℝ</mi> <mi>M</mi></msup></math> 的全部，因此*所有*<math
    alttext="double-struck upper R Superscript upper M"><msup><mi>ℝ</mi> <mi>M</mi></msup></math>中的向量必然位于列空间中。
