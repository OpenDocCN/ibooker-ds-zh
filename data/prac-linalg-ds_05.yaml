- en: Chapter 5\. Matrices, Part 1
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç¬¬5ç« ã€‚çŸ©é˜µï¼Œç¬¬1éƒ¨åˆ†
- en: A matrix is a vector taken to the next level. Matrices are highly versatile
    mathematical objects. They can store sets of equations, geometric transformations,
    the positions of particles over time, financial records, and myriad other things.
    In data science, matrices are sometimes called data tables, in which rows correspond
    to observations (e.g., customers) and columns correspond to features (e.g., purchases).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: çŸ©é˜µæ˜¯å‘é‡çš„å‡çº§ç‰ˆã€‚çŸ©é˜µæ˜¯éå¸¸å¤šæ‰å¤šè‰ºçš„æ•°å­¦å¯¹è±¡ã€‚å®ƒä»¬å¯ä»¥å­˜å‚¨ä¸€ç»„æ–¹ç¨‹ã€å‡ ä½•å˜æ¢ã€ç²’å­éšæ—¶é—´çš„ä½ç½®ã€è´¢åŠ¡è®°å½•ä»¥åŠå…¶ä»–æ— æ•°çš„ä¸œè¥¿ã€‚åœ¨æ•°æ®ç§‘å­¦ä¸­ï¼ŒçŸ©é˜µæœ‰æ—¶è¢«ç§°ä¸ºæ•°æ®è¡¨ï¼Œå…¶ä¸­è¡Œå¯¹åº”è§‚æµ‹ï¼ˆä¾‹å¦‚å®¢æˆ·ï¼‰ï¼Œåˆ—å¯¹åº”ç‰¹å¾ï¼ˆä¾‹å¦‚è´­ä¹°ï¼‰ã€‚
- en: This and the following two chapters will take your knowledge about linear algebra
    to the next level. Get a cup of coffee and put on your thinking cap. Your brain
    will be bigger by the end of the chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç« å’Œæ¥ä¸‹æ¥çš„ä¸¤ç« å°†æŠŠä½ çš„çº¿æ€§ä»£æ•°çŸ¥è¯†æå‡åˆ°ä¸€ä¸ªæ–°çš„æ°´å¹³ã€‚æ¥æ¯å’–å•¡ï¼Œæˆ´ä¸Šæ€è€ƒå¸½å­ã€‚æœ¬ç« ç»“æŸæ—¶ä½ çš„å¤§è„‘ä¼šæ›´å¼ºå¤§ã€‚
- en: Creating and Visualizing Matrices in NumPy
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: åœ¨NumPyä¸­åˆ›å»ºå’Œå¯è§†åŒ–çŸ©é˜µ
- en: Depending on the context, matrices can be conceptualized as a set of column
    vectors stacked next to each other (e.g., a data table of observations-by-features),
    as a set of row vectors layered on top of each other (e.g., multisensor data in
    which each row is a time series from a different channel), or as an ordered collection
    of individual matrix elements (e.g., an image in which each matrix element encodes
    pixel intensity value).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: æ ¹æ®ä¸Šä¸‹æ–‡ï¼ŒçŸ©é˜µå¯ä»¥è¢«ç†è§£ä¸ºä¸€ç»„åˆ—å‘é‡ç›¸é‚»å †å åœ¨ä¸€èµ·ï¼ˆä¾‹å¦‚ï¼Œè§‚æµ‹å€¼-ç‰¹å¾æ•°æ®è¡¨ï¼‰ï¼Œæˆ–è€…ä¸€ç»„è¡Œå‘é‡å åŠ åœ¨ä¸€èµ·ï¼ˆä¾‹å¦‚ï¼Œå¤šä¼ æ„Ÿå™¨æ•°æ®ï¼Œæ¯è¡Œæ˜¯æ¥è‡ªä¸åŒé€šé“çš„æ—¶é—´åºåˆ—ï¼‰ï¼Œæˆ–è€…ä½œä¸ºæœ‰åºçš„ç‹¬ç«‹çŸ©é˜µå…ƒç´ é›†åˆï¼ˆä¾‹å¦‚ï¼Œå›¾åƒä¸­æ¯ä¸ªçŸ©é˜µå…ƒç´ ç¼–ç åƒç´ å¼ºåº¦å€¼ï¼‰ã€‚
- en: Visualizing, Indexing, and Slicing Matrices
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å¯è§†åŒ–ã€ç´¢å¼•å’Œåˆ‡ç‰‡çŸ©é˜µ
- en: 'Small matrices can simply be printed out in full, like the following examples:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: å°çŸ©é˜µå¯ä»¥ç®€å•åœ°å®Œæ•´æ‰“å°å‡ºæ¥ï¼Œä¾‹å¦‚ä»¥ä¸‹ç¤ºä¾‹ï¼š
- en: <math display="block"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mi>Ï€</mi></mtd> <mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>6</mn></mtd> <mtd><mn>7</mn></mtd></mtr></mtable></mfenced> <mo>,</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mo>-</mo> <mn>6</mn></mrow></mtd>
    <mtd><mrow><mn>1/3</mn></mrow></mtd></mtr> <mtr><mtd><msup><mi>e</mi> <mrow><mn>4.3</mn></mrow></msup></mtd>
    <mtd><mrow><mo>-</mo> <mn>1.4</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mn>6/5</mn></mrow></mtd>
    <mtd><mn>0</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mi>Ï€</mi></mtd> <mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>6</mn></mtd> <mtd><mn>7</mn></mtd></mtr></mtable></mfenced> <mo>,</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mo>-</mo> <mn>6</mn></mrow></mtd>
    <mtd><mrow><mn>1/3</mn></mrow></mtd></mtr> <mtr><mtd><msup><mi>e</mi> <mrow><mn>4.3</mn></mrow></msup></mtd>
    <mtd><mrow><mo>-</mo> <mn>1.4</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mn>6/5</mn></mrow></mtd>
    <mtd><mn>0</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: But thatâ€™s not scalable, and matrices that you work with in practice can be
    large, perhaps containing billions of elements. Therefore, larger matrices can
    be visualized as images. The numerical value of each element of the matrix maps
    onto a color in the image. In most cases, the maps are pseudo-colored because
    the mapping of numerical value onto color is arbitrary. [FigureÂ 5-1](#fig_5_1)
    shows some examples of matrices visualized as images using the Python library
    `matplotlib`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†è¿™ä¸æ˜¯å¯æ‰©å±•çš„ï¼Œå®é™…å·¥ä½œä¸­çš„çŸ©é˜µå¯èƒ½å¾ˆå¤§ï¼Œå¯èƒ½åŒ…å«æ•°åäº¿ä¸ªå…ƒç´ ã€‚å› æ­¤ï¼Œè¾ƒå¤§çš„çŸ©é˜µå¯ä»¥è¢«è§†ä¸ºå›¾åƒã€‚çŸ©é˜µçš„æ¯ä¸ªå…ƒç´ çš„æ•°å€¼æ˜ å°„åˆ°å›¾åƒä¸­çš„é¢œè‰²ã€‚åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œè¿™äº›æ˜ å°„æ˜¯ä¼ªå½©è‰²çš„ï¼Œå› ä¸ºæ•°å€¼åˆ°é¢œè‰²çš„æ˜ å°„æ˜¯ä»»æ„çš„ã€‚[FigureÂ 5-1](#fig_5_1)å±•ç¤ºäº†ä½¿ç”¨Pythonåº“`matplotlib`å°†çŸ©é˜µå¯è§†åŒ–ä¸ºå›¾åƒçš„ç¤ºä¾‹ã€‚
- en: '![Examples of matrices as images](assets/plad_0501.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![çŸ©é˜µä½œä¸ºå›¾åƒçš„ç¤ºä¾‹](assets/plad_0501.png)'
- en: Figure 5-1\. Three matrices, visualized as images
  id: totrans-10
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾ 5-1ã€‚ä¸‰ä¸ªçŸ©é˜µï¼Œè¢«è§†ä¸ºå›¾åƒ
- en: 'Matrices are indicated using bold-faced capital letters, like matrix <math
    alttext="bold upper A"><mi>ğ€</mi></math> or <math alttext="bold upper M"><mi>ğŒ</mi></math>
    . The size of a matrix is indicated using (row, column) convention. For example,
    the following matrix is 3 Ã— 5 because it has three rows and five columns:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: çŸ©é˜µä½¿ç”¨ç²—ä½“å¤§å†™å­—æ¯è¡¨ç¤ºï¼Œä¾‹å¦‚çŸ©é˜µ<math alttext="bold upper A"><mi>ğ€</mi></math>æˆ–<math alttext="bold
    upper M"><mi>ğŒ</mi></math>ã€‚çŸ©é˜µçš„å¤§å°ä½¿ç”¨ï¼ˆè¡Œæ•°ï¼Œåˆ—æ•°ï¼‰çº¦å®šè¡¨ç¤ºã€‚ä¾‹å¦‚ï¼Œä»¥ä¸‹çŸ©é˜µæ˜¯3 Ã— 5ï¼Œå› ä¸ºå®ƒæœ‰ä¸‰è¡Œäº”åˆ—ï¼š
- en: <math alttext="Start 3 By 5 Matrix 1st Row 1st Column 1 2nd Column 3 3rd Column
    5 4th Column 7 5th Column 9 2nd Row 1st Column 0 2nd Column 2 3rd Column 4 4th
    Column 6 5th Column 8 3rd Row 1st Column 1 2nd Column 4 3rd Column 7 4th Column
    8 5th Column 9 EndMatrix" display="block"><mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>3</mn></mtd> <mtd><mn>5</mn></mtd> <mtd><mn>7</mn></mtd> <mtd><mn>9</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>2</mn></mtd> <mtd><mn>4</mn></mtd> <mtd><mn>6</mn></mtd>
    <mtd><mn>8</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>4</mn></mtd> <mtd><mn>7</mn></mtd>
    <mtd><mn>8</mn></mtd> <mtd><mn>9</mn></mtd></mtr></mtable></mfenced></math>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 3 By 5 Matrix 1st Row 1st Column 1 2nd Column 3 3rd Column
    5 4th Column 7 5th Column 9 2nd Row 1st Column 0 2nd Column 2 3rd Column 4 4th
    Column 6 5th Column 8 3rd Row 1st Column 1 2nd Column 4 3rd Column 7 4th Column
    8 5th Column 9 EndMatrix" display="block"><mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>3</mn></mtd> <mtd><mn>5</mn></mtd> <mtd><mn>7</mn></mtd> <mtd><mn>9</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>2</mn></mtd> <mtd><mn>4</mn></mtd> <mtd><mn>6</mn></mtd>
    <mtd><mn>8</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>4</mn></mtd> <mtd><mn>7</mn></mtd>
    <mtd><mn>8</mn></mtd> <mtd><mn>9</mn></mtd></mtr></mtable></mfenced></math>
- en: 'You can refer to specific elements of a matrix by indexing the row and column
    position: the element in the 3rd row and 4th column of matrix <math alttext="bold
    upper A"><mi>ğ€</mi></math> is indicated as <math alttext="a Subscript 3 comma
    4"><msub><mi>a</mi> <mrow><mn>3</mn><mo>,</mo><mn>4</mn></mrow></msub></math>
    (and in the previous example matrix, <math alttext="a Subscript 3 comma 4 Baseline
    equals 8"><mrow><msub><mi>a</mi> <mrow><mn>3</mn><mo>,</mo><mn>4</mn></mrow></msub>
    <mo>=</mo> <mn>8</mn></mrow></math> ). *Important reminder:* math uses 1-based
    indexing whereas Python uses 0-based indexing. Thus, element <math alttext="a
    Subscript 3 comma 4"><msub><mi>a</mi> <mrow><mn>3</mn><mo>,</mo><mn>4</mn></mrow></msub></math>
    is indexed in Python as `A[2,3]`.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯ä»¥é€šè¿‡ç´¢å¼•è¡Œå’Œåˆ—ä½ç½®æ¥å¼•ç”¨çŸ©é˜µçš„ç‰¹å®šå…ƒç´ ï¼šçŸ©é˜µ<math alttext="bold upper A"><mi>ğ€</mi></math> ä¸­ç¬¬3è¡Œç¬¬4åˆ—çš„å…ƒç´ è¡¨ç¤ºä¸º<math
    alttext="a Subscript 3 comma 4"><msub><mi>a</mi> <mrow><mn>3</mn><mo>,</mo><mn>4</mn></mrow></msub></math>ï¼ˆåœ¨å‰è¿°ç¤ºä¾‹çŸ©é˜µä¸­ï¼Œ<math
    alttext="a Subscript 3 comma 4 Baseline equals 8"><mrow><msub><mi>a</mi> <mrow><mn>3</mn><mo>,</mo><mn>4</mn></mrow></msub>
    <mo>=</mo> <mn>8</mn></mrow></math>ï¼‰ã€‚*é‡è¦æç¤ºï¼š* æ•°å­¦ä¸­ä½¿ç”¨åŸºäº1çš„ç´¢å¼•ï¼Œè€ŒPythonä½¿ç”¨åŸºäº0çš„ç´¢å¼•ã€‚å› æ­¤ï¼Œåœ¨Pythonä¸­ç´¢å¼•å…ƒç´ <math
    alttext="a Subscript 3 comma 4"><msub><mi>a</mi> <mrow><mn>3</mn><mo>,</mo><mn>4</mn></mrow></msub></math>ä¸º`A[2,3]`ã€‚
- en: 'Extracting a subset of rows or columns of a matrix is done through slicing.
    If you are new to Python, you can consult [ChapterÂ 16](ch16.xhtml#Chapter_16)
    for an introduction to slicing lists and NumPy arrays. To extract a section out
    of a matrix, you specify the start and end rows and columns, and that the slicing
    goes in steps of 1\. The online code walks you through the procedure, and the
    following code shows an example of extracting a submatrix from rows 2â€“4 and columns
    1â€“5 of a larger matrix:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ä»çŸ©é˜µä¸­æå–å­é›†çš„è¡Œæˆ–åˆ—æ˜¯é€šè¿‡åˆ‡ç‰‡æ¥å®Œæˆçš„ã€‚å¦‚æœä½ ä¸ç†Ÿæ‚‰ Pythonï¼Œå¯ä»¥å‚è€ƒ [ChapterÂ 16](ch16.xhtml#Chapter_16)
    ä¸­å…³äºåˆ‡ç‰‡åˆ—è¡¨å’Œ NumPy æ•°ç»„çš„ä»‹ç»ã€‚è¦ä»çŸ©é˜µä¸­æå–ä¸€ä¸ªéƒ¨åˆ†ï¼Œä½ éœ€è¦æŒ‡å®šèµ·å§‹å’Œç»“æŸçš„è¡Œå’Œåˆ—ï¼Œåˆ‡ç‰‡æ­¥é•¿ä¸º1ã€‚åœ¨çº¿ä»£ç ä¼šå¼•å¯¼ä½ å®Œæˆè¿™ä¸ªè¿‡ç¨‹ï¼Œä»¥ä¸‹ä»£ç å±•ç¤ºäº†ä»è¾ƒå¤§çŸ©é˜µçš„ç¬¬2åˆ°ç¬¬4è¡Œå’Œç¬¬1åˆ°ç¬¬5åˆ—æå–å­çŸ©é˜µçš„ç¤ºä¾‹ï¼š
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And here are the full and submatrices:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯å®Œæ•´å’Œå­çŸ©é˜µçš„å…¨è²Œï¼š
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Special Matrices
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ç‰¹æ®ŠçŸ©é˜µ
- en: There is an infinite number of matrices, because there is an infinite number
    of ways of organizing numbers into a matrix. But matrices can be described using
    a relatively small number of characteristics, which creates â€œfamiliesâ€ or categories
    of matrices. These categories are important to know, because they appear in certain
    operations or have certain useful properties.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: çŸ©é˜µæœ‰æ— æ•°ç§ï¼Œå› ä¸ºæœ‰æ— æ•°ç§æ–¹æ³•å¯ä»¥å°†æ•°å­—ç»„ç»‡æˆçŸ©é˜µã€‚ä½†å¯ä»¥ä½¿ç”¨ç›¸å¯¹è¾ƒå°‘çš„ç‰¹å¾æ¥æè¿°çŸ©é˜µï¼Œè¿™äº›ç‰¹å¾å½¢æˆäº†çŸ©é˜µçš„â€œå®¶æ—â€æˆ–ç±»åˆ«ã€‚äº†è§£è¿™äº›ç±»åˆ«å¾ˆé‡è¦ï¼Œå› ä¸ºå®ƒä»¬åœ¨ç‰¹å®šæ“ä½œä¸­å‡ºç°æˆ–å…·æœ‰æŸäº›æœ‰ç”¨çš„å±æ€§ã€‚
- en: 'Some categories of matrices are used so frequently that they have dedicated
    NumPy functions to create them. Following is a list of some common special matrices
    and Python code to create them;^([1](ch05.xhtml#idm45733310025872)) you can see
    what they look like in [FigureÂ 5-2](#fig_5_2):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰äº›çŸ©é˜µç±»åˆ«è¢«å¦‚æ­¤é¢‘ç¹åœ°ä½¿ç”¨ï¼Œä»¥è‡³äºå®ƒä»¬æœ‰ä¸“é—¨çš„ NumPy å‡½æ•°æ¥åˆ›å»ºå®ƒä»¬ã€‚ä»¥ä¸‹æ˜¯ä¸€äº›å¸¸è§ç‰¹æ®ŠçŸ©é˜µçš„åˆ—è¡¨å’Œç”¨ Python ä»£ç åˆ›å»ºå®ƒä»¬çš„æ–¹æ³•ï¼›^([1](ch05.xhtml#idm45733310025872))
    ä½ å¯ä»¥åœ¨ [FigureÂ 5-2](#fig_5_2) ä¸­çœ‹åˆ°å®ƒä»¬çš„å¤–è§‚ï¼š
- en: Random numbers matrix
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: éšæœºæ•°çŸ©é˜µ
- en: This is a matrix that contains numbers drawn at random from some distribution,
    typically Gaussian (a.k.a. normal). Random-numbers matrices are great for exploring
    linear algebra in code, because they are quickly and easily created with any size
    and rank (matrix rank is a concept youâ€™ll learn about in [ChapterÂ 16](ch16.xhtml#Chapter_16)).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ä¸ªåŒ…å«ä»æŸä¸ªåˆ†å¸ƒï¼ˆé€šå¸¸æ˜¯é«˜æ–¯ï¼Œåˆç§°æ­£æ€ï¼‰éšæœºæŠ½å–çš„æ•°å­—çš„çŸ©é˜µã€‚éšæœºæ•°çŸ©é˜µéå¸¸é€‚åˆç”¨ä»£ç æ¢ç´¢çº¿æ€§ä»£æ•°ï¼Œå› ä¸ºå¯ä»¥å¿«é€Ÿä¸”è½»æ¾åœ°åˆ›å»ºä»»ä½•å¤§å°å’Œç§©çš„çŸ©é˜µï¼ˆçŸ©é˜µç§©æ˜¯ä¸€ä¸ªä½ å°†åœ¨
    [ChapterÂ 16](ch16.xhtml#Chapter_16) ä¸­å­¦ä¹ çš„æ¦‚å¿µï¼‰ã€‚
- en: 'There are several ways to create random matrices in NumPy, depending on which
    distribution you want to draw numbers from. In this book, weâ€™ll mostly use Gaussian-distributed
    numbers:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy ä¸­åˆ›å»ºéšæœºçŸ©é˜µæœ‰å‡ ç§æ–¹å¼ï¼Œå…·ä½“å–å†³äºä½ å¸Œæœ›ä»å“ªä¸ªåˆ†å¸ƒä¸­æŠ½å–æ•°å€¼ã€‚åœ¨æœ¬ä¹¦ä¸­ï¼Œæˆ‘ä»¬ä¸»è¦ä½¿ç”¨é«˜æ–¯åˆ†å¸ƒçš„æ•°å€¼ï¼š
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Square versus nonsquare
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: æ–¹é˜µä¸éæ–¹é˜µ
- en: A square matrix has the same number of rows as columns; in other words, the
    matrix is in <math alttext="double-struck upper R Superscript upper N times upper
    N"><msup><mi>â„</mi> <mrow><mi>N</mi><mo>Ã—</mo><mi>N</mi></mrow></msup></math>
    . A nonsquare matrix, also sometimes called a rectangular matrix, has a different
    number of rows and columns. You can create square and rectangular matrices from
    random numbers by adjusting the shape parameters in the previous code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: æ–¹é˜µçš„è¡Œæ•°ä¸åˆ—æ•°ç›¸åŒï¼›æ¢å¥è¯è¯´ï¼Œè¯¥çŸ©é˜µåœ¨ <math alttext="double-struck upper R Superscript upper
    N times upper N"><msup><mi>â„</mi> <mrow><mi>N</mi><mo>Ã—</mo><mi>N</mi></mrow></msup></math>
    ä¸­ã€‚éæ–¹é˜µï¼Œæœ‰æ—¶ä¹Ÿç§°ä¸ºçŸ©å½¢çŸ©é˜µï¼Œå…¶è¡Œæ•°å’Œåˆ—æ•°ä¸åŒã€‚é€šè¿‡åœ¨å…ˆå‰ä»£ç ä¸­è°ƒæ•´å½¢çŠ¶å‚æ•°ï¼Œä½ å¯ä»¥ä»éšæœºæ•°åˆ›å»ºæ–¹é˜µå’ŒçŸ©å½¢çŸ©é˜µã€‚
- en: Rectangular matrices are called *tall* if they have more rows than columns and
    *wide* if they have more columns than rows.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœçŸ©é˜µçš„è¡Œæ•°å¤šäºåˆ—æ•°ï¼Œåˆ™ç§°å…¶ä¸º*é«˜*çŸ©é˜µï¼Œå¦‚æœåˆ—æ•°å¤šäºè¡Œæ•°ï¼Œåˆ™ç§°å…¶ä¸º*å®½*çŸ©é˜µã€‚
- en: Diagonal
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹è§’çº¿
- en: The *diagonal* of a matrix is the elements starting at the top-left and going
    down to the bottom-right. A *diagonal matrix* has zeros on all the off-diagonal
    elements; the diagonal elements may also contain zeros, but they are the only
    elements that may contain nonzero values.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: çŸ©é˜µçš„*å¯¹è§’çº¿*æ˜¯ä»å·¦ä¸Šè§’åˆ°å³ä¸‹è§’çš„å…ƒç´ ã€‚*å¯¹è§’çŸ©é˜µ*åœ¨æ‰€æœ‰éå¯¹è§’çº¿å…ƒç´ ä¸Šéƒ½æœ‰é›¶ï¼›å¯¹è§’çº¿ä¸Šçš„å…ƒç´ å¯èƒ½åŒ…å«é›¶ï¼Œä½†è¿™äº›å…ƒç´ æ˜¯å”¯ä¸€å¯èƒ½åŒ…å«éé›¶å€¼çš„å…ƒç´ ã€‚
- en: 'The NumPy function `np.diag()` has two behaviors depending on the inputs: input
    a matrix and `np.diag` will return the diagonal elements as a vector; input a
    vector and `np.diag` will return a matrix with those vector elements on the diagonal.
    (Note: extracting the diagonal elements of a matrix is *not* called â€œdiagonalizing
    a matrixâ€; that is a separate operation introduced in [ChapterÂ 13](ch13.xhtml#Chapter_13).)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy å‡½æ•°`np.diag()`æ ¹æ®è¾“å…¥çš„ä¸åŒå…·æœ‰ä¸¤ç§è¡Œä¸ºï¼šè¾“å…¥ä¸€ä¸ªçŸ©é˜µï¼Œ`np.diag`ä¼šå°†å¯¹è§’çº¿å…ƒç´ ä½œä¸ºå‘é‡è¿”å›ï¼›è¾“å…¥ä¸€ä¸ªå‘é‡ï¼Œ`np.diag`ä¼šè¿”å›ä»¥è¯¥å‘é‡å…ƒç´ ä¸ºå¯¹è§’çº¿å…ƒç´ çš„çŸ©é˜µã€‚ï¼ˆæ³¨æ„ï¼šæå–çŸ©é˜µçš„å¯¹è§’çº¿å…ƒç´ å¹¶ä¸ç§°ä¸ºâ€œå¯¹è§’åŒ–çŸ©é˜µâ€ï¼›è¿™æ˜¯åœ¨[ç¬¬
    13 ç« ](ch13.xhtml#Chapter_13)ä¸­ä»‹ç»çš„å¦ä¸€ç§æ“ä½œã€‚ï¼‰
- en: Triangular
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‰è§’å½¢
- en: A triangular matrix contains all zeros either above or below the main diagonal.
    The matrix is called *upper triangular* if the nonzero elements are above the
    diagonal and *lower triangular* if the nonzero elements are below the diagonal.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‰è§’çŸ©é˜µåŒ…å«ä¸»å¯¹è§’çº¿ä¸Šæ–¹æˆ–ä¸‹æ–¹çš„å…¨éƒ¨é›¶å…ƒç´ ã€‚å¦‚æœéé›¶å…ƒç´ åœ¨å¯¹è§’çº¿ä¸Šæ–¹ï¼Œåˆ™ç§°ä¸º*ä¸Šä¸‰è§’*çŸ©é˜µï¼›å¦‚æœåœ¨å¯¹è§’çº¿ä¸‹æ–¹ï¼Œåˆ™ç§°ä¸º*ä¸‹ä¸‰è§’*çŸ©é˜µã€‚
- en: NumPy has dedicated functions to extract the upper (`np.triu()`) or lower (`np.tril()`)
    triangle of a matrix.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy æœ‰ä¸“é—¨çš„å‡½æ•°æ¥æå–çŸ©é˜µçš„ä¸Šä¸‰è§’ï¼ˆ`np.triu()`ï¼‰æˆ–ä¸‹ä¸‰è§’ï¼ˆ`np.tril()`ï¼‰ã€‚
- en: Identity
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: å•ä½çŸ©é˜µ
- en: The identity matrix is one of the most important special matrices. It is the
    equivalent of the number 1, in that any matrix or vector times the identity matrix
    is that same matrix or vector. The identity matrix is a square diagonal matrix
    with all diagonal elements having a value of 1\. It is indicated using the letter
    <math alttext="bold upper I"><mi>ğˆ</mi></math> . You might see a subscript to
    indicate its size (e.g., <math alttext="bold upper I 5"><msub><mi>ğˆ</mi> <mn>5</mn></msub></math>
    is the <math alttext="5 times 5"><mrow><mn>5</mn> <mo>Ã—</mo> <mn>5</mn></mrow></math>
    identity matrix); if not, then you can infer the size from context (e.g., to make
    the equation consistent).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: å•ä½çŸ©é˜µæ˜¯æœ€é‡è¦çš„ç‰¹æ®ŠçŸ©é˜µä¹‹ä¸€ã€‚å®ƒç›¸å½“äºæ•°å­—1ï¼Œä»»ä½•çŸ©é˜µæˆ–å‘é‡ä¹˜ä»¥å•ä½çŸ©é˜µéƒ½æ˜¯åŒæ ·çš„çŸ©é˜µæˆ–å‘é‡ã€‚å•ä½çŸ©é˜µæ˜¯ä¸€ä¸ªå…·æœ‰æ‰€æœ‰å¯¹è§’çº¿å…ƒç´ å€¼ä¸º1çš„æ–¹é˜µå¯¹è§’çº¿çŸ©é˜µã€‚å®ƒç”¨å­—æ¯<math
    alttext="bold upper I"><mi>ğˆ</mi></math>è¡¨ç¤ºã€‚ä½ å¯èƒ½ä¼šçœ‹åˆ°ä¸€ä¸ªä¸‹æ ‡æ¥è¡¨ç¤ºå…¶å¤§å°ï¼ˆä¾‹å¦‚ï¼Œ<math alttext="bold
    upper I 5"><msub><mi>ğˆ</mi><mn>5</mn></msub></math> æ˜¯<math alttext="5 times 5"><mrow><mn>5</mn><mo>Ã—</mo><mn>5</mn></mrow></math>å•ä½çŸ©é˜µï¼‰ï¼›å¦‚æœæ²¡æœ‰ï¼Œä½ å¯ä»¥ä»ä¸Šä¸‹æ–‡ä¸­æ¨æ–­å¤§å°ï¼ˆä¾‹å¦‚ï¼Œä¸ºäº†ä½¿æ–¹ç¨‹ä¸€è‡´ï¼‰ã€‚
- en: You can create an identity matrix in Python using `np.eye()`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Python ä¸­ï¼Œä½ å¯ä»¥ä½¿ç”¨`np.eye()`åˆ›å»ºå•ä½çŸ©é˜µã€‚
- en: Zeros
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: é›¶çŸ©é˜µ
- en: 'The zeros matrix is comparable to the zeros vector: it is the matrix of all
    zeros. Like the zeros vector, it is indicated using a bold-faced zero: <math alttext="bold
    0"><mn mathvariant="bold">0</mn></math> . It can be a bit confusing to have the
    same symbol indicate both a vector and a matrix, but this kind of overloading
    is common in math and science notation.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: é›¶çŸ©é˜µç±»ä¼¼äºé›¶å‘é‡ï¼šæ‰€æœ‰å…ƒç´ éƒ½æ˜¯é›¶çš„çŸ©é˜µã€‚åƒé›¶å‘é‡ä¸€æ ·ï¼Œå®ƒç”¨ç²—ä½“é›¶ç¬¦å·è¡¨ç¤ºï¼š<math alttext="bold 0"><mn mathvariant="bold">0</mn></math>ã€‚åœ¨æ•°å­¦å’Œç§‘å­¦ç¬¦å·ä¸­ï¼Œä½¿ç”¨ç›¸åŒç¬¦å·æŒ‡ä»£å‘é‡å’ŒçŸ©é˜µå¯èƒ½æœ‰äº›æ··æ·†ï¼Œä½†è¿™ç§é‡è½½åœ¨æ•°å­¦å’Œç§‘å­¦ç¬¦å·ä¸­å¾ˆå¸¸è§ã€‚
- en: The zeros matrix is created using the `np.zeros()` function.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨`np.zeros()`å‡½æ•°åˆ›å»ºé›¶çŸ©é˜µã€‚
- en: '![Sthpecial matrices](assets/plad_0502.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![ç‰¹æ®ŠçŸ©é˜µ](assets/plad_0502.png)'
- en: Figure 5-2\. Some special matrices. Numbers and grayscale values indicate the
    matrix value at each element.
  id: totrans-42
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾ 5-2\. ä¸€äº›ç‰¹æ®ŠçŸ©é˜µã€‚æ•°å­—å’Œç°åº¦å€¼è¡¨ç¤ºæ¯ä¸ªå…ƒç´ çš„çŸ©é˜µå€¼ã€‚
- en: 'Matrix Math: Addition, Scalar Multiplication, Hadamard Multiplication'
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: çŸ©é˜µæ•°å­¦ï¼šåŠ æ³•ï¼Œæ ‡é‡ä¹˜æ³•ï¼Œå“ˆè¾¾ç›ä¹˜æ³•
- en: 'Mathematical operations on matrices fall into two categories: intuitive and
    unintuitive. In general, the intuitive operations can be expressed as element-wise
    procedures whereas the unintuitive operations take longer to explain and a bit
    of practice to understand. Letâ€™s start with the intuitive operations.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: çŸ©é˜µçš„æ•°å­¦è¿ç®—åˆ†ä¸ºä¸¤ç±»ï¼šç›´è§‚å’Œä¸ç›´è§‚ã€‚é€šå¸¸ï¼Œç›´è§‚æ“ä½œå¯ä»¥è¡¨è¾¾ä¸ºé€å…ƒç´ çš„è¿‡ç¨‹ï¼Œè€Œä¸ç›´è§‚çš„æ“ä½œåˆ™éœ€è¦æ›´é•¿çš„è§£é‡Šå’Œä¸€äº›å®è·µæ‰èƒ½ç†è§£ã€‚è®©æˆ‘ä»¬ä»ç›´è§‚æ“ä½œå¼€å§‹ã€‚
- en: Addition and Subtraction
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: åŠ æ³•å’Œå‡æ³•
- en: 'You add two matrices by adding their corresponding elements. Hereâ€™s an example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸¤ä¸ªçŸ©é˜µç›¸åŠ æ˜¯é€šè¿‡ç›¸åŠ å®ƒä»¬å¯¹åº”å…ƒç´ å®ç°çš„ã€‚è¿™é‡Œæ˜¯ä¸€ä¸ªä¾‹å­ï¼š
- en: <math alttext="Start 2 By 3 Matrix 1st Row 1st Column 2 2nd Column 3 3rd Column
    4 2nd Row 1st Column 1 2nd Column 2 3rd Column 4 EndMatrix plus Start 2 By 3 Matrix
    1st Row 1st Column 0 2nd Column 3 3rd Column 1 2nd Row 1st Column negative 1 2nd
    Column negative 4 3rd Column 2 EndMatrix equals Start 2 By 3 Matrix 1st Row 1st
    Column left-parenthesis 2 plus 0 right-parenthesis 2nd Column left-parenthesis
    3 plus 3 right-parenthesis 3rd Column left-parenthesis 4 plus 1 right-parenthesis
    2nd Row 1st Column left-parenthesis 1 minus 1 right-parenthesis 2nd Column left-parenthesis
    2 minus 4 right-parenthesis 3rd Column left-parenthesis 4 plus 2 right-parenthesis
    EndMatrix equals Start 2 By 3 Matrix 1st Row 1st Column 2 2nd Column 6 3rd Column
    5 2nd Row 1st Column 0 2nd Column negative 2 3rd Column 6 EndMatrix" display="block"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>2</mn></mtd> <mtd><mn>3</mn></mtd> <mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd> <mtd><mn>4</mn></mtd></mtr></mtable></mfenced>
    <mo>+</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>0</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>3</mn></mrow></mtd>
    <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>1</mn></mrow></mtd>
    <mtd><mrow><mo>-</mo> <mn>4</mn></mrow></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mo>(</mo> <mn>2</mn>
    <mo>+</mo> <mn>0</mn> <mo>)</mo></mrow></mtd> <mtd><mrow><mo>(</mo> <mn>3</mn>
    <mo>+</mo> <mn>3</mn> <mo>)</mo></mrow></mtd> <mtd><mrow><mo>(</mo> <mn>4</mn>
    <mo>+</mo> <mn>1</mn> <mo>)</mo></mrow></mtd></mtr> <mtr><mtd><mrow><mo>(</mo>
    <mn>1</mn> <mo>-</mo> <mn>1</mn> <mo>)</mo></mrow></mtd> <mtd><mrow><mo>(</mo>
    <mn>2</mn> <mo>-</mo> <mn>4</mn> <mo>)</mo></mrow></mtd> <mtd><mrow><mo>(</mo>
    <mn>4</mn> <mo>+</mo> <mn>2</mn> <mo>)</mo></mrow></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>2</mn></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>6</mn></mrow></mtd> <mtd><mn>5</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mrow><mo>-</mo> <mn>2</mn></mrow></mtd> <mtd><mn>6</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 3 Matrix 1st Row 1st Column 2 2nd Column 3 3rd Column
    4 2nd Row 1st Column 1 2nd Column 2 3rd Column 4 EndMatrix plus Start 2 By 3 Matrix
    1st Row 1st Column 0 2nd Column 3 3rd Column 1 2nd Row 1st Column negative 1 2nd
    Column negative 4 3rd Column 2 EndMatrix equals Start 2 By 3 Matrix 1st Row 1st
    Column left-parenthesis 2 plus 0 right-parenthesis 2nd Column left-parenthesis
    3 plus 3 right-parenthesis 3rd Column left-parenthesis 4 plus 1 right-parenthesis
    2nd Row 1st Column left-parenthesis 1 minus 1 right-parenthesis 2nd Column left-parenthesis
    2 minus 4 right-parenthesis 3rd Column left-parenthesis 4 plus 2 right-parenthesis
    EndMatrix equals Start 2 By 3 Matrix 1st Row 1st Column 2 2nd Column 6 3rd Column
    5 2nd Row 1st Column 0 2nd Column negative 2 3rd Column 6 EndMatrix" display="block"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>2</mn></mtd> <mtd><mn>3</mn></mtd> <mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd> <mtd><mn>4</mn></mtd></mtr></mtable></mfenced>
    <mo>+</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>0</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>3</mn></mrow></mtd>
    <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>1</mn></mrow></mtd>
    <mtd><mrow><mo>-</mo> <mn>4</mn></mrow></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mo>(</mo> <mn>2</mn>
    <mo>+</mo> <mn>0</mn> <mo>)</mo></mrow></mtd> <mtd><mrow><mo>(</mo> <mn>3</mn>
    <mo>+</mo> <mn>3</mn> <mo>)</mo></mrow></mtd> <mtd><mrow><mo>(</mo> <mn>4</mn>
    <mo>+</mo> <mn>1</mn> <mo>)</mo></mrow></mtd></mtr> <mtr><mtd><mrow><mo>(</mo>
    <mn>1</mn> <mo>-</mo> <mn>1</mn> <mo>)</mo></mrow></mtd> <mtd><mrow><mo>(</mo>
    <mn>2</mn> <mo>-</mo> <mn>4</mn> <mo>)</mo></mrow></mtd> <mtd><mrow><mo>(</mo>
    <mn>4</mn> <mo>+</mo> <mn>2</mn> <mo>)</mo></mrow></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>2</mn></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>6</mn></mrow></mtd> <mtd><mn>5</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mrow><mo>-</mo> <mn>2</mn></mrow></mtd> <mtd><mn>6</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: As you might guess from the example, matrix addition is defined only between
    two matrices of the same size.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚ä½ ä»ä¾‹å­ä¸­æ‰€çŒœæµ‹çš„é‚£æ ·ï¼ŒçŸ©é˜µåŠ æ³•ä»…åœ¨å¤§å°ç›¸åŒçš„ä¸¤ä¸ªçŸ©é˜µä¹‹é—´å®šä¹‰ã€‚
- en: â€œShiftingâ€ a Matrix
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: â€œå¹³ç§»â€çŸ©é˜µ
- en: As with vectors, it is not formally possible to add a scalar to a matrix, as
    in <math alttext="lamda plus bold upper A"><mrow><mi>Î»</mi> <mo>+</mo> <mi>ğ€</mi></mrow></math>
    . Python allows such an operation (e.g., `3+np.eye(2)`), which involves broadcast-adding
    the scalar to each element of the matrix. That is a convenient computation, but
    it is not formally a linear algebra operation.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å‘é‡ä¸€æ ·ï¼Œæ­£å¼è€Œè¨€ä¸èƒ½åƒ <math alttext="lamda plus bold upper A"><mrow><mi>Î»</mi> <mo>+</mo>
    <mi>ğ€</mi></mrow></math> è¿™æ ·å°†æ ‡é‡æ·»åŠ åˆ°çŸ©é˜µä¸­ã€‚Python å…è®¸è¿™æ ·çš„æ“ä½œï¼ˆä¾‹å¦‚ `3+np.eye(2)`ï¼‰ï¼Œè¿™æ¶‰åŠå°†æ ‡é‡å¹¿æ’­æ·»åŠ åˆ°çŸ©é˜µçš„æ¯ä¸ªå…ƒç´ ä¸­ã€‚è¿™æ˜¯ä¸€ä¸ªæ–¹ä¾¿çš„è®¡ç®—ï¼Œä½†å¹¶ä¸æ˜¯æ­£å¼çš„çº¿æ€§ä»£æ•°æ“ä½œã€‚
- en: 'But there is a linear-algebra way to add a scalar to a square matrix, and that
    is called *shifting* a matrix. It works by adding a constant value to the diagonal,
    which is implemented by adding a scalar multiplied identity matrix:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†æ˜¯æœ‰ä¸€ç§çº¿æ€§ä»£æ•°çš„æ–¹æ³•å¯ä»¥å‘æ–¹é˜µæ·»åŠ ä¸€ä¸ªæ ‡é‡ï¼Œé‚£å°±æ˜¯*ç§»ä½*çŸ©é˜µã€‚å®ƒé€šè¿‡å‘å¯¹è§’çº¿æ·»åŠ ä¸€ä¸ªå¸¸æ•°å€¼æ¥å®ç°ï¼Œè¿™ç”±æ·»åŠ ä¸€ä¸ªæ ‡é‡ä¹˜ä»¥å•ä½çŸ©é˜µæ¥å®ç°ï¼š
- en: <math alttext="bold upper A plus lamda bold upper I" display="block"><mrow><mi>ğ€</mi>
    <mo>+</mo> <mi>Î»</mi> <mi>ğˆ</mi></mrow></math>
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="bold upper A plus lamda bold upper I" display="block"><mrow><mi>ğ€</mi>
    <mo>+</mo> <mi>Î»</mi> <mi>ğˆ</mi></mrow></math>
- en: 'Hereâ€™s a numerical example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ä¸ªæ•°å€¼ä¾‹å­ï¼š
- en: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 4 2nd Column 5 3rd Column
    1 2nd Row 1st Column 0 2nd Column 1 3rd Column 11 3rd Row 1st Column 4 2nd Column
    9 3rd Column 7 EndMatrix plus 6 Start 3 By 3 Matrix 1st Row 1st Column 1 2nd Column
    0 3rd Column 0 2nd Row 1st Column 0 2nd Column 1 3rd Column 0 3rd Row 1st Column
    0 2nd Column 0 3rd Column 1 EndMatrix equals Start 3 By 3 Matrix 1st Row 1st Column
    10 2nd Column 5 3rd Column 1 2nd Row 1st Column 0 2nd Column 7 3rd Column 11 3rd
    Row 1st Column 4 2nd Column 9 3rd Column 13 EndMatrix" display="block"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>4</mn></mtd> <mtd><mn>5</mn></mtd> <mtd><mn>1</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>11</mn></mtd></mtr>
    <mtr><mtd><mn>4</mn></mtd> <mtd><mn>9</mn></mtd> <mtd><mn>7</mn></mtd></mtr></mtable></mfenced>
    <mo>+</mo> <mn>6</mn> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>10</mn></mtd> <mtd><mn>5</mn></mtd>
    <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>7</mn></mtd> <mtd><mn>11</mn></mtd></mtr>
    <mtr><mtd><mn>4</mn></mtd> <mtd><mn>9</mn></mtd> <mtd><mn>13</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 4 2nd Column 5 3rd Column
    1 2nd Row 1st Column 0 2nd Column 1 3rd Column 11 3rd Row 1st Column 4 2nd Column
    9 3rd Column 7 EndMatrix plus 6 Start 3 By 3 Matrix 1st Row 1st Column 1 2nd Column
    0 3rd Column 0 2nd Row 1st Column 0 2nd Column 1 3rd Column 0 3rd Row 1st Column
    0 2nd Column 0 3rd Column 1 EndMatrix equals Start 3 By 3 Matrix 1st Row 1st Column
    10 2nd Column 5 3rd Column 1 2nd Row 1st Column 0 2nd Column 7 3rd Column 11 3rd
    Row 1st Column 4 2nd Column 9 3rd Column 13 EndMatrix" display="block"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>4</mn></mtd> <mtd><mn>5</mn></mtd> <mtd><mn>1</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>11</mn></mtd></mtr>
    <mtr><mtd><mn>4</mn></mtd> <mtd><mn>9</mn></mtd> <mtd><mn>7</mn></mtd></mtr></mtable></mfenced>
    <mo>+</mo> <mn>6</mn> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>10</mn></mtd> <mtd><mn>5</mn></mtd>
    <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>7</mn></mtd> <mtd><mn>11</mn></mtd></mtr>
    <mtr><mtd><mn>4</mn></mtd> <mtd><mn>9</mn></mtd> <mtd><mn>13</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'Shifting in Python is straightforward:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Python ä¸­è¿›è¡Œç§»ä½æ˜¯ç›´æ¥çš„ï¼š
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that only the diagonal elements change; the rest of the matrix is unadulterated
    by shifting. In practice, one shifts a relatively small amount to preserve as
    much information as possible in the matrix while benefiting from the effects of
    shifting, including increasing the numerical stability of the matrix (youâ€™ll learn
    later in the book why that happens).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„åªæœ‰å¯¹è§’å…ƒç´ ä¼šæ”¹å˜ï¼›çŸ©é˜µçš„å…¶ä½™éƒ¨åˆ†ä¸ä¼šå—åˆ°ç§»ä½çš„å½±å“ã€‚åœ¨å®è·µä¸­ï¼Œä¸ºäº†å°½å¯èƒ½ä¿ç•™çŸ©é˜µä¸­çš„ä¿¡æ¯ï¼ŒåŒæ—¶å—ç›Šäºç§»ä½çš„æ•ˆæœï¼ŒåŒ…æ‹¬å¢åŠ çŸ©é˜µçš„æ•°å€¼ç¨³å®šæ€§ï¼ˆæ‚¨å°†åœ¨æœ¬ä¹¦åé¢å­¦åˆ°ä¸ºä»€ä¹ˆä¼šå‘ç”Ÿè¿™ç§æƒ…å†µï¼‰ã€‚
- en: Exactly how much to shift is a matter of ongoing research in multiple areas
    of machine learning, statistics, deep learning, control engineering, etc. For
    example, is shifting by <math alttext="lamda equals 6"><mrow><mi>Î»</mi> <mo>=</mo>
    <mn>6</mn></mrow></math> a little or a lot? How about <math display="inline"><mrow><mi>Î»</mi>
    <mo>=</mo> <mn>.001</mn></mrow></math> ? Obviously, these numbers are â€œbigâ€ or
    â€œsmallâ€ relative to the numerical values in the matrix. Therefore, in practice,
    <math alttext="lamda"><mi>Î»</mi></math> is usually set to be some fraction of
    a matrix-defined quantity such as the norm or the average of the eigenvalues.
    Youâ€™ll get to explore this in later chapters.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ç©¶ç«Ÿéœ€è¦ç§»åŠ¨å¤šå°‘æ˜¯æœºå™¨å­¦ä¹ ã€ç»Ÿè®¡å­¦ã€æ·±åº¦å­¦ä¹ ã€æ§åˆ¶å·¥ç¨‹ç­‰å¤šä¸ªé¢†åŸŸæ­£åœ¨è¿›è¡Œç ”ç©¶çš„é—®é¢˜ã€‚ä¾‹å¦‚ï¼Œé€šè¿‡ <math alttext="lamda equals
    6"><mrow><mi>Î»</mi> <mo>=</mo> <mn>6</mn></mrow></math> è¿›è¡Œç§»åŠ¨æ˜¯å¤šè¿˜æ˜¯å°‘ï¼Ÿ<math display="inline"><mrow><mi>Î»</mi>
    <mo>=</mo> <mn>.001</mn></mrow></math> å‘¢ï¼Ÿæ˜¾ç„¶ï¼Œè¿™äº›æ•°å€¼ç›¸å¯¹äºçŸ©é˜µä¸­çš„æ•°å€¼æ¥è¯´æ˜¯â€œå¤§â€è¿˜æ˜¯â€œå°â€ã€‚å› æ­¤ï¼Œåœ¨å®è·µä¸­ï¼Œ<math
    alttext="lamda"><mi>Î»</mi></math> é€šå¸¸è¢«è®¾ç½®ä¸ºçŸ©é˜µå®šä¹‰çš„æŸä¸ªé‡ï¼Œå¦‚èŒƒæ•°æˆ–ç‰¹å¾å€¼çš„å¹³å‡æ•°çš„ä¸€éƒ¨åˆ†ã€‚æ‚¨å°†åœ¨åé¢çš„ç« èŠ‚ä¸­è¿›ä¸€æ­¥æ¢è®¨è¿™ä¸ªé—®é¢˜ã€‚
- en: 'â€œShiftingâ€ a matrix has two primary (extremely important!) applications: it
    is the mechanism of finding the eigenvalues of a matrix, and it is the mechanism
    of regularizing matrices when fitting models to data.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: â€œç§»ä½â€çŸ©é˜µæœ‰ä¸¤ä¸ªä¸»è¦ï¼ˆéå¸¸é‡è¦ï¼ï¼‰çš„åº”ç”¨ï¼šå®ƒæ˜¯æ‰¾åˆ°çŸ©é˜µç‰¹å¾å€¼çš„æœºåˆ¶ï¼Œä¹Ÿæ˜¯åœ¨å°†æ¨¡å‹æ‹Ÿåˆåˆ°æ•°æ®æ—¶æ­£åˆ™åŒ–çŸ©é˜µçš„æœºåˆ¶ã€‚
- en: Scalar and Hadamard Multiplications
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: æ ‡é‡å’ŒHadamardä¹˜æ³•
- en: These two types of multiplication work the same for matrices as they do for
    vectors, which is to say, element-wise.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸¤ç§ä¹˜æ³•å¯¹çŸ©é˜µå’Œå‘é‡çš„å·¥ä½œæ–¹å¼ç›¸åŒï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒä»¬æ˜¯é€å…ƒç´ çš„ã€‚
- en: 'Scalar-matrix multiplication means to multiply each element in the matrix by
    the same scalar. Here is an example using a matrix comprising letters instead
    of numbers:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: æ ‡é‡-çŸ©é˜µä¹˜æ³•æ„å‘³ç€å°†çŸ©é˜µä¸­çš„æ¯ä¸ªå…ƒç´ ä¹˜ä»¥ç›¸åŒçš„æ ‡é‡ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªä½¿ç”¨å­—æ¯è€Œä¸æ˜¯æ•°å­—çš„çŸ©é˜µçš„ç¤ºä¾‹ï¼š
- en: <math alttext="gamma Start 2 By 2 Matrix 1st Row 1st Column a 2nd Column b 2nd
    Row 1st Column c 2nd Column d EndMatrix equals Start 2 By 2 Matrix 1st Row 1st
    Column gamma a 2nd Column gamma b 2nd Row 1st Column gamma c 2nd Column gamma
    d EndMatrix" display="block"><mrow><mi>Î³</mi> <mfenced close="]" open="["><mtable><mtr><mtd><mi>a</mi></mtd>
    <mtd><mi>b</mi></mtd></mtr> <mtr><mtd><mi>c</mi></mtd> <mtd><mi>d</mi></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mi>Î³</mi> <mi>a</mi></mrow></mtd>
    <mtd><mrow><mi>Î³</mi> <mi>b</mi></mrow></mtd></mtr> <mtr><mtd><mrow><mi>Î³</mi>
    <mi>c</mi></mrow></mtd> <mtd><mrow><mi>Î³</mi> <mi>d</mi></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="gamma Start 2 By 2 Matrix 1st Row 1st Column a 2nd Column b 2nd
    Row 1st Column c 2nd Column d EndMatrix equals Start 2 By 2 Matrix 1st Row 1st
    Column gamma a 2nd Column gamma b 2nd Row 1st Column gamma c 2nd Column gamma
    d EndMatrix" display="block"><mrow><mi>Î³</mi> <mfenced close="]" open="["><mtable><mtr><mtd><mi>a</mi></mtd>
    <mtd><mi>b</mi></mtd></mtr> <mtr><mtd><mi>c</mi></mtd> <mtd><mi>d</mi></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mi>Î³</mi> <mi>a</mi></mrow></mtd>
    <mtd><mrow><mi>Î³</mi> <mi>b</mi></mrow></mtd></mtr> <mtr><mtd><mrow><mi>Î³</mi>
    <mi>c</mi></mrow></mtd> <mtd><mrow><mi>Î³</mi> <mi>d</mi></mrow></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'Likewise, Hadamard multiplication involves multiplying two matrices element-wise
    (hence the alternative terminology *element-wise multiplication*). Here is an
    example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: åŒæ ·ï¼ŒHadamard ä¹˜æ³•æ¶‰åŠå¯¹ä¸¤ä¸ªçŸ©é˜µè¿›è¡Œé€å…ƒç´ ä¹˜æ³•ï¼ˆå› æ­¤ä¹Ÿç§°ä¸º*é€å…ƒç´ ä¹˜æ³•*ï¼‰ã€‚è¿™é‡Œæœ‰ä¸€ä¸ªä¾‹å­ï¼š
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 2 2nd Column 3 2nd Row
    1st Column 4 2nd Column 5 EndMatrix circled-dot Start 2 By 2 Matrix 1st Row 1st
    Column a 2nd Column b 2nd Row 1st Column c 2nd Column d EndMatrix equals Start
    2 By 2 Matrix 1st Row 1st Column 2 a 2nd Column 3 b 2nd Row 1st Column 4 c 2nd
    Column 5 d EndMatrix" display="block"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mn>2</mn></mtd>
    <mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mn>4</mn></mtd> <mtd><mn>5</mn></mtd></mtr></mtable></mfenced>
    <mo>âŠ™</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mi>a</mi></mtd> <mtd><mi>b</mi></mtd></mtr>
    <mtr><mtd><mi>c</mi></mtd> <mtd><mi>d</mi></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mn>2</mn> <mi>a</mi></mrow></mtd>
    <mtd><mrow><mn>3</mn> <mi>b</mi></mrow></mtd></mtr> <mtr><mtd><mrow><mn>4</mn>
    <mi>c</mi></mrow></mtd> <mtd><mrow><mn>5</mn> <mi>d</mi></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 2 2nd Column 3 2nd Row
    1st Column 4 2nd Column 5 EndMatrix circled-dot Start 2 By 2 Matrix 1st Row 1st
    Column a 2nd Column b 2nd Row 1st Column c 2nd Column d EndMatrix equals Start
    2 By 2 Matrix 1st Row 1st Column 2 a 2nd Column 3 b 2nd Row 1st Column 4 c 2nd
    Column 5 d EndMatrix" display="block"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mn>2</mn></mtd>
    <mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mn>4</mn></mtd> <mtd><mn>5</mn></mtd></mtr></mtable></mfenced>
    <mo>âŠ™</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mi>a</mi></mtd> <mtd><mi>b</mi></mtd></mtr>
    <mtr><mtd><mi>c</mi></mtd> <mtd><mi>d</mi></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mn>2</mn> <mi>a</mi></mrow></mtd>
    <mtd><mrow><mn>3</mn> <mi>b</mi></mrow></mtd></mtr> <mtr><mtd><mrow><mn>4</mn>
    <mi>c</mi></mrow></mtd> <mtd><mrow><mn>5</mn> <mi>d</mi></mrow></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'In NumPy, Hadamard multiplication can be implemented using the `np.multiply()`
    function. But itâ€™s often easier to implement using an asterisk between the two
    matrices: `A*B`. This can cause some confusion, because standard matrix multiplication
    (next section) is indicated using an `@` symbol. Thatâ€™s a subtle but important
    difference! (This will be particularly confusing for readers coming to Python
    from MATLAB, where `*` indicates matrix multiplication.)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ NumPy ä¸­ï¼ŒHadamard ä¹˜æ³•å¯ä»¥ä½¿ç”¨ `np.multiply()` å‡½æ•°å®ç°ã€‚ä½†é€šå¸¸æ›´å®¹æ˜“ä½¿ç”¨ä¸¤ä¸ªçŸ©é˜µä¹‹é—´çš„æ˜Ÿå· `A*B` æ¥å®ç°ã€‚è¿™å¯èƒ½ä¼šå¼•èµ·ä¸€äº›æ··æ·†ï¼Œå› ä¸ºæ ‡å‡†çš„çŸ©é˜µä¹˜æ³•ï¼ˆä¸‹ä¸€èŠ‚ï¼‰ä½¿ç”¨
    `@` ç¬¦å·æ¥è¡¨ç¤ºã€‚è¿™æ˜¯ä¸€ä¸ªå¾®å¦™ä½†é‡è¦çš„åŒºåˆ«ï¼ï¼ˆè¿™å¯¹äºä» MATLAB è½¬åˆ° Python çš„è¯»è€…å°¤å…¶ä»¤äººå›°æƒ‘ï¼Œå› ä¸ºåœ¨ MATLAB ä¸­ï¼Œ`*` è¡¨ç¤ºçŸ©é˜µä¹˜æ³•ã€‚ï¼‰
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Hadamard multiplication does have some applications in linear algebra, for example,
    when computing the matrix inverse. However, it is most often used in applications
    as a convenient way to store many individual multiplications. Thatâ€™s similar to
    how vector Hadamard multiplication is often used, as discussed in [ChapterÂ 2](ch02.xhtml#Chapter_2).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Hadamardä¹˜æ³•åœ¨çº¿æ€§ä»£æ•°ä¸­ç¡®å®æœ‰ä¸€äº›åº”ç”¨ï¼Œä¾‹å¦‚åœ¨è®¡ç®—çŸ©é˜µé€†æ—¶ã€‚ä½†æ˜¯ï¼Œå®ƒæœ€å¸¸ç”¨äºåº”ç”¨ç¨‹åºä¸­ï¼Œä½œä¸ºå­˜å‚¨è®¸å¤šä¸ªä½“ä¹˜æ³•çš„ä¾¿æ·æ–¹å¼ã€‚è¿™ä¸å‘é‡Hadamardä¹˜æ³•çš„å¸¸è§ç”¨æ³•ç›¸ä¼¼ï¼Œæ­£å¦‚åœ¨[ç¬¬2ç« ](ch02.xhtml#Chapter_2)ä¸­è®¨è®ºçš„é‚£æ ·ã€‚
- en: Standard Matrix Multiplication
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ ‡å‡†çŸ©é˜µä¹˜æ³•
- en: Now we get to the unintuitive way to multiply matrices. To be clear, standard
    matrix multiplication is not particularly difficult; itâ€™s just different from
    what you might expect. Rather than operating element-wise, standard matrix multiplication
    operates row/column-wise. In fact, standard matrix multiplication reduces to a
    systematic collection of dot products between rows of one matrix and columns of
    the other matrix. (This form of multiplication is formally simply called *matrix
    multiplication*; Iâ€™ve added the term *standard* to help disambiguate from Hadamard
    and scalar multiplications.)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æ¥åˆ°äº†çŸ©é˜µä¹˜æ³•çš„ä¸ç›´è§‚æ–¹å¼ã€‚æ˜ç¡®åœ°è¯´ï¼Œæ ‡å‡†çŸ©é˜µä¹˜æ³•å¹¶ä¸ç‰¹åˆ«å›°éš¾ï¼›å®ƒåªæ˜¯ä¸ä½ å¯èƒ½æœŸæœ›çš„ä¸åŒã€‚ä¸å…¶æŒ‰å…ƒç´ æ“ä½œï¼Œæ ‡å‡†çŸ©é˜µä¹˜æ³•æ˜¯æŒ‰è¡Œ/åˆ—è¿›è¡Œæ“ä½œã€‚äº‹å®ä¸Šï¼Œæ ‡å‡†çŸ©é˜µä¹˜æ³•å¯ä»¥ç®€åŒ–ä¸ºä¸€ä¸ªçŸ©é˜µçš„è¡Œä¸å¦ä¸€ä¸ªçŸ©é˜µçš„åˆ—ä¹‹é—´çš„é€ç‚¹ä¹˜ç§¯çš„ç³»ç»Ÿæ”¶é›†ã€‚ï¼ˆè¿™ç§å½¢å¼çš„ä¹˜æ³•æ­£å¼ç§°ä¸º*çŸ©é˜µä¹˜æ³•*ï¼›æˆ‘æ·»åŠ äº†æœ¯è¯­*æ ‡å‡†*ä»¥å¸®åŠ©æ¶ˆé™¤ä¸Hadamardå’Œæ ‡é‡ä¹˜æ³•çš„æ­§ä¹‰ã€‚ï¼‰
- en: But before I get into the details of how to multiply two matrices, I will first
    explain how to determine whether two matrices can be multiplied. As youâ€™ll learn,
    two matrices can be multiplied only if their sizes are concordant.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†åœ¨æˆ‘è¯¦ç»†è®¨è®ºå¦‚ä½•å°†ä¸¤ä¸ªçŸ©é˜µç›¸ä¹˜ä¹‹å‰ï¼Œæˆ‘å°†é¦–å…ˆè§£é‡Šå¦‚ä½•ç¡®å®šä¸¤ä¸ªçŸ©é˜µæ˜¯å¦å¯ä»¥ç›¸ä¹˜ã€‚æ­£å¦‚ä½ å°†äº†è§£åˆ°çš„ï¼Œåªæœ‰å½“ä¸¤ä¸ªçŸ©é˜µçš„å¤§å°åè°ƒæ—¶ï¼Œå®ƒä»¬æ‰èƒ½ç›¸ä¹˜ã€‚
- en: Rules for Matrix Multiplication Validity
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: çŸ©é˜µä¹˜æ³•æœ‰æ•ˆæ€§è§„åˆ™
- en: You know that matrix sizes are written out as <math alttext="upper M times upper
    N"><mrow><mi>M</mi> <mo>Ã—</mo> <mi>N</mi></mrow></math> â€”rows by columns. Two
    matrices multiplying each other can have different sizes, so letâ€™s refer to the
    size of the second matrix as <math alttext="upper N times upper K"><mrow><mi>N</mi>
    <mo>Ã—</mo> <mi>K</mi></mrow></math> . When we write out the two multiplicand matrices
    with their sizes underneath, we can refer to the â€œinnerâ€ dimensions <math alttext="upper
    N"><mi>N</mi></math> and the â€œouterâ€ dimensions <math alttext="upper M"><mi>M</mi></math>
    and <math alttext="upper K"><mi>K</mi></math> .
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ çŸ¥é“çŸ©é˜µå¤§å°æ˜¯ä»¥<math alttext="ä¸ŠMä¹˜ä»¥ä¸ŠN"><mrow><mi>M</mi> <mo>Ã—</mo> <mi>N</mi></mrow></math>
    â€”è¡Œä¹˜åˆ—æ¥å†™å‡ºçš„ã€‚ä¸¤ä¸ªç›¸ä¹˜çš„çŸ©é˜µå¯ä»¥æœ‰ä¸åŒçš„å¤§å°ï¼Œå› æ­¤è®©æˆ‘ä»¬å°†ç¬¬äºŒä¸ªçŸ©é˜µçš„å¤§å°ç§°ä¸º<math alttext="ä¸ŠNä¹˜ä»¥ä¸ŠK"><mrow><mi>N</mi>
    <mo>Ã—</mo> <mi>K</mi></mrow></math> ã€‚å½“æˆ‘ä»¬å°†ä¸¤ä¸ªä¹˜æ•°çŸ©é˜µå†™å‡ºå¹¶åœ¨å…¶ä¸‹æ–¹å†™å‡ºå®ƒä»¬çš„å¤§å°æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥å¼•ç”¨â€œå†…â€ç»´åº¦<math
    alttext="ä¸ŠN"><mi>N</mi></math> å’Œâ€œå¤–â€ç»´åº¦<math alttext="ä¸ŠM"><mi>M</mi></math> å’Œ<math
    alttext="ä¸ŠK"><mi>K</mi></math> ã€‚
- en: 'Hereâ€™s the important point: *matrix multiplication is valid only when the â€œinnerâ€
    dimensions match, and the size of the product matrix is defined by the â€œouterâ€
    dimensions*. See [FigureÂ 5-3](#fig_5_3).'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œçš„é‡è¦ä¸€ç‚¹æ˜¯ï¼š*çŸ©é˜µä¹˜æ³•ä»…åœ¨â€œå†…â€ç»´åº¦åŒ¹é…ä¸”ä¹˜ç§¯çŸ©é˜µçš„å¤§å°ç”±â€œå¤–â€ç»´åº¦å®šä¹‰æ—¶æœ‰æ•ˆ*ã€‚å‚è§[å›¾5-3](#fig_5_3)ã€‚
- en: '![Visualization of matrix multiplication validity](assets/plad_0503.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![çŸ©é˜µä¹˜æ³•æœ‰æ•ˆæ€§çš„å¯è§†åŒ–](assets/plad_0503.png)'
- en: Figure 5-3\. Matrix multiplication validity, visualized. Memorize this picture.
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾5-3\. çŸ©é˜µä¹˜æ³•æœ‰æ•ˆæ€§çš„å¯è§†åŒ–ã€‚è®°ä½è¿™å¼ å›¾ç‰‡ã€‚
- en: More formally, matrix multiplication is valid when the number of columns in
    the left matrix equals the number of rows in the right matrix, and the size of
    the product matrix is defined by the number of rows in the left matrix and the
    number of columns in the right matrix. I find the â€œinner/outerâ€ rubric easier
    to remember.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: æ›´æ­£å¼åœ°è¯´ï¼ŒçŸ©é˜µä¹˜æ³•åœ¨å·¦çŸ©é˜µçš„åˆ—æ•°ç­‰äºå³çŸ©é˜µçš„è¡Œæ•°æ—¶æœ‰æ•ˆï¼Œä¹˜ç§¯çŸ©é˜µçš„å¤§å°ç”±å·¦çŸ©é˜µçš„è¡Œæ•°å’Œå³çŸ©é˜µçš„åˆ—æ•°å®šä¹‰ã€‚æˆ‘è§‰å¾—â€œå†…/å¤–â€å‡†åˆ™æ›´å®¹æ˜“è®°ä½ã€‚
- en: 'You can already see that matrix multiplication does not obey the commutative
    law: <math alttext="bold upper A bold upper B"><mrow><mi>ğ€</mi> <mi>ğ</mi></mrow></math>
    may be valid while <math alttext="bold upper B bold upper A"><mrow><mi>ğ</mi>
    <mi>ğ€</mi></mrow></math> is invalid. Even if both multiplications are valid (for
    example, if both matrices are square), they may produce different results. That
    is, if <math alttext="bold upper C bold equals bold upper A bold upper B"><mrow><mi>ğ‚</mi>
    <mo>=</mo> <mi>ğ€</mi> <mi>ğ</mi></mrow></math> and <math alttext="bold upper D
    bold equals bold upper B bold upper A"><mrow><mi>ğƒ</mi> <mo>=</mo> <mi>ğ</mi>
    <mi>ğ€</mi></mrow></math> , then in general <math alttext="bold upper C not-equals
    bold upper D"><mrow><mi>ğ‚</mi> <mo>â‰ </mo> <mi>ğƒ</mi></mrow></math> (they are equal
    in some special cases, but we cannot generally assume equality).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: æ‚¨å·²ç»å¯ä»¥çœ‹åˆ°çŸ©é˜µä¹˜æ³•ä¸éµå®ˆäº¤æ¢å¾‹ï¼š <math alttext="bold upper A bold upper B"><mrow><mi>ğ€</mi>
    <mi>ğ</mi></mrow></math> å¯èƒ½æœ‰æ•ˆï¼Œè€Œ <math alttext="bold upper B bold upper A"><mrow><mi>ğ</mi>
    <mi>ğ€</mi></mrow></math> åˆ™æ— æ•ˆã€‚å³ä½¿ä¸¤ç§ä¹˜æ³•éƒ½æœ‰æ•ˆï¼ˆä¾‹å¦‚ï¼Œå¦‚æœä¸¤ä¸ªçŸ©é˜µéƒ½æ˜¯æ–¹é˜µï¼‰ï¼Œå®ƒä»¬å¯èƒ½äº§ç”Ÿä¸åŒçš„ç»“æœã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœ <math
    alttext="bold upper C bold equals bold upper A bold upper B"><mrow><mi>ğ‚</mi>
    <mo>=</mo> <mi>ğ€</mi> <mi>ğ</mi></mrow></math> å’Œ <math alttext="bold upper D bold
    equals bold upper B bold upper A"><mrow><mi>ğƒ</mi> <mo>=</mo> <mi>ğ</mi> <mi>ğ€</mi></mrow></math>
    ï¼Œé‚£ä¹ˆä¸€èˆ¬æƒ…å†µä¸‹ <math alttext="bold upper C not-equals bold upper D"><mrow><mi>ğ‚</mi>
    <mo>â‰ </mo> <mi>ğƒ</mi></mrow></math> ï¼ˆå®ƒä»¬åœ¨æŸäº›ç‰¹æ®Šæƒ…å†µä¸‹ç›¸ç­‰ï¼Œä½†æˆ‘ä»¬ä¸èƒ½ä¸€èˆ¬æ€§åœ°å‡è®¾å®ƒä»¬ç›¸ç­‰ï¼‰ã€‚
- en: 'Note the notation: Hadamard multiplication is indicated using a dotted-circle
    ( <math alttext="bold upper A circled-dot bold upper B"><mrow><mi>ğ€</mi> <mo>âŠ™</mo>
    <mi>ğ</mi></mrow></math> ) whereas matrix multiplication is indicated as two matrices
    side-by-side without any symbol between them ( <math alttext="bold upper A bold
    upper B"><mrow><mi>ğ€</mi> <mi>ğ</mi></mrow></math> ).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·æ³¨æ„æ ‡è®°ï¼šHadamardä¹˜æ³•ä½¿ç”¨ç‚¹åœˆç¤ºï¼ˆ <math alttext="bold upper A circled-dot bold upper B"><mrow><mi>ğ€</mi>
    <mo>âŠ™</mo> <mi>ğ</mi></mrow></math> ï¼‰ï¼Œè€ŒçŸ©é˜µä¹˜æ³•åˆ™è¡¨ç¤ºä¸ºä¸¤ä¸ªçŸ©é˜µå¹¶æ’æ”¾ç½®ï¼Œä¸­é—´æ²¡æœ‰ä»»ä½•ç¬¦å·ï¼ˆ <math alttext="bold
    upper A bold upper B"><mrow><mi>ğ€</mi> <mi>ğ</mi></mrow></math> ï¼‰ã€‚
- en: Now itâ€™s time to learn about the mechanics and interpretation of matrix multiplication.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æ˜¯å­¦ä¹ çŸ©é˜µä¹˜æ³•çš„æœºåˆ¶å’Œè§£é‡Šçš„æ—¶å€™äº†ã€‚
- en: Matrix Multiplication
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: çŸ©é˜µä¹˜æ³•
- en: The reason why matrix multiplication is valid only if the number of columns
    in the left matrix matches the number of rows in the right matrix is that the
    (*i,j*)th element in the product matrix is the dot product between the *i*th row
    of the left matrix and the *j*th column in the right matrix.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: çŸ©é˜µä¹˜æ³•ä»…åœ¨å·¦çŸ©é˜µçš„åˆ—æ•°ä¸å³çŸ©é˜µçš„è¡Œæ•°ç›¸åŒ¹é…æ—¶æ‰æœ‰æ•ˆï¼Œè¿™æ˜¯å› ä¸ºä¹˜ç§¯çŸ©é˜µä¸­çš„ï¼ˆ*i,j*ï¼‰å…ƒç´ æ˜¯å·¦çŸ©é˜µç¬¬*i*è¡Œä¸å³çŸ©é˜µç¬¬*j*åˆ—çš„ç‚¹ç§¯ã€‚
- en: '[Equation 5-1](#matrixmult) shows an example of matrix multiplication, using
    the same two matrices that we used for Hadamard multiplication. Make sure you
    understand how each element in the product matrix is computed as dot products
    of corresponding rows and columns of the left-hand side matrices.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[æ–¹ç¨‹å¼ 5-1](#matrixmult) å±•ç¤ºäº†çŸ©é˜µä¹˜æ³•çš„ç¤ºä¾‹ï¼Œä½¿ç”¨äº†ä¸Hadamardä¹˜æ³•ç›¸åŒçš„ä¸¤ä¸ªçŸ©é˜µã€‚ç¡®ä¿ç†è§£ä¹˜ç§¯çŸ©é˜µä¸­æ¯ä¸ªå…ƒç´ å¦‚ä½•è®¡ç®—ä¸ºå·¦ä¾§çŸ©é˜µçš„ç›¸åº”è¡Œå’Œå³ä¾§çŸ©é˜µçš„åˆ—çš„ç‚¹ç§¯ã€‚'
- en: Equation 5-1\. Example of matrix multiplication. Parentheses added to facilitate
    visual grouping.
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: æ–¹ç¨‹å¼ 5-1\. çŸ©é˜µä¹˜æ³•çš„ç¤ºä¾‹ã€‚æ·»åŠ æ‹¬å·ä»¥æ–¹ä¾¿è§†è§‰åˆ†ç»„ã€‚
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 2 2nd Column 3 2nd Row
    1st Column 4 2nd Column 5 EndMatrix Start 2 By 2 Matrix 1st Row 1st Column a 2nd
    Column b 2nd Row 1st Column c 2nd Column d EndMatrix equals Start 2 By 2 Matrix
    1st Row 1st Column left-parenthesis 2 a plus 3 c right-parenthesis 2nd Column
    left-parenthesis 2 b plus 3 d right-parenthesis 2nd Row 1st Column left-parenthesis
    4 a plus 5 c right-parenthesis 2nd Column left-parenthesis 4 b plus 5 d right-parenthesis
    EndMatrix" display="block"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mn>2</mn></mtd>
    <mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mn>4</mn></mtd> <mtd><mn>5</mn></mtd></mtr></mtable></mfenced>
    <mfenced close="]" open="["><mtable><mtr><mtd><mi>a</mi></mtd> <mtd><mi>b</mi></mtd></mtr>
    <mtr><mtd><mi>c</mi></mtd> <mtd><mi>d</mi></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mo>(</mo> <mn>2</mn> <mi>a</mi>
    <mo>+</mo> <mn>3</mn> <mi>c</mi> <mo>)</mo></mrow></mtd> <mtd><mrow><mo>(</mo>
    <mn>2</mn> <mi>b</mi> <mo>+</mo> <mn>3</mn> <mi>d</mi> <mo>)</mo></mrow></mtd></mtr>
    <mtr><mtd><mrow><mo>(</mo> <mn>4</mn> <mi>a</mi> <mo>+</mo> <mn>5</mn> <mi>c</mi>
    <mo>)</mo></mrow></mtd> <mtd><mrow><mo>(</mo> <mn>4</mn> <mi>b</mi> <mo>+</mo>
    <mn>5</mn> <mi>d</mi> <mo>)</mo></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 2 2nd Column 3 2nd Row
    1st Column 4 2nd Column 5 EndMatrix Start 2 By 2 Matrix 1st Row 1st Column a 2nd
    Column b 2nd Row 1st Column c 2nd Column d EndMatrix equals Start 2 By 2 Matrix
    1st Row 1st Column left-parenthesis 2 a plus 3 c right-parenthesis 2nd Column
    left-parenthesis 2 b plus 3 d right-parenthesis 2nd Row 1st Column left-parenthesis
    4 a plus 5 c right-parenthesis 2nd Column left-parenthesis 4 b plus 5 d right-parenthesis
    EndMatrix" display="block"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mn>2</mn></mtd>
    <mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mn>4</mn></mtd> <mtd><mn>5</mn></mtd></mtr></mtable></mfenced>
    <mfenced close="]" open="["><mtable><mtr><mtd><mi>a</mi></mtd> <mtd><mi>b</mi></mtd></mtr>
    <mtr><mtd><mi>c</mi></mtd> <mtd><mi>d</mi></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mo>(</mo> <mn>2</mn> <mi>a</mi>
    <mo>+</mo> <mn>3</mn> <mi>c</mi> <mo>)</mo></mrow></mtd> <mtd><mrow><mo>(</mo>
    <mn>2</mn> <mi>b</mi> <mo>+</mo> <mn>3</mn> <mi>d</mi> <mo>)</mo></mrow></mtd></mtr>
    <mtr><mtd><mrow><mo>(</mo> <mn>4</mn> <mi>a</mi> <mo>+</mo> <mn>5</mn> <mi>c</mi>
    <mo>)</mo></mrow></mtd> <mtd><mrow><mo>(</mo> <mn>4</mn> <mi>b</mi> <mo>+</mo>
    <mn>5</mn> <mi>d</mi> <mo>)</mo></mrow></mtd></mtr></mtable></mfenced></mrow></math>
- en: If you are struggling to remember how matrix multiplication works, [FigureÂ 5-4](#fig_5_4)
    shows a mnemonic trick for drawing out the multiplication with your fingers.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæ‚¨éš¾ä»¥è®°ä½çŸ©é˜µä¹˜æ³•çš„å·¥ä½œåŸç†ï¼Œ[å›¾ 5-4](#fig_5_4) æ˜¾ç¤ºäº†ä¸€ç§ç”¨æ‰‹æŒ‡ç”»å‡ºä¹˜æ³•çš„åŠ©è®°æŠ€å·§ã€‚
- en: '![Fingers for matrix multiplication](assets/plad_0504.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![çŸ©é˜µä¹˜æ³•çš„æ‰‹æŒ‡ç¤ºæ„å›¾](assets/plad_0504.png)'
- en: Figure 5-4\. Finger movements for matrix multiplication
  id: totrans-88
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾ 5-4\. çŸ©é˜µä¹˜æ³•çš„æ‰‹æŒ‡åŠ¨ä½œ
- en: How do you interpret matrix multiplication? Remember that the dot product is
    a number that encodes the relationship between two vectors. So, the result of
    matrix multiplication is a matrix that stores all the pairwise linear relationships
    between rows of the left matrix and columns of the right matrix. That is a beautiful
    thing, and is the basis for computing covariance and correlation matrices, the
    general linear model (used in statistics analyses including ANOVAs and regressions),
    singular-value decomposition, and countless other applications.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: æ‚¨å¦‚ä½•è§£é‡ŠçŸ©é˜µä¹˜æ³•ï¼Ÿè¯·è®°ä½ï¼Œç‚¹ç§¯æ˜¯ç¼–ç ä¸¤ä¸ªå‘é‡ä¹‹é—´å…³ç³»çš„æ•°å­—ã€‚å› æ­¤ï¼ŒçŸ©é˜µä¹˜æ³•çš„ç»“æœæ˜¯ä¸€ä¸ªçŸ©é˜µï¼Œå­˜å‚¨äº†å·¦çŸ©é˜µè¡Œä¸å³çŸ©é˜µåˆ—ä¹‹é—´çš„æ‰€æœ‰æˆå¯¹çº¿æ€§å…³ç³»ã€‚è¿™æ˜¯ä¸€ä»¶ç¾å¦™çš„äº‹æƒ…ï¼Œå¹¶ä¸”æ˜¯è®¡ç®—åæ–¹å·®å’Œç›¸å…³çŸ©é˜µã€ä¸€èˆ¬çº¿æ€§æ¨¡å‹ï¼ˆç”¨äºåŒ…æ‹¬ANOVAå’Œå›å½’åœ¨å†…çš„ç»Ÿè®¡åˆ†æï¼‰ä»¥åŠæ— æ•°å…¶ä»–åº”ç”¨çš„åŸºç¡€ã€‚
- en: Matrix-Vector Multiplication
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: çŸ©é˜µ-å‘é‡ä¹˜æ³•
- en: 'In a purely mechanical sense, matrix-vector multiplication is nothing special
    and does not deserve its own subsection: mutliplying a matrix and a vector is
    simply matrix multiplication where one â€œmatrixâ€ is a vector.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ä»çº¯æœºæ¢°è§’åº¦æ¥çœ‹ï¼ŒçŸ©é˜µå‘é‡ä¹˜æ³•å¹¶ä¸ç‰¹åˆ«ï¼Œä¸å€¼å¾—ä¸“é—¨å¼€è¾Ÿå°èŠ‚æ¥è®¨è®ºï¼šçŸ©é˜µå’Œå‘é‡çš„ä¹˜æ³•å°±æ˜¯ä¸€ä¸ªâ€œçŸ©é˜µâ€æ˜¯å‘é‡çš„çŸ©é˜µä¹˜æ³•ã€‚
- en: 'But matrix-vector multiplication does have many applications in data science,
    machine learning, and computer graphics, so itâ€™s worth spending some time on.
    Letâ€™s start with the basics:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†æ˜¯çŸ©é˜µå‘é‡ä¹˜æ³•åœ¨æ•°æ®ç§‘å­¦ã€æœºå™¨å­¦ä¹ å’Œè®¡ç®—æœºå›¾å½¢å­¦ä¸­æœ‰è®¸å¤šåº”ç”¨ï¼Œå› æ­¤å€¼å¾—èŠ±ä¸€äº›æ—¶é—´è®¨è®ºã€‚è®©æˆ‘ä»¬ä»åŸºç¡€å¼€å§‹ï¼š
- en: A matrix can be right-multiplied by a column vector but not a row vector, and
    it can be left-multiplied by a row vector but not a column vector. In other words,
    <math alttext="bold upper A bold v"><mrow><mi>ğ€</mi> <mi>ğ¯</mi></mrow></math>
    and <math alttext="bold v Superscript upper T Baseline bold upper A"><mrow><msup><mi>ğ¯</mi>
    <mtext>T</mtext></msup> <mi>ğ€</mi></mrow></math> are valid, but <math alttext="bold
    upper A bold v Superscript upper T"><mrow><mi>ğ€</mi> <msup><mi>ğ¯</mi> <mtext>T</mtext></msup></mrow></math>
    and <math alttext="bold v bold upper A"><mrow><mi>ğ¯</mi> <mi>ğ€</mi></mrow></math>
    are invalid.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªçŸ©é˜µå¯ä»¥å³ä¹˜ä¸€ä¸ªåˆ—å‘é‡ï¼Œä½†ä¸èƒ½å³ä¹˜ä¸€ä¸ªè¡Œå‘é‡ï¼Œä¹Ÿå¯ä»¥å·¦ä¹˜ä¸€ä¸ªè¡Œå‘é‡ï¼Œä½†ä¸èƒ½å·¦ä¹˜ä¸€ä¸ªåˆ—å‘é‡ã€‚æ¢å¥è¯è¯´ï¼Œ<math alttext="bold upper
    A bold v"><mrow><mi>ğ€</mi> <mi>ğ¯</mi></mrow></math>å’Œ<math alttext="bold v Superscript
    upper T Baseline bold upper A"><mrow><msup><mi>ğ¯</mi> <mtext>T</mtext></msup>
    <mi>ğ€</mi></mrow></math>æ˜¯æœ‰æ•ˆçš„ï¼Œä½†<math alttext="bold upper A bold v Superscript upper
    T"><mrow><mi>ğ€</mi> <msup><mi>ğ¯</mi> <mtext>T</mtext></msup></mrow></math>å’Œ<math
    alttext="bold v bold upper A"><mrow><mi>ğ¯</mi> <mi>ğ€</mi></mrow></math>æ˜¯æ— æ•ˆçš„ã€‚
- en: 'That is clear from inspecting matrix sizes: an <math alttext="upper M times
    upper N"><mrow><mi>M</mi> <mo>Ã—</mo> <mi>N</mi></mrow></math> matrix can be premultiplied
    by a <math alttext="1 times upper M"><mrow><mn>1</mn> <mo>Ã—</mo> <mi>M</mi></mrow></math>
    matrix (a.k.a. a row vector) or postmultiplied by an <math alttext="upper N times
    1"><mrow><mi>N</mi> <mo>Ã—</mo> <mn>1</mn></mrow></math> matrix (a.k.a. a column
    vector).'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ä»æ£€æŸ¥çŸ©é˜µå°ºå¯¸ä¸­å¯ä»¥çœ‹å‡ºï¼šä¸€ä¸ª<math alttext="upper M times upper N"><mrow><mi>M</mi> <mo>Ã—</mo>
    <mi>N</mi></mrow></math>çŸ©é˜µå¯ä»¥é€šè¿‡ä¸€ä¸ª<math alttext="1 times upper M"><mrow><mn>1</mn>
    <mo>Ã—</mo> <mi>M</mi></mrow></math>çŸ©é˜µï¼ˆä¹Ÿç§°ä¸ºè¡Œå‘é‡ï¼‰å·¦ä¹˜ï¼Œæˆ–é€šè¿‡ä¸€ä¸ª<math alttext="upper N times
    1"><mrow><mi>N</mi> <mo>Ã—</mo> <mn>1</mn></mrow></math>çŸ©é˜µï¼ˆä¹Ÿç§°ä¸ºåˆ—å‘é‡ï¼‰å³ä¹˜ã€‚
- en: 'The result of matrix-vector multiplication is always a vector, and the orientation
    of that vector depends on the orientation of the multiplicand vector: premultiplying
    a matrix by a row vector produces another row vector, while postmultiplying a
    matrix by a column vector produces another column vector. Again, this is obvious
    when you think about matrix sizes, but itâ€™s worth pointing out.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: çŸ©é˜µå‘é‡ä¹˜æ³•çš„ç»“æœæ€»æ˜¯ä¸€ä¸ªå‘é‡ï¼Œè¯¥å‘é‡çš„æ–¹å‘å–å†³äºä¹˜æ³•çš„å‘é‡ï¼šé€šè¿‡è¡Œå‘é‡å·¦ä¹˜ä¸€ä¸ªçŸ©é˜µäº§ç”Ÿå¦ä¸€ä¸ªè¡Œå‘é‡ï¼Œè€Œé€šè¿‡åˆ—å‘é‡å³ä¹˜ä¸€ä¸ªçŸ©é˜µäº§ç”Ÿå¦ä¸€ä¸ªåˆ—å‘é‡ã€‚å†æ¬¡å¼ºè°ƒï¼Œå½“ä½ è€ƒè™‘çŸ©é˜µå°ºå¯¸æ—¶è¿™æ˜¯æ˜¾è€Œæ˜“è§çš„ï¼Œä½†å€¼å¾—æŒ‡å‡ºçš„ã€‚
- en: Matrix-vector multiplication has several applications. In statistics, the model-predicted
    data values are obtained by multiplying the design matrix by the regression coefficients,
    which is written out as <math alttext="bold upper X beta"><mrow><mi mathvariant="bold">X</mi>
    <mi mathvariant="bold">Î²</mi></mrow></math> . In principal components analysis,
    a vector of â€œfeature-importanceâ€ weights is identified that maximizes variance
    in dataset <math alttext="bold upper Y"><mi>ğ˜</mi></math> , and is written out
    as <math alttext="left-parenthesis bold upper Y Superscript upper T Baseline bold
    upper Y right-parenthesis bold v"><mrow><mo>(</mo> <msup><mi>ğ˜</mi> <mtext>T</mtext></msup>
    <mi>ğ˜</mi> <mo>)</mo> <mi>ğ¯</mi></mrow></math> (that feature-importance vector
    <math alttext="bold v"><mi>ğ¯</mi></math> is called an eigenvector). In multivariate
    signal processing, a reduced-dimensional component is obtained by applying a spatial
    filter to multichannel time series data <math alttext="bold upper S"><mi>ğ’</mi></math>
    , and is written out as <math alttext="bold w Superscript upper T Baseline bold
    upper S"><mrow><msup><mi>ğ°</mi> <mtext>T</mtext></msup> <mi>ğ’</mi></mrow></math>
    . In geometry and computer graphics, a set of image coordinates can be transformed
    using a mathematical transformation matrix, and is written out as <math alttext="bold
    upper T bold p"><mrow><mi>ğ“</mi> <mi>ğ©</mi></mrow></math> , where <math alttext="bold
    upper T"><mi>ğ“</mi></math> is the transformation matrix and <math alttext="bold
    p"><mi>ğ©</mi></math> is the set of geometric coordinates.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: çŸ©é˜µ-å‘é‡ä¹˜æ³•æœ‰å‡ ä¸ªåº”ç”¨ã€‚åœ¨ç»Ÿè®¡å­¦ä¸­ï¼Œé€šè¿‡å°†è®¾è®¡çŸ©é˜µä¹˜ä»¥å›å½’ç³»æ•°æ¥è·å¾—æ¨¡å‹é¢„æµ‹çš„æ•°æ®å€¼ï¼Œå†™ä¸º <math alttext="bold upper X beta"><mrow><mi
    mathvariant="bold">X</mi> <mi mathvariant="bold">Î²</mi></mrow></math> ã€‚åœ¨ä¸»æˆåˆ†åˆ†æä¸­ï¼Œç¡®å®šäº†ä¸€ç»„â€œç‰¹å¾é‡è¦æ€§â€æƒé‡å‘é‡ï¼Œç”¨äºæœ€å¤§åŒ–æ•°æ®é›†
    <math alttext="bold upper Y"><mi>ğ˜</mi></math> çš„æ–¹å·®ï¼Œå¹¶å†™ä¸º <math alttext="left-parenthesis
    bold upper Y Superscript upper T Baseline bold upper Y right-parenthesis bold
    v"><mrow><mo>(</mo> <msup><mi>ğ˜</mi> <mtext>T</mtext></msup> <mi>ğ˜</mi> <mo>)</mo>
    <mi>ğ¯</mi></mrow></math> ï¼ˆè¯¥ç‰¹å¾é‡è¦æ€§å‘é‡ <math alttext="bold v"><mi>ğ¯</mi></math> è¢«ç§°ä¸ºç‰¹å¾å‘é‡ï¼‰ã€‚åœ¨å¤šå˜é‡ä¿¡å·å¤„ç†ä¸­ï¼Œé€šè¿‡å°†ç©ºé—´æ»¤æ³¢å™¨åº”ç”¨äºå¤šé€šé“æ—¶é—´åºåˆ—æ•°æ®
    <math alttext="bold upper S"><mi>ğ’</mi></math> ï¼Œè·å¾—äº†ä¸€ä¸ªé™ç»´çš„ç»„ä»¶ï¼Œå¹¶å†™ä¸º <math alttext="bold
    w Superscript upper T Baseline bold upper S"><mrow><msup><mi>ğ°</mi> <mtext>T</mtext></msup>
    <mi>ğ’</mi></mrow></math> ã€‚åœ¨å‡ ä½•å­¦å’Œè®¡ç®—æœºå›¾å½¢å­¦ä¸­ï¼Œå¯ä»¥ä½¿ç”¨æ•°å­¦å˜æ¢çŸ©é˜µæ¥å˜æ¢ä¸€ç»„å›¾åƒåæ ‡ï¼Œå¹¶å†™ä¸º <math alttext="bold
    upper T bold p"><mrow><mi>ğ“</mi> <mi>ğ©</mi></mrow></math> ï¼Œå…¶ä¸­ <math alttext="bold
    upper T"><mi>ğ“</mi></math> æ˜¯å˜æ¢çŸ©é˜µï¼Œ<math alttext="bold p"><mi>ğ©</mi></math> æ˜¯å‡ ä½•åæ ‡é›†ã€‚
- en: There are so many more examples of how matrix-vector multiplication is used
    in applied linear algebra, and you will see several of these examples later in
    the book. Matrix-vector multiplication is also the basis for matrix spaces, which
    is an important topic that youâ€™ll learn about later in the next chapter.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: è¿˜æœ‰å¾ˆå¤šå…³äºå¦‚ä½•åœ¨åº”ç”¨çº¿æ€§ä»£æ•°ä¸­ä½¿ç”¨çŸ©é˜µ-å‘é‡ä¹˜æ³•çš„ä¾‹å­ï¼Œä½ å°†åœ¨æœ¬ä¹¦çš„åé¢çœ‹åˆ°å…¶ä¸­çš„å‡ ä¸ªã€‚çŸ©é˜µ-å‘é‡ä¹˜æ³•ä¹Ÿæ˜¯çŸ©é˜µç©ºé—´çš„åŸºç¡€ï¼Œè¿™æ˜¯ä½ å°†åœ¨ä¸‹ä¸€ç« ä¸­å­¦ä¹ çš„é‡è¦ä¸»é¢˜ã€‚
- en: 'For now, I want to focus on two specific interpretations of matrix-vector multiplication:
    as a means to implement linear weighted combinations of vectors, and as the mechanism
    of implementing geometric transformations.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæˆ‘æƒ³é›†ä¸­è®¨è®ºçŸ©é˜µ-å‘é‡ä¹˜æ³•çš„ä¸¤ç§å…·ä½“è§£é‡Šï¼šä½œä¸ºå®ç°å‘é‡çš„çº¿æ€§åŠ æƒç»„åˆçš„æ–¹æ³•ï¼Œä»¥åŠä½œä¸ºå®ç°å‡ ä½•å˜æ¢çš„æœºåˆ¶ã€‚
- en: Linear weighted combinations
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: çº¿æ€§åŠ æƒç»„åˆ
- en: 'In the previous chapter, we calculated linear weighted combinations by having
    separate scalars and vectors, and then multiplying them individually. But you
    are now smarter than when you started the previous chapter, and so you are now
    ready to learn a better, more compact, and more scalable method for computing
    linear weighted combinations: put the individual vectors into a matrix, and put
    the weights into corresponding elements of a vector. Then multiply. Hereâ€™s a numerical
    example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å‰ä¸€ç« ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡åˆ†åˆ«ä½¿ç”¨æ ‡é‡å’Œå‘é‡è¿›è¡Œçº¿æ€§åŠ æƒç»„åˆçš„è®¡ç®—ï¼Œç„¶åé€ä¸ªè¿›è¡Œä¹˜æ³•ã€‚ä½†æ˜¯ç°åœ¨ä½ æ¯”å‰ä¸€ç« å¼€å§‹æ—¶èªæ˜å¤šäº†ï¼Œæ‰€ä»¥ä½ ç°åœ¨å‡†å¤‡å­¦ä¹ ä¸€ç§æ›´å¥½ã€æ›´ç´§å‡‘å’Œæ›´å¯æ‰©å±•çš„è®¡ç®—çº¿æ€§åŠ æƒç»„åˆçš„æ–¹æ³•ï¼šå°†å•ç‹¬çš„å‘é‡æ”¾å…¥çŸ©é˜µä¸­ï¼Œå¹¶å°†æƒé‡æ”¾å…¥å‘é‡çš„ç›¸åº”å…ƒç´ ä¸­ã€‚ç„¶åç›¸ä¹˜ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªæ•°å€¼ç¤ºä¾‹ï¼š
- en: <math alttext="4 Start 3 By 1 Matrix 1st Row  3 2nd Row  0 3rd Row  6 EndMatrix
    plus 3 Start 3 By 1 Matrix 1st Row  1 2nd Row  2 3rd Row  5 EndMatrix right double
    arrow Start 3 By 2 Matrix 1st Row 1st Column 3 2nd Column 1 2nd Row 1st Column
    0 2nd Column 2 3rd Row 1st Column 6 2nd Column 5 EndMatrix StartBinomialOrMatrix
    4 Choose 3 EndBinomialOrMatrix" display="block"><mrow><mn>4</mn> <mfenced close="]"
    open="["><mtable><mtr><mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>6</mn></mtd></mtr></mtable></mfenced> <mo>+</mo> <mn>3</mn> <mfenced
    close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mn>5</mn></mtd></mtr></mtable></mfenced> <mo>â‡’</mo> <mfenced close="]"
    open="["><mtable><mtr><mtd><mn>3</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>6</mn></mtd> <mtd><mn>5</mn></mtd></mtr></mtable></mfenced>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mn>3</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="4 Start 3 By 1 Matrix 1st Row  3 2nd Row  0 3rd Row  6 EndMatrix
    plus 3 Start 3 By 1 Matrix 1st Row  1 2nd Row  2 3rd Row  5 EndMatrix right double
    arrow Start 3 By 2 Matrix 1st Row 1st Column 3 2nd Column 1 2nd Row 1st Column
    0 2nd Column 2 3rd Row 1st Column 6 2nd Column 5 EndMatrix StartBinomialOrMatrix
    4 Choose 3 EndBinomialOrMatrix" display="block"><mrow><mn>4</mn> <mfenced close="]"
    open="["><mtable><mtr><mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>6</mn></mtd></mtr></mtable></mfenced> <mo>+</mo> <mn>3</mn> <mfenced
    close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mn>5</mn></mtd></mtr></mtable></mfenced> <mo>â‡’</mo> <mfenced close="]"
    open="["><mtable><mtr><mtd><mn>3</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>6</mn></mtd> <mtd><mn>5</mn></mtd></mtr></mtable></mfenced>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mn>3</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: Please take a moment to work through the multiplication, and make sure you understand
    how the linear weighted combination of the two vectors can be implemented as a
    matrix-vector multiplication. The key insight is that each element in the vector
    scalar multiplies the corresponding column in the matrix, and then the weighted
    column vectors are summed to obtain the product.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·èŠ±ç‚¹æ—¶é—´é€šè¿‡ä¹˜æ³•æ¥ç†è§£å¦‚ä½•å°†ä¸¤ä¸ªå‘é‡çš„çº¿æ€§åŠ æƒç»„åˆå®ç°ä¸ºçŸ©é˜µ-å‘é‡ä¹˜æ³•ã€‚å…³é”®çš„æ´å¯ŸåŠ›åœ¨äºå‘é‡ä¸­çš„æ¯ä¸ªå…ƒç´ æ ‡é‡ä¹˜ä»¥ç›¸åº”çš„åˆ—çŸ©é˜µï¼Œç„¶ååŠ æƒåˆ—å‘é‡æ±‚å’Œä»¥å¾—åˆ°ä¹˜ç§¯ã€‚
- en: This example involved linear weighted combinations of column vectors; what would
    you change to compute linear weighted combinations of row vectors?^([2](ch05.xhtml#idm45733309424816))
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªä¾‹å­æ¶‰åŠåˆ°åˆ—å‘é‡çš„çº¿æ€§åŠ æƒç»„åˆï¼›å¦‚æœè¦è®¡ç®—è¡Œå‘é‡çš„çº¿æ€§åŠ æƒç»„åˆï¼Œä½ ä¼šæ”¹å˜ä»€ä¹ˆï¼Ÿ^([2](ch05.xhtml#idm45733309424816))
- en: Geometric transforms
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: å‡ ä½•å˜æ¢
- en: When we think of a vector as a geometric line, then matrix-vector multiplication
    becomes a way of rotating and scaling that vector (remember that scalar-vector
    multiplication can scale but not rotate).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æˆ‘ä»¬å°†å‘é‡çœ‹ä½œå‡ ä½•çº¿æ—¶ï¼ŒçŸ©é˜µå‘é‡ä¹˜æ³•æˆä¸ºæ—‹è½¬å’Œç¼©æ”¾è¯¥å‘é‡çš„ä¸€ç§æ–¹æ³•ï¼ˆè®°ä½ï¼Œæ ‡é‡å‘é‡ä¹˜æ³•å¯ä»¥ç¼©æ”¾ä½†ä¸èƒ½æ—‹è½¬ï¼‰ã€‚
- en: 'Letâ€™s start with a 2D case for easy visualization. Here are our matrix and
    vectors:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ä» 2D æƒ…å†µå¼€å§‹ï¼Œæ–¹ä¾¿å¯è§†åŒ–ã€‚è¿™é‡Œæ˜¯æˆ‘ä»¬çš„çŸ©é˜µå’Œå‘é‡ï¼š
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice that I created `x` as a row vector and then transposed it into a column
    vector; that reduced the number of square brackets to type.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæˆ‘åˆ›å»ºäº† `x` ä½œä¸ºè¡Œå‘é‡ï¼Œç„¶åå°†å…¶è½¬ç½®ä¸ºåˆ—å‘é‡ï¼›è¿™å‡å°‘äº†éœ€è¦è¾“å…¥çš„æ–¹æ‹¬å·æ•°é‡ã€‚
- en: Graph A in [FigureÂ 5-5](#fig_5_5) visualizes these two vectors. You can see
    that the matrix <math alttext="bold upper M"><mi>ğŒ</mi></math> both rotated and
    stretched the original vector. Letâ€™s try a different vector with the same matrix.
    Actually, just for fun, letâ€™s use the same vector elements but with swapped positions
    (thus, vector `v = [1.5,1]`).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ A åœ¨ [å›¾ 5-5](#fig_5_5) ä¸­å±•ç¤ºäº†è¿™ä¸¤ä¸ªå‘é‡ã€‚ä½ å¯ä»¥çœ‹åˆ°çŸ©é˜µ <math alttext="bold upper M"><mi>ğŒ</mi></math>
    åŒæ—¶æ—‹è½¬å’Œæ‹‰ä¼¸äº†åŸå§‹å‘é‡ã€‚è®©æˆ‘ä»¬å°è¯•ç”¨åŒä¸€çŸ©é˜µæ¥è®¡ç®—å¦ä¸€ä¸ªå‘é‡ã€‚äº‹å®ä¸Šï¼Œåªæ˜¯ä¸ºäº†å¥½ç©ï¼Œè®©æˆ‘ä»¬ä½¿ç”¨åŒæ ·çš„å‘é‡å…ƒç´ ï¼Œä½†ä½ç½®äº’æ¢ï¼ˆå› æ­¤ï¼Œå‘é‡ `v = [1.5,1]`ï¼‰ã€‚
- en: 'Now a strange thing happens in graph B ([FigureÂ 5-5](#fig_5_5)): the matrix-vector
    product is no longer rotated into a different direction. The matrix still scaled
    the vector, but its direction was preserved. In other words, the *matrix*-vector
    multiplication acted as if it were *scalar*-vector multiplication. That is not
    a random event: in fact, vector `v` is an eigenvector of matrix `M`, and the amount
    by which `M` stretched `v` is its eigenvalue. Thatâ€™s such an incredibly important
    phenomenon that it deserves its own chapter ([ChapterÂ 13](ch13.xhtml#Chapter_13)),
    but I just couldnâ€™t resist introducing you to the concept now.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œåœ¨å›¾ B ä¸­å‡ºç°äº†ä¸€ä¸ªå¥‡æ€ªçš„ç°è±¡ï¼ˆ[å›¾ 5-5](#fig_5_5)ï¼‰ï¼šçŸ©é˜µå‘é‡ç§¯ä¸å†å°†å‘é‡æ—‹è½¬åˆ°å¦ä¸€ä¸ªæ–¹å‘ã€‚çŸ©é˜µä»ç„¶ç¼©æ”¾äº†å‘é‡ï¼Œä½†å…¶æ–¹å‘è¢«ä¿ç•™äº†ã€‚æ¢å¥è¯è¯´ï¼Œ*çŸ©é˜µ*-å‘é‡ä¹˜æ³•å°±åƒ*æ ‡é‡*-å‘é‡ä¹˜æ³•ä¸€æ ·ã€‚è¿™å¹¶ä¸æ˜¯å¶ç„¶äº‹ä»¶ï¼šäº‹å®ä¸Šï¼Œå‘é‡
    `v` æ˜¯çŸ©é˜µ `M` çš„ç‰¹å¾å‘é‡ï¼Œè€Œ `M` æ‹‰ä¼¸ `v` çš„ç¨‹åº¦æ˜¯å…¶ç‰¹å¾å€¼ã€‚è¿™æ˜¯ä¸€ä¸ªéå¸¸é‡è¦çš„ç°è±¡ï¼Œå€¼å¾—å•ç‹¬è®¨è®ºï¼ˆ[ç¬¬ 13 ç« ](ch13.xhtml#Chapter_13)ï¼‰ï¼Œä½†æˆ‘ç°åœ¨å°±å¿ä¸ä½å‘ä½ ä»‹ç»è¿™ä¸ªæ¦‚å¿µã€‚
- en: '![Matrix-vector multiplication](assets/plad_0505.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![çŸ©é˜µå‘é‡ä¹˜æ³•](assets/plad_0505.png)'
- en: Figure 5-5\. Examples of matrix-vector multiplication
  id: totrans-112
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾ 5-5\. çŸ©é˜µå‘é‡ä¹˜æ³•ç¤ºä¾‹
- en: Segues to advanced topics aside, the main point of these demonstrations is that
    one of the functions of matrix-vector multiplication is for a matrix to house
    a transformation that, when applied to a vector, can rotate and stretch that vector.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: é¡ºä¾¿æä¸€ä¸‹é«˜çº§ä¸»é¢˜ï¼Œè¿™äº›æ¼”ç¤ºçš„ä¸»è¦è§‚ç‚¹æ˜¯ï¼ŒçŸ©é˜µå‘é‡ä¹˜æ³•çš„ä¸€ä¸ªåŠŸèƒ½æ˜¯è®©çŸ©é˜µæ‰¿è½½ä¸€ä¸ªå˜æ¢ï¼Œå½“åº”ç”¨åˆ°ä¸€ä¸ªå‘é‡ä¸Šæ—¶ï¼Œå¯ä»¥æ—‹è½¬å’Œæ‹‰ä¼¸è¯¥å‘é‡ã€‚
- en: 'Matrix Operations: Transpose'
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: çŸ©é˜µæ“ä½œï¼šè½¬ç½®
- en: 'You learned about the transpose operation on vectors in [ChapterÂ 2](ch02.xhtml#Chapter_2).
    The principle is the same with matrices: swap the rows and columns. And just like
    with vectors, the transpose is indicated with a superscripted <math alttext="Superscript
    upper T"><msup><mtext>T</mtext></msup></math> (thus, <math alttext="bold upper
    C Superscript upper T"><msup><mi>ğ‚</mi> <mtext>T</mtext></msup></math> is the
    transpose of <math alttext="bold upper C"><mi>ğ‚</mi></math> ). And double-transposing
    a matrix returns the original matrix ( <math alttext="bold upper C Superscript
    TT Baseline equals bold upper C"><mrow><msup><mi>ğ‚</mi> <mtext>TT</mtext></msup>
    <mo>=</mo> <mi>ğ‚</mi></mrow></math> ).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ åœ¨ [ç¬¬ 2 ç« ](ch02.xhtml#Chapter_2) ä¸­å­¦ä¹ äº†å‘é‡çš„è½¬ç½®æ“ä½œã€‚å¯¹äºçŸ©é˜µæ¥è¯´ï¼ŒåŸç†æ˜¯ä¸€æ ·çš„ï¼šäº¤æ¢è¡Œå’Œåˆ—ã€‚å°±åƒå‘é‡ä¸€æ ·ï¼Œè½¬ç½®ç”¨ä¸Šæ ‡
    <math alttext="Superscript upper T"><msup><mtext>T</mtext></msup></math> è¡¨ç¤ºï¼ˆå› æ­¤ï¼Œ<math
    alttext="bold upper C Superscript upper T"><msup><mi>ğ‚</mi> <mtext>T</mtext></msup></math>
    æ˜¯çŸ©é˜µ <math alttext="bold upper C"><mi>ğ‚</mi></math> çš„è½¬ç½®ï¼‰ã€‚è€Œä¸”å¯¹ä¸€ä¸ªçŸ©é˜µè¿›è¡Œä¸¤æ¬¡è½¬ç½®ä¼šå¾—åˆ°åŸå§‹çŸ©é˜µï¼ˆ
    <math alttext="bold upper C Superscript TT Baseline equals bold upper C"><mrow><msup><mi>ğ‚</mi>
    <mtext>TT</mtext></msup> <mo>=</mo> <mi>ğ‚</mi></mrow></math> ï¼‰ã€‚
- en: The formal mathematical definition of the transpose operation is printed in
    [Equation 5-2](#deftransop) (essentially repeated from the previous chapter),
    but I think itâ€™s just as easy to remember that *transposing swaps rows and columns*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: è½¬ç½®æ“ä½œçš„æ­£å¼æ•°å­¦å®šä¹‰æ‰“å°åœ¨ [æ–¹ç¨‹å¼ 5-2](#deftransop) ä¸­ï¼ˆåŸºæœ¬ä¸Šæ˜¯ä»å‰ä¸€ç« é‡å¤çš„ï¼‰ï¼Œä½†æˆ‘è®¤ä¸ºè®°ä½*è½¬ç½®ä¼šäº¤æ¢è¡Œå’Œåˆ—*ä¹ŸåŒæ ·ç®€å•ã€‚
- en: Equation 5-2\. Definition of the transpose operation
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: æ–¹ç¨‹å¼ 5-2\. è½¬ç½®æ“ä½œçš„å®šä¹‰
- en: <math alttext="a Subscript i comma j Superscript upper T Baseline equals a Subscript
    j comma i" display="block"><mrow><msubsup><mi>a</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow>
    <mtext>T</mtext></msubsup> <mo>=</mo> <msub><mi>a</mi> <mrow><mi>j</mi><mo>,</mo><mi>i</mi></mrow></msub></mrow></math>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="a Subscript i comma j Superscript upper T Baseline equals a Subscript
    j comma i" display="block"><mrow><msubsup><mi>a</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow>
    <mtext>T</mtext></msubsup> <mo>=</mo> <msub><mi>a</mi> <mrow><mi>j</mi><mo>,</mo><mi>i</mi></mrow></msub></mrow></math>
- en: 'Hereâ€™s an example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰ä¸€ä¸ªä¾‹å­ï¼š
- en: <math alttext="Start 2 By 3 Matrix 1st Row 1st Column 3 2nd Column 0 3rd Column
    4 2nd Row 1st Column 9 2nd Column 8 3rd Column 3 EndMatrix Superscript upper T
    Baseline equals Start 3 By 2 Matrix 1st Row 1st Column 3 2nd Column 9 2nd Row
    1st Column 0 2nd Column 8 3rd Row 1st Column 4 2nd Column 3 EndMatrix" display="block"><mrow><msup><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>3</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>4</mn></mtd></mtr><mtr><mtd><mn>9</mn></mtd><mtd><mn>8</mn></mtd><mtd><mn>3</mn></mtd></mtr></mtable></mfenced>
    <mtext>T</mtext></msup> <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>3</mn></mtd>
    <mtd><mn>9</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>8</mn></mtd></mtr>
    <mtr><mtd><mn>4</mn></mtd> <mtd><mn>3</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 3 Matrix 1st Row 1st Column 3 2nd Column 0 3rd Column
    4 2nd Row 1st Column 9 2nd Column 8 3rd Column 3 EndMatrix Superscript upper T
    Baseline equals Start 3 By 2 Matrix 1st Row 1st Column 3 2nd Column 9 2nd Row
    1st Column 0 2nd Column 8 3rd Row 1st Column 4 2nd Column 3 EndMatrix" display="block"><mrow><msup><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>3</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>4</mn></mtd></mtr><mtr><mtd><mn>9</mn></mtd><mtd><mn>8</mn></mtd><mtd><mn>3</mn></mtd></mtr></mtable></mfenced>
    <mtext>T</mtext></msup> <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>3</mn></mtd>
    <mtd><mn>9</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>8</mn></mtd></mtr>
    <mtr><mtd><mn>4</mn></mtd> <mtd><mn>3</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'There are a few ways to transpose matrices in Python, using a function and
    a method acting on NumPy arrays:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Python ä¸­ï¼Œæœ‰å‡ ç§æ–¹å¼å¯ä»¥å¯¹çŸ©é˜µè¿›è¡Œè½¬ç½®ï¼Œä½¿ç”¨å‡½æ•°å’Œä½œç”¨äº NumPy æ•°ç»„çš„æ–¹æ³•ï¼š
- en: '[PRE7]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The matrix in this example uses a 2D NumPy array; what do you think will happen
    if you apply the transpose method to a vector encoded as a 1D array? Try it and
    find out!^([3](ch05.xhtml#idm45733312589280))
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: æ­¤ç¤ºä¾‹ä¸­çš„çŸ©é˜µä½¿ç”¨ 2D NumPy æ•°ç»„ï¼›å¦‚æœå°†ä½œä¸º 1D æ•°ç»„ç¼–ç çš„å‘é‡åº”ç”¨è½¬ç½®æ–¹æ³•ï¼Œä½ è®¤ä¸ºä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿè¯•ä¸€è¯•å¹¶æ‰¾å‡ºç­”æ¡ˆï¼^([3](ch05.xhtml#idm45733312589280))
- en: Dot and Outer Product Notation
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ç‚¹ç§¯å’Œå¤–ç§¯ç¬¦å·
- en: Now that you know about the transpose operation and about the rules for matrix
    multiplication validity, we can return to the notation of the vector dot product.
    For two-column vectors of <math alttext="upper M times 1"><mrow><mi>M</mi> <mo>Ã—</mo>
    <mn>1</mn></mrow></math> , transposing the first vector and not the second gives
    two â€œmatricesâ€ of sizes <math alttext="1 times upper M"><mrow><mn>1</mn> <mo>Ã—</mo>
    <mi>M</mi></mrow></math> and <math alttext="upper M times 1"><mrow><mi>M</mi>
    <mo>Ã—</mo> <mn>1</mn></mrow></math> . The â€œinnerâ€ dimensions match and the â€œouterâ€
    dimensions tell us that the product will be <math alttext="1 times 1"><mrow><mn>1</mn>
    <mo>Ã—</mo> <mn>1</mn></mrow></math> , a.k.a. a scalar. That is the reason why
    the dot product is indicated as <math alttext="bold a Superscript upper T Baseline
    bold b"><mrow><msup><mi>ğš</mi> <mtext>T</mtext></msup> <mi>ğ›</mi></mrow></math>
    .
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ä½ å·²ç»äº†è§£äº†è½¬ç½®æ“ä½œä»¥åŠçŸ©é˜µä¹˜æ³•æœ‰æ•ˆæ€§è§„åˆ™ï¼Œæˆ‘ä»¬å¯ä»¥å›é¡¾ä¸€ä¸‹å‘é‡ç‚¹ç§¯çš„ç¬¦å·ã€‚å¯¹äºä¸¤åˆ—å‘é‡ <math alttext="upper M times
    1"><mrow><mi>M</mi> <mo>Ã—</mo> <mn>1</mn></mrow></math> ï¼Œè½¬ç½®ç¬¬ä¸€ä¸ªå‘é‡è€Œä¸è½¬ç½®ç¬¬äºŒä¸ªå‘é‡ä¼šå¾—åˆ°å°ºå¯¸ä¸º
    <math alttext="1 times upper M"><mrow><mn>1</mn> <mo>Ã—</mo> <mi>M</mi></mrow></math>
    å’Œ <math alttext="upper M times 1"><mrow><mi>M</mi> <mo>Ã—</mo> <mn>1</mn></mrow></math>
    çš„ä¸¤ä¸ªâ€œçŸ©é˜µâ€ã€‚â€œå†…éƒ¨â€å°ºå¯¸åŒ¹é…ï¼Œè€Œâ€œå¤–éƒ¨â€å°ºå¯¸å‘Šè¯‰æˆ‘ä»¬ä¹˜ç§¯å°†æ˜¯ <math alttext="1 times 1"><mrow><mn>1</mn> <mo>Ã—</mo>
    <mn>1</mn></mrow></math> ï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ªæ ‡é‡ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆç‚¹ç§¯è¢«è¡¨ç¤ºä¸º <math alttext="bold a Superscript
    upper T Baseline bold b"><mrow><msup><mi>ğš</mi> <mtext>T</mtext></msup> <mi>ğ›</mi></mrow></math>
    çš„åŸå› ã€‚
- en: 'Same reasoning for the outer product: multiplying a column vector by a row
    vector has sizes <math alttext="upper M times 1"><mrow><mi>M</mi> <mo>Ã—</mo> <mn>1</mn></mrow></math>
    and <math alttext="1 times upper N"><mrow><mn>1</mn> <mo>Ã—</mo> <mi>N</mi></mrow></math>
    . The â€œinnerâ€ dimensions match, and the size of the result will be <math alttext="upper
    M times upper N"><mrow><mi>M</mi> <mo>Ã—</mo> <mi>N</mi></mrow></math> .'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: å¤–ç§¯åŒç†ï¼šå°†åˆ—å‘é‡ä¹˜ä»¥è¡Œå‘é‡å°ºå¯¸ä¸º <math alttext="upper M times 1"><mrow><mi>M</mi> <mo>Ã—</mo>
    <mn>1</mn></mrow></math> å’Œ <math alttext="1 times upper N"><mrow><mn>1</mn> <mo>Ã—</mo>
    <mi>N</mi></mrow></math> ã€‚â€œå†…éƒ¨â€å°ºå¯¸åŒ¹é…ï¼Œç»“æœçš„å°ºå¯¸å°†æ˜¯ <math alttext="upper M times upper
    N"><mrow><mi>M</mi> <mo>Ã—</mo> <mi>N</mi></mrow></math>ã€‚
- en: 'Matrix Operations: LIVE EVIL (Order of Operations)'
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: çŸ©é˜µè¿ç®—ï¼šLIVE EVILï¼ˆè¿ç®—é¡ºåºï¼‰
- en: LIVE EVIL is a palindrome (a palindrome is a word or phrase that is spelled
    the same forwards and backwards) and a cute mnemonic for remembering how transposing
    affects the order of multiplied matrices. Basically, the rule is that the transpose
    of multiplied matrices is the same as the individual matrices transposed and multiplied,
    but reversed in order. In [Equation 5-3](#live_evil), <math alttext="bold upper
    L"><mi>ğ‹</mi></math> , <math alttext="bold upper I"><mi>ğˆ</mi></math> , <math
    alttext="bold upper V"><mi>ğ•</mi></math> , and <math alttext="bold upper E"><mi>ğ„</mi></math>
    are all matrices, and you can assume that their sizes match to make multiplication
    valid.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: LIVE EVIL æ˜¯ä¸€ä¸ªå›æ–‡ï¼ˆå›æ–‡æ˜¯æŒ‡å‰åè¯»éƒ½ä¸€æ ·çš„å•è¯æˆ–çŸ­è¯­ï¼‰ï¼Œä¹Ÿæ˜¯ä¸€ä¸ªå¯çˆ±çš„è®°å¿†æ³•åˆ™ï¼Œç”¨äºè®°å¿†è½¬ç½®å¦‚ä½•å½±å“ä¹˜ç§¯çŸ©é˜µçš„é¡ºåºã€‚åŸºæœ¬ä¸Šï¼Œè§„åˆ™æ˜¯ä¹˜ç§¯çŸ©é˜µçš„è½¬ç½®ç­‰åŒäºå•ç‹¬è½¬ç½®å¹¶ç›¸ä¹˜çš„çŸ©é˜µï¼Œä½†é¡ºåºç›¸åã€‚åœ¨
    [Equation 5-3](#live_evil) ä¸­ï¼Œ<math alttext="bold upper L"><mi>ğ‹</mi></math>ï¼Œ<math
    alttext="bold upper I"><mi>ğˆ</mi></math>ï¼Œ<math alttext="bold upper V"><mi>ğ•</mi></math>ï¼Œå’Œ<math
    alttext="bold upper E"><mi>ğ„</mi></math> éƒ½æ˜¯çŸ©é˜µï¼Œä½ å¯ä»¥å‡è®¾å®ƒä»¬çš„å°ºå¯¸åŒ¹é…ä»¥ä½¿ä¹˜æ³•æœ‰æ•ˆã€‚
- en: Equation 5-3\. Example of the LIVE EVIL rule
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: æ–¹ç¨‹å¼ 5-3\. LIVE EVIL è§„åˆ™ç¤ºä¾‹
- en: <math alttext="left-parenthesis bold upper L bold upper I bold upper V bold
    upper E right-parenthesis Superscript upper T Baseline equals bold upper E Superscript
    upper T Baseline bold upper V Superscript upper T Baseline bold upper I Superscript
    upper T Baseline bold upper L Superscript upper T" display="block"><mrow><msup><mrow><mo>(</mo><mi>ğ‹</mi><mi>ğˆ</mi><mi>ğ•</mi><mi>ğ„</mi><mo>)</mo></mrow>
    <mtext>T</mtext></msup> <mo>=</mo> <msup><mi>ğ„</mi> <mtext>T</mtext></msup> <msup><mi>ğ•</mi>
    <mtext>T</mtext></msup> <msup><mi>ğˆ</mi> <mtext>T</mtext></msup> <msup><mi>ğ‹</mi>
    <mtext>T</mtext></msup></mrow></math>
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="left-parenthesis bold upper L bold upper I bold upper V bold
    upper E right-parenthesis Superscript upper T Baseline equals bold upper E Superscript
    upper T Baseline bold upper V Superscript upper T Baseline bold upper I Superscript
    upper T Baseline bold upper L Superscript upper T" display="block"><mrow><msup><mrow><mo>(</mo><mi>ğ‹</mi><mi>ğˆ</mi><mi>ğ•</mi><mi>ğ„</mi><mo>)</mo></mrow>
    <mtext>T</mtext></msup> <mo>=</mo> <msup><mi>ğ„</mi> <mtext>T</mtext></msup> <msup><mi>ğ•</mi>
    <mtext>T</mtext></msup> <msup><mi>ğˆ</mi> <mtext>T</mtext></msup> <msup><mi>ğ‹</mi>
    <mtext>T</mtext></msup></mrow></math>
- en: Needless to say, this rule applies for multiplying any number of matrices, not
    just four, and not just with these â€œrandomly selectedâ€ letters.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ç”¨è¯´ï¼Œè¿™æ¡è§„åˆ™é€‚ç”¨äºä»»æ„æ•°é‡çš„çŸ©é˜µä¹˜æ³•ï¼Œä¸ä»…ä»…æ˜¯å››ä¸ªï¼Œå¹¶ä¸”ä¸ä»…ä»…æ˜¯è¿™äº›â€œéšæœºé€‰æ‹©â€çš„å­—æ¯ã€‚
- en: This does seem like a strange rule, but itâ€™s the only way to make transposing
    multiplied matrices work. Youâ€™ll have the opportunity to test this yourself in
    [Exercise 5-7](#exercise_5_7) at the end of this chapter. If you like, you may
    skip to that exercise before moving on.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¼¼ä¹æ˜¯ä¸ªå¥‡æ€ªçš„è§„åˆ™ï¼Œä½†è¿™æ˜¯ä½¿è½¬ç½®ä¹˜ç§¯çŸ©é˜µèµ·ä½œç”¨çš„å”¯ä¸€æ–¹æ³•ã€‚ä½ å¯ä»¥åœ¨æœ¬ç« æœ«å°¾çš„ [Exercise 5-7](#exercise_5_7) ä¸­äº²è‡ªæµ‹è¯•è¿™ä¸€ç‚¹ã€‚å¦‚æœæ„¿æ„ï¼Œä½ å¯ä»¥å…ˆè·³åˆ°è¯¥ç»ƒä¹ å†ç»§ç»­é˜…è¯»ã€‚
- en: Symmetric Matrices
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å¯¹ç§°çŸ©é˜µ
- en: Symmetric matrices have lots of special properties that make them great to work
    with. They also tend to be numerically stable and thus convenient for computer
    algorithms. Youâ€™ll learn about the special properties of symmetric matrices as
    you work through this book; here I will focus on what symmetric matrices are and
    how to create them from nonsymmetric matrices.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹ç§°çŸ©é˜µå…·æœ‰è®¸å¤šç‰¹æ®Šå±æ€§ï¼Œä½¿å®ƒä»¬å¾ˆé€‚åˆå¤„ç†ã€‚å®ƒä»¬é€šå¸¸æ•°å€¼ç¨³å®šï¼Œå› æ­¤å¯¹è®¡ç®—æœºç®—æ³•å¾ˆæ–¹ä¾¿ã€‚åœ¨æ‚¨é˜…è¯»æœ¬ä¹¦çš„è¿‡ç¨‹ä¸­ï¼Œæ‚¨å°†äº†è§£å¯¹ç§°çŸ©é˜µçš„ç‰¹æ®Šå±æ€§ï¼›åœ¨æ­¤ï¼Œæˆ‘å°†é‡ç‚¹ä»‹ç»å¯¹ç§°çŸ©é˜µçš„å®šä¹‰åŠå¦‚ä½•ä»éå¯¹ç§°çŸ©é˜µåˆ›å»ºå®ƒä»¬ã€‚
- en: What does it mean for a matrix to be symmetric? It means that the corresponding
    rows and columns are equal. And that means that when you swap the rows and columns,
    nothing happens to the matrix. And that in turn means that a *symmetric matrix
    equals its transpose*. In math terms, a matrix <math alttext="bold upper A"><mi>ğ€</mi></math>
    is symmetric if <math alttext="bold upper A Superscript upper T Baseline equals
    bold upper A"><mrow><msup><mi>ğ€</mi> <mtext>T</mtext></msup> <mo>=</mo> <mi>ğ€</mi></mrow></math>
    .
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: çŸ©é˜µå¯¹ç§°æ„å‘³ç€ä»€ä¹ˆï¼Ÿè¿™æ„å‘³ç€ç›¸åº”çš„è¡Œå’Œåˆ—æ˜¯ç›¸ç­‰çš„ã€‚è¿™æ„å‘³ç€å½“æ‚¨äº¤æ¢è¡Œå’Œåˆ—æ—¶ï¼ŒçŸ©é˜µä¸å˜ã€‚è¿™åˆæ„å‘³ç€*å¯¹ç§°çŸ©é˜µç­‰äºå…¶è½¬ç½®*ã€‚åœ¨æ•°å­¦æœ¯è¯­ä¸­ï¼ŒçŸ©é˜µ<math alttext="bold
    upper A"><mi>ğ€</mi></math>æ˜¯å¯¹ç§°çš„ï¼Œå¦‚æœ<math alttext="bold upper A Superscript upper
    T Baseline equals bold upper A"><mrow><msup><mi>ğ€</mi> <mtext>T</mtext></msup>
    <mo>=</mo> <mi>ğ€</mi></mrow></math>ã€‚
- en: Check out the symmetric matrix in [Equation 5-4](#sym_matrix).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: æŸ¥çœ‹[æ–¹ç¨‹ 5-4](#sym_matrix)ä¸­çš„å¯¹ç§°çŸ©é˜µã€‚
- en: Equation 5-4\. A symmetric matrix; note that each row equals its corresponding
    column
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: æ–¹ç¨‹ 5-4\. ä¸€ä¸ªå¯¹ç§°çŸ©é˜µï¼›æ³¨æ„æ¯è¡Œç­‰äºå…¶å¯¹åº”çš„åˆ—
- en: <math alttext="Start 4 By 4 Matrix 1st Row 1st Column a 2nd Column e 3rd Column
    f 4th Column g 2nd Row 1st Column e 2nd Column b 3rd Column h 4th Column i 3rd
    Row 1st Column f 2nd Column h 3rd Column c 4th Column j 4th Row 1st Column g 2nd
    Column i 3rd Column j 4th Column d EndMatrix" display="block"><mfenced close="]"
    open="["><mtable><mtr><mtd><mrow><mi>a</mi></mrow></mtd> <mtd><mrow><mi>e</mi></mrow></mtd>
    <mtd><mrow><mi>f</mi></mrow></mtd> <mtd><mrow><mi>g</mi></mrow></mtd></mtr> <mtr><mtd><mi>e</mi></mtd>
    <mtd><mi>b</mi></mtd> <mtd><mi>h</mi></mtd> <mtd><mi>i</mi></mtd></mtr> <mtr><mtd><mi>f</mi></mtd>
    <mtd><mi>h</mi></mtd> <mtd><mi>c</mi></mtd> <mtd><mi>j</mi></mtd></mtr> <mtr><mtd><mi>g</mi></mtd>
    <mtd><mi>i</mi></mtd> <mtd><mi>j</mi></mtd> <mtd><mi>d</mi></mtd></mtr></mtable></mfenced></math>
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 4 By 4 Matrix 1st Row 1st Column a 2nd Column e 3rd Column
    f 4th Column g 2nd Row 1st Column e 2nd Column b 3rd Column h 4th Column i 3rd
    Row 1st Column f 2nd Column h 3rd Column c 4th Column j 4th Row 1st Column g 2nd
    Column i 3rd Column j 4th Column d EndMatrix" display="block"><mfenced close="]"
    open="["><mtable><mtr><mtd><mrow><mi>a</mi></mrow></mtd> <mtd><mrow><mi>e</mi></mrow></mtd>
    <mtd><mrow><mi>f</mi></mrow></mtd> <mtd><mrow><mi>g</mi></mrow></mtd></mtr> <mtr><mtd><mi>e</mi></mtd>
    <mtd><mi>b</mi></mtd> <mtd><mi>h</mi></mtd> <mtd><mi>i</mi></mtd></mtr> <mtr><mtd><mi>f</mi></mtd>
    <mtd><mi>h</mi></mtd> <mtd><mi>c</mi></mtd> <mtd><mi>j</mi></mtd></mtr> <mtr><mtd><mi>g</mi></mtd>
    <mtd><mi>i</mi></mtd> <mtd><mi>j</mi></mtd> <mtd><mi>d</mi></mtd></mtr></mtable></mfenced></math>
- en: Can a nonsquare matrix be symmetric? Nope! The reason is that if a matrix is
    of size <math alttext="upper M times upper N"><mrow><mi>M</mi> <mo>Ã—</mo> <mi>N</mi></mrow></math>
    , then its transpose is of size <math alttext="upper N times upper M"><mrow><mi>N</mi>
    <mo>Ã—</mo> <mi>M</mi></mrow></math> . Those two matrices could not be equal unless
    <math alttext="upper M equals upper N"><mrow><mi>M</mi> <mo>=</mo> <mi>N</mi></mrow></math>
    , which means the matrix is square.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªéæ–¹é˜µå¯ä»¥å¯¹ç§°å—ï¼Ÿä¸è¡Œï¼åŸå› åœ¨äºå¦‚æœä¸€ä¸ªçŸ©é˜µçš„å¤§å°æ˜¯<math alttext="upper M times upper N"><mrow><mi>M</mi>
    <mo>Ã—</mo> <mi>N</mi></mrow></math>ï¼Œé‚£ä¹ˆå®ƒçš„è½¬ç½®çš„å¤§å°æ˜¯<math alttext="upper N times upper
    M"><mrow><mi>N</mi> <mo>Ã—</mo> <mi>M</mi></mrow></math>ã€‚é™¤é<math alttext="upper
    M equals upper N"><mrow><mi>M</mi> <mo>=</mo> <mi>N</mi></mrow></math>ï¼Œå¦åˆ™è¿™ä¸¤ä¸ªçŸ©é˜µä¸å¯èƒ½ç›¸ç­‰ï¼Œè¿™æ„å‘³ç€çŸ©é˜µæ˜¯æ–¹é˜µã€‚
- en: Creating Symmetric Matrices from Nonsymmetric Matrices
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ä»éå¯¹ç§°çŸ©é˜µåˆ›å»ºå¯¹ç§°çŸ©é˜µ
- en: This may be surprising at first, but multiplying *any* matrixâ€”even a nonsquare
    and nonsymmetric matrixâ€”by its transpose will produce a square symmetric matrix.
    In other words, <math alttext="bold upper A Superscript upper T Baseline bold
    upper A"><mrow><msup><mi>ğ€</mi> <mtext>T</mtext></msup> <mi>ğ€</mi></mrow></math>
    is square symmetric, as is <math alttext="bold upper A bold upper A Superscript
    upper T"><mrow><mi>ğ€</mi> <msup><mi>ğ€</mi> <mtext>T</mtext></msup></mrow></math>
    . (If you lack the time, patience, or keyboard skills to format the superscripted
    ^T, you can write AtA and AAt or Aâ€²A and AAâ€².)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åˆè¿™å¯èƒ½ä»¤äººæƒŠè®¶ï¼Œä½†æ˜¯ä¹˜ä»¥*ä»»ä½•*çŸ©é˜µâ€”â€”ç”šè‡³æ˜¯éæ–¹é˜µå’Œéå¯¹ç§°çŸ©é˜µâ€”â€”å®ƒçš„è½¬ç½®å°†äº§ç”Ÿä¸€ä¸ªæ–¹å¯¹ç§°çŸ©é˜µã€‚æ¢å¥è¯è¯´ï¼Œ<math alttext="bold
    upper A Superscript upper T Baseline bold upper A"><mrow><msup><mi>ğ€</mi> <mtext>T</mtext></msup>
    <mi>ğ€</mi></mrow></math>æ˜¯æ–¹å¯¹ç§°çš„ï¼Œä»¥åŠ<math alttext="bold upper A bold upper A Superscript
    upper T"><mrow><mi>ğ€</mi> <msup><mi>ğ€</mi> <mtext>T</mtext></msup></mrow></math>ã€‚
    ï¼ˆå¦‚æœæ‚¨ç¼ºä¹æ—¶é—´ã€è€å¿ƒæˆ–é”®ç›˜æŠ€èƒ½æ¥æ ¼å¼åŒ–ä¸Šæ ‡ ^Tï¼Œæ‚¨å¯ä»¥å†™æˆAtAå’ŒAAtæˆ–A'Aå’ŒAA'ã€‚ï¼‰
- en: Letâ€™s prove this claim rigorously before seeing an example. On the one hand,
    we donâ€™t actually need to prove separately that <math alttext="bold upper A Superscript
    upper T Baseline bold upper A"><mrow><msup><mi>ğ€</mi> <mtext>T</mtext></msup>
    <mi>ğ€</mi></mrow></math> is square *and* symmetric, because the latter implies
    the former. But proving squareness is straightforward and a good exercise in linear
    algebra proofs (which tend to be shorter and easier than, e.g., calculus proofs).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨çœ‹åˆ°ä¸€ä¸ªä¾‹å­ä¹‹å‰ï¼Œè®©æˆ‘ä»¬ä¸¥æ ¼è¯æ˜è¿™ä¸ªæ–­è¨€ã€‚ä¸€æ–¹é¢ï¼Œæˆ‘ä»¬å®é™…ä¸Šä¸éœ€è¦å•ç‹¬è¯æ˜<math alttext="bold upper A Superscript
    upper T Baseline bold upper A"><mrow><msup><mi>ğ€</mi> <mtext>T</mtext></msup>
    <mi>ğ€</mi></mrow></math>æ˜¯æ–¹ *ä¸”* å¯¹ç§°ï¼Œå› ä¸ºåè€…æ„å‘³ç€å‰è€…ã€‚ä½†è¯æ˜æ–¹å½¢æ˜¯çº¿æ€§ä»£æ•°è¯æ˜ä¸­çš„ä¸€ä¸ªç®€å•ä¸”è‰¯å¥½çš„ç»ƒä¹ ï¼ˆé€šå¸¸æ¯”å¾®ç§¯åˆ†è¯æ˜æ›´çŸ­ä¸”æ›´å®¹æ˜“ï¼‰ã€‚
- en: 'The proof is obtained simply by considering the matrix sizes: if <math alttext="bold
    upper A"><mi>ğ€</mi></math> is <math alttext="upper M times upper N"><mrow><mi>M</mi>
    <mo>Ã—</mo> <mi>N</mi></mrow></math> , then <math alttext="bold upper A Superscript
    upper T Baseline bold upper A"><mrow><msup><mi>ğ€</mi> <mtext>T</mtext></msup>
    <mi>ğ€</mi></mrow></math> is <math alttext="left-parenthesis upper N times upper
    M right-parenthesis left-parenthesis upper M times upper N right-parenthesis"><mrow><mo>(</mo>
    <mi>N</mi> <mo>Ã—</mo> <mi>M</mi> <mo>)</mo> <mo>(</mo> <mi>M</mi> <mo>Ã—</mo> <mi>N</mi>
    <mo>)</mo></mrow></math> , which means the product matrix is of size <math alttext="upper
    N times upper N"><mrow><mi>N</mi> <mo>Ã—</mo> <mi>N</mi></mrow></math> . You can
    work through the same logic for <math alttext="bold upper A bold upper A Superscript
    upper T"><mrow><mi>ğ€</mi> <msup><mi>ğ€</mi> <mtext>T</mtext></msup></mrow></math>
    .'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡è€ƒè™‘çŸ©é˜µçš„å°ºå¯¸å³å¯å¾—åˆ°è¯æ˜ï¼šå¦‚æœ <math alttext="bold upper A"><mi>ğ€</mi></math> æ˜¯ <math alttext="upper
    M times upper N"><mrow><mi>M</mi> <mo>Ã—</mo> <mi>N</mi></mrow></math> ï¼Œé‚£ä¹ˆ <math
    alttext="bold upper A Superscript upper T Baseline bold upper A"><mrow><msup><mi>ğ€</mi>
    <mtext>T</mtext></msup> <mi>ğ€</mi></mrow></math> æ˜¯ <math alttext="left-parenthesis
    upper N times upper M right-parenthesis left-parenthesis upper M times upper N
    right-parenthesis"><mrow><mo>ï¼ˆ</mo> <mi>N</mi> <mo>Ã—</mo> <mi>M</mi> <mo>ï¼‰</mo>
    <mo>ï¼ˆ</mo> <mi>M</mi> <mo>Ã—</mo> <mi>N</mi> <mo>ï¼‰</mo></mrow></math> ï¼Œè¿™æ„å‘³ç€ä¹˜ç§¯çŸ©é˜µçš„å¤§å°ä¸º
    <math alttext="upper N times upper N"><mrow><mi>N</mi> <mo>Ã—</mo> <mi>N</mi></mrow></math>
    ã€‚æ‚¨å¯ä»¥æŒ‰ç…§ç›¸åŒçš„é€»è¾‘å¤„ç† <math alttext="bold upper A bold upper A Superscript upper T"><mrow><mi>ğ€</mi>
    <msup><mi>ğ€</mi> <mtext>T</mtext></msup></mrow></math> ã€‚
- en: 'Now to prove symmetry. Recall that the definition of a symmetric matrix is
    one that equals its transpose. So letâ€™s transpose <math alttext="bold upper A
    Superscript upper T Baseline bold upper A"><mrow><msup><mi>ğ€</mi> <mtext>T</mtext></msup>
    <mi>ğ€</mi></mrow></math> , do some algebra, and see what happens. Make sure you
    can follow each step here; the proof relies on the LIVE EVIL rule:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æ¥è¯æ˜å¯¹ç§°æ€§ã€‚å›æƒ³ä¸€ä¸‹ï¼Œå¯¹ç§°çŸ©é˜µçš„å®šä¹‰æ˜¯ç­‰äºå…¶è½¬ç½®ã€‚å› æ­¤è®©æˆ‘ä»¬è½¬ç½® <math alttext="bold upper A Superscript
    upper T Baseline bold upper A"><mrow><msup><mi>ğ€</mi> <mtext>T</mtext></msup>
    <mi>ğ€</mi></mrow></math> ï¼Œè¿›è¡Œä¸€äº›ä»£æ•°è¿ç®—ï¼Œçœ‹çœ‹ä¼šå‘ç”Ÿä»€ä¹ˆã€‚ç¡®ä¿æ‚¨èƒ½å¤Ÿè·Ÿè¿›æ¯ä¸€ä¸ªæ­¥éª¤ï¼›è¯æ˜ä¾èµ–äºâ€œLIVE EVILâ€è§„åˆ™ï¼š
- en: <math alttext="left-parenthesis bold upper A Superscript upper T Baseline bold
    upper A right-parenthesis Superscript upper T Baseline equals bold upper A Superscript
    upper T Baseline bold upper A Superscript TT Baseline equals bold upper A Superscript
    upper T Baseline bold upper A" display="block"><mrow><msup><mrow><mo>(</mo><msup><mi>ğ€</mi>
    <mtext>T</mtext></msup> <mi>ğ€</mi><mo>)</mo></mrow> <mtext>T</mtext></msup> <mo>=</mo>
    <msup><mi>ğ€</mi> <mtext>T</mtext></msup> <msup><mi>ğ€</mi> <mtext>TT</mtext></msup>
    <mo>=</mo> <msup><mi>ğ€</mi> <mtext>T</mtext></msup> <mi>ğ€</mi></mrow></math>
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="left-parenthesis bold upper A Superscript upper T Baseline bold
    upper A right-parenthesis Superscript upper T Baseline equals bold upper A Superscript
    upper T Baseline bold upper A Superscript TT Baseline equals bold upper A Superscript
    upper T Baseline bold upper A" display="block"><mrow><msup><mrow><mo>(</mo><msup><mi>ğ€</mi>
    <mtext>T</mtext></msup> <mi>ğ€</mi><mo>)</mo></mrow> <mtext>T</mtext></msup> <mo>=</mo>
    <msup><mi>ğ€</mi> <mtext>T</mtext></msup> <msup><mi>ğ€</mi> <mtext>TT</mtext></msup>
    <mo>=</mo> <msup><mi>ğ€</mi> <mtext>T</mtext></msup> <mi>ğ€</mi></mrow></math>
- en: Taking the first and final terms, we get <math alttext="left-parenthesis bold
    upper A Superscript upper T Baseline bold upper A right-parenthesis Superscript
    upper T Baseline equals left-parenthesis bold upper A Superscript upper T Baseline
    bold upper A right-parenthesis"><mrow><msup><mrow><mo>(</mo><msup><mi>ğ€</mi> <mtext>T</mtext></msup>
    <mi>ğ€</mi><mo>)</mo></mrow> <mtext>T</mtext></msup> <mo>=</mo> <mrow><mo>(</mo>
    <msup><mi>ğ€</mi> <mtext>T</mtext></msup> <mi>ğ€</mi> <mo>)</mo></mrow></mrow></math>
    . The matrix equals its transpose, hence it is symmetric.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: å–é¦–æœ«é¡¹ï¼Œå¾—åˆ° <math alttext="left-parenthesis bold upper A Superscript upper T Baseline
    bold upper A right-parenthesis Superscript upper T Baseline equals left-parenthesis
    bold upper A Superscript upper T Baseline bold upper A right-parenthesis"><mrow><msup><mrow><mo>ï¼ˆ</mo><msup><mi>ğ€</mi>
    <mtext>T</mtext></msup> <mi>ğ€</mi><mo>ï¼‰</mo></mrow> <mtext>T</mtext></msup> <mo>=</mo>
    <mrow><mo>ï¼ˆ</mo> <msup><mi>ğ€</mi> <mtext>T</mtext></msup> <mi>ğ€</mi> <mo>ï¼‰</mo></mrow></mrow></math>
    ã€‚çŸ©é˜µç­‰äºå…¶è½¬ç½®ï¼Œå› æ­¤å®ƒæ˜¯å¯¹ç§°çš„ã€‚
- en: Now repeat the proof on your own using <math alttext="bold upper A bold upper
    A Superscript upper T"><mrow><mi>ğ€</mi> <msup><mi>ğ€</mi> <mtext>T</mtext></msup></mrow></math>
    . Spoiler alert! Youâ€™ll come to the same conclusion. But writing out the proof
    will help you internalize the concept.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ç‹¬è‡ªè¿›è¡Œ <math alttext="bold upper A bold upper A Superscript upper T"><mrow><mi>ğ€</mi>
    <msup><mi>ğ€</mi> <mtext>T</mtext></msup></mrow></math> çš„è¯æ˜ã€‚å‰§é€è­¦å‘Šï¼æ‚¨å°†å¾—å‡ºç›¸åŒçš„ç»“è®ºã€‚ä½†æ˜¯ä¹¦å†™è¯æ˜å°†æœ‰åŠ©äºæ‚¨å†…åŒ–è¿™ä¸ªæ¦‚å¿µã€‚
- en: So <math alttext="bold upper A bold upper A Superscript upper T"><mrow><mi>ğ€</mi>
    <msup><mi>ğ€</mi> <mtext>T</mtext></msup></mrow></math> and <math alttext="bold
    upper A Superscript upper T Baseline bold upper A"><mrow><msup><mi>ğ€</mi> <mtext>T</mtext></msup>
    <mi>ğ€</mi></mrow></math> are both square symmetric. But they are not the same
    matrix! In fact, if <math alttext="bold upper A"><mi>ğ€</mi></math> is nonsquare,
    then the two matrix products are not even the same size.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ <math alttext="bold upper A bold upper A Superscript upper T"><mrow><mi>ğ€</mi>
    <msup><mi>ğ€</mi> <mtext>T</mtext></msup></mrow></math> å’Œ <math alttext="bold upper
    A Superscript upper T Baseline bold upper A"><mrow><msup><mi>ğ€</mi> <mtext>T</mtext></msup>
    <mi>ğ€</mi></mrow></math> éƒ½æ˜¯æ–¹é˜µå¯¹ç§°çš„ã€‚ä½†å®ƒä»¬ä¸æ˜¯åŒä¸€ä¸ªçŸ©é˜µï¼å®é™…ä¸Šï¼Œå¦‚æœ <math alttext="bold upper A"><mi>ğ€</mi></math>
    æ˜¯éæ–¹é˜µï¼Œåˆ™è¿™ä¸¤ä¸ªçŸ©é˜µä¹˜ç§¯ç”šè‡³ä¸æ˜¯ç›¸åŒå¤§å°ã€‚
- en: <math alttext="bold upper A Superscript upper T Baseline bold upper A"><mrow><msup><mi>ğ€</mi>
    <mtext>T</mtext></msup> <mi>ğ€</mi></mrow></math> is called the *multiplicative
    method* for creating symmetric matrices. There is also an *additive method*, which
    is valid when the matrix is square but nonsymmetric. This method has some interesting
    properties but doesnâ€™t have a lot of application value, so I wonâ€™t focus on it.
    [Exercise 5-9](#exercise_5_9) walks you through the algorithm; if youâ€™re up for
    a challenge, you can try to discover that algorithm on your own before looking
    at the exercise.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="ç²—ä½“å¤§å†™ğ€ä¸Šæ ‡å¤§å†™TåŸºçº¿ç²—ä½“å¤§å†™ğ€"><mrow><msup><mi>ğ€</mi> <mtext>T</mtext></msup>
    <mi>ğ€</mi></mrow></math> è¢«ç§°ä¸º*ä¹˜æ³•æ–¹æ³•*æ¥åˆ›å»ºå¯¹ç§°çŸ©é˜µã€‚è¿˜æœ‰*åŠ æ³•æ–¹æ³•*ï¼Œå½“çŸ©é˜µæ˜¯æ–¹é˜µä½†éå¯¹ç§°æ—¶æœ‰æ•ˆã€‚è¿™ç§æ–¹æ³•æœ‰ä¸€äº›æœ‰è¶£çš„æ€§è´¨ï¼Œä½†å®é™…åº”ç”¨ä»·å€¼ä¸é«˜ï¼Œæ‰€ä»¥æˆ‘ä¸ä¼šé‡ç‚¹ä»‹ç»å®ƒã€‚[ç»ƒä¹ 5-9](#exercise_5_9)å°†å¸¦ä½ é€æ­¥å­¦ä¹ ç®—æ³•ï¼›å¦‚æœä½ æƒ³æŒ‘æˆ˜è‡ªå·±ï¼Œå¯ä»¥åœ¨çœ‹ç»ƒä¹ ä¹‹å‰å°è¯•è‡ªå·±å‘ç°è¯¥ç®—æ³•ã€‚
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ‘˜è¦
- en: 'This chapter is the first of a three-chapter series on matrices. Here you learned
    the groundwork from which all matrix operations are based. In summary:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬ç« æ˜¯å…³äºçŸ©é˜µçš„ä¸‰ç« ç³»åˆ—ä¸­çš„ç¬¬ä¸€ç« ã€‚åœ¨è¿™é‡Œï¼Œä½ å­¦ä¼šäº†æ‰€æœ‰çŸ©é˜µæ“ä½œçš„åŸºç¡€ã€‚æ€»ç»“ï¼š
- en: Matrices are spreadsheets of numbers. In different applications, it is useful
    to conceptualize them as a set of column vectors, a set of row vectors, or an
    arrangement of individual values. Regardless, visualizing matrices as images is
    often insightful, or at least pleasant to look at.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: çŸ©é˜µå°±æ˜¯æ•°å­—çš„ç”µå­è¡¨æ ¼ã€‚åœ¨ä¸åŒçš„åº”ç”¨ä¸­ï¼Œå°†çŸ©é˜µæ¦‚å¿µåŒ–ä¸ºä¸€ç»„åˆ—å‘é‡ã€ä¸€ç»„è¡Œå‘é‡æˆ–å•ä¸ªå€¼çš„æ’åˆ—æ˜¯æœ‰ç”¨çš„ã€‚ä¸è¿‡ï¼Œå°†çŸ©é˜µè§†ä¸ºå›¾åƒé€šå¸¸æ˜¯å…·æ´å¯ŸåŠ›çš„ï¼Œæˆ–è€…è‡³å°‘çœ‹ä¸Šå»å¾ˆæ„‰å¿«ã€‚
- en: There are several categories of special matrices. Being familiar with the properties
    of the types of matrices will help you understand matrix equations and advanced
    applications.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æœ‰å‡ ç§ç‰¹æ®ŠçŸ©é˜µçš„åˆ†ç±»ã€‚ç†Ÿæ‚‰çŸ©é˜µç±»å‹çš„æ€§è´¨å°†æœ‰åŠ©äºç†è§£çŸ©é˜µæ–¹ç¨‹å’Œé«˜çº§åº”ç”¨ã€‚
- en: Some arithmetic operations work element-wise, like addition, scalar multiplication,
    and Hadamard multiplication.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€äº›ç®—æœ¯è¿ç®—æ˜¯é€å…ƒç´ å®Œæˆçš„ï¼Œæ¯”å¦‚åŠ æ³•ã€æ ‡é‡ä¹˜æ³•å’ŒHadamardä¹˜æ³•ã€‚
- en: â€œShiftingâ€ a matrix means adding a constant to the diagonal elements (without
    changing the off-diagonal elements). Shifting has several applications in machine
    learning, primarily for finding eigenvalues and regularizing statistical models.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: â€œå¹³ç§»â€çŸ©é˜µæ„å‘³ç€å‘å¯¹è§’çº¿å…ƒç´ æ·»åŠ å¸¸æ•°ï¼ˆè€Œä¸æ›´æ”¹éå¯¹è§’çº¿å…ƒç´ ï¼‰ã€‚å¹³ç§»åœ¨æœºå™¨å­¦ä¹ ä¸­å…·æœ‰å‡ ç§åº”ç”¨ï¼Œä¸»è¦ç”¨äºæŸ¥æ‰¾ç‰¹å¾å€¼å’Œæ­£åˆ™åŒ–ç»Ÿè®¡æ¨¡å‹ã€‚
- en: 'Matrix multiplication involves dot products between rows of the left matrix
    and columns of the right matrix. The product matrix is an organized collection
    of mappings between row-column pairs. Memorize the rule for matrix multiplication
    validity: <math alttext="left-parenthesis upper M times upper N right-parenthesis
    left-parenthesis upper N times upper K right-parenthesis equals left-parenthesis
    upper M times upper K right-parenthesis"><mrow><mo>(</mo> <mi>M</mi> <mo>Ã—</mo>
    <mi>N</mi> <mo>)</mo> <mo>(</mo> <mi>N</mi> <mo>Ã—</mo> <mi>K</mi> <mo>)</mo> <mo>=</mo>
    <mo>(</mo> <mi>M</mi> <mo>Ã—</mo> <mi>K</mi> <mo>)</mo></mrow></math> .'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: çŸ©é˜µä¹˜æ³•æ¶‰åŠå·¦çŸ©é˜µçš„è¡Œä¸å³çŸ©é˜µçš„åˆ—çš„ç‚¹ç§¯ã€‚ä¹˜ç§¯çŸ©é˜µæ˜¯è¡Œ-åˆ—å¯¹ä¹‹é—´çš„æ˜ å°„çš„æœ‰åºé›†åˆã€‚è®°ä½çŸ©é˜µä¹˜æ³•æœ‰æ•ˆæ€§è§„åˆ™ï¼š<math alttext="å·¦æ‹¬å·å¤§å†™Mä¹˜å¤§å†™Nå³æ‹¬å·å·¦æ‹¬å·å¤§å†™Nä¹˜å¤§å†™Kå³æ‹¬å·ç­‰äºå·¦æ‹¬å·å¤§å†™Mä¹˜å¤§å†™Kå³æ‹¬å·"><mrow><mo>(</mo>
    <mi>M</mi> <mo>Ã—</mo> <mi>N</mi> <mo>)</mo> <mo>(</mo> <mi>N</mi> <mo>Ã—</mo> <mi>K</mi>
    <mo>)</mo> <mo>=</mo> <mo>(</mo> <mi>M</mi> <mo>Ã—</mo> <mi>K</mi> <mo>)</mo></mrow></math>
    ã€‚
- en: LIVE EVIL:^([4](ch05.xhtml#idm45733312413120)) The transpose of multiplied matrices
    equals the individual matrices transposed and multiplied with their order reversed.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LIVE EVIL:^([4](ch05.xhtml#idm45733312413120)) ç›¸ä¹˜çŸ©é˜µçš„è½¬ç½®ç­‰äºå„è‡ªçŸ©é˜µçš„è½¬ç½®å¹¶ä¸”å®ƒä»¬çš„é¡ºåºé¢ å€’åç›¸ä¹˜ã€‚
- en: Symmetric matrices are mirrored across the diagonal, which means that each row
    equals its corresponding columns, and are defined as <math alttext="bold upper
    A equals bold upper A Superscript upper T"><mrow><mi>ğ€</mi> <mo>=</mo> <msup><mi>ğ€</mi>
    <mtext>T</mtext></msup></mrow></math> . Symmetric matrices have many interesting
    and useful properties that make them great to work with in applications.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¯¹ç§°çŸ©é˜µæ˜¯æ²¿å¯¹è§’çº¿é•œåƒçš„çŸ©é˜µï¼Œè¿™æ„å‘³ç€æ¯è¡Œç­‰äºå…¶å¯¹åº”çš„åˆ—ï¼Œå¹¶å®šä¹‰ä¸º<math alttext="ç²—ä½“å¤§å†™Aç­‰äºç²—ä½“å¤§å†™Aä¸Šæ ‡å¤§å†™T"><mrow><mi>ğ€</mi>
    <mo>=</mo> <msup><mi>ğ€</mi> <mtext>T</mtext></msup></mrow></math>ã€‚å¯¹ç§°çŸ©é˜µæœ‰è®¸å¤šæœ‰è¶£å’Œæœ‰ç”¨çš„æ€§è´¨ï¼Œä½¿å…¶åœ¨åº”ç”¨ä¸­éå¸¸é€‚ç”¨ã€‚
- en: You can create a symmetric matrix from any matrix by multiplying that matrix
    by its transpose. The resulting matrix <math alttext="bold upper A Superscript
    upper T Baseline bold upper A"><mrow><msup><mi>ğ€</mi> <mtext>T</mtext></msup>
    <mi>ğ€</mi></mrow></math> is central to statistical models and the singular value
    decomposition.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä½ å¯ä»¥é€šè¿‡å°†çŸ©é˜µä¹˜ä»¥å…¶è½¬ç½®æ¥ä»ä»»ä½•çŸ©é˜µåˆ›å»ºå¯¹ç§°çŸ©é˜µã€‚ç»“æœçŸ©é˜µ <math alttext="bold upper A Superscript upper
    T Baseline bold upper A"><mrow><msup><mi>ğ€</mi> <mtext>T</mtext></msup> <mi>ğ€</mi></mrow></math>
    å¯¹äºç»Ÿè®¡æ¨¡å‹å’Œå¥‡å¼‚å€¼åˆ†è§£éå¸¸é‡è¦ã€‚
- en: Code Exercises
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ä»£ç ç»ƒä¹ 
- en: Exercise 5-1\.
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ç»ƒä¹  5-1ã€‚
- en: 'This exercise will help you gain familiarity with indexing matrix elements.
    Create a <math alttext="3 times 4"><mrow><mn>3</mn> <mo>Ã—</mo> <mn>4</mn></mrow></math>
    matrix using `np.arange(12).reshape(3,4)`. Then write Python code to extract the
    element in the second row, fourth column. Use softcoding so that you can select
    different row/column indices. Print out a message like the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªç»ƒä¹ å°†å¸®åŠ©ä½ ç†Ÿæ‚‰çŸ©é˜µå…ƒç´ çš„ç´¢å¼•ã€‚ä½¿ç”¨ `np.arange(12).reshape(3,4)` åˆ›å»ºä¸€ä¸ª<math alttext="3 times
    4"><mrow><mn>3</mn> <mo>Ã—</mo> <mn>4</mn></mrow></math>çŸ©é˜µã€‚ç„¶åç¼–å†™ Python ä»£ç æå–ç¬¬äºŒè¡Œç¬¬å››åˆ—çš„å…ƒç´ ã€‚ä½¿ç”¨è½¯ç¼–ç ï¼Œä»¥ä¾¿å¯ä»¥é€‰æ‹©ä¸åŒçš„è¡Œ/åˆ—ç´¢å¼•ã€‚æ‰“å°å‡ºå¦‚ä¸‹æ¶ˆæ¯ï¼š
- en: '`The matrix element at index (2,4) is 7.`'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`çŸ©é˜µç´¢å¼• (2,4) å¤„çš„å…ƒç´ ä¸º 7ã€‚`'
- en: Exercise 5-2\.
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ç»ƒä¹  5-2ã€‚
- en: This and the following exercise focus on slicing matrices to obtain submatrices.
    Start by creating matrix <math alttext="bold upper C"><mi>ğ‚</mi></math> in [FigureÂ 5-6](#fig_5_6),
    and use Python slicing to extract the submatrix comprising the first five rows
    and five columns. Letâ€™s call this matrix <math alttext="bold upper C 1"><msub><mi>ğ‚</mi>
    <mn>1</mn></msub></math> . Try to reproduce [FigureÂ 5-6](#fig_5_6), but if you
    are struggling with the Python visualization coding, then just focus on extracting
    the submatrix correctly.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªå’Œæ¥ä¸‹æ¥çš„ç»ƒä¹ ä¸“æ³¨äºé€šè¿‡åˆ‡ç‰‡çŸ©é˜µè·å–å­çŸ©é˜µã€‚é¦–å…ˆåˆ›å»º [å›¾Â 5-6](#fig_5_6) ä¸­çš„çŸ©é˜µ <math alttext="bold upper
    C"><mi>ğ‚</mi></math>ï¼Œå¹¶ä½¿ç”¨ Python åˆ‡ç‰‡æå–ç”±å‰äº”è¡Œå’Œäº”åˆ—ç»„æˆçš„å­çŸ©é˜µã€‚æˆ‘ä»¬ç§°è¿™ä¸ªçŸ©é˜µä¸º <math alttext="bold
    upper C 1"><msub><mi>ğ‚</mi> <mn>1</mn></msub></math> ã€‚å°è¯•é‡ç° [å›¾Â 5-6](#fig_5_6)ï¼Œä½†å¦‚æœä½ åœ¨
    Python å¯è§†åŒ–ç¼–ç æ–¹é¢é‡åˆ°å›°éš¾ï¼Œé‚£ä¹ˆåªéœ€ä¸“æ³¨äºæ­£ç¡®æå–å­çŸ©é˜µå³å¯ã€‚
- en: '![Visualization of Exercise 5-2](assets/plad_0506.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![Exercise 5-2 çš„å¯è§†åŒ–](assets/plad_0506.png)'
- en: Figure 5-6\. Visualization of Exercise 5-2
  id: totrans-167
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾ 5-6ã€‚Exercise 5-2 çš„å¯è§†åŒ–
- en: Exercise 5-3\.
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ç»ƒä¹  5-3ã€‚
- en: Expand this code to extract the other four <math alttext="5 times 5"><mrow><mn>5</mn>
    <mo>Ã—</mo> <mn>5</mn></mrow></math> blocks. Then create a new matrix with those
    blocks reorganized according to [FigureÂ 5-7](#fig_5_7).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: å°†æ­¤ä»£ç æ‰©å±•ä¸ºæå–å…¶ä»–å››ä¸ª<math alttext="5 times 5"><mrow><mn>5</mn> <mo>Ã—</mo> <mn>5</mn></mrow></math>å—ã€‚ç„¶åæ ¹æ®
    [å›¾Â 5-7](#fig_5_7) é‡æ–°ç»„ç»‡è¿™äº›å—åˆ›å»ºä¸€ä¸ªæ–°çš„çŸ©é˜µã€‚
- en: '![Visualization of Exercise 5-3](assets/plad_0507.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![Exercise 5-3 çš„å¯è§†åŒ–](assets/plad_0507.png)'
- en: Figure 5-7\. Visualization of Exercise 5-3
  id: totrans-171
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾ 5-7ã€‚Exercise 5-3 çš„å¯è§†åŒ–
- en: Exercise 5-4\.
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ç»ƒä¹  5-4ã€‚
- en: Implement matrix addition element-wise using two `for` loops over rows and columns.
    What happens when you try to add two matrices with mismatching sizes? This exercise
    will help you think about breaking down a matrix into rows, columns, and individual
    elements.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ä¸¤ä¸ª`for`å¾ªç¯é€å…ƒç´ å®ç°çŸ©é˜µçš„é€å…ƒç´ åŠ æ³•ã€‚å½“å°è¯•å°†å¤§å°ä¸åŒ¹é…çš„ä¸¤ä¸ªçŸ©é˜µç›¸åŠ æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿè¿™ä¸ªç»ƒä¹ å°†å¸®åŠ©ä½ æ€è€ƒå¦‚ä½•å°†çŸ©é˜µåˆ†è§£ä¸ºè¡Œã€åˆ—å’Œå•ç‹¬çš„å…ƒç´ ã€‚
- en: Exercise 5-5\.
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ç»ƒä¹  5-5ã€‚
- en: 'Matrix addition and scalar multiplication obey the mathematical laws of commutivity
    and distributivity. That means that the following equations give the same results
    (assume that the matrices <math alttext="bold upper A"><mi>ğ€</mi></math> and <math
    alttext="bold upper B"><mi>ğ</mi></math> are the same size and that <math alttext="sigma"><mi>Ïƒ</mi></math>
    is some scalar):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: çŸ©é˜µåŠ æ³•å’Œæ ‡é‡ä¹˜æ³•éµå®ˆäº¤æ¢å’Œåˆ†é…çš„æ•°å­¦æ³•åˆ™ã€‚è¿™æ„å‘³ç€ä»¥ä¸‹æ–¹ç¨‹ç»™å‡ºç›¸åŒçš„ç»“æœï¼ˆå‡è®¾çŸ©é˜µ <math alttext="bold upper A"><mi>ğ€</mi></math>
    å’Œ <math alttext="bold upper B"><mi>ğ</mi></math> çš„å¤§å°ç›¸åŒï¼Œè€Œ <math alttext="sigma"><mi>Ïƒ</mi></math>
    æ˜¯æŸä¸ªæ ‡é‡ï¼‰ï¼š
- en: <math alttext="sigma left-parenthesis bold upper A plus bold upper B right-parenthesis
    equals sigma bold upper A plus sigma bold upper B equals bold upper A sigma plus
    bold upper B sigma" display="block"><mrow><mi>Ïƒ</mi> <mo>(</mo> <mi>ğ€</mi> <mo>+</mo>
    <mi>ğ</mi> <mo>)</mo> <mo>=</mo> <mi>Ïƒ</mi> <mi>ğ€</mi> <mo>+</mo> <mi>Ïƒ</mi> <mi>ğ</mi>
    <mo>=</mo> <mi>ğ€</mi> <mi>Ïƒ</mi> <mo>+</mo> <mi>ğ</mi> <mi>Ïƒ</mi></mrow></math>
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="sigma left-parenthesis bold upper A plus bold upper B right-parenthesis
    equals sigma bold upper A plus sigma bold upper B equals bold upper A sigma plus
    bold upper B sigma" display="block"><mrow><mi>Ïƒ</mi> <mo>(</mo> <mi>ğ€</mi> <mo>+</mo>
    <mi>ğ</mi> <mo>)</mo> <mo>=</mo> <mi>Ïƒ</mi> <mi>ğ€</mi> <mo>+</mo> <mi>Ïƒ</mi> <mi>ğ</mi>
    <mo>=</mo> <mi>ğ€</mi> <mi>Ïƒ</mi> <mo>+</mo> <mi>ğ</mi> <mi>Ïƒ</mi></mrow></math>
- en: Rather than proving this mathematically, you are going to demonstrate it through
    coding. In Python, create two random-numbers matrices of size <math alttext="3
    times 4"><mrow><mn>3</mn> <mo>Ã—</mo> <mn>4</mn></mrow></math> and a random scalar.
    Then implement the three expressions in the previous equation. Youâ€™ll need to
    figure out a way to confirm that the three results are equal. Keep in mind that
    tiny computer precision errors in the range of <math alttext="10 Superscript negative
    15"><msup><mn>10</mn> <mrow><mo>-</mo><mn>15</mn></mrow></msup></math> should
    be ignored.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å…¶é€šè¿‡æ•°å­¦æ–¹å¼è¯æ˜è¿™ä¸€ç‚¹ï¼Œä¸å¦‚é€šè¿‡ç¼–ç æ¥æ¼”ç¤ºã€‚åœ¨Pythonä¸­ï¼Œåˆ›å»ºä¸¤ä¸ªå¤§å°ä¸º <math alttext="3 times 4"><mrow><mn>3</mn>
    <mo>Ã—</mo> <mn>4</mn></mrow></math> çš„éšæœºæ•°å­—çŸ©é˜µå’Œä¸€ä¸ªéšæœºæ ‡é‡ã€‚ç„¶åå®ç°å‰è¿°æ–¹ç¨‹å¼ä¸­çš„ä¸‰ä¸ªè¡¨è¾¾å¼ã€‚ä½ éœ€è¦æ‰¾å‡ºä¸€ç§æ–¹æ³•æ¥ç¡®è®¤è¿™ä¸‰ä¸ªç»“æœæ˜¯å¦ç›¸ç­‰ã€‚è¯·è®°ä½ï¼Œå¿½ç•¥åœ¨
    <math alttext="10 Superscript negative 15"><msup><mn>10</mn> <mrow><mo>-</mo><mn>15</mn></mrow></msup></math>
    èŒƒå›´å†…çš„å¾®å°è®¡ç®—æœºç²¾åº¦è¯¯å·®ã€‚
- en: Exercise 5-6\.
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ç»ƒä¹  5-6ã€‚
- en: Code matrix multiplication using `for` loops. Confirm your results against using
    the numpy `@` operator. This exercise will help you solidify your understanding
    of matrix multiplication, but in practice, itâ€™s always better to use `@` instead
    of writing out a double `for` loop.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨`for`å¾ªç¯ç¼–å†™çŸ©é˜µä¹˜æ³•ä»£ç ã€‚å°†ç»“æœä¸ä½¿ç”¨numpyçš„`@`æ“ä½œç¬¦è¿›è¡Œç¡®è®¤ã€‚è¿™ä¸ªç»ƒä¹ å°†å¸®åŠ©ä½ å·©å›ºå¯¹çŸ©é˜µä¹˜æ³•çš„ç†è§£ï¼Œä½†åœ¨å®è·µä¸­ï¼Œæœ€å¥½ä½¿ç”¨`@`è€Œä¸æ˜¯ç¼–å†™åŒé‡`for`å¾ªç¯ã€‚
- en: Exercise 5-7\.
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ç»ƒä¹  5-7ã€‚
- en: 'Confirm the LIVE EVIL rule using the following five steps: (1) Create four
    matrices of random numbers, setting the sizes to be <math alttext="bold upper
    L element-of double-struck upper R Superscript 2 times 6"><mrow><mi>ğ‹</mi> <mo>âˆˆ</mo>
    <msup><mi>â„</mi> <mrow><mn>2</mn><mo>Ã—</mo><mn>6</mn></mrow></msup></mrow></math>
    , <math alttext="bold upper I element-of double-struck upper R Superscript 6 times
    3"><mrow><mi>ğˆ</mi> <mo>âˆˆ</mo> <msup><mi>â„</mi> <mrow><mn>6</mn><mo>Ã—</mo><mn>3</mn></mrow></msup></mrow></math>
    , <math alttext="bold upper V element-of double-struck upper R Superscript 3 times
    5"><mrow><mi>ğ•</mi> <mo>âˆˆ</mo> <msup><mi>â„</mi> <mrow><mn>3</mn><mo>Ã—</mo><mn>5</mn></mrow></msup></mrow></math>
    , and <math alttext="bold upper E element-of double-struck upper R Superscript
    5 times 2"><mrow><mi>ğ„</mi> <mo>âˆˆ</mo> <msup><mi>â„</mi> <mrow><mn>5</mn><mo>Ã—</mo><mn>2</mn></mrow></msup></mrow></math>
    . (2) Multiply the four matrices and transpose the product. (3) Transpose each
    matrix individually and multiply them *without reversing their order*. (4) Transpose
    each matrix individually and multiply them reversing their order *according to
    the LIVE EVIL rule*. Check whether the result of step 2 matches the results of
    step 3 and step 4\. (5) Repeat the previous steps but using all square matrices.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ç¡®è®¤ä½¿ç”¨ä»¥ä¸‹äº”ä¸ªæ­¥éª¤çš„LIVE EVILè§„åˆ™ï¼šï¼ˆ1ï¼‰åˆ›å»ºå››ä¸ªéšæœºæ•°çŸ©é˜µï¼Œè®¾ç½®å¤§å°åˆ†åˆ«ä¸º <math alttext="bold upper L element-of
    double-struck upper R Superscript 2 times 6"><mrow><mi>ğ‹</mi> <mo>âˆˆ</mo> <msup><mi>â„</mi>
    <mrow><mn>2</mn><mo>Ã—</mo><mn>6</mn></mrow></msup></mrow></math> ï¼Œ<math alttext="bold
    upper I element-of double-struck upper R Superscript 6 times 3"><mrow><mi>ğˆ</mi>
    <mo>âˆˆ</mo> <msup><mi>â„</mi> <mrow><mn>6</mn><mo>Ã—</mo><mn>3</mn></mrow></msup></mrow></math>
    ï¼Œ<math alttext="bold upper V element-of double-struck upper R Superscript 3 times
    5"><mrow><mi>ğ•</mi> <mo>âˆˆ</mo> <msup><mi>â„</mi> <mrow><mn>3</mn><mo>Ã—</mo><mn>5</mn></mrow></msup></mrow></math>
    å’Œ <math alttext="bold upper E element-of double-struck upper R Superscript 5 times
    2"><mrow><mi>ğ„</mi> <mo>âˆˆ</mo> <msup><mi>â„</mi> <mrow><mn>5</mn><mo>Ã—</mo><mn>2</mn></mrow></msup></mrow></math>
    ã€‚ï¼ˆ2ï¼‰å°†å››ä¸ªçŸ©é˜µç›¸ä¹˜å¹¶è½¬ç½®ä¹˜ç§¯ã€‚ï¼ˆ3ï¼‰åˆ†åˆ«è½¬ç½®æ¯ä¸ªçŸ©é˜µå¹¶å°†å®ƒä»¬ç›¸ä¹˜ï¼Œ*ä¸åè½¬å®ƒä»¬çš„é¡ºåº*ã€‚ï¼ˆ4ï¼‰åˆ†åˆ«è½¬ç½®æ¯ä¸ªçŸ©é˜µå¹¶å°†å®ƒä»¬ç›¸ä¹˜ï¼Œ*æŒ‰ç…§LIVE EVILè§„åˆ™åè½¬å®ƒä»¬çš„é¡ºåº*ã€‚æ£€æŸ¥æ­¥éª¤2çš„ç»“æœæ˜¯å¦ä¸æ­¥éª¤3å’Œæ­¥éª¤4çš„ç»“æœç›¸åŒ¹é…ã€‚ï¼ˆ5ï¼‰é‡å¤å‰é¢çš„æ­¥éª¤ï¼Œä½†ä½¿ç”¨æ‰€æœ‰æ–¹é˜µã€‚
- en: Exercise 5-8\.
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ç»ƒä¹  5-8ã€‚
- en: In this exercise, you will write a Python function that checks whether a matrix
    is symmetric. It should take a matrix as input, and should output a boolean `True`
    if the matrix is symmetric or `False` if the matrix is nonsymmetric. Keep in mind
    that small computer rounding/precision errors can make â€œequalâ€ matrices appear
    unequal. Therefore, you will need to test for equality with some reasonable tolerance.
    Test the function on symmetric and nonsymmetric matrices.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªç»ƒä¹ ä¸­ï¼Œä½ å°†ç¼–å†™ä¸€ä¸ªPythonå‡½æ•°æ¥æ£€æŸ¥ä¸€ä¸ªçŸ©é˜µæ˜¯å¦å¯¹ç§°ã€‚å®ƒåº”è¯¥æ¥å—ä¸€ä¸ªçŸ©é˜µä½œä¸ºè¾“å…¥ï¼Œå¹¶ä¸”å¦‚æœçŸ©é˜µæ˜¯å¯¹ç§°çš„ï¼Œåˆ™è¾“å‡ºå¸ƒå°”å€¼`True`ï¼Œå¦‚æœçŸ©é˜µæ˜¯éå¯¹ç§°çš„ï¼Œåˆ™è¾“å‡ºå¸ƒå°”å€¼`False`ã€‚è¯·è®°ä½ï¼Œç”±äºè®¡ç®—æœºå°çš„èˆå…¥/ç²¾åº¦è¯¯å·®å¯èƒ½ä½¿â€œç›¸ç­‰â€çš„çŸ©é˜µçœ‹èµ·æ¥ä¸ç›¸ç­‰ã€‚å› æ­¤ï¼Œä½ éœ€è¦æµ‹è¯•ä¸€äº›åˆç†çš„å®¹å·®æ¥åˆ¤æ–­æ˜¯å¦ç›¸ç­‰ã€‚åœ¨å¯¹ç§°å’Œéå¯¹ç§°çŸ©é˜µä¸Šæµ‹è¯•è¯¥å‡½æ•°ã€‚
- en: Exercise 5-9\.
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ç»ƒä¹  5-9ã€‚
- en: 'I mentioned that there is an additive method for creating a symmetric matrix
    from a nonsymmetric square matrix. The method is quite simple: average the matrix
    with its transpose. Implement this algorithm in Python and confirm that the result
    really is symmetric. (Hint: you can use the function you wrote in the previous
    exercise!)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘æåˆ°äº†ä»éå¯¹ç§°æ–¹é˜µåˆ›å»ºå¯¹ç§°çŸ©é˜µçš„ä¸€ç§åŠ æ³•æ–¹æ³•ã€‚è¿™ç§æ–¹æ³•éå¸¸ç®€å•ï¼šç”¨çŸ©é˜µä¸å…¶è½¬ç½®çš„å¹³å‡å€¼ã€‚åœ¨Pythonä¸­å®ç°è¿™ä¸ªç®—æ³•ï¼Œå¹¶ç¡®è®¤ç»“æœç¡®å®æ˜¯å¯¹ç§°çš„ã€‚ï¼ˆæç¤ºï¼šä½ å¯ä»¥ä½¿ç”¨å‰ä¸€ä¸ªç»ƒä¹ ä¸­ç¼–å†™çš„å‡½æ•°ï¼ï¼‰
- en: Exercise 5-10\.
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ç»ƒä¹  5-10\.
- en: Repeat the second part of [Exercise 3-3](ch03.xhtml#exercise_3_3) (the two vectors
    in <math alttext="double-struck upper R cubed"><msup><mi>â„</mi> <mn>3</mn></msup></math>
    ), but use matrix-vector multiplication instead of vector-scalar multiplication.
    That is, compute <math alttext="bold upper A bold s"><mrow><mi>ğ€</mi> <mi>ğ¬</mi></mrow></math>
    instead of <math alttext="sigma 1 bold v 1 plus sigma 2 bold v 2"><mrow><msub><mi>Ïƒ</mi>
    <mn>1</mn></msub> <msub><mi>ğ¯</mi> <mn>1</mn></msub> <mo>+</mo> <msub><mi>Ïƒ</mi>
    <mn>2</mn></msub> <msub><mi>ğ¯</mi> <mn>2</mn></msub></mrow></math> .
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: é‡å¤ç¬¬äºŒéƒ¨åˆ†çš„ [Exercise 3-3](ch03.xhtml#exercise_3_3) ï¼ˆ<math alttext="double-struck
    upper R cubed"><msup><mi>â„</mi> <mn>3</mn></msup></math> ä¸­çš„ä¸¤ä¸ªå‘é‡ï¼‰ï¼Œä½†ä½¿ç”¨çŸ©é˜µ-å‘é‡ä¹˜æ³•ä»£æ›¿å‘é‡-æ ‡é‡ä¹˜æ³•ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œè®¡ç®—
    <math alttext="bold upper A bold s"><mrow><mi>ğ€</mi> <mi>ğ¬</mi></mrow></math>
    è€Œä¸æ˜¯ <math alttext="sigma 1 bold v 1 plus sigma 2 bold v 2"><mrow><msub><mi>Ïƒ</mi>
    <mn>1</mn></msub> <msub><mi>ğ¯</mi> <mn>1</mn></msub> <mo>+</mo> <msub><mi>Ïƒ</mi>
    <mn>2</mn></msub> <msub><mi>ğ¯</mi> <mn>2</mn></msub></mrow></math> ã€‚
- en: Exercise 5-11\.
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ç»ƒä¹  5-11\.
- en: 'Diagonal matrices have many interesting properties that make them useful to
    work with. In this exercise, you will learn about two of those properties:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹è§’çŸ©é˜µå…·æœ‰è®¸å¤šæœ‰è¶£çš„ç‰¹æ€§ï¼Œä½¿å®ƒä»¬åœ¨å·¥ä½œä¸­éå¸¸æœ‰ç”¨ã€‚åœ¨è¿™ä¸ªç»ƒä¹ ä¸­ï¼Œä½ å°†å­¦ä¹ å…¶ä¸­ä¸¤ä¸ªæ€§è´¨ï¼š
- en: Premultiplying by a diagonal matrix scales the rows of the right matrix by the
    corresponding diagonal elements.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: é€šè¿‡å¯¹è§’çŸ©é˜µçš„é¢„ä¹˜ï¼Œå¯ä»¥å°†å³çŸ©é˜µçš„è¡ŒæŒ‰ç…§å¯¹åº”çš„å¯¹è§’å…ƒç´ è¿›è¡Œç¼©æ”¾ã€‚
- en: Postmultiplying by a diagonal matrix scales the columns of the left matrix by
    the corresponding diagonal elements.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åä¹˜ä¸€ä¸ªå¯¹è§’çŸ©é˜µå¯ä»¥å°†å·¦çŸ©é˜µçš„åˆ—æŒ‰ç…§å¯¹åº”çš„å¯¹è§’å…ƒç´ è¿›è¡Œç¼©æ”¾ã€‚
- en: This fact is used in several applications, including computing correlation matrices
    ([ChapterÂ 7](ch07.xhtml#Chapter_7)) and diagonalizing a matrix (Chapters [13](ch13.xhtml#Chapter_13)
    and [14](ch14.xhtml#Chapter_14)).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªäº‹å®è¢«ç”¨åœ¨å¤šä¸ªåº”ç”¨ä¸­ï¼ŒåŒ…æ‹¬è®¡ç®—ç›¸å…³çŸ©é˜µï¼ˆ[ç¬¬Â 7Â ç« ](ch07.xhtml#Chapter_7)ï¼‰å’ŒçŸ©é˜µå¯¹è§’åŒ–ï¼ˆç¬¬ [13](ch13.xhtml#Chapter_13)
    å’Œ [14](ch14.xhtml#Chapter_14) ç« ï¼‰ã€‚
- en: 'Letâ€™s explore an implication of this property. Start by creating three <math
    alttext="4 times 4"><mrow><mn>4</mn> <mo>Ã—</mo> <mn>4</mn></mrow></math> matrices:
    a matrix of all ones (hint: `np.ones()`); a diagonal matrix where the diagonal
    elements are 1, 4, 9, and 16; and a diagonal matrix equal to the square root of
    the previous diagonal matrix.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æ¢è®¨è¿™ä¸ªå±æ€§çš„ä¸€ä¸ªæ¨è®ºã€‚é¦–å…ˆåˆ›å»ºä¸‰ä¸ª <math alttext="4 times 4"><mrow><mn>4</mn> <mo>Ã—</mo>
    <mn>4</mn></mrow></math> çŸ©é˜µï¼šä¸€ä¸ªå…¨ä¸º1çš„çŸ©é˜µï¼ˆæç¤ºï¼š`np.ones()`ï¼‰ï¼›ä¸€ä¸ªå¯¹è§’å…ƒç´ ä¸º1, 4, 9 å’Œ 16 çš„å¯¹è§’çŸ©é˜µï¼›ä»¥åŠä¸€ä¸ªä¸å‰ä¸€ä¸ªå¯¹è§’çŸ©é˜µçš„å¹³æ–¹æ ¹ç›¸ç­‰çš„å¯¹è§’çŸ©é˜µã€‚
- en: 'Next, print out the pre- and postmultiplied ones matrix by the first diagonal
    matrix. Youâ€™ll get the following results:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: æ¥ä¸‹æ¥ï¼Œæ‰“å°å‡ºç”±ç¬¬ä¸€ä¸ªå¯¹è§’çŸ©é˜µé¢„ä¹˜å’Œåä¹˜çš„å•ä½çŸ©é˜µã€‚ä½ å°†å¾—åˆ°ä»¥ä¸‹ç»“æœï¼š
- en: '[PRE8]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, premultiply *and* postmultiply the ones matrix by the square root
    of the diagonal matrix. Youâ€™ll get the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œé€šè¿‡å¯¹è§’çŸ©é˜µçš„å¹³æ–¹æ ¹è¿›è¡Œé¢„ä¹˜å’Œåä¹˜å•ä½çŸ©é˜µã€‚ä½ å°†å¾—åˆ°ä»¥ä¸‹ç»“æœï¼š
- en: '[PRE9]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that the rows *and* the columns are scaled such that the (*i*,*j*)th
    element in the matrix is multiplied by the product of the *i*th and *j*th diagonal
    elements. (In fact, weâ€™ve created a multiplication table!)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œè¡Œå’Œåˆ—éƒ½è¢«ç¼©æ”¾ï¼Œä»¥ä¾¿çŸ©é˜µä¸­çš„ï¼ˆ*i*,*j*ï¼‰å…ƒç´ ä¹˜ä»¥ç¬¬ *i* å’Œ *j* å¯¹è§’å…ƒç´ çš„ä¹˜ç§¯ã€‚ï¼ˆå®é™…ä¸Šï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªä¹˜æ³•è¡¨ï¼ï¼‰
- en: Exercise 5-12\.
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ç»ƒä¹  5-12\.
- en: 'Another fun fact: matrix multiplication is the same thing as Hadamard multiplication
    for two diagonal matrices. Figure out why this is using paper and pencil with
    two <math alttext="3 times 3"><mrow><mn>3</mn> <mo>Ã—</mo> <mn>3</mn></mrow></math>
    diagonal matrices, and then illustrate it in Python code.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: å¦ä¸€ä¸ªæœ‰è¶£çš„äº‹å®æ˜¯ï¼šå¯¹äºä¸¤ä¸ªå¯¹è§’çŸ©é˜µï¼ŒçŸ©é˜µä¹˜æ³•ä¸å“ˆè¾¾ç›å¾·ä¹˜ç§¯æ˜¯ç›¸åŒçš„ã€‚ä½¿ç”¨çº¸å’Œé“…ç¬”æ¥ç†è§£ä¸ºä»€ä¹ˆï¼Œç„¶åç”¨Pythonä»£ç æ¥è¯´æ˜ã€‚
- en: ^([1](ch05.xhtml#idm45733310025872-marker)) There are more special matrices
    that you will learn about later in the book, but this list is enough to get started.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch05.xhtml#idm45733310025872-marker)) ä¹¦ä¸­è¿˜ä¼šä»‹ç»æ›´å¤šç‰¹æ®ŠçŸ©é˜µï¼Œä½†è¿™ä¸ªåˆ—è¡¨è¶³ä»¥å¸®åŠ©å…¥é—¨ã€‚
- en: ^([2](ch05.xhtml#idm45733309424816-marker)) Put the coefficients into a row
    vector and premultiply.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch05.xhtml#idm45733309424816-marker)) å°†ç³»æ•°æ”¾å…¥è¡Œå‘é‡ä¸­ï¼Œå¹¶è¿›è¡Œé¢„ä¹˜ã€‚
- en: ^([3](ch05.xhtml#idm45733312589280-marker)) Nothing. NumPy will return the same
    1D array without altering it, and without giving a warning or error.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch05.xhtml#idm45733312589280-marker)) ä»€ä¹ˆä¹Ÿä¸åšã€‚NumPy å°†è¿”å›ç›¸åŒçš„ 1D æ•°ç»„ï¼Œä¸ä¼šå¯¹å…¶è¿›è¡Œä¿®æ”¹ï¼Œä¹Ÿä¸ä¼šç»™å‡ºè­¦å‘Šæˆ–é”™è¯¯ã€‚
- en: ^([4](ch05.xhtml#idm45733312413120-marker)) LIVE EVIL is a cute mnemonic, not
    a recommendation for how to behave in society!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch05.xhtml#idm45733312413120-marker)) LIVE EVIL æ˜¯ä¸€ä¸ªå¯çˆ±çš„è®°å¿†æ³•ï¼Œè€Œä¸æ˜¯ç¤¾ä¼šè¡Œä¸ºå»ºè®®ï¼
