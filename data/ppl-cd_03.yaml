- en: 2 Pipeline as code with Jenkins
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 使用 Jenkins 的管道作为代码
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: How pipeline as code works with Jenkins
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道作为代码如何与 Jenkins 一起工作
- en: An overview of Jenkinsfile structure and syntax
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkinsfile 结构和语法的概述
- en: Introduction to Blue Ocean, the new Jenkins user experience
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blue Ocean 的新 Jenkins 用户体验介绍
- en: Declarative versus scripted Jenkins pipelines
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明式与脚本式 Jenkins 管道
- en: Integration of a GitFlow model within Jenkins projects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Jenkins 项目中集成 GitFlow 模型
- en: Tips for productivity and efficiency while writing Jenkinsfiles for complex
    CI/CD pipelines
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编写复杂的 CI/CD 管道 Jenkinsfile 时的生产力和效率技巧
- en: There’s no doubt that cloud computing has had a major impact on the way companies
    build, scale, and maintain technology products. The ability to click a few buttons
    to provision machines, databases, and other infrastructure has led to an increase
    in developer productivity we’ve never seen before.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，云计算对公司在构建、扩展和维护技术产品的方式产生了重大影响。只需点击几个按钮就能配置机器、数据库和其他基础设施的能力，导致了我们以前从未见过的开发者生产力的提升。
- en: While it was easy to spin up simple cloud architectures, mistakes can easily
    be made while provisioning complex ones. Human error will always be present, especially
    when you can launch cloud infrastructure by clicking buttons on the cloud provider’s
    web console.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然启动简单的云架构很容易，但在配置复杂的云架构时，错误很容易发生。人为错误始终存在，尤其是在你可以通过点击云提供商网页控制台上的按钮来启动云基础设施的情况下。
- en: The only way to avoid these kinds of errors is through automation, and infrastructure
    as code (IaC) is helping engineers automatically launch cloud environments quickly
    and without mistakes. The growth of DevOps and the adoption of its practices have
    led to more tooling that can implement the IaC paradigm to a larger degree.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这些错误的方法是通过自动化，而基础设施即代码 (IaC) 正在帮助工程师快速且无错误地自动启动云环境。DevOps 的增长和对其实践的采用导致了更多工具可以更大程度地实现
    IaC 范式。
- en: In the past, setting up CI/CD workflow has been a manual process. It was commonly
    done via defining a series of individual jobs for the various pipeline tasks.
    Each job was configured via web forms—filling in text boxes, selecting entries
    from drop-down lists, and so forth. And then the series of jobs were strung together,
    each triggering the next, into a pipeline.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，设置 CI/CD 工作流程一直是一个手动过程。通常是通过定义一系列针对各种管道任务的独立作业来完成的。每个作业都是通过网页表单配置的——填写文本框、从下拉列表中选择条目等等。然后，这些作业系列被串联起来，每个作业触发下一个作业，形成一个管道。
- en: Jenkins somewhat lagged in this area until the release of Jenkins 2\. Although
    widely used and a primary workflow tool for creating CI/CD pipelines, this way
    of creating and connecting Jenkins jobs to form a pipeline was challenging. It
    did not meet the definition of IaC. Job configurations were stored only as Extensible
    Markup Language (XML) files within the Jenkins configuration area. This meant
    that the files were not easily readable or directly modifiable. And the Jenkins
    application itself provided the user’s primary view and access to them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jenkins 2 发布之前，Jenkins 在这个领域有些落后。尽管它被广泛使用，并且是创建 CI/CD 管道的首选工作流程工具，但这种方式创建和连接
    Jenkins 作业以形成一个管道具有挑战性。它不符合 IaC 的定义。作业配置仅以可扩展标记语言 (XML) 文件的形式存储在 Jenkins 配置区域中。这意味着文件不易阅读或直接修改。Jenkins
    应用程序本身提供了用户的主要视图和访问方式。
- en: Note Jenkins 2 is the name we are generally applying to newer versions that
    support the pipeline-as-code functionality, as well as other features.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Jenkins 2 是我们通常用于指代支持 pipeline-as-code 功能以及其他新特性的新版本的名称。
- en: Because it’s an important part of each project, the pipeline configuration should
    be managed as code and rolled out automatically. This also allows us to manage
    the pipeline itself, applying the same standards that apply to application code.
    That’s where pipeline as code comes into play.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是每个项目的重要部分，因此管道配置应作为代码进行管理并自动部署。这也允许我们管理管道本身，应用适用于应用程序代码的相同标准。这就是管道作为代码发挥作用的地方。
- en: 2.1 Introducing the Jenkinsfile
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 介绍 Jenkinsfile
- en: '*Pipeline* *as code* (PaC) describes a set of features that allow Jenkins users
    to define pipelined job processes with code, stored and versioned in a source
    repository. These features allow Jenkins to discover, manage, and run jobs for
    multiple source repositories and branches—eliminating the need for manual job
    creation and management.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*管道* *作为代码* (PaC) 描述了一组功能，允许 Jenkins 用户使用代码定义管道作业过程，这些代码存储和版本化在源代码仓库中。这些功能允许
    Jenkins 发现、管理和运行多个源代码仓库和分支的作业—消除了手动创建和管理作业的需求。'
- en: 'PaC helps you automate the CI/CD workflows in a repeatable, consistent manner,
    which has many benefits:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: PaC 帮助您以可重复、一致的方式自动化 CI/CD 工作流程，这带来了许多好处：
- en: '*Speed*—You can quickly and easily write a CI/CD workflow for sandbox, staging,
    and production environments, which can help you deliver your product on time.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*速度*—您可以快速轻松地为沙盒、预发布和生产环境编写 CI/CD 工作流程，这有助于您按时交付产品。'
- en: '*Consistency*—PaC completely standardizes the setup of CI/CD, so there’s a
    reduced possibility of any human errors or deviations.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一致性*—PaC 完全标准化了 CI/CD 的设置，因此减少了任何人为错误或偏差的可能性。'
- en: '*Risk management*—Because the pipeline can be version-controlled, PaC allows
    every change to your CI/CD workflow to be documented, logged, tracked, and tested
    just like application code. Hence, you can revert to a working version in case
    of failure.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*风险管理*—由于管道可以进行版本控制，PaC 允许记录、日志记录、跟踪和测试您 CI/CD 工作流程中的每个更改，就像应用程序代码一样。因此，在出现故障的情况下，您可以回滚到工作版本。'
- en: '*Efficiency*—It minimizes the introduction of human errors and helps your application’s
    deployment run more smoothly.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*效率*—它最小化了人为错误的发生，并有助于您的应用程序部署更加顺畅。'
- en: 'The bottom line is simple: adopting the PaC paradigm will create a culture
    that generates better software, and will save you a lot of money, time, and headaches
    trying to implement complex CI/CD workflows through UIs and web forms. So how
    does PaC work with Jenkins?'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 核心是简单的：采用 PaC 范式将创造一种产生更好软件的文化，并将节省您大量金钱、时间和因通过 UI 和网页表单实施复杂的 CI/CD 工作流程而带来的头痛。那么
    PaC 是如何与 Jenkins 一起工作的呢？
- en: To use PaC with Jenkins, projects must contain a file named Jenkinsfile in the
    code repository top-level folder. This template file contains a set of instructions,
    or steps, called *stages* that will be executed on Jenkins every time the development
    team pushes a new feature to the code repository. Because Jenkinsfile is living
    along with the source code, we can always pull, edit, and push the Jenkinsfile
    within source control, just as we would for any other file. We can also do things
    like code reviews on the pipeline script.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 PaC 与 Jenkins 一起使用，项目必须在代码仓库顶层文件夹中包含一个名为 Jenkinsfile 的文件。此模板文件包含一组指令或步骤，称为
    *阶段*，每次开发团队将新功能推送到代码仓库时，都会在 Jenkins 上执行。由于 Jenkinsfile 与源代码一起生活，我们可以像对任何其他文件一样，始终在源代码控制中拉取、编辑和推送
    Jenkinsfile。我们还可以对管道脚本进行代码审查。
- en: Jenkinsfile uses a domain-specific language (DSL) based on the Groovy programming
    language to define the entire CI/CD workflow. Figure 2.1 is an example of a classic
    CI/CD workflow.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkinsfile 使用基于 Groovy 编程语言的领域特定语言 (DSL) 来定义整个 CI/CD 工作流程。图 2.1 是一个经典 CI/CD
    工作流程的示例。
- en: '![](Images/CH02_F01_Labouardy.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH02_F01_Labouardy.png)'
- en: Figure 2.1 CI/CD workflow
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 CI/CD 工作流程
- en: Those phases can be described in a Jenkinsfile by using the `stage` keyword.
    A *stage* is a block that contains a series of steps. It can be used to visualize
    the pipeline process. The following listing is an example of a simple Jenkinsfile
    for figure 2.1.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些阶段可以使用 `stage` 关键字在 Jenkinsfile 中描述。*阶段*是一个包含一系列步骤的块。它可以用来可视化管道过程。以下列表是用于图
    2.1 的简单 Jenkinsfile 的示例。
- en: Listing 2.1 Jenkinsfile stages
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.1 Jenkinsfile 阶段
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We’ll dive deep into the syntax in the next chapter, but for now, let’s focus
    on what the stages are doing:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章深入探讨语法，但就目前而言，让我们关注阶段正在做什么：
- en: '*Checkout*—Pulls the latest changes from the source code repository, which
    can be GitHub, Bitbucket, Mercurial, or any SCM.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检出*—从源代码仓库拉取最新更改，这些仓库可以是 GitHub、Bitbucket、Mercurial 或任何源代码管理工具。'
- en: '*Quality tests*—Contains instructions on how to execute static code analysis
    to measure code quality, and identify bugs, vulnerabilities, and code smell. It
    can be automated by integrating external tools like SonarQube to fix code-quality
    violations and reduce technical debt.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*质量测试*—包含执行静态代码分析以衡量代码质量、识别错误、漏洞和代码问题的说明。可以通过集成外部工具（如 SonarQube）来自动化修复代码质量违规行为并减少技术债务。'
- en: '*Unit tests*—In this stage, unit tests are executed. If tests are successful,
    a code coverage report will be generated that can be consumed by Jenkins plugins
    to show a visual overview of the project’s health and keep track of the code coverage
    metrics as your project grows. Code coverage can be an indication of how much
    your application code is executed during your tests, and can give some indication
    as to how well your team is applying good testing practices such test-driven development
    (TDD) or behavior-driven development (BDD).'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单元测试*——在这个阶段，将执行单元测试。如果测试成功，将生成一个代码覆盖率报告，该报告可以被Jenkins插件消费，以显示项目的健康状况的可视概述，并跟踪随着项目增长而变化的代码覆盖率指标。代码覆盖率可以表明您的应用程序代码在测试期间执行的程度，并可以提供一些关于您的团队是否应用了良好的测试实践（如测试驱动开发（TDD）或行为驱动开发（BDD））的指示。'
- en: '*Security tests*—Responsible for identifying project dependencies and checks
    if any known, publicly disclosed vulnerabilities exist. A security report will
    be published with the total number of findings grouped by severity (critical,
    high, medium, or low). A well-known open source Jenkins plugin is OWASP Dependency-Check
    ([http://mng.bz/MvR7](https://shortener.manning.com/MvR7)).'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安全测试*——负责识别项目依赖项并检查是否存在任何已知、公开披露的漏洞。将发布一个安全报告，其中包含按严重程度（关键、高、中、低）分组的发现总数。一个著名的开源Jenkins插件是OWASP
    Dependency-Check ([http://mng.bz/MvR7](https://shortener.manning.com/MvR7))。'
- en: '*Build*—In this phase, the needed dependencies will be installed, the source
    code will be compiled, and an artifact will be built (Docker image, zip file,
    Maven JAR, and so forth).'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*构建*——在这个阶段，将安装所需的依赖项，编译源代码，并构建一个工件（Docker镜像、zip文件、Maven JAR等）。'
- en: '*Push*—The artifact built in the previous stage will be versioned and stored
    in a remote repository.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*推送*——前一个阶段构建的工件将被版本化并存储在远程仓库中。'
- en: '*Deploy*—In this stage, the artifact will be deployed to a sandbox/testing
    environment for quality assurance or to production after the user has approved
    the deployment.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*部署*——在这个阶段，工件将被部署到沙盒/测试环境进行质量保证，或者用户批准部署后部署到生产环境。'
- en: '*Acceptance tests*—After the changes are deployed, a series of smoke and validation
    tests will be executed against the deployed application to verify that the application
    is running as expected. The tests can be simple health checks with cURL commands
    or sophisticated API calls.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*验收测试*——更改部署后，将执行一系列的烟雾测试和验证测试，以验证部署的应用程序是否按预期运行。这些测试可以是简单的健康检查，使用cURL命令，或者复杂的API调用。'
- en: If any of these stages throws an exception or error, the pipeline build’s status
    will be set to fail. This default behavior can be overridden by using `try-catch`
    blocks. The `finally` block can be used to clean up the Jenkins workspace (temporary
    files or build packages) or to execute post-script commands such as sending Slack
    notifications to alert the development team about the build status.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些阶段中的任何一个抛出异常或错误，管道构建的状态将被设置为失败。这种默认行为可以通过使用`try-catch`块来覆盖。`finally`块可以用来清理Jenkins工作空间（临时文件或构建包）或执行后脚本命令，例如向开发团队发送Slack通知以提醒构建状态。
- en: Note Don’t worry if you don’t completely understand the steps of the Jenkinsfile
    in listing 2.1\. You will get an in-depth explanation of how to implement each
    stage in chapters 7, 8, and 9.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果您不完全理解列表2.1中Jenkinsfile的步骤，请不要担心。您将在第7、8和9章中深入解释如何实现每个阶段。
- en: One of the things that makes Jenkins a leader when it comes to CI tools is the
    ecosystem behind it. You can customize your Jenkins instance with free open source
    plugins. A must-have plugin is Pipeline Stage View ([https://plugins.jenkins.io/pipeline-rest-api](https://plugins.jenkins.io/pipeline-rest-api)),
    shown in figure 2.2\. It allows you to have a visualization of your pipeline stages.
    This plugin is handy when you have complex build pipelines and want to track the
    progress of each stage.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到CI工具时，使Jenkins成为领导者之一的因素是其背后的生态系统。您可以使用免费的开源插件自定义您的Jenkins实例。一个必备的插件是Pipeline
    Stage View ([https://plugins.jenkins.io/pipeline-rest-api](https://plugins.jenkins.io/pipeline-rest-api))，如图2.2所示。它允许您可视化您的管道阶段。当您有复杂的构建管道并希望跟踪每个阶段的进度时，这个插件非常方便。
- en: The pipeline output is organized as a matrix, with each row representing a run
    of the job, and each column mapped to a defined stage in the pipeline. When you
    run some builds, the stage view will appear with Checkout, Quality Test, Unit
    Test, Security Test, Build, Push, and Deploy columns, and one row per build showing
    the status of those stages. When hovering over a stage cell, you can click the
    Logs button to see log messages printed in that stage.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 管道输出被组织成一个矩阵，每一行代表一个作业的运行，每一列映射到管道中定义的阶段。当你运行一些构建时，阶段视图将显示Checkout（检出）、Quality
    Test（质量测试）、Unit Test（单元测试）、Security Test（安全测试）、Build（构建）、Push（推送）和Deploy（部署）列，每行显示这些阶段的状态。当鼠标悬停在阶段单元格上时，你可以点击日志按钮来查看在该阶段打印的日志消息。
- en: Note Part 3 of this book covers how to create a Jenkins job and define a pipeline
    like the one in figure 2.2.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本书的第三部分介绍了如何创建Jenkins作业并定义如图2.2所示的管道。
- en: '![](Images/CH02_F02_Labouardy.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH02_F02_Labouardy.png)'
- en: Figure 2.2 Jenkins Pipeline Stage View
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 Jenkins Pipeline阶段视图
- en: You can take this UI further and install the Blue Ocean plugin ([https://plugins.jenkins.io/blueocean/](https://plugins.jenkins.io/blueocean/))
    to have a fast and intuitive comprehension of the CI/CD stages, as shown in figure
    2.3\. This plugin requires Jenkins version 2.7 or later.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这个UI进一步扩展，并安装Blue Ocean插件([https://plugins.jenkins.io/blueocean/](https://plugins.jenkins.io/blueocean/))，以便快速直观地理解CI/CD阶段，如图2.3所示。此插件需要Jenkins版本2.7或更高版本。
- en: '![](Images/CH02_F03_Labouardy.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH02_F03_Labouardy.png)'
- en: Figure 2.3 Blue Ocean plugin’s detailed view of the pipeline
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 Blue Ocean插件对管道的详细视图
- en: Note Chapter 5 covers how to install and configure the Jenkins Blue Ocean plugin.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：第5章介绍了如何安装和配置Jenkins Blue Ocean插件。
- en: 2.1.1 Blue Ocean plugin
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1 Blue Ocean插件
- en: You can also troubleshoot pipeline failure by clicking the stage in red to easily
    identify the problem without going through thousands of output logs.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过点击红色的阶段来排查管道故障，轻松识别问题，而无需查看数千个输出日志。
- en: One of the big concerns while choosing Jenkins is the user interface, which
    many users consider outdated, unintuitive, and hard to navigate when you have
    many projects. That’s why the Jenkins core team launched Blue Ocean in April 2017
    for a new, modern Jenkins user experience.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择Jenkins时，用户界面是一个很大的担忧，许多用户认为它过时、不直观，当有多个项目时很难导航。这就是为什么Jenkins核心团队在2017年4月推出了Blue
    Ocean，为Jenkins提供了一个新的、现代的用户体验。
- en: Blue Ocean is a new user experience for Jenkins, based on a modern design that
    allows users to graphically create, personalize, visualize, and diagnose CD pipelines.
    It comes bundled with the Jenkins Pipeline plugin or as a separate plugin ([www.jenkins.io/doc/book/blueocean/getting-started/](http://www.jenkins.io/doc/book/blueocean/getting-started/)).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Blue Ocean是基于现代设计的新Jenkins用户体验，它允许用户图形化创建、个性化、可视化和诊断CD管道。它捆绑了Jenkins Pipeline插件，或作为单独的插件提供([www.jenkins.io/doc/book/blueocean/getting-started/](http://www.jenkins.io/doc/book/blueocean/getting-started/))。
- en: Note The Jenkins Classic UI exists side-by-side at its usual place at JENKINS_
    URL/jenkins. The Blue Ocean plugin is available by appending `/blue` to the end
    of the Jenkins server URL.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Jenkins经典UI与其通常的JENKINS_URL/jenkins位置并排存在。Blue Ocean插件可以通过在Jenkins服务器URL末尾附加`/blue`来获取。
- en: Anyone in your team can create a CI/CD pipeline with just several clicks. Blue
    Ocean has seamless integration with Git and GitHub. It prompts you for credentials
    to access your repositories on the Git server in order to create pipelines based
    on those repositories (figure 2.4).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你的团队中的任何人都可以通过几步点击创建一个CI/CD管道。Blue Ocean与Git和GitHub无缝集成。它提示你输入凭证以访问Git服务器上的存储库，以便根据这些存储库创建管道（图2.4）。
- en: '![](Images/CH02_F04_Labouardy.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH02_F04_Labouardy.png)'
- en: Figure 2.4 New pipeline in Blue Ocean mode
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 Blue Ocean模式中的新管道
- en: You can also create a complete CI/CD pipeline from start to finish by using
    the intuitive and visual pipeline editor (figure 2.5). It’s a great way to write
    pipeline prototypes and debug pipeline stages before generating a working Jenkinsfile.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用直观的视觉管道编辑器（图2.5）从头到尾创建一个完整的CI/CD管道。这是一种编写管道原型和调试管道阶段的好方法，在生成可工作的Jenkinsfile之前。
- en: '![](Images/CH02_F05_Labouardy.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH02_F05_Labouardy.png)'
- en: Figure 2.5 Defining stages with pipeline editor
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 使用管道编辑器定义阶段
- en: Any pipeline created with the visual editor can also be edited in your favorite
    text editor, bringing all the benefits of PaC. Figure 2.6 shows an example of
    the pipeline script generated by pressing Ctrl-S for Windows users and Command-S
    for macOS users.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可视化编辑器创建的任何管道都可以在您喜欢的文本编辑器中进行编辑，从而带来 PaC 的所有好处。图 2.6 展示了 Windows 用户按 Ctrl-S
    和 macOS 用户按 Command-S 按钮生成的管道脚本示例。
- en: '![](Images/CH02_F06_Labouardy.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH02_F06_Labouardy.png)'
- en: Figure 2.6 Jenkinsfile generated from the pipeline edito.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 由管道编辑器生成的 Jenkinsfile。
- en: You can now copy the content and paste it in a new file called Jenkinsfile in
    your code repository, alongside the source code. Alternatively, you can upload
    the file directly from the Blue Ocean editor by supplying an appropriate description
    and the target Git branch (figure 2.7).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以将内容复制并粘贴到名为 Jenkinsfile 的新文件中，并将其放置在代码仓库中的源代码旁边。或者，您可以直接从 Blue Ocean 编辑器上传文件，提供适当的描述和目标
    Git 分支（图 2.7）。
- en: '![](Images/CH02_F07_Labouardy.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH02_F07_Labouardy.png)'
- en: Figure 2.7 Committing the Jenkinsfile to the Git repositor.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 将 Jenkinsfile 提交到 Git 仓库。
- en: Once the file is committed, the pipeline will be triggered, and the stages defined
    in the pipeline will be executed.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 文件提交后，管道将被触发，并执行管道中定义的阶段。
- en: Keep in mind that Blue Ocean doesn’t support all features of Jenkins such as
    administration, nodes management, or credential settings. However, you can always
    switch back to the classic Jenkins UI by clicking the exit icon at the top right
    of the Blue Ocean navigation bar.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Blue Ocean 不支持 Jenkins 的所有功能，例如管理、节点管理或凭据设置。然而，您始终可以通过点击 Blue Ocean 导航栏右上角的退出图标切换回经典
    Jenkins UI。
- en: Note This is just a sneak peek of Blue Ocean’s main features. In chapter 7,
    we will dig deeper into each feature.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这只是 Blue Ocean 主要功能的预览。在第 7 章中，我们将更深入地探讨每个功能。
- en: Now that you’re familiar with how a Jenkinsfile works, let’s see how to write
    your own pipeline as code with Jenkins. Jenkins 2 allows two styles of structure
    and syntax for building out workflows. These are referred to as scripted and declarative
    pipelines.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经熟悉了 Jenkinsfile 的工作原理，让我们看看如何使用 Jenkins 编写自己的管道代码。Jenkins 2 允许两种结构和语法的风格来构建工作流程。这些被称为脚本和声明式管道。
- en: 2.1.2 Scripted pipeline
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2 脚本管道
- en: A *scripted pipeline* is a traditional way of writing pipeline code. In this
    pipeline, the Jenkinsfile is written on the Jenkins UI instance. The pipeline
    steps are wrapped in a node block (denoted by the opening and closing braces).
    Here, a node refers to a *Jenkins agent* (formerly referred to as a *slave instance*).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*脚本管道*是编写管道代码的传统方式。在这个管道中，Jenkinsfile 是在 Jenkins UI 实例上编写的。管道步骤被包裹在一个节点块中（由开闭花括号表示）。在这里，节点指的是
    *Jenkins 代理*（以前称为 *从属实例*）。'
- en: The node gets mapped to the Jenkins cluster by using a label. A *label* is simply
    an identifier that has been added when configuring the node in Jenkins via the
    Manage Nodes section, as shown in figure 2.8.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 节点通过标签映射到 Jenkins 集群。*标签*只是一个标识符，当通过 Jenkins 的“管理节点”部分配置节点时添加，如图 2.8 所示。
- en: '![](Images/CH02_F08_Labouardy.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH02_F08_Labouardy.png)'
- en: Figure 2.8 Assigning labels to Jenkins workers
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 分配标签到 Jenkins 工作节点
- en: Note The next chapter covers how the Jenkins distributed mode works and how
    node agents can be used to offload work from Jenkins.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：下一章将介绍 Jenkins 分布式模式的工作原理以及如何使用节点代理来从 Jenkins 转移工作。
- en: The steps inside the node block can include and make use of any valid Groovy
    code. The pipeline can be defined by creating a new pipeline project and typing
    the code in the Pipeline Editor section, as shown in figure 2.9.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 节点块内的步骤可以包括并使用任何有效的 Groovy 代码。可以通过创建一个新的管道项目并在管道编辑器部分输入代码来定义管道，如图 2.9 所示。
- en: '![](Images/CH02_F09_Labouardy.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH02_F09_Labouardy.png)'
- en: Figure 2.9 Using an inline Jenkinsfile with Pipeline scripts
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9 使用内联 Jenkinsfile 与 Pipeline 脚本
- en: Although this simple node block is technically valid syntax, Jenkins pipelines
    generally have a further level of granularity—stages. A *stage* is a way to divide
    the pipeline into logical functional units. It also serves to group steps and
    Groovy code together to create targeted functionality. Figure 2.10 shows an example
    of the preceding pipeline using stages.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个简单的节点块在技术上是一个有效的语法，但 Jenkins 管道通常具有更细粒度的级别——阶段。*阶段*是将管道划分为逻辑功能单元的一种方式。它还用于将步骤和
    Groovy 代码分组在一起，以创建目标功能。图 2.10 展示了使用阶段的先前管道的示例。
- en: '![](Images/CH02_F10_Labouardy.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH02_F10_Labouardy.png)'
- en: Figure 2.10 Using the `stage` keyword to define logical units
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 使用`stage`关键字定义逻辑单元
- en: 'The pipeline has two stages:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 管道有两个阶段：
- en: '*Checkout*—For cloning the project GitHub repository'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检出*—用于克隆项目的GitHub仓库'
- en: '*Build*—For building the project Docker image'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*构建*—用于构建项目的Docker镜像'
- en: How much of the pipeline’s logic goes into a particular stage is up to the developer.
    However, the general practice is to create stages that mimic the separate pieces
    of a traditional pipeline.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 管道逻辑中有多少进入特定的阶段取决于开发者。然而，一般的做法是创建模仿传统管道各个部分的阶段。
- en: The scripted pipeline uses stricter Groovy-based syntaxes because it was the
    first pipeline to be built on the Groovy foundation. Since this Groovy script
    was not typically desirable to all users, the declarative pipeline was introduced
    to offer a simpler and more optioned Groovy syntax.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本式管道使用基于Groovy的更严格的语法，因为它是在Groovy基础上构建的第一个管道。由于此Groovy脚本通常不适合所有用户，因此引入了声明式管道，以提供更简单、更灵活的Groovy语法。
- en: Note Chapter 14 covers how to write a shared Jenkins library with custom Groovy
    scripts for code modularity.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：第14章介绍了如何编写带有自定义Groovy脚本的共享Jenkins库，以实现代码模块化。
- en: 2.1.3 Declarative pipeline
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.3 声明式管道
- en: A *declarative pipeline* is a relatively new feature (introduced in Pipeline
    2.5, [https://plugins.jenkins.io/workflow-aggregator](https://plugins.jenkins.io/workflow-aggregator))
    that supports the PaC approach. It makes the pipeline code easier to read and
    write for new Jenkins users.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*声明式管道*是一个相对较新的功能（在Pipeline 2.5中引入，[https://plugins.jenkins.io/workflow-aggregator](https://plugins.jenkins.io/workflow-aggregator)），它支持PaC方法。它使得新Jenkins用户更容易阅读和编写管道代码。'
- en: This code is written in a Jenkinsfile that can be checked into a version-control
    system (VCS) such as SVN or an SCM system such as GitHub, GitLab, Bitbucket, or
    others. Figure 2.11 is an example of a Jenkinsfile located at the root folder
    of a GitHub repository.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码编写在Jenkinsfile中，可以将其检查到版本控制系统（VCS）中，如SVN或SCM系统，如GitHub、GitLab、Bitbucket或其他。图2.11是GitHub仓库根目录中存储的Jenkinsfile的一个示例。
- en: '![](Images/CH02_F11_Labouardy.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH02_F11_Labouardy.png)'
- en: Figure 2.11 A Jenkinsfile stored in a source-control repository
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 存储在源控制仓库中的Jenkinsfile
- en: In declarative syntax, you cannot use Groovy code such as variables, loops,
    or conditions. You are restricted to the structured sections/blocks and the DSL
    (Jenkins domain-specific language) steps.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明式语法中，您不能使用Groovy代码，如变量、循环或条件。您被限制在结构化部分/块和DSL（Jenkins领域特定语言）步骤中。
- en: Figure 2.12 shows the differences between scripted and declarative pipelines.
    Declarative pipelines are restricted and have well-defined structures (for example,
    all DSL statements must be enclosed in a `steps` directive).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12显示了脚本式和声明式管道之间的差异。声明式管道是受限的，并且具有明确的结构（例如，所有DSL语句都必须包含在`steps`指令中）。
- en: '![](Images/CH02_F12_Labouardy.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH02_F12_Labouardy.png)'
- en: Figure 2.12 Differences between scripted and declarative pipelines
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 脚本式和声明式管道之间的差异
- en: 'Declarative pipelines provide a more restrictive syntax, as each pipeline must
    use these predefined block attributes or sections:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式管道提供了一种更严格的语法，因为每个管道都必须使用这些预定义的块属性或部分：
- en: '`agent`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`agent`'
- en: '`environment`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`environment`'
- en: '`post`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post`'
- en: '`stages`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stages`'
- en: '`steps`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`steps`'
- en: 'The `agent` section defines the worker or machine where the pipeline will be
    executed. This section must be defined at the top level inside the pipeline block
    or overridden at the stage level. The agent can be any of the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`agent`部分定义了管道将要执行的工作节点或机器。此部分必须在管道块内部的最顶层定义，或在阶段级别覆盖。代理可以是以下任何一种：'
- en: Jenkins worker or node (refer to chapter 3 for distributed builds on Jenkins)
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins工作节点或节点（有关Jenkins上的分布式构建，请参阅第3章）
- en: Docker container based on a Docker image or a custom Dockerfile (covered in
    chapter 9)
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Docker镜像或自定义Dockerfile的Docker容器（在第9章中介绍）
- en: Pod deployed on a Kubernetes cluster (covered in chapter 14)
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署在Kubernetes集群上的Pod（在第14章中介绍）
- en: For example, you can define the pipeline to run on a custom Docker container,
    as shown in the following listing.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以定义管道在自定义Docker容器上运行，如下所示。
- en: Listing 2.2 Declarative pipeline agents definition
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.2 声明式管道代理定义
- en: '[PRE1]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note Refer to the official documentation for more information about the agent
    syntax: [www.jenkins.io/doc/book/pipeline/syntax/](http://www.jenkins.io/doc/book/pipeline/syntax/).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：有关代理语法的更多信息，请参阅官方文档：[www.jenkins.io/doc/book/pipeline/syntax/](http://www.jenkins.io/doc/book/pipeline/syntax/)。
- en: The `environment` section contains a set of environment variables needed to
    run the pipeline steps. The variables can be defined as sequences of key-value
    pairs. These will be available for all steps if the environment block is defined
    at the pipeline top level; otherwise, the variables can be stage-specific. You
    can also reference credential variables by using a helper method `credentials``()`,
    which takes as a parameter the ID of the target credential, as shown in the following
    listing.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`environment`部分包含了一组运行管道步骤所需的环境变量。如果环境块在管道顶层定义，则这些变量将可用于所有步骤；否则，变量可以是阶段特定的。您还可以通过使用辅助方法`credentials()`来引用凭据变量，该方法以目标凭据的ID作为参数，如下面的列表所示。'
- en: Listing 2.3 Environment variables definition
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.3 环境变量定义
- en: '[PRE2]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The Docker registry username and password are accessible automatically by referencing
    the `REGISTRY_CREDENTIALS_USR` and `REGISTRY_CREDENTIALS_PSW` environment variables.
    Those credentials are then passed to the `docker login` command to authenticate
    with the Docker Registry before pushing a Docker image.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引用`REGISTRY_CREDENTIALS_USR`和`REGISTRY_CREDENTIALS_PSW`环境变量，Docker注册表的用户名和密码可以自动访问。然后，这些凭据被传递给`docker
    login`命令，在推送Docker镜像之前与Docker注册表进行身份验证。
- en: The `post` section contains commands or scripts that will be run upon the completion
    of a pipeline or stage run, depending on the location of this section within the
    pipeline. However, conventionally the `post` section should be placed at the end
    of the pipeline. Examples of commands that can be used within the `post` section
    are those that provide Slack notifications, clean up the job workspace, and execute
    post-scripts based on the build status. The pipeline build status can be fetched
    by using either the `currentBuild.result` variable or the post-condition blocks
    `always`, `success`, `unstable`, `failure`, and so forth.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`post`部分包含在管道或阶段运行完成后要运行的命令或脚本，具体取决于此部分在管道中的位置。然而，传统上，`post`部分应该放在管道的末尾。可以在`post`部分使用的命令示例包括提供Slack通知、清理作业工作空间以及根据构建状态执行后脚本。可以通过使用`currentBuild.result`变量或后置条件块`always`、`success`、`unstable`、`failure`等来获取管道构建状态。'
- en: The following listing is an example Slack notification. The instructions wrapped
    by the `always` directive will run no matter the status of the build and will
    not interfere with the final status.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表是一个示例Slack通知。由`always`指令包裹的指令将无论构建状态如何都会运行，并且不会干扰最终状态。
- en: Listing 2.4 Post build actions in a declarative pipeline
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.4 声明式管道中的构建后操作
- en: '[PRE3]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code references the `env.JOB_NAME` variable, which contains the Jenkins
    job name.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码引用了`env.JOB_NAME`变量，它包含Jenkins作业的名称。
- en: Note Chapter 10 has a dedicated section on how to implement Slack notifications
    with Jenkins.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：第10章有专门的部分介绍如何使用Jenkins实现Slack通知。
- en: The `stages` section is the core of the pipeline. This section defines what
    is to be done at a high level. It contains a sequence of more stage directives
    for each discrete part of the CI/CD workflow.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`stages`部分是管道的核心。本部分定义了在高级别上要执行的操作。它包含了一系列针对CI/CD工作流程每个离散部分的更多阶段指令。'
- en: Finally, the `steps` section contains a series of more steps to be executed
    in a given stage directive. The following listing defines a `Test` stage with
    instructions to run unit tests and generate code coverage reports.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`steps`部分包含了一系列在给定阶段指令中要执行的步骤。以下列表定义了一个`Test`阶段，其中包含运行单元测试和生成代码覆盖率报告的指令。
- en: Listing 2.5 Running automated tests within a pipeline
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.5 在管道中运行自动化测试
- en: '[PRE4]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These are the most used directives and sections while writing a declarative
    pipeline. Additional directives will be covered throughout this book. For an overview
    of all available blocks, refer to Pipeline Syntax documentation ([www.jenkins.io/doc/book/pipe
    line/syntax/#stages](https://www.jenkins.io/doc/book/pipeline/syntax/#stages)).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是在编写声明式管道时最常用的指令和部分。本书将涵盖更多指令。有关所有可用块的概述，请参阅Pipeline语法文档([www.jenkins.io/doc/book/pipeline/syntax/#stages](https://www.jenkins.io/doc/book/pipeline/syntax/#stages))。
- en: Both declarative and scripted styles can be used to build CI/CD pipelines in
    either the web UI or with a Jenkinsfile. However, it’s generally considered a
    best practice to create a Jenkinsfile and check it into the source-control repository
    to have a single source of truth and be able to track all changes (auditing) that
    your pipeline went through.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 声明性和脚本样式都可以用于在 Web UI 或使用 Jenkinsfile 中构建 CI/CD 管道。然而，通常认为将 Jenkinsfile 创建并提交到源代码控制仓库是一个最佳实践，以确保有一个单一的事实来源，并能够跟踪管道所经历的所有更改（审计）。
- en: Note In chapters 7 through 11, you will learn how to write a scripted pipeline
    from scratch for various application architectures and how to convert a Jenkinsfile
    from a scripted to a declarative format.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在第 7 章至第 11 章中，您将学习如何从头开始为各种应用程序架构编写脚本管道，以及如何将 Jenkinsfile 从脚本格式转换为声明性格式。
- en: 2.2 Understanding multibranch pipelines
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 理解多分支管道
- en: When you’re building your application, you must separate your deployment environments
    to test new changes without impacting your production. Therefore, having multiple
    environments for your application makes sense. To be able to achieve that, you
    need to structure your code repository to use multiple branches, with each branch
    representing an environment. For instance, the master branch corresponds to the
    current production code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当您构建应用程序时，您必须将您的部署环境分开，以测试新更改而不影响生产。因此，为您的应用程序拥有多个环境是有意义的。为了能够实现这一点，您需要结构化您的代码仓库以使用多个分支，每个分支代表一个环境。例如，master
    分支对应于当前的生产代码。
- en: While it’s easier nowadays to replicate multiple infrastructure environments
    with the adoption of cloud computing and IaC tools, you still need to configure
    your CI tools for each target branch.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然如今随着云计算和 IaC 工具的采用，复制多个基础设施环境变得更加容易，但您仍然需要为每个目标分支配置 CI 工具。
- en: Fortunately, when using a Jenkinsfile, your pipeline definition lives with the
    code source of the application going through the pipeline. Jenkins will automatically
    scan through each branch in the application code repository and check whether
    the branch has a Jenkinsfile. If it does, Jenkins will automatically create and
    configure a subproject within the multibranch pipeline project to run the pipeline
    for that branch. This eliminates the need for manual pipeline creation and management.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在使用 Jenkinsfile 时，您的管道定义与应用程序代码源一起存储。Jenkins 将自动扫描应用程序代码仓库中的每个分支，并检查该分支是否有
    Jenkinsfile。如果有，Jenkins 将自动在多分支管道项目中创建和配置一个子项目来运行该分支的管道。这消除了手动创建和管理管道的需求。
- en: Figure 2.13 shows the jobs in a multibranch pipeline project after executing
    against the Jenkinsfiles and source repositories. Jenkins automatically scans
    the designated repository and creates appropriate projects for each branch in
    the repository that contains a Jenkinsfile.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13 显示了在执行 Jenkinsfile 和源代码仓库后，多分支管道项目中的作业。Jenkins 自动扫描指定的仓库，并为包含 Jenkinsfile
    的每个分支创建适当的项目。
- en: '![](Images/CH02_F13_Labouardy.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH02_F13_Labouardy.png)'
- en: Figure 2.13 Jenkins automatically creates a job for each branch with a Jenkinsfile.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13 显示了 Jenkins 为每个带有 Jenkinsfile 的分支自动创建作业。
- en: In figure 2.13, Jenkins will trigger a build whenever a new code change occurs
    on any of the develop, preprod, or master branches. In addition, each branch might
    have different pipeline stages. For example, you might perform a complete CI/CD
    pipeline for the master branch and only a CI pipeline for the develop branch (see
    figure 2.14). You can do this with the help of a multibranch pipeline project.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 2.13 中，每当 develop、preprod 或 master 分支中的任何分支发生新的代码更改时，Jenkins 都会触发构建。此外，每个分支可能具有不同的管道阶段。例如，您可能为
    master 分支执行完整的 CI/CD 管道，而为 develop 分支仅执行 CI 管道（见图 2.14）。您可以使用多分支管道项目来实现这一点。
- en: '![](Images/CH02_F14_Labouardy.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH02_F14_Labouardy.png)'
- en: Figure 2.14 Each Git branch can have its own Jenkinsfile stages.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.14 每个 Git 分支都可以有自己的 Jenkinsfile 阶段。
- en: A multibranch pipeline can also be used to validate pull requests before merging
    them to target branches. You can configure Jenkins to launch pre-integration tests
    against the application’s code and block the pull request merge if the tests failed,
    as in figure 2.15.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 多分支管道还可以用于在合并到目标分支之前验证拉取请求。您可以配置 Jenkins 对应用程序代码执行预集成测试，如果测试失败，则阻止拉取请求合并，如图
    2.15 所示。
- en: '![](Images/CH02_F15_Labouardy.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH02_F15_Labouardy.png)'
- en: Figure 2.15 Jenkins build status in GitHub pull request
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.15 GitHub 拉取请求中的 Jenkins 构建状态
- en: Note Chapter 9 covers using multibranch pipelines to validate pull/change requests.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：第9章介绍了使用多分支管道来验证拉取/更改请求。
- en: Now that you’re familiar with the basics of the Jenkins multibranch pipeline,
    you must follow Git branching guidelines to have a common vision and methodology
    within the development team. So which Git branching strategies should you use
    for your development cycle?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了Jenkins多分支管道的基本知识，你必须遵循Git分支指南，以便在开发团队内部有一个共同的愿景和方法。那么，你应该为你的开发周期使用哪种Git分支策略？
- en: 2.3 Exploring the GitFlow branch model
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 探索GitFlow分支模型
- en: 'A couple of Git branching strategies exist. The most interesting and used one
    is GitFlow. It consists of the following essential branches:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 存在几种Git分支策略。最有趣且使用最广泛的是GitFlow。它包括以下基本分支：
- en: '*Master*—A branch that corresponds to the current production code. You can’t
    commit directly except for hotfixes. Git tags can be used to tag all commits in
    the master branch with a version number (for instance, you can use the semantic
    versioning convention detailed at [https://semver.org/](https://semver.org/)).'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*主分支*—一个对应当前生产代码的分支。除了热修复之外，你不能直接提交。可以使用Git标签来为主分支上的所有提交添加版本号（例如，你可以使用在[https://semver.org/](https://semver.org/)中详细说明的语义版本控制约定）。'
- en: '*Preprod*—A release branch, a mirror of production. It can be used to test
    all new features developed on the develop branch before merging them to the master
    branch.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*预生产*—一个发布分支，是生产的镜像。在将它们合并到主分支之前，可以用来测试在开发分支上开发的所有新功能。'
- en: '*Develop*—A development integration branch containing the latest integrated
    development code.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开发*—一个包含最新集成开发代码的开发集成分支。'
- en: '*Feature/X*—An individual feature branch being developed. Each new feature
    resides in its own branch, and it’s generally created from the latest develop
    branch.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*功能/X*—一个正在开发中的单个功能分支。每个新功能都位于自己的分支中，通常是从最新的开发分支创建的。'
- en: '*Hotfix/X*—When you need to solve something in production code, you can use
    the hotfix branch and open a pull request for the master branch. This branch is
    based on the master branch.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*热修复/X*—当你需要在生产代码中解决问题时，你可以使用热修复分支并为主分支打开一个拉取请求。这个分支基于主分支。'
- en: Note A complete example demonstrating the use of GitFlow with the Jenkins multibranch
    pipeline project is given in chapters 7 through 11.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在第7章到第11章中给出了一个使用GitFlow与Jenkins多分支管道项目的完整示例。
- en: 'The overall flow of GitFlow within Jenkins can be summarized as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins中GitFlow的整体流程可以总结如下：
- en: A develop branch is created from the master branch.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从主分支创建一个开发分支。
- en: A preprod branch is created from the develop branch.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从开发分支创建一个预生产分支。
- en: A developer creates a new feature branch based on the development branch. When
    a feature is completed, a pull request is created.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者基于开发分支创建一个新的功能分支。当功能完成时，创建一个拉取请求。
- en: Jenkins automatically runs pre-integration tests in this individual feature.
    If the tests are successful, Jenkins marks the commits as successful. The development
    team will then review the changes and merge the pull request of the new feature
    branch to the develop branch and delete the feature branch.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins会自动运行此单个功能的预集成测试。如果测试成功，Jenkins会将提交标记为成功。然后，开发团队将审查更改并将新功能分支的拉取请求合并到开发分支，并删除功能分支。
- en: A build will be triggered on the develop branch, and the changes will be deployed
    to the sandbox/development environment.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将在开发分支上触发构建，并将更改部署到沙盒/开发环境。
- en: A pull request is created to merge the develop branch into the preprod branch.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个拉取请求以将开发分支合并到预生产分支。
- en: When the develop branch is merged to the preprod branch, the pipeline will be
    triggered to deploy the new features to the staging environment upon the completion
    of the pipeline.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当开发分支合并到预生产分支时，管道将在管道完成后触发将新功能部署到预发布环境。
- en: Once the release is being validated, the preprod branch will be merged to master,
    and changes will be deployed to the production environment after user approval.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦发布开始验证，预生产分支将被合并到主分支，并在用户批准后，将更改部署到生产环境。
- en: If an issue in production is detected, a hot branch is created from the master
    branch. Once the hotfix is complete, it will be merged to both the develop and
    master branches.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在生产中检测到问题，将从一个主分支创建一个热分支。一旦热修复完成，它将被合并到开发和主分支。
- en: Note You can use the GitFlow wrapper around the Git command line (available
    on multiple operating systems) to create a project blueprint with all needed branches.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可以使用Git命令行周围的GitFlow包装器（在多个操作系统上可用）来创建包含所有所需分支的项目蓝图。
- en: Figure 2.16 summarizes how GitFlow works.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.16总结了GitFlow的工作方式。
- en: '![](Images/CH02_F16_Labouardy.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH02_F16_Labouardy.png)'
- en: Figure 2.16 Overview of GitFlow branches
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.16 GitFlow分支概述
- en: 'GitFlow does not solve all problems with branching. But it offers you a more
    logical branch structure and a great workflow organization model when working
    within a big team. In addition, many feature branches are developed concurrently,
    which makes parallel development easy. For smaller projects (and smaller teams),
    GitFlow can be overkill. Hence, in upcoming chapters, we will usually use three
    main branches:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: GitFlow并不能解决所有关于分支的问题。但是，当在大团队中工作时，它提供了一个更合理的分支结构和优秀的流程组织模型。此外，许多功能分支是并发开发的，这使得并行开发变得容易。对于较小项目（和较小团队），GitFlow可能有些过度。因此，在接下来的章节中，我们通常会使用三个主要分支：
- en: '*Master* branch, to store the official release history and the source code
    of an application running in a production environment'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*主*分支，用于存储官方发布历史和在生产环境中运行的应用程序的源代码'
- en: '*Preprod* branch, to store new integrated features running in the staging environment
    and ready to be merged to the master branch'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*预生产*分支，用于存储在预发布环境中运行的新集成功能和准备合并到主分支的内容'
- en: '*Develop* branch, for the latest delivered development changes and mirror of
    the application running in a sandbox environment'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开发*分支，用于最新交付的开发更改和沙盒环境中运行的应用程序的镜像'
- en: 2.4 Test-driven development with Jenkins
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 使用Jenkins进行测试驱动开发
- en: 'Using Jenkinsfiles has one potential downside: it can be more challenging to
    discover problems up-front when you are working in the external file and not in
    the environment of the Jenkins server. One approach to dealing with this is developing
    the code within the Jenkins server as a pipeline project first. Then, you can
    convert it to a Jenkinsfile afterward.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Jenkinsfile有一个潜在的缺点：当您在外部文件中工作而不是在Jenkins服务器环境中时，可能更难在前期发现问题。处理这个问题的一个方法是在Jenkins服务器上首先作为一个管道项目开发代码。然后，您可以在之后将其转换为Jenkinsfile。
- en: You can also use Blue Ocean mode as a playground, as seen earlier in this chapter,
    to set up a Jenkinsfile from scratch with a modern and intuitive pipeline editor.
    Another approach to test a new pipeline is a declarative pipeline linter application
    that you can run against Jenkinsfiles, outside Jenkins, to detect problems early.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以像本章前面所看到的那样，使用Blue Ocean模式作为游乐场，从头开始使用现代直观的管道编辑器设置Jenkinsfile。测试新管道的另一种方法是声明性管道lint器应用程序，您可以在Jenkins之外运行它，以提前检测问题。
- en: 2.4.1 The Jenkins Replay button
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.1 Jenkins回放按钮
- en: Sometimes, when working on Jenkins jobs, you might find yourself stuck in this
    cycle of committing the Jenkinsfile, pushing it, and running the job over and
    over again. It can be a time-consuming and tedious workflow, especially if your
    build time is inherently long. Plus, your Git history will get filled with junk
    commits (unnecessary debugging commits).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当在Jenkins作业上工作时，您可能会发现自己陷入提交Jenkinsfile、推送它并反复运行作业的循环。这可能是一个耗时且繁琐的工作流程，尤其是如果您的构建时间本身就很长。此外，您的Git历史记录将被垃圾提交（不必要的调试提交）填满。
- en: What if you could work on your Jenkinsfile in a “sandbox” and test the Jenkinsfile
    live on the system? A neat little feature allows you to modify the Jenkins file
    and rerun the job. You can do it over and over until you are happy with the results
    and then commit the working Jenkinsfile without breaking anything.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您能在“沙盒”中修改您的Jenkinsfile并实时在系统上测试Jenkinsfile，会怎么样？一个巧妙的小功能允许您修改Jenkins文件并重新运行作业。您可以反复进行，直到对结果满意，然后提交工作状态的Jenkinsfile而不会破坏任何东西。
- en: Now, this is a little easier. If you have a Pipeline build that did not proceed
    exactly as you expected, you can use the Replay button in the build’s sidebar,
    shown in fig- ure 2.17.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这要容易一些。如果您有一个没有按照预期进行构建的Pipeline构建，您可以使用构建侧边栏中的回放按钮，如图2.17所示。
- en: '![](Images/CH02_F17_Labouardy.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH02_F17_Labouardy.png)'
- en: Figure 2.17 Rerunning the build with a Replay button
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.17 使用回放按钮重新运行构建
- en: It is somewhat similar to the Rebuild button but allows you to edit the Jenkinsfile
    content just before running the job. Therefore, you can use the built-in Jenkinsfile
    block in the UI (figure 2.18), to test your pipelines out there before committing
    them to source control like GitHub.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 它与重建按钮有些相似，但允许你在运行作业之前编辑Jenkinsfile的内容。因此，你可以使用UI中的内置Jenkinsfile块（图2.18），在提交到源代码控制（如GitHub）之前测试你的管道。
- en: '![](Images/CH02_F18_Labouardy.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH02_F18_Labouardy.png)'
- en: Figure 2.18 Updating the Jenkinsfile before replaying the pipeline
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.18 在重新播放管道之前更新Jenkinsfile
- en: You can change your pipeline’s code and click the Run button and rerun the job.
    Once you are satisfied with the changes, you update the Jenkinsfile with the applied
    changes and commit them to your SCM.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以更改你的管道代码并点击运行按钮重新运行作业。一旦你对更改满意，你就可以更新Jenkinsfile并应用更改，然后将它们提交到你的源代码管理（SCM）。
- en: The Replay button feature allows for quick modifications and execution of an
    existing pipeline without changing the pipeline configuration or creating a new
    commit. It’s ideal for rapid iteration and prototyping of a pipeline.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 重放按钮功能允许快速修改和执行现有的管道，而无需更改管道配置或创建新的提交。这对于快速迭代和原型设计管道非常理想。
- en: 2.4.2 Command-line pipeline linter
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.2 命令行管道检查器
- en: For advanced users, you can use the Jenkins RESTful API to validate the Jenkinsfile
    syntax by issuing an HTTP/HTTPS POST request with the parameters shown in figure
    2.19.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 对于高级用户，你可以使用Jenkins RESTful API通过发出如图2.19所示的参数的HTTP/HTTPS POST请求来验证Jenkinsfile的语法。
- en: 'Note To get the API endpoint working on a Jenkins server with cross-site request
    forgery (CSRF) protection enabled, you need to request a crumb issuer and include
    it in the Authorization header in the issued HTTP request. To generate this crumb,
    you need to request the following URL: JENKINS_ URL/jenkins/crumbIssuer/api/json.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：为了在启用了跨站请求伪造（CSRF）保护的Jenkins服务器上使API端点工作，你需要请求一个crumb发行者并将其包含在发出的HTTP请求的Authorization头中。要生成这个crumb，你需要请求以下URL：JENKINS_URL/jenkins/crumbIssuer/api/json。
- en: Figure 2.19 is an example of how to use the Jenkins Linter API to validate Jenkinsfile
    syntax. We’re using Postman in this example, and the Jenkinsfile form data has
    been loaded from the developer machine.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.19是使用Jenkins Linter API验证Jenkinsfile语法的示例。在这个例子中，我们使用了Postman，并且Jenkinsfile表单数据已从开发机器加载。
- en: '![](Images/CH02_F19_Labouardy.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH02_F19_Labouardy.png)'
- en: Figure 2.19 Example of using Jenkins Linter API
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.19 使用Jenkins Linter API的示例
- en: The API response will return both errors and warnings, which can save time during
    the development and allows you to follow best practices while writing a Jenkinsfile.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: API响应将返回错误和警告，这可以在开发过程中节省时间，并允许你在编写Jenkinsfile时遵循最佳实践。
- en: 'Specifying the real password is still supported, but it is not recommended
    because of the risk of revealing the password, and the human tendency to reuse
    the same password in different places. Another way of validating the Jenkinsfile
    is to run the following command from the terminal session (cURL is available for
    most operating systems):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 支持指定真实密码，但出于泄露密码的风险以及人们倾向于在不同地方重复使用相同密码的倾向，这并不推荐。验证Jenkinsfile的另一种方法是，从终端会话中运行以下命令（大多数操作系统都可用cURL）：
- en: '[PRE5]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note Chapter 7 covers another way of creating a Jenkins API token from the Jenkins
    web dashboard.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：第7章介绍了从Jenkins Web仪表板创建Jenkins API令牌的另一种方法。
- en: 'The Jenkins command-line interface (CLI), [www.jenkins.io/doc/book/managing/cli/](http://www.jenkins.io/doc/book/managing/cli/),
    can also be used with the `declarative-lint` option to lint a declarative pipeline
    from the command line before actually running it. You can issue this command to
    lint a Jenkinsfile via the CLI with SSH:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins命令行界面（CLI），[www.jenkins.io/doc/book/managing/cli/](http://www.jenkins.io/doc/book/managing/cli/)，也可以使用`declarative-lint`选项在命令行中检查声明式管道，在真正运行之前。你可以通过SSH使用以下命令来检查Jenkinsfile：
- en: '[PRE6]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Replace the `JENKINS_HOSTNAME` and `JENKINS_SSHD_PORT` variables based on the
    URL and port where you are running Jenkins. You can also use localhost as a URL
    if you are running Jenkins on your machine.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你运行Jenkins的URL和端口替换`JENKINS_HOSTNAME`和`JENKINS_SSHD_PORT`变量。如果你在自己的机器上运行Jenkins，也可以使用localhost作为URL。
- en: 2.4.3 IDE integrations
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.3 IDE集成
- en: The Jenkins CLI or API does a great job of reducing the turnaround times when
    writing a Jenkinsfile, but its usage has its own inconveniences. You need tools
    like SSH to make a connection to your Jenkins server, and you need to remember
    the correct command to validate your Jenkinsfile.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins CLI 或 API 在编写 Jenkinsfile 时减少了周转时间，但它的使用也有其不便之处。你需要像 SSH 这样的工具来连接到你的
    Jenkins 服务器，并且你需要记住正确的命令来验证你的 Jenkinsfile。
- en: Fortunately, you can install extensions on your favorite integrated development
    environment (IDE) to automate the validation process. For instance, on Visual
    Studio Code (VSCode), you can install Jenkins Validation Linter from the marketplace.
    This extension, shown in figure 2.20, validates Jenkinsfiles by sending them to
    the Pipeline Linter endpoint of a Jenkins server.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你可以在你喜欢的集成开发环境（IDE）上安装扩展来自动化验证过程。例如，在 Visual Studio Code (VSCode) 中，你可以从市场安装
    Jenkins Validation Linter。这个扩展，如图 2.20 所示，通过将 Jenkinsfile 发送到 Jenkins 服务器的 Pipeline
    Linter 端点来验证 Jenkinsfile。
- en: Note Similar extensions and packages are available to validate a Jenkinsfile
    for Eclipse, Atom, and Sublime Text.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：类似扩展和包可用于验证 Eclipse、Atom 和 Sublime Text 的 Jenkinsfile。
- en: '![](Images/CH02_F20_Labouardy.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH02_F20_Labouardy.png)'
- en: Figure 2.20 Jenkins Pipeline Linter extension for VSCode
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.20 VSCode 的 Jenkins Pipeline Linter 扩展
- en: 'Once the extension is installed, you must provide Jenkins server settings,
    including the server URL (with the following format: JENKINS_URL/pipeline_model_converter/validate)
    and credentials (Jenkins username and password, or token if CSRF protection is
    enabled) by clicking Preferences from the top navigation bar, and selecting Settings,
    as shown in figure 2.21.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了扩展，你必须通过点击顶部导航栏中的“首选项”，然后选择“设置”，提供 Jenkins 服务器设置，包括服务器 URL（格式如下：JENKINS_URL/pipeline_model_converter/validate）和凭据（Jenkins
    用户名和密码，或者如果启用了 CSRF 保护，则为令牌）。
- en: '![](Images/CH02_F21_Labouardy.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH02_F21_Labouardy.png)'
- en: Figure 2.21 Jenkins Pipeline Linter configuration
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.21 Jenkins Pipeline Linter 配置
- en: Once settings are configured, you can type the `Validate Jenkinsfile` command
    on the command palette search bar (keyword shortcut ⇧⌘P), as shown in figure 2.22.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置了设置，你可以在命令面板搜索栏中输入“验证 Jenkinsfile”命令（关键字快捷键 ⇧⌘P），如图 2.22 所示。
- en: '![](Images/CH02_F22_Labouardy.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH02_F22_Labouardy.png)'
- en: Figure 2.22 VSCode command palette
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.22 VSCode 命令面板
- en: The linter will report the pipeline validation results in the terminal, as shown
    in fig-ure 2.23.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 检查器将在终端中报告管道验证结果，如图 2.23 所示。
- en: '![](Images/CH02_F23_Labouardy.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH02_F23_Labouardy.png)'
- en: Figure 2.23 Example of Jenkins Linter’s output
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.23 Jenkins Linter 输出示例
- en: Note In chapter 8, you will learn how to write unit tests for CI pipelines and
    use the Jenkins Pipeline Unit ([https://github.com/jenkinsci/JenkinsPipelineUnit](https://github.com/jenkinsci/JenkinsPipelineUnit))
    testing framework to mock the pipeline executor locally.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在第 8 章中，你将学习如何为 CI 管道编写单元测试，并使用 Jenkins Pipeline Unit ([https://github.com/jenkinsci/JenkinsPipelineUnit](https://github.com/jenkinsci/JenkinsPipelineUnit))
    测试框架在本地模拟管道执行器。
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Infrastructure as code influenced CI/CD tools to embrace the pipeline-as-code
    concepts.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施即代码影响了 CI/CD 工具，使其接受管道即代码的概念。
- en: A Jenkinsfile uses Groovy syntax and utilizes shared Jenkins libraries to customize
    a CI/CD workflow.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkinsfile 使用 Groovy 语法，并利用共享的 Jenkins 库来自定义 CI/CD 工作流程。
- en: Declarative pipelines encourage a declarative programming model. Scripted pipelines
    follow a more imperative programming model.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明式管道鼓励声明式编程模型。脚本式管道遵循更命令式的编程模型。
- en: The Blue Ocean editor can facilitate a quick and easy setup of a new Jenkins
    pipeline with minimal hassle.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝海编辑器可以简化新 Jenkins 管道的快速和轻松设置，最小化麻烦。
- en: A feature branch workflow facilitates pull requests and more efficient collaboration.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能分支工作流程促进了拉取请求和更高效的协作。
- en: GitFlow offers a dedicated channel for hotfixes to production without interrupting
    the rest of the workflow or waiting for the next release cycle.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitFlow 为生产提供了专门的通道，以进行热修复，而不会中断其他工作流程或等待下一个发布周期。
- en: The Jenkins UI, Replay button, and code linters can be used to test new pipelines
    before committing them to source control, enabling you to avoid a bunch of unnecessary
    debugging commits.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins UI、回放按钮和代码检查器可以用来在提交到源代码控制之前测试新的管道，从而帮助你避免大量不必要的调试提交。
