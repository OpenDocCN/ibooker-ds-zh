- en: 2 Processing and formatting strings
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 处理和格式化字符串
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Using f-strings to interpolate expressions and apply formatting
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 f 字符串进行表达式插值和格式化
- en: Converting strings to other applicable data types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将字符串转换为其他适用的数据类型
- en: Joining and splitting strings
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接和拆分字符串
- en: Using regular expressions for advanced string processing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正则表达式进行高级字符串处理
- en: 'Textual information is the most important form of data in almost every application.
    Textual data as well as numeric data can be saved as text files, and reading them
    requires us to process strings. On a shopping website, for example, we use text
    to provide production descriptions. Machine learning is trending, and you may
    have heard about one machine learning specialty: natural language processing,
    which extracts information from texts. Because of the universal use of strings,
    text processing is an inevitable step in preparing data in these scenarios. Using
    our task management app as the context, we need to convert a task’s attributes
    to textual data so that we can present them at the frontend of our web app. When
    we obtain data entry at the frontend of our app, we must convert these strings
    to a proper type, such as an integer, for further processing. In numerous real-life
    cases like these, we need to process and format strings properly. In this chapter,
    we tackle some common text processing problems.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 文本信息几乎是每个应用程序最重要的数据形式。文本数据以及数值数据都可以保存为文本文件，读取它们需要我们处理字符串。例如，在购物网站上，我们使用文本来提供产品描述。机器学习正在兴起，你可能听说过一个机器学习专业：自然语言处理，它从文本中提取信息。由于字符串的通用使用，在这些场景中准备数据时，文本处理是不可避免的步骤。以我们的任务管理应用程序为背景，我们需要将任务的属性转换为文本数据，以便我们可以在我们的
    Web 应用程序的前端展示它们。当我们从应用程序的前端获取数据输入时，我们必须将这些字符串转换为适当的类型，例如整数，以便进一步处理。在许多现实生活中的案例中，我们需要正确处理和格式化字符串。在本章中，我们解决了一些常见的文本处理问题。
- en: 2.1 How do I use f-strings for string interpolation and formatting?
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 我该如何使用 f 字符串进行字符串插值和格式化？
- en: In Python, you can format text strings in a variety of ways. One emerging approach
    is to use an f-string, which allows you to embed expressions inside a string literal.
    Although you can use other string formatting approaches, an f-string offers a
    more readable solution; thus, you should use f-strings as the preferred approach
    when you prepare strings as output.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，你可以以多种方式格式化文本字符串。一种新兴的方法是使用 f 字符串，它允许你在字符串字面量中嵌入表达式。虽然你可以使用其他字符串格式化方法，但
    f 字符串提供了一个更易读的解决方案；因此，当你准备字符串作为输出时，你应该使用 f 字符串作为首选方法。
- en: TRIVIA F-strings were introduced in Python 3.6\. Both f and F (which mean *formatted*
    ) can be the prefix for the f-string. A *string literal* is a series of characters
    enclosed within single or double quotation marks.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 事实小贴士：F 字符串是在 Python 3.6 中引入的。f 和 F（表示*格式化*）都可以作为 f 字符串的前缀。一个*字符串字面量*是一系列被单引号或双引号包围的字符。
- en: 'When you use strings as an output, you often need to deal with nonstring data,
    such as integers and floats. Suppose that our task management application has
    the requirement of creating a string output from existing variables:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用字符串作为输出时，你经常需要处理非字符串数据，例如整数和浮点数。假设我们的任务管理应用程序有从现有变量创建字符串输出的需求：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this section, you’ll learn how to use f-strings to interpolate nonstring
    data and present strings in the desired format. As you’ll discover, f-strings
    are a more readable solution for formatting strings from existing strings and
    other types of variables.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何使用 f 字符串来插值非字符串数据并以所需的格式呈现字符串。正如你将发现的，f 字符串是格式化从现有字符串和其他类型变量中获取的字符串的更易读的解决方案。
- en: 2.1.1 Formatting strings before f-strings
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1 在 f 字符串之前格式化字符串
- en: The str class handles textual data through its instances, which we refer to
    as *string variables.* Besides string variables, textual information often involves
    data types such as integers and floats. Theoretically, we can convert nonstring
    data to strings and concatenate them to create the desired textual output, as
    shown in the next listing.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: str 类通过其实例处理文本数据，我们将其称为*字符串变量*。除了字符串变量之外，文本信息通常涉及整数和浮点数等数据类型。理论上，我们可以将非字符串数据转换为字符串并将它们连接起来以创建所需的文本输出，如以下列表所示。
- en: Listing 2.1 Creating string output using string concatenation
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.1 使用字符串连接创建字符串输出
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There are two potential problems with the code creating the task variable. First,
    it looks cumbersome and doesn’t read smoothly, as we’re dealing with multiple
    strings, each of which is enclosed in quotation marks. Second, we must convert
    urgency from int to str before it can be joined with other strings, further complicating
    the string concatenation operation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建任务变量的代码中存在两个潜在问题。首先，它看起来很繁琐，读起来不流畅，因为我们正在处理多个字符串，每个字符串都被引号包围。其次，我们必须在将紧急程度从
    int 转换为 str 之后，才能将其与其他字符串连接，这进一步复杂了字符串连接操作。
- en: Old string formatting techniques
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 旧字符串格式化技术
- en: 'Before the f-string was introduced, two other solutions were available. The
    first solution is the classic C-style involving the % sign, and the other uses
    the format method. You’ll find these solutions in the following code snippet:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 f-string 被引入之前，有两种其他解决方案可用。第一种解决方案是经典的 C 风格，涉及 % 符号，另一种使用格式方法。您将在下面的代码片段中找到这些解决方案：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ The % sign separates the string literal and the tuple object.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ % 符号将字符串字面量和元组对象分开。
- en: The C-style approach uses % within the string literal to denote that one variable
    will be formatted, following which are the % sign and the tuple of the corresponding
    variables. The format method approach has a similar usage. Instead of using %
    signs in the literal, it uses curly braces as the marker for string interpolation,
    and the corresponding variables are listed in the format method.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: C 风格的方法在字符串字面量中使用 % 符号来表示一个变量将被格式化，其后跟随 % 符号和相应变量的元组。格式方法方法有类似的用法。它不使用字面量中的
    % 符号，而是使用花括号作为字符串插值的标记，相应的变量列在格式方法中。
- en: Notably, both approaches are still supported in Python, but they have become
    obsolete, and you rarely need to use them. Thus, I don’t expand on them here.
    It’s important to know that what they do can be done with f-strings—a more readable
    string interpolation and formatting approach, as we’ll explore in section 2.1.2.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这两种方法在 Python 中仍然得到支持，但它们已经过时，您很少需要使用它们。因此，在这里我不展开讨论。重要的是要知道，它们所做的工作可以用
    f-string 来完成——这是一种更易读的字符串插值和格式化方法，我们将在 2.1.2 节中探讨。
- en: CONCEPT In general, methods are functions that are defined within a class. Here,
    format is a function defined in the str class, and we call these methods on str
    instance objects.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: CONCEPT 通常，方法是在类内部定义的函数。在这里，format 是在 str 类中定义的函数，我们调用这些方法在 str 实例对象上。
- en: 2.1.2 Using f-strings to interpolate variables
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2 使用 f-string 插值变量
- en: 'Formatting strings often involves combining string literals and variables of
    different types, such as integers and strings. When we integrate variables into
    an f-string, we can interpolate these variables to convert them to the desired
    strings automatically. In this section, you’ll see a variety of interpolations
    involving common data types using f-strings. Let’s see first how we use f-strings
    to create the output shown in listing 2.1:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化字符串通常涉及将字符串字面量和不同类型的变量（如整数和字符串）组合在一起。当我们把变量整合到 f-string 中时，我们可以将这些变量进行插值，自动转换为所需的字符串。在本节中，您将看到使用
    f-string 进行各种插值，涉及常见数据类型的示例。让我们首先看看如何使用 f-string 创建如列表 2.1 所示的输出：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, we create the task_f variable by using the f-string approach.
    The most significant thing is that we use curly braces to enclose variables for
    interpolation. As f-strings integrate string interpolation, they’re also referred
    to as *interpolated string literals**.*
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过使用 f-string 方法创建 task_f 变量。最重要的是，我们使用花括号来包围用于插值的变量。由于 f-string 集成了字符串插值，它们也被称为
    *插值字符串字面量**.*
- en: CONCEPT The term *string interpolation* isn’t Python-specific, as most common
    modern languages (such as JavaScript, Swift, and C#) have this feature. In general,
    it’s a more concise and readable syntax for creating formatted strings than string
    concatenations and alternative string formatting approaches.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: CONCEPT “字符串插值”这个术语并非 Python 独有，因为大多数常见的现代语言（如 JavaScript、Swift 和 C#）都有这个特性。一般来说，它比字符串连接和替代字符串格式化方法更简洁、更易读。
- en: The assertion statement
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 断言语句
- en: assert is a Python keyword used to create an assertion statement, which evaluates
    the supplied condition. When the condition is True, the program continues its
    execution. When the condition is False, execution stops, and the program raises
    an AssertionError.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: assert 是 Python 中的一个关键字，用于创建断言语句，它评估提供的条件。当条件为 True 时，程序继续执行。当条件为 False 时，执行停止，程序引发
    AssertionError。
- en: As a convention in this book, I use the assertion statement to show the equivalence
    of the involved variables in a comparison. As a special case, when the evaluated
    variable is Boolean, it’s technically preferred to use assert true_var and assert
    not false_var. To explicitly show the variable’s Boolean value, however, I opt
    to use assert true_var == True and assert false_var == False.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本书的惯例，我使用断言语句来显示比较中涉及的变量的等价性。作为一个特殊情况，当评估的变量是布尔值时，技术上更倾向于使用assert true_var
    and assert not false_var。然而，为了明确显示变量的布尔值，我选择使用assert true_var == True和assert false_var
    == False。
- en: 'We’ve seen that an f-string interpolates string and integer variables. How
    about other types, such as list and tuple? These types are supported by f-string,
    as shown in this code snippet:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到f-字符串可以插值字符串和整数变量。那么其他类型，如列表和元组呢？这些类型由f-字符串支持，如以下代码片段所示：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Interpolates a list object
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 插值一个列表对象
- en: ❷ Interpolates a tuple object
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 插值一个元组对象
- en: ❸ Interpolates a dict object
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 插值一个字典对象
- en: PEEK F-strings also support custom class instances. When we’re learning about
    creating our own custom classes in chapter 8, we’ll revisit how string interpolation
    works with the custom instances (section 8.4).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: PEEK F-字符串也支持自定义类实例。当我们学习在第8章创建自己的自定义类时，我们将重新审视字符串插值如何与自定义实例一起工作（第8.4节）。
- en: 2.1.3 Using f-strings to interpolate expressions
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.3 使用f-字符串插值表达式
- en: 'We’ve seen how f-string interpolates variables. As a more general usage, f-strings
    can also interpolate expressions, which eliminates the need to create intermediate
    variables. You may access an item in a dict object to create string output, for
    example, or use the result of calling a function. In these common scenarios, you
    can plug these expressions into f-strings, as shown in the following code snippet:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到f-字符串如何插值变量。作为一种更通用的用法，f-字符串还可以插值表达式，从而消除了创建中间变量的需要。例如，您可以通过访问字典对象中的项来创建字符串输出，或者使用函数调用的结果。在这些常见场景中，您可以将这些表达式插入到f-字符串中，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Accesses an item in the list
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 访问列表中的项
- en: ❷ Calls a function
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 调用一个函数
- en: ❸ Direct calculation
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 直接计算
- en: 'These expressions are enclosed within curly braces, allowing f-strings to evaluate
    them directly to produce the desired string output: {tasks[0]} -> “homework”;
    {task_name .title()} -> “Grocery Shopping”; {number*number} -> 25.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些表达式被括在花括号内，允许f-字符串直接计算它们以产生所需的字符串输出：{tasks[0]} -> “作业”；{task_name .title()}
    -> “购物清单”；{number*number} -> 25。
- en: As a key programming concept, we often encounter the term *expression.* Some
    beginners may confuse this term with a related concept *statement.* An expression
    usually is one line of code (it can expand to multiple lines, such as a triple-quoted
    string) that evaluates to a value or an object, such as a string or a custom class
    instance. Applying this definition, we can easily figure out that variables are
    a kind of expression.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种关键编程概念，我们经常遇到术语*表达式*。一些初学者可能会将这个术语与相关概念*语句*混淆。表达式通常是一行代码（它可以扩展到多行，例如三引号字符串），计算为一个值或对象，例如字符串或自定义类实例。根据这个定义，我们可以轻松地弄清楚变量是一种表达式。
- en: By contrast, statements don’t create any value or object, and a statement’s
    purpose is to complete an action. We use assert, for example, to create an assertion
    statement, which ensures that something is valid before proceeding. We aren’t
    trying to produce a True or False Boolean value; we’re checking or asserting a
    condition. Figure 2.1 illustrates the differences between expressions and statements.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，语句不会创建任何值或对象，语句的目的就是完成一个动作。例如，我们使用assert创建断言语句，以确保在继续之前某件事是有效的。我们并不是试图产生一个True或False布尔值；我们是在检查或断言一个条件。图2.1说明了表达式和语句之间的区别。
- en: '![CH02_F01_Cui](../Images/CH02_F01_Cui.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F01_Cui](../Images/CH02_F01_Cui.png)'
- en: Figure 2.1 Differences between expressions and statements. Expressions represent
    something and are evaluated to a value or an object, whereas statements execute
    specific actions and can’t be evaluated to a value.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 表达式和语句之间的区别。表达式表示某物，并计算为一个值或对象，而语句执行特定操作，不能计算为一个值。
- en: 'Although f-strings interpolate expressions natively, we should use this skill
    with caution because any complicated expressions in an f-string compromise the
    readability of your code. The following example represents a misuse of an f-string
    that uses a complex expression:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然f-字符串可以原生地插值表达式，但我们应谨慎使用这项技能，因为f-字符串中的任何复杂表达式都会损害代码的可读性。以下是一个使用复杂表达式的f-字符串误用的例子：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A rule of thumb for checking your code’s readability is to determine how much
    time a reader needs to digest your code. In the preceding code, it may take tens
    of seconds for a reader to know what you want to achieve. As a direct contrast,
    consider the following refactored version:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 检查代码可读性的一个经验法则是确定读者消化你的代码需要多少时间。在前面的代码中，读者可能需要数十秒才能知道你想要实现什么。作为直接对比，考虑以下重构版本：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This version has several things to note. First, we use a list object to store
    the scores to remove the duplication of the data. Second, we use separate steps,
    with each step representing a simpler calculation. Third, the key thing for improved
    readability is that each step uses a sensible name to indicate the calculation
    result. Without any comment, your code is comfortable to read; everything is clear
    by itself.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本有几个需要注意的地方。首先，我们使用列表对象来存储分数，以消除数据的重复。其次，我们使用单独的步骤，每个步骤代表一个更简单的计算。第三，提高可读性的关键是每个步骤使用一个合理的名称来指示计算结果。在没有任何注释的情况下，你的代码易于阅读；一切都很清楚。
- en: Readability Create necessary intermediate variables with sensible names to clearly
    indicate each step of your operations. For these simple operations, you don’t
    even need to write any comment because the sensible names indicate the purpose
    of each operation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性 创建具有合理名称的必要中间变量，以清楚地指示每个操作步骤。对于这些简单的操作，你甚至不需要写任何注释，因为合理的名称表明了每个操作的目的。
- en: 2.1.4 Applying specifiers to format f-strings
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.4 将说明符应用于格式化f-string
- en: The proper formatting of textual data, such as alignment, is key to conveying
    the desired information. As they are designed to handle string formatting, f-strings
    allow us to set a *format specifier* (beginning with a colon) to apply additional
    formatting configurations to the expression in the curly braces (figure 2.2).
    In this section, you’ll learn how to apply the specifiers to format f-strings.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正确格式化文本数据，如对齐，是传达所需信息的关键。由于它们被设计用来处理字符串格式化，f-string允许我们设置一个*格式说明符*（以冒号开头）来对花括号中的表达式应用额外的格式配置（图2.2）。在本节中，你将学习如何应用这些说明符来格式化f-string。
- en: '![CH02_F02_Cui](../Images/CH02_F02_Cui.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F02_Cui](../Images/CH02_F02_Cui.png)'
- en: Figure 2.2 Components of an f-string. The expression is the first part and is
    required. The expression is evaluated first, and a corresponding string is created.
    The second part, which is the format specifier, is optional.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 f-string的组成部分。表达式是第一部分，是必需的。表达式首先被评估，然后创建相应的字符串。第二部分，即格式说明符，是可选的。
- en: As an optional component, the format specifier defines how the interpolated
    string of the expression should be formatted. An f-string can accept different
    kinds of format specifiers. Let’s explore some of the most useful ones next, starting
    with text alignment.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 作为可选组件，格式说明符定义了表达式插入字符串应该如何格式化。f-string可以接受不同类型的格式说明符。接下来，我们将探讨一些最有用的格式说明符，从文本对齐开始。
- en: Aligning strings to create a visual structure
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文本对齐创建视觉结构
- en: One way to improve communication efficiency is to use a structured organization,
    which is also true for presenting textual data. As shown in figure 2.3, scenario
    B provides clearer information than scenario A due to its more organized structure,
    with the columns aligned.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 提高沟通效率的一种方法是用结构化的组织，这在呈现文本数据时也是正确的。如图2.3所示，由于结构更组织化，列对齐，场景B比场景A提供了更清晰的信息。
- en: '![CH02_F03_Cui](../Images/CH02_F03_Cui.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F03_Cui](../Images/CH02_F03_Cui.png)'
- en: Figure 2.3 Improved clarity when the texts are presented in an organized structure
    (scenario B) compared with the default left alignment (scenario A)
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 与默认的左对齐（场景A）相比，当文本以有组织的结构呈现时（场景B），提高了清晰度
- en: 'Text alignment in f-strings involves three characters: <, >, and ^, which align
    the text left, right, and center, respectively. If you’re confused about which
    is which, *remember to focus on the arrow’s tip;* if it’s on the left side, for
    example, the text is left-aligned.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: f-string中的文本对齐涉及三个字符：<, >, 和 ^，分别对文本进行左对齐、右对齐和居中对齐。如果你对哪个是哪个感到困惑，*记住要关注箭头的尖端；*例如，如果它在左侧，文本就是左对齐的。
- en: To specify text alignment as the format specifier, we use the syntax f”{expr:x<n}”,
    in which expr means the interpolated expression, x means the padding character
    (when omitted, it defaults to spaces) for alignment, < means left alignment, and
    n is an integer that the string expands in width. Applying this syntax, the code
    in the next listing shows how to create two properly aligned records with improved
    clarity.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要将文本对齐指定为格式说明符，我们使用语法f”{expr:x<n}”，其中expr表示插值表达式，x表示填充字符（省略时默认为空格）用于对齐，<表示左对齐，n是一个整数，表示字符串扩展的宽度。应用此语法，下一列表中的代码展示了如何创建两个正确对齐的记录，以提高清晰度。
- en: Listing 2.2 Applying format specifiers in f-strings
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列出2.2：在f-strings中应用格式说明符
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Applies format specifiers to the expressions
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将格式说明符应用于表达式
- en: One thing that should catch your attention is that you apply the *same* format
    specifier for all the expressions, which represents repetition. When you see repetitions
    in your code, you’re likely violating the DRY (Don’t Repeat Yourself) principle,
    which is a signal for refactoring.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 应该引起你注意的是，你应该为所有表达式应用**相同的**格式说明符，这代表重复。当你看到代码中的重复时，你很可能会违反DRY（不要重复自己）原则，这是一个重构的信号。
- en: The DRY principle and refactoring
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: DRY原则和重构
- en: We can apply many principles to our coding. One famous one is the DRY principle.
    When your program includes repeated code, it’s likely that you can refactor it
    to remove such repetitions. Some IDEs, such as PyCharm, include features that
    automatically detect duplications, and you should take advantage of those features
    to better your program.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将许多原则应用到我们的编码中。其中一个著名的是DRY原则。当你的程序包含重复的代码时，你很可能会将其重构以去除这些重复。一些IDE，如PyCharm，包括自动检测重复的功能，你应该利用这些功能来改进你的程序。
- en: When I say refactor*,* I mean taking steps to update existing code to improve
    its design, structure, and thus maintainability. Refactoring isn’t intended to
    add features to your program; instead, it’s meant to restructure existing code
    without inducing any changes in its external behavior. Whenever applicable, you’ll
    see examples of refactoring throughout the book.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说“重构”时，我的意思是采取步骤更新现有代码以改进其设计、结构和可维护性。重构的目的不是向你的程序添加功能；相反，它意味着在不改变其外部行为的情况下重构现有代码。在适用的情况下，你将在本书中看到重构的示例。
- en: 'In listing 2.2, if we have a new text alignment requirement, we must update
    the code in three locations, which is inconvenient and error-prone. Thus, the
    objective of refactoring is to have a mechanism to use a variable for the format
    specifier. Listing 2.3 shows a possible solution that extracts the repetitive
    part: the format specifier. Taking the refactoring a step further, we define a
    function to accept the format specifier as a parameter, allowing us to try different
    format specifiers. To improve readability, we create separate variables for the
    task’s information.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在列出2.2中，如果我们有一个新的文本对齐要求，我们必须在三个地方更新代码，这既不方便又容易出错。因此，重构的目标是有一个机制来使用变量作为格式说明符。列出2.3显示了一个可能的解决方案，它提取了重复的部分：格式说明符。将重构进一步推进，我们定义了一个函数来接受格式说明符作为参数，允许我们尝试不同的格式说明符。为了提高可读性，我们为任务的详细信息创建了单独的变量。
- en: Listing 2.3 Refactored function to take any format specifier
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列出2.3：接受任何格式说明符的重构函数
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'One important thing to note in listing 2.3 is that the format specifier fmt
    is enclosed within curly braces, embedded within the outside curly braces. Python
    knows how to replace {fmt} with the proper format specifier. Let’s try this function
    with different format specifiers:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在列出2.3时需要注意的一个重要事项是，格式说明符fmt被括号包围，嵌套在外部括号内。Python知道如何将{fmt}替换为正确的格式说明符。让我们尝试使用不同的格式说明符来运行这个函数：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, the refactored code allows us to set any format specifier, and
    this flexibility highlights the benefit of refactoring. When we use format specifiers
    for text alignment, text forms distinct columns, creating visual boundaries to
    separate different pieces of information.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，重构后的代码允许我们设置任何格式说明符，这种灵活性突出了重构的好处。当我们使用格式说明符进行文本对齐时，文本形成不同的列，创建视觉边界来分隔不同的信息块。
- en: Maintainability We constantly spot opportunities to refactor our code, usually
    at a “local” level. The local optimization may seem to be insignificant, but these
    small improvements add up and determine the entire project’s overall maintainability.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性 我们不断发现重构代码的机会，通常是在“局部”层面。局部优化可能看起来微不足道，但这些小的改进会累积起来，并决定整个项目的整体可维护性。
- en: We have been using spaces as padding for the alignment; we can use other characters
    as padding too. Our choice of characters depends on whether they make the information
    stand out. Table 2.1 shows some examples of using different paddings and alignments.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直使用空格作为填充进行对齐；我们也可以使用其他字符作为填充。我们选择的字符取决于它们是否使信息突出。表 2.1 显示了使用不同填充和对齐的一些示例。
- en: Table 2.1 F-string format specifiers for text alignment
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.1 F-string 格式说明符用于文本对齐
- en: '| F-string | Output | Description |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| F-string | 输出 | 描述 |'
- en: '| f"{task:*>10}"¹ | "**homework" | Right alignment, * as padding |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| f"{task:*>10}"¹ | "**homework" | 右对齐，* 作为填充 |'
- en: '| f"{task:*<10}" | "homework**" | Left alignment, * as padding |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| f"{task:*<10}" | "homework**" | 左对齐，* 作为填充 |'
- en: '| f"{task:*^10}" | "*homework*" | Center alignment, * as padding |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| f"{task:*^10}" | "*homework*" | 居中对齐，* 作为填充 |'
- en: '| f"{task:^10}" | " homework " | Center alignment, space as padding |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| f"{task:^10}" | " homework " | 居中对齐，空格作为填充 |'
- en: '(¹ We define the task as a string variable: task = "homework".)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: （¹ 我们将任务定义为字符串变量：task = "homework"。）
- en: Formatting numbers
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化数字
- en: Numbers are integral sources of information that we often include in textual
    material. There are multiple forms of numeric values, such as large integers,
    floating-point numbers, and percentages. In this section, you’ll learn how f-strings
    can represent numeric values with proper formatting specifiers to improve their
    readability.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 数字是信息的重要来源，我们经常将其包含在文本材料中。存在多种数值形式，例如大整数、浮点数和百分比。在本节中，你将学习如何使用 f 字符串通过适当的格式说明符来表示数值，以提高其可读性。
- en: 'There is an infinite number of prime numbers. By doing a quick Google search,
    we can find that the smallest prime number greater than 1 billion is 1000000007\.
    To show this large integer, it’s a good idea to use separators between digits,
    and a common approach is to use commas every three digits. To apply separators
    to integers in an f-string, the format specifier is xd, where x is the separator
    and d is the specific format specifier for integers:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有无限多的质数。通过快速进行 Google 搜索，我们可以找到大于 10 亿的最小质数是 1000000007。为了显示这个大整数，使用数字之间的分隔符是个好主意，常见的方法是每三位数字使用逗号分隔。要在
    f 字符串中的整数上应用分隔符，格式说明符是 xd，其中 x 是分隔符，d 是整数的具体格式说明符：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Floating-point numbers, or decimal numbers in general, can be found in almost
    any scientific or engineering report. As you probably expect, f-strings have format
    specifiers that allow us to format decimals in a readable manner. Consider the
    following examples:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数，或一般的小数，几乎可以在任何科学或工程报告中找到。正如你可能预期的，f 字符串有格式说明符，允许我们以可读的方式格式化小数。考虑以下示例：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As with d for integers, we use f as a format specifier for decimal values.
    Although the f format specifier can be used alone, it’s more often used to specify
    how many digits we want to keep after the decimal symbol: .2 to keep two digits,
    .4 to keep four digits, and so on.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与整数中的 d 一样，我们使用 f 作为十进制值的格式说明符。虽然 f 格式说明符可以单独使用，但它更常用于指定我们想要在小数符号后保留多少位数字：.2
    保留两位数字，.4 保留四位数字，依此类推。
- en: 'In a similar fashion to using f for decimals, we can use e as the format specifier
    for scientific notations. Consider the following examples of this feature:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于使用 f 表示十进制，我们可以使用 e 作为科学记数法的格式说明符。考虑以下该功能的示例：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Another common form of numeric values is percentages, and the format specifier
    for percentages is the percent sign (%). As we do with the e and f specifiers,
    we can use the % specifier alone or in conjunction with the precision specification,
    such as .2 for two-digit precision:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 数值的一个常见形式是百分比，百分比的格式说明符是百分号（%）。正如我们使用 e 和 f 说明符一样，我们可以单独使用 % 说明符或与精度说明符结合使用，例如
    .2 表示两位精度：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In addition to these format specifiers, f-strings support other specifiers.
    Table 2.2 shows common specifiers that you can apply to f-strings when you deal
    with numbers.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些格式说明符之外，f 字符串还支持其他说明符。表 2.2 显示了在处理数字时可以应用于 f 字符串的常见说明符。
- en: Table 2.2 Common format specifiers for formatting numbers with f-strings
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.2 使用 f 字符串格式化数字的常见格式说明符
- en: '| Numeric type | F-string | Output | Description |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 数值类型 | F-string | 输出 | 描述 |'
- en: '| int | f"{number:b}" | "1111" | Binary format, using base 2 |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| int | f"{number:b}" | "1111" | 二进制格式，使用基数2 |'
- en: '|  | f"{number:c}" | "\x0f" | Unicode representation of the integer |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '|  | f"{number:c}" | "\x0f" | 整数的 Unicode 表示 |'
- en: '|  | f"{number:d}" | "15" | Decimal format, using base 10 |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '|  | f"{number:d}" | "15" | 十进制格式，使用基数10 |'
- en: '|  | f"{number:o}" | "17" | Octal format, using base 8 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '|  | f"{number:o}" | "17" | 八进制格式，使用基数8 |'
- en: '|  | f"{number:x}" | "f" | Hexadecimal format, using base 16 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '|  | f"{number:x}" | "f" | 十六进制格式，使用16为基数 |'
- en: '| float | f"{point:.2e}" | "1.23e+00" | Scientific notation |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| float | f"{point:.2e}" | "1.23e+00" | 科学计数法 |'
- en: '|  | f"{point:.2f}" | "1.23" | Fixed-point notation with two-digit precision
    |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '|  | f"{point:.2f}" | "1.23" | 保留两位小数的定点表示法 |'
- en: '|  | f"{point:.2g}" | "1.23" | General format, automatically applying e or
    f |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '|  | f"{point:.2g}" | "1.23" | 通用格式，自动应用e或f |'
- en: '|  | f"{point:.2%}" | "123.45%" | Percentage with two-digit precision² |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '|  | f"{point:.2%}" | "123.45%" | 百分比，保留两位小数² |'
- en: (² We define the number as an integer variable (number = 15) and the point as
    a float variable (point = 1.2345). Please note that the .2 portion in the format
    specifiers for floats is optional. When you use .3, you’ll have three-digit precision.)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: (² 我们将数字定义为整数变量（number = 15）和浮点变量（point = 1.2345）。请注意，浮点格式说明符中的.2部分是可选的。当你使用.3时，你将有三位小数精度。)
- en: 2.1.5 Discussion
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.5 讨论
- en: Although directly interpolating expressions by f-strings makes code cleaner,
    avoid using complicated expressions in f-strings, which may confuse your readers.
    Instead, create intermediate variables with sensible names when the expressions
    are complicated.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然直接通过f-string插值表达式可以使代码更简洁，但避免在f-string中使用复杂的表达式，这可能会使读者困惑。相反，当表达式复杂时，创建具有合理名称的中间变量。
- en: Python still supports the conventional C-style and format-based approaches,
    but there is no real need for you to learn them (you may see them in legacy code,
    though). Whenever you need to create string output, use f-strings. Don’t forget
    about aligning your text and formatting numeric values to improve the text output’s
    clarity.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Python仍然支持传统的C风格和基于格式的接近方法，但你实际上没有必要学习它们（尽管你可能在旧代码中看到它们）。每次你需要创建字符串输出时，请使用f-string。不要忘记对齐文本和格式化数值以提高文本输出的清晰度。
- en: 2.1.6 Challenge
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.6 挑战
- en: 'James works in a wholesale company’s IT department and is preparing a template
    of price tags. Suppose that the product’s data is saved as a dict object: {"name":
    "Vacuum", "price": 130.675}. How can James write an f-string if the desired output
    is Vacuum: {130.68}? Note that the price requires two-digit precision and that
    the output includes curly braces, which are coincidentally the characters for
    string interpolation in f-strings.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 'James在一家批发公司的IT部门工作，正在准备价格标签模板。假设产品的数据被保存为一个字典对象：`{"name": "Vacuum", "price":
    130.675}`。如果期望的输出是`Vacuum: {130.68}`，James应该如何编写f-string？请注意，价格需要保留两位小数，并且输出包括花括号，这些花括号恰好是f-string中的字符串插值字符。'
- en: 'Hint Curly braces are special characters in f-strings. When a string literal
    includes special characters, you need to escape them in such a way that they’re
    no longer evaluated as special characters. To escape curly braces, you use an
    extra curly brace: {{ means {, and }} means }.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：花括号在f-string中是特殊字符。当字符串字面量包含特殊字符时，你需要以这种方式转义它们，使它们不再被评估为特殊字符。要转义花括号，你使用额外的花括号：{{表示{，}}表示}。
- en: 2.2 How do I convert strings to retrieve the represented data?
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 如何将字符串转换为检索表示的数据？
- en: 'Although strings are textual data on their surface, the actual data represented
    by strings can be integers, dictionaries, and other data types. The built-in input
    function, for example, is the most basic way to collect users’ input in a Python
    console:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然表面上字符串是文本数据，但字符串实际表示的数据可以是整数、字典和其他数据类型。例如，内置的`input`函数是收集Python控制台用户输入的最基本方式：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Checks the variable’s type
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查变量的类型
- en: 'As shown in the preceding code snippet, the user’s input is taken as a string.
    Suppose that we wanted to check whether the user’s age is over 18\. We think we
    can run the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，用户的输入被当作字符串。假设我们想要检查用户的年龄是否超过18岁。我们认为我们可以运行以下代码：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Unfortunately, the comparison didn’t work because age is a string, and you can’t
    compare a string with an integer. This example highlights the necessity of converting
    a string to an integer. More broadly, many other scenarios require that we convert
    strings to lists, dictionaries, and other applicable data types. Such conversion
    is essential for subsequent data processing. In this section, you’ll learn how
    to check the data types represented by the strings and the proper ways to convert
    strings to the desired data types.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，比较没有成功，因为年龄是一个字符串，你不能将字符串与整数进行比较。这个例子突出了将字符串转换为整数的必要性。更广泛地说，许多其他场景需要我们将字符串转换为列表、字典和其他适用的数据类型。这种转换对于后续数据处理至关重要。在本节中，你将学习如何检查字符串表示的数据类型以及将字符串转换为所需数据类型的正确方法。
- en: 2.2.1 Checking whether strings represent alphanumeric values
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 检查字符串是否表示字母数字值
- en: In Python, strings can be anything you can type with your keyboard. One common
    need is to check whether strings include only alphanumeric characters. In this
    section, you’ll learn a variety of ways to check the nature of a string’s characters.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，字符串可以是你可以用键盘输入的任何内容。一个常见的需求是检查字符串是否只包含字母数字字符。在本节中，你将学习检查字符串字符性质的各种方法。
- en: 'Suppose that the task management app requires users to set a username, which
    must be alphanumeric. We can implement this functionality by using the isalnum
    method, which examines whether a string contains only a-z, A-Z, and 0-9. Some
    examples follow:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 假设任务管理应用程序要求用户设置用户名，该用户名必须是字母数字的。我们可以通过使用isalnum方法实现此功能，该方法检查字符串是否只包含a-z、A-Z和0-9。以下是一些示例：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Suppose that when a user creates a task, we require the name to contain letters
    only. For this feature, we can use the isalpha method, which returns True or False.
    As you’ve probably noticed, all these is- methods return Boolean values:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 假设当用户创建任务时，我们要求名称只包含字母。为此功能，我们可以使用isalpha方法，它返回True或False。正如你可能已经注意到的，所有这些is-方法都返回布尔值：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In a similar fashion, you can use the isnumeric method to check whether all
    characters in the string are numeric characters:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，你可以使用isnumeric方法来检查字符串中的所有字符是否都是数值字符：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, I want to discuss a couple of gotchas about checking whether a string
    represents a numeric value when we use the isnumeric method:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我想讨论一下在使用isnumeric方法检查字符串是否表示数值时的一些需要注意的问题：
- en: '*Strings that represent floats won’t pass the* isnumeric *check.* It would
    be reasonable to expect that strings with valid numeric values would return True
    on this method call. Unfortunately, that’s not the case:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*表示浮点数的字符串将不会通过isnumeric检查*。合理地预期，包含有效数值的字符串在这个方法调用上应该返回True。不幸的是，情况并非如此：'
- en: '[PRE20]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Strings that represent negative integers won’t pass the* isnumeric *check.*
    It probably goes against many people’s intuition, too, as in this example:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示负整数的字符串将不会通过*isnumeric*检查。这在很多人看来可能也违背了直觉，例如在这个例子中：
- en: '[PRE21]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Empty strings are evaluated as* False *with* isnumeric*.* Evaluating empty
    strings as non-numeric is probably a desired behavior. We should understand this
    behavior when we deal with conversions from strings to numbers.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*空字符串在isnumeric中被评估为* False *。将空字符串评估为非数值可能是期望的行为。当我们处理字符串到数字的转换时，我们应该理解这种行为。'
- en: To avoid these gotchas, remember that a string produces a True value by means
    of the isnumeric method only if all the characters in a nonempty string are numeric
    characters. Please note that numeric characters don’t include the decimal symbol
    or the negative sign. For this reason, the isnumeric method evaluates floats and
    negative numbers as False.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这些意外，请记住，只有当非空字符串中的所有字符都是数值字符时，字符串才会通过isnumeric方法产生True值。请注意，数值字符不包括小数符号或负号。因此，isnumeric方法将浮点数和负数评估为False。
- en: Differences between isnumeric, isdigit, and isdecimal
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: isnumeric、isdigit和isdecimal之间的区别
- en: Related to the isnumeric method, the methods isdigit and isdecimal are often
    used to check whether strings contain only digits or decimal characters. These
    names seem to mean the same thing, and they produce the same Boolean values in
    most cases, such as "123". But some nuances make them produce different values
    for some strings, especially when numeric strings are not Arabic numerals.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与isnumeric方法相关，isdigit和isdecimal方法通常用于检查字符串是否只包含数字或小数字符。这些名称似乎意味着相同的意思，并且在大多数情况下它们产生相同的布尔值，例如"123"。但一些细微差别使它们在某些字符串上产生不同的值，尤其是在数值字符串不是阿拉伯数字时。
- en: 'By definition, these three methods have the following relationships in terms
    of their strictness of checking numerics: isdecimal < isdigit < isnumeric. When
    you’re confused about these methods, your best bet is to use isnumeric, which
    is the most inclusive.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，这三个方法在检查数值的严格性方面有以下关系：isdecimal < isdigit < isnumeric。当你对这些方法感到困惑时，最好的选择是使用isnumeric，这是最全面的。
- en: Besides the discussed is- methods for checking the numeric nature of strings,
    as a refresher, Python strings have other is- methods that perform other checking
    tasks, such as islower and isupper. Although I don’t cover these other is- methods
    in this book, you should be familiar with them.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 除了讨论过的用于检查字符串数值性质的is-方法之外，作为一个复习，Python字符串还有其他is-方法，它们执行其他检查任务，例如islower和isupper。尽管我在这本书中没有涵盖这些其他is-方法，但你应该熟悉它们。
- en: TRIVIA Among these is- methods, isidentifier is interesting because it tests
    whether a string is a valid identifier to name a variable, a function, or an object
    in general.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**趣闻** 在这些方法中，isidentifier 是一个有趣的方法，因为它测试一个字符串是否是一个有效的标识符，可以用来命名变量、函数或对象。'
- en: 2.2.2 Casting strings to numbers
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2 将字符串转换为数字
- en: In the preceding section, you learned to examine whether a string represents
    a positive integer. But there seems to be no easy way to tell whether a string
    represents a numeric value, particularly when it’s a floating-point or negative
    number. Converting strings to numbers is important because we can’t do any numeric
    calculations with strings, such as comparing age with 18. Thus, in many cases,
    we must derive the represented numeric values of strings for subsequent processing.
    In this section, you’ll learn to convert strings to numbers—a process termed *casting**.*
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你学习了如何检查一个字符串是否表示一个正整数。但似乎没有简单的方法来判断一个字符串是否表示一个数值，尤其是当它是浮点数或负数时。将字符串转换为数字很重要，因为我们不能对字符串进行任何数值计算，例如比较年龄与18岁。因此，在许多情况下，我们必须推导出字符串所表示的数值，以便进行后续处理。在本节中，你将学习如何将字符串转换为数字——这个过程被称为*类型转换*。
- en: CONCEPT In programming, the process of converting a data type to another data
    type, such as converting a string to an integer, is known as *casting**.*
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念** 在编程中，将数据类型转换为另一种数据类型的过程，例如将字符串转换为整数，被称为 *类型转换*。'
- en: The two common data types for numeric values are float and int. The syntax for
    creating these instances from strings is float("string") and int("string"). Python
    evaluates the string objects to cast them to a proper float or int object—*if
    possible.*
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数值，有两种常见的数据类型：float 和 int。从字符串创建这些实例的语法是 float("string") 和 int("string")。Python
    会评估字符串对象，将它们转换为适当的 float 或 int 对象——*如果可能的话*。
- en: 'If you expect a float with a string, you can send it to the built-in float
    constructor. In the following examples, all the casted numbers are of the float
    type, even if the string represents an integer:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你期望一个字符串是 float 类型，你可以将其发送给内置的 float 构造函数。在以下示例中，所有转换后的数字都是 float 类型，即使字符串表示的是整数：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ A float is created even though the string appears to be an integer.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 即使字符串看起来像整数，也会创建一个 float 对象。
- en: CONCEPT A *constructor* refers to a special kind of function that creates an
    instance object of a class. For more on this topic, see chapter 8\. Here, we use
    float and int constructors to create objects of the float and int types, respectively.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念** 一个 *构造函数* 指的是一种特殊的函数，它创建一个类的实例对象。有关这个主题的更多信息，请参阅第 8 章。在这里，我们使用 float
    和 int 构造函数分别创建 float 和 int 类型的对象。'
- en: 'If you expect an integer with a string, you can use the built-in int constructor:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你期望一个字符串是 int 类型，你可以使用内置的 int 构造函数：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Note that when these strings have desired numeric values, these casting operations
    succeed. When they don’t, however, these castings result in errors, which cause
    your entire program to halt, as shown in the following code snippet:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当这些字符串具有所需的数值时，这些类型转换操作会成功。但是，当它们不具备所需数值时，这些转换会导致错误，这会导致你的整个程序停止，如下面的代码片段所示：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To prevent your program from being terminated due to this error, it is important
    to use the try...except... statement to handle the exception. Although I’m not
    expanding the discussion here, the next listing shows such usage. I’ll discuss
    this feature in chapter 12 (section 12.3).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止你的程序因这个错误而终止，使用 try...except... 语句来处理异常是非常重要的。虽然在这里我不展开讨论，但下一个列表显示了这种用法。我将在第
    12 章中讨论这个特性（第 12.3 节）。
- en: Listing 2.4 Casting numbers from strings
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.4 从字符串转换数字
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ Uses the repr function to have the string in a quoted format
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 repr 函数以引号格式显示字符串
- en: 2.2.3 Evaluating strings to derive their represented data
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.3 将字符串评估为获取其表示的数据
- en: Besides numeric values, our application often has textual data that represents
    other data types, such as lists and tuples. For example, in a web application,
    data are commonly entered as text, such as “[1, 2, 3]” which resumes a list object.
    Because of the data type as str, you can’t apply any list methods to this textual
    data—that is, you can only call list methods on list objects. In this case, data
    conversion is required. In this section, you explore how to derive the underlying
    data, other than numbers, from strings.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数值之外，我们的应用程序通常还有表示其他数据类型的文本数据，例如列表和元组。例如，在一个网络应用程序中，数据通常以文本形式输入，如 "[1, 2,
    3]"，它表示一个列表对象。由于数据类型是 str，你不能对这个文本数据应用任何列表方法——也就是说，你只能在列表对象上调用列表方法。在这种情况下，需要进行数据转换。在本节中，你将探索如何从字符串中获取除了数字之外的其他底层数据。
- en: 'In the previous section, you learned to use float and int constructors to cast
    strings to derive numeric values. The approach of using the constructor with a
    string object won’t always work, however. Consider the three common data types—list,
    tuple, and dict—which are represented by strings in the following code snippet:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你学习了如何使用float和int构造函数将字符串转换为数值。然而，使用带有字符串对象的构造函数的方法并不总是有效。考虑以下代码片段中的三个常见数据类型——列表、元组和字典，它们在以下代码片段中由字符串表示：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When we attempt to send the strings directly to their respective constructors,
    unexpected outcomes happen:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试直接将这些字符串发送到相应的构造函数时，会出现意外的结果：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Lists and tuples can instantiate from strings.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 列表和元组可以从字符串实例化。
- en: Although the list and tuple constructors do create a list and a tuple object
    by treating strings as iterables, the created objects wouldn’t be the data that
    you would expect to extract from these strings. Specifically, strings are iterables
    that consist of characters. When you include a string in a list constructor, its
    characters become items of the created list object. The same operation happens
    to a tuple constructor.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然列表和元组构造函数确实通过将字符串作为可迭代对象处理来创建列表和元组对象，但创建的对象不会是你从这些字符串中期望提取的数据。具体来说，字符串是包含字符的可迭代对象。当你将一个字符串包含在列表构造函数中时，它的字符成为创建的列表对象的项。对元组构造函数执行相同的操作。
- en: CONCEPT *Iterables* are objects that can render items one by one. Strings, lists,
    and tuples are common examples of iterables. For further discussion of iterables,
    see chapter 5.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**可迭代**（Iterables）是能够逐个渲染项目的对象。字符串、列表和元组是常见的可迭代对象。关于可迭代的进一步讨论，请参阅第5章。'
- en: 'To solve this unpredicted behavior, use the built-in eval function, which takes
    a string as though you typed it in the console and returns the evaluated result:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这种不可预测的行为，使用内置的eval函数，它将字符串作为你在控制台中输入的字符串处理，并返回评估结果：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: By evaluating these strings, we can retrieve the data that these strings represent.
    This transformation is useful because we often use texts as the data interchange
    format. The benefit of using eval is that the evaluation result of the supplied
    text is guaranteed to be what you expect from running the same text as code in
    a console.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过评估这些字符串，我们可以检索这些字符串所代表的数据。这种转换很有用，因为我们经常使用文本作为数据交换格式。使用eval的好处是，提供的文本的评估结果保证是你从在控制台中运行相同文本作为代码所期望的结果。
- en: Using eval and exec with caution
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 谨慎使用eval和exec
- en: 'You may want to restrict the use of eval to trusted data sources because eval
    will evaluate the string as though the code is part of the program. The following
    snippet shows such a problem. The evaluation of the improper code results in a
    SyntaxError, which could crash your program:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望限制eval的使用范围，仅限于可信的数据源，因为eval会将字符串评估为代码的一部分。以下代码片段显示了这样一个问题。不正确代码的评估会导致SyntaxError，这可能会使你的程序崩溃：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Another built-in exec function is similar to eval. The exec function can run
    a string as though that string is part of the program. The most notable difference
    between exec and eval is that eval evaluates and returns an expression, whereas
    exec can accept expressions and statements such as if...else... but doesn’t return
    anything. Although both functions can provide dynamicity to your application,
    when used improperly, they can jeopardize your application or even your computer.
    You could send the string "os.system('rm -rf *')", for example, to the exec function,
    which would remove all folders and files from your computer.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个内置的exec函数与eval类似。exec函数可以运行一个字符串，就像这个字符串是程序的一部分。exec与eval之间最显著的区别是，eval评估并返回一个表达式，而exec可以接受表达式和语句，如if...else...，但不返回任何内容。尽管这两个函数都可以为你的应用程序提供动态性，但使用不当时，它们可能会危害你的应用程序甚至你的计算机。例如，你可以将字符串
    "os.system('rm -rf *') " 发送到exec函数，这将删除你计算机上的所有文件夹和文件。
- en: Thus, you should be cautious when your application needs to process strings
    as code dynamically by using eval and exec. As an alternative to eval, you can
    look into the ast module in the standard library, which has the literal_eval function
    to evaluate the strings safely.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当你的应用程序需要使用eval和exec动态处理字符串作为代码时，你应该谨慎行事。作为eval的替代方案，你可以查看标准库中的ast模块，它具有literal_eval函数，可以安全地评估字符串。
- en: 'If your application is concerned with the validity of the data source, I recommend
    that you parse the strings yourself. If you need to get a list object of integers
    from a string, for example, you can remove the square brackets and split the strings
    to recreate the applicable list object. A trivial example follows for your reference.
    Please note that the code snippet involves a few techniques, such as string splitting
    and list comprehension, that I cover later (sections 2.3 and 5.2):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序关心数据源的合法性，我建议你自己解析字符串。例如，如果你需要从一个字符串中获取整数列表对象，你可以移除方括号并拆分字符串以重新创建适用的列表对象。以下是一个简单的示例供你参考。请注意，代码片段涉及一些技术，如字符串拆分和列表推导，我将在后面的章节（2.3和5.2）中介绍：
- en: '[PRE30]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Maintainability Using eval without verifying the integrity of the string object
    can cause bugs or even catastrophic outcomes. Be cautious whenever you need to
    use this method.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性 使用eval而不验证字符串对象的一致性可能会导致错误，甚至灾难性的后果。每次你需要使用此方法时都要小心。
- en: 2.2.4 Discussion
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.4 讨论
- en: When we use the float or int constructor to derive the actual numeric values
    that strings represent, consider using try...except... because successful casting
    is never guaranteed, and when casting fails, it crashes the program if the exception
    isn’t handled. When you use eval to obtain the underlying data, you should be
    cautious, as it can introduce danger to a program if you use untrusted sources.
    Thus, when data security is a concern, you should consider parsing the data yourself
    or using a more secure tool, such as the ast module. If you work on your own data,
    such as a script for processing data, you can just use eval to obtain the underlying
    data.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用浮点数或整数构造函数来获取字符串表示的实际数值时，请考虑使用try...except...，因为成功的转换并不总是保证的，如果转换失败，并且没有处理异常，程序会崩溃。当你使用eval来获取底层数据时，你应该小心，因为如果你使用不受信任的来源，它可能会给程序带来危险。因此，当数据安全是一个关注点时，你应该考虑自己解析数据或使用更安全的工具，例如ast模块。如果你处理自己的数据，例如处理数据的脚本，你只需使用eval来获取底层数据。
- en: 2.2.5 Challenge
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.5 挑战
- en: 'At the beginning of this section, you learned that you can use the input function
    to collect a user’s input. Mary is an elementary school teacher who wants to write
    a simple toy program for her students. Suppose that she wants to ask the students
    about today’s temperature in Celsius degrees, using a Python console. How can
    she write the program so that it meets the following requirements? x represents
    the value that the user enters:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的开始，你学习了你可以使用input函数来收集用户的输入。玛丽是一位小学教师，她想要为她的学生编写一个简单的玩具程序。假设她想要询问学生今天的摄氏度温度，使用Python控制台。她如何编写程序以满足以下要求？x代表用户输入的值：
- en: When the temperature is < 10 degrees, output You entered x degrees. It's cold!
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当温度小于10度时，输出你输入了x度。天气寒冷！
- en: When the temperature is between 10 and 25 degrees, output You entered x degrees.
    It's cool!
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当温度在10到25度之间时，输出你输入了x度。天气凉爽！
- en: When the temperature is > 25 degrees, output You entered x degrees. It's hot!
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当温度大于25度时，输出你输入了x度。天气炎热！
- en: The x value should have one decimal precision. If the user enters 15.75, for
    example, it should be displayed as 15.8.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: x值应保留一位小数精度。例如，如果用户输入15.75，则应显示为15.8。
- en: Hint The entered string input needs to be casted to a float number before it
    can be compared with other numbers. To create a string output, use f-strings.
    Don’t forget about format specifiers!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 输入的字符串输入需要在与其他数字比较之前转换为浮点数。要创建字符串输出，请使用f-strings。不要忘记格式说明符！
- en: 2.3 How do I join and split strings?
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 我该如何连接和拆分字符串？
- en: 'Strings are not always in the format that you want them to be. In some cases,
    individual strings represent discrete pieces of related information, and we need
    to join them to form a single string. Suppose that a user enters multiple strings,
    with each representing a fruit that they like. We may join the strings to create
    a single string to display the user’s likes, as shown here:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串不一定是你想要的形式。在某些情况下，单个字符串代表相关信息的离散部分，我们需要将它们连接起来形成一个单独的字符串。假设用户输入了多个字符串，每个字符串代表他们喜欢的某种水果。我们可能将字符串连接起来创建一个单独的字符串来显示用户的喜好，如下所示：
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'At other times, we need to split strings to create multiple strings. Suppose
    that a user enters all the countries that they’ve been to as a single string.
    We want to have a list of these countries, as shown here:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他时候，我们需要拆分字符串以创建多个字符串。假设用户输入了他们访问过的所有国家作为一个单独的字符串。我们希望有一个这些国家的列表，如下所示：
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: These two scenarios are plausible examples of basic string processing jobs that
    you might encounter in a real-life project. In this section, we explore key functionalities
    for joining and splitting strings, using realistic examples.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个场景是你在实际项目中可能会遇到的基本字符串处理任务的合理示例。在本节中，我们通过使用现实生活中的例子来探索连接和拆分字符串的关键功能。
- en: 2.3.1 Joining strings with whitespaces
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 使用空白字符连接字符串
- en: 'When you join multiple strings, you can use the explicit concatenation operator:
    the + symbol, which you saw in listing 2.1\. When you have multiple string literals,
    you can join them if they’re separated by whitespaces, such as spaces, tabs, and
    newline characters. In this section, you’ll see how strings separated by whitespaces
    can be joined.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当你连接多个字符串时，可以使用显式的连接运算符：加号（+）符号，正如你在列表2.1中看到的。当你有多个字符串字面量时，如果它们之间由空白字符（如空格、制表符和换行符）分隔，你可以将它们连接起来。在本节中，你将看到如何将用空白字符分隔的字符串连接起来。
- en: 'Suppose that we have multiple configurations to set a display style for our
    application. We separate each configuration as a string literal, and these individual
    configuration settings are joined automatically:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有多组配置来设置我们应用程序的显示样式。我们将每个配置作为一个字符串字面量分开，这些单独的配置设置会自动连接起来：
- en: '[PRE33]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Automatic concatenation can only occur among string literals, however, and
    you can’t use this technique with string variables or a mixture of string literals
    and variables. F-strings also support automatic concatenation. This feature is
    useful when you construct a long f-string by breaking distinct string literals
    into separate lines of code for clarity:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 自动连接只能在字符串字面量之间发生，你不能用这个技术处理字符串变量或字符串字面量和变量的混合。F字符串也支持自动连接。当你通过将不同的字符串字面量拆分成单独的代码行以提高清晰度来构建一个长的f字符串时，这个特性非常有用：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ❶ Uses the backslash as the line continuation character
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用反斜杠作为行续接字符
- en: Readability When a string is long, consider breaking it into multiple lines,
    with each line representing a meaningful substring. These substrings can be joined
    automatically when they’re separated by whitespaces.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性 当字符串很长时，考虑将其拆分成多行，每行代表一个有意义的子字符串。这些子字符串在它们之间用空白字符分隔时可以自动连接。
- en: 2.3.2 Joining strings with any delimiters
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 使用任何分隔符连接字符串
- en: Joining strings separated by spaces can be a little confusing because the boundaries
    (spaces) between string literals don’t make it easy for us to eyeball the individual
    strings. Moreover, it can occur only between string literals, which is an additional
    restriction. As a general scenario, joining strings with any delimiters is ideal.
    In this section, you’ll learn to join strings with any applicable delimiter.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用空格分隔的字符串连接可能会有些令人困惑，因为字符串字面量之间的边界（空格）并不容易让我们直观地看到单个字符串。此外，它只能在字符串字面量之间发生，这是一个额外的限制。作为一个一般情况，使用任何分隔符连接字符串是理想的。在本节中，你将学习如何使用任何适用的分隔符连接字符串。
- en: 'Still, consider the style setting example. We can use the join method to concatenate
    these separate strings:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，考虑样式设置示例。我们可以使用`join`方法将这些单独的字符串连接起来：
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The join method takes a list of strings as its argument. The items of the list
    are joined sequentially with the delimiter string that we use to call the method.
    Although we use a list object here, more broadly speaking, it can be any iterable,
    such as tuple or set.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`join`方法接受一个字符串列表作为其参数。列表中的项将按照我们调用方法时使用的分隔符字符串依次连接。虽然我们在这里使用了一个列表对象，但更广泛地说，它可以是任何可迭代对象，例如元组或集合。'
- en: str.join or list.join
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`str.join`或`list.join`'
- en: Frankly, the method call "separator".join(the_list) puzzled me a bit when I
    started to use Python, because in daily life, I was used to saying that I wanted
    to join these items with a specific separator. With that logic, you might expect
    the list object to appear before the specifier. In fact, in another common language,
    JavaScript, the Array (like list in Python) has the join method, which creates
    a delimited string from its items. Applying this logic, you would expect Python
    list objects to have the join method.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 实话实说，当我刚开始使用Python时，方法调用`separator`.join(the_list)`让我有些困惑，因为在日常生活中，我习惯于说我想用特定的分隔符连接这些项。按照这个逻辑，你可能会期望列表对象出现在指定符之前。实际上，在另一种常见的语言JavaScript中，数组（类似于Python中的列表）有一个`join`方法，它可以从其项创建一个分隔符字符串。应用这个逻辑，你可能会期望Python列表对象有`join`方法。
- en: 'Unfortunately, that is not the case. Instead, Python’s strings have the join
    method. Thus, there appears to be a mismatch between the expectation and the actual
    implementation. Later, I found out that the best way to remember the correct method
    call signature is to think of this feature this way: I want to use the specific
    separator to join each of the items in the list object.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，情况并非如此。相反，Python的字符串有join方法。因此，似乎期望的实现与实际实现之间存在不匹配。后来，我发现记住正确的方法调用签名的最佳方式是这样的：我想使用特定的分隔符来连接列表对象中的每个项目。
- en: When you learn more about Python, you’ll find out that Python’s design of having
    join as a string method is brilliant. Not only items in a list can be joined by
    a separator; we can also use join with tuples, sets, dictionaries, map objects,
    and any other iterables. If Python were to have join as a list method, to have
    the same feature for other iterables, Python would have to implement join for
    each type of the iterables, which violates DRY!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当你更多地了解Python时，你会发现Python将join作为字符串方法的设计非常出色。不仅列表中的项目可以用分隔符连接；我们还可以使用join与元组、集合、字典、map对象以及任何其他可迭代对象一起使用。如果Python将join作为列表方法来实现，以提供其他可迭代对象的相同功能，Python将不得不为每种可迭代类型实现join，这违反了DRY原则！
- en: 'Compared with the direct concatenation, join is more readable, as contributing
    strings are separate items; thus, it’s easy for us to know what is to be joined.
    More importantly, join has an extra advantage: we can manipulate the items dynamically
    in the list object.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 与直接连接相比，join更易于阅读，因为贡献的字符串是单独的项目；因此，我们很容易知道要连接什么。更重要的是，join有一个额外的优势：我们可以动态地操作列表对象中的项目。
- en: 'Suppose that we want to have a string to list the tasks that we want to complete
    for the week in our task management application. To begin, we have the following
    tasks. We can join these strings to generate a string as a note to display on
    our desktop:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在任务管理应用程序中有一个字符串来列出我们希望在本周完成的任务。首先，我们有以下任务。我们可以将这些字符串连接起来生成一个字符串，作为显示在桌面上的备注：
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After some hard work, a few tasks are done, so we’re removing these tasks:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些艰苦的工作，一些任务已经完成，所以我们要移除这些任务：
- en: '[PRE37]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'After removing these tasks, we can still use the join method to create the
    needed string:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 移除这些任务后，我们仍然可以使用join方法来创建所需的字符串：
- en: '[PRE38]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This example shows a use case with a list of strings that is subject to dynamic
    changes. When we have additional tasks, we can add the tasks to the list object
    and regenerate the desired string with the join method to create an updated string.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了具有动态变化字符串列表的使用案例。当我们有额外的任务时，我们可以将这些任务添加到列表对象中，并使用join方法重新生成所需的字符串以创建更新的字符串。
- en: 2.3.3 Splitting strings to create a list of strings
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.3 将字符串分割成字符串列表
- en: We often use text files to save and transfer data. We can save tabulated data
    to a text file, for example, with each line representing a record. When we read
    the text file, each row is a single string containing multiple substrings, and
    each substring represents a value for the record. To process the data, we need
    to extract these values with split strings to obtain separate substrings. This
    section covers topics related to string splitting.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常使用文本文件来保存和传输数据。例如，我们可以将表格数据保存到文本文件中，其中每一行代表一条记录。当我们读取文本文件时，每一行是一个包含多个子字符串的单个字符串，每个子字符串代表记录的一个值。为了处理数据，我们需要使用分割字符串来提取这些值，以获得单独的子字符串。本节涵盖了与字符串分割相关的话题。
- en: 'Suppose that we have a text file named "task_data.txt" that stores some tasks.
    Each row represents a task’s information, including task ID number, name, and
    urgency level, as shown in the following code snippet. Because you’re going to
    learn how to read data from a file in chapter 11, assume that you’ve read the
    text data and saved it as a multiline string, using triple quotes:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为"task_data.txt"的文本文件，其中存储了一些任务。每一行代表一个任务的详细信息，包括任务ID号、名称和紧急程度，如下面的代码片段所示。因为你在第11章将要学习如何从文件中读取数据，所以假设你已经读取了文本数据，并使用三引号将其保存为多行字符串：
- en: '[PRE39]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: TRIVIA You can use single or double quotes to create a triple-quoted string
    that expands multiple lines. F-strings also support triple quotes for a multiline
    f-string.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 逸事：你可以使用单引号或双引号来创建一个展开多行的三引号字符串。F-字符串也支持三引号的多行f-string。
- en: To process this string, we can use the split method, which can locate the specified
    delimiters and separate the string accordingly. The next listing shows a possible
    solution.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这个字符串，我们可以使用split方法，它可以定位指定的分隔符并相应地分离字符串。下面的列表显示了可能的解决方案。
- en: Listing 2.5 Processing text data by splitting strings
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.5 通过拆分字符串处理文本数据
- en: '[PRE40]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ❶ Splits each line’s text
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 拆分每一行的文本
- en: 'One limitation of the split method is that it allows us to specify only one
    separator, which can be a problem when strings are separated with different separators.
    Suppose that we have a text file that mixes the use of commas and underscores
    as separators. For simplicity, only one separator exists between words. For demonstration
    purposes, consider a single line of data: messy_data = "process,messy_data_mixed,separators".'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: split 方法的局限性在于它只允许我们指定一个分隔符，当字符串使用不同的分隔符分隔时，这可能会成为一个问题。假设我们有一个文本文件，它混合了逗号和下划线作为分隔符的使用。为了简单起见，单词之间只有一个分隔符。为了演示目的，考虑一行数据：messy_data
    = "process,messy_data_mixed,separators"。
- en: 'The problem is likely to occur in real life when we deal with uncleaned raw
    data. When we encounter this problem, we must think about a programmatic way to
    solve the problem because chances are that the text file has tons of records.
    Apparently, using the split method on these records won’t work, as we can set
    only one kind of separator. Thus, we must consider alternative solutions:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理未清理的原始数据时，这个问题很可能会在现实生活中出现。当我们遇到这个问题时，我们必须考虑一种程序化的方法来解决它，因为很可能会发现文本文件中有大量的记录。显然，在这些记录上使用
    split 方法是不行的，因为我们只能设置一种类型的分隔符。因此，我们必须考虑替代方案：
- en: 'Use separators sequentially:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 依次使用分隔符：
- en: We split the strings by using commas to create a list.
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用逗号拆分字符串以创建一个列表。
- en: 'We examine whether the item in the list contains any underscores. If no, the
    item is ready. If yes, we perform a second split using underscores:'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查列表中的项是否包含任何下划线。如果没有，则该项就绪。如果有，我们使用下划线进行第二次拆分：
- en: '[PRE41]'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ❶ When no match is found, the result will be -1.
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❶ 当没有找到匹配项时，结果将是 -1。
- en: ❷ The extend method appends all items of the split strings.
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❷ 扩展方法将拆分字符串的所有项附加到列表中。
- en: Consolidate the separators.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 合并分隔符。
- en: 'Because we know that there are only two possible separators, we can convert
    one separator to the other, which allows us to call the split method just once
    to complete the needed operation:'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为我们知道只有两种可能的分隔符，所以我们可以将一个分隔符转换为另一个分隔符，这允许我们只需调用一次 split 方法即可完成所需的操作：
- en: '[PRE42]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ❶ Uses the replace method to replace a substring
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❶ 使用 replace 方法替换子字符串
- en: These two solutions are straightforward. If you know the basic operations with
    strings and lists, they are perfect solutions if performance isn’t a concern,
    because they require multiple passes to examine the separators, particularly when
    you must deal with multiple separators. In that case, the operations are more
    expensive in terms of computation.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种解决方案都很直接。如果你熟悉字符串和列表的基本操作，那么在性能不是问题的情况下，它们是完美的解决方案，因为它们需要多次遍历来检查分隔符，尤其是在你必须处理多个分隔符的情况下。在这种情况下，操作在计算方面更加昂贵。
- en: Is there any more performant solution? The answer is yes. Regular expressions
    are designed to handle this more complicated pattern matching and searching, as
    I discuss in sections 2.4 and 2.5.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 是否有更高效的解决方案？答案是肯定的。正则表达式被设计用来处理这种更复杂的模式匹配和搜索，正如我在第 2.4 节和第 2.5 节中讨论的那样。
- en: CONCEPT *Regular expressions,* often shortened to *regex* or *regexp,* are sequences
    of characters that define specific search patterns.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 概念 *正则表达式*，通常简称为 *regex* 或 *regexp*，是由字符序列定义的特定搜索模式。
- en: 2.3.4 Discussion
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.4 讨论
- en: Choosing string concatenation, f-string, or join should be evaluated on a case-by-case
    basis. The key is making your code readable. When you have a small number of strings
    to join, you can use concatenation operators to join them. When you have more
    strings, you should consider using f-strings first to bring related strings together.
    The join method is particularly useful for joining individual strings when these
    strings are saved in an iterable.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 选择字符串连接、f-string 或 join 应该根据具体情况评估。关键是使你的代码可读。当你有少量字符串要连接时，你可以使用连接运算符来连接它们。当你有更多字符串时，你应该首先考虑使用
    f-string 来将相关字符串组合在一起。join 方法在将这些字符串保存为可迭代对象时连接单个字符串特别有用。
- en: 'Besides split, strings have another method: rsplit, which has a similar functionality
    to split. The only difference is that you set a maximal number of items to the
    maxsplit parameter to be created from the split. Section 2.3.5 explores split
    and rsplit further.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 split，字符串还有一个方法：rsplit，它具有与 split 类似的功能。唯一的区别是你可以设置一个最大项数，通过 maxsplit 参数从拆分中创建。第
    2.3.5 节将进一步探讨 split 和 rsplit。
- en: 2.3.5 Challenge
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.5 挑战
- en: The split and rsplit methods have the following calling signature. Both methods
    take an argument to specify the separator and another to specify the maximal number
    of created items. Can you write a few strings to split to make them behave the
    same way and differently?
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`split` 和 `rsplit` 方法有以下调用签名。两种方法都接受一个参数来指定分隔符，另一个参数来指定创建的最大项目数。你能写几个字符串来使它们的行为相同和不同吗？'
- en: '[PRE43]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Hint Both methods typically behave the same way. When the number of maximal
    splits is smaller than the number of split items, you’ll see a difference.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：两种方法通常行为相同。当最大分割次数小于分割项数时，你会看到差异。
- en: 2.4 What are the essentials of regular expressions?
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 正则表达式的关键要素是什么？
- en: 'Python’s str class has useful methods, such as find and rfind, for searching
    substrings. Many scenarios go beyond what these basic methods can address, however,
    particularly when it comes to complex pattern matching. In these cases, we should
    consider using regular expressions. In the previous section, I mentioned that
    you can use regular expressions to split a string containing multiple kinds of
    separators—a use case that isn’t easy to address with pure str-based methods.
    Here’s a peek at the solution using regular expressions:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `str` 类包含一些有用的方法，例如 `find` 和 `rfind`，用于搜索子字符串。然而，许多场景超出了这些基本方法所能解决的问题，尤其是在复杂模式匹配方面。在这些情况下，我们应该考虑使用正则表达式。在前一节中，我提到你可以使用正则表达式来分割包含多种分隔符的字符串——这是一个纯
    `str` 方法难以解决的问题。下面是使用正则表达式解决问题的示例：
- en: '[PRE44]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ❶ Compiles the desired regular expression
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 编译所需的正则表达式
- en: From the performance perspective, we traverse the string only one time to complete
    the split. When there are more separators, regular expressions perform much better
    than the other two solutions (section 2.3.3), which require multiple traverses
    of the string. Because of its flexibility and performance, the regular-expressions
    approach is the irreplaceable technique for conducting advanced string processing.
    In this section, I use string searching as the teaching topic to explain the mechanisms
    of regular expressions.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 从性能角度来看，我们只需遍历字符串一次即可完成分割。当存在更多分隔符时，正则表达式的性能比其他两种解决方案（第 2.3.3 节）要好得多，后者需要多次遍历字符串。由于其灵活性和性能，正则表达式方法是在进行高级字符串处理中不可替代的技术。在本节中，我使用字符串搜索作为教学主题来解释正则表达式的机制。
- en: TRIVIA Regular expressions are considered to be independent entities, and all
    common programming languages support regular expressions despite some variations
    in terms of the syntax. Regular expressions are similar, however, and you can
    think of different programming languages as having their own dialects for them.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 知识点 正则表达式被认为是独立实体，尽管在语法方面存在一些差异，但所有常见的编程语言都支持正则表达式。然而，正则表达式是相似的，你可以将不同的编程语言视为拥有它们自己的正则表达式方言。
- en: 2.4.1 Using regular expressions in Python
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.1 在 Python 中使用正则表达式
- en: 'To learn regular expressions, you’ll start with getting the big picture: the
    pertinent module and its core syntax. This section provides a 10,000-foot overview
    of regular expressions in Python.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 要学习正则表达式，你将从了解大局开始：相关的模块及其核心语法。本节提供了 Python 中正则表达式的 10,000 英尺概览。
- en: Python’s standard library includes the re module, which provides features related
    to regular expressions. There are two ways to use this module. The first approach
    pertains to the object-oriented programming (OOP) aspect of Python. Applying the
    OOP paradigm to regular expressions (figure 2.4), we carry out our operations
    with a focus on Pattern objects. In this approach, we first create a Pattern object
    by compiling the desired string pattern. Next, we use this Pattern object to search
    the occurrences that match the pattern.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的标准库中包含 `re` 模块，它提供了与正则表达式相关的功能。使用此模块有两种方式。第一种方法与 Python 的面向对象编程（OOP）方面相关。将
    OOP 模式应用于正则表达式（图 2.4），我们通过关注模式对象来执行操作。在这种方法中，我们首先通过编译所需的字符串模式来创建一个模式对象。接下来，我们使用这个模式对象来搜索与模式匹配的实例。
- en: CONCEPT *OOP* stands for *object-oriented programming,* which is a programming
    design model with a central focus on data and objects rather than functions and
    procedures.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 概念 *OOP* 代表 *面向对象编程*，这是一种以数据和对象为中心的编程设计模型，而不是以函数和过程为中心。
- en: '![CH02_F04_Cui](../Images/CH02_F04_Cui.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F04_Cui](../Images/CH02_F04_Cui.png)'
- en: Figure 2.4 Applying the general OOP in pattern matching. In a general OOP approach,
    we first determine the proper class for the task. In this case, we use the Pattern
    class in the re module. The second step is creating the instance object. In the
    OOP paradigm, an object consists of attributes, which are accessible via dot notations,
    and methods, which are callable via parentheses. The third step is using the created
    Pattern object, such as by accessing its attributes or calling the methods.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 应用通用 OOP 在模式匹配中。在通用 OOP 方法中，我们首先确定适合任务的正确类。在这种情况下，我们使用 re 模块中的 Pattern
    类。第二步是创建实例对象。在 OOP 范式下，一个对象由属性组成，可以通过点符号访问，以及方法，可以通过括号调用。第三步是使用创建的模式对象，例如通过访问其属性或调用其方法。
- en: 'The following code snippet shows how to apply the OOP paradigm to use regular
    expressions for pattern searching:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何将 OOP 范式应用于使用正则表达式进行模式搜索：
- en: '[PRE45]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ❶ Creates a pattern
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建模式
- en: ❷ Accesses attributes
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 访问属性
- en: ❸ Uses methods
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用方法
- en: 'The other style adopts a functional approach. Instead of creating a Pattern
    object, we call the functions directly in the module. In the function call, we
    specify the pattern as well as the string against which the pattern is tested:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种风格采用功能方法。我们不是在模块中创建模式对象，而是直接调用函数。在函数调用中，我们指定模式以及模式要测试的字符串：
- en: '[PRE46]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Behind the scenes, when we call re.search, Python creates the Pattern object
    for us and calls the search method on the pattern. Thus, using the module to call
    these functions is a convenient way to use regular expressions. You should be
    aware of a difference, however: when you use the compile function to create a
    Pattern object, the compiled pattern is cached in such a way that it’s more efficient
    to use the pattern multiple times because there is no need to compile the pattern
    the second time.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，当我们调用 re.search 时，Python 会为我们创建模式对象并调用该模式上的搜索方法。因此，使用模块调用这些函数是使用正则表达式的便捷方式。然而，你应该意识到一个差异：当你使用
    compile 函数创建模式对象时，编译后的模式以某种方式被缓存，这使得多次使用模式更有效率，因为不需要再次编译模式。
- en: CONCEPT *Cache* or *caching* is a mechanism used in programming (and computing
    in general) to store pertinent data so that the data can serve any future requests
    faster.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 概念 *缓存* 或 *缓存机制* 是在编程（以及一般计算）中用来存储相关数据的一种机制，以便数据可以更快地服务于未来的请求。
- en: By contrast, the functional approach creates the pattern on the fly, so it doesn’t
    have the benefit of improved efficiency of the cached pattern. Thus, if you use
    the pattern once, you don’t need to worry about the difference between these two
    approaches.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相反，功能方法会在运行时动态创建模式，因此它没有缓存模式的效率提升优势。因此，如果你只使用一次模式，你不需要担心这两种方法之间的差异。
- en: 2.4.2 Creating the pattern with a raw string
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.2 使用原始字符串创建模式
- en: The key manifestation of the power of regular expressions is the conciseness
    of a pattern to match a wide range of possibilities. To create a pattern, we often
    need to use raw strings, such as a string literal with the prefix r, as in r"pattern".
    In this section, you’ll see why it’s necessary to use raw strings to build a regular-expression
    pattern.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式强大功能的关键表现是模式匹配广泛可能性的简洁性。要创建一个模式，我们通常需要使用原始字符串，例如带有前缀 r 的字符串字面量，如 r"pattern"。在本节中，你将看到为什么需要使用原始字符串来构建正则表达式模式。
- en: In regular expressions, we use \d to match any digit and \w to denote a Unicode
    word character. These are examples of special characters in regular expressions,
    and we use backslashes as the prefixes to indicate that these characters have
    special meanings beyond what they appear to be. Notably, Python strings also use
    backslashes to denote special characters, such as \t for tab, \n for newline,
    and \\ for backslash.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在正则表达式中，我们使用 \d 来匹配任何数字，使用 \w 来表示 Unicode 单词字符。这些都是正则表达式中的特殊字符的例子，我们使用反斜杠作为前缀来表示这些字符具有超出其表面意义的特殊含义。值得注意的是，Python
    字符串也使用反斜杠来表示特殊字符，例如 \t 表示制表符，\n 表示换行符，\\ 表示反斜杠本身。
- en: 'When these coincidences are combined, we end up using weird-looking patterns.
    Suppose that we want to search for \task in strings. Notably, \t is a literal
    here; it really means a backslash and a letter t, but not the tab character. We
    must use \\task so Python can search for \task. Making things even more complicated,
    when we create such a pattern, both backslashes must be escaped, which leads to
    four backslashes (\\\\task) to search \task in strings. Sounds confusing? Examine
    the following code:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些巧合结合在一起时，我们最终会使用看起来很奇怪的图案。假设我们想在字符串中搜索\task。值得注意的是，\t在这里是一个字面量；它实际上意味着一个反斜杠和一个字母t，而不是制表符字符。我们必须使用\\task，这样Python才能搜索\task。事情变得更加复杂，当我们创建这样的模式时，两个反斜杠都必须转义，这导致四个反斜杠（\\\\task）来在字符串中搜索\task。听起来很混乱吗？请查看以下代码：
- en: '[PRE47]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As match searches a string at the beginning, our pattern can match only "\\task".
    This behavior is expected; the two consecutive backslashes are interpreted as
    a literal backslash, which makes the string effectively "\task", matching the
    pattern that we want to search.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 由于match在字符串的开始处搜索，我们的模式只能匹配"\\task"。这种行为是预期的；两个连续的反斜杠被解释为一个字面量反斜杠，这使得字符串实际上变成了"\task"，匹配我们想要搜索的模式。
- en: 'Apparently, using so many backslashes is confusing. To address this problem,
    we should use raw-string notation in such a way that Python doesn’t process any
    backslashes. As in f-string notation, we use r instead of f as the prefix to convert
    a regular string literal to a raw string. Applying raw strings to the pattern,
    we get the following solution:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，使用如此多的反斜杠会让人困惑。为了解决这个问题，我们应该以这种方式使用原始字符串表示法，使得Python不处理任何反斜杠。就像f-string表示法一样，我们使用r而不是f作为前缀，将常规字符串字面量转换为原始字符串。将原始字符串应用于模式，我们得到以下解决方案：
- en: '[PRE48]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As you can tell, the raw string defines a cleaner pattern than the regular string
    literal, with which we had to use four consecutive backslashes. As you can imagine,
    when you build a more complex pattern, you need more backslashes to denote special
    characters. Without raw strings, your patterns will look like puzzles. Thus, it’s
    always a good practice to use raw strings to create regular-expression patterns.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，原始字符串定义了一个比常规字符串字面量更干净的模式，我们不得不使用四个连续的反斜杠。正如你所想象的那样，当你构建更复杂的模式时，你需要更多的反斜杠来表示特殊字符。没有原始字符串，你的模式将看起来像拼图。因此，始终使用原始字符串来创建正则表达式模式是一个好习惯。
- en: Readability Using raw strings to build a pattern eliminates the need to escape
    the special character backslash, making it easier for users to read.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性使用原始字符串构建模式消除了转义特殊字符反斜杠的需要，这使得用户更容易阅读。
- en: 2.4.3 Understanding the essentials of a search pattern
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.3 理解搜索模式的基本要素
- en: The syntax of regular expressions confuses most programmers. As mentioned at
    the beginning of section 2.4, regular expressions constitute a separate language
    with its own unique syntax. The good news is that Python adopts regular expressions’
    syntax in general. In this section, I go over the essential components of a pattern.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式的语法让大多数程序员感到困惑。如第2.4节开头所述，正则表达式构成了一种具有自己独特语法的独立语言。好消息是Python在一般情况下采用了正则表达式的语法。在本节中，我将介绍模式的基本组成部分。
- en: Boundary anchors
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 边界锚点
- en: 'When you work with strings, you may want to know whether a string begins or
    ends with a particular pattern. These use cases are concerned with the boundaries
    of the strings, and we refer to them as boundary anchors, including the beginning
    and the end of a string, as illustrated in the following code:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理字符串时，你可能想知道一个字符串是否以特定的模式开始或结束。这些用例与字符串的边界有关，我们称它们为边界锚点，包括字符串的开始和结束，如下面的代码所示：
- en: '[PRE49]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The ^ symbol signifies that the pattern is concerned about the start of the
    string, whereas the $ symbol signifies that the pattern is concerned about the
    end of the string. The following code snippet shows some examples of these anchors:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ^符号表示模式关注字符串的开始，而$符号表示模式关注字符串的结束。以下代码片段展示了这些锚点的示例：
- en: '[PRE50]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You may know that there are startswith and endswith methods in the str class,
    which work in simple cases. But when you have a more complex need, such as searching
    a string that starts with one or more instances of h followed by i, it’s impossible
    to use startswith because you must account for hi, hhi, hhhi, and more. In such
    a scenario, regular expressions become very handy.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能知道，在 str 类中存在 startswith 和 endswith 方法，它们在简单情况下工作。但是，当你有更复杂的需求时，例如搜索以一个或多个
    h 后跟 i 开头的字符串，使用 startswith 是不可能的，因为你必须考虑 hi、hhi、hhhi 等等。在这种情况下，正则表达式变得非常有用。
- en: Maintainability Although regular expressions are powerful, it’s always a good
    idea to see whether a simpler solution would work, such as startswith or endswith.
    These solutions are more straightforward and less error-prone.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性 虽然正则表达式功能强大，但始终查看是否有一个更简单的解决方案是一个好主意，例如 startswith 或 endswith。这些解决方案更直接，且错误更少。
- en: Quantifiers
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 量词
- en: 'In the previous section, I brought up the question of searching for a variable
    number of characters, which requires creating a pattern that accounts for the
    quantity. Regular expressions address this problem by supporting the quantifiers
    category. This category includes several special characters:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我提出了搜索可变数量字符的问题，这需要创建一个考虑数量的模式。正则表达式通过支持量词类别来解决此问题。这个类别包括几个特殊字符：
- en: '[PRE51]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As you can see, there are four general quantifiers: ? for 0 or 1, * for 0 or
    more, + for 1 or more, and {} for a range. One important thing to note: searching
    a string with the patterns using ?, *, and + is greedy, which means that the pattern
    matches the longest sequence whenever possible. To modify this default behavior,
    we can append the suffix ? to these quantifiers:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，有四个通用的量词：? 表示 0 或 1，* 表示 0 或更多，+ 表示 1 或更多，{} 表示范围。需要注意的是：使用 ?, *, 和 + 的模式进行字符串搜索是贪婪的，这意味着模式尽可能匹配最长的序列。为了修改这种默认行为，我们可以在这些量词后附加后缀
    ?：
- en: '[PRE52]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: These search results should be consistent with what you can expect. Among these
    results, the last several patterns involve the use of the ? suffix, which makes
    the pattern match the shortest possible sequence that satisfies the pattern instead
    of the longest one.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这些搜索结果应该符合你的预期。在这些结果中，最后几个模式涉及使用 ? 后缀，这使得模式匹配满足模式的最短序列，而不是最长序列。
- en: Character classes and sets
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 字符类和集合
- en: 'The flexibility of regular expressions arises from the simplicity of using
    a few characters to denote multiple possibilities of characters. When I introduced
    raw strings in section 2.4.2, I mentioned that you can use \d to denote any digit.
    You can specify many other character sets with regular expressions. Here, I focus
    on the most common ones:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式的灵活性源于使用少量字符表示多个字符可能性的简单性。当我在2.4.2节中介绍原始字符串时，我提到你可以使用 \d 来表示任何数字。你可以使用正则表达式指定许多其他字符集。在这里，我专注于最常见的一些：
- en: '[PRE53]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You should note a few things about using [] to define a character set:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [] 定义字符集时，你应该注意以下几点：
- en: '*You can include individual characters.* [abcxyz] will match any of these six
    characters, and [0z] will match "0" and "z".'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以包括单个字符。[abcxyz] 将匹配这六个字符中的任何一个，而 [0z] 将匹配 "0" 和 "z"。
- en: '*You can include a range of characters.* [a-z] will match any character between
    "a" and "z", and [A-Z] will match any character between "A" and "Z".'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以包括字符范围。[a-z] 将匹配 "a" 和 "z" 之间的任何字符，而 [A-Z] 将匹配 "A" 和 "Z" 之间的任何字符。
- en: '*You can even combine different ranges of characters.* [a-dw-z] will match
    any character between "a" and "d" and "w" and "z".'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你甚至可以组合不同的字符范围。[a-dw-z] 将匹配 "a" 和 "d" 以及 "w" 和 "z" 之间的任何字符。
- en: 'The best way to remember what each character set does is to study specific
    examples, as shown in the following code snippet:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆每个字符集的作用的最佳方式是研究具体的示例，如下面的代码片段所示：
- en: '[PRE54]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The identified matches form several pairs of complements. \d locates all digits,
    for example, and \D locates all the nondigits. Recognizing that these character
    classes make the opposite matches helps you remember them. The key to mastering
    regular expressions is practice!
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 识别的匹配形成几个互补对。\d 定位所有数字，例如，而 \D 定位所有非数字。认识到这些字符类进行相反匹配有助于你记住它们。掌握正则表达式的关键是实践！
- en: Logical operators
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: 'Like other programming languages, regular expressions have logical operations
    in terms of defining the patterns. These operations are the most common ones:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他编程语言一样，正则表达式通过定义模式来进行逻辑操作。这些操作是最常见的：
- en: '[PRE55]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Use a pair of parentheses to denote an exact group of characters that must
    be present, and use the caret sign to create a character set by negating a specific
    one. If you want to find any character that is not s, for example, you can use
    [^s]. Here are some examples for your reference:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一对括号来表示必须存在的确切字符组，并使用插入符号来通过否定特定字符来创建字符集。例如，如果你想找到任何不是s的字符，你可以使用[^s]。以下是一些参考示例：
- en: '[PRE56]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 2.4.4 Dissecting the matches
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.4 解构匹配项
- en: When you’ve learned to build a proper pattern, one obvious task is finding all
    the matches, as you did with the findall method (section 2.4.3). The findall method
    may be the most useful when the involved texts are short and we can easily figure
    out where the matches are. In actual projects, we’ll likely deal with a large
    chunk of text, so showing us what the matches are doesn’t help. Instead, we want
    to know where and what the matches are. This task is what Match objects are all
    about. This section shows how to process the matches.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 当你学会了构建合适的模式后，一个明显的任务就是找到所有匹配项，就像你在使用findall方法（第2.4.3节）时做的那样。当涉及到的文本较短且我们能够轻松地找出匹配项的位置时，findall方法可能最为有用。在实际项目中，我们很可能会处理大量的文本，所以仅仅展示匹配项并不帮助。相反，我们想知道匹配项在哪里以及是什么。这项任务正是Match对象所关注的。本节将展示如何处理匹配项。
- en: Creating Match objects
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Match对象
- en: 'The match and search methods are often used for pattern searching. The major
    difference between match and search is where they look for matches. The match
    method is interested in whether a match exists at the beginning of the string;
    the search method scans the string until it finds a match (if one exists). Despite
    this difference, both methods return a Match object when the pattern finds a match.
    For the sake of learning Match objects, focus on an example that calls the search
    method:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: match和search方法通常用于模式搜索。match和search之间的主要区别在于它们寻找匹配项的位置。match方法关注字符串开头是否存在匹配项；search方法扫描字符串直到找到匹配项（如果存在）。尽管存在这种差异，但两种方法在找到匹配项时都返回一个Match对象。为了学习Match对象，关注一个调用search方法的示例：
- en: '[PRE57]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The key information about a Match object is its matched string and the span.
    We can retrieve them with their respective methods: group, span, start, and end,
    as shown in the next listing.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Match对象的关键信息是其匹配的字符串和范围。我们可以通过它们各自的方法：group、span、start和end来检索它们，如下一列表所示。
- en: Listing 2.6 Methods of a Match object
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.6 Match对象的方 法
- en: '[PRE58]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'When we use regular expressions, we perform specific operations only if a match
    is identified. To make our life easy, a Match object always evaluates to True
    when used in a conditional statement. Here’s a general-use style:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用正则表达式时，我们仅在识别到匹配项时执行特定操作。为了使我们的工作更简单，Match对象在条件语句中始终评估为True。以下是一种通用风格：
- en: '[PRE59]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Readability When you use if...else... with regular expressions, you can include
    a Match object directly in the if clause as a Match object evaluates to True.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性 当你使用正则表达式结合if...else...时，可以直接在if子句中包含一个Match对象，因为Match对象评估为True。
- en: Working with multiple groups
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 处理多个组
- en: 'One thing that may puzzle you is why these pieces of information are retrieved
    by calling methods instead of attributes: match.span() vs. match.span. If you’re
    wondering why, congratulations; you’re developing a good sense of the OOP principle.
    I agree with you that from the OOP perspective, your intuition that the data should
    be attributes is correct. But you implement the feature by using method invocations
    because pattern searching can result in multiple groups. If you pay close attention
    to listing 2.6, you’ll notice that you use the group method to retrieve the matched
    string. Are you wondering when a match can have multiple groups? Find out through
    an example:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 可能让你感到困惑的一件事是，为什么这些信息是通过调用方法而不是属性来检索的：match.span()与match.span。如果你想知道为什么，恭喜你；你正在培养良好的面向对象原则感。我同意你的观点，从面向对象的角度来看，你认为数据应该是属性是正确的。但你是通过使用方法调用来实现这个功能的，因为模式搜索可能会导致多个组。如果你仔细观察列表2.6，你会注意到你使用group方法来检索匹配的字符串。你在想匹配项何时会有多个组吗？通过一个例子来找出答案：
- en: '[PRE60]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This pattern involves two groups (enclosed within parentheses), each of which
    searches for one or more word characters separated by a comma and a space. As
    mentioned previously, the matching is greedy because the longest possible sequence
    is 'Homework, urgent'. The identified match creates separate groups that correspond
    to the pattern’s groups.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式涉及两组（括号内），每组都搜索一个或多个由逗号和空格分隔的单词字符。如前所述，匹配是贪婪的，因为可能的最长序列是“Homework, urgent”。识别出的匹配创建的单独组对应于模式的组。
- en: 'By default, group 0 is the entire match. The subsequent groups are matched
    based on the pattern’s groups. Because of the multiple groups that a pattern can
    match, it’s better to use methods to retrieve each group’s information instead
    of an attribute, which can’t accept arguments. The same grouping also applies
    to span:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，组 0 是整个匹配。后续的组基于模式的组进行匹配。由于模式可以匹配多个组，最好使用方法来检索每个组的信息，而不是使用无法接受参数的属性。相同的分组也适用于
    span：
- en: '[PRE61]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 2.4.5 Knowing the common methods
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.5 了解常用方法
- en: To use regular expressions effectively in our projects, we must know what functionalities
    are available for us to use. Table 2.3 summarizes the key methods; each method
    is accompanied by an example for illustration purposes.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的项目中有效地使用正则表达式，我们必须知道我们可以使用哪些功能。表 2.3 总结了关键方法；每个方法都附有示例以供说明。
- en: Table 2.3 Common regular expression methods
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.3 常见正则表达式方法
- en: '| Method | Code example | Match/return value |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 代码示例 | 匹配/返回值 |'
- en: '| search: Returns a Match if a match is found anywhere in the string. | re.search(r"\d+",
    "ab12xy") | ''12'' |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| search: 如果在字符串的任何位置找到匹配项，则返回 Match。 | re.search(r"\d+", "ab12xy") | ''12''
    |'
- en: '| re.search(r"\d+", "abxy") | None |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| re.search(r"\d+", "abxy") | None |'
- en: '| match: Returns a Match only if a match is found at the string’s beginning.
    | re.match(r"\d+", "ab12xy") | None |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| match: 仅当在字符串的开始处找到匹配项时返回 Match。 | re.match(r"\d+", "ab12xy") | None |'
- en: '| re.match(r"\d+", "12abxy") | ''12'' |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| re.match(r"\d+", "12abxy") | ''12'' |'
- en: '| findall: Returns a list of strings that match the pattern. When the pattern
    has multiple groups, the item is a tuple. | re.findall(r"h[ie]\w", "hi hey hello")
    | [''hey'', ''hel''] |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| findall: 返回与模式匹配的字符串列表。当模式有多个组时，项是一个元组。 | re.findall(r"h[ie]\w", "hi hey
    hello") | [''hey'', ''hel''] |'
- en: '| re.findall(r"(h&#124;H)(i&#124;e)", "Hey hello") | [(''H'', ''e''), (''h'',
    ''e'')] |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| re.findall(r"(h&#124;H)(i&#124;e)", "Hey hello") | [(''H'', ''e''), (''h'',
    ''e'')] |'
- en: '| finditer: Returns an iterator³ that yields the Match objects. | re.finditer(r"(h&#124;H)(i&#124;e)",
    "hi Hey hello") | An iterator |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| finditer: 返回一个迭代器³，它产生 Match 对象。 | re.finditer(r"(h&#124;H)(i&#124;e)", "hi
    Hey hello") | An iterator |'
- en: '| split: Splits the string by the pattern. | re.split(r"\d+", ''a1b2c3d4e'')
    | [''a'', ''b'', ''c'', ''d'', ''e''] |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| split: 通过模式分割字符串。 | re.split(r"\d+", ''a1b2c3d4e'') | [''a'', ''b'', ''c'',
    ''d'', ''e''] |'
- en: '| sub: Creates a string by replacing the matched with the replacement. | re.sub(r"\D",
    "-", ''123,456_789'') | ''123-456-789'' |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| sub: 通过替换匹配项创建字符串。 | re.sub(r"\D", "-", ''123,456_789'') | ''123-456-789''
    |'
- en: (³An *iterator* is an object that can be iterated, such as in a for loop. I
    cover iterators in chapter 5.)
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: (³An *iterator* is an object that can be iterated, such as in a for loop. I
    cover iterators in chapter 5.)
- en: 'For the methods in table 2.3, I want to highlight the key points regarding
    their usages:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 对于表 2.3 中的方法，我想强调它们使用的关键点：
- en: Both search and match identify a single Match object. The biggest difference
    is that match is anchored to the beginning of the string, whereas search scans
    the string, and a match in the middle is also valid.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: search 和 match 都识别单个 Match 对象。最大的区别是 match 锚定在字符串的开始处，而 search 则扫描字符串，中间的匹配也是有效的。
- en: When you try to locate all matches, the findall method returns all the matches
    without providing any information about where they are. Thus, more commonly, you
    want to use finditer. That method returns an iterator that yields each Match object,
    which has more descriptive information about the match (such as location).
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你尝试定位所有匹配项时，findall 方法返回所有匹配项，但不提供它们的位置信息。因此，更常见的是使用 finditer。该方法返回一个迭代器，它产生每个
    Match 对象，该对象包含有关匹配的更多描述性信息（例如位置）。
- en: The split method splits the string by all the matched patterns. Optionally,
    you can specify the maximum number of splits that you want.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: The split method splits the string by all the matched patterns. Optionally,
    you can specify the maximum number of splits that you want.
- en: The sub method’s name means *substitute,* and you use this method to replace
    any identified pattern with the specified replacement. In an advanced use case,
    you can specify a function instead of a string literal, which takes a Match object
    as its argument to produce the desired replacement.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子方法（sub method）的名称意味着“替换”，你使用此方法用指定的替换内容替换任何已识别的模式。在高级用法中，你可以指定一个函数而不是字符串字面量，该函数接受一个匹配对象作为其参数以产生所需的替换。
- en: 2.4.6 Discussion
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.6 讨论
- en: The key steps in using regular expressions are (1) creating a pattern, (2) finding
    matches, and (3) processing matches. These steps should be built on a clear understanding
    of the exact needs of your text processing job. Think of the pattern at a higher
    level. Do you need boundary anchors, quantifiers, or character sets? Then drill
    down to the syntax for these categories. Be prepared for your pattern not to work
    as you expect. You must test your pattern by evaluating the matches with a subset
    of your text. There are almost always some edge cases that will surprise you.
    Ensure that the pattern accounts for rare cases before you deploy anything to
    production.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正则表达式的关键步骤是（1）创建模式，（2）查找匹配项，以及（3）处理匹配项。这些步骤应建立在对你文本处理工作确切需求清晰理解的基础上。从更高层次考虑模式。你需要边界锚点、量词还是字符集？然后深入到这些类别的语法。准备好你的模式可能不会按预期工作。你必须通过用你的文本子集评估匹配项来测试你的模式。几乎总是有一些边缘情况会让你感到惊讶。在将任何内容部署到生产之前，确保模式考虑到了罕见情况。
- en: 2.4.7 Challenge
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.7 挑战
- en: Jerry is a graduate student. One of his projects requires him to extract data
    from text. Suppose that the text data is "abc_,abc__,abc,,__abc_,_abc", where
    abc stands for the needed data values. That is, the data values are separated
    by one or more separators. How can he use regular expressions to extract the data
    values?
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 杰瑞是一名研究生。他的一个项目要求他从文本中提取数据。假设文本数据是 "abc_,abc__,abc,,__abc_,_abc"，其中 abc 代表所需的数据值。也就是说，数据值由一个或多个分隔符分隔。他如何使用正则表达式提取数据值？
- en: Hint When you need to create a pattern that involves a variable number of characters,
    think about using pattern quantifiers.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 当你需要创建一个涉及可变字符数的模式时，考虑使用模式量词。
- en: 2.5 How do I use regular expressions to process texts?
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 我如何使用正则表达式处理文本？
- en: Regular expressions are not the easiest topic to grasp because we’re creating
    a general pattern that can match a variety of possibilities. In most cases, the
    pattern looks rather abstract and thus is confusing to many beginners. Therefore,
    don’t feel frustrated if the concept is not making sense to you now; it takes
    time to master regular expressions. When you grasp them, you’ll find them powerful
    for processing textual data.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式不是最容易掌握的主题，因为我们正在创建一个可以匹配多种可能性的通用模式。在大多数情况下，模式看起来相当抽象，因此对许多初学者来说很令人困惑。因此，如果你现在对概念感到困惑，请不要感到沮丧；掌握正则表达式需要时间。当你掌握了它们，你会发现它们在处理文本数据方面非常强大。
- en: Using our task management app as an example, suppose that we have the text shown
    in the following listing to begin with. The text, which is the data recovered
    from a database crash, contains multiple valid records of the tasks, but unfortunately,
    random text appears throughout the data.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们的任务管理应用为例，假设我们最初有如下所示的文本。该文本是从数据库崩溃中恢复的数据，包含多个有效的任务记录，但不幸的是，随机文本遍布整个数据。
- en: Listing 2.7 Text data to be processed
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.7 待处理文本数据
- en: '[PRE62]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: ❶ Triple quotes for multiline strings
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 多行字符串的三重引号
- en: Our job is to extract all the valid records from the text data, leaving out
    invalid records. Suppose that there are several thousand lines of text, making
    it unrealistic to go through the data manually. We need to use a general pattern-searching
    approach to conquer this job, which is exactly what regular expressions are designed
    to do. In this section, I go over the key steps in solving this problem.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工作是从文本数据中提取所有有效的记录，排除无效记录。假设有数千行文本，手动处理数据是不现实的。我们需要使用一种通用的模式搜索方法来完成这项工作，这正是正则表达式设计来做的。在本节中，我将概述解决此问题的关键步骤。
- en: 2.5.1 Creating a working pattern to find the matches
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.1 创建工作模式以查找匹配项
- en: 'The string shown in listing 2.7 highlights a common task when we deal with
    texts: cleaning up the data. Often, the needed data is mixed with unneeded data.
    Thus, we want to implement a programmatic solution, taking advantage of regular
    expressions, to keep only the needed data. In this section, you’ll learn the first
    step: creating the pattern.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.7中显示的字符串突出了我们在处理文本时遇到的一个常见任务：清理数据。通常，所需数据与不需要的数据混合在一起。因此，我们希望实现一个程序性解决方案，利用正则表达式，仅保留所需数据。在本节中，你将学习第一步：创建模式。
- en: 'After making a careful inspection of the raw data, you notice that the valid
    records have three contributing groups: the task ID number in the form of three
    digits, the title of the task, and the description of the task. The first two
    groups are separated by a comma, and the last two groups are separated by a semicolon.
    Based on these pieces of information, you might build the following pattern, with
    each of the components analyzed in detail:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在仔细检查原始数据后，你注意到有效的记录包含三个贡献组：以三位数字形式出现的任务ID，任务的标题，以及任务的描述。前两组由逗号分隔，后两组由分号分隔。基于这些信息，你可能构建以下模式，并对每个组件进行详细分析：
- en: '[PRE63]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Applying this pattern to the text data, you can have a quick look at the outcome.
    At this stage, don’t worry about processing the matches, because you want to make
    sure that the pattern works as expected. You can run the following code after
    you test and modify the pattern multiple times before you reach the desired pattern:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 将此模式应用于文本数据，你可以快速查看结果。在这个阶段，不要担心处理匹配项，因为你想要确保模式按预期工作。在测试和修改模式多次并达到期望的模式之前，你可以运行以下代码：
- en: '[PRE64]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: ❶ Splits the data rows to extract each row
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将数据行拆分以提取每行
- en: ❷ Uses the match method to search for the pattern at the beginning of the string
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用匹配方法在字符串开头搜索模式
- en: ❸ Uses the group method to show the matched string
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用group方法显示匹配的字符串
- en: As mentioned in section 2.4.4, an important feature of the Match object is that
    it evaluates to True, allowing us to work on the Match object only if it is created
    by the match method. From the printout, you see that you obtain valid records
    from the matched objects. By contrast, in those unmatched cases, those records
    are indeed invalid.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如第2.4.4节所述，Match对象的一个重要特性是它评估为True，这允许我们仅在通过match方法创建时才在Match对象上工作。从打印输出中，你可以看到你从匹配对象中获得了有效记录。相比之下，在不匹配的情况下，这些记录确实是无效的。
- en: 2.5.2 Extracting the needed data from the matches
  id: totrans-373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.2 从匹配中提取所需数据
- en: Because the pattern works as expected, it’s time to extract the data and prepare
    it for further processing. To be specific, you want to save each record (ID, title,
    and description) as a tuple object, and the tuple objects form a list object.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 因为模式按预期工作，现在是时候提取数据并准备进一步处理了。具体来说，你希望将每个记录（ID、标题和描述）保存为元组对象，而元组对象形成一个列表对象。
- en: Notably, when you built your pattern, you included three separate groups that
    accounted for each of the task’s data fields. These groups allow you to access
    these individual matches for each group. The next listing shows how groups work.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，当你构建你的模式时，你包括了三个独立的组，分别对应任务的每个数据字段。这些组允许你访问每个组的单个匹配项。下一个列表显示了组是如何工作的。
- en: Listing 2.8 Extracting data from individual groups
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.8 从单个组中提取数据
- en: '[PRE65]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: ❶ Creates a tuple from multiple groups
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从多个组创建元组
- en: 'As shown in listing 2.8, we use the group method and access the identified
    three groups in a sequential manner: group 1 for the ID, group 2 for the title,
    and group 3 for the description. As a related note, when we omit the number parameter
    in the group method, we’ll retrieve the entire match across the groups (see section
    2.4.4).'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表2.8所示，我们使用group方法并按顺序访问识别的三个组：组1用于ID，组2用于标题，组3用于描述。作为一个相关的注释，当我们省略group方法中的数字参数时，我们将检索跨越组的整个匹配（见第2.4.4节）。
- en: In our example, we have three groups in the pattern. When our records get more
    complicated, we may have to deal with more groups. Using the integers to track
    these groups sequentially can be error-prone; it’s not difficult to miscount by
    one, which can lead to unexpected behaviors.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，模式中有三个组。当我们的记录变得更加复杂时，我们可能需要处理更多的组。使用整数按顺序跟踪这些组可能会出错；很容易多计数一个，这可能导致意外的行为。
- en: Isn’t a better solution available? That question leads to the discussion in
    section 2.5.3.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 是否有更好的解决方案？这个问题引出了第2.5.3节中的讨论。
- en: 2.5.3 Using named groups for text processing
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.3 使用命名组进行文本处理
- en: In general, texts provide more semantic information than numbers do. If the
    integers that refer to the groups can be confusing, do we have the option of using
    texts for group referencing? Fortunately, Python supports this feature, which
    is called *named groups.* In essence, this feature allows you to give a name to
    the group in such a way that you can use the name to refer to the group for later
    processing.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，文本提供的语义信息比数字要多。如果引用组的整数可能会令人困惑，我们是否有使用文本进行组引用的选项？幸运的是，Python支持这一功能，称为*命名组*。本质上，这个功能允许你以某种方式给组命名，这样你就可以使用该名称来引用组以进行后续处理。
- en: To name a group, you use the syntax (?P<group_name>pattern), in which you name
    the pattern group as group_name. The name should be a valid Python identifier
    because you must be able to retrieve it by calling the name. Now you can use the
    named groups technique to update the code in listing 2.8, as the next listing
    shows.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 要命名一个组，你使用语法(?P<group_name>pattern)，其中将模式组命名为group_name。该名称应该是一个有效的Python标识符，因为你必须能够通过调用名称来检索它。现在你可以使用命名组技术来更新列表2.8中的代码，如下一个列表所示。
- en: Listing 2.9 Using named groups to extract data
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.9 使用命名组提取数据
- en: '[PRE66]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In the code snippet, we named the three groups task_id, task_title, and task_
    desc, which clearly indicate the data for each group. Later, instead of passing
    an integer to the group method, we can pass the group name directly. Compared
    with the implementation in listing 2.8, using named groups in listing 2.9 improves
    code readability; more important, it decreases the likelihood of referencing a
    wrong group, particularly if a pattern contains many more groups.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码片段中，我们命名了三个组task_id、task_title和task_desc，这清楚地指出了每个组的数据。以后，我们不再将整数传递给组方法，而是可以直接传递组名。与列表2.8中的实现相比，列表2.9中使用命名组提高了代码的可读性；更重要的是，它减少了引用错误组的可能性，尤其是如果模式包含更多的组。
- en: Maintainability Always use sensible identifiers to name variables or any objects.
    This approach not only improves readability, but also leads to fewer possible
    mistakes because you know what data you’re dealing with by looking at the names.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性：始终使用合理的标识符来命名变量或任何对象。这种方法不仅提高了可读性，而且由于你知道通过查看名称你正在处理什么数据，因此可以减少可能的错误。
- en: 'Although we use the group method to retrieve the individual items from the
    identified groups, named groups give us another option for retrieving the identified
    data: the groupdict method. For the first identified match, we might have the
    following data:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们使用group方法从识别出的组中检索单个项，但命名组为我们提供了另一种检索识别数据的选项：groupdict方法。对于第一个识别出的匹配项，我们可能有以下数据：
- en: '[PRE67]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: If you prefer using this dict object for data processing, it’s also a good choice
    in terms of code readability.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢使用这个字典对象进行数据处理，从代码可读性的角度来看，这也是一个好的选择。
- en: 2.5.4 Discussion
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.4 讨论
- en: The first step in using regular expressions is knowing what business needs we
    want to achieve and creating a pattern accordingly. You shouldn’t feel obsessed
    with making the pattern correct on the first try. You must test your pattern with
    the text, and it’ll take multiple rounds of back-and-forth effort to find the
    correct pattern (figure 2.5).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正则表达式的第一步是了解我们想要实现什么业务需求，并据此创建一个模式。你不应该对第一次就使模式正确感到着迷。你必须用文本测试你的模式，找到正确的模式需要多次来回努力（图2.5）。
- en: '![CH02_F05_Cui](../Images/CH02_F05_Cui.png)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F05_Cui](../Images/CH02_F05_Cui.png)'
- en: Figure 2.5 The general process of using regular expressions in processing texts
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 使用正则表达式处理文本的一般过程
- en: When you work with more groups identified through a pattern, I recommend that
    you use named groups, as by naming these groups, you’re clearly telling the readers
    what data a group holds. Later, it’ll be easier to refer to the groups because
    of their sensible names.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用通过模式识别出的更多组时，我建议你使用命名组，因为通过命名这些组，你清楚地告诉读者每个组包含什么数据。以后，由于它们的名称合理，引用组将更容易。
- en: 2.5.5 Challenge
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.5 挑战
- en: When we processed the text data to extract the records, we split the text into
    separate rows. Assuming that each row indeed has one valid record or no record,
    could you find a pattern that processes all the text without splitting the data
    into multiple rows?
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理文本数据以提取记录时，我们将文本分割成单独的行。假设每一行确实有一个有效的记录或没有记录，你能找到一个处理所有文本而不将数据分割成多行的模式吗？
- en: Hint Each row ends with a newline character (\n). Integrate that character into
    your pattern.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：每一行都以换行符（\n）结束。将这个字符整合到你的模式中。
- en: Summary
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: An f-string is a concise way to interpolate variables and expressions.
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: f-string 是一种简洁的方式来插值变量和表达式。
- en: Applying a proper text alignment to an f-string makes the information clear
    by creating visual boundaries for distinct pieces of data.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 f-string 应用适当的文本对齐可以通过创建不同数据片段的视觉边界，使信息更加清晰。
- en: F-strings are also good at formatting numbers, such as scientific notations
    and precisions for decimals.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: f-string 在格式化数字方面也很擅长，例如科学记数法和小数精度。
- en: Python strings have isalnum, isnumeric, and many other is- methods. You can
    use them to determine the nature of a string.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 字符串有 isalnum、isnumeric 以及许多其他的 is- 方法。你可以使用它们来确定字符串的性质。
- en: All Python data, such as integers and lists, can have the appearance of a string
    (such as when data is transferred over the internet and all of it consists of
    strings). We convert these strings to their native data types by evaluating them,
    so we can use the data type-specific methods.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有 Python 数据，如整数和列表，都可以具有字符串的外观（例如，当数据通过互联网传输且全部由字符串组成时）。我们通过评估它们将这些字符串转换为它们的原生数据类型，因此我们可以使用特定数据类型的方法。
- en: When we need to join a few strings, it’s fine to use the concatenation symbols.
    When we deal with multiple strings, however, it’s better to use the join method.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们需要连接几个字符串时，使用连接符号是可以的。然而，当我们处理多个字符串时，最好使用 join 方法。
- en: The split method splits strings, which is a useful data processing tool as well
    as the basis for processing tabulated text files. Although built-in modules are
    available, such as csv, knowing these fundamentals is key to writing a script
    for your own job.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: split 方法用于分割字符串，它是一个有用的数据处理工具，也是处理表格文本文件的基础。尽管有内置模块，如 csv，但了解这些基础知识对于编写适合自己工作的脚本至关重要。
- en: 'The key to using regular expressions is building a pattern that addresses your
    needs. When we build a pattern, we need to start our thinking at a higher level.
    Relevant questions can include these: Do I need multiple groups? How about boundary
    anchors, character sets, or quantifiers?'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正则表达式的关键是构建一个满足你需求的模式。当我们构建模式时，我们需要从更高的层次开始思考。相关的问题可以包括这些：我需要多个组吗？边界锚点、字符集或量词如何？
- en: Named groups make it easier to refer to specific information when you use regular
    expressions to process complicated text data.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名组使得在使用正则表达式处理复杂的文本数据时，更容易引用特定的信息。
