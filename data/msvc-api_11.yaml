- en: 8 Designing GraphQL APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 设计 GraphQL API
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Understanding how GraphQL works
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 GraphQL 的工作原理
- en: Producing an API specification using the Schema Definition Language (SDL)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模式定义语言（SDL）生成 API 规范
- en: Learning GraphQL’s built-in scalar types and data structures and building custom
    object types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习 GraphQL 的内置标量类型和数据结构，以及构建自定义对象类型
- en: Creating meaningful connections between GraphQL types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 GraphQL 类型之间建立有意义的连接
- en: Designing GraphQL queries and mutations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计 GraphQL 查询和突变
- en: GraphQL is one of the most popular protocols for building web APIs. It’s a suitable
    choice for driving integrations between microservices and for building integrations
    with frontend applications. GraphQL gives API consumers full control over the
    data they want to fetch from the server and how they want to fetch it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 是构建 Web API 最受欢迎的协议之一。它是驱动微服务之间集成和构建与前端应用程序集成的合适选择。GraphQL 使 API 消费者能够完全控制他们从服务器获取的数据以及他们希望如何获取这些数据。
- en: 'In this chapter, you’ll learn to design a GraphQL API. You’ll do it by working
    on a practical example: you’ll design a GraphQL API for the products service of
    the CoffeeMesh platform. The products service owns data about CoffeeMesh’s products
    as well as their ingredients. Each product and ingredient contains a rich list
    of properties that describe their features. However, when a client requests a
    list of products, they are most likely interested in fetching only a few details
    about each product. Also, clients may be interested in being able to traverse
    the relationships between products, ingredients, and other objects owned by the
    products service. For these reasons, GraphQL is an excellent choice for building
    the products API.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何设计一个 GraphQL API。你将通过一个实际案例来完成这项工作：你将为 CoffeeMesh 平台的产品服务设计一个 GraphQL
    API。产品服务拥有关于 CoffeeMesh 产品及其成分的数据。每个产品和成分都包含一个丰富的属性列表，描述了它们的特性。然而，当客户端请求产品列表时，他们最可能只对获取每个产品的少量详细信息感兴趣。此外，客户端可能还希望能够遍历产品、成分以及产品服务拥有的其他对象之间的关系。出于这些原因，GraphQL
    是构建产品 API 的一个绝佳选择。
- en: As we build the specification for the products API, you’ll learn about GraphQL’s
    scalar types, designing custom object types, as well as queries and mutations.
    By the end of this chapter, you’ll understand how GraphQL compares with other
    types of APIs and when it makes the most sense to use it. We’ve got a lot to cover,
    so without further ado, let’s start our journey!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们为产品 API 构建规范，你将了解 GraphQL 的标量类型、自定义对象类型的设计，以及查询和突变。到本章结束时，你将了解 GraphQL 与其他类型
    API 的比较，以及何时使用它最为合理。我们有很多内容要覆盖，所以无需多言，让我们开始我们的旅程吧！
- en: To follow along with the specification we develop in this chapter, you can use
    the GitHub repository provided with this book. The code for this chapter is available
    under the folder named ch08.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章中开发的规范，你可以使用本书提供的 GitHub 仓库。本章的代码位于名为 ch08 的文件夹中。
- en: 8.1 Introducing GraphQL
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 介绍 GraphQL
- en: This section covers what GraphQL is, what its advantages are, and when it makes
    sense to use it. The official website of the GraphQL specification defines GraphQL
    as a “query language for APIs and a runtime for fulfilling those queries with
    your existing data.”[¹](#pgfId-1309583) What does this really mean? It means that
    GraphQL is a specification that allows us to run queries in an API server. In
    the same way SQL provides a query language for databases, GraphQL provides a query
    language for APIs.[²](#pgfId-1309586) GraphQL also provides a specification for
    how those queries are resolved in a server so that anyone can implement a GraphQL
    runtime in any programming language.[³](#pgfId-1309589)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了 GraphQL 是什么，它的优势是什么，以及在什么情况下使用它是合理的。GraphQL 规范的官方网站将 GraphQL 定义为“API 的查询语言，以及用现有数据满足这些查询的运行时。”[¹](#pgfId-1309583)
    这到底是什么意思呢？这意味着 GraphQL 是一个规范，允许我们在 API 服务器上运行查询。就像 SQL 为数据库提供查询语言一样，GraphQL 为
    API 提供了查询语言。[²](#pgfId-1309586) GraphQL 还提供了一个规范，说明如何在服务器中解析这些查询，以便任何人都可以在任何编程语言中实现
    GraphQL 运行时。[³](#pgfId-1309589)
- en: Just as we can use SQL to define schemas for our database tables, we can use
    GraphQL to write specifications that describe the type of data that can be queried
    from our servers. A GraphQL API specification is called a schema, and it’s written
    in a standard called Schema Definition Language (SDL). In this chapter, we will
    learn how to use the SDL to produce a specification for the products API.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们可以使用SQL来定义数据库表的模式一样，我们也可以使用GraphQL来编写描述从我们的服务器可以查询的数据类型的规范。GraphQL API规范被称为模式，它使用一种称为模式定义语言（SDL）的标准编写。在本章中，我们将学习如何使用SDL为产品API生成规范。
- en: GraphQL was first released in 2015, and since then it’s gained traction as one
    of the most popular choices for building web APIs. I should say there’s nothing
    in the GraphQL specification saying that GraphQL should be used over HTTP, but
    in practice, this is the most common type of protocol used in GraphQL APIs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL首次发布于2015年，自那时起，它已成为构建Web API最受欢迎的选择之一。我必须说，在GraphQL规范中并没有说GraphQL应该通过HTTP使用，但在实践中，这是GraphQL
    API中最常见的协议类型。
- en: What’s great about GraphQL? It shines in giving users full control over which
    data they want to obtain from the server. For example, as we’ll see in the next
    section, in the products API we store many details about each product, such as
    its name, price, availability, and ingredients, among others. As you can see in
    figure 8.1, if a user wishes to get a list of just product names and prices, with
    GraphQL they can do that. In contrast, with other types of APIs, such as REST,
    you get a full list of details for each product. Therefore, whenever it’s important
    to give the client full control over how they fetch data from the server, GraphQL
    is a great choice.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL的伟大之处在于它能够让用户完全控制他们希望从服务器获取哪些数据。例如，正如我们将在下一节中看到的，在产品API中，我们存储了关于每个产品的许多详细信息，例如其名称、价格、可用性和成分等。如图8.1所示，如果用户只想获取产品名称和价格列表，使用GraphQL可以实现这一点。相比之下，在其他类型的API，如REST中，你会得到每个产品的完整详细信息列表。因此，每当需要让客户端完全控制他们从服务器获取数据的方式时，GraphQL都是一个很好的选择。
- en: '![](../Images/08-01.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/08-01.png)'
- en: Figure 8.1 Using a GraphQL API, a client can request a list of items with specific
    details. In this example, a client is requesting the name and price of each product
    in the products API.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1展示了使用GraphQL API，客户端可以请求具有特定详细信息的项目列表。在这个例子中，客户端正在请求产品API中每个产品的名称和价格。
- en: Another great advantage of GraphQL is the ability to create connections between
    different types of resources, and to expose those connections to our clients for
    use in their queries. For example, in the products API, products and ingredients
    are different but related types of resources. As you can see in figure 8.2, if
    a user wants to get a list of products, including their names, prices, and their
    ingredients, with GraphQL they can do that by leveraging the connections between
    these resources. Therefore, in services where we have highly interconnected resources,
    and where it’s useful for our clients to explore and query those connections,
    GraphQL makes an excellent choice.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL的另一个巨大优势是能够在不同类型的资源之间创建连接，并将这些连接暴露给我们的客户端以供他们在查询中使用。例如，在产品API中，产品和成分是不同但相关的资源类型。如图8.2所示，如果用户想要获取包括产品名称、价格和成分的产品列表，使用GraphQL可以通过利用这些资源之间的连接来实现这一点。因此，在具有高度互联资源的服务中，并且当客户端探索和查询这些连接对客户端有用时，GraphQL是一个极佳的选择。
- en: '![](../Images/08-02.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/08-02.png)'
- en: 'Figure 8.2 Using GraphQL, a client can request the details of a resource and
    other resources linked to it. In this example, the products API has two types
    of resources: products and ingredients, both of which are connected through product’s
    `ingredients` field. Using this connection, a client can request the name and
    price of each product, as well as the name of each product’s ingredient.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2展示了使用GraphQL，客户端可以请求资源的详细信息及其相关联的其他资源。在这个例子中，产品API有两种类型的资源：产品和成分，它们通过产品的`ingredients`字段相互连接。利用这种连接，客户端可以请求每个产品的名称和价格，以及每个产品成分的名称。
- en: In the sections that follow, we’ll learn how to produce a GraphQL specification
    for the products service. We’ll learn how to define the types of our data, how
    to create meaningful connections between resources, and how to define operations
    for querying the data and changing the state of the server. But before we do that,
    we ought to understand the requirements for the products API, and that’s what
    we do in the next section!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将学习如何为产品服务生成GraphQL规范。我们将学习如何定义数据类型，如何创建资源之间的有意义连接，以及如何定义查询数据和更改服务器状态的操作。但在我们这样做之前，我们应该了解产品API的要求，这就是我们在下一节要做的。
- en: 8.2 Introducing the products API
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 介绍产品API
- en: This section discusses the requirements of the products API. Before working
    on an API specification, it’s important to gather information about the API requirements.
    As you can see in figure 8.3, the products API is the interface to the products
    service. To determine the requirements of the products API, we need to know what
    users of the products service can do with it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了产品API的要求。在着手编写API规范之前，收集有关API要求的信息非常重要。如图8.3所示，产品API是产品服务的接口。为了确定产品API的要求，我们需要知道产品服务的用户可以用它做什么。
- en: '![](../Images/08-03.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/08-03.png)'
- en: Figure 8.3 To interact with the products service, clients use the products API.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 客户端通过产品API与产品服务交互。
- en: The products service owns data about the products offered by the CoffeeMesh
    platform. As you can see in figure 8.4, the CoffeeMesh staff must be able to use
    the products service to manage the available stock of each product, as well as
    to keep the products’ ingredients up to date. In particular, they must be able
    to query the stock of a product or ingredient, and to update them when new stock
    arrives to the warehouse. They must also be able to add new products or ingredients
    to the system and delete old ones. This information already gives us a complex
    list of requirements, so let’s break it down into specific technical requirements.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 产品服务拥有关于CoffeeMesh平台提供的产品数据。如图8.4所示，CoffeeMesh员工必须能够使用产品服务来管理每种产品的可用库存，以及保持产品配料的最新状态。特别是，他们必须能够查询产品或配料的库存，并在新库存到达仓库时更新它们。他们还必须能够向系统中添加新产品或配料，并删除旧的。这些信息已经给我们提供了一个复杂的要求列表，所以让我们将其分解为具体的技術要求。
- en: '![](../Images/08-04.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/08-04.png)'
- en: Figure 8.4 The CoffeeMesh staff uses the products service to manage products
    and ingredients.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 CoffeeMesh员工使用产品服务来管理产品和配料。
- en: 'Let’s start with by modeling the resources managed by the products API. We
    want to know which type of resources we should expose through the API and the
    products’ properties. From the description in the previous paragraph, we know
    that the products service manages two types of resources: products and ingredients.
    Let’s analyze products first.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为产品API管理的资源建模开始。我们想知道应该通过API公开哪种类型的资源以及产品的属性。从上一段的描述中，我们知道产品服务管理两种类型的资源：产品和配料。让我们首先分析产品。
- en: 'The CoffeeMesh platform offers two types of products: cakes and beverages.
    As you can see in figure 8.5, both cakes and beverages have a common set of properties,
    including the product’s name, price, size, list of ingredients, and its availability.
    Cakes have two additional properties:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: CoffeeMesh平台提供两种类型的产品：蛋糕和饮料。如图8.5所示，蛋糕和饮料都有一些共同的属性，包括产品的名称、价格、大小、配料列表以及其可用性。蛋糕有两个额外的属性：
- en: '`hasFilling`—Indicates whether the cake has a filling'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasFilling`—表示蛋糕是否有填充物'
- en: '`hasNutsToppingOption`—Indicates whether the customer can add a topping of
    nuts to the cake'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasNutsToppingOption`—表示客户是否可以给蛋糕添加坚果作为配料'
- en: '![](../Images/08-05.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/08-05.png)'
- en: 'Figure 8.5 CoffeeMesh exposes two types of products: `Cake` and `Beverage`,
    both of which share a common list of properties.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 CoffeeMesh公开了两种产品类型：`蛋糕`和`饮料`，它们都共享一组通用的属性列表。
- en: 'Beverages have the following two additional properties:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 饮料有以下两个额外的属性：
- en: '`hasCreamOnTopOption`—Indicates whether the customer can top the beverage with
    cream'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasCreamOnTopOption`—表示客户是否可以加奶油到饮料上'
- en: '`hasServeOnIceOption`—Indicates whether the customer can choose to get the
    beverage served on ice'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasServeOnIceOption`—表示客户是否可以选择要冰镇饮料'
- en: 'What about ingredients? As you can see in figure 8.6, we can represent all
    ingredients through one entity with the following attributes:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 关于成分呢？正如图8.6所示，我们可以通过以下属性使用一个实体来表示所有成分：
- en: '`name`—The ingredient’s name.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`—成分的名称。'
- en: '`stock`—The ingredient’s available stock. Since different ingredients are measured
    with different units, such as kilograms or liters, we express the available stock
    in terms of amounts of per unit of measure.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stock`—该成分的可用库存。由于不同的成分使用不同的单位进行测量，例如千克或升，我们用每单位测量的数量来表示可用库存。'
- en: '`description`—A collection of notes that CoffeeMesh employees can use to describe
    and qualify the product.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`—一组笔记，CoffeeMesh员工可以使用它来描述和说明产品。'
- en: '`supplier`—Information about the company that supplies the ingredient to CoffeeMesh,
    including their name, address, contact number, and email.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`supplier`—关于向CoffeeMesh供应成分的公司信息，包括他们的名称、地址、联系电话和电子邮件。'
- en: '![](../Images/08-06.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6](../Images/08-06.png)'
- en: Figure 8.6 List of properties that describe an ingredient. The ingredient’s
    supplier is described by a resource called `Supplier`, while the ingredient’s
    stock is described through a `Stock` object.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 展示了描述成分的属性列表。成分的供应商由一个名为`Supplier`的资源来描述，而成分的库存通过一个`Stock`对象来描述。
- en: Now that we’ve modeled the main resources managed by the products service, let’s
    turn our attention to the operations we must expose through the API. We’ll distinguish
    read operations from write/delete operations. This distinction will make sense
    when we look more closely at these operations in sections 8.8 and 8.9.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经模拟了产品服务管理的主要资源，让我们将注意力转向我们必须通过API公开的操作。我们将区分读取操作和写入/删除操作。当我们更仔细地查看第8.8节和第8.9节中的这些操作时，这种区分将变得有意义。
- en: 'Based on the previous discussion, we’ll expose the following read operations:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 根据之前的讨论，我们将公开以下读取操作：
- en: '`allProducts()`—Returns the full list of products available in the CoffeeMesh
    catalogue'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allProducts()`—返回CoffeeMesh目录中可用的产品完整列表'
- en: '`allIngredients()`—Returns the full list of ingredients used by CoffeeMesh
    to make their products'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allIngredients()`—返回CoffeeMesh用于制作其产品的所有成分的完整列表'
- en: '`products()`—Allows users to filter the full list of products by certain criteria
    such as availability, maximum price, and others'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`products()`—允许用户根据某些标准（如可用性、最高价格等）过滤产品完整列表'
- en: '`product()`—Allows users to obtain information about a single product'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product()`—允许用户获取单个产品的信息'
- en: '`ingredient()`—Allows users to obtain information about a single ingredient'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ingredient()`—允许用户获取单个成分的信息'
- en: 'In terms of write/delete operations, from the previous discussion it’s clear
    that we should expose the following capabilities:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在写入/删除操作方面，根据之前的讨论，很明显我们应该公开以下功能：
- en: '`addIngredient()`—To add new ingredients'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addIngredient()`—添加新成分'
- en: '`updateStock()`—To update an ingredient’s stock'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updateStock()`—更新成分的库存'
- en: '`addProduct()`—To add new products'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addProduct()`—添加新产品'
- en: '`updateProduct()`—To update existing products'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updateProduct()`—更新现有产品'
- en: '`deleteProduct()`—To delete products from the catalogue'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deleteProduct()`—从目录中删除产品'
- en: Now that we understand the requirements of the products API, it’s time to move
    on to creating the API specification! In the following sections, we’ll learn to
    create a GraphQL specification for the products API, and along the way we’ll learn
    how GraphQL works. Our first stop is GraphQL’s type system, which we’ll use to
    model the resources managed by the APIs.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了产品API的要求，是时候继续创建API规范了！在接下来的章节中，我们将学习如何为产品API创建GraphQL规范，并且在这个过程中，我们将了解GraphQL是如何工作的。我们的第一个停靠点是GraphQL的类型系统，我们将使用它来模拟API管理的资源。
- en: 8.3 Introducing GraphQL’s type system
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 介绍GraphQL的类型系统
- en: In this section, we introduce GraphQL’s type system. In GraphQL, types are definitions
    that allow us to describe the properties of our data. They’re the building blocks
    of a GraphQL API, and we use them to model the resources owned by the API. In
    this section, you’ll learn to use GraphQL’s type system to describe the resources
    we defined in section 8.2.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍GraphQL的类型系统。在GraphQL中，类型是允许我们描述数据属性的定义。它们是GraphQL API的构建块，我们使用它们来模拟API拥有的资源。在本节中，你将学习如何使用GraphQL的类型系统来描述我们在第8.2节中定义的资源。
- en: 8.3.1 Creating property definitions with scalars
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1 使用标量创建属性定义
- en: 'This section explains how we define the type of a property using GraphQL’s
    type system. We distinguish between scalar types and object types. As we’ll see
    in section 8.3.2, object types are collection of properties that represent entities.
    *Scalar types* are types such as Booleans or integers. The syntax for defining
    a property’s type is very similar to how we use type hints in Python: we include
    the name of the property followed by a colon, and the property’s type to the right
    of the colon. For example, in section 8.2 we discussed that cakes have two distinct
    properties: `hasFilling` and `hasNutsToppingOption`, both of which are Booleans.
    Using GraphQL’s type system, we describe these properties like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了我们如何使用 GraphQL 的类型系统来定义属性的类型。我们区分标量类型和对象类型。正如我们将在第 8.3.2 节中看到的，对象类型是表示实体的属性集合。*标量类型*是布尔值或整数等类型。定义属性类型的语法与我们使用
    Python 中的类型提示非常相似：我们包括属性名称后跟一个冒号，以及冒号右侧的属性类型。例如，在第 8.2 节中，我们讨论了蛋糕有两个不同的属性：`hasFilling`
    和 `hasNutsToppingOption`，这两个属性都是布尔值。使用 GraphQL 的类型系统，我们这样描述这些属性：
- en: '[PRE0]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'GraphQL supports the following types of scalars:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 支持以下类型的标量：
- en: '*Strings* (`String`)—For text-based object properties.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*字符串* (`String`)—用于基于文本的对象属性。'
- en: '*Integers* (`Int`)—For numerical object properties.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*整数* (`Int`)—用于数值对象属性。'
- en: '*Floats* (`Float`)—For numerical object properties with decimal precision.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*浮点数* (`Float`)—用于具有小数精度的数值对象属性。'
- en: '*Booleans* (`Boolean`)—For binary properties of an object.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*布尔值* (`Boolean`)—用于对象的二进制属性。'
- en: '*Unique identifiers* (`ID`)—For describing an object ID. Technically, IDs are
    strings, but GraphQL checks and ensures that the ID of each object is unique.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*唯一标识符* (`ID`)—用于描述对象 ID。技术上，ID 是字符串，但 GraphQL 会检查并确保每个对象的 ID 是唯一的。'
- en: 'In addition to defining the type of a property, we can also indicate whether
    the property is non-nullable. Nullable properties are properties that can be set
    to `null` when we don’t know their value. We mark a property as non-nullable by
    placing an exclamation point at the end of the property definition:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 除了定义属性的类型外，我们还可以指示属性是否为非可选的。可选属性是在我们不知道其值时可以设置为 `null` 的属性。我们通过在属性定义的末尾放置一个感叹号来标记属性为非可选的：
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This line defines a property `name` of type `String`, and it marks it as non-nullable
    by using an exclamation point. This means that, whenever we serve this property
    from the API, it will always be a string.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这行定义了一个类型为 `String` 的属性 `name`，并通过使用感叹号将其标记为非可选的。这意味着，无论何时我们从 API 提供这个属性，它都将始终是一个字符串。
- en: Now that we’ve learned about properties and scalars, let’s see how we use this
    knowledge to model resources!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了属性和标量，让我们看看我们如何利用这些知识来建模资源！
- en: 8.3.2 Modeling resources with object types
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.2 使用对象类型建模资源
- en: This section explains how we use GraphQL’s type system to model resources. Resources
    are the entities managed by the API, such as the ingredients, cakes, and beverages
    that we discussed in section 8.2\. In GraphQL, each of these resources is modeled
    as an object type. *Object types* are collections of properties, and as the name
    indicates, we use them to define objects. To define an object type, we use the
    `type` keyword followed by the object name, and the list of object properties
    wrapped between curly braces. A property is defined by declaring the property
    name followed by a colon, and its type on the right side of the colon. In GraphQL,
    `ID` is a type with a unique value. An exclamation point at the end of a property
    indicates that the property is non-nullable. The following illustrates how we
    describe the cake resource as an object type. The listing contains the basic properties
    of the cake type, such as the ID, the name, and its price.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了我们如何使用 GraphQL 的类型系统来建模资源。资源是由 API 管理的实体，例如我们在第 8.2 节中讨论的成分、蛋糕和饮料。在 GraphQL
    中，这些资源中的每一个都被建模为一个对象类型。*对象类型*是一组属性，正如其名称所示，我们使用它们来定义对象。要定义一个对象类型，我们使用 `type` 关键字后跟对象名称，以及用大括号括起来的对象属性列表。一个属性通过声明属性名称后跟一个冒号，以及冒号右侧的类型来定义。在
    GraphQL 中，`ID` 是一个具有唯一值的类型。属性末尾的感叹号表示该属性是非可选的。以下展示了我们如何将蛋糕资源描述为一个对象类型。列表包含了蛋糕类型的基本属性，如
    ID、名称和价格。
- en: Listing 8.1 Definition of the `Cake` object type
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.1 `Cake` 对象类型的定义
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ① We define an object type.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们定义一个对象类型。
- en: ② We define a non-nullble ID property.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们定义一个非可选的 ID 属性。
- en: types and object types For convenience, throughout the book, we use the concepts
    of type and object type interchangeably unless otherwise stated.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 类型与对象类型 为了方便起见，除非另有说明，否则在本书中，我们将类型和对象类型的概念互换使用。
- en: Some of the property definitions in listing 8.1 end with an exclamation point.
    In GraphQL, an exclamation point means that a property is non-nullable, which
    means that every cake object returned by our API will contain an ID, a name, its
    availability, as well as the `hasFilling` and `hasNutsToppingOption` properties.
    It also guarantees that none of these properties will be set to `null`. For API
    client developers, this information is very valuable because they know they can
    count on these properties to always be present and build their applications with
    that assumption. The following code shows the definitions for the `Beverage` and
    `Ingredient` types. It also shows the definition for the `Supplier` type, which
    contains information about the business that supplies a certain ingredient, and
    in section 8.5.1 we’ll see how we connect it with the `Ingredient` type.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.1 中的一些属性定义以感叹号结尾。在 GraphQL 中，感叹号表示属性是非空白的，这意味着我们 API 返回的每个蛋糕对象都将包含一个 ID、一个名称、其可用性，以及
    `hasFilling` 和 `hasNutsToppingOption` 属性。这也保证了这些属性都不会被设置为 `null`。对于 API 客户端开发者来说，这些信息非常有价值，因为他们知道他们可以依赖这些属性始终存在，并据此构建他们的应用程序。以下代码显示了
    `Beverage` 和 `Ingredient` 类型的定义。它还显示了 `Supplier` 类型的定义，该类型包含有关供应特定成分的企业的信息，在 8.5.1
    节中我们将看到如何将其与 `Ingredient` 类型连接起来。
- en: Listing 8.2 Definitions of the `Beverage` and `Ingredient` object types
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.2 `Beverage` 和 `Ingredient` 对象类型的定义
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we know how to define object types, let’s complete our exploration
    of GraphQL’s type system by learning how to create our own custom types!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何定义对象类型，让我们通过学习如何创建自己的自定义类型来完善对 GraphQL 类型系统的探索！
- en: 8.3.3 Creating custom scalars
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.3 创建自定义标量
- en: 'This section explains how we create custom scalar definitions. In section 8.3.1,
    we introduced GraphQL’s built-in scalars: `String`, `Int`, `Float`, `Boolean`,
    and `ID`. In many cases, this list of scalar types is sufficient to model our
    API resources. In some cases, however, GraphQL’s built-in scalar types might prove
    limited. In such cases, we can define our own custom scalar types. For example,
    we may want to be able to represent a date type, a URL type, or an email address
    type.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了如何创建自定义标量定义。在 8.3.1 节中，我们介绍了 GraphQL 的内置标量：`String`、`Int`、`Float`、`Boolean`
    和 `ID`。在许多情况下，这个标量类型列表足以模拟我们的 API 资源。然而，在某些情况下，GraphQL 的内置标量类型可能显得有限。在这种情况下，我们可以定义自己的自定义标量类型。例如，我们可能希望能够表示日期类型、URL
    类型或电子邮件地址类型。
- en: 'Since the products API is used to manage products and ingredients and make
    changes to them, it is useful to add a `lastUpdated` property that tells us the
    last time a record changed. `lastUpdated` should be a `Datetime` scalar. GraphQL
    doesn’t have a built-in scalar of that type, so we have to create our own. To
    declare a custom date-time scalar, we use the following statement:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于产品 API 用于管理产品和成分以及对其进行更改，因此添加一个 `lastUpdated` 属性很有用，该属性告诉我们记录最后一次更改的时间。`lastUpdated`
    应该是一个 `Datetime` 标量。GraphQL 没有内置该类型的标量，因此我们必须自己创建。要声明一个自定义日期时间标量，我们使用以下语句：
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We also need to define how this scalar type is validated and serialized. We
    define the rules for validation and serialization of a custom scalar in the server
    implementation, which will be the topic of chapter 10.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要定义如何验证和序列化此标量类型。我们定义自定义标量在服务器实现中的验证和序列化规则，这将是第 10 章的主题。
- en: Listing 8.3 Using a custom `Datetime` scalar type
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.3 使用自定义的 `Datetime` 标量类型
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ① We declare a custom Datetime scalar.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们声明一个自定义的 Datetime 标量。
- en: ② We declare a non-nullable property with type Datetime.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们声明一个类型为 Datetime 的非空属性。
- en: This concludes our exploration of GraphQL scalars and object types. You’re now
    in a position to define basic object types in GraphQL and create your own custom
    scalars. In the following sections, we’ll learn to create connections between
    different object types, and we’ll learn how to use lists, interfaces, enumerations,
    and more!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对 GraphQL 标量和对象类型的探索。你现在可以定义 GraphQL 中的基本对象类型并创建自己的自定义标量。在接下来的章节中，我们将学习如何在不同的对象类型之间创建连接，以及如何使用列表、接口、枚举等！
- en: 8.4 Representing collections of items with lists
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 使用列表表示项目集合
- en: This section introduces GraphQL lists. Lists are arrays of types, and they’re
    defined by surrounding a type with square brackets. Lists are useful when we need
    to define properties that represent collections of items. As discussed in section
    8.2, the `Ingredient` type contains a property called `description`, which contains
    collections of notes about the ingredient, as shown in the following code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了GraphQL列表。列表是类型的数组，它们通过在类型周围加上方括号来定义。当我们需要定义表示项目集合的属性时，列表非常有用。如第8.2节所述，`Ingredient`类型包含一个名为`description`的属性，它包含有关成分的笔记集合，如下面的代码所示。
- en: Listing 8.4 Representing a list of strings
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.4 表示字符串列表
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ① We define a list of non-nullable items.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们定义了一个不可为空的项列表。
- en: 'Look closely at the use of exclamation points in the `description` property:
    we’re defining it as a nullable property with non-nullable items. What does this
    mean? When we return an ingredient from the API, it may or may not contain a `description`
    field, and if that field is present, it will contain a list of strings.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察`description`属性中感叹号的使用：我们将其定义为具有不可为空项的可空属性。这意味着什么？当我们从API返回成分时，它可能包含也可能不包含`description`字段，如果该字段存在，它将包含字符串列表。
- en: 'When it comes to lists, you must pay careful attention to the use of exclamation
    points. In list properties, we can use two exclamation points: one for the list
    itself and another for the item within the list. To make both the list and its
    contents non-nullable, we use exclamation points for both. The use of exclamation
    points for list types is one of the most common sources of confusion among GraphQL
    users. Table 8.1 summarizes the possible return values for each combination of
    exclamation points in a list property definition.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到列表时，你必须仔细注意感叹号的使用。在列表属性中，我们可以使用两个感叹号：一个用于列表本身，另一个用于列表中的项。为了使列表及其内容都不可为空，我们为两者都使用感叹号。对于列表类型使用感叹号是GraphQL用户中最常见的混淆来源之一。表8.1总结了列表属性定义中感叹号每种组合的可能返回值。
- en: 'USE Exclamation points and lists CAREFULLY! In GraphQL, an exclamation point
    indicates that a property is non-nullable, which means that the property needs
    to be present in an object and its value cannot be `null`. When it comes to lists,
    we can use two exclamation points: one for the list itself and another for the
    item within the list. Different combinations of the exclamation points will yield
    different representations of the property. Table 8.1 shows which representations
    are valid for each combination.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用感叹号和列表要小心！在GraphQL中，感叹号表示属性不可为空，这意味着该属性必须在对象中存在，并且其值不能为`null`。当涉及到列表时，我们可以使用两个感叹号：一个用于列表本身，另一个用于列表中的项。感叹号的不同组合将产生属性的不同表示。表8.1显示了每种组合的有效表示。
- en: Table 8.1 Valid return values for list properties
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.1 列表属性的合法返回值
- en: '|  | `[Word]` | `[Word!]` | `[Word]!` | `[Word!]!` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '|  | `[Word]` | `[Word!]` | `[Word]!` | `[Word!]!` |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `null` | Valid | Valid | Invalid | Invalid |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `null` | 合法 | 合法 | 非法 | 非法 |'
- en: '| `[]` | Valid | Valid | Valid | Valid |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `[]` | 合法 | 合法 | 合法 | 合法 |'
- en: '| `["word"]` | Valid | Valid | Valid | Valid |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `["word"]` | 合法 | 合法 | 合法 | 合法 |'
- en: '| `[null]` | Valid | Invalid | Valid | Invalid |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `[null]` | 合法 | 非法 | 合法 | 非法 |'
- en: '| `["word", null]` | Valid | Invalid | Valid | Invalid |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `["word", null]` | 合法 | 非法 | 合法 | 非法 |'
- en: 'Now that we’ve learned about GraphQL’s type system and list properties, we’re
    ready to explore one of the most powerful and exciting features of GraphQL: connections
    between types.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了GraphQL的类型系统和列表属性，我们准备探索GraphQL最强大和最令人兴奋的功能之一：类型之间的连接。
- en: '8.5 Think graphs: Building meaningful connections between object types'
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5 思考图形：在对象类型之间建立有意义的连接
- en: This section explains how we create connections between objects in GraphQL.
    One of the great benefits of GraphQL is being able to connect objects. By connecting
    objects, we make it clear how our entities are related. As we’ll see in the next
    chapter, this makes our GraphQL API more easily consumed.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了如何在GraphQL中创建对象之间的连接。GraphQL的一个巨大好处是能够连接对象。通过连接对象，我们清楚地说明了我们的实体之间的关系。正如我们将在下一章中看到的，这使得我们的GraphQL
    API更容易被消费。
- en: 8.5.1 Connecting types through edge properties
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.1 通过边缘属性连接类型
- en: 'This section explains how we connect types by using *edge properties*: properties
    that point to another type. Types can be connected by creating a property that
    points to another type. As you can see in figure 8.7, a property that connects
    with another object is called an *edge*. The following code shows how we connect
    the `Ingredient` type with the `Supplier` type by adding a property called `supplier`
    to `Ingredient` that points to `Supplier`.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了如何通过使用**边属性**来连接类型：指向另一个类型的属性。可以通过创建一个指向另一个类型的属性来连接类型。如图8.7所示，连接另一个对象的属性被称为边。以下代码展示了我们如何通过向`Ingredient`添加一个名为`supplier`的属性来连接`Ingredient`类型和`Supplier`类型，该属性指向`Supplier`。
- en: Listing 8.5 Edge for one-to-one connection
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.5 一对一连接的Edge
- en: '[PRE7]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ① We use an edge property to connect the Ingredient and the Supplier types.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们使用边属性来连接Ingredient和Supplier类型。
- en: '![](../Images/08-07.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08-07.png)'
- en: Figure 8.7 To connect the `Ingredient` type with the `Supplier` type, we add
    a property to `Ingredient` called `supplier`, which points to the `Supplier` type.
    Since the `Ingredient`’s `supplier` property is creating a connection between
    two types, we call it an edge.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 要将`Ingredient`类型与`Supplier`类型连接起来，我们在`Ingredient`中添加一个名为`supplier`的属性，该属性指向`Supplier`类型。由于`Ingredient`的`supplier`属性正在在两个类型之间创建连接，我们称它为边。
- en: 'This is an example of *one-to-one connection*: a property in an object that
    points to exactly one object. The property in this case is called an edge because
    it connects the `Ingredient` type with the `Supplier` type. It’s also an example
    of a *directed connection*: as you can see in figure 8.7, we can reach the `Supplier`
    type from the `Ingredient` type, but not the other way around, so the connection
    only works in one direction.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个**一对一连接**的例子：一个对象中的属性指向恰好一个对象。在这个例子中，这个属性被称为边，因为它将`Ingredient`类型与`Supplier`类型连接起来。它也是一个**有向连接**的例子：如图8.7所示，我们可以从`Ingredient`类型到达`Supplier`类型，但不能反过来，所以连接只在一个方向上工作。
- en: To make the connection between `Supplier` and the `Ingredient` bidirectional,[⁴](#pgfId-1309896)
    we need to add a property to the `Supplier` type that points to the `Ingredient`
    type. Since a supplier can provide more than one ingredient, the `ingredients`
    property points to a list of `Ingredient` types. This is an example of a *one-to-many
    connection*. Figure 8.8 shows what the new relationship between the `Ingredient`
    and the `Supplier` types looks like.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`Supplier`和`Ingredient`之间的连接双向，[⁴](#pgfId-1309896)我们需要向`Supplier`类型添加一个指向`Ingredient`类型的属性。由于一个供应商可以提供多种成分，`ingredients`属性指向一个`Ingredient`类型的列表。这是一个**一对一连接**的例子。图8.8显示了`Ingredient`和`Supplier`类型之间新的关系。
- en: Listing 8.6 Bidirectional relationship between `Supplier` and `Ingredient`
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.6 `Supplier`和`Ingredient`之间的双向关系
- en: '[PRE8]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ① We create a bidirectional relationship between the Ingredient and the Supplier
    types.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们在Ingredient和Supplier类型之间创建一个双向关系。
- en: '![](../Images/08-08.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08-08.png)'
- en: Figure 8.8 To create a bidirectional relationship between two types, we add
    properties to each of them that point to each other. In this example, the `Ingredient`’s
    `supplier` property points to the Supplier type, while the `Supplier`’s `ingredients`
    property points to a list of ingredients.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 要在两个类型之间创建双向关系，我们需要向每个类型添加指向对方的属性。在这个例子中，`Ingredient`的`supplier`属性指向`Supplier`类型，而`Supplier`的`ingredients`属性指向一个成分列表。
- en: Now that we know how to create simple connections through edge properties, let’s
    see how we create more complex connections using dedicated types.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何通过边属性创建简单的连接，让我们看看如何使用专用类型创建更复杂的连接。
- en: 8.5.2 Creating connections with through types
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.2 使用通过类型创建连接
- en: 'This section discusses *through types*: types that tell us how other object
    types are connected. They add additional information about the connection itself.
    We’ll use through types to connect our products, cakes, and beverages, with their
    ingredients. We could connect them by adding a simple list of ingredients to `Cake`
    and `Beverage`, as shown in figure 8.9, but this wouldn’t tell us how much of
    each ingredient goes into a product’s recipe.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了**通过类型**：这些类型告诉我们其他对象类型是如何相互连接的。它们提供了关于连接本身的一些额外信息。我们将使用通过类型来连接我们的产品、蛋糕和饮料及其成分。我们可以通过向`Cake`和`Beverage`添加一个简单的成分列表来连接它们，如图8.9所示，但这不会告诉我们每种成分在产品配方中各占多少。
- en: '![](../Images/08-09.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08-09.png)'
- en: Figure 8.9 We can express `Cake`’s `ingredients` field as a list of `Ingredient`
    types, but that wouldn’t tell us how much of each ingredient goes into a cake
    recipe.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 我们可以将`Cake`的`ingredients`字段表示为`Ingredient`类型的列表，但这不会告诉我们每种成分在蛋糕配方中各占多少。
- en: 'To connect cakes and beverages with their ingredients, we’ll use a through
    type called `IngredientRecipe`. As you can see in figure 8.10, `IngredientRecipe`
    has three properties: the ingredient itself, its amount, and the unit in which
    the amount is measured. This gives us more meaningful information about how our
    products relate to their ingredients.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将蛋糕和饮料与它们的成分连接起来，我们将使用一个称为`IngredientRecipe`的关联类型。如图8.10所示，`IngredientRecipe`有三个属性：成分本身、其数量以及数量所测量的单位。这为我们提供了关于我们的产品如何与它们的成分相关联的更多有意义的信息。
- en: '![](../Images/08-10.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/08-10.png)'
- en: Figure 8.10 To express how an `Ingredient` is connected with a `Cake`, we use
    the `IngredientRecipe` through type, which allows us to detail how much of each
    ingredient goes into a cake recipe.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 为了表达`Ingredient`如何与`Cake`连接，我们使用`IngredientRecipe`关联类型，这允许我们详细说明每种成分在蛋糕配方中各占多少。
- en: Listing 8.7 Through types that represent a relationship between two types
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.7 通过类型表示两种类型之间关系的类型
- en: '[PRE9]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ① We declare the IngredientRecipe through type.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们声明`IngredientRecipe`关联类型。
- en: ② We declare ingredients as a list of IngredientRecipe through types.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们通过类型声明成分为一个`IngredientRecipe`列表。
- en: By creating connections between different object types, we give our API consumers
    the ability to explore our data by just following the connecting edges in the
    types. And by creating bidirectional relationships, we give users the ability
    to traverse our data graph back and forth. This is one of the most powerful features
    of GraphQL, and it’s always worth spending the time to design meaningful connections
    across our data.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在对象类型之间创建连接，我们为API消费者提供了通过仅跟随类型中的连接边来探索我们的数据的能力。通过创建双向关系，我们为用户提供在数据图之间往返的能力。这是GraphQL最强大的功能之一，总是值得花时间设计跨我们数据的有意义连接。
- en: More often than not, we need to create properties that represent multiple types.
    For example, we could have a property that represents either cakes or beverages.
    This is the topic of the next section.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 更多的时候，我们需要创建表示多个类型的属性。例如，我们可能有一个表示蛋糕或饮料的属性。这是下一节的主题。
- en: 8.6 Combining different types through unions and interfaces
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.6 通过联合和接口组合不同类型
- en: This section discusses how we cope with situations where we have multiple types
    of the same entity. You’ll often have to deal with properties that point to a
    collection of multiple types. What does this mean in practice, and how does it
    work? Let’s look at an example from the products API!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了如何处理我们拥有多种相同实体类型的情况。你经常会遇到指向多个类型集合的属性。这在实践中意味着什么，又是如何工作的呢？让我们通过产品API的一个例子来看看！
- en: 'In the products API, `Cake` and `Beverage` are two types of products. In section
    8.4.2, we saw how we connect `Cake` and `Beverage` with the `Ingredient` type.
    But how do we connect `Ingredient` to `Cake` and `Beverage`? We could simply add
    a property called `products` to the `Ingredient` type, which points to a list
    of `Cakes` and `Beverages`, like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在产品API中，`Cake`和`Beverage`是两种产品类型。在第8.4.2节中，我们看到了如何将`Cake`和`Beverage`与`Ingredient`类型连接起来。但我们是怎样将`Ingredient`连接到`Cake`和`Beverage`的呢？我们可以简单地给`Ingredient`类型添加一个名为`products`的属性，它指向一个`Cakes`和`Beverages`的列表，如下所示：
- en: '[PRE10]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This works, but it doesn’t allow us to represent `Cakes` and `Beverages` as
    a single product entity. Why would we want to do that? Because of the following
    reasons:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这可行，但它不允许我们将`Cakes`和`Beverages`表示为单一的产品实体。我们为什么要这样做呢？原因如下：
- en: '`Cake` and `Beverage` are the same thing: a product, and as such, it makes
    sense to treat them as the same entity.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cake`和`Beverage`是同一事物：一个产品，因此将它们视为同一实体是有意义的。'
- en: As we’ll see in sections 8.8 and 8.9, we’ll have to refer to our products in
    other parts of the code, and it will be very helpful to be able to use one single
    type for that.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们在第8.8节和第8.9节中将要看到的，我们将在代码的其他部分引用我们的产品，能够使用单一类型来做这一点将非常有帮助。
- en: If we add new types of products to the system in the future, we don’t want to
    have to change all parts of the specification that refer to products. Instead,
    we want to have a single type that represents them all and update only that type.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们在未来向系统中添加新的产品类型，我们不希望不得不更改所有引用产品的规范部分。相反，我们希望有一个单一的类型来代表它们所有，并只更新那个类型。
- en: 'GraphQL offers two ways to bring various types together under a single type:
    unions and interfaces. Let’s look at each in detail.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL提供了两种将各种类型组合到单个类型下的方法：联合和接口。让我们详细看看每种方法。
- en: 'Interfaces are useful when we have types that share properties in common. This
    is the case for the `Cake` and the `Beverage` types, which share most of their
    properties. GraphQL interfaces are similar to class interfaces in programming
    languages, such as Python: they define a collection of properties that must be
    implemented by other types. Listing 8.8 shows how we use an interface to represent
    the collection of properties shared by `Cake` and `Beverage`. As you can see,
    we declare interface types using the `interface` keyword. The `Cake` and `Beverage`
    types implement `ProductInterface`, and therefore they must define all the properties
    defined in the `ProductInterface` type. By looking at the `ProductInterface` type,
    any user of our API can quickly get an idea of which properties are accessible
    on both the `Beverage` and `Cake` types.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一些具有共同属性的类型时，接口非常有用。例如，对于`Cake`和`Beverage`类型，它们共享了大部分属性。GraphQL接口与编程语言（如Python）中的类接口类似：它们定义了一组必须由其他类型实现的属性。列表8.8展示了我们如何使用接口来表示`Cake`和`Beverage`共享的属性集合。正如你所看到的，我们使用`interface`关键字声明接口类型。`Cake`和`Beverage`类型实现了`ProductInterface`接口，因此它们必须定义`ProductInterface`类型中定义的所有属性。通过查看`ProductInterface`类型，任何使用我们API的用户都可以快速了解在`Beverage`和`Cake`类型上可访问哪些属性。
- en: Listing 8.8 Representing common properties through interfaces
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.8 通过接口表示公共属性
- en: '[PRE11]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ① We declare the ProductInterface interface type.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们声明了`ProductInterface`接口类型。
- en: ② The Cake type implements the ProductInterface interface.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ② `Cake`类型实现了`ProductInterface`接口。
- en: ③ We define properties specific to Cake.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们定义了特定于`Cake`的属性。
- en: ④ Beverage implements the ProductInterface interface.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ④ `Beverage`实现了`ProductInterface`接口。
- en: By creating interfaces, we make it easier for our API consumers to understand
    the common properties shared by our product types. As we’ll see in the next chapter,
    interfaces also make the API easier to consume.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建接口，我们使API消费者更容易理解我们的产品类型共享的公共属性。正如我们将在下一章中看到的，接口也使API更容易消费。
- en: While interfaces help us define the common properties of various types, unions
    help us bring various types under the same type. This is very helpful when we
    want to treat various types as a single entity. In the products API, we want to
    be able to treat the `Cake` and `Beverage` types as a single `Product` type, and
    unions allow us to do that. A union type is the combination of different types
    using the pipe (`|`) operator.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然接口帮助我们定义各种类型的公共属性，但联合帮助我们将各种类型归入同一类型。当我们想要将各种类型视为单个实体时，这非常有用。在产品API中，我们希望能够将`Cake`和`Beverage`类型视为单个`Product`类型，联合允许我们这样做。联合类型是使用管道（`|`）运算符组合不同类型的结果。
- en: Listing 8.9 A union of different types
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.9 不同类型的联合
- en: '[PRE12]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ① We create a union of the Beverage and the Cake types.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们创建了`Beverage`和`Cake`类型的联合。
- en: Using unions and interfaces makes our API easier to maintain and to consume.
    If we ever add a new type of product to the API, we can make sure it offers a
    similar interface to `Cake` and `Beverage` by making it implement the `ProductInterface`
    type. And by adding the new product to the `Product` union, we make sure it’s
    available on all operations that use the `Product` union type.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用联合和接口使我们的API更容易维护和消费。如果我们向API添加新的产品类型，我们可以确保它通过实现`ProductInterface`类型提供与`Cake`和`Beverage`类似的接口。通过将新产品添加到`Product`联合中，我们确保它可以在使用`Product`联合类型的所有操作中使用。
- en: Now that we know how to combine multiple object types, it’s time to learn how
    we constrain the values of object type properties through enumerations.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何组合多种对象类型，现在是时候学习如何通过枚举来约束对象类型属性的值了。
- en: 8.7 Constraining property values with enumerations
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.7 使用枚举约束属性值
- en: This section covers GraphQL’s enumeration type. Technically, an *enumeration*
    is a specific type of scalar that can only take on a predefined number of values.
    Enumerations are useful in properties that can accept a value only from a constrained
    list of choices. In GraphQL, we declare enumerations using the `enum` keyword
    followed by the enumeration’s name, and we list its allowed values within curly
    braces.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了GraphQL的枚举类型。技术上讲，枚举是一种只能取预定义值的特定类型的标量。枚举在只能接受受限列表中选择值的属性中非常有用。在GraphQL中，我们使用`enum`关键字后跟枚举名称来声明枚举，并在大括号内列出其允许的值。
- en: In the products API, we need enumerations for expressing the amounts of the
    ingredients. For example, in section 8.5.2, we defined a through type called `IngredientRecipe`,
    which indicates the amount of each ingredient that goes into a product. `IngredientRecipe`
    expresses amounts in terms of quantity per unit of measure. We can measure ingredients
    in different ways. For example, we can measure milk in pints, liters, ounces,
    gallons, and so on. For the sake of consistency, we want to ensure that everyone
    uses the same units to describe the amounts of our ingredients, so we’ll create
    an enumeration type called `MeasureUnit` that can be used to constrain the values
    for the unit property.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在产品API中，我们需要枚举来表达成分的数量。例如，在第8.5.2节中，我们定义了一个通过类型`IngredientRecipe`，它表示产品中每种成分的量。`IngredientRecipe`以每单位测量的数量来表示数量。我们可以用不同的方式来衡量成分。例如，我们可以用品脱、升、盎司、加仑等方式来衡量牛奶。为了保持一致性，我们希望确保每个人都使用相同的单位来描述我们成分的数量，因此我们将创建一个名为`MeasureUnit`的枚举类型，它可以用来约束单位属性的值。
- en: Listing 8.10 Using the `MeasureUnit` enumeration type
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.10 使用`MeasureUnit`枚举类型
- en: '[PRE13]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ① We declare an enumeration.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们声明一个枚举。
- en: ② We list the allowed values within this enumeration.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们在这个枚举中列出允许的值。
- en: ③ unit is a non-nullable property of type MeasureUnit.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 单位是非空属性，类型为`MeasureUnit`。
- en: We also want to use the `MeasureUnit` enumeration to describe the available
    stock of an ingredient. To do so, we define a `Stock` type, and we use it to define
    the `stock` property of the `Ingredient` type.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望使用`MeasureUnit`枚举来描述成分的可用库存。为此，我们定义一个`Stock`类型，并使用它来定义`Ingredient`类型的`stock`属性。
- en: Listing 8.11 Using the `Stock` enumeration type
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.11 使用`Stock`枚举类型
- en: '[PRE14]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ① We declare the Stock type to help us express information about the available
    stock of an ingredient.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们声明`Stock`类型，以帮助我们表达有关成分可用库存的信息。
- en: ② Stock’s unit property is an enumeration.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ② 库存的单位属性是一个枚举。
- en: ③ We connect the Ingredient type with the Stock type through Ingredient’s stock
    property.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们通过成分的库存属性将成分类型与库存类型连接起来。
- en: Enumerations are useful to ensure that certain values remain consistent through
    the interface. This helps avoid errors that happen when you let users choose and
    write those values by themselves.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举有助于确保某些值在整个接口中保持一致。这有助于避免当用户自行选择和编写这些值时发生的错误。
- en: This concludes our journey through GraphQL’s type system. Types are the building
    blocks of an API specification, but without a mechanism to query or interact with
    them, our API is very limited. To perform actions on the server, we need to learn
    about GraphQL queries and mutations. Those will be the topic of the rest of the
    chapter!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们通过GraphQL类型系统的旅程结束。类型是API规范的构建块，但没有查询或与之交互的机制，我们的API将非常有限。要在服务器上执行操作，我们需要了解GraphQL查询和突变。这些将是本章剩余部分的主题！
- en: 8.8 Defining queries to serve data from the API
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.8 定义查询以从API提供数据
- en: 'This section introduces GraphQL *queries*: operations that allow us to fetch
    or read data from the server. Serving data is one of the most important functions
    of any web API, and GraphQL offers great flexibility to create a powerful query
    interface. Queries correspond to the group of read operations that we discussed
    in section 8.2\. As a reminder, these are the query operations that the products
    API needs to support:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了GraphQL *查询*：允许我们从服务器获取或读取数据的操作。提供数据是任何Web API最重要的功能之一，GraphQL提供了极大的灵活性来创建强大的查询接口。查询对应于我们在第8.2节中讨论的读取操作组。作为提醒，这些是需要产品API支持查询操作：
- en: '`allProducts()`'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allProducts()`'
- en: '`allIngredients()`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allIngredients()`'
- en: '`products()`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`products()`'
- en: '`product()`'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product()`'
- en: '`ingredient()`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ingredient()`'
- en: We’ll work on the `allProducts()` query first since it’s the simplest, and then
    move on to the `products()` query. As we work on `products()`, we’ll see how we
    add arguments to our query definitions, we’ll learn about pagination, and, finally,
    we’ll learn how to refactor our query parameters into their own type to improve
    readability and maintenance.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先处理`allProducts()`查询，因为它是最简单的，然后继续处理`products()`查询。当我们处理`products()`时，我们将看到如何向我们的查询定义添加参数，我们将了解分页，最后，我们将学习如何将查询参数重构为其自己的类型以提高可读性和维护性。
- en: 'The specification of a GraphQL query looks similar to the signature definition
    of a Python function: we define the query name, optionally define a list of parameters
    for the query between parentheses, and specify the return type after a colon.
    The following code shows the simplest query in the products API: the `allProducts()`
    query, which returns a list of all products. `allProducts()` doesn’t take any
    parameters and simply returns a list of all products that exist in the server.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 查询的规范看起来类似于 Python 函数签名定义：我们定义查询名称，可选地在括号内定义查询参数列表，并在冒号后指定返回类型。以下代码展示了产品
    API 中最简单的查询：`allProducts()` 查询，它返回所有产品的列表。`allProducts()` 不接受任何参数，仅返回服务器中存在的所有产品列表。
- en: Listing 8.12 Simple GraphQL query to return a list of products
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.12 简单的 GraphQL 查询以返回产品列表
- en: '[PRE15]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ① All queries are defined under the Query object type.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ① 所有查询都是在查询对象类型下定义的。
- en: ② We define the allProducts() query. After the colon, we indicate what the return
    type of the query is.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们定义了 `allProducts()` 查询。在冒号之后，我们指明查询的返回类型。
- en: '`allProducts()` returns a list of all products that exist in the CoffeeMesh
    database. Such a query is useful if we want to run an exhaustive analysis of all
    products, but in real life our API consumers want to be able to filter the results.
    They can do that by using the `products()` query, which, according to the requirements
    we gathered in section 8.2, returns a filtered list of products.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`allProducts()` 返回 CoffeeMesh 数据库中所有产品的列表。此类查询如果我们想对所有产品进行彻底分析时很有用，但在现实生活中，我们的
    API 用户希望能够过滤结果。他们可以通过使用 `products()` 查询来实现，根据我们在第 8.2 节中收集的要求，该查询返回过滤后的产品列表。'
- en: Query arguments are defined within parentheses, similar to how we define the
    parameters of a Python function. Listing 8.13 shows how we define the `products()`
    query. It includes arguments that allows our API consumers to filter products
    by availability, or by maximum and minimum price. All the arguments are optional.
    API consumers are free to use any or all of the query arguments, or none. If they
    don’t specify any of the arguments when using the `products()` query, they’ll
    get a list of all the products.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 查询参数在括号内定义，类似于我们定义 Python 函数参数的方式。列表 8.13 展示了如何定义 `products()` 查询。它包括允许我们的 API
    用户通过可用性或最大和最小价格过滤产品的参数。所有参数都是可选的。API 用户可以自由使用任何或所有查询参数，或者不使用任何参数。如果他们在使用 `products()`
    查询时没有指定任何参数，他们将获得所有产品的列表。
- en: Listing 8.13 Simple GraphQL query to return a list of products
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.13 简单的 GraphQL 查询以返回产品列表
- en: '[PRE16]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ① Query parameters are defined within parentheses.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ① 查询参数在括号内定义。
- en: In addition to filtering the list of products, API consumers will likely want
    to be able to sort the list and paginate the results. Pagination is the ability
    to deliver the result of a query in different sets of a specified size, and it’s
    commonly used in APIs to ensure that API clients receive a sensible amount of
    data in each request. As illustrated in figure 8.11, if the result of a query
    yields 10 or more records, we can divide the query result into groups of five
    items each and serve one set at a time. Each set is called a *page*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 除了过滤产品列表之外，API 用户可能还希望能够对列表进行排序并分页显示结果。分页是将查询结果以指定大小的不同集合的形式提供的能力，并且在 API 中通常用于确保
    API 客户端在每次请求中接收合理数量的数据。如图 8.11 所示，如果查询的结果有 10 条或更多记录，我们可以将查询结果分成每组五项的组，并一次服务一组。每组被称为
    *页面*。
- en: '![](../Images/08-11.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/08-11.png)'
- en: Figure 8.11 A more common approach to pagination is to let users decide how
    many results per page they want to see and let them select the specific page they
    want to get.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.11 一种更常见的分页方法是让用户决定他们希望每页显示多少结果，并让他们选择他们想要获取的特定页面。
- en: 'We enable pagination by adding a `resultsPerPage` argument to the query, as
    well as a `page` argument. To sort the result set, we expose a `sort` argument.
    The following snippet shows in bold the changes to the `products()` query after
    we add these arguments:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过向查询中添加 `resultsPerPage` 参数和 `page` 参数来启用分页。为了对结果集进行排序，我们公开了一个 `sort` 参数。以下代码片段以粗体显示了在添加这些参数后对
    `products()` 查询所做的更改：
- en: '[PRE17]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Offering numerous query arguments gives a lot of flexibility to our API consumers,
    but it can be cumbersome to set values for all of them. We can make our API easier
    to use by setting default values for some of the arguments. We’ll set a default
    sorting order, as well as a default value for the `resultsPerPage` argument and
    a default value for the `page` argument. The following code shows how we assign
    default values to some of the arguments in the `products()` query and includes
    a `SortingOrder` enumeration that constrains the values of the `sort` argument
    to either `ASCENDING` or `DESCENDING`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 提供众多的查询参数给我们的API消费者提供了很大的灵活性，但为所有这些参数设置值可能会很繁琐。我们可以通过为一些参数设置默认值来使我们的API更容易使用。我们将设置一个默认排序顺序，以及
    `resultsPerPage` 参数和 `page` 参数的默认值。以下代码显示了如何为 `products()` 查询中的某些参数分配默认值，并包括一个
    `SortingOrder` 枚举，该枚举将 `sort` 参数的值限制为 `ASCENDING` 或 `DESCENDING`。
- en: Listing 8.14 Setting default values for query arguments
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.14 为查询参数设置默认值
- en: '[PRE18]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ① We declare the SortingOrder enumeration.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们声明了 SortingOrder 枚举。
- en: ② We assign default values for some of the parameters.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们为一些参数分配默认值。
- en: ③ We constrain sort’s values by setting its type to the SortingOrder enumeration.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们通过将 sort 的类型设置为 SortingOrder 枚举来限制 sort 的值。
- en: The signature of the `products()` query is becoming a bit cluttered. If we keep
    adding arguments to it, it will become difficult to read and maintain. To improve
    readability, we can refactor the arguments out of the query specification into
    their own type. In GraphQL, we can define lists of parameters by using input types,
    which have the same look and feel as any other GraphQL object type, but they’re
    meant for use as input for queries and mutations.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`products()` 查询的签名正变得越来越杂乱。如果我们继续向其中添加参数，它将变得难以阅读和维护。为了提高可读性，我们可以将参数从查询规范中重构出来，形成它们自己的类型。在GraphQL中，我们可以通过使用输入类型来定义参数列表，这些输入类型看起来和感觉上与任何其他GraphQL对象类型相同，但它们是用于查询和mutations的输入。'
- en: Listing 8.15 Refactoring query arguments into input types
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.15 将查询参数重构为输入类型
- en: '[PRE19]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ① We declare the ProductsFilter input type.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们声明了 ProductsFilter 输入类型。
- en: ② We define ProductsFilter’s parameters.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们定义 ProductsFilter 的参数。
- en: ③ We assign default values to some parameters.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们为一些参数分配默认值。
- en: ④ We set the input parameter’s type to ProductsFilter.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 我们将输入参数的类型设置为 ProductsFilter。
- en: The remaining API queries, namely, `allIngredients()`, `product()`, and `ingredient()`,
    are shown in listing 8.16 in bold. `allIngredients()` returns a full list of ingredients
    and therefore takes no arguments, as in the case of the `allProducts()` query.
    Finally, `product()` and `ingredient()` return a single product or ingredient
    by ID, and therefore have a required `id` argument of type ID. If a product or
    ingredient is found for the provided ID, the queries will return the details of
    the requested item; otherwise, they’ll return `null`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的API查询，即 `allIngredients()`、`product()` 和 `ingredient()`，在列表8.16中以粗体显示。`allIngredients()`
    返回完整的成分列表，因此不需要参数，就像 `allProducts()` 查询一样。最后，`product()` 和 `ingredient()` 通过ID返回单个产品或成分，因此需要一个必需的
    `id` 参数，参数类型为ID。如果找到了提供的ID对应的产品或成分，查询将返回请求项的详细信息；否则，它们将返回 `null`。
- en: Listing 8.16 Specification for all the queries in the products API
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.16 产品API中所有查询的规范
- en: '[PRE20]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ① product() returns a nullable result of type Product.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ① product() 返回一个可空的 Product 类型结果。
- en: Now that we know how to define queries, it’s time to learn about mutations,
    which are the topic of the next section.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何定义查询，是时候学习mutations了，这是下一节的主题。
- en: 8.9 Altering the state of the server with mutations
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.9 使用mutations改变服务器的状态
- en: 'This section introduces GraphQL *mutations*: operations that allow us to trigger
    actions that change the state of the server. While the purpose of a query is to
    let us fetch data from the server, mutations allow us to create new resources,
    to delete them, or to alter their state. Mutations have a return value, which
    can be a scalar, such as a Boolean, or an object. This allows our API consumers
    to verify that the operation completed successfully and to fetch any values generated
    by the server, such as IDs.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了 GraphQL **mutations**：允许我们触发改变服务器状态的操作的命令。虽然查询的目的是让我们从服务器获取数据，但mutations允许我们创建新资源、删除它们或改变它们的状态。mutations有一个返回值，可以是标量，例如布尔值，或是一个对象。这允许我们的API消费者验证操作是否成功完成，并获取服务器生成的任何值，例如ID。
- en: 'In section 8.2, we discussed that the products API needs to support the following
    operations for adding, deleting, and updating resources in the server:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在 8.2 节中，我们讨论了产品 API 需要支持以下操作以在服务器中添加、删除和更新资源：
- en: '`addIngredient()`'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addIngredient()`'
- en: '`updateStock()`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updateStock()`'
- en: '`addProduct()`'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addProduct()`'
- en: '`updateProduct()`'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updateProduct()`'
- en: '`deleteProduct()`'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deleteProduct()`'
- en: In this section, we’ll document the `addProduct()`, `updateProduct()`, and `deleteProduct()`
    mutations. The specification for the other mutations is similar to these, and
    you can check them out in the GitHub repository provided with this book.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将记录 `addProduct()`、`updateProduct()` 和 `deleteProduct()` 演变。其他演变的规范与这些类似，你可以在本书提供的
    GitHub 仓库中查看它们。
- en: 'A GraphQL mutation looks similar to the signature of a function in Python:
    we define the name of the mutation, describe its parameters between parentheses,
    and provide its return type after a colon. Listing 8.17 shows the specification
    for the `addProduct()` mutation. `addProduct()` accepts a long list of arguments,
    and it returns a `Product` type. All the arguments are optional except `name`
    and `type`. We use `type` to indicate what kind of product we’re creating, a cake
    or a beverage. We also include a `ProductType` enumeration to constrain the values
    of the `type` argument to either `cake` or `beverage`. Since this mutation is
    used to create cakes and beverages, we allow users to specify properties of each
    type, namely `hasFilling` and `hasNutsToppingOption` for cakes, as well as `hasCreamOnTopOption`
    and `hasServeOnIceOption` for beverages, but we set them by default to `false`
    to make the mutation easier to use.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 演变看起来类似于 Python 中函数的签名：我们定义演变的名称，在括号中描述其参数，并在冒号后提供其返回类型。列表 8.17 展示了
    `addProduct()` 演变的规范。`addProduct()` 接受一系列参数，并返回 `Product` 类型。所有参数都是可选的，除了 `name`
    和 `type`。我们使用 `type` 来指示我们正在创建的产品类型，是蛋糕还是饮料。我们还包含了一个 `ProductType` 枚举来约束 `type`
    参数的值只能是 `cake` 或 `beverage`。由于这个演变用于创建蛋糕和饮料，我们允许用户指定每种类型的属性，即蛋糕的 `hasFilling`
    和 `hasNutsToppingOption`，以及饮料的 `hasCreamOnTopOption` 和 `hasServeOnIceOption`，但我们默认将它们设置为
    `false` 以简化演变的用法。
- en: Listing 8.17 Defining a GraphQL mutation
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.17 定义 GraphQL 演变
- en: '[PRE21]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ① We declare a ProductType enumeration.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们声明一个 `ProductType` 枚举。
- en: ② We declare mutations under the Mutation object type.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们在 `Mutation` 对象类型下声明演变。
- en: ③ We specify the return type of addProduct().
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们指定了 `addProduct()` 的返回类型。
- en: You’d agree that the signature definition of the `addProduct()` mutation looks
    a bit cluttered. We can improve readability and maintainability by refactoring
    the list of parameters into their own type. Listing 8.18 shows how we refactor
    the `addProduct()` mutation by moving the list of parameters into an input type.
    `AddProductInput` contains all the optional parameters that can be set when we
    create a new product. We set aside the `name` parameter, which is the only required
    parameter when we create a new product. As we’ll see shortly, this allows us to
    reuse the `AddProductInput` input type in other mutations that don’t require the
    `name` parameter.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你会同意 `addProduct()` 演变的签名定义看起来有点杂乱。我们可以通过将参数列表重构为它们自己的类型来提高可读性和可维护性。列表 8.18
    展示了如何通过将参数列表移动到输入类型中来重构 `addProduct()` 演变。`AddProductInput` 包含了在创建新产品时可以设置的 所有可选参数。我们留出了
    `name` 参数，这是创建新产品时唯一的必需参数。正如我们很快就会看到的，这允许我们在不需要 `name` 参数的其他演变中重用 `AddProductInput`
    输入类型。
- en: Listing 8.18 Refactoring parameters with input types
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.18 使用输入类型重构参数
- en: '[PRE22]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ① We declare the AddProductInput input type.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们声明 `AddProductInput` 输入类型。
- en: ② We list AddProductInput’s parameters.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们列出 `AddProductInput` 的参数。
- en: ③ We assign default values to some parameters.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们为一些参数指定了默认值。
- en: ④ addProduct()’s input parameter has the AddProduct input type.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ④ `addProduct()` 方法的输入参数具有 `AddProduct` 输入类型。
- en: 'Input types not only help us make our specification more readable and maintainable,
    but they also allow us to create reusable types. We can reuse the `AddProductInput`
    input type in the signature of the `updateProduct()` mutation. When we update
    the configuration for a product, we may want to change only some of its parameters,
    such as the name, the price, or its ingredients. The following snippet shows how
    we reuse the `AddProductInput` parameters in `updateProduct()`. In addition to
    `AddProductInput`, we also include a mandatory product `id` parameter, which is
    necessary to identify the product we want to update. We also include the `name`
    parameter, which in this case is optional:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 输入类型不仅帮助我们使规范更易于阅读和维护，而且还可以允许我们创建可重用的类型。我们可以在 `updateProduct()` 变异的签名中重用 `AddProductInput`
    输入类型。当我们更新产品的配置时，我们可能只想更改其某些参数，例如名称、价格或其成分。下面的片段显示了我们在 `updateProduct()` 中如何重用
    `AddProductInput` 参数。除了 `AddProductInput` 之外，我们还包括一个强制性的产品 `id` 参数，这是识别我们想要更新的产品所必需的。我们还包括
    `name` 参数，在这种情况下是可选的：
- en: '[PRE23]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let’s now look at the `deleteProduct()` mutation, which removes a product from
    the catalogue. To do that, the user must provide the ID for the product they want
    to delete. If the operation is successful, the mutation returns `true`; otherwise,
    it returns `false`. The next snippet shows the specification for the `deleteProduct()`
    mutation:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看 `deleteProduct()` 变异，它从目录中删除一个产品。为此，用户必须提供他们想要删除的产品的 ID。如果操作成功，变异返回
    `true`；否则，返回 `false`。下面的片段显示了 `deleteProduct()` 变异的规范：
- en: '[PRE24]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This concludes our journey through GraphQL’s SDL! You’re now equipped with everything
    you need to define your own API schemas. In chapter 9, we’ll learn how to launch
    a mock server using the products API specification and how to consume and interact
    with the GraphQL API.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们通过 GraphQL 的 SDL 的旅程结束！你现在已经拥有了定义自己的 API 模式的所有必要工具。在第 9 章中，我们将学习如何使用产品
    API 规范启动模拟服务器，以及如何消费和交互 GraphQL API。
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: GraphQL is a popular protocol for building web APIs. It shines in scenarios
    where it’s important to give API clients full control over the data they want
    to fetch and in situations where we have highly interconnected data.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL 是构建 Web API 的流行协议。它在需要给予 API 客户端对要获取的数据有完全控制权的情况下，以及在数据高度互联的情况下表现出色。
- en: A GraphQL API specification is called a schema, and it’s written using the Schema
    Definition Language (SDL).
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 GraphQL API 规范被称为模式，它使用模式定义语言（SDL）编写。
- en: 'We use GraphQL’s scalar types to define the properties of an object type: Booleans,
    strings, floats, integers, and IDs. In addition, we can also create our own custom
    scalar types.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 GraphQL 的标量类型来定义对象类型的属性：布尔值、字符串、浮点数、整数和 ID。此外，我们还可以创建自己的自定义标量类型。
- en: GraphQL’s object types are collections of properties, and they typically represent
    the resource or entities managed by the API server.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL 的对象类型是属性的集合，它们通常代表由 API 服务器管理的资源或实体。
- en: We can connect objects by using edge properties, namely, properties that point
    to another object, and by using through types. Through types are object types
    that add additional information about how two objects are connected.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过使用边缘属性来连接对象，即指向另一个对象的属性，以及通过使用通过类型。通过类型是添加关于两个对象如何连接的额外信息的对象类型。
- en: To constrain the values of a property, we use enumeration types.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要约束属性的值，我们使用枚举类型。
- en: GraphQL queries are operations that allow API clients to fetch data from the
    server.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL 查询是允许 API 客户端从服务器获取数据的操作。
- en: GraphQL mutations are operations that allow API clients to trigger actions that
    change the state of the server.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL 变异是允许 API 客户端触发改变服务器状态的行动的操作。
- en: When queries and mutations have long lists of parameters, we can refactor them
    into input types to increase readability and maintainability. Input types can
    also be reused in more than one query or mutation.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当查询和变更有长参数列表时，我们可以将它们重构为输入类型以提高可读性和可维护性。输入类型也可以在多个查询或变体中重用。
- en: '* * *'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '¹ This definition appears in the home page of the GraphQL specification: [https://graphql.org/](https://graphql.org/).'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ 此定义出现在 GraphQL 规范的主页上：[https://graphql.org/](https://graphql.org/)。
- en: ² I owe the comparison between GraphQL and SQL to Eve Porcello and Alex Banks,
    *Learning GraphQL, Declarative Data Fetching for Modern Web Apps* (O’Reilly, 2018),
    pp. 31–32.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ² 我将 GraphQL 与 SQL 的比较归功于 Eve Porcello 和 Alex Banks，*学习 GraphQL，现代 Web 应用程序声明式数据获取*（O’Reilly，2018），第
    31-32 页。
- en: '³ The GraphQL website maintains a list of runtimes available for building GraphQL
    servers in different languages: [https://graphql.org/code/](https://graphql.org/code/).'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ³ GraphQL 网站维护了一个在不同语言中构建 GraphQL 服务器的可用运行时列表：[https://graphql.org/code/](https://graphql.org/code/).
- en: ⁴ In the literature about GraphQL, you’ll often find a digression about how
    GraphQL is inspired by graph theory, and how we can use some of the concepts from
    graph theory to illustrate the relationships between types. Following that tradition,
    the bidirectional relationship we refer to here is an example of an undirected
    graph, since the `Supplier` type can be reached from the `Ingredient` type, and
    vice versa. For a good discussion of graph theory in the context of GraphQL, see
    Eve Porcello and Alex Banks, *Learning GraphQL, Declarative Data Fetching for
    Modern Web Apps* (O’Reilly, 2018), pp. 15–30.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ⁴ 在关于 GraphQL 的文献中，你经常会发现关于 GraphQL 受图论启发的讨论，以及我们如何使用图论的一些概念来阐述类型之间的关系。遵循这一传统，我们这里提到的双向关系是一个无向图的例子，因为可以从
    `Supplier` 类型到达 `Ingredient` 类型，反之亦然。关于 GraphQL 上下文中的图论的良好讨论，请参阅 Eve Porcello
    和 Alex Banks 的作品 *Learning GraphQL, Declarative Data Fetching for Modern Web Apps*
    (O’Reilly, 2018)，第 15-30 页。
