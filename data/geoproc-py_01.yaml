- en: Chapter 2\. Python basics
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2章. Python基础知识
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Using the Python interpreter vs. writing scripts
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python解释器与编写脚本
- en: Using the core Python data types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python的核心数据类型
- en: Controlling the order of code execution
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制代码执行顺序
- en: You can do many things with desktop GIS software such as QGIS, but if you work
    with spatial data for long, you’ll inevitably want to do something that isn’t
    available through the software’s interface. If you know how to program, and are
    clever enough, you can write code that does exactly what you need. Another common
    scenario is the need to automate a repetitive processing task instead of using
    the point-and-click method over and over again. Not only is coding more fun and
    intellectually stimulating than pointing and clicking, but it’s also much more
    efficient when it comes to repetitive tasks. You have no shortage of languages
    you could learn and work with, but because Python is used with many GIS software
    packages, including QGIS and ArcGIS, it’s an excellent language for working with
    spatial data. It’s also powerful, but at the same time a relatively easy-to-learn
    language, so that makes it a good choice if you’re starting out with programming.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用桌面GIS软件（如QGIS）做很多事情，但如果你长时间处理空间数据，你不可避免地会想要做一些软件界面中不可用的操作。如果你懂得编程，并且足够聪明，你可以编写出正好满足你需求的代码。另一个常见场景是需要自动化重复处理任务，而不是一遍又一遍地使用点选方法。编程不仅比点选更有趣、更有智力挑战性，而且在重复性任务中效率也更高。你可以学习并使用许多语言，但由于Python与许多GIS软件包（包括QGIS和ArcGIS）一起使用，因此它是一个处理空间数据的优秀语言。它也非常强大，同时相对容易学习，这使得它对于编程初学者来说是一个很好的选择。
- en: Another reason for using Python is that it’s an interpreted language, so programs
    written in Python will run on any computer with an interpreter, and interpreters
    exist for any operating system you’re likely to use. To run a Python script, you
    need the script and an interpreter, which is different from running an .exe file,
    for example, where you only need one file. But if you have an .exe file, you can
    only run it under the Windows operating system, which is a bummer if you want
    to run it on a Mac or Linux. However, if you have a Python script, you can run
    it anywhere that has an interpreter, so you’re no longer limited to a single operating
    system.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python的另一个原因是它是一种解释型语言，因此用Python编写的程序可以在任何带有解释器的计算机上运行，而且对于你可能会使用的任何操作系统，都存在相应的解释器。要运行Python脚本，你需要脚本和一个解释器，这与运行.exe文件不同，例如，你只需要一个文件。但是，如果你有一个.exe文件，你只能在Windows操作系统下运行它，如果你想在Mac或Linux上运行，这会是一个遗憾。然而，如果你有一个Python脚本，你可以在任何有解释器的位置运行它，因此你不再局限于单一的操作系统中。
- en: 2.1\. Writing and executing code
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1. 编写和执行代码
- en: Another advantage of interpreted languages is that you can use them interactively.
    This is great for playing around and learning a language, because you can type
    a line of code and see the results instantly. You can run the Python interpreter
    in a terminal window, but it’s probably easier to use *IDLE*, which is a simple
    development environment installed with Python. Two different types of windows
    exist in IDLE, *shells* and *edit windows*. A shell is an interactive window in
    which you can type Python code and get immediate results. You’ll know that you’re
    looking at an interactive window if you see a `>>>` prompt, like that in [figure
    2.1](#ch02fig01). You can type code after this prompt and execute it by pressing
    Enter. Many of the examples in this book are run this way to show results. This
    is an inefficient way to run more than a few lines of code, and it doesn’t save
    your code for later use. This is where the edit window comes in. You can use the
    File menu in IDLE to open a new window, which will contain an empty file. You
    can type your code in there and then execute the script using the Run menu, although
    you’ll need to save it with a .py extension first. The output from the script
    will be sent to the interactive window. Speaking of output, in many of the interactive
    examples in this book I type a variable name to see what the variable contains,
    but this won’t work if you’re running the code from a script. Instead, you need
    to use `print` to explicitly tell it to send information to the output window.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 解释型语言的另一个优点是你可以以交互式方式使用它们。这对于探索和学习一门语言来说非常棒，因为你可以输入一行代码并立即看到结果。你可以在终端窗口中运行Python解释器，但使用与Python一起安装的简单开发环境*IDLE*可能更容易。IDLE中存在两种不同类型的窗口，*shell*和*编辑窗口*。shell是一个交互式窗口，你可以在其中输入Python代码并立即得到结果。如果你看到一个`>>>`提示符，就像图2.1中的那样，你就知道你正在查看一个交互式窗口。你可以在该提示符后输入代码，并通过按Enter键执行它。本书中的许多示例都是这样运行的，以展示结果。这种方法运行超过几行代码效率不高，而且它不会保存你的代码以供以后使用。这就是编辑窗口发挥作用的地方。你可以在IDLE的文件菜单中打开一个新窗口，它将包含一个空文件。你可以在那里输入代码，然后使用运行菜单执行脚本，尽管你需要首先将其保存为.py扩展名。脚本的输出将被发送到交互式窗口。说到输出，在本书的许多交互式示例中，我输入一个变量名来查看变量包含的内容，但如果你是从脚本中运行代码，这就不起作用了。相反，你需要使用`print`来明确告诉它将信息发送到输出窗口。
- en: Figure 2.1\. An IDLE shell window
  id: totrans-9
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.1\. IDLE shell窗口
- en: '![](02fig01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig01.jpg)'
- en: In [figure 2.1](#ch02fig01) the string I typed, `'Hello world!'`, and the output
    are color coded. This syntax highlighting is useful because it helps you pick
    out keywords, built-in functions, strings, and error messages at a glance. It
    can also help you find spelling mistakes if something doesn’t change color when
    you expect it to. Another useful feature of IDLE is *tab completion*. If you start
    typing a variable or function name and then press the Tab key, a list of options
    will pop up, as shown in [figure 2.2](#ch02fig02). You can keep typing, and it
    will narrow the search. You can also use arrow keys to scroll through the list.
    When the word you want is highlighted, press Tab again, and the word will appear
    on your screen.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图2.1](#ch02fig01)中，我输入的字符串`'Hello world!'`和输出结果都进行了颜色编码。这种语法高亮非常有用，因为它可以帮助你一眼就识别出关键词、内置函数、字符串和错误信息。如果某些内容在你预期中应该变色但没有变色，这也可以帮助你发现拼写错误。IDLE的另一个有用功能是*自动补全*。如果你开始输入一个变量或函数名，然后按下Tab键，就会弹出一个选项列表，如图2.2所示。你可以继续输入，它会缩小搜索范围。你还可以使用箭头键在列表中滚动。当你想要的单词被高亮时，再次按下Tab键，该单词就会出现在你的屏幕上。
- en: Figure 2.2\. Start typing and press the Tab key in order to get a list of possible
    variables or functions that match what you were typing.
  id: totrans-12
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.2\. 开始输入并按下Tab键，以获取与您输入匹配的可能变量或函数的列表。
- en: '![](02fig02_alt.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig02_alt.jpg)'
- en: Because Python scripts are plain text files, you aren’t forced to use IDLE if
    you don’t want to. You can write scripts in whatever text editor you prefer. Many
    editors are easy to configure, so you can run a Python script directly without
    leaving the editor. See the documentation for your favorite editor to learn how
    to do this. Packages that are designed specifically for working with Python code
    are Spyder, PyCharm, Wing IDE, and PyScripter. Everybody has their own favorite
    development environment, and you may need to play with a few different ones before
    you find an environment that you like.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Python 脚本是纯文本文件，所以如果你不想使用 IDLE，就不必强制使用它。你可以使用你喜欢的任何文本编辑器来编写脚本。许多编辑器很容易配置，因此你可以在不离开编辑器的情况下直接运行
    Python 脚本。查看你喜欢的编辑器的文档，了解如何这样做。专门为处理 Python 代码设计的软件包包括 Spyder、PyCharm、Wing IDE
    和 PyScripter。每个人都有自己的首选开发环境，你可能需要尝试几种不同的环境，才能找到一个你喜欢的环境。
- en: 2.2\. Basic structure of a script
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2\. 脚本的基本结构
- en: Some of the first things you’ll see right at the top of most Python scripts
    are `import` statements. These lines of code load additional modules so that the
    scripts can use them. A module is basically a library of code that you can access
    and use from your scripts, and the large ecosystem of specialized modules is another
    advantage to using Python. You’d have a difficult time working with GIS data in
    Python without extra modules that are designed for this, similar to the way tools
    such as GIMP and Photoshop make it easier to work with digital images. The whole
    point of this book is to teach you how to use these tools for working with GIS
    data. Along the way, you’ll also use several of the modules that come with Python
    because they’re indispensable for tasks such as working with the file system.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数 Python 脚本的顶部，你最先看到的一些东西可能是 `import` 语句。这些代码行加载额外的模块，以便脚本可以使用它们。模块基本上是一个代码库，你可以从脚本中访问和使用它，而庞大的专业模块生态系统也是使用
    Python 的另一个优势。如果没有为这种用途设计的额外模块，你将很难在 Python 中处理 GIS 数据，这类似于 GIMP 和 Photoshop 等工具使处理数字图像变得更容易的方式。本书的整个目的就是教你如何使用这些工具来处理
    GIS 数据。在这个过程中，你还将使用一些 Python 附带的一些模块，因为它们对于处理文件系统等任务来说是必不可少的。
- en: 'Let’s look at a simple example that uses one of the built-in modules. The first
    thing you need to do to use a module is load it using `import`. Then you can access
    objects in the module by prefixing them with the module name so that Python knows
    where to find them. This example loads the `random` module and then uses the `gauss`
    function contained in that module to get a random number from the standard normal
    distribution:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个使用内置模块的简单示例。使用模块的第一件事是使用 `import` 加载它。然后，你可以通过在模块名前加上前缀来访问模块中的对象，这样 Python
    就知道在哪里找到它们。这个例子加载了 `random` 模块，然后使用该模块中包含的 `gauss` 函数从标准正态分布中获取一个随机数：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Another thing you might notice in a Python script is the lack of semicolons
    and curly braces, which are commonly used in other languages for ending lines
    and setting off blocks of code. Python uses whitespace to do these things. Instead
    of using a semicolon to end a line, press Enter and start a new line. Sometimes
    one line of code is too long to fit comfortably on one line in your file, however.
    In this case, break your line at a sensible place, such as right after a comma,
    and the Python interpreter will know that the lines belong together. As for the
    missing curly braces, Python uses indentation to define blocks of code instead.
    This may seem weird at first if you’re used to using braces or `end` statements,
    but indentation works as well and forces you to write more readable code. Because
    of this, you need to be careful with your indentations. In fact, it’s common for
    beginners to run into syntax errors because of wayward indentations. For example,
    even an extra space at the beginning of a line of code will cause an error. You’ll
    see examples of how indentation is used in [section 2.5](#ch02lev1sec5).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 脚本中，你可能还会注意到缺少分号和大括号，这些在其他语言中常用于结束行和设置代码块。Python 使用空白来实现这些功能。通常，你不会使用分号来结束一行，而是按
    Enter 键开始新的一行。然而，有时一行代码太长，无法舒适地放在文件的一行中。在这种情况下，在合理的位置断行，例如逗号之后，Python 解释器就会知道这些行属于一起。至于缺少的大括号，Python
    使用缩进来定义代码块。如果你习惯了使用大括号或 `end` 语句，这可能会让你一开始觉得奇怪，但缩进同样有效，并迫使你编写更易读的代码。正因为如此，你需要小心处理缩进。实际上，初学者经常因为不正确的缩进而遇到语法错误。例如，代码行开头多一个空格也会导致错误。你将在[第
    2.5 节](#ch02lev1sec5)中看到缩进是如何使用的示例。
- en: Python is also case sensitive, which means that uppercase and lowercase letters
    are different from one another. For example, `random.Gauss(0, 1)` wouldn’t have
    worked in the last example because `gauss` needs to be all lowercase. If you get
    error messages about something being undefined (which means Python doesn’t know
    what it is), but you’re sure that it exists, check both your spelling and your
    capitalization for mistakes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Python 也是区分大小写的，这意味着大写字母和小写字母是不同的。例如，`random.Gauss(0, 1)` 在上一个例子中不会工作，因为 `gauss`
    需要全部小写。如果你收到有关某些内容未定义的错误消息（这意味着 Python 不认识它），但你确信它存在，请检查你的拼写和大小写是否有误。
- en: 'It’s also a good idea to add comments to your code to help you remember what
    it does or why you did it a certain way. I can guarantee that things that are
    obvious as you’re writing your code will not be so obvious six months later. Comments
    are ignored by Python when the script is run, but can be invaluable to the real
    people looking at the code, whether it’s you or someone else trying to understand
    your code. To create a comment, prefix text with a hash sign:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中添加注释也是一个好主意，这有助于你记住代码的功能或为什么以某种方式编写它。我可以保证，在你编写代码时看似明显的事情，六个月后可能就不会那么明显了。当脚本运行时，Python
    会忽略注释，但对于真正查看代码的人来说，注释可能非常有价值。要创建注释，请在文本前加上井号（#）：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In addition to comments, descriptive variable names improve the legibility of
    your code. For example, if you name a variable `m`, you need to read through the
    code to figure out what’s stored in that variable. If you name it `mean_value`
    instead, the contents will be obvious.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了注释外，描述性的变量名也能提高代码的可读性。例如，如果你将一个变量命名为 `m`，你需要阅读整个代码来弄清楚该变量存储了什么。如果你将其命名为 `mean_value`，其内容就会很明显。
- en: 2.3\. Variables
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3. 变量
- en: Unless your script is extremely simple, it will need a way to store information
    as it runs, and this is where variables come in. Think about what happens when
    you use software to open a file, no matter what kind of file it is. The software
    displays an Open dialog, you select a file and click OK, and then the file is
    opened. When you press OK, the name of the selected file is stored as a variable
    so that the software knows what file to open. Even if you’ve never programmed
    anything in your life, you’re probably familiar with this concept in the mathematical
    sense. Think back to algebra class and computing the value of *y* based on the
    value of *x*. The *x* variable can take on any value, and *y* changes in response.
    A similar concept applies in programming. You’ll use many different variables,
    or *x*’s, that will affect the outcome of your script. The outcome can be anything
    you want it to be and isn’t limited to a single *y* value, however. It might be
    a number, if your goal is to calculate a statistic on your data, but it could
    as easily be one or more entirely new datasets.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你的脚本非常简单，否则在运行过程中需要一种存储信息的方法，这就是变量的作用。想想当你使用软件打开文件时会发生什么，无论文件类型如何。软件显示一个打开对话框，你选择一个文件并点击确定，然后文件被打开。当你点击确定时，所选文件的名称被存储为一个变量，这样软件就知道要打开哪个文件。即使你从未编写过任何程序，你也可能熟悉这个数学概念。回想一下代数课，根据
    `x` 的值计算 `y` 的值。`x` 变量可以取任何值，而 `y` 会相应地变化。在编程中也有类似的概念。你会使用许多不同的变量，或 `x`，这些变量会影响脚本的输出。输出可以是任何你想要的东西，而不仅限于单个
    `y` 值。如果目标是计算数据上的统计量，它可能是一个数字，但也可能是一个或多个全新的数据集。
- en: 'Creating a variable in Python is easy. Give it a name and a value. For example,
    this assigns the value of `10` to a variable called `n` and then prints it out:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中创建变量非常简单。给它一个名字并赋予一个值。例如，这行代码将值 `10` 赋给名为 `n` 的变量，然后将其打印出来：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you’ve used other programming languages such as C++ or Java, you might be
    wondering why you didn’t need to specify that the variable `n` was going to hold
    an integer value. Python is a dynamically typed language, which means that variable
    types aren’t checked until runtime, and you can even change the data type stored
    in a variable. For example, you can switch `n` from an integer to a string and
    nobody will complain:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用过其他编程语言，如 C++ 或 Java，你可能想知道为什么你不需要指定变量 `n` 将要存储整数值。Python 是一种动态类型语言，这意味着变量类型直到运行时才进行检查，你甚至可以更改存储在变量中的数据类型。例如，你可以将
    `n` 从整数更改为字符串，而没有人会抱怨：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Although you can store whatever you want in a variable without worrying about
    data type, you will run into trouble if you try to use the variable in a way that’s
    inconsistent with the kind of data stored in it. Because the data types aren’t
    checked until runtime, the error won’t happen until that line of the script is
    executed, so you won’t get any warning beforehand. You’ll get the same errors
    in the Python interactive window that would occur in a script, so you can always
    test examples there if you’re not sure if something will work. For example, you
    can’t add strings and integers together, and this shows what happens if you try:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以在变量中存储任何你想要的内容而不必担心数据类型，但如果你试图以与存储在其中的数据类型不一致的方式使用变量，你将会遇到麻烦。因为数据类型直到运行时才会被检查，所以错误不会在脚本执行之前发生，因此你不会事先得到任何警告。你会在Python交互窗口中得到与脚本中发生的相同错误，所以如果你不确定某件事是否可行，你总是可以在那里测试示例。例如，你不能将字符串和整数相加，这显示了如果你尝试这样做会发生什么：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Remember that `n` contains `Hello world`, which cannot be added to `1`. If
    you’re using Python 2.7, the core of the problem is the same, but your error message
    will look like this instead:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 记住`n`包含`Hello world`，这不能与`1`相加。如果你使用Python 2.7，问题的核心是相同的，但你的错误信息将如下所示：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Notice that you use a single equal sign to assign a value to a variable. To
    test for equality, always use a double equal sign:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你使用单个等号来给变量赋值。为了测试相等性，始终使用双等号：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When you’re first starting out, you might be more comfortable hardcoding values
    into your script instead of using variables when you don’t have to. For example,
    say you need to open a file in the script, maybe on line 37\. You’ll probably
    be tempted to type the filename on line 37 when the file is opened. This will
    certainly work, but you’ll find that things are easier to change later if you
    instead define a variable containing the filename early in the script and then
    use that variable on line 37\. First, this makes it easier to find the values
    you need to change, but even more importantly, it will be much easier to adapt
    your code so that you can use it in more situations. Instead of line 37 looking
    something like this,
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当你刚开始时，你可能更愿意在脚本中将值硬编码而不是使用变量，即使你不必这样做。例如，假设你需要在脚本中打开一个文件，可能在第37行。你可能会在文件打开时在第37行输入文件名。这当然可以工作，但你很快会发现，如果你在脚本早期定义一个包含文件名的变量并在第37行使用它，事情会更容易改变。首先，这使得找到你需要更改的值变得更容易，但更重要的是，这将使你更容易调整代码，以便在更多情况下使用它。而不是让第37行看起来像这样，
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'you’d define a variable early on and then use it when needed:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在一开始就定义一个变量，并在需要时使用它：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It might be hard to remember to do this at first, but you’ll be glad you did
    if you have to adapt your code to use other data.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 起初可能很难记住这样做，但如果你需要调整代码以使用其他数据，你会很高兴你做了这件事。
- en: 2.4\. Data types
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4. 数据类型
- en: As your code becomes more complex, you’ll find that it’s extremely difficult
    to store all of the information that your script needs as numbers and strings.
    Fortunately, you can use many different types of data structures, ranging from
    simple numbers to complex objects that can contain many different types of data
    themselves. Although an infinite number of these object types can be used (because
    you can define your own), only a small number of core data types exist from which
    the more complex ones are built. I’ll briefly discuss several of those here. Please
    see a more comprehensive set of Python documentation for more details, because
    this leaves out much information.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的代码变得越来越复杂，你会发现将所有脚本所需的信息以数字和字符串的形式存储变得极其困难。幸运的是，你可以使用许多不同类型的数据结构，从简单的数字到可以包含许多不同类型数据的复杂对象。虽然可以使用无限数量的这些对象类型（因为你可以定义自己的），但只有少数核心数据类型存在，更复杂的数据类型都是基于这些核心数据类型构建的。我将在下面简要讨论其中几个。请参阅更全面的Python文档以获取更多详细信息，因为这里省略了许多信息。
- en: 2.4.1\. Booleans
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.1. 布尔值
- en: 'A *Boolean* variable denotes true or false values. Two case-sensitive keywords,
    `True` and `False`, are used to denote these values. They can be used in standard
    Boolean operations, like these:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*布尔*变量表示真或假值。两个区分大小写的关键字`True`和`False`用于表示这些值。它们可以用于标准的布尔运算，如下所示：'
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Other values can also resolve to `True` or `False` when value testing and performing
    Boolean operations. For example, `0`, the `None` keyword, blank strings, and empty
    lists, tuples, sets, and dictionaries all resolve to `False` when used in Boolean
    expressions. Anything else resolves to `True`. You’ll see examples of this in
    [section 2.5](#ch02lev1sec5).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 其他值在值测试和执行布尔运算时也可以解析为`True`或`False`。例如，`0`、`None`关键字、空字符串以及空列表、元组、集合和字典在布尔表达式中都解析为`False`。其他任何东西都解析为`True`。你将在[第2.5节](#ch02lev1sec5)中看到这个例子。
- en: 2.4.2\. Numeric types
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.2\. 数字类型
- en: 'As you’d expect, you can use Python to work with numbers. What you might not
    expect, however, is that distinct kinds of numbers exist. *Integers* are whole
    numbers, such as 5, 27, or 592\. *Floating-point numbers*, on the other hand,
    are numbers with decimal points, such as 5.3, 27.0, or 592.8\. Would it surprise
    you to know that 27 and 27.0 are different? For one, they might take up different
    amounts of memory, although the details depend on your operating system and version
    of Python. If you’re using Python 2.7 there’s a major difference in how the two
    numbers are used for mathematical operations, because integers don’t take decimal
    places into account. Take a look at this Python 2.7 example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所期望的，你可以使用Python处理数字。然而，你可能不会预料到存在不同类型的数字。*整数*是整数，例如5、27或592。另一方面，*浮点数*是带有小数点的数字，例如5.3、27.0或592.8。知道27和27.0是不同的会令你惊讶吗？一方面，它们可能占用不同的内存量，尽管具体取决于你的操作系统和Python版本。如果你使用Python
    2.7，这两个数字在数学运算中的使用方式存在重大差异，因为整数不考虑小数位。看看这个Python 2.7的例子：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, if you divide an integer by another integer, you still end
    up with an integer, even if there’s a remainder. You get the correct answer if
    one or both of the numbers being used in the operation is floating-point. This
    behavior has changed in Python 3.x, however. Now you get floating-point math either
    way, but you can still force integer math using the `//` floor division operator:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，如果你将一个整数除以另一个整数，你仍然会得到一个整数，即使有余数。如果操作中使用的数字之一或两个都是浮点数，你会得到正确答案。然而，在Python
    3.x中，这种行为已经改变。现在无论哪种方式，你都会得到浮点数数学，但你仍然可以使用`//`地板除法运算符强制整数数学：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|  |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Python 3.x performs floating-point math by default, even on integers, but older
    versions of Python perform integer math if all inputs are integers. This integer
    math often leads to undesirable results, such as 2 instead of 2.4, in which case
    you must ensure that at least one input is floating-point.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.x默认执行浮点数数学，即使是在整数上，但Python的旧版本如果所有输入都是整数，则执行整数数学。这种整数数学往往会导致不理想的结果，例如2而不是2.4，在这种情况下，你必须确保至少有一个输入是浮点数。
- en: '|  |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Fortunately, you have a simple way to convert one numeric data type to the
    other, although be aware that converting floating-point to integer this way truncates
    the number instead of rounding it:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你有一种简单的方法可以将一种数值数据类型转换为另一种类型，尽管请注意，以这种方式将浮点数转换为整数会截断数字而不是四舍五入：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you want to round the number instead, you must use the `round` function:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要四舍五入数字，你必须使用`round`函数：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Python also supports complex numbers, which contain real and imaginary parts.
    As you might recall, these values result when you take the square root of a negative
    number. We won’t use complex numbers in this book, but you can read more about
    them at python.org if you’re interested.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Python还支持复数，它们包含实部和虚部。你可能还记得，这些值是在对负数开平方时得到的。我们在这本书中不会使用复数，但如果你感兴趣，可以在python.org上了解更多关于它们的信息。
- en: 2.4.3\. Strings
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.3\. 字符串
- en: '*Strings* are text values, such as `''Hello world''`. You create a string by
    surrounding the text with either single or double quotes—it doesn’t matter which,
    although if you start a string with one type, you can’t end it with the other
    because Python won’t recognize it as the end of the string. The fact that either
    one works makes it easy to include quotes as part of your string. For example,
    if you need single quotes inside your string, as you would in a SQL statement,
    surround the entire string with double quotes, like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符串*是文本值，例如`''Hello world''`。你可以通过将文本用单引号或双引号包围来创建字符串——哪种都可以，尽管如果你以一种类型开始字符串，就不能用另一种类型结束它，因为Python不会将其识别为字符串的结尾。两种方式都可以使用的事实使得在字符串中包含引号变得容易。例如，如果你需要在字符串内部使用单引号，就像在SQL语句中那样，将整个字符串用双引号包围，如下所示：'
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you need to include the same type of quote in your string that you’re using
    to delineate it, you can use a backslash before the quote. The first example here
    results in an error because the single quote in “don’t” ends the string, which
    isn’t what you want. The second one works, thanks to the backslash:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在字符串中包含与用于界定它的相同的引号类型，你可以在引号前使用反斜杠。这里的第一种情况会导致错误，因为“don’t”中的单引号结束了字符串，这不是你想要的。第二种情况由于反斜杠而有效：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Notice the caret symbol (`^`) under the spot where Python ran into trouble.
    This can help you narrow down where your syntax error is. The double quotes that
    surround the string when it’s printed aren’t part of the string. They show that
    it’s a string, which is obvious in this case, but wouldn’t be if the string was
    `"42"` instead. If you use the `print` function, the quotes aren’t shown:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意Python遇到麻烦的地方下的撇号符号（`^`）。这可以帮助你缩小语法错误的位置。当字符串打印时，包围字符串的双引号不是字符串的一部分。它们表明这是一个字符串，在这个例子中很明显，但如果字符串是`"42"`，则不会如此。如果你使用`print`函数，引号就不会显示：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Although most of these examples from the interactive window don’t use `print`
    to send output to the screen, you must use it to send output to the screen from
    a script. If you don’t, it won’t show up. In Python 3, `print` is a function and
    like all functions, you must pass the parameters inside parentheses. In Python
    2, `print` is a statement and the parentheses aren’t required, but they won’t
    break anything, either.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数来自交互窗口的示例都没有使用`print`将输出发送到屏幕，但你必须使用它从脚本中发送输出到屏幕。如果不这样做，它就不会显示。在Python
    3中，`print`是一个函数，就像所有函数一样，你必须将参数传递到括号内。在Python 2中，`print`是一个语句，括号不是必需的，但它们也不会造成任何问题。
- en: '|  |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Joining strings
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 字符串连接
- en: 'You have several ways to join strings together. If you’re only concatenating
    two strings, then the simplest and fastest is to use the `+` operator:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你有几种方法可以将字符串连接起来。如果你只是连接两个字符串，那么最简单、最快的方法是使用`+`运算符：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you’re joining multiple strings, the `format` method is a better choice.
    It can also join values together that aren’t all strings, something the `+` operator
    can’t do. To use it, you create a template string that uses curly braces as placeholders,
    and then pass values to take the place of the placeholders. You can read the Python
    documentation online to see the many ways you can use this for sophisticated formatting,
    but we’ll look at the basic method of specifying order. Here, the first item passed
    to `format` replaces the `{0}` placeholder, the second replaces `{1}`, and so
    on:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要连接多个字符串，`format`方法是一个更好的选择。它还可以连接不是所有都是字符串的值，这是`+`运算符无法做到的。要使用它，你创建一个模板字符串，该字符串使用大括号作为占位符，然后传递值以替换占位符。你可以在线阅读Python文档，了解你可以用这种方式进行复杂格式化的许多方法，但我们将查看指定顺序的基本方法。在这里，传递给`format`的第一个项目替换了`{0}`占位符，第二个替换了`{1}`，依此类推：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To see that the numeric placeholders make a difference, try switching them
    around but leaving everything else the same:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到数字占位符有何不同，尝试交换它们的位置，但保持其他一切不变：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The fact that the placeholders reference specific values means that you can
    use the same placeholder in multiple locations if you need to insert an item in
    the string more than once. This way you don’t have to repeat anything in the list
    of values passed to `format`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 事实是占位符引用特定值意味着如果你需要在字符串中插入一个项目多次，你可以在多个位置使用相同的占位符。这样你就不必在传递给`format`的值列表中重复任何内容。
- en: Escape characters
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 转义字符
- en: 'Remember the backslash that you used to include a quote inside a string earlier?
    That’s called an *escape character* and can also be used to include nonprintable
    characters in strings. For example, `"\n"` includes a new line, and `"\t"` represents
    a tab:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 记得你之前用来在字符串中包含引号的反斜杠吗？这被称为*转义字符*，也可以用来在字符串中包含不可打印的字符。例如，`"\n"`包含一个换行符，而`"\t"`代表一个制表符：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The fact that Windows uses backslashes as path separators causes angst for
    beginning programmers who use Windows, because they tend to forget that a single
    backslash isn’t a backslash. For example, pretend you have a file called cities.csv
    in your d:\temp folder. Try asking Python if it exists:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Windows使用反斜杠作为路径分隔符，这给使用Windows的初学者带来了困扰，因为他们往往会忘记单个反斜杠不是反斜杠。例如，假设你在d:\temp文件夹中有一个名为cities.csv的文件。尝试询问Python它是否存在：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To get an idea of why that fails, when you know that the file does indeed exist,
    try printing the string instead:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解为什么它会失败，当你知道文件确实存在时，尝试打印字符串而不是文件名：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `"\t"` was treated as a tab character! You have three ways to solve this
    problem. Either use forward slashes or double backslashes, or prefix the string
    with an `r` to tell Python to ignore escape characters:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`"\t"`被当作制表符处理！你有三种方法解决这个问题。要么使用正斜杠或双反斜杠，要么在字符串前加一个`r`来告诉Python忽略转义字符：'
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: I prefer the latter method if I’m copying and pasting paths, because it’s much
    easier to add one character at the beginning than to add multiple backslashes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我在复制粘贴路径，我更喜欢后者，因为添加一个字符在开头比添加多个反斜杠要容易得多。
- en: 2.4.4\. Lists and tuples
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.4. 列表和元组
- en: 'A *list* is an ordered collection of items that are accessed via their index.
    The first item in the list has index 0, the second has index 1, and so on. The
    items don’t even have to all be the same data type. You can create an empty list
    with a set of square brackets, `[]`, or you can populate it right off the bat.
    For example, this creates a list with a mixture of numbers and strings and then
    accesses some of them:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表*是有序的项目集合，通过它们的索引访问。列表中的第一个项目索引为0，第二个索引为1，依此类推。项目不必都是相同的数据类型。你可以使用一组方括号`[]`创建一个空列表，或者立即填充它。例如，这创建了一个包含数字和字符串混合的列表，然后访问其中的一些：'
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can also use offsets from the end of the list, with the last item having
    index -1:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用列表末尾的偏移量，最后一个项目具有索引-1：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You’re not limited to retrieving one item at a time, either. You can provide
    a starting and ending index to extract a slice, or sublist. The item at the ending
    index isn’t included in the returned value, however:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你也不限于一次检索一个项目。你可以提供一个起始和结束索引来提取一个切片或子列表。但是，结束索引的项目不包括在返回值中：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can change single values in the list, or even slices, using indices:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用索引更改列表中的单个值，甚至切片：
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Use `append` to add an item to the end of the list, and `del` to remove an
    item:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`append`向列表末尾添加项目，并使用`del`删除项目：
- en: '[PRE28]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It’s also easy to find out how many items are in a list or if it contains a
    specific value:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，也很容易找出列表中有多少项，或者它是否包含特定的值：
- en: '[PRE29]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Tuples* are also ordered collections of items, but they can’t be changed once
    created. Instead of brackets, tuples are surrounded by parentheses. You can access
    items and test for existence the same as with lists:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*元组*也是有序的项目集合，但一旦创建就不能更改。与方括号不同，元组由圆括号包围。你可以像访问列表一样访问项目和检查是否存在：'
- en: '[PRE30]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Like I said, you’re not allowed to change a tuple once it has been created:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我说的一样，一旦创建元组，就不允许更改：
- en: '[PRE31]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Because of this, use lists instead of tuples when it’s possible that the data
    will change.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当可能改变数据时，最好使用列表而不是元组。
- en: '|  |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Error messages are your friend**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误信息是你的朋友**'
- en: 'When you get an error message, be sure to look carefully at the information
    it provides because this can save you time figuring out the problem. The last
    line is a message giving you a general idea of what the problem is, as seen here:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当你收到错误信息时，一定要仔细查看它提供的信息，因为这可以节省你解决问题的时间。最后一行是一个消息，它给你一个关于问题的总体概念，就像这里看到的：
- en: '[PRE32]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You could deduce from this error message that your code tried to edit a tuple
    object somehow. Before the error message, you’ll see a list of the lines of code
    that were executed before it ran into a problem. This is called a *stack trace*.
    In this example, `<stdin>` means the interactive window, so the line number isn’t
    as helpful. But look at the following, which traces through two lines of code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从这个错误信息中推断出你的代码试图以某种方式编辑一个元组对象。在错误信息之前，你会看到在遇到问题之前执行的一行代码列表。这被称为*堆栈跟踪*。在这个例子中，`<stdin>`表示交互式窗口，所以行号并不那么有用。但看看下面的，它追踪了两个代码行：
- en: '![](025fig01_alt.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](025fig01_alt.jpg)'
- en: The last line tells you the error is from trying to add an integer and a string
    together. The trace tells you that the problem started with line 7 of the file
    trace_example.py. Line 7 calls a function called `add`, and the error happens
    on line 2 inside of that function. You can use the information from the stack
    trace to determine where the error occurred, and where the original line of code
    that triggered it is. In this example, you know that either you passed bad data
    to the `add` function on line 7, or else an error exists in the `add` function
    on line 2\. That gives you two specific places to look for a mistake.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行告诉你错误是由于尝试将整数和字符串相加而产生的。跟踪信息告诉你问题始于文件 trace_example.py 的第7行。第7行调用了一个名为 `add`
    的函数，错误发生在该函数的第2行。你可以使用堆栈跟踪信息来确定错误发生的位置，以及触发它的原始代码行。在这个例子中，你知道要么你在第7行的 `add` 函数中传递了错误的数据，要么在第2行的
    `add` 函数中存在错误。这为你提供了两个具体的错误查找位置。
- en: '|  |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 2.4.5\. Sets
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.5\. 集合
- en: '*Sets* are unordered collections of items, but each value can only occur once,
    which makes it an easy way to remove duplicates from a list. For example, this
    set is created using a list that contains two instances of the number 13, but
    only one is in the resulting set:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*集合* 是由项目组成的无序集合，但每个值只能出现一次，这使得它成为从列表中删除重复项的一种简单方法。例如，这个集合是通过包含两个13的实例的列表创建的，但结果集合中只有一个：'
- en: '[PRE33]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can add new values, but they’ll be ignored if they’re already in the set,
    such as `''movie''` in this example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加新的值，但如果它们已经在集合中，则会被忽略，例如本例中的 `'movie'`：
- en: '[PRE34]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Sets aren’t ordered, so you can’t access specific elements. You can check if
    items are in the set, however:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是无序的，因此你不能访问特定元素。然而，你可以检查项目是否在集合中：
- en: '[PRE35]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Sets also make it easy to do things such as combine collections (`union`) or
    find out which items are contained in both sets (`intersection`):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 集合还使得执行诸如合并集合（`并集`）或找出两个集合中都包含哪些项目（`交集`）等操作变得容易：
- en: '![](026fig01_alt.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](026fig01_alt.jpg)'
- en: You’ve already seen that you can use sets to remove duplicates from a list.
    An easy way to determine if a list contains duplicate values is to create a set
    from the list and check to see if the set and list have the same length. If they
    don’t, then you know duplicates were in the list.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到你可以使用集合从列表中删除重复项。确定列表是否包含重复值的一个简单方法是从列表创建一个集合，并检查集合和列表的长度是否相同。如果它们不同，那么你就知道列表中有重复项。
- en: 2.4.6\. Dictionaries
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.6\. 字典
- en: '*Dictionaries* are indexed collections, like lists and tuples, except that
    the indices aren’t offsets like they are in lists. Instead, you get to choose
    the index value, called a *key*. Keys can be numbers, strings, or other data types,
    as can the values they reference. Use curly braces to create a new dictionary:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 是索引集合，类似于列表和元组，但索引不是列表中的偏移量。相反，你可以选择索引值，称为 *键*。键可以是数字、字符串或其他数据类型，以及它们引用的值。使用花括号创建新字典：'
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As with lists, you can add, change, and remove items:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表一样，你可以添加、更改和删除项目：
- en: '[PRE37]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can also test to see if a key exists in the dictionary:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以测试字典中是否存在键：
- en: '[PRE38]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is a powerful way to store data when you don’t know beforehand what it
    will be. For example, say you needed to remember the spatial extent for each file
    in a collection of geographic datasets, but the list of datasets changed each
    time you ran your script. You could create a dictionary and use the filenames
    as keys and the spatial extents as values, and then this information would be
    readily available later in your script.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当你事先不知道数据将是什么时，这是一种强大的数据存储方式。例如，假设你需要记住地理数据集集合中每个文件的空间范围，但每次运行你的脚本时数据集列表都会改变。你可以创建一个字典，并使用文件名作为键，空间范围作为值，然后这些信息就可以在脚本后面的任何地方轻松获取。
- en: 2.5\. Control flow
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5\. 控制流
- en: The first script you write will probably consist of a sequence of statements
    that are executed in order, like all of the examples we have looked at so far.
    The real power of programming, however, is the ability to change what happens
    based on different conditions. Similar to the way you might use sale prices to
    decide which veggies to buy at the supermarket, your code should use data, such
    as whether it’s working with a point or a line, to determine exactly what needs
    to be done. *Control flow* is the concept of changing this order of code execution.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你写的第一个脚本可能是由一系列按顺序执行的语句组成的，就像我们之前看过的所有例子一样。然而，编程的真正力量在于能够根据不同的条件改变发生的事情。类似于你可能会用折扣价来决定在超市买哪些蔬菜，你的代码应该使用数据，比如它是在处理点还是线，来确定确切需要做什么。*控制流*是改变代码执行顺序的概念。
- en: 2.5.1\. If statements
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.5.1\. 如果语句
- en: 'Perhaps the simplest way to change execution order is to test a condition and
    do something different depending on the outcome of the test. This can be done
    with an `if` statement. Here’s a simple example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 改变执行顺序可能最简单的方法是测试一个条件，并根据测试结果执行不同的操作。这可以通过`if`语句来实现。这里有一个简单的例子：
- en: '[PRE39]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If the value of the `n` variable is `1`, then the string “n equals 1” will be
    printed. Otherwise, the string “n does not equal 1” will be printed. Notice that
    the `if` and `else` lines end with a colon and that the code depending on a condition
    is indented under the condition. This is a requirement. Once you quit indenting
    code, then the code quits depending on the condition. What do you think the following
    code will print?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`n`变量的值是`1`，那么会打印出字符串“n等于1”。否则，会打印出字符串“n不等于1”。注意，`if`和`else`行以冒号结尾，并且依赖于条件的代码缩进在条件之下。这是必需的。一旦你停止缩进代码，那么代码就会停止依赖于条件。你认为以下代码会打印出什么？
- en: '[PRE40]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Well, `n` is equal to `1`, so the equality message prints out, and then control
    is transferred to the first line of code that isn’t indented, so this is the result:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，`n`等于`1`，所以等式信息会被打印出来，然后控制权传递到第一个没有缩进的代码行，所以这就是结果：
- en: '[PRE41]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can also test multiple conditions like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以用这种方式测试多个条件：
- en: '[PRE42]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this case, `n` is first compared to `1`. If it’s not equal to `1`, then it’s
    compared to `3`. If it’s not equal to that, either, then it checks to see if `n`
    is greater than `5`. If none of those conditions are true, then the code under
    the `else` statement is executed. You can have as many `elif` statements as you
    want, but only one `if` and no more than one `else`. Similar to the way the `elif`
    statements aren’t required, neither is an `else` statement. You can use an `if`
    statement all by itself if you’d like.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`n`首先与`1`进行比较。如果它不等于`1`，那么它就会与`3`进行比较。如果它也不等于那个数，那么它会检查`n`是否大于`5`。如果这些条件都不成立，那么就会执行`else`语句下的代码。你可以有任意多的`elif`语句，但只能有一个`if`语句，并且不能有超过一个的`else`。与`elif`语句不需要一样，`else`语句也不需要。如果你想，你可以单独使用一个`if`语句。
- en: 'This is a good place to illustrate the idea that different values can evaluate
    to `True` or `False` while testing conditions. Remember that strings resolve to
    `True` unless they’re blank. Let’s test this with an `if` statement:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个说明不同值在测试条件时可以评估为`True`或`False`的好地方。记住，除非字符串为空，否则字符串会解析为`True`。让我们用一个`if`语句来测试这个：
- en: '[PRE43]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If you’d used a string containing any characters at all, including a single
    space, then the preceding example would have resolved to `True` instead of `False`.
    If you have a Python console open, go ahead and try it and see for yourself. Let’s
    look at one more example that resolves to `True` because the list isn’t empty:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用了一个包含任何字符的字符串，包括单个空格，那么前面的例子就会解析为`True`而不是`False`。如果你有一个Python控制台打开，就去试一试，看看结果如何。让我们再看一个解析为`True`的例子，因为列表不为空：
- en: '[PRE44]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You can use this same idea to test that a number isn’t equal to zero, because
    zero is the same as `False,` but any other number, positive or negative, will
    be treated as `True`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用这个相同的概念来测试一个数字是否不等于零，因为零等同于`False`，但任何其他数字，无论是正数还是负数，都会被视为`True`。
- en: 2.5.2\. While statements
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.5.2\. 当循环语句
- en: 'A `while` statement executes a block of code as long as a condition is `True`.
    The condition is evaluated, and if it’s `True,` then the code is executed. Then
    the condition is checked again, and if it’s still `True`, then the code executes
    again. This continues until the condition is `False`. If the condition never becomes
    `False`, then the code will run forever, which is called an *infinite loop* and
    is a scenario you definitely want to avoid. Here’s an example of a `while` loop:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 语句只要条件为 `True` 就会执行一段代码。条件被评估，如果它是 `True`，则执行代码。然后再次检查条件，如果它仍然是 `True`，则再次执行代码。这会一直持续到条件变为
    `False`。如果条件永远不会变为 `False`，则代码将永远运行，这被称为 *无限循环*，是你绝对想要避免的场景。以下是一个 `while` 循环的例子：'
- en: '[PRE45]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `+=` syntax means “increment the value on the left by the value on the right,”
    so `n` is incremented by `1`. Once `n` is equal to `5`, it’s no longer less than
    `5`, so the condition becomes `False` and the indented code isn’t executed again.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`+=` 语法表示“将右侧的值加到左侧的值上”，因此 `n` 的值增加 `1`。一旦 `n` 等于 `5`，它就不再小于 `5`，因此条件变为 `False`，缩进的代码不再执行。'
- en: 2.5.3\. For statements
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.5.3\. 对于语句
- en: 'A `for` statement allows you to iterate over a sequence of values and do something
    for each one. When you write a `for` statement, you not only provide the sequence
    to iterate over, but you also provide a variable name. Each time through the loop,
    this variable contains a different value from the sequence. This example iterates
    through a list of names and prints a message for each one:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 语句允许你遍历一系列值并对每个值执行一些操作。当你写一个 `for` 语句时，你不仅提供了要遍历的序列，还提供了一个变量名。每次通过循环时，这个变量包含序列中的不同值。这个例子遍历一个名字列表并为每个名字打印一条消息：'
- en: '[PRE46]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The first time through the loop, the `name` variable is equal to `'Chris'`,
    the second time it holds `'Janet'`, and the last time it is equal to `'Tami'`.
    I called this variable `name`, but it can be called anything you want.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 循环第一次执行时，`name` 变量等于 `'Chris'`，第二次它保持 `'Janet'`，最后一次它等于 `'Tami'`。我称这个变量为 `name`，但你可以称它为你想要的任何名字。
- en: The range function
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`range` 函数'
- en: 'The range function makes it easy to iterate over a sequence of numbers. Although
    this function has more parameters, the simplest way to use it is to provide a
    number *n*, and it will create a sequence from 0 to *n*-1\. For example, this
    will count how many times the loop was executed:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`range` 函数使得遍历一系列数字变得简单。尽管这个函数有更多的参数，但最简单的方法是提供一个数字 *n*，然后它将创建一个从 `0` 到 *n*-1
    的序列。例如，这将计算循环执行了多少次：'
- en: '[PRE47]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The variable `i` wasn’t used in this code, but nothing is stopping you from
    using it. Let’s use it to calculate the factorial of 20, although this time we’ll
    provide a starting value of `1` for the sequence, and have it go up to but not
    include the number `21`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `i` 在这段代码中没有使用，但没有什么阻止你使用它。让我们使用它来计算 `20` 的阶乘，尽管这次我们将序列的起始值设置为 `1`，并且让它增加到但不包括数字
    `21`：
- en: '[PRE48]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You’ll see in later chapters that this variable is also useful for accessing
    individual items in a dataset when they aren’t directly iterable.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在后面的章节中看到，这个变量在访问数据集中的单个项目时也非常有用，即使它们不是直接可迭代的。
- en: 2.5.4\. break, continue, and else
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.5.4\. break、continue 和 else
- en: 'A few statements apply to `while` and `for` loops. The first one, `break`,
    will kick execution completely out of the loop, as in this example that stops
    the loop when `i` is equal to `3`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语句适用于 `while` 和 `for` 循环。第一个是 `break`，它将完全退出循环，就像这个例子中当 `i` 等于 `3` 时停止循环：
- en: '[PRE49]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Without the break `statement`, this loop would have printed the numbers 0 through
    4.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有 `break` 语句，这个循环将打印从 `0` 到 `4` 的数字。
- en: 'The `continue` statement jumps back up to the top of the loop and starts the
    next iteration, skipping the rest of the code that would normally be executed
    during the current loop iteration. In this example, `continue` is used to skip
    the code that prints `i` if it’s equal to `3`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue` 语句将跳回到循环的顶部并开始下一次迭代，跳过在当前循环迭代期间通常要执行的其余代码。在这个例子中，`continue` 用于跳过当
    `i` 等于 `3` 时打印 `i` 的代码：'
- en: '[PRE50]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Loops can also have an `else` statement. Code inside of this clause is executed
    when the loop is done executing, unless the loop was stopped with `break`. Here
    we’ll check to see if the number 2 is in a list of numbers. If it is, we’ll break
    out of the loop. Otherwise, the `else` clause is used to notify us that the number
    wasn’t found. In the first case, the number is found, `break` is used to exit
    the loop, and the `else` statement is ignored:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 循环也可以有一个`else`子句。当循环执行完毕时，除非使用`break`停止循环，否则会执行这个子句中的代码。这里我们将检查数字2是否在数字列表中。如果是，我们将跳出循环。否则，`else`子句用于通知我们没有找到数字。在第一种情况下，找到了数字，使用`break`退出循环，并忽略`else`子句：
- en: '[PRE51]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'But if the number isn’t found, so `break` is never called, then the `else`
    clause is executed:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果找不到数字，那么`break`从未被调用，那么`else`子句将被执行：
- en: '[PRE52]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You could use this pattern to set a default value for something if an appropriate
    value wasn’t found in a list. For example, say you needed to find and edit a file
    with a specific format in a folder. If you can’t find a file with the correct
    format, you need to create one. You could loop through the files in the folder,
    and if you found an appropriate one you could break out of the loop. You could
    create a new file inside the `else` clause, and that code would only run if no
    suitable existing file had been found.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在列表中找不到合适的值，可以使用这种模式为某个东西设置默认值。例如，假设你需要在一个文件夹中找到并编辑具有特定格式的文件。如果你找不到具有正确格式的文件，你需要创建一个。你可以遍历文件夹中的文件，如果找到一个合适的文件，就可以跳出循环。你可以在`else`子句中创建一个新文件，并且只有当没有找到合适的现有文件时，这段代码才会运行。
- en: 2.6\. Functions
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6\. 函数
- en: 'If you find that you reuse the same bits of code over and over, you can create
    your own function and call that instead of repeating the same code. This makes
    things much easier and also less error-prone, because you won’t have nearly as
    many places to make typos. When you create a function, you need to give it a name
    and tell it what parameters the user needs to provide to use it. Let’s create
    a simple function to calculate a factorial:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现你反复使用相同的代码片段，你可以创建自己的函数并调用它，而不是重复相同的代码。这样做可以使事情变得更容易，也更不容易出错，因为你不会在那么多地方犯拼写错误。当你创建一个函数时，你需要给它一个名字，并告诉用户需要提供哪些参数才能使用它。让我们创建一个简单的函数来计算阶乘：
- en: '[PRE53]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The name of this function is `factorial`, and it takes one parameter, `n`.
    It uses the same algorithm you used earlier to calculate a factorial and then
    uses a `return` statement to send the answer back to the caller. You could use
    this function like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的名称是`factorial`，它接受一个参数`n`。它使用你之前使用的相同算法来计算阶乘，然后使用`return`语句将答案发送回调用者。你可以像这样使用这个函数：
- en: '[PRE54]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Functions can also have optional parameters that the user doesn’t need to provide.
    To create one of these, you must provide a default value for it when you create
    the function. For example, you could modify factorial to optionally print out
    the answer:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也可以有可选参数，用户不需要提供这些参数。要创建这样的参数，你必须在创建函数时为它提供一个默认值。例如，你可以修改阶乘函数，使其可选地打印出答案：
- en: '[PRE55]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If you were to call this function with only a number, nothing would get printed
    because the default value of `print_it` is `False`. But if you pass `True` as
    the second parameter, then a message will print before the answer is returned:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只传递一个数字调用这个函数，什么也不会打印出来，因为`print_it`的默认值是`False`。但是，如果你将`True`作为第二个参数传递，那么在返回答案之前会打印一条消息：
- en: '[PRE56]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'It’s easy to reuse your functions by saving them in a .py file and then importing
    them the way you would any other module. The one hitch is that your file needs
    to be in a location where Python can find it. One way to do this is to put it
    in the same folder as the script that you’re running. For example, if the `factorial`
    function was saved in a file called myfuncs.py, you could import `myfuncs` (notice
    there’s no .py extension) and then call the function inside of it:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将它们保存在.py文件中，然后以导入其他模块的方式导入它们，很容易重用你的函数。唯一的问题是，你的文件需要位于Python可以找到的位置。一种方法是将它放在你正在运行的脚本的同一文件夹中。例如，如果`factorial`函数保存在一个名为myfuncs.py的文件中，你可以导入`myfuncs`（注意没有.py扩展名），然后调用其中的函数：
- en: '[PRE57]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Because certain characters aren’t allowed in module names, and module names
    are only filenames without the extension, you need to be careful when naming your
    files. For example, underscores are allowed in module names, but hyphens aren’t.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模块名称中不允许使用某些字符，并且模块名称只是没有扩展名的文件名，因此在命名文件时需要小心。例如，下划线在模块名称中是允许的，但破折号则不行。
- en: 2.7\. Classes
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.7\. 类
- en: As you work through this book, you’ll come across variables that have other
    data and functions attached to them. These are objects created from classes. Although
    we won’t cover how to create your own classes in this book, you need to be aware
    of them because you’ll still use ones defined by someone else. Classes are an
    extremely powerful concept, but all you need to understand for the purposes of
    this book are that they’re data types that can contain their own internal data
    and functions. An object or variable that is of this type contains these data
    and functions, and the functions operate on that particular object. You saw this
    with several of the data types we looked at earlier, such as lists. You can have
    a variable of type `list`, and that variable contains all of the functions, such
    as `append`, that come with being a list. When you call `append` on a list, it
    only appends data to that particular list and not to any other list variables
    you might have.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你阅读这本书，你将遇到一些附加了其他数据和函数的变量。这些是从类中创建的对象。虽然我们在这本书中不会介绍如何创建自己的类，但你需要了解它们，因为你会继续使用其他人定义的类。类是一个非常强大的概念，但为了这本书的目的，你需要理解的是，它们是包含自身内部数据和函数的数据类型。这种类型的对象或变量包含这些数据和函数，并且函数作用于特定的对象。你已经在之前查看的一些数据类型中看到了这一点，例如列表。你可以有一个类型为`list`的变量，并且这个变量包含所有与列表相关的函数，例如`append`。当你对一个列表调用`append`时，它只会向该特定列表添加数据，而不会向你可能拥有的任何其他列表变量添加。
- en: 'Classes can also have methods that don’t apply to a particular object, but
    to the data type itself. For example, the Python datetime module contains a class,
    or type, called `date`. Let’s get that data type out of the module and then use
    it to create a new date object, which we can then ask which day of the week it
    is, where Monday is 0 and Sunday is 6:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 类也可以有适用于特定对象但不适用于数据类型的函数。例如，Python的datetime模块包含一个名为`date`的类或类型。让我们从模块中提取这个数据类型，然后使用它来创建一个新的日期对象，然后我们可以询问它是星期几，其中星期一是0，星期天是6：
- en: '[PRE58]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `datetype` variable holds a reference to the `date` type itself, not to
    a particular date object. The data type has a method, `today`, that creates a
    new date object. The date object stored in the `mydate` variable stores date information
    internally and uses that to determine what day of the week the date refers to,
    Sunday in this case. You couldn’t ask the `datetype` variable what weekday it
    was, because it doesn’t contain any information about a particular date. You don’t
    need to get a reference to the data type and could have created `mydate` with
    `datetime.date.today()`. Now suppose you want to find out what day of the week
    May 18 was in 2010\. You can create a new date object based on the existing one,
    but with the year changed, and then you can ask the new one what day of the week
    it represents:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`datetype`变量持有对`date`类型的引用，而不是对特定日期对象的引用。该数据类型有一个名为`today`的方法，它创建一个新的日期对象。存储在`mydate`变量中的日期对象内部存储日期信息，并使用这些信息来确定日期指的是星期几，在本例中是星期天。你不能询问`datetype`变量它是星期几，因为它不包含任何关于特定日期的信息。你不需要获取数据类型的引用，可以用`datetime.date.today()`创建`mydate`。现在假设你想知道2010年5月18日是星期几。你可以基于现有的日期对象创建一个新的日期对象，但年份已更改，然后你可以询问新的对象它代表的是星期几：'
- en: '[PRE59]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Apparently May 18, 2010, was a Tuesday. The original `mydate` variable hasn’t
    changed, and will still report that it refers to a Sunday.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，2010年5月18日是星期二。原始的`mydate`变量没有改变，仍然会报告它指的是星期天。
- en: You’ll use objects created from classes throughout this book. For example, whenever
    you open a dataset, you’ll get an object that represents that dataset. Depending
    on the type of data, that object will have different information and functions
    associated with it. Obviously, you need to know about the classes being used to
    create these objects, so that you know what data and functions they contain. The
    GDAL modules contain fairly extensive classes, which are documented in appendixes
    B, C, and D. (Appendixes C through E are available online on the Manning Publications
    website at [www.manning.com/books/geoprocessing-with-python](http://www.manning.com/books/geoprocessing-with-python).)
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在整本书中使用从类中创建的对象。例如，每次你打开一个数据集时，你都会得到一个代表该数据集的对象。根据数据类型的不同，该对象将具有不同的信息和函数。显然，你需要了解用于创建这些对象的类，以便你知道它们包含哪些数据和函数。GDAL模块包含相当广泛的类，这些类在附录B、C和D中有文档说明。（附录C至E可在Manning
    Publications网站上在线获取，网址为[www.manning.com/books/geoprocessing-with-python](http://www.manning.com/books/geoprocessing-with-python)。）
- en: 2.8\. Summary
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.8. 摘要
- en: The Python interpreter is useful for learning how things work or trying out
    small bits of code, but writing scripts is more efficient for running multiple
    lines of code. Plus, you can save scripts and use them later, which is one of
    the main reasons for programming.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 解释器对于学习事物的工作原理或尝试一小段代码非常有用，但编写脚本在运行多行代码时更有效率。此外，你可以保存脚本并在以后使用它们，这是编程的主要原因之一。
- en: Modules are libraries of code that you can load into your script and use. If
    you need to do something with Python, chances are good that somewhere a module
    exists that will help you out, no matter what it is you’re trying to do.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块是一组你可以加载到脚本中并使用的代码库。如果你需要用 Python 做某事，很可能某个模块存在，可以帮助你完成，无论你试图做什么。
- en: Get used to storing data in variables, because it will make your code much easier
    to adapt later.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 习惯于将数据存储在变量中，因为这会使你的代码在以后更容易适应。
- en: Python has a few core data types, all of which are extremely useful for different
    types of data and different situations.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 有一些核心数据类型，它们对于不同类型的数据和不同情况都非常有用。
- en: You can use control flow statements to change which lines of code execute based
    on various conditions or to repeat the same code multiple times.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用控制流语句根据各种条件改变代码的执行行，或者重复执行相同的代码多次。
- en: Use functions to make your code reusable.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数可以使你的代码可重用。
