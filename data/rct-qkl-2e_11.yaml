- en: '11 Project: Website menu'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11项目：网站菜单
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Creating the necessary scaffolding for a menu component
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为菜单组件创建必要的脚手架
- en: Rendering a static website menu
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染静态网站菜单
- en: 'Homework: Adding advanced features to the menu'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作业：向菜单添加高级功能
- en: We’ve reached a milestone. With the completion of chapter 10, you now know all
    you need to know about React itself to start building some pretty complex web
    applications. This and the next two chapters are all project chapters. These projects
    are much larger examples that guide you through the first steps of creating a
    full-featured web application and set you up for creating more advanced variants
    of those same applications.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经达到了一个里程碑。随着第10章的完成，你现在已经了解了关于React本身所需的所有知识，可以开始构建一些相当复杂的Web应用程序了。这一章和接下来的两章都是项目章节。这些项目是更大的示例，引导你通过创建一个功能齐全的Web应用程序的第一步，并为你创建这些应用程序的更高级版本做好准备。
- en: The project in this chapter is a website menu. It’s a top-bar menu component
    that you can directly use in a website. We’ll create this project in five steps,
    as outlined in figure 11.1.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目是一个网站菜单。这是一个可以直接在网站中使用的顶部栏菜单组件。我们将按照图11.1中概述的五个步骤创建这个项目。
- en: '![11-01](../Images/11-01.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![11-01](../Images/11-01.png)'
- en: Figure 11.1 We start this project with a scaffold, and through the steps in
    this chapter, we’ll build a fully fledged dynamic menu with an optional link to
    a profile page.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 我们从这个脚手架开始这个项目，通过本章中的步骤，我们将构建一个完整的动态菜单，并可选地链接到个人资料页面。
- en: The scaffold is where you start out building this application. Each additional
    step of the application adds more advanced features to the menu while utilizing
    new parts of the React API. We’ll set up step 1 first in this chapter, and then
    we’ll solve step 2 together. From then on, we’ll introduce the subsequent steps
    to you, but then you have to solve them yourself.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 脚手架是你开始构建这个应用程序的地方。应用程序的每个附加步骤都会为菜单添加更多高级功能，同时利用React API的新部分。我们将在本章中首先设置步骤1，然后我们将一起解决步骤2。从那时起，我们将向您介绍后续的步骤，但之后你必须自己解决它们。
- en: Of course, we’ll provide a reference solution to all the steps, including steps
    3 to 5, but we won’t tell you how we got there. Your solution to steps 3 to 5
    will most definitely not be identical to ours because there are so many different
    ways to do things. If you’re ever stuck, feel free to peek at our solutions to
    the latter steps, but please first try to solve them yourself.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们将为所有步骤提供参考解决方案，包括步骤3到5，但我们不会告诉你我们是如何做到这一点的。你步骤3到5的解决方案肯定不会与我们的一样，因为做事情的方法有很多种。如果你遇到困难，随时可以查看我们后者的解决方案，但请首先尝试自己解决。
- en: Table 11.1 outlines exactly what happens at each step in terms of what functionality
    we’re creating as well as which parts of the React API we’re utilizing.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.1概述了在每一步中确切发生的事情，包括我们正在创建的功能以及我们正在利用的React API的哪些部分。
- en: Table 11.1 The five steps of the menu project
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.1 菜单项目的五个步骤
- en: '| Step | Feature | Additional React API used | Difficulty |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 步骤 | 功能 | 使用额外的React API | 难度 |'
- en: '| Step 1: Scaffold | Create the basic component structure for a website with
    an empty menu. | Chapters 1-4: Functional components using JSX | ★☆☆☆☆ |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 步骤1：脚手架 | 创建一个带有空菜单的网站的基本组件结构。 | 第1-4章：使用JSX的功能组件 | ★☆☆☆☆ |'
- en: '| Step 2: Static menu | Add a static JSX menu using a custom menu item component
    with dynamic properties. | Chapters 3-4: Using JSX with dynamic properties | ★☆☆☆☆
    |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 步骤2：静态菜单 | 使用具有动态属性的定制菜单项组件添加静态JSX菜单。 | 第3-4章：使用具有动态属性的JSX | ★☆☆☆☆ |'
- en: '| Step 3: Dynamic menu from a list of links | Render the menu from a list of
    objects describing the menu items.Note: This is homework. You have to create this
    step *yourself*! | Chapters 3-4: Rendering lists of JSX elements | ★★☆☆☆ |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 步骤3：从链接列表创建动态菜单 | 从描述菜单项的对象列表中渲染菜单。注意：这是作业。你必须自己创建这一步！ | 第3-4章：渲染JSX元素列表
    | ★★☆☆☆ |'
- en: '| Step 4: Retrieving links from context | Retrieve the list of menu items from
    a context provided around the entire application.Note: This is homework. You have
    to create this step *yourself*! | Chapter 10: Context | ★★★☆☆ |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 步骤4：从上下文中检索链接 | 从围绕整个应用程序提供的上下文中检索菜单项列表。注意：这是作业。你必须自己创建这一步！ | 第10章：上下文 |
    ★★★☆☆ |'
- en: '| Step 5: Adding an optional link | Add a login/logout button that will dynamically
    add and remove a profile link to/from the menu.Note: This is homework. You have
    to create this step *yourself*! | Chapter 5: StateChapter 8: EventsChapter 10:
    Complex context and custom hooks | ★★★★☆ |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 第 5 步：添加可选链接 | 添加一个登录/注销按钮，该按钮将动态地将个人资料链接添加到/从菜单中。注意：这是作业。你必须自己创建这一步！ | 第
    5 章：状态第 8 章：事件第 10 章：复杂上下文和自定义钩子 | ★★★★☆ |'
- en: Before we get started, let’s take a look at what we’re building. It’s a minimalist
    website with a top bar with menu links. Take a look at figure 11.2 for a screenshot
    of the menu in action.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们看看我们要构建什么。这是一个具有顶部菜单链接的最简网站。查看图 11.2 以查看菜单的实际截图。
- en: '![11-02](../Images/11-02.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![11-02](../Images/11-02.png)'
- en: Figure 11.2 This is the website we’ll build. The menu at the top—Home, Services,
    Pricing, and Blog—is the main focus. In the first iteration, the menu items are
    statically defined.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 这是我们将要构建的网站。顶部的菜单——主页、服务、定价和博客——是主要焦点。在第一次迭代中，菜单项是静态定义的。
- en: For a little flair, we’ll also add some UX, including a slight hover effect
    when you move your pointer over one of the menu items. Figure 11.3 shows what
    this looks like. With the design and end goal out of the way, let’s get started!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加一些风格，我们还将添加一些用户体验设计，包括当你的指针移到菜单项上时，会有轻微的悬停效果。图 11.3 展示了这看起来是什么样子。设计目标确定后，让我们开始吧！
- en: '![11-03](../Images/11-03.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![11-03](../Images/11-03.png)'
- en: Figure 11.3 When the user hovers over a menu item, the background turns a slightly
    darker gray to highlight what the user is interacting with.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 当用户悬停在菜单项上时，背景变为略深的灰色以突出显示用户正在与之交互的内容。
- en: Note The source code for the scaffolding and suggested solutions to all the
    sections in this chapter are available at [https://rq2e.com/ch11](https://rq2e.com/ch11).
    But as you learned in chapter 2, you can instantiate all the examples and solutions
    directly from the command line using a single command.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章中所有部分的源代码和解决方案的代码框架都可以在[https://rq2e.com/ch11](https://rq2e.com/ch11)找到。但正如你在第
    2 章中学到的，你可以使用单个命令直接从命令行实例化所有示例和解决方案。
- en: 11.1 Scaffolding for the menu
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 菜单的代码框架
- en: Okay, here we go. Our first “real” React project is on the line. To do this,
    we need a plan. We’ll think this through as if it was a real project that we had
    to solve for a client, an employer, or your uncle’s lawn mowing and babysitting
    business, aka Laps & Naps Inc.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们开始了。我们的第一个“真正”的 React 项目就在眼前。为了做到这一点，我们需要一个计划。我们将像对待一个真正的项目一样，这个项目是我们必须为客户、雇主或你叔叔的草坪修剪和婴儿看护业务（即
    Laps & Naps Inc.）解决的，来思考这个问题。
- en: 'Starting with the desired result as illustrated in figures 11.2 and 11.3, we’ll
    go through these steps:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从图 11.2 和 11.3 中所示的目标结果开始，我们将按以下步骤进行：
- en: Define the HTML output that will render the desired result.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义将渲染所需结果的 HTML 输出。
- en: Create a number of React components that will render JSX to achieve the desired
    HTML.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建多个 React 组件，以渲染 JSX 来实现所需的 HTML。
- en: Place static images in the public folder that we can load at runtime.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将静态图像放置在公共文件夹中，以便在运行时加载。
- en: Create a stylesheet.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个样式表。
- en: Implement the components that we need to get the necessary functionality.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现我们需要的组件以获得必要的功能。
- en: Let’s get cracking!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: 11.1.1 HTML output
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.1 HTML 输出
- en: In this project, we’re starting out by building a static HTML page with React
    and JSX. In general, you neither would nor should use React for this, but because
    it’s only the first step, and we’ll be adding dynamic functionality on top of
    that later, it makes sense to start out with static output. The desired output
    HTML for the scaffolding looks like figure 11.4.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们首先使用 React 和 JSX 构建一个静态 HTML 页面。一般来说，你既不会也不会使用 React 来做这个，但因为这是第一步，而且我们稍后将在其上添加动态功能，所以从静态输出开始是有意义的。代码框架的期望输出
    HTML 看起来像图 11.4。
- en: '![11-04](../Images/11-04.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![11-04](../Images/11-04.png)'
- en: Figure 11.4 The HTML node tree for the scaffold of the menu application consists
    of just these elements.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 菜单应用程序代码框架的 HTML 节点树仅由这些元素组成。
- en: 11.1.2 Component hierarchy
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.2 组件层次结构
- en: To render the desired HTML tree, we need a React application that renders a
    similar set of JSX nodes. We could use any number of React components to implement
    this. We could create a component for every HTML node if we wanted to, or we could
    create a single component that renders the entire thing. This is where the developer’s
    judgment comes into play.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了渲染所需的HTML树，我们需要一个React应用程序来渲染一组类似的JSX节点。我们可以使用任意数量的React组件来实现这一点。如果我们想的话，我们可以为每个HTML节点创建一个组件，或者我们可以创建一个渲染整个内容的单个组件。这就是开发者判断发挥作用的地方。
- en: You’ve seen us devise the desired React component structure for all the examples
    so far in this book. But soon (later in this chapter), this will be on you. You
    have to be in charge. You have to come up with a component tree for a given desired
    output.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了我们为本书中迄今为止的所有示例设计了所需的React组件结构。但很快（在本章的后面部分），这将成为你的责任。你必须负责。你必须为给定的预期输出设计一个组件树。
- en: Figuring out how to cut the cake and split a given desired output into components
    is a task central to being a React developer. In figure 11.5, you can see two
    different approaches to how to create components that render the desired output.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 确定如何切割蛋糕并将给定的预期输出拆分为组件是成为React开发者的一项核心任务。在图11.5中，你可以看到两种不同的方法来创建渲染预期输出的组件。
- en: '![11-05](../Images/11-05.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![11-05](../Images/11-05.png)'
- en: Figure 11.5 Two different approaches to creating components for a desired output.
    We're actually going to go for neither, but rather a medium approach between the
    two because we're focusing on the menu only.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 创建用于预期输出的组件的两种不同方法。我们实际上将不会选择其中任何一种，而是选择介于两者之间的中等方法，因为我们只关注菜单。
- en: There’s more than one way to skin a component tree, and no one way is the right
    one. When deciding how to structure your components, you should aim for a balance
    between complexity and responsibility. In this case, we could easily implement
    the whole application in a single component as in the left-most case in figure
    11.5; but knowing we’ll add extra functionality inside the <nav> element in the
    header, we’ll encapsulate that as its own component. It will be a very small component
    for now, but we’ll expand it later.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 组件树的结构化方式不止一种，没有哪一种方式是绝对正确的。在决定如何构建你的组件时，你应该在复杂性和责任之间寻求平衡。在这种情况下，我们可以轻松地将整个应用程序实现为一个组件，就像图11.5中最左侧的情况；但考虑到我们将在页眉中的
    <nav> 元素内添加额外功能，我们将将其封装为它自己的组件。目前这个组件将会非常小，但我们会稍后扩展它。
- en: 11.1.3 Icons
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.3 图标
- en: As you might have noticed in the original screenshot in figure 11.2, we have
    some icons in the menu. Let’s take a closer look at those in figure 11.6.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在图11.2中的原始截图中所注意到的，我们在菜单中有些图标。让我们在图11.6中更仔细地看看这些图标。
- en: '![11-06](../Images/11-06.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![11-06](../Images/11-06.png)'
- en: Figure 11.6 A close-up of the icons in the menu
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 菜单中图标的特写
- en: 'There are many ways to render icons in React, but we’re using the simplest
    one for now. We’ll render scalable vector graphics (SVG) images loaded from an
    external file. We can do that by placing files inside the public folder in the
    React application folder like so:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中渲染图标的方法有很多，但我们现在使用的是最简单的一种。我们将通过将文件放置在React应用程序文件夹中的公共文件夹中来渲染可缩放矢量图形（SVG）图像。我们可以这样做：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Creates an icons folder inside the public folder
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在公共文件夹内创建一个图标文件夹
- en: ❷ Places five SVG files inside the icons folder
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在图标文件夹内放置五个SVG文件
- en: ❸ The public folder also has these two files, created by create-react-app (CRA)
    by default. We don't touch those.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 公共文件夹中也包含这两个由 create-react-app (CRA) 默认创建的文件。我们不会去修改它们。
- en: 'When these files are inside the public folder, we can load them wherever via
    the path "/icons/blog.svg". For example, we can render the blog icon as an <img>
    tag:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些文件位于公共文件夹中时，我们可以通过路径"/icons/blog.svg"在任何地方加载它们。例如，我们可以将博客图标渲染为一个<img>标签：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that we also have a profile.svg image in the icons folder. We don’t need
    that for the first versions of the menu, but we’ll need it later, so it’s already
    there if you keep working on the same application. All the icons are public domain
    and completely free to use in whatever context you desire.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还在图标文件夹中有一个 profile.svg 图像。对于菜单的第一版，我们不需要它，但稍后我们会需要它，所以如果你继续在同一应用程序上工作，它已经在那里了。所有图标都是公共领域，可以完全免费在任何你想要的上下文中使用。
- en: 11.1.4 CSS
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.4 CSS
- en: Finally, we’ll need quite a bit of CSS for this application. So far, we’ve used
    inline styles via the style attribute on JSX elements. This has worked okay because
    we only had very limited styling to apply. In this application, however, we need
    a lot of styles, and we need hover styling. Rendering a lot of styles is possible
    using inline styles, though it’s not optimal. But hover styling is impossible
    using inline styles, so we’ll need a proper stylesheet.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还需要相当多的 CSS 来完成此应用程序。到目前为止，我们通过 JSX 元素上的 style 属性使用了内联样式。这已经足够好了，因为我们只需要应用非常有限的样式。然而，在这个应用程序中，我们需要很多样式，并且需要悬停样式。虽然使用内联样式可以渲染很多样式，但这并不是最佳选择。但是，使用内联样式无法实现悬停样式，因此我们需要一个合适的样式表。
- en: React and CRA, fortunately, make this incredibly simple. We haven’t discussed
    this much, but in a React file, you can import a stylesheet directly, and the
    React compiler will convert it to a regular stylesheet inserted in the HTML when
    needed.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，React 和 CRA 使这变得非常简单。我们还没有详细讨论这个问题，但在 React 文件中，你可以直接导入样式表，React 编译器会在需要时将其转换为常规样式表并插入到
    HTML 中。
- en: '*The pros and cons of loading styles inline or using stylesheets is outside
    the scope of this* *book, so, for now, we’ll use this approach because it’s simple
    and it works well for smaller applications:*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*将样式内联加载或使用样式表的优势和劣势超出了本书的范围，因此，目前我们将采用这种方法，因为它简单且适用于较小的应用程序：*'
- en: Create a stylesheet, style.css, inside the src folder.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 src 文件夹内创建一个样式表，style.css。
- en: Load the stylesheet inside the main App.js file where the root application is
    defined.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义根应用程序的 main App.js 文件中加载样式表。
- en: Apply class names to JSX elements and have them render using the rules defined
    in the stylesheet.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类名应用于 JSX 元素，并使用样式表中定义的规则进行渲染。
- en: And that’s it!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！
- en: 'Loading a stylesheet in JavaScript means importing the file. You don’t import
    it *as* something, like you do for components, you simply import the file like
    this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中加载样式表意味着导入文件。你不需要像导入组件那样导入它，你只需像这样导入文件：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That’s all it takes. You can now apply class names where relevant.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些。现在您可以在相关位置应用类名。
- en: 11.1.5 Template
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.5 模板
- en: We’ve created this whole scaffold as a template for you to start your work on.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了这个整个框架作为您开始工作的模板。
- en: 'Repository: rq11-scaffold'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq11-scaffold
- en: 'This example can be seen in repository rq11-scaffold. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例可以在仓库 rq11-scaffold 中看到。您可以通过创建基于相关模板的新应用程序来使用该仓库：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问此网站浏览代码，直接在浏览器中查看应用程序的运行情况，或下载源代码的 zip 文件：
- en: '[https://rq2e.com/rq11-scaffold](https://rq2e.com/rq11-scaffold)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq11-scaffold](https://rq2e.com/rq11-scaffold)'
- en: 'This template comes with the following files relevant for your application:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板包含以下与您的应用程序相关的文件：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Icons used to render the menu items
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 用于渲染菜单项的图标
- en: ❷ Default files included in a CRA minimal project untouched by us
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们未修改的 CRA 最小项目中的默认文件
- en: ❸ Custom components with the basic scaffold
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 基础框架的自定义组件
- en: ❹ A complete stylesheet with all the rules required to complete this project
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 一个包含完成此项目所需所有规则的完整样式表
- en: 'However, if you want to start from scratch, you can do so. You can use the
    following template that only contains the icons and stylesheet, but no custom
    components. The src folder is completely standard based on the regular minimal
    template except for the stylesheet needed:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您想从头开始，您也可以这样做。您可以使用以下仅包含图标和样式表的模板，但没有自定义组件。src 文件夹完全基于常规最小模板，除了需要的样式表：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you do use this latter approach, you’ll have to start editing src/App.js.
    Remember to import the stylesheet as well. This minimal template contains these
    files:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用此后的方法，您将不得不开始编辑 src/App.js。请记住，还需要导入样式表。此最小模板包含以下文件：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Icons used to render the menu items
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 用于渲染菜单项的图标
- en: ❷ Default files included in a CRA minimal project untouched by us
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们未修改的 CRA 最小项目中的默认文件
- en: ❸ A complete stylesheet with all the rules required to complete this project
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 一个包含完成此项目所需所有规则的完整样式表
- en: 11.1.6 Source code
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.6 源代码
- en: The source code for the scaffolding application, defined in src/App.js, follows.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 框架应用程序的源代码，定义在 src/App.js 中，如下所示。
- en: Listing 11.1 src/App.js in the scaffolding
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.1 框架中的 src/App.js
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ The menu is defined in an external file and imported at the top.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 菜单定义在一个外部文件中，并在顶部导入。
- en: ❷ Defines the CSS externally in a file named style.css
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在名为 style.css 的文件中外部定义 CSS
- en: ❸ Renders the menu component in the header at the relevant place
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在页眉的相关位置渲染菜单组件
- en: The source code for the CSS file, src/style.css, is defined in the next listing.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 文件，src/style.css 的源代码定义在下一个列表中。
- en: Listing 11.2 src/style.css in the scaffolding
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.2 框架中的 src/style.css
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The source code for the menu, defined in src/Menu.js, follows.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单的源代码，定义在 src/Menu.js 中，如下所示。
- en: Listing 11.3 src/Menu.js in the scaffolding
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.3 框架中的 src/Menu.js
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ The menu only renders an empty <nav> element for now.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 目前菜单只渲染一个空的 <nav> 元素。
- en: 11.1.7 In the browser
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.7 在浏览器中
- en: If we run this in the browser, we get a nice website with an empty menu, as
    shown in figure 11.7.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中运行这个程序，我们会得到一个带有空菜单的漂亮网站，如图 11.7 所示。
- en: '![11-07](../Images/11-07.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![11-07](../Images/11-07.png)'
- en: Figure 11.7 A website with a temporarily empty menu that we'll soon fill with
    some great links
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 一个暂时为空菜单的网站，我们很快会用一些优秀的链接来填充
- en: 11.2 Rendering a static menu
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 渲染静态菜单
- en: In this step of the project, we’ll take the current state of affairs after completing
    the first part of the exercise and add the required functionality to render a
    static menu with a fixed list of menu items.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目步骤中，我们将完成练习第一部分后的当前状态，并添加所需的功能来渲染一个具有固定菜单项的静态菜单。
- en: You can start the project by either implementing the scaffolding yourself based
    on the information given in the previous section or starting from the application
    defined in the rq11-scaffold template. The result of this step is the application
    defined in the following repository.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过根据上一节提供的信息自行实现框架或从 rq11-scaffold 模板定义的应用程序开始来启动项目。这一步的结果是以下仓库中定义的应用程序。
- en: 'Repository: rq11-static'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq11-static
- en: 'This example can be seen in repository rq11-static. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在 rq11-static 仓库中看到。您可以通过创建基于相关模板的新应用程序来使用该仓库：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问这个网站来浏览代码，直接在您的浏览器中查看应用程序的运行情况，或者下载源代码的 zip 文件：
- en: '[https://rq2e.com/rq11-static](https://rq2e.com/rq11-static)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq11-static](https://rq2e.com/rq11-static)'
- en: 11.2.1 The goal of this exercise
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.1 本练习的目标
- en: 'The goal of this exercise is to populate the empty menu in the previous step.
    The menu component was just this—a completely empty element with no menu items:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目标是在上一步中填充空白的菜单。菜单组件就是这样的——一个完全空白的元素，没有任何菜单项：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Before we get started, we first need to define the desired HTML output, then
    decide on a component tree that best creates this output, and, finally, implement
    these components.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们首先需要定义所需的 HTML 输出，然后决定一个最佳的组件树来创建这个输出，最后实现这些组件。
- en: 11.2.2 Desired HTML output
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.2 所需的 HTML 输出
- en: We’re focusing on the HTML output inside the <nav> component only. To render
    a list of links in a menu, the HTML tree visualized in figure 11.8 renders the
    desired outcome.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只关注 <nav> 组件内部的 HTML 输出。为了在菜单中渲染一系列链接，图 11.8 中可视化的 HTML 树会渲染出期望的结果。
- en: '![11-08](../Images/11-08.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![11-08](../Images/11-08.png)'
- en: Figure 11.8 The HTML node tree for the navigation element is an unordered list
    of links.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8 导航元素的 HTML 节点树是一个链接的无序列表。
- en: 11.2.3 Component tree
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.3 组件树
- en: 'The component tree for this one kind of writes itself. We want to create a
    component that encapsulates the duplicated HTML in the HTML tree in figure 11.8\.
    We can call that a MenuItem component, which takes three properties:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件树几乎可以自己写出来。我们想要创建一个组件，它封装了图 11.8 中的 HTML 树中的重复 HTML。我们可以称这个组件为 MenuItem
    组件，它接受三个属性：
- en: href—The actual target URL that the link will point to
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: href—链接实际指向的目标 URL
- en: icon—The name of the SVG file to load as an icon
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: icon—要加载为图标的 SVG 文件名
- en: children—The text that goes inside the link
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: children—链接内的文本
- en: We can illustrate this as a component tree in figure 11.9.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用图 11.9 中的组件树来表示这一点。
- en: '![11-09](../Images/11-09.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![11-09](../Images/11-09.png)'
- en: Figure 11.9 Along with having two components, we pass two properties and children
    to the MenuItem component.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9 除了有两个组件外，我们还向 MenuItem 组件传递了两个属性和 children。
- en: With that out of the way, we can now implement the required changes in the relevant
    components.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决这个问题之后，我们现在可以在相关组件中实现所需的变化。
- en: 11.2.4 Source code
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.4 源代码
- en: First, we implement the updated Menu.js component in the next listing. As illustrated
    in figure 11.7, we need to render a list of four MenuItem instances.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在下一个列表中实现更新的 Menu.js 组件。如图 11.7 所示，我们需要渲染四个 MenuItem 实例的列表。
- en: Listing 11.4 src/Menu.js for a static menu
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.4 src/Menu.js 用于静态菜单
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Four instances of our MenuItem component, each with slightly different properties
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 四个我们的 MenuItem 组件实例，每个实例具有略微不同的属性
- en: Second, we implement the new component, MenuItem.js.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们实现新的组件，MenuItem.js。
- en: Listing 11.5 src/MenuItem.js for a static menu
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.5 src/MenuItem.js 用于静态菜单
- en: '[PRE13]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ The MenuItem component takes three properties, of which one is the special
    children property.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ MenuItem 组件接受三个属性，其中一个是特殊的子属性。
- en: ❷ Defines the icon source based on the known location of the icon files as well
    as the passed icon property
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 基于图标文件的已知位置以及传递的图标属性定义图标源
- en: ❸ The anchor element needs an href, which we take from the properties.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 锚点元素需要一个 href，我们从属性中获取。
- en: ❹ The image element needs a source, which we’ve calculated in a variable.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 图像元素需要一个源，我们已经在一个变量中计算了它。
- en: ❺ Renders the children property next to the image as the link text
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将子属性作为链接文本放在图像旁边
- en: 11.2.5 In the browser
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.5 在浏览器中
- en: If we run this in the browser, we get exactly what we wanted as originally illustrated
    in figure 11.2, but repeated here in figure 11.10 for comparison.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中运行它，我们将得到如图 11.2 所示的原始所需结果，但在此处重复图 11.10 以进行比较。
- en: '![11-10](../Images/11-10.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![11-10](../Images/11-10.png)'
- en: Figure 11.10 Our static menu works! Try hovering the menu items in your browser
    to see the slight hover effect achieved by the stylesheet rules.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.10 我们静态菜单工作！在浏览器中尝试悬停菜单项，以查看通过样式表规则实现的轻微悬停效果。
- en: '11.3 Homework: A dynamic menu'
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 家庭作业：一个动态菜单
- en: After step 2, we have a nice static menu, so you might now be wondering why
    we would want to do that differently. Well, the thing is, the menu items will
    be dynamic in a later stage of this project (management told us some time ago),
    so we might as well prepare ourselves for that.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 2 之后，我们有一个漂亮的静态菜单，所以你现在可能想知道为什么我们想要以不同的方式做这件事。事实上，在项目的后期阶段，菜单项将是动态的（管理层之前告诉我们），所以我们最好为此做好准备。
- en: Dynamic menu items mean that the number of items as well as the text, icon,
    and perhaps href of the individual menu items might be updated as the user interacts
    with the site. Imagine that you log into the website as a customer, and suddenly
    some of the menu items are removed and others are added. Different customers might
    see different menu items once logged in. So, while the current approach works,
    it’s not ideal for a dynamic menu, where we have to update the menu items depending
    on state and external data.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 动态菜单项意味着随着用户与网站交互，项目数量以及文本、图标和可能 href 的单个菜单项可能会更新。想象一下，你以客户身份登录网站，突然一些菜单项被删除，而其他菜单项被添加。不同的客户在登录后可能会看到不同的菜单项。因此，虽然当前方法可行，但它并不适合动态菜单，我们必须根据状态和外部数据更新菜单项。
- en: 11.3.1 Goal for this step
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.1 本步骤的目标
- en: The goal for this step is to prepare the project for dynamic rendering by switching
    to a list of objects to be rendered as menu items, rather than manually typing
    all the menu items out in JSX. The structure of the project will be the same as
    you’ll probably have the same number of components, but a bit more data will be
    passed between components.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 本步骤的目标是通过将菜单项转换为要渲染的对象列表，而不是手动在 JSX 中输入所有菜单项，为动态渲染准备项目。项目的结构将与您可能拥有的相同数量的组件相同，但组件之间传递的数据将更多。
- en: However, it’s a requirement that the list of menu items is defined in the App
    component (because some senior architect says so, and who are we to question seniority?).
    Because we’ll use this list in the Menu component, we need to pass this list as
    a property.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要求在 App 组件中定义菜单项列表（因为一些高级架构师这么说，我们又能质疑谁呢？）。因为我们将使用这个列表在 Menu 组件中，我们需要将这个列表作为属性传递。
- en: 11.3.2 Hints for solving this step
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.2 解决本步骤的提示
- en: 'The central points of this step require answering these two questions:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本步骤的核心要点需要回答这两个问题：
- en: How will the list items be structured to capture all the information we need
    to render the menu items?
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将如何构建列表项以捕获我们渲染菜单项所需的所有信息？
- en: How will we render the menu items based on a list of objects?
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将如何根据对象列表渲染菜单项？
- en: We’ll give you a hint for each of these questions.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为每个问题提供一个提示。
- en: Defining list items
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 定义列表项
- en: 'The list items need to contain information about where the menu item link points
    to (the href), which icon is going to be displayed, and what text is going to
    be displayed. This can be captured in an object like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表项需要包含有关菜单项链接指向何处（href）、将要显示哪个图标以及将要显示什么文本的信息。这可以捕获在一个像这样的对象中：
- en: '[PRE14]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Naming properties is completely up to you, and you might do it differently than
    this if you want to.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的命名完全取决于您，如果您愿意，您可能会以不同的方式来做。
- en: Rendering list items
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染列表项
- en: 'To render JSX nodes based on a list of items, think back to section 3.2.8 on
    rendering a list of JSX objects. This generally takes the following structure:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据项目列表渲染JSX节点，回想一下第3.2.8节关于渲染JSX对象列表的内容。这通常具有以下结构：
- en: '[PRE15]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Maps the list of objects to a list of JSX nodes
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将对象列表映射到JSX节点列表
- en: ❷ Adds a unique key for each node
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为每个节点添加一个唯一的键
- en: ❸ Adds any other relevant properties from the mapped list element
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从映射的列表元素添加任何其他相关属性
- en: Importantly, remember to define a unique key on each node in the mapped response.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，记得在映射的响应中的每个节点上定义一个唯一的键。
- en: 11.3.3 Component hierarchy
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.3 组件层次结构
- en: The number of components doesn’t change, but we use them a bit differently.
    Where we previously had a static list of four MenuItem component instances inside
    the Menu component, we now have a dynamic list of MenuItem instances based on
    the length of the array of links. We need to pass this list of links from the
    App component to the Menu component. The only unchanged component is the MenuItem
    component, as it was already dynamic and capable of displaying dynamic content.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的数量没有变化，但我们使用它们的方式略有不同。在我们之前在Menu组件内部有四个MenuItem组件实例的静态列表中，我们现在有一个基于链接数组长度的动态MenuItem实例列表。我们需要将这个链接列表从App组件传递到Menu组件。唯一没有变化的是MenuItem组件，因为它已经可以动态显示内容。
- en: Our recommendation for a component hierarchy is displayed in figure 11.11, but
    you’re free to come up with your own structure, if you so desire. There is no
    single correct solution to this.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对组件层次结构的建议显示在图11.11中，但您可以根据自己的意愿提出自己的结构。对此没有唯一的正确解决方案。
- en: '![11-11](../Images/11-11.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![11-11](../Images/11-11.png)'
- en: Figure 11.11 We now pass a property to the Menu component from App, and we then
    use that property to generate a dynamic number of MenuItem instances.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11 我们现在从App组件传递一个属性到Menu组件，然后我们使用该属性来生成动态数量的MenuItem实例。
- en: 11.3.4 What now?
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.4 现在怎么办？
- en: We strongly recommend that you have a go at this yourself. If you followed in
    step 2 implementing the static list yourself, we recommend that you just keep
    going from there. But if you want to start from a clean slate, you can also start
    with our implementation of step 2 from the rq11-static repository.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议您亲自尝试一下。如果您在第二步中自己实现了静态列表，我们建议您继续从这里开始。但如果您想从零开始，您也可以从rq11-static仓库中的我们的第二步实现开始。
- en: After completing this exercise, you might want to compare your solution to our
    version, not to see if you got it 100% identical (because odds are small that
    you did), but just to see if we had a different approach.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个练习后，您可能想比较一下您的解决方案和我们的版本，不是为了看是否完全相同（因为您做到这一点的机会很小），而是为了看看我们是否有不同的方法。
- en: 'Repository: rq11-dynamic'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq11-dynamic
- en: 'This example can be seen in repository rq11-dynamic. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq11-dynamic仓库中看到。您可以通过创建一个基于相关模板的新应用程序来使用该仓库：
- en: '[PRE16]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以去这个网站浏览代码，直接在浏览器中查看应用程序的实际运行情况，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq11-dynamic](https://rq2e.com/rq11-dynamic)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq11-dynamic](https://rq2e.com/rq11-dynamic)'
- en: If you enjoyed this step, we recommend that you try the next two steps in this
    project, though they do get a little bit harder.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您喜欢这一步，我们建议您尝试这个项目中的下两个步骤，尽管它们会变得稍微有点难。
- en: '11.4 Homework: Retrieving items from context'
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4 作业：从上下文中检索项目
- en: We’ve made the menu dynamic now, which is a great first step. But to make it
    truly dynamic, we need to be able to manipulate the list of menu items from throughout
    the application. Passing lists of links around to a lot of components would be
    annoying, so we would rather move the list of links to a context that surrounds
    the entire application. This will ensure that we have access to the list easily
    from anywhere.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使菜单变得动态，这是一个很好的第一步。但要使其真正动态，我们需要能够从应用程序的任何地方操作菜单项的列表。将链接列表传递给许多组件会很麻烦，所以我们更愿意将链接列表移动到包围整个应用程序的上下文中。这将确保我们能够轻松地从任何地方访问列表。
- en: 11.4.1 Goal for this step
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.1 本步骤的目标
- en: In this step, we’ll take the abstraction up another level. Rather than pass
    the list of links around as a property between components, we’ll move it to a
    context. For now, this context will only contain our list of links, which is used
    inside the Menu component. To prepare for the next step, where the context will
    need to also be accessible from the rest of the application, we recommend wrapping
    the context around the entire application.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，我们将抽象提升到另一个层次。而不是将链接列表作为属性在组件之间传递，我们将它移动到上下文中。目前，这个上下文只包含我们的链接列表，该列表在
    Menu 组件内部使用。为了准备下一步，其中上下文还需要从应用程序的其他部分访问，我们建议将上下文包裹在整个应用程序周围。
- en: 11.4.2 Hints for solving this step
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.2 解决此步骤的提示
- en: 'To load the links from a context, we need to do three things:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要从上下文中加载链接，我们需要做三件事：
- en: Define a React context in a variable that is accessible from multiple components.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个可以从多个组件访问的变量中定义一个 React 上下文。
- en: Create a context provider around the relevant part of the application.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序的相关部分创建一个上下文提供者。
- en: Apply the useContext hook where we need access to the context variable.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们需要访问上下文变量的地方应用 useContext 钩子。
- en: Defining a context
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 定义上下文
- en: 'To define a React context, you simply invoke the createContext() function from
    the React package. To make sure this variable is accessible from multiple components,
    you can create it in a separate file and export it. This is the shortest way to
    achieve this goal:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个 React 上下文，你只需从 React 包中调用 createContext() 函数。为了确保这个变量可以从多个组件中访问，你可以在一个单独的文件中创建它并导出。这是实现这一目标的最短方式：
- en: '[PRE17]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ The default argument is an empty array in this instance.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在这个例子中，默认参数是一个空数组。
- en: Note how we supply an empty array as the default context value. If, for some
    reason, we tried to access the context where it isn’t defined, we would get an
    empty list of links as the value.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何提供一个空数组作为默认上下文值。如果我们出于某种原因试图访问未定义的上下文，我们会得到一个空链接列表作为值。
- en: Creating a context provider
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 创建上下文提供者
- en: To create a context provider, wrap the relevant components inside a Context.Provider
    component. This component instance should be supplied with a value property, which
    will contain the current context value.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个上下文提供者，将相关组件包裹在 Context.Provider 组件内部。这个组件实例应该提供一个包含当前上下文值的 value 属性。
- en: 'If you have the context in a variable named MenuContext and a list of links
    in a variable named links, you can provide a context for a set of components,
    A, B, and C, like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个名为 MenuContext 的变量包含上下文信息，以及一个名为 links 的变量包含链接列表，你可以为组件 A、B 和 C 提供上下文，如下所示：
- en: '[PRE18]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Accessing the context value
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 访问上下文值
- en: 'To access the context value, you use the useContext hook inside a component
    that exists somewhere inside the context provider. If the context in question
    is named MenuContext, you can access the current value like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问上下文值，你需要在上下文提供者内部某个组件中使用 useContext 钩子。如果相关的上下文名为 MenuContext，你可以这样访问当前值：
- en: '[PRE19]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 11.4.3 Component hierarchy
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.3 组件层次结构
- en: Once again, you can do this in many ways. We’ve outlined our suggestion for
    how to accomplish this in figure 11.12, but it’s just one such tree diagram. Many
    other solutions are possible.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，你可以用很多种方式来做这件事。我们在图 11.12 中概述了我们的建议，但这只是众多树形图解决方案之一。
- en: '![11-12](../Images/11-12.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![11-12](../Images/11-12.png)'
- en: Figure 11.12 The whole application is wrapped in a context provider, and we
    use the same context to retrieve the context value inside the menu component.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12 整个应用程序被包裹在一个上下文提供者中，我们使用相同的上下文在菜单组件内部检索上下文值。
- en: 11.4.4 What now?
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.4 接下来做什么？
- en: We recommend that you have a go at this yourself. If you’ve completed step 3,
    we recommend that you keep going from there. But if you don’t like your result
    or for some other reason want to start from a fresh slate, you can start with
    our implementation of step 3 in the rq11-dynamic repository. When complete, you’ll
    probably want to compare your solution to ours for educational purposes.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您亲自尝试。如果您已经完成了第3步，我们建议您从那里继续。但如果您不喜欢您的结果或出于其他原因想要从头开始，您可以从rq11-dynamic存储库中的第3步实现开始。完成后，您可能想为了教育目的将您的解决方案与我们的解决方案进行比较。
- en: Now that you’ve come this far, we suggest that you also try the next step. It’s
    a bit harder, but most likely worth it, as you’ll really see how things start
    to work together.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 既然您已经走到这一步，我们建议您也尝试下一步。这有点难，但很可能值得，因为您将真正看到事物是如何开始协同工作的。
- en: 'Repository: rq11-context'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库：rq11-context
- en: 'This example can be seen in repository rq11-context. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例可以在rq11-context存储库中看到。您可以通过创建基于相关模板的新应用程序来使用该存储库：
- en: '[PRE20]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问这个网站来浏览代码，直接在您的浏览器中查看应用程序，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq11-context](https://rq2e.com/rq11-context)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq11-context](https://rq2e.com/rq11-context)'
- en: '11.5 Homework: Optional link'
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.5 家庭作业：可选链接
- en: We’ve reached the last step of this project. We’ll now add some very simple
    authentication mechanics, and, once authenticated, the user will be presented
    with an additional link in the menu.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了这个项目的最后一步。现在，我们将添加一些非常简单的认证机制，一旦认证成功，用户将在菜单中看到一个额外的链接。
- en: How basic of an authentication scheme, you ask? Trust-based. If you click the
    Log In button, you’re logged in. If you then click the Log Out button, you’re
    logged out. This isn’t useful for any real authentication, of course, but for
    demonstration purposes, it will serve us fine. The flowchart for this application
    is incredibly simple, as you can see in figure 11.13.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 您问基本认证方案有多基本？基于信任的。如果您点击登录按钮，您就登录了。然后如果您点击注销按钮，您就注销了。当然，这对任何真正的认证都没有用，但为了演示目的，它将对我们很有用。此应用程序的流程图非常简单，如图11.13所示。
- en: '![11-13](../Images/11-13.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![11-13](../Images/11-13.png)'
- en: Figure 11.13 A user will either be logged in or not, and the menu will reflect
    that.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.13 用户将要么登录，要么未登录，菜单将反映这一点。
- en: To achieve this, we’ll add a very simple Log In button to the main section of
    the page below the headline. You can see what the website should look like in
    this state in figure 11.14.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将在页面标题下方的主区域添加一个非常简单的登录按钮。您可以在图11.14中看到网站在这个状态下的样子。
- en: '![11-14](../Images/11-14.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![11-14](../Images/11-14.png)'
- en: Figure 11.14 When the user is unknown, the main section of the website contains
    a Log In button, and the menu still has four menu items like before.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.14 当用户未知时，网站的主区域包含一个登录按钮，菜单仍然像以前一样有四个菜单项。
- en: If you click the button, you’re considered logged in and can see the new profile
    link in the menu. You can see what this should look like in figure 11.15.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击该按钮，您将被视为已登录，可以在菜单中看到新的个人资料链接。您可以在图11.15中看到它应该是什么样子。
- en: '![11-15](../Images/11-15.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![11-15](../Images/11-15.png)'
- en: Figure 11.15 When the user is authenticated, the main section of the website
    now contains a Log Out button, and the menu has an extra, fifth, menu item.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.15 当用户认证时，网站的主区域现在包含一个注销按钮，菜单有一个额外的、第五个菜单项。
- en: 11.5.1 Goal for this step
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.1 此步骤的目标
- en: The goal for this step is to extend the context provider with the extra properties
    required to know the state and to manipulate it. We also need to store the state
    somewhere in an updatable way.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤的目标是扩展上下文提供者，以包含了解状态和操作状态所需的额外属性。我们还需要以可更新的方式将状态存储在某个地方。
- en: While doing this work, feel free to reorganize components as you see fit. You
    might want to add extra components if that seems like the right thing to do. As
    mentioned earlier, that is a judgment call for the developer to make.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这项工作时，请随意根据您的需要重新组织组件。如果您认为这样做是正确的，您可能还想添加额外的组件。如前所述，这是开发者需要做出的判断。
- en: 11.5.2 Hints for solving this step
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.2 解决此步骤的提示
- en: 'Here are some hints that might help you solve this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些可能有助于您解决问题的提示：
- en: In step 4, the context value was only a list of links. You now need the context
    to hold more than one value, so you probably want to use an object.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在步骤 4 中，上下文值只是一个链接列表。你现在需要上下文持有多个值，所以你可能想使用一个对象。
- en: You can create a custom hook to more easily access the value of a context.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以创建一个自定义钩子来更轻松地访问上下文的值。
- en: To keep track of the Boolean state of whether the user is authenticated or not,
    you probably need a stateful hook.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了跟踪用户是否认证的布尔状态，你可能需要一个有状态的钩子。
- en: Moving the context provider to a dedicated component might make the application
    easier to understand.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将上下文提供者移动到专用组件可能会使应用程序更容易理解。
- en: Because the main section of the application now has more logic, it could benefit
    from becoming its own component.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为应用程序的主部分现在有更多的逻辑，它可能从成为它自己的组件中受益。
- en: Remember that you can use the special property children to pass components “through”
    another component.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住，你可以使用特殊的属性 children 将组件“传递”给另一个组件。
- en: Object as a context value
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 作为上下文值的对象
- en: 'While we did not directly address this in chapter 10, you can store multiple
    values in a context. You do so by using an object:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在第 10 章中没有直接解决这个问题，但你可以在上下文中存储多个值。你可以通过使用对象来实现这一点：
- en: '[PRE21]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ We can have as many values as we want in a provider object.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在提供者对象中，我们可以拥有我们想要的任意多个值。
- en: ❷ We can even put functions in there.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们甚至可以放函数在里面。
- en: Remember, if you change the value of a provider, you might also want to change
    the initial default value passed to createContext.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果你更改提供者的值，你可能还想更改传递给 createContext 的初始默认值。
- en: Custom hook for context access
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 用于上下文访问的自定义钩子
- en: 'If you have a context that you want to use in multiple places—let’s say it’s
    an API context for access to some general API functionality—you can use the useContext
    hook directly in multiple places like so:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个想在多个地方使用的上下文——比如说它是一个用于访问某些通用 API 功能的 API 上下文——你可以在多个地方直接使用 useContext
    钩子，如下所示：
- en: '[PRE22]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'But to make life simpler for yourself (and perhaps your fellow team members),
    you can create a custom hook that does this for you. Then, you only have to import
    a single thing:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 但为了使自己的生活更简单（也许还有你的团队成员），你可以创建一个自定义钩子来为你完成这项工作。然后，你只需要导入一个东西：
- en: '[PRE23]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Creating tiny custom hooks like that might look a bit silly, but it’s actually
    helpful and a very common practice.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这样的小型自定义钩子可能看起来有点愚蠢，但实际上很有帮助，并且是一种非常常见的做法。
- en: Stateful Boolean
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 有状态的布尔值
- en: 'If you need a simple value to be stateful in React, the easiest way is to apply
    the useState hook, as explained in chapter 5:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个简单的值在 React 中成为有状态的，最简单的方法是应用 useState 钩子，如第 5 章中所述：
- en: '[PRE24]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ The return value from useState can be deconstructed into the value and the
    setter function.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ useState 的返回值可以被解构为值和设置函数。
- en: 'Remember that you don’t have to expose the state setter directly. You can create
    your own functions to make it easier to work with:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你不必直接暴露状态设置器。你可以创建自己的函数来使其更容易工作：
- en: '[PRE25]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: These are just general examples, of course; you have to modify them for the
    application in question.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是通用示例，当然；你必须根据具体的应用程序进行修改。
- en: In addition, remember to actually use this stateful variable in your application.
    In this application in particular, you want to vary the value of the links variable
    depending on the stateful Boolean.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请记住实际上在你的应用程序中使用这个有状态变量。特别是在这个应用程序中，你希望根据有状态布尔值改变链接变量的值。
- en: Dedicated context provider component
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 专用上下文提供者组件
- en: When we add more logic and more values to our context, it often makes sense
    to move it to a dedicated component. So rather than
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向上下文中添加更多逻辑和更多值时，将其移动到专用组件通常是有意义的。所以，而不是
- en: '[PRE26]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'we can instead create two components, App and ValueProvider, and split them
    up like this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建两个组件，App 和 ValueProvider，并将它们拆分如下：
- en: '[PRE27]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Converting part of a component to a separate component
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 将组件的一部分转换为单独的组件
- en: 'If a component grows too complex, it can make sense to split a part of it out.
    Let’s say we have a component with several different sections, and we’re adding
    complexity to one of them:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个组件变得过于复杂，将其拆分出来是有意义的。比如说我们有一个包含几个不同部分的组件，并且我们正在增加其中一个部分的复杂性：
- en: '[PRE28]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ This variable is only used inside the main section.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这个变量仅在主部分内部使用。
- en: ❷ The main section here is growing a bit large and can be refactored into a
    new component.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这里的主部分正在变得越来越大，可以重构为新的组件。
- en: 'At some point, you might feel that the main section of the application grows
    a bit large and it should become its own component. If you want to do so, you
    take the relevant JSX (and associated variables) of the component and move it
    to a new component:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，您可能会觉得应用程序的主要部分有点大，应该成为它自己的组件。如果您想这样做，您可以将组件的相关JSX（和相关变量）移动到一个新的组件中：
- en: '[PRE29]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ We created a new component (in a new file) with only part of the previous
    component.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们创建了一个新的组件（在新的文件中），它只包含之前组件的一部分。
- en: ❷ We can now safely replace the entire main section from before with our new
    component.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们现在可以安全地用我们的新组件替换之前的主部分。
- en: Both components are now much simpler, and it’s easier to understand their purpose.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个组件现在都简单得多，更容易理解它们的目的。
- en: The children property
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 子属性
- en: 'Sometimes you might create a new component, but you don’t want to make it too
    specific. You still want to be able to populate it with different content in different
    circumstances. Let’s say that you have an application with multiple identically
    styled sections, but the contents are different:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您可能会创建一个新的组件，但您不想让它过于具体。您仍然希望能够在不同情况下用不同的内容填充它。假设您有一个具有多个相同样式的部分的应用程序，但内容是不同的：
- en: '[PRE30]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ We have the same class on all the sections.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 所有部分都有相同的类。
- en: ❷ But the contents are different.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 但内容是不同的。
- en: 'Here, it can make sense to create a component for the sections that still allow
    you to pass in arbitrary children. You can do just that with the children property:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，为仍允许您传递任意子组件的部分创建一个组件是有意义的。您可以使用子属性做到这一点：
- en: '[PRE31]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ This is a new component with the generic section markup.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这是一个具有通用部分标记的新组件。
- en: ❷ Remember to render the children property where you want the children to appear.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 记得在您希望子组件出现的地方渲染子属性。
- en: ❸ We can now replace the sections with our new component, which makes the app
    look a lot neater without the repeated logic.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们现在可以用我们的新组件替换部分，这使得应用程序看起来更加整洁，没有重复的逻辑。
- en: 'Why do we mention that in this step? Well, this is often used for dedicated
    provider components, so you can do something like this:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们在这一步提到它？因为这在专用提供者组件中经常使用，所以您可以这样做：
- en: '[PRE32]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 11.5.3 Component hierarchy
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.3 组件层次结构
- en: You have a lot more choices to make in this last step, so we’re not going to
    try to influence you too much. However, figure 11.16 shows a high-level overview
    of how we might see the components laid out in the final application.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后一步，您有很多选择要做，所以我们不会过多地影响您。然而，图 11.16 显示了我们可能看到组件在最终应用程序中布局的高级概述。
- en: '![11-16](../Images/11-16.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![11-16](../Images/11-16.png)'
- en: Figure 11.16 A high-level overview of how the components could be laid out in
    the application in this final step
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.16 在此最终步骤中，组件如何在应用程序中布局的高级概述
- en: 11.5.4 What now?
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.4 接下来是什么？
- en: If you want to have a go at this yourself, and we really think you should, you
    can keep working on your application from the previous step. If you want to start
    from our application as completed after step 4, you can start with the rq11-context
    repository. When complete, you probably want to compare your solution to ours
    for educational purposes.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想自己尝试，我们真的认为您应该这样做，您可以从上一个步骤继续工作在您的应用程序。如果您想从步骤4完成后我们的应用程序开始，您可以从rq11-context存储库开始。完成后，您可能想为了教育目的比较您的解决方案和我们的解决方案。
- en: 'Repository: rq11-profile'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库：rq11-profile
- en: 'This example can be seen in repository rq11-profile. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例可在rq11-profile存储库中看到。您可以通过创建基于相关模板的新应用程序来使用该存储库：
- en: '[PRE33]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以去这个网站浏览代码，直接在浏览器中查看应用程序的运行情况，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq11-profile](https://rq2e.com/rq11-profile)'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq11-profile](https://rq2e.com/rq11-profile)'
- en: And that’s it. That’s the end of the project for now. But feel free to expand
    this to add more functionality and play around with just how powerful contexts
    are for data control. You can add a different login button that would log you
    in as an administrator, which might render even more menu items—or maybe a completely
    different menu.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。这就是目前项目的结束。但请随意扩展以添加更多功能，并探索上下文在数据控制方面的强大功能。您可以添加一个不同的登录按钮，这样就可以以管理员身份登录，这可能会显示更多的菜单项——或者可能是一个完全不同的菜单。
- en: 11.6 Final thoughts
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.6 最后的想法
- en: This first project had a lot of handholding, and we went through the steps very
    slowly with lots of rather detailed hints on how to complete them. In the next
    two projects, there will be less handholding and fewer verbose hints. But don’t
    hesitate to refer back to this project to see which steps you might want to go
    through to complete an exercise.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个项目有很多指导，我们非常缓慢地进行了步骤，并且提供了很多相当详细的提示，说明了如何完成它们。在接下来的两个项目中，会有更少的指导和更少的冗长提示。但不要犹豫，参考这个项目，看看你可能想要经历哪些步骤来完成练习。
- en: The final product in this project is a solid foundation for building a website
    with a dynamic menu. However, a lot of things are still missing to make this useful
    in a real website. These include proper hosting, server-side rendering, backend
    authentication, and much more, but those topics are beyond the scope of this book.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目的最终产品是构建具有动态菜单的网站的一个坚实的基础。然而，还有很多东西缺失，才能使这个项目在真实网站中变得有用。这包括适当的托管、服务器端渲染、后端身份验证等等，但这些主题超出了本书的范围。
- en: Summary
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this project, we learned the steps that you would go through in a real project
    when working with React on a regular basis.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个项目中，我们学习了在常规使用React时，在真实项目中会经历的步骤。
- en: Start the process with the desired result, and try to create the HTML that would
    render the desired output.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以期望的结果开始这个过程，并尝试创建能够渲染期望输出的HTML。
- en: From there, devise the component tree that would create the equivalent JSX.
    You can make it completely static and stateless in the first iteration.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从那里，设计出能够创建等效JSX的组件树。你可以在第一次迭代中将其完全设计为静态和无状态的。
- en: Then, slowly add more and more complexity until you end up where you want your
    application to be.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，逐渐增加更多的复杂性，直到你达到你希望应用程序所在的位置。
- en: Becoming more experienced as a React developer, you’ll gain the confidence to
    skip more steps in this process and perhaps jump directly to the last step because
    you’re already very familiar with how to best use contexts, lists of JSX objects,
    stateful variables, and all the other things required.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着作为React开发者的经验越来越丰富，你将获得信心跳过这个过程中的更多步骤，也许可以直接跳到最后一步，因为你已经非常熟悉如何最好地使用上下文、JSX对象列表、状态变量以及所有其他所需的东西。
