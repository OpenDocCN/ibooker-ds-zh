- en: '5 Nonlocal games: Implementing a multi-qubit simulator'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 éå±€åŸŸæ¸¸æˆï¼šå®ç°å¤šé‡å­æ¯”ç‰¹æ¨¡æ‹Ÿå™¨
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬ç« æ¶µç›–
- en: Programming a simulator for multiple qubits using the QuTiP Python package and
    tensor products
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä½¿ç”¨QuTiP PythonåŒ…å’Œå¼ é‡ç§¯ç¼–ç¨‹å¤šé‡å­æ¯”ç‰¹æ¨¡æ‹Ÿå™¨
- en: Recognizing the proof that quantum mechanics is consistent with our observations
    of the universe by simulating experimental results
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: é€šè¿‡æ¨¡æ‹Ÿå®éªŒç»“æœæ¥è¯†åˆ«é‡å­åŠ›å­¦ä¸æˆ‘ä»¬å¯¹å®‡å®™è§‚å¯Ÿçš„ä¸€è‡´æ€§è¯æ˜
- en: In the previous chapter, we learned about nonlocal games and how we can use
    them to validate our understanding of quantum mechanics. We also learned how to
    represent states of multiple qubits and what *entanglement* is.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸Šä¸€ç« ä¸­ï¼Œæˆ‘ä»¬å­¦ä¹ äº†éå±€åŸŸæ¸¸æˆä»¥åŠæˆ‘ä»¬å¦‚ä½•åˆ©ç”¨å®ƒä»¬æ¥éªŒè¯æˆ‘ä»¬å¯¹é‡å­åŠ›å­¦çš„ç†è§£ã€‚æˆ‘ä»¬è¿˜å­¦ä¹ äº†å¦‚ä½•è¡¨ç¤ºå¤šä¸ªé‡å­æ¯”ç‰¹çš„çŠ¶æ€ä»¥åŠä»€ä¹ˆæ˜¯*çº ç¼ *ã€‚
- en: 'In this chapter, we will dive into a new Python package called QuTiP that will
    allow us to program quantum systems faster and has some cool built-in features
    for simulating quantum mechanics. Then weâ€™ll learn how to use QuTiP to program
    a simulator for multiple qubits and see how that changes (or doesnâ€™t!) the three
    main tasks for our qubits: state preparations, operations, and measurement. This
    will let us finish the implementation of the CHSH game from chapter 4!'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†æ·±å…¥ç ”ç©¶ä¸€ä¸ªæ–°çš„PythonåŒ…QuTiPï¼Œå®ƒå°†ä½¿æˆ‘ä»¬èƒ½å¤Ÿæ›´å¿«åœ°ç¼–ç¨‹é‡å­ç³»ç»Ÿï¼Œå¹¶ä¸ºæ¨¡æ‹Ÿé‡å­åŠ›å­¦æä¾›ä¸€äº›å†…ç½®çš„é…·ç‰¹æ€§ã€‚ç„¶åæˆ‘ä»¬å°†å­¦ä¹ å¦‚ä½•ä½¿ç”¨QuTiPæ¥ç¼–ç¨‹å¤šé‡å­æ¯”ç‰¹æ¨¡æ‹Ÿå™¨ï¼Œå¹¶çœ‹çœ‹è¿™å¦‚ä½•ï¼ˆæˆ–æ²¡æœ‰ï¼ï¼‰æ”¹å˜æˆ‘ä»¬é‡å­æ¯”ç‰¹çš„ä¸‰ä¸ªä¸»è¦ä»»åŠ¡ï¼šçŠ¶æ€åˆ¶å¤‡ã€æ“ä½œå’Œæµ‹é‡ã€‚è¿™å°†ä½¿æˆ‘ä»¬èƒ½å¤Ÿå®Œæˆç¬¬4ç« ä¸­CHSHæ¸¸æˆçš„å®ç°ï¼
- en: 5.1 Quantum objects in QuTiP
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 QuTiPä¸­çš„é‡å­å¯¹è±¡
- en: 'QuTiP (Quantum Toolbox in Python, [www.qutip.org](http://www.qutip.org)) is
    a particularly useful package that provides built-in support for representing
    states and measurements as bras and kets, respectively, and for building matrices
    to represent quantum operations. Just as `np.array` is at the core of NumPy, all
    of our use of QuTiP will center around the `Qobj` class (short for *quantum object*).
    This class encapsulates vectors and matrices, providing additional metadata and
    useful methods that will make it easier for us to improve our simulator. Figure
    5.1 shows an example of creating a `Qobj` from a vector, where it keeps track
    of some metadata:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: QuTiPï¼ˆPythonä¸­çš„é‡å­å·¥å…·ç®±ï¼Œ[www.qutip.org](http://www.qutip.org)ï¼‰æ˜¯ä¸€ä¸ªç‰¹åˆ«æœ‰ç”¨çš„åŒ…ï¼Œå®ƒæä¾›äº†å†…ç½®æ”¯æŒï¼Œç”¨äºå°†çŠ¶æ€å’Œæµ‹é‡åˆ†åˆ«è¡¨ç¤ºä¸ºbraå’Œketï¼Œå¹¶æ„å»ºçŸ©é˜µæ¥è¡¨ç¤ºé‡å­æ“ä½œã€‚æ­£å¦‚`np.array`æ˜¯NumPyçš„æ ¸å¿ƒä¸€æ ·ï¼Œæˆ‘ä»¬æ‰€æœ‰çš„QuTiPä½¿ç”¨éƒ½å°†å›´ç»•`Qobj`ç±»ï¼ˆç®€ç§°*é‡å­å¯¹è±¡*ï¼‰å±•å¼€ã€‚è¿™ä¸ªç±»å°è£…äº†çŸ¢é‡å’ŒçŸ©é˜µï¼Œæä¾›äº†é¢å¤–çš„å…ƒæ•°æ®å’Œæœ‰ç”¨çš„æ–¹æ³•ï¼Œè¿™å°†ä½¿æˆ‘ä»¬çš„æ¨¡æ‹Ÿå™¨æ›´å®¹æ˜“æ”¹è¿›ã€‚å›¾5.1å±•ç¤ºäº†ä»çŸ¢é‡åˆ›å»º`Qobj`çš„ç¤ºä¾‹ï¼Œå…¶ä¸­å®ƒè·Ÿè¸ªäº†ä¸€äº›å…ƒæ•°æ®ï¼š
- en: '`data` holds the array representing the `Qobj`.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`ä¿å­˜è¡¨ç¤º`Qobj`çš„æ•°ç»„ã€‚'
- en: '`dims` is the size of our quantum register. We can think of it as a way of
    keeping track of how we record the qubits we are dealing with.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dims`æ˜¯æˆ‘ä»¬é‡å­å¯„å­˜å™¨çš„å¤§å°ã€‚æˆ‘ä»¬å¯ä»¥å°†å…¶è§†ä¸ºè·Ÿè¸ªæˆ‘ä»¬å¤„ç†é‡å­æ¯”ç‰¹çš„æ–¹å¼ã€‚'
- en: '`shape` keeps the dimension of the original object we used to make the `Qobj`.
    It is similar to the `np.shape` attribute.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shape`ä¿å­˜äº†æˆ‘ä»¬ç”¨æ¥åˆ›å»º`Qobj`çš„åŸå¯¹è±¡çš„ç»´åº¦ã€‚å®ƒç±»ä¼¼äº`np.shape`å±æ€§ã€‚'
- en: '`type` is what the `Qobj` represents (a state = `ket`, a measurement = `bra`,
    or an operator = `oper`).'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`æ˜¯`Qobj`æ‰€è¡¨ç¤ºçš„å†…å®¹ï¼ˆçŠ¶æ€= `ket`ï¼Œæµ‹é‡= `bra`ï¼Œæˆ–ç®—å­= `oper`ï¼‰ã€‚'
- en: '![](../Images/5-1.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![å›¾5-1](../Images/5-1.png)'
- en: Figure 5.1 Properties of the `Qobj` class in the QuTiP Python package. Here
    we can see things like the `type` and `dims` properties that help both us and
    the package keep track of metadata about our quantum objects.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾5.1 QuTiP PythonåŒ…ä¸­`Qobj`ç±»çš„å±æ€§ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°è¯¸å¦‚`type`å’Œ`dims`å±æ€§ï¼Œè¿™äº›å±æ€§å¸®åŠ©æˆ‘ä»¬å’ŒåŒ…è·Ÿè¸ªå…³äºæˆ‘ä»¬çš„é‡å­å¯¹è±¡çš„å…ƒæ•°æ®ã€‚
- en: Letâ€™s try importing QuTiP and asking it for the Hadamard operation; see listing
    5.1.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å°è¯•å¯¼å…¥QuTiPå¹¶è¯·æ±‚å®ƒæ‰§è¡ŒHadamardè¿ç®—ï¼›è¯·å‚è§åˆ—è¡¨5.1ã€‚
- en: Note Make sure as you run things that you are in the right `conda env`; for
    more information, see appendix A.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼šç¡®ä¿ä½ åœ¨æ­£ç¡®çš„`conda env`ä¸­è¿è¡Œç¨‹åºï¼›æ›´å¤šä¿¡æ¯è¯·å‚é˜…é™„å½•Aã€‚
- en: Listing 5.1 QuTiPâ€™s representation of the Hadamard operation
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨5.1 QuTiPå¯¹Hadamardè¿ç®—çš„è¡¨ç¤º
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that QuTiP prints out some diagnostic information about each `Qobj` instance
    along with the data itself. Here, for instance, `type = oper` tells us that `H`
    represents an operator (a more formal term for the matrices weâ€™ve seen so far)
    along with some information about the dimensions of the operator represented by
    `H`. Finally, the `isherm = True` output tells us that `H` is an example of a
    special kind of matrix called a *Hermitian operator*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼ŒQuTiP ä¼šæ‰“å°å‡ºæœ‰å…³æ¯ä¸ª `Qobj` å®ä¾‹çš„è¯Šæ–­ä¿¡æ¯ï¼ŒåŒ…æ‹¬æ•°æ®æœ¬èº«ã€‚ä¾‹å¦‚ï¼Œè¿™é‡Œçš„ `type = oper` å‘Šè¯‰æˆ‘ä»¬ `H` ä»£è¡¨ä¸€ä¸ªç®—å­ï¼ˆæˆ‘ä»¬ä¹‹å‰çœ‹åˆ°çš„çŸ©é˜µçš„æ›´æ­£å¼çš„æœ¯è¯­ï¼‰ä»¥åŠ
    `H` æ‰€è¡¨ç¤ºç®—å­çš„ç»´åº¦ä¿¡æ¯ã€‚æœ€åï¼Œ`isherm = True` çš„è¾“å‡ºå‘Šè¯‰æˆ‘ä»¬ `H` æ˜¯ä¸€ç§ç‰¹æ®ŠçŸ©é˜µçš„ä¾‹å­ï¼Œç§°ä¸º *å„ç±³ç®—å­*ã€‚
- en: We can make new instances of `Qobj` in much the same way we made NumPy arrays,
    by passing in Python lists to the `Qobj` initializer.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥é€šè¿‡ä¼ é€’ Python åˆ—è¡¨åˆ° `Qobj` åˆå§‹åŒ–å™¨ä¸­ï¼Œä»¥ä¸åˆ›å»º NumPy æ•°ç»„ç›¸åŒçš„æ–¹å¼åˆ›å»ºæ–°çš„ `Qobj` å®ä¾‹ã€‚
- en: Listing 5.2 Making a `Qobj` from a vector representing a qubit state
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ 5.2 ä»è¡¨ç¤ºé‡å­æ¯”ç‰¹çŠ¶æ€çš„å‘é‡åˆ›å»º `Qobj`
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: â¶ One key difference between creating Qobj instances and arrays is that when
    we create Qobj instances, we always need two levels of lists. The outer list is
    a list of rows in the new Qobj instance.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ åˆ›å»º Qobj å®ä¾‹å’Œæ•°ç»„ä¹‹é—´çš„ä¸€ä¸ªå…³é”®åŒºåˆ«æ˜¯ï¼Œå½“æˆ‘ä»¬åˆ›å»º Qobj å®ä¾‹æ—¶ï¼Œæˆ‘ä»¬æ€»æ˜¯éœ€è¦ä¸¤å±‚åˆ—è¡¨ã€‚å¤–å±‚åˆ—è¡¨æ˜¯æ–°çš„ Qobj å®ä¾‹ä¸­çš„è¡Œåˆ—è¡¨ã€‚
- en: â· QuTiP prints some metadata about the size and shape of the new quantum object,
    along with the data contained in the new object. In this case, the data for the
    new Qobj has two rows, each with one column. We identify that as the vector or
    ket that we use to write the |0ã€‰ state.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: â· QuTiP æ‰“å°å‡ºæœ‰å…³æ–°é‡å­å¯¹è±¡çš„å¤§å°å’Œå½¢çŠ¶çš„å…ƒæ•°æ®ï¼Œä»¥åŠæ–°å¯¹è±¡ä¸­åŒ…å«çš„æ•°æ®ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ–° Qobj çš„æ•°æ®æœ‰ä¸¤è¡Œï¼Œæ¯è¡Œæœ‰ä¸€åˆ—ã€‚æˆ‘ä»¬å°†å…¶è¯†åˆ«ä¸ºç”¨äºç¼–å†™
    |0ã€‰ çŠ¶æ€çš„å‘é‡æˆ– ketsã€‚
- en: 'Exercise 5.1: Creating the Qobj for other states'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ç»ƒä¹  5.1ï¼šåˆ›å»ºå…¶ä»–çŠ¶æ€çš„ Qobj
- en: How would you create a `Qobj` to represent the |1ã€‰ state? How about the |+ã€‰
    or |âˆ’ã€‰ state? If you need to, check back to section 2.3.5 for what vectors represent
    those states.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ ä¼šå¦‚ä½•åˆ›å»ºä¸€ä¸ªè¡¨ç¤º |1ã€‰ çŠ¶æ€çš„ `Qobj`ï¼Ÿå¯¹äº |+ã€‰ æˆ– |âˆ’ã€‰ çŠ¶æ€å‘¢ï¼Ÿå¦‚æœä½ éœ€è¦ï¼Œå¯ä»¥å›æŸ¥ç¬¬ 2.3.5 èŠ‚ï¼Œäº†è§£è¿™äº›çŠ¶æ€æ‰€ä»£è¡¨çš„å‘é‡ã€‚
- en: Exercise solutions
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ç»ƒä¹ è§£ç­”
- en: 'All solutions for exercises in this book can be found in the companion code
    repo: [https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp).
    Just go to the folder for the chapter you are in, and open the Jupyter notebook
    with the name that mentions exercise solutions.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬ä¹¦æ‰€æœ‰ç»ƒä¹ çš„è§£ç­”éƒ½å¯ä»¥åœ¨é…å¥—ä»£ç ä»“åº“ä¸­æ‰¾åˆ°ï¼š[https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp)ã€‚åªéœ€è¿›å…¥ä½ æ‰€åœ¨ç« èŠ‚çš„æ–‡ä»¶å¤¹ï¼Œå¹¶æ‰“å¼€åä¸ºç»ƒä¹ è§£ç­”çš„
    Jupyter ç¬”è®°æœ¬ã€‚
- en: 'QuTiP really helps by providing a lot of nice shorthand for the kinds of objects
    we need to work with in quantum computing. For instance, we could have also made
    `ket0` in the previous sample by using the QuTiP `basis` function; see listing
    5.3\. The `basis` function takes two arguments. The first tells QuTiP that we
    want a qubit state: `2` for a single qubit because the length of a vector that
    is needed to represent it. The second argument tells QuTiP which basis state we
    want.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: QuTiP é€šè¿‡æä¾›å¤§é‡ç®€å†™æ¥å¸®åŠ©æˆ‘ä»¬å¤„ç†é‡å­è®¡ç®—ä¸­éœ€è¦ç”¨åˆ°çš„å¯¹è±¡ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥é€šè¿‡ä½¿ç”¨ QuTiP çš„ `basis` å‡½æ•°æ¥åˆ›å»ºå‰ä¸€ä¸ªç¤ºä¾‹ä¸­çš„
    `ket0`ï¼›å‚è§åˆ—è¡¨ 5.3ã€‚`basis` å‡½æ•°æ¥å—ä¸¤ä¸ªå‚æ•°ã€‚ç¬¬ä¸€ä¸ªå‚æ•°å‘Šè¯‰ QuTiP æˆ‘ä»¬æƒ³è¦ä¸€ä¸ªé‡å­æ¯”ç‰¹çŠ¶æ€ï¼šå¯¹äºå•ä¸ªé‡å­æ¯”ç‰¹æ˜¯ `2`ï¼Œå› ä¸ºè¡¨ç¤ºå®ƒæ‰€éœ€çš„å‘é‡çš„é•¿åº¦ã€‚ç¬¬äºŒä¸ªå‚æ•°å‘Šè¯‰
    QuTiP æˆ‘ä»¬æƒ³è¦å“ªä¸ªåŸºæ€ã€‚
- en: Listing 5.3 Using QuTiP to easily create |0ã€‰ and |1ã€‰
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ 5.3 ä½¿ç”¨ QuTiP ç®€å•åˆ›å»º |0ã€‰ å’Œ |1ã€‰
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: â¶ Passes a 2 as the first argument to indicate we want a single qubit, and passes
    a 0 for the second argument because we want |0ã€‰
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ å°† `2` ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°ä¼ é€’ï¼Œè¡¨ç¤ºæˆ‘ä»¬æƒ³è¦ä¸€ä¸ªå•ä¸ªé‡å­æ¯”ç‰¹ï¼Œå¹¶å°† `0` ä½œä¸ºç¬¬äºŒä¸ªå‚æ•°ä¼ é€’ï¼Œå› ä¸ºæˆ‘ä»¬æƒ³è¦ |0ã€‰
- en: â· Note that we get exactly the same output here as in the previous example.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: â· æ³¨æ„ï¼Œè¿™é‡Œçš„è¾“å‡ºä¸ä¸Šä¸€ä¸ªç¤ºä¾‹å®Œå…¨ç›¸åŒã€‚
- en: â¸ We can also construct a quantum object for |1ã€‰ by passing a 1 instead of a
    0.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: â¸ æˆ‘ä»¬ä¹Ÿå¯ä»¥é€šè¿‡ä¼ é€’ 1 è€Œä¸æ˜¯ 0 æ¥æ„é€ è¡¨ç¤º |1ã€‰ çš„é‡å­å¯¹è±¡ã€‚
- en: '...basis?'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '...åŸºï¼Ÿ'
- en: As we have seen before, the states |0ã€‰ and |1ã€‰ make up the *computational basis*
    for a single qubit. The QuTiP function `basis` gets its name from this definition,
    as it makes quantum objects to represent computational basis states.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚æˆ‘ä»¬ä¹‹å‰æ‰€çœ‹åˆ°çš„ï¼ŒçŠ¶æ€ |0ã€‰ å’Œ |1ã€‰ æ„æˆäº†ä¸€ä¸ªå•é‡å­æ¯”ç‰¹çš„ *è®¡ç®—åŸº*ã€‚QuTiP å‡½æ•° `basis` çš„åå­—æ¥æºäºè¿™ä¸ªå®šä¹‰ï¼Œå› ä¸ºå®ƒä½¿å¾—é‡å­å¯¹è±¡å¯ä»¥è¡¨ç¤ºè®¡ç®—åŸºçŠ¶æ€ã€‚
- en: There are more things in heaven and earth than our qubits
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: å¤©åœ°ä¹‹é—´è¿˜æœ‰æ¯”æˆ‘ä»¬çš„é‡å­æ¯”ç‰¹æ›´å¤šçš„äº‹æƒ…ã€‚
- en: It may seem a little odd that we had to tell QuTiP that we wanted a qubit. After
    all, what else *could* we want? As it turns out, quite a bit (yes, pun very much
    intended)!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯èƒ½è§‰å¾—å¿…é¡»å‘Šè¯‰ QuTiP æˆ‘ä»¬æƒ³è¦ä¸€ä¸ªé‡å­æ¯”ç‰¹æœ‰ç‚¹å¥‡æ€ªã€‚æ¯•ç«Ÿï¼Œæˆ‘ä»¬è¿˜èƒ½æƒ³è¦ä»€ä¹ˆï¼Ÿå®é™…ä¸Šï¼Œç›¸å½“å¤šï¼ˆæ˜¯çš„ï¼ŒåŒå…³è¯­éå¸¸æœ‰æ„ï¼‰ï¼
- en: There are many other ways to represent classical information than bits, such
    as *trits*, which have three possible values. However, we tend not to see classical
    information represented using anything other than bits when we write programs,
    as itâ€™s very useful to pick a convention and stick with it. Things other than
    bits still have their uses, though, in specialized domains such as telecommunications
    systems.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: é™¤äº†æ¯”ç‰¹ä¹‹å¤–ï¼Œè¿˜æœ‰è®¸å¤šå…¶ä»–æ–¹å¼å¯ä»¥è¡¨ç¤ºç»å…¸ä¿¡æ¯ï¼Œä¾‹å¦‚ *ä¸‰è¿›åˆ¶*ï¼Œå®ƒæœ‰ä¸‰ä¸ªå¯èƒ½å€¼ã€‚ç„¶è€Œï¼Œå½“æˆ‘ä»¬ç¼–å†™ç¨‹åºæ—¶ï¼Œæˆ‘ä»¬é€šå¸¸ä¸ä¼šçœ‹åˆ°ä½¿ç”¨é™¤æ¯”ç‰¹ä¹‹å¤–çš„å…¶ä»–æ–¹å¼æ¥è¡¨ç¤ºç»å…¸ä¿¡æ¯ï¼Œå› ä¸ºé€‰æ‹©ä¸€ä¸ªçº¦å®šå¹¶åšæŒä¸‹å»éå¸¸æœ‰ç”¨ã€‚å°½ç®¡å¦‚æ­¤ï¼Œåœ¨ç”µä¿¡ç³»ç»Ÿç­‰ç‰¹å®šé¢†åŸŸï¼Œé™¤äº†æ¯”ç‰¹ä¹‹å¤–çš„äº‹ç‰©ä»ç„¶æœ‰å…¶ç”¨é€”ã€‚
- en: 'In the exact same fashion, quantum systems can have any number of different
    states: we can have qutrits, qu4its, qu5its, qu17its, and so forth, collectively
    known as qu *d*its. While representing quantum information using qu *d*its other
    than qubits can be useful in some cases and can have some very interesting mathematical
    properties, qubits give us all we need to dive into quantum programming.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥å®Œå…¨ç›¸åŒçš„æ–¹å¼ï¼Œé‡å­ç³»ç»Ÿå¯ä»¥å…·æœ‰ä»»ä½•æ•°é‡çš„ä¸åŒçŠ¶æ€ï¼šæˆ‘ä»¬å¯ä»¥æœ‰é‡å­ä¸‰æ¯”ç‰¹ã€é‡å­å››æ¯”ç‰¹ã€é‡å­äº”æ¯”ç‰¹ã€é‡å­åä¸ƒæ¯”ç‰¹ç­‰ç­‰ï¼Œç»Ÿç§°ä¸ºé‡å­ *d*itsã€‚è™½ç„¶åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œä½¿ç”¨é‡å­
    *d*its è€Œä¸æ˜¯é‡å­æ¯”ç‰¹æ¥è¡¨ç¤ºé‡å­ä¿¡æ¯å¯èƒ½å¾ˆæœ‰ç”¨ï¼Œå¹¶ä¸”å¯ä»¥å…·æœ‰ä¸€äº›éå¸¸æœ‰è¶£çš„æ•°å­¦å±æ€§ï¼Œä½†é‡å­æ¯”ç‰¹ä¸ºæˆ‘ä»¬æä¾›äº†è¿›å…¥é‡å­ç¼–ç¨‹æ‰€éœ€çš„ä¸€åˆ‡ã€‚
- en: 'Exercise 5.2: Using qt.basis for multiple qubits'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ç»ƒä¹  5.2ï¼šä½¿ç”¨ qt.basis å¯¹å¤šä¸ªé‡å­æ¯”ç‰¹è¿›è¡Œæ“ä½œ
- en: How could you use the `qt.basis` function to create a two-qubit register in
    the |10ã€‰ state? How could you create the |001ã€‰ state? Remember that the second
    argument to `qt.basis` is an index to the computational basis states we saw earlier.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¦‚ä½•ä½¿ç”¨ `qt.basis` å‡½æ•°åˆ›å»ºä¸€ä¸ªå¤„äº |10ã€‰ çŠ¶æ€çš„ä¸¤ä¸ªé‡å­æ¯”ç‰¹å¯„å­˜å™¨ï¼Ÿå¦‚ä½•åˆ›å»º |001ã€‰ çŠ¶æ€ï¼Ÿè¯·è®°ä½ï¼Œ`qt.basis` çš„ç¬¬äºŒä¸ªå‚æ•°æ˜¯æˆ‘ä»¬ä¹‹å‰çœ‹åˆ°çš„è®¡ç®—åŸºæ€çš„ç´¢å¼•ã€‚
- en: QuTiP also provides a number of different functions for making quantum objects
    to represent unitary matrices. For instance, we can make a quantum object for
    the *X* matrix by using the `sigmax` function.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: QuTiP è¿˜æä¾›äº†ä¸€äº›ä¸åŒçš„å‡½æ•°æ¥åˆ›å»ºé‡å­å¯¹è±¡ä»¥è¡¨ç¤ºå¹ºæ­£çŸ©é˜µã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ä½¿ç”¨ `sigmax` å‡½æ•°æ¥åˆ›å»º *X* çŸ©é˜µçš„é‡å­å¯¹è±¡ã€‚
- en: Listing 5.4 Using QuTiP to create an object for the *X* matrix
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ 5.4 ä½¿ç”¨ QuTiP åˆ›å»º *X* çŸ©é˜µçš„å¯¹è±¡
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we saw in chapter 2, the matrix for `sigmax` represents a rotation of 180Â°
    (figure 5.2).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚æˆ‘ä»¬åœ¨ç¬¬ 2 ç« ä¸­çœ‹åˆ°çš„ï¼Œ`sigmax` çš„çŸ©é˜µè¡¨ç¤º 180Â° çš„æ—‹è½¬ï¼ˆå›¾ 5.2ï¼‰ã€‚
- en: '![](../Images/5-2.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![å›¾ 5-2](../Images/5-2.png)'
- en: Figure 5.2 A visualization of the quantum equivalent of a NOT operation operating
    on a qubit in the |0ã€‰ state, leaving the qubit in the |1ã€‰ state
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ 5.2 åœ¨ |0ã€‰ çŠ¶æ€ä¸‹å¯¹é‡å­æ¯”ç‰¹æ‰§è¡Œ NOT æ“ä½œçš„é‡å­ç­‰æ•ˆå¯è§†åŒ–ï¼Œä½¿é‡å­æ¯”ç‰¹å¤„äº |1ã€‰ çŠ¶æ€
- en: QuTiP also provides a function `ry` to represent rotating by whatever angle
    we want instead of 180Â° like the `x` operation. We saw the operation that `ry`
    represents in chapter 2 when we considered rotating |0ã€‰ by an arbitrary angle
    *Î¸*. See figure 5.3 for a refresher on the operation we now know as `ry`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: QuTiP è¿˜æä¾›äº†ä¸€ä¸ªåä¸º `ry` çš„å‡½æ•°æ¥è¡¨ç¤ºæ—‹è½¬ä»»æ„è§’åº¦ï¼Œè€Œä¸æ˜¯åƒ `x` æ“ä½œé‚£æ ·æ—‹è½¬ 180Â°ã€‚æˆ‘ä»¬åœ¨ç¬¬ 2 ç« ä¸­è€ƒè™‘æ—‹è½¬ |0ã€‰ çš„ä»»æ„è§’åº¦
    *Î¸* æ—¶çœ‹åˆ°äº† `ry` æ‰€è¡¨ç¤ºçš„æ“ä½œã€‚å‚è§å›¾ 5.3 ä»¥å¤ä¹ æˆ‘ä»¬ç°åœ¨æ‰€çŸ¥é“çš„ `ry` æ“ä½œã€‚
- en: '![](../Images/5-3.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![å›¾ 5-3](../Images/5-3.png)'
- en: Figure 5.3 A visualization of QuTiP function `ry`, which corresponds to a variable
    rotation of *Î¸* around the *Y*-axis of our qubit (which points directly out of
    the page)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ 5.3 QuTiP å‡½æ•° `ry` çš„å¯è§†åŒ–ï¼Œå®ƒå¯¹åº”äºå›´ç»•é‡å­æ¯”ç‰¹çš„ *Y*-è½´ï¼ˆæŒ‡å‘é¡µé¢ç›´æ¥å¤–ä¾§ï¼‰çš„å˜é‡æ—‹è½¬ *Î¸*
- en: Now that we have a few more single-qubit operations down, how can we easily
    simulate multi-qubit operations in QuTiP? We can use QuTiPâ€™s `tensor` function
    to quickly get up and running with tensor products to make our multi-qubit registers
    and operations, as we show in listing 5.5.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å·²ç»æŒæ¡äº†ä¸€äº›å•é‡å­æ¯”ç‰¹æ“ä½œï¼Œæˆ‘ä»¬å¦‚ä½•åœ¨ QuTiP ä¸­è½»æ¾æ¨¡æ‹Ÿå¤šé‡å­æ¯”ç‰¹æ“ä½œï¼Ÿæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ QuTiP çš„ `tensor` å‡½æ•°å¿«é€Ÿä½¿ç”¨å¼ é‡ç§¯æ¥åˆ›å»ºæˆ‘ä»¬çš„å¤šé‡å­æ¯”ç‰¹å¯„å­˜å™¨å’Œæ“ä½œï¼Œæ­£å¦‚æˆ‘ä»¬åœ¨åˆ—è¡¨
    5.5 ä¸­æ‰€å±•ç¤ºçš„ã€‚
- en: Note Since identity matrices are often written using the letter *I*, many scientific
    computing packages use the name `eye` as a bit of a pun to refer to the identity
    matrix.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼šç”±äºå•ä½çŸ©é˜µé€šå¸¸ç”¨å­—æ¯ *I* è¡¨ç¤ºï¼Œè®¸å¤šç§‘å­¦è®¡ç®—åŒ…ä½¿ç”¨ `eye` è¿™ä¸ªåå­—ä½œä¸ºåŒå…³è¯­æ¥æŒ‡ä»£å•ä½çŸ©é˜µã€‚
- en: Listing 5.5 Tensor products in QuTiP
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ 5.5 QuTiP ä¸­çš„å¼ é‡ç§¯
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: â¶ Sets psi to represent |*Î¨*ã€‰ = |0ã€‰
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ å°† psi è®¾ç½®ä¸ºè¡¨ç¤º |*Î¨*ã€‰ = |0ã€‰
- en: â· Sets phi to represent |*Ï•*ã€‰ = |1ã€‰
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: â· å°† phi è®¾ç½®ä¸ºè¡¨ç¤º |*Ï•*ã€‰ = |1ã€‰
- en: â¸ After calling tensor, QuTiP tells us the amplitudes for each classical label
    in |*Î¨*ã€‰ âŠ— |*Ï•*ã€‰ = |0ã€‰ âŠ— |1ã€‰ = |01ã€‰, using the same order as listing 4.3.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: â¸ åœ¨è°ƒç”¨å¼ é‡ç§¯ä¹‹åï¼ŒQuTiPå‘Šè¯‰æˆ‘ä»¬|*Î¨*ã€‰ âŠ— |*Ï•*ã€‰ = |0ã€‰ âŠ— |1ã€‰ = |01ã€‰ä¸­æ¯ä¸ªç»å…¸æ ‡ç­¾çš„æŒ¯å¹…ï¼Œä½¿ç”¨ä¸åˆ—è¡¨4.3ç›¸åŒçš„é¡ºåºã€‚
- en: â¹ Sets HÂ to represent the Hadamard operation discussed earlier
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: â¹ å°†Hè®¾ç½®ä¸ºè¡¨ç¤ºä¹‹å‰è®¨è®ºè¿‡çš„Hadamardç®—ç¬¦
- en: âº We can use the qeye function provided by QuTiP to get a copy of a Qobj instance
    representing the identity matrix that we first saw in listing 4.8.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: âº æˆ‘ä»¬å¯ä»¥ä½¿ç”¨QuTiPæä¾›çš„qeyeå‡½æ•°æ¥è·å–ä¸€ä¸ªè¡¨ç¤ºå•ä½çŸ©é˜µçš„Qobjå®ä¾‹çš„å‰¯æœ¬ï¼Œè¿™æ˜¯æˆ‘ä»¬ç¬¬ä¸€æ¬¡åœ¨åˆ—è¡¨4.8ä¸­çœ‹åˆ°çš„ã€‚
- en: â» The unitary matrices representing quantum operations combine using tensor
    products in the same way as states and measurements.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: â» è¡¨ç¤ºé‡å­æ“ä½œçš„å¹ºæ­£çŸ©é˜µé€šè¿‡å¼ é‡ç§¯ä»¥ä¸çŠ¶æ€å’Œæµ‹é‡ç›¸åŒçš„æ–¹å¼ç»„åˆã€‚
- en: 'We can use a common math trick to prove how applying tensor products of states
    and operations works. Say we want to prove this statement:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ªå¸¸è§çš„æ•°å­¦æŠ€å·§æ¥è¯æ˜åº”ç”¨çŠ¶æ€å’Œæ“ä½œçš„å¼ é‡ç§¯æ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚æ¯”å¦‚è¯´æˆ‘ä»¬æƒ³è¦è¯æ˜è¿™ä¸ªé™ˆè¿°ï¼š
- en: If we apply a unitary to a state and then take the tensor product, we get the
    same answer as if we applied the tensor product and then the unitary.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬å¯¹ä¸€ä¸ªçŠ¶æ€åº”ç”¨ä¸€ä¸ªå¹ºæ­£ç®—ç¬¦ï¼Œç„¶åå–å¼ é‡ç§¯ï¼Œæˆ‘ä»¬å°†å¾—åˆ°ä¸åº”ç”¨å¼ é‡ç§¯ç„¶åå¹ºæ­£ç®—ç¬¦ç›¸åŒçš„ç­”æ¡ˆã€‚
- en: In math, we would say that for any unitary operators *U* and *V* and for any
    states |*Î¨*ã€‰ and |*Ï•*ã€‰, (*U*|*Î¨*ã€‰) âŠ— (*V*|*Ï•*ã€‰) = (*U* âŠ— *V*) (|*Î¨*ã€‰ âŠ— |*Ï•*ã€‰).
    The math trick we can use is to take the left side and subtract from it the right.
    We should end up with 0\. We give this a try in the following listing.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ•°å­¦ä¸Šï¼Œæˆ‘ä»¬ä¼šè¯´å¯¹äºä»»ä½•å¹ºæ­£ç®—ç¬¦*U*å’Œ*V*ä»¥åŠä»»ä½•çŠ¶æ€|*Î¨*ã€‰å’Œ|*Ï•*ã€‰ï¼Œ(*U*|*Î¨*ã€‰) âŠ— (*V*|*Ï•*ã€‰) = (*U* âŠ— *V*)
    (|*Î¨*ã€‰ âŠ— |*Ï•*ã€‰)ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨çš„æ•°å­¦æŠ€å·§æ˜¯ä»å·¦ä¾§å‡å»å³ä¾§ã€‚æˆ‘ä»¬åº”è¯¥å¾—åˆ°0ã€‚æˆ‘ä»¬å°†åœ¨ä»¥ä¸‹åˆ—è¡¨ä¸­å°è¯•è¿™æ ·åšã€‚
- en: Listing 5.6 Verifying the tensor product in QuTiP
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨5.6 åœ¨QuTiPä¸­éªŒè¯å¼ é‡ç§¯
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'â¶ The right side of the statement we are trying to prove, where we use *H*
    and *I* as *U* and *V*: (*U* âŠ— *V*) (|*Î¨*ã€‰ âŠ— |*Ï•*ã€‰).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ æˆ‘ä»¬è¯•å›¾è¯æ˜çš„è¯­å¥çš„å³ä¾§ï¼Œå…¶ä¸­æˆ‘ä»¬ä½¿ç”¨*H*å’Œ*I*ä½œä¸º*U*å’Œ*V*ï¼š(*U* âŠ— *V*) (|*Î¨*ã€‰ âŠ— |*Ï•*ã€‰)ã€‚
- en: 'â· The left side of the statement we are trying to prove, where we use *H* and
    *I* as *U* and *V*: (*U*|*Î¨*ã€‰) âŠ— (*V*|*Ï•*ã€‰).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: â· æˆ‘ä»¬è¯•å›¾è¯æ˜çš„è¯­å¥çš„å·¦ä¾§ï¼Œå…¶ä¸­æˆ‘ä»¬ä½¿ç”¨*H*å’Œ*I*ä½œä¸º*U*å’Œ*V*ï¼š(*U*|*Î¨*ã€‰) âŠ— (*V*|*Ï•*ã€‰)ã€‚
- en: â¸ Yay! The two sides of the equation are equal if their difference is 0.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: â¸ å“ˆå“ˆï¼å¦‚æœå®ƒä»¬çš„å·®ä¸º0ï¼Œåˆ™ç­‰å¼çš„ä¸¤è¾¹æ˜¯ç›¸ç­‰çš„ã€‚
- en: Note For a list of all the built-in states and operations in QuTiP, see [http://qutip.org/docs/latest/guide/guide-basics.html#states-and-operators](http://qutip.org/docs/latest/guide/guide-basics.html#states-and-operators).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼šæœ‰å…³QuTiPä¸­æ‰€æœ‰å†…ç½®çŠ¶æ€å’Œæ“ä½œçš„åˆ—è¡¨ï¼Œè¯·å‚é˜…[http://qutip.org/docs/latest/guide/guide-basics.html#states-and-operators](http://qutip.org/docs/latest/guide/guide-basics.html#states-and-operators)ã€‚
- en: 5.1.1 Upgrading the simulator
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.1 å‡çº§æ¨¡æ‹Ÿå™¨
- en: The goal now is to use QuTiP to upgrade our single-qubit simulator to a multi-qubit
    simulator with some of the features of QuTiP. We will do this by adding a few
    features to our single-qubit simulator from chapters 2 and 3.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å‰çš„ç›®æ ‡æ˜¯ä½¿ç”¨QuTiPå°†æˆ‘ä»¬çš„å•é‡å­ä½æ¨¡æ‹Ÿå™¨å‡çº§ä¸ºå…·æœ‰QuTiPä¸€äº›ç‰¹æ€§çš„å¤šé‡å­ä½æ¨¡æ‹Ÿå™¨ã€‚æˆ‘ä»¬å°†é€šè¿‡å‘ç¬¬2ç« å’Œç¬¬3ç« çš„å•é‡å­ä½æ¨¡æ‹Ÿå™¨æ·»åŠ ä¸€äº›åŠŸèƒ½æ¥å®ç°è¿™ä¸€ç‚¹ã€‚
- en: The most significant change weâ€™ll need to make to our simulator from previous
    chapters is that we can no longer assign a state to each qubit. Rather, we must
    assign a state to the entire *register* of qubits in our device since some of
    the qubits may be *entangled* with each other. Letâ€™s jump into making the modifications
    necessary to separate the concept of the state to the device level.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬éœ€è¦å¯¹æ¨¡æ‹Ÿå™¨ä»ä¹‹å‰ç« èŠ‚æ‰€åšçš„æœ€æ˜¾è‘—çš„æ”¹å˜æ˜¯ï¼Œæˆ‘ä»¬ä¸èƒ½å†ä¸ºæ¯ä¸ªé‡å­ä½åˆ†é…ä¸€ä¸ªçŠ¶æ€ã€‚ç›¸åï¼Œæˆ‘ä»¬å¿…é¡»ä¸ºè®¾å¤‡ä¸­çš„æ•´ä¸ª*å¯„å­˜å™¨*åˆ†é…ä¸€ä¸ªçŠ¶æ€ï¼Œå› ä¸ºä¸€äº›é‡å­ä½å¯èƒ½å½¼æ­¤*çº ç¼ *ã€‚è®©æˆ‘ä»¬å¼€å§‹è¿›è¡Œå¿…è¦çš„ä¿®æ”¹ï¼Œä»¥å°†çŠ¶æ€çš„æ¦‚å¿µåˆ†ç¦»åˆ°è®¾å¤‡çº§åˆ«ã€‚
- en: 'Note To look at the code we wrote earlier, as well as the samples for this
    chapter, see the GitHub repo for the book: [https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼šè¦æŸ¥çœ‹æˆ‘ä»¬ä¹‹å‰ç¼–å†™çš„ä»£ç ä»¥åŠæœ¬ç« çš„ç¤ºä¾‹ï¼Œè¯·å‚é˜…æœ¬ä¹¦çš„GitHubä»“åº“ï¼š[https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp)ã€‚
- en: 'To review, we have two files for our simulator: the interface (interface.py)
    and the simulator itself (simulator.py). The device interface (`QuantumDevice`)
    defines a way of interacting with an actual or simulated quantum device, which
    is represented in Python as an object that lets us allocate and deallocate qubits.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†å¤ä¹ ï¼Œæˆ‘ä»¬æœ‰ä¸¤ä¸ªç”¨äºæˆ‘ä»¬çš„æ¨¡æ‹Ÿå™¨çš„æ–‡ä»¶ï¼šæ¥å£ï¼ˆinterface.pyï¼‰å’Œæ¨¡æ‹Ÿå™¨æœ¬èº«ï¼ˆsimulator.pyï¼‰ã€‚è®¾å¤‡æ¥å£ï¼ˆ`QuantumDevice`ï¼‰å®šä¹‰äº†ä¸å®é™…æˆ–æ¨¡æ‹Ÿé‡å­è®¾å¤‡äº¤äº’çš„æ–¹å¼ï¼Œåœ¨Pythonä¸­ï¼Œå®ƒæ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œå…è®¸æˆ‘ä»¬åˆ†é…å’Œé‡Šæ”¾é‡å­ä½ã€‚
- en: We wonâ€™t need anything new for the `QuantumDevice` class in the interface to
    model our CHSH game since weâ€™ll still need to allocate and deallocate qubits.
    Where we can add features is in the `Qubit` class provided along with our `SingleQubitSimulator`
    in simulator.py.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ¥å£ä¸­ï¼Œæˆ‘ä»¬ä¸éœ€è¦ä¸º `QuantumDevice` ç±»æ·»åŠ ä»»ä½•æ–°åŠŸèƒ½æ¥æ¨¡æ‹Ÿæˆ‘ä»¬çš„ CHSH æ¸¸æˆï¼Œå› ä¸ºæˆ‘ä»¬ä»ç„¶éœ€è¦åˆ†é…å’Œé‡Šæ”¾é‡å­æ¯”ç‰¹ã€‚æˆ‘ä»¬å¯ä»¥åœ¨ `Qubit`
    ç±»ä¸­æ·»åŠ åŠŸèƒ½ï¼Œè¿™ä¸ªç±»ä¸æˆ‘ä»¬çš„ `SingleQubitSimulator` ä¸€èµ·åœ¨ simulator.py ä¸­æä¾›ã€‚
- en: Now we need to consider what, if anything, needs to change in our interface
    for a `Qubit` we allocate from the `QuantumDevice`. In chapter 2, we saw that
    the Hadamard operation was useful for rotating qubits between different bases
    to make a QRNG. Letâ€™s build on this by adding a new method to `Qubit` to allow
    quantum programs to send a new kind of rotation instruction that we will need
    to use the quantum strategy for CHSH.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬éœ€è¦è€ƒè™‘ï¼Œå¦‚æœæˆ‘ä»¬ä» `QuantumDevice` åˆ†é…ä¸€ä¸ª `Qubit`ï¼Œæˆ‘ä»¬çš„æ¥å£ä¸­æ˜¯å¦éœ€è¦åšå‡ºä»»ä½•æ”¹å˜ã€‚åœ¨ç¬¬ 2 ç« ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°äº† Hadamard
    æ“ä½œå¯¹äºåœ¨ QRNG ä¸­æ—‹è½¬é‡å­æ¯”ç‰¹åˆ°ä¸åŒåŸºæ˜¯æœ‰ç”¨çš„ã€‚è®©æˆ‘ä»¬åœ¨æ­¤åŸºç¡€ä¸Šæ·»åŠ ä¸€ä¸ªæ–°çš„æ–¹æ³•åˆ° `Qubit`ï¼Œä»¥ä¾¿é‡å­ç¨‹åºå¯ä»¥å‘é€ä¸€ç§æ–°çš„æ—‹è½¬æŒ‡ä»¤ï¼Œæˆ‘ä»¬å°†éœ€è¦ä½¿ç”¨é‡å­ç­–ç•¥æ¥æ‰§è¡Œ
    CHSHã€‚
- en: 'Listing 5.7 interface.py: adding a new `ry` operation'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ 5.7 interface.pyï¼šæ·»åŠ æ–°çš„ `ry` æ“ä½œ
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: â¶ The abstract method ry, which takes an argument angle to specify how far to
    rotate the qubit around the *Y*-axis
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ æŠ½è±¡æ–¹æ³• ryï¼Œå®ƒé€šè¿‡ä¸€ä¸ªè§’åº¦å‚æ•°æ¥æŒ‡å®šé‡å­æ¯”ç‰¹ç»• *Y*- è½´æ—‹è½¬å¤šè¿œ
- en: That should cover all the changes we need to make to our `Qubit` and `QuantumDevice`
    interface for playing CHSH with Eve. We need to address what changes we need to
    make to simulator.py to allow it to allocate, operate, and measure multi-qubit
    states.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ ·å°±åº”è¯¥æ¶µç›–äº†æˆ‘ä»¬éœ€è¦å¯¹ `Qubit` å’Œ `QuantumDevice` æ¥å£è¿›è¡Œçš„æ‰€æœ‰æ›´æ”¹ï¼Œä»¥ä¾¿ä¸ Eve è¿›è¡Œ CHSH æ¸¸æˆã€‚æˆ‘ä»¬éœ€è¦è§£å†³æˆ‘ä»¬éœ€è¦å¯¹
    simulator.py è¿›è¡Œå“ªäº›æ›´æ”¹ï¼Œä»¥ä¾¿å®ƒèƒ½å¤Ÿåˆ†é…ã€æ“ä½œå’Œæµ‹é‡å¤šé‡å­æ¯”ç‰¹çŠ¶æ€ã€‚
- en: The main changes to our `Simulator` class that implements a `QuantumDevice`
    are that we need attributes to track how many qubits it has and the registerâ€™s
    overall state. The next listing shows these changes as well as an update to allocation
    and deallocation methods.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å®ç° `QuantumDevice` çš„ `Simulator` ç±»çš„ä¸»è¦å˜åŒ–æ˜¯éœ€è¦å±æ€§æ¥è·Ÿè¸ªå®ƒæœ‰å¤šå°‘ä¸ªé‡å­æ¯”ç‰¹ä»¥åŠå¯„å­˜å™¨çš„æ•´ä½“çŠ¶æ€ã€‚ä¸‹ä¸€ä¸ªåˆ—è¡¨æ˜¾ç¤ºäº†è¿™äº›å˜åŒ–ä»¥åŠåˆ†é…å’Œé‡Šæ”¾æ–¹æ³•çš„æ›´æ–°ã€‚
- en: 'Listing 5.8 simulator.py: the multi-qubit `Simulator`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ 5.8 simulator.pyï¼šå¤šé‡å­æ¯”ç‰¹ `Simulator`
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: â¶ We have changed the name from SingleQubitSimulator to Simulator to indicate
    that it is more generalized. That means we can simulate multiple qubits with it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ æˆ‘ä»¬å°†åç§°ä» SingleQubitSimulator æ›´æ”¹ä¸º Simulatorï¼Œä»¥è¡¨æ˜å®ƒæ›´é€šç”¨ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥ç”¨å®ƒæ¥æ¨¡æ‹Ÿå¤šä¸ªé‡å­æ¯”ç‰¹ã€‚
- en: â· The more general Simulator class needs a few attributes, the first being capacity,
    which represents the number of qubits it can simulate.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: â· æ›´é€šç”¨çš„ Simulator ç±»éœ€è¦ä¸€äº›å±æ€§ï¼Œé¦–å…ˆæ˜¯å®¹é‡ï¼Œå®ƒè¡¨ç¤ºå®ƒå¯ä»¥æ¨¡æ‹Ÿçš„é‡å­æ¯”ç‰¹æ•°é‡ã€‚
- en: â¸ available_qubits is a list containing the qubits the Simulator is using.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: â¸ available_qubits æ˜¯ä¸€ä¸ªåŒ…å« Simulator æ­£åœ¨ä½¿ç”¨çš„é‡å­æ¯”ç‰¹çš„åˆ—è¡¨ã€‚
- en: â¹ register_state uses the new QuTiP Qobj to represent the state of the entire
    simulator.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: â¹ register_state ä½¿ç”¨æ–°çš„ QuTiP Qobj æ¥è¡¨ç¤ºæ•´ä¸ªæ¨¡æ‹Ÿå™¨çš„çŠ¶æ€ã€‚
- en: âº A list comprehension allows us to make a list of available qubits by calling
    SimulatedQubit with the indices from the range of capacity.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: âº åˆ—è¡¨æ¨å¯¼å¼å…è®¸æˆ‘ä»¬é€šè¿‡è°ƒç”¨å…·æœ‰å®¹é‡èŒƒå›´çš„ç´¢å¼•çš„ SimulatedQubit æ¥åˆ›å»ºä¸€ä¸ªå¯ç”¨é‡å­æ¯”ç‰¹çš„åˆ—è¡¨ã€‚
- en: â» register_state is initialized by taking the tensor product of a number of
    copies of the |0ã€‰ state equal to the simulatorâ€™s capacity. The *[...] notation
    turns the generated list into a sequence of arguments for qt.tensor.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: â» register_state é€šè¿‡å–ä¸æ¨¡æ‹Ÿå™¨å®¹é‡ç›¸ç­‰çš„ |0ã€‰ çŠ¶æ€çš„å¤šä¸ªå¤åˆ¶å“çš„å¼ é‡ç§¯æ¥åˆå§‹åŒ–ã€‚The *[...] notation å°†ç”Ÿæˆçš„åˆ—è¡¨è½¬æ¢ä¸º
    qt.tensor çš„å‚æ•°åºåˆ—ã€‚
- en: â¼ The allocate_qubit and deallocate_qubit methods are the same as from chapter
    3.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: â¼ allocate_qubit å’Œ deallocate_qubit æ–¹æ³•ä¸ç¬¬ 3 ç« ä¸­çš„ç›¸åŒã€‚
- en: Peer not into the box, mortal!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸è¦çª¥è§†ç›’å­ï¼Œå‡¡äººï¼
- en: Just as we used NumPy to represent a simulatorâ€™s state, the `register_state`
    property of our newly upgraded simulator uses QuTiP to predict how each instruction
    has transformed the state of our register. When we write quantum programs, though,
    we do so against the interface in listing 5.7, which doesnâ€™t have any way to let
    us access `register_state`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚æˆ‘ä»¬ä½¿ç”¨ NumPy æ¥è¡¨ç¤ºæ¨¡æ‹Ÿå™¨çš„çŠ¶æ€ä¸€æ ·ï¼Œæˆ‘ä»¬æ–°å‡çº§çš„æ¨¡æ‹Ÿå™¨çš„ `register_state` å±æ€§ä½¿ç”¨ QuTiP æ¥é¢„æµ‹æ¯ä¸ªæŒ‡ä»¤å¦‚ä½•è½¬æ¢äº†æˆ‘ä»¬çš„å¯„å­˜å™¨çŠ¶æ€ã€‚ç„¶è€Œï¼Œå½“æˆ‘ä»¬ç¼–å†™é‡å­ç¨‹åºæ—¶ï¼Œæˆ‘ä»¬æ˜¯åœ¨åˆ—è¡¨
    5.7 ä¸­ç»™å‡ºçš„æ¥å£ä¸Šè¿›è¡Œæ“ä½œçš„ï¼Œè¿™ä¸ªæ¥å£æ²¡æœ‰æä¾›ä»»ä½•è®©æˆ‘ä»¬è®¿é—® `register_state` çš„æ–¹å¼ã€‚
- en: We can think of the simulator as a kind of black box that *encapsulates* the
    notion of a state. If our quantum programs were able to look inside that box,
    they would be able to cheat by copying the information in ways forbidden by the
    no-cloning theorem. This means for a quantum program to be correct, we cannot
    look inside the simulator to see its state.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥å°†æ¨¡æ‹Ÿå™¨è§†ä¸ºä¸€ç§å°è£…äº†çŠ¶æ€æ¦‚å¿µçš„ *é»‘ç›’*ã€‚å¦‚æœæˆ‘ä»¬çš„é‡å­ç¨‹åºèƒ½å¤ŸæŸ¥çœ‹è¿™ä¸ªç›’å­å†…éƒ¨ï¼Œå®ƒä»¬å°†èƒ½å¤Ÿé€šè¿‡å¤åˆ¶ä¿¡æ¯çš„æ–¹å¼ä½œå¼Šï¼Œè¿™æ˜¯ç”±ä¸å¯å…‹éš†å®šç†æ‰€ç¦æ­¢çš„ã€‚è¿™æ„å‘³ç€ä¸ºäº†ä½¿é‡å­ç¨‹åºæ­£ç¡®ï¼Œæˆ‘ä»¬æ— æ³•æŸ¥çœ‹æ¨¡æ‹Ÿå™¨ä»¥æŸ¥çœ‹å…¶çŠ¶æ€ã€‚
- en: In this chapter, weâ€™ll cheat a little; but in the next chapter, weâ€™ll fix that
    to make sure our programs can be run on actual quantum hardware.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†ç¨å¾®ä½œå¼Šä¸€ä¸‹ï¼›ä½†åœ¨ä¸‹ä¸€ç« ä¸­ï¼Œæˆ‘ä»¬å°†ä¿®å¤è¿™ä¸ªé—®é¢˜ï¼Œä»¥ç¡®ä¿æˆ‘ä»¬çš„ç¨‹åºå¯ä»¥åœ¨å®é™…çš„é‡å­ç¡¬ä»¶ä¸Šè¿è¡Œã€‚
- en: We also will add a new *private* method to our `Simulator` that allows us to
    apply operations to specific qubits in our device. This will let us write methods
    on our qubits that send operations back to the simulator to be applied to the
    state of an entire register of qubits.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿˜å°†åœ¨æˆ‘ä»¬çš„ `Simulator` ä¸­æ·»åŠ ä¸€ä¸ªæ–°çš„ *ç§æœ‰* æ–¹æ³•ï¼Œå…è®¸æˆ‘ä»¬å¯¹è®¾å¤‡ä¸­çš„ç‰¹å®šé‡å­æ¯”ç‰¹åº”ç”¨æ“ä½œã€‚è¿™å°†ä½¿æˆ‘ä»¬èƒ½å¤Ÿåœ¨é‡å­æ¯”ç‰¹ä¸Šç¼–å†™æ–¹æ³•ï¼Œå°†æ“ä½œå‘é€å›æ¨¡æ‹Ÿå™¨ä»¥åº”ç”¨äºæ•´ä¸ªé‡å­æ¯”ç‰¹å¯„å­˜å™¨çš„çŠ¶æ€ã€‚
- en: Tip Python is not strict about keeping methods or attributes private, but we
    will prefix this method name with an underscore to indicate that it is meant for
    use in the class only.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: æç¤ºï¼šPython å¯¹ä¿æŒæ–¹æ³•æˆ–å±æ€§ä¸ºç§æœ‰å¹¶ä¸ä¸¥æ ¼ï¼Œä½†æˆ‘ä»¬å°†åœ¨è¿™ä¸ªæ–¹æ³•åå‰åŠ ä¸Šä¸‹åˆ’çº¿æ¥è¡¨ç¤ºå®ƒä»…ç”¨äºç±»å†…éƒ¨ã€‚
- en: 'Listing 5.9 simulator.py: one additional method for `Simulator`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ 5.9 simulator.pyï¼šä¸º `Simulator` æ·»åŠ ä¸€ä¸ªé¢å¤–çš„æ–¹æ³•
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: â¶ The private method _apply takes an input unitary of type Qobj representing
    a unitary operation to be applied and a list of int to indicate the indices of
    the available_qubits list where we want to apply the operation. For now, that
    list will only ever contain one element since weâ€™re only implementing single-qubit
    operations in our simulator. Weâ€™ll relax this in the next chapter.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ ç§æœ‰æ–¹æ³• _apply æ¥æ”¶ä¸€ä¸ªè¡¨ç¤ºè¦åº”ç”¨çš„å¯é€†æ“ä½œçš„ Qobj ç±»å‹çš„è¾“å…¥å•å…ƒï¼Œä»¥åŠä¸€ä¸ªè¡¨ç¤ºæˆ‘ä»¬æƒ³è¦åº”ç”¨æ“ä½œçš„ available_qubits
    åˆ—è¡¨ä¸­ç´¢å¼•çš„æ•´æ•°åˆ—è¡¨ã€‚ç›®å‰ï¼Œè¿™ä¸ªåˆ—è¡¨å°†åªåŒ…å«ä¸€ä¸ªå…ƒç´ ï¼Œå› ä¸ºæˆ‘ä»¬ç›®å‰åªåœ¨æˆ‘ä»¬çš„æ¨¡æ‹Ÿå™¨ä¸­å®ç°å•é‡å­æ¯”ç‰¹æ“ä½œã€‚æˆ‘ä»¬å°†åœ¨ä¸‹ä¸€ç« ä¸­æ”¾å®½è¿™ä¸ªé™åˆ¶ã€‚
- en: â· If we want to apply a single-qubit operation to a qubit in a register, we
    can use QuTiP to generate the matrix we need. QuTiP does this by applying the
    matrix for our single-qubit operation to the correct qubit, and by applying ğŸ™
    everywhere else. This is done for us automatically by the gate_expand_1toN function.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: â· å¦‚æœæˆ‘ä»¬æƒ³è¦å¯¹ä¸€ä¸ªå¯„å­˜å™¨ä¸­çš„é‡å­æ¯”ç‰¹åº”ç”¨å•é‡å­æ¯”ç‰¹æ“ä½œï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ QuTiP ç”Ÿæˆæ‰€éœ€çš„çŸ©é˜µã€‚QuTiP é€šè¿‡å°†æˆ‘ä»¬çš„å•é‡å­æ¯”ç‰¹æ“ä½œçš„çŸ©é˜µåº”ç”¨äºæ­£ç¡®çš„é‡å­æ¯”ç‰¹ï¼Œå¹¶åœ¨å…¶ä»–åœ°æ–¹åº”ç”¨
    ğŸ™ æ¥å®Œæˆè¿™é¡¹å·¥ä½œã€‚è¿™æ˜¯ç”± gate_expand_1toN å‡½æ•°è‡ªåŠ¨å®Œæˆçš„ã€‚
- en: â¸ Now that we have the right matrix to which to multiply our entire register_state,
    we can update the value of that register accordingly.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: â¸ ç°åœ¨æˆ‘ä»¬æœ‰äº†è¦ä¹˜ä»¥æ•´ä¸ªå¯„å­˜å™¨çŠ¶æ€çš„æ­£ç¡®çŸ©é˜µï¼Œæˆ‘ä»¬å¯ä»¥ç›¸åº”åœ°æ›´æ–°å¯„å­˜å™¨çš„å€¼ã€‚
- en: Letâ€™s get to the implementation of `SimulatedQubit`, the class that represents
    how we simulate a single qubit, given that we know it is part of a device that
    has multiple qubits. The main difference between the single- and multi-qubit versions
    of `SimulatedQubit` is that we need each qubit to remember its â€œparentâ€ device
    and location or `id` in that device so that we can associate the state with the
    register and not each qubit. This is important, as we will see in the next section,
    when we want to measure qubits in a multi-qubit device.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æ¥çœ‹çœ‹ `SimulatedQubit` çš„å®ç°ï¼Œè¿™æ˜¯ä¸€ä¸ªè¡¨ç¤ºæˆ‘ä»¬å¦‚ä½•æ¨¡æ‹Ÿå•ä¸ªé‡å­æ¯”ç‰¹çš„ç±»ï¼Œå‰ææ˜¯æˆ‘ä»¬çŸ¥é“å®ƒæ˜¯ä¸€ä¸ªå…·æœ‰å¤šä¸ªé‡å­æ¯”ç‰¹çš„è®¾å¤‡çš„ä¸€éƒ¨åˆ†ã€‚å•é‡å­æ¯”ç‰¹å’Œå¤šé‡å­æ¯”ç‰¹ç‰ˆæœ¬çš„
    `SimulatedQubit` ä¹‹é—´çš„ä¸»è¦åŒºåˆ«åœ¨äºï¼Œæˆ‘ä»¬éœ€è¦æ¯ä¸ªé‡å­æ¯”ç‰¹è®°ä½å…¶â€œçˆ¶â€è®¾å¤‡å’Œåœ¨è¯¥è®¾å¤‡ä¸­çš„ä½ç½®æˆ– `id`ï¼Œè¿™æ ·æˆ‘ä»¬æ‰èƒ½å°†çŠ¶æ€ä¸å¯„å­˜å™¨å…³è”èµ·æ¥ï¼Œè€Œä¸æ˜¯ä¸æ¯ä¸ªé‡å­æ¯”ç‰¹å…³è”ã€‚è¿™å¾ˆé‡è¦ï¼Œæ­£å¦‚æˆ‘ä»¬å°†åœ¨ä¸‹ä¸€èŠ‚ä¸­çœ‹åˆ°çš„ï¼Œå½“æˆ‘ä»¬æƒ³è¦æµ‹é‡å¤šé‡å­æ¯”ç‰¹è®¾å¤‡ä¸­çš„é‡å­æ¯”ç‰¹æ—¶ã€‚
- en: 'Listing 5.10 simulator.py: single-qubit operations on a multi-qubit device'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ 5.10 simulator.pyï¼šåœ¨å¤šé‡å­æ¯”ç‰¹è®¾å¤‡ä¸Šæ‰§è¡Œå•é‡å­æ¯”ç‰¹æ“ä½œ
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: â¶ To initialize a qubit, we need the name of the parent simulator (so we can
    easily associate it) and the index of the qubit in the simulatorâ€™s register. __init__
    then sets those attributes and resets the qubit to the |0ã€‰ state.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ è¦åˆå§‹åŒ–ä¸€ä¸ªé‡å­æ¯”ç‰¹ï¼Œæˆ‘ä»¬éœ€è¦çˆ¶æ¨¡æ‹Ÿå™¨çš„åç§°ï¼ˆä»¥ä¾¿æˆ‘ä»¬èƒ½å¤Ÿè½»æ¾å…³è”ï¼‰å’Œé‡å­æ¯”ç‰¹åœ¨æ¨¡æ‹Ÿå™¨å¯„å­˜å™¨ä¸­çš„ç´¢å¼•ã€‚`__init__` ç„¶åè®¾ç½®è¿™äº›å±æ€§å¹¶å°†é‡å­æ¯”ç‰¹é‡ç½®åˆ°
    |0ã€‰ çŠ¶æ€ã€‚
- en: â· To implement the HÂ operation, we ask the parent of SimulatedQubit (which is
    an instance of Simulator) to use the _apply method to generate the right matrix
    that would represent the operation on the complete register, then update the register_state.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: â· è¦å®ç° H æ“ä½œï¼Œæˆ‘ä»¬è¦æ±‚ SimulatedQubit çš„çˆ¶å¯¹è±¡ï¼ˆå®ƒæ˜¯ä¸€ä¸ª Simulator å®ä¾‹ï¼‰ä½¿ç”¨ _apply æ–¹æ³•ç”Ÿæˆè¡¨ç¤ºå¯¹æ•´ä¸ªå¯„å­˜å™¨æ“ä½œçš„çŸ©é˜µï¼Œç„¶åæ›´æ–°å¯„å­˜å™¨çŠ¶æ€ã€‚
- en: â¸ We can also pass the parameterized qt.ry operation from QuTiP to _apply to
    rotate our qubit about the Y-axis by an angle â€œangleâ€.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: â¸ æˆ‘ä»¬è¿˜å¯ä»¥å°† QuTiP ä¸­çš„å‚æ•°åŒ– qt.ry æ“ä½œä¼ é€’ç»™ _apply ä»¥æ—‹è½¬æˆ‘ä»¬çš„é‡å­æ¯”ç‰¹ç»• Y è½´æ—‹è½¬ä¸€ä¸ªè§’åº¦â€œangleâ€ã€‚
- en: Great! We are almost finished upgrading our simulator to use QuTiP and support
    multiple qubits. We will tackle simulating measurement on multi-qubit states in
    the next section.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: å¤ªå¥½äº†ï¼æˆ‘ä»¬å‡ ä¹å®Œæˆäº†å‡çº§æˆ‘ä»¬çš„æ¨¡æ‹Ÿå™¨ä»¥ä½¿ç”¨ QuTiP å¹¶æ”¯æŒå¤šä¸ªé‡å­æ¯”ç‰¹çš„å·¥ä½œã€‚æˆ‘ä»¬å°†åœ¨ä¸‹ä¸€èŠ‚ä¸­å¤„ç†åœ¨å¤šé‡å­æ¯”ç‰¹çŠ¶æ€ä¸Šæ¨¡æ‹Ÿæµ‹é‡çš„å·¥ä½œã€‚
- en: '5.1.2 Measuring up: How can we measure multiple qubits?'
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.2 æµ‹é‡ï¼šæˆ‘ä»¬å¦‚ä½•æµ‹é‡å¤šä¸ªé‡å­æ¯”ç‰¹ï¼Ÿ
- en: Tip This section is one of the most challenging in the book. Please donâ€™t worry
    if it doesnâ€™t make a lot of sense the first time around.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: æç¤ºï¼šæœ¬èŠ‚æ˜¯æœ¬ä¹¦ä¸­æœ€å…·æŒ‘æˆ˜æ€§çš„éƒ¨åˆ†ä¹‹ä¸€ã€‚å¦‚æœç¬¬ä¸€æ¬¡é˜…è¯»æ—¶å®ƒæ²¡æœ‰å¤ªå¤šæ„ä¹‰ï¼Œè¯·ä¸è¦æ‹…å¿ƒã€‚
- en: 'In some sense, measuring multiple qubits works the same way weâ€™re used to from
    measuring single-qubit systems. We can still use Bornâ€™s rule to predict the probability
    of any particular measurement outcome. For example, letâ€™s return to the (|00ã€‰
    + |11ã€‰) / âˆš2 state that weâ€™ve seen a few times already. If we were to measure
    a pair of qubits in that state, we would get either â€œ00â€ or â€œ11â€ as our classical
    outcomes with equal probability since both have the same amplitude: 1 / âˆš2.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æŸç§ç¨‹åº¦ä¸Šï¼Œæµ‹é‡å¤šä¸ªé‡å­æ¯”ç‰¹çš„å·¥ä½œæ–¹å¼ä¸æˆ‘ä»¬ä¹ æƒ¯äºæµ‹é‡å•é‡å­æ¯”ç‰¹ç³»ç»Ÿçš„æ–¹å¼ç›¸åŒã€‚æˆ‘ä»¬ä»ç„¶å¯ä»¥ä½¿ç”¨ Born å®šå¾‹æ¥é¢„æµ‹ä»»ä½•ç‰¹å®šæµ‹é‡ç»“æœçš„å¯èƒ½æ€§ã€‚ä¾‹å¦‚ï¼Œè®©æˆ‘ä»¬å›åˆ°æˆ‘ä»¬å·²ç»çœ‹åˆ°å‡ æ¬¡çš„
    (|00ã€‰ + |11ã€‰) / âˆš2 çŠ¶æ€ã€‚å¦‚æœæˆ‘ä»¬æµ‹é‡å¤„äºè¯¥çŠ¶æ€çš„ä¸€å¯¹é‡å­æ¯”ç‰¹ï¼Œæˆ‘ä»¬ä¼šä»¥ç›¸ç­‰çš„æ¦‚ç‡å¾—åˆ°â€œ00â€æˆ–â€œ11â€ä½œä¸ºæˆ‘ä»¬çš„ç»å…¸ç»“æœï¼Œå› ä¸ºå®ƒä»¬éƒ½æœ‰ç›¸åŒçš„æŒ¯å¹…ï¼š1
    / âˆš2ã€‚
- en: Similarly, weâ€™ll still demand that if we measure the same register twice in
    a row, we get the same answer. If we get the â€œ00â€ outcome, for instance, we know
    that qubits are left in the |00ã€‰ = |0ã€‰ âŠ— |0ã€‰ state.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: åŒæ ·ï¼Œæˆ‘ä»¬ä»ç„¶è¦æ±‚å¦‚æœæˆ‘ä»¬è¿ç»­ä¸¤æ¬¡æµ‹é‡ç›¸åŒçš„å¯„å­˜å™¨ï¼Œæˆ‘ä»¬å¾—åˆ°ç›¸åŒçš„ç­”æ¡ˆã€‚ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬å¾—åˆ°â€œ00â€çš„ç»“æœï¼Œæˆ‘ä»¬çŸ¥é“é‡å­æ¯”ç‰¹è¢«ç•™åœ¨ |00ã€‰ = |0ã€‰
    âŠ— |0ã€‰ çŠ¶æ€ã€‚
- en: This gets a little bit trickier, however, if we measure *part* of a quantum
    register without measuring the whole thing. Letâ€™s look at a couple of examples
    to see how that could work. Again taking (|00ã€‰ + |11ã€‰) / âˆš2 as an example, if
    we measure *only* the first qubit and we get a â€œ0â€, we know that we need to get
    the same answer again the next time we measure. The only way this can happen is
    if the state transforms to |00ã€‰ as a result of having observed â€œ0â€ on the first
    qubit.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œå¦‚æœæˆ‘ä»¬ä¸æµ‹é‡æ•´ä¸ªé‡å­å¯„å­˜å™¨è€Œåªæµ‹é‡å…¶ä¸€éƒ¨åˆ†ï¼Œè¿™ä¼šå˜å¾—æœ‰ç‚¹å¤æ‚ã€‚è®©æˆ‘ä»¬çœ‹çœ‹å‡ ä¸ªä¾‹å­ï¼Œçœ‹çœ‹è¿™æ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚å†æ¬¡ä»¥ (|00ã€‰ + |11ã€‰) / âˆš2
    ä¸ºä¾‹ï¼Œå¦‚æœæˆ‘ä»¬åªæµ‹é‡ç¬¬ä¸€ä¸ªé‡å­æ¯”ç‰¹å¹¶ä¸”å¾—åˆ°â€œ0â€ï¼Œæˆ‘ä»¬çŸ¥é“æˆ‘ä»¬ä¸‹æ¬¡æµ‹é‡æ—¶éœ€è¦å¾—åˆ°ç›¸åŒçš„ç­”æ¡ˆã€‚è¿™ç§æƒ…å†µåªèƒ½é€šè¿‡è§‚å¯Ÿç¬¬ä¸€ä¸ªé‡å­æ¯”ç‰¹ä¸Šçš„â€œ0â€å¯¼è‡´çŠ¶æ€è½¬æ¢ä¸º |00ã€‰
    æ¥å®ç°ã€‚
- en: On the other hand, what happens if we measure the first qubit from a pair of
    qubits in the |+ã€‰ state? First, itâ€™s helpful to refresh our memory as to what
    |+ã€‰ looks like when written as a vector.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: å¦ä¸€æ–¹é¢ï¼Œå¦‚æœæˆ‘ä»¬æµ‹é‡å¤„äº |+ã€‰ çŠ¶æ€çš„ä¸€å¯¹é‡å­æ¯”ç‰¹ä¸­çš„ç¬¬ä¸€ä¸ªé‡å­æ¯”ç‰¹ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿé¦–å…ˆï¼Œå›é¡¾ä¸€ä¸‹å½“ä»¥å‘é‡å½¢å¼è¡¨ç¤ºæ—¶ |+ã€‰ çœ‹èµ·æ¥æ˜¯ä»€ä¹ˆæ ·å­æ˜¯æœ‰å¸®åŠ©çš„ã€‚
- en: Listing 5.11 Representing the |++ã€‰ state with QuTiP
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ 5.11 ä½¿ç”¨ QuTiP è¡¨ç¤º |++ã€‰ çŠ¶æ€
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: â¶ Start by writing |+ã€‰ as *H*|0ã€‰. In QuTiP, we use the hadamard _transform function
    to get a Qobj instance to represent H, and we use basis(2, 0) to get a Qobj representing
    |0ã€‰.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ é¦–å…ˆå°† |+ã€‰ å†™ä½œ *H*|0ã€‰ã€‚åœ¨ QuTiP ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ hadamard _å˜æ¢å‡½æ•°_ æ¥è·å–ä¸€ä¸ª Qobj å®ä¾‹ä»¥è¡¨ç¤º Hï¼Œæˆ‘ä»¬ä½¿ç”¨ basis(2,
    0) æ¥è·å–ä¸€ä¸ªè¡¨ç¤º |0ã€‰ çš„ Qobjã€‚
- en: â· We can print out ket_plus to get a list of the elements in that vector; as
    before, we call each of these elements an amplitude.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: â· æˆ‘ä»¬å¯ä»¥æ‰“å°å‡º ket_plus æ¥è·å–è¯¥å‘é‡ä¸­çš„å…ƒç´ åˆ—è¡¨ï¼›å°±åƒä¹‹å‰ä¸€æ ·ï¼Œæˆ‘ä»¬ç§°è¿™äº›å…ƒç´ ä¸­çš„æ¯ä¸€ä¸ªä¸ºä¸€ä¸ªæŒ¯å¹…ã€‚
- en: â¸ To represent the state |+ã€‰, we use that |+ã€‰ = |+ã€‰ âŠ— |+ã€‰.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: â¸ ä¸ºäº†è¡¨ç¤ºçŠ¶æ€ |+ã€‰ï¼Œæˆ‘ä»¬ä½¿ç”¨ |+ã€‰ = |+ã€‰ âŠ— |+ã€‰ã€‚
- en: â¹ This output tells us that |++ã€‰ has the same amplitude for each of the four
    computational basis states |00ã€‰, |01ã€‰, |10ã€‰, and |11ã€‰, just as ket_plus has the
    same amplitude for each of the computational basis states |0ã€‰ and |1ã€‰.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: â¹ è¿™ä¸ªè¾“å‡ºå‘Šè¯‰æˆ‘ä»¬ |++ã€‰ å¯¹äºå››ä¸ªè®¡ç®—åŸºæ€ |00ã€‰ã€|01ã€‰ã€|10ã€‰ å’Œ |11ã€‰ éƒ½æœ‰ç›¸åŒçš„æŒ¯å¹…ï¼Œæ­£å¦‚ ket_plus å¯¹äºè®¡ç®—åŸºæ€ |0ã€‰
    å’Œ |1ã€‰ çš„æŒ¯å¹…ç›¸åŒã€‚
- en: Suppose that we measure the first qubit and get a â€œ1â€ outcome. To ensure that
    we get the same result the next time we measure, the state after measurement canâ€™t
    have any amplitude on |00ã€‰ or |01ã€‰. If we only keep the amplitudes on |10ã€‰ and
    |11ã€‰ (the third and four rows of the vector we calculated previously), then we
    get that the state of our two qubits becomes (|10ã€‰ + |11ã€‰) / âˆš2.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬æµ‹é‡ç¬¬ä¸€ä¸ªé‡å­æ¯”ç‰¹å¹¶å¾—åˆ°â€œ1â€çš„ç»“æœã€‚ä¸ºäº†ç¡®ä¿æˆ‘ä»¬ä¸‹æ¬¡æµ‹é‡æ—¶å¾—åˆ°ç›¸åŒçš„ç»“æœï¼Œæµ‹é‡åçš„çŠ¶æ€ä¸èƒ½åœ¨ |00ã€‰ æˆ– |01ã€‰ ä¸Šæœ‰ä»»ä½•æŒ¯å¹…ã€‚å¦‚æœæˆ‘ä»¬åªä¿ç•™
    |10ã€‰ å’Œ |11ã€‰ï¼ˆæˆ‘ä»¬ä¹‹å‰è®¡ç®—çš„å‘é‡çš„ç¬¬ä¸‰è¡Œå’Œç¬¬å››è¡Œï¼‰ä¸Šçš„æŒ¯å¹…ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¾—åˆ°çš„çŠ¶æ€å°±å˜æˆäº† (|10ã€‰ + |11ã€‰) / âˆš2ã€‚
- en: Where did the âˆš2 come from?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: âˆš2 ä»å“ªé‡Œæ¥çš„ï¼Ÿ
- en: We included a âˆš2 to ensure that all our measurement probabilities still sum
    to 1 when we measure the second qubit. For Bornâ€™s rule to make any sense, we always
    need the sum of the squares of each amplitude to sum to 1.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åŒ…æ‹¬äº†ä¸€ä¸ªâˆš2ï¼Œä»¥ç¡®ä¿å½“æˆ‘ä»¬æµ‹é‡ç¬¬äºŒä¸ªé‡å­æ¯”ç‰¹æ—¶ï¼Œæ‰€æœ‰æµ‹é‡æ¦‚ç‡çš„æ€»å’Œä»ç„¶ä¸º1ã€‚ä¸ºäº†ä½¿Bornè§„åˆ™æœ‰æ„ä¹‰ï¼Œæˆ‘ä»¬æ€»æ˜¯éœ€è¦æ¯ä¸ªæŒ¯å¹…å¹³æ–¹çš„æ€»å’ŒåŠ èµ·æ¥ä¸º1ã€‚
- en: Thereâ€™s another way to write this state, though, that we can check using QuTiP.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: å°½ç®¡å¦‚æ­¤ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥ç”¨å¦ä¸€ç§æ–¹å¼æ¥è¡¨ç¤ºè¿™ä¸ªçŠ¶æ€ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨QuTiPæ¥æ£€æŸ¥è¿™ä¸€ç‚¹ã€‚
- en: Listing 5.12 Representing the |1+ã€‰ state with QuTiP
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨5.12 ä½¿ç”¨QuTiPè¡¨ç¤º|1+ã€‰çŠ¶æ€
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: â¶ Recall that we can write |+ã€‰ as *H*|0ã€‰.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ å›æƒ³ä¸€ä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥å°†|+ã€‰å†™æˆ*H*|0ã€‰ã€‚
- en: This tells us that if we only keep the parts of the state |+ã€‰ that are consistent
    with getting a â€œ1â€ outcome from measuring the first qubit, then we get |1ã€‰ = |1ã€‰
    âŠ— |+ã€‰. That is, nothing happens at all to the second qubit in this case!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å‘Šè¯‰æˆ‘ä»¬ï¼Œå¦‚æœæˆ‘ä»¬åªä¿ç•™ä¸æµ‹é‡ç¬¬ä¸€ä¸ªé‡å­æ¯”ç‰¹å¾—åˆ°â€œ1â€ç»“æœä¸€è‡´çš„çŠ¶æ€|+ã€‰çš„éƒ¨åˆ†ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¾—åˆ°|1ã€‰ = |1ã€‰ âŠ— |+ã€‰ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œç¬¬äºŒä¸ªé‡å­æ¯”ç‰¹æ ¹æœ¬æ²¡æœ‰ä»»ä½•å˜åŒ–ï¼
- en: 'Exercise 5.3: Measuring the other qubit'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 5.3ï¼šæµ‹é‡å¦ä¸€ä¸ªé‡å­æ¯”ç‰¹
- en: In the example where our two qubits begin in the |++ã€‰ state, suppose we measured
    the second qubit instead. Check that no matter what result we get, nothing happens
    to the state of the first qubit.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬çš„ä¸¤ä¸ªé‡å­æ¯”ç‰¹ä»|++ã€‰çŠ¶æ€å¼€å§‹çš„ä¾‹å­ä¸­ï¼Œå‡è®¾æˆ‘ä»¬æµ‹é‡äº†ç¬¬äºŒä¸ªé‡å­æ¯”ç‰¹ã€‚æ£€æŸ¥ä¸€ä¸‹ï¼Œæ— è®ºæˆ‘ä»¬å¾—åˆ°ä»€ä¹ˆç»“æœï¼Œç¬¬ä¸€ä¸ªé‡å­æ¯”ç‰¹çš„çŠ¶æ€éƒ½ä¸ä¼šå‘ç”Ÿå˜åŒ–ã€‚
- en: To work out what it means to measure part of a register more generally, we can
    use another concept from linear algebra called *projectors*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†æ›´æ™®éåœ°å¼„æ¸…æ¥šæµ‹é‡å¯„å­˜å™¨çš„ä¸€éƒ¨åˆ†æ„å‘³ç€ä»€ä¹ˆï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨çº¿æ€§ä»£æ•°ä¸­çš„å¦ä¸€ä¸ªæ¦‚å¿µï¼Œå³*æŠ•å½±å™¨*ã€‚
- en: Definition A *projector* is the product of a state vector (the â€œketâ€ or |+ã€‰
    part of a bra-ket) and a measurement (the â€œbraâ€ or ã€ˆ+| part of a bra-ket) and
    represents our requirement that *if* a certain measurement outcome occurs, *then*
    we must transform to a state consistent with that measurement.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: å®šä¹‰A *æŠ•å½±å™¨*æ˜¯çŠ¶æ€å‘é‡ï¼ˆæ‹¬å·ä¸­çš„â€œketâ€æˆ–|+ã€‰éƒ¨åˆ†ï¼‰å’Œæµ‹é‡ï¼ˆæ‹¬å·ä¸­çš„â€œbraâ€æˆ–ã€ˆ+|éƒ¨åˆ†ï¼‰çš„ä¹˜ç§¯ï¼Œå®ƒä»£è¡¨æˆ‘ä»¬çš„è¦æ±‚ï¼šå¦‚æœ*å‘ç”Ÿ*æŸç§æµ‹é‡ç»“æœï¼Œé‚£ä¹ˆæˆ‘ä»¬å¿…é¡»è½¬æ¢åˆ°ä¸€ä¸ªä¸è¯¥æµ‹é‡ä¸€è‡´çš„çŠ¶æ€ã€‚
- en: See figure 5.4 for a quick example of a single-qubit projector. Defining projectors
    on multiple qubits works exactly the same way.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: è§å›¾5.4ï¼Œäº†è§£å•é‡å­æ¯”ç‰¹æŠ•å½±å™¨çš„å¿«é€Ÿç¤ºä¾‹ã€‚åœ¨å¤šä¸ªé‡å­æ¯”ç‰¹ä¸Šå®šä¹‰æŠ•å½±å™¨çš„å·¥ä½œæ–¹å¼å®Œå…¨ç›¸åŒã€‚
- en: '![](../Images/5-4.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![å›¾ç‰‡](../Images/5-4.png)'
- en: Figure 5.4 An example of a projector acting on a single-qubit state
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾5.4 å•é‡å­æ¯”ç‰¹çŠ¶æ€çš„æŠ•å½±å™¨ä½œç”¨ç¤ºä¾‹
- en: In QuTiP, we write the bra corresponding to a ket by using the `.dag()` method
    (short for *dagger*, a call-back to mathematical notation we see in figure 5.4).
    Fortunately, even if the math isnâ€™t straightforward, it winds up not being that
    bad to write in Python, as we can see next.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨QuTiPä¸­ï¼Œæˆ‘ä»¬é€šè¿‡ä½¿ç”¨`.dag()`æ–¹æ³•ï¼ˆç®€ç§°ä¸º*dagger*ï¼Œè¿™æ˜¯å¯¹å›¾5.4ä¸­çœ‹åˆ°çš„æ•°å­¦ç¬¦å·çš„å›æº¯ï¼‰æ¥å†™å‡ºä¸åŸºç›¸å¯¹åº”çš„å…±è½­ã€‚å¹¸è¿çš„æ˜¯ï¼Œå³ä½¿æ•°å­¦è¿ç®—ä¸æ˜¯é‚£ä¹ˆç›´æ¥ï¼Œåœ¨Pythonä¸­ç¼–å†™èµ·æ¥å¹¶ä¸é‚£ä¹ˆç³Ÿç³•ï¼Œæ­£å¦‚æˆ‘ä»¬æ¥ä¸‹æ¥å¯ä»¥çœ‹åˆ°çš„ã€‚
- en: 'Listing 5.13 simulator.py: measuring individual qubits in a register'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨5.13 simulator.pyï¼šæµ‹é‡å¯„å­˜å™¨ä¸­çš„å•ä¸ªé‡å­æ¯”ç‰¹
- en: '[PRE12]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: â¶ Uses QuTiP to make a list of projectors, one for each possible measurement
    outcome
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ ä½¿ç”¨QuTiPåˆ¶ä½œä¸€ä¸ªæŠ•å½±å™¨åˆ—è¡¨ï¼Œæ¯ä¸ªå¯èƒ½çš„æµ‹é‡ç»“æœä¸€ä¸ªã€‚
- en: â· As in listing 5.9, uses the gate_expand_1toN function to expand each single-qubit
    projector into a projector that acts on the whole register
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: â· å¦‚åˆ—è¡¨5.9æ‰€ç¤ºï¼Œä½¿ç”¨gate_expand_1toNå‡½æ•°å°†æ¯ä¸ªå•é‡å­æ¯”ç‰¹æŠ•å½±å™¨æ‰©å±•ä¸ºä½œç”¨äºæ•´ä¸ªå¯„å­˜å™¨çš„æŠ•å½±å™¨
- en: â¸ Uses each projector to pick out the parts of a state that are consistent with
    each measurement outcome
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: â¸ ä½¿ç”¨æ¯ä¸ªæŠ•å½±å™¨æ¥æŒ‘é€‰å‡ºä¸æ¯ä¸ªæµ‹é‡ç»“æœä¸€è‡´çš„çŠ¶æ€éƒ¨åˆ†
- en: â¹ The length of what each projector picks (written as the .norm() method in
    QuTiP) tells us about the probability of each measurement outcome.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: â¹ æ¯ä¸ªæŠ•å½±å™¨é€‰æ‹©çš„é•¿åº¦ï¼ˆåœ¨QuTiPä¸­ç”¨.unit()æ–¹æ³•è¡¨ç¤ºï¼‰å‘Šè¯‰æˆ‘ä»¬æ¯ä¸ªæµ‹é‡ç»“æœçš„å¯èƒ½æ€§ã€‚
- en: âº Once we have the probabilities for each outcome, we can pick an outcome using
    NumPy.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: âº ä¸€æ—¦æˆ‘ä»¬å¾—åˆ°äº†æ¯ä¸ªç»“æœçš„æ¦‚ç‡ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨NumPyæ¥é€‰æ‹©ä¸€ä¸ªç»“æœã€‚
- en: â» Uses the .unit() method built-in to QuTiP to ensure that the measurement probabilities
    still sum up to 1
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: â» ä½¿ç”¨QuTiPå†…ç½®çš„.unit()æ–¹æ³•ç¡®ä¿æµ‹é‡æ¦‚ç‡çš„æ€»å’Œä»ç„¶ä¸º1
- en: â¼ If the result of a measurement is |1ã€‰, then flipping with an x instruction
    resets back to |0ã€‰.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: â¼ å¦‚æœæµ‹é‡çš„ç»“æœæ˜¯|1ã€‰ï¼Œé‚£ä¹ˆä½¿ç”¨xæŒ‡ä»¤ç¿»è½¬ä¼šå°†å…¶é‡ç½®å›|0ã€‰ã€‚
- en: '5.2 CHSH: Quantum strategy'
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 CHSHï¼šé‡å­ç­–ç•¥
- en: Now that we have expanded our simulator to handle multiple qubits, letâ€™s see
    how we can simulate a *quantum*-based strategy for our players that will result
    in a win probability higher than could be possible with any classical strategy!
    See figure 5.5 for a reminder of how the CHSH game is played.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å·²ç»æ‰©å±•äº†æˆ‘ä»¬çš„æ¨¡æ‹Ÿå™¨ä»¥å¤„ç†å¤šä¸ªé‡å­æ¯”ç‰¹ï¼Œè®©æˆ‘ä»¬çœ‹çœ‹æˆ‘ä»¬å¦‚ä½•æ¨¡æ‹Ÿä¸€ä¸ªåŸºäº*é‡å­*çš„ç­–ç•¥ï¼Œè¿™å°†ä½¿ç©å®¶çš„è·èƒœæ¦‚ç‡é«˜äºä»»ä½•ç»å…¸ç­–ç•¥ï¼è§å›¾5.5ï¼Œä»¥æé†’å¦‚ä½•ç©CHSHæ¸¸æˆã€‚
- en: '![](../Images/5-5.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![å›¾ç‰‡](../Images/5-5.png)'
- en: Figure 5.5 The CHSH game, a nonlocal game with two players and a referee. The
    referee gives each player a question in the form of a bit value, and then each
    player has to figure out how to respond to the referee. The players win if the
    Boolean XOR of their responses is the same as the classical AND of the refereeâ€™s
    questions.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾5.5 CHSHæ¸¸æˆï¼Œä¸€ä¸ªæœ‰ä¸¤ä¸ªç©å®¶å’Œä¸€ä¸ªè£åˆ¤çš„éå®šåŸŸæ¸¸æˆã€‚è£åˆ¤ä»¥æ¯”ç‰¹å€¼çš„å½¢å¼å‘æ¯ä¸ªç©å®¶æå‡ºé—®é¢˜ï¼Œç„¶åæ¯ä¸ªç©å®¶å¿…é¡»æƒ³å‡ºå¦‚ä½•å›åº”è£åˆ¤ã€‚å¦‚æœç©å®¶ä»¬çš„å“åº”çš„å¸ƒå°”å¼‚æˆ–ä¸è£åˆ¤é—®é¢˜çš„ç»å…¸ä¸ç›¸åŒï¼Œåˆ™ç©å®¶è·èƒœã€‚
- en: 'You and Eve now have quantum resources, so letâ€™s start with the simplest option:
    You each have one qubit allocated from the same device. Weâ€™ll use our simulator
    to implement this strategy, so this isnâ€™t really a test of quantum mechanics as
    much as that our simulator agrees with quantum mechanics.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œä½ å’ŒEveæœ‰äº†é‡å­èµ„æºï¼Œè®©æˆ‘ä»¬ä»æœ€ç®€å•çš„æ–¹æ³•å¼€å§‹ï¼šä½ ä»¬æ¯ä¸ªäººä»åŒä¸€ä¸ªè®¾å¤‡ä¸­åˆ†é…åˆ°ä¸€ä¸ªé‡å­æ¯”ç‰¹ã€‚æˆ‘ä»¬å°†ä½¿ç”¨æˆ‘ä»¬çš„æ¨¡æ‹Ÿå™¨æ¥å®ç°è¿™ä¸ªç­–ç•¥ï¼Œæ‰€ä»¥è¿™å¹¶ä¸æ˜¯çœŸæ­£æµ‹è¯•é‡å­åŠ›å­¦ï¼Œæ›´å¤šçš„æ˜¯æµ‹è¯•æˆ‘ä»¬çš„æ¨¡æ‹Ÿå™¨æ˜¯å¦ä¸é‡å­åŠ›å­¦ä¸€è‡´ã€‚
- en: Note We canâ€™t simulate the players being truly nonlocal, as the simulator parts
    need to communicate to emulate quantum mechanics. Faithfully simulating quantum
    games and quantum networking protocols in this manner exposes a lot of interesting
    classical networking topology questions that are well beyond the scope of this
    book. If youâ€™re interested in simulators intended more for use in quantum networking
    than quantum computing, we recommend looking at the SimulaQron project ([www.simulaqron.org](http://www.simulaqron.org))
    for more information.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼šæˆ‘ä»¬æ— æ³•æ¨¡æ‹Ÿç©å®¶çœŸæ­£éå®šåŸŸæ€§ï¼Œå› ä¸ºæ¨¡æ‹Ÿå™¨éƒ¨åˆ†éœ€è¦é€šä¿¡æ¥æ¨¡æ‹Ÿé‡å­åŠ›å­¦ã€‚ä»¥è¿™ç§æ–¹å¼å¿ å®æ¨¡æ‹Ÿé‡å­æ¸¸æˆå’Œé‡å­ç½‘ç»œåè®®æš´éœ²äº†è®¸å¤šæœ‰è¶£çš„ç»å…¸ç½‘ç»œæ‹“æ‰‘é—®é¢˜ï¼Œè¿™äº›é—®é¢˜è¿œè¿œè¶…å‡ºäº†æœ¬ä¹¦çš„èŒƒå›´ã€‚å¦‚æœæ‚¨å¯¹æ›´å¤šç”¨äºé‡å­ç½‘ç»œè€Œä¸æ˜¯é‡å­è®¡ç®—çš„æ¨¡æ‹Ÿå™¨æ„Ÿå…´è¶£ï¼Œæˆ‘ä»¬å»ºè®®æŸ¥çœ‹SimulaQroné¡¹ç›®([www.simulaqron.org](http://www.simulaqron.org))ä»¥è·å–æ›´å¤šä¿¡æ¯ã€‚
- en: Letâ€™s see how often we and Eve can win if we each start with a single qubit,
    and if those qubits start in the (|00ã€‰ + |11ã€‰) / âˆš2 state that weâ€™ve seen a few
    times so far in this chapter. Donâ€™t worry about how to prepare this state; weâ€™ll
    learn how to do that in chapter 6\. For now, letâ€™s just see what we can do with
    qubits in that state once we have them.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬çœ‹çœ‹å¦‚æœæˆ‘ä»¬æ¯ä¸ªäººä»ä¸€ä¸ªå•é‡å­æ¯”ç‰¹å¼€å§‹ï¼Œå¹¶ä¸”è¿™äº›é‡å­æ¯”ç‰¹å¤„äºï¼ˆ|00ã€‰ + |11ã€‰ï¼‰/ âˆš2çŠ¶æ€ï¼Œè¿™æ˜¯æˆ‘ä»¬åœ¨è¿™ç« ä¸­çœ‹åˆ°å‡ æ¬¡çš„çŠ¶æ€ï¼Œæˆ‘ä»¬å’ŒEveèƒ½æœ‰å¤šç»å¸¸è·èƒœã€‚ä¸ç”¨æ‹…å¿ƒå¦‚ä½•å‡†å¤‡è¿™ç§çŠ¶æ€ï¼›æˆ‘ä»¬å°†åœ¨ç¬¬6ç« ä¸­å­¦ä¹ å¦‚ä½•åšåˆ°è¿™ä¸€ç‚¹ã€‚ç°åœ¨ï¼Œè®©æˆ‘ä»¬çœ‹çœ‹ä¸€æ—¦æˆ‘ä»¬æœ‰äº†è¿™äº›é‡å­æ¯”ç‰¹ï¼Œæˆ‘ä»¬èƒ½ç”¨å®ƒä»¬åšä»€ä¹ˆã€‚
- en: Using these qubits, we can form a new quantum strategy for the CHSH game we
    saw at the start of the chapter. The trick is that we and Eve can each apply operations
    to each of our qubits once we get our respective messages from the referee.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿™äº›é‡å­æ¯”ç‰¹ï¼Œæˆ‘ä»¬å¯ä»¥ä¸ºæˆ‘ä»¬åœ¨æœ¬ç« å¼€å¤´çœ‹åˆ°çš„CHSHæ¸¸æˆå½¢æˆä¸€ä¸ªæ–°çš„é‡å­ç­–ç•¥ã€‚çªé—¨æ˜¯æˆ‘ä»¬å’ŒEveå¯ä»¥åœ¨ä»è£åˆ¤é‚£é‡Œå¾—åˆ°å„è‡ªçš„æ¶ˆæ¯åå¯¹å„è‡ªçš„æ¯ä¸ªé‡å­æ¯”ç‰¹åº”ç”¨æ“ä½œã€‚
- en: As it turns out, `ry` is a very useful operation for this strategy. It lets
    us and Eve trade off slightly between how often we win when the referee asks us
    to output the same answers (the 00, 01, and 10 cases) to do slightly better when
    we need to output different answers (the 11 case), as shown in figure 5.6.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: äº‹å®ä¸Šï¼Œ`ry`å¯¹äºè¿™ç§ç­–ç•¥éå¸¸æœ‰ç”¨ã€‚å®ƒè®©æˆ‘ä»¬å’ŒEveåœ¨è£åˆ¤è¦æ±‚æˆ‘ä»¬è¾“å‡ºç›¸åŒç­”æ¡ˆï¼ˆ00ã€01å’Œ10æƒ…å†µï¼‰çš„é¢‘ç‡ä¸Šç¨ä½œæƒè¡¡ï¼Œä»¥ä¾¿åœ¨éœ€è¦è¾“å‡ºä¸åŒç­”æ¡ˆï¼ˆ11æƒ…å†µï¼‰æ—¶è¡¨ç°å¾—æ›´å¥½ï¼Œå¦‚å›¾5.6æ‰€ç¤ºã€‚
- en: '![](../Images/5-6.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5-6.png)'
- en: Figure 5.6 Rotating qubits to win at CHSH. If we get a `0` from the referee,
    we should rotate our qubit by 45Â°; and if we get a `1`, we should rotate our qubit
    by 135Â°.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾5.6 é€šè¿‡æ—‹è½¬é‡å­æ¯”ç‰¹èµ¢å¾—CHSHæ¸¸æˆã€‚å¦‚æœæˆ‘ä»¬ä»è£åˆ¤é‚£é‡Œå¾—åˆ°ä¸€ä¸ª`0`ï¼Œæˆ‘ä»¬åº”è¯¥å°†æˆ‘ä»¬çš„é‡å­æ¯”ç‰¹æ—‹è½¬45Â°ï¼›å¦‚æœæˆ‘ä»¬å¾—åˆ°ä¸€ä¸ª`1`ï¼Œæˆ‘ä»¬åº”è¯¥å°†æˆ‘ä»¬çš„é‡å­æ¯”ç‰¹æ—‹è½¬135Â°ã€‚
- en: We can see from this strategy that both we and Eve have a pretty easy, straightforward
    rule for what to do with our respective qubits before we measure them. If we get
    a `0` from the referee, we should rotate our qubit by 45Â°; and if we get a `1`,
    we should rotate our qubit by 135Â°. If you like a table approach to this strategy,
    table 5.1 shows a summary.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ä»è¿™ä¸ªç­–ç•¥ä¸­æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œæˆ‘ä»¬å’ŒEveåœ¨æµ‹é‡ä¹‹å‰å¯¹å„è‡ªçš„é‡å­æ¯”ç‰¹è¦åšä»€ä¹ˆéƒ½æœ‰ä¸€ä¸ªç›¸å½“ç®€å•ã€ç›´æ¥çš„è§„å®šã€‚å¦‚æœæˆ‘ä»¬ä»è£åˆ¤é‚£é‡Œå¾—åˆ°ä¸€ä¸ª`0`ï¼Œæˆ‘ä»¬åº”è¯¥å°†æˆ‘ä»¬çš„é‡å­æ¯”ç‰¹æ—‹è½¬45Â°ï¼›å¦‚æœæˆ‘ä»¬å¾—åˆ°ä¸€ä¸ª`1`ï¼Œæˆ‘ä»¬åº”è¯¥å°†æˆ‘ä»¬çš„é‡å­æ¯”ç‰¹æ—‹è½¬135Â°ã€‚å¦‚æœæ‚¨å–œæ¬¢è¡¨æ ¼æ–¹æ³•æ¥å¤„ç†è¿™ä¸ªç­–ç•¥ï¼Œè¡¨5.1å±•ç¤ºäº†æ€»ç»“ã€‚
- en: Table 5.1 Rotations we and Eve will do to our qubits as a function of the input
    bit we receive from the referee. Note that they are all `ry` rotations, just by
    different angles (converted to radians for `ry`).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: è¡¨5.1 æˆ‘ä»¬å’ŒEveæ ¹æ®ä»è£åˆ¤é‚£é‡Œæ¥æ”¶åˆ°çš„è¾“å…¥æ¯”ç‰¹å¯¹æˆ‘ä»¬é‡å­æ¯”ç‰¹è¿›è¡Œçš„æ—‹è½¬ã€‚æ³¨æ„ï¼Œå®ƒä»¬éƒ½æ˜¯`ry`æ—‹è½¬ï¼Œåªæ˜¯è§’åº¦ä¸åŒï¼ˆè½¬æ¢ä¸ºå¼§åº¦ç”¨äº`ry`ï¼‰ã€‚
- en: '| Input from referee | Our rotation | Eveâ€™s rotation |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| è£åˆ¤çš„è¾“å…¥ | æˆ‘ä»¬çš„æ—‹è½¬ | Eveçš„æ—‹è½¬ |'
- en: '| 0 | `ry(90 * np.pi / 180)` | `ry(45 * np.pi / 180)` |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 0 | `ry(90 * np.pi / 180)` | `ry(45 * np.pi / 180)` |'
- en: '| 1 | `ry(0)` | `ry(135 * np.pi / 180)` |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 1 | `ry(0)` | `ry(135 * np.pi / 180)` |'
- en: Donâ€™t worry if these angles look random. We can check to see that they work
    using our new simulator! The next listing uses the new features we added to the
    simulator to write out a quantum strategy.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœè¿™äº›è§’åº¦çœ‹èµ·æ¥æ˜¯éšæœºçš„ï¼Œè¯·ä¸è¦æ‹…å¿ƒã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨æˆ‘ä»¬æ–°çš„æ¨¡æ‹Ÿå™¨æ¥æ£€æŸ¥å®ƒä»¬æ˜¯å¦æœ‰æ•ˆï¼ä¸‹ä¸€ä¸ªåˆ—è¡¨ä½¿ç”¨æˆ‘ä»¬æ·»åŠ åˆ°æ¨¡æ‹Ÿå™¨ä¸­çš„æ–°åŠŸèƒ½æ¥ç¼–å†™é‡å­ç­–ç•¥ã€‚
- en: 'Listing 5.14 chsh.py: a quantum CHSH strategy, using two qubits'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ 5.14 chsh.pyï¼šä¸€ä¸ªä½¿ç”¨ä¸¤ä¸ªé‡å­æ¯”ç‰¹çš„é‡å­ CHSH ç­–ç•¥
- en: '[PRE13]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: â¶ To start the quantum strategy, we need to create a QuantumDevice instance
    where we will simulate our qubits.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ è¦å¼€å§‹é‡å­ç­–ç•¥ï¼Œæˆ‘ä»¬éœ€è¦åˆ›å»ºä¸€ä¸ª QuantumDevice å®ä¾‹ï¼Œæˆ‘ä»¬å°†åœ¨è¿™ä¸ªå®ä¾‹ä¸­æ¨¡æ‹Ÿæˆ‘ä»¬çš„é‡å­æ¯”ç‰¹ã€‚
- en: â· Labels can be assigned to each qubit as we allocate them to the shared_system.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: â· æˆ‘ä»¬å¯ä»¥å°†æ ‡ç­¾åˆ†é…ç»™æ¯ä¸ªé‡å­æ¯”ç‰¹ï¼Œå°±åƒæˆ‘ä»¬å°†å®ƒä»¬åˆ†é…ç»™å…±äº«ç³»ç»Ÿä¸€æ ·ã€‚
- en: â¸ We cheat a little to set the state of our qubits to the entangled state (|00ã€‰
    + |11ã€‰) / âˆš2. We will see in chapter 6 how to prepare this state from scratch
    and why the function to prepare this state is called bell_state.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: â¸ æˆ‘ä»¬ç¨å¾®ä½œå¼Šä¸€ä¸‹ï¼Œå°†æˆ‘ä»¬çš„é‡å­æ¯”ç‰¹çš„çŠ¶æ€è®¾ç½®ä¸ºçº ç¼ æ€ï¼ˆ|00ã€‰ + |11ã€‰ï¼‰/ âˆš2ã€‚æˆ‘ä»¬å°†åœ¨ç¬¬ 6 ç« ä¸­çœ‹åˆ°å¦‚ä½•ä»å¤´å¼€å§‹åˆ¶å¤‡è¿™ä¸ªçŠ¶æ€ï¼Œä»¥åŠä¸ºä»€ä¹ˆåˆ¶å¤‡è¿™ä¸ªçŠ¶æ€çš„å‡½æ•°è¢«ç§°ä¸º
    bell_stateã€‚
- en: â¹ Angles for the rotations we and Eve need to do based on our input from the
    referee
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: â¹ æˆ‘ä»¬å’Œæ¬§å¨ƒéœ€è¦æ ¹æ®è£åˆ¤çš„è¾“å…¥è¿›è¡Œçš„æ—‹è½¬è§’åº¦
- en: âº Strategy for playing the CHSH game starts with us rotating our qubit based
    on the input classical bit from the referee.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: âº ç© CHSH æ¸¸æˆçš„ç­–ç•¥å§‹äºæˆ‘ä»¬æ ¹æ®è£åˆ¤è¾“å…¥çš„ç»å…¸æ¯”ç‰¹æ—‹è½¬æˆ‘ä»¬çš„é‡å­æ¯”ç‰¹ã€‚
- en: â» The classical bit value our strategy returns is the bit value we get when
    we measure our qubit.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: â» æˆ‘ä»¬ç­–ç•¥è¿”å›çš„ç»å…¸æ¯”ç‰¹å€¼æ˜¯æˆ‘ä»¬æµ‹é‡é‡å­æ¯”ç‰¹æ—¶å¾—åˆ°çš„æ¯”ç‰¹å€¼ã€‚
- en: â¼ Eveâ€™s strategy is similar to ours; she just uses different angles for her
    initial rotation.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: â¼ æ¬§å¨ƒçš„ç­–ç•¥ä¸æˆ‘ä»¬çš„ç±»ä¼¼ï¼›å¥¹åªæ˜¯å¯¹åˆå§‹æ—‹è½¬ä½¿ç”¨äº†ä¸åŒçš„è§’åº¦ã€‚
- en: â½ Just like our classical strategy, quantum_strategy returns a tuple of functions
    that represent our and Eveâ€™s individual actions.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: â½ å°±åƒæˆ‘ä»¬çš„ç»å…¸ç­–ç•¥ä¸€æ ·ï¼Œquantum_strategy è¿”å›ä¸€ä¸ªè¡¨ç¤ºæˆ‘ä»¬å’Œæ¬§å¨ƒå„è‡ªè¡ŒåŠ¨çš„å‡½æ•°å…ƒç»„ã€‚
- en: Now that we have implemented a Python version of `quantum_strategy`, letâ€™s see
    how often we can win by using our CHSH game `est_win_probability` function.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å·²ç»å®ç°äº† `quantum_strategy` çš„ Python ç‰ˆæœ¬ï¼Œè®©æˆ‘ä»¬çœ‹çœ‹æˆ‘ä»¬ä½¿ç”¨ CHSH æ¸¸æˆçš„ `est_win_probability`
    å‡½æ•°å¯ä»¥èµ¢å¤šå°‘æ¬¡ã€‚
- en: Listing 5.15 Running CHSH with our new `quantum_strategy`
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ 5.15 è¿è¡Œ CHSH ä½¿ç”¨æˆ‘ä»¬çš„æ–° `quantum_strategy`
- en: '[PRE14]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: â¶ You may get slightly more or less than 85% when you try this, because the
    win probability is estimated under the hood using a binomial distribution. For
    this example, weâ€™d expect error bars of about 1.5%.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ å½“ä½ å°è¯•è¿™ä¸ªæ—¶ï¼Œä½ å¯èƒ½å¾—åˆ°ç•¥å¤šäºæˆ–å°‘äº 85%ï¼Œå› ä¸ºè·èƒœæ¦‚ç‡æ˜¯åœ¨å¹•åä½¿ç”¨äºŒé¡¹åˆ†å¸ƒä¼°è®¡çš„ã€‚å¯¹äºè¿™ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬é¢„è®¡è¯¯å·®æ¡çº¦ä¸º 1.5%ã€‚
- en: The estimated win probability of 83.2% in listing 5.15 is higher than what we
    can get with any classical strategy. This means that we and Eve can start winning
    the CHSH game more frequently than any other classical playersâ€”awesome! What this
    strategy shows, though, is an example of how states like (|00ã€‰ + |11ã€‰) / âˆš2 are
    important resources provided by quantum mechanics.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ 5.15 ä¸­ä¼°è®¡çš„ 83.2% çš„è·èƒœæ¦‚ç‡é«˜äºæˆ‘ä»¬ä½¿ç”¨ä»»ä½•ç»å…¸ç­–ç•¥æ‰€èƒ½è·å¾—çš„æ¦‚ç‡ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬å’Œæ¬§å¨ƒå¯ä»¥æ¯”ä»»ä½•å…¶ä»–ç»å…¸ç©å®¶æ›´é¢‘ç¹åœ°èµ¢å¾— CHSH
    æ¸¸æˆâ€”â€”å¤ªæ£’äº†ï¼ç„¶è€Œï¼Œè¿™ä¸ªç­–ç•¥å±•ç¤ºçš„æ˜¯åƒï¼ˆ|00ã€‰ + |11ã€‰ï¼‰/ âˆš2 è¿™æ ·çš„æ€æ˜¯é‡å­åŠ›å­¦æä¾›çš„é‡è¦èµ„æºçš„ä¸€ä¸ªä¾‹å­ã€‚
- en: Note States like (|00ã€‰ + |11ã€‰) / âˆš2 are called *entangled* because they canâ€™t
    be written as the tensor product of single-qubit states. Weâ€™ll see many more examples
    of entanglement as we go along, but entanglement is one of the most amazing and
    fun things that we get to use in writing quantum programs.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œåƒï¼ˆ|00ã€‰ + |11ã€‰ï¼‰/ âˆš2 è¿™æ ·çš„æ€è¢«ç§°ä¸º *çº ç¼ *ï¼Œå› ä¸ºå®ƒä»¬ä¸èƒ½å†™æˆå•ä¸ªé‡å­æ¯”ç‰¹æ€çš„å¼ é‡ç§¯ã€‚éšç€æˆ‘ä»¬çš„æ·±å…¥ï¼Œæˆ‘ä»¬å°†çœ‹åˆ°æ›´å¤šçº ç¼ çš„ä¾‹å­ï¼Œä½†çº ç¼ æ˜¯æˆ‘ä»¬èƒ½å¤Ÿåœ¨ç¼–å†™é‡å­ç¨‹åºæ—¶ä½¿ç”¨çš„æœ€ç¥å¥‡å’Œæœ‰è¶£çš„äº‹æƒ…ä¹‹ä¸€ã€‚
- en: As we saw in this example, entanglement allows us to create correlations in
    our data that can be used to our advantage when we want to get useful information
    out of our quantum systems.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚æˆ‘ä»¬åœ¨æœ¬ä¾‹ä¸­æ‰€è§ï¼Œçº ç¼ ä½¿æˆ‘ä»¬èƒ½å¤Ÿåœ¨æˆ‘ä»¬æƒ³è¦ä»é‡å­ç³»ç»Ÿä¸­è·å–æœ‰ç”¨ä¿¡æ¯æ—¶ï¼Œåˆ›å»ºå¯ä»¥åˆ©ç”¨çš„æ•°æ®ç›¸å…³æ€§ã€‚
- en: The speed of light is still a thing
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: å…‰é€Ÿä»ç„¶æ˜¯ä¸€ä¸ªä¸œè¥¿
- en: If youâ€™ve read about relativity (if you havenâ€™t, no worries), you may have heard
    that itâ€™s impossible to send information faster than the speed of light. It may
    seem from what weâ€™ve learned about entanglement so far that quantum mechanics
    violates this, but as it turns out, entanglement can *never* be used on its own
    to communicate a message of our choosing. We always need to send something else
    along with using entanglement. This means the speed of light still constrains
    how fast information can travel through the universeâ€”phew!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ è¯»è¿‡å…³äºç›¸å¯¹è®ºçš„å†…å®¹ï¼ˆå¦‚æœä½ æ²¡æœ‰ï¼Œæ²¡å…³ç³»ï¼‰ï¼Œä½ å¯èƒ½å¬è¯´è¿‡ä¸å¯èƒ½ä»¥è¶…è¿‡å…‰é€Ÿçš„é€Ÿåº¦å‘é€ä¿¡æ¯ã€‚ä»æˆ‘ä»¬ç›®å‰å¯¹çº ç¼ çš„äº†è§£æ¥çœ‹ï¼Œé‡å­åŠ›å­¦ä¼¼ä¹è¿åäº†è¿™ä¸€ç‚¹ï¼Œä½†äº‹å®ä¸Šï¼Œçº ç¼ *æ°¸è¿œ*ä¸èƒ½å•ç‹¬ç”¨æ¥å‘é€æˆ‘ä»¬é€‰æ‹©çš„æ¶ˆæ¯ã€‚æˆ‘ä»¬æ€»æ˜¯éœ€è¦åœ¨ä½¿ç”¨çº ç¼ çš„åŒæ—¶å‘é€å…¶ä»–ä¸œè¥¿ã€‚è¿™æ„å‘³ç€å…‰é€Ÿä»ç„¶é™åˆ¶äº†ä¿¡æ¯åœ¨å®‡å®™ä¸­ä¼ æ’­çš„é€Ÿåº¦â€”â€”è°¢å¤©è°¢åœ°ï¼
- en: 'Far from being strange or weird, entanglement is a direct result of what weâ€™ve
    already learned about quantum computing: it is a direct consequence of quantum
    mechanics being *linear*. If we can prepare a two-qubit register in the |00ã€‰ state
    and the |11ã€‰ state, then we can also prepare a state in a linear combination of
    the two, such as (|00ã€‰ + |11ã€‰) / âˆš2.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: çº ç¼ è¿œéå¥‡æ€ªæˆ–å¥‡æ€ªï¼Œå®ƒæ˜¯æˆ‘ä»¬å…³äºé‡å­è®¡ç®—å·²ç»å­¦åˆ°çš„å†…å®¹çš„ç›´æ¥ç»“æœï¼šå®ƒæ˜¯é‡å­åŠ›å­¦*çº¿æ€§*çš„ç›´æ¥åæœã€‚å¦‚æœæˆ‘ä»¬èƒ½å¤Ÿå‡†å¤‡ä¸€ä¸ªå¤„äº|00ã€‰çŠ¶æ€å’Œ|11ã€‰çŠ¶æ€çš„äºŒé‡å­æ¯”ç‰¹å¯„å­˜å™¨ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä¹Ÿå¯ä»¥å‡†å¤‡ä¸€ä¸ªè¿™ä¸¤ä¸ªçŠ¶æ€çš„çº¿æ€§ç»„åˆçŠ¶æ€ï¼Œä¾‹å¦‚ï¼ˆ|00ã€‰
    + |11ã€‰ï¼‰/ âˆš2ã€‚
- en: Since entanglement is a direct result of the linearity of quantum mechanics,
    the CHSH game also gives us a great way to check that quantum mechanics is really
    correct (or to the best our data can show). Letâ€™s go back to the win probability
    in listing 5.15\. If we do an *experiment*, and we see something like an 83.2%
    win probability, that tells us our experiment couldnâ€™t have been purely classical
    since we know a classical strategy can *at most* win 75% of the time. This experiment
    has been done many times throughout history and is part of how we know that our
    universe isnâ€™t just classicalâ€”we need quantum mechanics to describe it.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºçº ç¼ æ˜¯é‡å­åŠ›å­¦çº¿æ€§çš„ç›´æ¥ç»“æœï¼ŒCHSHæ¸¸æˆä¹Ÿä¸ºæˆ‘ä»¬æä¾›äº†ä¸€ä¸ªå¾ˆå¥½çš„æ–¹æ³•æ¥æ£€æŸ¥é‡å­åŠ›å­¦æ˜¯å¦çœŸçš„æ­£ç¡®ï¼ˆæˆ–è€…æˆ‘ä»¬çš„æ•°æ®æ‰€èƒ½æ˜¾ç¤ºçš„æœ€å¥½ï¼‰ã€‚è®©æˆ‘ä»¬å›åˆ°åˆ—è¡¨5.15ä¸­çš„èƒœç‡ã€‚å¦‚æœæˆ‘ä»¬è¿›è¡Œä¸€ä¸ª*å®éªŒ*ï¼Œå¹¶ä¸”çœ‹åˆ°å¤§çº¦83.2%çš„èƒœç‡ï¼Œè¿™å‘Šè¯‰æˆ‘ä»¬æˆ‘ä»¬çš„å®éªŒä¸å¯èƒ½å®Œå…¨æ˜¯ç»å…¸çš„ï¼Œå› ä¸ºæˆ‘ä»¬çŸ¥é“ç»å…¸ç­–ç•¥æœ€å¤šåªèƒ½èµ¢75%çš„æ—¶é—´ã€‚è¿™ä¸ªå®éªŒåœ¨å†å²ä¸Šå·²ç»è¿›è¡Œäº†å¾ˆå¤šæ¬¡ï¼Œä¹Ÿæ˜¯æˆ‘ä»¬äº†è§£æˆ‘ä»¬çš„å®‡å®™ä¸ä»…ä»…æ˜¯ç»å…¸çš„åŸå› ä¹‹ä¸€â€”â€”æˆ‘ä»¬éœ€è¦é‡å­åŠ›å­¦æ¥æè¿°å®ƒã€‚
- en: Note In 2015, one experiment had the two players in the CHSH game separated
    by more than a kilometer!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼šåœ¨2015å¹´ï¼ŒCHSHæ¸¸æˆä¸­çš„ä¸¤ä¸ªç©å®¶ç›¸éš”è¶…è¿‡ä¸€å…¬é‡Œï¼
- en: 'Self-testing: An application for nonlocal games'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: è‡ªæµ‹è¯•ï¼šéå±€åŸŸæ¸¸æˆçš„åº”ç”¨
- en: 'This hints at another application for nonlocal games: if we can play *and win*
    a nonlocal game with Eve, then along the way, we must have built something we
    can use to send quantum data. This sort of insight leads to ideas known as *quantum
    self-testing*, where we make parts of a device play nonlocal games with other
    parts of the device to make sure the device works correctly.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æš—ç¤ºäº†éå±€åŸŸæ¸¸æˆçš„ä¸€ä¸ªåº”ç”¨ï¼šå¦‚æœæˆ‘ä»¬èƒ½å¤Ÿä¸Eveä¸€èµ·ç©å¹¶èµ¢å¾—ä¸€ä¸ªéå±€åŸŸæ¸¸æˆï¼Œé‚£ä¹ˆåœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬å¿…é¡»å·²ç»æ„å»ºäº†ä¸€äº›æˆ‘ä»¬å¯ä»¥ç”¨æ¥å‘é€é‡å­æ•°æ®çš„ä¸œè¥¿ã€‚è¿™ç§æ´å¯ŸåŠ›å¯¼è‡´äº†ä¸€äº›è¢«ç§°ä¸º*é‡å­è‡ªæµ‹è¯•*çš„æƒ³æ³•ï¼Œå…¶ä¸­æˆ‘ä»¬è®©è®¾å¤‡çš„ä¸€éƒ¨åˆ†ä¸å…¶ä»–éƒ¨åˆ†ç©éå±€åŸŸæ¸¸æˆï¼Œä»¥ç¡®ä¿è®¾å¤‡æ­£å¸¸å·¥ä½œã€‚
- en: The simulator that we wrote in this chapter gives us everything we need to see
    how those kinds of experiments work. Now we can plow ahead to use quantum mechanics
    and qubits to do awesome stuff, armed with the knowledge that quantum mechanics
    really is how our universe works.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬ç« ä¸­æˆ‘ä»¬ç¼–å†™çš„æ¨¡æ‹Ÿå™¨ä¸ºæˆ‘ä»¬æä¾›äº†è§‚å¯Ÿé‚£äº›å®éªŒå¦‚ä½•å·¥ä½œçš„æ‰€æœ‰å¿…è¦ä¿¡æ¯ã€‚ç°åœ¨æˆ‘ä»¬å¯ä»¥ç»§ç»­ä½¿ç”¨é‡å­åŠ›å­¦å’Œé‡å­æ¯”ç‰¹æ¥åšä¸€äº›å¾ˆé…·çš„äº‹æƒ…ï¼ŒåŒæ—¶æˆ‘ä»¬çŸ¥é“é‡å­åŠ›å­¦ç¡®å®æ˜¯æˆ‘ä»¬çš„å®‡å®™è¿ä½œçš„æ–¹å¼ã€‚
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: æ‘˜è¦
- en: We can use the QuTiP package to help us work with tensor products and other
    computations we need to write a multi-qubit simulator in Python.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥ä½¿ç”¨QuTiPåŒ…æ¥å¸®åŠ©æˆ‘ä»¬å¤„ç†å¼ é‡ç§¯å’Œå…¶ä»–æˆ‘ä»¬éœ€è¦åœ¨Pythonä¸­ç¼–å†™å¤šé‡å­æ¯”ç‰¹æ¨¡æ‹Ÿå™¨çš„è®¡ç®—ã€‚
- en: The `Qobj` class in QuTiP tracks many useful properties of the states and operators
    we want to simulate.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QuTiPä¸­çš„`Qobj`ç±»è·Ÿè¸ªäº†æˆ‘ä»¬æƒ³è¦æ¨¡æ‹Ÿçš„çŠ¶æ€å’Œç®—ç¬¦çš„è®¸å¤šæœ‰ç”¨å±æ€§ã€‚
- en: We and Eve can use a quantum strategy to play the CHSH game, where we share
    a pair of entangled qubits before we start playing the game.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å’ŒEveå¯ä»¥ä½¿ç”¨é‡å­ç­–ç•¥æ¥ç©CHSHæ¸¸æˆï¼Œåœ¨æˆ‘ä»¬å¼€å§‹ç©æ¸¸æˆä¹‹å‰ï¼Œæˆ‘ä»¬å…±äº«ä¸€å¯¹çº ç¼ é‡å­æ¯”ç‰¹ã€‚
- en: By writing the CHSH game as a quantum program, we can prove that players using
    entangled pairs of qubits can win more often than players that only use classical
    computers, which is consistent with our understanding of quantum mechanics.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: é€šè¿‡å°†CHSHæ¸¸æˆç¼–å†™æˆä¸€ä¸ªé‡å­ç¨‹åºï¼Œæˆ‘ä»¬å¯ä»¥è¯æ˜ä½¿ç”¨çº ç¼ é‡å­æ¯”ç‰¹å¯¹çš„ç©å®¶æ¯”åªä½¿ç”¨ç»å…¸è®¡ç®—æœºçš„ç©å®¶èµ¢çš„æ¬¡æ•°æ›´å¤šï¼Œè¿™ä¸æˆ‘ä»¬å¯¹é‡å­åŠ›å­¦çš„ç†è§£æ˜¯ä¸€è‡´çš„ã€‚
