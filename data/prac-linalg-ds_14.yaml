- en: Chapter 14\. Singular Value Decomposition
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç¬¬ 14 ç« . å¥‡å¼‚å€¼åˆ†è§£
- en: The previous chapter was really dense! I tried my best to make it comprehensible
    and rigorous, without getting too bogged down in details that have less relevance
    for data science.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸Šä¸€ç« çœŸçš„å¾ˆå¯†é›†ï¼æˆ‘å°½åŠ›ä½¿å…¶æ˜“äºç†è§£å’Œä¸¥è°¨ï¼Œè€Œä¸è‡³äºé™·å…¥å¯¹æ•°æ®ç§‘å­¦å°‘ç›¸å…³çš„ç»†èŠ‚ä¸­ã€‚
- en: Fortunately, most of what you learned about eigendecomposition applies to the
    SVD. That means that this chapter will be easier and shorter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: å¹¸è¿çš„æ˜¯ï¼Œå¤§éƒ¨åˆ†ä½ å­¦åˆ°çš„å…³äºç‰¹å¾åˆ†è§£çš„å†…å®¹éƒ½é€‚ç”¨äºå¥‡å¼‚å€¼åˆ†è§£ã€‚è¿™æ„å‘³ç€æœ¬ç« ä¼šæ›´å®¹æ˜“ä¹Ÿæ›´ç®€çŸ­ã€‚
- en: 'The purpose of the SVD is to decompose a matrix into the product of three matrices,
    called the left singular vectors ( <math alttext="bold upper U"><mi>ğ”</mi></math>
    ), the singular values (<math alttext="bold upper Sigma"><mi mathvariant="bold">Î£</mi></math>),
    and the right singular vectors ( <math alttext="bold upper V"><mi>ğ•</mi></math>
    ):'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: å¥‡å¼‚å€¼åˆ†è§£çš„ç›®çš„æ˜¯å°†çŸ©é˜µåˆ†è§£ä¸ºä¸‰ä¸ªçŸ©é˜µçš„ä¹˜ç§¯ï¼Œç§°ä¸ºå·¦å¥‡å¼‚å‘é‡ï¼ˆ <math alttext="ç²—ä½“å¤§å†™ U"><mi>ğ”</mi></math> ï¼‰ã€å¥‡å¼‚å€¼ï¼ˆ<math
    alttext="ç²—ä½“å¤§å†™ Sigma"><mi mathvariant="bold">Î£</mi></math>ï¼‰å’Œå³å¥‡å¼‚å‘é‡ï¼ˆ <math alttext="ç²—ä½“å¤§å†™
    V"><mi>ğ•</mi></math> ï¼‰ï¼š
- en: <math alttext="bold upper A equals bold upper U bold upper Sigma bold upper
    V Superscript upper T" display="block"><mrow><mi mathvariant="bold">A</mi> <mo>=</mo>
    <mi mathvariant="bold">U</mi> <mi mathvariant="bold">Î£</mi> <msup><mi mathvariant="bold">V</mi>
    <mtext>T</mtext></msup></mrow></math>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="bold upper A equals bold upper U bold upper Sigma bold upper
    V Superscript upper T" display="block"><mrow><mi mathvariant="bold">A</mi> <mo>=</mo>
    <mi mathvariant="bold">U</mi> <mi mathvariant="bold">Î£</mi> <msup><mi mathvariant="bold">V</mi>
    <mtext>T</mtext></msup></mrow></math>
- en: This decomposition should look similar to eigendecomposition. In fact, you can
    think of the SVD as a generalization of eigendecomposition to nonsquare matricesâ€”or
    you can think of eigendecomposition as a special case of the SVD for square matrices.^([1](ch14.xhtml#idm45733291549488))
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§åˆ†è§£çœ‹èµ·æ¥ç±»ä¼¼äºç‰¹å¾åˆ†è§£ã€‚äº‹å®ä¸Šï¼Œä½ å¯ä»¥æŠŠå¥‡å¼‚å€¼åˆ†è§£çœ‹ä½œæ˜¯å¯¹éæ–¹é˜µçš„ç‰¹å¾åˆ†è§£çš„ä¸€èˆ¬åŒ–ï¼Œæˆ–è€…ä½ å¯ä»¥æŠŠç‰¹å¾åˆ†è§£çœ‹ä½œæ˜¯å¥‡å¼‚å€¼åˆ†è§£åœ¨æ–¹é˜µæƒ…å†µä¸‹çš„ç‰¹æ®Šæƒ…å†µã€‚^([1](ch14.xhtml#idm45733291549488))
- en: The singular values are comparable to eigenvalues, while the singular vectors
    matrices are comparable to eigenvectors (these two sets of quantities are the
    same under some circumstances that I will explain later).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: å¥‡å¼‚å€¼å¯ä¸ç‰¹å¾å€¼ç›¸æ¯”è¾ƒï¼Œè€Œå¥‡å¼‚å‘é‡çŸ©é˜µåˆ™ä¸ç‰¹å¾å‘é‡å¯æ¯”è¾ƒï¼ˆåœ¨æŸäº›æƒ…å†µä¸‹è¿™ä¸¤ç»„é‡æ˜¯ç›¸åŒçš„ï¼Œæˆ‘ç¨åä¼šè§£é‡Šï¼‰ã€‚
- en: The Big Picture of the SVD
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å¥‡å¼‚å€¼åˆ†è§£çš„å…¨å±€è§†è§’
- en: I want to introduce you to the idea and interpretation of the matrices, and
    then later in the chapter I will explain how to compute the SVD.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘æƒ³å…ˆè®©ä½ äº†è§£çŸ©é˜µçš„æ¦‚å¿µå’Œè§£é‡Šï¼Œç„¶ååœ¨æœ¬ç« åé¢è§£é‡Šå¦‚ä½•è®¡ç®—å¥‡å¼‚å€¼åˆ†è§£ã€‚
- en: '[FigureÂ 14-1](#fig_14_1) shows the overview of the SVD.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[å›¾Â 14-1](#fig_14_1) æ˜¾ç¤ºäº†å¥‡å¼‚å€¼åˆ†è§£çš„æ¦‚è§ˆã€‚'
- en: '![The SVD](assets/plad_1401.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![å¥‡å¼‚å€¼åˆ†è§£](assets/plad_1401.png)'
- en: Figure 14-1\. The big picture of the SVD
  id: totrans-11
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾ 14-1. å¥‡å¼‚å€¼åˆ†è§£çš„å…¨å±€è§†è§’
- en: 'Many important features of the SVD are visible in this diagram; I will go into
    these features in more detail throughout this chapter, but to put them into a
    list:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™å¼ å›¾ä¸­å¯ä»¥çœ‹åˆ°å¥‡å¼‚å€¼åˆ†è§£çš„è®¸å¤šé‡è¦ç‰¹æ€§ï¼›æˆ‘å°†åœ¨æœ¬ç« ä¸­æ›´è¯¦ç»†åœ°è§£é‡Šè¿™äº›ç‰¹æ€§ï¼Œä½†å…ˆç®€è¦åˆ—ä¸¾ä¸€ä¸‹ï¼š
- en: Both <math alttext="bold upper U"><mi>ğ”</mi></math> and <math alttext="bold
    upper V"><mi>ğ•</mi></math> are square matrices, even when <math alttext="bold
    upper A"><mi>ğ€</mi></math> is nonsquare.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <math alttext="ç²—ä½“å¤§å†™ U"><mi>ğ”</mi></math> å’Œ <math alttext="ç²—ä½“å¤§å†™ V"><mi>ğ•</mi></math>
    éƒ½æ˜¯æ–¹é˜µï¼Œå³ä½¿ <math alttext="ç²—ä½“å¤§å†™ A"><mi>ğ€</mi></math> ä¸æ˜¯æ–¹é˜µã€‚
- en: The matrices of singular vectors <math alttext="bold upper U"><mi>ğ”</mi></math>
    and <math alttext="bold upper V"><mi>ğ•</mi></math> are orthogonal, meaning <math
    alttext="bold upper U Superscript upper T Baseline bold upper U equals bold upper
    I"><mrow><msup><mi>ğ”</mi> <mtext>T</mtext></msup> <mi>ğ”</mi> <mo>=</mo> <mi>ğˆ</mi></mrow></math>
    and <math alttext="bold upper V Superscript upper T Baseline bold upper V equals
    bold upper I"><mrow><msup><mi>ğ•</mi> <mtext>T</mtext></msup> <mi>ğ•</mi> <mo>=</mo>
    <mi>ğˆ</mi></mrow></math> . As a reminder, this means that each column is orthogonal
    to each other column, and any subset of columns is orthogonal to any other (nonoverlapping)
    subset of columns.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¥‡å¼‚å‘é‡çŸ©é˜µ <math alttext="ç²—ä½“å¤§å†™ U"><mi>ğ”</mi></math> å’Œ <math alttext="ç²—ä½“å¤§å†™ V"><mi>ğ•</mi></math>
    æ˜¯æ­£äº¤çš„ï¼Œæ„å‘³ç€ <math alttext="ç²—ä½“å¤§å†™ U ä¸Šæ ‡ T ä¸Šæ ‡ bold upper U ç­‰äº bold upper I"><mrow><msup><mi>ğ”</mi>
    <mtext>T</mtext></msup> <mi>ğ”</mi> <mo>=</mo> <mi>ğˆ</mi></mrow></math> å’Œ <math
    alttext="ç²—ä½“å¤§å†™ V ä¸Šæ ‡ T ä¸Šæ ‡ bold upper V ç­‰äº bold upper I"><mrow><msup><mi>ğ•</mi> <mtext>T</mtext></msup>
    <mi>ğ•</mi> <mo>=</mo> <mi>ğˆ</mi></mrow></math> ã€‚æé†’ä¸€ä¸‹ï¼Œè¿™æ„å‘³ç€æ¯ä¸€åˆ—éƒ½ä¸å…¶ä»–åˆ—æ­£äº¤ï¼Œä¸”ä»»ä½•ä¸€ä¸ªåˆ—å­é›†ä¸ä»»ä½•å…¶ä»–ï¼ˆéé‡å ï¼‰åˆ—å­é›†ä¹Ÿæ­£äº¤ã€‚
- en: The first *r* columns of <math alttext="bold upper U"><mi>ğ”</mi></math> provide
    orthogonal basis vectors for the column space of the matrix <math alttext="bold
    upper A"><mi>ğ€</mi></math> , while the rest of the columns provide orthogonal
    basis vectors for the left-null space (unless *r* = *M*, in which case the matrix
    is full column-rank and the left-null space is empty).
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <math alttext="ç²—ä½“å¤§å†™ U"><mi>ğ”</mi></math> çš„å‰ *r* åˆ—æä¾›äº†çŸ©é˜µ <math alttext="ç²—ä½“å¤§å†™ A"><mi>ğ€</mi></math>
    çš„åˆ—ç©ºé—´çš„æ­£äº¤åŸºå‘é‡ï¼Œè€Œå…¶ä½™åˆ—åˆ™æä¾›äº†å·¦é›¶ç©ºé—´çš„æ­£äº¤åŸºå‘é‡ï¼ˆé™¤é *r* = *M*ï¼Œæ­¤æ—¶çŸ©é˜µå…·æœ‰æ»¡åˆ—ç§©ä¸”å·¦é›¶ç©ºé—´ä¸ºç©ºï¼‰ã€‚
- en: The first *r* rows of <math alttext="bold upper V Superscript upper T"><msup><mi>ğ•</mi>
    <mtext>T</mtext></msup></math> (which are the columns of <math alttext="bold upper
    V"><mi>ğ•</mi></math> ) provide orthogonal basis vectors for the row space, while
    the rest of the rows provide orthogonal basis vectors for the null space.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <math alttext="bold upper V Superscript upper T"><msup><mi>ğ•</mi> <mtext>T</mtext></msup></math>
    çš„å‰*r*è¡Œï¼ˆå³<math alttext="bold upper V"><mi>ğ•</mi></math> çš„åˆ—ï¼‰ä¸ºè¡Œç©ºé—´æä¾›æ­£äº¤åŸºå‘é‡ï¼Œè€Œå…¶ä½™è¡Œä¸ºé›¶ç©ºé—´æä¾›æ­£äº¤åŸºå‘é‡ã€‚
- en: The singular values matrix is a diagonal matrix of the same size as <math alttext="bold
    upper A"><mi>ğ€</mi></math> . The singular values are always sorted from largest
    (top-left) to smallest (lower-right).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¥‡å¼‚å€¼çŸ©é˜µæ˜¯ä¸<math alttext="bold upper A"><mi>ğ€</mi></math>ç›¸åŒå¤§å°çš„å¯¹è§’çŸ©é˜µã€‚å¥‡å¼‚å€¼å§‹ç»ˆæŒ‰ä»æœ€å¤§ï¼ˆå·¦ä¸Šè§’ï¼‰åˆ°æœ€å°ï¼ˆå³ä¸‹è§’ï¼‰æ’åºã€‚
- en: All singular values are nonnegative and real-valued. They cannot be complex
    or negative, even if the matrix contains complex-valued numbers.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ‰€æœ‰å¥‡å¼‚å€¼éƒ½æ˜¯éè´Ÿå®æ•°ã€‚å®ƒä»¬ä¸èƒ½æ˜¯å¤æ•°æˆ–è´Ÿæ•°ï¼Œå³ä½¿çŸ©é˜µåŒ…å«å¤æ•°ã€‚
- en: The number of nonzero singular values equals the matrix rank.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: éé›¶å¥‡å¼‚å€¼çš„æ•°é‡ç­‰äºçŸ©é˜µçš„ç§©ã€‚
- en: 'Perhaps the most amazing thing about the SVD is that it reveals all four subspaces
    of the matrix: the column space and left-null space are spanned by the first *r*
    and last *M* âˆ’ *r* through *M* columns of <math alttext="bold upper U"><mi>ğ”</mi></math>
    , while the row space and null space are spanned by the first *r* and last *N*
    âˆ’ *r* through *N* rows of <math alttext="bold upper V Superscript upper T"><msup><mi>ğ•</mi>
    <mtext>T</mtext></msup></math> . For a rectangular matrix, if *r* = *M*, then
    the left-null space is empty, and if *r* = *N*, then the null space is empty.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ–è®¸SVDæœ€æƒŠäººçš„åœ°æ–¹åœ¨äºå®ƒæ­ç¤ºäº†çŸ©é˜µçš„å››ä¸ªå­ç©ºé—´ï¼šåˆ—ç©ºé—´å’Œå·¦ç©ºé—´ç”±<math alttext="bold upper U"><mi>ğ”</mi></math>çš„å‰*r*åˆ—å’Œæœ€å*M*
    âˆ’ *r*åˆ°*M*åˆ—ï¼Œè€Œè¡Œç©ºé—´å’Œé›¶ç©ºé—´ç”±<math alttext="bold upper V Superscript upper T"><msup><mi>ğ•</mi>
    <mtext>T</mtext></msup></math> çš„å‰*r*è¡Œå’Œæœ€å*N* âˆ’ *r*åˆ°*N*è¡Œæä¾›ã€‚å¯¹äºçŸ©å½¢çŸ©é˜µï¼Œå¦‚æœ*r* = *M*ï¼Œåˆ™å·¦ç©ºé—´ä¸ºç©ºï¼Œå¦‚æœ*r*
    = *N*ï¼Œåˆ™é›¶ç©ºé—´ä¸ºç©ºã€‚
- en: Singular Values and Matrix Rank
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å¥‡å¼‚å€¼ä¸çŸ©é˜µçš„ç§©
- en: The rank of a matrix is defined as the number of nonzero singular values. The
    reason comes from the previous discussion that the column space and the row space
    of the matrix are defined as the left and right singular vectors that are scaled
    by their corresponding singular values to have some â€œvolumeâ€ in the matrix space,
    whereas the left and right null spaces are defined as the left and right singular
    vectors that are scaled to zeros. Thus, the dimensionality of the column and row
    spaces are determined by the number of nonzero singular values.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: çŸ©é˜µçš„ç§©è¢«å®šä¹‰ä¸ºéé›¶å¥‡å¼‚å€¼çš„æ•°é‡ã€‚è¿™ä¸ªåŸå› æ¥è‡ªäºå‰é¢çš„è®¨è®ºï¼Œå³çŸ©é˜µçš„åˆ—ç©ºé—´å’Œè¡Œç©ºé—´è¢«å®šä¹‰ä¸ºé€šè¿‡å®ƒä»¬å¯¹åº”çš„å¥‡å¼‚å€¼è¿›è¡Œç¼©æ”¾ä»¥åœ¨çŸ©é˜µç©ºé—´ä¸­å…·æœ‰ä¸€å®šâ€œä½“ç§¯â€çš„å·¦å¥‡å¼‚å‘é‡å’Œå³å¥‡å¼‚å‘é‡ï¼Œè€Œå·¦ç©ºé—´å’Œå³ç©ºé—´è¢«å®šä¹‰ä¸ºé€šè¿‡å®ƒä»¬è¿›è¡Œç¼©æ”¾ä¸ºé›¶çš„å·¦å¥‡å¼‚å‘é‡å’Œå³å¥‡å¼‚å‘é‡ã€‚å› æ­¤ï¼Œåˆ—ç©ºé—´å’Œè¡Œç©ºé—´çš„ç»´æ•°ç”±éé›¶å¥‡å¼‚å€¼çš„æ•°é‡å†³å®šã€‚
- en: 'In fact, we can peer into the NumPy function `np.linalg.matrix_rank` to see
    how Python computes matrix rank (Iâ€™ve edited the code slightly to focus on the
    key concepts):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: å®é™…ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥æŸ¥çœ‹NumPyå‡½æ•°`np.linalg.matrix_rank`æ¥çœ‹Pythonå¦‚ä½•è®¡ç®—çŸ©é˜µçš„ç§©ï¼ˆæˆ‘ç¨ä½œä¿®æ”¹ä»¥ä¾¿ä¸“æ³¨äºå…³é”®æ¦‚å¿µï¼‰ï¼š
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The returned value is the number of singular values that exceed the value of
    `tol`. What is `tol`? Thatâ€™s a tolerance level that accounts for possible rounding
    errors. It is defined as the machine precision for this data type (`eps`), scaled
    by the largest singular value and the size of the matrix.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: è¿”å›çš„å€¼æ˜¯è¶…è¿‡`tol`å€¼çš„å¥‡å¼‚å€¼æ•°é‡ã€‚`tol`æ˜¯ä»€ä¹ˆï¼Ÿè¿™æ˜¯ä¸€ä¸ªå®¹å¿åº¦æ°´å¹³ï¼Œè€ƒè™‘å¯èƒ½çš„èˆå…¥è¯¯å·®ã€‚å®ƒè¢«å®šä¹‰ä¸ºæ­¤æ•°æ®ç±»å‹çš„æœºå™¨ç²¾åº¦(`eps`)ï¼ŒæŒ‰ç…§æœ€å¤§å¥‡å¼‚å€¼å’ŒçŸ©é˜µçš„å¤§å°è¿›è¡Œç¼©æ”¾ã€‚
- en: 'Thus, we yet again see the difference between â€œchalkboard mathâ€ and precision
    math implemented on computers: the rank of the matrix is not actually computed
    as the number of nonzero singular values, but instead as the number of singular
    values that are larger than some small number. There is a risk that small but
    truly nonzero singular values are ignored, but that outweighs the risk of incorrectly
    inflating the rank of the matrix when truly zero-valued singular values appear
    nonzero due to precision errors.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬å†æ¬¡çœ‹åˆ°â€œé»‘æ¿ä¸Šçš„æ•°å­¦â€ä¸è®¡ç®—æœºä¸Šå®ç°çš„ç²¾ç¡®æ•°å­¦ä¹‹é—´çš„å·®å¼‚ï¼šçŸ©é˜µçš„ç§©å®é™…ä¸Šå¹¶ä¸æ˜¯è®¡ç®—ä¸ºéé›¶å¥‡å¼‚å€¼çš„æ•°é‡ï¼Œè€Œæ˜¯è®¡ç®—ä¸ºå¤§äºæŸä¸ªå°æ•°çš„å¥‡å¼‚å€¼çš„æ•°é‡ã€‚æœ‰å¯èƒ½å¿½ç•¥ä¸€äº›çœŸæ­£éé›¶ä½†ç”±äºç²¾åº¦è¯¯å·®è€Œè¢«å¿½ç•¥çš„å¥‡å¼‚å€¼ï¼Œä½†è¿™ç›¸å¯¹äºåœ¨çœŸæ­£å€¼ä¸ºé›¶çš„æƒ…å†µä¸‹ç”±äºç²¾åº¦è¯¯å·®è€Œé”™è¯¯åœ°å¢åŠ çŸ©é˜µçš„ç§©çš„é£é™©æ¥è¯´æ›´ä¸ºåˆç†ã€‚
- en: SVD in Python
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pythonä¸­çš„SVD
- en: 'The SVD is fairly straightforward to compute in Python:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨Pythonä¸­è®¡ç®—SVDç›¸å¯¹ç›´è§‚ï¼š
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There are two features of NumPyâ€™s `svd` function to keep in mind. First, the
    singular values are returned as a vector, not a matrix of the same size as <math
    alttext="bold upper A"><mi>ğ€</mi></math> . This means that you need some extra
    code to get the <math alttext="bold upper Sigma"><mi mathvariant="bold">Î£</mi></math>
    matrix:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy çš„ `svd` å‡½æ•°æœ‰ä¸¤ä¸ªéœ€è¦æ³¨æ„çš„ç‰¹ç‚¹ã€‚é¦–å…ˆï¼Œå¥‡å¼‚å€¼ä½œä¸ºä¸€ä¸ªå‘é‡è¿”å›ï¼Œè€Œä¸æ˜¯ä¸ <math alttext="bold upper A"><mi>ğ€</mi></math>
    ç›¸åŒå¤§å°çš„çŸ©é˜µã€‚è¿™æ„å‘³ç€ä½ éœ€è¦ä¸€äº›é¢å¤–çš„ä»£ç æ¥è·å– <math alttext="bold upper Sigma"><mi mathvariant="bold">Î£</mi></math>
    çŸ©é˜µï¼š
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You might initially think of using `np.diag(s)`, but that only produces the
    correct singular values matrix for a square matrix <math alttext="bold upper A"><mi>ğ€</mi></math>
    . Therefore, I first create the correctly sized matrix of zeros, and then fill
    in the diagonal with the singular values.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯èƒ½æœ€åˆæƒ³åˆ°ä½¿ç”¨ `np.diag(s)`ï¼Œä½†é‚£åªé€‚ç”¨äºæ–¹é˜µ <math alttext="bold upper A"><mi>ğ€</mi></math>
    çš„æ­£ç¡®å¥‡å¼‚å€¼çŸ©é˜µã€‚å› æ­¤ï¼Œæˆ‘é¦–å…ˆåˆ›å»ºäº†æ­£ç¡®å¤§å°çš„é›¶çŸ©é˜µï¼Œç„¶åç”¨å¥‡å¼‚å€¼å¡«å……å¯¹è§’çº¿ã€‚
- en: The second feature is that NumPy returns the matrix <math alttext="bold upper
    V Superscript upper T"><msup><mi>ğ•</mi> <mtext>T</mtext></msup></math> , not <math
    alttext="bold upper V"><mi>ğ•</mi></math> . This may be confusing for readers coming
    from a MATLAB background, because the MATLAB `svd` function returns the matrix
    <math alttext="bold upper V"><mi>ğ•</mi></math> . The hint is in the docstring,
    which describes matrix `vh`, where the `h` is for Hermitian, the name of a symmetric
    complex-valued matrix.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬äºŒä¸ªç‰¹ç‚¹æ˜¯ NumPy è¿”å›çŸ©é˜µ <math alttext="bold upper V Superscript upper T"><msup><mi>ğ•</mi>
    <mtext>T</mtext></msup></math> ï¼Œè€Œä¸æ˜¯ <math alttext="bold upper V"><mi>ğ•</mi></math>
    ã€‚è¿™å¯¹äºä¹ æƒ¯äº MATLAB çš„è¯»è€…å¯èƒ½ä¼šæ„Ÿåˆ°å›°æƒ‘ï¼Œå› ä¸º MATLAB çš„ `svd` å‡½æ•°è¿”å›çŸ©é˜µ <math alttext="bold upper V"><mi>ğ•</mi></math>
    ã€‚åœ¨æ–‡æ¡£å­—ç¬¦ä¸²ä¸­æœ‰æç¤ºï¼Œæè¿°äº†çŸ©é˜µ `vh`ï¼Œå…¶ä¸­çš„ `h` è¡¨ç¤º Hermitianï¼Œå³å¯¹ç§°å¤å€¼çŸ©é˜µçš„åç§°ã€‚
- en: '[FigureÂ 14-2](#fig_14_2) shows the outputs of the `svd` function (with the
    singular values converted into a matrix).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[å›¾ 14-2](#fig_14_2) å±•ç¤ºäº† `svd` å‡½æ•°çš„è¾“å‡ºï¼ˆå¥‡å¼‚å€¼å·²è½¬æ¢ä¸ºçŸ©é˜µï¼‰ã€‚'
- en: '![The SVD](assets/plad_1402.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![å¥‡å¼‚å€¼åˆ†è§£](assets/plad_1402.png)'
- en: Figure 14-2\. The big picture of the SVD shown for an example matrix
  id: totrans-36
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾ 14-2\. æ˜¾ç¤ºäº†å¥‡å¼‚å€¼åˆ†è§£çš„ç¤ºä¾‹çŸ©é˜µçš„æ•´ä½“æƒ…å†µ
- en: SVD and Rank-1 â€œLayersâ€ of a Matrix
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å¥‡å¼‚å€¼åˆ†è§£å’ŒçŸ©é˜µçš„ç§©-1â€œå±‚â€
- en: 'The first equation I showed in the previous chapter was the vector-scalar version
    of the eigenvalue equation ( <math alttext="bold upper A bold v equals lamda bold
    v"><mrow><mi>ğ€</mi> <mi>ğ¯</mi> <mo>=</mo> <mi>Î»</mi> <mi>ğ¯</mi></mrow></math>
    ). I opened this chapter with the *matrix* SVD equation (<math alttext="bold upper
    A equals bold upper U bold upper Sigma bold upper V Superscript upper T"><mrow><mi
    mathvariant="bold">A</mi><mo>=</mo><mi mathvariant="bold">U</mi><mi mathvariant="bold">Î£</mi><msup><mi
    mathvariant="bold">V</mi> <mtext>T</mtext></msup></mrow></math> ); what does that
    equation look like for one vector? We can write it in two different ways that
    highlight different features of the SVD:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘åœ¨ä¸Šä¸€ç« èŠ‚å±•ç¤ºçš„ç¬¬ä¸€ä¸ªæ–¹ç¨‹æ˜¯ç‰¹å¾å€¼æ–¹ç¨‹çš„å‘é‡-æ ‡é‡ç‰ˆæœ¬ï¼ˆ <math alttext="bold upper A bold v equals lamda
    bold v"><mrow><mi>ğ€</mi> <mi>ğ¯</mi> <mo>=</mo> <mi>Î»</mi> <mi>ğ¯</mi></mrow></math>
    ï¼‰ã€‚æˆ‘åœ¨æœ¬ç« å¼€å¤´ä½¿ç”¨äº†*çŸ©é˜µ*å¥‡å¼‚å€¼åˆ†è§£æ–¹ç¨‹ï¼ˆ <math alttext="bold upper A equals bold upper U bold upper
    Sigma bold upper V Superscript upper T"><mrow><mi mathvariant="bold">A</mi><mo>=</mo><mi
    mathvariant="bold">U</mi><mi mathvariant="bold">Î£</mi><msup><mi mathvariant="bold">V</mi>
    <mtext>T</mtext></msup></mrow></math> ï¼‰ï¼›å¯¹äºä¸€ä¸ªå‘é‡ï¼Œè¿™ä¸ªæ–¹ç¨‹æ˜¯ä»€ä¹ˆæ ·å­ï¼Ÿæˆ‘ä»¬å¯ä»¥ç”¨ä¸¤ç§ä¸åŒçš„æ–¹å¼æ¥ä¹¦å†™å®ƒï¼Œçªå‡ºå¥‡å¼‚å€¼åˆ†è§£çš„ä¸åŒç‰¹ç‚¹ï¼š
- en: <math alttext="StartLayout 1st Row 1st Column bold upper A bold v 2nd Column
    equals bold u sigma 2nd Row 1st Column bold u Superscript upper T Baseline bold
    upper A 2nd Column equals sigma bold v Superscript upper T EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>ğ€</mi> <mi>ğ¯</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>ğ®</mi> <mi>Ïƒ</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mrow><msup><mi>ğ®</mi> <mtext>T</mtext></msup> <mi>ğ€</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>Ïƒ</mi> <msup><mi>ğ¯</mi> <mtext>T</mtext></msup></mrow></mtd></mtr></mtable></math>
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column bold upper A bold v 2nd Column
    equals bold u sigma 2nd Row 1st Column bold u Superscript upper T Baseline bold
    upper A 2nd Column equals sigma bold v Superscript upper T EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>ğ€</mi> <mi>ğ¯</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>ğ®</mi> <mi>Ïƒ</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mrow><msup><mi>ğ®</mi> <mtext>T</mtext></msup> <mi>ğ€</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>Ïƒ</mi> <msup><mi>ğ¯</mi> <mtext>T</mtext></msup></mrow></mtd></mtr></mtable></math>
- en: 'Those equations are kind of similar to the eigenvalue equation except that
    there are two vectors instead of one. The interpretations are, therefore, slightly
    more nuanced: in general, those equations say that the effect of the matrix on
    one vector is the same as the effect of a scalar on a different vector.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›æ–¹ç¨‹æœ‰ç‚¹ç±»ä¼¼äºç‰¹å¾å€¼æ–¹ç¨‹ï¼Œåªæ˜¯æœ‰ä¸¤ä¸ªå‘é‡è€Œä¸æ˜¯ä¸€ä¸ªã€‚å› æ­¤ï¼Œå®ƒä»¬çš„è§£é‡Šç•¥å¾®æ›´ä¸ºç»†è…»ï¼šæ€»ä½“æ¥è¯´ï¼Œè¿™äº›æ–¹ç¨‹è¡¨æ˜çŸ©é˜µå¯¹ä¸€ä¸ªå‘é‡çš„ä½œç”¨ä¸ä¸€ä¸ªä¸åŒå‘é‡çš„æ ‡é‡ä½œç”¨ç›¸åŒã€‚
- en: Notice that the first equation means that <math alttext="bold u"><mi>ğ®</mi></math>
    is in the column space of <math alttext="bold upper A"><mi>ğ€</mi></math> , with
    <math alttext="bold v"><mi>ğ¯</mi></math> providing the weights for combining the
    columns. Same goes for the second equation, but <math alttext="bold v"><mi>ğ¯</mi></math>
    is in the row space of <math alttext="bold upper A"><mi>ğ€</mi></math> with <math
    alttext="bold u"><mi>ğ®</mi></math> providing the weights.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ç¬¬ä¸€ä¸ªæ–¹ç¨‹æ„å‘³ç€ <math alttext="bold u"><mi>ğ®</mi></math> åœ¨ <math alttext="bold upper
    A"><mi>ğ€</mi></math> çš„åˆ—ç©ºé—´ä¸­ï¼Œè€Œ <math alttext="bold v"><mi>ğ¯</mi></math> æä¾›äº†ç»„åˆåˆ—çš„æƒé‡ã€‚ç¬¬äºŒä¸ªæ–¹ç¨‹åŒæ ·å¦‚æ­¤ï¼Œä½†
    <math alttext="bold v"><mi>ğ¯</mi></math> åœ¨ <math alttext="bold upper A"><mi>ğ€</mi></math>
    çš„è¡Œç©ºé—´ä¸­ï¼Œ<math alttext="bold u"><mi>ğ®</mi></math> æä¾›äº†æƒé‡ã€‚
- en: But thatâ€™s not what I want to focus on in this section; I want to consider what
    happens when you multiply one left singular vector by one right singular vector.
    Because the singular vectors are paired with the same singular value, we need
    to multiply the *i*th left singular vector by the *i*th singular value by the
    *i*th right singular vector.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†è¿™å¹¶ä¸æ˜¯æˆ‘æƒ³åœ¨æœ¬èŠ‚ä¸­é›†ä¸­è®¨è®ºçš„å†…å®¹ï¼›æˆ‘æƒ³è€ƒè™‘çš„æ˜¯å½“ä½ å°†ä¸€ä¸ªå·¦å¥‡å¼‚å‘é‡ä¹˜ä»¥ä¸€ä¸ªå³å¥‡å¼‚å‘é‡æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆã€‚å› ä¸ºå¥‡å¼‚å‘é‡ä¸ç›¸åŒçš„å¥‡å¼‚å€¼é…å¯¹ï¼Œæˆ‘ä»¬éœ€è¦å°†ç¬¬*i*ä¸ªå·¦å¥‡å¼‚å‘é‡ä¹˜ä»¥ç¬¬*i*ä¸ªå¥‡å¼‚å€¼ï¼Œå†ä¹˜ä»¥ç¬¬*i*ä¸ªå³å¥‡å¼‚å‘é‡ã€‚
- en: 'Note the orientations in this vector-vector multiplication: column on the left,
    row on the right ([FigureÂ 14-3](#fig_14_3)). That means that the result will be
    an outer product of the same size as the original matrix. Furthermore, that outer
    product is a rank-1 matrix whose norm is determined by the singular value (because
    the singular vectors are unit-length):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„è¿™ä¸ªå‘é‡-å‘é‡ä¹˜æ³•ä¸­çš„æ–¹å‘ï¼šå·¦è¾¹æ˜¯åˆ—ï¼Œå³è¾¹æ˜¯è¡Œï¼ˆè§[å›¾Â 14-3](#fig_14_3)ï¼‰ã€‚è¿™æ„å‘³ç€ç»“æœå°†æ˜¯ä¸€ä¸ªä¸åŸå§‹çŸ©é˜µå¤§å°ç›¸åŒçš„å¤–ç§¯çŸ©é˜µã€‚æ­¤å¤–ï¼Œè¯¥å¤–ç§¯æ˜¯ä¸€ä¸ªç§©-1çŸ©é˜µï¼Œå…¶èŒƒæ•°ç”±å¥‡å¼‚å€¼å†³å®šï¼ˆå› ä¸ºå¥‡å¼‚å‘é‡æ˜¯å•ä½é•¿åº¦çš„ï¼‰ï¼š
- en: <math alttext="bold u 1 sigma 1 bold v 1 Superscript upper T Baseline equals
    bold upper A 1" display="block"><mrow><msub><mi>ğ®</mi> <mn>1</mn></msub> <msub><mi>Ïƒ</mi>
    <mn>1</mn></msub> <msubsup><mi>ğ¯</mi> <mn>1</mn> <mtext>T</mtext></msubsup> <mo>=</mo>
    <msub><mi>ğ€</mi> <mn>1</mn></msub></mrow></math>![layer](assets/plad_1403.png)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="bold u 1 sigma 1 bold v 1 Superscript upper T Baseline equals
    bold upper A 1" display="block"><mrow><msub><mi>ğ®</mi> <mn>1</mn></msub> <msub><mi>Ïƒ</mi>
    <mn>1</mn></msub> <msubsup><mi>ğ¯</mi> <mn>1</mn> <mtext>T</mtext></msubsup> <mo>=</mo>
    <msub><mi>ğ€</mi> <mn>1</mn></msub></mrow></math>![layer](assets/plad_1403.png)
- en: Figure 14-3\. Outer product of singular vectors creates a matrix â€œlayerâ€
  id: totrans-45
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾Â 14-3\. å¥‡å¼‚å‘é‡çš„å¤–ç§¯åˆ›å»ºä¸€ä¸ªçŸ©é˜µâ€œå±‚â€
- en: The subscripted *1* in the equation indicates using the first singular vectors
    and first (largest) singular value. I call the result <math alttext="bold upper
    A 1"><msub><mi>ğ€</mi> <mn>1</mn></msub></math> because itâ€™s not the original matrix
    <math alttext="bold upper A"><mi>ğ€</mi></math> ; instead, itâ€™s a rank-1 matrix
    of the same size as <math alttext="bold upper A"><mi>ğ€</mi></math> . And not just
    any rank-1 matrixâ€”it is the most important â€œlayerâ€ of the matrix. Itâ€™s the most
    important because it has the largest singular value (more on this point in a later
    section).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: æ–¹ç¨‹ä¸­çš„ä¸‹æ ‡*1*è¡¨ç¤ºä½¿ç”¨ç¬¬ä¸€ä¸ªå¥‡å¼‚å‘é‡å’Œç¬¬ä¸€ä¸ªï¼ˆæœ€å¤§çš„ï¼‰å¥‡å¼‚å€¼ã€‚æˆ‘ç§°ä¹‹ä¸º<math alttext="bold upper A 1"><msub><mi>ğ€</mi>
    <mn>1</mn></msub></math>çš„ç»“æœï¼Œå› ä¸ºå®ƒä¸æ˜¯åŸå§‹çŸ©é˜µ<math alttext="bold upper A"><mi>ğ€</mi></math>ï¼›ç›¸åï¼Œå®ƒæ˜¯ä¸<math
    alttext="bold upper A"><mi>ğ€</mi></math>ç›¸åŒå¤§å°çš„ç§©-1çŸ©é˜µã€‚ä¸ä»…å¦‚æ­¤ï¼Œå®ƒæ˜¯æœ€é‡è¦çš„â€œå±‚â€ä¹‹ä¸€ã€‚å®ƒä¹‹æ‰€ä»¥å¦‚æ­¤é‡è¦ï¼Œæ˜¯å› ä¸ºå®ƒå…·æœ‰æœ€å¤§çš„å¥‡å¼‚å€¼ï¼ˆå…³äºè¿™ä¸€ç‚¹çš„è¯¦ç»†å†…å®¹å°†åœ¨åé¢çš„éƒ¨åˆ†ä»‹ç»ï¼‰ã€‚
- en: 'With this in mind, we can reconstruct the original matrix by summing all SVD
    â€œlayersâ€ associated with <math alttext="sigma greater-than 0"><mrow><mi>Ïƒ</mi>
    <mo>></mo> <mn>0</mn></mrow></math> ^([2](ch14.xhtml#idm45733291241712)):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰äº†è¿™ä¸ªç†è§£ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å¯¹æ‰€æœ‰ä¸<math alttext="sigma greater-than 0"><mrow><mi>Ïƒ</mi> <mo>></mo>
    <mn>0</mn></mrow></math>ç›¸å…³çš„SVDâ€œå±‚â€æ±‚å’Œæ¥é‡æ„åŸå§‹çŸ©é˜µ ^([2](ch14.xhtml#idm45733291241712))ï¼š
- en: <math alttext="bold upper A equals sigma-summation Underscript i equals 1 Overscript
    r Endscripts bold u Subscript i Baseline sigma Subscript i Baseline bold v Subscript
    i Superscript upper T" display="block"><mrow><mi>ğ€</mi> <mo>=</mo> <munderover><mo>âˆ‘</mo>
    <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mi>r</mi></munderover> <msub><mi>ğ®</mi>
    <mi>i</mi></msub> <msub><mi>Ïƒ</mi> <mi>i</mi></msub> <msubsup><mi>ğ¯</mi> <mi>i</mi>
    <mtext>T</mtext></msubsup></mrow></math>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="bold upper A equals sigma-summation Underscript i equals 1 Overscript
    r Endscripts bold u Subscript i Baseline sigma Subscript i Baseline bold v Subscript
    i Superscript upper T" display="block"><mrow><mi>ğ€</mi> <mo>=</mo> <munderover><mo>âˆ‘</mo>
    <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mi>r</mi></munderover> <msub><mi>ğ®</mi>
    <mi>i</mi></msub> <msub><mi>Ïƒ</mi> <mi>i</mi></msub> <msubsup><mi>ğ¯</mi> <mi>i</mi>
    <mtext>T</mtext></msubsup></mrow></math>
- en: The point of showing this summation is that you donâ€™t necessarily need to use
    all *r* layers; instead, you can reconstruct some other matrix, letâ€™s call it
    <math alttext="bold upper A overTilde"><mover accent="true"><mi>ğ€</mi> <mo>Ëœ</mo></mover></math>
    , which contains the first *k* < *r* layers. This is called a *low-rank approximation*
    of matrix <math alttext="bold upper A"><mi>ğ€</mi></math> â€”in this case, a rank-*k*
    approximation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: å±•ç¤ºè¿™ä¸ªæ±‚å’Œçš„è¦ç‚¹åœ¨äºï¼Œä½ ä¸ä¸€å®šéœ€è¦ä½¿ç”¨æ‰€æœ‰çš„*r*å±‚ï¼›ç›¸åï¼Œä½ å¯ä»¥é‡æ„å¦ä¸€ä¸ªçŸ©é˜µï¼Œè®©æˆ‘ä»¬ç§°ä¹‹ä¸º<math alttext="bold upper A
    overTilde"><mover accent="true"><mi>ğ€</mi> <mo>Ëœ</mo></mover></math>ï¼Œå…¶ä¸­åŒ…å«äº†å‰*k*
    < *r*å±‚ã€‚è¿™è¢«ç§°ä¸ºçŸ©é˜µ<math alttext="bold upper A"><mi>ğ€</mi></math>çš„*ä½ç§©é€¼è¿‘* â€” åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ˜¯ä¸€ä¸ªç§©ä¸º*k*çš„é€¼è¿‘ã€‚
- en: Low-rank approximations are used, for example, in data cleaning. The idea is
    that information associated with small singular values makes little contribution
    to the total variance of the dataset, and therefore might reflect noise that can
    be removed. More on this in the next chapter.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œåœ¨æ•°æ®æ¸…ç†ä¸­ä½¿ç”¨ä½ç§©é€¼è¿‘ã€‚å…¶æ€æƒ³æ˜¯ä¸å°å¥‡å¼‚å€¼ç›¸å…³è”çš„ä¿¡æ¯å¯¹æ•°æ®é›†çš„æ€»æ–¹å·®è´¡çŒ®è¾ƒå°ï¼Œå› æ­¤å¯èƒ½åæ˜ å‡ºå¯ä»¥å»é™¤çš„å™ªå£°ã€‚åœ¨ä¸‹ä¸€ç« ä¸­ä¼šè¯¦ç»†ä»‹ç»ã€‚
- en: SVD from EIG
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SVD from EIG
- en: OK, at this point in the chapter you know the basics of understanding and interpreting
    the SVD matrices. Iâ€™m sure you are wondering what this magical formula is to produce
    the SVD. Perhaps itâ€™s so incredibly complicated that only Gauss could understand
    it? Or maybe it would take so long to explain that it doesnâ€™t fit into one chapter?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: å¥½çš„ï¼Œåœ¨æœ¬ç« çš„è¿™ä¸€ç‚¹ä¸Šï¼Œä½ å·²ç»äº†è§£äº†ç†è§£å’Œè§£é‡ŠSVDçŸ©é˜µçš„åŸºç¡€ã€‚æˆ‘ç›¸ä¿¡ä½ æƒ³çŸ¥é“çš„æ˜¯å¦‚ä½•äº§ç”ŸSVDçš„è¿™ä¸ªç¥å¥‡å…¬å¼ã€‚ä¹Ÿè®¸å®ƒéå¸¸å¤æ‚ï¼Œåªæœ‰é«˜æ–¯èƒ½ç†è§£ï¼Ÿæˆ–è€…å¯èƒ½éœ€è¦å¾ˆé•¿æ—¶é—´æ¥è§£é‡Šï¼Œä¸é€‚åˆæ”¾åœ¨ä¸€ä¸ªç« èŠ‚é‡Œï¼Ÿ
- en: Wrong!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: é”™äº†ï¼
- en: 'In fact, the SVD is really easy (conceptually; performing an SVD by hand is
    another matter). It simply comes from computing the eigendecomposition of the
    matrix times its transpose. The following equations show how to derive the singular
    values and the left singular vectors:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: å®é™…ä¸Šï¼ŒSVDéå¸¸ç®€å•ï¼ˆåœ¨æ¦‚å¿µä¸Šï¼›æ‰‹åŠ¨æ‰§è¡ŒSVDåˆæ˜¯å¦ä¸€å›äº‹ï¼‰ã€‚å®ƒåªæ˜¯æ¥è‡ªè®¡ç®—çŸ©é˜µä¹˜ä»¥å…¶è½¬ç½®çš„ç‰¹å¾åˆ†è§£ã€‚ä»¥ä¸‹æ–¹ç¨‹æ˜¾ç¤ºå¦‚ä½•æ¨å¯¼å¥‡å¼‚å€¼å’Œå·¦å¥‡å¼‚å‘é‡ï¼š
- en: <math alttext="StartLayout 1st Row 1st Column bold upper A bold upper A Superscript
    upper T Baseline equals 2nd Column left-parenthesis bold upper U bold upper Sigma
    bold upper V Superscript upper T Baseline right-parenthesis left-parenthesis bold
    upper U bold upper Sigma bold upper V Superscript upper T Baseline right-parenthesis
    Superscript upper T 2nd Row 1st Column equals 2nd Column bold upper U bold upper
    Sigma bold upper V Superscript upper T Baseline bold upper V bold upper Sigma
    Superscript upper T Baseline bold upper U Superscript upper T 3rd Row 1st Column
    equals 2nd Column bold upper U bold upper Sigma squared bold upper U Superscript
    upper T EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi
    mathvariant="bold">A</mi> <msup><mi mathvariant="bold">A</mi> <mtext>T</mtext></msup>
    <mo>=</mo></mrow></mtd> <mtd columnalign="left"><mrow><mrow><mo>(</mo> <mi mathvariant="bold">U</mi>
    <mi mathvariant="bold">Î£</mi> <msup><mi mathvariant="bold">V</mi> <mtext>T</mtext></msup>
    <mo>)</mo></mrow> <msup><mrow><mo>(</mo><mi mathvariant="bold">U</mi><mi mathvariant="bold">Î£</mi><msup><mi
    mathvariant="bold">V</mi> <mtext>T</mtext></msup> <mo>)</mo></mrow> <mtext>T</mtext></msup></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mo>=</mo></mtd> <mtd columnalign="left"><mrow><mi
    mathvariant="bold">U</mi> <mi mathvariant="bold">Î£</mi> <msup><mi mathvariant="bold">V</mi>
    <mtext>T</mtext></msup> <mi mathvariant="bold">V</mi> <msup><mi mathvariant="bold">Î£</mi>
    <mtext>T</mtext></msup> <msup><mi mathvariant="bold">U</mi> <mtext>T</mtext></msup></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mo>=</mo></mtd> <mtd columnalign="left"><mrow><mi
    mathvariant="bold">U</mi> <msup><mi mathvariant="bold">Î£</mi> <mn>2</mn></msup>
    <msup><mi mathvariant="bold">U</mi> <mtext>T</mtext></msup></mrow></mtd></mtr></mtable></math>
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column bold upper A bold upper A Superscript
    upper T Baseline equals 2nd Column left-parenthesis bold upper U bold upper Sigma
    bold upper V Superscript upper T Baseline right-parenthesis left-parenthesis bold
    upper U bold upper Sigma bold upper V Superscript upper T Baseline right-parenthesis
    Superscript upper T 2nd Row 1st Column equals 2nd Column bold upper U bold upper
    Sigma bold upper V Superscript upper T Baseline bold upper V bold upper Sigma
    Superscript upper T Baseline bold upper U Superscript upper T 3rd Row 1st Column
    equals 2nd Column bold upper U bold upper Sigma squared bold upper U Superscript
    upper T EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi
    mathvariant="bold">A</mi> <msup><mi mathvariant="bold">A</mi> <mtext>T</mtext></msup>
    <mo>=</mo></mrow></mtd> <mtd columnalign="left"><mrow><mrow><mo>(</mo> <mi mathvariant="bold">U</mi>
    <mi mathvariant="bold">Î£</mi> <msup><mi mathvariant="bold">V</mi> <mtext>T</mtext></msup>
    <mo>)</mo></mrow> <msup><mrow><mo>(</mo><mi mathvariant="bold">U</mi><mi mathvariant="bold">Î£</mi><msup><mi
    mathvariant="bold">V</mi> <mtext>T</mtext></msup> <mo>)</mo></mrow> <mtext>T</mtext></msup></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mo>=</mo></mtd> <mtd columnalign="left"><mrow><mi
    mathvariant="bold">U</mi> <mi mathvariant="bold">Î£</mi> <msup><mi mathvariant="bold">V</mi>
    <mtext>T</mtext></msup> <mi mathvariant="bold">V</mi> <msup><mi mathvariant="bold">Î£</mi>
    <mtext>T</mtext></msup> <msup><mi mathvariant="bold">U</mi> <mtext>T</mtext></msup></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mo>=</mo></mtd> <mtd columnalign="left"><mrow><mi
    mathvariant="bold">U</mi> <msup><mi mathvariant="bold">Î£</mi> <mn>2</mn></msup>
    <msup><mi mathvariant="bold">U</mi> <mtext>T</mtext></msup></mrow></mtd></mtr></mtable></math>
- en: In other words, the eigenvectors of <math alttext="bold upper A bold upper A
    Superscript upper T"><mrow><mi>ğ€</mi> <msup><mi>ğ€</mi> <mtext>T</mtext></msup></mrow></math>
    are the left-singular vectors of <math alttext="bold upper A"><mi>ğ€</mi></math>
    , and the squared eigenvalues of <math alttext="bold upper A bold upper A Superscript
    upper T"><mrow><mi>ğ€</mi> <msup><mi>ğ€</mi> <mtext>T</mtext></msup></mrow></math>
    are the singular values of <math alttext="bold upper A"><mi>ğ€</mi></math> .
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: æ¢å¥è¯è¯´ï¼Œ<math alttext="bold upper A bold upper A Superscript upper T"><mrow><mi>ğ€</mi>
    <msup><mi>ğ€</mi> <mtext>T</mtext></msup></mrow></math>çš„ç‰¹å¾å‘é‡æ˜¯<math alttext="bold
    upper A"><mi>ğ€</mi></math>çš„å·¦å¥‡å¼‚å‘é‡ï¼Œ<math alttext="bold upper A bold upper A Superscript
    upper T"><mrow><mi>ğ€</mi> <msup><mi>ğ€</mi> <mtext>T</mtext></msup></mrow></math>çš„å¹³æ–¹ç‰¹å¾å€¼æ˜¯<math
    alttext="bold upper A"><mi>ğ€</mi></math>çš„å¥‡å¼‚å€¼ã€‚
- en: 'This insight reveals three features of the SVD: (1) singular values are nonnegative
    because squared numbers cannot be negative, (2) singular values are real-valued
    because symmetric matrices have real-valued eigenvalues, and (3) singular vectors
    are orthogonal because the eigenvectors of a symmetric matrix are orthogonal.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸€æ´å¯Ÿæ­ç¤ºäº†SVDçš„ä¸‰ä¸ªç‰¹ç‚¹ï¼šï¼ˆ1ï¼‰å¥‡å¼‚å€¼éè´Ÿï¼Œå› ä¸ºå¹³æ–¹æ•°ä¸èƒ½ä¸ºè´Ÿæ•°ï¼›ï¼ˆ2ï¼‰å¥‡å¼‚å€¼æ˜¯å®æ•°ï¼Œå› ä¸ºå¯¹ç§°çŸ©é˜µå…·æœ‰å®æ•°ç‰¹å¾å€¼ï¼›ï¼ˆ3ï¼‰å¥‡å¼‚å‘é‡æ­£äº¤ï¼Œå› ä¸ºå¯¹ç§°çŸ©é˜µçš„ç‰¹å¾å‘é‡æ˜¯æ­£äº¤çš„ã€‚
- en: 'The right-singular values come from premultiplying the matrix transpose:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: å³å¥‡å¼‚å€¼æ¥è‡ªçŸ©é˜µè½¬ç½®çš„é¢„ä¹˜ï¼š
- en: <math alttext="StartLayout 1st Row 1st Column bold upper A Superscript upper
    T Baseline bold upper A equals 2nd Column left-parenthesis bold upper U bold upper
    Sigma bold upper V Superscript upper T Baseline right-parenthesis Superscript
    upper T Baseline left-parenthesis bold upper U bold upper Sigma bold upper V Superscript
    upper T Baseline right-parenthesis 2nd Row 1st Column equals 2nd Column bold upper
    V bold upper Sigma Superscript upper T Baseline bold upper U Superscript upper
    T Baseline bold upper U bold upper Sigma bold upper V Superscript upper T 3rd
    Row 1st Column equals 2nd Column bold upper V bold upper Sigma squared bold upper
    V Superscript upper T EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mrow><msup><mi mathvariant="bold">A</mi> <mtext>T</mtext></msup>
    <mi mathvariant="bold">A</mi> <mo>=</mo></mrow></mtd> <mtd columnalign="left"><mrow><msup><mrow><mo>(</mo><mi
    mathvariant="bold">U</mi><mi mathvariant="bold">Î£</mi><msup><mi mathvariant="bold">V</mi>
    <mtext>T</mtext></msup> <mo>)</mo></mrow> <mtext>T</mtext></msup> <mrow><mo>(</mo>
    <mi mathvariant="bold">U</mi> <mi mathvariant="bold">Î£</mi> <msup><mi mathvariant="bold">V</mi>
    <mtext>T</mtext></msup> <mo>)</mo></mrow></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mo>=</mo></mtd>
    <mtd columnalign="left"><mrow><mi mathvariant="bold">V</mi> <msup><mi mathvariant="bold">Î£</mi>
    <mtext>T</mtext></msup> <msup><mi mathvariant="bold">U</mi> <mtext>T</mtext></msup>
    <mi mathvariant="bold">U</mi> <mi mathvariant="bold">Î£</mi> <msup><mi mathvariant="bold">V</mi>
    <mtext>T</mtext></msup></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mo>=</mo></mtd>
    <mtd columnalign="left"><mrow><mi mathvariant="bold">V</mi> <msup><mi mathvariant="bold">Î£</mi>
    <mn>2</mn></msup> <msup><mi mathvariant="bold">V</mi> <mtext>T</mtext></msup></mrow></mtd></mtr></mtable></math>
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column bold upper A Superscript upper
    T Baseline bold upper A equals 2nd Column left-parenthesis bold upper U bold upper
    Sigma bold upper V Superscript upper T Baseline right-parenthesis Superscript
    upper T Baseline left-parenthesis bold upper U bold upper Sigma bold upper V Superscript
    upper T Baseline right-parenthesis 2nd Row 1st Column equals 2nd Column bold upper
    V bold upper Sigma Superscript upper T Baseline bold upper U Superscript upper
    T Baseline bold upper U bold upper Sigma bold upper V Superscript upper T 3rd
    Row 1st Column equals 2nd Column bold upper V bold upper Sigma squared bold upper
    V Superscript upper T EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mrow><msup><mi mathvariant="bold">A</mi> <mtext>T</mtext></msup>
    <mi mathvariant="bold">A</mi> <mo>=</mo></mrow></mtd> <mtd columnalign="left"><mrow><msup><mrow><mo>(</mo><mi
    mathvariant="bold">U</mi><mi mathvariant="bold">Î£</mi><msup><mi mathvariant="bold">V</mi>
    <mtext>T</mtext></msup> <mo>)</mo></mrow> <mtext>T</mtext></msup> <mrow><mo>(</mo>
    <mi mathvariant="bold">U</mi> <mi mathvariant="bold">Î£</mi> <msup><mi mathvariant="bold">V</mi>
    <mtext>T</mtext></msup> <mo>)</mo></mrow></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mo>=</mo></mtd>
    <mtd columnalign="left"><mrow><mi mathvariant="bold">V</mi> <msup><mi mathvariant="bold">Î£</mi>
    <mtext>T</mtext></msup> <msup><mi mathvariant="bold">U</mi> <mtext>T</mtext></msup>
    <mi mathvariant="bold">U</mi> <mi mathvariant="bold">Î£</mi> <msup><mi mathvariant="bold">V</mi>
    <mtext>T</mtext></msup></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mo>=</mo></mtd>
    <mtd columnalign="left"><mrow><mi mathvariant="bold">V</mi> <msup><mi mathvariant="bold">Î£</mi>
    <mn>2</mn></msup> <msup><mi mathvariant="bold">V</mi> <mtext>T</mtext></msup></mrow></mtd></mtr></mtable></math>
- en: 'In fact, you can rearrange the SVD equation to solve for the right-singular
    vectors without having to compute the eigendecomposition of <math alttext="bold
    upper A Superscript upper T Baseline bold upper A"><mrow><msup><mi>ğ€</mi> <mtext>T</mtext></msup>
    <mi>ğ€</mi></mrow></math> :'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: å®é™…ä¸Šï¼Œæ‚¨å¯ä»¥é‡æ–°æ’åˆ—SVDæ–¹ç¨‹ä»¥è§£å‡ºå³å¥‡å¼‚å‘é‡ï¼Œè€Œæ— éœ€è®¡ç®—<math alttext="bold upper A Superscript upper
    T Baseline bold upper A"><mrow><msup><mi>ğ€</mi> <mtext>T</mtext></msup> <mi>ğ€</mi></mrow></math>çš„ç‰¹å¾åˆ†è§£ï¼š
- en: <math alttext="bold upper V Superscript upper T Baseline equals bold upper Sigma
    Superscript negative 1 Baseline bold upper U Superscript upper T Baseline bold
    upper A" display="block"><mrow><msup><mi mathvariant="bold">V</mi> <mtext>T</mtext></msup>
    <mo>=</mo> <msup><mi mathvariant="bold">Î£</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msup><mi mathvariant="bold">U</mi> <mtext>T</mtext></msup> <mi mathvariant="bold">A</mi></mrow></math>
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="bold upper V Superscript upper T Baseline equals bold upper Sigma
    Superscript negative 1 Baseline bold upper U Superscript upper T Baseline bold
    upper A" display="block"><mrow><msup><mi mathvariant="bold">V</mi> <mtext>T</mtext></msup>
    <mo>=</mo> <msup><mi mathvariant="bold">Î£</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msup><mi mathvariant="bold">U</mi> <mtext>T</mtext></msup> <mi mathvariant="bold">A</mi></mrow></math>
- en: Of course, there is a complementary equation for deriving <math alttext="bold
    upper U"><mi>ğ”</mi></math> if you already know <math alttext="bold upper V"><mi>ğ•</mi></math>
    .
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œå¦‚æœæ‚¨å·²ç»çŸ¥é“<math alttext="bold upper V"><mi>ğ•</mi></math> ï¼Œåˆ™å¯ä»¥æ¨å¯¼å‡º<math alttext="bold
    upper U"><mi>ğ”</mi></math> çš„äº’è¡¥æ–¹ç¨‹ã€‚
- en: SVD of <math alttext="bold upper A Superscript upper T Baseline bold upper A"><mrow><msup><mi>ğ€</mi>
    <mtext>T</mtext></msup> <mi>ğ€</mi></mrow></math>
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SVD of <math alttext="bold upper A Superscript upper T Baseline bold upper A"><mrow><msup><mi>ğ€</mi>
    <mtext>T</mtext></msup> <mi>ğ€</mi></mrow></math>
- en: 'Briefly, if a matrix can be expressed as <math alttext="bold upper S equals
    bold upper A Superscript upper T Baseline bold upper A"><mrow><mi>ğ’</mi> <mo>=</mo>
    <msup><mi>ğ€</mi> <mtext>T</mtext></msup> <mi>ğ€</mi></mrow></math> , then its left-
    and right-singular vectors are equal. In other words:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ç®€è€Œè¨€ä¹‹ï¼Œå¦‚æœä¸€ä¸ªçŸ©é˜µå¯ä»¥è¡¨ç¤ºä¸º<math alttext="bold upper S equals bold upper A Superscript
    upper T Baseline bold upper A"><mrow><mi>ğ’</mi> <mo>=</mo> <msup><mi>ğ€</mi> <mtext>T</mtext></msup>
    <mi>ğ€</mi></mrow></math> ï¼Œé‚£ä¹ˆå®ƒçš„å·¦å¥‡å¼‚å‘é‡å’Œå³å¥‡å¼‚å‘é‡æ˜¯ç›¸ç­‰çš„ã€‚æ¢å¥è¯è¯´ï¼š
- en: <math alttext="bold upper S equals bold upper U bold upper Sigma bold upper
    V Superscript upper T Baseline equals bold upper V bold upper Sigma bold upper
    U Superscript upper T Baseline equals bold upper U bold upper Sigma bold upper
    U Superscript upper T Baseline equals bold upper V bold upper Sigma bold upper
    V Superscript upper T" display="block"><mrow><mi mathvariant="bold">S</mi> <mo>=</mo>
    <mi mathvariant="bold">U</mi> <mi mathvariant="bold">Î£</mi> <msup><mi mathvariant="bold">V</mi>
    <mtext>T</mtext></msup> <mo>=</mo> <mi mathvariant="bold">V</mi> <mi mathvariant="bold">Î£</mi>
    <msup><mi mathvariant="bold">U</mi> <mtext>T</mtext></msup> <mo>=</mo> <mi mathvariant="bold">U</mi>
    <mi mathvariant="bold">Î£</mi> <msup><mi mathvariant="bold">U</mi> <mtext>T</mtext></msup>
    <mo>=</mo> <mi mathvariant="bold">V</mi> <mi mathvariant="bold">Î£</mi> <msup><mi
    mathvariant="bold">V</mi> <mtext>T</mtext></msup></mrow></math>
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="bold upper S equals bold upper U bold upper Sigma bold upper
    V Superscript upper T Baseline equals bold upper V bold upper Sigma bold upper
    U Superscript upper T Baseline equals bold upper U bold upper Sigma bold upper
    U Superscript upper T Baseline equals bold upper V bold upper Sigma bold upper
    V Superscript upper T" display="block"><mrow><mi mathvariant="bold">S</mi> <mo>=</mo>
    <mi mathvariant="bold">U</mi> <mi mathvariant="bold">Î£</mi> <msup><mi mathvariant="bold">V</mi>
    <mtext>T</mtext></msup> <mo>=</mo> <mi mathvariant="bold">V</mi> <mi mathvariant="bold">Î£</mi>
    <msup><mi mathvariant="bold">U</mi> <mtext>T</mtext></msup> <mo>=</mo> <mi mathvariant="bold">U</mi>
    <mi mathvariant="bold">Î£</mi> <msup><mi mathvariant="bold">U</mi> <mtext>T</mtext></msup>
    <mo>=</mo> <mi mathvariant="bold">V</mi> <mi mathvariant="bold">Î£</mi> <msup><mi
    mathvariant="bold">V</mi> <mtext>T</mtext></msup></mrow></math>
- en: The proof of this claim comes from writing out the SVD of <math alttext="bold
    upper S"><mi>ğ’</mi></math> and <math alttext="bold upper S Superscript upper T"><msup><mi>ğ’</mi>
    <mtext>T</mtext></msup></math> , then considering the implication of <math alttext="bold
    upper S equals bold upper S Superscript upper T"><mrow><mi>ğ’</mi> <mo>=</mo> <msup><mi>ğ’</mi>
    <mtext>T</mtext></msup></mrow></math> . Iâ€™m leaving this one for you to explore
    on your own! And I also encourage you to confirm it in Python using random symmetric
    matrices.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªæ–­è¨€çš„è¯æ˜æºäºå°†<math alttext="bold upper S"><mi>ğ’</mi></math>å’Œ<math alttext="bold
    upper S Superscript upper T"><msup><mi>ğ’</mi> <mtext>T</mtext></msup></math>çš„SVDå†™å‡ºæ¥ï¼Œç„¶åè€ƒè™‘<math
    alttext="bold upper S equals bold upper S Superscript upper T"><mrow><mi>ğ’</mi>
    <mo>=</mo> <msup><mi>ğ’</mi> <mtext>T</mtext></msup></mrow></math>çš„å«ä¹‰ã€‚æˆ‘ç•™ç»™ä½ è‡ªå·±å»æ¢ç´¢ï¼æˆ‘è¿˜é¼“åŠ±æ‚¨åœ¨Pythonä¸­ä½¿ç”¨éšæœºå¯¹ç§°çŸ©é˜µæ¥ç¡®è®¤ã€‚
- en: In fact, for a symmetric matrix, SVD is the same thing as eigendecomposition.
    This has implications for principal components analysis, because PCA can be performed
    using eigendecomposition of the data covariance matrix, the SVD of the covariance
    matrix, or the SVD of the data matrix.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: å®é™…ä¸Šï¼Œå¯¹äºå¯¹ç§°çŸ©é˜µï¼ŒSVDä¸ç‰¹å¾åˆ†è§£æ˜¯ç›¸åŒçš„ã€‚è¿™å¯¹ä¸»æˆåˆ†åˆ†ææœ‰å½±å“ï¼Œå› ä¸ºPCAå¯ä»¥ä½¿ç”¨æ•°æ®åæ–¹å·®çŸ©é˜µçš„ç‰¹å¾åˆ†è§£ï¼Œåæ–¹å·®çŸ©é˜µçš„SVDæˆ–æ•°æ®çŸ©é˜µçš„SVDæ¥æ‰§è¡Œã€‚
- en: Converting Singular Values to Variance, Explained
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å°†å¥‡å¼‚å€¼è½¬æ¢ä¸ºè§£é‡Šçš„æ–¹å·®
- en: The sum of the singular values is the total amount of â€œvarianceâ€ in the matrix.
    What does that mean? If you think of the information in the matrix as being contained
    in a bubble, then the sum of the singular values is like the volume of that bubble.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: å¥‡å¼‚å€¼çš„æ€»å’Œæ˜¯çŸ©é˜µä¸­çš„æ€»â€œæ–¹å·®â€é‡ã€‚è¿™æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿå¦‚æœä½ å°†çŸ©é˜µä¸­çš„ä¿¡æ¯è§†ä¸ºåŒ…å«åœ¨ä¸€ä¸ªæ°”æ³¡ä¸­ï¼Œé‚£ä¹ˆå¥‡å¼‚å€¼çš„æ€»å’Œå°±åƒæ˜¯é‚£ä¸ªæ°”æ³¡çš„ä½“ç§¯ã€‚
- en: The reason why all the variance is contained in the singular values is that
    the singular vectors are normalized to unit magnitude, which means they provide
    no magnitude information (that is, <math alttext="parallel-to bold upper U bold
    w parallel-to equals parallel-to bold w parallel-to"><mrow><mo>âˆ¥</mo> <mi>ğ”</mi>
    <mi>ğ°</mi> <mo>âˆ¥</mo> <mo>=</mo> <mo>âˆ¥</mo> <mi>ğ°</mi> <mo>âˆ¥</mo></mrow></math>
    ).^([3](ch14.xhtml#idm45733291075808)) In other words, the singular vectors point,
    and the singular values say how far.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€æœ‰æ–¹å·®éƒ½åŒ…å«åœ¨å¥‡å¼‚å€¼ä¸­çš„åŸå› æ˜¯å¥‡å¼‚å‘é‡è¢«è§„èŒƒåŒ–ä¸ºå•ä½å¤§å°ï¼Œè¿™æ„å‘³ç€å®ƒä»¬ä¸æä¾›å¤§å°ä¿¡æ¯ï¼ˆå³ï¼Œ<math alttext="parallel-to bold
    upper U bold w parallel-to equals parallel-to bold w parallel-to"><mrow><mo>âˆ¥</mo>
    <mi>ğ”</mi> <mi>ğ°</mi> <mo>âˆ¥</mo> <mo>=</mo> <mo>âˆ¥</mo> <mi>ğ°</mi> <mo>âˆ¥</mo></mrow></math>
    ï¼‰ã€‚^([3](ch14.xhtml#idm45733291075808)) æ¢å¥è¯è¯´ï¼Œå¥‡å¼‚å‘é‡æŒ‡å‘æŸä¸ªæ–¹å‘ï¼Œè€Œå¥‡å¼‚å€¼åˆ™è¡¨ç¤ºè·ç¦»æœ‰å¤šè¿œã€‚
- en: The â€œrawâ€ singular values are in the numerical scale of the matrix. That means
    that if you multiply the data by a scalar, then the singular values will increase.
    And this in turn means that the singular values are difficult to interpret, and
    are basically impossible to compare across different datasets.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: â€œåŸå§‹â€å¥‡å¼‚å€¼å¤„äºçŸ©é˜µçš„æ•°å€¼å°ºåº¦ä¸­ã€‚è¿™æ„å‘³ç€å¦‚æœå°†æ•°æ®ä¹˜ä»¥ä¸€ä¸ªæ ‡é‡ï¼Œé‚£ä¹ˆå¥‡å¼‚å€¼å°†ä¼šå¢åŠ ã€‚è€Œè¿™åˆæ„å‘³ç€ï¼Œå¥‡å¼‚å€¼éš¾ä»¥è§£é‡Šï¼Œå¹¶ä¸”åŸºæœ¬ä¸Šä¸å¯èƒ½åœ¨ä¸åŒæ•°æ®é›†ä¹‹é—´è¿›è¡Œæ¯”è¾ƒã€‚
- en: 'For this reason, it is often useful to convert the singular values to percent
    total variance explained. The formula is simple; each singular value *i* is normalized
    as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œå°†å¥‡å¼‚å€¼è½¬æ¢ä¸ºè§£é‡Šçš„æ€»ç™¾åˆ†æ¯”é€šå¸¸æ˜¯æœ‰ç”¨çš„ã€‚å…¬å¼å¾ˆç®€å•ï¼›æ¯ä¸ªå¥‡å¼‚å€¼ *i* è§„èŒƒåŒ–å¦‚ä¸‹ï¼š
- en: <math alttext="sigma Subscript i Baseline overTilde equals StartFraction 100
    sigma Subscript i Baseline Over sigma-summation sigma EndFraction" display="block"><mrow><mover
    accent="true"><msub><mi>Ïƒ</mi> <mi>i</mi></msub> <mo>Ëœ</mo></mover> <mo>=</mo>
    <mfrac><mrow><mn>100</mn><msub><mi>Ïƒ</mi> <mi>i</mi></msub></mrow> <mrow><mo>âˆ‘</mo><mi>Ïƒ</mi></mrow></mfrac></mrow></math>
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="sigma Subscript i Baseline overTilde equals StartFraction 100
    sigma Subscript i Baseline Over sigma-summation sigma EndFraction" display="block"><mrow><mover
    accent="true"><msub><mi>Ïƒ</mi> <mi>i</mi></msub> <mo>Ëœ</mo></mover> <mo>=</mo>
    <mfrac><mrow><mn>100</mn><msub><mi>Ïƒ</mi> <mi>i</mi></msub></mrow> <mrow><mo>âˆ‘</mo><mi>Ïƒ</mi></mrow></mfrac></mrow></math>
- en: This normalization is common in principal components analysis, for example,
    to determine the number of components that account for 99% of the variance. That
    can be interpreted as an indicator of system complexity.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œåœ¨ä¸»æˆåˆ†åˆ†æä¸­ï¼Œè¿™ç§å½’ä¸€åŒ–å¸¸ç”¨æ¥ç¡®å®šè§£é‡Š 99% æ–¹å·®çš„æˆåˆ†æ•°é‡ã€‚è¿™å¯ä»¥è§£é‡Šä¸ºç³»ç»Ÿå¤æ‚æ€§çš„ä¸€ä¸ªæŒ‡æ ‡ã€‚
- en: Importantly, this normalization does not affect the relative distances between
    singular values; it merely changes the numerical scale into one that is more readily
    intepretable.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: é‡è¦çš„æ˜¯ï¼Œè¿™ç§å½’ä¸€åŒ–ä¸ä¼šå½±å“å¥‡å¼‚å€¼ä¹‹é—´çš„ç›¸å¯¹è·ç¦»ï¼›å®ƒåªæ˜¯å°†æ•°å€¼å°ºåº¦æ”¹å˜ä¸ºæ›´å®¹æ˜“è§£é‡Šçš„å°ºåº¦ã€‚
- en: Condition Number
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: æ¡ä»¶æ•°
- en: Iâ€™ve hinted several times in this book that the condition number of a matrix
    is used to indicate the numerical stability of a matrix. Now that you know about
    singular values, you can better appreciate how to compute and interpret the condition
    number.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ¬ä¹¦ä¸­æˆ‘å¤šæ¬¡æåˆ°ï¼ŒçŸ©é˜µçš„æ¡ä»¶æ•°ç”¨äºæŒ‡ç¤ºçŸ©é˜µçš„æ•°å€¼ç¨³å®šæ€§ã€‚ç°åœ¨ä½ äº†è§£äº†å¥‡å¼‚å€¼ï¼Œå¯ä»¥æ›´å¥½åœ°ç†è§£å¦‚ä½•è®¡ç®—å’Œè§£é‡Šæ¡ä»¶æ•°ã€‚
- en: 'The condition number of a matrix is defined as the ratio of the largest to
    the smallest singular value. Itâ€™s often given the letter <math alttext="kappa"><mi>Îº</mi></math>
    (Greek letter *kappa*):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: çŸ©é˜µçš„æ¡ä»¶æ•°å®šä¹‰ä¸ºæœ€å¤§å¥‡å¼‚å€¼ä¸æœ€å°å¥‡å¼‚å€¼çš„æ¯”å€¼ã€‚é€šå¸¸ç”¨å¸Œè…Šå­—æ¯ *Îº*ï¼ˆkappaï¼‰è¡¨ç¤ºï¼š
- en: <math alttext="kappa equals StartFraction sigma Subscript m a x Baseline Over
    sigma Subscript min Baseline EndFraction" display="block"><mrow><mi>Îº</mi> <mo>=</mo>
    <mfrac><msub><mi>Ïƒ</mi> <mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub> <msub><mi>Ïƒ</mi>
    <mo form="prefix" movablelimits="true">min</mo></msub></mfrac></mrow></math>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="kappa equals StartFraction sigma Subscript m a x Baseline Over
    sigma Subscript min Baseline EndFraction" display="block"><mrow><mi>Îº</mi> <mo>=</mo>
    <mfrac><msub><mi>Ïƒ</mi> <mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub> <msub><mi>Ïƒ</mi>
    <mo form="prefix" movablelimits="true">min</mo></msub></mfrac></mrow></math>
- en: The condition number is often used in statistics and machine learning to evaluate
    the stability of a matrix when computing its inverse and when using it to solve
    systems of equations (e.g., least squares). Of course, a noninvertible matrix
    has a condition number of NaN because <math alttext="sigma slash 0 equals"><mrow><mi>Ïƒ</mi>
    <mo>/</mo> <mn>0</mn> <mo>=</mo></mrow></math> â€½.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ç»Ÿè®¡å­¦å’Œæœºå™¨å­¦ä¹ ä¸­ï¼Œæ¡ä»¶æ•°å¸¸ç”¨äºè¯„ä¼°çŸ©é˜µåœ¨è®¡ç®—å…¶é€†çŸ©é˜µå’Œä½¿ç”¨å…¶è§£å†³æ–¹ç¨‹ç»„ï¼ˆå¦‚æœ€å°äºŒä¹˜æ³•ï¼‰æ—¶çš„ç¨³å®šæ€§ã€‚å½“ç„¶ï¼Œéå¯é€†çŸ©é˜µçš„æ¡ä»¶æ•°ä¸º NaNï¼Œå› ä¸º <math
    alttext="sigma slash 0 equals"><mrow><mi>Ïƒ</mi> <mo>/</mo> <mn>0</mn> <mo>=</mo></mrow></math>
    â€½ã€‚
- en: But a numerically full-rank matrix with a large condition number can still be
    unstable. Though theoretically invertible, in practice the matrix inverse may
    be unreliable. Such matrices are called *ill-conditioned*. You might have seen
    that term in warning messages in Python, sometimes accompanied by phrases like
    â€œresult is not guaranteed to be accurate.â€
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†æ˜¯ï¼Œæ•°å€¼ä¸Šæ»¡ç§©ä¸”æ¡ä»¶æ•°è¾ƒå¤§çš„çŸ©é˜µä»å¯èƒ½ä¸ç¨³å®šã€‚è™½ç„¶åœ¨ç†è®ºä¸Šå¯é€†ï¼Œä½†å®é™…ä¸Šå…¶é€†çŸ©é˜µå¯èƒ½ä¸å¯é ã€‚è¿™æ ·çš„çŸ©é˜µè¢«ç§°ä¸º*ç—…æ€çŸ©é˜µ*ã€‚ä½ å¯èƒ½åœ¨Pythonçš„è­¦å‘Šæ¶ˆæ¯ä¸­è§è¿‡è¿™ä¸ªæœ¯è¯­ï¼Œæœ‰æ—¶ä¼´éšç€â€œç»“æœå¯èƒ½ä¸å‡†ç¡®â€çš„çŸ­è¯­ã€‚
- en: Whatâ€™s the problem with an ill-conditioned matrix? As the condition number increases,
    the matrix tends toward being singular. Therefore, an ill-conditioned matrix is
    â€œalmost singularâ€ and its inverse becomes untrustworthy due to increased risk
    of numerical errors.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºæ¡ä»¶æ•°è¾ƒå¤§çš„ç—…æ€çŸ©é˜µæœ‰ä»€ä¹ˆé—®é¢˜ï¼Ÿéšç€æ¡ä»¶æ•°çš„å¢åŠ ï¼ŒçŸ©é˜µè¶‹å‘äºå¥‡å¼‚ã€‚å› æ­¤ï¼Œç—…æ€çŸ©é˜µå‡ ä¹æ˜¯â€œå‡ ä¹å¥‡å¼‚çš„â€ï¼Œå…¶é€†ç”±äºæ•°å€¼è¯¯å·®é£é™©å¢åŠ è€Œä¸å¯ä¿¡ã€‚
- en: There are a few ways to think about the impact of an ill-conditioned matrix.
    One is as the decrease in the precision of a solution due to round-off errors.
    For example, a condition number on the order of 10âµ means that the solution (e.g.,
    the matrix inverse or least squares problem) loses five significant digits (this
    would mean, for example, going from a precision of 10^(âˆ’16) to 10^(âˆ’11)).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰å‡ ç§æ–¹æ³•å¯ä»¥æ€è€ƒç—…æ€çŸ©é˜µçš„å½±å“ã€‚ä¸€ç§æ˜¯ç”±äºèˆå…¥è¯¯å·®å¯¼è‡´è§£çš„ç²¾åº¦é™ä½ã€‚ä¾‹å¦‚ï¼Œæ¡ä»¶æ•°çº¦ä¸º10âµæ„å‘³ç€è§£ï¼ˆä¾‹å¦‚çŸ©é˜µé€†æˆ–æœ€å°äºŒä¹˜é—®é¢˜ï¼‰å¤±å»äº†äº”ä¸ªæœ‰æ•ˆæ•°å­—ï¼ˆä¾‹å¦‚ï¼Œä»ç²¾åº¦10^(âˆ’16)é™è‡³10^(âˆ’11)ï¼‰ã€‚
- en: A second interpretation, related to the previous, is as an amplification factor
    for noise. If you have a matrix with a condition number on the order of 10â´, then
    noise could impact the solution to a least squares problem by 10â´. That might
    sound like a lot, but it could be an insigificant amplification if your data has
    a precision of 10^(âˆ’16).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬äºŒç§è§£é‡Šä¸å‰è¿°æœ‰å…³ï¼Œæ˜¯å™ªå£°æ”¾å¤§å› å­ã€‚å¦‚æœçŸ©é˜µçš„æ¡ä»¶æ•°çº¦ä¸º10â´ï¼Œé‚£ä¹ˆå™ªå£°å¯èƒ½ä¼šä½¿æœ€å°äºŒä¹˜é—®é¢˜çš„è§£å—åˆ°10â´çš„å½±å“ã€‚è¿™å¬èµ·æ¥å¯èƒ½å¾ˆå¤šï¼Œä½†å¦‚æœæ‚¨çš„æ•°æ®ç²¾åº¦ä¸º10^(âˆ’16)ï¼Œè¿™å¯èƒ½æ˜¯ä¸€ä¸ªå¾®ä¸è¶³é“çš„æ”¾å¤§æ•ˆåº”ã€‚
- en: Thirdly, the condition number indicates the sensitivity of a solution to perturbations
    in the data matrix. A well-conditioned matrix can be perturbed (more noise added)
    with minimal change in the solution. In contrast, adding a small amount of noise
    to an ill-conditioned matrix can lead to wildly different solutions.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬ä¸‰ï¼Œæ¡ä»¶æ•°è¡¨ç¤ºè§£å¯¹æ•°æ®çŸ©é˜µæ‰°åŠ¨çš„æ•æ„Ÿæ€§ã€‚è‰¯å¥½æ¡ä»¶çš„çŸ©é˜µå¯ä»¥åœ¨æ·»åŠ å™ªå£°æ—¶ä¿æŒè§£çš„æœ€å°å˜åŒ–ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œå¯¹ç—…æ€çŸ©é˜µæ·»åŠ å°‘é‡å™ªå£°å¯èƒ½ä¼šå¯¼è‡´å®Œå…¨ä¸åŒçš„è§£ã€‚
- en: What is the threshold for a matrix to be ill-conditioned? There is none. There
    is no magic number that separates a well-conditioned from an ill-conditioned matrix.
    Different algorithms will apply different thresholds that depend on the numerical
    values in the matrix.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: çŸ©é˜µä½•æ—¶è¢«è®¤ä¸ºæ˜¯ç—…æ€ï¼Ÿæ²¡æœ‰ç¡®å®šçš„é˜ˆå€¼ã€‚æ²¡æœ‰ä¸€ä¸ªé­”æ³•æ•°å­—å¯ä»¥å°†è‰¯å¥½æ¡ä»¶çš„çŸ©é˜µä¸ç—…æ€çŸ©é˜µåˆ†å¼€ã€‚ä¸åŒçš„ç®—æ³•å°†é€‚ç”¨ä¸åŒçš„é˜ˆå€¼ï¼Œè¿™äº›é˜ˆå€¼å–å†³äºçŸ©é˜µä¸­çš„æ•°å€¼ã€‚
- en: 'This much is clear: take warning messages about ill-conditioned matrices seriously.
    They usually indicate that something is wrong and the results should not be trusted.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: å¾ˆæ˜æ˜¾ï¼šè¦è®¤çœŸå¯¹å¾…å…³äºç—…æ€çŸ©é˜µçš„è­¦å‘Šä¿¡æ¯ã€‚å®ƒä»¬é€šå¸¸è¡¨æ˜æŸäº›åœ°æ–¹å‡ºäº†é—®é¢˜ï¼Œç»“æœä¸å¯ä¿¡ã€‚
- en: SVD and the MP Pseudoinverse
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SVDå’ŒMPä¼ªé€†
- en: 'The SVD of a matrix inverse is quite elegant. Assuming the matrix is square
    and invertible, we get:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: çŸ©é˜µçš„å¥‡å¼‚å€¼åˆ†è§£é€†çŸ©é˜µéå¸¸ä¼˜é›…ã€‚å‡è®¾çŸ©é˜µæ˜¯æ–¹é˜µä¸”å¯é€†ï¼Œæˆ‘ä»¬æœ‰ï¼š
- en: <math alttext="StartLayout 1st Row 1st Column bold upper A Superscript negative
    1 2nd Column equals left-parenthesis bold upper U bold upper Sigma bold upper
    V Superscript upper T Baseline right-parenthesis Superscript negative 1 Baseline
    2nd Row 1st Column Blank 2nd Column equals bold upper V bold upper Sigma Superscript
    negative 1 Baseline bold upper U Superscript negative 1 Baseline 3rd Row 1st Column
    Blank 2nd Column equals bold upper V bold upper Sigma Superscript negative 1 Baseline
    bold upper U Superscript upper T EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><msup><mi mathvariant="bold">A</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <msup><mrow><mo>(</mo><mi mathvariant="bold">U</mi><mi
    mathvariant="bold">Î£</mi><msup><mi mathvariant="bold">V</mi> <mtext>T</mtext></msup>
    <mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mo>=</mo> <mi mathvariant="bold">V</mi> <msup><mi
    mathvariant="bold">Î£</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <msup><mi mathvariant="bold">U</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mo>=</mo>
    <mi mathvariant="bold">V</mi> <msup><mi mathvariant="bold">Î£</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msup><mi mathvariant="bold">U</mi> <mtext>T</mtext></msup></mrow></mtd></mtr></mtable></math>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column bold upper A Superscript negative
    1 2nd Column equals left-parenthesis bold upper U bold upper Sigma bold upper
    V Superscript upper T Baseline right-parenthesis Superscript negative 1 Baseline
    2nd Row 1st Column Blank 2nd Column equals bold upper V bold upper Sigma Superscript
    negative 1 Baseline bold upper U Superscript negative 1 Baseline 3rd Row 1st Column
    Blank 2nd Column equals bold upper V bold upper Sigma Superscript negative 1 Baseline
    bold upper U Superscript upper T EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><msup><mi mathvariant="bold">A</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <msup><mrow><mo>(</mo><mi mathvariant="bold">U</mi><mi
    mathvariant="bold">Î£</mi><msup><mi mathvariant="bold">V</mi> <mtext>T</mtext></msup>
    <mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mo>=</mo> <mi mathvariant="bold">V</mi> <msup><mi
    mathvariant="bold">Î£</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <msup><mi mathvariant="bold">U</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mo>=</mo>
    <mi mathvariant="bold">V</mi> <msup><mi mathvariant="bold">Î£</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msup><mi mathvariant="bold">U</mi> <mtext>T</mtext></msup></mrow></mtd></mtr></mtable></math>
- en: In other words, we only need to invert <math alttext="bold upper Sigma"><mi
    mathvariant="bold">Î£</mi></math>, because <math alttext="bold upper U Superscript
    negative 1 Baseline equals bold upper U Superscript upper T"><mrow><msup><mi>ğ”</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>=</mo> <msup><mi>ğ”</mi> <mtext>T</mtext></msup></mrow></math>
    . Furthermore, because <math alttext="bold upper Sigma"><mi mathvariant="bold">Î£</mi></math>
    is a diagonal matrix, its inverse is obtained simply by inverting each diagonal
    element. On the other hand, this method is still subject to numerical instabilities,
    because tiny singular values that might reflect precision errors (e.g., 10^(âˆ’15))
    become galatically large when inverted.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬åªéœ€æ±‚é€†<math alttext="bold upper Sigma"><mi mathvariant="bold">Î£</mi></math>ï¼Œå› ä¸º<math
    alttext="bold upper U Superscript negative 1 Baseline equals bold upper U Superscript
    upper T"><mrow><msup><mi>ğ”</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>=</mo>
    <msup><mi>ğ”</mi> <mtext>T</mtext></msup></mrow></math>ã€‚æ­¤å¤–ï¼Œå› ä¸º<math alttext="bold
    upper Sigma"><mi mathvariant="bold">Î£</mi></math>æ˜¯å¯¹è§’çŸ©é˜µï¼Œå…¶é€†å¯ä»¥é€šè¿‡å€’è½¬æ¯ä¸ªå¯¹è§’å…ƒç´ æ¥è·å¾—ã€‚ç„¶è€Œï¼Œè¿™ç§æ–¹æ³•ä»ç„¶å—åˆ°æ•°å€¼ä¸ç¨³å®šæ€§çš„å½±å“ï¼Œå› ä¸ºå¾®å°çš„å¥‡å¼‚å€¼å¯èƒ½åæ˜ å‡ºç²¾åº¦é”™è¯¯ï¼ˆä¾‹å¦‚10^(âˆ’15)ï¼‰ï¼Œåœ¨æ±‚é€†æ—¶ä¼šå˜å¾—æå¤§ã€‚
- en: Now for the algorithm to compute the MP pseudoinverse. Youâ€™ve waited many chapters
    for this; I appreciate your patience.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è®©æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹è®¡ç®—MPä¼ªé€†çš„ç®—æ³•ã€‚æ‚¨å·²ç»ç­‰å¾…äº†è®¸å¤šç« èŠ‚ï¼›æˆ‘æ„Ÿè°¢æ‚¨çš„è€å¿ƒã€‚
- en: The MP pseudoinverse is computed almost exactly as the full inverse shown in
    the previous example; the only modification is to invert the *nonzero* diagonal
    elements in <math alttext="bold upper Sigma"><mi mathvariant="bold">Î£</mi></math>
    instead of trying to to invert all diagonal elements. (In practice, â€œnonzeroâ€
    is implemented as above a threshold to account for precision errors.)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: MPä¼ªé€†å‡ ä¹ä¸å‰é¢ç¤ºä¾‹ä¸­æ˜¾ç¤ºçš„å®Œå…¨é€†çŸ©é˜µè®¡ç®—ç›¸åŒï¼›å”¯ä¸€çš„ä¿®æ”¹æ˜¯åè½¬<math alttext="bold upper Sigma"><mi mathvariant="bold">Î£</mi></math>ä¸­çš„*éé›¶*å¯¹è§’å…ƒç´ ï¼Œè€Œä¸æ˜¯å°è¯•åè½¬æ‰€æœ‰å¯¹è§’å…ƒç´ ã€‚ï¼ˆåœ¨å®è·µä¸­ï¼Œâ€œéé›¶â€è¢«å®ç°ä¸ºé«˜äºæŸä¸ªé˜ˆå€¼ä»¥åº”å¯¹ç²¾åº¦è¯¯å·®ã€‚ï¼‰
- en: And thatâ€™s it! Thatâ€™s how the pseudoinverse is computed. You can see that itâ€™s
    very simple and intuitive, but requires a considerable amount of background knowledge
    about linear algebra to understand.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: å°±æ˜¯è¿™æ ·ï¼è¿™å°±æ˜¯ä¼ªé€†çš„è®¡ç®—æ–¹æ³•ã€‚æ‚¨å¯ä»¥çœ‹åˆ°å®ƒéå¸¸ç®€å•å’Œç›´è§‚ï¼Œä½†éœ€è¦ç›¸å½“å¤šçš„çº¿æ€§ä»£æ•°èƒŒæ™¯çŸ¥è¯†æ‰èƒ½ç†è§£ã€‚
- en: 'Even better: because the SVD works on matrices of any size, the MP pseudoinverse
    can be applied to nonsquare matrices. In fact, the MP pseudoinverse of a tall
    matrix equals its left-inverse, and the MP pseudoinverse of a wide matrix equals
    its right-inverse. (Quick reminder that the pseudoinverse is indicated as <math
    alttext="bold upper A Superscript plus"><msup><mi>ğ€</mi> <mo>+</mo></msup></math>
    , <math alttext="bold upper A Superscript asterisk"><msup><mi>ğ€</mi> <mo>*</mo></msup></math>
    , or <math alttext="bold upper A Superscript dagger"><msup><mi>ğ€</mi> <mo>â€ </mo></msup></math>
    .)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: æ›´å¥½çš„æ˜¯ï¼šå› ä¸ºSVDé€‚ç”¨äºä»»ä½•å¤§å°çš„çŸ©é˜µï¼ŒMPä¼ªé€†å¯ä»¥åº”ç”¨äºéæ–¹é˜µã€‚å®é™…ä¸Šï¼Œé«˜çŸ©é˜µçš„MPä¼ªé€†ç­‰äºå…¶å·¦é€†ï¼Œè€Œå®½çŸ©é˜µçš„MPä¼ªé€†ç­‰äºå…¶å³é€†ã€‚ï¼ˆå¿«é€Ÿæé†’ï¼Œä¼ªé€†è¡¨ç¤ºä¸º<math
    alttext="bold upper A Superscript plus"><msup><mi>ğ€</mi> <mo>+</mo></msup></math>ï¼Œ<math
    alttext="bold upper A Superscript asterisk"><msup><mi>ğ€</mi> <mo>*</mo></msup></math>æˆ–<math
    alttext="bold upper A Superscript dagger"><msup><mi>ğ€</mi> <mo>â€ </mo></msup></math>ã€‚ï¼‰
- en: Youâ€™ll gain more experience with the pseudoinverse by implementing it yourself
    in the exercises.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡åœ¨ç»ƒä¹ ä¸­è‡ªå·±å®ç°ï¼Œæ‚¨å°†æ›´å¤šåœ°äº†è§£ä¼ªé€†ã€‚
- en: Summary
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ‘˜è¦
- en: 'I hope you agree that after putting in the effort to learn about eigendecomposition,
    a little bit of extra effort goes a long way toward understanding the SVD. The
    SVD is arguably the most important decomposition in linear algebra, because it
    reveals rich and detailed information about the matrix. Here are the key points:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘å¸Œæœ›æ‚¨åŒæ„ï¼Œåœ¨åŠªåŠ›å­¦ä¹ ç‰¹å¾åˆ†è§£åï¼Œå†å¤šä»˜å‡ºä¸€ç‚¹åŠªåŠ›å°±èƒ½æ›´å¥½åœ°ç†è§£SVDã€‚SVDå¯ä»¥è¯´æ˜¯çº¿æ€§ä»£æ•°ä¸­æœ€é‡è¦çš„åˆ†è§£æ–¹æ³•ï¼Œå› ä¸ºå®ƒæ­ç¤ºäº†å…³äºçŸ©é˜µçš„ä¸°å¯Œå’Œè¯¦ç»†ä¿¡æ¯ã€‚ä»¥ä¸‹æ˜¯å…¶å…³é”®ç‚¹ï¼š
- en: SVD decomposes a matrix (of any size and rank) into the product of three matrices,
    termed *left singular vectors* <math alttext="bold upper U"><mi>ğ”</mi></math>
    , *singular values* <math alttext="bold upper Sigma"><mi mathvariant="bold">Î£</mi></math>,
    and *right singular vectors* <math alttext="bold upper V Superscript upper T"><msup><mi>ğ•</mi>
    <mtext>T</mtext></msup></math> .
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SVDå°†ä¸€ä¸ªï¼ˆä»»æ„å¤§å°å’Œç§©ï¼‰çŸ©é˜µåˆ†è§£ä¸ºä¸‰ä¸ªçŸ©é˜µçš„ä¹˜ç§¯ï¼Œç§°ä¸º*å·¦å¥‡å¼‚å‘é‡* <math alttext="bold upper U"><mi>ğ”</mi></math>
    ï¼Œ*å¥‡å¼‚å€¼* <math alttext="bold upper Sigma"><mi mathvariant="bold">Î£</mi></math> å’Œ*å³å¥‡å¼‚å‘é‡*
    <math alttext="bold upper V Superscript upper T"><msup><mi>ğ•</mi> <mtext>T</mtext></msup></math>
    ã€‚
- en: The first *r* (where *r* is the matrix rank) left singular vectors provide an
    orthonormal basis set for the column space of the matrix, while the later singular
    vectors provide an orthonormal basis set for the left-null space.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å‰*r*ï¼ˆå…¶ä¸­*r*æ˜¯çŸ©é˜µç§©ï¼‰ä¸ªå·¦å¥‡å¼‚å‘é‡ä¸ºçŸ©é˜µçš„åˆ—ç©ºé—´æä¾›ä¸€ç»„æ ‡å‡†æ­£äº¤åŸºï¼Œè€Œåç»­çš„å¥‡å¼‚å‘é‡ä¸ºå·¦é›¶ç©ºé—´æä¾›ä¸€ç»„æ ‡å‡†æ­£äº¤åŸºã€‚
- en: 'Itâ€™s a similar story for the right singular vectors: the first *r* vectors
    provide an orthonormal basis set for the row space, while the later vectors provide
    an orthonormal basis set for the null space. Be mindful that the right singular
    vectors are actually the *rows* of <math alttext="bold upper V"><mi>ğ•</mi></math>
    , which are the *columns* of <math alttext="bold upper V Superscript upper T"><msup><mi>ğ•</mi>
    <mtext>T</mtext></msup></math> .'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¯¹äºå³å¥‡å¼‚å‘é‡ä¹Ÿæ˜¯ç±»ä¼¼çš„æƒ…å†µï¼šå‰*r*ä¸ªå‘é‡ä¸ºè¡Œç©ºé—´æä¾›ä¸€ç»„æ ‡å‡†æ­£äº¤åŸºï¼Œè€Œåç»­çš„å‘é‡ä¸ºé›¶ç©ºé—´æä¾›ä¸€ç»„æ ‡å‡†æ­£äº¤åŸºã€‚è¯·æ³¨æ„ï¼Œå³å¥‡å¼‚å‘é‡å®é™…ä¸Šæ˜¯<math alttext="bold
    upper V"><mi>ğ•</mi></math>çš„*è¡Œ*ï¼Œè¿™äº›è¡Œæ˜¯<math alttext="bold upper V Superscript upper
    T"><msup><mi>ğ•</mi> <mtext>T</mtext></msup></math>çš„*åˆ—*ã€‚
- en: The number of nonzero singular values equals the rank of the matrix. In practice,
    it can be difficult to distinguish between very small nonzero singular values
    versus precision errors on zero-valued singular values. Programs like Python will
    use a tolerance threshold to make this distinction.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: éé›¶å¥‡å¼‚å€¼çš„æ•°é‡ç­‰äºçŸ©é˜µçš„ç§©ã€‚åœ¨å®è·µä¸­ï¼Œå¾ˆéš¾åŒºåˆ†éå¸¸å°çš„éé›¶å¥‡å¼‚å€¼ä¸é›¶å€¼å¥‡å¼‚å€¼çš„ç²¾åº¦è¯¯å·®ã€‚åƒPythonè¿™æ ·çš„ç¨‹åºä¼šä½¿ç”¨å®¹å·®é˜ˆå€¼æ¥åŒºåˆ†å®ƒä»¬ã€‚
- en: The outer product of the *k*th left singular vector and the *k*th right singular
    vector, scalar multiplied by the *k*th singular value, produces a rank-1 matrix
    that can be interpreted as a â€œlayerâ€ of the matrix. Reconstructing a matrix based
    on layers has many applications, including denoising and data compression.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç¬¬ *k* ä¸ªå·¦å¥‡å¼‚å‘é‡å’Œç¬¬ *k* ä¸ªå³å¥‡å¼‚å‘é‡çš„å¤–ç§¯ï¼Œä¹˜ä»¥ç¬¬ *k* ä¸ªå¥‡å¼‚å€¼ï¼Œäº§ç”Ÿä¸€ä¸ªç§©-1çŸ©é˜µï¼Œå¯ä»¥è§£é‡Šä¸ºçŸ©é˜µçš„â€œå±‚â€ã€‚åŸºäºå±‚é‡å»ºçŸ©é˜µå…·æœ‰è®¸å¤šåº”ç”¨ï¼ŒåŒ…æ‹¬å»å™ªå’Œæ•°æ®å‹ç¼©ã€‚
- en: Conceptually, the SVD can be obtained from the eigendecomposition of <math alttext="bold
    upper A bold upper A Superscript upper T"><mrow><mi>ğ€</mi> <msup><mi>ğ€</mi> <mtext>T</mtext></msup></mrow></math>
    .
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä»æ¦‚å¿µä¸Šè®²ï¼ŒSVDå¯ä»¥ä» <math alttext="bold upper A bold upper A Superscript upper T"><mrow><mi>ğ€</mi>
    <msup><mi>ğ€</mi> <mtext>T</mtext></msup></mrow></math> çš„ç‰¹å¾åˆ†è§£ä¸­è·å¾—ã€‚
- en: The super-duper important Moore-Penrose pseudoinverse is computed as <math alttext="bold
    upper V bold upper Sigma Superscript plus Baseline bold upper U Superscript upper
    T"><mrow><mi mathvariant="bold">V</mi><msup><mi mathvariant="bold">Î£</mi> <mo>+</mo></msup>
    <msup><mi mathvariant="bold">U</mi> <mtext>T</mtext></msup></mrow></math> , where
    <math alttext="bold upper Sigma Superscript plus"><msup><mi mathvariant="bold">Î£</mi>
    <mo>+</mo></msup></math> is obtained by inverting the nonzero singular values
    on the diagonal.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¶…çº§é‡è¦çš„æ‘©å°”-å½­ç½—æ–¯ä¼ªé€†è®¡ç®—ä¸º <math alttext="bold upper V bold upper Sigma Superscript plus
    Baseline bold upper U Superscript upper T"><mrow><mi mathvariant="bold">V</mi><msup><mi
    mathvariant="bold">Î£</mi> <mo>+</mo></msup> <msup><mi mathvariant="bold">U</mi>
    <mtext>T</mtext></msup></mrow></math> ï¼Œå…¶ä¸­ <math alttext="bold upper Sigma Superscript
    plus"><msup><mi mathvariant="bold">Î£</mi> <mo>+</mo></msup></math> é€šè¿‡åè½¬å¯¹è§’çº¿ä¸Šçš„éé›¶å¥‡å¼‚å€¼è·å¾—ã€‚
- en: Code Exercises
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ä»£ç ç»ƒä¹ ã€‚
- en: Exercise 14-1\.
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ç»ƒä¹  14-1ã€‚
- en: You learned that for a symmetric matrix, the singular values and the eigenvalues
    are the same. How about the singular vectors and eigenvectors? Use Python to answer
    this question using a random <math alttext="5 times 5"><mrow><mn>5</mn> <mo>Ã—</mo>
    <mn>5</mn></mrow></math> <math alttext="bold upper A Superscript upper T Baseline
    bold upper A"><mrow><msup><mi>ğ€</mi> <mtext>T</mtext></msup> <mi>ğ€</mi></mrow></math>
    matrix. Next, try it again using the additive method for creating a symmetric
    matrix ( <math alttext="bold upper A Superscript upper T Baseline plus bold upper
    A"><mrow><msup><mi>ğ€</mi> <mtext>T</mtext></msup> <mo>+</mo> <mi>ğ€</mi></mrow></math>
    ). Pay attention to the signs of the eigenvalues of <math alttext="bold upper
    A Superscript upper T Baseline plus bold upper A"><mrow><msup><mi>ğ€</mi> <mtext>T</mtext></msup>
    <mo>+</mo> <mi>ğ€</mi></mrow></math> .
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å­¦åˆ°å¯¹äºå¯¹ç§°çŸ©é˜µï¼Œå¥‡å¼‚å€¼å’Œç‰¹å¾å€¼æ˜¯ç›¸åŒçš„ã€‚é‚£ä¹ˆå¥‡å¼‚å‘é‡å’Œç‰¹å¾å‘é‡å‘¢ï¼Ÿä½¿ç”¨ä¸€ä¸ªéšæœº <math alttext="5 times 5"><mrow><mn>5</mn>
    <mo>Ã—</mo> <mn>5</mn></mrow></math> <math alttext="bold upper A Superscript upper
    T Baseline bold upper A"><mrow><msup><mi>ğ€</mi> <mtext>T</mtext></msup> <mi>ğ€</mi></mrow></math>
    çŸ©é˜µæ¥å›ç­”è¿™ä¸ªé—®é¢˜ã€‚æ¥ä¸‹æ¥ï¼Œä½¿ç”¨åŠ æ³•æ–¹æ³•å†æ¬¡å°è¯•åˆ›å»ºå¯¹ç§°çŸ©é˜µï¼ˆ <math alttext="bold upper A Superscript upper
    T Baseline plus bold upper A"><mrow><msup><mi>ğ€</mi> <mtext>T</mtext></msup> <mo>+</mo>
    <mi>ğ€</mi></mrow></math> ï¼‰ã€‚æ³¨æ„ <math alttext="bold upper A Superscript upper T
    Baseline plus bold upper A"><mrow><msup><mi>ğ€</mi> <mtext>T</mtext></msup> <mo>+</mo>
    <mi>ğ€</mi></mrow></math> çš„ç‰¹å¾å€¼çš„ç¬¦å·ã€‚
- en: Exercise 14-2\.
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ç»ƒä¹  14-2ã€‚
- en: Python can optionally return the â€œeconomyâ€ SVD, which means that the singular
    vectors matrices are truncated at the smaller of *M* or *N*. Consult the docstring
    to figure out how to do this. Confirm with tall and wide matrices. Note that you
    would typically want to return the full matrices; economy SVD is mainly used for
    really large matrices and/or really limited computational power.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Python å¯ä»¥é€‰æ‹©è¿”å›â€œç»æµâ€SVDï¼Œè¿™æ„å‘³ç€å¥‡å¼‚å‘é‡çŸ©é˜µåœ¨è¾ƒå°çš„*M*æˆ–*N*å¤„è¢«æˆªæ–­ã€‚è¯·æŸ¥é˜…æ–‡æ¡£å­—ç¬¦ä¸²ä»¥äº†è§£å¦‚ä½•å®ç°æ­¤åŠŸèƒ½ã€‚ä¸é«˜å’Œå®½çŸ©é˜µç¡®è®¤ã€‚æ³¨æ„ï¼Œé€šå¸¸åº”è¿”å›å®Œæ•´çŸ©é˜µï¼›ç»æµå‹SVDä¸»è¦ç”¨äºéå¸¸å¤§çš„çŸ©é˜µå’Œ/æˆ–è®¡ç®—èƒ½åŠ›éå¸¸æœ‰é™çš„æƒ…å†µã€‚
- en: Exercise 14-3\.
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ç»ƒä¹  14-3ã€‚
- en: One of the important features of an orthogonal matrix (such as the left and
    right singular vectors matrices) is that they rotate, but do not scale, a vector.
    This means that the magnitude of a vector is preserved after multiplication by
    an orthogonal matrix. Prove that <math alttext="parallel-to bold upper U bold
    w parallel-to equals parallel-to bold w parallel-to"><mrow><mo>âˆ¥</mo> <mi>ğ”</mi>
    <mi>ğ°</mi> <mo>âˆ¥</mo> <mo>=</mo> <mo>âˆ¥</mo> <mi>ğ°</mi> <mo>âˆ¥</mo></mrow></math>
    . Then demonstrate this empirically in Python by using a singular vectors matrix
    from the SVD of a random matrix and a random vector.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£äº¤çŸ©é˜µï¼ˆå¦‚å·¦å’Œå³å¥‡å¼‚å‘é‡çŸ©é˜µï¼‰çš„ä¸€ä¸ªé‡è¦ç‰¹æ€§æ˜¯å®ƒä»¬å¯ä»¥æ—‹è½¬å‘é‡ä½†ä¸æ”¹å˜å…¶å¤§å°ã€‚è¿™æ„å‘³ç€ç»è¿‡æ­£äº¤çŸ©é˜µä¹˜æ³•åï¼Œå‘é‡çš„å¤§å°ä¿æŒä¸å˜ã€‚é€šè¿‡åœ¨Pythonä¸­ä½¿ç”¨æ¥è‡ªéšæœºçŸ©é˜µSVDçš„å¥‡å¼‚å‘é‡çŸ©é˜µå’Œéšæœºå‘é‡æ¥è¯æ˜
    <math alttext="parallel-to bold upper U bold w parallel-to equals parallel-to
    bold w parallel-to"><mrow><mo>âˆ¥</mo> <mi>ğ”</mi> <mi>ğ°</mi> <mo>âˆ¥</mo> <mo>=</mo>
    <mo>âˆ¥</mo> <mi>ğ°</mi> <mo>âˆ¥</mo></mrow></math>ã€‚ç„¶åé€šè¿‡å®è¯æ–¹æ³•æ¼”ç¤ºè¿™ä¸€ç‚¹ã€‚
- en: Exercise 14-4\.
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ç»ƒä¹  14-4ã€‚
- en: Create a random tall matrix with a specified condition number. Do this by creating
    two random square matrices to be <math alttext="bold upper U"><mi>ğ”</mi></math>
    and <math alttext="bold upper V"><mi>ğ•</mi></math> , and a rectangular <math alttext="bold
    upper Sigma"><mi mathvariant="bold">Î£</mi></math>. Confirm that the empirical
    condition number of <math alttext="bold upper U bold upper Sigma bold upper V
    Superscript upper T"><mrow><mi mathvariant="bold">U</mi><mi mathvariant="bold">Î£</mi><msup><mi
    mathvariant="bold">V</mi> <mtext>T</mtext></msup></mrow></math> is the same as
    the number you specified. Visualize your results in a figure like [FigureÂ 14-4](#fig_14_4).
    (I used a condition number of 42.^([4](ch14.xhtml#idm45733290915728)))
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ›å»ºä¸€ä¸ªå…·æœ‰æŒ‡å®šæ¡ä»¶æ•°çš„éšæœºé«˜ç˜¦çŸ©é˜µã€‚é€šè¿‡åˆ›å»ºä¸¤ä¸ªéšæœºæ–¹é˜µ<math alttext="bold upper U"><mi>ğ”</mi></math>å’Œ<math
    alttext="bold upper V"><mi>ğ•</mi></math>ï¼Œä»¥åŠä¸€ä¸ªçŸ©å½¢çš„<math alttext="bold upper Sigma"><mi
    mathvariant="bold">Î£</mi></math>æ¥å®ç°è¿™ä¸€ç‚¹ã€‚ç¡®è®¤<math alttext="bold upper U bold upper
    Sigma bold upper V Superscript upper T"><mrow><mi mathvariant="bold">U</mi><mi
    mathvariant="bold">Î£</mi><msup><mi mathvariant="bold">V</mi> <mtext>T</mtext></msup></mrow></math>çš„ç»éªŒæ¡ä»¶æ•°ä¸æ‚¨æŒ‡å®šçš„æ•°å­—ç›¸åŒã€‚åƒ[å›¾
    14-4](#fig_14_4)ä¸€æ ·åœ¨å›¾ä¸­å¯è§†åŒ–æ‚¨çš„ç»“æœã€‚ï¼ˆæˆ‘ä½¿ç”¨äº†ä¸€ä¸ªæ¡ä»¶æ•°ä¸º 42ã€‚^([4](ch14.xhtml#idm45733290915728))ï¼‰
- en: '![exercise 14-4](assets/plad_1404.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![ä¹ é¢˜ 14-4](assets/plad_1404.png)'
- en: Figure 14-4\. Results of Exercise 14-3
  id: totrans-116
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾ 14-4\. ä¹ é¢˜ 14-3 çš„ç»“æœ
- en: Exercise 14-5\.
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ä¹ é¢˜ 14-5\.
- en: 'Your goal here is simple: write code to reproduce [FigureÂ 14-5](#fig_14_5).
    What does this figure show? Panel A shows a <math alttext="30 times 40"><mrow><mn>30</mn>
    <mo>Ã—</mo> <mn>40</mn></mrow></math> random matrix that I created by smoothing
    random numbers (implemented as the 2D convolution between a 2D Gaussian and random
    numbers; if you are not familiar with image processing and filtering, then please
    feel free to copy the code to create this matrix from my code solution). The rest
    of panel A shows the SVD matrices. Itâ€™s interesting to note that the earlier singular
    vectors (associated with the larger singular values) are smoother while the later
    ones are more rugged; this comes from the spatial filtering.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ åœ¨è¿™é‡Œçš„ç›®æ ‡å¾ˆç®€å•ï¼šç¼–å†™ä»£ç ä»¥é‡ç°[å›¾ 14-5](#fig_14_5)ã€‚è¿™ä¸ªå›¾æ˜¾ç¤ºäº†ä»€ä¹ˆï¼Ÿé¢æ¿ A å±•ç¤ºäº†ä¸€ä¸ª<math alttext="30 times
    40"><mrow><mn>30</mn> <mo>Ã—</mo> <mn>40</mn></mrow></math>çš„éšæœºçŸ©é˜µï¼Œæˆ‘é€šè¿‡å¯¹éšæœºæ•°è¿›è¡Œå¹³æ»‘ï¼ˆå®ç°ä¸º
    2D é«˜æ–¯å’Œéšæœºæ•°ä¹‹é—´çš„ 2D å·ç§¯ï¼‰åˆ›å»ºäº†å®ƒï¼›å¦‚æœä½ å¯¹å›¾åƒå¤„ç†å’Œæ»¤æ³¢ä¸ç†Ÿæ‚‰ï¼Œè¯·éšæ„ä»æˆ‘çš„ä»£ç è§£å†³æ–¹æ¡ˆä¸­å¤åˆ¶åˆ›å»ºè¿™ä¸ªçŸ©é˜µçš„ä»£ç ã€‚é¢æ¿ A çš„å…¶ä½™éƒ¨åˆ†å±•ç¤ºäº†
    SVD çŸ©é˜µã€‚æœ‰è¶£çš„æ˜¯ï¼Œæ—©æœŸçš„å¥‡å¼‚å‘é‡ï¼ˆä¸è¾ƒå¤§çš„å¥‡å¼‚å€¼ç›¸å…³è”ï¼‰æ›´åŠ å¹³æ»‘ï¼Œè€Œåæ¥çš„åˆ™æ›´åŠ ç²—ç³™ï¼›è¿™æ˜¯æ¥è‡ªç©ºé—´æ»¤æ³¢çš„æ•ˆæœã€‚
- en: Panel B shows a â€œscree plot,â€ which is the singular values normalized to percent
    variance explained. Notice that the first few components account for most of the
    variance in the image, while the later components each account for relatively
    little variance. Confirm that the sum over all normalized singular values is 100\.
    Panel C shows the first four â€œlayersâ€â€”rank-1 matrices defined as <math alttext="bold
    u Subscript i Baseline sigma Subscript i Baseline bold v Subscript i Superscript
    upper T"><mrow><msub><mi>ğ®</mi> <mi>i</mi></msub> <msub><mi>Ïƒ</mi> <mi>i</mi></msub>
    <msubsup><mi>ğ¯</mi> <mi>i</mi> <mtext>T</mtext></msubsup></mrow></math> â€”on the
    top row and the cumulative sum of those layers on the bottom row. You can see
    that each layer adds more information to the matrix; the lower-right image (titled
    â€œL 0:3â€) is a rank-4 matrix and yet appears visually very similar to the original
    rank-30 matrix in panel A.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: é¢æ¿ B å±•ç¤ºäº†ä¸€ä¸ªâ€œscree plotâ€ï¼Œå³å½’ä¸€åŒ–ä¸ºç™¾åˆ†æ¯”æ–¹å·®è§£é‡Šçš„å¥‡å¼‚å€¼å›¾ã€‚è¯·æ³¨æ„ï¼Œå‰å‡ ä¸ªåˆ†é‡å äº†å›¾åƒä¸­å¤§éƒ¨åˆ†çš„æ–¹å·®ï¼Œè€Œåç»­çš„åˆ†é‡æ¯ä¸ªéƒ½åªè§£é‡Šäº†ç›¸å¯¹è¾ƒå°‘çš„æ–¹å·®ã€‚ç¡®è®¤æ‰€æœ‰å½’ä¸€åŒ–å¥‡å¼‚å€¼çš„æ€»å’Œä¸º
    100\. é¢æ¿ C å±•ç¤ºäº†å‰å››ä¸ªâ€œå±‚æ¬¡â€â€”â€”å®šä¹‰ä¸º<math alttext="bold u Subscript i Baseline sigma Subscript
    i Baseline bold v Subscript i Superscript upper T"><mrow><msub><mi>ğ®</mi> <mi>i</mi></msub>
    <msub><mi>Ïƒ</mi> <mi>i</mi></msub> <msubsup><mi>ğ¯</mi> <mi>i</mi> <mtext>T</mtext></msubsup></mrow></math>â€”â€”åœ¨é¡¶éƒ¨è¡Œå’Œè¿™äº›å±‚æ¬¡çš„ç´¯ç§¯å’Œåœ¨åº•éƒ¨è¡Œã€‚ä½ å¯ä»¥çœ‹åˆ°æ¯ä¸ªå±‚æ¬¡éƒ½å‘çŸ©é˜µæ·»åŠ äº†æ›´å¤šä¿¡æ¯ï¼›å³ä¸‹è§’çš„å›¾åƒï¼ˆæ ‡é¢˜ä¸ºâ€œL
    0:3â€ï¼‰æ˜¯ä¸€ä¸ªç§©ä¸º 4 çš„çŸ©é˜µï¼Œä½†åœ¨è§†è§‰ä¸Šä¸é¢æ¿ A ä¸­åŸå§‹çš„ç§© 30 çŸ©é˜µéå¸¸ç›¸ä¼¼ã€‚
- en: '![exercise 14-5](assets/plad_1405.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![ä¹ é¢˜ 14-5](assets/plad_1405.png)'
- en: Figure 14-5\. Results of Exercise 14-5
  id: totrans-121
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾ 14-5\. ä¹ é¢˜ 14-5 çš„ç»“æœ
- en: Exercise 14-6\.
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ä¹ é¢˜ 14-6\.
- en: Implement the MP pseduoinverse based on the description in this chapter. Youâ€™ll
    need to define a tolerance to ignore tiny-but-nonzero singular values. Please
    donâ€™t look up NumPyâ€™s implementationâ€”and donâ€™t check back to earlier code in this
    chapterâ€”but instead use your knowledge of linear algebra to come up with your
    own tolerance.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: æ ¹æ®æœ¬ç« æè¿°å®ç° MP ä¼ªé€†ã€‚ä½ éœ€è¦å®šä¹‰ä¸€ä¸ªå®¹å·®æ¥å¿½ç•¥å¾®å°ä½†éé›¶çš„å¥‡å¼‚å€¼ã€‚è¯·ä¸è¦æŸ¥é˜… NumPy çš„å®ç°ï¼Œä¹Ÿä¸è¦å›é¡¾æœ¬ç« çš„æ—©æœŸä»£ç ï¼Œè€Œæ˜¯åˆ©ç”¨ä½ å¯¹çº¿æ€§ä»£æ•°çš„çŸ¥è¯†è‡ªè¡Œè®¾è®¡å®¹å·®ã€‚
- en: Test your code on a <math alttext="5 times 5"><mrow><mn>5</mn> <mo>Ã—</mo> <mn>5</mn></mrow></math>
    rank-3 matrix. Compare your result against the output of NumPyâ€™s `pinv` function.
    Finally, inspect the source code for `np.linalg.pinv` to make sure you understand
    the implementation.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸€ä¸ª <math alttext="5 times 5"><mrow><mn>5</mn> <mo>Ã—</mo> <mn>5</mn></mrow></math>
    ç§©ä¸º3çš„çŸ©é˜µä¸Šæµ‹è¯•ä½ çš„ä»£ç ã€‚å°†ç»“æœä¸NumPyçš„ `pinv` å‡½æ•°çš„è¾“å‡ºè¿›è¡Œæ¯”è¾ƒã€‚æœ€åï¼Œæ£€æŸ¥ `np.linalg.pinv` çš„æºä»£ç ä»¥ç¡®ä¿ä½ ç†è§£å…¶å®ç°ã€‚
- en: Exercise 14-7\.
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ç»ƒä¹  14-7\.
- en: Demonstrate that the MP pseudoinverse equals the left-inverse for a full column-rank
    matrix by computing the explicit left-inverse of a tall full matrix ( <math alttext="left-parenthesis
    bold upper A Superscript upper T Baseline bold upper A right-parenthesis Superscript
    negative 1 Baseline bold upper A Superscript upper T"><mrow><msup><mrow><mo>(</mo><msup><mi>ğ€</mi>
    <mtext>T</mtext></msup> <mi>ğ€</mi><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msup><mi>ğ€</mi> <mtext>T</mtext></msup></mrow></math> ) and the pseudoinverse
    of <math alttext="bold upper A"><mi>ğ€</mi></math> . Repeat for the right inverse
    with a wide full row-rank matrix.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡è®¡ç®—é«˜åˆ—æ»¡ç§©çŸ©é˜µçš„æ˜¾å¼å·¦é€†è¯æ˜MPä¼ªé€†ç­‰äºå·¦é€†ï¼Œï¼ˆ <math alttext="left-parenthesis bold upper A Superscript
    upper T Baseline bold upper A right-parenthesis Superscript negative 1 Baseline
    bold upper A Superscript upper T"><mrow><msup><mrow><mo>(</mo><msup><mi>ğ€</mi>
    <mtext>T</mtext></msup> <mi>ğ€</mi><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msup><mi>ğ€</mi> <mtext>T</mtext></msup></mrow></math> )ï¼Œä»¥åŠ <math alttext="bold
    upper A"><mi>ğ€</mi></math> çš„ä¼ªé€†ã€‚å¯¹äºå®½è¡Œæ»¡ç§©çŸ©é˜µï¼Œé‡å¤å³é€†çš„æƒ…å†µã€‚
- en: Exercise 14-8\.
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ç»ƒä¹  14-8\.
- en: 'Consider the eigenvalue equation <math alttext="bold upper A bold v equals
    lamda bold v"><mrow><mi>ğ€</mi> <mi>ğ¯</mi> <mo>=</mo> <mi>Î»</mi> <mi>ğ¯</mi></mrow></math>
    . Now that you know about the pseudoinverse, you can play around with that equation
    a bit. In particular, use the <math alttext="2 times 2"><mrow><mn>2</mn> <mo>Ã—</mo>
    <mn>2</mn></mrow></math> matrix used at the outset of [ChapterÂ 13](ch13.xhtml#Chapter_13)
    to compute <math alttext="bold v Superscript plus"><msup><mi>ğ¯</mi> <mo>+</mo></msup></math>
    and confirm that <math alttext="bold v bold v Superscript plus Baseline equals
    1"><mrow><mi>ğ¯</mi> <msup><mi>ğ¯</mi> <mo>+</mo></msup> <mo>=</mo> <mn>1</mn></mrow></math>
    . Next, confirm the following identities:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: è€ƒè™‘ç‰¹å¾å€¼æ–¹ç¨‹ <math alttext="bold upper A bold v equals lamda bold v"><mrow><mi>ğ€</mi>
    <mi>ğ¯</mi> <mo>=</mo> <mi>Î»</mi> <mi>ğ¯</mi></mrow></math> ã€‚ç°åœ¨ä½ å·²ç»äº†è§£äº†ä¼ªé€†ï¼Œå¯ä»¥ç¨å¾®ç©å¼„ä¸€ä¸‹è¿™ä¸ªæ–¹ç¨‹ã€‚ç‰¹åˆ«æ˜¯ï¼Œä½¿ç”¨åœ¨[ç¬¬13ç« ](ch13.xhtml#Chapter_13)å¼€å§‹æ—¶ä½¿ç”¨çš„
    <math alttext="2 times 2"><mrow><mn>2</mn> <mo>Ã—</mo> <mn>2</mn></mrow></math>
    çŸ©é˜µè®¡ç®— <math alttext="bold v Superscript plus"><msup><mi>ğ¯</mi> <mo>+</mo></msup></math>
    å¹¶ç¡®è®¤ <math alttext="bold v bold v Superscript plus Baseline equals 1"><mrow><mi>ğ¯</mi>
    <msup><mi>ğ¯</mi> <mo>+</mo></msup> <mo>=</mo> <mn>1</mn></mrow></math> ã€‚æ¥ä¸‹æ¥ï¼Œç¡®è®¤ä»¥ä¸‹æ’ç­‰å¼ï¼š
- en: <math alttext="StartLayout 1st Row 1st Column bold v Superscript plus Baseline
    bold upper A bold v 2nd Column equals lamda bold v Superscript plus Baseline bold
    v 2nd Row 1st Column bold upper A bold v bold v Superscript plus 2nd Column equals
    lamda bold v bold v Superscript plus EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mrow><msup><mi>ğ¯</mi> <mo>+</mo></msup> <mi>ğ€</mi> <mi>ğ¯</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>Î»</mi> <msup><mi>ğ¯</mi> <mo>+</mo></msup>
    <mi>ğ¯</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mrow><mi>ğ€</mi> <mi>ğ¯</mi>
    <msup><mi>ğ¯</mi> <mo>+</mo></msup></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mi>Î»</mi> <mi>ğ¯</mi> <msup><mi>ğ¯</mi> <mo>+</mo></msup></mrow></mtd></mtr></mtable></math>
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column bold v Superscript plus Baseline
    bold upper A bold v 2nd Column equals lamda bold v Superscript plus Baseline bold
    v 2nd Row 1st Column bold upper A bold v bold v Superscript plus 2nd Column equals
    lamda bold v bold v Superscript plus EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mrow><msup><mi>ğ¯</mi> <mo>+</mo></msup> <mi>ğ€</mi> <mi>ğ¯</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>Î»</mi> <msup><mi>ğ¯</mi> <mo>+</mo></msup>
    <mi>ğ¯</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mrow><mi>ğ€</mi> <mi>ğ¯</mi>
    <msup><mi>ğ¯</mi> <mo>+</mo></msup></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mi>Î»</mi> <mi>ğ¯</mi> <msup><mi>ğ¯</mi> <mo>+</mo></msup></mrow></mtd></mtr></mtable></math>
- en: ^([1](ch14.xhtml#idm45733291549488-marker)) The SVD is not the same as eigendecomposition
    for all square matrices; more on this later.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch14.xhtml#idm45733291549488-marker)) å¯¹äºæ‰€æœ‰æ–¹é˜µï¼Œå¥‡å¼‚å€¼åˆ†è§£ä¸ç‰¹å¾åˆ†è§£å¹¶ä¸ç›¸åŒï¼›ç¨åè¯¦ç»†è®¨è®ºã€‚
- en: ^([2](ch14.xhtml#idm45733291241712-marker)) There is no point in summing the
    zero-valued singular values, because thatâ€™s just adding zeros matrices.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch14.xhtml#idm45733291241712-marker)) æ²¡æœ‰æ„ä¹‰å¯¹é›¶å€¼å¥‡å¼‚å€¼æ±‚å’Œï¼Œå› ä¸ºé‚£åªæ˜¯åœ¨åŠ é›¶çŸ©é˜µã€‚
- en: ^([3](ch14.xhtml#idm45733291075808-marker)) The proof of this statement is in
    [Exercise 14-3](#exercise_14_3).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch14.xhtml#idm45733291075808-marker)) è¿™ä¸ªé™ˆè¿°çš„è¯æ˜åœ¨[ç»ƒä¹  14-3](#exercise_14_3)ä¸­ã€‚
- en: ^([4](ch14.xhtml#idm45733290915728-marker)) Yes, thatâ€™s another reference to
    *Hitchhikerâ€™s Guide to the Galaxy*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch14.xhtml#idm45733290915728-marker)) è¿™æ˜¯å¯¹ã€Šé“¶æ²³ç³»æ¼«æ¸¸æŒ‡å—ã€‹çš„å¦ä¸€ä¸ªå¼•ç”¨ã€‚
