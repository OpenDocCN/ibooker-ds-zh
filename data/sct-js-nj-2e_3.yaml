- en: Part 4\. Browser reconnaissance
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第四部分\. 浏览器侦察
- en: Now that we’ve explored the fundamentals of the JavaScript language, we’ll move
    on to browsers, the environment in which most JavaScript applications are executed.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了JavaScript语言的基础，我们将转向浏览器，这是大多数JavaScript应用执行的环境。
- en: In [chapter 12](kindle_split_025.html#ch12), we’ll take a closer look at the
    DOM by exploring efficient techniques for modifying the DOM and achieving fast,
    highly dynamic web applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](kindle_split_025.html#ch12)中，我们将通过探索修改DOM的有效技术来更深入地了解DOM，以实现快速、高度动态的网络应用。
- en: In [chapter 13](kindle_split_026.html#ch13), you’ll learn about events, with
    a special focus on the event loop and its influence on perceived web application
    performance.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第13章](kindle_split_026.html#ch13)中，你将了解事件，特别关注事件循环及其对感知网络应用性能的影响。
- en: 'Finally, the book concludes with a not-so-pleasant but necessary topic: cross-browser
    development. Although the state of affairs has improved greatly in recent years,
    we still can’t assume that our code will work in the same way in every available
    browser. Therefore, [chapter 14](kindle_split_027.html#ch14) presents strategies
    for developing cross-browser web applications.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这本书以一个不太愉快但必要的主题结束：跨浏览器开发。尽管近年来情况有了很大改善，但我们仍然不能假设我们的代码在所有可用的浏览器中将以相同的方式工作。因此，[第14章](kindle_split_027.html#ch14)介绍了开发跨浏览器网络应用的战略。
- en: Chapter 12\. Working the DOM
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第12章\. 操作DOM
- en: '*This chapter covers*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Inserting HTML into the DOM
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将HTML插入DOM
- en: Understanding DOM attributes and DOM properties
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解DOM属性和DOM属性
- en: Discovering computed styles
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现计算样式
- en: Dealing with layout thrashing
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理布局抖动
- en: Up to now, you’ve been learning mostly about JavaScript the language, and although
    there are plenty of nuances to pure JavaScript, developing web applications definitely
    doesn’t get any easier when we throw the browser’s Document Object Model (DOM)
    into the mix. One of the primary means for achieving highly dynamic web applications
    that respond to user actions is by modifying the DOM. But if we were to open up
    a JavaScript library, you’d notice the length and complexity of the code behind
    simple DOM operations. Even presumably simple operations like `cloneNode` and
    `removeChild` have relatively complex implementations.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你主要学习的是JavaScript语言，尽管纯JavaScript有很多细微差别，但当我们把浏览器的文档对象模型（DOM）加入其中时，开发网络应用肯定不会变得更容易。实现高度动态且对用户动作做出响应的网络应用的主要方法之一是修改DOM。但如果打开一个JavaScript库，你会注意到简单DOM操作背后的代码的长度和复杂性。即使是像`cloneNode`和`removeChild`这样的看似简单的操作也有相对复杂的实现。
- en: 'This raises two questions:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这提出了两个问题：
- en: Why is this code so complex?
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么这段代码如此复杂？
- en: Why do you need to understand how it works if the library will take care of
    it for you?
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果库会为你处理它，为什么你需要了解它是如何工作的？
- en: The most compelling reason is *performance*. Understanding how DOM modification
    works in libraries can allow you to write better and faster code that uses the
    library or, alternatively, enable you to use those techniques in your own code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最有力的理由是**性能**。了解库中DOM修改的工作原理可以让你编写更好、更快的代码，使用库，或者，你也可以将这些技术应用到自己的代码中。
- en: So we’ll start this chapter by seeing how to create new parts of our pages,
    on demand, by injecting arbitrary HTML. We’ll continue by examining all the conundrums
    that browsers throw at us with respect to element properties and attributes, and
    we’ll discover why the results aren’t always exactly what we might expect.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将从探讨如何通过注入任意HTML按需创建我们页面的新部分开始本章。然后，我们将检查浏览器在元素属性和属性方面对我们提出的所有难题，并发现为什么结果并不总是我们可能期望的那样。
- en: The same goes for Cascading Style Sheets (CSS) and the styling of elements.
    Many of the difficulties that we’ll run into when constructing a dynamic web application
    stem from the complications of setting and getting element styling. This book
    can’t cover all that’s known about handling element styling (that’s enough to
    fill another entire book), but the core essentials are discussed.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样适用于层叠样式表（CSS）和元素的样式。我们在构建动态网络应用时遇到的许多困难都源于设置和获取元素样式的复杂性。这本书无法涵盖关于处理元素样式的所有已知信息（这足以填满另一整本书），但核心要点已讨论。
- en: We’ll finish the chapter by taking a look at some of the performance difficulties
    that can arise if you don’t pay attention to the way you modify and read information
    from the DOM. Let’s start by seeing how to inject arbitrary HTML into our pages.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过查看一些可能出现的性能困难来结束本章，这些困难可能出现在你没有注意你修改和从DOM中读取信息的方式时。让我们首先看看如何将任意HTML注入我们的页面。
- en: Do you know?
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你知道吗？
- en: '**Q1:**'
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q1:**'
- en: ''
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why do you need to preparse self-closing elements in a page before injecting
    HTML into it?
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么在将HTML注入页面之前需要预先解析页面中的自闭合元素？
- en: '**Q2:**'
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q2:**'
- en: ''
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are the benefits of working with DOM fragments when inserting HTML?
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在插入HTML时，与DOM片段一起工作的好处是什么？
- en: '**Q3:**'
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q3:**'
- en: ''
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How do you determine the dimensions of a hidden element on a page?
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你如何确定页面中隐藏元素的尺寸？
- en: 12.1\. Injecting HTML into the DOM
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1. 将HTML注入DOM
- en: 'In this section, we’ll look at an efficient way to insert HTML into a document
    at any location, given that HTML as a string. We present this particular technique
    because it’s frequently used to create highly dynamic web pages in which the user
    interface is modified as a response to user actions or data incoming from the
    server. This is particularly useful for the following scenarios:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一种在给定HTML字符串的情况下，在任何位置高效插入HTML的方法。我们提出这种特定的技术，因为它经常用于创建高度动态的网页，其中用户界面作为对用户操作或从服务器接收的数据的响应而修改。这在以下场景中尤其有用：
- en: Injecting arbitrary HTML into a page and manipulating and inserting client-side
    templates
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将任意HTML注入页面，并操作和插入客户端模板
- en: Retrieving and injecting HTML sent from a server
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取和注入从服务器发送的HTML
- en: 'It can be technically challenging to implement this functionality correctly
    (especially when compared to building an object-oriented-style DOM construction
    API, which is certainly easier to implement but requires an extra layer of abstraction
    than injecting the HTML). Consider this example of creating HTML elements from
    an HTML string that we can use with jQuery:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正确实现此功能可能具有技术挑战性（尤其是与构建面向对象的DOM构建API相比，后者当然更容易实现，但需要比注入HTML额外的抽象层）。考虑以下示例，从HTML字符串创建HTML元素，我们可以使用jQuery：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And compare that with an approach that uses only the DOM API:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与仅使用DOM API的方法进行比较：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Which one would you rather use?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你更愿意使用哪一个？
- en: 'For these reasons, we’ll implement our own way of doing clean DOM manipulation
    from scratch. The implementation requires the following steps:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，我们将从头开始实现我们自己的清洁DOM操作方法。实现需要以下步骤：
- en: Convert an arbitrary but valid HTML string into a DOM structure.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将任意但有效的HTML字符串转换为DOM结构。
- en: Inject that DOM structure into any location in the DOM as efficiently as possible.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽可能高效地将该DOM结构注入DOM中的任何位置。
- en: These steps provide page authors with a smart way to inject HTML into a document.
    Let’s get started.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤为页面作者提供了一种智能的方法来将HTML注入文档。让我们开始吧。
- en: 12.1.1\. Converting HTML to DOM
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.1.1. 将HTML转换为DOM
- en: 'Converting an HTML string to a DOM structure doesn’t involve a whole lot of
    magic. In fact, it uses a tool that you’re most likely already familiar with:
    the `innerHTML` property of DOM elements.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 将HTML字符串转换为DOM结构并不涉及太多的魔法。实际上，它使用了一个你可能已经很熟悉的工具：DOM元素的`innerHTML`属性。
- en: 'Using it is a multistep process:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它是一个多步骤的过程：
- en: Make sure that the HTML string contains valid HTML code.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保HTML字符串包含有效的HTML代码。
- en: Wrap the string in any enclosing markup that’s required by browser rules.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字符串包裹在任何浏览器规则要求的封装标记中。
- en: Insert the HTML string, using `innerHTML`, into a dummy DOM element.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`innerHTML`将HTML字符串插入到虚拟DOM元素中。
- en: Extract the DOM nodes back out.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将DOM节点提取出来。
- en: The steps aren’t overly complex, but the actual insertion has some gotchas that
    we’ll need to take into account. Let’s take a look at each step in detail.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤并不过于复杂，但实际的插入有一些需要注意的陷阱。让我们详细看看每个步骤。
- en: Preprocessing the HTML source string
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 预处理HTML源字符串
- en: 'To start, we’ll need to clean up the source HTML to meet our needs. For example,
    let’s take a look at a skeleton HTML that allows us to choose a ninja (through
    the `option` element) and that shows the details of the chosen ninja within a
    table, details that are intended to be added at a later point:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要清理源HTML以满足我们的需求。例如，让我们看看一个骨架HTML，它允许我们通过`option`元素选择一个忍者，并在表格中显示所选忍者的详细信息，这些详细信息打算稍后添加：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This HTML string has two problems. First, the option elements shouldn’t stand
    on their own. If you follow proper HTML semantics, they should be contained within
    a `select` element. Second, even though markup languages usually allow us to self-close
    childless elements, such as `<table/>`, in HTML the self-closing works for only
    a small subset of elements (`table` not being one of them). Attempting to use
    that syntax in other cases is likely to cause problems in some browsers.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个HTML字符串有两个问题。首先，选项元素不应该独立存在。如果你遵循正确的HTML语义，它们应该包含在一个 `select` 元素内。其次，尽管标记语言通常允许我们自闭合无子元素的元素，如
    `<table/>`，但在HTML中，自闭合只适用于一小部分元素（`table` 不是其中之一）。在其他情况下尝试使用该语法可能会在某些浏览器中引起问题。
- en: Let’s start with solving the problem of self-closing elements. To support this
    feature, we can do a quick preparse on the HTML string to convert elements such
    as `<table/>` to `<table></table>` (which will be handled uniformly in all browsers),
    as shown in the following listing.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从解决自闭合元素的问题开始。为了支持这个特性，我们可以在HTML字符串上进行快速预解析，将如 `<table/>` 这样的元素转换为 `<table></table>`（这将在所有浏览器中统一处理），如下面的列表所示。
- en: Listing 12.1\. Making sure that self-closing elements are interpreted correctly
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.1\. 确保自闭合元素被正确解释
- en: '![](308fig01_alt.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](308fig01_alt.jpg)'
- en: 'When we apply the `convert` function to this example HTML string, we end up
    with the following HTML string:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 `convert` 函数应用于这个示例HTML字符串时，我们最终得到以下HTML字符串：
- en: '![](308fig02.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](308fig02.jpg)'
- en: With that accomplished, we still have to solve the problem that our `option`
    elements aren’t contained within a `select` element. Let’s see how to determine
    whether an element needs to be wrapped.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们仍然需要解决我们的 `option` 元素不包含在 `select` 元素中的问题。让我们看看如何确定一个元素是否需要被包裹。
- en: HTML wrapping
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: HTML包裹
- en: According to the semantics of HTML, some HTML elements must be within certain
    container elements before they can be injected. For example, an `<option>` element
    must be contained within a `<select>`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 根据HTML的语义，一些HTML元素在注入之前必须位于某些容器元素内。例如，一个 `<option>` 元素必须包含在一个 `<select>` 元素内。
- en: 'We can solve this problem in two ways, both of which require constructing a
    mapping between problematic elements and their containers:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两种方式解决这个问题，这两种方式都需要在问题元素和它们的容器之间构建映射：
- en: The string could be injected directly into a specific parent by using `innerHTML`,
    where the parent has been previously constructed using the built-in `document
    createElement`. Although this may work in some cases and in some browsers, it
    isn’t universally guaranteed.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过使用 `innerHTML` 将字符串直接注入到特定的父元素中，其中父元素之前已经使用内置的 `document.createElement`
    构建过。尽管在某些情况下和某些浏览器中这可能有效，但它并不保证在所有情况下都有效。
- en: The string could be wrapped with the appropriate required markup and then injected
    directly into any container element (such as a `<div>`). This is more foolproof,
    but it’s also more work.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将字符串包裹在适当的所需标记中，然后直接注入到任何容器元素中（例如一个 `<div>`）。这更可靠，但工作量也更大。
- en: The second technique is preferred; it involves little browser-specific code,
    in contrast to the first approach, which requires a fair amount of mostly browser-specific
    code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种技术更受欢迎；与第一种方法相比，它涉及很少的特定浏览器代码，而第一种方法需要相当多的主要是特定浏览器代码。
- en: The set of problematic elements that need to be wrapped in specific container
    elements is fortunately a rather manageable seven. In [table 12.1](#ch12table01),
    the ellipses (`...`) indicates the locations where the elements need to be injected.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 需要包裹在特定容器元素中的问题元素集幸运地只有七个是可管理的。在[表12.1](#ch12table01)中，省略号(`...`)表示元素需要注入的位置。
- en: Table 12.1\. Elements that need to be contained within other elements
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表12.1\. 需要包含在其他元素中的元素
- en: '| Element name | Ancestor element |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 元素名称 | 祖先元素 |'
- en: '| --- | --- |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <option>, <optgroup> | <select multiple>...</select> |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| <option>, <optgroup> | <select multiple>...</select> |'
- en: '| <legend> | <fieldset>...</fieldset> |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| <legend> | <fieldset>...</fieldset> |'
- en: '| <thead>, <tbody>, <tfoot>, <colgroup>, <caption> | <table>...</table> |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| <thead>, <tbody>, <tfoot>, <colgroup>, <caption> | <table>...</table> |'
- en: '| <tr> | <table><thead>...</thead></table> <table><tbody>...</tbody></table>'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '| <tr> | <table><thead>...</thead></table> <table><tbody>...</tbody></table>
    |'
- en: <table><tfoot>...</tfoot></table> |
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <table><tfoot>...</tfoot></table> |
- en: '| <td>, <th> | <table><tbody><tr>...</tr></tbody></table> |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| <td>, <th> | <table><tbody><tr>...</tr></tbody></table> |'
- en: '| <col> | <table> <tbody></tbody>'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '| <col> | <table> <tbody></tbody> |'
- en: <colgroup>...</colgroup>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <colgroup>...</colgroup>
- en: </table> |
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: </table> |
- en: 'Nearly all of these are straightforward, save for the following points, which
    require a bit of explanation:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有这些都是直接的，除了以下需要一些解释的点：
- en: A `<select>` element with the `multiple` attribute is used (as opposed to a
    nonmultiple select) because it won’t automatically check any of the options that
    are placed inside it (whereas a single select will autocheck the first option).
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用具有`multiple`属性的`<select>`元素（而不是非多选选择），因为它不会自动检查放置在其内的任何选项（而单选将自动检查第一个选项）。
- en: The `<col>` fix includes an extra `<tbody>`, without which the `<colgroup>`
    won’t be generated properly.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<col>`修复包括一个额外的`<tbody>`，没有它，`<colgroup>`将无法正确生成。'
- en: With the elements properly mapped to their wrapping requirements, let’s start
    generating.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在元素正确映射到其包装要求之后，让我们开始生成。
- en: With the information from [table 12.1](#ch12table01), we can generate the HTML
    that we need to insert into a DOM element, as shown in the following listing.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[表 12.1](#ch12table01)中的信息，我们可以生成需要插入到DOM元素中的HTML，如下所示。
- en: Listing 12.2\. Generating a list of DOM nodes from some markup
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.2\. 从一些标记生成DOM节点列表
- en: '![](ch12ex02-0.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](ch12ex02-0.jpg)'
- en: '![](ch12ex02-1.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](ch12ex02-1.jpg)'
- en: 'We create a map of all element types that need to be placed within special
    parent containers, a map that contains the depth of the node, as well as the enclosing
    HTML. Next, we use a regular expression to match the opening bracket and the tag
    name of the element we want to insert:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个映射，其中包含需要放置在特殊父容器内的所有元素类型，该映射包含节点的深度以及封装的HTML。接下来，我们使用正则表达式来匹配要插入的元素的打开括号和标签名：
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then we select a map entry, and in case there isn’t one, we create a dummy
    entry with an empty parent element markup:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们选择一个映射条目，如果没有，我们创建一个带有空父元素标记的虚拟条目：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We follow this by creating a new `div` element, surrounding it with the mapped
    HTML, and inserting the newly created HTML into the previously created `div` element:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后创建一个新的`div`元素，将其与映射的HTML包装在一起，并将新创建的HTML插入到之前创建的`div`元素中：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, we find the parent of the desired node created from our HTML string,
    and we return the newly created node:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们找到从我们的HTML字符串创建的所需节点的父节点，并返回新创建的节点：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After all of this, we have a set of DOM nodes that we can begin to insert into
    the document.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些之后，我们有一组DOM节点可以开始插入到文档中。
- en: 'If we go back to our motivating example, and apply the `getNodes` function,
    we’ll end up with something along the following lines:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到我们的动机示例，并应用`getNodes`函数，我们最终会得到以下类似的结果：
- en: '![](311fig01.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](311fig01.jpg)'
- en: 12.1.2\. Inserting elements into the document
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.1.2\. 在文档中插入元素
- en: After we have the DOM nodes, it’s time to insert them into the document. A couple
    of steps are required, and we’ll work through them in this section.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们获得DOM节点后，是时候将它们插入到文档中了。需要几个步骤，我们将在本节中逐一介绍。
- en: Because we have an array of elements that we need to insert—potentially into
    any number of locations within the document—we want to try to keep the number
    of operations performed to a minimum. We can do this by using *DOM fragments*.
    DOM fragments are part of the W3C DOM specification and are supported in all browsers.
    This useful facility gives us a container to hold a collection of DOM nodes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要插入的元素数组——可能插入到文档中的任何位置——我们希望尽量减少执行的操作数量。我们可以通过使用*DOM片段*来实现这一点。DOM片段是W3C
    DOM规范的一部分，并且所有浏览器都支持。这个有用的功能为我们提供了一个容器来保存一组DOM节点。
- en: This in itself is quite useful, but it also has the advantage that the fragment
    can be injected and cloned in a single operation instead of having to inject and
    clone each individual node over and over again. This has the potential to dramatically
    reduce the number of operations required for a page.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这本身很有用，但它还有一个优点，即片段可以在单个操作中注入和克隆，而不是每次都要重复注入和克隆每个单独的节点。这有可能大大减少页面所需的操作数量。
- en: Before we use this mechanism in our code, let’s revisit the `getNodes()` code
    of [listing 12.2](#ch12ex02) and adjust it a tad to use DOM fragments. The changes
    are minor and consist of adding a `fragment` parameter to the function’s parameter
    list, as follows.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将在代码中使用此机制之前，让我们回顾一下[列表 12.2](#ch12ex02)中的`getNodes()`代码，并稍作调整以使用DOM片段。这些更改很小，包括向函数参数列表中添加一个`fragment`参数，如下所示。
- en: Listing 12.3\. Expanding the getNodes function with fragments
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.3\. 使用片段扩展getNodes函数
- en: '![](ch12ex03-0.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](ch12ex03-0.jpg)'
- en: '![](ch12ex03-1.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](ch12ex03-1.jpg)'
- en: 'In this example, we make a couple of changes. First we modify the function
    signature by adding another parameter, `fragment`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们进行了一些修改。首先，我们通过添加另一个参数`fragment`修改了函数签名：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This parameter, if it’s passed, is expected to be a DOM fragment that we want
    the nodes to be injected into for later use.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递了此参数，则预期它是一个DOM片段，我们希望将节点注入其中以供以后使用。
- en: 'To do so, we add the following fragment just before the `return` statement
    of the function to add the nodes to the passed fragment:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们在函数的`return`语句之前添加以下片段，以便将节点添加到传递的片段中：
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, let’s see it in use. In the following listing, which assumes that the updated
    `getNodes` function is in scope, a fragment is created and passed in to that function
    (which, you may recall, converts the incoming HTML string into DOM elements).
    This DOM is now appended to the fragment.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看它是如何使用的。在下面的列表中，假设更新的`getNodes`函数在作用域内，创建了一个片段并将其传递给该函数（你可能还记得，该函数将传入的HTML字符串转换为DOM元素）。现在，这个DOM被附加到片段中。
- en: Listing 12.4\. Inserting a DOM fragment into multiple locations in the DOM
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.4\. 在DOM的多个位置插入DOM片段
- en: '![](ch12ex04-0.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](ch12ex04-0.jpg)'
- en: '![](ch12ex04-1.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](ch12ex04-1.jpg)'
- en: 'There’s another important point here: If we’re inserting this element into
    more than one location in the document, we’re going to need to clone this fragment
    again and again. If we weren’t using a fragment, we’d have to clone each individual
    node every time, instead of the whole fragment at once.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个重要的点：如果我们将此元素插入文档的多个位置，我们将需要反复克隆此片段。如果我们没有使用片段，我们就必须每次都克隆每个单独的节点，而不是整个片段。
- en: With this, we’ve developed a way to generate and insert arbitrary DOM elements
    in an intuitive manner. Let’s continue this exploration of the DOM by seeing the
    difference between DOM attributes and properties.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经开发出了一种以直观方式生成和插入任意DOM元素的方法。让我们继续探索DOM，看看DOM属性和属性之间的区别。
- en: 12.2\. Using DOM attributes and properties
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2\. 使用DOM属性和属性
- en: 'When accessing the values of element attributes, we have two options: using
    the traditional DOM methods of `getAttribute` and `setAttribute,` or using properties
    of the DOM objects that correspond to the attributes.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问元素属性值时，我们有两种选择：使用传统的DOM方法`getAttribute`和`setAttribute`，或者使用与属性对应的DOM对象属性。
- en: 'For example, to obtain the `id` of an element whose reference is stored in
    variable `e`, we could use either of the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要获取存储在变量`e`中的元素的`id`，我们可以使用以下两种方法中的任何一种：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Either will give us the value of the `id`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 任何一种方法都会给我们`id`的值。
- en: Let’s examine the following code to better understand how attribute values and
    their corresponding properties behave.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查以下代码，以更好地理解属性值及其对应属性的行为。
- en: Listing 12.5\. Accessing attribute values via DOM methods and properties
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.5\. 通过DOM方法和属性访问属性值
- en: '![](313fig01_alt.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](313fig01_alt.jpg)'
- en: This example shows interesting behavior with respect to element attributes and
    element properties. It starts by defining a simple `<div>` element that we’ll
    use as a test subject. Within the document’s `DOMContentLoaded` handler (to ensure
    that the DOM is fully built), we obtain a reference to the lone `<div>` element,
    `const div = document.querySelector("div")`, and then run a few tests.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了元素属性和元素属性之间有趣的行为。它首先定义了一个简单的`<div>`元素，我们将用它作为测试对象。在文档的`DOMContentLoaded`处理程序（以确保DOM完全构建）中，我们获取对唯一的`<div>`元素的引用，`const
    div = document.querySelector("div")`，然后运行一些测试。
- en: 'In the first test, we set the `id` attribute to the value `ninja-1` via the
    `setAttribute()` method. Then we assert that `getAttribute()` returns the same
    value for that attribute. It should be no surprise that this test works just fine
    when we load the page:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个测试中，我们通过`setAttribute()`方法将`id`属性设置为值`ninja-1`。然后我们断言`getAttribute()`返回该属性的相同值。当页面加载时，这个测试工作得很好，这并不令人惊讶：
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Similarly, in the next test, we set the `id` property to the value `ninja-2`
    and then verify that the property value has indeed changed. No problem.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在下一个测试中，我们将`id`属性设置为值`ninja-2`，然后验证属性值确实已更改。没问题。
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The next test is when things get interesting. We again set the `id` property
    to a new value, in this case `ninja-3`, and again verify that the property value
    has changed. But then we also assert that not only should the property value change,
    but also the value of the `id` *attribute*. Both assertions pass. From this we
    learn that the `id` property and the `id` attribute are somehow linked together.
    Changing the `id` property value also changes the `id` attribute value:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个测试是当事情变得有趣的时候。我们再次将`id`属性设置为新的值，在这种情况下是`ninja-3`，并再次验证属性值已经改变。但然后我们断言，不仅属性值应该改变，而且`id`
    *属性*的值也应该改变。两个断言都通过了。从这个例子中我们了解到，`id`属性和`id`属性是某种方式联系在一起的。改变`id`属性值也会改变`id`属性值：
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The next test proves that it also works the other way around: Setting an attribute
    value also changes the corresponding property value.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个测试证明它也可以反过来工作：设置属性值也会改变相应的属性值。
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: But don’t let this fool you into thinking that the property and attribute are
    sharing the same value—they aren’t. We’ll see later in this chapter that the attribute
    and corresponding property, although linked, aren’t always identical.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 但不要被这个想法误导，以为属性和属性值是共享相同的值——它们不是。我们将在本章后面看到，尽管属性和相应的属性是链接的，但它们并不总是相同的。
- en: It’s important to note that not all attributes are represented by element properties.
    Although it’s generally true for attributes that are natively specified by the
    HTML DOM, *custom attributes* that we may place on the elements in our pages don’t
    automatically become represented by element properties. To access the value of
    a custom attribute, we need to use the DOM methods `getAttribute()` and `setAttribute()`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，并非所有属性都由元素属性表示。尽管对于由HTML DOM原生指定的属性来说通常是正确的，但我们在页面元素上放置的*自定义属性*并不会自动成为元素属性的表示。要访问自定义属性值，我们需要使用DOM方法`getAttribute()`和`setAttribute()`。
- en: 'If you’re not sure whether a property for an attribute exists, you can always
    test for it and fall back to the DOM methods if it doesn’t exist. Here’s an example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定一个属性的属性值是否存在，你总是可以测试它，如果不存在，就回退到DOM方法。以下是一个例子：
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|  |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: In HTML5, use the prefix `data-` for all custom attributes to keep them valid
    in the eye of the HTML5 specification. It’s a good convention that clearly separates
    custom attributes from native attributes.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML5中，使用前缀`data-`为所有自定义属性，以保持它们在HTML5规范眼中的有效性。这是一个良好的约定，它清楚地区分了自定义属性和原生属性。
- en: '|  |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 12.3\. Styling attribute headaches
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3. 样式属性头痛问题
- en: 'As with general attributes, getting and setting styling attributes can be a
    headache. As with the attributes and properties in the previous section, we again
    have two approaches for handling `style` values: the attribute value, and the
    element property created from it.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 与一般的属性一样，获取和设置样式属性可能会让人头疼。与上一节中的属性和属性值一样，我们再次有两种处理`style`值的方法：属性值，以及由此创建的元素属性。
- en: The most commonly used of these is the `style` element property, which isn’t
    a string but an object that holds properties corresponding to the style values
    specified in the element markup. In addition, you’ll see that there’s a method
    for accessing the computed style information of an element, where *computed style*
    means the style that will be applied to the element after evaluating all inherited
    and applied style information.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这些中最常用的是`style`元素属性，它不是一个字符串，而是一个包含与元素标记中指定的样式值相对应的属性的对象。此外，你还会看到有一个方法可以访问元素的计算样式信息，其中*计算样式*是指评估所有继承和应用的样式信息后应用于元素的样式。
- en: This section outlines the things you need to know when working with styles in
    browsers. Let’s start with a look at where style information is recorded.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 本节概述了在浏览器中处理样式时需要了解的内容。让我们先看看样式信息是如何记录的。
- en: 12.3.1\. Where are my styles?
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.3.1. 我的样式在哪里？
- en: The style information located in the `style` property of a DOM element is initially
    set from the value specified for the `style` attribute in the element markup.
    For example, `style="color:red;"` results in that style information being placed
    into the style object. During page execution, the script can set or modify values
    in the style object, and these changes will actively affect the display of the
    element.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: DOM元素的`style`属性中定位的样式信息最初是从元素标记中指定的`style`属性值设置的。例如，`style="color:red;"`会导致该样式信息被放入样式对象中。在页面执行期间，脚本可以设置或修改样式对象中的值，这些更改将直接影响元素的显示。
- en: Many script authors are disappointed to find that no values from on-page `<style>`
    elements or external style sheets are available in the element’s `style` object.
    But we won’t stay disappointed for long—you’ll soon see a way to obtain this information.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 许多脚本作者失望地发现，页面上的`<style>`元素或外部样式表中的任何值都不在元素的`style`对象中可用。但我们的失望不会持续太久——你很快就会看到一种获取这些信息的方法。
- en: For now, let’s see how the `style` property gets its values. Examine the following
    code.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`style`属性是如何获取其值的。检查以下代码。
- en: Listing 12.6\. Examining the style property
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.6\. 检查样式属性
- en: '![](316fig01_alt.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](316fig01_alt.jpg)'
- en: In this example, we set up a `<style>` element to establish an internal style
    sheet whose values will be applied to the elements on the page. The style sheet
    specifies that all `<div>` elements will appear in a font size that’s 1.8 times
    bigger than the default, with a solid gold border of `0` width. Any elements to
    which this is applied will possess a border, but it won’t be visible because it
    has a width of `0`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们设置了一个`<style>`元素来建立一个内部样式表，其值将应用于页面上的元素。样式表指定所有`<div>`元素将以默认字体大小的1.8倍显示，并带有宽度为`0`的实心金色边框。任何应用了这个样式的元素都将具有边框，但由于宽度为`0`，它将不可见。
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then we create a `<div>` element with an inlined style attribute that colors
    the text of the element black:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建了一个带有内联样式属性的`<div>`元素，该属性将元素的文本颜色设置为黑色：
- en: '![](316fig02.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](316fig02.jpg)'
- en: We then begin the testing. After obtaining a reference to the `<div>` element,
    we test that the `style` attribute receives a `color` property that represents
    the color assigned to the element. Note that even though the `color` is specified
    as `#000` in the inline style, it’s normalized to RGB notation when set in the
    `style` property in most browsers (so we check both formats).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后开始测试。在获取到`<div>`元素引用后，我们测试`style`属性是否接收到了一个表示分配给该元素的颜色的`color`属性。请注意，尽管`color`在行内样式中被指定为`#000`，但在大多数浏览器中将它设置为`style`属性时，它会被规范化为RGB表示法（因此我们检查了两种格式）。
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Looking ahead, in [figure 12.1](#ch12fig01), we see that this test passes.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 向前看，在[图12.1](#ch12fig01)中，我们看到这个测试通过了。
- en: Figure 12.1\. By running this test, we can see that inline and assigned styles
    are recorded, but inherited styles aren’t.
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.1\. 通过运行这个测试，我们可以看到内联和指定的样式被记录，但继承的样式没有被记录。
- en: '![](12fig01.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](12fig01.jpg)'
- en: 'Then we naïvely test that the fontsize styling and the border width specified
    in the inline style sheet have been recorded in the style object. But even though
    we can see in [figure 12.1](#ch12fig01) that the fontsize style has been applied
    to the element, the test fails. This is because the style object doesn’t reflect
    any style information inherited from CSS style sheets:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们天真地测试了内联样式表中指定的字体大小样式和边框宽度是否已记录在样式对象中。但尽管我们在[图12.1](#ch12fig01)中看到字体大小样式已被应用到元素上，测试却失败了。这是因为样式对象没有反映从CSS样式表中继承的任何样式信息：
- en: '[PRE17]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Moving on, we use an assignment to change the value of the `borderWidth` property
    in the style object to `4` pixels wide and test that the change is applied. We
    can see in [figure 12.1](#ch12fig01) that the test passes and that the previously
    invisible border is applied to the element. This assignment causes a `borderWidth`
    property to appear in the `style` property of the element, as proven by the test.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用赋值来改变样式对象中`borderWidth`属性的值，将其设置为4像素宽，并测试这个更改是否被应用。我们可以在[图12.1](#ch12fig01)中看到测试通过了，并且之前不可见的边框被应用到元素上。这个赋值导致在元素的`style`属性中出现了`borderWidth`属性，正如测试所证明的那样。
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It should be noted that any values in an element’s `style` property take precedence
    over anything inherited by a style sheet (even if the style sheet rule uses the
    `!important` annotation).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，元素`style`属性中的任何值都优先于从样式表继承的任何内容（即使样式表规则使用了`!important`注释）。
- en: One thing that you may have noted in [listing 12.6](#ch12ex06) is that CSS specifies
    the font size property as `font-size`, but in script you reference it as `fontSize`.
    Why is that?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在[列表12.6](#ch12ex06)中注意到了一点，CSS将字体大小属性指定为`font-size`，但在脚本中我们引用它为`fontSize`。为什么是这样？
- en: 12.3.2\. Style property naming
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.3.2\. 样式属性命名
- en: CSS attributes cause relatively few cross-browser difficulties when it comes
    to accessing the values provided by the browser. But differences between how CSS
    names styles and how we access those in script do exist, and some style names
    differ across browsers.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到访问浏览器提供的值时，CSS属性在跨浏览器中引起的问题相对较少。但CSS命名样式和我们在脚本中访问它们的方式之间存在差异，并且一些样式名称在不同的浏览器中是不同的。
- en: CSS attributes that span more than one word separate the words with a hyphen;
    examples are `font-weight`, `font-size`, and `background-color`. You may recall
    that property names in JavaScript *can* contain a hyphen, but including a hyphen
    prevents the property from being accessed via the dot operator.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 包含多个单词的CSS属性使用连字符分隔单词；例如`font-weight`、`font-size`和`background-color`。你可能记得JavaScript中的属性名称*可以*包含连字符，但包含连字符会阻止通过点运算符访问属性。
- en: 'Consider this example:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE19]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding is perfectly valid. But the following isn’t:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是有效的。但以下代码不是：
- en: '[PRE20]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The JavaScript parser would see the hyphen as a subtraction operator, and nobody
    would be happy with the outcome. Rather than forcing page developers to always
    use the general form for property access, *multiword CSS style names are converted
    to camel case when used as a property name*. As a result, `font-size` becomes
    `fontSize`, and `backgroundcolor` becomes `backgroundColor`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript解析器会将连字符视为减法运算符，没有人会对结果感到满意。与其强迫页面开发者始终使用属性访问的一般形式，不如将多词CSS样式名称在用作属性名称时转换为驼峰式。因此，`font-size`变为`fontSize`，`backgroundcolor`变为`backgroundColor`。
- en: We can either remember to do this, or write a simple API to set or get styles
    that automatically handle the camel casing, as shown in the following listing.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以记住这样做，或者编写一个简单的API来设置或获取样式，该API会自动处理驼峰式，如下面的列表所示。
- en: Listing 12.7\. A simple method for accessing styles
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.7\. 访问样式的简单方法
- en: '![](318fig01_alt.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](318fig01_alt.jpg)'
- en: 'The style function has two important characteristics:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 样式函数有两个重要特性：
- en: It uses a regular expression to convert the `name` parameter to camel-case notation.
    (If the regex-driven conversion operation has you scratching your head, you might
    want to review the material in [chapter 10](kindle_split_022.html#ch10).)
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用正则表达式将`name`参数转换为驼峰式表示法。（如果你对正则表达式驱动的转换操作感到困惑，你可能想回顾第10章的内容。）
- en: It can be used both as a setter and a getter, by inspecting its own argument
    list. For example, we can obtain the value of the font-size property with `style(div,
    'font-size')`, and we can set a new value with `style(div, 'font-size', '5px')`.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以通过检查其自己的参数列表同时作为设置器和获取器使用。例如，我们可以使用`style(div, 'font-size')`获取字体大小属性的值，并且我们可以使用`style(div,
    'font-size', '5px')`设置新的值。
- en: 'Consider the following code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If a `value` argument is passed to the function, the function acts as a setter,
    setting the passed value as the value of the attribute. If the `value` argument
    is omitted and only the first two arguments are passed, it acts as a getter, retrieving
    the value of the specified attribute. In either case, the value of the attribute
    is returned, which makes it easy to use the function in either of its modes in
    a function-call chain.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果向函数传递一个`value`参数，则函数作为设置器，将传递的值设置为属性的值。如果省略`value`参数，并且只传递前两个参数，则函数作为获取器，检索指定属性的值。在任一情况下，都会返回属性的值，这使得在函数调用链中以任一模式使用函数变得容易。
- en: The `style` property of an element doesn’t include any style information that
    an element inherits from style sheets in scope for the element. Many times it
    would be handy to know the full computed style that’s been applied to an element,
    so let’s see if there’s a way to obtain that.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 元素的`style`属性不包括元素从作用域内的样式表中继承的任何样式信息。很多时候，知道应用于元素的完整计算样式会很有用，所以让我们看看是否有方法可以获得它。
- en: 12.3.3\. Fetching computed styles
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.3.3\. 获取计算样式
- en: At any point in time, the *computed style* of an element is a combination of
    all the built-in styles provided by the browser, all the styles applied to it
    via style sheets, the element’s `style` attribute, and any manipulations of the
    `style` property by script. [Figure 12.2](#ch12fig02) shows how browser developer
    tools differentiate between styles.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时刻，元素的*计算样式*是浏览器提供的所有内置样式、通过样式表应用的所有样式、元素的`style`属性以及通过脚本对`style`属性的任何操作的组合。[图12.2](#ch12fig02)显示了浏览器开发者工具如何区分样式。
- en: 'Figure 12.2\. The final style associated with an element can come from many
    things: the browser builtin styles (user agent style sheet), the styles assigned
    through the style property, and styles from the CSS rules defined in CSS code.'
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.2\. 与元素关联的最终样式可以来自许多方面：浏览器的内置样式（用户代理样式表）、通过`style`属性分配的样式，以及CSS代码中定义的CSS规则中的样式。
- en: '![](12fig02_alt.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](12fig02_alt.jpg)'
- en: The standard method, implemented by all modern browsers, is the `getComputedStyle`
    method. This method accepts an element whose styles are to be computed and returns
    an interface through which property queries can be made. The returned interface
    provides a method named `getPropertyValue` for retrieving the computed style of
    a specific style property.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 标准方法，由所有现代浏览器实现，是 `getComputedStyle` 方法。这个方法接受一个要计算样式的元素，并返回一个接口，通过这个接口可以进行属性查询。返回的接口提供了一个名为
    `getPropertyValue` 的方法，用于检索特定样式属性的计算后样式。
- en: Unlike the properties of an element’s `style` object, the `getPropertyValue`
    method accepts CSS property names (such as `font-size` and `background-color`)
    rather than the camel-cased versions of those names.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 与元素的 `style` 对象的属性不同，`getPropertyValue` 方法接受 CSS 属性名（如 `font-size` 和 `background-color`），而不是这些名称的驼峰式版本。
- en: The following listing shows a simple example.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了一个简单的例子。
- en: Listing 12.8\. Fetching computed style values
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.8\. 获取计算后的样式值
- en: '![](ch12ex08-0.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch12ex08-0.jpg)'
- en: '![](ch12ex08-1.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch12ex08-1.jpg)'
- en: To test the function that we’ll be creating, we set up an element that specifies
    style information in its markup and a style sheet that provides style rules to
    be applied to the element. We expect that the computed styles will be the result
    of applying both the immediate and the applied styles to the element.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们将要创建的函数，我们设置了一个在标记中指定样式信息的元素和一个提供要应用于元素的样式规则的样式表。我们预计计算后的样式将是将直接和应用的样式应用于元素的结果。
- en: 'We then define the new function, which accepts an element and the style property
    that we want to find the computed value for. And to be especially friendly (after
    all, we’re ninjas—making things easier for those using our code is part of the
    job), we’ll allow multiword property names to be specified in either format: dashed
    or camel-cased. In other words, we’ll accept both `backgroundColor` and `background-color`.
    We’ll see how to accomplish that in a little bit.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义一个新的函数，它接受一个元素和我们要查找计算值的样式属性。为了特别友好（毕竟，我们是忍者——让使用我们代码的人更容易是我们的工作的一部分），我们将允许以两种格式指定多词属性名：破折号或驼峰式。换句话说，我们将接受
    `backgroundColor` 和 `background-color`。我们将在稍后展示如何实现这一点。
- en: The first thing we want to do is to obtain the computed style interface, which
    we store in a variable, `computedStyles`, for later reference. We want to do things
    this way because we don’t know how expensive making this call may be, and it’s
    likely best to avoid repeating it needlessly.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先想要做的是获取计算后的样式接口，我们将它存储在一个变量 `computedStyles` 中，以便稍后引用。我们这样做的理由是因为我们不知道调用这个接口可能需要多少成本，而且最好避免无谓地重复调用。
- en: '[PRE22]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If that succeeds (and we can’t think of any reason why it wouldn’t, but it frequently
    pays to be cautious), we call the `getPropertyValue()` method of the interface
    to get the computed style value. But first we adjust the name of the property
    to accommodate either the camel-cased or dashed version of the property name.
    The `getPropertyValue` method expects the dashed version, so we use the `String`’s
    `replace()` method, with a simple but clever regular expression, to insert a hyphen
    before every uppercase character and then lowercase the whole thing. (Bet that
    was easier than you thought it would be.)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这成功了（我们想不出任何它不会成功的理由，但通常谨慎一些是有好处的），我们就调用接口的 `getPropertyValue()` 方法来获取计算后的样式值。但首先我们需要调整属性的名称，以适应属性名的驼峰式或破折号版本。`getPropertyValue`
    方法期望的是破折号版本，所以我们使用 `String` 的 `replace()` 方法，配合一个简单但巧妙的正则表达式，在每一个大写字母前插入一个破折号，然后将整个字符串转换为小写。（这比你想的要容易吧。）
- en: To test the function, we make calls to the function, passing various style names
    in various formats, and display the results, as shown in [figure 12.3](#ch12fig03).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个函数，我们调用函数，传递各种格式和样式名称，并显示结果，如图 [12.3](#ch12fig03) 所示。
- en: Figure 12.3\. Computed styles include all styles specified with the element
    as well as those inherited from style sheets.
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.3\. 计算后的样式包括元素指定的所有样式以及从样式表中继承的样式。
- en: '![](12fig03.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图片](12fig03.jpg)'
- en: Note that the styles are fetched regardless of whether they’re explicitly declared
    on the element or inherited from the style sheet. Also note that the `color` property,
    specified in both the style sheet and directly on the element, returns the explicit
    value. Styles specified by an element’s `style` attribute always take precedence
    over inherited styles, even if marked `!important`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，无论这些样式是否在元素上显式声明或从样式表中继承，都会检索到这些样式。另外，注意在样式表和元素上直接指定的`color`属性返回的是显式值。通过元素的`style`属性指定的样式始终优先于继承的样式，即使标记为`!important`。
- en: 'We need to be aware of one more topic when dealing with style properties: *amalgam*
    properties. CSS allows us to use a shortcut notation for the amalgam of properties
    such as the `border-`properties. Rather than forcing us to specify colors, widths,
    and border styles individually and for all four borders, we can use a rule such
    as this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理样式属性时，我们还需要注意一个额外的主题：*混合*属性。CSS允许我们使用简写符号来表示如`border-`属性这样的混合属性。我们不必分别指定颜色、宽度和所有四个边框的边框样式，可以使用如下规则：
- en: '[PRE23]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We used this exact rule in [listing 12.8](#ch12ex08). This saves a lot of typing,
    but we need to be aware that when we retrieve the properties, we need to fetch
    the low-level individual properties. We can’t fetch `border`, but we can fetch
    styles such as `border-top-color` and `border-top-width`, just as we did in the
    example.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[列表12.8](#ch12ex08)中使用了这个精确的规则。这可以节省很多输入，但我们需要意识到，当我们检索属性时，我们需要获取低级别的单个属性。我们不能获取`border`，但我们可以获取如`border-top-color`和`border-top-width`这样的样式，就像我们在示例中所做的那样。
- en: It can be a bit of a hassle, especially when all four styles are given the same
    values, but that’s the hand we’ve been dealt.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能有点麻烦，尤其是当所有四个样式都赋予相同的值时，但我们只能接受这个现实。
- en: 12.3.4\. Converting pixel values
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.3.4\. 转换像素值
- en: 'An important point to consider when setting style values is the assignment
    of numeric values that represent pixels. When setting a numeric value for a style
    property, we must specify the unit in order for it to work reliably across all
    browsers. For example, let’s say that we want to set the `height` style value
    of an element to 10 pixels. Either of the following is a safe way to do this across
    browsers:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置样式值时，需要考虑的是分配代表像素的数值。当为一个样式属性设置数值时，我们必须指定单位，以便它在所有浏览器中可靠地工作。例如，假设我们想要将一个元素的`height`样式值设置为10像素。以下两种方法都可以安全地在浏览器之间进行操作：
- en: '[PRE24]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following isn’t safe across browsers:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法在浏览器之间不安全：
- en: '[PRE25]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You might think it’d be easy to add a little logic to the `style()` function
    of [listing 12.7](#ch12ex07) to tack a `px` to the end of a numeric value coming
    into the function. But not so fast! Not all numeric values represent pixels! Some
    style properties take numeric values that don’t represent a pixel dimension. The
    list includes the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为向[列表12.7](#ch12ex07)的`style()`函数添加一点逻辑，将`px`添加到传入函数的数值的末尾很容易。但别急！并非所有数值都代表像素！一些样式属性接受的数值不代表像素维度。以下是一些例子：
- en: '`z-index`'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`z-index`'
- en: '`font-weight`'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`font-weight`'
- en: '`opacity`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opacity`'
- en: '`zoom`'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zoom`'
- en: '`line-height`'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`line-height`'
- en: For these (and any others you can think of), go ahead and extend the function
    of [listing 12.6](#ch12ex06) to automatically handle nonpixel values. Also, when
    attempting to read a pixel value out of a style attribute, the `parseFloat` method
    should be used to make sure that you get the intended value under all circumstances.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些（以及你可以想到的任何其他情况），请扩展[列表12.6](#ch12ex06)的功能，以自动处理非像素值。此外，当尝试从一个样式属性中读取像素值时，应使用`parseFloat`方法，以确保在所有情况下都能得到预期的值。
- en: Now let’s take a look at a set of important style properties that can be tough
    to handle.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看一组重要的样式属性，这些属性可能很难处理。
- en: 12.3.5\. Measuring heights and widths
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.3.5\. 测量高度和宽度
- en: Style properties such as `height` and `width` pose a special problem, because
    their values default to `auto` when not specified, so that the element sizes itself
    according to its contents. As a result, we can’t use the `height` and `width`
    style properties to get accurate values unless explicit values are provided in
    the attribute string.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 样式属性如`height`和`width`存在特殊问题，因为当未指定时，它们的值默认为`auto`，这样元素就会根据其内容的大小自动调整。因此，除非在属性字符串中提供了显式值，否则我们不能使用`height`和`width`样式属性来获取准确值。
- en: 'Thankfully, the `offsetHeight` and `offsetWidth` properties provide just that:
    a fairly reliable means to access the height and width of an element. But be aware
    that the values assigned to these two properties include the padding of the element.
    This information is usually exactly what we want if we’re attempting to position
    one element over another. But sometimes we may want to obtain information about
    the element’s dimensions with and without borders and padding.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`offsetHeight`和`offsetWidth`属性正好提供了这样的功能：一种相当可靠的方式来访问元素的高度和宽度。但请注意，分配给这两个属性的价值包括元素的填充。如果我们试图将一个元素定位在另一个元素之上，通常这正是我们想要的信息。但有时我们可能想要获取有关元素尺寸的信息，包括和不包括边框和填充。
- en: Something to watch out for, however, is that in highly interactive sites, elements
    will likely spend some of their time in a nondisplayed state (with the `display`
    style being set to `none`), and when an element isn’t part of the display, it
    has no dimensions. Any attempt to fetch the `offsetWidth` or `offsetHeight` properties
    of a nondisplayed element will result in a value of `0`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要注意的是，在高度交互的网站上，元素可能会花费一些时间处于非显示状态（`display`样式设置为`none`），当一个元素不是显示的一部分时，它没有尺寸。尝试获取非显示元素的`offsetWidth`或`offsetHeight`属性将导致值为`0`。
- en: For such hidden elements, if we want to obtain the nonhidden dimensions, we
    can employ a trick to momentarily unhide the element, grab the values, and hide
    it again. Of course, we want to do so in such a way that we leave no visible clue
    that this is going on behind the scenes. How can we make a hidden element not
    hidden without making it visible?
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些隐藏元素，如果我们想获取非隐藏维度，我们可以使用一个技巧来暂时显示元素，获取值，然后再隐藏它。当然，我们希望这样做的方式不会留下任何明显的线索，表明幕后正在进行这种情况。我们如何使一个隐藏的元素看起来不隐藏，同时又不会让它变得可见？
- en: 'Employing our ninja skills, we can do it! Here’s how:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 利用我们的忍者技巧，我们可以做到！下面是如何操作的：
- en: Change the `display` property to `block`.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`display`属性更改为`block`。
- en: Set `visibility` to `hidden`.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`visibility`设置为`hidden`。
- en: Set `position` to `absolute`.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`position`设置为`absolute`。
- en: Grab the dimension values.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕获维度值。
- en: Restore the changed properties.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恢复更改的属性。
- en: Changing the `display` property to `block` allows us to grab the values of `offsetHeight`
    and `offsetWidth`, but that makes the element part of the display and therefore
    visible. To make the element invisible, we’ll set the `visibility` property to
    `hidden`. But (there’s always another *but*) that will leave a big hole where
    the element is positioned, so we also set the `position` property to `absolute`
    to take the element out of the normal display flow.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 将`display`属性更改为`block`允许我们获取`offsetHeight`和`offsetWidth`的值，但这会使元素成为显示的一部分，因此是可见的。为了使元素不可见，我们将`visibility`属性设置为`hidden`。但（总会有另一个“但是”）这将留下一个很大的洞，元素就定位在那里，所以我们还将`position`属性设置为`absolute`，将元素从正常的显示流程中移除。
- en: All that sounds more complicated than the implementation, which is shown in
    the following listing.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些听起来比实现要复杂，下面的列表显示了实现。
- en: Listing 12.9\. Grabbing the dimensions of hidden elements
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.9。获取隐藏元素的尺寸
- en: '![](ch12ex09-0.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch12ex09-0.jpg)'
- en: '![](ch12ex09-1.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch12ex09-1.jpg)'
- en: That’s a long listing, but most of it is test code; the implementation of the
    new dimension-fetching function spans only a dozen or so lines of code.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段很长的列表，但其中大部分是测试代码；新维度获取函数的实现只有十几行代码。
- en: 'Let’s take a look at it piece by piece. First, we set up elements to test:
    a `<div>` element containing a bunch of text with two images embedded within it,
    left-justified by styles in an external style sheet. These image elements will
    be the subjects of our tests; one is visible, and one is hidden.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个分析它。首先，我们设置了用于测试的元素：一个包含大量文本的`<div>`元素，其中包含两张图片，通过外部样式表中的样式左对齐。这些图片元素将成为我们测试的主题；一个是可见的，一个是隐藏的。
- en: Prior to running any script, the elements appear as shown in [figure 12.4](#ch12fig04).
    If the second image weren’t hidden, it would appear as a second ninja just to
    the right of the visible one.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行任何脚本之前，元素看起来如图12.4所示。如果第二张图片没有被隐藏，它将作为一个第二忍者出现在可见忍者右侧。
- en: Figure 12.4\. We’ll use two images—one visible, one hidden—for testing the fetching
    of dimensions of hidden elements.
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.4。我们将使用两张图片——一张可见，一张隐藏——来测试获取隐藏元素的尺寸。
- en: '![](12fig04.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图片](12fig04.jpg)'
- en: Then we set about defining our new function. We’re going to use a hash for some
    important information, but we don’t want to pollute the global namespace with
    this hash; we want it to be available to the function in its local scope, but
    no further than that.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们着手定义我们的新函数。我们将使用一个哈希表来存储一些重要信息，但我们不想用这个哈希表污染全局命名空间；我们希望它在函数的局部作用域内可用，但仅限于此。
- en: We accomplish that by enclosing the hash definition and function declaration
    within an immediate function, which creates a local scope. The hash isn’t accessible
    outside the immediate function, but the `getDimensions` function that we also
    define within the immediate function has access to the hash via its closure. Nifty,
    eh?
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将哈希定义和函数声明放在立即函数中来实现这一点，这创建了一个局部作用域。哈希表在立即函数外部不可访问，但我们也在立即函数中定义的 `getDimensions`
    函数可以通过闭包访问这个哈希表。不错吧？
- en: '[PRE26]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Our new dimension-fetching function is then declared, accepting the element
    that’s to be measured. Within that function, we first create a hash named `previous`
    in which we’ll record the previous values of the style properties that we’ll be
    stomping on, so that we can restore them later. Looping over the replacement properties,
    we then record each of their previous values and replace those values with the
    new ones.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明了新的维度获取函数，该函数接受要测量的元素。在这个函数内部，我们首先创建一个名为 `previous` 的哈希表，我们将记录将要修改的样式属性的前一个值，以便稍后恢复它们。在遍历替换属性时，我们记录每个属性的前一个值，并用新值替换它们。
- en: That accomplished, we’re ready to measure the element, which has now been made
    part of the display layout, invisible, and absolutely positioned. The dimensions
    are recorded in a hash assigned to local variable `result`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们准备测量元素，该元素现在已成为显示布局的一部分，不可见，并且绝对定位。尺寸记录在分配给局部变量 `result` 的哈希表中。
- en: Now that we’ve pilfered what we came for, we erase our tracks by restoring the
    original values of the style properties that we modified, and we return the results
    as a hash containing `width` and `height` properties.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经得到了我们想要的东西，我们通过恢复我们修改的样式属性的原值来擦除我们的痕迹，并将包含 `width` 和 `height` 属性的哈希表作为结果返回。
- en: All well and good, but does it work? Let’s find out.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都很好，但它真的起作用吗？让我们来看看。
- en: In a load handler, we perform the tests in a callback to a 3-second timer. Why,
    you ask? The load handler ensures that we don’t perform the test until we know
    that the DOM has been built, and the timer enables us to watch the display while
    the test is running, to make sure no display glitches occur while we fiddle with
    the properties of the hidden element. After all, if the display is disturbed in
    any way when we run our function, it’s a bust.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载处理程序中，我们在3秒计时器的回调中执行测试。为什么问这个？加载处理程序确保我们在知道DOM已经构建后才执行测试，计时器使我们能够在测试运行时观察显示，以确保我们在调整隐藏元素的属性时不会出现显示故障。毕竟，如果我们运行我们的函数时显示以任何方式受到干扰，那将是一个失败。
- en: In the timer callback, we first get a reference to our test subjects (the two
    images) and assert that we can obtain the dimensions of the visible image by using
    the offset properties. This test passes, which we can see if we peek ahead to
    [figure 12.5](#ch12fig05).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在计时器回调中，我们首先获取我们的测试对象（两个图像）的引用，并断言我们可以通过使用偏移属性来获取可见图像的尺寸。这个测试通过了，如果我们提前看到[图12.5](#ch12fig05)。
- en: Figure 12.5\. By temporarily adjusting the style properties of hidden elements,
    we can successfully fetch their dimensions.
  id: totrans-251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.5。通过临时调整隐藏元素的样式属性，我们可以成功获取它们的尺寸。
- en: '![](12fig05.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![12fig05.jpg](12fig05.jpg)'
- en: Then we make the same test on the hidden element, incorrectly assuming that
    the offset properties will work with a hidden image. Not surprisingly, because
    we’ve already acknowledged that this won’t work, the test fails.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们对隐藏元素进行了相同的测试，错误地假设偏移属性将适用于隐藏图像。不出所料，因为我们已经承认这不会工作，测试失败了。
- en: Next, we call our new function on the hidden image, and then retest with those
    results. Success! Our test passes, as shown in [figure 12.5](#ch12fig05).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在隐藏图像上调用我们的新函数，然后使用这些结果重新进行测试。成功了！我们的测试通过了，如[图12.5](#ch12fig05)所示。
- en: If we watch the display of the page while the test is running—remember, we delay
    running the test until 3 seconds after the DOM is loaded—we can see that the display
    isn’t perturbed in any way by our behind-the-scenes adjustments of the hidden
    element’s properties.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试运行时，如果我们观察页面的显示——记住，我们延迟运行测试直到DOM加载后的3秒——我们可以看到，我们的隐藏元素属性背后的调整并没有以任何方式影响显示。
- en: '|  |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Checking the `offsetWidth` and `offsetHeight` style properties for zeroes can
    serve as an incredibly efficient means of determining the visibility of an element.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`offsetWidth`和`offsetHeight`样式属性是否为零可以作为一个非常高效的确定元素可见性的方法。
- en: '|  |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 12.4\. Minimizing layout thrashing
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4. 最小化布局抖动
- en: 'So far in this chapter, you’ve learned how to relatively easily modify the
    DOM: by creating and inserting new elements, removing existing elements, or modifying
    their attributes. Modifying the DOM is one of the fundamental tools for achieving
    highly dynamic web applications.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，你已经学会了如何相对容易地修改DOM：通过创建和插入新元素、删除现有元素或修改它们的属性。修改DOM是实现高度动态Web应用程序的基本工具之一。
- en: But this tool also comes with usage asterisks, one of the most important being,
    be aware of *layout thrashing*. Layout thrashing occurs when we perform a series
    of consecutive reads and writes to DOM, in the process not allowing the browser
    to perform layout optimizations.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个工具也附带了一些使用注意事项，其中最重要的一点是，要注意*布局抖动*。布局抖动发生在我们连续对DOM进行一系列的读取和写入操作时，在这个过程中不允许浏览器执行布局优化。
- en: Before we delve deeper, consider that changing attributes of one element (or
    modifying its content) doesn’t necessarily affect only that element; instead it
    can cause a cascade of changes. For example, setting the width of one element
    can lead to changes in the element’s children, siblings, and parents. So whenever
    a change is made, the browser has to calculate the impact of those changes. In
    certain cases, there’s nothing we can do about it; we need those changes to occur.
    But at the same time, there’s no need to put additional weight on the shoulders
    of our poor browsers, causing our web application performance to dwindle.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨之前，请考虑这样一个事实：改变一个元素的属性（或修改其内容）并不一定只会影响该元素；相反，它可能引起一系列的变化。例如，设置一个元素的宽度可能会导致该元素的孩子、兄弟和父元素发生变化。因此，每当进行更改时，浏览器都必须计算这些更改的影响。在某些情况下，我们对此无能为力；我们需要这些更改发生。但与此同时，我们也没有必要给我们的可怜的浏览器增加额外的负担，导致我们的Web应用程序性能下降。
- en: Because recalculating layout is expensive, browsers try to be as lazy as possible,
    by delaying working with the layout as much as they can; they try to batch as
    many write operations as possible on the DOM in a queue so that these operations
    can be executed in one go. Then, when an operation that requires an up-to-date
    layout comes along, the browser grudgingly obeys, and executes all batched operations
    and finally updates the layout. But sometimes, the way we’ll write our code doesn’t
    give the browser enough room to perform these sorts of optimizations, and we force
    the browser to perform a lot of (possibly needless) recalculations. This is what
    layout thrashing is all about; it occurs when our code performs a series of (often
    unnecessary) consecutive reads and writes to the DOM, not allowing the browser
    to optimize layout operations. The problem is that, whenever we modify the DOM,
    the browser has to recalculate the layout before any layout information is read.
    This action is expensive, in terms of performance. Let’s take a look at an example.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 由于重新计算布局代价高昂，浏览器尽可能地变得懒惰，通过尽可能推迟处理布局；它们试图将尽可能多的DOM写入操作排队，以便一次性执行这些操作。然后，当出现需要最新布局的操作时，浏览器不情愿地服从，执行所有排队的操作，并最终更新布局。但有时，我们编写代码的方式并没有给浏览器足够的空间来执行这些优化，这迫使浏览器进行大量的（可能是多余的）重新计算。这就是布局抖动的问题；它发生在我们的代码执行一系列（通常是多余的）连续的DOM读取和写入操作时，不允许浏览器优化布局操作。问题是，每当修改DOM时，浏览器都必须在读取任何布局信息之前重新计算布局。这个动作在性能方面代价高昂。让我们看看一个例子。
- en: Listing 12.10\. Consecutive series of reads and writes causes layout thrashing
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.10. 连续的读取和写入序列导致布局抖动
- en: '![](328fig01_alt.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](328fig01_alt.jpg)'
- en: Reading the value of the element’s `clientWidth` property is one of those actions
    that requires the browser to have an up-to-date layout. By performing consecutive
    reads and writes to the width property of different elements, we don’t allow the
    browser to be lazy in a smart way. Instead, because we read layout information
    after every layout modification, the browser has to recalculate the layout every
    time, just to be sure that we still get the correct information.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 读取元素的`clientWidth`属性值是那些需要浏览器保持布局最新状态的操作之一。通过连续读取和写入不同元素的宽度属性，我们不允许浏览器以智能的方式偷懒。相反，因为我们每次布局修改后都会读取布局信息，所以浏览器必须每次都重新计算布局，以确保我们仍然得到正确的信息。
- en: One way of minimizing layout thrashing is to write code in a way that doesn’t
    cause needless layout recalculations. For example, we can rewrite [listing 12.10](#ch12ex10)
    into the following.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 减小布局抖动的一种方法是以不会引起不必要的布局重新计算的方式编写代码。例如，我们可以将 [列表 12.10](#ch12ex10) 重写为以下内容。
- en: Listing 12.11\. Batch DOM reads and writes to avoid layout thrashing
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.11\. 批量 DOM 读取和写入以避免布局抖动
- en: '![](328fig02_alt.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![图片](328fig02_alt.jpg)'
- en: Here we batch all reads and writes, because we know that no dependencies exist
    between the dimensions of our elements; setting the width of the `ninja` element
    doesn’t influence the width of the `samurai` element. This allows the browser
    to lazily batch operations that modify the DOM.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们批量处理所有读取和写入操作，因为我们知道我们元素的尺寸之间不存在依赖关系；设置`ninja`元素的宽度不会影响`samurai`元素的宽度。这允许浏览器以懒加载的方式批量处理修改
    DOM 的操作。
- en: Layout thrashing isn’t something that you’d notice in smaller, simpler pages,
    but it’s something to keep in mind when developing complex web applications, especially
    on mobile devices. For this reason, it’s always good to keep in mind the methods
    and properties that require an up-to-date layout, shown in the following table
    (obtained from [http://ricostacruz.com/cheatsheets/layout-thrashing.html](http://ricostacruz.com/cheatsheets/layout-thrashing.html)).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 布局抖动不是你在较小、较简单的页面上会注意到的事情，但在开发复杂网络应用程序时，尤其是在移动设备上，这是需要记住的事情。因此，始终记住需要最新布局的方法和属性总是好的，如下表所示（来自
    [http://ricostacruz.com/cheatsheets/layout-thrashing.html](http://ricostacruz.com/cheatsheets/layout-thrashing.html)）。
- en: Table 12.2\. APIs and properties that cause layout invalidation
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 12.2\. 导致布局无效化的 API 和属性
- en: '| Interface | Property name |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| 接口 | 属性名 |'
- en: '| --- | --- |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Element | clientHeight, clientLeft, clientTop, clientWidth, focus, getBoundingClientRect,
    getClientRects, innerText, offsetHeight, offsetLeft, offsetParent, offsetTop,
    offsetWidth, outerText, scrollByLines, scrollByPages, scrollHeight, scrollIntoView,
    scrollIntoViewIfNeeded, scrollLeft, scrollTop, scrollWidth |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| Element | clientHeight, clientLeft, clientTop, clientWidth, focus, getBoundingClientRect,
    getClientRects, innerText, offsetHeight, offsetLeft, offsetParent, offsetTop,
    offsetWidth, outerText, scrollByLines, scrollByPages, scrollHeight, scrollIntoView,
    scrollIntoViewIfNeeded, scrollLeft, scrollTop, scrollWidth |'
- en: '| MouseEvent | layerX, layerY, offsetX, offsetY |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| MouseEvent | layerX, layerY, offsetX, offsetY |'
- en: '| Window | getComputedStyle, scrollBy, scrollTo, scroll, scrollY |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| Window | getComputedStyle, scrollBy, scrollTo, scroll, scrollY |'
- en: '| Frame, Document, Image | height, width |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| Frame, Document, Image | height, width |'
- en: Several libraries that try to minimize layout thrashing have been developed.
    One of the more popular ones is FastDom ([https://github.com/wilsonpage/fastdom](https://github.com/wilsonpage/fastdom)).
    The library repository includes examples that clearly show the performance gains
    that can be achieved by batching DOM read/write operations ([https://wilsonpage.github.io/fastdom/examples/aspect-ratio.html](https://wilsonpage.github.io/fastdom/examples/aspect-ratio.html)).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 已经开发出几个试图最小化布局抖动的库。其中较受欢迎的一个是 FastDom ([https://github.com/wilsonpage/fastdom](https://github.com/wilsonpage/fastdom))。库的存储库包括示例，清楚地展示了通过批量
    DOM 读写操作可以获得性能提升 ([https://wilsonpage.github.io/fastdom/examples/aspect-ratio.html](https://wilsonpage.github.io/fastdom/examples/aspect-ratio.html))。
- en: '|  |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**React’s virtual DOM**'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**React 的虚拟 DOM**'
- en: One of the most popular client-side libraries is Facebook’s React ([https://facebook.github.io/react/](https://facebook.github.io/react/)).
    React achieves great performance by using a virtual DOM, a set of JavaScript objects
    that mimic the actual DOM. When we develop applications in React, we perform all
    modifications on the virtual DOM, without any regard for layout thrashing. Then,
    at an appropriate time, React uses the virtual DOM to figure out what changes
    have to be made to the actual DOM, in order to keep the UI in sync. This batching
    of updates increases the performance of applications.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的客户端库之一是 Facebook 的 React ([https://facebook.github.io/react/](https://facebook.github.io/react/))。React
    通过使用虚拟 DOM（一组模仿实际 DOM 的 JavaScript 对象）实现了出色的性能。当我们使用 React 开发应用程序时，我们会对虚拟 DOM
    进行所有修改，而不考虑布局抖动。然后，在适当的时候，React 使用虚拟 DOM 来确定需要对实际 DOM 进行哪些更改，以保持 UI 保持同步。这种更新批处理提高了应用程序的性能。
- en: '|  |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 12.5\. Summary
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.5\. 摘要
- en: 'Converting an HTML string into DOM elements includes the following steps:'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 HTML 字符串转换为 DOM 元素包括以下步骤：
- en: Making sure that the HTML string is valid HTML code
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保HTML字符串是有效的HTML代码
- en: Wrapping it into enclosing markup, required by browser rules
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其包装到浏览器规则要求的封装标记中
- en: Inserting the HTML into a dummy DOM element through the `innerHTML` property
    of a DOM element
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 DOM 元素的 `innerHTML` 属性将 HTML 插入到虚拟 DOM 元素中
- en: Extracting the created DOM nodes back out
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取创建的 DOM 节点
- en: For fast inserting of DOM nodes, use DOM fragments, because a fragment can be
    injected in a single operation, thereby drastically reducing the number of operations.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了快速插入 DOM 节点，请使用 DOM 片段，因为片段可以在单个操作中注入，从而大大减少操作次数。
- en: DOM element attributes and properties, although linked, aren’t always identical!
    We can read and write to DOM attributes by using the `getAttribute` and `setAttribute`
    methods, whereas we write to DOM properties by using object property notation.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DOM 元素属性和属性，尽管相关联，但并不总是相同！我们可以通过使用 `getAttribute` 和 `setAttribute` 方法来读取和写入
    DOM 属性，而通过使用对象属性表示法来写入 DOM 属性。
- en: When working with attributes and properties, we have to be aware of *custom
    attributes*. Attributes that we decide to place on HTML elements in order to carry
    information useful to our applications aren’t automatically presented as element
    properties.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当处理属性和属性时，我们必须注意 *自定义属性*。我们决定放置在 HTML 元素上的属性，以便携带对我们应用程序有用的信息，并不会自动作为元素属性呈现。
- en: The `style` element property is an object that holds properties corresponding
    to the style values specified in the element markup. To get the computed styles,
    which also take into account the styles set in style sheets, use the built-in
    `getComputedStyle` method.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`style` 元素属性是一个对象，它包含与元素标记中指定的样式值相对应的属性。要获取计算后的样式，这也会考虑在样式表中设置的样式，请使用内置的 `getComputedStyle`
    方法。'
- en: For getting the dimensions of HTML elements, use `offsetWidth` and `offsetHeight`
    properties.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获取 HTML 元素的尺寸，请使用 `offsetWidth` 和 `offsetHeight` 属性。
- en: Layout thrashing occurs when code performs a series of consecutive reads and
    writes to DOM, each time forcing the browser to recalculate the layout information.
    This leads to slower, less responsive web applications.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当代码执行一系列连续的 DOM 读取和写入操作时，会发生布局抖动，每次都会迫使浏览器重新计算布局信息。这导致 Web 应用程序运行缓慢，响应性降低。
- en: Batch your DOM updates!
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 批量更新 DOM！
- en: 12.6\. Exercises
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.6\. 练习
- en: '**1\.**'
  id: totrans-299
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1\.**'
- en: ''
  id: totrans-300
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the following code, which of the following assertions will pass?
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在以下代码中，以下哪个断言将会通过？
- en: ''
  id: totrans-302
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-303
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**2**'
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**'
- en: ''
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given the following code, how can we access the element’s `border-width` style
    property?
  id: totrans-306
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定以下代码，我们如何访问元素的 `border-width` 样式属性？
- en: ''
  id: totrans-307
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-308
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ''
  id: totrans-309
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`element.border-width`'
  id: totrans-310
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`element.border-width`'
- en: '`element.getAttribute("border-width");`'
  id: totrans-311
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`element.getAttribute("border-width");`'
- en: '`element.style["border-width"];`'
  id: totrans-312
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`element.style["border-width"];`'
- en: '`element.style.borderWidth;`'
  id: totrans-313
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`element.style.borderWidth;`'
- en: '**3**'
  id: totrans-314
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**'
- en: ''
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which built-in method can get all styles applied to a certain element (styles
    provided by the browser, styles applied via style sheets, and properties set through
    the style attribute)?
  id: totrans-316
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 哪个内置方法可以获取应用到特定元素上的所有样式（浏览器提供的样式、通过样式表应用的样式以及通过样式属性设置的属性）？
- en: ''
  id: totrans-317
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`getStyle`'
  id: totrans-318
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getStyle`'
- en: '`getAllStyles`'
  id: totrans-319
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getAllStyles`'
- en: '`getComputedStyle`'
  id: totrans-320
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getComputedStyle`'
- en: '**4**'
  id: totrans-321
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**'
- en: ''
  id: totrans-322
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When does layout thrashing occur?
  id: totrans-323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 布局抖动何时发生？
- en: Chapter 13\. Surviving events
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 13 章：应对事件
- en: '*This chapter covers*'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Understanding the event loop
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解事件循环
- en: Processing complex tasks with timers
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用计时器处理复杂任务
- en: Managing animations with timers
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用计时器管理动画
- en: Using event bubbling and delegation
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事件冒泡和委托
- en: Using custom events
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义事件
- en: '[Chapter 2](kindle_split_012.html#ch02) included a short discussion on the
    JavaScript single-threaded execution model and introduced the event loop and the
    event queue, in which events wait for their turn to be processed. This discussion
    was particularly useful when presenting the steps in the lifecycle of a web page,
    especially when discussing the order in which certain pieces of JavaScript code
    get executed. At the same time, it’s a simplification, so in order to get a more
    complete picture of how the browser works, we’ll spend a significant part of this
    chapter exploring the nooks and crannies of the event loop. This will help us
    better understand some of the performance limitations inherent in JavaScript and
    the browser. In turn, we’ll use this knowledge to develop smoother-running applications.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '[第2章](kindle_split_012.html#ch02)中包含了对JavaScript单线程执行模型的简要讨论，并介绍了事件循环和事件队列，其中事件等待轮到它们被处理的机会。当展示网页的生命周期步骤时，特别是讨论某些JavaScript代码执行的顺序时，这次讨论特别有用。同时，这也是一种简化，因此为了更全面地了解浏览器的工作原理，我们将在本章中花相当大的篇幅来探索事件循环的各个角落。这将帮助我们更好地理解JavaScript和浏览器中固有的某些性能限制。反过来，我们将利用这些知识来开发运行更流畅的应用程序。'
- en: During this exploration, we’ll put a special focus on timers, a JavaScript feature
    that enables us to delay the execution of a piece of code asynchronously by a
    certain amount of time. At first glance, this might not seem like much, but we’ll
    show you how to use timers to break up long-running tasks that make applications
    slow and unresponsive into smaller tasks that don’t clog the browser. This helps
    develop better-performing applications.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次探索中，我们将特别关注定时器，这是一个JavaScript特性，它允许我们通过一定的时间延迟异步执行一段代码。乍一看，这可能看起来并不重要，但我们将向您展示如何使用定时器将长时间运行的任务分解成不会阻塞浏览器的小任务。这有助于开发性能更好的应用程序。
- en: We’ll continue this exploration of events by showing how events are propagated
    through the DOM tree, and how to use this knowledge to write simpler and less
    memory-intensive code. Finally, we’ll finish the chapter with creating custom
    events, which can help reduce coupling between different parts of the application.
    Without further ado, let’s start looping through the event loop.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续探索事件，展示事件是如何通过DOM树传播的，以及如何利用这些知识来编写更简单、内存消耗更少的代码。最后，我们将以创建自定义事件结束本章，这有助于减少应用程序不同部分之间的耦合。现在，让我们不拖延，开始遍历事件循环。
- en: Do you know?
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你知道吗？
- en: '**Q1:**'
  id: totrans-335
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q1:**'
- en: ''
  id: totrans-336
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why is the timing on timer callbacks not guaranteed?
  id: totrans-337
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么定时器回调的时机没有保证？
- en: '**Q2:**'
  id: totrans-338
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q2:**'
- en: ''
  id: totrans-339
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If a `setInterval` timer fires every 3 milliseconds while another event handler
    is running for 16 ms, how many times will the timer’s callback function be added
    to the microtask queue?
  id: totrans-340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果一个`setInterval`定时器在另一个事件处理程序运行了16毫秒的同时每3毫秒触发一次，定时器的回调函数将被添加到微任务队列多少次？
- en: '**Q3:**'
  id: totrans-341
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q3:**'
- en: ''
  id: totrans-342
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why is the function context for an event handler sometimes different from the
    event’s target?
  id: totrans-343
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么事件处理函数的函数上下文有时与事件的目标不同？
- en: 13.1\. Diving into the event loop
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1. 深入事件循环
- en: 'As you might have figured out, the event loop is more complicated than its
    presentation in [chapter 2](kindle_split_012.html#ch02). For starters, instead
    of a single event queue, which holds only events, the event loop has at least
    two queues that, in addition to events, hold other actions performed by the browser.
    These actions are called *tasks* and are grouped into two categories: *macrotasks*
    (or often just called tasks) and *microtasks*.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经猜到的，事件循环比其在[第2章](kindle_split_012.html#ch02)中的描述要复杂。首先，事件循环不仅仅有一个只包含事件的单一事件队列，它至少包含两个队列，除了事件外，这些队列还持有浏览器执行的其他操作。这些操作被称为*任务*，并被分为两类：*宏任务*（或通常简称为任务）和*微任务*。
- en: Examples of macrotasks include creating the main document object, parsing HTML,
    executing mainline (or global) JavaScript code, changing the current URL, as well
    as various events such as page loading, input, network events, and timer events.
    From the browser’s perspective, a macrotask represents one discrete, self-contained
    unit of work. After running a task, the browser can continue with other assignments
    such as re-rendering the UI of the page, or performing garbage collection.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 宏任务的例子包括创建主文档对象、解析HTML、执行主线（或全局）JavaScript代码、更改当前URL，以及各种事件，如页面加载、输入、网络事件和定时器事件。从浏览器的角度来看，一个宏任务代表一个离散的、自包含的工作单元。执行完一个任务后，浏览器可以继续其他任务，例如重新渲染页面UI或执行垃圾回收。
- en: Microtasks, on the other hand, are smaller tasks that update the application
    state and should be executed before the browser continues with other assignments
    such as re-rendering the UI. Examples include promise callbacks and DOM mutation
    changes. Microtasks should be executed as soon as possible, in an asynchronous
    way, but without the cost of executing a whole new macrotask. Microtasks enable
    us to execute certain actions *before* the UI is re-rendered, thereby avoiding
    unnecessary UI rendering that might show inconsistent application state.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，微任务是较小的任务，用于更新应用程序状态，应该在浏览器继续其他任务（如重新渲染UI）之前执行。例如，包括promise回调和DOM变更。微任务应该尽快以异步方式执行，但不需要执行整个新的宏任务。微任务使我们能够在UI重新渲染之前执行某些操作，从而避免显示不一致的应用程序状态的无效UI渲染。
- en: '|  |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-349
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The ECMAScript specification doesn’t mention event loops. Instead, the event
    loop is detailed in the HTML specification ([https://html.spec.whatwg.org/#event-loops](https://html.spec.whatwg.org/#event-loops)),
    which also discusses the concept of macrotasks and microtasks. The ECMAScript
    specification mentions *jobs* (which are analogous to microtasks) in respect to
    handling promise callbacks ([http://mng.bz/fOlK](http://mng.bz/fOlK)). Even though
    the event loop is defined in the HTML specification, other environments, such
    as Node.js, also use it.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript规范没有提到事件循环。相反，事件循环在HTML规范中详细说明（[https://html.spec.whatwg.org/#event-loops](https://html.spec.whatwg.org/#event-loops)），同时也讨论了宏任务和微任务的概念。ECMAScript规范在处理promise回调时提到了*作业*（与微任务类似）。尽管事件循环在HTML规范中定义，但其他环境，如Node.js，也使用它。
- en: '|  |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The implementation of an event loop *should* use at least one queue for macrotasks
    and at least one queue for microtasks. Event loop implementations usually go beyond
    that, and have *several* queues for different types of macro- and microtasks.
    This enables the event loop to prioritize types of tasks; for example, giving
    priority to performance-sensitive tasks such as user input. On the other hand,
    because there are many browsers and JavaScript execution environments out in the
    wild, you shouldn’t be surprised if you run into event loops with only a single
    queue for both types of tasks together.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环的实现应该至少使用一个队列来处理宏任务，以及至少一个队列来处理微任务。事件循环的实现通常不止于此，并为不同类型的宏任务和微任务提供多个队列。这使得事件循环能够优先处理不同类型的任务；例如，优先处理性能敏感的任务，如用户输入。另一方面，由于野外有众多浏览器和JavaScript执行环境，如果你遇到只有单个队列同时处理这两种类型任务的事件循环，也不必感到惊讶。
- en: 'The event loop is based on two fundamental principles:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环基于两个基本原理：
- en: Tasks are handled one at a time.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务是逐个处理的。
- en: A task runs to completion and can’t be interrupted by another task.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个任务运行到完成，不能被另一个任务中断。
- en: Let’s take a look at [figure 13.1](#ch13fig01), which depicts these two principles.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看[图13.1](#ch13fig01)，它描绘了这两个原则。
- en: 'Figure 13.1\. The event loop usually has access to at least two task queues:
    a microtask queue and a macrotask queue. Both types of tasks are handled one at
    a time.'
  id: totrans-357
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.1。事件循环通常至少可以访问两个任务队列：一个微任务队列和一个宏任务队列。这两种类型的任务都是逐个处理的。
- en: '![](13fig01.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![](13fig01.jpg)'
- en: 'On a high level, [figure 13.1](#ch13fig01) shows that in a single iteration,
    the event loop first checks the macrotask queue, and if there’s a macrotask waiting
    to be executed, starts its execution. Only after the task is fully processed (or
    if there were no tasks in the queue), the event loop moves onto processing the
    microtask queue. If there’s a task waiting in that queue, the event loop takes
    it and executes it to completion. This is performed for all microtasks in the
    queue. Note the difference between handling the macrotask and microtask queues:
    In a single loop iteration, one macrotask at most is processed (others are left
    waiting in the queue), whereas all microtasks are processed.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，[图13.1](#ch13fig01) 显示，在单次迭代中，事件循环首先检查宏任务队列，如果有等待执行的任务，则开始执行。只有在任务完全处理完毕（或者队列中没有任务）之后，事件循环才会继续处理微任务队列。如果队列中有等待的任务，事件循环会取走并执行它直到完成。这会针对队列中的所有微任务执行。注意处理宏任务和微任务队列之间的区别：在单次循环迭代中，最多处理一个宏任务（其他任务则留在队列中等待），而所有微任务都会被处理。
- en: When the microtask queue is finally empty, the event loop checks whether a UI
    render update is required, and if it is, the UI is re-rendered. This ends the
    current iteration of the event loop, which goes back to the beginning and checks
    the macrotask queue again.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 当微任务队列最终为空时，事件循环检查是否需要UI渲染更新，如果是的话，UI就会被重新渲染。这标志着事件循环当前迭代的结束，然后它回到开始处再次检查宏任务队列。
- en: 'Now that we have a high-level understanding of the event loop, let’s check
    some of the interesting details shown in [figure 13.1](#ch13fig01):'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对事件循环有了高层次的理解，让我们检查[图13.1](#ch13fig01)中显示的一些有趣细节：
- en: '*Both task queues are placed outside the event loop*, to indicate that the
    act of adding tasks to their matching queues happens outside the event loop. If
    this wasn’t the case, any events that occur while JavaScript code is being executed
    would be ignored. Because we most definitely don’t want to do this, the acts of
    detecting and adding tasks are done separately from the event loop.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*两个任务队列都放置在事件循环之外*，以表明将任务添加到其匹配队列的行为发生在事件循环之外。如果不是这样，在JavaScript代码执行期间发生的任何事件都将被忽略。因为我们绝对不希望这样做，所以检测和添加任务的行为与事件循环分开进行。'
- en: '*Both types of tasks are executed one at a time*, because JavaScript is based
    on a single-threaded execution model. When a task starts executing, it’s executed
    to its completion, without being interrupted by another task. Only the browser
    can stop the execution of a task; for example, if the task starts being too selfish
    by taking up too much time or memory.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*两种类型的任务一次执行一个*，因为JavaScript基于单线程执行模型。当一个任务开始执行时，它会执行到完成，不会被另一个任务中断。只有浏览器可以停止任务的执行；例如，如果任务变得过于自私，占用太多时间或内存。'
- en: '*All microtasks should be executed before the next rendering*, because their
    goal is to update the application state before rendering occurs.'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*所有微任务都应该在下一轮渲染之前执行*，因为它们的目的是在渲染发生之前更新应用程序状态。'
- en: '*The browser usually tries to render the page 60 times per second*, to achieve
    60 frames per second (60 fps), a frame rate that’s often considered ideal for
    smooth motion, such as animations—*meaning, the browser tries to render a frame
    every 16 ms.* Notice how the “Update rendering” action, shown in [figure 13.1](#ch13fig01),
    happens inside the event loop, because the page content shouldn’t be modified
    by another task while the page is being rendered. This all means that, if we want
    to achieve smooth-running applications, we don’t have much time to process tasks
    in a single event-loop iteration. *A single task and all microtasks generated
    by that task should ideally complete within 16 ms*.'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*浏览器通常每秒尝试渲染页面60次*，以达到每秒60帧（60 fps），这是一种常被认为对平滑运动，如动画等理想的帧率——*也就是说，浏览器尝试每16毫秒渲染一帧。*
    注意到“更新渲染”操作，如[图13.1](#ch13fig01)所示，发生在事件循环内部，因为当页面正在渲染时，页面的内容不应该被另一个任务修改。所有这些都意味着，如果我们想实现运行流畅的应用程序，我们在单个事件循环迭代中处理任务的时间并不多。*一个任务及其产生的所有微任务理想上应该在16毫秒内完成*。'
- en: 'Now, let’s consider three situations that can occur in the next event-loop
    iteration, after the browser has completed a page render:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑在浏览器完成页面渲染后的下一个事件循环迭代中可能出现的三种情况：
- en: The event loop reaches the “Is rendering required?” decision point before another
    16 ms has elapsed. Because updating the UI is a complex operation, if there isn’t
    an explicit need to render the page, the browser may choose not to perform the
    UI rendering in this loop iteration.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件循环在另一个16毫秒过去之前就达到了“是否需要渲染？”的决策点。因为更新UI是一个复杂的操作，如果没有明确的渲染页面需求，浏览器可能会选择不在这次循环迭代中执行UI渲染。
- en: The event loop reaches the “Is rendering required?” decision point roughly around
    16 ms after the last rendering. In this case, the browser updates the UI, and
    users will experience a smooth-running application.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件循环在大约最后一次渲染后的16毫秒左右达到“是否需要渲染？”的决策点。在这种情况下，浏览器更新UI，用户将体验到运行流畅的应用程序。
- en: Executing the next task (and all related microtasks) takes much more than 16
    ms. In this case, the browser won’t be able to re-render the page at the target
    frame rate, and the UI won’t be updated. If running the task code doesn’t take
    up too much time (more than a couple of hundred milliseconds), this delay might
    not even be perceivable, especially if there isn’t much motion going on in the
    page. On the other hand, if we take too much time, or animations are running on
    the page, users will probably perceive the web page as slow and nonresponsive.
    In a worst-case scenario, in which a task gets executed for more than a couple
    of seconds, the user’s browser shows the dreaded “Unresponsive script” message.
    (Don’t worry, later in the chapter we’ll show you a technique for breaking complex
    tasks into smaller ones that won’t clog the event loop.)
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行下一个任务（及其所有相关微任务）需要超过16毫秒。在这种情况下，浏览器将无法以目标帧率重新渲染页面，UI将不会更新。如果运行任务代码的时间不太长（不超过几百毫秒），这种延迟可能甚至感觉不到，尤其是如果页面上没有太多运动。另一方面，如果我们花费太多时间，或者页面上有动画运行，用户可能会觉得网页运行缓慢且无响应。在最坏的情况下，如果一个任务执行超过几秒钟，用户的浏览器会显示可怕的“无响应脚本”消息。（别担心，在本章的后面部分，我们将向你展示一种将复杂任务分解成更小任务的技术，这样就不会阻塞事件循环。）
- en: '|  |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-371
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Be careful about which events you decide to handle, how often they occur, and
    how much processing time an event handler takes. For example, you should be extra
    careful when handling mouse-move events. Moving the mouse around causes a large
    number of events to be queued, so performing any complex operation in that mouse-move
    handler is a sure path to building a slow and jerky web application.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细考虑你决定处理哪些事件，它们发生的频率，以及事件处理器消耗的处理时间。例如，在处理鼠标移动事件时，你应该格外小心。鼠标的移动会导致大量事件被排队，因此在鼠标移动处理器中执行任何复杂操作都可能导致构建一个缓慢且不流畅的Web应用程序。
- en: '|  |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Now that we’ve described how the event loop works, you’re ready to explore a
    couple of examples in detail.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经描述了事件循环的工作原理，你就可以详细探索几个示例了。
- en: 13.1.1\. An example with only macrotasks
  id: totrans-375
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.1\. 只包含宏任务的示例
- en: The unavoidable result of JavaScript’s single-threaded execution model is that
    only one task can be executed at a time. This in turn means that all created tasks
    have to wait in a queue until their turn for execution comes.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的单线程执行模型不可避免的结果是，一次只能执行一个任务。这反过来意味着所有创建的任务都必须在队列中等待，直到轮到它们执行。
- en: 'Let’s focus our attention on a simple web page that contains the following:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关注一个简单的网页，它包含以下内容：
- en: Nontrivial mainline (global) JavaScript code
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非平凡的常规（全局）JavaScript代码
- en: Two buttons and two nontrivial click handlers, one for each button
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个按钮和两个非平凡的点击处理器，每个按钮一个
- en: The following listing shows the sample code.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了示例代码。
- en: Listing 13.1\. Pseudocode for our event loop demo with one task queue
  id: totrans-381
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表13.1\. 事件循环演示的一个任务队列的伪代码
- en: '![](336fig01_alt.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![](336fig01_alt.jpg)'
- en: 'This example requires some imagination, so instead of cluttering the code fragment
    with unnecessary code, we ask you to imagine the following:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子需要一些想象力，所以我们不把不必要的代码添加到代码片段中，而是要求你想象以下内容：
- en: Our mainline JavaScript code takes 15 ms to execute.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的主线JavaScript代码执行需要15毫秒。
- en: The first click event handler runs for 8 ms.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一次点击事件处理器运行了8毫秒。
- en: The second click event handler runs for 5 ms.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二次点击事件处理器运行了5毫秒。
- en: Now let’s continue to be imaginative, and say that we have a super quick user
    who clicks the first button 5 ms after our script starts executing, and the second
    button 12 ms after. [Figure 13.2](#ch13fig02) depicts this situation.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续发挥想象力，假设我们有一个超级快的用户，在脚本开始执行后的5毫秒点击了第一个按钮，在12毫秒后点击了第二个按钮。[图13.2](#ch13fig02)描述了这种情况。
- en: Figure 13.2\. This timing diagram shows how events are added to the task queue
    as they occur. When a task is done executing, the event loop takes it off the
    queue, and continues by executing the next task.
  id: totrans-388
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.2\. 这个时间图显示了事件如何随着它们的发生被添加到任务队列中。当一个任务执行完毕时，事件循环将其从队列中移除，并继续执行下一个任务。
- en: '![](13fig02_alt.jpg)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![](13fig02_alt.jpg)'
- en: There’s a lot of information to digest here, but understanding it completely
    will give you a better idea of how the event loop works. In the top part of the
    figure, time (in milliseconds) is running from left to right along the x-axis.
    The rectangles underneath that timeline represent portions of JavaScript code
    under execution, extending for the amount of time they’re running. For example,
    the first block of mainline JavaScript code executes for approximately 15 ms,
    the first click handler for approximately 8 ms, and the second click handler for
    approximately 5 ms. The timing diagram also shows when certain events occur; for
    example, the first button click occurs 5 ms into application execution, and the
    second button click at 12 ms. The bottom part of the figure shows the state of
    the macrotask queue at various points of application execution.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多信息需要消化，但完全理解它将更好地帮助你了解事件循环是如何工作的。在图的上部，时间（以毫秒为单位）沿着 x 轴从左到右运行。时间线之下的矩形代表正在执行的
    JavaScript 代码的部分，它们的持续时间与它们运行的时间相同。例如，第一块主线 JavaScript 代码执行了大约 15 毫秒，第一个点击处理程序大约
    8 毫秒，第二个点击处理程序大约 5 毫秒。时序图还显示了某些事件发生的时间；例如，第一个按钮点击发生在应用程序执行 5 毫秒时，第二个按钮点击发生在 12
    毫秒时。图的底部显示了应用程序执行过程中各个时间点的宏任务队列的状态。
- en: 'The program starts by executing mainline JavaScript code. Immediately, two
    elements, `firstButton` and `secondButton`, are fetched from the DOM, and two
    functions, `firstHandler` and `secondHandler`, are registered as click event handlers:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 程序开始执行主线 JavaScript 代码。立即，两个元素 `firstButton` 和 `secondButton` 被从 DOM 中获取，两个函数
    `firstHandler` 和 `secondHandler` 被注册为点击事件处理程序：
- en: '[PRE29]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is followed by code that executes for another 15 ms. During this execution,
    our quick user clicks `firstButton` 5 ms after the program starts executing, and
    clicks `secondButton` 12 ms after.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 接着是执行了另外 15 毫秒的代码。在这段执行过程中，我们的快速用户在程序开始执行后 5 毫秒点击了 `firstButton`，并在 12 毫秒后点击了
    `secondButton`。
- en: 'Because JavaScript is based on a single-threaded execution model, clicking
    `firstButton` doesn’t mean that the click handler is immediately executed. (Remember,
    if a task is already being executed, it can’t be interrupted by another task.)
    Instead, the click event related to `firstButton` is placed in the task queue,
    where it patiently waits for its turn to be executed. The same thing happens when
    a click of `secondButton` occurs: A matching event is placed in the task queue,
    and waits for execution. Note that it’s important that the event detection and
    addition to the task queue happens outside the event loop; the tasks are added
    to the task queue even while mainline JavaScript code is being executed.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JavaScript 基于单线程执行模型，点击 `firstButton` 并不意味着点击处理程序会立即执行。（记住，如果一个任务正在执行，它不能被另一个任务中断。）相反，与
    `firstButton` 相关的点击事件被放置在任务队列中，它耐心地等待轮到它执行。当 `secondButton` 被点击时，也会发生同样的事情：一个匹配的事件被放置在任务队列中，等待执行。请注意，事件检测和添加到任务队列发生在事件循环之外；即使在主线
    JavaScript 代码执行的同时，任务也会被添加到任务队列中。
- en: 'If we take a snapshot of our task queue 12 ms into the execution of our script,
    we’ll see the following three tasks:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在脚本执行 12 毫秒时对任务队列进行快照，我们将看到以下三个任务：
- en: Evaluate mainline JavaScript code—the currently executing task.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估主线 JavaScript 代码——当前正在执行的任务。
- en: Click `firstButton`—the event created when `firstButton` is clicked.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `firstButton`——当点击 `firstButton` 时创建的事件。
- en: Click `secondButton`—the event created when `secondButton` is clicked.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `secondButton`——当点击 `secondButton` 时创建的事件。
- en: These tasks are also shown in [figure 13.3](#ch13fig03).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这些任务也显示在[图 13.3](#ch13fig03)中。
- en: 'Figure 13.3\. 12 ms into the application execution, the task queue has three
    tasks: one for evaluating mainline JavaScript code (the currently executing task),
    and one for each button-click event.'
  id: totrans-400
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.3\. 在应用程序执行 12 毫秒时，任务队列中有三个任务：一个用于评估主线 JavaScript 代码（当前正在执行的任务），以及每个按钮点击事件一个。
- en: '![](13fig03.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](13fig03.jpg)'
- en: The next interesting point in the application execution happens at 15 ms, when
    the mainline JavaScript code finishes its execution. As shown in [figure 13.1](#ch13fig01),
    after a task has finished the execution, the event loop moves on to processing
    the microtask queue. Because in this situation we don’t have any microtasks (we
    don’t even show the microtask queue in the diagram, because it’s always empty),
    we skip this step and move on to updating the UI. In this example, even though
    the update happens and takes some time, for simplicity sake, we keep it out of
    our discussion. With this, the event loop finishes the first iteration and starts
    the second iteration, by moving onto the following task in the queue.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序执行中的下一个有趣点发生在15毫秒，此时主线JavaScript代码完成执行。如图13.1所示，在任务完成执行后，事件循环继续处理微任务队列。因为在这种情况下我们没有微任务（我们甚至在图中没有显示微任务队列，因为它总是空的），所以我们跳过这一步，继续更新UI。在这个例子中，尽管更新发生了并且花费了一些时间，但为了简单起见，我们将其排除在我们的讨论之外。这样，事件循环完成第一次迭代，并开始第二次迭代，移动到队列中的下一个任务。
- en: Next, the `firstButton` click task starts its execution. [Figure 13.4](#ch13fig04)
    illustrates the task queue 15 ms into the application execution. The execution
    of `firstHandler`, associated with the `firstButton` click, takes around 8 ms,
    and the handler is executed to its completion, without interruption, while the
    click event related to `secondButton` is waiting in the queue.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`firstButton`点击任务开始执行。[图13.4](#ch13fig04)说明了应用程序执行15毫秒时的任务队列。与`firstButton`点击相关的`firstHandler`执行大约需要8毫秒，处理程序被执行到完成，没有中断，而与`secondButton`相关的点击事件正在队列中等待。
- en: Figure 13.4\. The task queue 15 ms into application execution contains two tasks
    for click events. The first task is currently being executed.
  id: totrans-404
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.4.应用程序执行15毫秒时的任务队列包含两个点击事件的任务。第一个任务目前正在执行。
- en: '![](13fig04.jpg)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![13fig04.jpg](13fig04.jpg)'
- en: Next, at 23 ms, the `firstButton` click event is fully processed, and the matching
    task is removed from the task queue. Again, the browser checks the microtask queue,
    which is still empty, and re-renders the page, if necessary.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在23毫秒时，`firstButton`点击事件被完全处理，匹配的任务从任务队列中移除。同样，浏览器检查微任务队列，它仍然是空的，并在必要时重新渲染页面。
- en: Finally, in the third loop iteration, the `secondButton` click event is being
    handled, as shown in [figure 13.5](#ch13fig05). The `secondHandler` takes around
    5 ms to execute, and after this is performed, the task queue is finally empty,
    at 28 ms.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第三次循环迭代中，正在处理`secondButton`点击事件，如图13.5所示。`secondHandler`大约需要5毫秒来执行，在此之后，任务队列最终在28毫秒时为空。
- en: Figure 13.5\. 23 ms after the application starts executing, only one task, handling
    the `secondButton` click event, remains to be executed.
  id: totrans-408
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.5.应用程序开始执行后23毫秒，只有一个任务，即处理`secondButton`点击事件，需要执行。
- en: '![](13fig05_alt.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![13fig05_alt.jpg](13fig05_alt.jpg)'
- en: This example emphasizes that an event has to wait its turn to be processed,
    if other tasks are already being handled. For example, even though the `secondButton`
    click has happened 12 ms into the application execution, the matching handler
    is called somewhere around 23 ms into the application execution.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子强调，如果其他任务正在处理中，事件必须等待其轮次才能被处理。例如，尽管`secondButton`点击发生在应用程序执行的12毫秒处，但匹配的处理程序在大约23毫秒处被调用。
- en: Now let’s extend this code to include microtasks.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将这段代码扩展到包括微任务。
- en: 13.1.2\. An example with both macro- and microtasks
  id: totrans-412
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.2. 包含宏任务和微任务的例子
- en: Now that you’ve seen how the event loop works against one task queue, we’ll
    extend our example to also include a microtask queue. The cleanest way to do this
    is to include a promise in the first button-click handler and the code that handles
    the promise after it resolves. As you’ll recall from [chapter 6](kindle_split_017.html#ch06),
    *a promise is a placeholder for a value that we don’t have yet but will have later;*
    it’s a guarantee that we’ll eventually know the result of an asynchronous computation.
    For this reason, promise handlers, the callbacks we attach through the promise’s
    `then` method, are always called asynchronously, even if we attach them to already
    resolved promises.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了事件循环如何针对一个任务队列工作，我们将扩展我们的例子，也包括一个微任务队列。最干净的方法是在第一个按钮点击处理程序中包含一个promise，以及在其解析后处理promise的代码。如你从[第6章](kindle_split_017.html#ch06)中回忆的那样，*promise是我们尚未拥有但将来会拥有的值的占位符；*它是对我们最终将知道异步计算结果的保证。因此，promise处理程序，我们通过promise的`then`方法附加的回调，总是异步调用的，即使我们将其附加到已解析的promise上。
- en: The following listing shows the modified code for this two-queue example.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了此双队列示例的修改后的代码。
- en: Listing 13.2\. Pseudocode for our event loop demo with two queues
  id: totrans-415
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.2\. 我们带有两个队列的事件循环演示的伪代码
- en: '![](340fig01_alt.jpg)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
  zh: '![340fig01_alt.jpg](340fig01_alt.jpg)'
- en: 'In this example, we assume that the same actions occur as in the first example:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们假设发生的行为与第一个例子相同：
- en: '`firstButton` is clicked after 5 ms.'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`firstButton` 在 5 毫秒后被点击。'
- en: '`secondButton` is clicked after 12 ms.'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`secondButton` 在 12 毫秒后被点击。'
- en: '`firstHandler` handles the click event of `firstButton` and runs for 8 ms.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`firstHandler` 处理 `firstButton` 的点击事件，并运行 8 毫秒。'
- en: '`secondHandler` handles the click event of `secondButton` and runs for 5 ms.'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`secondHandler` 处理 `secondButton` 的点击事件，并运行 5 毫秒。'
- en: The only difference is that this time, within the `firstHandler` code, we also
    create an immediately resolved promise to which we pass a callback that will run
    for 4 ms. Because a promise represents a future value that we usually don’t know
    immediately, promise handlers are always handled asynchronously.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的不同之处在于，这次，在 `firstHandler` 代码中，我们还创建了一个立即解决的承诺，并将一个运行时间为 4 毫秒的回调传递给它。因为承诺代表一个我们通常不知道的未来的值，所以承诺处理程序总是异步处理的。
- en: To be honest, in this case, where we’ve created an immediately resolved promise,
    the JavaScript engine could immediately invoke the callback, because we already
    know that the promise is successfully resolved. But, for consistency sake, the
    JavaScript engine doesn’t do this, and instead calls all promise callbacks asynchronously,
    after the rest of the `firstHandler` code (which runs for 8 ms) is done executing.
    It does this by creating a new microtask and pushing it onto the microtask queue.
    Let’s explore the timing diagram of this execution in [figure 13.6](#ch13fig06).
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，在这种情况下，我们已经创建了一个立即解决的承诺，JavaScript 引擎可以立即调用回调，因为我们已经知道承诺已经成功解决。但是，为了保持一致性，JavaScript
    引擎并不这样做，而是将所有承诺回调异步地调用，在执行完其余的 `firstHandler` 代码（运行时间为 8 毫秒）之后。它是通过创建一个新的微任务并将其推入微任务队列来做到这一点的。让我们来探索这个执行过程的时序图，如图
    13.6 所示。
- en: Figure 13.6\. If a microtask is queued in the microtask queue, it gets priority
    and is processed even if an older task is already waiting in the queue. In this
    case, the promise success microtask gets priority over the `secondButton` click
    event task.
  id: totrans-424
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.6\. 如果微任务被排入微任务队列，它将获得优先级，即使队列中已经有一个更早的任务在等待，它也会被处理。在这种情况下，承诺成功微任务比 `secondButton`
    点击事件任务具有优先级。
- en: '![](13fig06_alt.jpg)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![13fig06_alt.jpg](13fig06_alt.jpg)'
- en: 'This timing diagram is similar to the diagram of the previous example. If we
    take a snapshot of the task queue 12 ms into the application execution, we’ll
    see the exact same tasks in the queue: The mainline JavaScript code is being processed
    while the tasks for handling the `firstButton` click and the `secondButton` click
    are waiting for their turns (just as in [figure 13.3](#ch13fig03)). But in addition
    to the task queue, in this example we’ll also focus on the microtask queue, which
    is still empty 12 ms into application execution.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 这个时序图与上一个例子的图相似。如果我们对应用程序执行 12 毫秒时的任务队列进行快照，我们会看到队列中确切的相同任务：主线 JavaScript 代码正在处理，而处理
    `firstButton` 点击和 `secondButton` 点击的任务正在等待它们的轮次（就像在图 13.3 中一样）。但在任务队列之外，在这个例子中我们还将关注微任务队列，在应用程序执行
    12 毫秒时，微任务队列仍然是空的。
- en: The next interesting point in application execution happens at 15 ms, when mainline
    JavaScript execution ends. Because a task has finished executing, the event loop
    checks the microtask queue, which is empty, and moves onto page rendering, if
    necessary. Again, for simplicity sake, we don’t include a rendering fragment in
    our timing diagram.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序执行中的下一个有趣点发生在 15 毫秒，此时主线 JavaScript 执行结束。因为一个任务已经完成执行，事件循环检查微任务队列，该队列是空的，如果需要，则继续页面渲染。为了简单起见，我们不包括渲染片段在我们的时序图中。
- en: 'In the next iteration of the event loop, the task associated with the `firstButton`
    click is being processed:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件循环的下一个迭代中，正在处理与 `firstButton` 点击相关联的任务：
- en: '[PRE30]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `firstHandler` function creates an already resolved promise, by calling
    `Promise.resolve()` with a callback function that will for sure be invoked, because
    the promise is already resolved. This creates a new microtask to run the callback
    code. The microtask is placed into the microtask queue, and the click handler
    continues to execute for another 8 ms. The current state of the task queues is
    shown in [figure 13.7](#ch13fig07).
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '`firstHandler` 函数通过调用 `Promise.resolve()` 并传入一个一定会被调用的回调函数来创建一个已解决的承诺，因为承诺已经解决。这会创建一个新的微任务来运行回调代码。微任务被放入微任务队列中，而点击处理程序继续执行另外
    8 毫秒。当前任务队列的状态显示在 [图 13.7](#ch13fig07) 中。'
- en: Figure 13.7\. During the execution of the first click handler, a resolved promise
    is created. This queues up a promise success microtask in the microtask queue
    that will be executed as soon as possible, but without interrupting the currently
    running task.
  id: totrans-431
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.7\. 在第一个点击处理程序执行期间，创建了一个已解决的承诺。这将在微任务队列中排一个承诺成功微任务，该任务将尽可能快地执行，但不会打断当前正在运行的任务。
- en: '![](13fig07.jpg)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: '![图片 13.7](13fig07.jpg)'
- en: We revisit the task queues again 23 ms into the application execution, after
    the `firstButton` click has been completely handled and its task taken off the
    task queue.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `firstButton` 点击完全处理并从任务队列中移除后，应用执行 23 毫秒时，我们再次回顾任务队列。
- en: At this point, the event loop has to choose which task to process next. We have
    one macrotask for handling the `secondButton` click that was placed in the task
    queue 12 ms into application execution, and one microtask for handling the promise
    success that was placed in the microtask queue somewhere around 15 ms into the
    application execution.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，事件循环必须选择下一个要处理的任务。我们有一个处理 `secondButton` 点击的宏任务，该任务在应用执行 12 毫秒时放入任务队列，还有一个处理承诺成功的微任务，该任务在应用执行大约
    15 毫秒时放入微任务队列。
- en: If we consider things like this, it would be only fair that the `secondButton`
    click task gets handled first, but as we already mentioned, microtasks are smaller
    tasks that should be executed as soon as possible. Microtasks have priority, and
    if you look back at [figure 13.1](#ch13fig01), you’ll see that every time a task
    is processed, the event loop first checks the microtask queue, with the goal of
    processing all microtasks before continuing on to either rendering or other tasks.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 如果考虑这些因素，`secondButton` 点击任务首先被处理似乎是公平的，但正如我们之前提到的，微任务是应该尽快执行的小任务。微任务有优先级，如果你回顾
    [图 13.1](#ch13fig01)，你会看到每次处理任务时，事件循环首先检查微任务队列，目标是处理所有微任务，然后再继续渲染或其他任务。
- en: For this reason, the promise success task is executed *immediately* after the
    `firstButton` click, even with the “older” `secondButton` click task still waiting
    in the task queue, as shown in [figure 13.8](#ch13fig08).
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，承诺成功任务在 `firstButton` 点击后立即执行，即使“较老”的 `secondButton` 点击任务仍然在任务队列中等待，如 [图
    13.8](#ch13fig08) 所示。
- en: Figure 13.8\. After a task gets executed, the event loop processes all tasks
    in the microtask queue. In this case, before moving to the `secondButton` click
    task, the promise success task is handled.
  id: totrans-437
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.8\. 任务执行后，事件循环处理微任务队列中的所有任务。在这种情况下，在移动到 `secondButton` 点击任务之前，处理了承诺成功任务。
- en: '![](13fig08_alt.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![图片 13.8](13fig08_alt.jpg)'
- en: There’s one important point that we need to emphasize. After a macrotask gets
    executed, the event loop immediately moves onto handling the microtask queue,
    without allowing rendering until the microtask queue is empty. Just take a look
    at the timing diagram in [figure 13.9](#ch13fig09).
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个重要的观点我们需要强调。在宏任务执行完毕后，事件循环立即转向处理微任务队列，直到微任务队列为空之前不允许渲染。只需看看 [图 13.9](#ch13fig09)
    中的时间图即可。
- en: Figure 13.9\. A page can be re-rendered between two macrotasks (mainline JavaScript
    execution and first click handler), while it *can’t* be rendered before a microtask
    is executed (before the promise handler).
  id: totrans-440
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.9\. 在两个宏任务（主线 JavaScript 执行和第一个点击处理程序）之间可以重新渲染页面，而**不能**在执行微任务之前（在承诺处理程序之前）进行渲染。
- en: '![](13fig09_alt.jpg)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
  zh: '![图片 13.9](13fig09_alt.jpg)'
- en: '[Figure 13.9](#ch13fig09) shows that a re-render can occur between two macrotasks,
    only if there are no microtasks in between. In our case, the page can be rendered
    between the mainline JavaScript execution and the first click handler, but it
    can’t be rendered immediately after the first click handler, because microtasks,
    such as promise handlers, have priority over rendering.'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13.9](#ch13fig09) 显示，在两个宏任务之间可以发生重新渲染，前提是它们之间没有微任务。在我们的情况下，页面可以在主线 JavaScript
    执行和第一个点击处理程序之间渲染，但不能在第一个点击处理程序之后立即渲染，因为微任务（如承诺处理程序）的优先级高于渲染。'
- en: A render can also occur after a microtask, but only if no other microtasks are
    waiting in the microtask queue. In our example, after the promise handler occurs,
    but before the event loop moves onto the second click handler, the browser can
    re-render the page.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在微任务之后也可以发生渲染，但前提是微任务队列中没有其他微任务等待。在我们的例子中，在承诺处理程序发生之后，但在事件循环移动到第二个点击处理程序之前，浏览器可以重新渲染页面。
- en: Note that there’s nothing stopping the promise success microtask from queuing
    other microtasks, and that all of these microtasks will have priority over the
    `secondButton` click task. The event loop will re-render the page and move onto
    the `secondButton` task only when the microtask queue is empty, so be careful!
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，没有任何东西可以阻止成功承诺的微任务将其他微任务排队，并且所有这些微任务都将优先于 `secondButton` 点击任务。事件循环只有在微任务队列为空时才会重新渲染页面并移动到
    `secondButton` 任务，所以请小心！
- en: 'Now that you understand how the event loop works, let’s take a look at a special
    group of events: timers.'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了事件循环的工作原理，让我们来看看一组特殊的事件：定时器。
- en: '13.2\. Taming timers: time-outs and intervals'
  id: totrans-446
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2\. 驯服定时器：超时和间隔
- en: Timers, an often misused and poorly understood feature in JavaScript, can enhance
    the development of complex applications if used properly. Timers enable us to
    delay the execution of a piece of code by *at least* a certain number of milliseconds.
    We’ll use this capability to break long-running tasks into smaller tasks that
    won’t clog the event loop, thereby stopping the browser from rendering, and in
    the process making our web applications slow and unresponsive.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 定时器，JavaScript 中一个常被误用且理解不深的特性，如果使用得当，可以增强复杂应用程序的开发。定时器使我们能够通过至少一定的毫秒数延迟执行一段代码。我们将利用这一功能将长时间运行的任务分解成更小的任务，这样就不会阻塞事件循环，从而停止浏览器渲染，在这个过程中使我们的网络应用变得缓慢且无响应。
- en: 'But first, we’ll start by examining the functions we can use to construct and
    manipulate timers. The browser provides two methods for creating timers: `setTimeout`
    and `setInterval`. The browser also provides two corresponding methods to clear
    (or remove) them: `clearTimeout` and `clearInterval`. All are methods of the `window`
    (global context) object. Similarly to the event loop, timers aren’t defined within
    JavaScript itself; instead they’re provided by the host environment (such as the
    browser on the client, or Node.js on the server). [Table 13.1](#ch13table01) lists
    the methods for creating and clearing timers.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们将从检查我们可以用来构建和操作定时器的函数开始。浏览器提供了两种创建定时器的方法：`setTimeout` 和 `setInterval`。浏览器还提供了两种相应的方法来清除（或移除）它们：`clearTimeout`
    和 `clearInterval`。所有这些都是 `window`（全局上下文）对象的方法。与事件循环类似，定时器不是在 JavaScript 本身中定义的；相反，它们由宿主环境（例如客户端的浏览器或服务器的
    Node.js）提供。[表 13.1](#ch13table01) 列出了创建和清除定时器的方法。
- en: Table 13.1\. JavaScript’s timer-manipulation methods (methods of the global
    `window` object)
  id: totrans-449
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 13.1\. JavaScript 的定时器操作方法（全局 `window` 对象的方法）
- en: '| Method | Format | Description |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 格式 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| setTimeout | id = setTimeout(fn,delay) | Initiates a timer that will execute
    the passed callback once after the specified delay has elapsed. A value that uniquely
    identifies the timer is returned. |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '| setTimeout | id = setTimeout(fn,delay) | 启动一个定时器，该定时器将在指定的延迟时间过后执行一次传入的回调函数。返回一个唯一标识定时器的值。|'
- en: '| clearTimeout | clearTimeout(id) | Cancels (clears) the timer identified by
    the passed value if the timer hasn’t yet fired. |'
  id: totrans-453
  prefs: []
  type: TYPE_TB
  zh: '| clearTimeout | clearTimeout(id) | 如果定时器尚未触发，则取消（清除）由传入值标识的定时器。|'
- en: '| setInterval | id = setInterval(fn,delay) | Initiates a timer that will continually
    try to execute the passed callback at the specified delay interval, until canceled.
    A value that uniquely identifies the timer is returned. |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
  zh: '| setInterval | id = setInterval(fn,delay) | 启动一个定时器，该定时器将在指定的延迟间隔内不断尝试执行传入的回调函数，直到取消。返回一个唯一标识定时器的值。|'
- en: '| clearInterval | clearInterval(id) | Cancels (clears) the interval timer identified
    by the passed value. |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
  zh: '| clearInterval | clearInterval(id) | 取消（清除）由传递的值标识的间隔计时器。 |'
- en: These methods allow us to set and clear timers that either fire a single time
    or fire periodically at a specified interval. In practice, most browsers allow
    you to use both `clearTimeout` and `clearInterval` to cancel both kinds of timers,
    but it’s recommended that the methods be used in matched pairs, if for nothing
    other than clarity.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法允许我们设置和清除计时器，这些计时器要么一次性触发，要么在指定的时间间隔内周期性触发。在实践中，大多数浏览器允许你使用`clearTimeout`和`clearInterval`来取消这两种类型的计时器，但如果只是为了清晰，建议使用匹配的成对方法。
- en: '|  |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-458
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: It’s important to understand that *a timer’s delay isn’t guaranteed*. This has
    a great deal to do with the event loop, as we’ll see in the next section.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解*计时器的延迟是不保证的*。这与事件循环有很大关系，我们将在下一节中看到。
- en: '|  |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 13.2.1\. Timer execution within the event loop
  id: totrans-461
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.1. 事件循环中的计时器执行
- en: You’ve already examined exactly what happens when an event occurs. But timers
    are different from standard events, so let’s explore an example similar to the
    ones you’ve seen so far. The following listing shows the code used for this example.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经详细地检查了事件发生时会发生什么。但是计时器与标准事件不同，所以让我们探索一个与之前看到的类似的例子。下面的列表显示了用于此例的代码。
- en: Listing 13.3\. Pseudocode for our time-out and interval demo
  id: totrans-463
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表13.3.我们的超时和间隔演示的伪代码
- en: '![](345fig01_alt.jpg)'
  id: totrans-464
  prefs: []
  type: TYPE_IMG
  zh: '![](345fig01_alt.jpg)'
- en: 'This time we have only one button, but we also register two timers. First,
    we register a time-out that expires after 10 ms:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们只有一个按钮，但我们还注册了两个计时器。首先，我们注册了一个在10毫秒后到期的超时：
- en: '[PRE31]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As a handler, that time-out has a function that takes 6 ms to execute. Next,
    we also register an interval that expires every 10 ms:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 作为处理者，那个超时有一个执行时间为6毫秒的功能。接下来，我们还注册了一个每10毫秒就到期的间隔：
- en: '[PRE32]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The interval has a handler that takes 8 ms to execute. We continue by registering
    a button-click event handler that takes 10 ms to execute:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 间隔有一个处理程序，它需要8毫秒来执行。我们继续注册一个按钮点击事件处理程序，它需要10毫秒来执行：
- en: '[PRE33]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This example ends with a code block that runs for about 18 ms (again, humor
    us a bit and imagine some complex code here).
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子以一个运行约18毫秒（再次，请稍等片刻，想象一些复杂的代码）的代码块结束。
- en: Now, let’s say we again have a quick and impatient user who clicks the button
    6 ms into the application execution. [Figure 13.10](#ch13fig10) shows a timing
    diagram of the first 18 ms of execution.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们有一个快速且不耐烦的用户在应用程序执行6毫秒时点击了按钮。[图13.10](#ch13fig10)显示了执行前18毫秒的时序图。
- en: 'Figure 13.10\. A timing diagram that shows 18 ms of execution in the example
    program. The first, currently running task is to evaluate mainline JavaScript
    code. It takes 18 ms to execute. During that execution, three events occur: a
    mouse click, a timer expiry, and an interval firing.'
  id: totrans-473
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.10。一个显示示例程序中18毫秒执行时间的时序图。第一个，当前正在运行的任务是评估主线JavaScript代码。它需要18毫秒来执行。在执行过程中，发生了三个事件：鼠标点击、计时器到期和间隔触发。
- en: '![](13fig10_alt.jpg)'
  id: totrans-474
  prefs: []
  type: TYPE_IMG
  zh: '![](13fig10_alt.jpg)'
- en: 'As in the previous examples, the first task in the queue is to execute mainline
    JavaScript code. During that execution, which roughly takes 18 ms to complete,
    three important things occur:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，队列中的第一个任务是执行主线JavaScript代码。在这个过程中，大约需要18毫秒来完成，发生了三件重要的事情：
- en: At 0 ms, a time-out timer is initiated with a 10 ms delay, and an interval timer
    is also initiated with a 10 ms delay. Their references are kept by the browser.
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在0毫秒时，启动了一个10毫秒延迟的超时计时器，并启动了一个10毫秒延迟的间隔计时器。它们的引用被浏览器保留。
- en: At 6 ms, the mouse is clicked.
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在6毫秒时，鼠标被点击。
- en: At 10 ms, the time-out timer expires and the first interval fires.
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在10毫秒时，超时计时器到期，第一个间隔触发。
- en: 'As we already know from our event-loop exploration, a task always runs to completion
    and can’t be interrupted by another task. Instead, all newly created tasks are
    placed in a queue, where they patiently wait their turn to be processed. When
    the user clicks the button 6 ms into application execution, that task is added
    to the task queue. A similar thing happens at around 10 ms, when the timer expires
    and the interval fires. Timer events, just like input events (such as mouse events),
    are placed in the task queue. Note that both the timer and interval are initiated
    with a 10 ms delay, and that after this period, their matching tasks are placed
    in the task queue. We’ll come back to this later, but for now it’s enough that
    you notice that the tasks are added to the queue in the order in which the handlers
    are registered: first the time-out handler and then the interval handler.'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从事件循环探索中已经知道的，一个任务总是运行到完成，不能被另一个任务中断。相反，所有新创建的任务都被放置在一个队列中，它们耐心地等待轮到它们被处理。当用户在应用程序执行6毫秒时点击按钮，该任务被添加到任务队列中。在大约10毫秒时，当计时器到期并触发间隔时，也会发生类似的事情。计时器事件，就像输入事件（如鼠标事件）一样，被放置在任务队列中。请注意，计时器和间隔都是以10毫秒的延迟启动的，并且在此期间，它们的匹配任务被放置在任务队列中。我们稍后会回到这一点，但现在你只需要注意到任务是以处理程序注册的顺序添加到队列中的：首先是超时处理程序，然后是间隔处理程序。
- en: The initial block of code completes executing after 18 ms, and because there
    are no microtasks in this execution, the browser can re-render the page (again,
    left out from our timing discussions, due to simplicity) and move onto the second
    iteration of the event loop. The state of the task queue at this time is shown
    in [figure 13.11](#ch13fig11).
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 初始代码块在18毫秒后完成执行，因为这次执行中没有微任务，浏览器可以重新渲染页面（再次省略了我们的时间讨论，因为简单），并进入事件循环的第二次迭代。此时任务队列的状态在[图13.11](#ch13fig11)中显示。
- en: Figure 13.11\. Timer events are placed into the task queue as they expire.
  id: totrans-481
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.11。计时器事件在到期时被放置到任务队列中。
- en: '![](13fig11.jpg)'
  id: totrans-482
  prefs: []
  type: TYPE_IMG
  zh: '![](13fig11.jpg)'
- en: 'When the initial block of code ends execution at 18 ms, three code blocks are
    queued up for execution: the click handler, the time-out handler, and the first
    invocation of the interval handler. This means that the waiting click handler
    (which we assume takes 10 ms to execute) begins execution. [Figure 13.12](#ch13fig12)
    shows another timing diagram.'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 当初始代码块在18毫秒时结束执行，有三个代码块被排队等待执行：点击处理程序、超时处理程序和间隔处理程序的第一次调用。这意味着等待的点击处理程序（我们假设它需要10毫秒来执行）开始执行。[图13.12](#ch13fig12)显示了另一个时间图。
- en: Figure 13.12\. If an interval event fires, and a task is already associated
    with that interval waiting in the queue, a new task isn’t added. Instead, nothing
    happens, as is shown for the queues at 20 ms and 30 ms.
  id: totrans-484
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.12。如果一个间隔事件被触发，并且一个任务已经与该间隔关联并等待在队列中，则不会添加新的任务。相反，就像在20毫秒和30毫秒的队列中所示，什么都不会发生。
- en: '![](13fig12_alt.jpg)'
  id: totrans-485
  prefs: []
  type: TYPE_IMG
  zh: '![](13fig12_alt.jpg)'
- en: Unlike the `setTimeout` function, which expires only once, the `setInterval`
    function fires until we explicitly clear it. So, at around 20 ms, another interval
    fires. Normally, this would create a new task and add it to the task queue. But
    this time, because an instance of an interval task is already queued and awaiting
    execution, this invocation is dropped. *The browser won’t queue up more than one
    instance of a specific interval handler*.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 与只触发一次的`setTimeout`函数不同，`setInterval`函数会一直触发，直到我们明确清除它。所以，在大约20毫秒时，另一个间隔被触发。通常，这会创建一个新的任务并将其添加到任务队列中。但这次，因为一个间隔任务的实例已经排队并等待执行，这次调用被丢弃。*浏览器不会为特定的间隔处理程序排队超过一个实例*。
- en: 'The click handler completes at 28 ms, and the browser is again allowed to re-render
    the page before the event loop goes into another iteration. In the next iteration
    of the event loop, at 28 ms, the time-out task is processed. But think back to
    the beginning of this example. We used the following function call to set a time-out
    that should expire after 10 ms:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 点击处理程序在28毫秒时完成，在事件循环进入下一次迭代之前，浏览器再次被允许重新渲染页面。在事件循环的下一个迭代中，在28毫秒时，处理超时任务。但回想一下这个示例的开始。我们使用以下函数调用来设置一个应该在10毫秒后到期的超时：
- en: '[PRE34]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Because this is the first task in our application, it’s not weird to expect
    that the time-out handler will be executed exactly after 10 ms. But as you see
    in [figure 13.11](#ch13fig11), the time-out starts at the 28 ms mark!
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是我们应用程序中的第一个任务，所以期待超时处理程序在10毫秒后正好执行并不奇怪。但正如你在[图13.11](#ch13fig11)中看到的，超时是在28毫秒标记开始的！
- en: That’s why we were extra careful when saying that a timer provides the capability
    to asynchronously delay the execution of a piece of code by *at least* a certain
    number of milliseconds. Because of the single-threaded nature of JavaScript, we
    can control only when the timer task is added to the queue, and not when it’s
    finally executed! Now that we cleared up this little conundrum, let’s continue
    with the remainder of the application execution.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，我们在说定时器提供的能力可以异步延迟代码执行至少一定数量的毫秒时格外小心。由于JavaScript的单线程特性，我们只能控制定时器任务何时被添加到队列，而不能控制它何时最终执行！现在我们已经澄清了这个小难题，让我们继续处理应用程序执行的其余部分。
- en: The time-out task takes 6 ms to execute, so it should be finished 34 ms into
    the application execution. During this time period, at 30 ms another interval
    fires, because we’ve scheduled it to be executed every 10 ms. Once more, no additional
    task is queued, because a matching task for interval handler execution is already
    waiting in the queue. At 34 ms, the time-out handler finishes, and the browser
    again has a chance to re-render the page and enter another iteration of the event
    loop.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 超时任务需要6毫秒来执行，所以它应该在应用程序执行的34毫秒时完成。在这个时间段内，在30毫秒时另一个间隔触发，因为我们已经安排它每10毫秒执行一次。再次，没有额外的任务被排队，因为间隔处理程序执行的匹配任务已经在队列中等待。在34毫秒时，超时处理程序完成，浏览器再次有机会重新渲染页面并进入事件循环的另一个迭代。
- en: Finally, the interval handler starts its execution at 34 ms, 24 ms *after* the
    10 ms mark at which it was added to the event queue. This again emphasizes that
    the delay we pass in as an argument to the functions `setTimeout(fn, delay)` and
    `setInterval(fn, delay)` specifies only the delay after which the matching task
    is added to the queue, and not the exact time of execution.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，间隔处理程序在34毫秒开始执行，比它被添加到事件队列的10毫秒标记晚了24毫秒。这再次强调了我们将作为参数传递给`setTimeout(fn, delay)`和`setInterval(fn,
    delay)`函数的延迟，只指定了匹配任务添加到队列后的延迟时间，而不是执行的确切时间。
- en: The interval handler takes 8 ms to execute, so while it’s executing, another
    interval expires at the 40 ms mark. This time, because the interval handler is
    being executed (and not waiting in the queue), a new interval task is finally
    added to the task queue, and the execution of our application continues, as shown
    in [figure 13.13](#ch13fig13). Setting a `setInterval` delay to 10 ms doesn’t
    mean that we’ll end up with our handler executing every 10 ms. For example, because
    tasks are queued and the duration of a single task execution can vary, intervals
    can be executed one right after another, as is the case with intervals at the
    42 and 50 ms marks.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 间隔处理程序需要8毫秒来执行，所以在它执行的过程中，另一个间隔在40毫秒标记处到期。这次，因为间隔处理程序正在执行（而不是在队列中等待），一个新的间隔任务最终被添加到任务队列中，并且应用程序的执行继续，如[图13.13](#ch13fig13)所示。将`setInterval`延迟设置为10毫秒并不意味着我们的处理程序会每10毫秒执行一次。例如，因为任务被排队，单个任务执行的时间可能有所不同，所以间隔可以一个接一个地执行，就像42毫秒和50毫秒标记处的间隔一样。
- en: Figure 13.13\. Because of the setbacks caused by the mouse click and time-out
    handler, it takes some time for the interval handlers to start executing every
    10 ms.
  id: totrans-494
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.13。由于鼠标点击和超时处理程序造成的延误，间隔处理程序每10毫秒开始执行需要一些时间。
- en: '![](13fig13_alt.jpg)'
  id: totrans-495
  prefs: []
  type: TYPE_IMG
  zh: '![图片](13fig13_alt.jpg)'
- en: Finally, after 50 ms our intervals stabilize and are executed every 10 ms. The
    important concept to take away is that the event loop can process only one task
    at a time, and that we can never be certain that timer handlers will execute exactly
    when we expect them to. This is especially true of interval handlers. We saw in
    this example that even though we scheduled an interval expected to fire at 10,
    20, 30, 40, 50, 60, and 70 ms marks, the callbacks were executed at 34, 42, 50,
    60, and 70 ms marks. In this case, we completely lost two of them along the way,
    and some weren’t executed at the expected time.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，经过50毫秒后，我们的间隔稳定下来，并且每10毫秒执行一次。需要记住的重要概念是事件循环一次只能处理一个任务，而且我们永远不能确定定时器处理程序会正好在我们期望的时候执行。这一点在间隔处理程序中尤其如此。在这个例子中，尽管我们安排了在10、20、30、40、50、60和70毫秒标记处触发的间隔，但回调却在34、42、50、60和70毫秒标记处执行。在这种情况下，我们完全丢失了其中两个，而且有些并没有在预期的时间执行。
- en: As we can see, intervals have special considerations that don’t apply to time-outs.
    Let’s look at those more closely.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，间隔有一些特殊的考虑因素，这些因素不适用于超时。让我们更仔细地看看这些。
- en: Differences between time-outs and intervals
  id: totrans-498
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 超时和间隔之间的差异
- en: 'At first glance, an interval may look like a time-out that periodically repeats
    itself. But the differences run a little deeper. Let’s look at an example to better
    illustrate the differences between `setTimeout` and `setInterval`:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，一个间隔可能看起来像是一个周期性重复的时间暂停。但差异要深得多。让我们通过一个例子来更好地说明`setTimeout`和`setInterval`之间的区别：
- en: '![](350fig01_alt.jpg)'
  id: totrans-500
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](350fig01_alt.jpg)'
- en: The two pieces of code may *appear* to be functionally equivalent, but they
    aren’t. Notably, the `setTimeout` variant of the code will always have at least
    a 10 ms delay after the previous callback execution (depending on the state of
    the event queue, it may end up being more, but never less), whereas `setInterval`
    will attempt to execute a callback every 10 ms regardless of when the last callback
    was executed. And, as you saw in the example from the previous section, intervals
    can be fired immediately one after another, regardless of the delay.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 这两段代码可能*看起来*在功能上是等效的，但它们并不是。值得注意的是，代码的`setTimeout`变体在之前的回调执行后始终至少有10毫秒的延迟（取决于事件队列的状态，它可能最终会更多，但绝不会更少），而`setInterval`将尝试在每次回调执行后每10毫秒执行一次。而且，正如你在上一节中的示例中所看到的，间隔可以立即连续触发，而不管延迟是多少。
- en: We know that the time-out callback is never guaranteed to execute exactly when
    it’s fired. Rather than being fired every 10 ms, as the interval is, it will reschedule
    itself for 10 ms after it gets around to executing.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，超时回调并不保证在触发时正好执行。它不会像间隔那样每10毫秒触发一次，而是在执行完毕后重新安排10毫秒后执行。
- en: All of this is incredibly important knowledge. Knowing how a JavaScript engine
    handles asynchronous code, especially with the large number of asynchronous events
    that typically occur in the average page, creates a great foundation for building
    advanced pieces of application code.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些知识都极其重要。了解JavaScript引擎如何处理异步代码，尤其是在平均页面中通常发生的众多异步事件，为构建高级应用程序代码奠定了坚实的基础。
- en: With all that under our belts, let’s see how our understanding of timers and
    the event loop can help avoid some performance pitfalls.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了所有这些知识之后，让我们看看我们对计时器和事件循环的理解如何帮助我们避免一些性能陷阱。
- en: 13.2.2\. Dealing with computationally expensive processing
  id: totrans-505
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.2. 处理计算密集型处理
- en: The single-threaded nature of JavaScript is probably the largest gotcha in complex
    JavaScript application development. While JavaScript is busy executing, user interaction
    in the browser can become, at best, sluggish, and, at worst, unresponsive. The
    browser may stutter or seem to hang, because all updates to the rendering of a
    page are suspended while JavaScript is executing.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的单线程特性可能是复杂JavaScript应用程序开发中最大的陷阱。当JavaScript正在执行时，浏览器中的用户交互最多只能变得缓慢，最坏的情况是变得无响应。浏览器可能会出现卡顿或似乎挂起的情况，因为当JavaScript执行时，页面的所有更新都会暂停。
- en: Reducing all complex operations that take any more than a few hundred milliseconds
    into manageable portions becomes a necessity if we want to keep the interface
    responsive. Additionally, most browsers will produce a dialog box warning the
    user that a script has become “unresponsive” if it has run nonstop for at least
    5 seconds, while some other browsers will even silently kill any script running
    for more than 5 seconds.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望保持界面响应，将所有超过几百毫秒的复杂操作简化为可管理的部分变得必要。此外，大多数浏览器会在脚本连续运行至少5秒后，弹出一个对话框警告用户脚本已变得“无响应”，而一些其他浏览器甚至会静默地终止运行超过5秒的任何脚本。
- en: You may have been to a family reunion where a garrulous uncle won’t stop talking
    and insists on telling the same stories over and over again. If no one else gets
    a chance to break in and get a word in edgewise, the conversation’s not going
    to be pleasant for anyone (except for Uncle Bruce). Likewise, code that hogs all
    the processing time results in an outcome that’s less than desirable; producing
    an unresponsive user interface is never good. But situations will almost certainly
    arise that require us to process a significant amount of data, situations such
    as manipulating a couple of thousand DOM elements, for example.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能参加过一次家庭聚会，其中一位健谈的叔叔不停地说个不停，坚持一遍又一遍地讲述同样的故事。如果没有人有机会打断并说上几句，对话对任何人来说都不会愉快（除了布鲁斯叔叔）。同样，占用所有处理时间的代码会导致结果不尽如人意；产生无响应的用户界面永远不是好事。但几乎肯定会出现需要我们处理大量数据的情况，例如操作几千个DOM元素。
- en: On these occasions, timers can come to the rescue and become especially useful.
    Because timers are capable of effectively suspending the execution of a piece
    of JavaScript until a later time, they can also break individual pieces of code
    into fragments that aren’t long enough to cause the browser to hang. Taking this
    into account, we can convert intensive loops and operations into nonblocking operations.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些场合，计时器可以救命，并且变得特别有用。因为计时器能够有效地挂起JavaScript代码的执行，直到稍后时间，它们也可以将单个代码片段分解成不会使浏览器挂起的不够长的时间段。考虑到这一点，我们可以将密集的循环和操作转换为非阻塞操作。
- en: Let’s look at the following example of a task that’s likely to take a long time.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下可能需要花费很长时间的任务示例。
- en: Listing 13.4\. A long-running task
  id: totrans-511
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表13.4。一个长时间运行的任务
- en: '![](351fig01_alt.jpg)'
  id: totrans-512
  prefs: []
  type: TYPE_IMG
  zh: '![](351fig01_alt.jpg)'
- en: In this example, we’re creating a total of 240,000 DOM nodes, populating a table
    with 20,000 rows of 6 cells, each containing a text node. This is incredibly expensive
    and will likely hang the browser for a noticeable period while executing, preventing
    the user from performing normal interactions (much in the same way that Uncle
    Bruce dominates the conversation at the family get-together).
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们总共创建了240,000个DOM节点，用包含6个单元格的20,000行填充表格，每个单元格都包含一个文本节点。这非常昂贵，并且在执行过程中很可能会使浏览器挂起一段时间，从而阻止用户进行正常交互（就像布鲁斯叔叔在家庭聚会上主导谈话一样）。
- en: What we need to do is shut up Uncle Bruce at regular intervals so that other
    people can get a chance to join the conversation. In code, we can introduce timers
    to create just such “breaks in the conversation,” as shown in the next listing.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定期让布鲁斯叔叔闭嘴，这样其他人就有机会加入谈话。在代码中，我们可以引入计时器来创建这样的“谈话中断”，如下一个列表所示。
- en: Listing 13.5\. Using a timer to break up a long-running task
  id: totrans-515
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表13.5。使用计时器分解长时间运行的任务
- en: '![](351fig02_alt.jpg)'
  id: totrans-516
  prefs: []
  type: TYPE_IMG
  zh: '![](351fig02_alt.jpg)'
- en: In this modification to the example, we’ve broken up the lengthy operation into
    four smaller operations, each creating its own share of DOM nodes. These smaller
    operations are much less likely to interrupt the flow of the browser, as shown
    in [figure 13.14](#ch13fig14). Note that we’ve set it up so that the data values
    controlling the operation are collected into easily tweakable variables (`rowCount`,
    `divideInto`, and `chunkSize`), should we need to break the operations into, let’s
    say, ten parts instead of four.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个对示例的修改中，我们将长时间操作分解为四个更小的操作，每个操作都创建自己的DOM节点。这些较小的操作不太可能中断浏览器的流程，如图13.14所示。请注意，我们已经将其设置为将控制操作的数据值收集到易于调整的变量中（`rowCount`、`divideInto`和`chunkSize`），如果我们需要将操作分解为，比如说，四个部分而不是十个部分。
- en: Figure 13.14\. Use timers to break long-running tasks into smaller tasks that
    won’t clog the event loop.
  id: totrans-518
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.14。使用计时器将长时间运行的任务分解为不会阻塞事件循环的小任务。
- en: '![](13fig14_alt.jpg)'
  id: totrans-519
  prefs: []
  type: TYPE_IMG
  zh: '![](13fig14_alt.jpg)'
- en: 'Also important to note is the little bit of math needed to keep track of where
    we left off in the previous iteration, `base = chunkSize * iteration`, and how
    we automatically schedule the next iterations until we determine that we’re done:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意的是，我们需要一点数学知识来跟踪我们在前一次迭代中留下的位置，`base = chunkSize * iteration`，以及我们如何自动安排下一次迭代，直到我们确定已经完成：
- en: '[PRE35]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: What’s impressive is just how little the code has to change in order to accommodate
    this new, asynchronous approach. We have to do a *little* more work to keep track
    of what’s going on, to ensure that the operation is correctly conducted, and to
    schedule the execution parts. But beyond that, the core of the code looks similar
    to what we started with.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 令人印象深刻的是，为了适应这种新的异步方法，代码需要做的改动非常小。我们必须做一点额外的工作来跟踪正在发生的事情，确保操作正确执行，并安排执行部分。但除此之外，代码的核心看起来与我们开始时相似。
- en: '|  |'
  id: totrans-523
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-524
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In this case, we’ve used `0` for our time-out delay. If you’ve paid close attention
    to how the event loop works, you know that this doesn’t mean that the callback
    will be executed in 0 ms. Instead, it’s a way of telling the browser, please execute
    this callback as soon as possible; but unlike with microtasks, you’re allowed
    to do page rendering in between. This allows the browser to update the UI and
    make our web applications more responsive.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们为超时延迟使用了`0`。如果你密切关注事件循环的工作方式，你就会知道这并不意味着回调将在0毫秒后执行。相反，这是一种告诉浏览器的方式，请尽快执行此回调；但与微任务不同，你可以在其中进行页面渲染。这允许浏览器更新UI，并使我们的Web应用更加响应。
- en: '|  |'
  id: totrans-526
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The most perceptible change resulting from this technique, from the user’s perspective,
    is that a long browser hang is replaced with four (or however many we choose)
    visual updates of the page. Although the browser will attempt to execute the code
    segments as quickly as possible, it will also render the DOM changes after each
    step of the timer. In the original version of the code, it needed to wait for
    one large bulk update.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户的角度来看，这种技术最明显的变化是，长时间的浏览器挂起被替换为四（或我们选择的任何数量）页面的视觉更新。尽管浏览器会尽可能快地执行代码段，但它也会在每个定时器步骤之后渲染
    DOM 更改。在代码的原始版本中，它需要等待一次大的批量更新。
- en: Much of the time, these types of updates are imperceptible to the user, but
    it’s important to remember that they do occur. We should strive to ensure that
    any code we introduce into the page doesn’t perceptibly interrupt the normal operation
    of the browser.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，这些类型的更新对用户来说是不可察觉的，但重要的是要记住它们确实发生了。我们应该努力确保我们引入页面的任何代码都不会明显中断浏览器的正常操作。
- en: It’s often surprising just how useful this technique can be. By understanding
    how the event loop works, we can work around the restrictions of the single-threaded
    browser environment, while still providing a pleasant experience to the user.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术有多么有用往往令人惊讶。通过理解事件循环的工作原理，我们可以绕过单线程浏览器环境的限制，同时仍然为用户提供愉悦的体验。
- en: Now that we understand the event loop and the roles timers can play in dealing
    with complex operations, let’s take a closer look at how the events themselves
    work.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了事件循环以及定时器在处理复杂操作中的作用，让我们更仔细地看看事件本身是如何工作的。
- en: 13.3\. Working with events
  id: totrans-531
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3\. 处理事件
- en: When a certain event occurs, we can handle it in our code. As you’ve seen many
    times throughout this book, one common way of registering event handlers is by
    using the built-in `addEventListener` method, as shown in the following listing.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 当某个事件发生时，我们可以在我们的代码中处理它。正如你在本书中多次看到的，注册事件处理器的一种常见方式是使用内置的 `addEventListener`
    方法，如下面的列表所示。
- en: Listing 13.6\. Registering event handlers
  id: totrans-533
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.6\. 注册事件处理器
- en: '![](353fig01_alt.jpg)'
  id: totrans-534
  prefs: []
  type: TYPE_IMG
  zh: '![图片](353fig01_alt.jpg)'
- en: In this snippet, we define a button named `myButton` and register a click event
    handler by using the built-in `addEventListener` method that’s accessible from
    all elements.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们定义了一个名为 `myButton` 的按钮，并通过从所有元素可访问的内置 `addEventListener` 方法注册了一个点击事件处理器。
- en: After a click event occurs, the browser calls the associated handler, in this
    case the `myHandler` function. To this handler, the browser passes in an event
    object that contains properties that we can use to find out more information about
    the event, such as the position of the mouse or the mouse button that was clicked,
    in case we’re dealing with a mouse-click event, or the pressed key if we’re dealing
    with a keyboard event.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 在点击事件发生后，浏览器会调用相关处理器，在本例中是 `myHandler` 函数。浏览器会将一个包含我们可用于获取更多事件信息的属性的事件对象传递给此处理器，例如鼠标的位置或被点击的鼠标按钮，如果我们处理的是鼠标点击事件，或者按下的键，如果我们处理的是键盘事件。
- en: One of the properties of the passed-in event object is the `target` property,
    which references the element on which the event has occurred.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 传入事件对象的属性之一是 `target` 属性，它引用了事件发生的元素。
- en: '|  |'
  id: totrans-538
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-539
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: As within most other functions, within the event handler, we can use the `this`
    keyword. People often colloquially say that within an event handler, the `this`
    keyword refers to the object on which the event has occurred, but as we’ll soon
    find out, this isn’t exactly true. Instead, the `this` keyword refers to the element
    on which the event handler has been *registered*. To be honest, in most cases
    the element on which the event handler has been registered *is* the element on
    which the event has occurred, but there are exceptions. We’ll explore these situations
    shortly.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在大多数其他函数中一样，在事件处理器中，我们可以使用 `this` 关键字。人们常常口语化地说，在事件处理器中，`this` 关键字指的是事件发生的对象，但正如我们很快就会发现的，这并不完全正确。相反，`this`
    关键字指的是事件处理器已被注册的元素。坦白说，在大多数情况下，事件处理器已被注册的元素确实是事件发生的元素，但也有一些例外。我们很快就会探讨这些情况。
- en: '|  |'
  id: totrans-541
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Before exploring this concept further, let’s set the stage so you can see how
    events can be propagated through the DOM.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步探索这个概念之前，让我们设定场景，以便你可以看到事件是如何通过 DOM 传播的。
- en: 13.3.1\. Propagating events through the DOM
  id: totrans-543
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.3.1\. 通过 DOM 传播事件
- en: As we already know from [chapter 2](kindle_split_012.html#ch02), in HTML documents,
    elements are organized in a tree. An element can have zero or more children, and
    every element (except the root `html` element) has exactly one parent. Now, suppose
    that we’re working with a page that has an element inside another element, and
    both elements have a click handler, as in the following listing.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们已在[第2章](kindle_split_012.html#ch02)中了解到的，在HTML文档中，元素以树状结构组织。一个元素可以有零个或多个子元素，每个元素（除了根`html`元素）恰好有一个父元素。现在，假设我们正在处理一个页面，其中包含另一个元素内的元素，并且这两个元素都有点击处理器，如下所示。
- en: Listing 13.7\. Nested elements and click handlers
  id: totrans-545
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.7\. 嵌套元素和点击处理器
- en: '![](ch13ex07-0.jpg)'
  id: totrans-546
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch13ex07-0.jpg)'
- en: '![](ch13ex07-1.jpg)'
  id: totrans-547
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch13ex07-1.jpg)'
- en: Here we have two HTML elements, `outerContainer` and `innerContainer`, that
    are, like all the other HTML elements, contained within our global `document`.
    And on all three objects, we register a click handler.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有两个HTML元素，`outerContainer`和`innerContainer`，它们，就像所有其他HTML元素一样，包含在我们的全局`document`中。并且在这三个对象上，我们注册了一个点击处理器。
- en: Now let’s suppose that a user clicks the `innerContainer` element. Because `innerContainer`
    is contained within the `outerContainer` element, and both of these elements are
    contained within the `document`, it’s obvious that this should trigger the execution
    of all three event handlers, outputting three messages. What’s not apparent is
    the order in which the event handlers should be executed.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设用户点击了`innerContainer`元素。因为`innerContainer`包含在`outerContainer`元素中，而这两个元素都包含在`document`中，所以很明显，这将触发所有三个事件处理器的执行，输出三条消息。不明显的是事件处理器的执行顺序。
- en: Should we follow the order in which the events were registered? Should we start
    with the element on which the event occurs and move upward? Or should we start
    from the top and move downward toward the targeted element? Back in the day, when
    browsers were first making these decisions, the two primary competitors, Netscape
    and Microsoft, made opposing choices.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该遵循事件注册的顺序吗？应该从事件发生元素开始向上移动？还是应该从顶部开始向下移动到目标元素？在浏览器最初做出这些决定的时候，两大主要竞争对手，网景和微软，做出了相反的选择。
- en: 'In Netscape’s event model, the event handling starts with the top element and
    trickles down to the event target element. In our case, the event handlers would
    be executed in the following order: `document` click handler, `outerContainer`
    click handler, and finally `innerContainer` click handler. This is called *event
    capturing.*'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 在网景的事件模型中，事件处理从顶层元素开始，逐级向下传递到事件目标元素。在我们的例子中，事件处理器的执行顺序如下：`document`点击处理器，`outerContainer`点击处理器，最后是`innerContainer`点击处理器。这被称为*事件捕获*。
- en: 'Microsoft chose to go the other way around: start from the targeted element
    and bubble up the DOM tree. In our case, the events would be executed in the following
    order: `innerContainer` click handler, `outerContainer` click handler, and `document`
    click handler. This is called *event bubbling.*'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 微软选择了另一种方式：从目标元素开始，向上冒泡到DOM树。在我们的例子中，事件的执行顺序如下：`innerContainer`点击处理器，`outerContainer`点击处理器，以及`document`点击处理器。这被称为*事件冒泡*。
- en: 'The standard set by the W3 Consortium ([www.w3.org/TR/DOM-Level-3-Events/](http://www.w3.org/TR/DOM-Level-3-Events/)),
    which is implemented by all modern browsers, embraces both approaches. An event
    is handled in two phases:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 由万维网联盟（[www.w3.org/TR/DOM-Level-3-Events/](http://www.w3.org/TR/DOM-Level-3-Events/））制定的标准，被所有现代浏览器实现，它包含了两种方法。事件处理分为两个阶段：
- en: '***Capturing phase—*** An event is first captured at the top element and trickled
    down to the target element.'
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***捕获阶段—*** 事件首先在顶层元素被捕获，然后逐级向下传递到目标元素。'
- en: '***Bubbling phase—*** After the target element has been reached in the capturing
    phase, the event handling switches to bubbling, and the event bubbles up again
    from the target element to the top element.'
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***冒泡阶段—*** 在捕获阶段到达目标元素后，事件处理切换到冒泡，事件再次从目标元素向上冒泡到顶层元素。'
- en: These two phases are shown in [figure 13.15](#ch13fig15).
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个阶段在[图13.15](#ch13fig15)中展示。
- en: Figure 13.15\. With capturing, the event trickles down to the target element.
    With bubbling, the event bubbles up from the target element.
  id: totrans-557
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.15\. 在捕获中，事件逐级向下传递到目标元素。在冒泡中，事件从目标元素向上冒泡。
- en: '![](13fig15.jpg)'
  id: totrans-558
  prefs: []
  type: TYPE_IMG
  zh: '![图片](13fig15.jpg)'
- en: We can easily decide which event-handling order we want to use, by adding another
    Boolean argument to the `addEventListener` method. If we use `true` as the third
    argument, the event will be captured, whereas if we use `false` (or leave out
    the value), the event will bubble. So in a sense, the W3C standard prefers event
    bubbling slightly more to event capturing, because bubbling has been made the
    default option.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过向 `addEventListener` 方法添加另一个布尔参数轻松地决定我们想要使用的事件处理顺序。如果我们使用 `true` 作为第三个参数，事件将被捕获，而如果我们使用
    `false`（或省略该值），事件将冒泡。因此，从某种意义上说，W3C 标准略微更倾向于事件冒泡而不是事件捕获，因为冒泡已经成为默认选项。
- en: 'Now let’s go back to [listing 13.7](#ch13ex07) and look closely at the way
    we’ve registered events:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到 [代码列表 13.7](#ch13ex07) 并仔细看看我们注册事件的方式：
- en: '[PRE36]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As you can see, in all three cases, we’ve called the `addEventListener` method
    with only two arguments, which means that the default method, *bubbling*, is chosen.
    So in this case, if we click the `innerContainer` element, the event handlers
    would be executed in this order: `innerContainer` click handler, `outerContainer`
    click handler, `document` click handler.'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在这三种情况下，我们只使用两个参数调用了 `addEventListener` 方法，这意味着选择了默认方法，即 *冒泡*。因此，在这种情况下，如果我们点击
    `innerContainer` 元素，事件处理程序将按以下顺序执行：`innerContainer` 点击处理程序，`outerContainer` 点击处理程序，`document`
    点击处理程序。
- en: Let’s modify the code in [listing 13.7](#ch13ex07) in the following way.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式修改 [代码列表 13.7](#ch13ex07) 中的代码。
- en: Listing 13.8\. Capturing versus bubbling
  id: totrans-564
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.8\. 捕获与冒泡
- en: '![](357fig01_alt.jpg)'
  id: totrans-565
  prefs: []
  type: TYPE_IMG
  zh: '![](357fig01_alt.jpg)'
- en: This time, we set the event handler of the `outerContainer` to capturing mode
    (by passing in `true` as the third argument), and the event handlers of `innerContainer`
    (by passing in `false` as the third argument) and `document` to bubbling mode
    (leaving out the third argument chooses the default, bubbling mode).
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将 `outerContainer` 的事件处理程序设置为捕获模式（通过传递 `true` 作为第三个参数），而将 `innerContainer`（通过传递
    `false` 作为第三个参数）和 `document` 的事件处理程序设置为冒泡模式（省略第三个参数选择默认的冒泡模式）。
- en: As you know, a single event can trigger the execution of multiple event handlers,
    where each handler can be in either capturing or bubbling mode. For this reason,
    the event first goes through capturing, starting from the top element and trickling
    down to the event target element. When the target element is reached, bubbling
    mode is activated, and the event bubbles from the target element all the way back
    to the top.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，单个事件可以触发多个事件处理程序的执行，其中每个处理程序可以是捕获模式或冒泡模式。因此，事件首先从顶层元素开始，逐级向下到事件目标元素。当达到目标元素时，冒泡模式被激活，事件从目标元素冒泡回顶部。
- en: In our case, capturing starts from the top, `window` object and trickles down
    to the `innerContainer` element, with the goal of finding all elements that have
    an event handler for this click event in capturing mode. Only one element, `outerContainer`,
    is found, and its matching click handler is executed as the first event handler.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这个例子中，捕获从顶部开始，从 `window` 对象开始，逐级向下到 `innerContainer` 元素，目的是找到所有在捕获模式下具有此点击事件事件处理程序的所有元素。只找到一个元素，即
    `outerContainer`，其匹配的点击事件处理程序作为第一个事件处理程序执行。
- en: The event continues traveling down the capturing path, but no more event handlers
    with capturing are found. After the event reaches the event target element, the
    `innerContainer` element, the event moves on to the bubbling phase, where it goes
    from the target element all the way back to the top, executing all bubbling event
    handlers on that path.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 事件继续沿着捕获路径向下移动，但没有找到更多具有捕获的事件处理程序。当事件达到事件目标元素，即 `innerContainer` 元素时，事件进入冒泡阶段，从目标元素一路冒泡回顶部，执行该路径上所有冒泡事件处理程序。
- en: In our case, the `innerContainer` click handler will be executed as the second
    event handler, and the `document` click handler as the third. The output generated
    by clicking the `innerContainer` element, as well as the taken path, is shown
    in [figure 13.16](#ch13fig16).
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这个例子中，`innerContainer` 的点击事件处理程序将作为第二个事件处理程序执行，而 `document` 的点击事件处理程序将作为第三个。点击
    `innerContainer` 元素生成的输出以及所采取的路径显示在 [图 13.16](#ch13fig16) 中。
- en: Figure 13.16\. First the event trickles down from the top, executing all event
    handlers in capturing mode. When the target element is reached, the event bubbles
    up to the top, executing all event handlers in bubbling mode.
  id: totrans-571
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.16\. 首先，事件从顶部逐级向下，执行所有捕获模式的事件处理程序。当达到目标元素时，事件向上冒泡到顶部，执行所有冒泡模式的事件处理程序。
- en: '![](13fig16_alt.jpg)'
  id: totrans-572
  prefs: []
  type: TYPE_IMG
  zh: '![](13fig16_alt.jpg)'
- en: One of the things this example shows is that the element on which the event
    is handled doesn’t have to be the element on which the event occurs. For example,
    in our case, the event occurs on the `innerContainer` element, but we can handle
    it on elements higher up in the DOM hierarchy, such as on the `outerContainer`
    or the `document` element.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示的一个事情是，处理事件的元素不必是事件发生的元素。例如，在我们的情况下，事件发生在`innerContainer`元素上，但我们可以处理它在上层DOM层次结构中的元素，比如`outerContainer`或`document`元素。
- en: This takes us back to the `this` keyword in event handlers, and why we explicitly
    stated that the `this` keyword refers to the element on which the event handler
    is registered, and not necessarily to the element on which the event occurs.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 这带我们回到了事件处理程序中的`this`关键字，以及为什么我们明确指出`this`关键字指的是事件处理程序注册的元素，而不一定是事件发生的元素。
- en: Again, let’s modify our running example, as shown in the following listing.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们修改我们的运行示例，如下所示。
- en: Listing 13.9\. The difference between this and event.target in event handlers
  id: totrans-576
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.9\. 事件处理程序中`this`和`event.target`之间的区别
- en: '![](358fig01_alt.jpg)'
  id: totrans-577
  prefs: []
  type: TYPE_IMG
  zh: '![](358fig01_alt.jpg)'
- en: 'Again, let’s look at the application execution when a click occurs on `innerContainer`.
    Because both event handlers use event bubbling (there’s no third argument set
    to `true` in the `addEventListener` methods), first the `innerContainer` click
    handler is invoked. Within the body of the handler, we check that both the `this`
    keyword and the `event.target` property refer to the `innerContainer` element:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们看看当点击`innerContainer`时应用程序的执行情况。因为两个事件处理程序都使用事件冒泡（在`addEventListener`方法中没有设置第三个参数为`true`），首先调用`innerContainer`点击处理程序。在处理程序的主体中，我们检查`this`关键字和`event.target`属性是否都指向`innerContainer`元素：
- en: '[PRE37]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `this` keyword points to the `innerContainer` element because that’s the
    element on which the current handler has been *registered*, whereas the `event.target`
    property points to the `innerContainer` element because that’s the element on
    which the event has *occurred*.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`关键字指向`innerContainer`元素，因为这是当前处理程序已注册的元素，而`event.target`属性指向`innerContainer`元素，因为这是事件发生的元素。'
- en: 'Next, the event bubbles up to the `outerContainer` handler. This time, the
    `this` keyword and the `event.target` point to different elements:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，事件冒泡到`outerContainer`处理程序。这次，`this`关键字和`event.target`指向不同的元素：
- en: '[PRE38]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As expected, the `this` keyword refers to the `outerContainer` element, because
    this is the element on which the current handler has been registered. On the other
    hand, the `event.target` property points to the `innerContainer` element, because
    this is the element on which the event has occurred.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，`this`关键字指向`outerContainer`元素，因为这是当前处理程序已注册的元素。另一方面，`event.target`属性指向`innerContainer`元素，因为这是事件发生的元素。
- en: Now that we understand how an event is propagated through the DOM tree and how
    to access the element on which the event has originally occurred, let’s see how
    to apply this knowledge to write less memory-intensive code.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了事件是如何通过DOM树传播的，以及如何访问事件最初发生的元素，让我们看看如何应用这些知识来编写更节省内存的代码。
- en: Delegating events to an ancestor
  id: totrans-585
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将事件委托给祖先
- en: 'Let’s say that we want to visually indicate whether a cell within a table has
    been clicked by the user, by initially displaying a white background for each
    cell and then changing the background color to yellow after the cell is clicked.
    Sounds easy enough. We can iterate through all the cells and establish a handler
    on each one that changes the background color property:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要通过最初为每个单元格显示白色背景，然后在单元格被点击后改变背景颜色为黄色，来视觉上指示用户是否点击了表格内的单元格。听起来足够简单。我们可以遍历所有单元格，并在每个单元格上建立处理程序来改变背景颜色属性：
- en: '[PRE39]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Sure this works, but is it elegant? No. We’re establishing the exact same event
    handler on potentially hundreds of elements, and they all do *the exact same thing*.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可行，但这是否优雅？不。我们在可能成百上千个元素上建立了完全相同的事件处理程序，它们都做**完全相同的事情**。
- en: A much more elegant approach is to establish a single handler at a level higher
    than the cells that can handle all the events using event bubbling.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更加优雅的方法是在比单元格更高的级别上建立一个单一的处理程序，使用事件冒泡来处理所有事件。
- en: 'We know that all the cells will be descendants of their enclosing table, and
    we know that we can get a reference to the element that was clicked via `event.target`.
    It’s much more suave to *delegate* the event handling to the table, as follows:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道所有单元格都将是其包含表格的后代，我们也知道我们可以通过 `event.target` 获取被点击元素的引用。将事件处理委托给表格要优雅得多，如下所示：
- en: '![](360fig01_alt.jpg)'
  id: totrans-591
  prefs: []
  type: TYPE_IMG
  zh: '![](360fig01_alt.jpg)'
- en: Here, we establish one handler that easily handles the work of changing the
    background color for all cells in the table that were clicked. This is much more
    efficient and elegant.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个处理程序，它可以轻松地处理更改表格中被点击的所有单元格的背景颜色的任务。这要高效得多，也更优雅。
- en: With event delegation, we have to make sure that it’s only applied to elements
    that are ancestors of the elements that are the event targets. That way, we’re
    sure that the events will eventually bubble up to the element to which the handler
    has been delegated.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 使用事件委托，我们必须确保它只应用于事件目标元素的祖先元素。这样，我们才能确保事件最终会冒泡到已委托处理器的元素。
- en: So far, we’ve been dealing with events that are provided by the browser, but
    haven’t you ever fervently desired the ability to trigger your own *custom* events?
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在处理浏览器提供的事件，但你有没有热烈地渴望过能够触发你自己的 *自定义* 事件？
- en: 13.3.2\. Custom events
  id: totrans-595
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.3.2\. 自定义事件
- en: Imagine a scenario in which you want to perform an action, but you want to trigger
    it under a variety of conditions from different pieces of code, perhaps even from
    code that’s in shared script files. A novice would repeat the code everywhere
    it’s needed. A journeyman would create a global function and call it from everywhere
    it’s needed. A ninja would use custom events. But why?
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个场景，你想要执行一个操作，但你希望在不同的代码片段中，在多种条件下触发它，也许甚至是从共享脚本文件中的代码触发。新手会在需要的地方重复代码。熟练工会创建一个全局函数并在需要的地方调用它。忍者会使用自定义事件。但为什么？
- en: Loose coupling
  id: totrans-597
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 松耦合
- en: Say we’re doing operations from shared code, and we want to let page code know
    when it’s time to react to a particular condition. If we use the journeyman’s
    global function approach, we introduce the disadvantage that our shared code needs
    to define a fixed name for the function, and all pages that use the shared code
    need to use such a function.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在共享代码中执行操作，并且我们想在特定条件需要响应时让页面代码知道。如果我们使用熟练工的全局函数方法，我们会引入一个缺点，即我们的共享代码需要为函数定义一个固定的名称，并且所有使用共享代码的页面都需要使用这样的函数。
- en: Moreover, what if there are multiple things to do when the triggering condition
    occurs? Making allowances for multiple notifications would be arduous and necessarily
    messy. These disadvantages are a result of *close coupling*, in which the code
    that detects the conditions has to know the details of the code that will react
    to that condition.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果在触发条件发生时需要执行多项操作呢？为多个通知留出空间将会是艰巨且必然混乱的。这些缺点是 *紧密耦合* 的结果，在这种耦合中，检测条件的代码必须知道将对此条件做出反应的代码的详细信息。
- en: '*Loose coupling*, on the other hand, occurs when the code that triggers the
    condition doesn’t know anything about the code that will react to the condition,
    or even if there’s anything that will react to it at all. One of the advantages
    of event handlers is that we can establish as many as we want, and these handlers
    are completely independent of each other. So event handling is a good example
    of loose coupling. When a button-click event is triggered, the code triggering
    the event has no knowledge of what handlers we’ve established on the page, or
    even if there are any. Rather, the click event is pushed onto the task queue by
    the browser, and whatever caused the event to trigger could care less what happens
    after that. If handlers have been established for the click event, they’ll eventually
    be individually invoked in a completely independent fashion.'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，*松耦合* 发生在触发条件的代码对将对此条件做出反应的代码一无所知的情况下，甚至不知道是否有什么东西会做出反应。事件处理程序的一个优点是我们可以建立尽可能多的处理程序，并且这些处理程序之间完全独立。因此，事件处理是松耦合的一个很好的例子。当按钮点击事件被触发时，触发事件的代码对我们已经在页面上建立的处理器一无所知，甚至不知道是否存在任何处理器。相反，点击事件由浏览器推送到任务队列，而触发事件的任何东西都不会关心之后会发生什么。如果已经为点击事件建立了处理器，它们最终将以完全独立的方式逐个调用。
- en: There’s much to be said for loose coupling. In our scenario, the shared code,
    when it detects an interesting condition, triggers a signal of some sort that
    says, “This interesting thing has happened; anyone interested can deal with it,”
    and it couldn’t give a darn whether anyone’s interested. Let’s examine a concrete
    example.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 紧耦合有很多优点。在我们的场景中，当共享代码检测到有趣的条件时，它会触发某种类型的信号，表示“发生了这个有趣的事情；任何感兴趣的人都可以处理它”，而且它根本不在乎是否有人感兴趣。让我们考察一个具体的例子。
- en: An Ajax-y example
  id: totrans-602
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 一个Ajax示例
- en: Let’s pretend that we’ve written some shared code that will be performing an
    Ajax request. The pages that this code will be used on want to be notified when
    an Ajax request begins and when it ends; each page has its own things that it
    needs to do when these “events” occur.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们已经编写了一些共享代码，这些代码将执行Ajax请求。使用这些代码的页面希望在Ajax请求开始和结束时得到通知；每个页面在发生这些“事件”时都有它需要做的事情。
- en: For example, on one page using this package, we want to display a spinning pinwheel
    when an Ajax request starts, and we want to hide it when the request completes,
    in order to give the user some visual feedback that a request is being processed.
    If we imagine the start condition as an event named `ajax-start`, and the stop
    condition as `ajax-complete`, wouldn’t it be grand if we could establish event
    handlers on the page for these events that show and hide the image as appropriate?
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个使用此包的页面上，我们希望在Ajax请求开始时显示一个旋转的风扇，当请求完成时隐藏它，以便给用户提供一些视觉反馈，表明请求正在处理。如果我们把开始条件想象成一个名为
    `ajax-start` 的事件，把停止条件想象成 `ajax-complete`，如果我们能在页面上为这些事件建立显示和隐藏图像的处理程序，那岂不是很好？
- en: 'Consider this:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下内容：
- en: '[PRE40]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Sadly, these events don’t exist, but there’s nothing stopping us from bringing
    them into existence.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，这些事件并不存在，但没有任何阻止我们使它们成为现实。
- en: Creating custom events
  id: totrans-608
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建自定义事件
- en: Custom events are a way of simulating (for the user of our shared code) the
    experience of a real event, but an event that has business sense within the context
    of our application. The following listing shows an example of triggering a custom
    event.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义事件是模拟（对于我们的共享代码的用户）真实事件体验的一种方式，但这个事件在我们应用程序的上下文中具有业务意义。下面的列表显示了一个触发自定义事件的示例。
- en: Listing 13.10\. Using custom events
  id: totrans-610
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.10\. 使用自定义事件
- en: '![](ch13ex10-0.jpg)'
  id: totrans-611
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch13ex10-0.jpg)'
- en: '![](ch13ex10-1.jpg)'
  id: totrans-612
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch13ex10-1.jpg)'
- en: 'In this example, we explore custom events by establishing the scenario described
    in the previous section: An animated pinwheel image is displayed while an Ajax
    operation is underway. The operation is triggered by the click of a button.'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过建立前一个章节中描述的场景来探索自定义事件：在Ajax操作进行时显示一个动画风扇图像。操作是由按钮的点击触发的。
- en: 'In a completely decoupled fashion, a handler for a custom event named `ajax-start`
    is established, as is the one for the `ajax-complete` custom event. The handlers
    for these events show and hide the pinwheel image, respectively:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 以完全解耦的方式，为名为 `ajax-start` 的自定义事件创建了一个处理程序，同样为 `ajax-complete` 自定义事件也创建了一个处理程序。这些事件的处理程序分别显示和隐藏风扇图像：
- en: '[PRE41]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note that the three handlers know nothing of each other’s existence. In particular,
    the button click handler has no responsibilities with respect to showing and hiding
    the image.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这三个处理程序彼此之间一无所知。特别是，按钮点击处理程序在显示和隐藏图像方面没有责任。
- en: 'The Ajax operation itself is simulated with the following code:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: Ajax操作本身是通过以下代码模拟的：
- en: '[PRE42]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The function triggers the `ajax-start` event and sends data about the event
    (the `url` property), pretending that an Ajax request is about to be made. The
    function then issues a 5-second time-out, simulating an Ajax request that spans
    5 seconds. When the timer expires, we pretend that the response has been returned
    and trigger an `ajax-complete` event to signify that the Ajax operation has completed.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数触发 `ajax-start` 事件并发送关于事件的数据（`url` 属性），假装即将发起一个Ajax请求。然后该函数发出一个5秒的超时，模拟一个跨越5秒的Ajax请求。当计时器到期时，我们假装响应已经返回，并触发一个
    `ajax-complete` 事件，表示Ajax操作已完成。
- en: Notice the high degree of decoupling throughout this example. The shared Ajax
    operation code has no knowledge of what the page code is going to do when the
    events are triggered, or even if there’s page code to trigger at all. The page
    code is modularized into small handlers that don’t know about each other. Furthermore,
    the page code has no idea how the shared code is doing its thing; it just reacts
    to events that may or may not be triggered.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个例子中高度的解耦。共享的Ajax操作代码不知道当事件被触发时页面代码会做什么，甚至不知道是否真的有页面代码来触发。页面代码被模块化成小的处理程序，它们之间互不了解。此外，页面代码对共享代码如何执行一无所知；它只是对可能或可能不被触发的事件做出反应。
- en: This level of decoupling helps to keep code modular, easier to write, and a
    lot easier to debug when something goes wrong. It also makes it easy to share
    portions of code and to move them around without fear of violating a coupled dependency
    between the code fragments. Decoupling is a fundamental advantage when using custom
    events in code, and it allows us to develop applications in a much more expressive
    and flexible manner.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 这种程度的解耦有助于保持代码模块化，更容易编写，当出现问题时也更容易调试。它还使得共享代码片段变得容易，并且可以在不违反代码片段之间耦合依赖的情况下移动它们。解耦是使用自定义事件时的基本优势，它允许我们以更表达性和灵活的方式开发应用程序。
- en: 13.4\. Summary
  id: totrans-622
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4\. 摘要
- en: 'An event-loop task represents an action performed by the browser. Tasks are
    grouped into two categories:'
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件循环任务代表浏览器执行的动作。任务分为两类：
- en: Macrotasks are discrete, self-contained browser actions such as creating the
    main document object, handling various events, and making URL changes.
  id: totrans-624
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏任务是一些离散的、自包含的浏览器操作，例如创建主文档对象、处理各种事件以及进行URL更改。
- en: Microtasks are smaller tasks that should be executed as soon as possible. Examples
    include promise callbacks and DOM mutation changes.
  id: totrans-625
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微任务是一些应该尽快执行的小任务。例如，包括承诺回调和DOM变更。
- en: 'Because of the single-threaded execution model, tasks are processed one at
    a time, and after a task starts executing, it can’t be interrupted by another
    task. The event loop usually has at least two event queues: a macrotask queue
    and a microtask queue.'
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于单线程执行模型，任务一次处理一个，一旦任务开始执行，就不能被另一个任务中断。事件循环通常至少有两个事件队列：宏任务队列和微任务队列。
- en: Timers provide the ability to asynchronously delay the execution of a piece
    of code by *at least* some number of milliseconds.
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时器提供了一种异步延迟代码执行至少一些毫秒数的能力。
- en: Use the `setTimeout` function to execute a callback once after the specified
    delay has elapsed.
  id: totrans-628
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `setTimeout` 函数在指定的延迟时间过后执行回调。
- en: Use the `setInterval` function to initiate a timer that will try to execute
    the callback at the specified delay interval, until canceled.
  id: totrans-629
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `setInterval` 函数启动一个定时器，该定时器将在指定的延迟间隔内尝试执行回调，直到被取消。
- en: Both functions return an ID of the timer that we can use to cancel a timer through
    the `clearTimeout` and `clearInterval` functions.
  id: totrans-630
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个函数都返回一个定时器的ID，我们可以通过 `clearTimeout` 和 `clearInterval` 函数来取消定时器。
- en: Use timers to break up computationally expensive code into manageable chunks
    that won’t clog the browser.
  id: totrans-631
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用定时器将计算密集型代码分解成可管理的块，这样就不会阻塞浏览器。
- en: 'The DOM is a hierarchical tree of elements, and an event that occurs on an
    element (the target) is usually propagated through the DOM. There are two propagation
    mechanisms:'
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DOM 是一个元素分层树，一个元素（目标）上发生的事件通常通过 DOM 传播。有两种传播机制：
- en: In event capturing, the event trickles down from the top element all the way
    to the target element.
  id: totrans-633
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在事件捕获中，事件从顶层元素逐级向下传递到目标元素。
- en: In event bubbling, the event bubbles up from the target element all the way
    to the top element.
  id: totrans-634
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在事件冒泡中，事件从目标元素逐级向上冒泡到顶层元素。
- en: When calling event handlers, the browser also passes in an event object. Access
    the element on which the event has occurred through the event’s `target` property.
    Within the handler, use the `this` keyword to refer to the element on which the
    handler has been registered.
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用事件处理器时，浏览器也会传递一个事件对象。通过事件对象的 `target` 属性访问事件发生的元素。在处理器内部，使用 `this` 关键字来引用已注册处理器的元素。
- en: Use custom events, created through the built-in `CustomEvent` constructor, and
    dispatched with the `dispatchEvent` method, to reduce coupling between different
    parts of your application.
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用通过内置的 `CustomEvent` 构造函数创建的自定义事件，并通过 `dispatchEvent` 方法分发，以减少应用程序不同部分之间的耦合。
- en: 13.5\. Exercises
  id: totrans-637
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.5\. 练习
- en: '**1**'
  id: totrans-638
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**'
- en: ''
  id: totrans-639
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why is it important that adding tasks into the task queue happens outside the
    event loop?
  id: totrans-640
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么将任务添加到任务队列中发生在事件循环之外很重要？
- en: '**2**'
  id: totrans-641
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**'
- en: ''
  id: totrans-642
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why is it important that each iteration of the event loop doesn’t take much
    more than about 16 ms?
  id: totrans-643
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么事件循环的每一迭代不需要超过大约16毫秒很重要？
- en: '**3**'
  id: totrans-644
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**'
- en: ''
  id: totrans-645
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What’s the output from running the following code for 2 seconds?
  id: totrans-646
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 运行以下代码2秒后，输出结果是什么？
- en: ''
  id: totrans-647
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-648
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ''
  id: totrans-649
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Timeout Interval Interval Interval Interval`'
  id: totrans-650
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Timeout Interval Interval Interval Interval`'
- en: '`Interval Timeout Interval Interval Interval`'
  id: totrans-651
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Interval Timeout Interval Interval Interval`'
- en: '`Interval Timeout Timeout`'
  id: totrans-652
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Interval Timeout Timeout`'
- en: '**4**'
  id: totrans-653
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**'
- en: ''
  id: totrans-654
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What’s the output from running the following code for 2 seconds?
  id: totrans-655
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 运行以下代码2秒后的输出结果是什么？
- en: ''
  id: totrans-656
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-657
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ''
  id: totrans-658
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Interval Timeout Interval Interval Interval`'
  id: totrans-659
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Interval Timeout Interval Interval Interval`'
- en: '`Interval`'
  id: totrans-660
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Interval`'
- en: '`Interval Interval Interval Interval`'
  id: totrans-661
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Interval Interval Interval Interval`'
- en: '**5**'
  id: totrans-662
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**'
- en: ''
  id: totrans-663
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What’s the output from running the following code and clicking the element with
    the ID `inner`?
  id: totrans-664
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 运行以下代码并点击ID为`inner`的元素后，输出结果是什么？
- en: ''
  id: totrans-665
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-666
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ''
  id: totrans-667
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Inner Outer Body`'
  id: totrans-668
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Inner Outer Body`'
- en: '`Body Outer Inner`'
  id: totrans-669
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Body Outer Inner`'
- en: '`Outer Inner Body`'
  id: totrans-670
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Outer Inner Body`'
- en: Chapter 14\. Developing cross-browser strategies
  id: totrans-671
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第14章\. 开发跨浏览器策略
- en: '*This chapter covers*'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Developing reusable, cross-browser JavaScript code
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发可重用的跨浏览器JavaScript代码
- en: Analyzing cross-browser issues needing to be tackled
  id: totrans-674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析需要解决的跨浏览器问题
- en: Tackling those issues in a smart way
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以智能方式解决这些问题
- en: Anyone who’s spent time developing on-page JavaScript code knows that a wide
    range of pain points exist when it comes to ensuring that the code works flawlessly
    across a set of supported browsers. These considerations span from providing basic
    development for immediate needs, to planning for future browser releases, all
    the way to reusing code on web pages that have yet to be created.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 任何在页面上开发JavaScript代码的人都知道，在确保代码在一系列支持的浏览器中完美运行时，存在广泛的痛点。这些考虑因素从满足基本开发需求，到为未来的浏览器发布做准备，再到在尚未创建的网页上重用代码，涵盖了所有这些。
- en: Coding for multiple browsers is a nontrivial task that must be balanced according
    to the development methodologies that you have in place, as well as the resources
    available to your project. As much as we’d love for our pages to work perfectly
    in every browser that ever existed or will ever exist, reality will rear its ugly
    head and we must realize that we have finite development resources. We must plan
    to apply those resources appropriately and carefully, getting the biggest bang
    for our buck.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 为多个浏览器编写代码是一个非平凡的任务，必须根据你现有的开发方法和项目可用的资源进行平衡。尽管我们希望我们的页面能够在所有曾经存在或将来存在的浏览器中完美运行，但现实总会露出其丑陋的一面，我们必须认识到我们的开发资源是有限的。我们必须计划适当地、谨慎地应用这些资源，以获得最大的效益。
- en: Because of this, we start this chapter with advice on choosing which browsers
    to support. This is followed with a discussion of the major concerns regarding
    cross-browser development, as well as effective strategies for dealing with such
    problems. Let’s jump right into ways to carefully choose supported browsers.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们从这个章节开始，提供关于选择支持哪些浏览器的建议。接下来是关于跨浏览器开发的主要问题的讨论，以及处理这些问题的有效策略。让我们直接进入如何谨慎选择支持浏览器的途径。
- en: Do you know?
  id: totrans-679
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你知道吗？
- en: '**Q1:**'
  id: totrans-680
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q1:**'
- en: ''
  id: totrans-681
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are some common ways of dealing with inconsistencies in behavior with different
    browsers?
  id: totrans-682
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 处理不同浏览器之间行为不一致的常见方法有哪些？
- en: '**Q2:**'
  id: totrans-683
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q2:**'
- en: ''
  id: totrans-684
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the best way to make your code usable on other people’s pages?
  id: totrans-685
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最好的方法是什么，可以使你的代码在别人的页面上可用？
- en: '**Q3:**'
  id: totrans-686
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q3:**'
- en: ''
  id: totrans-687
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why are polyfills useful in cross-browser scripting?
  id: totrans-688
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么polyfills在跨浏览器脚本中很有用？
- en: 14.1\. Cross-browser considerations
  id: totrans-689
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1\. 跨浏览器考虑因素
- en: Perfecting our JavaScript programming skills will take us far, especially now
    that JavaScript has escaped the confines of the browser and is being used on the
    server with Node.js. But when developing browser-based JavaScript applications
    (which is the focus of this book), sooner rather than later, we’re going to run
    face first into *The Browsers* and their various issues and inconsistencies.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 完善我们的JavaScript编程技能将使我们受益匪浅，尤其是现在JavaScript已经摆脱了浏览器的限制，并在Node.js服务器上使用。但当我们开发基于浏览器的JavaScript应用程序（本书的重点）时，迟早会直面*浏览器*及其各种问题和不一致性。
- en: In a perfect world, all browsers would be bug-free and would support web standards
    consistently, but as we all know, we don’t live in that world. Although the quality
    of browsers has improved greatly as of late, all still have some bugs, missing
    APIs, and browser-specific quirks that we’ll need to deal with. Developing a comprehensive
    strategy for tackling these browser issues, and becoming intimately familiar with
    their differences and quirks, isn’t less important than proficiency in JavaScript
    itself.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个完美的世界里，所有浏览器都不会有错误，并且会一致地支持网络标准，但正如我们所知，我们并不生活在这个世界里。尽管近年来浏览器的质量有了很大提高，但所有浏览器仍然存在一些错误、缺失的API和浏览器特有的怪癖，我们需要处理这些问题。制定一个全面策略来应对这些浏览器问题，并深入了解它们之间的差异和怪癖，并不亚于掌握JavaScript本身的重要性。
- en: When writing browser applications, choosing which browsers to support is important.
    We’d probably like to support them all, but limitations on development and testing
    resources dictate otherwise. So how do we decide which to support, and to what
    level?
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写浏览器应用程序时，选择支持哪些浏览器很重要。我们可能希望支持所有浏览器，但开发和测试资源的限制决定了否则。那么我们如何决定支持哪些，以及支持到什么程度？
- en: One approach that we can employ is loosely borrowed from an older Yahoo! approach,
    *graded browser support*. In this technique, we create a browser-support matrix
    that serves as a snapshot of how important a browser and its platform are to our
    needs. In this table, we list the target platforms on one axis, and the browsers
    on the other. Then, in the table cells, we give a “grade” (A through F, or any
    other grading system that meets our needs) to each browser/platform combination.
    [Table 14.1](#ch14table01) shows a hypothetical example.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采用的一种方法是借鉴了较老的Yahoo!方法，即*分级浏览器支持*。在这种技术中，我们创建一个浏览器支持矩阵，作为浏览器及其平台对我们需求重要性的快照。在这个表格中，我们列出目标平台在一轴上，浏览器在另一轴上。然后，在表格单元格中，我们对每个浏览器/平台组合给出一个“等级”（A到F，或任何满足我们需求的评分系统）。[表14.1](#ch14table01)显示了假设的例子。
- en: Table 14.1\. A hypothetical browser-support matrix
  id: totrans-694
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表14.1\. 一个假设的浏览器支持矩阵
- en: '|   | Windows | OS X | Linux | iOS | Android |'
  id: totrans-695
  prefs: []
  type: TYPE_TB
  zh: '|   | Windows | OS X | Linux | iOS | Android |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-696
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| IE 9 |   | N/A | N/A | N/A | N/A |'
  id: totrans-697
  prefs: []
  type: TYPE_TB
  zh: '| IE 9 |   | N/A | N/A | N/A | N/A |'
- en: '| IE10 |   | N/A | N/A | N/A | N/A |'
  id: totrans-698
  prefs: []
  type: TYPE_TB
  zh: '| IE10 |   | N/A | N/A | N/A | N/A |'
- en: '| IE11 |   | N/A | N/A | N/A | N/A |'
  id: totrans-699
  prefs: []
  type: TYPE_TB
  zh: '| IE11 |   | N/A | N/A | N/A | N/A |'
- en: '| Edge |   | N/A | N/A | N/A | N/A |'
  id: totrans-700
  prefs: []
  type: TYPE_TB
  zh: '| Edge |   | N/A | N/A | N/A | N/A |'
- en: '| Firefox |   |   |   | N/A |   |'
  id: totrans-701
  prefs: []
  type: TYPE_TB
  zh: '| Firefox |   |   |   | N/A |   |'
- en: '| Chrome |   |   |   |   |   |'
  id: totrans-702
  prefs: []
  type: TYPE_TB
  zh: '| Chrome |   |   |   |   |   |'
- en: '| Opera |   |   |   |   |   |'
  id: totrans-703
  prefs: []
  type: TYPE_TB
  zh: '| Opera |   |   |   |   |   |'
- en: '| Safari |   |   | N/A |   | N/A |'
  id: totrans-704
  prefs: []
  type: TYPE_TB
  zh: '| Safari |   |   | N/A |   | N/A |'
- en: Note that we haven’t filled in any grades. The grades you assign to a particular
    combination of platform and browser are entirely dependent on the needs and requirements
    of your project, as well as other important factors, such as the makeup of the
    target audience. We can use this approach to come up with grades that measure
    the importance of support for that platform/browser, and combine that info with
    the cost of that support to try to come up with the optimal set of supported browsers.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还没有填写任何等级。你分配给特定平台和浏览器组合的等级完全取决于你项目的需求和需求，以及其他重要因素，如目标受众的构成。我们可以使用这种方法来制定衡量该平台/浏览器支持重要性的等级，并将这些信息与支持的成本结合起来，试图找出最佳的支持浏览器组合。
- en: 'When we choose to support a browser, we’re typically making the following promises:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们选择支持一个浏览器时，我们通常做出以下承诺：
- en: We’ll actively test against that browser with our test suite.
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用我们的测试套件积极测试该浏览器。
- en: We’ll fix bugs and regressions associated with that browser.
  id: totrans-708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将修复与该浏览器相关的错误和回归。
- en: The browser will execute our code with a reasonable level of performance.
  id: totrans-709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器将以合理的性能执行我们的代码。
- en: 'Because it’s impractical to develop against lots of platform/browser combinations,
    we must weigh the costs versus the benefits of supporting the various browsers.
    This analysis must take into account multiple considerations, and the primary
    ones are as follows:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 由于针对众多平台/浏览器组合进行开发不切实际，我们必须权衡支持各种浏览器所带来的成本与收益。这种分析必须考虑多个因素，其中主要因素如下：
- en: The expectations and needs of the target audience
  id: totrans-711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标受众的期望和需求
- en: The market share of the browser
  id: totrans-712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器的市场份额
- en: The amount of effort necessary to support the browser
  id: totrans-713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持浏览器所需的工作量
- en: The first point is a subjective one that only your project can determine. Market
    share, on the other hand, can frequently be measured using available information.
    And a rough estimate of the effort involved in supporting each browser can be
    determined by considering the capabilities of the browsers and their adherence
    to modern standards.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 第一点是一个主观的观点，只有你的项目可以确定。另一方面，市场份额通常可以使用可用信息来衡量。通过考虑浏览器的功能和它们对现代标准的遵守程度，可以确定支持每个浏览器所需的大致工作量。
- en: '[Figure 14.1](#ch14fig01) shows a sample chart that represents information
    on browser use (obtained from [http://gs.statcounter.com](http://gs.statcounter.com)
    for April 2016). Any piece of reusable JavaScript code, whether it’s a mass-consumption
    JavaScript library or our own onpage code, should be developed to work in as many
    environments as feasible, concentrating on the browsers and platforms that are
    important to the end user. For mass-consumption libraries, that’s a large set;
    for more-targeted applications, the required set may be narrower.'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14.1](#ch14fig01) 展示了一个代表浏览器使用信息（2016年4月从 [http://gs.statcounter.com](http://gs.statcounter.com)
    获取）的样本图表。任何可重用的JavaScript代码，无论是大众消费的JavaScript库还是我们自己的页面代码，都应该开发成在尽可能多的环境中工作，专注于对最终用户重要的浏览器和平台。对于大众消费的库，这是一个很大的集合；对于更针对性的应用，所需的集合可能更窄。'
- en: Figure 14.1\. Looking at the usage statistics of browsers on desktop and mobile
    devices gives us an idea of which browsers to focus our attention on.
  id: totrans-716
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图14.1. 观察桌面和移动设备上的浏览器使用统计，我们可以了解哪些浏览器需要我们关注。
- en: '![](14fig01_alt.jpg)'
  id: totrans-717
  prefs: []
  type: TYPE_IMG
  zh: '![14fig01_alt.jpg](14fig01_alt.jpg)'
- en: 'But it’s vitally important not to bite off more than you can chew, and quality
    should never be sacrificed for coverage. That’s important enough to repeat; in
    fact, we urge you to read it out loud:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，不要贪多嚼不烂，质量永远不应该为了覆盖面而牺牲。这一点很重要，值得重复；实际上，我们敦促你大声朗读：
- en: '*Quality should never be sacrificed for coverage.*'
  id: totrans-719
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*质量永远不应该为了覆盖面而牺牲*。'
- en: In this chapter, we’ll examine the situations that JavaScript code will find
    itself up against with regards to cross-browser support. Then we’ll examine some
    of the best ways to write that code with the aim of alleviating any potential
    problems that those situations pose. This should go a long way in helping you
    decide which of these techniques are worth your time to adopt, and it should help
    you fill out your own browser-support chart.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨JavaScript代码在跨浏览器支持方面可能遇到的情况。然后，我们将探讨编写该代码的一些最佳方法，目的是减轻这些情况可能带来的任何潜在问题。这应该有助于你决定哪些技术值得你投入时间采用，并帮助你完善自己的浏览器支持图表。
- en: 14.2\. The five major development concerns
  id: totrans-721
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2. 五大主要开发关注点
- en: Any piece of nontrivial code carries myriad development concerns to worry about.
    But five major points pose the biggest challenges to our reusable JavaScript code,
    as illustrated in [figure 14.2](#ch14fig02).
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 任何非平凡代码都包含无数的开发关注点。但五个主要点对我们可重用JavaScript代码构成了最大的挑战，如图14.2所示。
- en: Figure 14.2\. The five major points of concern for the development of reusable
    JavaScript
  id: totrans-723
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图14.2. 可重用JavaScript开发关注的五大要点
- en: '![](14fig02.jpg)'
  id: totrans-724
  prefs: []
  type: TYPE_IMG
  zh: '![14fig02.jpg](14fig02.jpg)'
- en: 'These are the five points:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是五个要点：
- en: Browser bugs
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器错误
- en: Browser bug fixes
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器错误修复
- en: External code
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部代码
- en: Browser regressions
  id: totrans-729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器回归
- en: Missing features in the browsers
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器中缺失的功能
- en: We’ll want to balance the amount of time we spend on each point against the
    resulting benefits. Ultimately, these are questions that you’ll have to answer,
    applying them to your own situation. An analysis of your intended audience, development
    resources, and schedule are all factors that go into your decision.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将想要平衡我们在每个点上花费的时间与由此产生的收益。最终，这些问题是你必须回答的，将它们应用于你自己的情况。分析你的目标受众、开发资源和时间表都是影响你决策的因素。
- en: When striving to develop reusable JavaScript code, we must take all the points
    into consideration but pay closest attention to the most popular browsers that
    exist right now, because these are most likely to be used by our targeted audience.
    With other, less popular browsers, we should at least make sure that our code
    degrades gracefully. For example, if a browser doesn’t support a certain API,
    at the very least, we should be careful that our code doesn’t throw any exceptions
    so that the rest of the code can be executed.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 当努力开发可重用JavaScript代码时，我们必须考虑所有这些要点，但最密切的关注点是目前最流行的浏览器，因为这些最有可能被我们的目标受众使用。对于其他不太受欢迎的浏览器，我们至少要确保我们的代码能够优雅地降级。例如，如果一个浏览器不支持某个API，至少我们应该小心，确保我们的代码不会抛出任何异常，这样其余的代码就可以执行。
- en: In the following sections, we’ll break down these various concerns to get a
    better understanding of the challenges we’re up against and how to combat them.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将分解这些各种关注点，以更好地理解我们所面临的挑战以及如何应对它们。
- en: 14.2.1\. Browser bugs and differences
  id: totrans-734
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.1\. 浏览器错误和差异
- en: One of the concerns that we’ll need to deal with when developing reusable JavaScript
    code is handling the various bugs and API differences associated with the set
    of browsers we’ve decided to support. Even though browsers are much more uniform
    these days, any features that we provide in our code should be completely and
    *verifiably* correct in *all* browsers we choose to support.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发可重用JavaScript代码时，我们需要处理与我们所决定支持的浏览器集合相关的各种错误和API差异。尽管如今浏览器更加统一，但我们在代码中提供的任何功能都应该在所有我们选择的浏览器中完全且**可验证地**正确。
- en: 'The way to achieve this is straightforward: We need a comprehensive suite of
    tests to cover both the common and fringe use cases of the code. With good test
    coverage, we can feel safe in knowing that the code we develop will work in the
    supported set of browsers. And assuming that no subsequent browser changes break
    backward compatibility, we’ll have a warm, fuzzy feeling that our code will even
    work in future versions of those browsers. We’ll be looking at specific strategies
    for dealing with browser bugs and differences in [section 14.3](#ch14lev1sec3).'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的方法很简单：我们需要一套全面的测试来覆盖代码的常见和边缘用例。有了良好的测试覆盖率，我们可以放心地知道我们开发的代码将在支持的浏览器集合中工作。并且假设后续的浏览器更改不会破坏向后兼容性，我们将有一种温暖而舒适的感觉，认为我们的代码甚至可以在那些浏览器的未来版本中工作。我们将在[第14.3节](#ch14lev1sec3)中查看处理浏览器错误和差异的具体策略。
- en: A tricky point in all of this is implementing fixes for current browser bugs
    in such a way that they’re resistant to any fixes for those bugs that are implemented
    in future versions of the browser.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些中，一个棘手的问题是，以这种方式实施对当前浏览器错误的修复，使得它们能够抵抗未来浏览器版本中实施的任何针对这些错误的修复。
- en: 14.2.2\. Browser bug fixes
  id: totrans-738
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.2\. 浏览器错误修复
- en: Assuming that a browser will forever present a particular bug is foolhardy—most
    browser bugs eventually get fixed, and *counting* on the presence of the bug is
    a dangerous development strategy. It’s best to use the techniques in [section
    14.3](#ch14lev1sec3) to make sure that any bug work-arounds are future-proofed
    as much as possible.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 假设浏览器将永远存在某个特定错误是愚蠢的——大多数浏览器错误最终都会得到修复，**依赖**于错误的持续存在是一种危险的开发策略。最好使用[第14.3节](#ch14lev1sec3)中的技术，以确保任何错误绕过策略尽可能具有未来性。
- en: When writing a piece of reusable JavaScript code, we want to make sure that
    it can last a long time. As with writing any aspect of a website (CSS, HTML, and
    so on), we don’t want to have to go back and fix code that’s broken by a new browser
    release.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写一段可重用JavaScript代码时，我们希望确保它能够长期存在。就像编写网站的任何方面（CSS、HTML等）一样，我们不希望因为新浏览器的发布而不得不回过头来修复损坏的代码。
- en: 'Making assumptions about browser bugs causes a common form of website breakage:
    specific hacks put in place to work around bugs presented by a browser that break
    when the browser fixes the bugs in future releases.'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 对浏览器错误的假设会导致一种常见的网站故障形式：为了绕过浏览器提出的错误而实施的特定黑客手段，当浏览器在未来版本中修复这些错误时，这些手段会失效。
- en: 'The problem with handling browser bugs is twofold:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 处理浏览器错误的问题有两个方面：
- en: Our code is liable to break when the bug fix is eventually instituted.
  id: totrans-743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当最终实施错误修复时，我们的代码可能会出现故障。
- en: We could end up training browser vendors to *not* fix bugs for fear of causing
    websites to break.
  id: totrans-744
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能会训练浏览器供应商**不**修复错误，以免造成网站故障。
- en: An interesting example of the second situation occurred just recently, with
    the `scrollTop` bug ([https://dev.opera.com/articles/fixing-the-scrolltop-bug/](https://dev.opera.com/articles/fixing-the-scrolltop-bug/)).
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况的一个有趣的例子最近刚刚发生，就是`scrollTop`错误（[https://dev.opera.com/articles/fixing-the-scrolltop-bug/](https://dev.opera.com/articles/fixing-the-scrolltop-bug/)）。
- en: When dealing with elements in the HTML DOM, we can use the `scrollTop` and `scrollLeft`
    properties to access and modify the current scroll position of the element. But
    if we use these properties on the root, `html` element, these properties should,
    according to specification, instead report (and influence) the scroll position
    of the viewport. IE 11 and Firefox closely follow this specification. Unfortunately,
    Safari, Chrome, and Opera don’t. Instead, if you try to modify these properties
    of the root, `html` element, nothing happens. To achieve the same effect in these
    browsers, we have to use the `scrollTop` and `scrollLeft` properties on the `body`
    element.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理HTML DOM中的元素时，我们可以使用`scrollTop`和`scrollLeft`属性来访问和修改元素的当前滚动位置。但如果我们对根元素`html`使用这些属性，根据规范，这些属性应该报告（并影响）视口的滚动位置。IE
    11和Firefox严格遵循这个规范。不幸的是，Safari、Chrome和Opera不遵循。相反，如果你尝试修改根元素`html`的这些属性，什么都不会发生。为了在这些浏览器中达到相同的效果，我们必须使用`body`元素的`scrollTop`和`scrollLeft`属性。
- en: When faced with this inconsistency, web developers have often resorted to detecting
    the current name of the browser (through the user agent string, more on this later),
    and then modifying the `scrollTop` and `scrollLeft` of the `html` element if our
    JavaScript code is being executed in IE or Firefox, and of the `body` element
    if the code is being executed in Safari, Chrome, or Opera. Unfortunately, this
    way of circumventing this bug has proved to be disastrous. Because many pages
    now explicitly encode “if this is Safari, Chrome, or Opera,” modify the `body`
    element, these browsers can’t really fix this bug, because the bug fix would,
    ironically, cause failures in many web pages.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 面对这种不一致性，网页开发者们常常求助于检测当前浏览器的名称（通过用户代理字符串，关于这一点稍后详述），然后如果我们的JavaScript代码在IE或Firefox中执行，就修改`html`元素的`scrollTop`和`scrollLeft`，如果代码在Safari、Chrome或Opera中执行，就修改`body`元素。不幸的是，这种绕过这个错误的方法已经被证明是灾难性的。因为现在许多页面明确编码“如果是Safari、Chrome或Opera”，就修改`body`元素，这些浏览器实际上无法修复这个错误，因为修复错误反而会导致许多网页失败。
- en: 'This brings up another important point concerning bugs: When determining whether
    a piece of functionality is potentially a bug, always verify it with the specification!'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 这又提出了关于错误的一个重要观点：在确定某个功能是否可能是错误时，始终要使用规范来验证它！
- en: A browser bug is also different from an unspecified API. It’s important to refer
    to browser specifications, because they provide the exact standards that browsers
    use to develop and improve their code. In contrast, the implementation of an unspecified
    API could change at any point (especially if the implementation ever attempts
    to become standardized). In the case of inconsistencies in unspecified APIs, you
    should always test for your expected output. Always be aware that future changes
    could occur in these APIs as they become solidified.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器错误也与未指定的API不同。参考浏览器规范很重要，因为它们提供了浏览器开发和完善代码的确切标准。相比之下，未指定API的实现可能会在任何时候发生变化（尤其是如果实现试图成为标准化的情况下）。在未指定API的不一致情况下，你应该始终测试你期望的输出。始终意识到，随着它们变得稳固，这些API可能会发生未来的变化。
- en: Additionally, there’s a distinction between bug fixes and API changes. Whereas
    bug fixes are easily foreseen—a browser will eventually fix the bugs in its implementation,
    even if it takes a long time—API changes are much harder to spot. Standard APIs
    are unlikely to change (though it’s not completely unheard of); changes are much
    more likely to occur with unspecified APIs.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，错误修复和API更改之间还有一个区别。虽然错误修复很容易预见——浏览器最终会修复其实施中的错误，即使这需要很长时间——但API更改很难发现。标准API不太可能更改（尽管并非完全不可能）；更改更有可能发生在未指定的API上。
- en: Luckily, this rarely happens in a way that will massively break most web applications.
    But if it does, it’s effectively undetectable in advance (unless, of course, we
    test every single API that we ever touch—but the overhead incurred in such a process
    would be ludicrous). API changes of this sort should be handled like any other
    regression.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这种情况很少发生到足以严重破坏大多数Web应用的程度。但如果确实发生了，那么在事先是难以检测到的（除非，当然，我们测试了我们接触过的每一个API——但这样的过程所造成的开销将是荒谬的）。这种类型的API更改应像处理任何其他回归一样处理。
- en: For our next point of concern, we know that no man is an island, and neither
    is our code. Let’s explore the ramifications.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们下一个关注点，我们知道没有人是一座孤岛，我们的代码也不例外。让我们探讨其影响。
- en: 14.2.3\. External code and markup
  id: totrans-753
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.3\. 外部代码和标记
- en: Any reusable code must coexist with the code that surrounds it. Whether we’re
    expecting our code to work on pages that we write or on websites developed by
    others, we need to ensure that it can exist on the page with any other random
    code.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 任何可重用代码都必须与周围的代码共存。无论我们期望我们的代码在我们自己编写的页面上工作，还是在他人开发的网站上工作，我们都需要确保它可以在页面上与任何其他随机代码共存。
- en: 'This is a double-edged sword: Our code not only must be able to withstand living
    with potentially poorly written external code, but also must take care not to
    have adverse effects on the code with which it lives.'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一把双刃剑：我们的代码不仅必须能够承受与可能编写不良的外部代码共存，而且必须注意不要对其共存的代码产生不利影响。
- en: Exactly how much we need to be vigilant about this point of concern depends
    a great deal on the environment in which we expect the code to be used. For example,
    if we’re writing reusable code for a single or limited number of websites that
    we have some level of control over, it might be safe to worry less about effects
    of external code because we know where the code will operate, and we can, to some
    degree, fix any problems ourselves.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对此关注点保持多高的警惕性，很大程度上取决于我们期望代码被使用的环境。例如，如果我们正在编写适用于单个或有限数量网站的可重用代码，并且我们对这些网站有一定程度的控制，那么可能不需要过于担心外部代码的影响，因为我们知道代码将在哪里运行，并且我们可以在一定程度上自行修复任何问题。
- en: '|  |'
  id: totrans-757
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-758
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: This is an important enough concern to warrant an entire book on the subject.
    If you’d like to delve more deeply, we highly recommend *Third-Party JavaScript*
    by Ben Vinegar and Anton Kovalyov (Manning, 2013, [https://www.manning.com/books/third-party-javascript](https://www.manning.com/books/third-party-javascript)).
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个足够重要的问题，足以写成一整本书。如果您想深入了解，我们强烈推荐本·文尼加和安东·科瓦洛夫的《第三方JavaScript》（Manning，2013年，[https://www.manning.com/books/third-party-javascript](https://www.manning.com/books/third-party-javascript))。
- en: '|  |'
  id: totrans-760
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: If we’re developing code that will have a broad level of applicability in unknown
    (and uncontrollable) environments, we’ll need to make doubly sure that our code
    is robust. Let’s discuss some strategies to achieve that.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在开发将在未知（且不可控）环境中广泛应用的代码，我们需要确保我们的代码是健壮的。让我们讨论一些实现这一目标的策略。
- en: Encapsulating our code
  id: totrans-762
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 封装我们的代码
- en: To keep our code from affecting other pieces of code on the pages where it’s
    loaded, it’s best to practice *encapsulation*. In general, this refers to the
    act of placing something in, or as if in, a capsule. A more domain-focused definition
    is “a language mechanism for restricting access to some of the object’s components.”
    Your Aunt Mathilda might summarize it more succinctly as “Keep your nose in your
    own business!”
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止我们的代码影响加载页面上的其他代码片段，最好的做法是实践*封装*。一般来说，这指的是将某物放入或仿佛放入胶囊中的行为。一个更专注于特定领域的定义是“一种语言机制，用于限制对某些对象组件的访问。”您的阿姨玛蒂尔达可能会更简洁地总结为“管好自己的事！”
- en: Keeping an incredibly small global footprint when introducing our code into
    a page can go a long way toward making Aunt Mathilda happy. In fact, keeping our
    global footprint to a handful of global variables, or better yet, *one*, is fairly
    easy.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将代码引入页面时，保持极小的全局影响范围可以极大地让阿姨玛蒂尔达感到满意。事实上，将我们的全局影响范围限制在几个全局变量，或者更好，*一个*全局变量，相当容易。
- en: As you saw in [chapter 12](kindle_split_025.html#ch12), jQuery, the most popular
    client-side JavaScript library, is a good example of this. It introduces one global
    variable (a function) named `jQuery`, and one alias for that global variable,
    `$`. It even has a supported means to give the `$` alias back to whatever other
    on-page code or other library may want to use it.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[第12章](kindle_split_025.html#ch12)中看到的，jQuery，最受欢迎的客户端JavaScript库，是这种做法的一个很好的例子。它引入了一个名为`jQuery`的全局变量（一个函数），以及该全局变量的一个别名`$`。它甚至有支持将`$`别名返回给页面上其他代码或其他库的途径。
- en: Almost all operations in jQuery are made via the `jQuery` function. And any
    other functions that it provides (called *utility functions*) are defined as properties
    of `jQuery` (remember from [chapter 3](kindle_split_014.html#ch03) how easy it
    is to define functions that are properties of other functions), thus using the
    name `jQuery` as a *namespace* for all its definitions.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎jQuery中的所有操作都是通过`jQuery`函数完成的。它提供的任何其他函数（称为*实用函数*）都被定义为`jQuery`的属性（记得从[第3章](kindle_split_014.html#ch03)中了解到，定义其他函数的属性是多么容易），因此使用`jQuery`作为所有定义的*命名空间*。
- en: We can use the same strategy. Let’s say that we’re defining a set of functions
    for our own use, or for the use of others, that we’ll group under a namespace
    of our own choosing—say, `ninja`.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用相同的策略。假设我们正在定义一组函数，供我们自己使用或供他人使用，我们将它们分组在我们自己选择的命名空间下——比如说，`ninja`。
- en: 'We could, like jQuery, define a global function named `ninja()`that performs
    various operations based on what we pass to the function. For example:'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像jQuery一样，定义一个名为`ninja()`的全局函数，该函数根据我们传递给函数的内容执行各种操作。例如：
- en: '[PRE46]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Defining our own utility functions that use this function as their namespace
    is easy:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 定义我们自己的实用函数，这些函数使用此函数作为它们的命名空间，是很容易的：
- en: '[PRE47]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If we didn’t want or need `ninja` to be a function but only to serve as a namespace,
    we could define it as follows:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不希望或需要`ninja`是一个函数，而只想将其作为命名空间使用，我们可以如下定义它：
- en: '[PRE48]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This creates an empty object in which we can define properties and functions
    in order to keep from adding these names to the global namespace.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个空对象，我们可以在其中定义属性和函数，以避免将这些名称添加到全局命名空间中。
- en: Other practices that we want to avoid, in order to keep our code encapsulated,
    are modifying any existing variables, function prototypes, or even DOM elements.
    Any aspect of the page that our code modifies, outside itself, is a potential
    area for collision and confusion.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持我们的代码封装，我们还想避免的其他做法是修改任何现有的变量、函数原型，甚至DOM元素。我们代码修改的页面任何方面，除了自身之外，都可能是潜在的冲突和混淆区域。
- en: The other side of the two-way street is that even if *we* follow best practices
    and carefully encapsulate our code, we can’t be assured that code we haven’t written
    is going to be as well-behaved.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 双向街道的另一边是，即使我们遵循最佳实践并仔细封装我们的代码，我们也不能保证我们没有编写的代码会表现得很好。
- en: Dealing with less-than-exemplary code
  id: totrans-777
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 处理不尽如人意的代码
- en: 'There’s an old joke that’s been going around since Grace Hopper removed that
    moth from a relay back in the Cretaceous period: “The only code that doesn’t suck
    is the code you write yourself.” This may seem cynical, but when our code coexists
    with code that we can’t control, we should assume the worst, just to be safe.'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个古老的笑话，自从Grace Hopper在白垩纪时期从继电器中移除那只蛾子以来一直在流传：“唯一不糟糕的代码就是你自己写的代码。”这听起来可能有些愤世嫉俗，但当我们无法控制的代码与我们的代码共存时，为了安全起见，我们应该假设最坏的情况。
- en: Some code, even if well-written, might *intentionally* be doing things like
    modifying function prototypes, object properties, and DOM element methods. This
    practice, well-meant or otherwise, can lay traps for us to step into.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 一些代码，即使写得很好，也可能**故意**进行修改函数原型、对象属性和DOM元素方法等操作。这种做法，无论初衷如何，都可能为我们设置陷阱。
- en: In these circumstances, our code could be doing something innocuous, such as
    using JavaScript arrays, and no one could fault us for making the simple assumption
    that JavaScript arrays are going to act like JavaScript arrays. But if some other
    on-page code modifies the way that arrays work, our code could end up not working
    as intended, through absolutely no fault of our own.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的代码可能在进行一些无害的操作，例如使用JavaScript数组，而且没有人会因为我们简单地假设JavaScript数组会像JavaScript数组那样表现而责怪我们。但如果页面上其他代码修改了数组的工作方式，我们的代码可能最终无法按预期工作，而这绝对不是我们的错。
- en: Unfortunately, there aren’t many steadfast rules when dealing with situations
    of this nature, but we can take some mitigating steps. The next few sections introduce
    these defensive steps.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在处理这类情况时，并没有很多坚定不移的规则，但我们可以采取一些缓解措施。接下来的几节将介绍这些防御性步骤。
- en: Coping with greedy IDs
  id: totrans-782
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 应对贪婪的ID
- en: Most browsers exhibit an *anti-feature* (we can’t call it a *bug* because the
    behavior is absolutely intended) that can cause our code to trip and fall unexpectedly.
    This feature causes element references to be added to other elements by using
    the `id` or `name` attributes of the original element. And when that `id` or `name`
    conflicts with properties that are already part of the element, bad things can
    happen.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数浏览器都表现出一种*反功能*（我们不能称之为*bug*，因为这种行为是完全有意的），这可能导致我们的代码意外地出错。这个功能通过使用原始元素的`id`或`name`属性将元素引用添加到其他元素中。当那个`id`或`name`与元素已包含的属性冲突时，就会发生不好的事情。
- en: 'Take a look at the following HTML snippet to observe the nastiness that can
    ensue as a result of these *greedy IDs*:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下HTML片段，以观察这些*贪婪的ID*可能导致的恶劣后果：
- en: '[PRE49]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, in the browsers, let’s call this:'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在浏览器中，我们将其称为：
- en: '[PRE50]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Rightly, we’d expect this to be the value of the form’s `action` attribute.
    And in most cases, it would be. But if we inspect the value of variable `what`,
    we find that it’s instead a reference to the `input#action` element! Huh?
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 正确地，我们期望这是表单的`action`属性的值。在大多数情况下，它确实是。但如果我们检查变量`what`的值，我们会发现它实际上是对`input#action`元素的引用！
    huh？
- en: 'Let’s try something else:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试别的：
- en: '[PRE51]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This statement should cause the form to be submitted, but instead, we get a
    script error:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句应该会导致表单提交，但相反，我们得到了一个脚本错误：
- en: '[PRE52]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: What’s going on?
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？
- en: The browsers have added properties to the `<form>` element for each of the input
    elements within the form that reference the element. This might seem handy at
    first, until we realize that the name of the added property is taken from the
    `id` or `name` values of the input elements. And if that value just happens to
    be an already-used property of the form element, such as `action` or `submit`,
    those original properties are replaced by the new property. This is usually referred
    to as *DOM clobbering*.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器为表单中的每个输入元素添加了属性，这些属性引用了该元素。一开始这看起来很方便，直到我们意识到添加的属性名称是从输入元素的`id`或`name`值中取来的。如果这个值恰好是表单元素的已使用属性，比如`action`或`submit`，那么这些原始属性就会被新属性所取代。这通常被称为*DOM覆盖*。
- en: So, before the `input#submit` element is created, the reference `form.action`
    points to the value of the `action` attribute for the `<form>`. Afterward, it
    points to the `input#submit` element. The same thing happens to `form.submit`.
    Yeesh!
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在创建`input#submit`元素之前，引用`form.action`指向的是`<form>`的`action`属性的值。之后，它指向`input#submit`元素。`form.submit`也会发生同样的事情。唉！
- en: This is a remnant from way back, from a time when browsers didn’t have a rich
    set of API methods for fetching elements from the DOM. Browser vendors added this
    feature to give easy access to form elements. Nowadays we can easily access any
    element in the DOM, so we’re left with only the unfortunate side effects of the
    feature.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从很久以前遗留下来的，那时浏览器还没有丰富的API方法来从DOM中获取元素。浏览器供应商添加了这个功能，以便轻松访问表单元素。如今，我们可以轻松访问DOM中的任何元素，所以我们只剩下这个功能的遗憾副作用。
- en: In any case, this particular “feature” of the browsers can cause numerous and
    mystifying problems in our code, and we should keep it in mind when debugging.
    When we encounter properties that have seemingly been inexplicably transformed
    into something other than what we expect, DOM clobbering is a likely culprit.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，这个浏览器特有的“功能”可能会在我们的代码中引起众多神秘的问题，我们在调试时应该牢记这一点。当我们遇到看似无法解释地变成了我们预期之外的其他属性时，DOM覆盖可能是罪魁祸首。
- en: Luckily, we can avoid this problem in our own markup by avoiding simple `id`
    and `name` values that can conflict with standard property names, and we can encourage
    others to do the same. The value `submit` is especially to be avoided, as it’s
    a common source of frustrating and perplexing buggy behavior.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以在自己的标记中避免这个问题，通过避免可能与其他标准属性名冲突的简单`id`和`name`值，并鼓励他人也这样做。`submit`值尤其要避免，因为它是一个常见的导致令人沮丧和困惑的故障行为的来源。
- en: Loading order of style sheets and scripts
  id: totrans-799
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 样式表和脚本的加载顺序
- en: Often we’ll expect CSS rules to already be available by the time our code executes.
    One of the best ways to ensure that CSS rules provided by style sheets are defined
    when our JavaScript code executes is to include the external style sheets *prior*
    to including the external script files.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常期望在代码执行时CSS规则已经可用。确保当我们的JavaScript代码执行时，由样式表提供的CSS规则已定义的最好方法之一是在包含外部脚本文件之前包含外部样式表。
- en: Not doing so can cause unexpected results, because the script attempts to access
    the as-yet-undefined style information. Unfortunately, this issue can’t easily
    be rectified with pure JavaScript and should instead be handled with user documentation.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 不这样做可能会导致意外结果，因为脚本尝试访问尚未定义的样式信息。不幸的是，这个问题不能轻易地用纯JavaScript修复，而应该通过用户文档来处理。
- en: These last few sections have covered some basic examples of how externalities
    can affect how our code works, frequently in unintentional and confounding ways.
    Issues with our code will often pop up when other users try to integrate it into
    *their* sites, at which point we should be able to diagnose the issues and build
    appropriate tests to handle them. At other times, we’ll discover such problems
    when we integrate others’ code into our pages, and hopefully the tips in these
    sections will help to identify the causes.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 这些最后几个部分介绍了一些基本示例，说明了外部因素如何影响我们的代码工作，通常是以无意和令人困惑的方式。当其他用户尝试将其集成到“他们”的网站时，我们代码的问题通常会浮出水面，此时我们应该能够诊断这些问题并构建适当的测试来处理它们。在其他时候，当我们将他人的代码集成到我们的页面中时，希望这些部分中的提示有助于识别原因。
- en: It’s unfortunate that there are no better and deterministic solutions to handling
    these integration issues other than to take some smart first steps and to write
    our code defensively. We’ll now move on to the next point of concern.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 很不幸，除了采取一些明智的初步步骤并编写防御性代码之外，没有更好的和确定性的解决方案来处理这些集成问题。我们现在将转向下一个关注点。
- en: 14.2.4\. Regressions
  id: totrans-804
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.4. 回归
- en: '*Regressions* are one of the hardest problems we’ll encounter in creating reusable
    and maintainable JavaScript code. These are bugs, or non-backward-compatible API
    changes (mostly to unspecified APIs), that browsers have introduced and that cause
    code to break in unpredictable ways.'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: “回归”是我们将在创建可重用和可维护的JavaScript代码过程中遇到的最困难的问题之一。这些是错误，或者非向后兼容的API更改（主要是对未指定的API），浏览器已经引入，并以不可预测的方式导致代码中断。
- en: '|  |'
  id: totrans-806
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-807
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Here we’re using the term *regression* in its classical definition: a feature
    that used to work but no longer functions as expected. This is usually unintentional,
    but it’s sometimes caused by deliberate changes that break existing code.'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用“回归”这个术语的经典定义：曾经起作用但现在不再按预期工作的功能。这通常是无意的，但有时是由故意改变现有代码而导致的。
- en: '|  |'
  id: totrans-809
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Anticipating changes
  id: totrans-810
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 预测变化
- en: There *are* some API changes that, with some foresight, we can proactively detect
    and handle, as shown in [listing 14.1](#ch14ex01). For example, with Internet
    Explorer 9, Microsoft introduced support for DOM level 2 event handlers (bound
    using the `addEventListener` method), while previous versions of IE were using
    the IE-specific built-in `attachEvent` method. For code written prior to IE 9,
    simple feature detection was able to handle that change.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些API更改，通过一些预见性，我们可以主动检测和处理，如[列表14.1](#ch14ex01)所示。例如，在Internet Explorer 9中，微软引入了对DOM
    2级事件处理程序的支持（使用`addEventListener`方法绑定），而之前的IE版本则使用IE特定的内置`attachEvent`方法。对于在IE
    9之前编写的代码，简单的功能检测能够处理这种变化。
- en: Listing 14.1\. Anticipating an upcoming API change
  id: totrans-812
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.1. 预测即将到来的API更改
- en: '![](376fig01_alt.jpg)'
  id: totrans-813
  prefs: []
  type: TYPE_IMG
  zh: '![图片](376fig01_alt.jpg)'
- en: In this example, we future-proof our code knowing (or hoping against hope) that
    someday Microsoft will bring Internet Explorer into line with DOM standards. If
    the browser supports the standards-compliant API, we use feature detection to
    infer that and use the standard API, the `addEventListener` method. If not, we
    check to see that the IE-proprietary method `attachEvent` is available and use
    that. If all else fails, we do nothing.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使代码具有未来兼容性，知道（或抱着一线希望）有一天微软会将Internet Explorer纳入DOM标准。如果浏览器支持符合标准的API，我们使用功能检测来推断这一点，并使用标准API，即`addEventListener`方法。如果不支持，我们检查IE专有的方法`attachEvent`是否可用，并使用它。如果所有其他方法都失败，我们就不做任何事情。
- en: Most future API changes, alas, aren’t that easy to predict, and there’s no way
    to predict upcoming bugs. This is but one of the important reasons that we’ve
    stressed testing throughout this book. In the face of unpredictable changes that
    will affect our code, the best that we can hope for is to be diligent in monitoring
    our tests for each browser release, and to quickly address issues that regressions
    may introduce.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，大多数未来的API更改并不容易预测，而且无法预测即将出现的错误。这正是我们在本书中强调测试的一个重要原因。面对将影响我们代码的不可预测的变化，我们所能期望的最好的事情就是勤勉地监控每个浏览器版本的测试，并迅速解决回归可能引入的问题。
- en: Having a good suite of tests and keeping close track of upcoming browser releases
    is absolutely the best way to deal with future regressions of this nature. It
    doesn’t have to be taxing on your normal development cycle, which should already
    include routine testing. Running these tests on new browser releases should always
    be factored into the planning of any development cycle.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个好的测试套件并密切关注即将发布的浏览器版本是处理此类未来回归的绝对最佳方式。这不需要对您的正常开发周期造成负担，您的开发周期应该已经包括常规测试。在新的浏览器版本上运行这些测试应该始终纳入任何开发周期的规划中。
- en: 'You can get information on upcoming browser releases from the following locations:'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从以下位置获取有关即将发布的浏览器版本的信息：
- en: 'Microsoft Edge (a successor to IE): [http://blogs.windows.com/msedgedev/](http://blogs.windows.com/msedgedev/)'
  id: totrans-818
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微软Edge（IE的后继产品）：[http://blogs.windows.com/msedgedev/](http://blogs.windows.com/msedgedev/)
- en: 'Firefox: [http://ftp.mozilla.org/pub/firefox/nightly/latest-trunk/](http://ftp.mozilla.org/pub/firefox/nightly/latest-trunk/)'
  id: totrans-819
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Firefox: [http://ftp.mozilla.org/pub/firefox/nightly/latest-trunk/](http://ftp.mozilla.org/pub/firefox/nightly/latest-trunk/)'
- en: 'WebKit (Safari): [https://webkit.org/nightly/](https://webkit.org/nightly/)'
  id: totrans-820
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebKit（Safari）：[https://webkit.org/nightly/](https://webkit.org/nightly/)
- en: 'Opera: [https://dev.opera.com/](https://dev.opera.com/)'
  id: totrans-821
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Opera: [https://dev.opera.com/](https://dev.opera.com/)'
- en: 'Chrome: [http://chrome.blogspot.hr/](http://chrome.blogspot.hr/)'
  id: totrans-822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Chrome: [http://chrome.blogspot.hr/](http://chrome.blogspot.hr/)'
- en: Diligence is important. Because we can never fully predict the bugs that will
    be introduced by a browser, it’s best to make sure that we stay on top of our
    code and quickly avert any crises that may arise.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 勤勉很重要。因为我们永远无法完全预测浏览器将引入的错误，所以最好确保我们始终关注我们的代码，并迅速避免可能出现的任何危机。
- en: Thankfully, browser vendors are doing a lot to make sure that regressions of
    this nature don’t occur, and browsers often have test suites from various JavaScript
    libraries integrated into their main browser test suite. This ensures that no
    future regressions will be introduced that affect those libraries directly. Although
    this won’t catch all regressions (and certainly won’t in all browsers), it’s a
    great start and shows good progress by the browser vendors toward preventing as
    many issues as possible.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，浏览器供应商正在做很多事情以确保这种类型的回归不会发生，浏览器通常将来自各种JavaScript库的测试套件集成到它们的主浏览器测试套件中。这确保了不会引入任何未来的回归，这些回归会直接影响到这些库。尽管这不会捕获所有回归（当然，在所有浏览器中都不会），但这是一个很好的开始，显示了浏览器供应商在尽可能防止尽可能多的问题方面取得的良好进展。
- en: 'In this section, we’ve gone through four major points of concern for the development
    of reusable JavaScript: browser bugs, browser bug fixes, external code, and browser
    regressions. The fifth point—missing features in the browsers—deserves a special
    mention, so we cover it in the next section, alongside other implementation strategies
    relevant for cross-browser web applications.'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经讨论了开发可重用JavaScript的四个主要关注点：浏览器错误、浏览器错误修复、外部代码和浏览器回归。第五个关注点——浏览器中缺失的功能——值得特别提及，因此我们在下一节中将其与其他适用于跨浏览器Web应用的实现策略一起介绍。
- en: 14.3\. Implementation strategies
  id: totrans-826
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3. 实施策略
- en: Knowing which issues to be aware of is only half the battle. Figuring out effective
    solutions and using them to implement robust cross-browser code is another matter.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 了解需要关注的问题只是战斗的一半。找出有效的解决方案并使用它们来实现健壮的跨浏览器代码是另一回事。
- en: A wide range of strategies are available, and although not every strategy will
    work in every situation, the range presented in this section covers most of the
    concerns that we’ll need to address within our robust code bases. Let’s start
    with something that’s easy and almost trouble free.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 一系列策略可供选择，尽管并非每个策略都适用于每种情况，但本节中提供的策略涵盖了我们需要在健壮的代码库中解决的大多数问题。让我们从一件既简单又几乎无麻烦的事情开始。
- en: 14.3.1\. Safe cross-browser fixes
  id: totrans-829
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.3.1. 安全的跨浏览器修复
- en: 'The simplest (and safest) classes of cross-browser fixes are those that exhibit
    two important traits:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单（也是最安全）的跨浏览器修复类型是那些具有两个重要特性的类型：
- en: They have no negative effects or side effects on other browsers.
  id: totrans-831
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们对其他浏览器没有负面影响或副作用。
- en: They use no form of browser or feature detection.
  id: totrans-832
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们不使用任何形式的浏览器或功能检测。
- en: The instances for applying these fixes may be rare, but they’re a tactic that
    we should always strive for in our applications.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 应用这些修复的实例可能很少，但它们是我们应该在应用程序中始终追求的策略。
- en: 'Let’s look at an example. The following code snippet represents a change (plucked
    from jQuery) that came about when working with Internet Explorer:'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。以下代码片段代表了一个更改（从 jQuery 中摘取），这是在处理 Internet Explorer 时出现的：
- en: '[PRE53]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Some versions of IE throw an exception when a negative value is set on the `height`
    or `width` style properties. All other browsers ignore negative input. This work-around
    ignores all negative values in *all* browsers. This change prevents an exception
    from being thrown in Internet Explorer and has no effect on any other browser.
    This is a painless change that provides a unified API to the user (because throwing
    unexpected exceptions is never desired).
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 一些版本的 IE 在将负值设置为 `height` 或 `width` 样式属性时抛出异常。所有其他浏览器都忽略负输入。这个解决方案忽略了所有浏览器中的所有负值。这个更改防止了在
    Internet Explorer 中抛出异常，并且对任何其他浏览器都没有影响。这是一个无痛苦的更改，为用户提供了一个统一的 API（因为抛出意外的异常是不希望的）。
- en: 'Another example of this type of fix (also from jQuery) appears in the attribute
    manipulation code. Consider this:'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型修复的另一个例子（也来自 jQuery）出现在属性操作代码中。考虑以下内容：
- en: '[PRE54]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Internet Explorer doesn’t allow us to manipulate the `type` attribute of input
    elements that are already part of the DOM; attempts to change this attribute result
    in a proprietary exception being thrown. jQuery came to a middle-ground solution:
    It disallows *all* attempts to manipulate the `type` attribute on injected input
    elements in all browsers, throwing a uniform informational exception.'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: Internet Explorer 不允许我们操作已包含在 DOM 中的输入元素的 `type` 属性；尝试更改此属性会导致抛出专有异常。jQuery
    达成了一个折中方案：它禁止在所有浏览器中注入输入元素上的 `type` 属性的所有尝试，并抛出一个统一的信息性异常。
- en: This change to the jQuery code base requires no browser or feature detection;
    it unifies the API across all browsers. The action still results in an exception,
    but that exception is uniform across all browser types.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 对 jQuery 代码库的这种更改不需要浏览器或功能检测；它在所有浏览器中统一了 API。操作仍然会导致异常，但这个异常在所有浏览器类型中都是统一的。
- en: This particular approach could be considered controversial. It purposefully
    limits the features of the library in all browsers because of a bug that exists
    in only one. The jQuery team weighed this decision carefully and decided that
    it was better to have a unified API that works consistently than an API that would
    break unexpectedly when developing cross-browser code. You might come across situations
    like this when developing your own reusable code bases, and you’ll need to carefully
    consider whether a limiting approach such as this is appropriate for your audience.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 这种特定的方法可能会被认为是具有争议性的。它故意限制了在所有浏览器中库的功能，因为只有一个浏览器存在一个错误。jQuery 团队仔细权衡了这个决定，并认为拥有一个始终如一工作的统一
    API 比在开发跨浏览器代码时意外中断的 API 更好。在开发自己的可重用代码库时，你可能会遇到这种情况，你需要仔细考虑这种限制方法是否适合你的受众。
- en: The important thing to remember for these types of code changes is that they
    provide a solution that works seamlessly across browsers without the need for
    browser or feature detection, effectively making them immune to changes going
    forward. You should always strive for solutions that work in this manner, even
    if the applicable instances are few and far between.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些类型的代码更改，重要的是要记住，它们提供了一个在浏览器之间无缝工作的解决方案，无需进行浏览器或功能检测，实际上使它们免受未来更改的影响。你应该始终努力寻求以这种方式工作的解决方案，即使适用实例很少。
- en: 14.3.2\. Feature detection and polyfills
  id: totrans-843
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.3.2\. 功能检测和填充
- en: As we’ve previously discussed, *feature detection* is a commonly used approach
    when writing cross-browser code. This approach isn’t only simple but also generally
    effective. It works by determining whether a certain object or object property
    exists, and if so, assuming that it provides the implied functionality. (In the
    next section, we’ll see what to do about cases where this assumption fails.)
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，*特征检测*是在编写跨浏览器代码时常用的一种方法。这种方法不仅简单，而且通常有效。它通过确定是否存在某个对象或对象属性，并假设它提供了隐含的功能来实现。
    (在下一节中，我们将看到当这个假设失败时应该怎么做。)
- en: Most commonly, feature detection is used to choose between multiple APIs that
    provide duplicate pieces of functionality. For example, [chapter 10](kindle_split_022.html#ch10)
    explored the `find` method, accessible to all arrays, a method that we can use
    to find the first array item that satisfies a certain condition. Unfortunately,
    the method is accessible only in browsers that fully support ES6\. So what do
    we do when we’re stuck with browsers that still don’t support this feature? In
    general, how do we deal with missing features in the browsers?
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的是，特征检测用于在提供重复功能的多重API之间进行选择。例如，第10章（[kindle_split_022.html#ch10](kindle_split_022.html#ch10)）探讨了所有数组都可以访问的`find`方法，我们可以使用它来找到满足特定条件的第一个数组项。不幸的是，这个方法只能在完全支持ES6的浏览器中使用。那么当我们遇到仍然不支持这个特性的浏览器时，我们该怎么办？一般来说，我们如何处理浏览器中缺失的功能？
- en: The answer is polyfilling! A polyfill is a browser fallback. If a browser doesn’t
    support a particular functionality, we provide our own implementation. For example,
    the Mozilla Developer Network (MDN) provides polyfills for a wide range of ES6
    functionality. Among other things, this includes the JavaScript implementation
    of the `Array.prototype.find` method ([http://mng.bz/d9lU](http://mng.bz/d9lU)),
    as shown in the following listing.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是polyfill！polyfill是一种浏览器回退。如果一个浏览器不支持特定的功能，我们就提供自己的实现。例如，Mozilla开发者网络（MDN）为广泛的ES6功能提供了polyfill。其中之一就是`Array.prototype.find`方法的JavaScript实现（[http://mng.bz/d9lU](http://mng.bz/d9lU)），如下面的列表所示。
- en: Listing 14.2\. A polyfill for the Array.prototype.find method
  id: totrans-847
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.2\. `Array.prototype.find`方法的polyfill
- en: '![](379fig01_alt.jpg)'
  id: totrans-848
  prefs: []
  type: TYPE_IMG
  zh: '![图片](379fig01_alt.jpg)'
- en: 'In this example, we first use feature detection to check whether the current
    browser has built-in support for the `find` method:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先使用特征检测来检查当前浏览器是否内置了对`find`方法的支持：
- en: '[PRE55]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Whenever possible, we should default to the standard way of performing any action.
    As mentioned before, this will help make our code as future-proof as possible.
    For this reason, if the browser already supports the method, we do nothing. If
    we’re dealing with a browser that hasn’t yet caught up with ES6, we provide our
    own implementation.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，我们应该默认使用执行任何操作的标准方式。如前所述，这将有助于使我们的代码尽可能具有未来性。因此，如果浏览器已经支持该方法，我们就不做任何事情。如果我们处理的是尚未赶上ES6的浏览器，我们提供自己的实现。
- en: It turns out that the core of the method is straightforward. We loop through
    the array, calling the passed-in predicate function, which checks whether an array
    item satisfies our criteria. If it does, we return it.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，该方法的核心非常简单。我们遍历数组，调用传入的谓词函数，该函数检查数组项是否满足我们的标准。如果满足，我们就返回它。
- en: 'One interesting technique is presented in this listing:'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，介绍了一种有趣的技巧：
- en: '[PRE56]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `>>>` operator is the *zero-fill right-shift operator*, which shifts the
    first operand the specified number of bits to the right, while discarding the
    excess bits. In this case, this operator is used to convert the `length` property
    to a non-negative integer. This is done because array indexes in JavaScript should
    be unsigned integers.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: '`>>>`运算符是*零填充右移运算符*，它将第一个操作数向右移动指定的位数，同时丢弃多余的位。在这种情况下，这个运算符用于将`length`属性转换为非负整数。这样做是因为JavaScript中的数组索引应该是无符号整数。'
- en: An important use of feature detection is discovering the facilities provided
    by the browser environment in which the code is executing. This allows us to provide
    features that use those facilities in our code, or to determine whether we need
    to provide a fallback.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 特征检测的一个重要用途是发现代码执行的环境提供的浏览器环境设施。这允许我们在代码中使用这些设施提供的功能，或者确定我们是否需要提供回退。
- en: 'The following code snippet shows a basic example of detecting the presence
    of a browser feature by using feature detection, to determine whether we should
    provide full application functionality or a reduced-experience fallback:'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了使用功能检测检测浏览器功能是否存在的基本示例，以确定我们是否应该提供完整的应用程序功能或简化体验的回退：
- en: '[PRE57]'
  id: totrans-858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here, we test whether
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们测试是否
- en: The browser has a document loaded
  id: totrans-860
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器已加载文档
- en: The browser provides a means to bind event handlers
  id: totrans-861
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器提供了一种绑定事件处理器的方法
- en: The browser can find elements based on a selector
  id: totrans-862
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器可以根据选择器找到元素
- en: 'Failing any of these tests causes us to resort to a fallback position. What
    is done in the fallback is up to the expectations of the consumers of the code,
    and the requirements placed on the code. A few options can be considered:'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何这些测试失败，我们将不得不求助于回退位置。在回退中做什么取决于代码的消费者期望以及代码的要求。可以考虑以下几种选项：
- en: We could perform further feature detection to figure out how to provide a reduced
    experience that still uses some JavaScript.
  id: totrans-864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以执行进一步的功能检测，以确定如何提供一种使用一些 JavaScript 的简化体验。
- en: We could opt to not execute any JavaScript, falling back to the unscripted HTML
    on the page.
  id: totrans-865
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以选择不执行任何 JavaScript，转而使用页面上的未脚本化 HTML。
- en: We could redirect the user to a plainer version of the site. Google does this
    with Gmail, for example.
  id: totrans-866
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将用户重定向到网站的简化版本。例如，谷歌在 Gmail 中就是这样做的。
- en: Because feature detection has little overhead (it’s just a property/object lookup)
    and is relatively simple in its implementation, it’s a good way to provide basic
    levels of fallback, both at the API and application levels. It’s a good choice
    for the first line of defense in your reusable code authoring.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 由于功能检测几乎没有开销（它只是属性/对象查找）并且实现相对简单，它是在 API 和应用程序级别提供基本回退水平的好方法。它是您可重用代码编写的第一道防线的好选择。
- en: 14.3.3\. Untestable browser issues
  id: totrans-868
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.3.3. 无法测试的浏览器问题
- en: Unfortunately, JavaScript and the DOM have several possible problem areas that
    are either impossible or prohibitively expensive to test for. These situations
    are fortunately rare, but when we encounter them, it always pays to spend time
    investigating to see whether there’s something we can do about it.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，JavaScript 和 DOM 有几个可能的问题区域，这些区域要么无法测试，要么测试成本过高。这些情况很幸运地很少发生，但当我们遇到它们时，花时间调查看看是否有什么可以做的总是值得的。
- en: The following sections discuss some known issues that are impossible to test
    using any conventional JavaScript interactions.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几节讨论了一些使用任何传统 JavaScript 交互都无法测试的已知问题。
- en: Event handler bindings
  id: totrans-871
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 事件处理器绑定
- en: One of the infuriating lapses in browsers is the inability to programmatically
    determine whether an event handler has been bound. The browsers don’t provide
    any way of determining whether any functions have been bound to an event listener
    on an element. There’s no way to remove all bound event handlers from an element
    unless we’ve maintained references to all bound handlers as we create them.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器中令人恼火的一个缺陷是无法通过编程方式确定事件处理器是否已被绑定。浏览器没有提供任何方法来确定是否有任何函数被绑定到元素的事件监听器上。除非我们在创建时维护了对所有绑定处理器的引用，否则无法从元素中移除所有绑定的事件处理器。
- en: Event firing
  id: totrans-873
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 事件触发
- en: Another aggravation is determining whether an event will fire. Although it’s
    possible to determine whether a browser supports a means of binding an event,
    it’s *not* possible to know whether a browser will fire an event. This becomes
    problematic in a couple of places.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个令人烦恼的问题是确定事件是否会触发。虽然可以确定浏览器是否支持绑定事件的方法，但无法知道浏览器是否会触发事件。这会在几个地方造成问题。
- en: First, if a script is loaded dynamically after the page has already loaded,
    the script may try to bind a listener to wait for the window to load when, in
    fact, that event already happened. Because there’s no way to determine whether
    the event has already occurred, the code may wind up waiting forever to execute.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果脚本在页面已经加载后动态加载，脚本可能会尝试绑定一个监听器等待窗口加载，但实际上那个事件已经发生了。由于无法确定事件是否已经发生，代码可能会无限期地等待执行。
- en: The second situation occurs if a script wants to use custom events provided
    by a browser as an alternative. For example, Internet Explorer provides `mouseenter`
    and `mouseleave` events, which simplify the process of determining when a user’s
    mouse enters or leaves an element’s boundaries. These are frequently used as alternatives
    to the `mouseover` and `mouseout` events, because they act slightly more intuitively
    than the standard events. But because there’s no way of determining whether these
    events will fire without first binding the events and waiting for a user interaction
    against them, it’s hard to use them in reusable code.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况发生在脚本想要使用浏览器提供的自定义事件作为替代时。例如，Internet Explorer提供了`mouseenter`和`mouseleave`事件，这些事件简化了确定用户鼠标进入或离开元素边界的过程。这些事件经常被用作`mouseover`和`mouseout`事件的替代，因为它们比标准事件更直观。但由于没有方法在绑定事件并等待用户交互之前确定这些事件是否会触发，所以在可重用代码中使用它们很困难。
- en: CSS property effects
  id: totrans-877
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: CSS属性效果
- en: Yet another pain point is determining whether changing certain CSS properties
    affects the presentation. Some CSS properties affect only the visual representation
    of the display and nothing else; they don’t change surrounding elements or affect
    other properties on the element. Examples are `color`, `backgroundColor`, and
    `opacity`.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个痛点是确定更改某些CSS属性是否会影响显示效果。一些CSS属性仅影响显示的视觉表示，而不影响其他任何内容；它们不会改变周围的元素或影响元素上的其他属性。例如，`color`、`backgroundColor`和`opacity`。
- en: There’s no way to programmatically determine whether changing these style properties
    will generate the effects desired. The only way to verify the impact is through
    a visual examination of the page.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 没有方法可以通过编程方式确定更改这些样式属性是否会生成期望的效果。验证影响的唯一方法是通过页面的视觉检查。
- en: Browser crashes
  id: totrans-880
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 浏览器崩溃
- en: Testing script that causes the browser to crash is another annoyance. Code that
    causes a browser to crash is especially problematic, because unlike exceptions
    that can be easily caught and handled, these will always cause the browser to
    break.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 测试导致浏览器崩溃的脚本又是一个烦恼。导致浏览器崩溃的代码特别有问题，因为与可以轻松捕获和处理异常不同，这些代码将始终导致浏览器崩溃。
- en: 'For example, in older versions of Safari (see [http://bugs.jquery.com/ticket/1331](http://bugs.jquery.com/ticket/1331)),
    creating a regular expression that used Unicode-character ranges would always
    cause the browser to crash, as in the following example:'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Safari的旧版本中（见[http://bugs.jquery.com/ticket/1331](http://bugs.jquery.com/ticket/1331)），创建一个使用Unicode字符范围的正则表达式将始终导致浏览器崩溃，如下面的示例所示：
- en: '[PRE58]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The problem with this is that it’s not possible to test whether this problem
    exists, because the test itself will always produce a crash in that older browser.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的麻烦在于，无法测试这个问题是否存在，因为测试本身将始终在旧浏览器中产生崩溃。
- en: Additionally, bugs that cause crashes to occur forever become embroiled in difficulty,
    because although it may be acceptable for JavaScript to be disabled in some segment
    of the population using your browser, it’s never acceptable to outright crash
    the browser of those users.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，那些导致浏览器永久崩溃的bug变得非常棘手，因为尽管对于使用你浏览器的某些用户群体来说禁用JavaScript可能是可以接受的，但直接让这些用户的浏览器崩溃是绝对不可接受的。
- en: Incongruous APIs
  id: totrans-886
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 不一致的API
- en: A while back, we saw that jQuery decided to disallow the ability to change the
    `type` attribute in all browsers because of a bug in Internet Explorer. We *could*
    test this feature and disable it only in IE, but that would set up an incongruity,
    as the API would work differently from browser to browser. In these situations,
    when a bug is so bad that it causes an API to break, the only option is to work
    around the affected area and provide a different solution.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 一段时间前，我们看到了jQuery决定禁止在所有浏览器中更改`type`属性的能力，这是由于Internet Explorer中的一个bug。我们*可以*测试这个功能，并仅在IE中禁用它，但这会设置一个不一致性，因为API在各个浏览器中的工作方式将不同。在这些情况下，当bug如此严重以至于导致API损坏时，唯一的选择是绕过受影响的区域并提供不同的解决方案。
- en: In addition to impossible-to-test problems, some issues are *possible* to test
    but are prohibitively difficult to test effectively. Let’s look at some of them.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 除了无法测试的问题之外，还有一些问题是*可以*测试的，但测试起来非常困难。让我们看看其中的一些。
- en: API performance
  id: totrans-889
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: API性能
- en: Sometimes specific APIs are faster or slower in different browsers. When writing
    reusable and robust code, it’s important to try to use the APIs that provide good
    performance. But it’s not always obvious which API that is.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，特定的API在不同的浏览器中可能更快或更慢。在编写可重用和健壮的代码时，尝试使用提供良好性能的API很重要。但并不总是明显知道哪个API是正确的。
- en: Effectively conducting performance analysis of a feature usually entails throwing
    a large amount of data at it, and that typically takes a relatively long time.
    Therefore, it’s not something we can do whenever our page is loaded.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 对一个功能进行有效的性能分析通常意味着向其投入大量数据，这通常需要相对较长的时间。因此，这不是我们可以在页面加载时随时进行的事情。
- en: Untestable features are a significant hassle that hinder writing reusable JavaScript,
    but frequently we can work around them with a bit of effort and cleverness. By
    using alternative techniques, or constructing our APIs so as to obviate these
    issues in the first place, we’ll likely be able to build effective code despite
    the odds stacked against us.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 无法测试的特性是编写可重用JavaScript的一个重大麻烦，但通常我们可以通过一些努力和巧妙的方法来绕过它们。通过使用替代技术，或者构建我们的API以消除这些问题，我们可能会在不利的情况下构建出有效的代码。
- en: 14.4\. Reducing assumptions
  id: totrans-893
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.4. 减少假设
- en: Writing cross-browser, reusable code is a battle of assumptions, but by using
    clever detection and authoring, we can reduce the number of assumptions that we
    make in our code. When we make assumptions about the code that we write, we stand
    to encounter problems further down the road.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 编写跨浏览器、可重用的代码是一场假设的战斗，但通过使用巧妙的检测和编写，我们可以减少我们在代码中做出的假设数量。当我们对我们编写的代码做出假设时，我们可能会在未来的道路上遇到问题。
- en: For example, assuming that an issue or a bug will always exist in a specific
    browser is a huge and dangerous assumption. Instead, testing for the problem (as
    we’ve done throughout this chapter) proves to be much more effective. In our coding,
    we should always strive to reduce the number of assumptions, effectively reducing
    the room for error and the probability that something is going to come back and
    bite us in the behind.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设一个问题或错误总是存在于特定浏览器中是一个巨大且危险的做法。相反，测试问题（正如我们在本章中一直所做的那样）证明要有效得多。在我们的编码中，我们应该始终努力减少假设的数量，从而有效地减少错误的空间和事情可能反过来咬我们屁股的概率。
- en: The most common area for making assumptions in JavaScript is in user-agent detection—specifically,
    analyzing the user agent provided by a browser (`navigator.userAgent`) and using
    it to make an assumption about how the browser will behave (in other words, browser
    detection). Unfortunately, most user-agent string analysis proves to be a superb
    source of future-induced errors. Assuming that a bug, issue, or proprietary feature
    will always be linked to a specific browser is a recipe for disaster.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，最常见的假设区域是在用户代理检测方面——具体来说，是分析浏览器提供的用户代理（`navigator.userAgent`）并据此做出关于浏览器行为的假设（换句话说，浏览器检测）。不幸的是，大多数用户代理字符串分析都证明是未来错误的一个极好来源。假设一个错误、问题或专有特性总是与特定浏览器相关联，这无疑是一个灾难性的做法。
- en: 'But reality intervenes when it comes to minimizing assumptions: It’s virtually
    impossible to remove all of them. At some point, we’ll have to assume that a browser
    will do what it’s supposed to do. Figuring out where to strike that balance is
    completely up to the developer, and it’s what “separates the men from the boys,”
    as they say (with apologies to our female readers).'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 但在减少假设方面，现实总是介入：几乎不可能完全去除所有假设。在某个时刻，我们不得不假设浏览器会做它应该做的事情。确定如何达到这种平衡完全取决于开发者，这也是他们所说的“区分男人和男孩”的地方（向我们的女性读者致歉）。
- en: 'For example, let’s reexamine the event-attaching code that we’ve already seen
    in this chapter:'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们重新审视本章中已经看到的事件绑定代码：
- en: '[PRE59]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Without looking ahead, see if you can spot three assumptions made by this code.
    Go on, we’ll wait. (*Jeopardy* theme plays...)
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 不看后续内容，看看你是否能找出这段代码中做出的三个假设。继续吧，我们会等待的。（*《危险边缘》主题音乐播放中...）
- en: 'How’d you do? The preceding code has at least these three assumptions:'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 你做得怎么样？前面的代码至少有这三个假设：
- en: The properties that we’re checking are callable functions.
  id: totrans-902
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在检查的是可调用的函数。
- en: They’re the correct functions, performing the actions that we expect.
  id: totrans-903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些是正确的函数，执行我们期望的动作。
- en: These two methods are the only possible ways of binding an event.
  id: totrans-904
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这两种方法是绑定事件的唯一可能方式。
- en: We could easily get rid of the first assumption by adding checks to see whether
    the properties are, in fact, functions. Tackling the remaining two points is much
    more difficult.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加检查来轻松去除第一个假设，看看这些属性实际上是否是函数。解决剩余的两个点要困难得多。
- en: In this code, we always need to decide how many assumptions are optimal for
    our requirements, our target audience, and us. Frequently, reducing the number
    of assumptions also increases the size and complexity of the code base. It’s fully
    possible, and rather easy, to attempt to reduce assumptions to the point of complete
    insanity, but at some point we have to stop and take stock of what we have, say
    “good enough,” and work from there. Remember that even the least-assuming code
    is still prone to regressions introduced by a browser.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们总是需要决定对我们需求、目标受众和我们自己来说最优化的是多少假设。通常，减少假设的数量也会增加代码库的大小和复杂性。试图将假设减少到完全疯狂的程度是完全可能的，而且相当容易，但到了某个时候，我们必须停下来，评估我们所拥有的，说“足够好”，然后从这里开始工作。记住，即使是假设最少的代码也仍然容易受到浏览器引入的回归的影响。
- en: 14.5\. Summary
  id: totrans-907
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.5\. 摘要
- en: Although the situation has improved considerably, browsers unfortunately aren’t
    bug-free and usually don’t support web standards consistently.
  id: totrans-908
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管情况已经大大改善，但不幸的是，浏览器仍然存在错误，并且通常不会一致地支持Web标准。
- en: When writing JavaScript applications, choosing which browsers and platforms
    to support is an important consideration.
  id: totrans-909
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编写JavaScript应用程序时，选择支持哪些浏览器和平台是一个重要的考虑因素。
- en: Because it’s not possible to support all combinations, quality should never
    be sacrificed for coverage!
  id: totrans-910
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于无法支持所有组合，质量永远不应该为了覆盖率而牺牲！
- en: The biggest challenges to writing JavaScript code that can be executed in various
    browsers are bug fixes, regressions, browser bugs, missing features, and external
    code.
  id: totrans-911
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够在各种浏览器中执行的JavaScript代码的最大挑战是错误修复、回归、浏览器错误、缺少功能和外部代码。
- en: 'Reusable cross-browser development involves juggling several factors:'
  id: totrans-912
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可重用跨浏览器开发涉及权衡几个因素：
- en: '***Code size—*** Keeping the file size small'
  id: totrans-913
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***代码大小—*** 保持文件大小小'
- en: '***Performance overhead—*** Keeping the performance level above a palatable
    minimum'
  id: totrans-914
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***性能开销—*** 保持性能水平在可接受的最低限度以上'
- en: '***API quality—*** Making sure that the APIs work uniformly across browsers'
  id: totrans-915
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***API质量—*** 确保API在所有浏览器中都能统一工作'
- en: There’s no magic formula for determining the correct balance of these factors.
  id: totrans-916
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有确定这些因素正确平衡的魔法公式。
- en: The development factors are something that have to be balanced by every developer
    in their individual development efforts.
  id: totrans-917
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发因素是每个开发者在其个人开发工作中必须权衡的东西。
- en: By using smart techniques such as feature detection, we can defend against the
    numerous directions from which reusable code will be attacked without making any
    undue sacrifices.
  id: totrans-918
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用智能技术，如功能检测，我们可以防御来自多个方向的攻击，而无需做出任何不必要的牺牲。
- en: 14.6\. Exercises
  id: totrans-919
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.6\. 练习
- en: '**1**'
  id: totrans-920
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**'
- en: ''
  id: totrans-921
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What should we take into account when deciding which browsers to support?
  id: totrans-922
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 决定支持哪些浏览器时，我们应该考虑哪些因素？
- en: '**2**'
  id: totrans-923
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**'
- en: ''
  id: totrans-924
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explain the problem of greedy IDs.
  id: totrans-925
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解释贪婪ID的问题。
- en: '**3**'
  id: totrans-926
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**'
- en: ''
  id: totrans-927
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is feature detection?
  id: totrans-928
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 功能检测是什么？
- en: '**4**'
  id: totrans-929
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**'
- en: ''
  id: totrans-930
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is a browser polyfill?
  id: totrans-931
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 浏览器polyfill是什么？
