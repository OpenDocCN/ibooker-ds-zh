- en: 13 Filtering data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13 过滤数据
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Cascading state transitions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 级联状态转换
- en: Listening to and intercepting events
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听和拦截事件
- en: Auditing and versioning with Hibernate Envers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Hibernate Envers 进行审计和版本控制
- en: Filtering data dynamically
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态过滤数据
- en: 'In this chapter, we’ll analyze many different strategies for *filtering* data
    as it passes through the Hibernate engine. When Hibernate loads data from the
    database, we can transparently restrict the data seen by the application with
    a filter. When Hibernate stores data in the database, we can listen to the event
    and execute secondary routines: for example, we could write an audit log or assign
    a tenant identifier to a record.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将分析许多不同的策略，用于在数据通过 Hibernate 引擎时进行*过滤*。当 Hibernate 从数据库加载数据时，我们可以通过过滤器透明地限制应用程序看到的数据。当
    Hibernate 将数据存储在数据库中时，我们可以监听事件并执行辅助程序：例如，我们可以编写审计日志或将租户标识符分配给记录。
- en: 'In the four main sections of this chapter, we’ll explore the following data-filtering
    features and APIs:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的四个主要部分中，我们将探讨以下数据过滤功能和 API：
- en: First you’ll learn to react to state changes of an entity instance and *cascade
    the state change* to associated entities. For example, when a `User` is saved,
    Hibernate can transitively and automatically save all related `BillingDetails`.
    When an `Item` is deleted, Hibernate can delete all `Bid` instances associated
    with that `Item`. We can enable this standard JPA feature with special attributes
    in the entity association and collection mappings.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，您将学习如何对实体实例的状态变化做出反应，并将状态变化*级联*到相关实体。例如，当`User`被保存时，Hibernate 可以传递性和自动保存所有相关的`BillingDetails`。当`Item`被删除时，Hibernate
    可以删除与该`Item`相关联的所有`Bid`实例。我们可以通过在实体关联和集合映射中使用特殊属性来启用此标准 JPA 功能。
- en: The Jakarta Persistence standard includes lifecycle *callbacks* and *event listeners*.
    An event listener is a class we write with special methods, called by Hibernate
    when an entity instance changes state, such as after Hibernate loads it or is
    about to delete it from the database. These callback methods can also be on the
    entity classes and marked with special annotations. This gives us an opportunity
    to execute custom side effects when a transition occurs. Hibernate also has several
    proprietary extension points that allow interception of lifecycle events at a
    lower level within its engine.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jakarta Persistence 标准包括生命周期*回调*和*事件监听器*。事件监听器是我们编写的具有特殊方法的类，当实体实例的状态发生变化时（例如，Hibernate
    加载它或即将从数据库中删除它时），Hibernate 会调用这些方法。这些回调方法也可以在实体类上，并带有特殊注解。这为我们提供了一个在状态转换发生时执行自定义副作用的机会。Hibernate
    还具有几个专有扩展点，允许在引擎内部较低级别拦截生命周期事件。
- en: A common side effect is writing an *audit log* ; such a log typically contains
    information about the data that was changed, when the change was made, and who
    made the modification. A more sophisticated auditing system might require storing
    several versions of data and *temporal views*; for example, we might want to ask
    Hibernate to load data “as it was last week.” This being a complex problem, we’ll
    introduce Hibernate Envers, a subproject dedicated to versioning and auditing
    in JPA applications.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个常见的副作用是编写*审计日志*；这样的日志通常包含有关更改的数据、何时进行更改以及谁进行了修改的信息。一个更复杂的审计系统可能需要存储多个数据版本和*时间视图*；例如，我们可能希望要求
    Hibernate 加载数据“就像上周那样。”这是一个复杂的问题，我们将介绍 Hibernate Envers，这是一个专门用于 JPA 应用程序版本控制和审计的子项目。
- en: Finally, we’ll examine *data filters*, which are also available as a proprietary
    Hibernate API. These filters add custom restrictions to SQL `SELECT` statements
    executed by Hibernate. Hence, we can effectively define a custom limited view
    of the data in the application tier. For example, we could apply a filter that
    restricts loaded data by sales region or any other authorization criteria.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将检查*数据过滤器*，这些过滤器也作为专有 Hibernate API 提供。这些过滤器向 Hibernate 执行的 SQL `SELECT`
    语句添加自定义限制。因此，我们可以在应用层有效地定义数据的自定义受限视图。例如，我们可以应用一个过滤器，限制按销售区域或其他授权标准加载的数据。
- en: We’ll start with cascading options for transitive state changes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从用于传递性状态变化的级联选项开始。
- en: Note To be able to execute the examples from the source code, you’ll first need
    to run the Ch13.sql script.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 要能够执行源代码中的示例，您首先需要运行 Ch13.sql 脚本。
- en: 13.1 Cascading state transitions
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.1 级联状态转换
- en: When an entity instance changes state—such as when goes from being *transient*
    to *persistent*—associated entity instances may also be included in this state
    transition. This *cascading* of state transitions isn’t enabled by default; each
    entity instance has an independent lifecycle. But for some associations between
    entities, we may want to implement fine-grained lifecycle dependencies.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当实体实例的状态发生变化——例如从*临时*状态变为*持久*状态时——关联的实体实例也可能包含在这个状态转换中。这种状态转换的*级联*默认情况下是未启用的；每个实体实例都有独立的生命周期。但对于实体之间的某些关联，我们可能希望实现细粒度的生命周期依赖。
- en: For example, in section 8.3 we created an association between the `Item` and
    `Bid` entity classes. In this case, not only did we make the bids of an `Item`
    automatically persistent when they were added to an `Item`, but they were also
    automatically deleted when the owning `Item` was deleted. We effectively made
    `Bid` an entity class that was dependent on another entity, `Item`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在第 8.3 节中，我们创建了 `Item` 和 `Bid` 实体类之间的关联。在这种情况下，不仅当它们被添加到 `Item` 时，`Bid` 的出价会自动持久化，而且当拥有
    `Item` 被删除时，它们也会自动删除。我们实际上使 `Bid` 成为一个依赖于另一个实体 `Item` 的实体类。
- en: The cascading settings we enabled in that association mapping were `CascadeType
    .PERSIST` and `CascadeType.REMOVE`. We also investigated the special `orphanRemoval`
    switch and how cascading deletion at the database level (with the foreign key
    `ON DELETE` option) affects the application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个关联映射中启用的级联设置是 `CascadeType .PERSIST` 和 `CascadeType.REMOVE`。我们还研究了特殊的 `orphanRemoval`
    开关以及数据库级别（使用外键 `ON DELETE` 选项）的级联删除如何影响应用程序。
- en: So we briefly pointed out how we could work with *cascading* state in chapter
    8\. In this section, we’ll analyze some other, rarely used, cascading options.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在第 8 章中简要介绍了如何处理 *级联* 状态。在本节中，我们将分析一些其他较少使用的级联选项。
- en: 13.1.1 Available cascading options
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1.1 可用的级联选项
- en: Table 13.1 summarizes the most important cascading options available in Hibernate.
    Note how each is linked with an `EntityManager` or `Session` operation.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 表 13.1 总结了 Hibernate 中可用的最重要的级联选项。注意每个选项是如何与 `EntityManager` 或 `Session` 操作相关联的。
- en: Table 13.1 Cascading options for entity association mappings
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 表 13.1 实体关联映射的级联选项
- en: '| Option | Description |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 描述 |'
- en: '| `CascadeType.PERSIST` | When an entity instance is stored with `EntityManager
    #persist()`, at flush time any associated entity instances are also made persistent.
    |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `CascadeType.PERSIST` | 当一个实体实例使用 `EntityManager #persist()` 存储时，在刷新时间任何关联的实体实例也会被设置为持久状态。
    |'
- en: '| `CascadeType.REMOVE` | When an entity instance is deleted with `EntityManager
    #remove()`, at flush time any associated entity instances are also removed. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `CascadeType.REMOVE` | 当一个实体实例使用 `EntityManager #remove()` 删除时，在刷新时间任何关联的实体实例也会被删除。
    |'
- en: '| `CascadeType.DETACH` | When an entity instance is evicted from the persistence
    context with `EntityManager#detach()`, any associated entity instances are also
    detached. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `CascadeType.DETACH` | 当一个实体实例使用 `EntityManager#detach()` 从持久上下文中移除时，任何关联的实体实例也会被分离。
    |'
- en: '| `CascadeType.MERGE` | When a transient or detached entity instance is merged
    into a persistence context with `EntityManager#merge()`, any associated transient
    or detached entity instances are also merged. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `CascadeType.MERGE` | 当一个临时或分离的实体实例使用 `EntityManager#merge()` 合并到持久上下文时，任何关联的临时或分离的实体实例也会被合并。
    |'
- en: '| `CascadeType.REFRESH` | When a persistent entity instance is refreshed with
    `EntityManager#refresh()`, any associated persistent entity instances are also
    refreshed. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `CascadeType.REFRESH` | 当一个持久实体实例使用 `EntityManager#refresh()` 刷新时，任何关联的持久实体实例也会被刷新。
    |'
- en: '| `CascadeType.REPLICATE` | When a detached entity instance is copied into
    a database with `Session#replicate()`, any associated detached entity instances
    are also copied. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `CascadeType.REPLICATE` | 当一个分离的实体实例使用 `Session#replicate()` 复制到数据库中时，任何关联的分离实体实例也会被复制。
    |'
- en: '| `CascadeType.ALL` | This is shorthand to enable all cascading options for
    the mapped association. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `CascadeType.ALL` | 这是一个简写，用于启用映射关联的所有级联选项。 |'
- en: There are more cascading options defined in the `org.hibernate.annotations .CascadeType`
    enumeration. Today, though, the only interesting option is `REPLICATE` and the
    `Session#replicate()` operation. All other `Session` operations have a stan-dardized
    equivalent or an alternative on the `EntityManager` API, so we can ignore these
    settings.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `org.hibernate.annotations .CascadeType` 枚举中定义了更多的级联选项。然而，今天唯一有趣的选择是 `REPLICATE`
    和 `Session#replicate()` 操作。所有其他 `Session` 操作都有在 `EntityManager` API 上的标准化等效或替代方案，因此我们可以忽略这些设置。
- en: We’ve already examined the `PERSIST` and `REMOVE` options. Let’s analyze transitive
    detachment, merging, refreshing, and replication.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经检查了 `PERSIST` 和 `REMOVE` 选项。让我们分析传递性分离、合并、刷新和复制。
- en: 13.1.2 Transitive detachment and merging
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1.2 传递性分离和合并
- en: 'We want to retrieve an `Item` and its `bids` from the database and work with
    this data in detached state. The `Bid` class maps this association with a `@ManyToOne`.
    It’s bidirectional with this `@OneToMany` collection mapping in `Item`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望从数据库中检索 `Item` 和其 `bids` 并在分离状态下处理这些数据。`Bid` 类使用 `@ManyToOne` 映射这个关联。它与
    `Item` 中的 `@OneToMany` 集合映射是双向的：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Transitive detachment and merging is enabled with the `DETACH` and `MERGE`
    cascade types. Now we can load the `Item` and initialize its `bids` collection:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 传递性分离和合并通过 `DETACH` 和 `MERGE` 级联类型启用。现在我们可以加载 `Item` 并初始化其 `bids` 集合：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Ⓐ Accessing `item.getBids()` initializes the bids collection (it is lazily initialized).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 访问 `item.getBids()` 初始化了 bids 集合（它是延迟初始化的）。
- en: 'Ⓑ The `EntityManager#detach()` operation is cascaded: it evicts the `Item`
    instance from the persistence context as well as all `bids` in the collection.
    If the `bids` aren’t loaded, they aren’t detached. (Of course, we could have closed
    the persistence context, effectively detaching *all* loaded entity instances.)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ `EntityManager#detach()` 操作是级联的：它将 `Item` 实例以及集合中的所有 `bids` 从持久化上下文中清除。如果
    `bids` 没有被加载，它们不会被分离。（当然，我们也可以关闭持久化上下文，从而有效地分离 *所有* 加载的实体实例。）
- en: 'In detached state, we can change the `Item#name`, create a new `Bid`, and link
    it with the `Item`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在分离状态下，我们可以更改 `Item#name`，创建一个新的 `Bid` 并将其与 `Item` 相关联：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Because we’re working with detached entity state and collections, we have to
    pay extra attention to identity and equality. As discussed in section 10.3, we
    should override the `equals``()` and `hashCode()` methods on the `Bid` entity
    class:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在处理分离的实体状态和集合，我们必须特别注意身份和相等性。如第 10.3 节所述，我们应该在 `Bid` 实体类上重写 `equals()`
    和 `hashCode()` 方法：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Two `Bid` instances are *equal* when they have the same `id`, the same `amount`,
    and are linked with the same `Item`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 `Bid` 实例在它们具有相同的 `id`、相同的 `amount` 以及与相同的 `Item` 相关联时是 *相等的*。
- en: Once we’re done with the modifications in detached state, the next step is to
    store the changes. Using a new persistence context, we can merge the detached
    `Item` and let Hibernate detect the changes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在分离状态下完成修改，下一步就是存储更改。使用一个新的持久化上下文，我们可以合并分离的 `Item` 并让 Hibernate 检测更改。
- en: Using the `merge` method, Hibernate will merge a detached instance. First it
    checks whether the persistence context already contains an entity with the given
    identifier value. If there isn’t any, the entity is loaded from the database.
    Hibernate is smart enough to know that it will also need the referenced entities
    during merging, so it fetches them right away in the same SQL query.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `merge` 方法，Hibernate 将合并一个分离实例。首先，它检查持久化上下文中是否已经包含具有给定标识符值的实体。如果没有，则从数据库中加载实体。Hibernate
    足够智能，知道在合并过程中它还需要引用的实体，因此它会立即在同一 SQL 查询中获取它们。
- en: 'When flushing the persistence context, Hibernate detects whether some property
    of the entity changed during merging. Referenced entities may also be stored:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当刷新持久化上下文时，Hibernate 检测实体在合并过程中是否有某些属性发生变化。引用的实体也可能被存储：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Ⓐ Hibernate merges the detached `item`. There isn’t any `Item` with the given
    identifier value, so the `Item` is loaded from the database. Hibernate fetches
    the `bids` during merging in the same SQL query. Hibernate then copies the detached
    `item` values into the loaded instance, which it returns to us in persistent state.
    The same procedure is applied to every `Bid`, and Hibernate will detect that one
    of the `bids` is new.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ Hibernate 合并了分离的 `item`。没有具有给定标识符值的 `Item`，因此从数据库中加载了 `Item`。Hibernate 在合并过程中通过相同的
    SQL 查询获取 `bids`。然后，Hibernate 将分离的 `item` 值复制到加载的实例中，并将其以持久状态返回给我们。相同的程序应用于每个 `Bid`，Hibernate
    将检测到其中一个 `bids` 是新的。
- en: Ⓑ Hibernate made the new `Bid` persistent during merging. It now has an identifier
    value assigned.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 在合并过程中，Hibernate 使新的 `Bid` 持久化。现在它已经分配了一个标识符值。
- en: Ⓒ When we flush the persistence context, Hibernate detects that the `name` of
    the `Item` changed during merging. The new `Bid` will also be stored.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 当我们刷新持久化上下文时，Hibernate 检测到在合并过程中 `Item` 的 `name` 发生了变化。新的 `Bid` 也将被存储。
- en: Cascaded merging with collections is a powerful feature; consider how much code
    we would have to write without Hibernate to implement this functionality.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用集合进行级联合并是一个强大的功能；考虑如果没有Hibernate，我们需要编写多少代码来实现这个功能。
- en: Eagerly fetching associations when merging
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 合并时积极获取关联
- en: In the final code example in section 13.1.2, we said that Hibernate is smart
    enough to load the `Item#bids` collection when we merge a detached `Item`. Hibernate
    always loads entity associations eagerly with a `JOIN` when merging if `CascadeType.MERGE`
    is enabled for the association. This is smart in the aforementioned case, where
    the `Item#bids` were initialized, detached, and modified. It’s necessary and optimal
    for Hibernate to load the collection when merging with a `JOIN`, but if we merge
    an `Item` instance with an uninitialized `bids` collection or an uninitialized
    `seller` proxy, Hibernate will fetch the collection and proxy with a `JOIN` when
    merging. The merge initializes these associations on the managed `Item` it returns.
    `CascadeType.MERGE` causes Hibernate to ignore and effectively override any `FetchType.LAZY`
    mapping (as allowed by the JPA specification).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在13.1.2节中的最后一个代码示例中，我们说Hibernate足够智能，能够在合并分离的`Item`时加载`Item#bids`集合。当关联启用了`CascadeType.MERGE`时，Hibernate总是积极使用`JOIN`加载实体关联。在上述情况下，这是聪明的，因为`Item#bids`已经被初始化、分离并修改。当使用`JOIN`合并时，加载集合是必要且最优的，但如果我们将一个未初始化的`bids`集合或未初始化的`seller`代理的`Item`实例合并，Hibernate将在合并时使用`JOIN`获取集合和代理。合并初始化返回的管理的`Item`上的这些关联。`CascadeType.MERGE`导致Hibernate忽略并有效地覆盖任何`FetchType.LAZY`映射（如JPA规范允许的）。
- en: Our next example is less sophisticated, enabling cascaded refreshing of related
    entities.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的示例更为简单，允许级联刷新相关实体。
- en: 13.1.3 Cascading refresh
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1.3 级联刷新
- en: 'The `User` entity class has a one-to-many relationship with `BillingDetails`:
    each user of the application may have several credit cards, bank accounts, and
    so on. If you would like to review the `BillingDetails` class, take a look at
    the mappings in chapter 7.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`实体类与`BillingDetails`存在一对一的关系：应用程序的每个用户可能有几张信用卡、银行账户等。如果您想查看`BillingDetails`类，请查看第7章中的映射。'
- en: 'We can map the relationship between `User` and `BillingDetails` as a unidirectional
    one-to-many entity association:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`User`和`BillingDetails`之间的关系映射为一个单向的一对多实体关联：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The cascading options enabled for this association are `PERSIST` and `REFRESH`.
    The `PERSIST` option simplifies storing billing details; they become persistent
    when we add an instance of `BillingDetails` to the collection of an already persistent
    `User`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为此关联启用的级联选项是`PERSIST`和`REFRESH`。`PERSIST`选项简化了存储账单详情；当我们向已持久化的`User`集合中添加`BillingDetails`实例时，它们变得持久化。
- en: 'The `REFRESH` cascading option ensures that when we reload the state of a `User`
    instance, Hibernate will also refresh the state of each `BillingDetails` instance
    linked to the `User`. For example, when we `refresh()` the managed `User` instance,
    Hibernate cascades the operation to the managed `BillingDetails` and refreshes
    each with an SQL `SELECT`. If none of these instances remain in the database,
    Hibernate throws an `EntityNotFoundException`. Then, Hibernate refreshes the `User`
    instance and eagerly loads the entire `billingDetails` collection to discover
    any new `BillingDetails`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`REFRESH`级联选项确保当我们重新加载`User`实例的状态时，Hibernate也会刷新与`User`关联的每个`BillingDetails`实例的状态。例如，当我们`refresh()`管理的`User`实例时，Hibernate会将操作级联到管理的`BillingDetails`，并使用SQL
    `SELECT`刷新每个实例。如果这些实例中没有任何一个留在数据库中，Hibernate将抛出`EntityNotFoundException`。然后，Hibernate刷新`User`实例，并积极加载整个`billingDetails`集合以发现任何新的`BillingDetails`：'
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Ⓐ An instance of `User` is loaded from the database.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 从数据库中加载`User`实例。
- en: Ⓑ Its lazy `billingDetails` collection is initialized when we iterate through
    the elements or when we call `size()`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 当我们遍历元素或调用`size()`时，它的懒加载`billingDetails`集合会被初始化。
- en: Ⓒ When we `refresh()` the managed `User` instance, Hibernate cascades the operation
    to the managed `BillingDetails` and refreshes each with an SQL `SELECT`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 当我们`refresh()`管理的`User`实例时，Hibernate会将操作级联到管理的`BillingDetails`，并使用SQL `SELECT`刷新每个实例。
- en: This is a case where Hibernate isn’t as smart as it could be. First, it executes
    an SQL `SELECT` for each `BillingDetails` instance that’s in the persistence context
    and referenced by the collection. Then it loads the entire collection again to
    find any added `BillingDetails`. Hibernate could obviously do this with one `SELECT`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 Hibernate 不够聪明的例子。首先，它为持久化上下文中每个由集合引用的 `BillingDetails` 实例执行一个 SQL `SELECT`。然后它再次加载整个集合以查找任何添加的
    `BillingDetails`。Hibernate 显然可以用一个 `SELECT` 来完成这个操作。
- en: 'We would like to refresh the record after it’s modified by another transaction,
    so we have to keep in mind that the default transaction isolation level for MySQL
    is `REPEATABLE_READ`, while for most other databases it is `READ_COMMITTED`. We
    started one transaction and then a second, which committed its changes before
    the first one performed the refresh operation. For the first transaction to be
    able to see the changes from the second, we need to change the isolation level
    on the JDBC driver. That is why we provided the following configuration URL:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在另一个事务修改记录后刷新记录，因此我们必须记住 MySQL 的默认事务隔离级别是 `REPEATABLE_READ`，而大多数其他数据库是 `READ_COMMITTED`。我们启动了一个事务，然后启动了第二个事务，在第一个事务执行刷新操作之前，第二个事务提交了其更改。为了使第一个事务能够看到第二个事务的更改，我们需要更改
    JDBC 驱动程序上的隔离级别。这就是为什么我们提供了以下配置 URL：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As the change is made only at the configuration level, the code will continue
    to work correctly using different databases, as long as the persistence.xml file
    contains the correct configuration.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于更改仅限于配置级别，只要 `persistence.xml` 文件包含正确的配置，代码将继续在不同的数据库上正确工作。
- en: The last cascading option is for the Hibernate-only `replicate()` operation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的级联选项是针对仅Hibernate的 `replicate()` 操作。
- en: 13.1.4 Cascading replication
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1.4 级联复制
- en: We first examined replication in section 10.2.7\. This nonstandard operation
    is available on the Hibernate `Session` API. Its main use case is copying data
    from one database into another.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 10.2.7 节中首先检查了复制。这个非标准操作在 Hibernate `Session` API 中可用。其主要用例是将数据从一个数据库复制到另一个数据库。
- en: 'Consider this many-to-one entity association mapping between `Item` and `User`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑 `Item` 和 `User` 之间的多对一实体关联映射：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here we enable the `REPLICATE` cascading option with a Hibernate annotation.
    Next, we’ll load an `Item` and its `seller` from the source database:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 Hibernate 注解启用 `REPLICATE` 级联选项。接下来，我们将从源数据库加载 `Item` 和其 `seller`：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Ⓐ Initialize `Item#seller` lazily.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 懒加载 `Item#seller`。
- en: 'After we close the persistence context, the `Item` and the `User` entity instances
    are in detached state. Next, we connect to the database and write the detached
    data:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们关闭持久化上下文后，`Item` 和 `User` 实体实例处于分离状态。接下来，我们连接到数据库并写入分离的数据：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When we call `replicate()` on the detached `Item`, Hibernate executes SQL `SELECT`
    statements to find out whether the `Item` and its `seller` are already present
    in the database. Then, on commit, when the persistence context is flushed, Hibernate
    writes the values of the `Item` and the `seller` into the target database. In
    the previous example, these rows were already present, so we’d see an `UPDATE`
    of each, overwriting the values in the database. If the target database doesn’t
    contain the `Item` or `User`, two `INSERT`s are made.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在分离的 `Item` 上调用 `replicate()` 时，Hibernate 执行 SQL `SELECT` 语句以确定 `Item` 和其
    `seller` 是否已经在数据库中存在。然后，在提交时，当持久化上下文被刷新，Hibernate 将 `Item` 和 `seller` 的值写入目标数据库。在先前的例子中，这些行已经存在，因此我们会看到每个的
    `UPDATE` 操作，覆盖数据库中的值。如果目标数据库不包含 `Item` 或 `User`，则进行两个 `INSERT` 操作。
- en: 13.2 Listening to and intercepting events
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2 监听和拦截事件
- en: 'In this section, we’ll analyze three different APIs for custom event listeners
    and persistence lifecycle interceptors available in JPA and Hibernate. They allow
    us to do several things:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将分析 JPA 和 Hibernate 中可用的三个不同的自定义事件监听器和持久化生命周期拦截器的API。它们允许我们做几件事情：
- en: Use the standard JPA lifecycle callback methods and event listeners.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准的 JPA 生命周期回调方法和事件监听器。
- en: Write a proprietary `org.hibernate.Interceptor` and activate it on a `Session`.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个专有的 `org.hibernate.Interceptor` 并在 `Session` 上激活它。
- en: Use extension points of the Hibernate core engine with the `org.hibernate .event`
    service provider interface (SPI).
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Hibernate 核心引擎的扩展点与 `org.hibernate.event` 服务提供程序接口（SPI）。
- en: Let’s start with the standard JPA callbacks. They offer easy access to persist,
    load, and remove lifecycle events.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从标准的 JPA 回调开始。它们提供了对持久化、加载和删除生命周期事件的简单访问。
- en: 13.2.1 JPA event listeners and callbacks
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.1 JPA 事件监听器和回调
- en: Let’s say we want to log a message whenever a new entity instance is stored.
    An entity listener class must have an implicit or explicit public no-argument
    constructor. It doesn’t have to implement any special interfaces. An entity listener
    is stateless; the JPA engine automatically creates and destroys it. This means
    it can be difficult to get more contextual information when we need it, but we’ll
    demonstrate some possibilities.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在存储新的实体实例时记录一条消息。实体监听器类必须有一个隐式或显式的无参数公共构造函数。它不需要实现任何特殊接口。实体监听器是无状态的；JPA引擎会自动创建和销毁它。这意味着当我们需要更多上下文信息时可能会很困难，但我们将演示一些可能性。
- en: First we’ll write a lifecycle event listener with a callback method, annotated
    with `@PostPersist`, as shown in the following listing. We can annotate any method
    of an entity listener class as a callback method for persistence lifecycle events.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将编写一个生命周期事件监听器，其中包含一个带有`@PostPersist`注解的回调方法，如下所示。我们可以将实体监听器类的任何方法注解为持久化生命周期事件的回调方法。
- en: Listing 13.1 Notifying an admin when an entity instance was stored
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.1 当实体实例被存储时通知管理员
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Ⓐ The `logMessage()` method, annotated with `@PostPersist`, is invoked after
    a new entity instance is stored in the database.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 带有`@PostPersist`注解的`logMessage()`方法，在新的实体实例存储到数据库后会被调用。
- en: Ⓑ We want the contextual information of the currently logged-in user and access
    to log information. A primitive solution is to use thread-local variables and
    singletons; the source for `CurrentUser` and `Log` is in the example code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 我们需要当前登录用户的上下文信息和访问日志信息。一个原始的解决方案是使用线程局部变量和单例；`CurrentUser`和`Log`的来源在示例代码中。
- en: 'A callback method of an entity listener class has a single `Object` parameter:
    the entity instance involved in the state change. If we only enable the callback
    for a particular entity type, we may declare the argument as that specific type.
    The callback method can have any kind of access; it doesn’t have to be public.
    It must not be static or final and return nothing. If a callback method throws
    an unchecked `RuntimeException`, Hibernate will abort the operation and mark the
    current transaction for rollback. If a callback method declares and throws a checked
    `Exception`, Hibernate will wrap and treat it as a `RuntimeException`.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 实体监听器类的回调方法有一个单一的`Object`参数：参与状态变化的实体实例。如果我们只为特定实体类型启用回调，我们可以声明该参数为该特定类型。回调方法可以有任何类型的访问权限；它不必是公开的。它不能是静态的或最终的，并且不返回任何值。如果回调方法抛出未检查的`RuntimeException`，Hibernate将中止操作并将当前事务标记为回滚。如果回调方法声明并抛出检查的`Exception`，Hibernate将将其包装并作为`RuntimeException`处理。
- en: We can only use each callback annotation once in an entity listener class; that
    is, only one method may be annotated `@PostPersist`. Table 13.2 summarizes all
    the available callback annotations.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能在实体监听器类中使用每个回调注解一次；也就是说，只能有一个方法被注解为`@PostPersist`。表13.2总结了所有可用的回调注解。
- en: Table 13.2 Lifecycle callback annotations
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 表13.2 生命周期回调注解
- en: '| Annotation | Description |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 注解 | 描述 |'
- en: '| `@PostLoad` | Triggered after an entity instance is loaded into the persistence
    context, either by identifier lookup, through navigation and proxy/collection
    initialization, or with a query. Also called after refreshing an already-persistent
    instance. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `@PostLoad` | 在实体实例被加载到持久化上下文之后触发，无论是通过标识符查找、通过导航和代理/集合初始化，还是通过查询。在刷新已持久化的实例后也会触发。|'
- en: '| `@PrePersist` | Called immediately when `persist()` is called on an entity
    instance. Also called for `merge()` when an entity is discovered as transient,
    after the transient state is copied into a persistent instance. Also called for
    associated entities if we enable `CascadeType.PERSIST`. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `@PrePersist` | 在对实体实例调用`persist()`时立即调用。如果实体被发现为瞬态，并且在瞬态状态被复制到持久实例之后调用`merge()`，也会调用。如果我们启用了`CascadeType.PERSIST`，也会为关联实体调用。|'
- en: '| `@PostPersist` | Called after the database operation for making an entity
    instance persistent is executed and an identifier value is assigned. This may
    be when `persist()` or `merge()` is invoked, or later when the persistence context
    is flushed if the identifier generator is pre-insert (see section 5.2.5). Also
    called for associated entities if we enable `CascadeType.PERSIST`. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `@PostPersist` | 在执行使实体实例持久化的数据库操作并分配标识符值之后调用。这可能是在调用`persist()`或`merge()`时，或者在持久化上下文刷新时（如果标识符生成器是预插入的，见第5.2.5节）。如果启用了`CascadeType.PERSIST`，也会为关联实体调用。|'
- en: '| `@PreUpdate`, `@PostUpdate` | Executed before and after the persistence context
    is synchronized with the database; that is, before and after flushing. Triggered
    only when the state of the entity requires synchronization (for example, because
    it’s considered dirty). |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `@PreUpdate`, `@PostUpdate` | 在持久化上下文与数据库同步之前和之后执行；即，在刷新之前和之后。仅在实体状态需要同步时触发（例如，因为它被认为是脏的）。|'
- en: '| `@PreRemove`, `@PostRemove` | Triggered when `remove()` is called or the
    entity instance is removed by cascading, and after deletion of the record in the
    database when the persistence context is flushed. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `@PreRemove`, `@PostRemove` | 在调用`remove()`或实体实例通过级联被移除时触发，以及在持久化上下文刷新后数据库中记录的删除操作之后。|'
- en: 'An entity listener class must be enabled for any entity we’d like to intercept,
    such as this `Item`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 实体监听器类必须对任何我们想要拦截的实体启用，例如这个`Item`：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `@EntityListeners` annotation accepts an array of listener classes if we
    have several interceptors. If several listeners define callback methods for the
    same event, Hibernate invokes the listeners in the declared order.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`@EntityListeners`注解接受一个监听器类数组，如果我们有多个拦截器。如果有多个监听器为同一事件定义了回调方法，Hibernate将按声明的顺序调用监听器。'
- en: 'We don’t have to write a separate entity listener class to intercept lifecycle
    events. We can, for example, implement the `logMessage()` method on the `User`
    entity class:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要编写一个单独的实体监听器类来拦截生命周期事件。例如，我们可以在`User`实体类上实现`logMessage()`方法：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note that callback methods on an entity class don’t have any arguments: the
    “current” entity involved in the state changes is `this`. Duplicate callbacks
    for the same event aren’t allowed in a single class, but we can intercept the
    same event with callback methods in several listener classes or in a listener
    and an entity class.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，实体类上的回调方法没有任何参数：参与状态变化的“当前”实体是`this`。在单个类中不允许对同一事件进行重复回调，但我们可以通过多个监听器类或监听器和实体类中的回调方法来拦截同一事件。
- en: 'We can also add callback methods on an entity superclass for the entire hierarchy.
    If, for a particular entity subclass, we want to disable the superclass’s callbacks,
    we can annotate the subclass with `@ExcludeSuperclassListeners`. If we want to
    disable a default entity listener for a particular entity, we can mark it with
    the `@ExcludeDefaultListeners` annotation:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为整个层次结构中的实体超类添加回调方法。如果我们想禁用特定实体子类的超类回调，我们可以用`@ExcludeSuperclassListeners`注解该子类。如果我们想禁用特定实体的默认实体监听器，我们可以用`@ExcludeDefaultListeners`注解标记它：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'JPA event listeners and callbacks provide a rudimentary framework for reacting
    to lifecycle events with our own procedures. Hibernate also has a more fine-grained
    and powerful alternative API: `org.hibernate.Interceptor`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: JPA事件监听器和回调提供了一个基本的框架，用于使用我们自己的程序来响应生命周期事件。Hibernate还有一个更细粒度和更强大的替代API：`org.hibernate.Interceptor`。
- en: 13.2.2 Implementing Hibernate interceptors
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.2 实现Hibernate拦截器
- en: Let’s assume that we want to write an audit log of data modifications in a separate
    database table. For example, we may want to record information about creation
    and update events for each `Item`. The audit log includes the user, the date and
    time of the event, what type of event occurred, and the identifier of the `Item`
    that was changed.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在单独的数据库表中记录数据修改的审计日志。例如，我们可能想记录每个`Item`的创建和更新事件的信息。审计日志包括用户、事件的时间和日期、发生的事件类型以及被更改的`Item`的标识符。
- en: Audit logs are often handled using database triggers. On the other hand, it’s
    sometimes better for the application to take responsibility, especially if portability
    between different databases is required.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 审计日志通常使用数据库触发器来处理。另一方面，有时让应用程序负责会更好，特别是如果需要在不同的数据库之间进行移植时。
- en: We need several elements to implement audit logging. First, we have to mark
    the entity classes for which we want to enable audit logging. Next, we define
    what information to log, such as the user, date, time, and type of modification.
    Finally, we’ll tie it all together with an `org.hibernate.Interceptor` that automatically
    creates the audit trail.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要几个元素来实现审计日志。首先，我们必须标记我们想要启用审计日志的实体类。接下来，我们定义要记录的信息，例如用户、日期、时间和修改类型。最后，我们将所有这些通过一个自动创建审计跟踪的`org.hibernate.Interceptor`结合起来。
- en: 'First we’ll create a marker interface, `Auditable`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个标记接口，`Auditable`：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This interface requires that a persistent entity class exposes its identifier
    with a getter method; we need this property to log the audit trail. Enabling audit
    logging for a particular persistent class is then trivial. We add it to the class
    declaration, such as for `Item`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口要求持久化实体类通过getter方法公开其标识符；我们需要这个属性来记录审计跟踪。为特定的持久化类启用审计日志记录是微不足道的。我们将它添加到类声明中，例如对于`Item`：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we can create a new persistent entity class, `AuditLogRecord`, with the
    information we want to log in the audit database table:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个新的持久化实体类，`AuditLogRecord`，其中包含我们想要在审计数据库表中记录的信息：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We want to store an instance of `AuditLogRecord` whenever Hibernate inserts
    or updates an `Item` in the database. A Hibernate interceptor can handle this
    automatically. Instead of implementing all methods in `org.hibernate.Interceptor`,
    we extend the `EmptyInterceptor` and override only the methods we need, as demonstrated
    in listing 13.2\. We need to access the database to write the audit log, so the
    interceptor needs a Hibernate `Session`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在Hibernate在数据库中插入或更新`Item`时存储`AuditLogRecord`的实例。Hibernate拦截器可以自动处理此操作。我们不需要在`org.hibernate.Interceptor`中实现所有方法，而是扩展`EmptyInterceptor`并仅覆盖我们需要的那些方法，如列表13.2所示。我们需要访问数据库来写入审计日志，因此拦截器需要一个Hibernate
    `Session`。
- en: We’ll also want to store the identifier of the currently logged-in user in each
    audit log record. The `inserts` and `updates` instance variables that we’ll declare
    will be collections where this interceptor will hold its internal state.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望在每条审计日志记录中存储当前登录用户的标识符。我们将声明的`inserts`和`updates`实例变量将是这个拦截器存储其内部状态集合的地方。
- en: Listing 13.2 Hibernate interceptor logging modification events
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.2 Hibernate拦截器记录修改事件
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Ⓐ This method is called when an entity instance is made persistent.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 当实体实例被持久化时，将调用此方法。
- en: Ⓑ The `state` was not modified.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 状态没有被修改。
- en: Ⓒ This method is called when an entity instance is detected as dirty during
    flushing of the persistence context.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 当在持久化上下文刷新期间检测到实体实例为脏时，将调用此方法。
- en: Ⓓ The `currentState` was not modified.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 当前状态`currentState`没有被修改。
- en: The interceptor collects the modified `Auditable` instances in `inserts` and
    `updates`. Note that in `onSave()`, there may not be an identifier value assigned
    to the given entity instance. Hibernate guarantees to set entity identifiers during
    flushing, so the actual audit log trail is written in the `postFlush()` callback,
    which isn’t shown in listing 13.2\. This method is called after the flushing of
    the persistence context is complete.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截器收集`inserts`和`updates`中的修改`Auditable`实例。请注意，在`onSave()`中，可能没有分配标识符值给给定的实体实例。Hibernate保证在刷新期间设置实体标识符，因此实际的审计日志轨迹是在`postFlush()`回调中编写的，该回调在列表13.2中没有显示。此方法在持久化上下文刷新完成后被调用。
- en: 'Now we’ll write the audit log records for all insertions and updates we collected
    earlier:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写我们之前收集的所有插入和更新的审计日志记录：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Ⓐ We can’t access the original persistence context—the `Session` that is currently
    executing this interceptor. The `Session` is in a fragile state during interceptor
    calls. Hibernate lets us create a new `Session` that inherits some information
    from the original `Session` with the `sessionWithOptions()` method. The new temporary
    `Session` works with the same transaction and database connection as the original
    `Session`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 我们无法访问原始持久化上下文——当前执行此拦截器的`Session`。在拦截器调用期间，`Session`处于脆弱状态。Hibernate允许我们使用`sessionWithOptions()`方法创建一个新的`Session`，该`Session`从原始`Session`继承一些信息。新的临时`Session`与原始`Session`使用相同的事务和数据库连接。
- en: Ⓑ We store a new `AuditLogRecord` for each insertion and update using the temporary
    `Session`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 我们使用临时`Session`为每个插入和更新存储一个新的`AuditLogRecord`。
- en: Ⓒ We flush and close the temporary `Session` independently of the original `Session`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 我们独立于原始`Session`刷新和关闭临时`Session`。
- en: 'We’re now ready to enable this interceptor:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以启用此拦截器：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Enabling default interceptors
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 启用默认拦截器
- en: If we want to enable an interceptor by default for any `EntityManager`, we can
    set the `hibernate.ejb.interceptor` property in persistence.xml to a class that
    implements `org.hibernate.Interceptor`. Note that, unlike a session-scoped interceptor,
    Hibernate shares this default interceptor, so it must be thread-safe! The example
    `AuditLogInterceptor` is *not* thread-safe.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要为任何`EntityManager`默认启用拦截器，我们可以将`hibernate.ejb.interceptor`属性在persistence.xml中设置为一个实现`org.hibernate.Interceptor`的类。请注意，与会话作用域的拦截器不同，Hibernate共享这个默认拦截器，因此它必须是线程安全的！示例`AuditLogInterceptor`不是线程安全的。
- en: 'This `Session` now has an enabled `AuditLogInterceptor`, but the interceptor
    must also be configured with the current `Session` and logged-in user identifier.
    This involves some typecasts to access the Hibernate API:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个`Session`已经启用了`AuditLogInterceptor`，但拦截器还必须配置为当前的`Session`和登录用户标识符。这涉及到一些类型转换以访问Hibernate
    API：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `Session` is now ready for use, and an audit trail will be written whenever
    we store or modify an `Item` instance with it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Session`已经准备好使用，并且每次我们使用它存储或修改`Item`实例时，都会写入一个审计跟踪。
- en: Hibernate interceptors are flexible, and, unlike JPA event listeners and callback
    methods, we have access to much more contextual information when an event occurs.
    Having said that, Hibernate allows us to hook even deeper into its core with the
    extensible event system it’s based on.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate拦截器是灵活的，并且与JPA事件监听器和回调方法不同，当事件发生时，我们能够访问更多上下文信息。话虽如此，Hibernate允许我们通过其基于可扩展事件系统的核心事件系统进一步深入。
- en: 13.2.3 The core event system
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.3 核心事件系统
- en: The Hibernate core engine is based on a model of events and listeners. For example,
    if Hibernate needs to save an entity instance, it triggers an event. Whoever listens
    to this kind of event can catch it and handle saving the data. Hibernate, therefore,
    implements all of its core functionality as a set of default listeners, which
    can handle all Hibernate events.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate的核心引擎基于事件和监听器的模型。例如，如果Hibernate需要保存一个实体实例，它会触发一个事件。任何监听此类事件的人都可以捕获它并处理数据的保存。因此，Hibernate通过一组默认监听器实现了其所有核心功能，这些监听器可以处理所有Hibernate事件。
- en: 'Hibernate is open by design: we can write and enable our own listeners for
    Hibernate events. We can either replace the existing default listeners or extend
    them and execute a side effect or additional procedure. Replacing the event listeners
    is rare; doing so implies that our own listener implementation can take care of
    a piece of Hibernate’s core functionality.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate的设计是开放的：我们可以为Hibernate事件编写和启用自己的监听器。我们可以替换现有的默认监听器或扩展它们以执行副作用或附加程序。替换事件监听器是罕见的；这样做意味着我们的监听器实现可以处理Hibernate的核心功能的一部分。
- en: Essentially, all the methods of the `Session` interface (and its narrower cousin,
    the `EntityManager`) correlate to an event. The `find``()` and `load()` methods
    trigger a `LoadEvent`, and by default this event is processed with the `DefaultLoadEventListener`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，`Session`接口（及其更窄的表亲`EntityManager`）的所有方法都与一个事件相关联。`find()`和`load()`方法触发一个`LoadEvent`，默认情况下，此事件由`DefaultLoadEventListener`处理。
- en: A custom listener should implement the appropriate interface for the event it
    wants to process and/or extend one of the convenience base classes provided by
    Hibernate, or any of the default event listeners. Here’s an example of a custom
    load event listener.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义监听器应实现它想要处理的事件的适当接口，并/或扩展Hibernate提供的便利基类之一，或任何默认事件监听器。以下是一个自定义加载事件监听器的示例。
- en: Listing 13.3 Custom load event listener
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.3 自定义加载事件监听器
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This listener performs custom authorization code. A listener should be considered
    effectively a singleton, meaning it’s shared between persistence contexts and
    thus shouldn’t save any transaction-related state as instance variables. For a
    list of all events and listener interfaces in native Hibernate, see the API Javadoc
    of the `org.hibernate .event` package.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此监听器执行自定义授权代码。应将监听器视为一个单例，这意味着它在持久化上下文中是共享的，因此不应将任何与事务相关的状态作为实例变量保存。有关原生Hibernate中所有事件和监听器接口的列表，请参阅`org.hibernate.event`包的API
    Javadoc。
- en: 'We enable listeners for each core event in persistence.xml:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在persistence.xml中为每个核心事件启用了监听器：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The property name of the configuration settings always starts with `hibernate.ejb
    .event`, followed by the type of event we want to listen to. You can find a list
    of all event types in `org.hibernate.event.spi.EventType`. The value of the property
    can be a comma-separated list of listener class names; Hibernate will call each
    listener in the specified order.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 配置设置的属性名始终以`hibernate.ejb.event`开头，后面跟着我们想要监听的事件类型。您可以在`org.hibernate.event.spi.EventType`中找到所有事件类型的列表。属性的值可以是一个以逗号分隔的监听器类名列表；Hibernate将按指定顺序调用每个监听器。
- en: We rarely have to extend the Hibernate core event system with our own functionality.
    Most of the time, an `org.hibernate.Interceptor` is flexible enough. However,
    it helps to have more options and to be able to replace any piece of the Hibernate
    core engine in a modular fashion.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很少需要扩展Hibernate核心事件系统以添加自己的功能。大多数时候，`org.hibernate.Interceptor`足够灵活。然而，拥有更多选项并且能够以模块化方式替换Hibernate核心引擎的任何部分是有帮助的。
- en: The audit-logging implementation we demonstrated in the previous section was
    very simple. If we needed to log more information for auditing, such as the actually
    changed property values of an entity, we would consider Hibernate Envers.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中我们展示的审计日志实现非常简单。如果我们需要为审计记录更多信息，例如实体的实际更改属性值，我们会考虑使用Hibernate Envers。
- en: 13.3 Auditing and versioning with Hibernate Envers
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3 使用Hibernate Envers进行审计和版本控制
- en: Envers is a project of the Hibernate suite dedicated to audit logging and keeping
    multiple versions of data in the database. This is similar to version control
    systems you may already be familiar with, such as Subversion and Git.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Envers是Hibernate套件中的一个项目，专注于审计日志和保留数据库中的多个数据版本。这与你可能已经熟悉的版本控制系统类似，例如Subversion和Git。
- en: With Envers enabled, a copy of the data is automatically stored in separate
    database tables when we add, modify, or delete data in the main tables of the
    application. Envers internally uses the Hibernate event SPI you saw in the previous
    section. Envers listens to Hibernate events, and when Hibernate stores changes
    in the database, Envers creates a copy of the data and logs a revision in its
    own tables.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 启用Envers后，当我们向应用程序的主要表中添加、修改或删除数据时，数据的一个副本将自动存储在单独的数据库表中。Envers内部使用你在上一节中看到的Hibernate事件SPI。Envers监听Hibernate事件，当Hibernate在数据库中存储更改时，Envers会创建数据的一个副本并在其自己的表中记录一个修订。
- en: Envers groups all data modifications in a unit of work—that is, in a transaction—as
    a change set with a revision number. We can write queries with the Envers API
    to retrieve historical data, given a revision number or timestamp; for example,
    “find all `Item` instances as they were last Friday.”
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Envers将所有数据修改分组在一个工作单元中——即在一个事务中——作为一个带有修订号的更改集。我们可以使用Envers API编写查询以检索历史数据，给定一个修订号或时间戳；例如，“找到上周五所有的`Item`实例。”
- en: Once you enable Envers in your application, you will be able to easily work
    with it, as it is based on annotations. It will provide you with the option to
    keep multiple versions of data in the database with little effort on your part.
    The tradeoff is that it will create a lot of additional tables (but you will be
    able to control which tables you want to audit).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在你的应用程序中启用了Envers，你将能够轻松地与之工作，因为它基于注解。它将为你提供在数据库中轻松保留多个数据版本的选择，而你几乎不需要做任何工作。权衡是它将创建大量的额外表（但你将能够控制你想要审计的表）。
- en: 13.3.1 Enabling audit logging
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3.1 启用审计日志
- en: Envers is available without further configuration as soon as we put its JAR
    file on the classpath (we’ll include it as a Maven dependency). We can enable
    audit logging selectively for an entity class with the `@org.hibernate.envers.Audited`
    annotation.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将Envers的JAR文件放在类路径上（我们将将其作为Maven依赖项包含），Envers就可以无需进一步配置即可使用。我们可以通过`@org.hibernate.envers.Audited`注解有选择地为一个实体类启用审计日志。
- en: Listing 13.4 Enabling audit logging for the `Item` entity
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.4 启用`Item`实体的审计日志
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We’ve now enabled audit logging for `Item` instances and all properties of the
    entity. To disable audit logging for a particular property, we can annotate it
    with `@NotAudited`. In this case, Envers ignores the `bids` but audits the `seller`.
    We also have to enable auditing with `@Audited` on the `User` class.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已为`Item`实例及其所有属性启用了审计日志。要禁用特定属性的审计日志，我们可以用`@NotAudited`注解它。在这种情况下，Envers忽略`bids`但审计`seller`。我们还需要在`User`类上启用`@Audited`以启用审计。
- en: Hibernate will now generate (or expect) additional database tables to hold historical
    data for each `Item` and `User`. Figure 13.1 shows the schema for these tables.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate现在将生成（或期望）额外的数据库表来存储每个`Item`和`User`的历史数据。图13.1显示了这些表的架构。
- en: '![](../../OEBPS/Images/CH13_F01_Tudose2.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图13.1 Tudose2](../../OEBPS/Images/CH13_F01_Tudose2.png)'
- en: Figure 13.1 Audit logging tables for the `Item` and `User` entities
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 `Item`和`User`实体的审计日志表
- en: 'The `ITEM_AUD` and `USERS_AUD` tables are where the modification history of
    `Item` and `User` instances is stored. When we modify data and commit a transaction,
    Hibernate inserts a new revision number with a timestamp into the `REVINFO` table.
    Then, for each modified and audited entity instance involved in the change set,
    a copy of its data is stored in the audit tables. Foreign keys on revision number
    columns link the change set together. The `REVTYPE` column holds the type of change:
    whether the entity instance was inserted, updated, or deleted in the transaction.
    Envers never automatically removes any revision information or historical data;
    even after we `remove()` an `Item` instance, we still have its previous versions
    stored in `ITEM_AUD`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`ITEM_AUD`和`USERS_AUD`表是存储`Item`和`User`实例修改历史的地方。当我们修改数据并提交事务时，Hibernate会在`REVINFO`表中插入一个新的版本号和时间戳。然后，对于每个更改集中涉及的修改和审计的实体实例，其数据的一个副本将存储在审计表中。版本号列上的外键将更改集链接在一起。`REVTYPE`列包含更改的类型：实体实例在事务中是插入、更新还是删除。Envers永远不会自动删除任何版本信息或历史数据；即使我们在`remove()`一个`Item`实例之后，我们仍然可以在`ITEM_AUD`中找到其之前的版本。'
- en: Let’s run through some transactions to see how this works.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行一些事务来看看这是如何工作的。
- en: 13.3.2 Creating an audit trail
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3.2 创建审计跟踪
- en: In the following code examples, we’ll look at several transactions involving
    an `Item` and its `seller`, a `User`. We’ll create and store an `Item` and `User`,
    then modify both, and then finally delete the `Item`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码示例中，我们将查看涉及`Item`及其`seller`（卖家）、`User`的几个事务。我们将创建并存储一个`Item`和一个`User`，然后修改这两个实例，最后删除`Item`。
- en: 'You should already be familiar with this code. Envers automatically creates
    an audit trail when we work with the `EntityManager`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经熟悉这段代码。当我们使用`EntityManager`工作时，Envers会自动创建审计跟踪：
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Envers transparently writes the audit trail for this sequence of transactions
    by logging three change sets. To access this historical data, we first have to
    obtain the number of the revision, representing the change set we’d like to access.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Envers通过记录三个更改集来透明地写入此事务序列的审计跟踪。为了访问这些历史数据，我们首先必须获取表示我们想要访问的更改集的版本号。
- en: 13.3.3 Finding revisions
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3.3 查找版本
- en: With the Envers `AuditReader` API, we can find the revision number of each change
    set. The main Envers API is `AuditReader`. It can be accessed with an `EntityManager`.
    Given a timestamp, we can find the revision number of a change set made before
    or on that timestamp. If we don’t have a timestamp, we can get all the revision
    numbers in which a particular audited entity instance was involved.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Envers的`AuditReader` API，我们可以找到每个更改集的版本号。主要的Envers API是`AuditReader`。它可以通过`EntityManager`访问。给定一个时间戳，我们可以找到在该时间戳之前或在该时间戳上做出的更改集的版本号。如果我们没有时间戳，我们可以获取所有涉及特定审计实体实例的版本号。
- en: Listing 13.5 Obtaining the revision numbers of change sets
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.5 获取更改集的版本号
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Ⓐ Access the `AuditReader` Envers API.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 访问Envers的`AuditReader` API。
- en: Ⓑ Find the revision number of a change set made before or on that timestamp.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 查找在给定时间戳之前或在该时间戳上做出的更改集的版本号。
- en: Ⓒ Without a timestamp, this operation finds all change sets where the given
    `Item` was created, modified, or deleted. In our example, we created, modified,
    and then deleted the `Item`. Hence, we have three revisions.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 如果没有时间戳，此操作将找到所有给定`Item`被创建、修改或删除的更改集。在我们的例子中，我们创建了`Item`，然后修改了它，最后删除了它。因此，我们有三个版本。
- en: Ⓓ If we have a revision number, we can get the timestamp when Envers logged
    the change set.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 如果我们有版本号，我们可以获取Envers记录更改集时的日志时间戳。
- en: Ⓔ We created and modified the `User`, so there are two revisions.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 我们创建并修改了`User`，因此有两个版本。
- en: In listing 13.5, we assumed that either we know the (approximate) timestamp
    for a transaction or we have the identifier value of an entity so we can obtain
    its revisions. If we have neither, we may want to explore the audit log with queries.
    This is also useful if we have to show a list of all change sets in the user interface
    of the application.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表13.5中，我们假设我们要么知道事务的（近似）时间戳，要么有实体标识值，这样我们就可以获取其版本。如果我们两者都没有，我们可能想通过查询探索审计日志。如果我们必须在应用程序的用户界面中显示所有更改集的列表，这也很有用。
- en: 'The following code discovers all revisions of the `Item` entity class and loads
    each `Item` version and the audit log information for that change set:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码发现`Item`实体类的所有版本，并加载每个`Item`版本和该更改集的审计日志信息：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Ⓐ If we don’t know the modification timestamps or revision numbers, we can write
    a query with `forRevisionsOfEntity()` to obtain all audit trail details of a particular
    entity.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 如果我们不知道修改时间戳或修订版本号，我们可以使用`forRevisionsOfEntity()`编写查询以获取特定实体的所有审计跟踪详情。
- en: Ⓑ This query returns the audit trail details as a `List` of `Object[]`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 此查询以`List`的`Object[]`形式返回审计跟踪详情。
- en: Ⓒ Each result tuple contains the entity instance for a particular revision,
    the revision details (including revision number and timestamp), as well as the
    revision type.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 每个结果元组包含特定修订版本的实体实例、修订详细信息（包括修订版本号和时间戳），以及修订类型。
- en: Ⓓ The revision type indicates why Envers created the revision—whether the entity
    instance was inserted, modified, or deleted in the database.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 修订类型指示 Envers 创建修订版本的原因——实体实例是否在数据库中插入、修改或删除。
- en: Revision numbers are sequentially incremented; a higher revision number is always
    a more recent version of an entity instance. We now have revision numbers for
    the three change sets in the audit trail, giving us access to historical data.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 修订版本号是顺序递增的；较高的修订版本号总是实体实例的较新版本。我们现在在审计跟踪中有三个更改集的修订版本号，这使我们能够访问历史数据。
- en: 13.3.4 Accessing historical data
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3.4 访问历史数据
- en: With a revision number, we can access different versions of the `Item` and its
    `seller`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用修订版本号，我们可以访问`项目`及其`卖家`的不同版本。
- en: Listing 13.6 Loading historical versions of entity instances
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.6 加载实体实例的历史版本
- en: '[PRE28]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Ⓐ The `find()` method returns an audited entity instance version, given a revision.
    This operation loads the `Item` as it was after creation.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 给定一个修订版本，`find()`方法返回一个经过审计的实体实例版本，此操作加载了创建后的`项目`。
- en: Ⓑ The `seller` of this change set is also retrieved automatically.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 此更改集的`卖家`也会自动检索。
- en: Ⓒ In this revision, the `Item` was deleted, so `find()` returns `null`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 在此修订版本中，`项目`已被删除，因此`find()`返回`null`。
- en: Ⓓ The example didn’t modify the `User` in this revision, so Envers returns its
    closest historical revision.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 示例中在此修订版本中没有修改`用户`，因此 Envers 返回其最接近的历史修订版本。
- en: 'The `AuditReader#find()` operation retrieves only a single entity instance,
    like `EntityManager#find``()`. But the returned entity instances are *not* in
    persistent state: the persistence context doesn’t manage them. If we modify an
    older version of `Item`, Hibernate won’t update the database. Consider the entity
    instances returned by the `AuditReader` API to be detached, or read-only.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuditReader#find()`操作仅检索单个实体实例，类似于`EntityManager#find()`。但返回的实体实例**不是**持久状态：持久上下文不管理它们。如果我们修改`项目`的旧版本，Hibernate
    不会更新数据库。请将`AuditReader` API返回的实体实例视为分离的或只读的。'
- en: '`AuditReader` also has an API for the execution of arbitrary queries, similar
    to the native Hibernate `Criteria` API.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuditReader`还有一个用于执行任意查询的API，类似于原生Hibernate `Criteria` API。'
- en: Listing 13.7 Querying historical entity instances
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.7 查询历史实体实例
- en: '[PRE29]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Ⓐ This query returns `Item` instances restricted to a particular revision and
    change set.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 此查询返回受特定修订版本和更改集限制的`项目`实例。
- en: Ⓑ We can add further restrictions to the query; here the `Item#name` must start
    with “Ba”.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 我们可以进一步限制查询；这里`项目#名称`必须以“Ba”开头。
- en: Ⓒ Restrictions can include entity associations; for example, we’re looking for
    the revision of an `Item` sold by a particular `User`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 限制可以包括实体关联；例如，我们正在寻找由特定`用户`销售的`项目`的修订版本。
- en: Ⓓ We can order query results.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 我们可以排序查询结果。
- en: Ⓔ We can paginate through large results.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 我们可以分页浏览大量结果。
- en: 'Envers supports projection. The following query retrieves only the `Item#name`
    of a particular version:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Envers 支持投影。以下查询仅检索特定版本的`项目#名称`：
- en: '[PRE30]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, we may want to roll back an entity instance to an older version. This
    can be accomplished with the `Session#replicate()` operation and overwriting an
    existing row. The following example loads the `User` instance from the first change
    set and then overwrites the current `User` in the database with the older version:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可能希望将实体实例回滚到较旧版本。这可以通过`Session#replicate()`操作和覆盖现有行来完成。以下示例从第一个更改集加载`用户`实例，然后使用较旧版本覆盖数据库中的当前`用户`：
- en: '[PRE31]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Envers will also track this change as an update in the audit log; it’s just
    another new revision of the `User` instance.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Envers 还会跟踪此更改作为审计日志中的更新；这只是`用户`实例的另一个新修订版本。
- en: Temporal data is a complex subject, and we encourage you to read the Envers
    reference documentation for more information. Adding details to the audit log,
    such as the user who made a change, isn’t difficult. The documentation also shows
    how to configure different tracking strategies and customize the database schema
    used by Envers.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 时间数据是一个复杂的话题，我们鼓励您阅读Envers参考文档以获取更多信息。向审计日志添加详细信息，例如更改的用户，并不困难。文档还展示了如何配置不同的跟踪策略和自定义Envers使用的数据库模式。
- en: Next, imagine that you don’t want to see all the data in the database. For example,
    the currently logged-in application user may not have the rights to see everything.
    Usually, we add a condition to the queries and restrict the results dynamically.
    But this becomes difficult if we have to handle a concern such as security, because
    we’d have to customize most of the queries in the application. We can centralize
    and isolate these restrictions with Hibernate’s dynamic data filters.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，假设你不想看到数据库中的所有数据。例如，当前登录的应用程序用户可能没有查看所有内容的权限。通常，我们会在查询中添加一个条件并动态地限制结果。但是，如果我们必须处理像安全这样的问题，这会变得很困难，因为我们必须定制应用程序中的大多数查询。我们可以使用Hibernate的动态数据过滤器来集中和隔离这些限制。
- en: 13.4 Dynamic data filters
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.4 动态数据过滤器
- en: 'The first use case for dynamic data filtering relates to data security. A `User`
    in CaveatEmptor may have a `ranking` property, which is a simple integer:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 动态数据过滤的第一个用例与数据安全相关。CaveatEmptor中的`User`可能有一个`ranking`属性，它是一个简单的整数：
- en: '[PRE32]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now assume that users can only bid on items that other users offer with an equal
    or lower ranking. In business terms, we may have several groups of users that
    are defined by an arbitrary ranking (a number), and users can trade only with
    people who have the same or a lower ranking.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设用户只能对其他用户提供的具有相同或更低排名的物品进行竞标。从商业角度来说，我们可能有几个由任意排名（一个数字）定义的用户组，并且用户只能与具有相同或更低排名的人进行交易。
- en: To implement this requirement, we’d have to customize all queries that load
    `Item` instances from the database. We’d check whether the `Item#seller` we want
    to load has an equal or lower ranking than the currently logged-in user. Hibernate
    can do this work for us with a dynamic filter.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一要求，我们必须定制所有从数据库加载`Item`实例的查询。我们需要检查我们想要加载的`Item#seller`是否与当前登录用户的排名相同或更低。Hibernate可以用动态过滤器为我们完成这项工作。
- en: 13.4.1 Defining dynamic filters
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4.1 定义动态过滤器
- en: 'First we’ll define our filter with a name and the dynamic runtime parameters
    it accepts. We can place the Hibernate annotation for this definition on any entity
    class of our domain model or in a package-info.java metadata file:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义一个具有名称和它接受的动态运行时参数的过滤器。我们可以将此定义的Hibernate注解放置在我们的领域模型中的任何实体类上或`package-info.java`元数据文件中：
- en: '[PRE33]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This example names this filter `limitByUserRanking`; note that filter names
    must be unique in a persistence unit. It accepts one runtime argument of type
    `int`. If we have several filter definitions, we declare them within `@org.hibernate.annotations
    .FilterDefs`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将此过滤器命名为`limitByUserRanking`；请注意，过滤器名称必须在持久化单元中是唯一的。它接受一个类型为`int`的运行时参数。如果我们有多个过滤器定义，我们可以在`@org.hibernate.annotations.FilterDefs`中声明它们。
- en: The filter is inactive now; nothing indicates that it’s supposed to apply to
    `Item` instances. We must apply and implement the filter on the classes or collections
    we want to filter.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在过滤器处于非活动状态；没有任何指示表明它应该应用于`Item`实例。我们必须在我们想要过滤的类或集合上应用和实现该过滤器。
- en: 13.4.2 Applying a dynamic filter
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4.2 应用动态过滤器
- en: 'We want to apply the defined filter on the `Item` class so that no items are
    visible if the logged-in user doesn’t have the necessary rank:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将定义的过滤器应用于`Item`类，以便如果登录用户没有必要的排名，则没有任何物品可见：
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `condition` in the preceding code is an SQL expression that’s passed through
    directly to the database system, so we can use any SQL operator or function. It
    must evaluate to `true` if a record should pass the filter. In this example, we
    are using a subquery to obtain the `ranking` of the seller of the item. Unqualified
    columns, such as `SELLER_ID`, refer to the table mapped to the entity class. If
    the currently logged-in user’s ranking isn’t greater than or equal to the ranking
    returned by the subquery, the `Item` instance is filtered out. We can apply several
    filters by grouping them in an `@org.hibernate.annotations.Filters`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码中的`condition`是一个直接传递给数据库系统的SQL表达式，因此我们可以使用任何SQL运算符或函数。如果一条记录应该通过过滤器，它必须评估为`true`。在这个例子中，我们使用子查询来获取物品卖家的`ranking`。未命名的列，如`SELLER_ID`，指的是映射到实体类的表。如果当前登录用户的排名不大于或等于子查询返回的排名，则`Item`实例将被过滤掉。我们可以通过在`@org.hibernate.annotations.Filters`中分组来应用多个过滤器。
- en: A defined and applied filter, if enabled for a particular unit of work, filters
    out any `Item` instance that doesn’t pass the condition. Let’s enable it.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为特定的工作单元启用，一个定义并应用的过滤器将过滤掉任何不满足条件的`Item`实例。让我们启用它。
- en: 13.4.3 Enabling a dynamic filter
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4.3 启用动态过滤器
- en: 'We’ve defined a data filter and applied it to a persistent entity class. It’s
    still not filtering anything—it must be enabled and parameterized in the application
    for a particular unit of work, with the `Session` API:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了一个数据过滤器并将其应用于持久化实体类。它仍然没有过滤任何内容——它必须在应用程序中为特定的工作单元启用并参数化，使用`Session`
    API：
- en: '[PRE35]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We enable the filter by name, and the method returns a `Filter` on which we
    set the runtime arguments dynamically. We must set the parameters we’ve defined;
    here it’s set to ranking 0\. This example then filters out `Item`s sold by a `User`
    with a higher ranking in this `Session`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过名称启用过滤器，该方法返回一个`Filter`，我们可以在其中动态设置运行时参数。我们必须设置我们定义的参数；这里设置为排名0。这个例子然后过滤掉由在这个`Session`中排名更高的`User`销售的`Item`。
- en: Other useful methods of the `Filter` are `getFilterDefinition()`, which allows
    us to iterate through the parameter names and types, and `validate()`, which throws
    a `HibernateException` if we forget to set a parameter. We can also set a list
    of arguments with `setParameterList()`; this is mostly useful if our SQL restriction
    contains an expression with a quantifier operator (the `IN` operator, for example).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`Filter`的其他有用方法是`getFilterDefinition()`，它允许我们遍历参数名称和类型，以及`validate()`，如果忘记设置参数，它将抛出`HibernateException`。我们还可以使用`setParameterList()`设置参数列表；这主要在SQL限制包含带有量词运算符的表达式（例如`IN`运算符）时有用。'
- en: 'Now every JPQL or criteria query that we execute on the filtered persistence
    context restricts the returned `Item` instances:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每次我们在过滤的持久化上下文中执行JPQL或标准查询时，都会限制返回的`Item`实例：
- en: '[PRE36]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note how Hibernate dynamically appends the SQL restriction conditions to the
    statement generated.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 注意Hibernate如何动态地将SQL限制条件追加到生成的语句中。
- en: 'When you first experiment with dynamic filters, you’ll most likely run into
    a problem with retrieval by identifier. You might expect that `em.find(Item.class,
    ITEM_ID)` will be filtered as well. This is not the case, though: Hibernate doesn’t
    apply filters to retrieval by identifier operations. One of the reasons is that
    data-filter conditions are SQL fragments, and lookup by identifier may be resolved
    completely in memory in the first-level persistence context cache. Similar reasoning
    applies to filtering of many-to-one or one-to-one associations. If a many-to-one
    association was filtered (for example, by returning `null` if you called `anItem.getSeller()`),
    the multiplicity of the association would change! You won’t know if the item has
    a seller or if you aren’t allowed to see it.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次尝试动态过滤器时，你很可能会遇到通过标识符检索的问题。你可能期望`em.find(Item.class, ITEM_ID)`也会被过滤。但这并不是事实：Hibernate不会将过滤器应用于通过标识符的检索操作。其中一个原因是数据过滤条件是SQL片段，而通过标识符的查找可能在第一级持久化上下文缓存中完全在内存中解决。类似的推理也适用于多对一或一对一的关联过滤。如果一个多对一关联被过滤（例如，如果你调用`anItem.getSeller()`返回`null`），关联的基数会改变！你将不知道项目是否有卖家，或者你是否被允许看到它。
- en: But you can dynamically filter collection access.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可以动态地过滤集合访问。
- en: 13.4.4 Filtering collection access
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4.4 过滤集合访问
- en: 'Until now, calling `someCategory.getItems()` has returned all `Item` instances
    that are referenced by that `Category`. This can be restricted with a filter applied
    to a collection:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，调用`someCategory.getItems()`返回了所有由该`Category`引用的`Item`实例。这可以通过对集合应用过滤器来限制：
- en: '[PRE37]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If we now enable the filter in a `Session`, all iteration through a collection
    of `Category# items` is filtered:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在在`Session`中启用过滤器，那么遍历`Category# items`集合的所有迭代都会被过滤：
- en: '[PRE38]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If the current user’s ranking is 0, only one `Item` is loaded when we access
    the collection. With a ranking of 100, we can see more data:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前用户的排名是0，当我们访问集合时只会加载一个`Item`。排名为100时，我们可以看到更多数据：
- en: '[PRE39]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You probably noticed that the SQL condition for both filter applications is
    the same. If the SQL restriction is the same for all filter applications, we can
    set it as the default condition when we define the filter, so we don’t have to
    repeat it:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，两个过滤器应用的SQL条件是相同的。如果所有过滤器应用的SQL限制都相同，那么我们可以在定义过滤器时将其设置为默认条件，这样我们就不必重复它：
- en: '[PRE40]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: There are many other excellent use cases for dynamic data filters. We’ve seen
    a restriction of data access given an arbitrary security-related condition. This
    can be the user ranking, a particular group the user must belong to, or a role
    the user has been assigned. Data might be stored with a regional code (for example,
    all business contacts of a sales team). Or perhaps each salesperson works only
    on data that covers their region.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 动态数据过滤器有许多其他优秀的用例。我们看到了在任意安全相关条件下对数据访问的限制。这可能包括用户排名、用户必须属于的特定组或用户被分配的角色。数据可能带有区域代码（例如，所有销售团队的商务联系人）。或者也许每个销售人员只处理覆盖他们地区的相关数据。
- en: Summary
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Cascading state transitions are predefined reactions to lifecycle events in
    the persistence engine.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 级联状态转换是持久化引擎中生命周期事件的预定义反应。
- en: 'Cascading provides options: the transitive detachment and merging, the cascading
    refresh and replication.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 级联提供了选项：传递性分离和合并，级联刷新和复制。
- en: You can implement event listeners and interceptors to add custom logic when
    Hibernate loads and stores data.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以实现事件监听器和拦截器，以便在Hibernate加载数据和存储数据时添加自定义逻辑。
- en: You can use Hibernate Envers for audit logging and keeping multiple versions
    of data in the database (like a version control system).
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用Hibernate Envers进行审计日志记录和在数据库中保留多个版本的数据（类似于版本控制系统）。
- en: You can query Envers to retrieve historical data.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用Envers查询历史数据。
- en: You can use dynamic data filters so that Hibernate can automatically append
    arbitrary SQL restrictions to queries it generates.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用动态数据过滤器，这样Hibernate就可以自动将其生成的查询中添加任意SQL限制。
- en: You can define dynamic filters, apply and enable the filters, and filter collection
    access.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以定义动态过滤器，应用和启用过滤器，并过滤集合访问。
