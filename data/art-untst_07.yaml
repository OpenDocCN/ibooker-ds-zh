- en: 5 Isolation frameworks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 隔离框架
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Defining isolation frameworks and how they help
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义隔离框架及其作用
- en: Two main flavors of frameworks
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架的两种主要类型
- en: Faking modules with Jest
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jest 模拟模块
- en: Faking functions with Jest
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jest 模拟函数
- en: Object-oriented fakes with substitute.js
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 substitute.js 的面向对象模拟
- en: In the previous chapters, we looked at writing mocks and stubs manually and
    saw the challenges involved, especially when the interface we’d like to fake requires
    us to create long, error prone, repetitive code. We kept having to declare custom
    variables, create custom functions, or inherit from classes that use those variables
    and basically make things a bit more complicated than they need to be (most of
    the time).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们探讨了手动编写模拟和存根的挑战，特别是当我们想要模拟的接口需要我们创建长、易出错、重复的代码时。我们不得不不断地声明自定义变量、创建自定义函数，或者从使用这些变量的类中继承，从而使事情比必要的更复杂（大多数时候）。
- en: In this chapter, we’ll look at some elegant solutions to these problems in the
    form of an *isolation framework*—a reusable library that can create and configure
    fake objects *at run time*. These objects are referred to as *dynamic stubs* and
    *dynamic mocks*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一些以隔离框架形式出现的优雅解决方案，这是一种可重用的库，可以在运行时创建和配置假对象。这些对象被称为*动态存根*和*动态模拟*。
- en: I call them isolation frameworks because they allow you to isolate the unit
    of work from its dependencies. You’ll find that many resources will refer to them
    as “mocking frameworks,” but I try to avoid that because they can be used for
    both mocks and stubs. In this chapter, we’ll take a look at a few of the JavaScript
    frameworks available and how we can use them in modular, functional, and object-oriented
    designs. You’ll see how you can use such frameworks to test various things and
    to create stubs, mocks, and other interesting things.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我称它们为隔离框架，因为它们允许您将工作单元与其依赖项隔离开来。您会发现许多资源会将它们称为“模拟框架”，但我尽量避免使用这个术语，因为它们可以用于模拟和存根。在本章中，我们将探讨一些可用的JavaScript框架以及我们如何在模块化、函数式和面向对象的设计中使用它们。您将看到如何使用这些框架来测试各种事物，并创建存根、模拟和其他有趣的事物。
- en: But the specific frameworks I’ll present here aren’t the point. While using
    them, you’ll see the values that their APIs promote in your tests (readability,
    maintainability, robust and long-lasting tests, and more), and you’ll find out
    what makes an isolation framework good and, alternatively, what can make it a
    drawback for your tests.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 但我将在下面展示的具体框架并不是重点。在使用它们的过程中，您将看到它们的API在测试中提倡的价值（可读性、可维护性、健壮且持久的测试等），并且您会发现是什么使隔离框架变得出色，以及它可能成为测试的缺点。
- en: 5.1 Defining isolation frameworks
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 定义隔离框架
- en: 'I’ll start with a basic definition that may sound a bit bland, but it needs
    to be generic in order to include the various isolation frameworks out there:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从一个非常基础的定义开始，这个定义可能听起来有点平淡无奇，但为了包括各种隔离框架，它需要具有通用性：
- en: An isolation framework is a set of programmable APIs that allow the dynamic
    creation, configuration, and verification of mocks and stubs, either in object
    or function form. When using an isolation framework, these tasks are often simpler,
    quicker, and produce shorter code than hand-coded mocks and stubs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离框架是一组可编程API，允许以对象或函数形式动态创建、配置和验证模拟和存根。当使用隔离框架时，这些任务通常比手动编写的模拟和存根更简单、更快，并且生成的代码更短。
- en: Isolation frameworks, when used properly, can save developers from the need
    to write repetitive code to assert or simulate object interactions, and if applied
    in the right places, they can help make tests last many years without requiring
    a developer to come back and fix them after every little production code change.
    If they’re applied badly, they can cause confusion and full-on abuse of these
    frameworks, to the point where we either can’t read or can’t trust our own tests,
    so be wary. I’ll discuss some dos and don’ts in part 3 of this book.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正确使用隔离框架可以节省开发者编写重复代码以断言或模拟对象交互的需求，如果应用得当，它们可以帮助测试持续多年而无需开发者每次进行微小的生产代码更改后回来修复。如果应用不当，它们可能导致混淆和完全滥用这些框架，以至于我们无法阅读或信任自己的测试，因此要小心。我将在本书的第三部分讨论一些应该做和不应该做的事情。
- en: '5.1.1 Choosing a flavor: Loose vs. typed'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.1 选择一种类型：松散型与类型化
- en: 'Because JavaScript supports multiple paradigms of programming design, we can
    split the frameworks in our world into two main flavors:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript支持多种编程设计范式，我们可以将我们世界中的框架分为两大类：
- en: '*Loose JavaScript isolation frameworks*—These are vanilla JavaScript-friendly
    loose-typed isolation frameworks (such as Jest and Sinon). These frameworks usually
    also lend themselves better to more functional styles of code because they require
    less ceremony and boilerplate code to do their work.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*松散的JavaScript隔离框架*—这些是针对纯JavaScript的松散类型隔离框架（如Jest和Sinon）。这些框架通常也更适合更函数式的代码风格，因为它们需要更少的仪式和样板代码来完成工作。'
- en: '*Typed JavaScript isolation frameworks*—These are more object-oriented and
    TypeScript-friendly isolation frameworks (such as substitute.js). They’re very
    useful when dealing with whole classes and interfaces.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*类型化的JavaScript隔离框架*—这些是更面向对象且TypeScript友好的隔离框架（如substitute.js）。当处理整个类和接口时，它们非常有用。'
- en: Which flavor you end up choosing to use in your project will depend on a few
    things, like taste, style, and readability, but the main question to start with
    is, what type of dependencies will you mostly need to fake?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你最终在项目中选择使用哪种风味将取决于几个因素，如口味、风格和可读性，但首先要问的问题是，你主要需要模拟哪种类型的依赖？
- en: '*Module dependencies (imports, requires)*—Jest and other loosely typed frameworks
    should work well.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模块依赖（导入、导入）*—Jest和其他松散类型框架应该可以很好地工作。'
- en: '*Functional (single and higher-order functions, simple parameters and values)*—Jest
    and other loosely typed frameworks should work well.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*函数式（单态和更高阶函数，简单的参数和值）*—Jest和其他松散类型框架应该可以很好地工作。'
- en: '*Full objects, object hierarchies, and interfaces*—Look into the more object-oriented
    frameworks, such as substitute.js.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*完整对象、对象层次结构和接口*—可以查看更面向对象的框架，如substitute.js。'
- en: Let’s go back to our Password Verifier and see how we can fake the same types
    of dependencies we did in previous chapters, but this time using a framework.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的密码验证器，看看我们如何使用框架来模拟我们在前几章中使用的相同类型的依赖，但这次是使用一个框架。
- en: 5.2 Faking modules dynamically
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 动态模拟模块
- en: For people who are trying to test code with direct dependencies on modules using
    `require` or `import`, isolation frameworks such as Jest or Sinon present the
    powerful ability to fake an entire module dynamically, with very little code.
    Since we started with Jest as our test framework, we’ll stick with it for the
    examples in this chapter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于试图使用`require`或`import`直接依赖模块进行代码测试的人来说，Jest或Sinon等隔离框架提供了强大的动态模拟整个模块的能力，且代码量非常少。由于我们最初选择了Jest作为我们的测试框架，因此在本章的示例中我们将继续使用它。
- en: 'Figure 5.1 illustrates a Password Verifier with two dependencies:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1展示了具有两个依赖关系的密码验证器：
- en: A configuration service that helps decide what the logging level is (`INFO`
    or `ERROR`)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个帮助决定日志级别（`INFO`或`ERROR`）的配置服务
- en: A logging service that we call as the exit point of our unit of work, whenever
    we verify a password
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个我们称之为工作单元出口点的日志服务，每次我们验证密码时
- en: '![05-01](../Images/05-01.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![05-01](../Images/05-01.png)'
- en: 'Figure 5.1 Password Verifier has two dependencies: an incoming one to determine
    the logging level, and an outgoing one to create a log entry.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 密码验证器有两个依赖关系：一个用于确定日志级别的外来依赖，一个用于创建日志条目的外出依赖。
- en: The arrows represent the flow of behavior through the unit of work. Another
    way to think about the arrows is through the terms *command* and *query*. We are
    querying the configuration service (to get the log level), but we are sending
    commands to the logger (to log).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头表示行为在工作单元中的流动。另一种思考箭头的方式是通过术语*命令*和*查询*。我们正在查询配置服务（以获取日志级别），但我们正在向记录器发送命令（以记录）。
- en: Command/query separation
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 命令/查询分离
- en: There is a school of design that falls under the ideas of command/query separation.
    If you’d like to learn more about these terms, I highly recommend reading Martin
    Fowler’s 2005 article on the topic, at [https://martinfowler.com/bliki/CommandQuerySeparation.html](https://martinfowler.com/bliki/CommandQuerySeparation.html).
    This pattern is very beneficial as you navigate your way around different design
    ideas, but we won’t be touching on this too much in this book.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种设计思想属于命令/查询分离的概念。如果你想了解更多关于这些术语的信息，我强烈推荐阅读马丁·福勒2005年关于该主题的文章，可在[https://martinfowler.com/bliki/CommandQuerySeparation.html](https://martinfowler.com/bliki/CommandQuerySeparation.html)找到。这种模式在你探索不同的设计思想时非常有用，但在这本书中我们不会过多涉及这个话题。
- en: The following listing shows a Password Verifier that has a hard dependency on
    a logger module.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了一个具有对记录器模块硬依赖的密码验证器。
- en: Listing 5.1 Code with hardcoded modular dependencies
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.1 带有硬编码模块依赖的代码
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this example we’re forced to find a way to do two things:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们被迫找到一种方法来做两件事：
- en: Simulate (stub) values returned from the `configuration` service’s `getLogLevel`
    function.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟（存根）`configuration`服务`getLogLevel`函数返回的值。
- en: Verify (mock) that the `logger` module’s `info` function was called.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证（模拟）`logger`模块的`info`函数是否被调用。
- en: Figure 5.2 shows a visual representation of this.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2展示了这一过程的视觉表示。
- en: '![05-02](../Images/05-02.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![05-02](../Images/05-02.png)'
- en: Figure 5.2 The test stubs an incoming dependency (the configuration service)
    and mocks the outgoing dependency (the logger).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 测试存根一个传入的依赖（配置服务）并模拟一个传出的依赖（日志器）。
- en: Jest presents us with a few ways to accomplish both simulation and verification,
    and one of the cleaner ways it presents is using `jest.mock([module` `name])`
    at the top of the spec file, followed by us requiring the fake modules in our
    tests so that we can configure them.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Jest提供了几种实现模拟和验证的方法，其中它呈现的一种更干净的方式是在spec文件顶部使用`jest.mock([module` `name])`，然后我们在测试中引入这些模拟模块，以便我们可以配置它们。
- en: Listing 5.2 Faking the module APIs directly with `jest.mock()`
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.2 使用`jest.mock()`直接模拟模块API
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Faking the modules
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 模拟模块
- en: ❷ Getting the fake instances of the modules
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 获取模块的模拟实例
- en: ❸ Telling Jest to reset any fake module behavior between tests
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 告诉Jest在测试之间重置任何模拟模块行为
- en: ❹ Configuring the stub to return a fake “info” value.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 配置存根以返回模拟的“info”值。
- en: ❺ Asserting that the mock was called correctly
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 断言模拟被正确调用
- en: ❻ Changing the stub config
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 修改存根配置
- en: ❼ Asserting on the mock logger as done previously
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 如前所述，对模拟日志器进行断言
- en: By using Jest here, I’ve saved myself a bunch of typing, and the tests still
    look pretty readable.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在这里使用Jest，我节省了很多打字时间，而且测试看起来仍然很易读。
- en: 5.2.1 Some things to notice about Jest’s API
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.1 关于Jest API的一些注意事项
- en: Jest uses the word “mock” almost everywhere, whether we’re stubbing things or
    mocking them, which can be a bit confusing. It’d be great if it had the word “stub”
    aliased to “mock” to make things more readable.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Jest几乎在所有地方都使用“mock”这个词，无论是我们是在存根还是模拟某些东西，这可能会有些令人困惑。如果它将“stub”别名到“mock”，会使事情更易读。
- en: 'Also, due to the way JavaScript “hoisting” works, the lines faking the modules
    (via `jest.mock`) will need to be at the top of the file. You can read more about
    this in Ashutosh Verma’s “Understanding Hoisting in JavaScript” article here:
    [http://mng.bz/j11r](http://mng.bz/j11r).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于JavaScript的“提升”方式，通过`jest.mock`模拟模块的行需要放在文件顶部。你可以在此处阅读更多关于Ashutosh Verma的“理解JavaScript中的提升”文章：[http://mng.bz/j11r](http://mng.bz/j11r)。
- en: Also note that Jest has many other APIs and abilities, and its worth exploring
    them if you’re interested in using it. Head over to [https://jestjs.io/](https://jestjs.io/)
    to get the full picture—it’s beyond the scope of this book, which is mostly about
    patterns, not tools.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，Jest有许多其他API和功能，如果你对其感兴趣，值得探索它们。前往[https://jestjs.io/](https://jestjs.io/)以获取完整信息——这超出了本书的范围，本书主要关于模式，而不是工具。
- en: A few other frameworks, among them Sinon ([https://sinonjs.org](https://sinonjs.org)),
    also support faking modules. Sinon is quite pleasant to work with, as far as isolation
    frameworks go, but like many other frameworks in the JavaScript world, and much
    like Jest, it contains too many ways of accomplishing the same task, and that
    can often be confusing. Still, faking modules by hand can be quite annoying without
    these frameworks.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他框架，包括Sinon([https://sinonjs.org](https://sinonjs.org))，也支持模拟模块。就隔离框架而言，Sinon相当易于使用，但就像JavaScript世界中的许多其他框架一样，以及Jest一样，它包含了许多完成同一任务的方法，这可能会让人感到困惑。然而，没有这些框架，手动模拟模块可能会相当麻烦。
- en: 5.2.2 Consider abstracting away direct dependencies
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.2 考虑抽象直接依赖
- en: The good news about the `jest.mock` API, and others like it, is that it meets
    a very real need for developers who are stuck trying to test modules that have
    baked-in dependencies that are not easily changeable (i.e., code they cannot control).
    This issue is very prevalent in legacy code situations, which I’ll discuss in
    chapter 12.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`jest.mock` API及其类似功能的利好消息是，它满足了开发者测试那些内置了不易更改的依赖项（即他们无法控制的代码）的非常实际的需求。这个问题在遗留代码情况下非常普遍，我将在第12章中讨论这个问题。
- en: The bad news about the `jest.mock` API is that it also allows us to mock the
    code that we do control and that might have benefited from abstracting away the
    real dependencies behind simpler, shorter, internal APIs. This approach, also
    known as *onion architecture* or *hexagonal architecture* or *ports and adapters*,
    is very useful for the long-term maintainability of our code. You can read more
    about this type of architecture in Alistair Cockburn’s article, “Hexagonal Architecture,”
    at [https://alistair.cockburn.us/hexagonal-architecture/](https://alistair.cockburn.us/hexagonal-architecture/).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `jest.mock` API 的坏消息是，它还允许我们模拟我们控制的代码，并且可能从抽象到更简单、更短的内部 API 中受益。这种方法也称为 *洋葱架构*
    或 *六边形架构* 或 *端口和适配器*，对于代码的长期可维护性非常有用。你可以在 Alistair Cockburn 的文章“Hexagonal Architecture”中了解更多关于这种类型架构的信息，该文章位于
    [https://alistair.cockburn.us/hexagonal-architecture/](https://alistair.cockburn.us/hexagonal-architecture/)。
- en: Why are direct dependencies potentially problematic? By using those APIs directly,
    we’re also forced into faking the module APIs directly in our tests instead of
    their abstractions. We’re gluing the design of those direct APIs to the implementation
    of the tests, which means that if (or really, when) those APIs change, we’ll also
    need to change many of our tests.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么直接依赖可能有问题？通过直接使用这些 API，我们也被迫在我们的测试中直接伪造模块 API，而不是它们的抽象。我们将这些直接 API 的设计粘合到测试的实现上，这意味着如果（或者更确切地说，当）这些
    API 发生变化时，我们也需要更改许多测试。
- en: Here’s a quick example. Imagine your code depends on a well-known JavaScript
    logging framework (such as Winston) and depends on it directly in hundreds or
    thousands of places in the code. Then imagine that Winston releases a breaking
    upgrade. Lots of pain will ensue, which could have been addressed much earlier,
    before things got out of hand. One simple way to accomplish this would be with
    a simple abstraction to a single adapter file, which is the only one holding a
    reference to that logger. That abstraction can expose a simpler, internal logging
    API that we do control, so we can prevent large-scale breakage across our code.
    I’ll return to this subject in chapter 12.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个快速示例。假设你的代码依赖于一个知名的 JavaScript 日志框架（例如 Winston），并且直接在代码中的数百或数千个地方依赖它。然后想象一下，Winston
    发布了一个破坏性的升级。随之而来的是大量的痛苦，这些问题本可以在事情失控之前得到解决。实现这一点的简单方法之一是使用一个简单的抽象到单个适配器文件，这是唯一持有该记录器引用的文件。这种抽象可以暴露一个更简单、内部日志
    API，我们确实可以控制它，因此我们可以防止代码中的大规模破坏。我将在第 12 章回到这个话题。
- en: 5.3 Functional dynamic mocks and stubs
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 功能性动态模拟和存根
- en: We covered modular dependencies, so let’s turn to faking simple functions. We’ve
    done that plenty of times in the previous chapters, but we’ve always done it by
    hand. That works great for stubs, but for mocks it gets annoying fast.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了模块依赖，现在让我们转向模拟简单的函数。我们在前面的章节中多次这样做，但我们总是手动完成。这对于存根来说效果很好，但对于模拟来说，很快就会变得令人烦恼。
- en: The following listing shows the manual approach we used before.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了之前我们使用的手动方法。
- en: Listing 5.3 Manually mocking a function to verify it was called
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.3 手动模拟函数以验证其是否被调用
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Declaring a custom variable to hold the value passed in
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 声明一个自定义变量来保存传入的值
- en: ❷ Saving the passed-in value to that variable
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将传入的值保存到该变量中
- en: ❸ Asserting on the value of the variable
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 断言变量的值
- en: It works—we’re able to verify that the logger function was called, but that’s
    a lot of work that can become very repetitive. Enter isolation frameworks like
    Jest. `jest.fn()` is the simplest way to get rid of such code. The following listing
    shows how we can use it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 它是有效的——我们能够验证记录器函数被调用，但这是一项大量工作，可能会变得非常重复。这时，隔离框架如 Jest 就派上用场。`jest.fn()` 是消除此类代码的最简单方法。下面的列表显示了我们可以如何使用它。
- en: Listing 5.4 Using `jest.fn()` for simple function mocks
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.4 使用 `jest.fn()` 进行简单的函数模拟
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Compare this code with the previous example. It’s subtle, but it saves plenty
    of time. Here we’re using `jest.fn()` to get back a function that is automatically
    tracked by Jest, so that we can query it later using Jest’s API via `toHaveBeenCalledWith()`.
    It’s small and cute, and it works well any time you need to track calls to a specific
    function. The `stringMatching` function is an example of a *matcher*. A matcher
    is usually defined as a utility function that can assert on the value of a parameter
    being sent into a function. The Jest docs use the term a bit more liberally, but
    you can find the full list of matchers in the Jest documentation at [https://jestjs.io/docs/en/expect](https://jestjs.io/docs/en/expect).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码与上一个示例进行比较。它很微妙，但可以节省很多时间。在这里，我们使用 `jest.fn()` 来获取一个由 Jest 自动跟踪的函数，这样我们就可以通过
    Jest 的 API 使用 `toHaveBeenCalledWith()` 在以后查询它。它小巧可爱，并且在你需要跟踪对特定函数的调用时效果很好。`stringMatching`
    函数是一个 *匹配器* 的例子。匹配器通常被定义为可以断言传入函数的参数值的实用函数。Jest 文档对此术语的使用更为宽松，但你可以在 Jest 文档的[https://jestjs.io/docs/en/expect](https://jestjs.io/docs/en/expect)中找到匹配器的完整列表。
- en: To summarize, `jest.fn()` works well for single-function-based mocks and stubs.
    Let’s move on to a more object-oriented challenge.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`jest.fn()` 对于基于单个功能的模拟和存根来说效果很好。让我们继续探讨一个更面向对象的挑战。
- en: 5.4 Object-oriented dynamic mocks and stubs
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 面向对象的动态模拟和存根
- en: As we’ve just seen, `jest.fn()` is an example of a single-function faking utility
    function. It works well in a functional world, but it breaks down a bit when we
    try to use it on full-blown API interfaces or classes that contain multiple functions.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚刚看到的，`jest.fn()` 是一个单功能模拟实用函数的例子。它在函数式世界中效果很好，但当我们尝试在包含多个函数的完整 API 接口或类中使用它时，它就会有点崩溃。
- en: 5.4.1 Using a loosely typed framework
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.1 使用松散类型框架
- en: I mentioned before that there are two categories of isolation frameworks. To
    start, we’ll use the first (loosely typed, function-friendly) kind. The following
    listing is an example of trying to tackle the `IComplicatedLogger` we looked at
    in the previous chapter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，存在两种隔离框架类别。首先，我们将使用第一种（松散类型，函数友好）类型。以下列表是尝试解决我们在上一章中查看的 `IComplicatedLogger`
    的一个例子。
- en: Listing 5.5 The `IComplicatedLogger` interface
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.5 `IComplicatedLogger` 接口
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Creating a handwritten stub or mock for this interface may be very time consuming,
    because you’d need to remember the parameters on a per-method basis, as the next
    listing shows.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为此接口创建手写的存根或模拟可能会非常耗时，因为你需要记住每个方法上的参数，如下一个列表所示。
- en: Listing 5.6 Handwritten stubs creating lots of boilerplate code
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.6 手写存根生成大量样板代码
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: What a mess. Not only is this handwritten fake time consuming and cumbersome
    to write, what happens if you want it to return a specific value somewhere in
    the test, or simulate an error from a function call on the logger? We can do it,
    but the code gets ugly fast.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 真是乱七八糟。这不仅意味着手写的模拟既耗时又难以编写，如果你想在测试中让它返回特定的值，或者模拟从日志器函数调用中产生的错误，会发生什么？我们可以做到，但代码会很快变得丑陋。
- en: Using an isolation framework, the code for doing this becomes trivial, more
    readable, and much shorter. Let’s use `jest.fn()` for the same task and see where
    we end up.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用隔离框架，执行此操作的代码变得简单、可读性更强，并且更短。让我们使用 `jest.fn()` 来完成同样的任务，看看我们会走到哪里。
- en: Listing 5.7 Mocking individual interface functions with `jest.fn()`
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.7 使用 `jest.fn()` 模拟单个接口函数
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Setting up the mock using Jest
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 Jest 设置模拟
- en: 'Not too shabby. Here we simply outline our own object and attach a `jest.fn()`
    function to each of the functions in the interface. This saves a lot of typing,
    but it has one important caveat: whenever the interface changes (a function is
    added, for example), we’ll have to go back to the code that defines this object
    and add that function. With plain JavaScript, this would be less of an issue,
    but it can still create some complications if the code under test uses a function
    we didn’t define in the test.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不太糟糕。在这里，我们只是概述了自己的对象，并将 `jest.fn()` 函数附加到接口中的每个函数上。这节省了很多打字，但有一个重要的注意事项：每当接口发生变化（例如添加了一个函数），我们都需要回到定义此对象的代码中并添加该函数。使用纯
    JavaScript，这可能会少一些问题，但如果有代码正在测试我们未在测试中定义的函数，这仍然可能造成一些复杂性。
- en: In any case, it might be wise to push the creation of such a fake object into
    a factory helper method, so that the creation only exists in a single place.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，将此类模拟对象的创建推入一个工厂辅助方法可能是明智的，这样创建就只存在于一个地方。
- en: 5.4.2 Switching to a type-friendly framework
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.2 转向类型友好的框架
- en: Let’s switch to the second category of frameworks and try substitute.js ([www.npmjs.com/package/@fluffy-spoon/substitute](http://www.npmjs.com/package/@fluffy-spoon/substitute)).
    We have to choose one, and I like the C# version of this framework a lot and used
    it in the previous edition of this book.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们切换到框架的第二类，并尝试 substitute.js ([www.npmjs.com/package/@fluffy-spoon/substitute](http://www.npmjs.com/package/@fluffy-spoon/substitute))。我们必须选择一个，我非常喜欢这个框架的
    C# 版本，并在上一版这本书中使用过它。
- en: With substitute.js (and the assumption of working with TypeScript), we can write
    code like the following.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 substitute.js（以及假设使用 TypeScript），我们可以编写如下代码。
- en: Listing 5.8 Using substitute.js to fake a full interface
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.8 使用 substitute.js 模拟完整接口
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Generating the fake object
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 生成假对象
- en: ❷ Verifying the fake object was called
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 验证假对象被调用
- en: In the preceding listing, we generate the fake object, which absolves us of
    caring about any functions other than the one we’re testing against, even if the
    object’s signature changes in the future. We then use `.received()` as our verification
    mechanism, as well as another argument matcher, `Arg.is`, this time from substitute.js’s
    API, which works just like string matches from Jasmine. The added benefit here
    is that if new functions are added to the object’s signature, we will be less
    likely to need to change the test, and there’s no need to add those functions
    to any tests that use the same object signature.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，我们生成了假对象，这使我们无需关心除了我们正在测试的函数之外的其他任何函数，即使对象签名在未来发生变化。然后我们使用 `.received()`
    作为我们的验证机制，以及另一个参数匹配器，`Arg.is`，这次来自 substitute.js 的 API，它的工作方式与 Jasmine 的字符串匹配类似。这里的额外好处是，如果对象签名中添加了新函数，我们就不太可能需要更改测试，而且无需将这些函数添加到使用相同对象签名的任何测试中。
- en: Isolation frameworks and the Arrange-Act-Assert pattern
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离框架和 Arrange-Act-Assert 模式
- en: Notice that the way you use the isolation framework matches nicely with the
    Arrange-Act-Assert structure, which we discussed in chapter 1\. You start by arranging
    a fake object, you act on the thing you’re testing, and then you assert on something
    at the end of the test.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你使用隔离框架的方式与我们在第 1 章中讨论的 Arrange-Act-Assert 结构非常匹配。你首先安排一个假对象，然后对你要测试的事物进行操作，最后在测试的末尾进行断言。
- en: It wasn’t always this easy, though. In the olden days (around 2006), most of
    the open source isolation frameworks didn’t support the idea of Arrange-Act-Assert
    and instead used a concept called Record-Replay (we’re talking about Java and
    C#). Record-Replay was a nasty mechanism where you’d have to tell the isolation
    API that its fake object was in *record* mode, and then you’d have to call the
    methods on that object as you expected them to be called from production code.
    Then you’d have to tell the isolation API to switch into *replay* mode, and only
    *then* could you send your fake object into the heart of your production code.
    An example can be seen on the Baeldung site at [www.baeldung.com/easymock](http://www.baeldung.com/easymock).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这并不总是那么容易。在古代（大约2006年），大多数开源隔离框架都不支持 Arrange-Act-Assert 的概念，而是使用了一个叫做 Record-Replay
    的概念（我们说的是 Java 和 C#）。Record-Replay 是一个讨厌的机制，你需要告诉隔离 API 它的假对象处于 *record* 模式，然后你需要按照预期的生产代码调用该对象上的方法。然后你需要告诉隔离
    API 切换到 *replay* 模式，只有 *那时* 你才能将你的假对象发送到生产代码的核心。一个例子可以在 Baeldung 网站上看到，[www.baeldung.com/easymock](http://www.baeldung.com/easymock)。
- en: Compared to today’s ability to write tests that use the far more readable Arrange-Act-Assert
    model, this tragedy cost many developers millions of combined hours in painstaking
    test reading to figure out exactly where tests failed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与今天使用更易读的 Arrange-Act-Assert 模型编写的测试能力相比，这场悲剧让许多开发者花费了数百万小时的不懈努力去阅读测试，以确定测试失败的确切位置。
- en: If you have the first edition of this book, you can see an example of Record-Replay
    when I showed Rhino Mocks (which initially had the same design).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你拥有这本书的第一版，你可以在展示 Rhino Mocks（最初具有相同的设计）时看到 Record-Replay 的一个例子。
- en: OK, that was mocks. What about stubs?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那是模拟。那么桩（stub）呢？
- en: 5.5 Stubbing behavior dynamically
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5 动态模拟行为
- en: 'Jest has a very simple API for simulating return values for modular and functional
    dependencies: `mockReturnValue()` and `mockReturnValueOnce()`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 为模拟模块和功能依赖的返回值提供了一个非常简单的 API：`mockReturnValue()` 和 `mockReturnValueOnce()`。
- en: Listing 5.9 Stubbing a value from a fake function with `jest.fn()`
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.9 使用 `jest.fn()` 从假函数中模拟值
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that, in the first test, we’re setting a *permanent* return value for
    the duration of the test. This is my preferred method of writing tests if I can
    use it, because it makes the tests simple to read and maintain. If we do need
    to simulate multiple values, we can use `mockReturnValueOnce`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在第一个测试中，我们正在为测试期间设置一个*永久*的返回值。如果我可以使用它，这是我编写测试的首选方法，因为它使得测试易于阅读和维护。如果我们需要模拟多个值，我们可以使用`mockReturnValueOnce`。
- en: 'If you need to simulate an error or do anything more complicated, you can use
    `mockImplementation()` and `mockImplementationOnce()`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要模拟错误或进行更复杂的操作，可以使用`mockImplementation()`和`mockImplementationOnce()`：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 5.5.1 An object-oriented example with a mock and a stub
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.1 使用模拟和存根的对象导向示例
- en: Let’s add another ingredient into our Password Verifier equation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在密码验证器的方程中添加另一个因素。
- en: Let’s say that the Password Verifier is *not* active during a special maintenance
    window, when software is being updated.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设密码验证器在特殊维护窗口期间（当软件正在更新时）是不活跃的。
- en: When a maintenance window is active, calling `verify()` on the verifier will
    cause it to call `logger.info()` with “under maintenance.”
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当维护窗口处于活动状态时，在验证器上调用`verify()`将导致它调用`logger.info()`并显示“正在维护”。
- en: Otherwise it will call `logger.info()` with a “passed” or “failed” result.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，它将调用`logger.info()`并显示“通过”或“失败”的结果。
- en: For this purpose (and for the purpose of showing an object-oriented design decision),
    we’ll introduce a `MaintenanceWindow` interface that will be injected into the
    constructor of our Password Verifier, as illustrated in figure 5.3.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的（以及展示面向对象的设计决策），我们将引入一个`MaintenanceWindow`接口，该接口将被注入到我们的密码验证器的构造函数中，如图5.3所示。
- en: '![05-03](../Images/05-03.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![05-03](../Images/05-03.png)'
- en: Figure 5.3 Using the `MaintenanceWindow` interface
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 使用`MaintenanceWindow`接口
- en: The following listing shows the code for the Password Verifier using the new
    dependency.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了使用新依赖项的密码验证器的代码。
- en: Listing 5.10 Password Verifier with a `MaintenanceWindow` dependency
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.10 带有`MaintenanceWindow`依赖的密码验证器
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `MaintenanceWindow` interface is injected as a constructor parameter (i.e.,
    using constructor injection), and it’s used to determine where to execute or not
    execute the password verification and send the proper message to the logger.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`MaintenanceWindow`接口作为构造函数参数注入（即使用构造函数注入），并用于确定是否执行密码验证以及向记录器发送适当的消息。'
- en: 5.5.2 Stubs and mocks with substitute.js
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.2 使用substitute.js的存根和模拟
- en: Now we’ll use substitute.js instead of Jest to create a stub of the `MaintenanceWindow`
    interface and a mock of the `IComplicatedLogger` interface. Figure 5.4 illustrates
    this.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用substitute.js而不是Jest来创建`MaintenanceWindow`接口的存根和`IComplicatedLogger`接口的模拟。图5.4展示了这一点。
- en: '![05-04](../Images/05-04.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![05-04](../Images/05-04.png)'
- en: Figure 5.4 A `MaintenanceWindow` dependency
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 `MaintenanceWindow`依赖
- en: 'Creating stubs and mocks with substitute.js works the same way: we use the
    `Substitute.for<T>` function. We can configure stubs with the `.returns` function
    and verify mocks with the `.received` function. Both of these are part of the
    fake object that is returned from `Substitute.for<T>().`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用substitute.js创建存根和模拟的方式相同：我们使用`Substitute.for<T>`函数。我们可以使用`.returns`函数配置存根，并使用`.received`函数验证模拟。这两个都是来自`Substitute.for<T>()`返回的假对象的一部分。
- en: 'Here’s what stub creation and configuration looks like:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是存根创建和配置的示例：
- en: '[PRE11]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Mock creation and verification looks like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟创建和验证看起来是这样的：
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The following listing shows the full code for a couple of tests that use a mock
    and a stub.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了使用模拟和存根的几个测试的完整代码。
- en: Listing 5.11 Testing Password Verifier with substitute.js
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.11 使用substitute.js测试密码验证器
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can successfully and relatively easily simulate values in our tests with
    dynamically created objects. I encourage you to research the flavor of an isolation
    framework you’d like to use. I’ve only used substitute.js as an example in this
    book. It’s not the only framework out there.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在测试中成功且相对容易地使用动态创建的对象来模拟值。我鼓励你研究你想要使用的隔离框架的版本。在这本书中，我只使用了substitute.js作为示例。它不是唯一的框架。
- en: This test requires no handwritten fakes, but notice that it’s already starting
    to take a toll on the readability for the test reader. Functional designs are
    usually much slimmer than this. In an object-oriented setting, sometimes this
    is a necessary evil. However, we could easily refactor the creation of various
    helpers, mocks, and stubs to helper functions as we refactor our code, so that
    the test can be simpler and shorter to read. More on that in part 3 of this book.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试不需要编写手写的模拟，但请注意，它已经开始对测试读者的可读性产生影响。功能设计通常比这更简洁。在面向对象的设置中，有时这是必要的恶行。然而，我们可以在重构代码的同时轻松地将各种辅助程序、模拟和存根的创建重构为辅助函数，从而使测试更简单、更易于阅读。关于这一点，本书的第3部分将有更多介绍。
- en: 5.6 Advantages and traps of isolation frameworks
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.6 隔离框架的优势和陷阱
- en: 'Based on what we’ve covered in this chapter, we’ve seen distinct advantages
    to using isolation frameworks:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 根据本章所涵盖的内容，我们看到了使用隔离框架的明显优势：
- en: '*Easier modular faking*—Module dependencies can be hard to get around without
    some boilerplate code, which isolation frameworks help us eliminate. This point
    can also be counted as a negative, as explained earlier, because it encourages
    us to have code strongly coupled to third-party implementations.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更易模块化模拟*——没有一些样板代码，模块依赖关系可能很难处理，而隔离框架帮助我们消除这些样板代码。这一点也可以被视为一个缺点，如前所述，因为它鼓励我们编写与第三方实现强耦合的代码。'
- en: '*Easier simulation of values or errors*—Writing mocks manually can be difficult
    across a complicated interface. Frameworks help a lot.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更易模拟值或错误*——在复杂的接口上手动编写模拟可能很困难。框架在这方面有很大帮助。'
- en: '*Easier fake creation*—Isolation frameworks can be used to create both mocks
    and stubs more easily.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更易创建模拟*——隔离框架可以更轻松地创建模拟和存根。'
- en: Although there are many advantages to using isolation frameworks, there are
    also possible dangers. Let’s now talk about a few things to watch out for.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用隔离框架有许多优点，但也存在可能的风险。现在让我们谈谈需要注意的一些事项。
- en: 5.6.1 You don’t need mock objects most of the time
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6.1 大多数时候你不需要模拟对象
- en: 'The biggest trap that isolation frameworks lead you into is making it easy
    to fake anything, and encouraging you to think you need mock objects in the first
    place. I’m not saying you won’t need stubs, but mock objects shouldn’t be the
    standard operating procedure for most unit tests. Remember that a unit of work
    can have three different types of exit points: return values, state change, and
    calling a third-party dependency. Only one of these types can benefit from a mock
    object in your test. The others don’t.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离框架让你陷入的最大陷阱是使任何事物都容易模拟，并鼓励你首先认为你需要模拟对象。我并不是说你不需要存根，但模拟对象不应该成为大多数单元测试的标准操作程序。记住，一个工作单元可以有三种不同类型的退出点：返回值、状态变化和调用第三方依赖。只有其中一种类型可以从你的测试中的模拟对象中受益。其他则不行。
- en: I find that, in my own tests, mock objects are present in perhaps 2%-5% of my
    tests. The rest of the tests are usually return-value or state-based tests. For
    functional designs, the number of mock objects should be near zero, except for
    some corner cases.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现，在我的测试中，模拟对象可能只占大约2%-5%。其余的测试通常是返回值或基于状态的测试。对于功能设计，模拟对象的数量应该接近零，除非是某些边缘情况。
- en: If you find yourself defining a test and verifying that an object or function
    was called, think carefully whether you can prove the same functionality without
    a mock object, but instead by verifying a return value or a change in the behavior
    of the overall unit of work from the outside (for example, verifying that a function
    throws an exception when it didn’t before). Chapter 6 of *Unit Testing Principles,
    Practices, and Patterns* by Vladimir Khorikov (Manning, 2020) contains a detailed
    description of how to refactor interaction-based tests into simpler, more reliable
    tests that check a return value instead.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己正在定义一个测试并验证一个对象或函数是否被调用，仔细思考是否可以在不使用模拟对象的情况下证明相同的功能，而是通过验证返回值或从外部验证整体工作单元的行为变化（例如，验证一个函数在之前没有抛出异常时现在抛出了异常）。Vladimir
    Khorikov所著的《单元测试原则、实践和模式》（Manning, 2020）的第6章包含了对如何将基于交互的测试重构为更简单、更可靠的测试的详细描述，这些测试检查的是返回值而不是模拟对象。
- en: 5.6.2 Unreadable test code
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6.2 不可读的测试代码
- en: Using a mock in a test makes the test a little less readable, but still readable
    enough that an outsider can look at it and understand what’s going on. Having
    many mocks, or many expectations, in a single test can ruin the readability of
    the test so it’s hard to maintain, or even to understand what’s being tested.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中使用模拟会使测试稍微难以阅读，但仍然足够清晰，以至于外人可以查看并理解正在发生的事情。在单个测试中包含许多模拟或许多期望可能会破坏测试的可读性，使其难以维护，甚至难以理解正在测试的内容。
- en: If you find that your test becomes unreadable or hard to follow, consider removing
    some mocks or some mock expectations, or separating the test into several smaller
    tests that are more readable.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现你的测试变得难以阅读或难以理解，考虑移除一些模拟或模拟期望，或者将测试拆分成几个更易读的小测试。
- en: 5.6.3 Verifying the wrong things
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6.3 验证错误的事情
- en: 'Mock objects allow you to verify that methods were called on your interfaces
    or that functions were called, but that doesn’t necessarily mean that you’re testing
    the right thing. A lot of people new to tests end up verifying things just because
    they can, not because it makes sense. Examples may include the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象允许你验证是否在接口上调用方法或函数被调用，但这并不一定意味着你正在测试正确的事情。许多刚开始接触测试的人最终只是因为可以验证而验证事情，而不是因为这样做有意义。以下是一些例子：
- en: Verifying that an internal function calls another internal function (not an
    exit point).
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证一个内部函数调用另一个内部函数（不是出口点）。
- en: Verifying that a stub was called (an incoming dependency should not be verified;
    it’s the overspecification antipattern, as we’ll discuss in section 5.6.5).
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证存根是否被调用（一个传入的依赖项不应该被验证；这是过度指定反模式，我们将在5.6.5节中讨论）。
- en: Verifying that something was called simply because someone told you to write
    a test, and you’re not sure what should really be tested. (This is a good time
    to verify that you’re understanding the requirements correctly.)
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为有人告诉你写测试，所以验证某事被调用，但你不确定真正应该测试什么。（这是验证你是否正确理解需求的好时机。）
- en: 5.6.4 Having more than one mock per test
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6.4 每个测试中包含多个模拟
- en: It’s considered good practice to test only one concern per test. Testing more
    than one concern can lead to confusion and problems maintaining the test. Having
    two mocks in a test is the same as testing several end results of the same unit
    of work (multiple exit points).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 被认为是一种良好的实践，每个测试只测试一个关注点。测试多个关注点可能会导致混淆和测试维护问题。在一个测试中包含两个模拟等同于测试同一个工作单元的多个最终结果（多个出口点）。
- en: For each exit point, consider writing a separate test, as it could be considered
    a separate requirement. Chances are that your test names will also become more
    focused and readable when you only test one concern. If you can’t name your test
    because it does too many things and the name becomes very generic (e.g., “XWorksOK”),
    it’s time to separate it into more than one test.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个出口点，考虑编写一个单独的测试，因为它可能被视为一个独立的需求。当你只测试一个关注点时，你的测试名称也可能变得更加专注和易读。如果你无法命名你的测试，因为它做了太多事情，名字变得非常通用（例如，“XWorksOK”），那么是时候将其拆分成多个测试了。
- en: 5.6.5 Overspecifying the tests
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6.5 过度指定测试
- en: 'If your test has too many expectations (`x.received().X()`, `x.received().Y()`,
    and so on), it may become very fragile, breaking on the slightest of production
    code changes, even though the overall functionality still works. Testing interactions
    is a double-edged sword: test them too much, and you start to lose sight of the
    big picture—the overall functionality; test them too little, and you’ll miss the
    important interactions between units of work.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的测试有太多的期望（例如`x.received().X()`、`x.received().Y()`等），它可能会变得非常脆弱，即使整体功能仍然正常，也会因为生产代码的微小变化而崩溃。测试交互是双刃剑：测试过多，你会开始失去对大局的视线——整体功能；测试过少，你会错过工作单元之间的重要交互。
- en: 'Here are some ways to balance this effect:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些平衡这种效果的方法：
- en: '*Use stubs instead of mocks when you can*—If more than 5% of your tests use
    mock objects, you might be overdoing it. Stubs can be everywhere. Mocks, not so
    much. You only need to test one scenario at a time. The more mocks you have, the
    more verifications will take place at the end of the test, but usually only one
    will be the important one. The rest will be noise against the current test scenario.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*当可能时，使用存根而不是模拟*——如果你的测试中超过5%使用了模拟对象，你可能做得有点过头了。存根可以无处不在。模拟则不然。你只需要一次测试一个场景。模拟对象越多，测试结束时进行的验证就越多，但通常只有一个是重要的。其余的都将是针对当前测试场景的噪音。'
- en: '*Avoid using stubs as mocks if possible*—Use a stub only for faking simulated
    values into the unit of work under test or to throw exceptions. Don’t verify that
    methods were called on stubs.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*尽可能避免将存根用作模拟*——仅使用存根来伪造模拟值进入正在测试的工作单元或抛出异常。不要验证存根上是否调用了方法。'
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Isolation, or mocking, frameworks allow you to dynamically create, configure,
    and verify mocks and stubs, either in object or function form. Isolation frameworks
    save a lot of time compared to handwritten fakes, especially in modular dependency
    situations.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离框架或模拟框架允许你动态地创建、配置和验证模拟和存根，无论是以对象还是函数的形式。与手写的伪造相比，隔离框架可以节省大量时间，尤其是在模块化依赖情况下。
- en: 'There are two flavors of isolation frameworks: loosely typed (such as Jest
    and Sinon) and strongly typed (such as substitute.js). Loosely typed frameworks
    require less boilerplate and are good for functional-style code; strongly typed
    frameworks are useful when dealing with classes and interfaces.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在两种隔离框架类型：松散类型（如 Jest 和 Sinon）和严格类型（如 substitute.js）。松散类型框架需要更少的样板代码，适用于函数式代码；严格类型框架在处理类和接口时很有用。
- en: Isolation frameworks can replace whole modules, but try to abstract away direct
    dependencies and fake those abstractions instead. This will help you reduce the
    amount of refactoring needed when the module’s API changes.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离框架可以替换整个模块，但尽量抽象出直接依赖，并伪造这些抽象。这有助于在模块的API发生变化时减少重构的工作量。
- en: It's important to lean toward return-value or state-based testing as opposed
    to interaction testing whenever you can, so that your tests assume as little as
    possible about internal implementation details.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下，倾向于基于返回值或状态测试，而不是交互测试，这样你的测试就可以尽可能少地假设内部实现细节。
- en: Mocks should be used only when there’s no other way to test the implementation,
    because they eventually lead to tests that are harder to maintain if you’re not
    careful.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该只在没有其他测试实现方法的情况下使用模拟，因为如果不小心，它们最终会导致难以维护的测试。
- en: Choose the way you work with isolation frameworks based on the codebase you
    are working on. In legacy projects, you may need to fake whole modules, as it
    might be the only way to add tests to such projects. In greenfield projects, try
    to introduce proper abstractions on top of third-party modules. It’s all about
    picking the right tool for the job, so be sure to look at the big picture when
    considering how to approach a specific problem in testing.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据你正在工作的代码库选择与隔离框架一起工作的方式。在遗留项目中，你可能需要伪造整个模块，因为这可能是向此类项目添加测试的唯一方法。在绿色项目中，尝试在第三方模块之上引入适当的抽象。这完全关乎选择合适的工具来完成工作，所以在考虑如何处理测试中的特定问题时，一定要从大局出发。
