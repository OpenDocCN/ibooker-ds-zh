- en: Chapter 7\. End-to-end testing
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7章. 端到端测试
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: End-to-end testing of microservice applications
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务应用的端到端测试
- en: Tools for end-to-end testing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端到端测试的工具
- en: Setting up Arquillian for end-to-end tests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为端到端测试设置Arquillian
- en: End-to-end tests build on integration tests, which in turn build on all the
    other forms of testing you’ve learned about. As the name indicates, end-to-end
    tests are designed to test your application from start to finish (or top to bottom,
    if you prefer). They should in theory simulate a real-world user of your application,
    or at least perform the actions of a real user. In practice, these tests are usually
    the most difficult to write and consume the most development time. End-to-end
    tests are nearly always slow in comparison to other types of tests, so they’re
    often isolated from the usual development process—on a Jenkins build server, for
    example ([https://jenkins.io](https://jenkins.io)).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试建立在集成测试之上，而集成测试又建立在所有其他你已经了解的测试形式之上。正如其名所示，端到端测试旨在从开始到结束（或者如果你更喜欢，从上到下）测试你的应用程序。理论上，这些测试应该模拟你的应用程序的真实世界用户，或者至少执行真实用户的操作。在实践中，这些测试通常是最难编写的，并且消耗最多的开发时间。与其他类型的测试相比，端到端测试几乎总是较慢，因此它们通常与常规的开发过程隔离——例如，在Jenkins构建服务器上（[https://jenkins.io](https://jenkins.io)）。
- en: '|  |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-7
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Learning everything about continuous integration and delivery would be beyond
    the scope of this book, so we’re thinking there may be another mini book in the
    pipeline. (For those familiar with the topic, excuse the pun.) That said, to get
    you started, [chapter 10](kindle_split_019_split_000.xhtml#ch10) provides a reasonably
    detailed discussion of how to set up a deployment pipeline using Jenkins.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 学习有关持续集成和交付的所有内容超出了本书的范围，所以我们认为可能还有另一本小书在计划中。（对于那些熟悉这个主题的人来说，请原谅这个双关语。）话虽如此，为了让你开始，[第10章](kindle_split_019_split_000.xhtml#ch10)提供了一个关于如何使用Jenkins设置部署管道的相当详细的讨论。
- en: '|  |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: An end-to-end test should ideally provide an environment that’s as close to
    your production environment as possible, yet is isolated, so it can’t damage the
    actual system. This could mean providing something as simple as a copied directory
    of images for a gallery application, or something as complex as a snapshot of
    your enterprise database for a data-warehouse application. Sometimes this isn’t
    possible—for example, having a real SAP endpoint to test against might be an exorbitant
    overhead that you’d like to avoid; so, using a dummy, a mock, or WireMock would
    be a legitimate solution.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试理想情况下应提供一个尽可能接近你的生产环境的环境，同时又是隔离的，这样它就不会损害实际系统。这可能意味着为画廊应用程序提供简单的图像目录副本，或者为数据仓库应用程序提供企业数据库的快照等复杂的东西。有时这可能是不可能的——例如，拥有一个真实的SAP端点进行测试可能是一个过高的开销，你希望避免；因此，使用一个模拟的、一个模拟的或WireMock将是一个合法的解决方案。
- en: 7.1\. End-to-end tests in the overall testing picture
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1. 端到端测试在整体测试图景中的位置
- en: End-to-end testing is required to verify that input is received correctly from
    the frontend entry all the way down to the backend. The real challenge is how
    to sew together all the standalone microservices on a single machine. The book’s
    example has four microservices, one of which is a Spring Boot application, and
    a UI application that calls the services. To test the UI, the microservices must
    be available before the UI starts. After that, you need to perform the required
    tests, record and collect the results, and then shut down and clean up the environment.
    In a sense, you’re putting your monolithic application back together to test it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试是必需的，以确保从前端入口到后端正确接收输入。真正的挑战是如何将所有独立的微服务在单个机器上串联起来。本书的例子中有四个微服务，其中一个是Spring
    Boot应用程序，还有一个调用这些服务的UI应用程序。为了测试UI，微服务必须在UI启动之前可用。之后，你需要执行必要的测试，记录和收集结果，然后关闭并清理环境。从某种意义上说，你是在将单体应用程序重新组装起来以进行测试。
- en: The individual microservices may also require that all dependent services, such
    as databases, be up and running and seeded with data. As you can imagine, this
    list of requirements can go on and on.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 单个微服务也可能需要所有依赖的服务，如数据库，都处于运行状态并已填充数据。正如你可以想象的那样，这个需求列表可以无限延伸。
- en: It may also be necessary to recycle the process for further tests, but we recommend
    that you try to keep everything up and running until all tests are complete. Try
    to batch tests together as much as possible, because restarting the environment
    is expensive in terms of time.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能需要重复这个过程进行进一步的测试，但我们建议你尽量保持一切运行直到所有测试完成。尽可能地将测试批量进行，因为重启环境在时间上代价很高。
- en: 7.2\. End-to-end testing techniques
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2\. 端到端测试技术
- en: 'In principle, there are two types of end-to-end tests: *horizontal* and *vertical*.
    We’ll describe them both in a moment. Both types can be performed in either a
    white-box or black-box environment, or combined. A *white-box environment* is
    one where the visible or outwardly facing elements of the application are tested,
    whereas a *black-box environment* tests the actual functionality (in the background).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从原则上讲，有两种类型的端到端测试：*水平*和*垂直*。我们将在稍后描述它们。这两种类型都可以在白盒或黑盒环境中执行，或者结合使用。*白盒环境*是指测试应用程序的可见或外部元素，而*黑盒环境*测试的是实际的功能（在后台）。
- en: 'To put this in a practical context: suppose you have a UI that the end user
    must interact with. The user can visualize and perform actions on the exposed
    application. These actions result in user expectations about the outcome. Logically,
    to simulate user interaction with the UI, you must provide the UI for the test.
    This is a white-box environment, because the user can see actions occurring.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这个概念应用到实际情境中：假设你有一个最终用户必须与之交互的UI。用户可以可视化和对暴露的应用程序执行操作。这些操作导致用户对结果的期望。从逻辑上讲，为了模拟用户与UI的交互，你必须为测试提供UI。这是一个白盒环境，因为用户可以看到操作的发生。
- en: In the same scope as the white-box scenario where the user interacts with the
    UI, actions may invoke processes on the underlying server. These backend processes
    aren’t visible to the user but may produce a result that the user will eventually
    encounter. This is a black-box environment, because actions are performed in the
    dark, so to speak.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户与UI交互的白盒场景的同一范围内，操作可能会在底层服务器上调用过程。这些后端过程对用户是不可见的，但可能会产生用户最终会遇到的结果。这是一个黑盒环境，因为操作是在黑暗中进行的，换句话说。
- en: 'End-to-end tests invariably combine both white- and black-box environments,
    especially in browser-based applications. The white box is the browser: you can
    see, and possibly influence, the test. The black box is the server: your actions
    send a request, which is invisibly processed, and a response is returned.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试通常结合了白盒和黑盒环境，尤其是在基于浏览器的应用程序中。白盒是浏览器：你可以看到，并且可能影响测试。黑盒是服务器：你的操作发送一个请求，这个请求被无形地处理，然后返回一个响应。
- en: 7.2.1\. Vertical tests
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.1\. 垂直测试
- en: '*Vertical* end-to-end tests are designed to test the depth of a feature presented
    by the application. For a UI, this means testing that the correct validation is
    performed before one view transitions to another when the user performs an action.
    This validation might require specific user rights in LDAP and the retrieval of
    the correct settings from a database, for example.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*垂直*端到端测试旨在测试应用程序展示的功能深度。对于一个用户界面（UI），这意味着在用户执行操作时，从一个视图转换到另一个视图之前，需要执行正确的验证。这种验证可能需要特定的用户权限在LDAP中，例如，从数据库检索正确的设置。'
- en: You’re basically looking up and down at what you see, and making sure everything
    is in order. All the elements should be present, based on the environment you’ve
    specified, as shown in [figure 7.1](kindle_split_016_split_002.xhtml#ch07fig01).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你基本上是在上下查看你所看到的，并确保一切井然有序。所有元素都应该根据你指定的环境存在，如图[图7.1](kindle_split_016_split_002.xhtml#ch07fig01)所示。
- en: Figure 7.1\. A simple white-box vertical test
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.1\. 一个简单的白盒垂直测试
- en: '![](Images/07fig01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig01.jpg)'
- en: The figure may seem simplistic, but it’s important to perform these tests. Users
    of your application have associated user rights; how would users react if the
    Search button wasn’t rendered or the input text box was disabled due to a misinterpreted
    user right in your code?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 该图可能看起来很简单，但执行这些测试很重要。你的应用程序的用户有相关的用户权限；如果由于你的代码中对用户权限的错误解释，搜索按钮没有被渲染或输入文本框被禁用，用户会如何反应？
- en: 7.2.2\. Horizontal tests
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.2\. 水平测试
- en: '*Horizontal* end-to-end tests are designed to test across the entire scope
    of an application. For a UI, this means testing that one view transitions to another
    when the user performs an action. The vertical test ensures that you’re ready
    to make the transition through validation; the horizontal test checks that the
    action occurs and that the result is what you expect.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*横向*端到端测试旨在测试应用的全范围。对于一个UI，这意味着测试用户执行操作时，一个视图过渡到另一个视图。垂直测试确保你准备好通过验证进行过渡；横向测试则检查操作是否发生，以及结果是否符合预期。'
- en: Here, you’re looking from left to right for the correct transition from one
    view to the next. Has your action resulted in the correct expectation? Or, alternatively,
    has an invalid action been handled (negative testing)? [Figure 7.2](kindle_split_016_split_002.xhtml#ch07fig02)
    shows an example.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你从左到右寻找从一个视图到下一个视图的正确过渡。你的操作是否导致了正确的预期？或者，换句话说，是否处理了无效操作（负面测试）？[图7.2](kindle_split_016_split_002.xhtml#ch07fig02)展示了示例。
- en: Figure 7.2\. A black- and white-box horizontal test
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.2\. 黑盒和白盒横向测试
- en: '![](Images/07fig02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/07fig02.jpg)'
- en: The white-box action sends a request to the black-box server, which in turn
    delivers a response that’s rendered as a list. You need to test the transition
    and ensure that the list is displayed and that the contents are correct.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 白盒操作向黑盒服务器发送请求，服务器随后返回一个作为列表渲染的响应。你需要测试过渡并确保列表显示且内容正确。
- en: 7.3\. Introduction to end-to-end testing tools
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3\. 端到端测试工具简介
- en: End-to-end tests are notoriously difficult and complicated to write in monolithic
    applications. In a microservices architecture, writing such tests is even more
    complex, so anything that will help you is a bonus. Fortunately, a range of great
    tools and (you’ve guessed it) Arquillian extensions are available to aid you in
    this endeavor. Let’s take a look at some of them.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试在单体应用中编写起来非常困难和复杂。在微服务架构中，编写此类测试更加复杂，所以任何能帮助你的是个加分项。幸运的是，一系列优秀的工具和（你猜对了）Arquillian扩展可用以帮助你完成这项任务。让我们看看其中的一些。
- en: 7.3.1\. Arquillian Cube
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.1\. Arquillian Cube
- en: '*Arquillian Cube* ([http://arquillian.org/arquillian-cube/](http://arquillian.org/arquillian-cube/))
    is an extension to the Arquillian testing framework that enables the management
    of containers hosted in a Docker environment. You can use this extension to deploy
    a designed Docker image and test against it or in it. The environment hosted on
    the image can be as simple or elaborate as you wish. So, rather than the developer
    having to know about and try to provide access to all the collaborators (such
    as databases or other services) required for the test in the test code, you ship
    your developer’s test to an image that has everything in place already—only DevOps
    needs to worry about the evolving environment provided by the image.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*Arquillian Cube* ([http://arquillian.org/arquillian-cube/](http://arquillian.org/arquillian-cube/))
    是Arquillian测试框架的一个扩展，它使得管理Docker环境中的容器成为可能。你可以使用这个扩展来部署一个设计的Docker镜像，并对其进行测试或在其中测试。镜像上托管的环境可以像你希望的那样简单或复杂。因此，而不是开发者需要在测试代码中了解并尝试提供对所有协作者（如数据库或其他服务）的访问，你只需将开发者的测试发送到一个已经一切准备就绪的镜像——只有DevOps需要担心由镜像提供的不断变化的环境。'
- en: The Docker image should typically host an application server. Arquillian packages
    your application in the usual manner and publishes the WAR or EAR file to the
    hosted server. This is the same lifecycle described in [section 4.1](kindle_split_013_split_001.xhtml#ch04lev1sec1);
    the only difference here is that rather than deploying to a local application
    server, you deploy to the server in your hosted environment.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像通常应该托管一个应用服务器。Arquillian按照常规方式打包你的应用，并将WAR或EAR文件发布到托管服务器。这与[第4.1节](kindle_split_013_split_001.xhtml#ch04lev1sec1)中描述的生命周期相同；唯一的区别在于，这里不是部署到本地应用服务器，而是部署到托管环境中的服务器。
- en: This is a hefty subject, and you’ll find everything you need to know in [chapter
    8](kindle_split_017_split_000.xhtml#ch08), where we discuss Docker. For now, we’ll
    focus on *basic* end-to-end unit testing—which may seem like a contradiction in
    terms, because there’s still a lot to pull together. We’re presenting things in
    this order so you’ll understand the challenges involved in building up the environment
    and can see where things may go wrong. It’s better to know what’s going on under
    the hood before you step on the gas.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的主题，您将在第 8 章（[kindle_split_017_split_000.xhtml#ch08](kindle_split_017_split_000.xhtml#ch08)）中找到您需要了解的所有内容，我们将讨论
    Docker。现在，我们将专注于 *基本* 的端到端单元测试——这可能在术语上似乎有些矛盾，因为仍然有很多东西需要整合。我们按此顺序介绍内容，以便您了解构建环境所涉及到的挑战，并可以看到可能出错的地方。在您踩下油门之前，了解引擎盖下发生的事情会更好。
- en: 7.3.2\. Arquillian Drone
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.2\. Arquillian Drone
- en: '*Arquillian Drone* ([http://arquillian.org/arquillian-extension-drone/](http://arquillian.org/arquillian-extension-drone/))
    is an extension to the Arquillian testing framework that enables access to the
    well-known Selenium WebDriver ([https://seleniumhq.github.io/docs](https://seleniumhq.github.io/docs)),
    which, in turn, is used for browser automation. Browser automation is a critical
    requirement when you’re testing web-based UIs. It enables the test to mimic the
    actions of a real user browsing through your application and entering or manipulating
    data.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*Arquillian Drone* ([http://arquillian.org/arquillian-extension-drone/](http://arquillian.org/arquillian-extension-drone/))
    是 Arquillian 测试框架的一个扩展，它使得访问知名的 Selenium WebDriver ([https://seleniumhq.github.io/docs](https://seleniumhq.github.io/docs))
    成为可能，而 Selenium WebDriver 又被用于浏览器自动化。在测试基于 Web 的 UI 时，浏览器自动化是一个关键需求。它使得测试能够模拟真实用户浏览您的应用程序并输入或操作数据的行为。'
- en: Why should you use this extension if it’s just a wrapper for WebDriver? Well,
    anyone who has written tests using the naked WebDriver API will be quick to tell
    you that an incredible amount of boilerplate code is required, even for relatively
    simple tests. Drone hides much of this boilerplate code, enabling you to get on
    with writing the meat of your tests. There’s still some setup to perform, but
    we’ll walk through this in the example later in this chapter.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么您要使用这个扩展，如果它只是 WebDriver 的包装器呢？好吧，任何使用裸 WebDriver API 编写测试的人都会很快告诉你，即使是相对简单的测试，也需要大量的样板代码。Drone
    隐藏了大部分这些样板代码，让您能够专注于编写测试的核心部分。仍然有一些设置需要执行，但我们在本章后面的示例中会介绍这些内容。
- en: 7.3.3\. Arquillian Graphene 2
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.3\. Arquillian Graphene 2
- en: '*Arquillian Graphene 2* ([https://github.com/arquillian/arquillian-graphene](https://github.com/arquillian/arquillian-graphene))
    is (as the name indicates) a second-generation rapid-development extension, designed
    to complement Selenium WebDriver. Although it can be used to create standalone
    AJAX-enabled tests, Graphene works best together with the Arquillian Drone extension.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*Arquillian Graphene 2* ([https://github.com/arquillian/arquillian-graphene](https://github.com/arquillian/arquillian-graphene))
    是（正如其名称所示）第二代快速开发扩展，旨在补充 Selenium WebDriver。尽管它可以用来创建独立的 AJAX 启用测试，但 Graphene
    与 Arquillian Drone 扩展一起使用效果最佳。'
- en: 7.3.4\. JMeter
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.4\. JMeter
- en: '*JMeter* ([http://jmeter.apache.org](http://jmeter.apache.org)) is an Apache
    Software Foundation project that can be used to load-test just about any kind
    of endpoint. It’s an entirely Java-based solution, so it can be used across all
    supported platforms. It’s capable of simulating heavy network traffic and is primarily
    used to test the resilience of application endpoints. You’ll use it to create
    a few simple stress tests to ensure that your services can stand up to some load.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*JMeter* ([http://jmeter.apache.org](http://jmeter.apache.org)) 是 Apache 软件基金会的一个项目，可以用来对几乎所有类型的端点进行负载测试。它是一个完全基于
    Java 的解决方案，因此可以在所有支持的平台上使用。它能够模拟大量的网络流量，主要用于测试应用端点的弹性。您将使用它来创建一些简单的压力测试，以确保您的服务能够承受一定的负载。'
- en: 7.3.5\. Cukes in Space
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.5\. Cukes in Space
- en: '*Cukes in Space* ([https://github.com/cukespace/cukespace](https://github.com/cukespace/cukespace))
    is an Arquillian extension that allows you to run tests against a Cucumber JVM
    ([https://cucumber.io/docs/reference](https://cucumber.io/docs/reference)) using
    the common Given-When-Then convention.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*Cukes in Space* ([https://github.com/cukespace/cukespace](https://github.com/cukespace/cukespace))
    是一个 Arquillian 扩展，允许您使用常见的 Given-When-Then 规范在 Cucumber JVM ([https://cucumber.io/docs/reference](https://cucumber.io/docs/reference))
    上运行测试。'
- en: 7.4\. Example end-to-end test
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4\. 示例端到端测试
- en: Now that you have your tools, it’s time for an example end-to-end test. As we’ve
    mentioned, such tests are complicated, and this one is no different. You’re using
    a variety of technologies for the demo microservice applications, so you’ll have
    to deal with this extra complexity in the end-to-end test. The bonus is that you
    get to see a range of solutions, which should help you develop your own tests
    in the future. There are no hard-and-fast rules here—you use the tools you have,
    to get the results you need. The gloves are off.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有了工具，是时候进行一个示例端到端测试了。正如我们提到的，这样的测试很复杂，这个也不例外。您正在使用各种技术进行演示微服务应用程序，所以您必须在端到端测试中处理这种额外的复杂性。好处是您可以看到一系列解决方案，这应该有助于您在未来开发自己的测试。这里没有硬性规则——您使用您拥有的工具，以获得您需要的成果。现在放手一搏。
- en: 'We’re using a simple application for the frontend UI, to highlight the end-to-end
    processes; there are no surprises in store. Open a command line at the source
    code root directory, and run the following commands:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个简单的应用程序作为前端UI，以突出显示端到端过程；这里没有惊喜。在源代码根目录下打开命令行，并运行以下命令：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will build the web application and ensure that all required dependencies
    are available and cached. We’re skipping the test here, because we want to explain
    it in detail first.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这将构建Web应用程序并确保所有必需的依赖项都可用并缓存。我们在这里跳过测试，因为我们想首先详细解释它。
- en: 7.4.1\. Building the microservices
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.1. 构建微服务
- en: The first thing you need to do is ensure that all the sample microservice code
    you’ve seen so far is built and ready for you to use. You’ll use the real WAR
    and JAR files that these projects generate, to create a more realistic end-to-end
    test.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要做的第一件事是确保您迄今为止看到的所有示例微服务代码都已构建并准备好供您使用。您将使用这些项目生成的真实WAR和JAR文件来创建一个更真实的端到端测试。
- en: 'Open a command line at the source code root directory, and run the following
    commands:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在源代码根目录下打开命令行，并运行以下命令：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|  |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You thoroughly tested all the microservice applications in previous chapters,
    so you’ll cheat here by skipping the tests for brevity. Also, some of the tests
    in these projects are designed to fail, to highlight a point or to provide a user
    exercise.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您在前面章节中彻底测试了所有微服务应用程序，所以在这里为了简洁起见，您将跳过测试。此外，这些项目中的某些测试被设计为失败，以突出某个点或提供用户练习。
- en: '|  |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 7.4.2\. Adding the build dependencies and configuration
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.2. 添加构建依赖项和配置
- en: 'Next, you need to add the relevant bill of materials (BOM) imports to the build
    script `dependencyManagement` section of your web UI application (in code/web/pom.xml).
    There’s only one new import item: the `arquillian-drone-bom` artifact. This new
    BOM ensures that all the dependencies required for Drone are available.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要将相关的物料清单（BOM）导入添加到您的Web UI应用程序的构建脚本`dependencyManagement`部分（在code/web/pom.xml中）。只有一个新的导入项：`arquillian-drone-bom`工件。这个新的BOM确保Drone所需的所有依赖项都可用。
- en: Listing 7.1\. Adding the `arquillian-drone-bom` artifact
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.1. 添加`arquillian-drone-bom`工件
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `graphene-webdriver` artifact is required in the UI app for injecting the
    Selenium WebDriver. This WebDriver is what communicates with the browser to perform
    actions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: UI应用程序需要`graphene-webdriver`工件来注入Selenium WebDriver。这个WebDriver是与浏览器通信以执行操作的东西。
- en: Listing 7.2\. Adding the `graphene-webdriver` artifact
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.2. 添加`graphene-webdriver`工件
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Installing browser drivers for automation
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 安装自动化浏览器驱动程序
- en: You need to make sure the appropriate browser driver is installed for the testing
    browsers. We’re using the Chrome browser as the default testing browser, so be
    sure the ChromeDriver binary ([http://mng.bz/VZig](http://mng.bz/VZig)) is downloaded
    and accessible to Arquillian in the test configuration. This is defined in the
    `webdriver` extension element, using the `chromeDriverBinary` property in the
    project arquillian.xml file. At the time of writing, you should be able to locate
    the current drivers for the extensive list of supported browsers from [www.seleniumhq.org/download](http://www.seleniumhq.org/download).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要确保为测试浏览器安装了适当的浏览器驱动程序。我们使用Chrome浏览器作为默认的测试浏览器，因此请确保ChromeDriver二进制文件（[http://mng.bz/VZig](http://mng.bz/VZig)）已下载并且可以在测试配置中对Arquillian可访问。这定义在`webdriver`扩展元素中，使用项目`arquillian.xml`文件中的`chromeDriverBinary`属性。在撰写本文时，您应该能够从[www.seleniumhq.org/download](http://www.seleniumhq.org/download)找到支持浏览器的大量当前驱动程序。
- en: Listing 7.3\. Adding the browser driver
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.3. 添加浏览器驱动程序
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* The browser property, with a default value of chrome**'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 浏览器属性，默认值为chrome**'
- en: '***2* The chromeDriverBinary property, pointing to the driver binary**'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 指向驱动二进制的chromeDriverBinary属性**'
- en: '|  |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: As always, there’s plenty of information on the internet regarding the use of
    different testing browsers. The ideal solution is to define a different build
    profile for each browser you wish to test against, overriding the `browser` property
    at runtime.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 总是会有很多关于使用不同测试浏览器的信息在网上。理想的解决方案是为您希望测试的每个浏览器定义不同的构建配置文件，在运行时覆盖`browser`属性。
- en: '|  |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Using and defining NoSQL databases
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用和定义NoSQL数据库
- en: Some useful dependencies are the `de.flapdoodle.embed.mongo` and `embedded-redis`
    artifacts (code/web/pom.xml)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一些有用的依赖项是`de.flapdoodle.embed.mongo`和`embedded-redis`工件（code/web/pom.xml）
- en: Listing 7.4\. Adding dependencies
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.4\. 添加依赖项
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|  |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Warning
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: It’s possible to add all sorts of undefined magical plugins to the build scripts
    to ensure that these runtime dependencies are started. This is *not* recommended,
    because the test would no longer be self-contained and couldn’t be run by IDEs
    out of the box.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能向构建脚本添加各种未定义的神奇插件以确保这些运行时依赖项启动。这**不是**推荐的，因为测试将不再自包含，并且无法由IDE直接运行。
- en: '|  |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The neat libraries in [listing 7.4](kindle_split_016_split_004.xhtml#ch07ex04)
    enable your test to fire up a MongoDB instance and a Redis instance directly in
    the test with relatively little overhead. Due to the lifecycle management of the
    JUnit test as a whole, `@BeforeClass` usually isn’t early enough to bootstrap
    these requirements. Implementing JUnit rules allows you to include them deeper
    in the test lifecycle. Variables in the rules are used to keep a reference to
    the process, so that you can clean up after the test is complete. The libraries
    used in the rules you’ll define in a moment will download and initialize the MongoDB
    and Redis instances for you. You don’t have to manually prepare anything, and
    your tests remain self-contained.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表7.4](kindle_split_016_split_004.xhtml#ch07ex04)中的整洁库能够在测试中直接启动MongoDB实例和Redis实例，相对开销很小。由于JUnit测试的整体生命周期管理，`@BeforeClass`通常不足以启动这些需求。实现JUnit规则允许您在测试生命周期中更深入地包含它们。规则中的变量用于保持对进程的引用，以便在测试完成后进行清理。您将在稍后定义的规则中使用的库将为您下载并初始化MongoDB和Redis实例。您无需手动准备任何东西，并且您的测试保持自包含。'
- en: The simple Mongod rule shown in the following listing (code/web/src/test/java/book/web/rule/MongodRule.java)
    fires up a Mongod instance that’s bound to the provided host and port. For your
    test, you don’t need any more than this, but the library API allows for a complete
    configuration. It would be easy to modify the rule to accept more parameters if
    you needed them.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表（code/web/src/test/java/book/web/rule/MongodRule.java）中展示的简单Mongod规则启动了一个绑定到提供的宿主和端口的Mongod实例。对于您的测试，您不需要更多，但库API允许进行完整的配置。如果您需要，可以轻松修改规则以接受更多参数。
- en: Listing 7.5\. Mongod rule
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.5\. Mongod规则
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* The before phase creates and executes the Mongod process.**'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在准备阶段创建并执行Mongod进程。**'
- en: '***2* The after phase ensures that the process is terminated and cleaned up.**'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在清理阶段确保进程被终止并清理。**'
- en: The Redis rule is basically the same (code/web/src/test/java/book/web/rule/RedisRule.java),
    but it uses the `RedisServer` provided by the library.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Redis规则基本上与（code/web/src/test/java/book/web/rule/RedisRule.java）相同，但它使用库提供的`RedisServer`。
- en: Listing 7.6\. Redis rule
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.6\. Redis规则
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|  |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Hats off to Krzysztof Styrc ([https://github.com/kstyrc](https://github.com/kstyrc))
    and Michael Mosmann ([https://github.com/michaelmosmann](https://github.com/michaelmosmann))
    and their teams for providing these great OSS projects!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 向Krzysztof Styrc ([https://github.com/kstyrc](https://github.com/kstyrc)) 和Michael
    Mosmann ([https://github.com/michaelmosmann](https://github.com/michaelmosmann))
    及他们的团队致敬，感谢他们提供这些优秀的开源项目！
- en: '|  |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: We hope you can see that it’s pretty easy to wrap all kinds of test resources
    using the JUnit rule mechanism. As we mentioned, you’ll put these rules to use
    in the example test later.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望您能看出，使用JUnit规则机制来包装各种测试资源非常简单。正如我们提到的，您将在后面的示例测试中使用这些规则。
- en: Providing the microservice runtime environments
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提供微服务运行时环境
- en: The principal runtime environment we’re providing for this example test is Apache
    TomEE ([http://tomee.apache.org](http://tomee.apache.org)). You could choose any
    Java EE environment to deploy your WAR files to, as long as it’s EE compatible.
    You also have a Spring Boot application and a WildFly fat JAR, but you’ll deal
    with those later.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为这个示例测试提供的首要运行时环境是Apache TomEE ([http://tomee.apache.org](http://tomee.apache.org))。你可以选择任何Java
    EE环境来部署你的WAR文件，只要它是EE兼容的。你还有一个Spring Boot应用程序和一个WildFly fat JAR，但稍后你将处理这些。
- en: Apache TomEE provides a Maven plugin that allows you to automatically create
    a ready-to-run server directory gamerwebapp in your target directory. This is
    a complete TomEE server distribution that’s downloaded and extracted by the plugin.
    This process is attached to the Maven *validate* phase every time a build is run.
    Add the following code to code/web/pom.xml.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Apache TomEE提供了一个Maven插件，允许你在目标目录中自动创建一个可运行的server目录gamerwebapp。这是一个完整的TomEE服务器发行版，由插件下载并解压。每次运行构建时，此过程都会附加到Maven
    *validate*阶段。将以下代码添加到code/web/pom.xml中。
- en: Listing 7.7\. Adding the Apache TomEE runtime environment
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.7\. 添加Apache TomEE运行时环境
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There is one caveat: the plugin downloads the TomEE server in the Maven build
    phase to a local directory in the project. This would be fine if you were to just
    run the build script. But if you want to debug a test in your IDE, you need to
    have run the build script at least once:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个注意事项：插件在Maven构建阶段将TomEE服务器下载到项目的一个本地目录。如果你只是运行构建脚本，这将是可行的。但如果你想在IDE中调试测试，你需要至少运行一次构建脚本：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first time you run this, it will take a while, because TomEE needs to be
    downloaded and extracted to a project local directory. Subsequent builds will
    be much faster.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行此操作时，需要一段时间，因为TomEE需要下载并解压到项目本地目录。后续构建将快得多。
- en: You then do a little Maven magic, using `<artifactId>maven-resources-plugin</artifactId>`
    to create multiple copies of the previously created gamerwebapp directory. The
    following code is repeated for each microservice WAR file that you want to deploy
    as a standalone microservice WAR. Again, open pom.xml in your IDE to get the full
    picture.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你进行一点Maven魔法，使用`<artifactId>maven-resources-plugin</artifactId>`来创建之前创建的gamerwebapp目录的多个副本。以下代码会为每个你想要部署为独立微服务WAR文件的微服务WAR文件重复。再次提醒，打开你的IDE中的pom.xml文件以获取完整信息。
- en: Listing 7.8\. Copying target/gamerwebapp to target/commentsservice
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.8\. 将target/gamerwebapp复制到target/commentsservice
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Adding a group to arquillian.xml
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在arquillian.xml中添加一个组
- en: You already know that you can define multiple containers in the arquillian.xml
    configuration file. This is perfect for what you need when it comes to providing
    multiple microservice environments supported by the Arquillian framework.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道你可以在arquillian.xml配置文件中定义多个容器。这对于提供由Arquillian框架支持的多个微服务环境来说非常完美。
- en: Listing 7.9\. Defining a group
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.9\. 定义一个组
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1* Group definition, flagged here as the default**'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 组定义，在此标记为默认**'
- en: '***2* Defines a container with a unique qualifier**'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 定义一个具有唯一限定符的容器**'
- en: '***3* Container-specific properties to define the HTTP port and protocol ports.
    TomEE uses -1 to indicate that a random port should be used.**'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 容器特定的属性，用于定义HTTP端口和协议端口。TomEE使用-1来指示应使用随机端口。**'
- en: '***4* Path to the actual server directory (as previously defined/created in
    pom.xml)**'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 实际服务器目录的路径（如之前在pom.xml中定义/创建的）**'
- en: If you’re still wondering about the Spring Boot and WildFly microservices, don’t
    worry. You’re nearly there; just one more section.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还在担心Spring Boot和WildFly微服务，不要担心。你几乎完成了；只需再有一个部分。
- en: 7.4.3\. Adding @Deployment and @TargetsContainer to the test
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.3\. 在测试中添加@Deployment和@TargetsContainer
- en: The test class is getting large—it has a lot to accomplish. We’ll focus on each
    core element. You can open the test in your IDE of choice to get the full picture,
    but you’ve already seen much of this in previous chapters. Outside the scope of
    an example, we suggest placing most of the initialization and deployment code
    in an abstract class for reuse in other tests.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类正在变得庞大——它有很多事情要做。我们将关注每个核心元素。你可以打开你选择的IDE中的测试以获取完整信息，但你已经在之前的章节中看到了很多。在示例范围之外，我们建议将大部分初始化和部署代码放在一个抽象类中，以便在其他测试中重用。
- en: '|  |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: If possible, build a deployment starting with a ShrinkWrap of the WAR file for
    the microservice. Then add the `provided` scoped artifacts to the mix of dependencies
    that the microservice requires. This means the test is as close as possible to
    a real production deployment.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能，从一个微服务的WAR文件ShrinkWrap开始构建部署。然后向微服务所需的依赖项混合中添加`provided`范围的工件。这意味着测试尽可能接近真实的生产部署。
- en: '|  |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The next thing you need to do is to ensure that *all* of your microservices
    are made available to the test class. You’ll begin with the easy deployments (code/web/src/test/java/book/web/EndToEndTest.java).
    Later sections will cover more elaborate deployments using JUnit rules.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步你需要做的是确保**所有**你的微服务都对测试类可用。你将从简单的部署开始（code/web/src/test/java/book/web/EndToEndTest.java）。后面的章节将涵盖使用JUnit规则进行更复杂的部署。
- en: Listing 7.10\. Adding `@Deployment` and `@TargetsContainer`
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.10\. 添加`@Deployment`和`@TargetsContainer`
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* Defines a unique deployment name, which is important when testing against
    multiple containers**'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义一个唯一的部署名称，这在针对多个容器进行测试时很重要**'
- en: '***2* @TargetsContainer(“[name]”) ensures the application is deployed to the
    specified container, as defined in arquillian.xml.**'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* @TargetsContainer(“[name]”)确保应用程序被部署到在arquillian.xml中定义的指定容器中。**'
- en: You can in theory specify an endless number of containers in the arquillian.xml
    file, which can then be bound to an endless number of deployments in your test.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在理论上，你可以在arquillian.xml文件中指定无限数量的容器，然后可以将它们绑定到测试中的无限数量的部署。
- en: '|  |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The TomEE plugin includes options to add `provided` scoped artifacts directly
    to the server runtime lib directory (which is what `provided` means, after all).
    For more information, check out the plugin documentation ([http://tomee.apache.org/maven/index.html](http://tomee.apache.org/maven/index.html)).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: TomEE插件包括选项，可以直接将`provided`范围的工件添加到服务器运行时lib目录中（毕竟这就是`provided`的含义）。有关更多信息，请参阅插件文档([http://tomee.apache.org/maven/index.html](http://tomee.apache.org/maven/index.html))。
- en: '|  |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 7.4.4\. Cross-origin resource sharing
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.4\. 跨源资源共享
- en: You may have noticed that, to allow access to RESTful endpoints from different
    hosts, you’ve enabled cross-origin resource sharing (CORS) on several of your
    microservices. You should only do this in your own environments once you fully
    understand the implications. But it’s often necessary in test environments—especially
    where multiple services are bound to multiple ports on the same local machine.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，为了允许从不同主机访问RESTful端点，你在多个微服务上启用了跨源资源共享（CORS）。你应该只在完全理解其影响后在自己的环境中这样做。但在测试环境中，尤其是在多个服务绑定到同一本地机器上的多个端口时，这通常是必要的。
- en: 'CORS is required only for scenarios where a service receives requests from
    a different host than the serving host: for example, a standalone microservice.
    The configuration is required on the serving host to allow specified hosts to
    consume the available services.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: CORS仅在服务从不同于服务主机的不同主机接收请求的场景中是必需的：例如，一个独立的微服务。配置需要在服务主机上进行，以允许指定的主机消费可用的服务。
- en: The CORS configuration varies for different application servers, so you’ll need
    to check the relevant documentation for your server of choice. The following example
    depicts a liberal configuration for Apache TomEE (code/web/src/test/resources/test-web.xml).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: CORS配置因不同的应用程序服务器而异，因此你需要检查你选择的服务器的相关文档。以下示例展示了Apache TomEE的宽松配置（code/web/src/test/resources/test-web.xml）。
- en: Listing 7.11\. Enabling CORS for TomEE or Tomcat
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.11\. 为TomEE或Tomcat启用CORS
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Most of your services are likely to be hosted in the same domain in production
    and won’t require such a liberal configuration.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你的大部分服务在生产中可能托管在同一个域中，并且不需要这样的宽松配置。
- en: 7.4.5\. Coping with a mixed environment using @ClassRule
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.5\. 使用@ClassRule应对混合环境
- en: At the time of writing, Arquillian isn’t able to mix different container environments
    in the same runtime out of the box. This will be problematic when you require
    that in your tests, because you’ve used multiple environments. You can create
    your own container implementation that wraps multiple environments, but that goes
    beyond the scope of this book.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Arquillian无法默认在同一个运行时中混合不同的容器环境。当你需要在测试中使用这种情况时，这将会成为一个问题，因为你使用了多个环境。你可以创建自己的容器实现，它封装了多个环境，但这超出了本书的范围。
- en: The solution we chose is simple, though a little verbose. You know that the
    Spring Boot and WildFly Swarm projects produce fat JARs, and that these JAR files
    are executable. You’ve also seen how to define JUnit rules to wrap external processes
    (Mongod and Redis). Armed with this knowledge, it’s relatively straightforward
    to use the JVM `ProcessBuilder` to execute these services and manage the process
    lifecycle in a rule, as shown in [listing 7.12](kindle_split_016_split_004.xhtml#ch07ex12)
    (code/web/src/test/java/book/web/rule/MicroserviceRule.java).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择的解决方案简单，尽管有点冗长。你知道 Spring Boot 和 WildFly Swarm 项目会生成胖 JAR，并且这些 JAR 文件是可执行的。你也看到了如何定义
    JUnit 规则来包装外部进程（Mongod 和 Redis）。有了这些知识，使用 JVM 的 `ProcessBuilder` 来执行这些服务并在规则中管理进程生命周期相对简单，如[列表
    7.12](kindle_split_016_split_004.xhtml#ch07ex12)（code/web/src/test/java/book/web/rule/MicroserviceRule.java）所示。
- en: The caveat is that even though the process may have started, you can’t use the
    service until the endpoint is accessible. To solve this issue, you can use a simple
    connect method in the test sequence that waits for a valid connection to a specified
    endpoint.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，即使进程可能已经启动，你也不能在端点可访问之前使用该服务。为了解决这个问题，你可以在测试序列中使用一个简单的连接方法，等待指定端点的有效连接。
- en: Listing 7.12\. code/web/src/test/java/book/web/rule/MicroserviceRule.java
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.12\. code/web/src/test/java/book/web/rule/MicroserviceRule.java
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1* Using a builder pattern for parameters makes it easy to use the rule
    inline.**'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用构建器模式来设置参数，使得规则的内联使用变得简单。**'
- en: '***2* Uses the default ResolutionStrategy to find the Java executable (Overridable)**'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用默认的 ResolutionStrategy 来查找 Java 可执行文件（可覆盖）**'
- en: '***3* Starts the microservice fat JAR executable process**'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 启动微服务的胖 JAR 可执行进程**'
- en: '***4* Polls the specified endpoint URL for a successful connection**'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 轮询指定的端点 URL 以建立成功连接**'
- en: '***5* Waits for a connection or a timeout after the specified period**'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 在指定时间段后等待连接或超时**'
- en: '***6* Uses a lock to synchronize the startup and shutdown process**'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 使用锁来同步启动和关闭过程**'
- en: '***7* You’re only interested in a valid connection to the endpoint, not the
    response.**'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 你只关心端点的有效连接，而不是响应。**'
- en: Just as `before` is used to initialize resources, you use `after` to clean them
    up.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正如使用 `before` 来初始化资源一样，你使用 `after` 来清理它们。
- en: '|  |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You aren’t actually testing the endpoints; you’re using them to confirm that
    your end-to-end tests are ready to be performed. Feel free to write your own connection-checking
    routine to suit your needs.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你实际上并不是在测试端点；你使用它们来确认你的端到端测试准备就绪。请随意编写自己的连接检查例程以满足你的需求。
- en: '|  |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now the rules have been implemented, and all you need to do is use them in the
    test.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在规则已经实现，你所需要做的就是将它们用于测试。
- en: '|  |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Avoid using the non-static JUnit `@Rule` annotation, because it would stop and
    start *all* the rule processes for *each* individual test!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用非静态的 JUnit `@Rule` 注解，因为它会停止和启动每个单独测试的 *所有* 规则进程！
- en: '|  |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 7.13\. code/web/src/test/java/book/web/EndToEndTest.java - @ClassRule
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.13\. code/web/src/test/java/book/web/EndToEndTest.java - @ClassRule
- en: '[PRE15]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* Uses a static JUnit RuleChain to ensure that the rules are executed in
    the defined order, as early as possible**'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用静态 JUnit RuleChain 确保规则尽可能早地按定义的顺序执行**'
- en: '***2* Begins with the MongodRule**'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 以 MongodRule 开始**'
- en: '***3* Uses the RedisRule**'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用 RedisRule**'
- en: '***4* The RedisRule is followed by the MicroserviceRule, which can be specified
    in any order if they aren’t dependent on each other.**'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* RedisRule 在 MicroserviceRule 之后，如果它们不相互依赖，可以指定任何顺序。**'
- en: If any of your services are dependent on each other, this is where you can define
    the startup order.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的任何服务相互依赖，你可以在定义启动顺序的地方这样做。
- en: '|  |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Defining timeouts is hardly deterministic in all cases. For end-to-end tests,
    you have to break this rule for obvious reasons—the connection polling might never
    be successful. Try to tune the parameters to be as deterministic as possible for
    your environment.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 定义超时在所有情况下几乎都不是确定性的。对于端到端测试，你必须出于明显的原因打破这个规则——连接轮询可能永远不会成功。尝试调整参数以尽可能地在你的环境中实现确定性。
- en: '|  |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 7.4.6\. Operating on the deployments with @OperateOnDeployment
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.6\. 使用 @OperateOnDeployment 操作部署
- en: You’ve seen several times how to define and use multiple deployments. In [listing
    7.13](kindle_split_016_split_004.xhtml#ch07ex13), the `@OperateOnDeployment` annotation
    refers to the deployment that a particular test should use. You’re also injecting
    the resource URL using the `@ArquillianResource` annotation. You’re using the
    `@InSequence` annotation to provide the order of tests, which, strictly speaking,
    is a big no-no for normal unit tests. For end-to-end tests, you already know that
    you have to logically coordinate the environment, so it’s virtually impossible
    to allow tests to run arbitrarily. There will always be an order of action, but
    the tests should still be performing a unit of work.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经多次看到如何定义和使用多个部署。在 [列表 7.13](kindle_split_016_split_004.xhtml#ch07ex13) 中，`@OperateOnDeployment`
    注解指向特定测试应使用的部署。你还在使用 `@ArquillianResource` 注解注入资源 URL。你使用 `@InSequence` 注解来提供测试的顺序，严格来说，这对于正常单元测试来说是一个大忌。对于端到端测试，你已经知道你必须逻辑上协调环境，因此几乎不可能允许测试任意运行。总会有一个操作顺序，但测试仍然应该执行一个工作单元。
- en: Listing 7.14\. Defining multiple deployments
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.14\. 定义多个部署
- en: '[PRE16]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 7.4.7\. Introducing @Drone, page objects, @Location, and the WebDriver
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.7\. 介绍 @Drone、页面对象、@Location 和 WebDriver
- en: The WebDriver could be injected directly into your test using the `@Drone` annotation.
    A better way is to create *page objects* for all browser-related tests. Page objects
    are nothing more than virtual wrappers designed to represent a single viewable
    page or element of your UI application. They should only encapsulate logic specific
    to the page or element at hand.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: WebDriver 可以通过 `@Drone` 注解直接注入到你的测试中。更好的方法是创建所有与浏览器相关的测试的 *页面对象*。页面对象不过是虚拟包装器，旨在表示你的
    UI 应用程序的单个可查看页面或元素。它们应该只封装与当前页面或元素相关的特定逻辑。
- en: The following listing shows an example of the `Index` page object (code/web/src/test/java/book/web/page/Index.java).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了 `Index` 页面对象的示例（code/web/src/test/java/book/web/page/Index.java）。
- en: Listing 7.15\. A sample page object
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.15\. 一个页面对象示例
- en: '[PRE17]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1* The optional @Location annotation defines where the page is found on
    the server.**'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 可选的 @Location 注解定义了页面在服务器上的位置。**'
- en: '***2* Uses the WebDriver to access browser features**'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用 WebDriver 访问浏览器功能**'
- en: '***3* An element, located by its physical DOM identifier using the Selenium
    @FindBy annotation**'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用 Selenium @FindBy 注解通过其物理 DOM 标识符定位的元素**'
- en: '***4* Provides an embedded page fragment (more on that in a moment)**'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 提供一个嵌入式页面片段（稍后详细介绍）**'
- en: '***5* Manages the browser environment programmatically**'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 以编程方式管理浏览器环境**'
- en: '***6* Sends keypresses to the selected HTML element (the text box, in this
    case)**'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 向选定的 HTML 元素（在这个例子中是文本框）发送按键**'
- en: '***7* Uses Graphene to wait (block) for the list response**'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 使用 Graphene 等待（阻塞）列表响应**'
- en: '***8* Returns the page fragment for further use**'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 返回页面片段以供进一步使用**'
- en: 'Another cool feature is being used here: *page fragments*, which are objects
    that represent dynamic elements of the UI page. The next listing shows an example
    (code/web/src/test/java/book/web/page/List.java). You can use page fragments to
    provide a logical model for the test to operate on. They can be nested, which
    makes them useful for defining UI transitions. Using Graphene allows the test
    to automatically block while the UI performs the transition.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还使用了一个酷炫的功能：*页面片段*，它们是表示 UI 页面动态元素的对象。下一个列表显示了示例（code/web/src/test/java/book/web/page/List.java）。你可以使用页面片段为测试提供一个逻辑模型。它们可以嵌套，这使得它们对于定义
    UI 转换非常有用。使用 Graphene 允许测试在 UI 执行转换时自动阻塞。
- en: Listing 7.16\. A sample page fragment
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.16\. 一个页面片段示例
- en: '[PRE18]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* Provides another nested page fragment**'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 提供另一个嵌套页面片段**'
- en: '***2* Gathers results to use for validation in the test**'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 收集结果以用于测试中的验证**'
- en: '***3* Uses Graphene to wait (block) for the detail response**'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用 Graphene 等待（阻塞）详细响应**'
- en: '***4* Returns the Detail fragment for further use**'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 返回详细片段以供进一步使用**'
- en: '|  |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This simple example opens the door to the big, wild world of Selenium browser
    automation. This subject would easily fill another book; take some time to visit
    the documentation at [www.seleniumhq.org/docs](http://www.seleniumhq.org/docs).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子打开了 Selenium 浏览器自动化的广阔、狂野世界。这个主题可以轻易填满另一本书；花些时间访问 [www.seleniumhq.org/docs](http://www.seleniumhq.org/docs)
    的文档。
- en: '|  |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 7.4.8\. Working with page objects in a test
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.8\. 在测试中使用页面对象
- en: Once you’ve defined a page object, you inject it into your test using the `@Page`
    annotation as shown next (code/web/src/test/java/book/web/EndToEndTest.java).
    This can then be used to operate on the testing browser to perform tests.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您定义了一个页面对象，您就可以使用`@Page`注解将其注入到您的测试中，如下所示（code/web/src/test/java/book/web/EndToEndTest.java）。然后可以使用它来操作测试浏览器以执行测试。
- en: Listing 7.17\. Injecting a page object
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.17\. 注入页面对象
- en: '[PRE19]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* The page object is injected using @Page, and it will @OperateOnDeployment(“gamerweb”).**'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 页面对象使用@Page注入，并且它将@OperateOnDeployment(“gamerweb”)。**'
- en: '***2* Uses the page object methods**'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用页面对象方法**'
- en: '***3* Simple developer trick to halt the test (more in the “[Development hack](kindle_split_016_split_004.xhtml#ch07sb01)”
    sidebar)**'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 简单的开发者技巧来停止测试（更多内容请参阅“[开发技巧](kindle_split_016_split_004.xhtml#ch07sb01)”侧边栏）**'
- en: Notice that you provide the URL in the `navigateTo` method. This is a programmatic
    alternative to using the `@Location` annotation, which can sometimes be too inflexible.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您在`navigateTo`方法中提供了URL。这是使用`@Location`注解的程序化替代方案，有时它可能过于僵化。
- en: '|  |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Development hack**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**开发技巧**'
- en: Using a `ServerSocket` to halt the runtime is a simple development trick that
    you may find useful. In effect, by “running” the test class in either the IDE
    or Maven, you’ll have fired up all your microservices at this point. This technique
    is useful for developing the UI, because you know where all the service endpoints
    are. Providing the `-Ddev.hack=true` system property to the test runtime will
    ensure that it waits indefinitely for a connection on port 9999.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ServerSocket`来停止运行是一个简单的开发技巧，您可能会觉得很有用。实际上，通过在IDE或Maven中“运行”测试类，您此时已经启动了所有微服务。这项技术对于开发UI很有用，因为您知道所有服务端点的位置。向测试运行时提供`-Ddev.hack=true`系统属性将确保它无限期地等待9999端口的连接。
- en: You can deploy the web application to a debuggable container in your IDE and
    continue to develop against the running services. To stop the test runtime, make
    a simple `curl localhost:9999` call.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将Web应用程序部署到IDE中的可调试容器中，并继续针对运行中的服务进行开发。要停止测试运行时，请执行简单的`curl localhost:9999`调用。
- en: Obviously this approach won’t be useful for everyone, and microservices are
    often developed and deployed by individual teams, but it may be food for thought.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这种方法对每个人来说可能都不适用，微服务通常由个别团队开发和部署，但这可能值得思考。
- en: '|  |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The last things that may be of interest are the configuration options available
    to Graphene. The various guard methods block for a configurable period. The default
    configuration can be overridden via the command line
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后可能引起兴趣的是Graphene可用的配置选项。各种守卫方法会阻塞一个可配置的周期。默认配置可以通过命令行覆盖
- en: '[PRE20]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: or in arquillian.xml, as shown in the following listing.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在arquillian.xml中，如下所示。
- en: Listing 7.18\. Overriding the default configuration
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.18\. 覆盖默认配置
- en: '[PRE21]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There are many more ways to use Graphene than we’ve laid out here, but again,
    this subject goes out of scope for this book. If you want more insight about what’s
    available, you can find the project documentation at [https://docs.jboss.org/author/display/ARQGRA2/Home](https://docs.jboss.org/author/display/ARQGRA2/Home).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在这里提到的，还有许多其他使用石墨烯的方法，但同样，这个主题超出了本书的范围。如果您想了解更多关于可用性的信息，您可以在[https://docs.jboss.org/author/display/ARQGRA2/Home](https://docs.jboss.org/author/display/ARQGRA2/Home)找到项目文档。
- en: 7.4.9\. Running the test
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.9\. 运行测试
- en: After all that, it’s going to be a real nightmare to get this test up and running,
    right? Wrong! Running the test should be as intuitive as any other unit test—that’s
    the idea, after all.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些之后，让这个测试运行起来可能真的会是一场噩梦，对吧？错！运行测试应该像任何其他单元测试一样直观——毕竟，这就是目标。
- en: '|  |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you haven’t obtained the required API keys and defined the corresponding
    environment entries, as described in [chapter 2](kindle_split_011_split_000.xhtml#ch02),
    then please do so before running the test. Because it’s an end-to-end test, this
    test makes real calls to the REST APIs using these keys; the test also requires
    an internet connection.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有获取所需的API密钥并定义相应的环境条目，如第2章[所述](kindle_split_011_split_000.xhtml#ch02)，请在运行测试之前这样做。因为这个是端到端测试，这个测试会使用这些密钥对REST
    API进行实际调用；测试还需要互联网连接。
- en: '|  |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Here are the commands:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是命令：
- en: '[PRE22]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'That’s it. If everything is in place, the following things occur:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。如果一切就绪，以下事情会发生：
- en: '**1**.  The MongoDB and Redis servers are deployed and started by the test
    class rules.'
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  测试类规则部署并启动了MongoDB和Redis服务器。'
- en: '**2**.  The independent microservices are started by the test class rules.'
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  测试类规则启动了独立的微服务。'
- en: '**3**.  All the Arquillian-managed containers are started, and the corresponding
    applications are deployed.'
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**.  启动了所有Arquillian管理的容器，并部署了相应的应用程序。'
- en: '**4**.  A test browser is started by Arquillian Drone, and the UI is displayed.'
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**.  Arquillian Drone启动了一个测试浏览器，并显示了用户界面。'
- en: '**5**.  Each test runs in sequence to provide access to the microservices and
    web application.'
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**.  每个测试按顺序运行，以提供对微服务和Web应用程序的访问。'
- en: '**6**.  The environment is terminated cleanly—all servers are shut down.'
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**6**.  环境被干净地终止——所有服务器都已关闭。'
- en: '[Figure 7.3](kindle_split_016_split_004.xhtml#ch07fig03) shows an example.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7.3](kindle_split_016_split_004.xhtml#ch07fig03)展示了示例。'
- en: Figure 7.3\. The UI automation during testing
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.3\. 测试期间的UI自动化
- en: '![](Images/07fig03_alt.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig03_alt.jpg)'
- en: '|  |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Warning
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: If you encounter the error message “Target exists and we haven’t been flagged
    to overwrite it,” perform a `maven clean` cycle. This error usually means the
    last test run wasn’t completed properly and failed to perform a cleanup on termination.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到错误消息“目标存在，我们没有标记为覆盖它”，请执行`maven clean`周期。这个错误通常意味着最后一次测试运行没有正确完成，并且在终止时未能执行清理。
- en: '|  |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You’ll notice that this test is extremely slow. This can rarely be avoided in
    end-to-end tests, due to the amount of wiring that needs to be performed. The
    only real solution is to perform end-to-end testing on a dedicated machine other
    than the developer machines. We suggest creating all end-to-end tests in a dedicated
    build module. This module can then be activated in a build profile that’s only
    enabled on the external machine, such as Jenkins or Bamboo. See [http://mng.bz/JDcT](http://mng.bz/JDcT)
    for more information on Maven build profiles.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这个测试非常慢。在端到端测试中，这通常难以避免，因为需要执行大量的连接操作。唯一的真正解决方案是在除开发机器之外的专用机器上执行端到端测试。我们建议在专用构建模块中创建所有端到端测试。然后，可以在仅在外部机器（如Jenkins或Bamboo）上启用的构建配置文件中激活此模块。有关Maven构建配置文件的信息，请参阅[http://mng.bz/JDcT](http://mng.bz/JDcT)。
- en: 7.5\. Exercise
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5\. 练习
- en: You now have a basic test template in place that contains all the features you
    need to perform an effective end-to-end test using several microservices. We know
    it’s not pretty, but this is mostly because you’re not using a thoroughbred environment.
    Your only real task here is to assess the information and environment provided
    for the test.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在有一个基本的测试模板，其中包含你执行有效端到端测试所需的全部功能，使用多个微服务。我们知道它并不漂亮，但这主要是因为你没有使用纯种环境。你在这里的唯一真正任务是评估为测试提供的信息和环境。
- en: The `@InSequence(7)` test starts with a vertical test assertion that checks
    whether the input was correct. It then performs a horizontal action by triggering
    the search and retrieving the result `List`. The test is obviously breaking the
    rule of performing a unit of work, but it does so for demonstration purposes.
    Continue by extracting the assertions into further `@InSequence(x)` test methods.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`@InSequence(7)`测试从垂直测试断言开始，检查输入是否正确。然后通过触发搜索并检索结果`List`执行水平操作。显然，这个测试违反了执行单一工作单元的规则，但它这样做是为了演示目的。继续通过将断言提取到更进一步的`@InSequence(x)`测试方法中。'
- en: Also, although you’ve started the Mongod and Redis instances, you haven’t actually
    seeded the databases with any test data. Try skipping back to [chapter 5](kindle_split_014_split_000.xhtml#ch05)
    and adding a populator to the test. The world is your oyster!
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，尽管你已经启动了Mongod和Redis实例，但你实际上并没有用任何测试数据对数据库进行初始化。尝试跳回到[第5章](kindle_split_014_split_000.xhtml#ch05)并添加一个填充器到测试中。世界是你的牡蛎！
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: 'End-to-end testing is as important as all other forms of testing, if not more
    so, and should be performed on all applications that require any kind of user
    interaction. The overhead will reap rewards later: that’s a promise!'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端到端测试与其他所有形式的测试一样重要，如果不是更重要的话，并且应该在所有需要任何形式用户交互的应用程序上执行。额外的开销将在以后带来回报：这是一个承诺！
- en: Always use abstractions and reuse code wherever possible to build your own test
    suite.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是尽可能使用抽象和重用代码来构建自己的测试套件。
- en: Plan end-to-end testing early in the design of your UI application, to reduce
    the impact later.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在UI应用程序的设计早期规划端到端测试，以减少后续的影响。
- en: Adding logical, well-defined UI attributes such as `name` and `id` to featured
    tags in your application will ensure that it’s ready to accept the automated actions
    promoted through the Selenium driver. Try to define and stick to your own naming
    conventions.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的应用程序中为特色标签添加逻辑上明确定义的UI属性，如`name`和`id`，将确保它准备好接受通过Selenium驱动程序推广的自动化操作。尽量定义并坚持您自己的命名约定。
