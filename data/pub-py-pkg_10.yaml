- en: 10 Scaling and solidifying your practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 规模化和巩固你的实践
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Extracting a project template to create future packages using cookiecutter
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用cookiecutter提取项目模板以创建未来的包
- en: Publishing and installing packages with a private package repository server
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用私有包仓库服务器发布和安装包
- en: Using namespace packages to split large projects across several packages
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命名空间包将大型项目拆分到几个包中
- en: You’ve spent the majority of this book working up to the act of publishing a
    package. Throughout this book, I’ve emphasized the value of a repeatable process
    and automation, but so far what you’ve focused on is for only a single package.
    Now that you have a solid process in place for your package, what about the next
    package you want to create? Whether you’re interested in maintaining open source
    projects or becoming the subject matter expert on Python packaging in your organization,
    you’ll inevitably create and publish more packages. Although you might want to
    reinforce some of what you’ve learned by building another package from scratch,
    the process will start to feel pretty monotonous after the fourth or fifth one.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这本书的大部分时间里都在为发布一个包做准备。在这本书的整个过程中，我强调了可重复的过程和自动化的价值，但到目前为止，你关注的是单个包。现在你已经为你的包建立了一个稳固的过程，那么你接下来想要创建的下一个包呢？无论你是想维护开源项目，还是成为你组织中Python打包的专家，你不可避免地会创建和发布更多的包。虽然你可能希望通过从头开始构建另一个包来巩固你所学的内容，但经过四五个包之后，这个过程可能会开始显得相当单调。
- en: In this chapter, you’ll learn how to extract the common elements from your existing
    package and some techniques for working with private and large distributed package
    projects at scale.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何从现有的包中提取常见元素，以及一些在规模上处理私有和大型分布式包项目的技巧。
- en: Important Before reading on, visit appendix B to install the tools you’ll need
    for this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 重要 在继续阅读之前，请访问附录B以安装本章所需的工具。
- en: You can use the code companion ([http://mng.bz/69A5](http://mng.bz/69A5)) to
    check your work for the exercises in this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用代码伴侣([http://mng.bz/69A5](http://mng.bz/69A5))来检查本章练习的工作。
- en: 10.1 Creating a project template for future packages
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 为未来的包创建项目模板
- en: As a general rule, each project you create should have one clear responsibility.
    This helps you have tough conversations with people asking for new features, because
    you can more easily determine what does and doesn’t belong in the project. It
    also allows your users to compose several small packages to achieve their specific
    goals, rather than installing a huge package and using only a small subset of
    its available behavior.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般规则，你创建的每个项目都应该有一个明确的责任。这有助于你与要求新功能的人进行艰难的对话，因为你更容易确定哪些属于项目，哪些不属于。这也允许你的用户组合几个小包来实现他们的特定目标，而不是安装一个庞大的包，只使用其可用行为的一小部分。
- en: Although your projects may each have unique responsibilities supported by different
    code, many parts will look the same from package to package. These common pieces
    of code and configuration, called *boilerplate*, are necessary for a project to
    work but seldom need special attention other than to fill in some values.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你的项目可能每个都有独特的责任，由不同的代码支持，但许多部分从包到包看起来都一样。这些常见的代码和配置，称为*样板代码*，对于项目运行是必要的，但通常不需要特别的关注，除了填写一些值。
- en: Imagine you need to create five new packages for CarCorp from scratch by following
    the process you’ve learned so far in this book. Think about all the different
    configuration files and the directory structure that you have to create. Where
    would you slip up? How would you verify that you did everything correctly? How
    long do you think it would take? You likely thought of a few things off the top
    of your head, and in practice, you often run into a few more issues that you didn’t
    anticipate. With so much room for human error, the lack of repeatability of package
    creation could hinder the pace at which you develop new value.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你需要从头开始创建五个新的包，用于CarCorp，遵循你在本书中学到的过程。想想所有你必须创建的不同配置文件和目录结构。你会在哪里出错？你将如何验证你做了一切正确？你认为这需要多长时间？你很可能首先想到了一些事情，在实践中，你经常会遇到一些你没有预料到的问题。由于人为错误的空间很大，包创建的可重复性不足可能会阻碍你开发新价值的速度。
- en: Instead of creating packages from scratch each time, you can use a templating
    system that contains all the boilerplate a project needs and helps you fill in
    the project-specific information where needed. You can even put your project template
    in version control and make improvements to it over time, imparting your latest
    standards on each new package you create. You can make a template specific to
    CarCorp and each of your other clients if you notice that they differ enough to
    codify those differences. In the following sections, you’ll use cookiecutter ([https://cookiecutter.readthedocs.io](https://cookiecutter.readthedocs.io)),
    a Python-based project for creating language-agnostic project templates.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是每次都从头开始创建包，你可以使用一个包含项目所需所有模板的模板系统，并帮助你填写所需的项目特定信息。你甚至可以将你的项目模板放入版本控制中，并随着时间的推移对其进行改进，将你最新的标准应用到每个新创建的包中。如果你注意到CarCorp和其他客户之间的差异足够大，以至于可以将其编码化，你可以为CarCorp和你的其他每个客户创建特定的模板。在接下来的章节中，你将使用cookiecutter
    ([https://cookiecutter.readthedocs.io](https://cookiecutter.readthedocs.io))，这是一个基于Python的项目，用于创建语言无关的项目模板。
- en: 10.1.1 Creating a cookiecutter configuration
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.1 创建cookiecutter配置
- en: Like a real cookie cutter, the cookiecutter project is so named because you
    use it to create a template and then use that template to stamp out several similarly
    shaped things. Although the core shape of the projects you create will be similar,
    you can also signify certain parts as dynamic and fill the values in when creating
    new projects (see figure 10.1). This is a bit like decorating cookies with different
    icing and sprinkle combinations.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 就像真正的饼干切割器一样，cookiecutter项目之所以这样命名，是因为你用它来创建一个模板，然后使用该模板来制作几个形状相似的东西。尽管你创建的项目的基本形状将是相似的，但你也可以将某些部分标记为动态的，并在创建新项目时填写这些值（见图10.1）。这有点像用不同的糖霜和撒料组合来装饰饼干。
- en: '![](../../OEBPS/Images/10-01.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/10-01.png)'
- en: Figure 10.1 Using cookiecutter to create new projects from a mix of static boilerplate
    and dynamic user input
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 使用cookiecutter从静态模板和动态用户输入的混合中创建新项目
- en: Throughout the following sections, you’ll make changes to this new directory
    to turn it into a cookiecutter template project.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将对这个新目录进行更改，将其转变为cookiecutter模板项目。
- en: 'The first step toward making this project work with cookiecutter is configuring
    the dynamic values that must be filled in. To understand which values those are,
    think about the things that are currently specific to your project but would need
    to be changed to other values in any new project, such as the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 将此项目与cookiecutter一起工作的第一步是配置必须填写的动态值。为了了解这些值是什么，考虑一下目前特定于你的项目但需要在任何新项目中更改到其他值的事情，例如以下内容：
- en: The project name, `first-python-package`
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目名称，`first-python-package`
- en: The import package name, `imppkg`
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入包名称，`imppkg`
- en: The description of the project’s purpose
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目目的的描述
- en: The project author’s name and email
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目作者的姓名和电子邮件
- en: The license under which you provide the project
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你提供项目的许可证
- en: 'These are all things that you can address using cookiecutter. Other things,
    such as the following, are specific to your project, without a reasonable way
    to templatize them for other projects:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是你可以使用cookiecutter来解决的问题。其他一些事情，例如以下内容，是特定于你的项目的，没有合理的方法将它们模板化以供其他项目使用：
- en: The packages the project depends on
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目所依赖的包
- en: The code and tests the project provides, including non-Python extensions
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目提供的代码和测试，包括非Python扩展
- en: Because a project template may be used in a wide variety of contexts that are
    difficult to predict, you typically want to omit these. That way, you don’t end
    up with unused code or dependencies polluting a newly created project. If you
    plan to create a template from which many people will create their own projects,
    you can consider providing runnable example code to help users verify that their
    projects are correctly configured after creation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于项目模板可能被用于难以预测的广泛环境中，你通常希望省略这些内容。这样，你就不会在创建的新项目中留下未使用的代码或依赖项。如果你计划创建一个模板，许多人将基于此模板创建自己的项目，你可以考虑提供可运行的示例代码，以帮助用户在创建后验证他们的项目是否正确配置。
- en: Tip Eventually, you might create enough projects so that subsets of them have
    the same kind of customization or specialization. After you notice these patterns
    across several projects, you can think about extracting a separate, special project
    template if you plan to create more projects like those in the future.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：最终，您可能会创建足够多的项目，以至于它们的子集具有相同类型的定制或专业化。在您注意到这些模式跨越多个项目后，如果您计划创建更多类似的项目，您可以考虑提取一个单独的特殊项目模板。
- en: Once you’ve identified all the values you want to templatize, the next step
    is to create the configuration file. cookiecutter looks for a cookiecutter.json
    file whose keys are the dynamic variable names and whose values are the default
    values presented when creating the package, as shown in the next listing.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您确定了所有想要模板化的值，下一步就是创建配置文件。cookiecutter 会查找一个 cookiecutter.json 文件，其键是动态变量名称，其值是在创建包时显示的默认值，如下一列表所示。
- en: Listing 10.1 A small cookiecutter JSON configuration with two variables
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.1 包含两个变量的小型 cookiecutter JSON 配置
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ variable_one defaults to the value "green".
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `variable_one` 默认值为 "green"。
- en: ❷ variable_two defaults to the value "blue".
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ `variable_two` 默认值为 "blue"。
- en: You can reference the `variable_one` and `variable_two` variables throughout
    your project template, and cookiecutter will replace them with the default or
    user-specified values when creating a project.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在项目模板的任何地方引用 `variable_one` 和 `variable_two` 变量，cookiecutter 在创建项目时会用默认值或用户指定的值替换它们。
- en: Prompting a user for input
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 提示用户输入
- en: You can create a project from a project template by running the `cookiecutter`
    command and passing it the path to your project template directory. When you run
    the command, cookiecutter will prompt you to accept the default value or enter
    a custom value for keys in the cookiecutter.json file, as shown in the next listing.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行 `cookiecutter` 命令并传递项目模板目录的路径来从项目模板创建一个项目。当您运行该命令时，cookiecutter 将提示您接受默认值或为
    cookiecutter.json 文件中的键输入自定义值，如下一列表所示。
- en: Listing 10.2 Example output from running cookiecutter with two variables
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.2 运行 cookiecutter 并带有两个变量的示例输出
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Variable name and default value, with alternative supplied
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 变量名称和默认值，以及提供的替代值
- en: ❷ You can press Enter to accept the default value.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 您可以按 Enter 键接受默认值。
- en: For variables with a string as the default option, you can input any arbitrary
    alternative input to use something other than the default value. In addition to
    a string, cookiecutter enables you to configure a list of values for a given variable.
    Unlike a string variable, a list variable will display all the available values
    when you run the cookiecutter command and default to the first one; you must choose
    one of those options and can’t enter an arbitrary value. This is useful when your
    project template needs to restrict the possible options or you want to make it
    convenient to select from a few options.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于默认选项为字符串的变量，您可以输入任何任意替代输入以使用除默认值以外的值。除了字符串外，cookiecutter 还允许您为给定变量配置值列表。与字符串变量不同，列表变量在运行
    cookiecutter 命令时会显示所有可用值，并默认选择第一个；您必须选择这些选项之一，不能输入任意值。这在您的项目模板需要限制可能的选项或您希望方便地从几个选项中选择时非常有用。
- en: Following from the earlier example, the following listing shows how to add a
    list of options for a variable.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的示例中继续，以下列表显示了如何为变量添加选项列表。
- en: Listing 10.3 Specifying a list of possible options for a cookiecutter variable
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.3 为 cookiecutter 变量指定可能的选项列表
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Uses a string to provide a default value
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用字符串提供默认值
- en: ❷ Uses a list to provide an enumeration of allowed options
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用列表提供允许选项的枚举
- en: Running the `cookiecutter` command with this configuration results in the same
    output for the first two variables as before and additionally displays all the
    options for the third variable (shown in the next listing).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此配置运行 `cookiecutter` 命令将产生与之前相同的前两个变量的输出，并额外显示第三个变量的所有选项（如下一列表所示）。
- en: Listing 10.4 Example output from running cookiecutter with a mix of variable
    types
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.4 运行 cookiecutter 并带有混合变量类型的示例输出
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Indicates you must make a selection
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 表示您必须进行选择
- en: ❷ Displays all available options
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 显示所有可用选项
- en: ❸ Enter the index of the option, or default to the first one.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 输入选项的索引，或默认为第一个。
- en: The string and list variable options give you enough power to make a template
    of the dynamic parts of your package, but there’s one more convenient feature
    of cookiecutter you can make use of.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串和列表变量选项为你提供了足够的权力来制作你包动态部分的模板，但cookiecutter还有一个更方便的特性你可以利用。
- en: Building on previous values
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 建立在先前值的基础上
- en: Quite often, a value in your project configuration will be similar, but not
    identical, to another value. One prominent example is that the distribution package
    name is often similar to the import package name, but the distribution name is
    hyphenated, whereas the import name has the hyphens removed or replaced with underscores.
    As an example, a package with a distribution package name like `flask-tools` might
    have an import name like `flasktools` or `flask_tools`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 很常见，你的项目配置中的一个值将与另一个值相似，但并不完全相同。一个突出的例子是，分发包的名称通常与导入包的名称相似，但分发名称是带连字符的，而导入名称的连字符被移除或替换为下划线。例如，一个具有类似`flask-tools`的分发包名称可能具有类似`flasktools`或`flask_tools`的导入名称。
- en: 'When you need to create a template for two similar values like package names,
    ask yourself the following questions:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要为两个类似值（如包名称）创建模板时，请自问以下问题：
- en: Is one of the two values more “canonical” than the other? That is, does one
    feel like a derivation of the other?
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这两个值中是否有一个是比另一个更“规范”的？也就是说，它是否感觉像是另一个的派生？
- en: If so, can the canonical value be readily transformed programmatically into
    the other?
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果答案是肯定的，那么规范值是否可以轻松地通过编程转换成另一个值？
- en: If the answer is yes to both these questions, you can consider prompting only
    for the canonical value and generating the other automatically. The cookiecutter
    template system uses Jinja2 ([https://palletsprojects.com/p/jinja/](https://palletsprojects.com/p/jinja/))
    to inject dynamic content, and Jinja2 enables you to use Python expressions when
    generating that content; more on this shortly. You can use a Python expression
    in the value of one variable to calculate a value based on an earlier variable.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这两个问题的答案都是肯定的，你可以考虑只提示规范值，并自动生成另一个值。cookiecutter模板系统使用Jinja2 ([https://palletsprojects.com/p/jinja/](https://palletsprojects.com/p/jinja/))来注入动态内容，Jinja2允许你在生成内容时使用Python表达式；稍后将有更多介绍。你可以在一个变量的值中使用Python表达式来根据前面的变量计算值。
- en: Warning Note that because cookiecutter prompts for the variables in the order
    they appear in the cookiecutter.json file, any variables that depend on another
    variable must come after the variables they depend on.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：请注意，由于cookiecutter按照cookiecutter.json文件中变量的出现顺序提示变量，因此任何依赖于其他变量的变量必须放在它们依赖的变量之后。
- en: As an example, you can prompt the user for a distribution package name and then
    use the provided value to generate valid import package name options. The following
    listing shows how you can use Python’s `str.replace` function to replace each
    hyphen in a user-supplied distribution package name with either the empty string
    or an underscore character and offer them as options for the import package name.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以提示用户输入分发包名称，然后使用提供的值生成有效的导入包名称选项。以下列表显示了如何使用Python的`str.replace`函数将用户提供的分发包名称中的每个连字符替换为空字符串或下划线字符，并将它们作为导入包名称的选项提供。
- en: Listing 10.5 Generating a cookiecutter variable value from another variable
    value
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.5：从另一个变量值生成cookiecutter变量值
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ A Python distribution package name often contains hyphens.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Python分发包名称通常包含连字符。
- en: ❷ Removes hyphens for a valid import package name
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 移除连字符以获得有效的导入包名称
- en: ❸ Replaces hyphens with underscores for a valid import package name
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将连字符替换为下划线以获得有效的导入包名称
- en: Running the `cookiecutter` command using this configuration results in the output
    shown here.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此配置运行`cookiecutter`命令会产生以下输出。
- en: Listing 10.6 Output from a cookiecutter configuration with dependent variables
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.6：具有依赖变量的cookiecutter配置的输出
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ The value chosen here is used to generate later values.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这里选择的值用于生成后续值。
- en: ❷ These values are generated from the first variable.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这些值是从第一个变量生成的。
- en: You now have all the configuration tools you need to turn the copy of your package
    into a Python package project template. The next step is to create the cookiecutter
    configuration and update the package contents to reference the configured variables,
    but before diving into creating templates, you need to understand the flow of
    the variables and Jinja2’s syntax more deeply.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经拥有了所有需要的配置工具，可以将你的包副本转换为Python包项目模板。下一步是创建cookiecutter配置并更新包内容以引用配置的变量，但在深入创建模板之前，你需要更深入地理解变量的流程和Jinja2的语法。
- en: 10.1.2 Extracting a cookiecutter template from an existing project
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.2 从现有项目中提取cookiecutter模板
- en: 'Jinja2 works under a *rendering context*, or a set of available variables containing
    values it can inject into the content. The cookiecutter tooling adds a `cookiecutter`
    variable to the context, which in turn has attributes corresponding to the variables
    configured in the cookiecutter.json file. Jinja2 *renders* output by parsing input
    as a string and then identifying and operating on the following two special expression
    types:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja2在*渲染上下文*下工作，或者是一组包含其可以注入内容的值的变量。cookiecutter工具集向上下文中添加了一个`cookiecutter`变量，该变量反过来具有与cookiecutter.json文件中配置的变量相对应的属性。Jinja2通过解析输入作为字符串，然后识别并操作以下两种特殊表达式类型来*渲染*输出：
- en: '*Placeholder expressions* are enclosed in double curly braces (`{{ ... }}`)
    and contain references to context variables. A placeholder expression may further
    manipulate a context variable value using Python string operations; you saw an
    example of this earlier when offering transformed options for an import package
    name based on a distribution package name.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*占位符表达式*被双大括号(`{{ ... }}`)包围，并包含对上下文变量的引用。占位符表达式可以进一步使用Python字符串操作来操纵上下文变量的值；你之前在根据分发包名提供导入包名的转换选项时已经看到了一个例子。'
- en: '*Block expressions* are enclosed in a curly brace and percent sign (`{% ...
    %}`). Block expressions can conditionally render content or render a piece of
    content repeatedly with different values from the rendering context.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*块表达式*被大括号和百分号(`{% ... %}`)包围。块表达式可以条件性地渲染内容，或者根据渲染上下文的不同值重复渲染同一块内容。'
- en: As an example, you could render one of two different pieces of content based
    on a context variable value using the syntax in the next listing.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以根据上下文变量的值使用下一列表中的语法渲染两块不同内容中的一块。
- en: Listing 10.7 A Jinja2 control flow using conditional block expressions
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.7 使用条件块表达式的Jinja2控制流
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is useful if your project template should render different content in a
    file depending on one of the options you configure.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于你的项目模板根据你配置的选项在文件中渲染不同内容是有用的。
- en: After Jinja2 parses expressions and renders the content, cookiecutter creates
    an output project containing the rendered content. Figure 10.2 depicts the flow
    you saw earlier with more specifics about cookiecutter and Jinja2.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jinja2解析表达式并渲染内容后，cookiecutter创建一个包含渲染内容的输出项目。图10.2描述了之前看到的流程，并提供了关于cookiecutter和Jinja2的更多具体信息。
- en: '![](../../OEBPS/Images/10-02.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/10-02.png)'
- en: Figure 10.2 Jinja2 renders values from a dynamic context into placeholder expressions
    within static content.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2展示了Jinja2将动态上下文中的值渲染到静态内容中的占位符表达式内。
- en: Another powerful aspect of the cookiecutter templating setup is that it also
    works in the names of files and directories. Because your package directory names
    are also dynamic and important to the proper functioning of the package, you need
    to be able to templatize these as well.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: cookiecutter模板设置的一个强大方面是它还适用于文件和目录的名称。因为你的包目录名称也是动态的，并且对包的正确运行很重要，所以你需要能够将这些也模板化。
- en: 'Importantly, cookiecutter expects the root directory of your project template
    to be a wrapper around the template for the output project. Put another way, your
    template project must contain a directory that will become the root directory
    of the output project. Like your `first-python-package` project, that output directory
    typically has the same name as the distribution package. You can achieve this
    using the following steps:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，cookiecutter期望你的项目模板的根目录是输出项目模板的包装器。换句话说，你的模板项目必须包含一个将成为输出项目根目录的目录。就像你的`first-python-package`项目一样，这个输出目录通常与分发包同名。你可以通过以下步骤实现这一点：
- en: Create a new directory for your template project called python-project-template/
    alongside your original package project.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的原始包项目旁边创建一个名为 python-project-template/ 的新目录，用于您的模板项目。
- en: Add an empty cookiecutter.json file to the python-project-template/ directory,
    which you’ll configure shortly.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 python-project-template/ 目录中添加一个空的 cookiecutter.json 文件，您将在稍后进行配置。
- en: Copy the first-python-package/ directory into the python-project-template/ directory.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 first-python-package/ 目录复制到 python-project-template/ 目录中。
- en: Rename the first-python-package/ directory to {{cookiecutter.package_distribution_name}}/
    using Jinja2 placeholder syntax to refer to the package’s distribution name.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Jinja2 占位符语法将 first-python-package/ 目录重命名为 {{cookiecutter.package_distribution_name}}/，以引用包的发行名称。
- en: The next listing shows what the directory structure should be for your project
    template.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了您的项目模板应该具有的目录结构。
- en: Listing 10.8 project-template-tree
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.8 project-template-tree
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ The project template root directory
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 项目模板根目录
- en: ❷ The cookiecutter configuration lives in the template root.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Cookiecutter 配置位于模板根目录。
- en: ❸ The package root directory lives inside the project template root directory.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 包根目录位于项目模板根目录内部。
- en: You’re now equipped with the knowledge you need to complete the conversion of
    your package into a project template.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经具备完成将您的包转换为项目模板所需的知识。
- en: Exercise 10.1
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 10.1
- en: 'Make a template from the rest of your project. You’ll need to configure the
    cookiecutter .json file to prompt for the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 从您的项目其余部分制作一个模板。您需要配置 cookiecutter .json 文件，提示以下内容：
- en: '`package_distribution_name`.'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`package_distribution_name`。'
- en: '`package_import_name`; generate an option with and without underscores from
    the value of `package_distribution_name`.'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`package_import_name`; 从 `package_distribution_name` 的值生成带下划线和不带下划线的选项。'
- en: '`package_description`; use the value of `package_distribution_name` in the
    description.'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`package_description`; 在描述中使用 `package_distribution_name` 的值。'
- en: '`package_license`; suggest a subset of open source licenses, using names from
    the list of OSI approved classifiers ([https://pypi.org/classifiers/](https://pypi.org/classifiers/)).'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`package_license`; 建议使用 OSI 批准的分类器列表中的名称，提出一个开源许可子集（[https://pypi.org/classifiers/](https://pypi.org/classifiers/))。'
- en: '`package_author_name`.'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`package_author_name`。'
- en: '`package_author_email`.'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`package_author_email`。'
- en: 'After configuring cookiecutter to prompt for those values, you need to replace
    all of the following hard-coded references in your project with the placeholders
    so they’ll be rendered dynamically:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置 cookiecutter 以提示这些值后，您需要用占位符替换以下所有硬编码的引用，以便它们可以动态渲染：
- en: The import package directory inside the src/ directory needs to be determined
    dynamically from the cookiecutter variables. Rename it to depend on a `package_import_name`
    variable.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: src/ 目录内的导入包目录需要从 cookiecutter 变量动态确定。将其重命名为依赖于 `package_import_name` 变量。
- en: 'Replace references in the following files with their placeholder variable counterparts:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用占位符变量替换以下文件中的引用：
- en: setup.cfg
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: setup.cfg
- en: README.md
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: README.md
- en: docs/index.rst
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: docs/index.rst
- en: docs/conf.py
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: docs/conf.py
- en: 'Then, use conditional block expressions to change the content of the LICENSE
    file to provide the proper license content for the chosen `package_license`. Finally,
    remove the following pieces that you might not want in your project template:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用条件块表达式更改 LICENSE 文件的内容，为所选的 `package_license` 提供适当的许可内容。最后，删除您可能不想在项目模板中包含的以下部分：
- en: The `[options.entry_points]` section in setup.cfg
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: setup.cfg 中的 `[options.entry_points]` 部分
- en: The `install_requires` option in setup.cfg
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: setup.cfg 中的 `install_requires` 选项
- en: The modules other than `__init.py__` in the src/ and test/ directories
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: src/ 和 test/ 目录中除了 `__init__.py__` 之外的其他模块
- en: The Cython machinery in setup.py and pyproject.toml
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: setup.py 和 pyproject.toml 中的 Cython 机制
- en: You can run the `cookiecutter` command with your project template periodically
    to generate a project and check your work.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以定期运行 `cookiecutter` 命令，使用项目模板生成项目并检查您的作品。
- en: After cookiecutter generates a project from your template that’s to your liking,
    you can commit the template to version control and continue to use it to create
    new projects in the future.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在 cookiecutter 从您的模板生成您喜欢的项目后，您可以提交模板到版本控制，并继续在未来创建新的项目。
- en: 10.2 Using namespace packages
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 使用命名空间包
- en: The package you’ve built in this book is a small, isolated piece of functionality.
    Sometimes, a project grows large enough that it no longer makes sense to keep
    it in a single package, even if all the behavior is still related in a broad way.
    As an example, think about a large plugin-based framework like Django ([https://www.djangoproject.com/](https://www.djangoproject.com/))
    or Flask ([https://flask.palletsprojects.com/en/2.0.x/](https://flask.palletsprojects.com/en/2.0.x/)).
    These projects have a core responsibility to provide tools for creating web server
    applications but can also do a lot more.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 本书构建的包是一个小型、独立的函数组件。有时，一个项目变得足够大，以至于即使所有行为在广义上仍然相关，也不再适合将其保留在单个包中。作为一个例子，想想像
    Django ([https://www.djangoproject.com/](https://www.djangoproject.com/)) 或 Flask
    ([https://flask.palletsprojects.com/en/2.0.x/](https://flask.palletsprojects.com/en/2.0.x/))
    这样的大型基于插件的框架。这些项目有核心责任提供创建网络服务器应用程序的工具，但也可以做更多的事情。
- en: Other times, you may be working on packaging within your organization and want
    to clearly delineate all your organization’s packages from third-party packages.
    It can be nice to maintain separate, small packages that share a common top-level
    import name so the team is certain they’re using organizational code. This pattern
    is extremely common in Java applications (see “Naming a Package,” The Java Tutorials,
    [http://mng.bz/N5md](http://mng.bz/N5md)), but less so in Python until an organization
    has wide adoption of Python and packaging.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能在组织内部进行打包工作，并希望清楚地划分出所有组织的包与第三方包。维护独立的、小型且共享相同顶级导入名称的包可能是个不错的选择，这样团队就可以确信他们正在使用组织的代码。这种模式在
    Java 应用程序（见“命名包”，Java 教程，[http://mng.bz/N5md](http://mng.bz/N5md)）中非常常见，但在 Python
    中直到组织广泛采用 Python 和打包之前则较少见。
- en: Recall that packages should generally have one clear responsibility. Following
    this rule rigidly has consequences; you can imagine needing to install hundreds
    or even thousands of packages, all with their own distribution and import package
    names, just to accomplish a simple task. The NPM ecosystem ([https://www.npmjs.com/](https://www.npmjs.com/))
    for JavaScript follows this philosophy. You don’t want to shove all behavior into
    one large package that no longer has a clear purpose, but you also might not want
    to break that behavior up so much that people can’t remember where to get what
    they need.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，包通常应该有一个明确的责任。严格遵循这一规则会有后果；你可以想象需要安装成百上千个包，每个包都有自己的分发和导入包名称，只是为了完成一个简单的任务。JavaScript
    的 NPM 生态系统（[https://www.npmjs.com/](https://www.npmjs.com/））遵循这一理念。你不想把所有行为都塞进一个没有明确目的的大型包中，但也许你也不想把这种行为拆分得太多，以至于人们无法记住他们需要从哪里获取所需的内容。
- en: PEP 420 ([https://www.python.org/dev/peps/pep-0420/](https://www.python.org/dev/peps/pep-0420/))
    defines the specification for *implicit namespace packages*, which make it possible
    to provide granular behavior without sacrificing the ergonomics of importing behavior
    from a common namespace. Namespace packages enable you to break up a distribution
    package into multiple distribution packages while keeping them under a single
    namespace (see figure 10.3).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 420 ([https://www.python.org/dev/peps/pep-0420/](https://www.python.org/dev/peps/pep-0420/))
    定义了 *隐式命名空间包* 的规范，这使得在不牺牲从公共命名空间导入行为的人体工程学的情况下提供细粒度行为成为可能。命名空间包允许你将分发包拆分为多个分发包，同时保持它们在单个命名空间下（见图
    10.3）。
- en: '![](../../OEBPS/Images/10-03.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/10-03.png)'
- en: Figure 10.3 Namespace packages break up an existing distribution package into
    multiple distribution packages while maintaining a single, top-level namespace.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 命名空间包将现有的分发包拆分为多个分发包，同时保持一个单一的顶级命名空间。
- en: 'Namespace packages differ from regular packages in one key way: they provide
    a directory containing one or more regular packages, but that is not itself a
    package. That is, a directory is a namespace package if it contains Python packages
    but doesn’t contain its own `__init__.py` module. Through this mechanism, multiple
    directories in different locations may share a common name but contain different
    packages. The name those directories share acts as the namespace, and the packages
    those directories contain are all importable under that namespace.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间包与常规包在一点上有所不同：它们提供了一个包含一个或多个常规包的目录，但这个目录本身不是包。也就是说，如果一个目录包含 Python 包但不包含自己的
    `__init__.py` 模块，那么这个目录就是一个命名空间包。通过这种机制，不同位置的多个目录可以共享一个共同名称，但包含不同的包。这些目录共享的名称充当命名空间，而包含在这些目录中的包都可以在该命名空间下导入。
- en: Namespace packages may also be nested, but the structure of namespace and regular
    packages needs to match across different directories to be compatible. If a directory
    is a namespace package in one directory but is a regular package in another directory,
    Python will favor the regular package and the namespace package won’t work. As
    an example, the directory structure shown in the following listing results in
    being able to import `geometry.lines` as well as `geometry.polygons`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间包也可以嵌套，但命名空间和常规包的结构需要在不同的目录之间匹配才能兼容。如果一个目录在一个目录中是命名空间包，但在另一个目录中是常规包，Python将优先选择常规包，而命名空间包将无法工作。例如，以下列表中显示的目录结构允许导入`geometry.lines`以及`geometry.polygons`。
- en: Listing 10.9 A directory structure with a single namespace package
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.9 单个命名空间包的目录结构
- en: '[PRE8]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ A namespace package providing packages in the geometry natmespace
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在几何命名空间中提供包的命名空间包
- en: ❷ Importable as geometry.lines
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 可导入为geometry.lines
- en: ❸ Another namespace package providing packages in the geometry namespace
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在几何命名空间中提供包的另一个命名空间包
- en: ❹ Importable as geometry.polygons
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 可导入为geometry.polygons
- en: On the other hand, if the geometry-lines/geometry/ directory is made to be a
    regular package, as shown in the following listing, you can still import `geometry.lines`
    and the packages it contains, but you can no longer import `geometry.polygons`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果geometry-lines/geometry/目录被设置为常规包，如以下列表所示，你仍然可以导入`geometry.lines`及其包含的包，但不能再导入`geometry.polygons`。
- en: Listing 10.10 A regular package taking precedence over a namespace package
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.10 常规包优先于命名空间包
- en: '[PRE9]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Makes geometry a regular package and takes precedence
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使几何成为常规包并具有优先权
- en: ❷ No longer importable if both namespace packages are on the path
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果路径上有两个命名空间包，则不再可导入
- en: When you attempt to import a package, Python works to resolve the requested
    import by checking the paths it knows about for matches. Python’s resolution algorithm
    will prefer regular packages, because looking for namespace packages takes more
    effort due to the additional nesting that may be involved for a namespace package.
    When one package on the system path is a regular package, Python will make it
    available over anything else, even when there are matching namespace packages
    on the system path as well.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试导入一个包时，Python会通过检查它所知道的路径来解析请求的导入。Python的解析算法会优先选择常规包，因为查找命名空间包需要更多的努力，因为命名空间包可能涉及额外的嵌套。当系统路径上的一个包是常规包时，Python会使其在系统路径上的任何其他包之上可用，即使系统路径上也有匹配的命名空间包。
- en: Now that you understand the mechanics of namespace packages, you need to get
    some practice with them.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了命名空间包的机制，你需要通过实践来熟悉它们。
- en: 10.2.1 Converting an existing package to a namespace package
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.1 将现有包转换为命名空间包
- en: 'To convert an existing distribution package that provides a regular package
    into one that provides a namespace package, you need to take the following two
    actions:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要将现有的提供常规包的分布包转换为提供命名空间包的包，你需要采取以下两个行动：
- en: 'Update the directory structure for the namespace:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新命名空间的目录结构：
- en: If the regular package is currently named the same as the namespace, remove
    the `__init__.py` module from the src/<package>/ directory to make it a namespace
    package.
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果常规包当前的名字与命名空间相同，请从src/<package>/目录中移除`__init__.py`模块，使其成为一个命名空间包。
- en: If the regular package is a package that should live inside the namespace, create
    an empty src/<namespace>/ directory, and move the src/<package>/ directory inside
    it.
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果常规包是一个应该存在于命名空间内的包，创建一个空的src/<namespace>/目录，并将src/<package>/目录移动到其中。
- en: 'Update the `[options]` section in the setup.cfg file:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新setup.cfg文件中的`[options]`部分：
- en: Change the `packages` key from `find:` to `find_namespace:`.
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`packages`键从`find:`更改为`find_namespace:`.
- en: Add a `namespace_packages` key with a value equal to the new namespace’s name.
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个`namespace_packages`键，其值等于新命名空间的名字。
- en: With these two changes, you turn a package from one that “consumes” its original
    namespace into one that can interoperate with other distribution packages that
    provide packages within the same namespace.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这两个更改，你可以将一个“消耗”其原始命名空间的包转换为可以与其他在同一命名空间内提供包的分布包交互的包。
- en: Tip Using the setup you’ve learned in this book, you can generally use `find_
    namespace:` in place of `find:` without affecting anything. You can use this as
    the default in your project template, even if your distribution package doesn’t
    provide any namespace packages.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：使用本书中学习到的设置，你通常可以用`find_ namespace:`代替`find:`，而不会影响任何内容。你甚至可以将此作为项目模板的默认设置，即使你的发行版包没有提供任何命名空间包。
- en: Exercise 10.2
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 10.2
- en: Using the project template you created earlier in this chapter, create two new
    packages. After you’re done creating them, convert them both to provide packages
    within the same namespace. Install them both into a virtual environment, and check
    that you can import the code from both of them using a single namespace.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本章早期创建的项目模板，创建两个新的包。在你完成创建后，将它们都转换为在同一命名空间内提供包。将它们都安装到一个虚拟环境中，并检查你是否可以使用单个命名空间从它们中导入代码。
- en: Now that you have a way to create many packages that follow your standards,
    as well as a way to create many packages that work well together using a single
    namespace, you might also be curious about how you can publish all these new packages
    in a private setting so that your team can install them within your organization.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了一种创建遵循你标准的大量包的方法，以及一种使用单个命名空间创建许多能够良好协作的包的方法，你可能也会好奇如何在一个私密的环境中发布所有这些新包，以便你的团队能够在你的组织内部安装它们。
- en: 10.3 Scaling packaging in your organization
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 在你的组织中扩展打包
- en: There’s no one right way to share code, and organizations will solve the problem
    of code reuse across projects in whatever way necessity dictates in the moment.
    Some organizations, like Google, end up putting all their code in a single repository
    with a complex build system. Others keep each project modular in its own repository
    with its own build process. If you suspect that decoupled delivery of behavior
    that people can opt into is going to be a priority for you, you should consider
    creating a private packaging ecosystem that mirrors how the Python Package Index
    and others work using the tools people are already familiar with.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 分享代码没有一种正确的方式，组织将根据当时的需求以任何必要的方式解决跨项目代码复用的问题。一些组织，比如谷歌，最终将所有代码放入一个具有复杂构建系统的单个仓库中。其他组织则在每个项目的仓库中保持其模块化，并拥有自己的构建过程。如果你怀疑行为解耦的交付方式将成为你的一个优先事项，你应该考虑创建一个与
    Python 包索引和其他工作方式相似的私有打包生态系统，使用人们已经熟悉的工具。
- en: 10.3.1 Private package repository servers
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.1 私有包仓库服务器
- en: Recall that PyPI is a package repository whose main job is to store and serve
    distribution packages. People can publish packages to it and install packages
    from it. This functionality seems basic, but as you learned in chapter 1, it’s
    the core of the opt-in update model for installed dependencies that makes packaging
    so valuable. Even when you can’t use PyPI because you’re working on proprietary
    software or because your organization has restrictions about external access,
    you can consider running a private package repository within the walls of your
    organization.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，PyPI 是一个包仓库，其主要任务是存储和提供分发包。人们可以向其发布包，并从中安装包。这个功能看似基本，但正如你在第 1 章中学到的，它是安装依赖项可选更新模型的基石，使得打包变得非常有价值。即使你因为正在开发专有软件或因为你的组织对外部访问有限制而无法使用
    PyPI，你仍然可以考虑在你的组织内部运行一个私有包仓库。
- en: PyPI works with pip because they each adhere to a particular contract about
    the paths the packages are served at in the index. Any private package repository
    you choose should adhere to this same contract to ensure that it is compatible
    with pip as well. The pypiserver package ([https://github.com/pypiserver/pypiserver](https://github.com/pypiserver/pypiserver))
    provides a plug-and-play, open source solution for running a PyPI-compatible package
    index server. If you foresee needing other kinds of package repositories for JavaScript,
    Docker, Ruby, and so on, you might want to consider running a multilanguage package
    index using a solution like Artifactory ([https://jfrog.com/artifactory/](https://jfrog.com/artifactory/)).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: PyPI 与 pip 一起工作，因为它们各自都遵循关于在索引中提供包路径的特定合同。你选择的任何私有包仓库都应该遵守这个相同的合同，以确保它与 pip
    兼容。pypiserver 包（[https://github.com/pypiserver/pypiserver](https://github.com/pypiserver/pypiserver)）提供了一个即插即用的开源解决方案，用于运行兼容
    PyPI 的包索引服务器。如果你预计需要其他类型的包仓库，如 JavaScript、Docker、Ruby 等，你可能想要考虑使用 Artifactory（[https://jfrog.com/artifactory/](https://jfrog.com/artifactory/)）之类的解决方案运行多语言包索引。
- en: Tip You can also look specifically for solutions that will automatically pull
    packages that have never been requested before from PyPI automatically and then
    cache them thereafter. This can speed up downloads for future installations and
    also gives you some resilience if PyPI servers are unavailable. pypiserver and
    Artifactory both support this.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：你也可以寻找那些会自动从PyPI拉取之前从未请求过的包，并在之后将其缓存的解决方案。这可以加快未来安装的下载速度，如果PyPI服务器不可用，这也提供了一定的弹性。pypiserver和Artifactory都支持这一点。
- en: Setting up and operating a private package repository server are outside the
    scope of this book, but the solutions mentioned and linked in this section have
    documentation about configuration and hosting that will help you do so. Assuming
    you have such a server, you need to know how to get your packaging tools to speak
    to it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 设置和运行私有包仓库服务器超出了本书的范围，但本节中提到的和链接的解决方案有关于配置和托管方面的文档，这将有助于你完成这项工作。假设你已经有了这样的服务器，你需要知道如何让你的打包工具与之通信。
- en: Configuring twine and pip to use a private repository
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 配置twine和pip以使用私有仓库。
- en: Recall that you first used twine ([https://twine.readthedocs.io](https://twine.readthedocs.io))
    to publish your package before using GitHub Actions. GitHub Actions can’t publish
    packages to a private package repository unless you specifically allow it to access
    the server through your network. If this is a limitation for you, you can use
    twine to publish your package instead. By default, twine and pip will communicate
    with PyPI when you ask it to install a package. Both tools accept configuration
    that will make them communicate with a server of your choosing. You can read about
    the variety of possible ways to configure twine ([http://mng.bz/DDZV](http://mng.bz/DDZV))
    and pip ([http://mng.bz/lRJo](http://mng.bz/lRJo)), but the following is my personal
    recommendation for being explicit in your projects to make clear whether the project
    publishes or installs packages from a private server.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，你首先使用twine ([https://twine.readthedocs.io](https://twine.readthedocs.io))
    在使用GitHub Actions之前发布你的包。GitHub Actions无法将包发布到私有包仓库，除非你明确允许它通过你的网络访问服务器。如果你觉得这是一个限制，你可以使用twine来发布你的包。默认情况下，当你要求安装一个包时，twine和pip将与PyPI通信。这两个工具都接受配置，使它们可以与你的选择的服务器通信。你可以阅读有关配置twine
    ([http://mng.bz/DDZV](http://mng.bz/DDZV)) 和pip ([http://mng.bz/lRJo](http://mng.bz/lRJo))
    的各种可能方式的说明，但以下是我个人对在你的项目中明确配置的建议，以便清楚地表明项目是否从私有服务器发布或安装包。
- en: 'To publish packages to an alternate repository server using twine, you can
    create a new `publish` tox environment in your setup.cfg file that does the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用twine将包发布到备用仓库服务器，你可以在你的setup.cfg文件中创建一个新的`publish` tox环境，执行以下操作：
- en: Installs the `build` package to build the package
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`build`包以构建包。
- en: Installs the `twine` package to upload the built package to the repository server
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`twine`包以将构建的包上传到仓库服务器。
- en: Allows the external `rm` command so you can clean up the dist/ directory before
    building and uploading packages
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许使用外部的`rm`命令，以便在构建和上传包之前清理dist/目录。
- en: Runs commands to clean, build, and publish the package
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行命令以清理、构建和发布包。
- en: You can pass the `twine upload` command a `--repository` flag with the URL to
    your repository server’s Python package repository upload endpoint, along with
    a `--username` flag and `--password` flag if your server requires authentication.
    The following listing shows an example of this setup using Artifactory.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向`twine upload`命令传递一个带有你仓库服务器Python包仓库上传端点的URL的`--repository`标志，如果服务器需要认证，还可以传递`--username`标志和`--password`标志。以下列表展示了使用Artifactory的此配置示例。
- en: Listing 10.11 Adding an alternate package repository URL via twine
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.11 通过twine添加备用包仓库URL。
- en: '[PRE10]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Installs twine for publishing the package
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 安装twine以发布包。
- en: ❷ Allows the external rm command to be used
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 允许使用外部的rm命令。
- en: ❸ Cleans up any existing built packages before proceeding
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在继续之前清理任何现有的已构建包。
- en: ❹ Builds the package
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 构建包。
- en: ❺ Uploads the package to an alternate repository server
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将包上传到备用仓库服务器。
- en: With the `publish` tox environment in place, you can publish the package manually
    from your machine or create a continuous integration workflow on a self-hosted
    solution like Jenkins ([https://www.jenkins.io/](https://www.jenkins.io/)) or
    GitLab CI/CD ([https://docs.gitlab.com/ee/ci/](https://docs.gitlab.com/ee/ci/))
    that runs the environment when you create a tag on the code repository.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在`publish` tox环境中，你可以从你的机器上手动发布包，或者在Jenkins ([https://www.jenkins.io/](https://www.jenkins.io/))或GitLab
    CI/CD ([https://docs.gitlab.com/ee/ci/](https://docs.gitlab.com/ee/ci/))等自托管解决方案上创建持续集成工作流程，当你在代码仓库上创建标签时，它会运行该环境。
- en: After you publish a package to your alternate repository server, you then need
    to tell pip how to retrieve packages from that same server. If you’re installing
    packages in a Python runtime application that uses a requirements.txt file, you
    can add an `--index-url` flag with the repository server’s Python package repository
    download endpoint to either the `pip install` command or into the requirements.txt
    file itself. Imagine you publish a private package called my-private-package to
    your private package repository, and you need to install it as well as Django
    in a project you’re working on. Listing 10.12 shows an example requirements.txt
    file that instructs pip to look at the private package repository, where it will
    be able to find my-private-package. The repository server may have a copy of Django
    available, or it may need to fetch it from PyPI first; this is an implementation
    and configuration detail of your private repository solution of choice.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在将包发布到你的备用仓库服务器后，你需要告诉pip如何从该服务器检索包。如果你在Python运行时应用程序中安装包，并使用requirements.txt文件，你可以在`pip
    install`命令中添加一个`--index-url`标志，将仓库服务器的Python包仓库下载端点添加到其中，或者直接添加到requirements.txt文件本身。想象一下，你将一个名为my-private-package的私有包发布到你的私有包仓库，并且你需要在正在工作的项目中安装它以及Django。列表10.12显示了一个示例requirements.txt文件，该文件指示pip查看私有包仓库，在那里它将能够找到my-private-package。仓库服务器可能有一个Django的副本，或者它可能需要首先从PyPI获取；这是你选择的私有仓库解决方案的实现和配置细节。
- en: Listing 10.12 Adding an alternate package repository URL via pip
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.12通过pip添加备用包仓库URL
- en: '[PRE11]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ pip looks here for packages, alternative to PyPI
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ pip在这里查找包，替代PyPI
- en: ❷ Resolves because you published it to the private server
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 解决因为它已发布到私有服务器
- en: ❸ Either resolved on the private server or fetched from PyPI
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在私有服务器上解决或从PyPI获取
- en: By putting these URLs explicitly into the project source code, you ensure that
    developers who check out and work from the code repository will publish and fetch
    packages from the expected package repository servers. If you use configuration
    methods that live outside the project, you must trust developers to properly configure
    tools like twine and pip to use the proper package repository servers.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这些URL明确放入项目源代码中，你确保了从代码仓库检出并工作的开发者将发布和从预期的包仓库服务器获取包。如果你使用存在于项目之外的可配置方法，你必须信任开发者正确配置twine和pip等工具以使用正确的包仓库服务器。
- en: You’ve now learned how you can proliferate the use of packages, even within
    an organization that might have limitations on using the broader open source packaging
    ecosystem. You can create new packages using your cookiecutter project template
    and create a set of namespace packages so people can install smaller pieces of
    software using a consistent prefix for the imports, and you can do this all on
    a self-hosted server internal to your organization. You’re almost ready to go
    forth and prosper! But don’t miss out on the last chapter, which will help you
    put some final important polish on things if you’re heading in the direction of
    open source projects.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经学会了如何在可能对使用更广泛的开源打包生态系统有限制的组织中推广包的使用。你可以使用cookiecutter项目模板创建新的包，并为人们创建一组命名空间包，这样他们就可以使用一致的导入前缀安装更小的软件片段，而你可以在组织内部的托管服务器上完成所有这些操作。你几乎准备好去开拓和繁荣了！但不要错过最后一章，如果你正朝着开源项目的方向发展，这将帮助你给事情添加一些最后的润色。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Don’t just focus on automating a single project; when it comes to modular software
    ecosystems, consider automating the creation of the projects themselves using
    a project template.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要只关注自动化单个项目；当涉及到模块化软件生态系统时，考虑使用项目模板自动化项目的创建。
- en: Using a project template helps others adopt the system, and you can keep it
    up to date to ensure the latest standards make it into each new project.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用项目模板有助于他人采用该系统，并且你可以保持其更新，以确保最新的标准被纳入每个新项目中。
- en: Some things in a specific project won’t map to all projects you create, so you
    need to refine your project template over time for maximum productivity.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在特定的项目中，有些内容可能不会映射到您创建的所有项目中，因此您需要随着时间的推移不断优化您的项目模板，以实现最大化的生产力。
- en: Packages can get too big, but too many namespaces can also be confusing. Consider
    using namespace packages to find a happy medium for your users.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包可能变得过大，但过多的命名空间也可能令人困惑。考虑使用命名空间包来为您的用户提供一个合适的平衡点。
- en: Each public solution you’ve used in this book has a private or self-hosted corrolary,
    and you can use these to build out a proprietary packaging ecosystem in your organization.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书中所使用的每个公开解决方案都有一个私有或自托管的对应版本，您可以使用这些版本在您的组织中构建专有的打包生态系统。
