- en: 8 Do I know you? Authentication
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 我认识你吗？认证
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Flask sessions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask 会话
- en: Remembering the user
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住用户
- en: Letting users log in
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户登录
- en: Registering new users
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册新用户
- en: The MyBlog web application supports many users so they can post engaging content
    that the community will read. In addition, that community can read and comment
    on the content posted by other users. However, it’s unlikely users want the content
    that they created edited or deleted by a user other than themselves.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: MyBlog Web 应用程序支持许多用户，使他们能够发布社区会阅读的引人入胜的内容。此外，该社区可以阅读并评论其他用户发布的内容。然而，用户不太可能希望他们创建的内容被除他们自己以外的用户编辑或删除。
- en: To control who can access and use the MyBlog site, we’ll need to identify users.
    Identifying users on a web application is called authenticating a user. This allows
    the application to ensure a user is who they claim to be.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制谁可以访问和使用 MyBlog 网站，我们需要识别用户。在 Web 应用程序中识别用户被称为用户认证。这允许应用程序确保用户是他们所声称的人。
- en: Providing authentication to the MyBlog application is the intent of this chapter.
    However, doing so with a web application presents some unique challenges.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 向 MyBlog 应用程序提供身份验证是本章的目的。然而，使用网络应用程序这样做会带来一些独特的挑战。
- en: 8.1 The HTTP protocol is stateless
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 HTTP 协议是无状态的
- en: The MyBlog web application follows the request/response model supported by HTTP.
    The user creates an HTTP `GET` request from the browser, and the server responds
    by sending the requested HTML, CSS, JavaScript, and image files back. Nothing
    in that transaction implies that the server has prior knowledge about the requests
    it received. The HTTP protocol is stateless, meaning each request is complete
    and independent from any previous request. The server maintains no memory of past,
    present, or future request/response transactions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: MyBlog Web 应用程序遵循 HTTP 支持的请求/响应模型。用户从浏览器创建一个 HTTP `GET` 请求，服务器通过发送请求的 HTML、CSS、JavaScript
    和图像文件作为响应。在该交易中没有任何内容暗示服务器对其收到的请求有先前的知识。HTTP 协议是无状态的，这意味着每个请求都是完整且独立于任何先前请求的。服务器不维护过去、现在或未来请求/响应事务的内存。
- en: In this model, the request must contain all the necessary information so the
    server can build the appropriate response. Even if the same request is made to
    the server multiple times, the server will rebuild the same response each time.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模型中，请求必须包含所有必要的信息，以便服务器可以构建适当的响应。即使相同的请求多次发送到服务器，服务器也会每次重建相同的响应。
- en: If servers using the HTTP protocol have no memory, how do retail shopping sites
    know who you are when you purchase things? How does the web application running
    on that site remember the shopping cart you’ve created across multiple request/response
    transactions? And most importantly, how does a shopping site ensure the credit
    card belongs to the user making the purchase request? The answers to these questions
    involve adding state information to the transactions between the client’s browser
    and the web application server.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 HTTP 协议的服务器没有内存，那么零售购物网站在您购买商品时如何知道您是谁？运行在该网站上的 Web 应用程序如何记住您在多个请求/响应事务中创建的购物车？最重要的是，购物网站如何确保信用卡属于发起购买请求的用户？这些问题的答案涉及在客户端浏览器和
    Web 应用程序服务器之间的交易中添加状态信息。
- en: 8.1.1 Sessions
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.1 会话
- en: A session allows the server to relate information about a user to incoming requests.
    The session commonly establishes the relationship with a cryptographically strong
    unique ID value generated by the server and saved as a cookie in the client’s
    browser. This is known as a session cookie, though the client’s actual cookie
    name can vary depending on the server framework in use.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 会话允许服务器将有关用户的信息与传入的请求相关联。会话通常通过服务器生成的强加密唯一 ID 值与客户端浏览器中的 cookie 建立关系，并将其保存为
    cookie。这被称为会话 cookie，尽管客户端的实际 cookie 名称可能因使用的服务器框架而异。
- en: The session usually contains a unique identifier the server encrypted when the
    session was created. To prevent the session from being modified on the client
    side, the unique identifier is encrypted before being passed to the client. Thereafter,
    every request the client makes includes the encrypted identifier.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 会话通常包含一个唯一标识符，该标识符在会话创建时由服务器加密。为了防止会话在客户端被修改，唯一标识符在传递给客户端之前被加密。此后，客户端发出的每个请求都包含加密的标识符。
- en: When a request with a session arrives at the server, the server can decrypt
    the unique identifier and relate it to a specific user and any user information
    the server maintains—for example, a user’s name, shopping cart, and more. The
    server can retain state information from one request to the next by layering a
    session on the HTTP protocol.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当带有会话的请求到达服务器时，服务器可以解密唯一的标识符并将其关联到特定用户以及服务器维护的任何用户信息——例如，用户的姓名、购物车等。服务器可以通过在
    HTTP 协议上叠加会话来保留状态信息，从一次请求到下一次请求。
- en: Flask sessions
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 会话
- en: Flask supports the use of sessions and makes them available to the MyBlog application.
    A session cookie doesn’t exist between a client and the server until the server
    explicitly creates it. You can create a session by adding information to any URL
    route handler code you develop. The session is created and added to the client
    as a cookie in the response when that URL is accessed.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 支持使用会话，并将它们提供给 MyBlog 应用程序。会话 cookie 在客户端和服务器之间不存在，直到服务器明确创建它。你可以在你开发的任何
    URL 路由处理程序代码中添加信息来创建会话。当访问该 URL 时，会话被创建并添加到客户端作为响应中的 cookie。
- en: Flask uses the `SECRET_KEY` we created in the configuration from the previous
    chapter to sign the session cookie when created cryptographically. By doing this,
    the cookie can be viewed on the client side but can’t be modified unless the `SECRET_KEY`
    is available. As mentioned in the previous chapter, when the `SECRET_KEY` is added
    to enable the Flask Debug Toolbar, it is essential that the `SECRET_KEY` be cryptographically
    strong and kept private.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 使用我们在上一章配置中创建的 `SECRET_KEY` 对创建的会话 cookie 进行加密签名。通过这样做，cookie 可以在客户端查看，但除非有
    `SECRET_KEY`，否则无法修改。正如上一章所述，当添加 `SECRET_KEY` 以启用 Flask 调试工具栏时，`SECRET_KEY` 必须是加密强健的，并且需要保密。
- en: 'By default, session cookies exist until the client browser is closed. This
    can be changed by modifying the session’s permanent attribute, a Python `datetime
    .timedelta()` value. You can make a session exist for a year by adding the following
    in the server code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，会话 cookie 存在直到客户端浏览器关闭。这可以通过修改会话的永久属性，即 Python `datetime.timedelta()`
    值来改变。你可以在服务器代码中添加以下内容，使会话存在一年：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ① Marks the session as permanent
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ① 标记会话为永久
- en: ② Uses the Flask app instance to set the lifetime of the permanent session
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ② 使用 Flask 应用实例设置永久会话的生存周期
- en: Once a session exists, you can use it to maintain information across the request/response
    transaction. Using a session cookie for information storage is convenient but
    has limitations. A cookie has a memory size limit imposed on it by the browser
    that can vary from browser to browser. The memory constraint on cookie size is
    one problem; another is the size of the data going across the internet for every
    request/response message.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦存在会话，就可以使用它来在请求/响应事务中维护信息。使用会话 cookie 进行信息存储很方便，但有其局限性。cookie 有浏览器强加的内存大小限制，这在不同浏览器之间可能有所不同。cookie
    大小的内存限制是一个问题；另一个问题是每次请求/响应消息在互联网上传输的数据大小。
- en: The information stored in a cookie is sent back and forth with every transaction
    between the client and the browser. Even in the age of widely available high-speed
    internet access, that’s still a concern, especially for mobile devices. The solution
    to both these concerns is to use the session cookie to store the unique user identifier
    value and incorporate it on the server side to retrieve all the other information
    necessary to build the correct response to the request.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在 cookie 中的信息在客户端和浏览器之间的每次事务中都会来回发送。即使在广泛可用的宽带互联网时代，这仍然是一个问题，尤其是对于移动设备。解决这两个问题的方案是使用会话
    cookie 来存储唯一的用户标识符值，并在服务器端将其整合以检索构建正确响应所需的所有其他信息。
- en: 8.2 Remembering someone
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 记住某人
- en: Remembering the user gives the MyBlog application ways to control what features
    are available to users. For example, blog entries and comments are visible to
    anyone, but the ability to add a new blog entry or comment on an existing one
    is reserved for known users.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 记住用户让 MyBlog 应用程序有了控制哪些功能对用户可用的方法。例如，博客条目和评论对任何人可见，但添加新博客条目或对现有条目发表评论的能力仅限于已知用户。
- en: The user information described previously can be stored on the server and retrieved
    using the session cookie’s unique user identifier. A unique user identifier value
    has to be created and stored and then used to authenticate that user. For a website,
    identifying a user happens when a user logs in through an authentication system.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 之前描述的用户信息可以存储在服务器上，并使用会话 cookie 的唯一用户标识符检索。必须创建并存储一个唯一的用户标识符值，然后用于验证该用户。对于网站来说，识别用户发生在用户通过认证系统登录时。
- en: 8.2.1 Authentication
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.1 认证
- en: The MyBlog application uses the `flask_login` extension module from the Python
    Package Index ([https://pypi.org/](https://pypi.org/)). The `flask_login` extension
    gives the MyBlog application session management abilities and tools to log users
    in and out and handle the somewhat difficult “remember me” functionality. It also
    adds protection to URL endpoints so only authenticated users can access the protected
    endpoints.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: MyBlog 应用程序使用来自 Python 包索引的 `flask_login` 扩展模块。`flask_login` 扩展为 MyBlog 应用程序提供了会话管理能力和登录、注销用户以及处理“记住我”功能的工具。它还增加了对
    URL 端点的保护，以确保只有经过认证的用户才能访问受保护的端点。
- en: The login process follows the common email/password pattern to authenticate
    users. The process is illustrated in figure 8.1\. The user’s email address is
    a valid choice as a unique identifier because it is already unique and likely
    well remembered. From a high-level view, the login system you’re going to create
    follows a stepwise workflow.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 登录过程遵循常见的电子邮件/密码模式以验证用户。该过程在图 8.1 中展示。用户的电子邮件地址是一个有效的唯一标识符选择，因为它已经唯一且很可能被很好地记住。从高层次来看，您将要创建的登录系统遵循逐步的工作流程。
- en: '![](../../OEBPS/Images/CH08_F01_Farrell.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F01_Farrell.png)'
- en: Figure 8.1 A visual representation of the login process workflow steps
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 登录过程的工作流程步骤的视觉表示
- en: 'The user login process follows this sequence of steps:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 用户登录过程遵循以下步骤序列：
- en: The user makes a `GET` request from their browser to the authentication login
    URL endpoint.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户从他们的浏览器向认证登录 URL 端点发出 `GET` 请求。
- en: The authentication login handler responds to the `GET` request by returning
    the rendered login HTML page.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 认证登录处理程序通过返回渲染的登录 HTML 页面来响应 `GET` 请求。
- en: The user fills out the login page form fields and submits the form.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户填写登录页面表单字段并提交表单。
- en: The form is submitted to the authentication login system using a `POST` request.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表单通过 `POST` 请求提交到认证登录系统。
- en: The login system tries to find a user with a matching email and password by
    using the models supported by the application.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录系统试图通过使用应用程序支持的模型来找到与匹配的电子邮件和密码的用户。
- en: The `User` model tries to find a user with a matching email and password in
    the application storage system.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`User` 模型试图在应用程序存储系统中找到与匹配的电子邮件和密码的用户。'
- en: If a matching user is found, the user is directed to the home page or the original
    destination page that the user wanted to view.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找到匹配的用户，用户将被引导到主页或用户想要查看的原始目标页面。
- en: Because powerful computer CPU and GPU hardware are readily available, the ability
    to crack user passwords is easier for hackers to implement. The MyBlog application
    uses the `Flask_bcrypt` extension to hash the passwords stored on the server.
    The `bcrypt` functionality creates a computationally expensive hash, making it
    resistant to brute force attacks, even with increasing computer power.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于强大的计算机 CPU 和 GPU 硬件 readily 可用，黑客破解用户密码的能力更容易实现。MyBlog 应用程序使用 `Flask_bcrypt`
    扩展来散列存储在服务器上的密码。`bcrypt` 功能创建一个计算成本高昂的散列，使其对暴力攻击具有抵抗力，即使随着计算机性能的提高也是如此。
- en: Tip Plain-text passwords should never be stored in a database and should always
    be cryptographically hashed first. This means your users will have to reset their
    passwords if they forget them. It also means the user accounts are protected if
    a hacker manages to gain access to your site’s database, as the passwords are
    encrypted.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：明文密码绝不应该存储在数据库中，而应该首先进行加密散列处理。这意味着如果用户忘记了密码，他们需要重置密码。这也意味着如果黑客设法访问了您的网站数据库，用户账户将得到保护，因为密码是加密的。
- en: Figure 8.1 shows a storage mechanism accessed by step six. The `flask_login`
    extension requires this storage to persist users to retrieve and identify them
    later. To do this, you’ll use SQLAlchemy to manage the user data in an SQLite
    database. This chapter focuses primarily on authenticating users and will defer
    more detailed information about SQLAlchemy and utilizing a database until chapter
    10.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1展示了由第六步访问的存储机制。`flask_login` 扩展需要这种存储来持久化用户，以便稍后检索和识别他们。为此，您将使用 SQLAlchemy
    来管理 SQLite 数据库中的用户数据。本章主要关注用户认证，并将有关 SQLAlchemy 和使用数据库的更详细信息推迟到第10章。
- en: 'To install all the modules necessary to run the example applications for this
    chapter, run the following command from within a Python virtual environment using
    the `requirements.txt` file from the repository:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装运行本章示例应用程序所需的所有模块，请在 Python 虚拟环境中运行以下命令，使用存储库中的 `requirements.txt` 文件：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This makes the modules available in the code you create to add authentication.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得模块在您创建的代码中可用于添加认证。
- en: LoginManager
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: LoginManager
- en: 'First, add the modules necessary for authentication, password encryption, and
    user persistence to the `app/__init__.py` module. Adding them to the import section
    at the top of the module makes the functionality available to the `create_app()`
    application factory function:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将必要的认证、密码加密和用户持久化模块添加到 `app/__init__.py` 模块中。将它们添加到模块顶部的导入部分，使得这些功能对 `create_app()`
    应用程序工厂函数可用：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ① Imports the SQLAlchemy functionality to manage the data persistence
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ① 导入 SQLAlchemy 功能以管理数据持久化
- en: ② Imports the LoginManager to handle user authentication
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ② 导入 LoginManager 以处理用户认证
- en: ③ Imports the Bcrypt module to cryptographically encrypt user passwords
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 导入 Bcrypt 模块以对用户密码进行加密
- en: 'Then, right above the `create_app()` function, add new global instance variables
    for the new functionality:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `create_app()` 函数上方，添加新的全局实例变量以实现新功能：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ① Creates an uninitialized instance of the LoginManager class
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建 LoginManager 类的一个未初始化实例
- en: ② Points the LoginManager instance to the Blueprint view to be created later
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将 LoginManager 实例指向稍后创建的蓝图视图
- en: ③ Creates an uninitialized instance of the Bcrypt() class
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 创建 Bcrypt() 类的一个未初始化实例
- en: ④ Creates an uninitialized instance of the SQLAlchemy class
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 创建 SQLAlchemy 类的一个未初始化实例
- en: 'Inside the scope of the `create_app()` function in the initialize plugins section,
    initialize the new instance variables you just created with the app instance variable
    as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `create_app()` 函数的初始化插件部分范围内，使用以下方式使用应用程序实例变量初始化您刚刚创建的新实例变量：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the import routes section, import an `auth` module that you’ll create shortly:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入路由部分，导入您即将创建的 `auth` 模块：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the register blueprints section, register an `auth` Blueprint that will
    be created soon:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册蓝图部分，注册一个即将创建的 `auth` 蓝图：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add this new section just above the `return` `app` line at the bottom of the
    `create_app()` function:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `create_app()` 函数底部的 `return` `app` 行上方添加此新部分：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ① Creates the SQLite database if it doesn’t already exist
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ① 如果不存在，则创建 SQLite 数据库
- en: The new code uses functionality that’s defined in later sections of this chapter.
    This work initializes the authentication, encryption, and database systems whenever
    the app package is accessed or imported. The next step is to create the `auth`
    Blueprint that handles the user authentication functionality.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 新代码使用本章后续部分定义的功能。这项工作在访问或导入 app 包时初始化认证、加密和数据库系统。下一步是创建处理用户认证功能的 `auth` 蓝图。
- en: Auth Blueprint
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Auth 蓝图
- en: 'Like the `intro` Blueprint, the `auth` Blueprint is a Python package containing
    distinct functionality. Create a directory named `auth` under the app package
    and then create an `__init__.py` file inside the `auth` directory. The `__init__.py`
    file generates and initializes the `auth_bp` Blueprint instance as we’ve done
    before:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `intro` 蓝图一样，`auth` 蓝图是一个包含独立功能的 Python 包。在应用程序包下创建一个名为 `auth` 的目录，然后在 `auth`
    目录中创建一个 `__init__.py` 文件。`__init__.py` 文件生成并初始化 `auth_bp` 蓝图实例，就像我们之前做的那样：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This code creates the `auth_bp` Blueprint instance whenever the `auth` package
    is accessed or imported. The actual authentication functionality is contained
    in the `auth.py` file also created in the `app/auth` directory:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码在访问或导入 `auth` 包时创建 `auth_bp` 蓝图实例。实际的认证功能包含在 `app/auth` 目录中创建的 `auth.py`
    文件中：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ① Imports the auth_bp Blueprint instance from the package
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ① 从包中导入 auth_bp 蓝图实例
- en: ② Imports the models, which will be created next
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ② 导入将要创建的模型
- en: ③ Imports the login_manager instance from the package
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 从包中导入login_manager实例
- en: ④ Imports the LoginForm, which will be created in the next section
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 导入LoginForm，它将在下一节中创建
- en: ⑤ The function called every time the login_manager needs to determine if the
    user exists
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 每次登录管理器需要确定用户是否存在时调用的函数
- en: ⑥ The login function registered with the auth_bp Blueprint for the "/login"
    route
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 为`/login`路由注册的与auth_bp蓝图相关联的登录函数
- en: ⑦ Begins a database session context manager scope to close the database session
    when the scope ends
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 开始数据库会话上下文管理器范围，以便在范围结束时关闭数据库会话
- en: ⑧ Gets a user from the database based on the form email value
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 根据表单电子邮件值从数据库中获取用户
- en: ⑨ If no user is found, or the password doesn’t verify, warn the user and redirect
    to the login.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 如果找不到用户或密码验证失败，警告用户并重定向到登录页面。
- en: ⑩ Sets the logged-in user and creates a session cookie
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 设置已登录用户并创建会话cookie
- en: The `auth.py` module creates a route called `"/login"` associated with the `auth_bp`
    Blueprint instance and associates it with the `login()` handler function. The
    `login()` handler function has two purposes. When it is called because of an HTTP
    `GET` request, it returns the rendered `login.xhtml` template, which will be created
    in the next section. If the function is called as the result of an HTTP `POST`
    request, it will process the contents of the form parameters in the `login.xhtml`
    template.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`auth.py`模块创建了一个名为`"/login"`的路由，与`auth_bp`蓝图实例相关联，并将其与`login()`处理函数相关联。`login()`处理函数有两个目的。当它因HTTP
    `GET`请求而被调用时，它返回渲染的`login.xhtml`模板，该模板将在下一节中创建。如果该函数因HTTP `POST`请求而被调用，它将处理`login.xhtml`模板中的表单参数内容。'
- en: 'The `if` `form.validate_on_submit()` code determines if the HTTP request method
    is a `GET` or a `POST` and branches accordingly. If the method is a `POST`, it
    will validate the form parameters against a set of rules configured in the `LoginForm`
    class. If the form parameters are valid, the function takes the following actions:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` `form.validate_on_submit()`代码确定HTTP请求方法是否为`GET`或`POST`，并相应地进行分支。如果方法是`POST`，它将验证表单参数与在`LoginForm`类中配置的规则集。如果表单参数有效，该函数将采取以下行动：'
- en: Gets a user from the database using the form email parameter.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用表单电子邮件参数从数据库中获取用户。
- en: 'If the user doesn’t exist or the form password parameter is not valid:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户不存在或表单密码参数无效：
- en: Flashes a warning message to the user and re-renders the login screen. Flask
    uses the term *Flash* to mean presenting additional information to the user.
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向用户显示警告消息并重新渲染登录屏幕。Flask使用术语*Flash*表示向用户展示额外信息。
- en: 'If the user does exist and the form password parameter is valid:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户确实存在且表单密码参数有效：
- en: Updates the login manager system about the user and creates a session cookie
    to remember them.
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新登录管理器系统关于用户的信息，并创建一个会话cookie以记住他们。
- en: Gets the page to which the user was trying to navigate when presented with the
    login action.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取用户在登录操作中尝试导航到的页面。
- en: Validates the request for that page if the `netloc` attribute is valid.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证该页面的请求是否有效，如果`netloc`属性有效。
- en: Redirects the user to that page or the home page if `netloc` is empty.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`netloc`为空，则将用户重定向到该页面或主页。
- en: User models
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 用户模型
- en: One of the goals of adding a login mechanism to the MyBlog application was to
    layer state information on top of the HTTP protocol to remember the user. Using
    the `flask_login` system, you’re getting closer to that, but we need to have a
    unique identifier to save in the session cookie. The identifier can be used to
    retrieve information about the user.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 向MyBlog应用程序添加登录机制的一个目标是在HTTP协议之上叠加状态信息以记住用户。使用`flask_login`系统，你正接近这个目标，但我们需要一个唯一的标识符来保存到会话cookie中。该标识符可以用来检索有关用户的信息。
- en: Both require us to define and implement a user data structure. We will create
    a Python SQLAlchemy class—`User`—that will be stored in an SQLite database.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者都要求我们定义和实现一个用户数据结构。我们将创建一个Python SQLAlchemy类—`User`—它将被存储在SQLite数据库中。
- en: SQLite is a relational database system that Python can access via modules. An
    in-depth discussion about databases and accessing them with SQLAlchemy will be
    presented in chapter 10\. Figure 8.2 shows all the information you’ll be storing
    about logged-in users—their name, email, hashed password, and whether they are
    active. The created and updated fields are simple audit information showing a
    timestamp when the record was created or updated.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 是一个关系型数据库系统，Python 可以通过模块访问它。关于数据库及其使用 SQLAlchemy 访问的深入讨论将在第 10 章中介绍。图
    8.2 展示了你将存储关于已登录用户的所有信息——他们的姓名、电子邮件、哈希密码以及他们是否活跃。创建和更新字段是简单的审计信息，显示了记录创建或更新的时间戳。
- en: '![](../../OEBPS/Images/CH08_F02_Farrell.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 Farrell](../../OEBPS/Images/CH08_F02_Farrell.png)'
- en: Figure 8.2 The ERD (entity relationship diagram) of the `User` table showing
    its fields and their data types
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 显示 `User` 表字段及其数据类型的 ERD（实体关系图）
- en: The MyBlog application will store and present information it remembers, such
    as users, blog content, and comments. Each item will need to be defined and implemented
    as you create more features that the application supports. Because everything
    the MyBlog application can present is stored in a database, you’ll start by using
    a database term—*models*.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: MyBlog 应用程序将存储和展示它记住的信息，例如用户、博客内容和评论。每个项目都需要在创建更多应用程序支持的功能时进行定义和实现。因为 MyBlog
    应用程序可以展示的所有内容都存储在数据库中，所以你将首先使用一个数据库术语——*模型*。
- en: 'The `app/models.py` module holds all database models that define and implement
    everything the MyBlog application stores. Because you need a `User` model to enable
    users to log into the system, let’s create the `app/models.py` file now. The first
    thing to do in the `app/models.py` file is to import the modules needed:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`app/models.py` 模块包含所有数据库模型，这些模型定义并实现了 MyBlog 应用程序存储的所有内容。因为你需要一个 `User` 模型来允许用户登录系统，所以现在让我们创建
    `app/models.py` 文件。在 `app/models.py` 文件中要做的第一件事是导入所需的模块：'
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `import` statements give the `app/models.py` module access to the functionality
    needed to create the `User` class. The `User` class is employed with the `flask_login`
    extension to authenticate a user of the MyBlog application. Authenticating a user
    means identifying and verifying that the user is known to the MyBlog application
    and can access features available to those users.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`import` 语句使 `app/models.py` 模块能够访问创建 `User` 类所需的功能。`User` 类与 `flask_login`
    扩展一起使用，以验证 MyBlog 应用程序的用户。验证用户意味着识别和验证用户是否为 MyBlog 应用程序所知，并且可以访问那些用户可用的功能。'
- en: We’ll begin by creating the `User` class, which contains information about the
    user—their name, email address, and password, as well as the unique ID associated
    with the user that will be stored in the HTTP session cookie.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从创建 `User` 类开始，该类包含有关用户的信息——他们的姓名、电子邮件地址和密码，以及将与用户关联的唯一 ID，该 ID 将存储在 HTTP
    会话 cookie 中。
- en: UUID database primary keys
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: UUID 数据库主键
- en: When creating a database table, a common practice is to use an auto-incrementing
    integer value as the unique ID associated with each record in the table. Instead,
    the MyBlog application will use UUID values for this unique ID, called the *primary
    key*, for records in the table. A UUID is a long string of alphanumeric characters
    that is unique worldwide. The pros and cons of taking this approach are covered
    in chapter 10.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建数据库表时，一个常见的做法是使用自动递增的整数值作为与表中每个记录相关联的唯一 ID。相反，MyBlog 应用程序将使用 UUID 值作为这个唯一
    ID，称为 *主键*，用于表中的记录。UUID 是一个全球唯一的由字母数字字符组成的长字符串。采用这种方法的优缺点在第 10 章中进行了讨论。
- en: 'A small function is created to supply UUID string values when `User` records
    are created and inserted into the database:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个小函数，在创建 `User` 记录并将其插入数据库时提供 UUID 字符串值：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `get_uuid()` function uses the imported `uuid4()` function to create UUID
    values and then returns the `hex` string version of that value. Returning the
    `hex` string version makes the UUID value a little shorter.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_uuid()` 函数使用导入的 `uuid4()` 函数创建 UUID 值，然后返回该值的 `hex` 字符串版本。返回 `hex` 字符串版本使
    UUID 值略短一些。'
- en: Next, you must add the definition of the `User` class to `app/models.py`. This
    class uses multiple inheritances to obtain built-in functionality from the modules
    imported at the top of `app/models.py`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你必须将 `User` 类的定义添加到 `app/models.py` 中。这个类使用多重继承从 `app/models.py` 顶部导入的模块中获取内置功能。
- en: 'The first is the `UserMixin` class, which presents the child class methods
    that the `flask_login` system expects to be available to access `User` information.
    The second is the `db.Model` class, which comes from the `db` instance variable
    created and initialized in the app module. The `db.Model` class gives a child
    class that inherits from it the SQLAlchemy functionality needed to interact with
    the database and define the columns in a table associated with the attributes
    of the class:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是 `UserMixin` 类，它提供了 `flask_login` 系统期望子类可用的方法来访问 `User` 信息。第二个是来自 `db` 实例变量的
    `db.Model` 类，该实例变量在应用模块中创建和初始化。`db.Model` 类为从其继承的子类提供了与数据库交互和定义与类属性关联的表中的列所需的
    SQLAlchemy 功能：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ① The User class multiply inherits from the UserMixin and db.Model classes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ① 用户类多重继承自 UserMixin 和 db.Model 类。
- en: ② Defines the table name in the database where records of this class will be
    stored
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ② 定义此类记录将存储在数据库中的表名
- en: ③ Defines the unique ID value for User records using the get_uuid function
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使用 `get_uuid` 函数定义用户记录的唯一 ID 值
- en: ④ Defines other User attributes
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 定义其他用户属性
- en: ⑤ Defines record-auditing timestamp attributes
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 定义记录审计时间戳属性
- en: The `User` class inherits from the imported `UserMixin` and `db.Model` classes.
    This means the `User` class IS-A `UserMixin` class and IS-A `db.model` class and
    has access to both classes’ methods and attributes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`User` 类继承自导入的 `UserMixin` 和 `db.Model` 类。这意味着 `User` 类是 `UserMixin` 类和 `db.model`
    类的 IS-A 类，并且可以访问这两个类的所有方法和属性。'
- en: By inheriting from the `UserMixin` class, the `User` class gets methods needed
    to function by the `LoginManager()` instance created in the app package. These
    methods use attributes defined in the `User` class to authenticate a user.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过继承 `UserMixin` 类，`User` 类获得了由在应用包中创建的 `LoginManager()` 实例所需的方法。这些方法使用在 `User`
    类中定义的属性来验证用户。
- en: The `User` class also inherits from the `db.Model` and is how the SQLAlchemy
    functionality is added to the class, giving it access to the database. The `User`
    model defines the structure of a single row of data in a table named `"user"`,
    where each defined attribute is a column in a database table record.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`User` 类也继承自 `db.Model`，这是将 SQLAlchemy 功能添加到类中的方式，使其能够访问数据库。`User` 模型定义了名为
    `"user"` 的表中单行数据的结构，其中每个定义的属性都是数据库表记录中的一个列。'
- en: The `get_id()` method overrides the method of the same name provided by the
    `UserMixin` class, replacing its functionality. The default `get_id()` method
    returns a `self.id` value, but because the `User` class defines the unique ID
    attribute name as `user_uid`, it’s necessary to override the default behavior.
    The `get_id()` method is used whenever the `LoginManager` instance needs to determine
    if the unique identifier stored in the session cookie relates to a real user in
    the system.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_id()` 方法覆盖了由 `UserMixin` 类提供的同名方法，并替换了其功能。默认的 `get_id()` 方法返回一个 `self.id`
    值，但由于 `User` 类将唯一 ID 属性名称定义为 `user_uid`，因此需要覆盖默认行为。`get_id()` 方法在 `LoginManager`
    实例需要确定会话 cookie 中存储的唯一标识符是否与系统中的真实用户相关时使用。'
- en: Note the pair of `password()` methods that create a write-only attribute on
    the `User` class. Because it’s not helpful (or even possible) to read the password
    because it’s cryptographically hashed, the method decorated with `@property` raises
    an attribute error.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意创建在 `User` 类上的只写属性的两个 `password()` 方法。由于密码是经过密码学散列的，因此读取密码没有帮助（甚至不可能），因此用
    `@property` 装饰的方法会引发属性错误。
- en: The `password()` method decorated with `@password.setter` creates the write
    behavior. The method intercepts setting the password attribute and generates a
    cryptographically strong hash of the password, which is stored in the `hashed_password`
    class attribute. Even though `hashed_password` is the attribute’s name, the corresponding
    database column is named `"password"`. The `verify_password()` method is used
    in the `auth.py` module to determine if the password retrieved from the login
    form template matches the hashed version stored for the user.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 用 `@password.setter` 装饰的 `password()` 方法创建写行为。该方法拦截设置密码属性，并生成密码的密码学强散列，该散列存储在
    `hashed_password` 类属性中。尽管 `hashed_password` 是属性名称，但相应的数据库列命名为 `"password"`。`verify_password()`
    方法在 `auth.py` 模块中使用，以确定从登录表单模板检索到的密码是否与为用户存储的散列版本匹配。
- en: 8.2.2 Logging in
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.2 登录
- en: Coding up an HTML form to gather user input for the email and password is a
    straightforward process. With a submit button, the form contents can be sent to
    the MyBlog server as an HTTP `POST` request, and you can then process the form
    information.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 HTML 表单以收集用户输入的电子邮件和密码是一个简单的过程。带有提交按钮的表单内容可以作为 HTTP `POST` 请求发送到 MyBlog 服务器，然后你可以处理表单信息。
- en: Because users can make unintentional and intentional errors when entering form
    data, validating the form input information is necessary. For example, are the
    email and password within the required length restrictions? Are the email and
    password present at all? Does the email address conform to a standardized format?
    Implementing these validation steps is extra work that’s difficult to get right.
    Fortunately, there’s another Flask extension that dramatically simplifies form
    handling—`Flask-WTF`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用户在输入表单数据时可能会无意或有意地犯错，因此验证表单输入信息是必要的。例如，电子邮件和密码是否在所需的长度限制内？电子邮件和密码是否都存在？电子邮件地址是否符合标准格式？实现这些验证步骤是额外的工作，而且很难做对。幸运的是，还有一个
    Flask 扩展可以极大地简化表单处理——`Flask-WTF`。
- en: Flask-WTF
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Flask-WTF
- en: 'The `Flask-WTF` extension integrates the more generalized WTForms package into
    Flask. Using the extension allows you to bind MyBlog server code to HTML form
    elements and automate handling those elements when the corresponding form is received
    by a handler using the HTTP `POST` method. To create the login form and its validation,
    add a new file to the `app/auth` package named `forms.py`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flask-WTF` 扩展将更通用的 WTForms 包集成到 Flask 中。使用此扩展允许你将 MyBlog 服务器代码绑定到 HTML 表单元素，并在使用
    HTTP `POST` 方法处理接收到的相应表单时自动处理这些元素。要创建登录表单及其验证，向 `app/auth` 包中添加一个名为 `forms.py`
    的新文件：'
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ① Imports the FlaskForm class
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ① 导入 FlaskForm 类
- en: ② Imports the field type classes to create in the form
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ② 导入用于在表单中创建的字段类型类
- en: ③ Imports the field validation classes used to validate the form elements
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 导入用于验证表单元素的字段验证类
- en: ④ Creates the LoginForm, inheriting from the base FlaskForm class
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 创建继承自基本 FlaskForm 类的 LoginForm
- en: ⑤ Creates the email form element and validators
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 创建电子邮件表单元素和验证器
- en: ⑥ Creates the password form element and validators
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 创建密码表单元素和验证器
- en: ⑦ Creates the remember_me form element
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 创建记住我表单元素
- en: ⑧ Creates the form cancel button
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 创建表单取消按钮
- en: ⑨ Creates the form submit button
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 创建表单提交按钮
- en: The `LoginForm` class defines an object to create when the form is rendered,
    containing all HTML elements in the form. The elements have a required first parameter—the
    name used for labels, the element form name, and the ID value. The `validators`
    parameter defines a list of validation steps that the element must pass for the
    form to be valid. The `render_kw` parameter is optional and defines additional
    HTML form attributes to be rendered with the element.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoginForm` 类定义了一个在表单渲染时创建的对象，包含表单中的所有 HTML 元素。元素有一个必需的第一个参数——用于标签、元素表单名称和
    ID 值的名称。`validators` 参数定义了一个列表，该列表定义了元素必须通过的验证步骤，以便表单有效。`render_kw` 参数是可选的，它定义了与元素一起渲染的附加
    HTML 表单属性。'
- en: The `email` element is an instance of the `EmailField` class. The class constructor
    has a parameter `"Email"` used as is for any label rendered with the element and
    converted to lowercase when used for name and ID values in the HTML DOM (document
    object model). The `validators` define that an entry is required; the length must
    be between 4 and 128 characters long inclusive, and the element value must be
    in a valid email format.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`email` 元素是 `EmailField` 类的一个实例。类构造函数有一个参数 `"Email"`，它被用作元素渲染的任何标签，并在用于 HTML
    DOM（文档对象模型）中的名称和 ID 值时转换为小写。`validators` 定义了一个条目是必需的；长度必须在 4 到 128 个字符之间，且元素值必须符合有效的电子邮件格式。'
- en: The `password` element is an instance of the `PasswordField` class. The `PasswordField`
    renders the element as an HTML type of password, so the user-entered text is shown
    as a sequence of asterisk characters. The class constructor has a parameter `"Password"`
    used in the same manner as the email element. The `validators` define that a password
    is required, and the length must be between 3 and 64 characters long inclusive.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`password` 元素是 `PasswordField` 类的一个实例。`PasswordField` 将元素渲染为 HTML 类型的密码，因此用户输入的文本显示为一系列星号字符。类构造函数有一个参数
    `"Password"`，其用法与电子邮件元素相同。`validators` 定义了一个密码是必需的，且长度必须在 3 到 64 个字符之间。'
- en: Notice the `render_kw={`"`placeholder`"`:` `“` `“}` parameters on both the email
    and password attributes. These are necessary to make the Bootstrap styling input
    element’s visual functionality work as intended.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意电子邮件和密码属性上的 `render_kw={`"`placeholder`"`:` `“` `“}` 参数。这些是使 Bootstrap 样式的输入元素的视觉功能按预期工作的必要条件。
- en: The `remember_me` element is an instance of the `BooleanField` class. This will
    be rendered as an HTML checkbox with the label “Keep me logged in.”
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`remember_me` 元素是 `BooleanField` 类的一个实例。这将被渲染为一个带有标签“Keep me logged in.”的 HTML
    复选框。'
- en: The `cancel` element is an instance of the `SubmitField` class and creates a
    cancel button that will take the user to the home screen when clicked. The `submit`
    element is also an instance of the `SubmitField` class and creates a submit button
    when the form is rendered. With the `forms.py` module in place, you’ll need to
    create an HTML page where the `LoginForm` class will render the contained elements.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`cancel` 元素是 `SubmitField` 类的一个实例，创建了一个当点击时会将用户带到主页的取消按钮。`submit` 元素也是 `SubmitField`
    类的一个实例，当表单被渲染时创建提交按钮。有了 `forms.py` 模块，你需要创建一个 HTML 页面，其中 `LoginForm` 类将渲染包含的元素。'
- en: Login form
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 登录表单
- en: The `login.xhtml` file is created in the `app/auth/templates` directory, where
    the `auth_bp` Blueprint can access it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`login.xhtml` 文件创建在 `app/auth/templates` 目录中，其中 `auth_bp` 蓝图可以访问它。'
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ① The login.xhtml template inherits from base.xhtml so it gets all the MyBlog
    page elements.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ① 登录.xhtml 模板继承自 base.xhtml，因此它获得了 MyBlog 页面的所有元素。
- en: ② Imports the macros.jinja macros file, which we’ll discuss next
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ② 导入 macros.jinja 宏文件，我们将在下一节讨论
- en: ③ Cross-Site Request Forgery protection token reviewed at the end of this chapter
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 在本章末尾审查跨站请求伪造保护令牌
- en: ④ Creates the email element on the page, passing the element Bootstrap class
    information
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 在页面上创建电子邮件元素，传递元素 Bootstrap 类信息
- en: ⑤ Creates the password element on the page, passing the element Bootstrap class
    information
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 在页面上创建密码元素，传递元素 Bootstrap 类信息
- en: ⑥ Creates the remember me element on the page, passing the element Bootstrap
    class information
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 在页面上创建“记住我”元素，传递元素 Bootstrap 类信息
- en: ⑦ Creates the cancel button, passing the element Bootstrap class information
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 创建取消按钮，传递元素 Bootstrap 类信息
- en: ⑧ Creates the submit button, passing the element Bootstrap class information
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 创建提交按钮，传递元素 Bootstrap 类信息
- en: 'Remember back to the `auth.py` module and the `login()` handler assigned to
    the `/login` route. Two lines of code are of interest as related to rendering
    the login form and connecting it to the `LoginForm` instance created in `forms.py`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下 `auth.py` 模块和分配给 `/login` 路由的 `login()` 处理程序。有两行代码与渲染登录表单和将其连接到在 `forms.py`
    中创建的 `LoginForm` 实例相关：
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: and
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE16]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: These two lines of code are important when the `login()` handler is invoked
    by an HTTP `GET` or `POST` request. The first creates the `LoginForm` class instance
    variable. The second passes that `form` instance to `render_template` as the second
    parameter, giving the Jinja template engine access to the `form` instance when
    rendering the `login.xhtml` template elements. This is how the `LoginForm` definition
    instance is connected to the `login.xhtml` template.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行代码在通过 HTTP `GET` 或 `POST` 请求调用 `login()` 处理程序时非常重要。第一行创建了 `LoginForm` 类的实例变量。第二行将那个
    `form` 实例传递给 `render_template` 作为第二个参数，这样在渲染 `login.xhtml` 模板元素时，Jinja 模板引擎就可以访问
    `form` 实例。这就是如何将 `LoginForm` 定义实例连接到 `login.xhtml` 模板的方式。
- en: When a `GET` request is received, the template engine uses the form instance
    to help render it in the browser window. When a `POST` request is received, the
    body of the form contains the form data entered by the user, which populates the
    `LoginForm` attributes. The form validation methods for each attribute run to
    validate that the form data meets the validation requirements.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到 `GET` 请求时，模板引擎使用表单实例帮助在浏览器窗口中渲染它。当接收到 `POST` 请求时，表单体包含用户输入的表单数据，这些数据填充了
    `LoginForm` 属性。每个属性的表单验证方法都会运行以验证表单数据是否符合验证要求。
- en: Running the code in `examples/CH_08/examples/01` and navigating to `127.0.0.1:5000/login`
    presents the login form shown in the figure 8.3 screenshot to the user. The login
    form presents input elements for the user to enter their email and password and
    whether they should be kept logged in.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `examples/CH_08/examples/01` 目录中运行代码并导航到 `127.0.0.1:5000/login`，将如图 8.3 截图所示的登录表单展示给用户。登录表单提供了用户输入他们的电子邮件和密码以及他们是否应该保持登录状态的功能。
- en: '![](../../OEBPS/Images/CH08_F03_Farrell.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH08_F03_Farrell.png)'
- en: Figure 8.3 The MyBlog-generated login screen lets the user enter their email
    and password to access the site.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 MyBlog 生成的登录界面允许用户输入他们的电子邮件和密码以访问网站。
- en: Jinja macros
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja 宏
- en: 'Notice this line in the `login.xhtml` template that’s part of the email and
    password definition sections:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `login.xhtml` 模板中电子邮件和密码定义部分这一行：
- en: '[PRE17]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This references a Jinja macro in the `app/templates/macros.jinja` file imported
    at the top of the `login.xhtml` template. The `validation_errors()` macro handles
    displaying any `LoginForm` validation errors to the user so they can be corrected:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这引用了 `app/templates/macros.jinja` 文件中的一个 Jinja 宏，该宏在 `login.xhtml` 模板的顶部导入。`validation_errors()`
    宏处理向用户显示任何 `LoginForm` 验证错误，以便它们可以被纠正：
- en: '[PRE18]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A macro is a function definition in the Jinja template engine, much like defining
    a Python function. The `validation_errors()` macro receives a list of `LoginForm`
    validation errors. It first checks if there are any errors and, if so, iterates
    over that list, displaying the error message in small red text below the form
    field that failed validation. The results of entering an invalid email address
    and a password of only two characters render the `login.xhtml` template and include
    error messages indicating the problem to the user. Those errors are shown in the
    figure 8.4 screenshot.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 宏是 Jinja 模板引擎中的一个函数定义，就像定义 Python 函数一样。`validation_errors()` 宏接收一个 `LoginForm`
    验证错误列表。它首先检查是否有任何错误，如果有，就遍历这个列表，在验证失败的表单字段下方以小红色文字显示错误信息。输入无效的电子邮件地址和仅两个字符的密码会导致
    `login.xhtml` 模板渲染，并包含向用户指示问题的错误消息。这些错误显示在图 8.4 截图上。
- en: '![](../../OEBPS/Images/CH08_F04_Farrell.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH08_F04_Farrell.png)'
- en: Figure 8.4 Errors presented if the email or password is invalid
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 如果电子邮件或密码无效时显示的错误
- en: 'You’ll notice nothing happens if you enter a valid email address and password
    with an acceptable length and click the submit button. The `login.xhtml` template
    is rendered again, and there is no information presented to the user about what,
    if anything, happened. Looking back at the `login()` function in the `auth.py`
    file, there is a conditional check in the code right after trying to find a user
    by their email address:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入一个有效长度且可接受的电子邮件地址和密码，并点击提交按钮，你会发现没有任何操作发生。`login.xhtml` 模板再次渲染，并且没有向用户展示任何关于发生了什么（如果有的话）的信息。回顾一下
    `auth.py` 文件中的 `login()` 函数，在尝试通过电子邮件地址查找用户之后，代码中有一个条件检查：
- en: '[PRE19]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If the user is not found, it has a value of `None`, and the code executes the
    `flash()` message function and redirects to the login route; the `login.xhtml`
    template is rendered again. No user was found because none had been created in
    the application yet. The intended code for this condition ran, and the user was
    redirected to the login screen. However, why isn’t the `flash()` function doing
    anything to inform the user by displaying the invalid email or password message?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到用户，则其值为 `None`，代码将执行 `flash()` 消息函数并将用户重定向到登录路由；`login.xhtml` 模板再次渲染。没有找到用户，因为应用程序中还没有创建任何用户。为此条件运行了预期的代码，用户被重定向到登录屏幕。然而，为什么
    `flash()` 函数没有通过显示无效的电子邮件或密码消息来通知用户呢？
- en: 8.3 News flash
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 新闻快讯
- en: The Flask `flash()` function provides users feedback about events and activities
    in an application. When a message is created and sent to the `flash()` function,
    the message is appended to a list of messages available in the context of the
    next request and only the next request. This makes those flash messages available
    to the next rendered template.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 的 `flash()` 函数为用户提供关于应用程序中事件和活动的反馈。当创建一个消息并发送到 `flash()` 函数时，该消息会被追加到下一个请求上下文中可用的消息列表中，并且只有下一个请求。这使得这些闪存消息对下一个渲染的模板可用。
- en: The template has to access the message list and add the messages to the rendered
    HTML to display the flash messages. A direct way to do this is to iterate over
    the flash messages list using a Jinja `for` loop and create an HTML unordered
    list of the messages as part of the rendered HTML. We’ll use Bootstrap to render
    the messages to display them temporarily and not disrupt the template style and
    presentation.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 模板必须访问消息列表并将消息添加到渲染的 HTML 中以显示闪存消息。一种直接的方法是使用 Jinja 的 `for` 循环遍历闪存消息列表，并将消息作为渲染
    HTML 的一部分创建一个 HTML 无序列表。我们将使用 Bootstrap 来渲染消息，以便临时显示它们，而不会破坏模板的样式和展示。
- en: 8.3.1 Improving the login form
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1 改进登录表单
- en: The Bootstrap framework provides a component called toasts, which are lightweight
    alert messages that “float” above the content. Toasts have been made popular in
    both mobile and desktop operating systems. They are useful in the MyBlog application
    because they don’t disrupt the template layout and are transient, and they disappear
    soon after the message is presented.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap 框架提供了一个名为 toasts 的组件，这些是轻量级的警告消息，它们“漂浮”在内容上方。Toast 在移动和桌面操作系统上都变得非常流行。在
    MyBlog 应用程序中，它们非常有用，因为它们不会破坏模板布局，并且是瞬时的，消息展示后很快就会消失。
- en: Because any URL endpoint handler can call the `flash()` function, it’s useful
    to centralize where the flash messages are handled. The `base.xhtml` template
    is ideal as it’s intended to be inherited by every template in the MyBlog system.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于任何 URL 端点处理器都可以调用 `flash()` 函数，因此将闪存消息的处理集中化是有用的。`base.xhtml` 模板是理想的，因为它旨在被
    MyBlog 系统中的每个模板继承。
- en: 'Creating a Bootstrap toast involves a significant amount of HTML code that
    would need to be added to the `base.xhtml` template file. A better option is to
    pull the flash message handling out of the `base.xhtml` template and create a
    Jinja macro. The `flask_flash_messages()` macro function is added to the `app/templates/macros.jinja`
    file:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 Bootstrap toast 需要大量的 HTML 代码，这些代码需要添加到 `base.xhtml` 模板文件中。更好的选择是将闪存消息处理从
    `base.xhtml` 模板中提取出来，并创建一个 Jinja 宏。`flask_flash_messages()` 宏函数被添加到 `app/templates/macros.jinja`
    文件中：
- en: '[PRE20]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ① Begins the definition of the flask_flash_messages() macro
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ① 开始定义 flask_flash_messages() 宏
- en: ② Begins a with context block to get the flash messages
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ② 开始使用 with 上下文块来获取闪存消息
- en: ③ Are there any flash messages to process?
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 是否有需要处理的闪存消息？
- en: ④ Begins the for loop to iterate over the list of flash messages
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 开始循环遍历闪存消息列表
- en: 'Most of the `flask_flash_messages()` macro concerns itself with generating
    the Bootstrap styling required to present toast messages. The toast messages are
    added to the rendered template but aren’t displayed to the user immediately. To
    do that requires JavaScript code to show the messages. The JavaScript code has
    to run every time a template that inherits from `base.xhtml` is rendered, so create
    an `app/static/js/base.js` file as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数的 `flask_flash_messages()` 宏都关注于生成用于展示 toast 消息所需的 Bootstrap 样式。这些 toast
    消息被添加到渲染的模板中，但不会立即显示给用户。为了实现这一点，需要 JavaScript 代码来显示这些消息。JavaScript 代码必须在渲染继承自
    `base.xhtml` 的模板时运行，因此创建一个 `app/static/js/base.js` 文件，如下所示：
- en: '[PRE21]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code creates a self-invoking anonymous JavaScript function, meaning it
    runs as soon as the browser JavaScript engine parses the code. This kind of function
    is useful when you want to run some code immediately and keep variables out of
    the global JavaScript scope. Because `base.js` is included at the end of the `base.xhtml`
    template, the function runs after the HTML DOM elements have been created, including
    the toast elements.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个自调用的匿名 JavaScript 函数，这意味着它在浏览器 JavaScript 引擎解析代码时立即运行。这种函数在你想立即运行一些代码并保持变量不在全局
    JavaScript 作用域中时非常有用。因为 `base.js` 被包含在 `base.xhtml` 模板的末尾，所以函数在 HTML DOM 元素（包括
    toast 元素）创建之后运行。
- en: The `option` variable is a JavaScript object literal and is something like a
    Python dictionary. It contains configuration information passed to the Bootstrap
    `Toast` class to animate the toast message and remove it after 3000 milliseconds,
    or 3 seconds.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`option` 变量是一个 JavaScript 对象字面量，类似于 Python 中的字典。它包含传递给 Bootstrap `Toast` 类以动画化
    toast 消息并在 3000 毫秒或 3 秒后移除的消息配置信息。'
- en: The function then creates the `toastElements` array variable containing all
    the toast HTML DOM elements on the page. An array in JavaScript is similar to
    a Python list. JavaScript arrays have a method called `map` that applies a function
    to each element in the array. The anonymous function passed to the map creates
    a new `Toast` instance passing the `option` object and then calls the `show()`
    method to display the toast message in the browser window.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后该函数创建了一个包含页面中所有 toast HTML DOM 元素的 `toastElements` 数组变量。JavaScript 中的数组类似于
    Python 中的列表。JavaScript 数组有一个名为 `map` 的方法，它将一个函数应用于数组中的每个元素。传递给 `map` 的匿名函数创建一个新的
    `Toast` 实例，传递 `option` 对象，然后调用 `show()` 方法在浏览器窗口中显示 toast 消息。
- en: Suppose you run the application in `examples/CH_08/examples/02` and enter a
    valid email address and password, but the values are unknown to the MyBlog application.
    In that case, the login page will be re-rendered with a toast message about the
    email or password being invalid. The screenshot in figure 8.5 shows the error
    produced.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在 `examples/CH_08/examples/02` 运行应用程序，并输入有效的电子邮件地址和密码，但 MyBlog 应用程序不知道这些值。在这种情况下，登录页面将重新渲染，显示有关电子邮件或密码无效的
    toast 消息。图 8.5 展示了产生的错误截图。
- en: '![](../../OEBPS/Images/CH08_F05_Farrell.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F05_Farrell.png)'
- en: Figure 8.5 The rendered template presenting a Bootstrap toast message containing
    an error message
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 展示了包含错误信息的 Bootstrap 通知消息的渲染模板
- en: Now that users can theoretically log into the MyBlog application, it’s time
    to allow a new user to register with the application, so they have an account
    to use when logging in!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户理论上可以登录 MyBlog 应用程序，是时候允许新用户使用应用程序注册，以便他们在登录时有一个账户！
- en: 8.4 Making new friends
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 结交新朋友
- en: Registering new users on the MyBlog application also uses the `flask_login`
    extension. The register-new-user process follows a pattern like the login process,
    as shown by figure 8.6\. Instead of looking for a user, it creates and saves one
    to the database.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MyBlog 应用程序上注册新用户也使用 `flask_login` 扩展。注册新用户的过程遵循与登录过程类似的模式，如图 8.6 所示。它不是寻找用户，而是创建并保存一个到数据库中。
- en: '![](../../OEBPS/Images/CH08_F06_Farrell.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F06_Farrell.png)'
- en: Figure 8.6 A visual representation of the register-new-user process workflow
    steps
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 注册新用户过程工作流程步骤的视觉表示
- en: 'The register-new-user process is as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注册新用户的过程如下：
- en: The user makes a `GET` request from their browser to the authentication register-new-user
    URL endpoint.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户从浏览器向认证注册新用户 URL 端点发出 `GET` 请求。
- en: The authentication register-new-user handler responds to the `GET` request by
    returning the rendered register-new-user HTML page.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 认证注册新用户处理程序通过返回渲染的注册新用户 HTML 页面来响应 `GET` 请求。
- en: The user fills out the register-new-user page form fields and submits the form.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户填写注册新用户页面表单字段并提交表单。
- en: The form is submitted to the authentication register-new-user system using a
    `POST` request.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `POST` 请求将表单提交到认证注册新用户系统。
- en: The register-new-user system creates a user from the form data using the models
    supported by the application.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册新用户系统使用应用程序支持的模式从表单数据创建用户。
- en: The `User` model saves the newly created user in the application storage system.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`User` 模型将新创建的用户保存到应用程序存储系统中。'
- en: The user is directed to the authentication login page to enter their login credentials.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户被引导到认证登录页面以输入他们的登录凭证。
- en: 8.4.1 Auth Blueprint
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.1 认证蓝图
- en: 'The register-new-user handler is in the `app/auth/auth.py` file. Like the login
    handler, a form is derived from the `FlaskForm` class in the `forms.py` module
    called `RegisterNewUserForm`. Add this class instance to the line of code in `app/auth.py`
    that imports the `LoginForm` class:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注册新用户处理程序位于 `app/auth/auth.py` 文件中。与登录处理程序一样，从 `forms.py` 模块中的 `FlaskForm` 类派生出一个名为
    `RegisterNewUserForm` 的表单。将此类实例添加到 `app/auth.py` 中导入 `LoginForm` 类的代码行：
- en: '[PRE22]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add a new handler to the module at the bottom of the file:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件底部添加一个新的处理程序：
- en: '[PRE23]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ① Marks the register_new_user() function as the handler for the /register_new_user
    route for both GET and POST HTTP requests
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将 register_new_user() 函数标记为 /register_new_user 路由的 GET 和 POST HTTP 请求的处理程序
- en: ② If the user is already authenticated, redirect them to the home screen.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ② 如果用户已经认证，则将其重定向到主页。
- en: ③ Creates an instance of the RegisterNewUserForm()
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 创建一个 RegisterNewUserForm 实例
- en: ④ If the HTTP request is a POST, validate the incoming form data.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 如果 HTTP 请求是 POST，则验证传入的表单数据。
- en: ⑤ Creates a new user initializing the attributes with form data
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 使用表单数据初始化属性创建新用户
- en: ⑥ Adds the newly created user to the database, logs that a new user was created,
    and redirects to the login page
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 将新创建的用户添加到数据库，记录新用户创建，并重定向到登录页面
- en: ⑦ If the HTTP request is a GET, render the empty register_new_user.xhtml template,
    passing in the form instance for use in the template.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 如果 HTTP 请求是 GET，则渲染空的 register_new_user.xhtml 模板，传入表单实例以供模板使用。
- en: 8.4.2 New user form
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.2 新用户表单
- en: 'Repeating the pattern used for the login form, a Flask-WTForm and HTML template
    file were created to complete the register-new-user functionality. Add the `RegisterNewUserForm`
    class definition to the `app/auth/forms.py` file:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 重复用于登录表单的模式，创建了一个 Flask-WTForm 和 HTML 模板文件，以完成注册新用户的功能。将 `RegisterNewUserForm`
    类定义添加到 `app/auth/forms.py` 文件中：
- en: '[PRE24]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ① New items to add to the import section
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ① 需要添加到导入部分的新条目
- en: ② Defines the RegisterNewUserForm class
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ② 定义了 RegisterNewUserForm 类
- en: ③ Creates the first_name, last_ name, email, password, and confirm_password
    form elements and validators
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 创建了 first_name、last_name、email、password 和 confirm_password 表单元素和验证器
- en: ④ Creates the form submit buttons
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 创建表单提交按钮
- en: 'This code creates the form passed to the register-new-user template to create
    the HTML DOM elements to render and apply validation rules when the form is submitted
    by a `POST` request. There is one additional method to add at the bottom of the
    `RegisterNewUserForm` class:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建传递给注册新用户模板的表单，以创建渲染的 HTML DOM 元素，并在通过 `POST` 请求提交表单时应用验证规则。在 `RegisterNewUserForm`
    类底部还需要添加一个额外的方法：
- en: '[PRE25]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `validate_email()` method is a custom validation that ensures a new user
    isn’t using an email address that already exists in the system. The `FlaskForm`
    class has the functionality to introspect classes that inherit from it. That introspection
    finds the `validate_email()` method and adds it to the validation for the email
    form field.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`validate_email()` 方法是一种自定义验证，确保新用户不会使用系统中已存在的电子邮件地址。`FlaskForm` 类具有对从它继承的类进行内省的功能。这种内省找到了
    `validate_email()` 方法并将其添加到电子邮件表单字段的验证中。'
- en: The `RegisterNewUserForm` class instance created in the handler is passed to
    the `register_new_user.xhtml` template to render the user’s form. This template
    is like the `login.xhtml` template and isn’t presented here. However, you can
    see the template by editing the `examples/CH_08/examples/03/app/auth/templates/register_new_user.xhtml`
    file.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序中创建的 `RegisterNewUserForm` 类实例被传递到 `register_new_user.xhtml` 模板以渲染用户的表单。这个模板类似于
    `login.xhtml` 模板，此处未展示。然而，你可以通过编辑 `examples/CH_08/examples/03/app/auth/templates/register_new_user.xhtml`
    文件来查看模板。
- en: If you move to the `examples/CH_08/examples/03` directory and run the MyBlog
    application and navigate to the `127.0.0.1:5000/register_new_user` route, the
    form in figure 8.7 will be rendered in the browser. The form provides fields for
    new users to enter their first name, last name, email, and password and confirm
    the password. When the Create New User button is clicked, the form data is sent
    to the server, and the email address is checked to see if it already exists in
    the system. If the email is unknown in the MyBlog application, a new user is created
    and saved to the database.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你切换到 `examples/CH_08/examples/03` 目录并运行 MyBlog 应用程序，然后导航到 `127.0.0.1:5000/register_new_user`
    路由，图 8.7 中的表单将在浏览器中渲染。该表单提供了新用户输入他们的名字、姓氏、电子邮件和密码以及确认密码的字段。当点击创建新用户按钮时，表单数据将被发送到服务器，并检查电子邮件地址是否已在系统中存在。如果电子邮件在
    MyBlog 应用程序中未知，则创建新用户并将其保存到数据库中。
- en: '![](../../OEBPS/Images/CH08_F07_Farrell.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH08_F07_Farrell.png)'
- en: Figure 8.7 The create new user form rendered in a browser
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 在浏览器中渲染的新用户创建表单
- en: '8.4.3 Oh yeah: logging out'
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.3 哦，对了：注销
- en: Now that users can log in to the MyBlog application, we also need to provide
    a way to log out. Besides nice symmetry, logging out of an authenticated application
    is vital so users have control over who can access the application with their
    credentials.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户可以登录 MyBlog 应用程序，我们还需要提供一个注销的方法。除了良好的对称性外，从认证应用程序中注销对于用户能够控制谁可以使用他们的凭据访问应用程序至关重要。
- en: For the MyBlog application, the logout functionality is created by adding another
    URL route to the `auth` module. When a user navigates to the logout route, no
    template is presented. Instead, the route handler resets the session cookie and
    redirects the user to the application home page. Because the home page is available
    to any user, authenticated or not, this is a reasonable approach.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 MyBlog 应用程序，注销功能是通过向 `auth` 模块添加另一个 URL 路由来创建的。当用户导航到注销路由时，不会显示任何模板。相反，路由处理程序重置会话cookie并将用户重定向到应用程序主页。因为主页对任何用户（无论是否认证）都可用，所以这是一种合理的方法。
- en: 'In the `app/auth/auth.py` module, modify the `from flask_login` line like this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `app/auth/auth.py` 模块中，修改 `from flask_login` 行如下：
- en: '[PRE26]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And add this to the bottom of the `app/auth.py` module:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到 `app/auth.py` 模块的底部：
- en: '[PRE27]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ① Adds a new route and handler for logging a user out of the system
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ① 添加了注销用户的新路由和处理程序
- en: ② Calls the flask_login logout_user() function to log the user out
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ② 调用 flask_login 的 logout_user() 函数来注销用户
- en: ③ Flashes a message to inform the user they’ve been logged out
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 向用户显示一条消息，告知他们已被注销
- en: ④ Redirects the user to the application home page
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 将用户重定向到应用程序主页
- en: 8.5 What’s next
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5 接下来是什么
- en: We’ve got the basics of our authentication system in place but need to add more
    functionality to make it fully useful. In the next chapter, you’ll add the login
    capability to the navigation system so users can easily log in and out. We’ll
    add the ability to confirm the user’s email address, which will close the loop
    on authenticating that a user is who they say they are.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经建立了认证系统的基本框架，但需要添加更多功能使其完全有用。在下一章中，你将为导航系统添加登录功能，以便用户可以轻松登录和注销。我们还将添加确认用户电子邮件地址的功能，这将完成验证用户身份的闭环。
- en: Users will need to reset their passwords if they’ve forgotten them and view
    and edit their profiles. We’ll add these features to the MyBlog application as
    well.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户忘记了密码，他们需要重置密码，并查看和编辑他们的个人资料。我们还将这些功能添加到 MyBlog 应用程序中。
- en: We’ll also add authorization roles to users to help the MyBlog application control
    what users can do when they’re logged into the application. The roles will control
    who can create content, who can edit the content, and who can activate and deactivate
    that content. Once we have both authentication and authorization mechanisms in
    place, we can use those concepts to protect routes in the application so that
    only authenticated users with specific roles can navigate and see certain URL
    routes.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将为用户添加授权角色，以帮助 MyBlog 应用程序控制用户在登录应用程序时可以执行的操作。这些角色将控制谁可以创建内容，谁可以编辑内容，以及谁可以激活和停用该内容。一旦我们建立了认证和授权机制，我们就可以使用这些概念来保护应用程序中的路由，以确保只有经过认证且具有特定角色的用户才能导航并查看特定的
    URL 路由。
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Authentication is all about identifying who someone is in a consistent, reliable
    way. Doing so with the HTTP protocol takes some thought and code to make it happen.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证的全部内容都是关于以一致、可靠的方式识别某人。使用 HTTP 协议实现这一点需要一些思考和代码。
- en: The Flask framework and third-party modules provide tools to aid you as a developer
    to manage users and the login and logout process.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask 框架和第三方模块提供了工具，帮助开发者管理用户和登录/注销过程。
- en: The Flask flash functionality combined with Bootstrap provides a good-looking
    and functional way to send messages to your users without disrupting the workflow
    or design of your site.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask 的 flash 功能结合 Bootstrap 提供了一种既美观又实用的方式，可以在不干扰工作流程或网站设计的情况下向用户发送消息。
