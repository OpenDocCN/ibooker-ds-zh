- en: Chapter 6\. Using the Two Languages Synergistically
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章\. 协同使用两种语言
- en: Rick J. Scavetta
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Rick J. Scavetta
- en: Interoperability, the ability for different programming languages to work together,
    is a cornerstone of computing. Ideally objects can be shared directly between
    the two languages. As you can imagine, this can be problematic for a variety of
    reasons, like memory usage and incompatible data storage structures to name just
    two. Although there have been several attempts to implement this smoothly between
    Python and R, it’s only been in the past couple of years that a reasonably functional
    kit had come to fruition. I’ll discuss this in [“Interoperability”](#interOp).
    But it’s useful to first return to the basics. This will not only give context
    to appreciate smooth interoperability later on, but you a basic solution may already
    meet your needs. Nonetheless, if you want to get started with interoperability,
    you can skip the next section.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 互操作性，即不同编程语言共同工作的能力，是计算机的基石。理想情况下，对象可以直接在两种语言之间共享。正如你可以想象的那样，这可能因为多种原因而成为问题，比如内存使用和不兼容的数据存储结构，只举两个例子。尽管有几次尝试使Python和R之间的互操作性实现得更加顺畅，但直到最近几年才真正出现了一个功能合理的工具包。我将在[“互操作性”](#interOp)一节中讨论这个问题。但首先回到基础是很有用的。这不仅能帮助你理解后面顺畅互操作的背景，而且一个基础的解决方案可能已经满足你的需求。尽管如此，如果你想开始使用互操作性，可以跳过下一节。
- en: Faux-operability
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伪操作性
- en: The most basic type of interoperability, which we’ll call cross-talk, is more
    of a faux-operability. Here, we execute pre-defined scripts across languages,
    passing information between them using files as intermediaries. Imagine the following
    situation, which I’ve diagramed in [Figure 6-1](#crosstalk).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的互操作类型，我们将其称为跨语言交流，更多地是一种伪操作性。在这里，我们通过文件作为中介，在语言之间执行预定义的脚本，传递信息。想象一下下面的情况，我已经在[图6-1](#crosstalk)中绘制了图示。
- en: '![](Images/prds_0601.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/prds_0601.png)'
- en: Figure 6-1\. An example of cross-talk to facilate interoperability.
  id: totrans-6
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-1\. 促进互操作性的跨语言交流示例。
- en: 'In R, after performing some necessary work on an object, e.g. `PlantGrowth`,
    we execute:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中，在对对象（如`PlantGrowth`）执行一些必要的工作后，我们执行：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `system()` function executes a system command, provided as a character argument.
    The command is made up of four parts.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`system()`函数执行一个系统命令，该命令作为字符参数提供。命令由四个部分组成。'
- en: First, `~/.venv/bin/python3` is the location of the Python executable within
    our virtual environment, assuming that you’ve created one. We could have also
    included this in the scripts *shebang* first line as `#!/.venv/bin/env python3`.
    This ensures that the script is executed in the environment in which it was created.
    See [“Virtual environments”](ch03.xhtml#pyvenv) if this sounds strange to you.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`~/.venv/bin/python3`是我们虚拟环境中Python可执行文件的位置，假设你已经创建了一个虚拟环境。我们也可以在脚本的*shebang*第一行中包含它，如`#!/.venv/bin/env
    python3`。这确保脚本在创建它的环境中执行。如果这对你来说听起来很奇怪，请参阅[“虚拟环境”](ch03.xhtml#pyvenv)。
- en: Second, `myScript_2.py` is the name of the Python file that contains the commands
    we want to execute.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，`myScript_2.py`是包含我们想要执行的命令的Python文件的名称。
- en: Third, `<` allow us to redirect `stdin` from the rhs to the file on the lhs^([1](ch06.xhtml#idm45127448988616)).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，`<`允许我们将`stdin`从rhs重定向到lhs上的文件^([1](ch06.xhtml#idm45127448988616))。
- en: 'Fourth, `"pg.csv"` is the `stdin`. You may recall that there are three standard
    *channels*, or *streams*, for command line functions. `stdin` for the *standard
    input*, `stdout` for the *standard output* and `stderr` for the `standard error`.
    Here, `stdin` is hardcoded. It’s a character string which corresponds to a file:
    `"pg.csv"`, which was exported in the previous command. Hard-coding should be
    avoided for the most part and we’re sure you can imagine many ways to make this
    dynamic. That’s not really our focus here; the point is to feed some input into
    a Python script.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第四，`"pg.csv"`是`stdin`。你可能记得命令行函数有三个标准*通道*或*流*，`stdin`用于*标准输入*，`stdout`用于*标准输出*，`stderr`用于*标准错误*。在这里，`stdin`是硬编码的。它是一个字符串，对应于一个文件：`"pg.csv"`，这个文件在前一个命令中被导出。在大多数情况下应避免硬编码，你可以想象很多使其动态化的方法。这不是我们这里关注的重点；重点是将一些输入传递到Python脚本中。
- en: Thus, we’re executing a Python script that takes `stdin` from within an R script,
    and that `stdin` in itself a product of the R script. Let’s take a look at the
    minimal components of this Python script.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们正在执行一个Python脚本，该脚本从R脚本中获取`stdin`，而`stdin`本身是R脚本的产物。让我们看看这个Python脚本的最小组件。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: First we need the `sys` module to handle `stdin` (`sys.stdin`). We import the
    file, represented by `sys.stdin` using pandas and after our Python script works
    it’s magic we export some other output using the `to_csv()` method.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要`sys`模块来处理`stdin`（`sys.stdin`）。我们使用pandas导入文件，用`to_csv()`方法在我们的Python脚本完成其工作后导出一些其他输出。
- en: There are a lot of things wrong with this method, and we’ll get to them soon.
    But the point is that it works, and sometimes, it’s exactly what you need. Working
    in a research laboratory I often had to provide results to colleagues quickly.
    I mean this literally, since very expensive cell cultures would die and a week’s
    worth of work would be wasted if the results were not ready. Pre-processing of
    proprietary raw data and access to a secure server prohibited my colleagues from
    executing automated R scripts. My solution was to first process the machine-generated
    proprietary data with software specialized for the task. Then I was able to use
    a Mac OS Automator service to execute a Perl script on that output, which was
    now my `stdin`. This Perl script then called an R script that produced a file
    of a plot with all the relevant information clearly displayed in the title. It
    wasn’t the most open or elegant solution, but it worked and I got my plots with
    one mouse click in about half a second without any extra web-sites or logins.
    Life was good, so what’s the problem?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有很多问题，我们很快就会解决它们。但关键是它起作用了，有时候这正是你所需要的。在研究实验室工作时，我经常需要快速向同事提供结果。我是说字面上的，因为非常昂贵的细胞培养物会死亡，如果结果还没有准备好，将浪费一周的工作。专有原始数据的预处理和访问安全服务器阻止了我的同事执行自动化的R脚本。我的解决方案是首先使用专门用于此任务的软件处理机器生成的专有数据。然后，我能够使用Mac
    OS Automator服务在该输出上执行Perl脚本，这是我的`stdin`。然后，这个Perl脚本调用一个R脚本，生成一个具有所有相关信息清晰显示在标题中的绘图文件。这并不是最开放或最优雅的解决方案，但它起作用了，我只需单击鼠标大约半秒钟就能得到我的绘图，而无需额外的网站或登录。生活很美好，那问题在哪里呢？
- en: Well, there are several problems. Let’s consider three.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，有几个问题。让我们考虑三个。
- en: First, in retrospect, I could have probably executed the entire workflow in
    R (excluding the proprietary pre-processing). It’s necessary to consider simplifying
    a workflow and having a good reason to use multiple languages. Deciding when and
    why to combine Python & R has come up throughout this book.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，回顾过去，我可能完全可以在R中执行整个工作流程（不包括专有的预处理）。必须考虑简化工作流程并有充分理由使用多种语言。在本书中，决定何时以及为何结合Python和R已经讨论过。
- en: Second, there are a lot of moving parts. We have several files and we’re even
    producing additional intermediate ones. This increases the chance for error and
    confusion. That’s not terrible, but we better take care to keep things organized.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，有很多移动的部分。我们有几个文件，甚至产生了额外的中间文件。这增加了出错和混乱的机会。这并不可怕，但我们最好注意保持事物有序。
- en: Third, in many cases, this workflow works well when we can export an R `data.frame`
    as a csv file, which `pandas` can easily import. For more complex data structures,
    you can export 1 or more R objects as an `RData` or `Rds` format file. The python
    `pyreadr` package provides functions to import these files and provide access
    to each object stored in a `dict`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，许多情况下，当我们可以将一个R `data.frame`导出为csv文件时，这个工作流程表现良好，而`pandas`可以轻松导入。对于更复杂的数据结构，您可以将1个或多个R对象导出为`RData`或`Rds`格式文件。Python的`pyreadr`包提供了导入这些文件并访问存储在`dict`中每个对象的函数。
- en: Cross-talk is great, but true interoperability smooths out the wrinkles in this
    process quite nicely. There are two widely-used frameworks, the choice of which
    to use will depend on which language is your starting point.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然交互性很好，但真正的互操作性会很好地解决这个过程中的问题。有两种广泛使用的框架，选择使用哪种取决于您的起始语言。
- en: Interoperability
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互操作性
- en: If you’re primarily using R and want access to Python, then the R package `reticulate`
    is the way to go. Conversely, if you’re primarily using Python and want access
    to R, then the Python module `rpy2` is the tool for you. We can summarize this
    in [Table 6-1](#ret_table) and [Table 6-2](#rpy2_table)^([2](ch06.xhtml#idm45127448806536)).
    In each table, read each line as a sentence beginning with the column headers.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您主要使用R并希望访问Python，则R包`reticulate`是正确的选择。相反，如果您主要使用Python并希望访问R，则Python模块`rpy2`是适合您的工具。我们可以在[表6-1](#ret_table)和[表6-2](#rpy2_table)^([2](ch06.xhtml#idm45127448806536))中总结这一点。在每个表中，将每行读作以列标题开头的句子。
- en: Table 6-1\. Interoperability granted by reticulate.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-1。由`reticulate`提供的互操作性。
- en: '| Access | Using command |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 访问 | 使用命令 |'
- en: '| --- | --- |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Python Functions | in R, `pd <- library(pandas)`; `pd$read_csv()` |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| Python 函数 | 在 R 中，`pd <- library(pandas)`; `pd$read_csv()` |'
- en: '| Python Objects | in R, `py$objName` |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| Python 对象 | 在 R 中，`py$objName` |'
- en: '| R Objects | in Python, `r.objName` in Python |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| R 对象 | 在 Python 中，`r.objName` in Python |'
- en: Table 6-2\. Interoperability granted by rpy2 when writing in Python.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-2\. 当使用 Python 编写时，rpy2 提供的互操作性。
- en: '| Access | Using command |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 访问 | 使用命令 |'
- en: '| --- | --- |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| R Functions | in Python, `import rpy2.robjects.lib.ggplot2 as ggplot2` |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| R 函数 | 在 Python 中，`import rpy2.robjects.lib.ggplot2 as ggplot2` |'
- en: '| R Packages | in Python, `r_cluster = importr(''cluster'')` |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| R 包 | 在 Python 中，`r_cluster = importr(''cluster'')` |'
- en: '| R Objects | in Python, `foo_py = robjects.r[''foo_r'']` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| R 对象 | 在 Python 中，`foo_py = robjects.r[''foo_r'']` |'
- en: The commands in [Table 6-1](#ret_table) and [Table 6-2](#rpy2_table) reveal
    how to access all variety of objects from one language directly from the other.
    In addition, we can also directly call functions. This is a real milestone since
    it relieves us of having to force one language to do tasks that it doesn’t excel
    at and means that we don’t need to reinvent the wheel, introducing redundancy
    between the languages. At the time of writing it was not possible to access R
    functions from within Python in `reticulate`. You may attempt to use `reticulate`
    for this task, but it would be easier to pass an object back to R and execute
    R commands natively.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Table 6-1](#ret_table) 和 [Table 6-2](#rpy2_table) 中的命令显示了如何直接从一种语言访问所有种类的对象到另一种语言。此外，我们还可以直接调用函数。这是一个真正的里程碑，因为它使我们免于强迫一种语言执行它不擅长的任务，并且意味着我们不需要在语言之间引入冗余，重复发明轮子。在撰写本文时，使用
    `reticulate` 无法从 Python 直接访问 R 函数。您可以尝试使用 `reticulate` 完成此任务，但将对象返回给 R 并本地执行 R
    命令会更容易。
- en: Up and running with reticulate
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 reticulate 快速上手
- en: '`reticulate` first appeared on CRAN in 2017, and has recently gained in popularity
    as it matured. This package is developed by RStudio, and is well-integrated into
    the RStudio IDE itself, which is pretty convenient. However, at the time of writing,
    there are some troublesome features (bugs?) that require some finesse (see the
    warning box [“State of reticulate”](#state_reticulate)). A good first step is
    to ensure you are using the latest public release of RStudio and the latest version
    of the `reticulate` package and any associated packages, such as `knitr`.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`reticulate` 首次出现在 CRAN 上是在 2017 年，并且随着它的成熟而日益流行。这个包由 RStudio 开发，并且很好地集成到了
    RStudio IDE 中，这非常方便。然而，在撰写本文时，存在一些需要精细处理的麻烦功能（或许是 bug？），这些需要注意（请参见警告框 [“State
    of reticulate”](#state_reticulate)）。一个很好的第一步是确保您正在使用最新的 RStudio 公开版本以及`reticulate`包和任何相关的包，如`knitr`。'
- en: State of `reticulate`
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`reticulate` 的状态'
- en: '`reticulate` is well-supported and stable enough to be used in production.
    Nonetheless, you may encounter issues depending on your system, and software versions.
    Since this tool combines technologies, it can also be difficult to debug, and
    documentation is still somewhat scarce. Stay up-to-date with new versions as they
    are released. If you encounter issues on your local machine, call up our [RStudio
    Cloud](https://rstudio.cloud/project/2534578) project.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`reticulate` 受到良好支持并且足够稳定，可以用于生产。尽管如此，根据您的系统和软件版本，您可能会遇到问题。由于此工具结合了多种技术，因此调试可能会困难，并且文档仍然有些匮乏。随着新版本的发布，请保持及时更新。如果在您的本地机器上遇到问题，请访问我们的
    [RStudio Cloud](https://rstudio.cloud/project/2534578) 项目。'
- en: In this section we’ll begin with two scripts, listed in [Table 6-3](#ret_table_start).
    You’ll find these in this chapter’s folder in the book’s [repository](https://github.com/moderndatadesign/PyR4MDS).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从两个脚本开始，列在 [Table 6-3](#ret_table_start) 中。您可以在本章的书籍 [存储库](https://github.com/moderndatadesign/PyR4MDS)
    中找到这些脚本。
- en: Table 6-3\. Up and running with reticulate.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-3\. 使用 reticulate 快速上手。
- en: '| File | Description |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 文件 | 描述 |'
- en: '| --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `0 - Setup.Rmd` | Setting up reticulate and virtual environments |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `0 - Setup.Rmd` | 设置 reticulate 和虚拟环境 |'
- en: '| `1 - Activate.R` | Activating a Python virtual environment |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `1 - Activate.R` | 激活 Python 虚拟环境 |'
- en: 'Let’s begin with the R script, `0 - Setup.R`. Make sure you’ve installed `reticulate`
    and have initialized it in your environment:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 R 脚本 `0 - Setup.R` 开始。确保您已安装了 `reticulate` 并在您的环境中初始化它：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: First, we need to specify which build of Python we’ll use. You can let R use
    your system default, or set the specific build of Python you want to use by going
    to `tools > Project options` and selecting the Python icon.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要指定使用哪个版本的 Python。您可以让 R 使用您的系统默认设置，或者通过转到`工具 > 项目选项`并选择 Python 图标来设置您想要使用的特定版本的
    Python。
- en: '![](Images/prds_0602.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/prds_0602.png)'
- en: Figure 6-2\. Selecting a specific Python version and build to use.
  id: totrans-52
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-2。选择要使用的特定Python版本和构建版本。
- en: 'Let’s check to see the version we’re using:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下我们正在使用的版本：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To be clear, we don’t need to use RStudio to set the Python version. This is
    just a convenience feature. We could have executed:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 清楚地说一下，我们不需要使用RStudio来设置Python版本。这只是一个方便的功能。我们可以执行：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that this function just makes a *suggestion* and doesn’t result in an error
    if the desired build is not found unless the `required` argument is set to `TRUE`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个函数只是一个*建议*，如果未找到所需的构建版本，则不会产生错误，除非将`required`参数设置为`TRUE`。
- en: 'Before we proceed, we’ll want to establish a virtual environment. If you’re
    on Windows you’ll have to use a `conda` environment, which we’ll get to in a minute.
    For everyone else, use the following command to create a virtual environment called
    `modern_data`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们将要建立一个虚拟环境。如果你在Windows上，你将不得不使用`conda`环境，我们将在一分钟内介绍它。对于其他人，请使用以下命令创建名为`modern_data`的虚拟环境：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Previously, when we used the `venv` package in Python, the virtual environment
    was stored as a hidden directory (typically called `.venv` in the project directory).
    So where are the Python virtual environments now? We can have a look with the
    following command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，当我们在Python中使用`venv`包时，虚拟环境存储在一个隐藏目录中（通常称为项目目录中的`.venv`）。那么现在Python虚拟环境在哪里？我们可以用以下命令来看一看：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'They are all stored in a hidden folder in the *root* directory. We can see
    all our virtual environment using the following command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都存储在根目录中的一个隐藏文件夹中。我们可以使用以下命令查看所有的虚拟环境：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The reticulate cheat sheet
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[Reticulate 速查表](https://raw.githubusercontent.com/rstudio/cheatsheets/master/reticulate.pdf)'
- en: As is the case for most popular data science packages, there is a cheat sheet
    available for `reticulate`. You can download it directly from [here](https://raw.githubusercontent.com/rstudio/cheatsheets/master/reticulate.pdf).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数流行的数据科学包一样，`reticulate`有一张速查表可用。你可以直接从[这里](https://raw.githubusercontent.com/rstudio/cheatsheets/master/reticulate.pdf)下载。
- en: This is a departure from what we saw with virtual environments in Python, where
    they were stored within the project directory. Nonetheless, it’s convenient, since
    we can easily reuse a good environment for many projects.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在Python中看到的虚拟环境存储在项目目录中的情况有所不同。尽管如此，这很方便，因为我们可以轻松地为许多项目重复使用一个好的环境。
- en: 'Note that to remove a virtual environment, we need to pass the path, as such:
    `virtualenv_remove("~/modern_data")`.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，要删除虚拟环境，我们需要传递路径，如下所示：`virtualenv_remove("~/modern_data")`。
- en: The next step is to install the appropriate packages.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是安装适当的包。
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Alternatively, you can use the tidyverse `purrr::map()` function to install
    many packages:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用`tidyverse`的`purrr::map()`函数来安装许多包：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you’re on Windows, use the following commands:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Windows上，请使用以下命令：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The final step is to activate our virtual environment. This seems to be an area
    under rapid development. Different error messages, or none at all are produced
    depending on your versions of `reticulate` and RStudio, making them harder to
    debug. From my experience, your safest bet is to (i) make sure all your R packages,
    as well as RStudio, are up to date, and (ii) restart R before activating your
    virtual environment. You can do this in the RStudio menu `Session > Restart R`,
    the keyboard shortcut `shift + cmd/ctrl + F10` or executing the command `.rs.restartR()`.
    You can also literally close and restart RStudio. This ensures that there is no
    Python build in active use and we can establish one from scratch. Thus, we have
    one R script for setup, where we create a virtual environment and install packages,
    and another with our actual analysis, where we load `reticulate` and activate
    our virtual environment.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是激活我们的虚拟环境。这似乎是一个快速发展的领域。根据你使用的`reticulate`和RStudio的版本，可能会产生不同的错误消息，或者根本没有错误消息，这使得调试变得更加困难。根据我的经验，你最安全的选择是：(i)
    确保所有的R包和RStudio都是最新的，以及 (ii) 在激活虚拟环境之前重新启动R。你可以在RStudio菜单中执行此操作`Session > Restart
    R`，键盘快捷键`shift + cmd/ctrl + F10`或执行命令`.rs.restartR()`。你也可以直接关闭并重新启动RStudio。这样可以确保没有活跃使用的Python构建，并且我们可以从头开始建立一个。因此，我们有一个用于设置的R脚本，我们在其中创建一个虚拟环境并安装包，以及另一个用于实际分析的脚本，我们在其中加载`reticulate`并激活我们的虚拟环境。
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And finally we can confirm which build we have using:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以确认我们正在使用哪个版本：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You should see the following output. Importantly, make sure that the path to
    your virtual environment is stated in the first line: `/.virtualenvs/modern_data/bin/python`.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出。重要的是确保你的虚拟环境路径在第一行中指定：`/.virtualenvs/modern_data/bin/python`。
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you see something like `/usr/local/bin/python3.8` then RStudio is still directed
    to use the Python version you defined at the beginning of the chapter and not
    a virtual environment. This may serve you well, but it is preferable to use a
    virtual environment.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到像`/usr/local/bin/python3.8`这样的东西，那么 RStudio 仍然指示使用你在本章开始时定义的 Python 版本，而不是虚拟环境。这可能对你有所帮助，但最好使用虚拟环境。
- en: Going deeper
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更深入了解
- en: At this point, we’ve created a virtual environment, installed some packages
    in it, restarted R and have activated the virtual environment. These step are
    covered in the the scripts `0 - Setup.R` and `1 - Activate.R`. For the rest of
    this section I’ll cover ways to pass information between R and Python, which I’ve
    summarized in [Table 6-1](#ret_table).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一个虚拟环境，在其中安装了一些包，重新启动了 R，并激活了虚拟环境。这些步骤在脚本`0 - Setup.R`和`1 - Activate.R`中有所涵盖。在本节的其余部分，我将介绍如何在
    R 和 Python 之间传递信息，我已在表6-1中进行了总结。
- en: Table 6-4\. Interoperability granted by reticulate.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-4。reticulate授予的互操作性。
- en: '| File | Description |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 文件 | 描述 |'
- en: '| --- | --- |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `2 - Passing objects.Rmd` | Pass objects between R and Python in an RMarkdown
    document |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `2 - Passing objects.Rmd` | 在 RMarkdown 文档中在 R 和 Python 之间传递对象 |'
- en: '| `3 - Using functions.Rmd` | Call Python in an RMarkdown document |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `3 - Using functions.Rmd` | 在 RMarkdown 文档中调用 Python |'
- en: '| `4 - Calling scripts.Rmd` | Call Python by sourcing a Python script |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `4 - Calling scripts.Rmd` | 通过源代码调用 Python 脚本 |'
- en: '| `5 - Interactive mode.R` | Call Python using a Python REPL console |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `5 - Interactive mode.R` | 使用 Python REPL 控制台调用 Python |'
- en: '| `6 - Interactive document.Rmd` | Call Python with dynamic input in an interactive
    document |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `6 - Interactive document.Rmd` | 在交互式文档中使用动态输入调用 Python |'
- en: Note
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Why “reticulate”? The reticulated python is a species of python found in Southeast
    Asia. They are the world’s longest snakes and longest reptiles. The species name,
    *Malayopython reticulatus*, is Latin meaning “net-like”, or reticulated, and is
    a reference to the complex colour pattern.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么叫“reticulate”？网纹蟒是一种生活在东南亚的蟒蛇。它们是世界上最长的蛇类和最长的爬行动物。物种名称 *Malayopython reticulatus*
    是拉丁文，意为“网状的”，或 reticulated，指的是其复杂的颜色图案。
- en: I’ll consider the scenarios in [Table 6-1](#ret_table) in the subsections below.
    To follow along with these examples, please ensure that you have followed the
    setup and activation instructions found in `0 - Setup.R` and `1 - Activate.R`
    (both in the book code [repository](https://github.com/moderndatadesign/PyR4MDS)).
    You’ll need to have the modern_data virtual environment and the above list of
    packages installed. If you’re using `miniconda`, be sure to use the correct command
    given in each file to activate your virtual environment.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在下面的小节中考虑表6-1中的情景。要跟随这些示例，请确保你已按照`0 - Setup.R`和`1 - Activate.R`中的设置和激活说明进行了设置（两者都在书籍代码[存储库](https://github.com/moderndatadesign/PyR4MDS)中）。你需要安装
    modern_data 虚拟环境和上述列出的包。如果你使用的是`miniconda`，请确保使用每个文件中给出的正确命令来激活你的虚拟环境。
- en: Pass objects between R and Python in an RMarkdown document
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 RMarkdown 文档中在 R 和 Python 之间传递对象
- en: 'The following commands can be found in the file `2 - Passing objects.Rmd`.
    To access an R object in python use the `r` object, and to access a Python in
    R, use the `py` object. Consider the following chunks found in an RMarkdown document:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 下列命令可在文件`2 - Passing objects.Rmd`中找到。要在 Python 中访问 R 对象，请使用`r`对象，要在 R 中访问 Python
    对象，请使用`py`对象。考虑下列在 RMarkdown 文档中找到的代码块：
- en: '[PRE16]{python}'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE16]{python}'
- en: a = 3.14
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: a = 3.14
- en: a
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: a
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]{r}'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE18]{r}'
- en: py$a
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: py$a
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The python object `a` is accessed in the R object `py` using the `$` notation.
    In the opposite direction:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`$`符号在 R 对象`py`中访问 Python 对象`a`。相反的方向：
- en: '[PRE20]{r}'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE20]{r}'
- en: b <- 42
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: b <- 42
- en: b
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: b
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]{python}'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE22]{python}'
- en: r.b
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: r.b
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In Python, call the `r` object and use `.` notation to access R objects by
    name. These are scalars, or simple vectors, but of course we can pass more complex
    items directly between the two languages. `reticulate` will take care of object
    conversion for us. Consider the following case:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，调用`r`对象并使用`.`符号按名称访问 R 对象。这些是标量，或简单向量，但当然我们可以直接在两种语言之间传递更复杂的项目。`reticulate`会为我们处理对象转换。考虑以下情况：
- en: '[PRE24]{r}'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE24]{r}'
- en: A build-in data frame
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个内置数据框
- en: head(PlantGrowth)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: head(PlantGrowth)
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]{python}'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE26]{python}'
- en: r.PlantGrowth.head()
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: r.PlantGrowth.head()
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: An R `data.frame` is accessed as a Python `pandas.DataFrame`. However, if you
    don’t have pandas installed you’ll see a `dict` object, a Python dictionary.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: R 的`data.frame`可以作为 Python 的`pandas.DataFrame`访问。但是，如果你没有安装 pandas，你会看到一个`dict`对象，即
    Python 字典。
- en: 'A Python `NumPy` `ndarray` will be converted to an R `matrix`^([3](ch06.xhtml#idm45127448026744)):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Python的`NumPy` `ndarray`将被转换为一个R的`matrix`^([3](ch06.xhtml#idm45127448026744))：
- en: '[PRE28]{python eval = TRUE}'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE28]{python eval = TRUE}'
- en: from sklearn.datasets import load_iris
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: from sklearn.datasets import load_iris
- en: iris = load_iris()
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: iris = load_iris()
- en: iris.data[:6]
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: iris.data[:6]
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A Python NumPy `ndarray` as an R `matrix`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 将Python的NumPy `ndarray`作为R的`matrix`：
- en: '[PRE30]{r eval = TRUE}'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE30]{r eval = TRUE}'
- en: head(py$iris$data)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: head(py$iris$data)
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Notice how the `.` notation in Python, `iris.data` is automatically accessible
    using the `$` notation in R: `py$iris$data`. This holds true for nested objects,
    methods and attributes, just as they would in Python,'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在Python中的`.`符号，`iris.data`可以使用`$`符号在R中自动访问：`py$iris$data`。对于嵌套对象、方法和属性，与Python中一样，
- en: Call Python in an RMarkdown document
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在RMarkdown文档中调用Python
- en: The following commands can be found in the file `3 - Using functions.Rmd`. We’ll
    continue to use the classic iris dataset that we accessed in Python in the previous
    section. Inside an RMarkdown document, we’ll access a Python function, which allows
    us to access the trained support vector machine classifier to predict classification
    on new values. This is a very naïve machine learning workflow and is not intended
    to produce a valuable model. The point is to demonstrate how to access a model
    from Python in R.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 文件`3 - Using functions.Rmd`中可以找到以下命令。我们将继续使用在前一节中在Python中访问的经典iris数据集。在RMarkdown文档内部，我们将访问一个Python函数，这使我们能够访问经过训练的支持向量机分类器，以预测新值的分类。这是一个非常朴素的机器学习工作流程，不打算生成有价值的模型。重点是演示如何在R中访问Python中的模型。
- en: 'The entire model configuration is defined here:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 整个模型配置在这里定义：
- en: '[PRE32]{python}'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE32]{python}'
- en: import modules
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: import modules
- en: from sklearn import datasets
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: from sklearn import datasets
- en: from sklearn.svm import SVC
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: from sklearn.svm import SVC
- en: 'load the data:'
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载数据：
- en: iris = datasets.load_iris()
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: iris = datasets.load_iris()
- en: Create an instance of the SVC, _Support Vector Classification_, class.
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建SVC（支持向量分类）类的一个实例。
- en: clf = SVC()
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: clf = SVC()
- en: Train the model by calling the fit method on the target data, using target names
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过在目标数据上调用fit方法来训练模型，使用目标名称
- en: clf.fit(iris.data, iris.target_names[iris.target])
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: clf.fit(iris.data, iris.target_names[iris.target])
- en: Predict the class of new values, here the first three
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预测新值的类别，这里是前三个
- en: clf.predict(iris.data[:3])
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: clf.predict(iris.data[:3])
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The method `clf.predict()` takes an `ndarray` as input and returns the named
    classification. To access this function in R, we can once again use the `py` object,
    as in `py$clf$predict()`. The `iris` dataset in R is a `data.frame`, where the
    5th column is the classification. We must convert this to a Python object using
    `r_to_py()`, in this case excluding the 5th column.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`clf.predict()`以`ndarray`作为输入，并返回命名分类。要在R中访问此函数，我们可以再次使用`py`对象，如`py$clf$predict()`。在R中，`iris`数据集是一个`data.frame`，其中第5列是分类。我们必须使用`r_to_py()`将其转换为Python对象，在这种情况下不包括第5列。
- en: '[PRE34]{r}'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE34]{r}'
- en: py$clf$predict(r_to_py(iris[-5]))
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: py$clf$predict(r_to_py(iris[-5]))
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Call Python by sourcing a Python script
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过调用Python脚本来调用Python
- en: 'The following commands can be found in the file `4 - Calling scripts.Rmd` and
    `4b - Calling scripts.R`. In this scenario we’ll execute an entire Python script
    and access all object and functions available therein. To do this we can call:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 文件`4 - Calling scripts.Rmd`和`4b - Calling scripts.R`中可以找到以下命令。在这种情况下，我们将执行整个Python脚本，并访问其中可用的所有对象和函数。为此，我们可以调用：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This works just as well in an RMarkdown document as in a script.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在RMarkdown文档中同样适用，正如在脚本中一样。
- en: 'Although this appears very similar to the previous section, there is a very
    important distinction. Python environments activated in this manner provide functions
    and objects directly. Thus we can call:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这与前一节看起来非常相似，但有一个非常重要的区别。以这种方式激活的Python环境直接提供函数和对象。因此，我们可以调用：
- en: '[PRE37]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is convenient, but also disconcerting. Not only has the syntax changes,
    i.e. no need for `py$`, but objects loaded in the R environment may conflict.
    Python objects will mask R objects, so be very careful about naming conflicts!
    You’ll notice that in `SVC_iris.py` we’ve renamed the Python `iris` dataset to
    `iris_py` to avoid problems when calling `iris` in R.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这很方便，但也让人不安。不仅语法改变了，即不再需要`py$`，而且在R环境中加载的对象可能会冲突。Python对象将掩盖R对象，因此在命名冲突方面一定要非常小心！您会注意到在`SVC_iris.py`中，我们已经将Python的`iris`数据集重命名为`iris_py`，以避免在R中调用`iris`时出现问题。
- en: Call Python using the REPL
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用REPL调用Python
- en: 'The following commands can be found in the file `5 - Interactive mode.R`. In
    this scenario we’ll start up a Python REPL console, using the following command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令可以在文件`5 - 交互模式.R`中找到。在这种情况下，我们将使用以下命令启动Python REPL控制台：
- en: '[PRE38]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-163
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: REPL stands for Read-eval-print loop. It is a common feature in many languages
    where the user can experiment in an interactive way, as opposed to writing a script
    that needs to be run.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: REPL代表读取-评估-打印循环。这是许多语言中的常见功能，用户可以以交互方式进行实验，而不是编写需要运行的脚本。
- en: 'This will allow you to directly execute Python commands in an interpreter.
    For example, try executing the commands we saw in the last example:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许你直接在解释器中执行Python命令。例如，尝试执行我们在上一个示例中看到的命令：
- en: '[PRE39]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We can exit the interpreter by executing the Python `exit` command.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行Python `exit`命令退出解释器。
- en: '[PRE40]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Just like we’ve seen before, the functions and objects in this Python environment
    can be accessed in R. This is truly interactive programming, since we’re executing
    commands directly in the console. Although we present this scenario for the sake
    of completeness, `repl_python()` is not really meant to be used in everyday practice.
    Actually, it’s what is called when an RMarkdown chunk uses a Python kernel. So
    although you can do this, be cautious! This presents a considerable problem in
    reproducibility and automation, but you may find it useful for quickly checking
    some commands.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前看到的那样，此Python环境中的函数和对象可以在R中访问。这确实是交互式编程，因为我们直接在控制台中执行命令。尽管出于完整性考虑我们提供了这种场景，但`repl_python()`实际上并不适合日常实践。实际上，当一个RMarkdown代码块使用Python内核时，会调用它。所以尽管你可以这样做，但要小心！这在可重复性和自动化方面存在相当大的问题，但你可能会发现它对快速检查某些命令很有用。
- en: Call Python with dynamic input in an interactive document
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在交互式文档中使用动态输入调用Python
- en: The following commands can be found in the file `6 - Interactive document.Rmd`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令可以在文件`6 - 交互式文档.Rmd`中找到。
- en: By now we’ve see all the core functionality of reticulate. Here we’ll go beyond
    that and show a very simple way to introduce interactivity using a `shiny` runtime
    in an RMarkdown document. To see the interactivity, make sure you have the `shiny`
    package installed and the you render the document to HTML. In RStudio, you can
    do this by clicking on the “Run Document” button when the file is open.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了reticulate的所有核心功能。在这里，我们将超越这一点，并展示一种非常简单的方法，使用RMarkdown文档中的`shiny`运行时引入互动性。要查看互动性，请确保安装了`shiny`包，并在打开文件时将文档渲染为HTML。在RStudio中，您可以通过点击“运行文档”按钮来执行此操作。
- en: 'First, in the header of our document we need to specify this new runtime environment:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在文档的标题中，我们需要指定这个新的运行时环境：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following Python code, which we’ve seen above, is executed in a Python
    chunk:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上面看到了以下Python代码，它在一个Python代码块中执行：
- en: '[PRE42]{python}'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE42]{python}'
- en: from sklearn import datasets
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: from sklearn import datasets
- en: from sklearn.svm import SVC
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: from sklearn.svm import SVC
- en: iris = datasets.load_iris()
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: iris = datasets.load_iris()
- en: clf = SVC()
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: clf = SVC()
- en: clf.fit(iris.data, iris.target_names[iris.target])
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: clf.fit(iris.data, iris.target_names[iris.target])
- en: '[PRE43]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the final two chunks we use functions from the `shiny` package to (i) produce
    sliders for each of the four features, and (ii) render the output from `py$clf$predict()`
    as HTML text, e.g.:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后两个代码块中，我们使用`shiny`包中的函数来：(i) 为四个特征中的每一个生成滑块，以及 (ii) 将`py$clf$predict()`的输出渲染为HTML文本，例如：
- en: '[PRE44]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: and… n
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 和… n
- en: '[PRE45]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Finally, we call the R object `prediction` as an in-line command, `r prediction`
    to print the result to the screen as a sentence.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将R对象`prediction`称为内联命令，`r prediction`以将结果作为句子打印到屏幕上。
- en: Final thoughts
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后的想法
- en: In this chapter we’ve covered the core components of the `reticulate` package,
    progressing from the essential setup to the basics and finally a simple yet powerful
    implementation that showcases the strengths R, Python and `reticulate`. Using
    this knowledge we’ll continue onto a larger case study in the last chapter.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了`reticulate`包的核心组件，从基本设置到基础知识，最后展示了一个简单而强大的实现，展示了R、Python和`reticulate`的优势。借助这些知识，我们将继续进行最后一章的更大案例研究。
- en: ^([1](ch06.xhtml#idm45127448988616-marker)) Recall that rhs is the *right-hand
    side* and lhs is the *left-hand side* when calling operators, in this case `<`
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch06.xhtml#idm45127448988616-marker)) 请回忆一下，在调用运算符时，rhs是*右手边*，lhs是*左手边*，在这种情况下是`<`
- en: ^([2](ch06.xhtml#idm45127448806536-marker)) In these tables we make a distinction
    between functions and objects. Recall that functions are themselves just objects,
    but we don’t need to worry about these details at the moment.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch06.xhtml#idm45127448806536-marker)) 在这些表格中，我们区分函数和对象。记住，函数本身也是对象，但我们目前不需要担心这些细节。
- en: ^([3](ch06.xhtml#idm45127448026744-marker)) Refer the Appendix A for a summary
    of data structures.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch06.xhtml#idm45127448026744-marker)) 参考附录 A 获取数据结构摘要。
