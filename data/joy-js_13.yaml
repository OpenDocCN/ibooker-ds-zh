- en: 9 Streams programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 流编程
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Reviewing the Iterator/Iterable protocols
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾迭代器/可迭代协议
- en: Using generators to represent iterable sequences of values over time
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用生成器表示随时间变化的值序列
- en: Reviewing the push/pull models as well as stream-based programming
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾推送/拉模型以及基于流的编程
- en: Using observables to create declarative, asynchronous push streams
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可观察者创建声明式、异步的推送流
- en: '*An* `Observable` *is a function that takes an observer and returns a function.
    Nothing more, nothing less. If you write a function that takes an observer and
    returns a function, is it async or sync? Neither. It’s a function.*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个* `Observable` *是一个接受观察者并返回函数的函数。没有更多，也没有更少。如果你写一个接受观察者并返回函数的函数，它是异步的还是同步的？都不是。它是一个函数。*'
- en: —Ben Lesh
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: ——本·莱斯
- en: This last chapter brings together the most important techniques covered in this
    book, including composable software as a whole, functional programming, mixin
    extensions, and reflective and asynchronous programming. Here, you’ll learn how
    they can all come together to support a computing model known as streams programming.
    Streams provide an abstraction that allows us to reuse a single computing model
    to process any type of data source regardless of its size. Think about building
    a real-time data application, such as a chat widget. You could set up long polling
    to pull messages from a server periodically, perhaps using a `Promise`-based API
    that you develop. Unfortunately, promises can deliver only a single value at a
    time, so you may receive one or two message objects (or potentially thousands
    if you have a chatty group), causing errors because you’ve exceeded the amount
    of data that can be transmitted in a single request. The best strategy is to set
    up a push solution; your application is notified when a new message is present
    and receives messages one at a time or in small batches. Programming with streams
    gives you the right level of abstraction to handle these use cases with a consistent
    API.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一章汇集了本书中涵盖的最重要的技术，包括整体的可组合软件、函数式编程、混入扩展以及反射和异步编程。在这里，你将了解它们如何结合在一起来支持一种称为流编程的计算模型。流提供了一种抽象，使我们能够重用单个计算模型来处理任何类型的数据源，无论其大小如何。想象一下构建一个实时数据应用，比如一个聊天小部件。你可以设置长轮询定期从服务器拉取消息，可能使用你开发的基于`Promise`的API。不幸的是，Promise一次只能传递一个值，所以你可能会收到一个或两个消息对象（或者如果你有一个健谈的群组，可能成千上万个），这会导致错误，因为你已经超过了单次请求中可以传输的数据量。最好的策略是设置一个推送解决方案；当有新消息时，你的应用会收到通知，并且一次或分批接收消息。使用流编程为你提供了适当的抽象级别，以一致的API处理这些用例。
- en: We’ve all been coding with streams in one way or another without realizing it.
    The flow of data between any piece of hardware, such as from memory to a processor
    or a disk drive, can be considered to be a stream. In fact, these input and output
    streams are used to read and write, respectively. Although this has been familiar
    for many years, we’ve never truly considered the state among the components that
    connect our applications—or that connect multiple applications—to be a stream.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都以一种或另一种方式在编码中使用流，而没有意识到这一点。任何硬件组件之间的数据流，例如从内存到处理器或磁盘驱动器，都可以被视为流。实际上，这些输入和输出流被用来分别读取和写入。尽管这已经熟悉很多年了，但我们从未真正考虑过连接我们的应用程序或连接多个应用程序的组件之间的状态是流。
- en: Think about the JavaScript code you write from day to day. For the most part,
    the typical way to deal with state is to use a pull model. Pull occurs when a
    client originates a request for some piece of data it needs. This process happens
    asynchronously when reading from a database or a file, or querying an API. It
    can also happen synchronously when calling a function or looping over some data
    structures in memory.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 想想你每天编写的JavaScript代码。大多数情况下，处理状态的传统方式是使用拉模型。拉发生在客户端发起对所需数据的请求时。这个过程在从数据库或文件读取或查询API时异步发生。它也可以在调用函数或遍历内存中的某些数据结构时同步发生。
- en: The other side of the coin is the push model. With push, the client code isn’t
    requesting data anymore; the server sends data to you. A push exchange may start
    with an initial pull, but after the client and server interfaces are in agreement,
    data can flow to clients as it becomes available—like new messages in your chat
    application. You may have heard of the publish/subscribe model, which is an architecture
    for these types of problems. A simple, useful analogy is to think of a callback
    function that gets called multiple times during a single request.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面是推送模型。在推送中，客户端代码不再请求数据；服务器将数据发送给你。推送交换可能从一个初始的拉取开始，但一旦客户端和服务器接口达成一致，数据就可以在可用时流向客户端——就像你的聊天应用中的新消息一样。你可能听说过发布/订阅模型，这是一种用于这些类型问题的架构。一个简单的、有用的类比是考虑一个在单个请求期间被多次调用的回调函数。
- en: Push technology can make your application much more snappy and reactive. I’ll
    come back to this notion of reactivity in section 9.3, because it’s an important
    one. Some push examples that come to mind are server-sent events (SSE), WebSockets,
    and the DOM’s event listeners. Imagine that instead of registering event handlers,
    you have to set up a timer to see when the state of a button changes to clicked.
    Or suppose that instead of getting notified when new message comes in, you need
    to explicitly click the refresh button to download new messages. We’re not in
    the ’90s anymore. When you know that data is available somewhere, you can issue
    a command to read it, but what happens when you don’t know? It’s awkward to set
    up polling for data that you don’t know will become available (if it ever does),
    not to mention inefficient.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 推送技术可以使你的应用程序更加敏捷和响应。我将在第9.3节中再次提到这个关于响应性的概念，因为它非常重要。一些想到的推送示例包括服务器发送事件（SSE）、WebSocket和DOM的事件监听器。想象一下，如果你不是注册事件处理器，而是需要设置一个定时器来查看按钮的状态何时变为点击状态。或者假设，如果你不是在新消息到来时收到通知，你需要明确地点击刷新按钮来下载新消息。我们不再是90年代了。当你知道数据在某处可用时，你可以发出一个命令来读取它，但当你不知道时会发生什么？为那些你不知道何时会变得可用的数据（如果它真的会）设置轮询是尴尬的，更不用说低效了。
- en: 'In chapters 7 and 8, I covered the concept of iterators. Here, I’ll continue
    talking about this subject from a new angle: how it’s used to represent streams
    of data combined with generator functions. Generators allow you to control the
    synchronous flow of data coming out of an iterable object (array, map, object,
    and so on). Also, you can emulate iterable data that can be computed on the fly.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7章和第8章中，我介绍了迭代器的概念。在这里，我将从新的角度继续讨论这个主题：它是如何与生成器函数结合来表示数据流的。生成器允许你控制从可迭代对象（数组、映射、对象等）输出的数据同步流。此外，你还可以模拟可以即时计算的可迭代数据。
- en: We’ll continue building on these lessons and switch gears to asynchronous iterables
    (async iterables, for short) and async generators used to compute sequences of
    values over time. Async iterables represent push streams and are an efficient,
    optimal, and memory-friendly way to read large amounts of asynchronous data (database,
    filesystem, or HTTP) piece by piece.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续构建这些课程，并转换到异步迭代器（简称async iterables）和异步生成器，它们用于计算随时间推移的值序列。异步迭代器代表推送流，是读取大量异步数据（数据库、文件系统或HTTP）的一种高效、最优和内存友好的方式，可以分块读取。
- en: 'Although a push paradigm can sometimes be hard to understand, you’ll see that
    using the same JavaScript constructs you’ve been learning about so far will make
    push more approachable. I think you’ll find the stream pattern to be quite interesting
    and enjoyable to code with, so I’ll end this chapter by looking at a new API that
    brings data-agnostic, reactive programming to JavaScript: `Observable`. Observables
    provide a single API surface to manage data flows independent of how data is generated
    and of its size.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然推送范式有时难以理解，但你会发现，使用你迄今为止一直在学习的相同的JavaScript结构会使推送更加容易接近。我认为你会发现流模式非常有趣，并且编写起来很愉快，所以我会以查看一个将数据无关、响应式编程引入JavaScript的新API来结束这一章：`Observable`。Observables提供了一个单一的API界面来管理数据流，独立于数据是如何生成的以及其大小。
- en: First, let’s talk about the Iterable and Iterator protocols in JavaScript.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们谈谈JavaScript中的可迭代（Iterable）和迭代器（Iterator）协议。
- en: 9.1 Iterables and Iterators
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 迭代器和迭代器
- en: Simply put, an iterable is an object whose elements (or properties) can be enumerated
    or looped over. As you learned in chapters 7 and 8, an iterable object defines
    its own `Symbol.iterator`, used to control how these elements are delivered to
    the caller. An iterator is the pattern or protocol that describes the structure
    of the iteration mechanism. Languages are free to define their own mechanisms
    for this purpose. In JavaScript, iteration is standardized. The following sections
    examine these protocols in detail.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，可迭代对象是一个其元素（或属性）可以被枚举或遍历的对象。正如你在第7章和第8章中学到的，可迭代对象定义了自己的 `Symbol.iterator`，用于控制这些元素如何传递给调用者。迭代器是描述迭代机制结构的模式或协议。语言可以自由定义自己的机制来实现这一点。在JavaScript中，迭代是标准化的。以下几节将详细检查这些协议。
- en: 9.1.1 Iterable protocol
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.1 可迭代协议
- en: The iterable protocol allows you to customize the iteration behavior of your
    objects when they appear inside a `for...of` construct or are used with the spread
    operator. JavaScript has built-in iterable objects such as `Array`, `Map`, and
    `Set`. Strings are also iterable as an individual array of characters.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 可迭代协议允许你在对象出现在 `for...of` 构造或与扩展运算符一起使用时自定义其迭代行为。JavaScript有内置的可迭代对象，如 `Array`、`Map`
    和 `Set`。字符串也可以作为一个字符数组进行迭代。
- en: Note Despite having similar names, `WeakSet` and `WeakMap` are not iterable
    (although they accept iterables in their constructors). In fact, neither extends
    from its non-weak counterpart (`Set` and `Map`, respectively). These APIs solve
    some interesting problems, but I don’t cover them in this book.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：尽管 `WeakSet` 和 `WeakMap` 有相似的名字，但它们不是可迭代的（尽管它们在构造函数中接受可迭代对象）。实际上，它们都没有扩展其非弱版本（`Set`
    和 `Map` 分别）。这些API解决了某些有趣的问题，但我在这本书中没有涉及它们。
- en: An iterable object (or any object from its prototype) must implement the function-valued
    `Symbol.iterator`. Inside this function, `this` refers to the object being iterated
    over, so that you have full access to its internal state and can decide what to
    send during the iteration process. An interesting fact about iterables is that
    `Symbol.iterator` can be a simple function or a generator function. (For more
    information on this topic, see section 9.2.)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可迭代对象（或其原型链上的任何对象）必须实现值函数 `Symbol.iterator`。在这个函数内部，`this` 指的是正在迭代的对象，这样你就可以完全访问其内部状态，并决定在迭代过程中发送什么内容。关于可迭代对象的一个有趣的事实是，`Symbol.iterator`
    可以是一个简单的函数或生成器函数。（关于这个主题的更多信息，请参阅第9.2节。）
- en: An iterable by itself doesn’t do much without its iterator.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 没有迭代器，可迭代本身并没有什么作用。
- en: 9.1.2 Iterator protocol
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.2 迭代器协议
- en: 'The iterator is the contract that’s presented to the language runtime when
    iteration behavior is required. JavaScript expects you to provide a `next` method
    to an object. This method returns objects with at least two properties:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是当需要迭代行为时向语言运行时提供的合约。JavaScript期望你向一个对象提供一个 `next` 方法。此方法返回至少包含两个属性的对象：
- en: '`done` (Boolean)—Indicates whether there are more elements. A value of `false`
    tells the JavaScript runtime to continue looping.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`done`（布尔值）——指示是否还有更多元素。`false` 的值告诉JavaScript运行时继续循环。'
- en: '`value` (any)—Contains the value bound to the loop variable. This value is
    ignored when `done` is equal to `true`, and the sequence terminates.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`（任何类型）——包含绑定到循环变量的值。当 `done` 等于 `true` 时，此值被忽略，序列终止。'
- en: If an object returned by `Symbol.iterator` does not abide by this contract,
    it’s considered to be malformed, and a `TypeError` occurs—JavaScript’s way of
    enforcing this particular protocol.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `Symbol.iterator` 返回的对象不遵守此协议，则被视为格式不正确，并引发 `TypeError`——这是JavaScript强制执行此特定协议的方式。
- en: 9.1.3 Examples
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.3 示例
- en: 'This section shows some examples of iterables, starting with our own `Block`
    class. As you know, this class accepts an array of data objects, which could be
    `Transaction` objects or any other type of object stored in the chain:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了可迭代对象的示例，从我们自己的 `Block` 类开始。正如你所知，这个类接受一个数据对象数组，这些对象可以是 `Transaction` 对象或存储在链上的任何其他类型的对象：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we created a block with a list of transactions, enumerating with `for...of`
    hooks into the special symbol to deliver each transaction:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建了一个包含交易列表的块，使用 `for...of` 枚举时，会钩入特殊符号以传递每个交易：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'All the main model objects of our application (`Blockchain`, `Block`, and `Transaction`)
    are iterable. This fact made it simple to create a generic validation method in
    the `HasValidation` mixin, which extends all these objects with the same interface.
    In chapter 5, the algorithm used APIs such as `flatMap` and `reduce`, but it created
    additional arrays as the validation logic flowed through the elements of the blockchain.
    Iterators loop over structure that’s already in memory. Also, we don’t have to
    reduce over all the elements to find out whether a failure occurred. When we find
    the first failure, we can break out of the algorithm early. Look at this snippet
    of code once more:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的所有主要模型对象（`Blockchain`、`Block` 和 `Transaction`）都是可迭代的。这个事实使得在 `HasValidation`
    混合中创建一个通用验证方法变得简单，该混合扩展了所有这些对象以具有相同的接口。在第 5 章中，使用的算法包括 `flatMap` 和 `reduce`，但它创建了额外的数组，因为验证逻辑流经区块链的元素。迭代器遍历已经存在于内存中的结构。而且，我们不必遍历所有元素来找出是否发生了失败。当我们找到第一个失败时，我们可以提前退出算法。再次查看以下代码片段：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This implementation relies on model objects implementing `Symbol.iterator`.
    In our case, the logic was simple, as the objects delegated to their internal
    data structure’s iterator. To see how the protocols work, let’s implement a random-number
    generator by using the iterator schema, as shown in the next listing.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现依赖于模型对象实现 `Symbol.iterator`。在我们的例子中，逻辑很简单，因为对象委托给其内部数据结构的迭代器。为了了解协议是如何工作的，让我们通过迭代器模式实现一个随机数生成器，如下一个列表所示。
- en: Listing 9.1 Random-number generator using an iterator
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.1 使用迭代器的随机数生成器
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Internal helper function to compute the next random integer
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 计算下一个随机整数的内部辅助函数
- en: ❷ Creates a sized array and fills it with random numbers
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个有大小数组和填充随机数
- en: ❸ Signals the end of the sequence
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 表示序列的结束
- en: ❹ Signals that there are more numbers to enumerate
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 表示还有更多数字要枚举
- en: ❺ Produces different numbers each time
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 每次产生不同的数字
- en: Notice that the object returned by `randomNumberIterator` is an object that
    conforms to the iterator schema (as you can tell by the declaration of `next`),
    but it’s not itself an iterable. To make it one, we can add `Symbol.iterator`
    in the next listing.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`randomNumberIterator` 返回的对象符合迭代器模式（如通过 `next` 的声明可以看出），但它本身并不是可迭代的。为了使其成为可迭代的，我们可以在下一个列表中添加
    `Symbol.iterator`。
- en: Listing 9.2 Making an object iterable with `@@iterator`
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.2 使用 `@@iterator` 使对象可迭代
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Because the object already implements next, it’s enough to return itself,
    making it both an iterator and an iterable.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 因为对象已经实现了 next 方法，所以只需返回自身，使其既是迭代器又是可迭代对象。
- en: 'Now you can benefit from the seamless integration with `for...of`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以从与 `for...of` 的无缝集成中受益：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This technique is powerful because the iterator protocol is data-agnostic; you
    can use it to implement any kind of iteration. You can represent directory traversals,
    graph/tree data structures, dictionaries, or any custom collection object with
    the simplicity of a `for...of`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术非常强大，因为迭代器协议是无数据相关的；你可以用它来实现任何类型的迭代。你可以用 `for...of` 的简单性来表示目录遍历、图/树数据结构、字典或任何自定义集合对象。
- en: 'The iterable/iterator duo is ubiquitous in JavaScript, controlling how objects
    behave with the spread operator:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 可迭代/迭代器对在 JavaScript 中无处不在，控制着对象如何与扩展运算符一起使用：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Native, built-in types are also iterables. The following listing shows that
    strings behave the same way for arrays, maps, and sets. (You get the idea.)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 原生、内置类型也是可迭代的。以下列表显示字符串在数组、映射和集合中表现相同。（你明白了。）
- en: Listing 9.3 Strings implementing `@@iterator`
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.3 实现 `@@iterator` 的字符串
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Logs all 17 characters to the console
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将所有 17 个字符记录到控制台
- en: 'Now, let’s be honest: you’ve probably never heard of a random-number iterator,
    but you have heard of a random-number generator. Is there a difference? You will
    find out in section 9.2, which covers generators.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们说实话：你可能从未听说过随机数迭代器，但你听说过随机数生成器。它们之间有区别吗？你将在第 9.2 节中找到答案，该节涵盖了生成器。
- en: 9.2 Generators
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 生成器
- en: 'A generator is a special type of function. Normally, when a function returns,
    the language runtime pops that function off the current stack frame, freeing any
    storage allocated for its local context. Generator functions work the same way
    but have a slight twist: it seems as though its context sticks and resumes to
    return more values. In this section, we’ll review what generator functions are,
    how to use them to create iterables that can send new values from thin air, and
    how to use them to create async iterables.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器是一种特殊的函数类型。通常，当函数返回时，语言运行时会将该函数从当前栈帧中弹出，释放为其局部上下文分配的任何存储。生成器函数以相同的方式工作，但有一个细微的区别：它的上下文似乎会保留并恢复以返回更多值。在本节中，我们将回顾生成器函数是什么，如何使用它们创建可以从空中发送新值的可迭代对象，以及如何使用它们创建异步可迭代对象。
- en: 9.2.1 To return or to yield
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.1 返回或`yield`
- en: A generator is a factory function of iterators. First, you can define a generator
    function by placing an asterisk (`*`) after the `function` keyword
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器是一个迭代器的工厂函数。首先，你可以通过在 `function` 关键字后放置一个星号 (`*`) 来定义一个生成器函数
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'or before a method name:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 或者在一个方法名之前：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'These functions aren’t too useful, but are useful enough to show that generators
    look like any regular functions. So what’s with the special syntax? There’s a
    twist in the return value. Run this function to see what you get:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数并不太有用，但足以展示生成器看起来像任何常规函数。那么特殊语法是什么呢？返回值中有一个转折。运行这个函数看看你会得到什么：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, that special syntax augments the return value with an object
    called `Generator`, not a string, as the normal function would have. Syntactically,
    this process is similar to how an `async` function augments (or wraps) the value
    in a `Promise`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个特殊语法通过一个名为 `Generator` 的对象增强了返回值，而不是像常规函数那样是一个字符串。从语法上讲，这个过程与 `async`
    函数增强（或包装）值在 `Promise` 中的方式类似。
- en: 'Like the simple `randomNumberIterator` example, `Generator` is itself an iterable
    and an iterator; it implements both protocols. Therefore, to extract its value,
    we need to call `next`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 就像简单的 `randomNumberIterator` 示例一样，`Generator` 本身就是一个可迭代对象和一个迭代器；它实现了这两个协议。因此，为了提取其值，我们需要调用
    `next`：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now you can recognize the shape of the iterator protocol. Simply using an iterator
    of one value (`done`: `true`) is not that interesting, however. The `function*`
    syntax is there so that you can produce many values, via a process called yielding.
    Consider this variation:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，你可以识别迭代器协议的形状了。然而，仅仅使用一个只包含一个值（`done`: `true`）的迭代器并不那么有趣。`function*` 语法存在是为了你可以通过一个称为`yield`的过程产生多个值。考虑这个变体：'
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note Currently, there’s no support for generator functions using lambda syntax.
    This lack of support may seem to be a flaw in the design, but it’s not: lambda
    expressions are really meant to be simple expressions, and most are one-liners.
    It’s rare to have generator functions be that simple. There is, however, a proposal
    to include support for generator arrow functions: [http://mng.bz/yYWq](http://mng.bz/yYWq).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 目前，没有对使用 lambda 语法生成器函数的支持。这种不支持可能看起来是设计上的缺陷，但事实并非如此：lambda 表达式实际上意味着是简单的表达式，大多数都是一行代码。生成器函数如此简单的情况很少见。然而，有一个提议要包括对生成器箭头函数的支持：[http://mng.bz/yYWq](http://mng.bz/yYWq)。
- en: 'And, of course, because `Generator` implements `Symbol.iterator`, you can stick
    it inside a `for...of` expression:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，因为 `Generator` 实现了 `Symbol.iterator`，你可以将其放入一个 `for...of` 表达式中：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In sum, a generator is nothing more than a simple way to create an iterator.
    Generators and iterators work seamlessly. The code looks like it’s invoking the
    same function many times and somehow resuming where it left off, but it’s only
    a function. Behind the scenes, you’re consuming the iterable object that the function
    returns, and `yield` pushes new values into the iterator.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，生成器不过是一种创建迭代器的简单方法。生成器和迭代器无缝工作。代码看起来像是在多次调用同一个函数，并且以某种方式从上次停止的地方继续，但实际上它只是一个函数。幕后，你正在消耗函数返回的可迭代对象，而
    `yield` 将新值推入迭代器。
- en: 9.2.2 Creating iterable objects
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.2 创建可迭代对象
- en: In this section, you’ll see how to integrate iterables to enhance the domain
    model of the blockchain application. You can add a generator helper function to
    `Blockchain` that can emit as many fully configured empty blocks as you want,
    for example. You can use this function to create chains of any size and perhaps
    use them for testing and running simulations.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将看到如何将可迭代对象集成到区块链应用程序的领域模型中。例如，你可以向 `Blockchain` 添加一个生成器辅助函数，它可以发出你想要的任何数量的完全配置的空块。你可以使用这个函数来创建任何大小的链，也许可以用它们进行测试和运行模拟。
- en: The next listing defines a simple `newBlock` generator. The `Blockchain` class
    is a bit complex at this point, so I’ll show only the pertinent bits.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表定义了一个简单的 `newBlock` 生成器。在这个阶段，`Blockchain` 类有些复杂，所以我只会展示相关的部分。
- en: Listing 9.4 Custom generator function
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.4 自定义生成器函数
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Uses the generator syntax on a function method
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在函数方法上使用生成器语法
- en: ❷ Looks like an infinite loop but is not. The generator function is able to
    “pause” its execution on yield, so the runtime doesn’t keep executing infinitely.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 看起来像无限循环但实际上不是。生成器函数能够在 `yield` 上“暂停”其执行，因此运行时不会无限执行。
- en: ❸ Pushes a new block to the chain and returns it
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将新块推送到链中并返回它
- en: The caller code calls `newBlock` 20 times to produce 20 new blocks, making the
    total height of the chain 21 (remember to count the first-ever genesis block),
    as shown in the following listing.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者代码调用 `newBlock` 20次以生成20个新块，使得链的总高度达到21（记得计算第一个创世块），如下所示。
- en: Listing 9.5 Using generators to create an arbitrary amount of new blocks
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.5 使用生成器创建任意数量的新块
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Stops after creating 20 blocks
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建20个块后停止
- en: ❷ 20 new blocks plus genesis = 21
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 20个新块加上创世块共21个
- en: 'Furthermore, the frictionless integration between generators and iterators
    makes using the spread operator and its counterpart destructuring assignment a
    terse, idiomatic way to read properties from any custom object. We can implement
    naive pattern-matching expressions on algebraic data types (ADTs) such as `Validation`,
    implemented in chapter 5\. First, let’s make `Validation` iterable and use generators
    to return its `Failure` and `Success` branches, respectively. This ADT is biased
    to the right, so the `Success` branch results from the second call to `yield`;
    otherwise, you can reverse this order. `Symbol.iterator` is implemented like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，生成器和迭代器之间的无缝集成使得使用扩展运算符及其对应的结构化赋值法成为从任何自定义对象中读取属性的一种简洁、惯用的方式。我们可以在第5章中实现的代数数据类型（ADT）如
    `Validation` 上实现原始的模式匹配表达式。首先，让我们使 `Validation` 可迭代，并使用生成器分别返回其 `Failure` 和 `Success`
    分支。这个ADT倾向于右侧，因此 `Success` 分支来自对 `yield` 的第二次调用；否则，你可以反转这个顺序。`Symbol.iterator`
    的实现如下：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Choice ADTs, such as `Validation`, can activate only one branch at a time and
    omit the other. Those destructuring assignment statements look like the next listing.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 选择ADT，如 `Validation`，一次只能激活一个分支并省略其他分支。那些结构化赋值语句看起来像下一个列表。
- en: Listing 9.6 Using destructuring assignment to extract success and error states
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.6 使用结构化赋值提取成功和错误状态
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Destructuring assignment that ignores the left result
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 忽略左侧结果的解构赋值
- en: ❷ Destructuring assignment that ignores the right result
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 忽略右侧结果的解构赋值
- en: 'Consider some simple use cases for both branches. Suppose that you’re calling
    some validation function. For the `Failure` case, you could use destructuring
    with default values as an alternative to calling `left.getOrElse(5``)`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这两个分支的一些简单用例。假设你正在调用某个验证函数。对于 `Failure` 情况，你可以使用带有默认值的解构赋值作为调用 `left.getOrElse(5)`
    的替代方案：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, iterators and generators (together with symbols) unlock idiomatic
    coding patterns. When you need to control how an object emits its own properties,
    these features make your code much more expressive and simpler to read.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，迭代器和生成器（连同符号）解锁了惯用的编码模式。当你需要控制对象如何发出其自己的属性时，这些功能使你的代码更具表现力和易于阅读。
- en: As JavaScript supports async iterables by making `next` return promises, it
    also supports async generators, as we’ll discuss in the next section.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript通过使 `next` 返回承诺来支持异步迭代器，它也支持异步生成器，我们将在下一节讨论。
- en: 9.2.3 Async generators
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.3 异步生成器
- en: An async generator is like a normal generator, except that instead of yielding
    values, it yields promises that resolve asynchronously. Hence, an async generator
    is useful for working with `Promise`-based APIs that allow you to read data asynchronously
    in chunks, such as the `fetch` API in browser (which is a mixin, by the way) or
    the Node.js built-in “stream” library. In the next example, you’ll see the difference
    between working with a normal async function and an async generator function.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 异步生成器就像一个普通生成器，除了它不会产生值，而是产生异步解决的承诺。因此，异步生成器对于与基于 `Promise` 的API一起工作非常有用，这些API允许你以块的形式异步读取数据，例如浏览器中的
    `fetch` API（顺便说一下，这是一个混合型）或Node.js内置的“流”库。在下一个示例中，你将看到使用普通异步函数和使用异步生成器函数之间的区别。
- en: 'To obtain an async generator, combine all the keywords we’ve covered in this
    chapter into a single function signature:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得异步生成器，将本章中涵盖的所有关键字组合成一个单独的函数签名：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The results returned from the generator are promises, so you need to use `for`
    `await ...of` syntax to consume it. The next listing shows a function that uses
    async iteration.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器返回的结果是承诺，所以你需要使用`for` `await ...of`语法来消费它。下一条列表显示了一个使用异步迭代的函数。
- en: Listing 9.7 Using async iteration to count the blocks in a file
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.7 使用异步迭代来计数文件中的区块
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ dataStream is an async iterable object, which means that every chunk of data
    is a value in the shape of the iterator protocol, wrapped by a promise.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ dataStream是一个异步可迭代对象，这意味着每个数据块都是一个迭代协议形状的值，由承诺包装。
- en: This function returns a count of the blocks read from a file. A more helpful,
    useful function would return the block objects themselves so that you could do
    much more than count. Maybe you could validate the entire collection of blocks.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数返回从文件中读取的区块数量。一个更有帮助、更有用的函数会返回区块对象本身，这样你就可以做更多不仅仅是计数的事情。也许你可以验证整个区块集合。
- en: The following listing shows a slightly refactored version that removes the counting
    bits. Also, it uses a generator that yields each JSON object describing each block.
    Let’s call this function `generateBlocksFromFile`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了稍微重构后的版本，去除了计数部分。它还使用了一个生成器，它产生每个描述区块的JSON对象。让我们称这个函数为`generateBlocksFromFile`。
- en: Listing 9.8 Async generator that sends blocks read from a file
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.8 异步生成器，发送从文件中读取的区块
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ async function* creates an async iterator.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ async function*创建一个异步迭代器。
- en: ❷ Yields all parsed blocks as objects
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 产生所有解析的区块作为对象
- en: Now the counting logic becomes extremely trivial, as the next listing shows.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在计数逻辑变得极其简单，如下一条列表所示。
- en: Listing 9.9 Using `generateBlocksFromFile` as an async iterator
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.9 使用`generateBlocksFromFile`作为异步迭代器
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Each call to the generator pulls out a new block object from the file stream.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 每次调用生成器都会从文件流中提取一个新的区块对象。
- en: Again, the beauty of this change is that we can do much more than count; we
    can also validate each block as it’s being generated. This process is efficient
    because we don’t have to read the entire file at the same time, but process it
    as a moving window of data. Working with data this way is known as a stream.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这种变化的优点在于我们不仅能计数，还可以在生成过程中验证每个区块。这个过程是高效的，因为我们不需要一次性读取整个文件，而是将其作为移动的数据窗口进行处理。以这种方式处理数据被称为流。
- en: Suppose now that we want to use this function to validate all the blocks in
    the chain. `Blockchain` creates its own genesis block upon construction, so the
    first thing we’ll do is skip the first block that comes in. Next, we’ll convert
    the JSON object representation of a block to a `Block` object that’s added to
    a chain; this process is called hydration. The validation logic checks whether
    a block is positioned properly in a chain. Finally, it calls `validate` mixed
    from `HasValidation`. The test file I use in the repository (blocks.txt) has three
    blocks, so we’ll be validating only the remaining two. All the logic in the next
    listing is shown in figure 9.1.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 假设现在我们想使用这个函数来验证链中的所有区块。`Blockchain`在构建时会创建自己的创世区块，所以我们将首先跳过第一个到达的区块。接下来，我们将区块的JSON对象表示转换为添加到链中的`Block`对象；这个过程称为活化。验证逻辑检查区块是否在链中正确定位。最后，它调用从`HasValidation`混合的`validate`。我在仓库中使用的测试文件（blocks.txt）有三个区块，所以我们将只验证剩下的两个。下一条列表中的所有逻辑都在图9.1中展示。
- en: Listing 9.10 Validating a stream of blocks generated from a file
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.10 验证从文件生成的区块流
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Validation of each block assumes that the blocks are part of a chain.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 每个区块的验证假设这些区块是链的一部分。
- en: ❷ Skips the first block in the test file because it’s a genesis block from a
    different chain instance
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 跳过测试文件中的第一个区块，因为它来自不同的链实例的创世区块
- en: ❸ Blocks need to be pushed into a chain for validation.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 区块需要被推入链中进行验证。
- en: ❹ Validates each block by using HasValidation#validate
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用HasValidation#validate验证每个区块
- en: The diagram in figure 9.1 captures this flow at a high level. As you can see,
    two generator functions are at work. The first function calls `fs.createReadStream`,
    and the second function calls `generateBlocksFromFile`, which uses the first function
    to deliver its own data.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1中的图示以高层次捕捉了这一流程。如图所示，有两个生成器函数正在工作。第一个函数调用`fs.createReadStream`，第二个函数调用`generateBlocksFromFile`，它使用第一个函数来传递自己的数据。
- en: '![](../Images/9-1.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9-1.png)'
- en: Figure 9.1 The two generator functions. One reads a file and yields binary chunks
    of data. The other processes each raw block, creates `Block` objects from them,
    validates each one, and tallies the result.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 两个生成器函数。一个读取文件并产生数据块。另一个处理每个原始块，从它们中创建`Block`对象，验证每个对象，并统计结果。
- en: In this section, we continued to build on the lessons of chapter 8 with more
    asynchronous capabilities. We discussed how to use the (async) iterator protocol,
    symbols, and generator functions to create iterable objects. These objects can
    enumerate their state upon request when they become the subject of a simple `for`
    loop.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们继续在第八章的基础上增加更多异步功能。我们讨论了如何使用（async）迭代器协议、符号和生成器函数来创建可迭代对象。这些对象在请求时可以枚举其状态，当它们成为简单`for`循环的主题时。
- en: 'Note It’s worth mentioning that we haven’t discussed other use cases involving
    generators, such as pushing values into generators and linking generator functions.
    Generators are functions, so you could return a generator from another or accept
    a generator as an argument. These techniques can be used to solve a complex class
    of problems that are beyond the scope of this book. Check this link to find out
    about these other use cases: [http://mng.bz/j45p](http://mng.bz/j45p).'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：值得提到的是，我们还没有讨论涉及生成器的其他用例，例如将值推送到生成器或将生成器函数作为参数。生成器是函数，因此你可以从一个函数返回一个生成器或接受一个生成器作为参数。这些技术可以用来解决超出本书范围的一些复杂问题。查看此链接以了解这些其他用例：[http://mng.bz/j45p](http://mng.bz/j45p)。
- en: Async generator functions can yield values asynchronously, like emitting events.
    When an event source sends lots of values in a sequence, this sequence is also
    called a stream.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 异步生成器函数可以异步产生值，就像发射事件一样。当一个事件源按顺序发送大量值时，这个序列也被称为流。
- en: 9.3 Working with data streams
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 使用数据流
- en: What do objects of `String`, `Array`, `Map`, and a sequence of WebSockets events
    have in common? In a typical programming task, not much. When we’re talking about
    a stream of data, at a fundamental level, however, these types of objects can
    be treated the same way. In fact, this consistent programming model that allows
    you to work across data sources makes streams necessary. Some real-world examples
    in which streams are compelling include
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`、`Array`、`Map`和WebSocket事件序列的对象有什么共同之处？在典型的编程任务中，并不多。然而，当我们谈论数据流时，在根本层面上，这些类型的对象可以以相同的方式处理。事实上，这种一致的编程模型允许你在数据源之间工作，使得流变得必要。一些现实世界的例子，其中流非常有用包括'
- en: Interacting with multiple asynchronous data sources (REST APIs, WebSockets,
    storage, DOM events, and others) as a single flow
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多个异步数据源（REST API、WebSockets、存储、DOM事件等）作为一个单一流程进行交互
- en: Creating a pipeline that applies different transformations to the data passing
    through it
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个管道，对通过它的数据进行不同的转换
- en: Creating a broadcast channel in which multiple components can be notified of
    a particular event
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个广播频道，其中多个组件可以通知特定事件
- en: In situations like these, in which every single interaction is asynchronous
    and part of the same flow, using async generators to wrap every action is a daunting
    task, and the callback pattern won’t scale well to this level of complexity.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，每个交互都是异步的，并且是同一流程的一部分，使用异步生成器来包装每个动作是一项艰巨的任务，回调模式也无法很好地扩展到这种复杂程度。
- en: In this section, we’ll learn the basics of streams and the APIs needed to represent
    them. JavaScript’s `Observable` API provides the necessary interfaces to build
    great reactive abstractions to process data from any push-based data sources.
    By the end of this section, you’ll know how to transform an object into a stream
    so that you can manage its data through chains of `Observable` objects. You’ll
    understand how any complex data source can be abstracted and processed as though
    it were a simple collection of events.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习流的基本知识以及表示它们的API。JavaScript的`Observable` API提供了必要的接口来构建处理来自任何基于推送的数据源的优秀反应抽象。在本节结束时，你将了解如何将对象转换为流，以便通过`Observable`对象的链来管理其数据。你将理解任何复杂的数据源都可以被抽象并处理，就像它是一个简单的事件集合一样。
- en: 9.3.1 What is a stream?
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.1 什么是流？
- en: To understand this concept, you must first understand how data arrives or is
    consumed by an application. Generally speaking, data is push or pull. In both
    cases, you have a producer (that creates the data) and a consumer (that subscribes
    to that data).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这个概念，你必须首先了解数据是如何到达或被应用程序消费的。一般来说，数据是推或拉。在这两种情况下，你都有一个生产者（创建数据）和一个消费者（订阅该数据）。
- en: In a pull system, the producer, which could be as simple as a function, doesn’t
    know how or when data is needed. So the consumer must pull from (or call) the
    producer. On the other hand, in a push system, the producer is the one in control
    of when an event is sent (a button was clicked, for example), and the consumer
    (subscriber) has no idea when it will receive said event. We say that the consumer
    reacts to the event (figure 9.2).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在拉系统中，生产者（可能只是一个函数）不知道何时或如何需要数据。因此，消费者必须从（或调用）生产者那里拉取。另一方面，在推系统中，生产者控制事件发送的时间（例如，点击按钮），而消费者（订阅者）不知道何时会收到该事件。我们说消费者是对事件做出反应（图9.2）。
- en: '![](../Images/9-2.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图9-2](../Images/9-2.png)'
- en: Figure 9.2 The difference between pull and push. With pull, the consumer must
    always initiate a request for data. With push, when the consumer subscribes, the
    producer sends data as it becomes available, stopping when the consumer unsubscribes
    or when there’s no more data to send.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 拉和推的区别。在拉模式下，消费者必须始终主动发起数据请求。在推模式下，当消费者订阅后，生产者会在数据可用时发送数据，直到消费者取消订阅或没有更多数据可发送。
- en: Table 9.1 summarizes pull, push, and the JavaScript features typically used
    in those cases.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.1总结了拉、推以及在这些情况下通常使用的JavaScript特性。
- en: Table 9.1 JavaScript features to handle push and pull data
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.1 处理推和拉数据的JavaScript特性
- en: '|  | Single | Multiple |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '|  | 单个 | 多个 |'
- en: '| Pull | Function | `Symbol.iterator` |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 拉取 | 函数 | `Symbol.iterator` |'
- en: '| Push | `Promise` | `Symbol.asyncIterator` &#124; stream |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 推送 | `Promise` | `Symbol.asyncIterator` | 流 |'
- en: The pull techniques in table 9.1 are simple to understand. Pull happens when
    a function is invoked or an iterator’s `next` is called many times. A simple push
    scenario, by contrast, occurs when asynchronous values are represented with a
    `Promise` object. Here, the promise (the producer) controls when the event will
    be emitted, abstracting this logic from a consumer. The consumer becomes the handler
    function passed to next. We can say that the function subscribes to the promise.
    If a promise sets a timeout function to three seconds to resolve, for example,
    its value is emitted three seconds from the last event handled by the event loop.
    The producer knows and is in control of emitting this value.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.1中的拉技术简单易懂。拉发生在函数被调用或迭代器的`next`被多次调用时。相比之下，一个简单的推场景发生在异步值用`Promise`对象表示时。在这里，承诺（生产者）控制事件何时被发射，将此逻辑从消费者抽象出来。消费者变成了传递给`next`的处理函数。我们可以说该函数订阅了承诺。例如，如果承诺设置了一个三秒的定时器来解析，那么它的值将在事件循环处理最后一个事件后的三秒被发射。生产者知道并控制发射这个值。
- en: 'In table 9.1, a promise represents a single push, whereas an async generator
    can emit multiple values with different time functions. Promises and async generators
    are in full control of the rate at which these events will be emitted. The `for`
    `await...of` loop acts as a permanent subscription to both of these data sources
    behind the scenes. You can imagine the async generator as being the producer,
    which will emit its values at its own convenience, and the async iterator as being
    the consumer. Recall how listing 9.8 sets up a data stream:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在表9.1中，一个承诺（promise）代表一个单独的推（push），而异步生成器（async generator）可以使用不同的时间函数发射多个值。承诺和异步生成器完全控制这些事件发射的速率。`for`
    `await...of` 循环在幕后作为这两个数据源的永久订阅。你可以想象异步生成器作为生产者，将在其方便的时候发射其值，而异步迭代器作为消费者。回想一下列表9.8是如何设置数据流的：
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Later, the code consumes that data stream, using `for` `await...of`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，代码使用`for` `await...of`来消费这个数据流。
- en: Now let’s raise the level of abstraction with streams. Streams solve the same
    problem, but in a way that makes it easier to reason about. A stream is a sequence
    of one or infinitely many pieces of data, called events. In this context, the
    word event does not refer only to a mouse drag or button click; it’s used in the
    general sense to mean any piece of data. An event is some value (synchronous or
    asynchronous) that gets emitted over time by some source (event emitter, generator,
    list, and so on) and handled by a subscriber or observer.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过流来提高抽象级别。流解决了相同的问题，但以一种更容易推理的方式。流是一系列一个或无限多个数据片段，称为事件。在这个上下文中，事件这个词不仅仅指鼠标拖动或按钮点击；它被用来泛指任何数据。事件是某个源（事件发射器、生成器、列表等）在一段时间内发出的某个值（同步或异步），并由订阅者或观察者处理。
- en: As streams are sequences of values over time, they can nicely wrap over any
    producer, manifesting as a single string or even a complex async generator. On
    the consuming end, we can abstract over them by using `for` `await...of` via an
    object known as a `Subscription`. Subscriptions are like iterators in that you
    can call them as many times as you want to notify them when data becomes available,
    such as a call to `next`. With a stream, we talk about subscribers, not consumers.
    To facilitate building up this abstraction, let’s warm up by creating a streamable
    object using arrays in the next section.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于流是随时间变化的值序列，它们可以很好地封装任何生产者，表现为单个字符串甚至复杂的异步生成器。在消费端，我们可以通过使用名为“订阅”的对象的`for`
    `await...of`来抽象它们。订阅类似于迭代器，你可以多次调用它们以通知数据可用，例如调用`next`。在使用流时，我们谈论的是订阅者，而不是消费者。为了便于构建这种抽象，让我们在下一节通过使用数组创建一个可流对象来热身。
- en: 9.3.2 Implementing a streamable array
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.2 实现可流数组
- en: 'Now that you understand the basics of a stream, let’s come back to the part
    of listing 9.8 that declares the data stream and study it more closely:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了流的基本知识，让我们回到列表9.8中声明数据流的那个部分，并更仔细地研究它：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The Node.js API `fs.createReadStream` returns an object of `fs.ReadStream`,
    which in turn extends from `stream.Readable`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js API `fs.createReadStream`返回一个`fs.ReadStream`对象，它反过来又扩展了`stream.Readable`。
- en: Node.js streams
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js流
- en: The stream module is a relatively new, built-in Node.js library for working
    with read/ write streams of data. Stream objects come equipped with `Symbol.asyncIterator`
    properties to make consuming its data easy. You can find more information about
    this library at [https://nodejs.org/api/stream.html](https://nodejs.org/api/stream.html).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 流模块是一个相对较新的内置Node.js库，用于处理数据的读写流。流对象配备了`Symbol.asyncIterator`属性，使得消费其数据变得简单。你可以在[https://nodejs.org/api/stream.html](https://nodejs.org/api/stream.html)找到更多关于这个库的信息。
- en: 'If you peek at this API documentation, two properties stand out for the purposes
    of this chapter: an `on` method that emits the `''data''` event and the `Symbol.asyncIterator`
    method. Here’s an example:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看这个API文档，有两个属性对于本章的目的来说很突出：一个`on`方法，它触发`'data'`事件，以及`Symbol.asyncIterator`方法。以下是一个示例：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This interface suggests that this object is both an async iterable and an `EventEmitter`.
    I haven’t covered event emitters in this book, but I’ll review the basics quickly
    to support the examples in this chapter. An `EventEmitter` is an API that allows
    you to separate the creation of some object from its use—a rudimentary form of
    publish/subscribe. The following listing shows an example.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口表明此对象既是异步可迭代的，也是`EventEmitter`。我在这本书中没有涵盖事件发射器，但我会快速回顾基础知识，以支持本章的示例。`EventEmitter`是一个API，允许你将某些对象的创建与其使用分离——这是一种基本的发布/订阅形式。以下列表显示了一个示例。
- en: Listing 9.11 Basic use of an `EventEmitter`
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.11 `EventEmitter`的基本使用
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Consumer of the data (subscriber). This process is similar to handling, say,
    an onClick event.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 数据的消费者（订阅者）。这个过程类似于处理，比如一个onClick事件。
- en: ❷ Producer of the data
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 数据的生产者
- en: By combining `EventEmitter` and `Symbol.asyncIterator`, we can implement a real
    push solution. The emitter in this case is a nice technique for separating the
    method that handles pushing new data (such as `push`) from the method that handles
    a subscriber to this data (such as `subscribe`). Arrays, for example, are pull
    data structures because they have functions and properties to pull its data (`indexOf`
    and indexing, respectively) as well as to implement `Symbol.iterator` for pulling
    multiple values (refer to table 9.1). If you want to run some code in response
    to a new value (a process called reacting), you must set up some kind of long
    polling solution that peeks at the status of the array at a time interval, which
    is not the most optimal solution. For efficiency, let’s invert this flow. Instead
    of picking at the data, we’ll subscribe to it so that it lets us know when it
    has a new value (a process called notifying).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合 `EventEmitter` 和 `Symbol.asyncIterator`，我们可以实现真正的推送解决方案。在这种情况下，发射器是一种很好的技术，可以将处理推送新数据的方法（如
    `push`）与处理此数据订阅者的方法（如 `subscribe`）分开。例如，数组是拉取数据结构，因为它们有函数和属性来拉取其数据（`indexOf` 和索引分别）以及实现
    `Symbol.iterator` 以拉取多个值（参见表 9.1）。如果你想对新值（称为反应的过程）运行一些代码，你必须设置某种类型的长时间轮询解决方案，在时间间隔内查看数组的状态，这不是最优的解决方案。为了提高效率，让我们反转这个流程。而不是挑数据，我们将订阅它，这样它就会在我们有新值时通知我们（称为通知的过程）。
- en: 'Let’s extend from `Array` with push semantics by configuring an internal `EventEmitter`
    that fires an event every time a new value is added. Consider a class called `PushArray`
    that exposes two new methods to enable subscription: `subscribe` and unsubscribe.
    The subscribe method accepts an object that implements a next(value) method, shown
    in the next listing.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过配置一个内部 `EventEmitter` 来扩展 `Array`，该 `EventEmitter` 在每次添加新值时触发一个事件。考虑一个名为
    `PushArray` 的类，它公开两个新方法以启用订阅：`subscribe` 和 `unsubscribe`。`subscribe` 方法接受一个实现
    `next(value)` 方法的对象，如下一列表所示。
- en: Listing 9.12 Subclass of `Array` that fires events when a new elements is pushed
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.12 `Array` 的子类，当新元素被推入时触发事件
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ Emits the new value pushed
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 发射被推入的新值
- en: ❷ Uses destructuring to extract the next method from the object passed in
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用解构从传入的对象中提取 `next` 方法
- en: ❸ When the emitter fires a new value, it’s pushed to the subscriber.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 当发射器触发新值时，它会被推送到订阅者。
- en: ❹ Removes all subscribers. Any further push events will not be emitted.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 移除所有订阅者。任何进一步的推送事件都不会被发射。
- en: '❺ Prints ''New value: 4'' and ''New value: 4'' to the console. Array now has
    1,2,3,4, 5.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '❺ 将 ''New value: 4'' 和 ''New value: 4'' 打印到控制台。数组现在有 1,2,3,4, 5。'
- en: ❻ Unsubscribes from the push array object
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 从推送数组对象取消订阅
- en: ❼ Subscriber does not get notified of the event. Array now has 1,2,3,4,5, 6.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 订阅者不会收到事件通知。数组现在有 1,2,3,4,5, 6。
- en: 'Let’s closely examine the call to `subscribe` in this example. The idea of
    a subscriber is central to the stream paradigm, which always requires two actors:
    a producer and a subscriber. When the number 4 is pushed to the array, the event
    emitter fires and immediately notifies the subscriber (figure 9.3).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细检查这个例子中的 `subscribe` 调用。订阅者的概念是流范式中的核心，它始终需要两个参与者：生产者和订阅者。当数字 4 被推入数组时，事件发射器触发并立即通知订阅者（图
    9.3）。
- en: '![](../Images/9-3.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9-3.png)'
- en: Figure 9.3 The basic flow of a push object with producer and subscriber
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 具有生产者和订阅者的推送对象的基本流程
- en: The call to `subscribe` accepts an object with the shape shown in listing 9.13.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscribe` 调用接受一个形状如列表 9.13 所示的对象。'
- en: Listing 9.13 Subscribers accepting objects with a `next` method
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.13 接受具有 `next` 方法的对象的订阅者
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ Using property syntax instead of shorthand, because it’s more descriptive
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用属性语法而不是缩写语法，因为它更具有描述性
- en: 'This object is called an observer, and it’s no coincidence that the name of
    the method is `next`. Observers align not only with the Iterable/Iterator protocols,
    but also with the protocol behind a push generator, which I’m omitting in this
    book to keep the discussions brief. If you follow this topic more closely, you’ll
    learn that generators can not only yield values, but also allow you to push values
    back. Here’s a link if you want to read more about the topic: [http://mng.bz/WdOw](http://mng.bz/WdOw).'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象被称为观察者，并且方法名为 `next` 并非巧合。观察者不仅与 Iterable/Iterator 协议相匹配，还与推送生成器背后的协议相匹配，我在本书中省略了这部分内容以保持讨论简洁。如果你更深入地关注这个话题，你会了解到生成器不仅可以产生值，还可以允许你推送值。如果你想了解更多关于这个话题的信息，请点击以下链接：[http://mng.bz/WdOw](http://mng.bz/WdOw)。
- en: Hence, the shape of the observer with the `next(value)` method has the sole
    purpose of keeping this protocol and makes the transition to stream-based programming
    fluid. The JavaScript API for representing a stream is known as `Observable`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，具有`next(value)`方法的观察者形状的唯一目的是保持此协议，使基于流的编程过渡流畅。表示流的JavaScript API称为`Observable`。
- en: '9.4 Welcoming a new native: Observable'
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 欢迎新的本地原生：可观察流
- en: At the time of this writing, a proposal slowly moving through the ranks may
    dramatically change the way we code on a day-to-day basis ([https://github.com/tc39/proposal
    -observable](https://github.com/tc39/proposal-observable)). Some people say it
    has already changed the way we use third-party, stream-oriented libraries, RxJS
    being my favorite. This project has deeply penetrated the Angular, Vue, React,
    Redux, and other web communities.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，一个缓慢推进的提案可能会显著改变我们日常编码的方式（[https://github.com/tc39/proposal-observable](https://github.com/tc39/proposal-observable)）。有些人说它已经改变了我们使用第三方、以流为导向的库的方式，RxJS就是我最喜欢的。这个项目已经深入到Angular、Vue、React、Redux和其他Web社区。
- en: In this section, we’ll discuss the current status of the `Observable` API. This
    API supports the reactive streams paradigm, which creates a layer of abstraction
    over any data type and size, regardless of whether the mechanism is push or pull
    or whether data arrives synchronous or asynchronously.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论`Observable` API的当前状态。此API支持响应式流范式，它为任何数据类型和大小创建了一个抽象层，无论机制是推送还是拉取，数据是否同步或异步到达。
- en: 'You may have used reactive programming through RxJS if you’ve worked with frameworks
    such as Angular and React or state management libraries such as Redux. If you
    haven’t, at a high level, observables have these two qualities, which I’ll build
    on in the following examples:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过RxJS进行过Angular和React等框架或Redux等状态管理库的工作，那么你可能已经使用过响应式编程。如果没有，从高层次来看，可观察流具有以下两个特性，我将在以下示例中加以阐述：
- en: Data propagation — Data propagation naturally follows the pub/sub model. You
    identify a publisher (known as the source), which can be a generator or a simple
    array. The data stream propagates or flows in a single direction all the way to
    a subscriber. Along the way, you can apply business logic that transforms data
    according to your needs.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据传播 — 数据传播自然遵循发布/订阅模型。你确定一个发布者（称为源），它可以是生成器或简单的数组。数据流以单一方向传播或流动，直到到达订阅者。在这个过程中，你可以应用业务逻辑，根据你的需求转换数据。
- en: Declarative, lazy pipeline — You can statically represent the execution of a
    stream regardless of publisher and subscriber, and pass it around like any other
    object in your application. Unlike promises, an observable object is lazy, so
    until a subscriber subscribes, nothing runs.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明式、懒加载管道 — 你可以静态地表示流的执行，无论发布者还是订阅者，就像在应用程序中的任何其他对象一样传递它。与承诺不同，可观察对象是懒加载的，所以直到订阅者订阅，什么都不会运行。
- en: Observable streams can be hard to understand; they require strong JavaScript
    skills and a solid understanding of the value of composable code. Fortunately,
    I’ve covered all these topics (and more) in this book, and I’ll reuse a lot of
    what you’ve already learned as I discuss how to use this API.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察流可能难以理解；它们需要强大的JavaScript技能和对可组合代码价值的深刻理解。幸运的是，我在这本书中涵盖了所有这些主题（以及更多），在讨论如何使用此API时，我会重用你已学到的很多内容。
- en: 'The following list summarizes these concepts (and if you skipped any of them,
    I highly recommend that you go back to the chapters that covered them to read
    about them):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表总结了这些概念（如果你跳过了任何内容，我强烈建议你回到涵盖它们的章节去阅读它们）：
- en: Observables are compositional objects, so you can combine them or create new
    observables from existing ones. You’ll create a mixin that extends the base functionality
    of `Observable`’s prototype. Object composition and mixin extension are covered
    in chapter 3.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观察流是组合对象，因此你可以将它们组合或从现有对象中创建新的可观察流。你将创建一个混合器，它扩展了`Observable`原型的基功能。对象组合和混合器扩展在第3章中介绍。
- en: Observable operators are pure, composable, curried functions. Any side effects
    should be carried out by subscribers. Pure functions, composition and currying
    are explained in chapter 4.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观察流操作符是纯函数、可组合的、柯里化的函数。任何副作用都应该由订阅者执行。纯函数、组合和柯里化在第4章中解释。
- en: The design of the `Observable` API draws on the design of ADTs, particularly
    in its use of `map`. Chapter 5 shows how to design your own ADT and how to implement
    universal protocols such as `Functor.map` and `Monad.flatMap`.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observable` API的设计借鉴了ADT的设计，特别是在其使用`map`方面。第五章展示了如何设计自己的ADT以及如何实现通用协议，如`Functor.map`和`Monad.flatMap`。'
- en: Part of the specification defines a new function-valued built-in symbol called
    `Symbol.observable`. Objects that implement this special symbol can be passed
    to the `Observable.from` constructor. Implementing custom symbols and using built-in
    symbols are covered in chapter 7.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规范的一部分定义了一个新的函数值内置符号，称为`Symbol.observable`。实现此特殊符号的对象可以传递给`Observable.from`构造函数。自定义符号的实现和使用内置符号在第七章中介绍。
- en: An observable models a unidirectional, linear stream of data. Chapter 8 discusses
    how to create chains with promises to streamline and flatten asynchronous flows
    and to make them easier to reason about.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观察对象模拟了一个单向、线性的数据流。第八章讨论了如何使用承诺创建链以简化并展平异步流程，并使它们更容易推理。
- en: With all the foundational concepts behind us, let’s dive into an observable
    stream in the next section.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握所有基础概念之后，让我们在下一节深入探讨可观察流。
- en: 9.4.1 What is an Observable?
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.1 什么是可观察的？
- en: In this section, we’ll learn what an `Observable` is and unpack its main components.
    As a simple example, consider the snippet of code in the next listing.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习什么是`Observable`，并解开其主要组件。作为一个简单的例子，考虑下一列表中的代码片段。
- en: Listing 9.14 Creating and subscribing to an `Observable`
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.14 创建和订阅`Observable`
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ Logs every word to the console and uses the unary form of the bind operator
    to pass a properly bound console.log function
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将每个单词记录到控制台，并使用绑定操作符的单值形式传递一个正确绑定的console.log函数
- en: Can you guess what will happen? This listing is the simplest possible example
    that uses observables. Notice the resemblance between this code and the `PushArray`
    class. If you guessed that it prints each individual word to the console, you
    nailed it! But how did you arrive at this conclusion? What assumptions did you
    make?
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜到会发生什么吗？这个列表是使用可观察者的最简单示例。注意这段代码与`PushArray`类的相似之处。如果你猜到它会将每个单词打印到控制台，你就猜对了！但你如何得出这个结论？你做了哪些假设？
- en: An `Observable` object is designed to model a lazy, unidirectional, push-based
    data source (such as streams).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable`对象旨在模拟一个懒加载、单向、基于推送的数据源（如流）。'
- en: NOTE It’s worth pointing out that observables are different from the technology
    known as Web Streams ([https://streams.spec.whatwg.org](https://streams.spec.whatwg.org)).
    Although the technologies have some of the same goals, observables offer an API
    to wrap over any data source, which could be a Web Stream but doesn’t have to
    be.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 备注：值得注意的是，可观察者与称为Web Streams（[https://streams.spec.whatwg.org](https://streams.spec.whatwg.org)）的技术不同。尽管这些技术有一些相同的目标，但可观察者提供了一个API来包装任何数据源，这可以是Web
    Stream，但不必是。
- en: You can think of data as being a river that flows downstream from some source
    to a destination. The conduit or the context in which this flow happens is the
    `Observable`. Along the way, the flow changes course, speed, and temperature until
    it arrives at its destination. These points of inflexion are known as operators,
    which I haven’t shown yet.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将数据想象成一条从某个源头流向目的地的河流。这条河流流动的管道或上下文是`Observable`。在旅途中，河流的流向、速度和温度会发生变化，直到到达目的地。这些转折点被称为操作符，我还没有展示它们。
- en: There’s no point in transmitting any data if there’s nobody on the other side
    to receive it, however, which is why observables are lazy and wait for the call
    to `subscribe` to set things in motion.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有人在另一端接收数据，那么传输任何数据都没有意义，这就是为什么可观察者是懒加载的，并等待调用`subscribe`来启动流程。
- en: The `Observable` constructor `Observable.of` lifts an iterable object and returns
    a `Subscription` object with the shape shown in the next listing.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable`构造函数`Observable.of`提升一个可迭代对象，并返回一个具有下一列表中所示形状的`Subscription`对象。'
- en: Listing 9.15 `Subscription` declaring a method to `unsubscribe` from the stream
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.15 `Subscription`声明一个从流中取消订阅的方法
- en: '[PRE31]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ Used to cancel the subscription (the stream) at any time
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 可以在任何时候取消订阅（流）
- en: ❷ The body of this function is supplied by the producer of the data.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 此函数的主体由数据的生产者提供。
- en: This simple interface declares a single `unsubscribe` method. The logic of this
    method is specific to how the data is being generated. If the data is sent intermittently
    by `setInterval`, for example, `unsubscribe` takes care of clearing the interval.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的接口声明了一个单一的`unsubscribe`方法。这个方法的逻辑是针对数据生成方式的特定。例如，如果数据是通过`setInterval`间歇性地发送的，那么`unsubscribe`会负责清除间隔。
- en: On the other side of the river, the `Observer` object is a bit more complex
    than a regular iterator but behaves in much the same way. The next listing shows
    the contract.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在河的另一边，`Observer`对象比普通迭代器复杂一些，但行为方式非常相似。下一个列表显示了合同。
- en: Listing 9.16 Shape of the `Observer` object
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.16 `Observer`对象的结构
- en: '[PRE32]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ Receives each event in the stream
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 接收流中的每个事件
- en: ❷ Triggered when an exception occurs somewhere along the observable
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当在可观察对象中某处发生异常时触发
- en: ❸ Called when there are no more values to emit; not called on error
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 当没有更多值要发出时调用；在错误情况下不调用
- en: Together, `Observable`, `Observer`, and `Subscription` make up the skeleton
    framework being standardized by TC39\. Libraries such as RxJS extend this framework
    to provide a programming tool belt to handle the types of tasks at which streams
    excel. In the next section, we’ll use this interface to implement more examples
    with observables.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable`、`Observer`和`Subscription`共同构成了TC39正在标准化的骨架框架。例如，RxJS之类的库扩展了这个框架，以提供编程工具包来处理流擅长处理的任务类型。在下一节中，我们将使用这个接口来实现更多使用可观察对象的示例。'
- en: 9.4.2 Creating custom observables
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.2 创建自定义可观察对象
- en: The static constructor functions `Observable.{of,` `from}` can be used to wrap
    or lift most JavaScript built-in data types (such as strings and arrays) or even
    another `Observable`. This interface is a basic one. From here, you can instantiate
    a new, empty `Observable` directly to define your own custom streams. This technique
    is used in case you want to wrap over, say, a DOM event listener and emit events
    through the `Observable` API. Perhaps you have created some `EventListener` objects
    that you want to combine. The next listing shows an `Observable` that emits random
    numbers every second and the subscriber that handles each event.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 静态构造函数`Observable.{of, from}`可以用来包装或提升大多数JavaScript内置数据类型（如字符串和数组）或另一个`Observable`。这个接口是一个基本的接口。从这里，你可以直接实例化一个新的空`Observable`来定义你自己的自定义流。这种技术用于你想要包装，比如说，一个DOM事件监听器并通过`Observable`
    API发出事件的情况。也许你已经创建了一些`EventListener`对象，想要将它们组合起来。下一个列表显示了一个每秒发出随机数的`Observable`以及处理每个事件的订阅者。
- en: Listing 9.17 Using observables to emit random numbers
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.17 使用可观察对象发出随机数
- en: '[PRE33]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ Returns a random number between min and max
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 返回介于min和max之间的随机数
- en: ❷ Uses the new keyword to instantiate an Observable with a custom observer
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用新关键字实例化一个带有自定义观察者的`Observable`
- en: ❸ A SubscriptionFunction. The body of this function is executed when calling
    subs.unsubscribe.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 一个订阅函数。当调用`subs.unsubscribe`时执行此函数的主体。
- en: In this snippet of code, `randomNum$` initially holds an inert `Observable`
    object waiting for a subscriber. The `Observable` constructor has not yet begun
    executing. Also, you may have noticed the dollar sign (`$`) used at the end of
    the variable name. No `jQuery` is being used here; `$` is a convention indicating
    that this variable holds a stream. Later, the call to `subscribe` kicks off the
    stream so that new random numbers print to the console. This process happens infinitely
    until clients call `unsubscribe`. So-called marble diagrams have become a popular
    way of illustrating how events are emitted through an observable, as shown in
    figure 9.4.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码片段中，`randomNum$`最初持有等待订阅者的惰性`Observable`对象。`Observable`构造函数尚未开始执行。此外，你可能已经注意到了变量名末尾使用的美元符号（`$`）。这里没有使用`jQuery`；`$`是一个约定，表示这个变量持有流。稍后，对`subscribe`的调用启动了流，以便新的随机数打印到控制台。这个过程无限进行，直到客户端调用`unsubscribe`。所谓的宝石图已经成为一种流行的展示事件如何通过可观察对象发出的方式，如图9.4所示。
- en: '![](../Images/9-4.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/9-4.png)'
- en: Figure 9.4 The unidirectional flow of an observable is depicted as an arrow.
    You can think of the producer and subscribers (not shown but implied) as being
    on the left and right sides, respectively. Events (marbles) move across the observable.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 可观察物的单向流被描绘为箭头。你可以将生产者和订阅者（未显示但暗示）分别想象在左侧和右侧。事件（宝石）在可观察物中移动。
- en: Each marble indicates an event that happens over time—in this case, a new random
    number emitted every second. In place of a random number every second, you could
    have events such as mouse coordinates, enumerations of the elements of an array,
    chunks of an HTTP response, filenames in a directory traversal, keystrokes, and
    so on.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 每个弹珠表示在一段时间内发生的事件——在这种情况下，每秒发出一个新的随机数。在每秒一个随机数的地方，你可以有诸如鼠标坐标、数组元素的枚举、HTTP响应的块、目录遍历中的文件名、按键等事件。
- en: At this writing, the observable specification defines rules and a skeleton only
    for `Observable` and `Subscriber`. In the real world, you’ll need much more. Without
    a library like RxJS, you can’t do much. You need functions that can operate on
    the data. These functions are called operators.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，可观察的规范仅定义了`Observable`和`Subscriber`的规则和骨架。在现实世界中，你需要更多。没有像RxJS这样的库，你几乎无法做什么。你需要能够操作数据的函数。这些函数被称为操作符。
- en: 9.4.3 Building your own reactive toolkit
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.3 构建自己的响应式工具包
- en: 'When data starts flowing through a stream, an operator allows you to process
    that stream before the data reaches a subscriber. An operator represents the twists
    and turns. The current proposal doesn’t define any built-in set of operators,
    but it does define two important rules about observables that we must follow:
    laziness and composition. Operators extend observables and capture the business
    logic of your application. In this section, we’ll create our own mini RxJS library
    and learn how to implement our own custom operators that extend the `Observable`
    prototype. If you follow the code in GitHub, all operators will be defined in
    a module called `rx.js`.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据开始通过流流动时，操作符允许你在数据到达订阅者之前处理该流。操作符代表曲折和转弯。当前的提案没有定义任何内置的操作符集，但它确实定义了关于可观察物的两个重要规则，我们必须遵守：惰性和组合。操作符扩展了可观察物并捕获了应用程序的业务逻辑。在本节中，我们将创建自己的迷你RxJS库，并学习如何实现我们自己的自定义操作符，这些操作符扩展了`Observable`原型。如果你遵循GitHub中的代码，所有操作符都将定义在一个名为`rx.js`的模块中。
- en: The way we’re going to design these operators is in line with the patterns and
    principles of ADTs. Comparing `Observable` with `Validation`, you can see a static
    lifting operator called `Observable.of` (like `Validation.of`). And although `Observable`
    doesn’t declare any methods other than `subscribe`, the proposal makes it clear
    that observables are composable objects. Do you recall the `map`/`compose` correspondence
    discussed in chapter 4? What’s more compositional than a `map` operator? By design,
    this higher-order function gives us the ability to transform the data flowing
    through the observable pipeline. You can use this function to add a timestamp
    to each event emitted, remove fields from the event object, compute new fields
    on the fly, and so on.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设计这些操作符的方式将与ADT的模式和原则一致。将`Observable`与`Validation`进行比较，你可以看到一个静态提升操作符称为`Observable.of`（类似于`Validation.of`）。尽管`Observable`没有声明任何除`subscribe`之外的方法，但提案清楚地表明可观察者是可组合的对象。你还记得第4章中讨论的`map`/`compose`对应关系吗？还有什么比`map`操作符更可组合的吗？按照设计，这个高阶函数使我们能够转换通过可观察管道流动的数据。你可以使用这个函数为每个事件添加时间戳，从事件对象中删除字段，动态计算新字段，等等。
- en: map operator
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: map操作符
- en: The `map` operator applies a given function, `fn`, to each value emitted by
    an observable source. This behavior matches the behavior of any ADT and even simple
    arrays. I’ve discussed `map` at length in this book, so I’m not going to review
    the laws that oversee it. Let’s cut straight to the chase and implement `Observable`’s
    version of `map`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`操作符将给定的函数`fn`应用于可观察源发出的每个值。这种行为与任何ADT和简单数组的行为相匹配。我在这本书中详细讨论了`map`，所以我不打算回顾它所遵循的法律。让我们直接进入正题，实现`Observable`的`map`版本。'
- en: 'Remember from chapter 5 that `map` always returns a new copy of the derived
    constructor. For `Observable`, you need to make sure that the source’s (the calling
    observable’s) observer and the new observer are linked so that one’s `next` feeds
    into the other’s `next`. Think about this concept for a moment: it’s function
    composition all over again, whereby one function’s return value is connected to
    the input of the next. This linkage creates data propagation, and the goal of
    every operator is to allow data to continue flowing from a producer downstream
    to a consumer.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 记住第5章的内容，`map`总是返回派生构造函数的新副本。对于`Observable`，你需要确保源（调用可观察对象的观察者）和新的观察者之间是链接的，以便一个的`next`可以输入到另一个的`next`中。思考一下这个概念：这又是函数组合，其中一个函数的返回值连接到下一个函数的输入。这种链接创建了数据传播，每个操作符的目标是允许数据从生产者向下流到消费者。
- en: Let’s define `map` as a standalone operator and then bind it to `Observable.prototype`
    to enable the fluent pattern of ADTsin the next listing.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义`map`为一个独立操作符，并将其绑定到`Observable.prototype`，以便在下一个列表中启用ADT的流畅模式。
- en: Listing 9.18 Custom `map` operator
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.18 自定义`map`操作符
- en: '[PRE34]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ❶ Currying is used to partially bind the mapping function to any stream. Currying
    will simplify the design of the operators to allow for standalone use as well
    as instance methods.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用柯里化将映射函数部分绑定到任何流。柯里化将简化操作符的设计，使其可以作为独立使用以及实例方法。
- en: ❷ map is structure-preserving and immutable, so it returns a new Observable
    whose subscription is tied to the source.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ `map`是结构保持和不可变的，因此它返回一个新的`Observable`，其订阅与源相关联。
- en: ❸ Subscribes to the source stream
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 订阅到源流
- en: ❹ Per the definition of map, applies the given function to each value emitted
    by the source observable and notifies observers of any errors
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 根据map的定义，将给定的函数应用于源可观察对象发出的每个值，并通知观察者任何错误
- en: ❺ Propagates any errors that occurred from the source observable downstream
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将源可观察对象发生的任何错误传播到下游
- en: ❻ Emits the complete event from the source observable
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 从源可观察对象发出完成事件
- en: ❼ Returns this subscription’s SubscriptionFunction so that a call to unsubscribe
    downstream cancels all the midstream observables
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 返回此订阅的SubscriptionFunction，以便在下游取消订阅取消所有中间流的可观察对象
- en: 'From the point of view of an operator function, the producer is the stream
    object that came before it, and the subscriber the observer object that’s passed
    in (with a `next` method). Every operator is like `map` in that it creates a new
    `Observable` that subscribes to the previous one with an `Observer`, building
    a downstream chain. Every event is propagated downstream by calling the observer’s
    `next` method along the way until it reaches the final observer: the subscriber.
    The same thing happens for `error` and the final `complete` event. By contrast,
    calls to `unsubscribe` bubble upstream, canceling every observable object in the
    chain.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 从操作符函数的角度来看，生产者是它之前的流对象，而订阅者是传入的观察者对象（带有`next`方法）。每个操作符都像`map`一样，创建一个新的`Observable`，该`Observable`通过`Observer`订阅前一个`Observable`，构建下游链。每个事件都会通过调用观察者的`next`方法沿路传播，直到达到最终的观察者：订阅者。对于`error`和最终的`complete`事件，情况也是一样的。相比之下，`unsubscribe`的调用会向上冒泡，取消链中的每个可观察对象。
- en: The point of making `map` a standalone function is merely a design decision
    that resembles what you would see in a project such as RxJS. This decision gives
    you the flexibility to use `map` as a standalone function or as a method, which
    is how the latest versions of RxJS export it.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 将`map`作为一个独立函数的做法仅仅是一个设计决策，这类似于你在RxJS等项目中所看到的样子。这个决策给了你使用`map`作为独立函数或方法的灵活性，这正是RxJS最新版本导出的方式。
- en: The next listing shows a simple use case that applies a `square` function over
    each number emitted by a stream by using the standalone version of `map`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了一个简单的用例，它通过使用独立的`map`版本，对每个由流发出的数字应用`square`函数。
- en: Listing 9.19 Using observables to map a function over a number sequence
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.19 使用可观察对象映射数字序列上的函数
- en: '[PRE35]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ Prints 1, 4, and 9, followed by "Stream ended"
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 打印1、4和9，然后是"Stream ended"
- en: The marble diagram in figure 9.5 illustrates this concept.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5中的宝石图说明了这个概念。
- en: Reading marble diagrams
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读宝石图
- en: A marble diagram is closely tied to the Reactive Extension (Rx) community to
    explain how an operator works. We’re going to be using a small subset of this
    notation. The only component of a marble diagram to understand for the purposes
    of this book is that a marble represents an event or a piece of data. The horizontal
    arrow represents time, and the space between marbles is the time between emissions,
    which can be synchronous (immediate) or asynchronous. The operator function (large
    rectangles) acts on a specific marble and produces a new one if needed, placed
    on a new timeline arrow. If the operation is synchronous, it maps to the same
    point in time; otherwise, it shifts forward in time, depending on the operator.
    The `map` operator here is instant, for example, whereas an operator like `delay`
    (not covered) can shift the event by some provided time period. If you want to
    read more about this tool, you can find good resources at [https://rxmarbles.com](https://rxmarbles.com)
    and [http://mng.bz/8NzB](http://mng.bz/8NzB).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 水晶图与反应式扩展（Rx）社区紧密相连，用于解释操作符的工作原理。我们将使用这个符号集的一个小子集。为了理解本书的目的，需要了解水晶图的一个唯一组件，那就是水晶代表一个事件或数据片段。水平箭头代表时间，水晶之间的空间代表发射之间的时间，可以是同步的（立即）或异步的。操作符函数（大矩形）作用于特定的水晶，并在需要时产生一个新的水晶，放置在新的时间线箭头上。如果操作是同步的，它映射到相同的时间点；否则，它根据操作符向前移动时间。这里的`map`操作符是瞬时的，例如，而像`delay`（未介绍）这样的操作符可以将事件延迟一段时间。如果您想了解更多关于这个工具的信息，可以在[https://rxmarbles.com](https://rxmarbles.com)和[http://mng.bz/8NzB](http://mng.bz/8NzB)找到好的资源。
- en: '![](../Images/9-5.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/9-5.png)'
- en: Figure 9.5 This example shows creating an observable with numbers 1, 2, and
    3\. As is, this code emits these numbers synchronously. The space between the
    marbles is added for visualization purposes.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 这个例子展示了创建一个包含数字1、2和3的可观察对象。按照原样，这段代码会同步发射这些数字。水晶之间的空间是为了可视化而添加的。
- en: Building on this example, the next listing and figure 9.6 showcase the composability
    of streams..
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个例子，下一个列表和图9.6展示了流的组合性。
- en: '![](../Images/9-6.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/9-6.png)'
- en: 'Figure 9.6 The composition of two operators. Three instances of an observable
    (arrow) are shown: the source observable and two operators. Each operator subscribes
    to the previous stream and creates a new observable.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 两个操作符的组合。显示了三个可观察对象（箭头）的实例：源可观察对象和两个操作符。每个操作符订阅前一个流并创建一个新的可观察对象。
- en: Listing 9.20 Composing observables
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.20 组合可观察对象
- en: '[PRE36]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ❶ Composes two calls to map
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 组合两次`map`调用
- en: ❷ Prints 4, 9, and 16, followed by "Stream ended"
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 打印4、9和16，然后输出"Stream ended"
- en: 'Now that you understand how an operator is designed and visualized, let’s move
    on to another operator: `filter`.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了操作符的设计和可视化方式，让我们继续介绍另一个操作符：`filter`。
- en: filter operator
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤操作符
- en: After you’ve been through `map`, `filter` should be straightforward. Like `Array#filter`,
    this operator selects which values get propagated depending on the Boolean result
    of a predicate function. The next listing shows the implementation.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过`map`之后，`filter`应该很简单。像`Array#filter`一样，这个操作符根据谓词函数的布尔结果选择哪些值被传播。下一个列表显示了实现。
- en: Listing 9.21 Custom `filter` operator
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.21 自定义`filter`操作符
- en: '[PRE37]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ❶ If the predicate returns a truthy result, the value is kept; otherwise, the
    event is not emitted.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果谓词返回一个真值结果，则保留该值；否则，事件不会被发射。
- en: As you can see, most of the domain-specific logic resides in the observer’s
    `next` method, propagating the result to the next operator in the chain, and so
    on. The next section jumps ahead to complete the triad with `reduce`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，大部分领域特定逻辑都位于观察者的`next`方法中，将结果传播到链中的下一个操作符，依此类推。下一节将跳到`reduce`以完成三联组。
- en: reduce operator
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 减少（reduce）操作符
- en: The `reduce` operator reduces or folds all the values emitted by a source observable
    to a single value that’s emitted when the source completes. The result is an observable
    of a single value, as shown in the following listing.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce`操作符将源可观察对象发出的所有值折叠或减少为单个值，当源完成时发出。结果是一个只发出单个值的可观察对象，如下面的列表所示。'
- en: Listing 9.22 Custom `reduce` operator
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.22 自定义`reduce`操作符
- en: '[PRE38]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ❶ Creates a new object when initialValue is null or undefined
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当`initialValue`为null或undefined时创建一个新对象
- en: ❷ Applies the accumulator callback, like Array#reduce
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 应用累加器回调，类似于`Array#reduce`
- en: ❸ Emits the accumulated result and sends the complete signal to end the stream
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 发射累积的结果，并发送完整的信号以结束流
- en: skip operator
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 跳过操作符
- en: The `skip` operator allows you to ignore the first X number of events from a
    source observable. The next listing shows the implementation of that operator.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`skip` 操作符允许你忽略来自源可观察对象的前 X 个事件。下一个列表显示了该操作符的实现。'
- en: Listing 9.23 Custom `skip` operator
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.23 自定义 `skip` 操作符
- en: '[PRE39]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'At this point, we’ve added `map`, `filter`, `reduce`, and `skip` operators.
    Believe it or not, with these operators we can tackle a wide range of programming
    tasks. Here’s an example that shows them used together:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经添加了 `map`、`filter`、`reduce` 和 `skip` 操作符。信不信由你，有了这些操作符，我们可以处理广泛的编程任务。以下是一个展示它们一起使用的示例：
- en: '[PRE40]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You can see the composable nature of these operators. When you’re building complex
    chains, this type of layout is hard to parse. Normally, full-featured reactive
    libraries like RxJS feature a `pipe` operator that makes writing all operators
    straightforward. An alternative is to use dot notation to write these chains fluently,
    similarly to how we chained `then` methods on promise chains. To do so, we’ll
    need to extend the built-in `Observable` object.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这些操作符的可组合性。当你构建复杂的链时，这种布局很难解析。通常，像 RxJS 这样的功能齐全的响应式库具有一个 `pipe` 操作符，这使得编写所有操作符变得简单。另一种选择是使用点符号来流畅地编写这些链，类似于我们在承诺链上链式调用
    `then` 方法。为此，我们需要扩展内置的 `Observable` 对象。
- en: 9.4.4 Observable mixin extension
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.4 可观察混合扩展
- en: Let’s again use the technique of concatenative mixin extension we talked about
    in chapter 3, which allows us to extend any object with new functionality. First,
    we’ll create a small toolkit module from these operators as an object mixin, calling
    it `ReactiveExtensions`, as shown in the next listing.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次使用第 3 章中提到的可串联混合扩展技术，它允许我们通过新功能扩展任何对象。首先，我们将从这些操作符创建一个小的工具包模块作为对象混合，命名为
    `ReactiveExtensions`，如下一个列表所示。
- en: Listing 9.24 Defining the shape of our mini-rxjs toolkit
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.24 定义我们迷你 rxjs 工具包的形状
- en: '[PRE41]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ❶ Exported as a member of the rx.js module
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 作为 rx.js 模块的一部分导出
- en: ❷ Refers to the standalone versions created within the same module
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 指的是在同一模块内创建的独立版本
- en: 'Now the extension is a simple prototype extension, like `Blockchain` and other
    model objects. `Object.assign` comes to the rescue once again:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在扩展是一个简单的原型扩展，类似于 `Blockchain` 和其他模型对象。`Object.assign` 再次伸出援手：
- en: '[PRE42]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: warning Again, use caution when monkey-patching JavaScript built-in types, because
    doing so makes your code harder to port, upgrade, or reuse. If you’re still keen
    on doing it for any reason, please write the required property existence checks
    so that you don’t break upgrades.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：再次提醒，在猴子补丁 JavaScript 内置类型时要小心，因为这样做会使你的代码更难移植、升级或重用。如果你出于任何原因仍然热衷于这样做，请编写所需的属性存在检查，以免破坏升级。
- en: For the joy of it, let’s use the reactive extensions to create an observable
    chain. Listing 9.25 creates a simple stream out of a finite set of numbers; each
    number is an event.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 为了乐趣，让我们使用响应式扩展来创建一个可观察的链。列表 9.25 从有限数字集合中创建一个简单的流；每个数字都是一个事件。
- en: As you can see, events flow downstream through the pipeline one at a time. Along
    the way, these chained, composable operators manipulate the data and form a chain
    in which one operator subscribes to the preceding operator’s observable.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，事件逐个通过管道向下流动。在这个过程中，这些链式组合的操作符操纵数据，并形成一个链，其中一个操作符订阅前一个操作符的可观察对象。
- en: Listing 9.25 Using observable operators to manipulate a number sequence
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.25 使用可观察操作符操作数字序列
- en: '[PRE43]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ❶ Skips the first element, which is 1
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 跳过第一个元素，即 1
- en: ❷ Tests whether the number is even, if it is let it through. In this case, 2
    and 4 make it through.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 测试数字是否为偶数，如果是，则让它通过。在这种情况下，2 和 4 通过。
- en: ❸ Computes the square of each number (4 and 16, respectively)
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 计算每个数字的平方（分别是 4 和 16）
- en: ❹ Adds all of the events together (20)
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将所有事件相加（20）
- en: ❺ Prints 20 to the console
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将 20 打印到控制台
- en: Figure 9.7 illustrates how events flow through the pipeline.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 阐述了事件如何通过管道流动。
- en: '![](../Images/9-7.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.7](../Images/9-7.png)'
- en: Figure 9.7 The composition of four operators, with the data (marbles) changing
    in response to the application of those operators. Every step of the way, a new
    Observable is created, and observers are connected.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 四个操作符的组合，数据（弹珠）根据这些操作符的应用而变化。每一步，都会创建一个新的可观察对象，并且观察者被连接。
- en: The use of composition is an existential quality of streams, which allows you
    to chain the multiple internal subscriptions that are happening inside each operator
    and manage them as a single subscription object.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 使用组合是流的存在质量，这使得您可以将每个操作符内部发生的多个内部订阅链式连接起来，并将它们作为一个单独的订阅对象来管理。
- en: Now that you’ve seen how to join multiple operators (figure 9.7), let’s review
    how data flows unidirectionally downstream. If you were to visualize each operator
    as a black box, you’d see that although the data flows downstream, subscription
    objects flow upstream, starting from the last call to `subscribe` all the way
    up to the source (the initial `Observable` object). This last call to `subscribe`
    kick-starts everything and notifies the source to begin emitting events. Figure
    9.8 explains the order of events.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了如何连接多个操作符（图9.7），让我们回顾一下数据如何单向向下流动。如果您将每个操作符视为一个黑盒，您会看到尽管数据向下流动，但订阅对象向上流动，从最后的`subscribe`调用开始，一直向上到源（初始的`Observable`对象）。这个最后的`subscribe`调用启动了一切，并通知源开始发出事件。图9.8解释了事件的顺序。
- en: '![](../Images/9-8.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/9-8.png)'
- en: Figure 9.8 A chain of observables. Data flows downstream as observers call the
    next one’s `next(...)`, while subscriptions flow upstream starting with the last
    call to `subscribe()`. Steps are numbered to show how the last call to `subscribe()`
    causes all operators to subscribe internally to one another upstream, notifying
    the source observable to begin sending events down.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 一系列可观察对象。数据在观察者调用下一个的`next(...)`时向下流动，而订阅从最后的`subscribe()`调用开始向上流动。步骤编号显示最后调用`subscribe()`如何导致所有操作符向上内部订阅彼此，并通知源可观察对象开始向下发送事件。
- en: So far, we’ve been dealing with arrays, which are relatively simple event sources.
    But the rubber meets the road when we start to deal with asynchronous, potentially
    infinite data sources such as async generators. In place of `Observable.of(1,2,3)`,
    which acts like the stream source for the operations we showed previously, we
    can have a generator that, after the `subscribe` is called on the composed observable,
    starts feeding values down the chain. The infinite nature of streams is in principle
    similar to that of generators in that until a generator returns, the function
    will continue to `yield` items indefinitely. Each call to `yield` in turn calls
    the observer’s `next`; finally, `return` (implicit or explicit) calls `complete`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在处理数组，它们是相对简单的事件源。但是，当我们开始处理异步、可能无限的数据源，如异步生成器时，情况就变得复杂了。在`Observable.of(1,2,3)`代替之前，它充当了我们之前展示的操作的流源，我们可以有一个生成器，在调用组合可观察对象的`subscribe`方法后，开始将值沿着链向下传递。流的无限性质在原则上与生成器的性质相似，即直到生成器返回，函数将无限期地继续`yield`项。每次`yield`调用都会依次调用观察者的`next`；最后，`return`（隐式或显式）调用`complete`。
- en: Hence, the generator produces events over time and decides how much data to
    push, the observable represents your business logic, and the subscriber consumes
    the resulting event value flowing through the observable. Using generators is
    a good way to experience how to subscribe to a potentially infinite data source
    like a DOM event listener or receiving messages from a WebSocket. With observables,
    processing events from any of these data sources will look exactly the same.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，生成器在一段时间内产生事件，并决定推送多少数据，可观察对象代表您的业务逻辑，而订阅者消费通过可观察对象流动的结果事件值。使用生成器是体验如何订阅可能无限的数据源（如DOM事件监听器或从WebSocket接收消息）的好方法。使用可观察对象，处理来自这些数据源的事件将看起来完全相同。
- en: 9.4.5 Representing push streams with generators
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.5 使用生成器表示推送流
- en: Generators create an interesting opportunity to use streams programming, because
    you can generate arbitrary amounts of data and feed it to the observables all
    at the same time or in chunks. Previously, we dealt with examples that lifted
    an array of values into an observable. Now we need to be able to lift a generator
    function into the observable. To onboard a generator function, we’ll create a
    simple, homegrown constructor function.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器为使用流编程提供了有趣的机会，因为您可以生成任意数量的数据，并一次性或分块地将它们馈送到可观察对象中。之前，我们处理了将值数组提升到可观察对象的示例。现在，我们需要能够将生成器函数提升到可观察对象中。为了引入生成器函数，我们将创建一个简单、自制的构造函数。
- en: Listing 9.26 defines a new static function, `Observable.fromGenerator`. This
    function takes a normal generator or an async generator. We’re going to use Node.js’s
    `stream.Readable` API to abstract over the generator function with consistent
    behavior. This API is ideal because it uses an event emitter internally to fire
    events when new data is available. When the generator yields new values, `Readable`
    fires an event that is pushed to any subscribers that are listening. We’ll create
    a one-to-one mapping between the data and end events and the `next` and `complete`
    observer methods, respectively. The use of the bind operator syntax (introduced
    in chapter 5) makes this mapping elegant and terse, because you can pass the bound
    methods directly as named functions as callbacks to those events.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.26 定义了一个新的静态函数，`Observable.fromGenerator`。这个函数接受一个普通生成器或异步生成器。我们将使用 Node.js
    的 `stream.Readable` API 来抽象生成器函数，以保持一致的行为。这个 API 是理想的，因为它内部使用事件发射器来在数据可用时触发事件。当生成器产生新值时，`Readable`
    会触发一个事件，并将其推送到任何正在监听的事件订阅者。我们将创建数据与结束事件以及 `next` 和 `complete` 观察者方法之间的一对一映射。使用第
    5 章中引入的绑定操作符语法使得这种映射既优雅又简洁，因为你可以直接将绑定方法作为命名函数作为回调传递给这些事件。
- en: Listing 9.26 Constructing `Observables` from a generator
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.26 从生成器构造 `Observables`
- en: '[PRE44]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ❶ Instantiates a Readable stream from a generator object
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从生成器对象实例化一个 Readable 流
- en: ❷ Passes the event value directly to the bound observer’s next method
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 直接将事件值传递给绑定观察者的 `next` 方法
- en: ❸ When the stream has ended (generator returns), notifies the observer that
    the stream has completed
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 当流结束（生成器返回）时，通知观察者流已完成
- en: Let’s put this new constructor into action with the example shown in the next
    listing.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个新的构造函数通过下面的示例列表来实际应用。
- en: Listing 9.27 Initialzing an observable with a generator function
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.27 使用生成器函数初始化可观察对象
- en: '[PRE45]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This code would work exactly the same way if `words()` were an async generator
    (`async` `function*` `words`). Time is the undercurrent of a stream, and if the
    events are separated by seconds or nanoseconds, the programming model is the same.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `words()` 是一个异步生成器（`async function* words`），这段代码将完全以相同的方式工作。时间是流的潜流，如果事件由秒或纳秒分隔，编程模型是相同的。
- en: 'Now we have a static constructor operator that lifts any generator function
    and a few operators to process events. Let’s tackle a more complex example with
    these tools. Back in listing 9.8, we wrote code that validated a stream of blocks
    read from a file. Here’s that code again:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个静态构造器操作符，可以将任何生成器函数和一些处理事件的操作符提升。让我们用这些工具解决一个更复杂的例子。回到列表 9.8，我们编写了验证从文件中读取的块流代码。这是那段代码的再次展示：
- en: '[PRE46]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Using the small reactive extensions toolkit we’ve built so far, we can tackle
    this rather complex imperative logic and take advantage of the declarative, functional
    API that observables promote. When you compare the two listings, you’ll see the
    dramatic improvement in code readability. Listing 9.28 makes the following key
    changes:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们迄今为止构建的小型响应式扩展工具包，我们可以处理这个相当复杂的过程式逻辑，并利用可观察对象促进的声明式、函数式 API。当你比较这两个列表时，你会看到代码可读性的显著提高。列表
    9.28 做了以下关键更改：
- en: Refactors the skip logic at the beginning of the loop using `skip`
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `skip` 重构循环开头的跳过逻辑
- en: Moves block creation logic into a different function and calls it by using `map`
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将块创建逻辑移动到不同的函数中，并使用 `map` 来调用它
- en: Uses `filter` to emit only the valid blocks
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `filter` 仅发射有效的块
- en: Listing 9.28 Validating a stream of blocks using observables
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.28 使用可观察对象验证块流
- en: '[PRE47]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: ❶ Skips the first block (genesis)
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 跳过第一个块（创世块）
- en: ❷ Adds block to chain (needed for validation algorithm)
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将块添加到链中（用于验证算法）
- en: ❸ Validates block
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 验证块
- en: ❹ Keeps only valid blocks
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 仅保留有效的块
- en: ❺ The successful validation result is mapped to a number (Success = 1 | Failure
    = 0), so it can be added up in the next step.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将成功的验证结果映射为一个数字（成功 = 1 | 失败 = 0），以便在下一步中累加。
- en: ❻ Adds total valid blocks
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 添加总有效块数
- en: Listing 9.28 instantiates a source observable `validBlocks$` from a generator.
    This variable holds a specification of your program. I use the word specification
    because the observable captures your intent declaratively into an object whose
    logic hasn’t yet executed. It starts by skipping the genesis block; then it maps
    a couple of business logic functions needed to validate; finally, it counts only
    blocks for which `Validation` returned successfully. This logic is simpler to
    parse, declarative, and point-free, and your code is much more modular than before.
    Also, you get error handling for free through the `Observer`’s `error` method.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.28 从生成器中实例化源可观察对象`validBlocks$`。这个变量持有你程序的规范。我使用“规范”这个词，因为可观察对象将你的意图声明性地捕获到一个尚未执行逻辑的对象中。它首先跳过创世块；然后映射几个用于验证的业务逻辑函数；最后，只计算`Validation`成功返回的块。这种逻辑更容易解析，是声明性的，无参数的，而且你的代码比以前更模块化。此外，你还可以通过`Observer`的`error`方法免费获得错误处理。
- en: 'We can optimize this code even more. Can you spot where? If you recall the
    `map`/ `compose` equivalence, you’ll remember that you can fuse multiple calls
    to `map` into a single call by using `compose`. I’m going to show only the `Observable`
    declaration, for brevity:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以进一步优化这段代码。你能找到优化点在哪里吗？如果你还记得`map`/`compose`等价性，你会记得你可以通过使用`compose`将多个对`map`的调用融合成一个单一的调用。为了简洁，我将只展示`Observable`的声明：
- en: '[PRE48]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This version is simpler to visualize. Figure 9.9 shows how a complex algorithm
    can be converted to a stepwise application of functions.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本更容易可视化。图9.9展示了如何将复杂算法转换为逐步应用函数。
- en: '![](../Images/9-9.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9-9.png)'
- en: Figure 9.9 Validating blocks by using streams
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 使用流验证块
- en: 'Furthermore, I mentioned that observables have built-in error handling. For
    the sake of completeness, here’s a simple example of how errors are handled. When
    an exception occurs anywhere in your pipeline, the error object propagates downstream
    to the last observer and triggers the `error` method:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我提到过可观察对象有内置的错误处理机制。为了完整性，这里有一个简单的错误处理示例。当你的管道中任何地方发生异常时，错误对象会向下传播到最后一个观察者并触发`error`方法：
- en: '[PRE49]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As you’ll recall from chapter 5, ADTs also skip business logic when validation
    fails so that you can handle the error from a single location, as the next listing
    shows.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如你从第5章回忆的那样，ADTs在验证失败时也会跳过业务逻辑，这样你就可以从单个位置处理错误，就像下一个列表所示。
- en: Listing 9.29 Skipping mapped functions on `Validation.Failure`
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.29 在`Validation.Failure`上跳过映射函数
- en: '[PRE50]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: ❶ Returns 'Success (J)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 返回 'Success (J)'
- en: ❷ Skips toUpper function and returns 'Failure (Expected non-null value)'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 跳过toUpperCase函数并返回 'Failure (Expected non-null value)'
- en: Once again, the comparison of observables and ADTs is uncanny, which is why
    it was so important to understand ADTs before observables.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，可观察对象和ADTs的比较非常奇特，这就是为什么在了解可观察对象之前理解ADTs如此重要的原因。
- en: Let’s talk a bit more about operators. A library like RxJS will provide an arsenal
    of operators for most of your needs, if not all of them. In the years I’ve worked
    with it, I’ve rarely needed to add my own operator, but it’s good to know that
    the library is extensible in this way. These operators are designed to accept
    observables as input and return new observables, which is why they are called
    pipeable operators.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再谈谈操作符。像RxJS这样的库将为你的大多数（如果不是所有）需求提供一系列操作符。在我使用它的这些年里，我很少需要添加自己的操作符，但了解库以这种方式是可扩展的总是好的。这些操作符被设计为接受可观察对象作为输入并返回新的可观察对象，这就是为什么它们被称为可管道操作符。
- en: 9.4.6 Pipeable operators
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.6 可管道操作符
- en: Observable operators are also known as pipeable functions—functions that take
    an observable as input and return another observable. You’ve seen how these functions
    are executed through composition and fluent chaining. In the near future, you
    will be able to synthesize observables with the pipeline syntax (`|>`) natively
    in pure, idiomatic, vanilla JavaScript without the help of any combinator functions,
    as shown in the next listing.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察对象操作符也被称为可管道函数——这些函数接受一个可观察对象作为输入并返回另一个可观察对象。你已经看到了这些函数是如何通过组合和流畅链式调用执行的。在不久的将来，你将能够使用管道语法（`|>`）在纯、惯用、普通的JavaScript中本地合成可观察对象，而不需要任何组合函数的帮助，就像下一个列表所示。
- en: Listing 9.30 Combining observables with the new pipeline operator
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.30 使用新的管道操作符组合可观察对象
- en: '[PRE51]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: ❶ Prints the value 20 to the console
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将值20打印到控制台
- en: Now we’re really kicking into hyperstream! But wait. Instead of a simple number
    sequence, what would happen if the data were asynchronous? Would the model break?
    Absolutely not. This code
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们真正进入了超流状态！但是等等。如果数据是异步的，会发生什么？模型会崩溃吗？绝对不会。这段代码
- en: '[PRE52]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: prints
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 打印
- en: '[PRE53]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In this case, the observable and promises provide the right level of abstraction
    so that you can deal with time or latency as though it didn’t exist. This code
    prints the right result and in the right order.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，可观察对象和承诺提供了正确级别的抽象，您可以像处理不存在的时间或延迟一样处理它们。这段代码打印了正确的结果，并且按照正确的顺序打印。
- en: 'Alternatively, you can use bind (`::`) syntax to perform method extraction
    from our catalog of reactive extension methods. Here’s that object again with
    `map`:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用绑定（`::`）语法从我们的反应扩展方法目录中提取方法。这里再次使用 `map` 的那个对象：
- en: '[PRE54]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: With the bind operator, we can control the binding of `this`, much as we would
    a virtual method. The next listing shows the same program as listing 9.30.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 使用绑定运算符，我们可以控制 `this` 的绑定，就像我们处理虚拟方法一样。下一个列表显示了与列表 9.30 相同的程序。
- en: Listing 9.31 Combining observables with the new bind operator
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.31 使用新绑定运算符组合可观察量
- en: '[PRE55]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: ❶ this points to the source observable Observable.of(1, 2, 3, 4).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `this` 指向源可观察量 `Observable.of(1, 2, 3, 4)`。
- en: ❷ Each function’s this will be set to the preceding observable source.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 每个函数的 `this` 将设置为前一个可观察源。
- en: ❸ Prints 20 to the console
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 打印 20 到控制台
- en: In this snippet of code, `Observable.of``(...)`becomes the `this` reference
    in `skip`, creating a new `this` reference in `filter`, and so on. It’s simple
    to see how a collection of elements or a generation function can be converted
    to a stream, but what about custom objects?
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码片段中，`Observable.of(...)` 成为 `skip` 中的 `this` 引用，在 `filter` 中创建一个新的 `this`
    引用，依此类推。很容易看出如何将元素集合或生成函数转换为流，但对于自定义对象又该如何处理呢？
- en: 9.4.7 Streamifying objects
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.7 对象流化
- en: In chapter 8, you learned that you can create iterable objects or async iterable
    objects by implementing the built-in `Symbol.iterator` or `Symbol.asyncIterator`,
    respectively. These symbols allow objects to be enumerated by a `for...of` loop.
    It would be nice if you could do something similar so that you can treat an object
    like an `Observable`. This capability would allow us to treat any custom object
    in our program as an observable and enjoy all the nice capabilities I have been
    describing, such as composition, powerful operators, declarative API, and built-in
    error handling.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 8 章中，您学习了可以通过实现内置的 `Symbol.iterator` 或 `Symbol.asyncIterator` 分别创建可迭代对象或异步可迭代对象。这些符号允许对象通过
    `for...of` 循环进行枚举。如果您能够以类似的方式处理对象，使其像 `Observable` 一样处理，那就太好了。这种能力将使我们能够将程序中的任何自定义对象视为可观察对象，并享受我一直在描述的所有优秀功能，例如组合、强大的运算符、声明式
    API 和内置错误处理。
- en: 'It turns out that we can. The TC39 observable specification proposes the addition
    of another well-known function-valued symbol: `Symbol.observable` `(@@observable`
    for short). The semantics are consistent with those of other symbols. This new
    symbol works in conjunction with `Observable.from` to lift any custom objects
    that need to be interpreted as observables. The symbol follows a couple of rules:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明我们可以。TC39 可观察规范建议添加另一个已知函数值符号：`Symbol.observable`（简称 `@@observable`）。其语义与其他符号一致。这个新符号与
    `Observable.from` 一起工作，将任何需要解释为可观察对象的自定义对象提升。该符号遵循以下规则：
- en: If the object defines `Symbol.observable`, `Observable.from` returns the result
    of invoking that method. If the return value is not an instance of `Observable`,
    it’s wrapped as one.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对象定义了 `Symbol.observable`，则 `Observable.from` 返回调用该方法的返回值。如果返回值不是 `Observable`
    的实例，则将其包装为一个实例。
- en: If `Observable.from` can’t find the special symbol, the argument is interpreted
    as an iterable, and the iteration values are delivered synchronously when `subscribe`
    is called—a sensible fallback.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `Observable.from` 找不到特殊符号，则将参数解释为可迭代对象，当调用 `subscribe` 时，迭代值将同步传递——这是一个合理的后备方案。
- en: I’ll show a couple of examples now, beginning with adding `Symbol.observable`
    to our custom `Pair` object in the next listing. I’ll omit the other symbols and
    properties.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在将展示几个示例，首先是向下一个列表中的自定义 `Pair` 对象添加 `Symbol.observable`。我将省略其他符号和属性。
- en: Listing 9.32 Adding `@@observable` to `Pair`
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.32 向 `Pair` 添加 `@@observable`
- en: '[PRE56]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '❶ Because Pair’s @@observable property returns an Observable object, the source
    becomes the result of invoking it. It prints Pair element: 20 and Pair element:
    30'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 因为 Pair 的 `@@observable` 属性返回一个可观察对象，所以源成为调用它的结果。它打印 Pair 元素：20 和 Pair 元素：30
- en: A `Blockchain` can also become a stream of blocks. Any time a new block is added
    to the chain, it pushes into the stream, and any subscribers are notified. The
    next listing shows a similar configuration to the `PushArray` example in section
    9.3.2.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`Blockchain` 也可以成为区块的流。每当链中添加新区块时，它就会推入流中，并且任何订阅者都会收到通知。下一列表显示了与 9.3.2 节中的
    `PushArray` 示例类似的配置。'
- en: Listing 9.33 Streaming blocks in a blockchain
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.33 区块链中的流式传输区块
- en: '[PRE57]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: ❶ Notifies listeners of a new block
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通知监听器有新的区块
- en: ❷ Invokes Blockchain’s @@iterator to enumerate the current list of blocks
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 调用 Blockchain 的 @@iterator 来枚举当前区块列表
- en: ❸ Upon receiving new block, pushes it into the stream
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 接收到新区块时，将其推入流
- en: One thing to note about this logic is that it never calls `observer.complete`.
    It’s infinite. Subscribers need to `unsubscribe` when they no longer want to receive
    new data, as shown in the next listing.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个逻辑需要注意的一点是，它永远不会调用 `observer.complete`。它是无限的。当订阅者不再想接收新数据时，需要 `unsubscribe`，如下一列表所示。
- en: Listing 9.34 Subscribing to and unsubscribing from a reactive `Blockchain` object
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.34 订阅和取消订阅响应式的 `Blockchain` 对象
- en: '[PRE58]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: ❶ Passes the blockchain object directly to the constructor
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 直接将区块链对象传递给构造函数
- en: ❷ Later pushes a third block, which will print its hash to the console
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 之后推送第三个区块，它将打印其哈希到控制台
- en: ❸ Need to unsubscribe to finalize the stream
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 需要取消订阅以最终化流
- en: 'If you run this code, the printout should look like the following:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这段代码，输出应该看起来像以下这样：
- en: '[PRE59]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Suppose that you push a fourth block into the chain with an invalid index this
    time:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这次你将一个无效索引的第四个区块推入链中：
- en: '[PRE60]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Then you’ll see
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你会看到
- en: '[PRE61]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Allowing `Blockchain` to be treated as a stream gives you automatic reactive
    capabilities, which means you can connect other parts of your application that
    subscribe to receive notifications when new blocks are added to the chain. This
    example is a simple implementation, but it’s not far from a real-world scenario
    in which other servers (nodes) in the blockchain network can subscribe to receive
    push notifications when a new block is mined in any of the peer nodes.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 允许 `Blockchain` 被视为流，这会给你自动的响应式能力，这意味着你可以连接应用程序的其他部分，当链中添加新区块时，它们会订阅以接收通知。这个例子是一个简单的实现，但它并不远离现实世界的场景，在区块链网络中的其他服务器（节点）可以订阅以接收当任何对等节点挖掘新区块时的推送通知。
- en: We added quite a bit of code to make the `Blockchain` class reactive. The good
    news is that most of this behavior relied on symbols, allowing us to extract this
    code into a separate module and use metaprogramming techniques (chapter 7) to
    augment objects by hooking into these symbols. This module can be implemented
    as a proxy to make any iterable object reactive.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了大量代码来使 `Blockchain` 类变得响应式。好消息是，大多数这种行为依赖于符号，这使得我们可以将这段代码提取到一个单独的模块中，并使用元编程技术（第
    7 章）通过挂钩这些符号来增强对象。这个模块可以作为代理使任何可迭代的对象变得响应式。
- en: 9.4.8 Dynamic streamification
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.8 动态流化
- en: In chapter 7, we used a `Proxy` to implement a smart block—a block that automatically
    recomputes its own hash when any of its fields changes. In this section, we’ll
    use a similar technique to make `Blockchain` a reactive data structure without
    adding a single line of code. The code is complex so I’ve divided it into a couple
    of functions. The following listing shows the overall layout.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 7 章，我们使用 `Proxy` 实现了一个智能区块——一个当其任何字段发生变化时自动重新计算其哈希的区块。在本节中，我们将使用类似的技术使 `Blockchain`
    成为响应式数据结构，而不需要添加一行代码。代码很复杂，所以我将其分成了几个函数。以下列表显示了整体布局。
- en: Listing 9.35 High-level structure of the `reactive` function
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.35 `reactive` 函数的高级结构
- en: '[PRE62]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Instead of adding all that observable scaffolding to `Blockchain`, we can define
    our own `Push` proxy to inject this behavior at runtime and keep things nicely
    separated. The proxy handler object requires objects to declare a `push` method,
    which `Blockchain` does. This code can make any pushable data structure reactive:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要将所有可观察的脚手架添加到 `Blockchain` 中，我们可以定义自己的 `Push` 代理来在运行时注入这种行为，并保持事物分离。代理处理对象需要对象声明一个
    `push` 方法，`Blockchain` 就是这样做的。这段代码可以使任何可推送的数据结构变得响应式：
- en: '[PRE63]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Next, let’s implement `pushProxy` in the next listing. This proxy will trap
    any calls to `push` and automatically augment its behavior to emit the value passed
    in.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在下一列表中实现 `pushProxy`。这个代理将拦截对 `push` 的任何调用，并自动增强其行为以发出传入的值。
- en: Listing 9.36 Using a proxy object to trap calls to `push`
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.36 使用代理对象拦截对 `push` 的调用
- en: '[PRE64]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: ❶ Spread operator to capture all the arguments. The first element is the target
    object, and the second is the property key.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 扩展运算符用于捕获所有参数。第一个元素是目标对象，第二个是属性键。
- en: ❷ Executes push normally and captures its result
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 正常执行推送并捕获其结果
- en: ❸ Emits the pushed object
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 发出推送的对象
- en: With the `push` behavior defined, the last task is implementing the observable
    logic. This logic listens for push events and notifies its subscribers. Also,
    every time you instantiate this observable, it emits (replays) any objects the
    data structure currently has. In listing 9.37, I’ve taken the liberty of adding
    some logging, using the new console APIs `console.group` and `console.groupEnd`,
    which I think will make tracing the data flow easier. I’ve struggled with this
    task myself, especially in complicated and intertwined pipelines, so the additional
    logging helps.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了`push`行为后，最后一项任务是实现可观察逻辑。这个逻辑监听推送事件并通知其订阅者。此外，每次实例化这个可观察量时，它都会发出（重放）数据结构当前拥有的任何对象。在列表9.37中，我大胆地添加了一些日志，使用了新的控制台API
    `console.group`和`console.groupEnd`，我认为这将使追踪数据流更容易。我自己也为此任务奋斗过，尤其是在复杂且相互交织的管道中，所以额外的日志很有帮助。
- en: Listing 9.37 Implementing `@@observable` to make any object behave like a stream
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.37 实现了`@@observable`以使任何对象表现得像流
- en: '[PRE65]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: ❶ Declares the Symbol.observable so you can pass this object works with Observable.from
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 声明Symbol.observable，这样你可以传递这个对象与Observable.from一起使用
- en: ❷ Creates an outer logging group label for the entire duration of the stream.
    Any logs within this group are intended for better visibility.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在整个流的过程中创建一个外部日志组标签。此组内的任何日志都旨在提高可见性。
- en: ❸ Creates an inner level of indentation to handle every push sequence in a different
    level
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建一个内部缩进级别，以处理不同级别的每个推送序列
- en: ❹ Creates an outer logging group label for the entire duration of the stream.
    Any logs within this group are intended for better visibility.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在整个流的过程中创建一个外部日志组标签。此组内的任何日志都旨在提高可见性。
- en: 'Now that we have the components we need, let’s compose them. The result is
    a proxied object decorated with `Symbol.observable` so that the `Observable` API
    can interoperate with it. Because `Object.assign` copies symbols as well, let’s
    use it:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了所需的组件，让我们将它们组合起来。结果是带有`Symbol.observable`的代理对象，这样`Observable` API就可以与之交互。由于`Object.assign`也会复制符号，让我们使用它：
- en: '[PRE66]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The easy part is streamifying objects that have push/iterator behavior. Example
    are `Array` and `Blockchain`. To keep things simple, let’s use an array:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的部分是将具有推送/迭代行为的对象流化。例如`Array`和`Blockchain`。为了保持简单，让我们使用一个数组：
- en: '[PRE67]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This code flow is easy to follow. If you were to add logging statements to
    `isEven` and `square`, the output of this program would look something like this
    (the logging enhancements help us read the output):'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码流程易于理解。如果你要在`isEven`和`square`中添加日志语句，这个程序的输出将类似于这样（日志增强有助于我们阅读输出）：
- en: '[PRE68]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'With this function, we can write the same code as before with a much leaner
    `Blockchain` class:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个函数，我们可以用更简洁的`Blockchain`类写出之前的相同代码：
- en: '[PRE69]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This chapter is the extent of this book’s coverage of observables. The goal
    was to give you a taste of this programming model, which without a doubt will
    change the way you write JavaScript applications. The way that JavaScript’s event
    loop operates allows us to raise the level of abstraction seamlessly from an array
    to iterators to generators to async generators and now to observables, creating
    the perfect architecture for the language.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了本书对可观察量的讨论范围。目标是让你对这种编程模型有一个初步的了解，毫无疑问，这将改变你编写JavaScript应用程序的方式。JavaScript的事件循环操作方式使我们能够无缝地从数组到迭代器、生成器、异步生成器，现在再到可观察量，从而为语言创造出一个完美的架构。
- en: Want to dive deep into streams and observables?
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 想深入了解流和可观察量吗？
- en: The behavior implemented in the preceding snippet is known as a cold observable.
    Observables are said to be cold when elements are produced inside the observable
    itself. In this case, the observable will replay all the events to new subscribers.
    By contrast, hot observables occur when the data is produced outside the observable
    itself, such as from a WebSocket. In such a case, it would be impossible to replay
    packets that have already been transmitted without additional infrastructure and
    code.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中实现的行为被称为冷观察者。当观察者内部产生元素时，观察者被称为冷。在这种情况下，观察者将重新播放所有事件给新的订阅者。相比之下，热观察者发生在数据在观察者外部产生时，例如来自WebSocket。在这种情况下，没有额外的基础设施和代码，将无法重新播放已传输的数据包。
- en: If you’d like to dive deeper this topic, check out *RxJS in* Action ([http://mng.bz/E21j](http://mng.bz/E21j)),
    by Paul P. Daniels and Luis Atencio (Manning, 2017). This book discusses streams
    and observables from theoretical and practical standpoints, using RxJS 5 to showcase
    these concepts.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要深入了解这个主题，请查看Paul P. Daniels和Luis Atencio所著的*RxJS in Action ([http://mng.bz/E21j](http://mng.bz/E21j))，由Manning出版社，2017年出版)。这本书从理论和实践的角度讨论了流和观察者，使用RxJS
    5来展示这些概念。
- en: In this chapter, the techniques I have shown you throughout this book come together,
    from functional style currying and composition to ADTs to iterables and generators
    and to the abstraction of time. All those techniques lead us to a model of programming
    that could not be better suited to observables. Making observables part of ECMAScript
    will allow platforms, frameworks, and applications to share a push-based stream
    protocol.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我在整本书中向你展示的技术汇聚在一起，从函数式风格的柯里化和组合到ADT，再到可迭代器和生成器，以及时间的抽象。所有这些技术都引导我们到一个非常适合观察者的编程模型。将观察者纳入ECMAScript将允许平台、框架和应用程序共享基于推送的流协议。
- en: 9.5 Closing thoughts
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5 总结思考
- en: This book presented a whirlwind of JavaScript topics but only scratched the
    surface of what you can do with the language now, as well as what lies ahead.
    I hope that the topics you learned here will guide and inspire you to explore
    different ways of problem solving, but always consistently within the framework
    of the paradigms you use. Employ these techniques wisely, and use the right tool
    for the job. For teaching purposes, I presented lots of techniques, patterns,
    and paradigms in the same application. This approach was purely didactical. I
    expect you to cherry-pick the techniques that make sense for the type of application
    you are building and what’s best for the problem you are solving.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 本书呈现了一系列JavaScript主题，但只是触及了你可以用这门语言做什么的表面，以及未来可能发生的事情。我希望你在本学到的主题能引导和激发你探索不同的解决问题的方式，但始终在使用的范式框架内保持一致。明智地运用这些技术，并使用适合工作的正确工具。出于教学目的，我在同一个应用程序中展示了大量的技术、模式和范式。这种方法纯粹是教学性的。我期望你挑选出适合你正在构建的应用程序类型和最适合你正在解决的问题的技术。
- en: Strolling down memory lane, we began by inspecting JavaScript’s object and prototyped
    inheritance model. You can take advantage of this object-oriented system to create
    the objects that capture the state of your application. Then you learned how functional
    programming can help you implement the business logic in a pure and composable
    way. By reducing mutation and side effects, and by harnessing the power of closures
    and higher-order functions, you can get rid of nasty bugs that can afflict even
    the best-tested business logic.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 漫步在记忆的长河中，我们首先检查了JavaScript的对象和原型继承模型。你可以利用这个面向对象系统来创建捕获应用程序状态的对象。然后你学习了函数式编程如何帮助你以纯净和可组合的方式实现业务逻辑。通过减少突变和副作用，并利用闭包和高阶函数的力量，你可以摆脱甚至最好的业务逻辑测试中可能出现的讨厌的bug。
- en: With these two foundations in place, you learned how to organize your code into
    fine-grained, reusable modules by using a functional and orthogonal architecture.
    You also set clear boundaries that separate cross-cutting logic (logging, tracing,
    policies, and so on) with metaprogramming.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个基础建立之后，你学习了如何通过使用函数性和正交架构将代码组织成细粒度、可重用的模块。你还设定了清晰的边界，将跨切逻辑（日志记录、跟踪、策略等）与元编程分开。
- en: 'Finally, after looking at data and functions, you tackled another dimension:
    time. Data can arrive in many form factors and from different locations. Asynchronous
    programming with promises and observables can erase data locality and simplify
    how you handle different types of data, using a consistent set of APIs and programming
    models.'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在查看数据和函数之后，你解决了另一个维度：时间。数据可以以多种形式从不同的位置到达。使用承诺和观察者的异步编程可以消除数据局部性，并简化你处理不同类型数据的方式，使用一致的API和编程模型。
- en: It’s important to realize that JavaScript has a unique challenge as the language
    of the web. It needs to not only remain relevant with modern programming idioms
    that developers want, but also continue to be the standardizing body for programming
    the web as a whole. These two forces are often at odds, and it’s not sensible
    to add every possible API natively to the language. As exciting as it is to use
    new and shiny features, we need to balance this novelty with the need to not bloat
    the core modules that are downloaded over the network. There’s still a strong
    preference for a canonical, bare JavaScript language, one with a small kernel
    into which you can plug APIs such as `Promise`, `Proxy`, `Reflect`, and even `Observable`.
    We’ll have to wait to see whether the JavaScript standard libraries continue to
    grow and whether a modular kernel is in the works so that you can download or
    import only the pieces of JavaScript that you need.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要认识到，JavaScript作为网络语言具有独特的挑战。它不仅需要与开发者想要的现代编程习惯保持相关，而且还需要继续作为整个网络编程的标准化机构。这两个力量往往是相互矛盾的，将每个可能的API原生化地添加到语言中并不合理。虽然使用新而闪亮的功能令人兴奋，但我们需要在创新性与不使通过网络下载的核心模块膨胀之间取得平衡。仍然强烈倾向于一个规范、裸JavaScript语言，它有一个小内核，你可以将API如`Promise`、`Proxy`、`Reflect`甚至`Observable`插入其中。我们将不得不等待看看JavaScript标准库是否会继续增长，以及是否有一个模块化内核正在开发中，这样你就可以下载或导入你需要的JavaScript部分。
- en: Our journey ends here. In closing, I’d like to urge each of you to fund your
    favorite NPM library or contribute to it. We rely on open source now more than
    ever, and open source is the main avenue for innovation. JavaScript itself is
    evolving in the open. Open source is where tried and tested new ideas come to
    fruition. ECMAScript Modules, promises, and observables all originated from open
    source libraries before becoming official standards, for example.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的旅程在这里结束。在结束之际，我想敦促你们每个人资助你最喜欢的NPM库或为其做出贡献。我们现在比以往任何时候都更依赖开源，开源是创新的主要途径。JavaScript本身也在公开环境中不断发展。开源是经过检验和测试的新想法得以实现的地方。例如，ECMAScript模块、承诺和观察者都是从开源库中起源，后来成为官方标准的。
- en: At age 25, JavaScript continues to be reimagined each year and reequipped to
    tackle the challenges of modern application development. What started as a typical
    object-oriented language is now being classified as a lambda language, according
    to experts like Douglas Crockford. The cloud is the limit. If all bets are on
    the table, I’d continue to bet on JavaScript and its future. I hope that reading
    this book gave you the same joy that writing it gave me!
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 25岁时，JavaScript每年都在重新构想，并重新装备以应对现代应用开发的挑战。根据像Douglas Crockford这样的专家的说法，最初是一种典型的面向对象语言，现在被归类为lambda语言。云是极限。如果所有的赌注都放在桌面上，我会继续押注JavaScript及其未来。我希望阅读这本书给你带来的快乐和我写作它时一样！
- en: Summary
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: An Iterator object has the method `next`, which returns an object with properties
    `value` and `done`. `value` contains the next element in the iteration, and `done`
    is the control switch that stops the iteration process.
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器对象有一个`next`方法，它返回一个具有`value`和`done`属性的对象。`value`包含迭代中的下一个元素，而`done`是停止迭代过程的控制开关。
- en: An async iterator follows the same behavior as a normal iterator except that
    `next` returns a `Promise` with a result of the same shape `{value,` `done}.`
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步迭代器的行为与普通迭代器相同，除了`next`返回一个具有相同形状的结果的`Promise` `{value, done}`。
- en: To build custom enumerable objects, you can implement `Symbol.iterator`. You
    can also define `Symbol.asyncIterator` to enumerate the pieces of your objects
    asynchronously.
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要构建自定义可枚举对象，你可以实现`Symbol.iterator`。你还可以定义`Symbol.asyncIterator`以异步枚举你的对象的部分。
- en: Generators are a special type of function that can produce a sequence of values
    instead of a single value—a factory for iterables. A generator function is identified
    by an asterisk (`*`).
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器是一种特殊的函数，可以产生一系列值而不是单个值——迭代器的工厂。生成器函数通过星号（`*`）标识。
- en: A generator function returns a `Generator` object that implements the iterator
    protocol, which means you can consume it by using the `for...of` loop.
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器函数返回一个实现了迭代协议的 `Generator` 对象，这意味着你可以通过使用 `for...of` 循环来消费它。
- en: The difference between a normal generator and an async generator is that generated
    values are wrapped by a `Promise`. To consume an async generator, you can use
    the `for` `await...of` loop.
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正常生成器和异步生成器之间的区别在于生成的值被一个 `Promise` 包裹。要消费异步生成器，你可以使用 `for` `await...of` 循环。
- en: Streams are sequences of values emitted over time. Anything can become a stream,
    such as a single value, an array, or a generator function. Anything that is iterable
    can be modeled as a stream.
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流是随时间发出值的序列。任何东西都可以成为流，比如单个值、数组或生成器函数。任何可迭代的都可以被建模为流。
- en: The new `Observable` API proposes to make stream-based, reactive programming
    easier.
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的 `Observable` API 提出使基于流的、响应式编程更容易。
- en: Observables are push-based, declarative streams. Their programming model is
    based on publish/subscribe. Observables are agnostic to the type of data in the
    sequence and to whether the data is synchronous or asynchronous; the programming
    model is the same.
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观察者是基于推送的、声明式的流。它们的编程模型基于发布/订阅。可观察者对序列中的数据类型以及数据是同步还是异步无关紧要；编程模型是相同的。
- en: You can create and augment your own observable objects by implementing a function-valued
    `Symbol.observable` property.
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过实现一个函数值的 `Symbol.observable` 属性来创建和增强你自己的可观察对象。
