- en: 2 Julia as a calculator
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 Julia作为计算器
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Working with integers, floating-point numbers, and fractions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理整数、浮点数和分数
- en: Using variables to store long numbers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用变量存储长数字
- en: Creating reusable calculations by defining functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过定义函数创建可重用的计算
- en: The most basic types in Julia
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia中最基本的类型
- en: Even if you never end up using Julia as your primary language, you may still
    value it as a replacement for your desk calculator. Julia can even double as an
    advanced high-school graphing calculator (figure 2.1). As a bonus, it’s completely
    free to use.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你最终没有将Julia作为你的主要语言，你也可能仍然将其视为桌面计算器的替代品。Julia甚至可以充当高级高中图形计算器（图2.1）。作为额外的好处，它是完全免费的。
- en: '![02-01](../Images/02-01.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![02-01](../Images/02-01.png)'
- en: Figure 2.1 Retro scientific calculator. Can we replace the usage of a handheld
    calculator with a Julia REPL?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1复古科学计算器。我们能否用Julia REPL来替代手持计算器的使用？
- en: Remember you have to walk before you can run, and exploring numbers is a great
    way to get introduced to the core concepts of Julia. Since Julia is not just a
    general-purpose programming language but specifically tailored towards numerical
    computing, manipulating numbers plays a unique role in Julia.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你必须先学会走路，然后才能跑步，探索数字是了解Julia核心概念的好方法。由于Julia不仅仅是一种通用编程语言，而且专门针对数值计算进行了定制，因此在Julia中操作数字扮演着独特的角色。
- en: In this chapter, you will look at the aspects of Julia that let you do the same
    kinds of things in Julia that you would do with a calculator. Of course, you may
    object that you don’t intend to use Julia as a calculator, but this is simply
    a way to give you the foundation to understand the more complex topics.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解Julia的各个方面，让你能够在Julia中做与使用计算器相同的事情。当然，你可能反对你并不打算将Julia用作计算器，但这仅仅是为了给你打下理解更复杂主题的基础。
- en: 2.1 The Julia command line
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 Julia命令行
- en: If you have Julia properly installed and configured (see appendix A), you can
    type Julia at your terminal prompt to start the Julia REPL. This interactive command-line
    program reads your input much like a calculator and prints out the result as soon
    as you hit enter. The REPL is a place for testing your code, looking up documentation,
    and installing third-party software.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经正确安装并配置了Julia（见附录A），你可以在终端提示符中输入Julia以启动Julia REPL。这个交互式命令行程序读取你的输入，就像计算器一样，并在你按下回车键后立即打印出结果。REPL是一个测试你的代码、查找文档和安装第三方软件的地方。
- en: 'In this chapter, you will focus on evaluating mathematical expressions in the
    REPL. The next code example demonstrates how to launch the Julia command line
    from the terminal (console) application. After it has launched, type in 2 + 3
    and hit enter. Julia evaluates this expression and prints 5:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将专注于在REPL中评估数学表达式。下一个代码示例演示了如何从终端（控制台）应用程序启动Julia命令行。启动后，输入2 + 3并按回车键。Julia评估这个表达式并打印出5：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can do far more complex operations than adding two single-digit numbers.
    In the next example, you perform some very common mathematical operations, including
    getting the logarithm, sine, and square root. rand is a mathematical function
    that evaluates to a random number between 0 and 1:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以执行比加两个一位数更复杂的操作。在下一个示例中，你将执行一些非常常见的数学运算，包括求对数、正弦和平方根。rand是一个数学函数，其结果是在0和1之间的随机数：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Complex expressions can be nested with parentheses.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 复杂表达式可以用括号嵌套。
- en: ❷ Exponents; taking two to the power of three
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 指数；求2的3次方
- en: ❸ The natural logarithm of 2.71, also known as Euler’s number e
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 2.71的自然对数，也称为欧拉数e
- en: ❹ Get sine of π/2 radians.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 获取π/2弧度的正弦值。
- en: ❺ The square root of 9
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 9的平方根
- en: ❻ Generate a random number from 0 to 1\.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 从0到1生成一个随机数。
- en: 2.2 Using constants and variables
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 使用常量和变量
- en: Remembering all the digits in numbers such as 3.1415926... (π) or 2.71828...
    (Euler’s number *e*) is tedious. In fact, it is impossible, since both numbers
    are what we call *irrational numbers*, which means they have an *infinite* number
    of digits. Therefore, it is much better to give each number a name—or, to be more
    accurate, an *identifier*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆像3.1415926...（π）或2.71828...（欧拉数 *e*）这样的数字的所有位数是枯燥的。实际上，这是不可能的，因为这两个数都是我们所说的*无理数*，这意味着它们有*无限*的位数。因此，给每个数字一个名字——或者更准确地说，一个*标识符*会更好。
- en: Important *Variables* and *constants* define areas in memory in which values
    (data) are stored. Think of memory as a long list of numbered mailboxes, each
    holding a value. To avoid remembering the number of the mailbox containing a value,
    affix a named identifier. You can change the value of a variable after it has
    been created but not the value of a constant.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 重要 *变量* 和 *常量* 定义了内存中的区域，其中存储着值（数据）。将内存想象成一个长长的编号信箱列表，每个信箱都持有一个值。为了避免记住包含值的信箱编号，附加一个命名标识符。你可以在创建变量后更改其值，但不能更改常量的值。
- en: 'Identifiers can be used to give names to constants, variables, types, and functions
    in Julia. pi (π), golden (ϕ), and Euler’s number e are identifiers used to refer
    to numerical *constants*. Both constants and variables simplify remembering long,
    complicated numbers:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符可以用来给 Julia 中的常量、变量、类型和函数命名。pi (π)、golden (ϕ) 和欧拉数 e 是用来引用数值 *常量* 的标识符。常量和变量简化了记忆长而复杂的数字：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ You can make common mathematical constants available to Julia. pi is always
    available, but the others are not.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 你可以使常见的数学常量在 Julia 中可用。pi 总是可用的，但其他常量则不是。
- en: ❷ Euler’s number is commonly used with logarithms.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 欧拉数通常与对数一起使用。
- en: ❸ The golden ratio is often used in the arts for aesthetic reasons and appears
    in nature, such as the spiral arrangement of leaves.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 黄金比例经常用于艺术中的美学原因，并在自然界中存在，例如叶子的螺旋排列。
- en: ❹ Catalan’s constant
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ Catalan 常数
- en: 'With these constants, it becomes more convenient to write mathematical expressions.
    You also get more accurate results because it isn’t possible to write *e* or π
    with enough digits. These are irrational numbers with an infinite number of digits.
    Mathematicians don’t actually know if Catalan’s number is irrational, but it is
    modeled as an irrational number in Julia:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些常量，编写数学表达式变得更加方便。你还会得到更准确的结果，因为无法用足够的数字来表示 *e* 或 π。这些是无理数，具有无限多位数字。数学家实际上不知道
    Catalan 的数是否是无理数，但在 Julia 中它被建模为无理数：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You are, however, not limited to using built-in constants. You can define your
    own in Julia with the const keyword and use them in calculations instead of number
    literals:^([1](#pgfId-1012656))
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你并不局限于使用内置常量。你可以在 Julia 中使用 const 关键字定义自己的常量，并在计算中使用它们而不是数字字面量：^([1](#pgfId-1012656))
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You might be wondering about the funny-sounding names foo, bar, and qux. These
    are nonsense words commonly used in code examples to inform the reader that they
    can pick *whatever* word they like in this case. These are different from words
    like if, while, const and function, which are reserved words; you are not allowed
    to use them as variable names.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道那些听起来很奇怪的名称 foo、bar 和 qux。这些是常用在代码示例中的无意义词汇，用来告知读者在这种情况下他们可以随意选择 *任何*
    词汇。这些与像 if、while、const 和 function 这样的保留词不同；你不允许将它们用作变量名。
- en: When writing Julia identifiers, you can mix and match cases. foObAr and FOObar
    are equally valid. But Julia is case sensitive, so they will be treated as *different*
    identifiers.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写 Julia 标识符时，你可以混合使用大小写。foObAr 和 FOObar 都是有效的。但是 Julia 是区分大小写的，所以它们将被视为 *不同的*
    标识符。
- en: Tip Julia’s identifiers are case sensitive. foo, Foo, and FOO will not be treated
    as the same identifiers by Julia. That is standard practice in most modern programming
    languages today.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：Julia 的标识符是区分大小写的。foo、Foo 和 FOO 不会被 Julia 视为相同的标识符。这是当今大多数现代编程语言的通用做法。
- en: You can add numbers as long as they are not at the start of the word. Thus f00bar
    is valid, but 1oobar is not. You should be used to similar rules from other programming
    languages.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 只要数字不是单词的开头，你就可以添加数字。因此 f00bar 是有效的，但 1oobar 是无效的。你应该习惯于来自其他编程语言的类似规则。
- en: Julia is unusual in its frequent use of Greek letters, such as π, θ, α, and
    Δ. The reason for this is that mathematics is usually written using Greek letters.
    When a mathematical equation is implemented in code, it becomes easier to read
    the code if it looks similar to the equation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 在频繁使用希腊字母方面很独特，例如 π、θ、α 和 Δ。这样做的原因是数学通常使用希腊字母书写。当数学方程在代码中实现时，如果代码看起来与方程相似，那么阅读代码会更容易。
- en: 'To accommodate this, the Julia creators built in special features in the Julia
    REPL and Julia editor plugins to make writing Greek letters and other Unicode
    characters easy. For example, in the REPL environment, you write a backslash,
    then you write the name of the character you want, and then you press tab:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应这一点，Julia的创建者在Julia REPL和Julia编辑器插件中内置了特殊功能，以便轻松编写希腊字母和其他Unicode字符。例如，在REPL环境中，你写一个反斜杠，然后写你想写的字符名，然后按Tab键：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After I hit the tab key, this turns into
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我按下Tab键后，这变成了
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The following is an overview of some popular Greek letters and Unicode characters
    you may like to use in your code, with some comments on what they usually mean.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些流行的希腊字母和Unicode字符的概述，你可能会想在代码中使用，以及一些关于它们通常含义的注释。
- en: '| Character | Tab Completion | Usage |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 字符 | 完成提示 | 用法 |'
- en: '| π | \pi | Circle equation |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| π | \pi | 圆的方程 |'
- en: '| θ | \theta | Angle |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| θ | \theta | 角度 |'
- en: '| Δ | \Delta | Difference or change in something |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| Δ | \Delta | 某物之间的差异或变化 |'
- en: '| *e* | \euler | Euler’s number (important in logarithms) |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| *e* | \euler | 欧拉数（对对数很重要）|'
- en: '| √ | \sqrt | Square root of a number |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| √ | \sqrt | 数字的平方根 |'
- en: '| ϕ | \varphi | The golden ratio |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| ϕ | \varphi | 黄金比例 |'
- en: 'What makes variables different from constants? Creating variables is very similar,
    except you don’t use the const keyword:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 变量与常量有什么不同？创建变量的过程非常相似，只是你不需要使用const关键字：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'So what exactly is the difference? This REPL interaction demonstrates the difference
    between variables and constants:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 那么究竟有什么区别呢？这个REPL交互演示了变量和常量之间的区别：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, you made x a constant and y a variable. Notice how Julia warns
    you that you are trying to change the value of a constant. While this may indeed
    work, Julia makes no guarantees it will, which is why Julia gives you a warning.
    Never make your code rely on undefined behavior.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你将x设为常量，y设为变量。注意Julia警告你正在尝试更改常量的值。虽然这确实可能工作，但Julia不保证它一定会这样做，这就是为什么Julia会给你一个警告。永远不要让你的代码依赖于未定义的行为。
- en: Useful hotkeys Use Ctrl-D to exit Julia. Ctrl-C will break execution of some
    code that has gotten stuck. Clearing the terminal screen varies between operating
    systems. On Mac, use Command-K to clear the terminal, and use Ctrl-L on Linux.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有用的快捷键 使用Ctrl-D退出Julia。Ctrl-C将中断某些卡住的代码的执行。清除终端屏幕的方法因操作系统而异。在Mac上，使用Command-K清除终端，在Linux上使用Ctrl-L。
- en: Restart Julia to make all identifiers available again.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动Julia以使所有标识符再次可用。
- en: 2.2.1 Assigning and binding values to variables
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 将值赋给变量和绑定
- en: 'The = operator is used to assign a value to a variable in Julia. Comparing
    two expressions for equality is done with a double equal sign ==. However, to
    be accurate, what Julia does is not an assignment but *binding*. To better understand
    how binding works, I will present a code example in which the variable x is first
    bound to the value 2. Next it is rebound to the value x + 3:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在Julia中，等号（=）用于将值赋给变量。使用双等号（==）比较两个表达式是否相等。然而，为了准确起见，Julia所做的不是赋值，而是*绑定*。为了更好地理解绑定是如何工作的，我将提供一个代码示例，其中变量x首先绑定到值2。然后它被重新绑定到值x
    + 3：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Set the initial value of x to 0.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将x的初始值设为0。
- en: ❷ Increment x with two.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将x增加2。
- en: If this code example had been a language such as C/C++, Fortran, or Pascal,
    then the system would have put aside a slot of memory to hold the x variable.
    Each time you assign a new value to variable x, the number stored in this memory
    location would be changed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个代码示例是一个像C/C++、Fortran或Pascal这样的语言，那么系统会为x变量预留一个内存槽位。每次你给变量x赋新值时，这个内存位置中存储的数字就会改变。
- en: '![02-02](../Images/02-02.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![02-02](../Images/02-02.png)'
- en: Figure 2.2 Binding variable x to different memory locations
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 将变量x绑定到不同的内存位置
- en: With binding, it works differently. You have to think about each calculation
    as producing a number that gets put in a different memory location. Binding involves
    moving the x label itself to a new memory location. The variable moves to the
    result rather than the result moving to the variable. Figure 2.2 shows the step-by-step
    explanation and should help clarify how this works.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用绑定，它的工作方式不同。你必须将每次计算视为产生一个数字，该数字被放入不同的内存位置。绑定涉及将x标签本身移动到新的内存位置。变量移动到结果，而不是结果移动到变量。图2.2展示了逐步解释，应该有助于阐明这是如何工作的。
- en: The value 2 is stored in memory cell number 2\. You attach the label x to this
    value, which is equivalent to the initial assignment statement x = 2.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数字2存储在内存单元格2号。你将标签x附加到这个值上，这相当于初始赋值语句x = 2。
- en: Julia begins to evaluate x + 3 in the expression x = x + 3. It stores the result
    of this calculation at memory cell number 4.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Julia 在表达式 x = x + 3 中开始评估 x + 3。它将这个计算的结果存储在内存单元 4 号。
- en: To complete the evaluation of the x = x + 3 statement, Julia moves the x label
    to memory cell 4.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成对 x = x + 3 语句的评估，Julia 将 x 标签移动到内存单元 4。
- en: But why do Julia and other dynamically typed languages perform binding rather
    than assignment? With a language such as C/C++ you can write statements such as
    the following.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么 Julia 和其他动态类型语言执行绑定而不是赋值？在 C/C++ 这样的语言中，你可以编写如下语句。
- en: Listing 2.1 Assignment in C/C++
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.1 C/C++ 中的赋值
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This works because the compiler will make sure you never attempt to put a value
    that cannot fit inside the memory slot set aside for the variable x and variable
    ch. In a dynamically typed language, any value can be assigned to x, and thus,
    it cannot have a predefined size in a predefined location in memory.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以可行，是因为编译器会确保你永远不会尝试将无法放入为变量 x 和变量 ch 预留的内存槽中的值。在动态类型语言中，任何值都可以赋给 x，因此，它不能在内存中预定义的位置有一个预定义的大小。
- en: 2.2.2 Using the ans variable
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2 使用 ans 变量
- en: There is a special variable in Julia that only exists when you use Julia interactively,
    called ans (answer). The Julia REPL assigns the value of the last expression you
    evaluate to it. Expressions in normal programs are not assigned to it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Julia 中有一个特殊的变量，只有在你交互式使用 Julia 时才存在，称为 ans（答案）。Julia REPL 将你评估的最后表达式的值赋给它。正常程序中的表达式不会赋给它。
- en: 'Many people will be familiar with a similar variable if they have used advanced
    calculators. ans is a variable that always holds the result of the last calculation.
    This behavior is practical, as it allows you to easily use the result from the
    last calculation in the next calculation:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果他们使用过高级计算器，许多人会对类似的变量很熟悉。ans 是一个总是持有最后计算结果的变量。这种行为是实用的，因为它允许你轻松地将最后计算的结果用于下一次计算：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 2.2.3 What is a literal coefficient?
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.3 什么是文字系数？
- en: 'If you read mathematics, you may have noticed that something like 3 × x + 2
    × y would be written as 3x + 2y. Julia lets you write a multiplication in the
    same manner. We refer to these as *literal coefficients*, which is shorthand for
    multiplication between a number literal and a constant or variable:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读过数学，你可能已经注意到，像 3 × x + 2 × y 这样的表达式会被写成 3x + 2y。Julia 允许你以相同的方式编写乘法。我们称这些为
    *文字系数*，它是数字文字与常数或变量之间乘法的缩写：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Literal coefficients only work for actual number literals. π, *e*, and ϕ, for
    instance, are not number literals. You can write 2π but not π2 because the latter
    would imply an identifier.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 文字系数仅适用于实际的数字文字。例如，π、*e* 和 ϕ 不是数字文字。你可以写 2π，但不能写 π2，因为后者会暗示一个标识符。
- en: 'There is a subtle difference between using literal coefficients and performing
    multiplication. See if you can make sense of the following example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文字系数和执行乘法之间存在细微的差别。看看你是否能理解以下示例：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: What is going on here? 1/2x is interpreted as 1/(2*x). Literal coefficients
    have higher precedence than division.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？1/2x 被解释为 1/(2*x)。文字系数的优先级高于除法。
- en: 2.3 Different number types and their bit length in Julia
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 Julia 中不同的数字类型及其位数
- en: Julia has a variety of different number types such as signed integers, unsigned
    integers, and floating-point numbers with different bit lengths. If these concepts
    are unfamiliar to you, I advise you read about different number types in appendix
    B.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 有多种不同的数字类型，如有符号整数、无符号整数和不同位长的浮点数。如果你对这些概念不熟悉，我建议你阅读附录 B 中关于不同数字类型的内容。
- en: Let’s focus on what is particular to Julia. In Julia, signed integers are named
    Int8, Int16, Int32, Int64, and Int128. The number suffix indicates the bit length
    of the number. Unsigned integer type names are formed by prefixing with a U, which
    gives you UInt8, UInt16, UInt32, UInt64, and UInt128.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于 Julia 的特殊性。在 Julia 中，有符号整数命名为 Int8、Int16、Int32、Int64 和 Int128。数字后缀表示数字的位数。无符号整数类型名称通过在前面加上
    U 来形成，这给你提供了 UInt8、UInt16、UInt32、UInt64 和 UInt128。
- en: 'While running code, it is often practical to know the minimum and maximum value
    of a particular integer type. You can use the typemin and typemax functions to
    discover minimum and maximum values. For instance, typemin(Int8) returns -128
    because an 8-bit integer cannot represent smaller values than -128\. typemax(Int8)
    will return 127:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行代码时，了解特定整数类型的最大和最小值通常是实用的。你可以使用typemin和typemax函数来发现最小和最大值。例如，typemin(Int8)返回-128，因为8位整数不能表示小于-128的值。typemax(Int8)将返回127：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The default bit length of a Julia number literal is a signed 64-bit integer.
    You can easily verify that using the typeof function, which returns the type of
    the input argument:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Julia中数字字面量的默认位长是有符号的64位整数。你可以使用typeof函数轻松验证这一点，该函数返回输入参数的类型：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'How do you form numbers of other bit lengths then? If you want to create a
    signed 8-bit number, you write Int8(x), where x is the number you would like to
    turn into an 8-bit number. This works for any number type. Naturally, if you try
    to input a number too large for the bit length, you will get an error message:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何形成其他位长的数字呢？如果你想创建一个有符号的8位数字，你写Int8(x)，其中x是你想转换成8位数的数字。这适用于任何数字类型。自然地，如果你尝试输入一个超出位长的数字，你会得到一个错误信息：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You should know that, unlike other popular dynamically typed languages such
    as Python, Ruby, and R, Julia doesn’t automatically pick a number type large enough
    to hold the result of an arithmetic operation. In Julia, if you add two Int8 values,
    the result will always be an Int8 value.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该知道，与Python、Ruby和R等其他流行的动态类型语言不同，Julia不会自动选择一个足够大的数字类型来容纳算术运算的结果。在Julia中，如果你将两个Int8值相加，结果将始终是Int8值。
- en: Other dynamic languages would have upgraded to an Int16 if the result was too
    large to represent as an 8-bit integer. In Julia, you will instead get an overflow.
    Read appendix B if the concept of integer overflow is unfamiliar to you.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 其他动态语言如果结果太大无法用8位整数表示，就会升级到Int16。在Julia中，你将得到一个溢出。如果你不熟悉整数溢出的概念，请阅读附录B。
- en: Sometimes even Int128 isn’t large enough to hold a value. In these cases you
    use BigInt, which can hold an integer of arbitrary size. This flexibility is paid
    for in higher memory consumption and lower performance, so only use BigInt when
    you have to.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有时即使是Int128也不足以容纳一个值。在这些情况下，你使用BigInt，它可以容纳任意大小的整数。这种灵活性是以更高的内存消耗和较低的性能为代价的，所以只有在必要时才使用BigInt。
- en: 2.3.1 Writing numbers using different number formats
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 使用不同的数字格式编写数字
- en: 'How you write a number and how that number is actually stored in memory are
    two different things. The numbers 0b1101, 0x0d, and 13 are stored as exactly the
    same binary number in computer memory. Julia defaults to showing all signed numbers
    in decimal format and unsigned numbers, such as UInt8, in hexadecimal format:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何写一个数字以及这个数字实际上在内存中的存储是两回事。数字0b1101、0x0d和13在计算机内存中以完全相同的二进制数存储。Julia默认以十进制格式显示所有有符号数，以十六进制格式显示无符号数，如UInt8：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Hexadecimal numbers are popular in low-level, bit-oriented programming. This
    is because four bits can be represented by exactly one hexadecimal digit. Octal
    numbers are also popular because exactly three bits can be used to represent one
    octal digit.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制数在低级、面向位的编程中很受欢迎。这是因为四个位可以用一个十六进制数字精确表示。八进制数也很受欢迎，因为可以用三个位来精确表示一个八进制数字。
- en: Hexadecimal and octal numbers
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制和八进制数
- en: Decimal numbers are created by combining digits from 0 to 9\. Octal numbers
    are created by combining digits from 0 to 7\. Thus the number 8 would be written
    as 10 in the octal number system.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制数是通过组合0到9的数字来创建的。八进制数是通过组合0到7的数字来创建的。因此，在八进制数系统中，数字8将被写作10。
- en: With hexadecimal numbers, there is a problem because the digits in the hexadecimal
    number system have to cover values 1 to 15; however, there are only symbols for
    digits 0 to 9\. The solution has been using letters for digits beyond 9; thus
    the value 10 is represented as A, 11 is represented as B, and so on. F stands
    for 15\. The largest value an 8-bit unsigned integer can hold is 0xff, which translates
    to 255 in decimal.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用十六进制数时，存在一个问题，因为十六进制数系统中的数字必须覆盖从1到15的值；然而，只有0到9的符号。解决方案是使用字母来表示超过9的数字；因此，10表示为A，11表示为B，以此类推。F代表15。一个8位无符号整数可以持有的最大值是0xff，这在十进制中相当于255。
- en: 'To write an octal number, use the 0o prefix—you don’t need to understand this
    very well. The point is making you aware of the fact that there are different
    ways of representing the same number. This is to avoid confusion when playing
    with *unsigned* integers in this chapter, as Julia defaults to displaying them
    in hexadecimal form:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写八进制数，使用0o前缀——你不需要完全理解这一点。关键是让你意识到有不同方式表示相同的数字。这是为了避免在处理本章中的*无符号*整数时产生混淆，因为Julia默认以十六进制形式显示它们：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 2.4 Floating-point numbers
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 浮点数
- en: 'Like integers there are floating-point numbers of different bit length. In
    Julia the default size is 64 bit, which means each floating-point number consumes
    8 bytes of memory. By using more bits you can not only represent larger numbers
    but also represent numbers with higher precision. However, precision is not always
    important. For scientific calculations precision is important, but when calculating
    (e.g., for computer graphics), precision matters less. One pixel out of millions
    that is slightly wrong in position or color does not matter much. The most common
    floating-point types, Float64 and Float32, can be written as number literals:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与整数类似，浮点数也有不同位长的。在Julia中，默认大小是64位，这意味着每个浮点数占用8字节内存。通过使用更多的位，你不仅可以表示更大的数字，还可以表示更高精度的数字。然而，精度并不总是重要的。对于科学计算，精度很重要，但在计算（例如，用于计算机图形）时，精度的重要性较小。在数百万个像素中，位置或颜色略有错误的像素并不重要。最常见的浮点数类型，Float64和Float32，可以写成数字字面量：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ A 64-bit floating-point literal. You can verify that with typeof.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 64位浮点数字面量。你可以使用typeof来验证。
- en: ❷ A 32-bit floating-point number
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 32位浮点数
- en: 'Notice the use of the f0 suffix to make the number of a 32-bit floating-point
    number. Why isn’t there just an f like in Java and C/C++? This is due to the literal
    coefficients feature. If you look at the following REPL session you may be able
    to figure out what is going on:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用f0后缀来表示32位浮点数的数字。为什么不像Java和C/C++那样只有一个f呢？这是因为字面量系数功能。如果你查看以下REPL会话，你可能能够弄清楚发生了什么：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you try to write a 32-bit floating-point number like in Java or C/C++, Julia
    thinks you are trying to multiply a number with the variable f. In the first case
    this fails because you have not yet defined the f variable. In the second case
    it works because f has been defined.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试编写类似于Java或C/C++的32位浮点数，Julia会认为你正在尝试将一个数字与变量f相乘。在第一种情况下，这会失败，因为你还没有定义f变量。在第二种情况下，它有效，因为f已经被定义。
- en: 'How about other floating-point values, such as 16-bit values? In these cases
    you need to perform an explicit conversion:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，其他浮点值，如16位值呢？在这些情况下，你需要执行显式转换：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Convert a 64-bit floating-point value to a 16-bit one.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将64位浮点数转换为16位浮点数。
- en: ❷ Mixing numbers of different bit length causes Julia to pick the largest type
    to store the result in.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 混合不同位长的数字会导致Julia选择最大的类型来存储结果。
- en: 2.4.1 Performing operations on integers and floating-point numbers
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.1 对整数和浮点数执行操作
- en: While you can do many of the same operations on floating-point and integer numbers,
    the operations don’t always have the same kind of results. And there are operations
    that only work on certain number types.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以在浮点数和整数上执行许多相同的操作，但操作的结果并不总是相同的。而且还有一些操作只适用于某些数字类型。
- en: 'For instance the \ division operator gives floating-point numbers as result.
    That is not always what you want. When working with integers you often want the
    quotient and remainder instead. This is achieved with the div and rem functions:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，\除法运算符返回浮点数作为结果。这并不总是你想要的。当与整数一起工作时，你通常想要商和余数。这可以通过div和rem函数来实现：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Regular division operator gives floating-point result
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 正规除法运算符给出浮点结果
- en: ❷ Integer division, which gives an integer result
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 整数除法，返回整数结果
- en: ❸ You also get a remainder, which you obtain with % the operator.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 你还会得到一个余数，你可以使用%运算符来获取。
- en: 2.5 Defining functions
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 定义函数
- en: 'You’ve already been exposed to some functions, such as *sin*, *cos*, and √.
    These are functions you can find on a regular calculator; they take a number as
    input and return a number as output. But what is the fundamental idea behind functions?
    And secondly, are functions in mathematics and in Julia the same kind of thing?
    The details differ, but conceptually, they are the same kind of thing. Functions
    have zero or more inputs called *arguments*. They can be considered to be returning
    a value or evaluating to a value. Consider the volume of a sphere:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经接触到了一些函数，例如*sin*、*cos*和√。这些是你可以在普通计算器上找到的函数；它们接受一个数字作为输入，并返回一个数字作为输出。但函数背后的基本理念是什么？其次，数学和Julia中的函数是否是同一类东西？细节不同，但从概念上讲，它们是同一类东西。函数有零个或多个称为*参数*的输入。它们可以被认为是返回一个值或评估到一个值。考虑球体的体积：
- en: '![02-02-Equation_2](../Images/02-02-Equation_2.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![02-02-Equation_2](../Images/02-02-Equation_2.png)'
- en: 'How good are you at remembering exactly how this calculation is performed?
    I often have to look it up. You could perform this calculation in Julia by writing
    the following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你记得这个计算过程有多好？我经常需要查找它。你可以在Julia中通过编写以下代码来执行这个计算：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ The radius of the sphere
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 球体的半径
- en: ❷ Storing the volume of the sphere in variable V
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将球体的体积存储在变量V中
- en: 'Variables and constants make it easy to remember long, complicated numbers.
    In many ways you can think of functions as an extension of this idea. They allow
    you to remember complicated calculations. Instead of remembering what numbers
    to multiply and divide, you only need to remember the name of a function:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 变量和常量使得记住长而复杂的数字变得容易。在许多方面，你可以将函数视为这个想法的扩展。它们允许你记住复杂的计算。你不需要记住要乘以和除以的数字，只需要记住函数的名称：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Define the sphere_volume function, which takes a single argument r, specifying
    the radius of the sphere.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义名为sphere_volume的函数，它接受单个参数r，指定球体的半径。
- en: ❷ Use the previously defined sphere function to calculate the volume of a sphere
    with a radius of 2.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用先前定义的球体函数来计算半径为2的球体的体积。
- en: ❸ The volume of a sphere with a radius of 4
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 半径为4的球体的体积
- en: 'Notice that when you define a function, unlike a variable, you specify one
    or more arguments. Arguments are variables in your calculation that you want to
    change each time you perform a calculation. For example, when calculating the
    volume of a sphere you want the value of π to be the same each time; hence π is
    not an argument to the function. The radius, however, is an argument because you
    are interested in calculating the volume of spheres of different radii:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你定义一个函数时，与变量不同，你指定一个或多个参数。参数是在你的计算中想要改变的变量。例如，在计算球体体积时，你希望π的值每次都相同；因此π不是函数的参数。然而，半径是一个参数，因为你是想计算不同半径的球体的体积：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code snippet you see a simple function definition. It’s a function
    with the name foo, taking three different arguments named x, y and z. You could
    have just a few or many arguments. The rules for how you name them are the same
    as for any Julia identifier.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，你可以看到一个简单的函数定义。这是一个名为foo的函数，它接受三个不同的参数，分别命名为x、y和z。你可以有少量或许多参数。命名它们的规则与任何Julia标识符的规则相同。
- en: 2.5.1 Storing function definitions in a file
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.1 在文件中存储函数定义
- en: Writing the definition of every function you want to use in the Julia REPL every
    time you restart Julia would be impractical. Instead you can store function definitions
    inside separate source code files.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 每次重启Julia时都在Julia REPL中编写你想要使用的每个函数的定义是不切实际的。相反，你可以在单独的源代码文件中存储函数定义。
- en: 'Code comments with # You can write comments in your code to remind yourself
    what various parts of your code does. Comments start with a hash or pound sign:
    #. Anything after the hash symbol is ignored by the Julia compiler.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 代码注释（#）你可以在代码中写注释来提醒自己代码的各个部分做了什么。注释以井号开头：#。井号符号之后的内容会被Julia编译器忽略。
- en: This file can then later be loaded into the Julia REPL when the functions contained
    within are needed. Let me demonstrate with an example. You will create a file
    called volumes.jl. Inside you store functions to calculate the volume of a sphere,
    cylinder, and cone.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件可以在需要其中包含的函数时稍后加载到Julia REPL中。让我用一个例子来演示。你将创建一个名为volumes.jl的文件。在里面，你存储计算球体、圆柱体和圆锥体体积的函数。
- en: Listing 2.2 volumes.jl source code file
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.2 volumes.jl源代码文件
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can get the code in this file into Julia in three different ways. Perhaps
    the least sophisticated way is simply copying and pasting the text into the Julia
    command line. Alternatively, you could load the file when you start Julia:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过三种不同的方式将此文件中的代码放入 Julia 中。可能最不复杂的方法就是简单地复制粘贴文本到 Julia 命令行。或者，你可以在启动 Julia
    时加载该文件：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'However the more flexible solution is using the include function. This removes
    the need to restart your Julia REPL session:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，更灵活的解决方案是使用 include 函数。这不需要重新启动你的 Julia REPL 会话：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ Loads the code in the given file into your current session
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将给定文件中的代码加载到你的当前会话中
- en: ❷ Runs one of the functions defined in the file loaded into current session
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 运行当前会话中加载的文件中定义的函数之一
- en: You can make changes to the code in this file and reload it using include to
    capture changes in the function implementations.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以修改此文件中的代码，并使用 include 重新加载它以捕获函数实现的更改。
- en: 2.5.2 Working with functions in the REPL
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.2 在 REPL 中处理函数
- en: Once complex calculations have been stored inside functions, you can easily
    reuse those calculations. But how do you deal with a large number of functions?
    The Julia REPL offers many ways to help.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将复杂计算存储在函数中，你可以轻松地重用这些计算。但是，你如何处理大量函数？Julia REPL 提供了许多帮助的方法。
- en: 'If you start typing the first letters in a function and press Tab, Julia will
    attempt to complete the function name. If you start typing sphere, then hit the
    Tab key, Julia will complete this as sphere_volume. Sometimes there are many possible
    completions. In these cases you can press Tab twice to get a full list of possible
    completions:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你开始输入函数的第一个字母并按 Tab 键，Julia 将尝试完成函数名。如果你开始输入 sphere 并按 Tab 键，Julia 将将其完成为
    sphere_volume。有时可能有多个可能的完成。在这些情况下，你可以按 Tab 键两次以获取可能的完整列表：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ Press Tab twice here to get the full list of functions starting with the word
    find.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在这里按 Tab 键两次以获取以单词 find 开头的函数的完整列表。
- en: 'On the web page of the Julia programming language you can also find a manual,
    which gives you a complete list of all the functions built in to the Julia standard
    library. You can access the manual on the following webpage: docs.julialang.org/en/v1.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Julia 编程语言的网页上，你还可以找到一个手册，其中提供了 Julia 标准库中所有内置函数的完整列表。你可以在以下网页上访问手册：docs.julialang.org/en/v1。
- en: 2.5.3 Functions everywhere
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.3 到处都是函数
- en: 'Functions are central to Julia. In fact, even common mathematical operators
    are defined as functions in Julia. Let me give you some examples:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是 Julia 的核心。实际上，甚至常见的数学运算符在 Julia 中也被定义为函数。让我给你举一些例子：
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ It looks like you are using an operator, but it is actually a function call
    written on infix form.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 它看起来像你正在使用一个运算符，但实际上是一个以中缀形式编写的函数调用。
- en: ❷ These are operators called like regular functions. This is called prefix form.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这些是像常规函数一样调用的运算符。这被称为前缀形式。
- en: ❸ The benefit of using + as a function is that you can use more than two arguments
    (e.g., you can use it to add up multiple values).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用 + 作为函数的好处是你可以使用超过两个参数（例如，你可以用它来累加多个值）。
- en: 'To describe the placement of identifiers, use the following terms: prefix,
    infix, and suffix. Thus +(3, 4) would be considered a *prefix* form, while 3 +
    4 would be the equivalent *infix* form.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要描述标识符的位置，请使用以下术语：前缀、中缀和后缀。因此 +(3, 4) 被认为是 *前缀* 形式，而 3 + 4 则是等效的 *中缀* 形式。
- en: 'How do you know if you can use a function on infix form? It’s simple: the function
    name needs to be a symbol. For instance you cannot use a function named foo on
    infix form. Let’s make some to demonstrate:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何知道是否可以在中缀形式中使用一个函数？很简单：函数名需要是一个符号。例如，你不能使用名为 foo 的函数来表示中缀形式。让我们做一些演示：
- en: '[PRE31]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here we made a function named × (write \times), and because it takes two arguments
    and is a symbol, we can use it on infix form. The simplest way to get a symbol
    is writing a LaTeX-like abbreviation and pressing tab (e.g., \Delta for Δ). Symbol
    completion will work in the Julia REPL and many Julia code editors. The LaTeX-like
    abbreviations supported by Julia can be found in the official Julia documentation
    at [https://docs.julialang.org/en/v1/manual/unicode-input/](https://docs.julialang.org/en/v1/manual/unicode-input/).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为 ×（写 \times）的函数，因为它接受两个参数并且是一个符号，所以我们可以使用它来表示中缀形式。获取符号的最简单方法就是编写类似
    LaTeX 的缩写并按 Tab 键（例如，\Delta 表示 Δ）。Julia 支持的类似 LaTeX 的缩写可以在官方 Julia 文档中找到，网址为 [https://docs.julialang.org/en/v1/manual/unicode-input/](https://docs.julialang.org/en/v1/manual/unicode-input/)。
- en: 2.5.4 Functions to work with numbers
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.4 与数字一起工作的函数
- en: 'You have already seen a number of functions you can use to operate on numbers,
    but Julia has a large collection of them. I would like to show some of the most
    useful ones, in particular for working with integers and floating-point numbers.
    Previously, I showed some operations on integers and floating-point numbers. However
    now you know that operations are really just functions. All of these variants
    are equivalent:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了一些可以用来操作数字的函数，但Julia有一大批这样的函数。我想展示一些最有用的函数，特别是用于处理整数和浮点数。之前，我展示了一些整数和浮点数的操作。然而现在你知道操作实际上只是函数。所有这些变体都是等价的：
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The principle in Julia is that you should never *have to* use special Unicode
    symbols. Operations such as integer division can also be performed with simple
    functions:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Julia的原则是，你永远不需要使用特殊的Unicode符号。整数除法等操作也可以使用简单的函数执行：
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In fact, if you hit the ? key and write an integer division, you will get the
    built-in help system showing you that div has two names:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，如果你按下?键并写一个整数除法，你会得到内置的帮助系统，显示div有两个名称：
- en: '[PRE34]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It is very useful to know how to round numbers in different ways. Julia has
    the functions floor, ceil, and round for this purpose:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何以不同方式四舍五入数字非常有用。Julia有floor、ceil和round函数用于此目的：
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ Always rounds downward
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 总是向下取整
- en: ❷ Always rounds upward
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 总是向上取整
- en: ❸ Rounds to the closest whole number
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 四舍五入到最接近的整数
- en: 'But if you are rounding to integers, then you probably want integer types:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你要四舍五入到整数，那么你可能想要整数类型：
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ❶ This is the native approach to get an integer.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这是获取整数的原生方法。
- en: '❷ This is the intended and most efficient approach: you provide the type you
    want as output as the first argument.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这是预期且最有效的方法：你将作为第一个参数提供你想要的输出类型。
- en: 2.6 How to use numbers in practice
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6 如何在实际中使用数字
- en: A lot of the details covered here are not things you need to think about when
    doing normal coding. I don’t want you to pack your brain with too many unnecessary
    details. The key point here is providing you with an understanding of how numbers
    work in Julia. This is not unique to Julia, but it may be unfamiliar to developers
    coming from other dynamic languages, such as Python, R, or Ruby.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这里涵盖的许多细节不是你在进行常规编码时需要考虑的事情。我不想让你的大脑充斥着太多不必要的细节。关键点在于向你提供对Julia中数字工作原理的理解。这不仅仅局限于Julia，但对于来自其他动态语言（如Python、R或Ruby）的开发者来说可能是不熟悉的。
- en: 'To make things easy for yourself, here are some simple rules to follow:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你更容易操作，以下是一些简单的规则：
- en: Just use the default integer and floating-point sizes. Only consider smaller
    or larger numbers when performance or the nature of your problem demands it.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只使用默认的整数和浮点数大小。只有当性能或问题的性质要求时，才考虑更小或更大的数字。
- en: Prefer signed integers to unsigned. It is very easy to make a mistake using
    unsigned numbers. To make it easy for yourself, stick with signed numbers most
    of the time.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 优先使用有符号整数而不是无符号整数。使用无符号数很容易出错。为了让你更容易操作，大多数时候坚持使用有符号数。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Julia supports different kinds of numbers, but the two most important types
    are integer numbers and floating-point numbers.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia支持不同类型的数字，但最重要的两种类型是整数和浮点数。
- en: Unlike numbers used by mathematicians, numbers used in programming have particular
    bit lengths. This determines how large and small of values you can store. For
    instance a signed 8-bit integer cannot store numbers smaller than -128 or larger
    than 127.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与数学家使用的数字不同，编程中使用的数字有特定的位数。这决定了你可以存储的数值大小。例如，一个有符号的8位整数无法存储小于-128或大于127的数字。
- en: Variables give names to numbers. Functions give names to calculations dependent
    on zero or more arguments.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量给数字命名。函数给依赖于零个或多个参数的计算命名。
- en: Assigning a value to a variable means sticking an identifier on that value.
    Reassigning another value to the same variable means moving the sticker to the
    new value. This is called binding.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个值赋给变量意味着在那个值上贴一个标识符。将另一个值赋给同一个变量意味着将标签移动到新值上。这被称为绑定。
- en: Two numbers that look identical in memory can look different on your screen
    because they are of different type.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内存中看起来相同的两个数字，因为它们的类型不同，在屏幕上可能看起来不同。
- en: 'You can input numbers using a variety of different formats: binary, decimal,
    and hexadecimal. Unless you do systems programming, decimal will usually be the
    preferred format.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用不同的格式输入数字：二进制、十进制和十六进制。除非你进行系统编程，否则通常首选十进制格式。
- en: '* * *'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^(1.)A number literal is made up of digits from 0 to 9 instead of being expressed
    as a named variable.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: (1.)一个数字字面量由0到9的数字组成，而不是用命名的变量来表示。
