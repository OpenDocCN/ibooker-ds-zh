- en: 1 Understanding object/relational persistence
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 理解对象/关系持久化
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Persisting with SQL databases in Java applications
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java应用程序中使用SQL数据库进行持久化
- en: Analyzing the object/relational paradigm mismatch
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析对象/关系范式不匹配
- en: Introducing ORM, JPA, Hibernate, and Spring Data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍ORM、JPA、Hibernate和Spring Data
- en: This book is about JPA, Hibernate, and Spring Data; our focus is on using Hibernate
    as a provider of the Jakarta Persistence API (formerly Java Persistence API) and
    Spring Data as a Spring-based programming model for data access. We’ll cover basic
    and advanced features and describe some ways to develop new applications using
    the Java Persistence API. Often these recommendations aren’t specific to Hibernate
    or Spring Data. Sometimes they’re our own ideas about the *best* ways to do things
    when working with persistent data, explained in the context of Hibernate and Spring
    Data.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书是关于JPA、Hibernate和Spring Data的；我们的重点是使用Hibernate作为Jakarta Persistence API（以前称为Java
    Persistence API）的提供者，以及Spring Data作为基于Spring的数据访问编程模型。我们将涵盖基本和高级功能，并描述一些使用Java
    Persistence API开发新应用的方法。这些推荐通常不仅限于Hibernate或Spring Data。有时，它们是我们关于在处理持久数据时*最佳*做法的自己的想法，这些想法在Hibernate和Spring
    Data的背景下进行解释。
- en: The choice of approach to managing persistent data may be a key design decision
    in many software projects. Persistence has always been a hot topic of debate in
    the Java community. Is persistence a problem that has already been solved by SQL
    and extensions such as stored procedures, or is it a more pervasive problem that
    must be addressed by special Java frameworks? Should we hand-code even the most
    primitive CRUD (create, read, update, delete) operations in SQL and JDBC, or should
    this work be handed to an intermediary layer? How can we achieve portability if
    every database management system has its own SQL dialect? Should we abandon SQL
    completely and adopt a different database technology, such as object database
    systems or NoSQL systems? The debate may never end, but a solution called *object/relational
    mapping* (ORM) now has wide acceptance. This is due in large part to Hibernate,
    an open source ORM service implementation, and Spring Data, an umbrella project
    from the Spring family whose purpose is to unify and facilitate access to different
    kinds of persistence stores, including relational database systems and NoSQL databases.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多软件项目中，选择管理持久数据的方法可能是一个关键的设计决策。持久性一直是Java社区的热门辩论话题。持久性是一个已经被SQL及其扩展（如存储过程）解决的问题，还是一个更普遍的问题，必须通过特殊的Java框架来解决？我们应该手动编写即使是最低级的CRUD（创建、读取、更新、删除）操作，使用SQL和JDBC，还是应该将这些工作交给中间层？如果每个数据库管理系统都有自己的SQL方言，我们如何实现可移植性？我们应该完全放弃SQL并采用不同的数据库技术，如对象数据库系统或NoSQL系统吗？辩论可能永远不会结束，但现在有一个名为*对象/关系映射*（ORM）的解决方案已经得到了广泛的认可。这很大程度上归功于Hibernate，一个开源的ORM服务实现，以及Spring
    Data，它是Spring家族的一个伞形项目，其目的是统一并简化对不同类型持久化存储的访问，包括关系数据库系统和NoSQL数据库。
- en: Before we can get started with Hibernate and Spring Data, however, you need
    to understand the core problems of object persistence and ORM. This chapter explains
    why you need tools like Hibernate and Spring Data and specifications such as the
    *Jakarta Persistence API* (JPA).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们开始使用Hibernate和Spring Data之前，你需要了解对象持久化和ORM的核心问题。本章解释了为什么你需要像Hibernate和Spring
    Data这样的工具以及像*Jakarta Persistence API*（JPA）这样的规范。
- en: First we’ll define persistent data management in the context of software applications
    and discuss the relationships between SQL, JDBC, and Java, the underlying technologies
    and standards that Hibernate and Spring Data build on. We’ll then discuss the
    so-called *object/relational paradigm mismatch* and the generic problems we encounter
    in object-oriented software development with SQL databases. These problems make
    it clear that we need tools and patterns to minimize the time we have to spend
    on persistence-related code in our applications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义软件应用程序中的持久数据管理，并讨论SQL、JDBC和Java之间的关系，Hibernate和Spring Data构建在底层技术和标准之上。然后，我们将讨论所谓的*对象/关系范式不匹配*以及我们在面向对象软件开发中使用SQL数据库时遇到的通用问题。这些问题清楚地表明，我们需要工具和模式来最小化我们在应用程序中花费在持久化相关代码上的时间。
- en: The best way to learn Hibernate and Spring Data isn’t necessarily linear. We
    understand that you may want to try Hibernate or Spring Data right away. If this
    is how you’d like to proceed, skip to the next chapter and set up a project with
    the “Hello World” example. We recommend that you return here at some point as
    you go through this book; that way, you’ll be prepared and have the background
    concepts you need for the rest of the material.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 学习Hibernate和Spring Data的最佳方式不一定是一成不变的。我们理解你可能想立即尝试Hibernate或Spring Data。如果你这样想，请跳到下一章，并使用“Hello
    World”示例设置一个项目。我们建议你在阅读本书的过程中某个时候返回这里；这样，你将准备好，并拥有完成剩余材料所需的所有背景概念。
- en: 1.1 What is persistence?
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 什么是持久性？
- en: Most applications require persistent data. Persistence is one of the fundamental
    concepts in application development. If an information system didn’t preserve
    data when it was powered off, the system would be of little practical use. *Object
    persistence* means individual objects can outlive the application process; they
    can be saved to a data store and be re-created at a later point in time. When
    we talk about persistence in Java, we’re generally talking about mapping and storing
    object instances in a database using SQL.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用都需要持久化数据。持久性是应用开发中的基本概念之一。如果一个信息系统在断电时没有保留数据，那么这个系统将几乎没有实际用途。*对象持久性*意味着单个对象可以比应用过程存在得更久；它们可以被保存到数据存储中，并在稍后的某个时间点重新创建。当我们谈论Java中的持久性时，我们通常是指使用SQL将对象实例映射和存储到数据库中。
- en: We’ll start by taking a brief look at persistence and how it’s used in Java.
    Armed with this information, we’ll continue our discussion of persistence and
    look at how it’s implemented in object-oriented applications.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先简要地看看持久性及其在Java中的使用。有了这些信息，我们将继续讨论持久性，并探讨它在面向对象应用中的实现方式。
- en: 1.1.1 Relational databases
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.1 关系型数据库
- en: You, like most other software engineers, have probably worked with SQL and relational
    databases; many of us handle such systems every day. Relational database management
    systems have SQL-based application programming interfaces, so we call today’s
    relational database products SQL *database management systems* (DBMS) or, when
    we’re talking about particular systems, SQL *databases*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你，像大多数其他软件工程师一样，可能已经使用过SQL和关系型数据库；我们中的许多人每天都在处理这样的系统。关系型数据库管理系统有基于SQL的应用程序编程接口，所以我们称今天的关系型数据库产品为SQL
    *数据库管理系统*（DBMS）或，当我们谈论特定系统时，称为SQL *数据库*。
- en: Relational technology is a well-known technology, and this alone is sufficient
    reason for many organizations to choose it. Relational databases are also an incredibly
    flexible and robust approach to data management. Due to the well-researched theoretical
    foundation of the relational data model, relational databases can guarantee and
    protect the integrity of stored data, along with having other desirable characteristics.
    You may be familiar with E.F. Codd’s five-decade-old introduction of the relational
    model, “A Relational Model of Data for Large Shared Data Banks” (Codd, 1970).
    A more recent compendium worth reading, with a focus on SQL, is C.J. Date’s *SQL
    and Relational Theory* (Date, 2015).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型技术是一个众所周知的技术，仅此一点就足以成为许多组织选择它的充分理由。关系型数据库也是数据管理的一个极其灵活和强大的方法。由于关系数据模型经过充分研究的理论基础，关系型数据库可以保证并保护存储数据的完整性，同时具有其他可取的特性。你可能熟悉E.F.
    Codd五十年前提出的关于关系模型的介绍，“大型共享数据银行的关系数据模型”（Codd，1970）。一本值得阅读的更近期的汇编，专注于SQL，是C.J. Date的《SQL和关系理论》（Date，2015）。
- en: Relational DBMSs aren’t specific to Java, nor is an SQL database specific to
    a particular application. This important principle is known as *data independence*.
    In other words, *data usually lives longer than an application does*. Relational
    technology provides a way of sharing data among different applications, or among
    different parts of the same overall system (a data entry application and a reporting
    application, for example). Relational technology is a common denominator of many
    disparate systems and technology platforms. Hence, the relational data model is
    often the foundation for the enterprise-wide representation of business entities.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库管理系统并不特定于Java，SQL数据库也不特定于某个特定应用。这个重要的原则被称为*数据独立性*。换句话说，*数据通常比应用存在的时间更长*。关系型技术提供了一种在不同应用之间或同一整体系统的不同部分之间（例如，数据录入应用和报告应用）共享数据的方法。关系型技术是许多不同系统和技术平台的一个共同基础。因此，关系数据模型通常是企业级业务实体表示的基础。
- en: 'Before we go into more detail about the practical aspects of SQL databases,
    we need to mention an important concern: although marketed as relational, a database
    system providing only an SQL data language interface isn’t really relational,
    and in many ways it isn’t even close to the original concept. Naturally, this
    has led to confusion. SQL practitioners blame the relational data model for shortcomings
    in the SQL language, and relational data management experts blame the SQL standard
    for being a weak implementation of the relational model and ideals. We’ll highlight
    some significant aspects of this problem throughout this book, but generally we’ll
    focus on the practical aspects. If you’re interested in more background material,
    we highly recommend *Fundamentals of Database Systems* by Ramez Elmasri and Shamkant
    B. Navathe (Elmasri, 2016) for the theory and concepts of relational database
    systems.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨 SQL 数据库的实际应用方面之前，我们需要提到一个重要的问题：尽管被宣传为关系型，但仅提供 SQL 数据语言接口的数据库系统实际上并不是关系型的，而且在很多方面甚至与原始概念相去甚远。这自然导致了混淆。SQL
    实践者将 SQL 语言中的不足归咎于关系数据模型，而关系数据管理专家则指责 SQL 标准是关系模型和理想的薄弱实现。本书中我们将突出一些与这个问题相关的重要方面，但总体上我们将关注实际应用。如果你对更多背景资料感兴趣，我们强烈推荐
    Ramez Elmasri 和 Shamkant B. Navathe 所著的《数据库系统基础》（Elmasri, 2016），以了解关系数据库系统的理论和概念。
- en: 1.1.2 Understanding SQL
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.2 理解 SQL
- en: To use JPA, Hibernate, and Spring Data effectively, you must start with a solid
    understanding of the relational model and SQL. You’ll need to understand the relational
    model and the information model and topics such as normalization to guarantee
    the integrity of your data, and you’ll need to use your knowledge of SQL to tune
    the performance of your application—these are all prerequisites for reading this
    book. Hibernate and Spring Data simplify many repetitive coding tasks, but your
    knowledge of persistence technology must extend beyond the frameworks themselves
    if you want to take advantage of the full power of modern SQL databases. To dig
    deeper, consult the sources in the references list at the end of this book.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地使用 JPA、Hibernate 和 Spring Data，你必须从对关系模型和 SQL 的扎实理解开始。你需要理解关系模型和信息模型，以及诸如规范化等主题，以确保数据的完整性，并且你需要使用你的
    SQL 知识来调整应用程序的性能——这些都是阅读本书的先决条件。Hibernate 和 Spring Data 简化了众多重复的编码任务，但如果你想充分利用现代
    SQL 数据库的全部功能，你的持久化技术知识必须超越这些框架本身。要深入了解，请参阅本书末尾参考文献列表中的资源。
- en: You’ve probably used SQL for many years and are familiar with the basic operations
    and statements written in this language. Still, we know from our own experience
    that SQL is sometimes hard to remember, and some terms vary in usage.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经使用 SQL 多年了，并且熟悉这种语言中编写的各种基本操作和语句。然而，根据我们自己的经验，SQL 有时很难记住，而且一些术语的使用方式也有所不同。
- en: You should be comfortable with them, so let’s briefly review some of the SQL
    terms we’ll use in this book. SQL is used as a *data definition language* (DDL),
    with syntax for *creating*, *altering*, and *dropping* artifacts such as tables
    and constraints in the catalog of the DBMS. When this *schema* is ready, you can
    use SQL as a *data manipulation language* (DML) to perform operations on data,
    including *insertions**, updates*, and *deletions*. You can retrieve data by executing
    *data query language* (DQL) statements with *restrictions**, projections*, and
    *Cartesian products*. For efficient reporting, you can use SQL to *join*, *aggregate*,
    and *group* data as necessary. You can even nest SQL statements inside each other—a
    technique that uses *subselects*. When your business requirements change, you’ll
    have to modify the database schema again with DDL statements after data has been
    stored; this is known as *schema evolution*. You may also use SQL as a *data control
    language* (DCL) to *grant and revoke* access to the database or parts of it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该对这些术语感到熟悉，因此让我们简要回顾一下本书中我们将使用的 SQL 术语。SQL 被用作 *数据定义语言*（DDL），具有用于在 DBMS 目录中
    *创建*、*修改* 和 *删除* 如表和约束等实体的语法。当这个 *模式* 准备就绪时，你可以使用 SQL 作为 *数据操纵语言*（DML）来对数据进行操作，包括
    *插入*、*更新* 和 *删除*。你可以通过执行带有 *限制*、*投影* 和 *笛卡尔积* 的 *数据查询语言*（DQL）语句来检索数据。为了高效地报告，你可以根据需要使用
    SQL 来 *连接*、*聚合* 和 *分组* 数据。你甚至可以将 SQL 语句嵌套在彼此内部——这是一种使用 *子查询* 的技术。当你的业务需求发生变化时，你必须在数据存储后使用
    DDL 语句再次修改数据库模式；这被称为 *模式演变*。你还可以使用 SQL 作为 *数据控制语言*（DCL）来 *授予和撤销* 对数据库或其部分的访问权限。
- en: 'If you’re an SQL veteran and you want to know more about optimization and how
    SQL is executed, get a copy of the excellent book *SQL Tuning* by Dan Tow (Tow,
    2003). For a look at the practical side of SQL through the lens of how not to
    use SQL, *SQL Antipatterns: Avoiding the Pitfalls of Database Programming*, by
    Bill Karwin (Karwin, 2010) is a good resource.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你是一位SQL老手，并且想了解更多关于优化以及SQL是如何执行的信息，可以获取Dan Tow（Tow，2003）所著的优秀书籍《SQL Tuning》。如果你想从如何不使用SQL的角度了解SQL的实际应用，Bill
    Karwin（Karwin，2010）所著的《SQL Antipatterns: Avoiding the Pitfalls of Database Programming》是一本很好的资源。'
- en: Although the SQL database is one part of ORM, the other part, of course, consists
    of the data in your Java application that needs to be persisted to and loaded
    from the database.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SQL数据库是ORM的一部分，但另一部分，当然，是由需要持久化到数据库并从中加载的Java应用程序中的数据组成。
- en: 1.1.3 Using SQL in Java
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.3 在Java中使用SQL
- en: When you work with an SQL database in a Java application, you issue SQL statements
    to the database via the Java Database Connectivity (JDBC) API. Whether the SQL
    was written by hand and embedded in the Java code or generated on the fly by Java
    code, you use the JDBC API to bind arguments when preparing query parameters,
    executing a query, scrolling through query results, retrieving values from a result
    set, and so on. These are low-level data access tasks; as application engineers,
    we’re more interested in the business problem that requires this data access.
    What we’d really like to write is code that saves and retrieves instances of our
    classes, relieving us of this low-level labor.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在Java应用程序中与SQL数据库一起工作时，你通过Java数据库连接（JDBC）API向数据库发出SQL语句。无论SQL是手动编写并嵌入到Java代码中，还是由Java代码即时生成，你都会使用JDBC
    API在准备查询参数、执行查询、滚动查询结果、从结果集中检索值等操作时绑定参数。这些都是低级的数据访问任务；作为应用工程师，我们更感兴趣的是需要这种数据访问的业务问题。我们真正想写的是能够保存和检索我们类实例的代码，从而让我们摆脱这种低级劳动。
- en: 'Because these data access tasks are often so tedious, we have to ask: are the
    relational data model and (especially) SQL the right choices for persistence in
    object-oriented applications? We can answer this question unequivocally: yes!
    There are many reasons why SQL databases dominate the computing industry—relational
    database management systems are the only proven generic data management technology,
    and they’re almost always a *requirement* in Java projects.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些数据访问任务通常非常繁琐，我们必须问：关系型数据模型和（尤其是）SQL是否是面向对象应用程序持久化的正确选择？我们可以明确地回答这个问题：是的！有许多原因使得SQL数据库在计算行业中占据主导地位——关系型数据库管理系统是唯一经过验证的通用数据管理技术，并且它们几乎总是Java项目的**要求**。
- en: Note that we aren’t claiming that relational technology is *always* the best
    solution. Many data management requirements warrant a completely different approach.
    For example, internet-scale distributed systems (web search engines, content distribution
    networks, peer-to-peer sharing, instant messaging) have to deal with exceptional
    transaction volumes. Many of these systems don’t require that after a data update
    completes, all processes see the same updated data (strong transactional consistency).
    Users might be happy with weak consistency; after an update, there might be a
    window of inconsistency before all processes see the updated data. In contrast,
    some scientific applications work with enormous but very specialized datasets.
    Such systems and their unique challenges typically require equally unique and
    often custom-made persistence solutions. Generic data management tools such as
    ACID-compliant transactional SQL databases, JDBC, Hibernate, and Spring Data would
    play only a minor role for these types of systems.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们并不是声称关系型技术**总是**是最好的解决方案。许多数据管理需求需要完全不同的方法。例如，互联网规模的分布式系统（如网络搜索引擎、内容分发网络、对等共享、即时通讯）必须处理异常的交易量。许多这些系统不需要在数据更新完成后，所有进程都看到相同的更新数据（强事务一致性）。用户可能对弱一致性感到满意；在所有进程看到更新数据之前，可能会有一段时间的不一致性。相比之下，一些科学应用处理的是巨大但非常专业的数据集。这些系统和它们独特的挑战通常需要同样独特且通常是定制的持久化解决方案。像ACID兼容的事务SQL数据库、JDBC、Hibernate和Spring
    Data这样的通用数据管理工具，对于这些类型的系统只扮演着较小的角色。
- en: Relational systems at internet scale
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网规模的关系型系统
- en: To understand why relational systems, and the data-integrity guarantees associated
    with them, are difficult to scale, we recommend that you first familiarize yourself
    with the *CAP theorem*. According to this rule, a distributed system cannot be
    *consistent*, *available*, and *tolerant against partition failures* all at the
    same time.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么关系型系统及其相关的数据完整性保证难以扩展，我们建议您首先熟悉*CAP定理*。根据这一规则，一个分布式系统不能同时保证*一致性*、*可用性*和*对分区故障的容错性*。
- en: A system may guarantee that all nodes will see the same data at the same time
    and that data read and write requests are always answered. But when a part of
    the system fails due to a host, network, or data center problem, you must either
    give up strong consistency or 100% availability. In practice, this means you need
    a strategy that detects partition failures and restores either consistency or
    availability to a certain degree (for example, by making some part of the system
    temporarily unavailable so data synchronization can occur in the background).
    Often, the data, the user, or the operation will determine whether strong consistency
    is necessary.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一个系统可能保证所有节点将同时看到相同的数据，并且数据读写请求总是得到响应。但是，当系统的一部分由于主机、网络或数据中心问题而失败时，您必须放弃强一致性或100%的可用性。在实践中，这意味着您需要一个策略来检测分区故障，并在一定程度上恢复一致性或可用性（例如，通过暂时使系统的一部分不可用，以便在后台进行数据同步）。通常，数据、用户或操作将决定是否需要强一致性。
- en: In this book, we’ll consider the problems of data storage and sharing in the
    context of an object-oriented application that uses a *domain model*. Instead
    of directly working with the rows and columns of a `java.sql.ResultSet`, the business
    logic of the application will interact with the application-specific object-oriented
    domain model. If the SQL database schema of an online auction system has `ITEM`
    and `BID` tables, for example, the Java application defines corresponding `Item`
    and `Bid` classes. Instead of reading and writing the value of a particular row
    and column with the `ResultSet` API, the application loads and stores instances
    of `Item` and `Bid` classes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将从使用*领域模型*的对象导向应用程序的上下文中考虑数据存储和共享的问题。应用程序的业务逻辑不会直接与`java.sql.ResultSet`的行和列交互，而是与特定于应用程序的对象导向领域模型交互。例如，如果在线拍卖系统的SQL数据库模式有`ITEM`和`BID`表，Java应用程序将定义相应的`Item`和`Bid`类。应用程序不会使用`ResultSet`
    API读取和写入特定行和列的值，而是加载和存储`Item`和`Bid`类的实例。
- en: 'At runtime, the application therefore operates with instances of these classes.
    Each instance of a `Bid` has a reference to an auction `Item`, and each `Item`
    may have a collection of references to `Bid` instances. The business logic isn’t
    executed in the database (as an SQL stored procedure); it’s implemented in Java
    and executed in the application tier. This allows the business logic to use sophisticated
    object-oriented concepts such as inheritance and polymorphism. For example, we
    could use well-known design patterns such as *strategy*, *mediator*, and *composite*
    (see *Design Patterns: Elements of Reusable Object-Oriented Software* [Gamma,
    1994]), all of which depend on polymorphic method calls.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在运行时，应用程序使用这些类的实例操作。每个`Bid`实例都有一个对拍卖`Item`的引用，每个`Item`可能有一组对`Bid`实例的引用。业务逻辑不在数据库中执行（作为SQL存储过程），而是在Java中实现并在应用层执行。这允许业务逻辑使用复杂的面向对象概念，如继承和多态。例如，我们可以使用如*策略*、*中介者*和*组合*等知名设计模式（参见*设计模式：可重用面向对象软件元素*
    [Gamma, 1994]），所有这些模式都依赖于多态方法调用。
- en: 'Now a warning: not all Java applications are designed this way, nor should
    they be. Simple applications may be much better off without a domain model. Use
    the JDBC `ResultSet` if that’s all you need. Call existing stored procedures,
    and read their SQL result sets, too. Many applications need to execute procedures
    that modify large sets of data, close to the data. You might also implement some
    reporting functionality with plain SQL queries and render the results directly
    onscreen. SQL and the JDBC API are perfectly serviceable for dealing with tabular
    data representations, and the JDBC `RowSet` makes CRUD operations even easier.
    Working with such a representation of persistent data is straightforward and well
    understood.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有一个警告：并不是所有的Java应用程序都是这样设计的，也不应该这样设计。简单的应用程序可能在没有领域模型的情况下更好。如果只需要JDBC `ResultSet`，请使用它。调用现有的存储过程，并读取它们的SQL结果集。许多应用程序需要执行修改大量数据的存储过程，这些数据接近数据源。您还可以使用普通的SQL查询实现一些报告功能，并将结果直接显示在屏幕上。SQL和JDBC
    API在处理表格数据表示方面非常适用，JDBC `RowSet`使CRUD操作更加容易。与这种持久数据的表示形式一起工作简单明了，且易于理解。
- en: But for applications with nontrivial business logic, the domain model approach
    helps to improve code reuse and maintainability significantly. In practice, *both*
    strategies are common and needed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于具有非平凡业务逻辑的应用程序，领域模型方法有助于显著提高代码重用性和可维护性。在实践中，*两种*策略都是常见且必要的。
- en: For several decades, developers have spoken of a *paradigm mismatch*. The *paradigms*
    referred to are object modeling and relational modeling, or, more practically,
    object-oriented programming and SQL. This mismatch explains why every enterprise
    project expends so much effort on persistence-related concerns. With this conception,
    you can begin to see the problems—some well understood and some less well understood—that
    must be solved in an application that combines an object-oriented domain model
    and a persistent relational model. Let’s take a closer look at this so-called
    paradigm mismatch.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 几十年来，开发者一直在谈论一种*范式不匹配*。这里所指的*范式*是指对象建模和关系建模，或者更实际地说，是面向对象编程和SQL。这种不匹配解释了为什么每个企业项目都要在持久化相关问题上投入大量精力。有了这种观念，您就可以开始看到必须解决的问题——一些问题被充分理解，而另一些问题则不太被理解——这些问题必须在一个结合了面向对象领域模型和持久化关系模型的程序中解决。让我们更仔细地看看这个所谓的范式不匹配。
- en: 1.2 The paradigm mismatch
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 范式不匹配
- en: The object/relational paradigm mismatch can be broken into several parts, which
    we’ll examine one at a time. Let’s start our exploration with a simple example
    that is problem-free. As we build on it, you’ll see the mismatch begin to appear.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对象/关系范式不匹配可以分为几个部分，我们将逐一检查。让我们从一个简单且无问题的例子开始我们的探索。随着我们的构建，您将看到不匹配开始出现。
- en: Suppose you have to design and implement an online e-commerce application. In
    this application, you need a class to represent information about a user of the
    system, and you need another class to represent information about the user’s billing
    details, as shown in figure 1.1.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您必须设计和实现一个在线电子商务应用程序。在这个应用程序中，您需要一个类来表示系统用户的信息，并且您需要一个类来表示用户的账单详细信息，如图1.1所示。
- en: '![](../../OEBPS/Images/CH01_F01_Tudose2.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH01_F01_Tudose2.png)'
- en: Figure 1.1 A simple UML diagram of the `User` and `BillingDetails` entities
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 `User`和`BillingDetails`实体的简单UML图
- en: 'In this diagram, you can see that a `User` has many `BillingDetails`. This
    is a composition, indicated by the full diamond. A composition is the type of
    association where an object (`BillingDetails` in our case) cannot conceptually
    exist without the container (`User` in our case). You can navigate the relationship
    between the classes in both directions; this means you can iterate through collections
    or call methods to get to the “other” side of the relationship. The classes representing
    these entities may be extremely simple:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，您可以看到一个`User`有多个`BillingDetails`。这是一个组合，由完整的菱形表示。组合是一种关联类型，其中对象（在我们的例子中是`BillingDetails`）在概念上不能独立于容器（在我们的例子中是`User`）存在。您可以双向导航类之间的关系；这意味着您可以通过迭代集合或调用方法来访问关系的“另一边”。代表这些实体的类可能非常简单：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that we’re only interested in the state of the entities’ persistence, so
    we’ve omitted the implementation of constructors, accessor methods, and business
    methods.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只对实体的持久化状态感兴趣，因此省略了构造函数、访问方法和业务方法的实现。
- en: 'It’s easy to come up with an SQL schema design for this case (the syntax of
    the following queries is applicable to MySQL):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为此情况（以下查询的语法适用于 MySQL）设计 SQL 模式很简单：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The foreign key–constrained column `USERNAME` in `BILLINGDETAILS` represents
    the relationship between the two entities. For this simple domain model, the object/
    relational mismatch is barely in evidence; it’s straightforward to write JDBC
    code to insert, update, and delete information about users and billing details.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `BILLINGDETAILS` 中的外键约束列 `USERNAME` 代表了两个实体之间的关系。对于这个简单的领域模型，对象/关系不匹配几乎不明显；编写
    JDBC 代码来插入、更新和删除用户和账单详细信息的信息是直接的。
- en: Now let’s see what happens when we consider something a little more realistic.
    The paradigm mismatch will be visible when we add more entities and entity relationships
    to the application.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看当我们考虑一些更现实的情况时会发生什么。当我们向应用程序添加更多实体和实体关系时，范式不匹配将变得明显。
- en: 1.2.1 The problem of granularity
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.1 粒度问题
- en: The most obvious problem with the current implementation is that we’ve designed
    an address as a simple `String` value. In most systems, it’s necessary to store
    street, city, state, country, and ZIP code information separately. Of course,
    you could add these properties directly to the `User` class, but because other
    classes in the system will likely also carry address information, it makes more
    sense to create an `Address` class to reuse it. Figure 1.2 shows the updated model.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当前实现中最明显的问题是，我们将地址设计为一个简单的 `String` 值。在大多数系统中，有必要分别存储街道、城市、州、国家和邮政编码信息。当然，你可以直接将这些属性添加到
    `User` 类中，但由于系统中的其他类也可能携带地址信息，因此创建一个 `Address` 类来重用它更有意义。图 1.2 显示了更新后的模型。
- en: '![](../../OEBPS/Images/CH01_F02_Tudose2.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH01_F02_Tudose2.png)'
- en: Figure 1.2 The `User` has an `Address`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 `User` 有一个 `Address`。
- en: The relationship between `User` and `Address` is an aggregation, indicated by
    the empty diamond. Should we also add an `ADDRESS` table? Not necessarily; it’s
    common to keep address information in the `USERS` table, in individual columns.
    This design is likely to perform better because a table join isn’t needed if you
    want to retrieve the user and address in a single query. The nicest solution may
    be to create a new SQL data type to represent addresses and to add a single column
    of that new type in the `USERS` table, instead of adding several new columns.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`User` 和 `Address` 之间的关系是一个聚合，由空菱形表示。我们是否也应该添加一个 `ADDRESS` 表？不一定；在 `USERS`
    表中，将地址信息保存在单独的列中是很常见的。这种设计可能性能更好，因为如果你想要在单个查询中检索用户和地址，不需要表连接。最好的解决方案可能是创建一个新的
    SQL 数据类型来表示地址，并在 `USERS` 表中添加一个该新类型的单列，而不是添加几个新列。'
- en: This choice of adding either several columns or a single column of a new SQL
    data type is a problem of *granularity*. Broadly speaking, granularity refers
    to the relative size of the types you’re working with.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 添加几个列或单个新 SQL 数据类型的单列的选择是 *粒度* 问题。广义上讲，粒度指的是你正在使用的类型的相对大小。
- en: 'Let’s return to the example. Adding a new data type to the database catalog
    to store `Address` Java instances in a single column sounds like the best approach:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到例子。将新的数据类型添加到数据库目录中，以在单个列中存储 `Address` Java 实例，听起来是最好的方法：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A new `Address` type (class) in Java and a new `ADDRESS` SQL data type should
    guarantee interoperability. But you’ll find various problems if you check on the
    support for user-defined data types (UDTs) in today’s SQL database management
    systems.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Java 中新增的 `Address` 类型（类）和新的 `ADDRESS` SQL 数据类型应该能保证互操作性。但如果你检查当前 SQL 数据库管理系统对用户定义数据类型（UDTs）的支持，你会发现各种问题。
- en: UDT support is one of several so-called *object/relational extensions* to traditional
    SQL. This term alone is confusing, because it means the database management system
    has (or is supposed to support) a sophisticated data type system. Unfortunately,
    UDT support is a somewhat obscure feature of most SQL DBMSs, and it certainly
    isn’t portable between different products. Furthermore, the SQL standard supports
    user-defined data types, but poorly.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: UDT 支持是传统 SQL 的几种所谓 *对象/关系扩展* 之一。这个术语本身就很令人困惑，因为它意味着数据库管理系统（或应该支持）一个复杂的数据类型系统。不幸的是，UDT
    支持是大多数 SQL DBMS 的一个相对不为人知的特性，而且它肯定在不同产品之间不可移植。此外，SQL 标准支持用户定义数据类型，但支持得并不好。
- en: This limitation isn’t the fault of the relational data model. You can consider
    the failure to standardize such an important piece of functionality to be a result
    of the object/relational database wars between vendors in the mid-1990s. Today
    most engineers accept that SQL products have limited type systems—no questions
    asked. Even with a sophisticated UDT system in your SQL DBMS, you would still
    likely duplicate the type declarations, writing the new type in Java and again
    in SQL. Attempts to find a better solution for the Java space, such as SQLJ, unfortunately
    have not had much success. DBMS products rarely support deploying and executing
    Java classes directly on the database, and if support is available, it’s typically
    limited to very basic functionality in everyday usage.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这种限制并不是关系数据模型的错误。你可以将未能标准化这样重要功能的功能视为20世纪90年代中期供应商之间对象/关系数据库战争的结果。如今，大多数工程师都接受SQL产品具有有限类型系统——无需质疑。即使你的SQL数据库管理系统中有一个复杂的UDT系统，你也可能仍然需要重复类型声明，既在Java中编写新类型，又在SQL中再次编写。试图为Java空间找到更好的解决方案，如SQLJ，不幸的是并没有取得很大成功。数据库管理系统产品很少支持直接在数据库上部署和执行Java类，如果支持可用，通常也仅限于日常使用中的非常基本的功能。
- en: For these and whatever other reasons, the use of UDTs or Java types in an SQL
    database isn’t common practice at this time, and it’s unlikely that you’ll encounter
    a legacy schema that makes extensive use of UDTs. We therefore can’t and won’t
    store instances of our new `Address` class in a single new column that has the
    same data type as the Java layer.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些以及其他原因，目前在SQL数据库中使用UDTs或Java类型并不是常见做法，你不太可能遇到大量使用UDTs的遗留模式。因此，我们无法也不打算将我们新的`Address`类的实例存储在具有与Java层相同数据类型的单个新列中。
- en: 'The pragmatic solution for this problem has several columns of built-in vendor-defined
    SQL types (such as Boolean, numeric, and string data types). You’d usually define
    the `USERS` table as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的实用方案涉及多个内置的供应商定义的SQL类型列（如布尔型、数值型和字符串数据类型）。你通常会按照以下方式定义`USERS`表：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Classes in the Java domain model come in a range of levels of granularity:
    from coarse-grained entity classes like `User` to finer-grained classes like `Address`,
    down to simple `SwissZipCode` extending `AbstractNumericZipCode` (or whatever
    your desired level of abstraction is). In contrast, just two levels of type granularity
    are visible in the SQL database: relation types created by you, like `USERS` and
    `BILLINGDETAILS`, and built-in data types such as `VARCHAR`, `BIGINT`, and `TIMESTAMP`.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Java领域模型中的类具有不同粒度级别：从粗粒度的实体类如`User`到更细粒度的类如`Address`，再到简单的扩展`AbstractNumericZipCode`的`SwissZipCode`（或任何你期望的抽象级别）。相比之下，SQL数据库中只可见两个级别的类型粒度：你创建的关系类型，如`USERS`和`BILLINGDETAILS`，以及内置的数据类型，如`VARCHAR`、`BIGINT`和`TIMESTAMP`。
- en: Many simple persistence mechanisms fail to recognize this mismatch and so end
    up forcing the less flexible representation of SQL products on the object-oriented
    model, effectively flattening it. It turns out that the granularity problem isn’t
    especially difficult to solve, even if it’s visible in so many existing systems.
    We’ll look at the solution to this problem in section 5.1.1.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 许多简单的持久化机制未能认识到这种不匹配，因此最终迫使SQL产品在面向对象模型上采用更不灵活的表示形式，实际上将其扁平化。实际上，粒度问题并不特别难以解决，尽管它在许多现有系统中都可见。我们将在5.1.1节中探讨这个问题的解决方案。
- en: A much more difficult and interesting problem arises when we consider domain
    models that rely on *inheritance*, a feature of object-oriented design you may
    use to bill the users of your e-commerce application in new and interesting ways.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑依赖于*继承*的领域模型时，会出现一个更困难且更有趣的问题，继承是面向对象设计中的一个特性，你可以用它以新颖和有趣的方式对你的电子商务应用程序的用户进行计费。
- en: 1.2.2 The problem of inheritance
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.2 继承问题
- en: 'In Java, you implement type inheritance using superclasses and subclasses.
    To illustrate why this can present a mismatch problem, let’s modify our e-commerce
    application so that we now can accept not only bank account billing, but also
    credit cards. The most natural way to reflect this change in the model is to use
    inheritance for the `BillingDetails` superclass, along with multiple concrete
    subclasses: `CreditCard`, `BankAccount`. Each of these subclasses defines slightly
    different data (and completely different functionality that acts on that data).
    The UML class diagram in figure 1.3 illustrates this model.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，您通过使用超类和子类来实现类型继承。为了说明这可能会引起不匹配问题，让我们修改我们的电子商务应用程序，使其现在不仅可以接受银行账户账单，还可以接受信用卡。在模型中反映这种变化的最自然方式是使用`BillingDetails`超类的继承，以及多个具体的子类：`CreditCard`、`BankAccount`。这些子类中的每一个都定义了略微不同的数据（以及完全不同的、作用于这些数据的功能）。图1.3中的UML类图展示了这个模型。
- en: '![](../../OEBPS/Images/CH01_F03_Tudose2.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH01_F03_Tudose2.png)'
- en: Figure 1.3 Using inheritance for different billing strategies
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 使用继承实现不同的账单策略
- en: What changes must we make to support this updated Java class structure? Can
    we create a `CREDITCARD` table that *extends* `BILLINGDETAILS`? SQL database products
    don’t generally implement table inheritance (or even data type inheritance), and
    if they do implement it, they don’t follow a standard syntax.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这个更新的Java类结构，我们必须做出哪些改变？我们能否创建一个扩展`BILLINGDETAILS`的`CREDITCARD`表？SQL数据库产品通常不实现表继承（甚至数据类型继承），如果它们实现了，也不遵循标准语法。
- en: We haven’t finished with inheritance. As soon as we introduce inheritance into
    the model, we have the possibility of *polymorphism*. The `User` class has a *polymorphic
    association* with the `BillingDetails` superclass. At runtime, a `User` instance
    may reference an instance of any of the subclasses of `BillingDetails`. Similarly,
    we want to be able to write *polymorphic queries* that refer to the `BillingDetails`
    class and have the query return instances of its subclasses.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有结束对继承的讨论。一旦我们将继承引入模型，我们就有了可能实现*多态性*的可能性。`User`类与`BillingDetails`超类有一个*多态关联*。在运行时，一个`User`实例可能引用`BillingDetails`的任何子类实例。同样，我们希望能够编写*多态查询*，这些查询引用`BillingDetails`类，并返回其子类的实例。
- en: SQL databases lack an obvious way (or at least a standardized way) to represent
    a polymorphic association. A foreign key constraint refers to exactly one target
    table; it isn’t straightforward to define a foreign key that refers to multiple
    tables.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: SQL数据库缺乏一种明显的方式（或者至少是一种标准化的方式）来表示多态关联。外键约束指向一个确切的目标表；定义一个指向多个表的外键并不直接。
- en: The result of this mismatch of subtypes is that the inheritance structure in
    a model must be persisted in an SQL database that doesn’t offer an inheritance
    mechanism. In chapter 7 we’ll discuss how ORM solutions such as Hibernate solve
    the problem of persisting a class hierarchy to an SQL database table or tables,
    and how polymorphic behavior can be implemented. Fortunately, this problem is
    now well understood in the community, and most solutions support approximately
    the same functionality.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这种子类型不匹配的结果是，模型中的继承结构必须持久化到一个不提供继承机制的SQL数据库中。在第7章中，我们将讨论如何使用Hibernate等ORM解决方案将类层次结构持久化到SQL数据库表或表中，以及如何实现多态行为。幸运的是，这个问题在社区中现在已经得到了很好的理解，并且大多数解决方案都支持大约相同的功能。
- en: The next aspect of the object/relational mismatch problem is the issue of *object
    identity*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对象/关系不匹配问题的下一个方面是*对象身份*的问题。
- en: 1.2.3 The problem of identity
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.3 身份问题
- en: You probably noticed that the example defined `USERNAME` as the primary key
    of the `USERS` table. Was that a good choice? How do you handle identical objects
    in Java?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，示例中将`USERNAME`定义为`USERS`表的主键。这是一个好的选择吗？如何在Java中处理相同对象？
- en: 'Although the problem of identity may not be obvious at first, you’ll encounter
    it often in your growing and expanding e-commerce system, such as when you need
    to check whether two instances are identical. There are three ways to tackle this
    problem: two in the Java world and one in the SQL database. As expected, they
    work together only with some help.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然身份问题一开始可能不明显，但你在不断增长和扩展的电子商务系统中经常会遇到它，例如当你需要检查两个实例是否相同的时候。有三种方法可以解决这个问题：Java世界中的两种和SQL数据库中的一种。正如预期的那样，它们只有在一些帮助的情况下才能一起工作。
- en: 'Java defines two different notions of *sameness*:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Java定义了两种不同的*相同性*概念：
- en: Instance identity (roughly equivalent to a memory location, checked with `a`
    `==` `b`)
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例身份（大致相当于内存位置，通过`a` `==` `b`进行检查）
- en: Instance equality, as determined by the implementation of the `equals()` method
    (also called *equality by value*)
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例相等性，由`equals()`方法的实现确定（也称为*值相等性*）
- en: On the other hand, the identity of a database row is expressed as a comparison
    of primary key values. As you’ll see in section 9.1.2, neither `equals()` nor
    `==` is always equivalent to a comparison of primary key values. It’s common for
    several non-identical instances in Java to simultaneously represent the same row
    of a database, such as in concurrently running application threads. Furthermore,
    some subtle difficulties are involved in implementing `equals()` correctly for
    a persistent class and in understanding when this might be necessary.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，数据库行身份的表达是通过比较主键值来完成的。正如您将在第9.1.2节中看到的，`equals()`和`==`并不总是等同于主键值的比较。在Java中，几个非相同实例同时表示数据库的同一行是很常见的，例如在并发运行的应用程序线程中。此外，在实现持久化类的`equals()`方法时，以及理解何时可能需要这样做时，存在一些微妙的问题。
- en: Let’s use an example to discuss another problem related to database identity.
    In the table definition for `USERS`, `USERNAME` is the primary key. Unfortunately,
    this decision makes it difficult to change a user’s name; you need to update not
    only the row in `USERS` but also the foreign key values in (many) rows of `BILLINGDETAILS`.
    To solve this problem, later in this book we’ll recommend that you use *surrogate
    keys* whenever you can’t find a good natural key. We’ll also discuss what makes
    a good primary key. A surrogate key column is a primary key column with no meaning
    to the application user—in other words, a key that isn’t presented to the application
    user. Its only purpose is to identify data inside the application.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来讨论与数据库身份相关的问题。在`USERS`表的表定义中，`USERNAME`是主键。不幸的是，这个决定使得更改用户名变得困难；您不仅需要更新`USERS`表中的行，还需要更新（许多）`BILLINGDETAILS`表中的外键值。为了解决这个问题，本书后面我们将建议您在无法找到合适的自然键时使用*代理键*。我们还将讨论什么因素使主键成为一个好的选择。代理键列是一个对应用程序用户没有意义的键列——换句话说，一个不会呈现给应用程序用户的键。它的唯一目的是在应用程序内部标识数据。
- en: 'For example, you may change your table definitions to look like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以将表格定义修改为如下所示：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `ID` columns contain system-generated values. These columns were introduced
    purely for the benefit of the data model, so how (if at all) should they be represented
    in the Java domain model? We’ll discuss this question in section 5.2, and we’ll
    find a solution with ORM.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`ID`列包含系统生成的值。这些列纯粹是为了数据模型的好处而引入的，因此它们如何在Java领域模型中（如果有的话）表示？我们将在第5.2节中讨论这个问题，并使用ORM找到解决方案。'
- en: In the context of persistence, identity is closely related to how the system
    handles caching and transactions. Different persistence solutions have chosen
    different strategies, and this has been an area of confusion. We’ll cover all
    these interesting topics—and look at how they’re related—in section 9.1.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在持久性的背景下，身份与系统如何处理缓存和事务密切相关。不同的持久化解决方案选择了不同的策略，这已经成为一个容易混淆的领域。我们将在第9.1节中涵盖所有这些有趣的话题，并探讨它们之间的关系。
- en: 'So far, the skeleton e-commerce application we’ve designed has exposed the
    paradigm mismatch problems with mapping granularity, subtypes, and identity. We
    need to discuss further the important concept of *associations*: how the relationships
    between entities are mapped and handled. Is the foreign key constraint in the
    database all you need?'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们设计的电子商务应用的骨架已经暴露了映射粒度、子类型和身份不匹配的问题。我们需要进一步讨论重要的概念*关联*：实体之间的关系是如何映射和处理的。数据库中的外键约束是否就是您所需要的全部？
- en: 1.2.4 The problem of associations
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.4 关联问题
- en: In the domain model, associations represent the relationships between entities.
    The `User`, `Address`, and `BillingDetails` classes are all associated; but unlike
    `Address`, `BillingDetails` stands on its own. `BillingDetails` instances are
    stored in their own table. Association mapping and the management of entity associations
    are central concepts in any object persistence solution.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在领域模型中，关联表示实体之间的关系。`User`、`Address`和`BillingDetails`类都是关联的；但与`Address`不同，`BillingDetails`独立存在。`BillingDetails`实例存储在其自己的表中。关联映射和实体关联的管理是任何对象持久化解决方案中的核心概念。
- en: Object-oriented languages represent associations using *object references*,
    but in the relational world, a *foreign* *key–constrained column* represents an
    association with copies of key values. The constraint is a rule that guarantees
    the integrity of the association. There are substantial differences between the
    two mechanisms.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的语言使用*对象引用*来表示关联，但在关系型世界中，一个*外键约束列*代表与键值副本的关联。约束是一个保证关联完整性的规则。这两种机制之间存在重大差异。
- en: Object references are inherently directional; the association is from one instance
    to the other. They’re pointers. If an association between instances should be
    navigable in both directions, you must define the association *twice*, once in
    each of the associated classes. The UML class diagram in figure 1.4 illustrates
    this model with a one-to-many association.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对象引用本质上是方向性的；关联是从一个实例到另一个实例的。它们是指针。如果实例之间的关联应该双向可导航，你必须定义关联*两次*，一次在每个关联的类中。图1.4中的UML类图使用单对多关联展示了这个模型。
- en: '![](../../OEBPS/Images/CH01_F04_Tudose2.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH01_F04_Tudose2.png)'
- en: Figure 1.4 One-to-many association between `User` and `BillingDetails`
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 `User`和`BillingDetails`之间的单对多关联
- en: 'You’ve already seen this in the domain model classes:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在领域模型类中看到了这一点：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Navigation in a particular direction has no meaning for a relational data model
    because you can create data associations with *join* and *projection* operators.
    The challenge is to map a completely open data model that is independent of the
    application that works with the data to an application-dependent navigational
    model—a constrained view of the associations needed by this particular application.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定方向上的导航对于关系型数据模型没有意义，因为你可以使用*连接*和*投影*运算符创建数据关联。挑战是将一个完全开放的数据模型映射到应用程序依赖的导航模型——这个特定应用程序所需的关联的约束视图。
- en: Java associations can have *many-to-many* multiplicity. The UML class diagram
    in figure 1.5 illustrates this model.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Java关联可以有*多对多*的基数。图1.5中的UML类图展示了这个模型。
- en: '![](../../OEBPS/Images/CH01_F05_Tudose2.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH01_F05_Tudose2.png)'
- en: Figure 1.5 Many-to-many association between `User` and `BillingDetails`
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 `User`和`BillingDetails`之间的多对多关联
- en: 'The classes could look like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 类可能看起来像这样：
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'However, the foreign key declaration on the `BILLINGDETAILS` table is a *many-to-one*
    association: each bank account is linked to a particular user, but each user may
    have multiple linked bank accounts.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在`BILLINGDETAILS`表上的外键声明是一个*多对一*关联：每个银行账户都与特定的用户相关联，但每个用户可能有多个关联的银行账户。
- en: 'If you wish to represent a *many-to-many* association in an SQL database, you
    must introduce a new table, usually called a *link table*. In most cases, this
    table doesn’t appear anywhere in the domain model. For this example, if you consider
    the relationship between the user and the billing information to be many-to-many,
    you would define the link table as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望在SQL数据库中表示一个*多对多*关联，你必须引入一个新的表，通常称为*链接表*。在大多数情况下，这个表不会出现在领域模型中。对于这个例子，如果你认为用户和账单信息之间的关系是多对多，你会定义链接表如下：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You no longer need the `USER_ID` foreign key column and constraint on the `BILLINGDETAILS`
    table; this additional table now manages the links between the two entities. We’ll
    discuss association and collection mappings in detail in chapter 8.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你不再需要在`BILLINGDETAILS`表上使用`USER_ID`外键列和约束；这个额外的表现在管理两个实体之间的链接。我们将在第8章详细讨论关联和集合映射。
- en: 'So far, the problems we’ve considered are mainly *structural*: you can see
    them by considering a purely static view of the system. Perhaps the most difficult
    problem in object persistence is a *dynamic* problem: how data is accessed at
    runtime.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们考虑的问题主要是*结构性的*：你可以通过考虑系统的纯粹静态视图来看到它们。也许面向对象持久性中最困难的问题是*动态的*问题：如何在运行时访问数据。
- en: 1.2.5 The problem of data navigation
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.5 数据导航问题
- en: There is a fundamental difference between how you access data in Java code and
    within a relational database. In Java, when you access a user’s billing information,
    you call `someUser.getBillingDetails().iterator().next()` or something similar.
    Or, starting from Java 8, you may call `someUser.getBillingDetails().stream()
    .filter(someCondition).map(someMapping).forEach(billingDetails->` `{doSomething
    (billingDetails)})`. This is the most natural way to access object-oriented data,
    and it’s often described as *walking the object network*. You navigate from one
    instance to another, even iterating collections, following prepared pointers between
    classes. Unfortunately, this isn’t an efficient way to retrieve data from an SQL
    database.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java代码中访问数据和在关系数据库中访问数据之间存在根本性的区别。在Java中，当你访问一个用户的账单信息时，你调用`someUser.getBillingDetails().iterator().next()`或类似的东西。或者，从Java
    8开始，你可能调用`someUser.getBillingDetails().stream() .filter(someCondition).map(someMapping).forEach(billingDetails->`
    `{doSomething (billingDetails)})`。这是访问面向对象数据最自然的方式，通常描述为*遍历对象网络*。你从一个实例导航到另一个实例，甚至迭代集合，遵循类之间的准备好的指针。不幸的是，这不是从SQL数据库检索数据的有效方式。
- en: The single most important thing you can do to improve the performance of data
    access code is to *minimize the number of requests to the database*. The most
    obvious way to do this is to minimize the number of SQL queries. (Of course, other,
    more sophisticated, ways—such as extensive caching—follow as a second step.)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你能做的最重要的事情之一是提高数据访问代码的性能，那就是*最小化对数据库的请求数量*。做到这一点最明显的方法是最小化SQL查询的数量。（当然，其他更复杂的方法——例如广泛的缓存——可以作为第二步来实施。）
- en: 'Therefore, efficient access to relational data with SQL usually requires joins
    between the tables of interest. The number of tables included in the join when
    retrieving data determines the depth of the object network you can navigate in
    memory. For example, if you need to retrieve a `User` and aren’t interested in
    the user’s billing information, you can write this simple query:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用SQL高效访问关系数据通常需要在感兴趣的表之间进行连接。在检索数据时包含在连接中的表的数量决定了你可以在内存中导航的对象网络的深度。例如，如果你需要检索一个`User`并且不感兴趣用户的账单信息，你可以编写这个简单的查询：
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'On the other hand, if you need to retrieve a `User` and then subsequently visit
    each of the associated `BillingDetails` instances (let’s say, to list the user’s
    bank accounts), you would write a different query:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你需要检索一个`User`然后随后访问每个相关的`BillingDetails`实例（比如说，列出用户的银行账户），你需要编写一个不同的查询：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see, to use joins efficiently you need to know what portion of the
    object network you plan to access *before* you start navigating the object network!
    Careful, though: if you retrieve too much data (probably more than you might need),
    you’re wasting memory in the application tier. You may also overwhelm the SQL
    database with huge Cartesian product result sets. Imagine retrieving not only
    users and bank accounts in one query, but also all orders paid from each bank
    account, the products in each order, and so on.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，为了有效地使用连接，你需要在开始导航对象网络之前就知道你打算访问对象网络的哪一部分！不过要小心：如果你检索了太多的数据（可能比你需要的还多），你正在浪费应用层中的内存。你也可能因为巨大的笛卡尔积结果集而压倒SQL数据库。想象一下，不仅在一个查询中检索用户和银行账户，还要检索每个银行账户支付的所有订单，每个订单中的产品等等。
- en: 'Any object persistence solution permits you to fetch the data of associated
    instances only when the association is first accessed in the Java code. This is
    known as *lazy loading* : retrieving data only on demand. This piecemeal style
    of data access is fundamentally inefficient in the context of an SQL database,
    because it requires executing one statement for each node or collection of the
    object network that is accessed. This is the dreaded *n+1 selects* problem. In
    our example, you will need one *select* to retrieve a `User` and then *n selects*
    for each of the *n* associated `BillingDetails` instances.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 任何对象持久化解决方案都允许你在Java代码中首次访问关联时才获取关联实例的数据。这被称为*延迟加载*：仅在需要时检索数据。这种分块的数据访问方式在SQL数据库的上下文中基本是低效的，因为它需要为访问的对象网络中的每个节点或节点集合执行一个语句。这就是可怕的*n+1次选择*问题。在我们的例子中，你需要一个*选择*来检索一个`User`，然后为每个相关的*n个`BillingDetails`实例执行*n个*选择。
- en: This mismatch in the way you access data in Java code and within a relational
    database is perhaps the single most common source of performance problems in Java
    information systems. Avoiding the Cartesian product and *n*+1 selects problems
    is still a problem for many Java programmers. Hibernate provides sophisticated
    features for efficiently and transparently fetching networks of objects from the
    database to the application accessing them. We’ll discuss these features in chapter
    12.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java代码中访问数据的方式与关系数据库中的方式不匹配，这可能是Java信息系统中最常见的性能问题来源。避免笛卡尔积和*n*+1选择问题仍然是许多Java程序员面临的问题。Hibernate提供了高效且透明地从数据库到访问它们的应用程序中检索对象网络的高级功能。我们将在第12章中讨论这些功能。
- en: 'We now have quite a list of object/relational mismatch problems: the problem
    of granularity, the problem of inheritance, the problem of identity, the problem
    of associations, and the problem of data navigation. It can be costly (in time
    and effort) to find solutions, as you may know from experience. It will take us
    a large part of this book to provide detailed answers to these questions and to
    demonstrate ORM as a viable solution. Let’s get started with an overview of ORM,
    the Java Persistence standard (JPA), and the Hibernate and Spring Data projects.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一长串对象/关系不匹配问题：粒度问题、继承问题、标识问题、关联问题以及数据导航问题。找到解决方案可能会耗费大量时间与精力，正如你可能从经验中得知的那样。本书的大部分内容将用于提供对这些问题的详细答案，并展示ORM作为一种可行的解决方案。让我们从ORM、Java持久化标准（JPA）以及Hibernate和Spring
    Data项目概述开始。
- en: 1.3 ORM, JPA, Hibernate, and Spring Data
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 ORM、JPA、Hibernate和Spring Data
- en: In a nutshell, object/relational mapping (ORM) is the automated (and transparent)
    persistence of objects in a Java application to the tables in an RDBMS (relational
    database management system), using metadata that describes the mapping between
    the classes of the application and the schema of the SQL database. In essence,
    ORM works by transforming (reversibly) data from one representation to another.
    A program using ORM will provide the meta-information about how to map the objects
    from the memory to the database, and the effective transformation will be fulfilled
    by ORM.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，对象/关系映射（ORM）是将Java应用程序中的对象自动（且透明地）持久化到关系数据库管理系统（RDBMS）的表中，使用描述应用程序类与SQL数据库模式之间映射的元数据。本质上，ORM通过（可逆地）将数据从一种表示形式转换为另一种表示形式来工作。使用ORM的程序将提供有关如何将对象从内存映射到数据库的元信息，而有效的转换将由ORM完成。
- en: Some people may consider one advantage of ORM to be that it shields developers
    from messy SQL. This view holds that object-oriented developers shouldn’t be expected
    to go deep into SQL or relational databases. On the contrary, Java developers
    must have a sufficient level of familiarity with—and appreciation of—relational
    modeling and SQL to work with Hibernate and Spring Data. ORM is an advanced technique
    used by developers who have already done it the hard way.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能认为ORM的一个优点是它保护开发者免受混乱的SQL的困扰。这种观点认为，面向对象的开发者不应该期望深入SQL或关系数据库。相反，Java开发者必须对关系建模和SQL有足够的熟悉程度和欣赏能力，才能与Hibernate和Spring
    Data一起工作。ORM是那些已经艰难地完成过这项工作的开发者所使用的一种高级技术。
- en: JPA (Jakarta Persistence API, formerly Java Persistence API) is a specification
    defining an API that manages the persistence of objects and object/relational
    mappings. Hibernate is the most popular implementation of this specification.
    So, JPA will specify what must be done to persist objects, while Hibernate will
    determine how to do it. Spring Data Commons, as part of the Spring Data family,
    provides the core Spring framework concepts that support all Spring Data modules.
    Spring Data JPA, another project from the Spring Data family, is an additional
    layer on top of JPA implementations (such as Hibernate). Not only can Spring Data
    JPA use all the capabilities of JPA, but it adds its own capabilities, such as
    generating database queries from method names. We’ll go into many details in this
    book, but if you would like an overall view right now, you can quickly jump ahead
    to figure 4.1.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: JPA（Jakarta Persistence API，之前称为Java Persistence API）是一个定义了管理对象持久化和对象/关系映射的API的规范。Hibernate是这个规范最流行的实现。因此，JPA将指定持久化对象必须执行的操作，而Hibernate将决定如何执行。Spring
    Data Commons作为Spring Data家族的一部分，提供了支持所有Spring Data模块的核心Spring框架概念。Spring Data
    JPA是Spring Data家族中的另一个项目，它是JPA实现（如Hibernate）之上的一个额外层。Spring Data JPA不仅能够使用JPA的所有功能，还增加了自己的功能，例如从方法名称生成数据库查询。本书将深入探讨许多细节，但如果你现在想获得一个整体的观点，可以快速跳转到图4.1。
- en: To use Hibernate effectively, you must be able to view and interpret the SQL
    statements it issues and understand their performance implications. To take advantage
    of the benefits of Spring Data, you must be able to anticipate how the boilerplate
    code and the generated queries are created.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地使用Hibernate，你必须能够查看和解释它发出的SQL语句，并理解其性能影响。为了利用Spring Data的好处，你必须能够预测样板代码和生成的查询是如何创建的。
- en: 'The JPA specification defines the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: JPA规范定义了以下内容：
- en: A facility for specifying mapping metadata—how persistent classes and their
    properties relate to the database schema. JPA relies heavily on Java annotations
    in domain model classes, but you can also write mappings in XML files.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种指定映射元数据的方法——持久化类及其属性如何与数据库模式相关联。JPA在领域模型类中大量依赖于Java注解，但你也可以在XML文件中编写映射。
- en: APIs for performing basic CRUD operations on instances of persistent classes,
    most prominently `javax.persistence.EntityManager` for storing and loading data.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于在持久化类实例上执行基本CRUD操作的API，最著名的是`javax.persistence.EntityManager`用于存储和加载数据。
- en: A language and APIs for specifying queries that refer to classes and properties
    of classes. This language is the Jakarta Persistence Query Language (JPQL) and
    it looks similar to SQL. The standardized API allows for the programmatic creation
    of *criteria queries* without string manipulation.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种用于指定引用类和类属性的查询的语言和API。这种语言是Jakarta Persistence Query Language（JPQL），其外观类似于SQL。标准化的API允许通过程序创建*条件查询*，而不需要字符串操作。
- en: How the persistence engine interacts with transactional instances to perform
    dirty checking, association fetching, and other optimization functions. The JPA
    specification covers some basic caching strategies.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久化引擎如何与事务实例交互以执行脏检查、关联抓取和其他优化功能。JPA规范涵盖了某些基本的缓存策略。
- en: 'Hibernate implements JPA and supports all the standardized mappings, queries,
    and programming interfaces. Let’s look at some of the benefits of Hibernate:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate实现了JPA并支持所有标准化的映射、查询和编程接口。让我们看看Hibernate的一些好处：
- en: '*Productivity*—Hibernate eliminates much of the repetitive work (more than
    you’d expect) and lets you concentrate on the business problem. No matter which
    application-development strategy you prefer—top-down (starting with a domain model)
    or bottom-up (starting with an existing database schema)—Hibernate, used together
    with the appropriate tools, will significantly reduce development time.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*生产力*——Hibernate消除了大量重复性工作（比你预期的要多），让你能够专注于业务问题。无论你更喜欢哪种应用程序开发策略——自顶向下（从领域模型开始）还是自底向上（从现有的数据库模式开始），与适当的工具一起使用Hibernate将显著减少开发时间。'
- en: '*Maintainability*—Automated ORM with Hibernate reduces lines of code, making
    the system more understandable and easier to refactor. Hibernate provides a buffer
    between the domain model and the SQL schema, isolating each model from minor changes
    to the other.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可维护性*——使用Hibernate的自动ORM减少了代码行数，使系统更易于理解且更容易重构。Hibernate在领域模型和SQL模式之间提供了一个缓冲区，隔离每个模型免受对方微小变化的影响。'
- en: '*Performance*—Although hand-coded persistence might be faster in the same sense
    that assembly code can be faster than Java code, automated solutions like Hibernate
    allow the use of many optimizations *at all times*. One example is the efficient
    and easily tunable caching in the application tier. This means developers can
    spend more energy hand-optimizing the few remaining real bottlenecks instead of
    prematurely optimizing everything.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*性能*—尽管手动编码的持久性可能在某种程度上比汇编代码比 Java 代码更快，但像 Hibernate 这样的自动化解决方案允许始终使用许多优化。一个例子是应用层中高效且易于调整的缓存。这意味着开发者可以将更多精力用于手动优化剩余的少数真实瓶颈，而不是过早地优化一切。'
- en: '*Vendor independence*—Hibernate can help mitigate some of the risks associated
    with vendor lock-in. Even if you plan never to change your DBMS product, ORM tools
    that support several different DBMSs enable a certain level of portability. Also,
    DBMS independence helps in development scenarios where engineers use a lightweight
    local database but deploy for testing and production on a different system.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*供应商独立性*—Hibernate 可以帮助减轻与供应商锁定相关的某些风险。即使您计划永远不会更改您的 DBMS 产品，支持多个不同 DBMS 的
    ORM 工具也能提供一定程度的可移植性。此外，DBMS 独立性有助于工程师在开发场景中使用轻量级本地数据库，但在测试和生产时部署到不同的系统上。'
- en: 'Spring Data makes the implementation of the persistence layer even more efficient.
    Spring Data JPA, one of the projects of the family, sits on top of the JPA layer.
    Spring Data JDBC, another project of the family, sits on top of JDBC. Let’s look
    at some of the benefits of Spring Data:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data 使持久层的实现更加高效。Spring Data JPA 是该家族中的一个项目，位于 JPA 层之上。Spring Data JDBC
    是该家族中的另一个项目，位于 JDBC 之上。让我们看看 Spring Data 的一些好处：
- en: '*Shared infrastructure—*Spring Data Commons, part of the umbrella Spring Data
    project, provides a metadata model for persisting Java classes and technology-neutral
    repository interfaces. It provides its capabilities to the other Spring Data projects.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*共享基础设施*—Spring Data Commons 是 Spring Data 项目的一部分，为持久化 Java 类和提供技术中立仓库接口提供了元数据模型。它将其能力提供给其他
    Spring Data 项目。'
- en: '*Removes DAO implementations*—JPA implementations use the *data access object*
    (DAO) pattern. This pattern starts with the idea of an abstract interface to a
    database and maps application calls to the persistence layer while hiding the
    details of the database. Spring Data JPA makes it possible to fully remove DAO
    implementations, so the code will be shorter.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*移除 DAO 实现*—JPA 实现使用 *数据访问对象*（DAO）模式。这种模式从抽象接口到数据库的概念开始，将应用程序调用映射到持久化层，同时隐藏数据库的细节。Spring
    Data JPA 使得完全移除 DAO 实现成为可能，因此代码会更短。'
- en: '*Automatic class creation*—Using Spring Data JPA, a DAO interface needs to
    extend the JPA-specific `Repository` interface—`JpaRepository`. Spring Data JPA
    will automatically create an implementation for this interface—the programmer
    will not have to take care of this.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自动类创建*—使用 Spring Data JPA，一个 DAO 接口需要扩展 JPA 特定的 `Repository` 接口—`JpaRepository`。Spring
    Data JPA 将自动为该接口创建实现—程序员无需关心这一点。'
- en: '*Default implementations for methods*—Spring Data JPA will generate default
    implementations for each method defined by its repository interfaces. Basic CRUD
    operations do not need to be implemented any longer. This reduces the boilerplate
    code, speeds up development, and removes the possibility of introducing bugs.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*方法的默认实现*—Spring Data JPA 将为它的仓库接口中定义的每个方法生成默认实现。基本的 CRUD 操作不再需要实现。这减少了样板代码，加快了开发速度，并消除了引入错误的可能性。'
- en: '*Generated queries*—You may define a method on your repository interface following
    a naming pattern. There’s no need to write your queries by hand; Spring Data JPA
    will parse the method name and create a query for it.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*生成的查询*—您可以在您的仓库接口上根据命名模式定义一个方法。您无需手动编写查询；Spring Data JPA 将解析方法名称并为其创建查询。'
- en: '*Close to the database if needed*—Spring Data JDBC can communicate directly
    with the database and avoid the “magic” of Spring Data JPA. It allows you to interact
    with the database through JDBC, but it removes the boilerplate code by using the
    Spring framework facilities.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*需要时接近数据库*—Spring Data JDBC 可以直接与数据库通信并避免 Spring Data JPA 的“魔法”。它允许您通过 JDBC
    与数据库交互，但通过使用 Spring 框架功能来移除样板代码。'
- en: 'This chapter has focused on understanding object/relational persistence and
    the problems generated by the object/relational paradigm mismatch. Chapter 2 will
    look at some of the persistence alternatives for a Java application: JPA, Hibernate
    Native, and Spring Data JPA.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了理解对象/关系持久化和对象/关系范式不匹配产生的问题。第 2 章将探讨 Java 应用程序的一些持久化替代方案：JPA、Hibernate
    Native 和 Spring Data JPA。
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: With *object persistence*, individual objects can outlive their application
    process, be saved to a data store, and be re-created later. The object/relational
    mismatch comes into play when the data store is an SQL-based relational database
    management system. For example, a network of objects can’t be saved to a database
    table; it must be disassembled and persisted to columns of portable SQL data types.
    A good solution to this problem is object/relational mapping (ORM).
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *对象持久化* 中，单个对象可以超出其应用程序过程，保存到数据存储中，并在以后重新创建。当数据存储是一个基于 SQL 的关系型数据库管理系统时，对象/关系不匹配就会发挥作用。例如，一个对象网络不能保存到数据库表中；它必须被拆分并持久化到可移植的
    SQL 数据类型列中。解决这个问题的好方法是对象/关系映射（ORM）。
- en: ORM isn’t a silver bullet for all persistence tasks; its job is to relieve the
    developer of about 95% of object persistence work, such as writing complex SQL
    statements with many table joins and copying values from JDBC result sets to objects
    or graphs of objects.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ORM 并非所有持久化任务的万能药；它的任务是减轻开发者大约 95% 的对象持久化工作，例如编写包含多个表连接的复杂 SQL 语句，以及从 JDBC 结果集中复制值到对象或对象图中。
- en: A full-featured ORM middleware solution may provide database portability, certain
    optimization techniques like caching, and other viable functions that aren’t easy
    to hand-code in a limited time with SQL and JDBC. An ORM solution implies, in
    the Java world, the JPA specification and a JPA implementation—Hibernate being
    the most popular nowadays.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个功能齐全的 ORM 中间件解决方案可能提供数据库可移植性、某些优化技术如缓存以及其他不易在有限时间内使用 SQL 和 JDBC 手动编写的可行功能。在
    Java 世界中，ORM 解决方案意味着 JPA 规范和 JPA 实现——Hibernate 目前是最受欢迎的。
- en: Spring Data may come on top of the JPA implementations, and it simplifies, even
    more, the data persistence process. It is an umbrella project that adheres to
    the Spring framework principles and comes with an even simpler approach, including
    removing the DAO pattern, automatic code generation, and automatic query generation.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data 可能建立在 JPA 实现之上，并且进一步简化了数据持久化过程。它是一个遵循 Spring 框架原则的伞形项目，提供了一种更加简单的方法，包括移除
    DAO 模式、自动代码生成和自动查询生成。
