- en: Chapter 6\. Contract tests
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 6 章. 合约测试
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Understanding and writing contract tests
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和编写合约测试
- en: Using consumer-driven contracts
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用消费者驱动的合约
- en: Working with Pact JVM
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Pact JVM 合作
- en: Integrating with Arquillian
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Arquillian 集成
- en: So far in this book, you’ve learned about unit, component, and integration tests.
    One thing they have in common is that they don’t test the entire application,
    but rather isolated parts of it. With unit tests, the unit under test consists
    of only one or a few classes; with integration tests, you test whether boundaries
    can connect to a real service. This is the first chapter in which you’ll write
    tests to understand the application as a whole. In this chapter, you’ll learn
    why it’s important to use contract tests to verify the entire system, and how
    to write them.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，你已经学习了单元测试、组件测试和集成测试。它们共同的一点是它们不测试整个应用程序，而是测试其隔离的部分。使用单元测试，被测试的单元只包含一个或几个类；使用集成测试，你测试边界是否可以连接到真实的服务。这是你将第一次编写测试来理解整个应用程序的章节。在本章中，你将了解为什么使用合约测试来验证整个系统很重要，以及如何编写它们。
- en: 6.1\. Understanding contracts
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1. 理解合约
- en: 'The microservices architecture involves a lot of intercommunication between
    microservices. In this book’s Gamer example, you saw interactions between the
    aggregator service, the video service, the comments service, and so on. These
    interactions effectively form a contract between the services: this contract consists
    of expectations of input and output data as well as pre- and post-conditions.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构涉及微服务之间的大量交互。在本书的 Gamer 示例中，你看到了聚合服务、视频服务、评论服务等的交互。这些交互实际上形成了服务之间的合约：这个合约包括对输入和输出数据的期望以及前置和后置条件。
- en: A contract is formed for each service that *consumes* data from another service,
    which provides (or *produces*) data based on the first service’s requirements.
    If the service that produces data can change over time, it’s important that the
    contracts with each service that consumes data from it continue to meet expectations.
    *Contract tests* provide a mechanism to explicitly verify that a component meets
    a contract.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个从其他服务消费数据的 *消费* 数据的服务，都会形成一个合约，该服务基于第一个服务的需求提供（或 *生产*）数据。如果生成数据的服务可以随时间变化，那么确保与每个消费其数据的服务的合约继续满足期望是很重要的。*合约测试*
    提供了一种机制，可以显式验证组件是否满足合约。
- en: 6.1.1\. Contracts and monolithic applications
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.1. 合约与单体应用程序
- en: In a monolithic application, services are developed in the same project, side
    by side. What makes them look different is that each service is developed in a
    separate module or subproject, running under the same runtime.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体应用程序中，服务是在同一个项目中，并排开发的。使它们看起来不同的地方是，每个服务都是在独立的模块或子项目中开发的，在相同的运行时下运行。
- en: 'In this kind of application, you don’t need to worry about breaking the contract
    (or compatibility) between services, because there’s an invisible verifier called
    a *compiler*. If one service changes its contract, the compiler will reject that
    build due to a compilation error. Let’s look at an example. Here’s serviceA.jar:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这类应用中，你不需要担心服务之间合约（或兼容性）的破坏，因为有一个无形验证器，称为 *编译器*。如果一个服务更改了其合约，编译器将因为编译错误而拒绝该构建。让我们看看一个例子。这是
    serviceA.jar：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And this is serviceB.jar:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 serviceB.jar：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The two services, service A and service B, are developed in two different JAR
    files. Service A calls service B by calling its method `createMessage`, which
    requires that you pass it two `String` parameters. And precisely this method is
    the contract between both services.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个服务，服务 A 和服务 B，是在两个不同的 JAR 文件中开发的。服务 A 通过调用其方法 `createMessage` 来调用服务 B，该方法要求你传递两个
    `String` 参数。正是这个方法构成了两个服务之间的合约。
- en: But what if service A changes its contract to something like the following?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果服务 A 将其合约更改为以下内容呢？
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The method signature has been changed to receive one `String` and one `Integer`.
    This breaks compatibility with service B (one consumer of the service). This isn’t
    an issue in a monolithic application, because you’ll get a compilation error informing
    you that method `createMessage` requires `(String, Integer)` but `(String, String)`
    was found. Thus it’s quick and easy to detect when a contract is broken.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 方法签名已更改，以接收一个 `String` 和一个 `Integer`。这破坏了与服务 B（服务的消费者）的兼容性。在单体应用程序中这不是问题，因为你会得到一个编译错误，告诉你方法
    `createMessage` 需要的是 `(String, Integer)`，但找到的是 `(String, String)`。因此，当合约被破坏时，检测起来既快又简单。
- en: From the point of view of testing, modules can be set in the test logic by instantiating
    them using the `new` keyword or, with container support like context dependency
    injection (CDI) or Spring inversion of control (IoC), by using Arquillian or the
    Spring Test Framework. But in with a microservices architecture, things become
    more complex and harder to detect. If a contract between two services is broken,
    it may not be detected for quite some time.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从测试的角度来看，可以通过使用 `new` 关键字实例化它们或在具有容器支持（如上下文依赖注入（CDI）或Spring控制反转（IoC））的情况下，使用Arquillian或Spring测试框架来设置模块在测试逻辑中。但在微服务架构中，事情变得更加复杂，也更难检测。如果两个服务之间的合同被破坏，可能需要相当长的时间才能检测到。
- en: 6.1.2\. Contracts and microservice applications
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.2。合同和微服务应用
- en: Each microservice has its own lifecycle, is deployed in its own runtime, and
    lives remotely from other microservices. In this scenario, any change to the contract
    of one service can’t be caught by the compiler. [Figure 6.1](kindle_split_015_split_001.xhtml#ch06fig01)
    illustrates how each service runs in a different runtime.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务都有自己的生命周期，在自己的运行时中部署，并且与其他微服务远程运行。在这种情况下，对某个服务合同的任何更改都无法被编译器捕获。[图6.1](kindle_split_015_split_001.xhtml#ch06fig01)说明了每个服务如何在不同的运行时中运行。
- en: Figure 6.1\. Big-picture overview of the example application
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.1。示例应用程序的大图概览
- en: '![](Images/06fig01_alt.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06fig01_alt.jpg)'
- en: Breaking the compatibility between services could happen and would be hard to
    detect. It’s easier to break compatibility because you don’t have direct feedback
    that something has been broken. It’s harder to detect that you’ve broken compatibility
    because, depending on the kind of (or lack of) tests you run, you may find the
    problem in (pre)production environments.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 服务之间的兼容性破坏可能发生，并且很难检测。由于你没有直接的反馈来确认某些东西已经被破坏，因此破坏兼容性更容易。由于你运行的是（或缺少）测试的类型，你可能在（预）生产环境中发现问题，因此检测你已破坏兼容性更难。
- en: Usually, each service is developed by a different team, making compatibility
    issues more complicated to detect if there isn’t good communication between teams.
    In our experience, the most common problems come from a change in the *provider*
    side so that the *consumer* can’t interact with the provider.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，每个服务都是由不同的团队开发的，如果没有良好的团队间沟通，兼容性问题就更加难以检测。根据我们的经验，最常见的问题来自提供方的一处更改，使得消费者无法与提供方交互。
- en: 'The most common issues are these:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的问题如下：
- en: A service renames its endpoint URL.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个服务重命名了其端点URL。
- en: A service adds a new mandatory parameter.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个服务添加了一个新的必填参数。
- en: A service changes/removes an existing parameter.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个服务更改/删除了现有的参数。
- en: A service changes the validation expression of input parameters.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个服务更改了输入参数的验证表达式。
- en: A service changes its response type or status code.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个服务更改了其响应类型或状态码。
- en: Consider an example where you have two services, producer and consumer A. The
    producer service exposes a blog-post resource in JSON format, which is consumed
    by consumer A.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个例子，其中你有两个服务，生产者和消费者A。生产者服务以JSON格式公开一个博客文章资源，该资源被消费者A消费。
- en: 'A possible representation of this document might be thus:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 该文档的一个可能的表示可能是这样的：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The message contains four attributes: `id`, `body`, `created`, and `author`.
    Consumer A interacts only with the `body` and `author` fields, ignoring the others.
    This is summarized in [figure 6.2](kindle_split_015_split_001.xhtml#ch06fig02).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 消息包含四个属性：`id`、`body`、`created` 和 `author`。消费者A仅与 `body` 和 `author` 字段交互，忽略其他字段。这总结在[图6.2](kindle_split_015_split_001.xhtml#ch06fig02)中。
- en: Figure 6.2\. Data exchange between producer and consumer A
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.2。生产者和消费者A之间的数据交换
- en: '![](Images/06fig02.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06fig02.jpg)'
- en: After some time, a new consumer consumes the producer resource API. This new
    consumer, consumer B, requires both the `author` and `body` fields, as well a
    new field (`author id`) that’s the identifier for the blog post’s author.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一段时间后，一个新的消费者开始使用生产者资源API。这个新的消费者，消费者B，需要 `author` 和 `body` 字段，以及一个新的字段（`author
    id`），它是博客文章作者的标识符。
- en: 'At this point, the maintainers of the producer service can take two different
    approaches:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，生产者服务的维护者可以采取两种不同的方法：
- en: Add a new field at the root level.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在根级别添加一个新字段。
- en: Create a composite object with the `author` field.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `author` 字段创建一个复合对象。
- en: 'The first approach adds a new field to the document called `authorId` at same
    level as `author`. A representation of this document might be as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是在文档中添加一个新的字段，称为 `authorId`，与 `author` 字段处于同一级别。该文档的一个表示可能如下所示：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With this change, consumer B’s requirements are met. If consumer A follows *Postel’s
    Law*, it will be able to continue consuming messages from the producer service.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这种改变满足了消费者B的需求。如果消费者A遵循*Postel定律*，它将能够继续从生产者服务消费消息。
- en: '|  |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**The robustness principle**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**鲁棒性原则**'
- en: 'The *Robustness Principle*, also known as *Postel’s Law*, comes from Jon Postel.
    He wrote an early specification of the TCP protocol and asserted the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*鲁棒性原则*，也称为*Postel定律*，来源于Jon Postel。他撰写了TCP协议的早期规范，并提出了以下观点：'
- en: '*Be conservative in what you do, be liberal in what you accept from others.*'
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*在行动上要保守，在接受他人时要宽容。*'
- en: ''
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Jon Postel*'
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Jon Postel*'
- en: This was an awful principle when applied to HTML, because it created the ridiculous
    browser battles that have now been largely resolved by a much stricter HTML5 specification.
    But for payload parsing, this principle still holds true. In other words, adapted
    to our case, producers and consumers should ignore any payload fields that aren’t
    important to them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用于HTML时，这是一个糟糕的原则，因为它导致了现在主要由更严格的HTML5规范在很大程度上解决的荒谬的浏览器之战。但对于有效载荷解析来说，这个原则仍然适用。换句话说，适应我们的情况，生产者和消费者应该忽略任何对他们不重要的有效载荷字段。
- en: '|  |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[Figure 6.3](kindle_split_015_split_001.xhtml#ch06fig03) shows that both consumers
    can still consume messages from the provider. But suppose the maintainers decide
    on the second approach and create a composite object from the `authorInfo` field:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6.3](kindle_split_015_split_001.xhtml#ch06fig03)显示，两个消费者仍然可以消费来自提供者的消息。但假设维护者决定采用第二种方法，并从`authorInfo`字段创建一个组合对象：'
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Figure 6.3\. Data exchange between producer and consumers A and B
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.3\. 生产者与消费者A和B之间的数据交换
- en: '![](Images/06fig03_alt.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06fig03_alt.jpg)'
- en: With this change, consumer B’s requirements are met, but the change breaks compatibility
    with consumer A. In [figure 6.4](kindle_split_015_split_001.xhtml#ch06fig04),
    you can see that although consumer B can process messages from the provider, consumer
    A can’t, because it expects an `author` field of type `string`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这种改变满足了消费者B的需求，但破坏了与消费者A的兼容性。在[图6.4](kindle_split_015_split_001.xhtml#ch06fig04)中，你可以看到，尽管消费者B可以处理来自提供者的消息，但消费者A不能，因为它期望一个类型为`string`的`author`字段。
- en: Figure 6.4\. Updated data-exchange scheme
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.4\. 更新的数据交换方案
- en: '![](Images/06fig04_alt.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06fig04_alt.jpg)'
- en: This change would be caught at compilation time if you were using the monolithic
    approach, but in this case, you don’t know about it immediately. From the producer’s
    point of view, even if all of its tests pass, you still don’t know that the contract
    has been broken.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是单体方法，这个问题会在编译时被发现，但在这个情况下，你不会立即知道它。从生产者的角度来看，即使所有测试都通过，你仍然不知道合同已被破坏。
- en: This problem will occur with consumer services, when the new producer service
    is deployed into a full environment with all services running and operating normally.
    At this point, consumers will begin operating incorrectly, because the contract
    has been broken. A new patch should be developed for all consumer services that
    have adapted the producer API and are now failing.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当新的生产者服务部署到包含所有服务正常运行的全环境时，这个问题会在消费者服务中出现。此时，消费者将开始错误地运行，因为合同已被破坏。应该为所有已适应生产者API但现在失败的消费者服务开发一个新的补丁。
- en: The later you catch a bug, the harder it is to fix it—and, depending on the
    phase in application deployment, the urgency can be severe. Suppose you found
    this bug in a production environment. At this phase, you’d need to roll back the
    new producer service to the old one, as well as all consumers that have been updated,
    to get the environment up and running again. Then you’d spend a substantial amount
    of time determining why the deployment failed and fixing it. The graph in [figure
    6.5](kindle_split_015_split_001.xhtml#ch06fig05) shows the cost of a bug found
    during different phases of a project.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你发现错误的时间越晚，修复它就越困难——并且，根据应用程序部署的阶段，紧迫性可能会非常严重。假设你在生产环境中发现了这个错误。在这个阶段，你需要将新的生产者服务回滚到旧版本，以及所有已更新的消费者，以使环境重新运行。然后你需要花费大量时间确定部署失败的原因并修复它。图[6.5](kindle_split_015_split_001.xhtml#ch06fig05)显示了在项目不同阶段发现错误的成本。
- en: Figure 6.5\. Costs of fixing bugs in specific development phases
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.5\. 在特定开发阶段修复错误的成本
- en: '![](Images/06fig05_alt.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06fig05_alt.jpg)'
- en: Using a microservices architecture implies changing the way services are tested
    to detect such issues before a new producer service is deployed. Ideally, bugs
    should be detected in your CI/delivery run during the testing stage.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务架构意味着改变服务测试的方式，以便在部署新的生产者服务之前检测到这些问题。理想情况下，应该在CI/交付运行期间的测试阶段检测到错误。
- en: '|  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Deprecation method**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**弃用方法**'
- en: 'You can also mix the two approaches to solving this problem, by deprecating
    the `author` field instead of removing it. The new document looks like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过弃用`author`字段而不是删除它来混合两种解决问题的方法。新的文档看起来像这样：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A new field called `authorInfo` has been created, and `author` is still valid
    but deprecated. This approach doesn’t replace any tests, because you’ll still
    have the same problem whenever you decide to remove the deprecated fields. But
    at least there’s a transition, and there may be time for consumer maintainers
    to be notified about the change and adapt to it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 已创建一个新的字段`authorInfo`，而`author`仍然有效但已弃用。这种方法不会替换任何测试，因为无论何时决定删除弃用的字段，你都会遇到相同的问题。但至少有一个过渡，并且消费者维护者可能有时间被告知更改并适应它。
- en: '|  |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 6.1.3\. Verifying with integration tests
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.3\. 使用集成测试进行验证
- en: In [chapter 5](kindle_split_014_split_000.xhtml#ch05), you saw that you use
    integration tests to test whether it’s possible for one system to communicate
    with another. Expressed in contract terms, you’re testing that the *boundary*
    or *gateway* class of a given consumer can communicate correctly with a provider
    to get or post some data.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](kindle_split_014_split_000.xhtml#ch05)中，你看到您使用集成测试来测试一个系统是否可以与另一个系统通信。用合约术语表达，你正在测试给定消费者中的*边界*或*网关*类是否可以正确与提供者通信以获取或发布一些数据。
- en: You may think that integration tests cover the use case where a contract is
    broken. But this approach has some issues that make running such tests for services
    difficult.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为集成测试涵盖了合约被破坏的使用场景。但这种方法存在一些问题，使得对服务进行此类测试变得困难。
- en: First, the consumer must know how to boot up the provider. Second, the consumer
    may depend on several providers. Each provider may have different requirements,
    such as a database or other services. So, starting a provider can imply starting
    several services and, without noticing it, converting integration tests into end-to-end
    tests.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，消费者必须知道如何启动提供者。其次，消费者可能依赖于多个提供者。每个提供者可能有不同的要求，例如数据库或其他服务。因此，启动提供者可能意味着启动多个服务，并且在不经意间将集成测试转换为端到端测试。
- en: The third and most important issue is that you need to create a direct relationship
    between the producer and all of its consumers. When any change is made to the
    producer, integration tests from all consumers related to this producer must be
    run to ensure that they can still communicate with the provider. This arrangement
    is difficult to maintain, because for each new consumer, you need to notify the
    producer team and provide a new set of running tests.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个也是最重要的问题是，您需要在生产者和所有消费者之间创建直接关系。当对生产者进行任何更改时，必须运行与该生产者相关的所有消费者的集成测试，以确保它们仍然可以与提供者通信。这种安排难以维护，因为对于每个新的消费者，您需要通知生产者团队并提供一组新的运行测试。
- en: Although integration tests might be a solution for verifying that consumers
    of one producer can connect, such tests may not always be the best approach to
    follow.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管集成测试可能是一种验证一个生产者的消费者可以连接的解决方案，但这些测试并不总是最佳的方法。
- en: 6.1.4\. What are contract tests?
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.4\. 什么是合约测试？
- en: As mentioned, a contract is a list of agreements between a service that acts
    as a client (or consumer) and another service that acts as a provider. The existence
    of a contract defining interactions between each consumer and its provider fixes
    all the problems described in [section 6.1.3](kindle_split_015_split_001.xhtml#ch06lev2sec3).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，合约是一系列协议，由充当客户端（或消费者）的服务与充当提供者的另一个服务之间达成。定义每个消费者与其提供者之间交互的合约的存在，解决了[第6.1.3节](kindle_split_015_split_001.xhtml#ch06lev2sec3)中描述的所有问题。
- en: In [figure 6.6](kindle_split_015_split_001.xhtml#ch06fig06), a contract between
    consumers and a provider is defined—let’s say, by having a file describe it—and
    thus both provider and consumers have an agreement to follow. Now the relationship
    between consumers and the provider is indirect, because from the producer’s point
    of view, you only need to verify that it meets the agreement described in the
    contract. The provider doesn’t need to run the consumer’s integration tests; it
    only needs to test that the consumer is able to consume requests and produce responses
    following the contract.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图6.6](kindle_split_015_split_001.xhtml#ch06fig06)中，定义了消费者和供应商之间的合同——比如说，通过一个文件来描述它——因此供应商和消费者都有遵守合同的协议。现在，消费者和供应商之间的关系是间接的，因为从生产者的角度来看，你只需要验证它是否符合合同中描述的协议。供应商不需要运行消费者的集成测试；它只需要测试消费者能否根据合同消费请求并生成响应。
- en: Figure 6.6\. Provider and consumer interactions
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.6\. 供应商和消费者交互
- en: '![](Images/06fig06.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06fig06.jpg)'
- en: In this case, each provider has a/many contract(s) between it and all the consumers
    that are provisioning data. For every change made to a provider, all contracts
    are verified to detect any break, without having to run integration tests.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，每个供应商与其提供数据的所有消费者之间都有一个/多个合同。对于对供应商所做的每个更改，都会验证所有合同以检测任何中断，而无需运行集成测试。
- en: The contract is also validated on the consumer side, verifying that its client
    classes (*gateways*) follow the contract. Notice that, again, you don’t need to
    know how a producer is booted up or start any external dependency that may depend
    on it, because verifying the contract doesn’t imply starting the producer; you’re
    only verifying that the consumer also meets the contract.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 合同也在消费者端进行验证，验证其客户端类（*网关*）是否遵循合同。请注意，再次强调，你不需要知道生产者是如何启动的或启动任何可能依赖于它的外部依赖项，因为验证合同并不意味着启动生产者；你只是在验证消费者是否也符合合同。
- en: Tests that verify contracts are known as *contract tests*. The next big question
    is, who’s responsible for creating and maintaining contract files? We’ll address
    this next.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 验证合同的测试被称为*合同测试*。下一个大问题是，谁负责创建和维护合同文件？我们将在下一节中讨论这个问题。
- en: 6.1.5\. Who owns the contracts?
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.5\. 谁拥有合同？
- en: 'As you just learned, the best way to validate that a consumer and a provider
    can communicate correctly and continuously is to define a contract between them.
    But we haven’t addressed who has ownership of this contract: the consumer team
    or the provider team.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你刚刚学到的，验证消费者和供应商能否正确且持续地通信的最佳方式是在它们之间定义一个合同。但我们还没有解决这个合同的拥有权问题：是消费者团队还是供应商团队。
- en: What are provider contracts?
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 供应商合同是什么？
- en: If the ownership of the contract lies with the team that’s developing the provider,
    this implies that they not only know the business behavior of their own service
    (the provider) but also the requirements of all consumers their service supports.
    This kind of contract is called a *provider contract* because the contract belongs
    to the provider, and consumers are merely viewers of it (see [figure 6.7](kindle_split_015_split_001.xhtml#ch06fig07)).
    One example of where such a contract might be beneficial is an internal security
    authentication/authorization service, where consuming services must conform to
    the provider contract.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果合同的拥有权属于开发供应商的团队，这意味着他们不仅了解自己服务（供应商）的商业行为，还了解其服务支持的所有消费者的需求。这种合同被称为*供应商合同*，因为合同属于供应商，消费者只是它的查看者（参见[图6.7](kindle_split_015_split_001.xhtml#ch06fig07)）。这种合同可能有益的例子之一是内部安全认证/授权服务，其中消费服务必须符合供应商合同。
- en: Figure 6.7\. Provider contracts
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.7\. 供应商合同
- en: '![](Images/06fig07.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06fig07.jpg)'
- en: Provider contracts define what the provider will offer to consumers. Each consumer
    must adapt to what the provider offers. Naturally, this implies that the consumer
    is coupled to the provider. If the contract developed by the provider team no
    longer satisfies the requirements of a consumer, the consumer team must start
    a conversation with the maintainers of the provider service to address this deficiency.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 供应商合同定义了供应商将向消费者提供的内容。每个消费者都必须适应供应商提供的内容。自然地，这表明消费者与供应商耦合。如果供应商团队开发的合同不再满足消费者的需求，消费者团队必须与供应商服务的维护者开始对话，以解决这一缺陷。
- en: What are consumer contracts?
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 消费者合同是什么？
- en: On the other hand, to fix the problem of one-size-fits-all contracts without
    forcing the provider team to define a complete contract, you can change the ownership
    of the contract by making the developers of the consumer service define what they
    need and send that contract to the provider team to implement. Such a contract
    is called a *consumer contract* because it belongs to the consumer.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，为了解决一刀切合同的问题，而不强迫提供商团队定义一个完整的合同，你可以通过让消费者服务的开发者定义他们所需的内容，并将该合同发送给提供商团队以实施，来改变合同的所有权。这种合同被称为**消费者合同**，因为它属于消费者。
- en: Consumer contracts define the consumer’s needs from the consumer’s point of
    view. Hence this contract applies only to that individual consumer and its particular
    use case. Consumer contracts can be used to complete an existing provider contract
    (if there is one), or they can help develop a new one. [Figure 6.8](kindle_split_015_split_001.xhtml#ch06fig08)
    shows that there’s one consumer contract for each provider-consumer relationship
    instead of a single contract for all consumers.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者合同从消费者的角度定义了消费者的需求。因此，此合同仅适用于该单个消费者及其特定用例。消费者合同可以用来完成现有的提供商合同（如果有的话），或者它们可以帮助开发一个新的合同。[图6.8](kindle_split_015_split_001.xhtml#ch06fig08)显示，对于每个提供商-消费者关系都有一个消费者合同，而不是为所有消费者提供一个单一的合同。
- en: Figure 6.8\. Consumer contracts
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '![图片](Images/06fig08.jpg)'
- en: '![](Images/06fig08.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06fig08.jpg)'
- en: As an example, consumer contracts might be beneficial for an internal checkout
    service in an organization, where the pace of the service’s evolution will be
    controlled by the provider, but the data pulled from this service is used in different
    contexts. These contexts may evolve individually, but there’s an internal locus
    of control and evolution.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，消费者合同可能对组织内部结账服务有益，其中服务的演变速度将由提供商控制，但从该服务提取的数据用于不同的上下文中。这些上下文可能各自演变，但存在一个内部的控制点和演变点。
- en: What are consumer-driven contracts?
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 什么是消费者驱动的合同？
- en: A *consumer-driven contract* represents an aggregation of all the contracts
    a provider has with all of its consumers (see [figure 6.9](kindle_split_015_split_001.xhtml#ch06fig09)).
    Obviously, a provider can evolve or extend consumers’ contracts by creating a
    provider contract, as long as the provider’s obligations to all consumers are
    satisfied.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**消费者驱动的合同**代表了一个提供商与其所有消费者之间所有合同的聚合（见[图6.9](kindle_split_015_split_001.xhtml#ch06fig09)）。显然，只要满足对所有消费者的义务，提供商可以通过创建一个提供商合同来演变或扩展消费者的合同。
- en: Figure 6.9\. Consumer-driven contracts
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.9. 消费者驱动的合同
- en: '![](Images/06fig09.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06fig09.jpg)'
- en: Consumer-driven contracts establish that a service provider is developed from
    its consumers’ perspective. Each consumer communicates to its provider the specific
    requirements for meeting that consumer’s use cases. These requirements create
    an obligation on the provider’s side to meet all the expectations of the consumers.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者驱动的合同确立了一个服务提供商是从其消费者的角度开发的。每个消费者都会向其提供商传达满足该消费者用例的具体要求。这些要求在提供商一方产生义务，以满足所有消费者的期望。
- en: Ideally, contract tests are developed, bundled by the consumer team, and sent
    to the producer team so they can develop the producing service. By assigning ownership
    of consumer contracts to consumer teams, you ensure that a provider’s consumer-driven
    contract is what consumers need, rather than a provider’s interpretation of consumer
    expectations. In addition, when the maintainers of the producing service change
    the provider-service code base, they know the impact of their changes on consumers,
    ensuring that there’s no communication failure at runtime when the new version
    of the providing service is deployed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '理想情况下，合同测试是由消费者团队开发的，捆绑后发送给生产团队，以便他们可以开发生产服务。通过将消费者合同的所有权分配给消费者团队，你确保了提供商的消费者驱动的合同是消费者所需的，而不是提供商对消费者期望的解释。此外，当生产服务的维护者更改提供商-服务代码库时，他们知道他们的更改对消费者的影响，确保在部署提供服务的最新版本时运行时没有通信失败。 '
- en: There are also some obligations on the consumer side. Providers are obliged
    to follow a consumer-driven contract, and consumers must ensure that they follow
    their part of the contract—nothing more, nothing less. Consumers should consume
    only what they need from the provider side. This way, consumers protect themselves
    against evolution of the provider contract resulting from the provider adding
    to it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者端也有一些义务。提供者必须遵守消费者驱动的合同，而消费者必须确保他们遵守合同的一部分——不多也不少。消费者应该只从提供者端消费他们所需的内容。这样，消费者可以保护自己免受提供者合同因提供者添加内容而产生的演变。
- en: One example of where consumer-driven contracts may be beneficial is an *external*
    (open to an outside organization) or *internal* user service that’s used across
    the organization. Data is pulled from this service for multiple other contexts.
    These contexts all evolve individually, and there’s an external locus of control/evolution.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者驱动合同可能有益的一个例子是，一个*外部*（对外部组织开放）或*内部*用户服务，该服务在整个组织中使用。数据从这个服务中提取用于多个其他上下文。这些上下文都各自发展，存在一个外部控制/演化的焦点。
- en: So far in this chapter, we’ve discussed the problem of having services running
    in different runtimes, why integration tests aren’t enough, and why consumer-driven
    contracts help you fix communication problems that may appear when updating the
    producer service. Let’s see how to practice these principles, as well as which
    tools can help you use the consumer-driven-contracts pattern for the microservices
    architecture.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们讨论了服务在不同运行时运行的问题，为什么集成测试不够，以及为什么消费者驱动合同有助于你修复在更新生产者服务时可能出现的通信问题。让我们看看如何实践这些原则，以及哪些工具可以帮助你使用消费者驱动合同模式为微服务架构。
- en: 6.2\. Tools
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2\. 工具
- en: 'We’ve explained why it’s important to write contract tests in the microservices
    architecture to avoid surprises when a service is deployed to production. Next,
    let’s look at the tools you can use to write contract tests. These are the three
    most popular tools:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经解释了为什么在微服务架构中编写合同测试很重要，以避免在服务部署到生产环境时出现意外。接下来，让我们看看你可以用来编写合同测试的工具。这些是最受欢迎的三种工具：
- en: '*Spring Cloud Contract*—A test framework developed under the Spring ecosystem,
    in Groovy. Although it integrates well with Spring products, it can be used by
    any application developed with a JVM language.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Spring Cloud Contract*——一个在Spring生态系统下开发的测试框架，使用Groovy编写。尽管它与Spring产品集成良好，但任何使用JVM语言开发的应用程序都可以使用它。'
- en: '*Pact*—A family of test frameworks that provide support for consumer-driven
    contract testing. It has official implementations for Ruby, JVM languages, .NET,
    JavaScript, Go, Python, Objective-C, PHP, and Swift languages.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Pact*——一组提供消费者驱动合同测试支持的测试框架。它为Ruby、JVM语言、.NET、JavaScript、Go、Python、Objective-C、PHP和Swift语言提供了官方实现。'
- en: '*Pacto*—A test framework for developing consumer-driven contract tests and/or
    document-driven contracts. It’s written in Ruby, although it can be used with
    several languages such as Python and Java by using the Pacto server.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Pacto*——一个用于开发消费者驱动合同测试和/或文档驱动合同的测试框架。它使用Ruby编写，尽管可以通过使用Pacto服务器与多种语言（如Python和Java）一起使用。'
- en: In our opinion, Pact ([https://docs.pact.io](https://docs.pact.io)) is the most
    widely adopted and mature project on the contract-testing scene. One of its main
    advantages is its support for almost all major languages used today for writing
    microservices; the same concepts can be reused independently of the programming
    language, from frontend to backend. For these reasons, we strongly believe that
    Pact is the most generic solution for writing consumer-driven contracts. It adapts
    well to microservices architectures developed in Java.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看来，Pact ([https://docs.pact.io](https://docs.pact.io)) 是合同测试场景中最广泛采用和最成熟的项目之一。其主要优势之一是它支持今天用于编写微服务的几乎所有主要语言；相同的概念可以独立于编程语言重用，从前端到后端。因此，我们坚信Pact是编写消费者驱动合同的通用解决方案。它很好地适应了在Java中开发的微服务架构。
- en: The next section explores in depth how Pact works and how to write contract
    tests with Pact.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将深入探讨Pact的工作原理以及如何使用Pact编写合同测试。
- en: 6.2.1\. Pact
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.1\. Pact
- en: The Pact framework lets you write contracts on the consumer side by providing
    a mock HTTP server and a fluent API to define the HTTP requests made from consumer
    to service provider and the HTTP responses expected in return. These HTTP requests
    and responses are used in the mock HTTP server to mock the service provider. The
    interactions are then used to generate the contract between service consumer and
    service provider.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Pact框架通过提供模拟HTTP服务器和流畅API来定义从消费者到服务提供商的HTTP请求以及预期的HTTP响应，允许你在消费者端编写合同。这些HTTP请求和响应用于模拟HTTP服务器来模拟服务提供商。然后，这些交互用于生成服务消费者和服务提供商之间的合同。
- en: Pact also provides the logic for validating the contract against the provider
    side. All interactions that occur on the consumer are played back in the “real”
    service provider to ensure that the provider produces the response the consumer
    expects for given requests. If the provider returns something unexpected, Pact
    marks the interaction as a failure, and the contract test fails.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Pact还提供了验证合同与提供商端逻辑。消费者上发生的所有交互都在“真实”服务提供商上回放，以确保提供商为给定的请求产生消费者期望的响应。如果提供商返回了意外的内容，Pact将交互标记为失败，并且合同测试失败。
- en: 'Any contract test is composed of two parts: one for the consumer and another
    for the provider. In addition, a contract file is sent from consumer to provider.
    Let’s look at the lifecycle of a contract test using Pact:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 任何合同测试都由两部分组成：一部分是消费者，另一部分是提供商。此外，合同文件从消费者发送到提供商。让我们使用Pact来查看合同测试的生命周期：
- en: '**1**.  Consumer expectations are set up on a mock HTTP server using a fluent
    API. Consumer communication takes place with the mock HTTP server handling HTTP
    requests/responses but never interacting with the provider. This way, the consumer
    doesn’t need to know how to deploy a provider (because it might not be trivial
    to do so, and will probably result in writing end-to-end tests instead of contract
    tests). The consumer verifies that its client/gateway code can communicate against
    the mock HTTP server with defined interactions.'
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 消费者预期在模拟HTTP服务器上使用流畅API设置。消费者与模拟HTTP服务器进行通信，处理HTTP请求/响应，但从不与提供商交互。这样，消费者不需要知道如何部署提供商（因为这可能不是一件简单的事情，并且可能结果是在编写端到端测试而不是合同测试）。消费者验证其客户端/网关代码可以与定义的交互通信的模拟HTTP服务器。'
- en: ''
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When consumer tests are run, all interactions are written into a pact contract
    file, which defines the contract that the consumer and provider must follow.
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当运行消费者测试时，所有交互都写入一个pact合同文件，该文件定义了消费者和提供商必须遵循的合同。
- en: '**2**.  The pact contract file is sent to the provider project to be replayed
    against the provider service. The contract is played back against the real provider,
    and real responses from the provider are checked against the expected responses
    defined in the contract.'
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 将pact合同文件发送到提供商项目，以便在提供商服务上回放。合同在真实提供商上回放，并检查提供商的真实响应与合同中定义的预期响应是否一致。'
- en: ''
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If the consumer is able to produce a pact contract file, and the provider meets
    all the expectations, then the contract has been verified by both parties, and
    they will be able to communicate.
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果消费者能够生成一个pact合同文件，并且提供商满足所有预期，那么合同已经由双方验证，他们就能够进行通信。
- en: These steps are summarized in [figure 6.10](kindle_split_015_split_002.xhtml#ch06fig10).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤在[图6.10](kindle_split_015_split_002.xhtml#ch06fig10)中进行了总结。
- en: Figure 6.10\. Pact lifecycle
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.10\. Pact生命周期
- en: '![](Images/06fig10.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06fig10.jpg)'
- en: 'In summary, Pact offers the following features:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Pact提供了以下功能：
- en: A mock HTTP server so you don’t have to depend on the provider.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个模拟的HTTP服务器，这样你就不必依赖提供商。
- en: An HTTP client to automatically replay expectations.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个HTTP客户端，用于自动回放预期。
- en: States to communicate the expected state from the consumer side to the provider
    before replaying expectations. For example, an interaction might require that
    the provider database contains a user called *Alexandra* before replaying an expectation.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在回放预期之前，将期望的状态从消费者端传达给提供商。例如，一个交互可能要求在回放预期之前，提供商数据库中必须包含一个名为*Alexandra*的用户。
- en: '*Pact Broker* is a repository for contracts, allowing you to share pacts between
    consumers and providers, versioning pact contract files so the provider can verify
    itself against a fixed version of a contract, and providing documentation for
    each pact as well as a visualization of the relationship between services.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Pact Broker* 是合同的存储库，允许您在消费者和提供者之间共享 pact，对 pact 合同文件进行版本控制，以便提供者可以针对合同的固定版本进行验证，并为每个
    pact 提供文档以及服务之间关系的可视化。'
- en: 'Next, we’ll explore Pact JVM: the implementation of Pact for the Java virtual
    machine.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨 Pact JVM：Pact 在 Java 虚拟机中的实现。
- en: 6.2.2\. Pact in JVM languages
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.2. JVM 语言中的 Pact
- en: Pact JVM is partially written in Scala, Groovy, and Java, but it can be used
    with any JVM language. It integrates perfectly with Java, Scala, Groovy, Grails
    (providing a Groovy DSL for defining contracts), and Clojure. In addition, it
    offers tight integration with test frameworks like JUnit, Spock, ScalaTest, and
    Specs2, as well as build tools such as Maven, Gradle, Leiningen, and sbt. This
    book focuses on Java tools, but keep in mind that if you plan to use any other
    JVM language, you can still use Pact JVM for consumer-driven contract testing.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Pact JVM 部分是用 Scala、Groovy 和 Java 编写的，但它可以与任何 JVM 语言一起使用。它与 Java、Scala、Groovy、Grails（提供用于定义合同的
    Groovy DSL）和 Clojure 完美集成。此外，它还提供了与测试框架（如 JUnit、Spock、ScalaTest 和 Specs2）以及构建工具（如
    Maven、Gradle、Leiningen 和 sbt）的紧密集成。本书侧重于 Java 工具，但请记住，如果您计划使用任何其他 JVM 语言，您仍然可以使用
    Pact JVM 进行消费者驱动的合同测试。
- en: Let’s see how to write consumer and provider tests using Pact JVM.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 Pact JVM 编写消费者和提供者测试。
- en: Consumer testing with Pact JVM
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 Pact JVM 进行消费者测试
- en: Pact JVM provides a mock HTTP server and a Java domain-specific language (DSL)
    for writing the expectations of the mock HTTP server. These expectations are materialized
    into pact contract files when the consumer test passes.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Pact JVM 提供了一个模拟 HTTP 服务器和一个 Java 领域特定语言 (DSL)，用于编写模拟 HTTP 服务器的预期。当消费者测试通过时，这些预期将实现为
    pact 合同文件。
- en: 'Pact JVM integrates with JUnit, providing a DSL and base classes for use with
    JUnit to build consumer tests. The first thing you do to write a consumer test
    using JUnit is register the `PactProviderRule` JUnit rule. This rule does the
    following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Pact JVM 与 JUnit 集成，提供 DSL 和基类，用于与 JUnit 一起构建消费者测试。使用 JUnit 编写消费者测试的第一件事是注册
    `PactProviderRule` JUnit 规则。此规则执行以下操作：
- en: Starts and stops the mock HTTP server
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动和停止模拟 HTTP 服务器
- en: Configures the mock HTTP server with defined expectations
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置具有定义预期的模拟 HTTP 服务器
- en: Generates pact contract files from defined expectations if the test passes
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果测试通过，则从定义的预期生成 pact 合同文件
- en: 'Here’s an example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例：
- en: '[PRE7]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The first argument is the provider name that the current consumer contract
    is defining. This name is used to refer to the provider of a given contract. Next
    are two optional parameters: the host where the mock HTTP server is bound, and
    the listening port. If values aren’t specified, *localhost* and *8080* are used,
    respectively. Finally, the `this` instance is the test itself.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是当前消费者合同定义的提供者名称。此名称用于引用给定合同的提供者。接下来是两个可选参数：模拟 HTTP 服务器绑定的主机和监听端口。如果没有指定值，则分别使用
    `localhost` 和 `8080`。最后，`this` 实例是测试本身。
- en: Next, you define the expectations by annotating a method with `au.com.dius.pact.consumer.Pact`.
    This method must receive a class of type `PactDslWithProvider` and return a `PactFragment`.
    `PactDslWithProvider` is a Java class that’s built around a DSL pattern to provide
    a description of the request that’s expected to be received when a mock HTTP server
    is used. As its name suggests, the `PactFragment` object is a fragment of a contract.
    It’s used as the expectation in the mock HTTP server and also to generate a pact
    contract file that’s used to verify the provider. The fragment may be the complete
    contract or only part of it. If more than one fragment is defined in the same
    test class, the pact contract file consists of the aggregation of all fragments.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您通过使用 `au.com.dius.pact.consumer.Pact` 注解一个方法来定义预期。此方法必须接收一个类型为 `PactDslWithProvider`
    的类，并返回一个 `PactFragment`。`PactDslWithProvider` 是一个围绕 DSL 模式构建的 Java 类，用于描述当使用模拟
    HTTP 服务器时预期接收到的请求。正如其名称所示，`PactFragment` 对象是合同的一部分。它用作模拟 HTTP 服务器中的预期，并用于生成 pact
    合同文件，该文件用于验证提供者。片段可以是完整的合同，也可以只是其中的一部分。如果在同一测试类中定义了多个片段，则 pact 合同文件由所有片段的聚合组成。
- en: 'The `@Pact` method must have this signature:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Pact` 方法必须具有以下签名：'
- en: '[PRE8]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that in the `@Pact` annotation, you set the name of the provider that
    should follow the contract and the name of the consumer that’s defining the contract.
    This information is important for provider test execution, to be sure the provider-side
    test is executed against all consumers for which the provider provides data.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 `@Pact` 注解中，您设置了应遵循合同的提供者名称以及定义合同的消费者名称。这些信息对于提供者测试执行很重要，以确保提供者端测试针对所有提供数据的消费者执行。
- en: 'The next snippet defines a request/response expectation. `PactDslWithProvider`
    has several options you can define:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个片段定义了一个请求/响应期望。`PactDslWithProvider` 有几个选项可以定义：
- en: '[PRE9]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* Defines a new request interaction**'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义一个新的请求交互**'
- en: '***2* Reacts to the /hello path for the HTTP POST**'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 对 HTTP POST 的 /hello 路径做出响应**'
- en: '***3* The body of the request must contain the given JSON document.**'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 请求体必须包含给定的 JSON 文档。**'
- en: '***4* Defines the response to the previous request**'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 定义对先前请求的响应**'
- en: '***5* Returns HTTP status code 200**'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 返回 HTTP 状态码 200**'
- en: '***6* The response body’s content is the given JSON document.**'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 响应体的内容是给定的 JSON 文档。**'
- en: '***7* Reacts to any path that starts with /hello/ and any number**'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 对以 /hello/ 开头的任何路径以及任何数字做出响应**'
- en: 'This example defines two expectations. The first request happens when the consumer
    sends a request using the `POST` method at /hello. The body of the message must
    contain exactly the JSON document `{"name": "Ada"}`. If this happens, then the
    response is the JSON document `{"hello": "Ada"}`. The second request happens when
    the path starts with /hello followed by any valid number. The conditions are the
    same as for the first request.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '此示例定义了两个期望。第一个请求发生在消费者使用 `POST` 方法在 /hello 发送请求时。消息体必须包含确切的 JSON 文档 `{"name":
    "Ada"}`。如果发生这种情况，则响应是 JSON 文档 `{"hello": "Ada"}`。第二个请求发生在路径以 /hello 开头并跟随着任何有效数字时。条件与第一个请求相同。'
- en: Notice that you can define as many interactions as required. Each interaction
    starts with `uponReceiving`, followed by `willRespondWith` to record the response.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您可以定义所需数量的交互。每个交互都以 `uponReceiving` 开头，后面跟着 `willRespondWith` 以记录响应。
- en: '|  |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: To keep your tests as readable and simple as possible, and to stay focused on
    the *one method, one task* approach, we recommend using several fragments for
    all interactions, instead of defining one big `@Pact` method that returns everything.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使您的测试尽可能可读和简单，并保持专注于“一种方法，一项任务”的方法，我们建议为所有交互使用多个片段，而不是定义一个返回所有内容的大的 `@Pact`
    方法。
- en: '|  |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'One important aspect of the previous definitions is that the body content is
    required to be the same as specified in the contract. For example, `a request
    for something` has a strong requirement that the response be provided only if
    the JSON document is `{"name": "Ada"}`. If the name is anything other than `Ada`,
    then the response isn’t generated. The same is true for the returned body. Because
    the JSON document is static, the response is always the same.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '之前定义的一个重要方面是，正文内容必须与合同中指定的内容相同。例如，`请求某物` 有一个强烈的要求，即只有当 JSON 文档是 `{"name": "Ada"}`
    时才提供响应。如果名称不是 `Ada`，则不生成响应。对于返回的正文也是如此。因为 JSON 文档是静态的，所以响应总是相同的。'
- en: This can be a restriction in cases where you can’t set a static value, especially
    when it comes to running contracts against the provider. For this reason, the
    builder’s `body` method can accept a `PactDslJsonBody` that can be used to construct
    a JSON body dynamically.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是在无法设置静态值的情况下的一种限制，尤其是在运行针对提供者的合同时。因此，构建器的 `body` 方法可以接受一个 `PactDslJsonBody`，它可以用来动态构建
    JSON 正文。
- en: '|  |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**The PactDslJsonBody class**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**PactDslJsonBody 类**'
- en: The `PactDslJsonBody` builder class implements a DSL pattern that you can use
    to construct a JSON body dynamically as well as define regular expressions for
    fields and type matchers. Let’s look at some examples.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`PactDslJsonBody` 构建器类实现了 DSL 模式，您可以使用它来动态构建 JSON 正文，以及为字段定义正则表达式和类型匹配器。让我们看看一些示例。'
- en: 'The following snippet generates a simple JSON document without an array:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的片段生成一个没有数组的简单 JSON 文档：
- en: '[PRE10]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* Defines a field named name, of type string, where value isn’t important**'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义一个名为 name 的字段，类型为字符串，其值不重要**'
- en: '***2* Defines a field named happy, of type boolean, where value isn’t important**'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 定义一个名为 happy 的字段，类型为布尔型，其值不重要**'
- en: '***3* Defines a field named age, of type number, with the specific value 100**'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 定义一个名为 age 的字段，类型为数字，其特定值为 100**'
- en: Using the *xType* form, you can also set an optional value parameter that’s
    used to generate example values when returning a mock response. If no example
    is provided, a random one is generated.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *xType* 表单，你还可以设置一个可选的值参数，用于在返回模拟响应时生成示例值。如果没有提供示例，将生成一个随机的值。
- en: 'The previous `PactDslJsonBody` definition will match any body like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的 `PactDslJsonBody` 定义将匹配任何这样的体：
- en: '[PRE11]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice that any document containing all the required fields of the required
    type and having an `age` field with the value `100` is valid.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，任何包含所需类型所有必需字段的文档，并且具有值为 `100` 的 `age` 字段都是有效的。
- en: '`PactDslJsonBody` also offers methods for defining array matchers. For example,
    you can validate that a list has a minimum or maximum size, or that each item
    in the list matches a given example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`PactDslJsonBody` 还提供了定义数组匹配器的方法。例如，你可以验证列表具有最小或最大大小，或者列表中的每个项目与给定的示例匹配：'
- en: '[PRE12]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* Defines that the list must contain at least one element**'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义列表必须至少包含一个元素**'
- en: '***2* Specifies that each document in the list must contain an ID, a name,
    and a barcode**'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 指定列表中的每个文档必须包含一个 ID、一个名称和一个条形码**'
- en: Here, the `products` array can’t be empty, and every product should have an
    identifier and a name of type `string` as well as a barcode that matches the form
    `"a"` plus a list of numbers.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`products` 数组不能为空，并且每个产品都应该有一个标识符和一个类型为 `string` 的名称，以及一个匹配形式 `"a"` 加上一个数字列表的条形码。
- en: 'If the size of the elements isn’t important, you can do this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果元素的大小不重要，你可以这样做：
- en: '[PRE13]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this example, each array must contain three fields: `expireDate`, `name`,
    and `amount`. Moreover, in the mocked response, each element will contain a `date`
    variable value in the `expireDate` field, a random `string` in the `name` field,
    and the value `100.0` in `amount`.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，每个数组必须包含三个字段：`expireDate`、`name` 和 `amount`。此外，在模拟响应中，每个元素将在 `expireDate`
    字段中包含一个 `date` 变量值，在 `name` 字段中包含一个随机的 `string`，在 `amount` 中包含值 `100.0`。
- en: 'As you can see, using `DslPart` to generate the body lets you define field
    types instead of concrete specific field/value pairs. This makes your contract
    more resilient during contract validation on the provider side. Suppose you set
    `.body("{''name'': ''Ada''}")` in the provider-validation phase: you expect the
    provider to produce the same JSON document with the same values. This may be correct
    in most cases; but if the test dataset changes and, instead of returning `.body("{''name'':''Ada''}")`,
    it returns `.body("{''name'':''Alexandra''}")`, the test will fail—although from
    the point of view of the contract, both responses are valid.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '如你所见，使用 `DslPart` 生成体让你可以定义字段类型而不是具体的特定字段/值对。这使得你的合约在提供者端的合约验证期间更具弹性。假设你在提供者验证阶段设置了
    `.body("{''name'': ''Ada''}")`：你期望提供者生成具有相同值的相同 JSON 文档。这在大多数情况下可能是正确的；但如果测试数据集发生变化，并且不是返回
    `.body("{''name'':''Ada''}")`，而是返回 `.body("{''name'':''Alexandra''}")`，测试将失败——尽管从合约的角度来看，这两个响应都是有效的。'
- en: '|  |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now that you’ve seen how to write consumer-driven contracts with Pact on the
    consumer side, let’s look at how to write the provider part of the test.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了如何在消费者端使用 Pact 编写驱动型合约，让我们看看如何编写测试的提供者部分。
- en: Provider testing with Pact JVM
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 Pact JVM 进行提供者测试
- en: 'After executing the consumer part of the test and generating and publishing
    the pact contract file, you need to play back the contract against a real provider.
    This part of the test is executed on the provider side, and Pact offers several
    tools to do so:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行测试的消费者部分并生成和发布 pact 合约文件后，你需要将合约回放到一个真实的提供者。这部分测试在提供者端执行，Pact 提供了几个工具来完成这项工作：
- en: '*JUnit*—Validates contracts in JUnit tests'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JUnit*—在 JUnit 测试中验证合约'
- en: '*Gradle, Lein, Maven, sbt*—Plugins for verifying contracts against a running
    provider'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Gradle, Lein, Maven, sbt*—用于验证运行中提供者的插件'
- en: '*ScalaTest*—Extension to validate contracts against a running provider'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ScalaTest*—用于验证运行中提供者的扩展'
- en: '*Specs2*—Extension to validate contracts against a running provider'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Specs2*—用于验证运行中提供者的扩展'
- en: 'In general, all of these integrations offer two ways to retrieve published
    contracts: by using Pact Broker and by specifying a concrete location (a file
    or a URL). The way to configure a retrieval method depends on how you choose to
    replay contracts. For example, JUnit uses an annotations approach, whereas in
    Maven, a plugin’s configuration section is used for this purpose.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，所有这些集成都提供了两种检索已发布合约的方式：通过使用 Pact Broker 和指定一个具体的位置（一个文件或一个 URL）。配置检索方法的方式取决于你选择如何回放合约。例如，JUnit
    使用注解方法，而在 Maven 中，插件配置部分用于此目的。
- en: Let’s examine how you can implement provider validation using Maven, Gradle,
    and JUnit.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何使用 Maven、Gradle 和 JUnit 实现提供者验证。
- en: Using Maven for verifying contracts
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 Maven 验证契约
- en: Pact offers a Maven plugin for verifying contracts against providers. To use
    it, add the following to the `plugins` section of pom.xml.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Pact 为验证提供者与契约提供了 Maven 插件。要使用它，请将以下内容添加到 pom.xml 的 `plugins` 部分。
- en: Listing 6.1\. Adding the Maven plugin
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.1\. 添加 Maven 插件
- en: '[PRE14]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Then you need to configure the plugin, defining all the providers you want to
    validate and the location of the consumer contract that you want to use to check
    them.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你需要配置插件，定义你想要验证的所有提供者以及你想要用来检查它们的消费者契约的位置。
- en: Listing 6.2\. Configuring the Maven plugin
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.2\. 配置 Maven 插件
- en: '[PRE15]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* Provider (or providers) to verify**'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 要验证的提供者（或提供者）**'
- en: '***2* Name of the provider (must be unique) and the location where it’s deployed**'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 提供者的名称（必须是唯一的）以及它部署的位置**'
- en: '***3* Directory where all Pact contracts are stored**'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 存储所有 Pact 契约的目录**'
- en: To verify contacts, execute `mvn pact:verify`. The Maven plugin will load all
    Pact contracts defined in the given directory and replay those that match the
    given provider name. If all the contracts validate against the provider, then
    the build will finish successfully; if not, the build will fail.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证契约，执行 `mvn pact:verify`。Maven 插件将加载给定目录中定义的所有 Pact 契约，并重新播放与给定提供者名称匹配的契约。如果所有契约都通过提供者验证，则构建将成功完成；如果不通过，则构建将失败。
- en: Using Gradle for verifying contracts
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 Gradle 验证契约
- en: The Gradle plugin uses an approach similar to Maven’s to verify contracts against
    providers. To use it, add the following to the `plugins` section of .build.gradle.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 插件使用与 Maven 类似的方法来验证契约与提供者。要使用它，请将以下内容添加到 .build.gradle 的 `plugins` 部分。
- en: Listing 6.3\. Adding the Gradle plugin
  id: totrans-212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.3\. 添加 Gradle 插件
- en: '[PRE16]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Then configure the plugin, defining the providers you want to validate and the
    location of the consumer contract you want to use to check them.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后配置插件，定义你想要验证的提供者以及你想要用来检查它们的消费者契约的位置。
- en: Listing 6.4\. Configuring the Maven plugin
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.4\. 配置 Maven 插件
- en: '[PRE17]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1* Provider (or providers) to verify**'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 要验证的提供者（或提供者）**'
- en: '***2* Name of the provider (must be unique) and the location where it’s deployed**'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 提供者的名称（必须是唯一的）以及它部署的位置**'
- en: '***3* Directory where all Pact contracts are stored**'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 存储所有 Pact 契约的目录**'
- en: To verify contacts, execute `gradlew pactVerify`. The Gradle plugin will load
    all Pact contracts defined in the given directory and replay those that match
    the given provider name. If all the contracts validate against the provider, then
    the build will finish successfully; if not, the build will fail.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证契约，执行 `gradlew pactVerify`。Gradle 插件将加载给定目录中定义的所有 Pact 契约，并重新播放与给定提供者名称匹配的契约。如果所有契约都通过提供者验证，则构建将成功完成；如果不通过，则构建将失败。
- en: Finally, let’s see how to validate providers by using JUnit instead of relying
    on a build tool.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看如何通过使用 JUnit 而不是依赖构建工具来验证提供者。
- en: Using JUnit for verifying contracts
  id: totrans-222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 JUnit 验证契约
- en: Pact offers a JUnit runner for verifying contracts against providers. This runner
    provides an HTTP client that automatically replays all the contracts against the
    configured provider. It also offers convenient out-of-the-box ways to load pacts
    using annotations.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Pact 为验证提供者与契约提供了 JUnit 运行器。此运行器提供了一个 HTTP 客户端，它将自动重新播放所有契约以针对配置的提供者。它还提供了使用注解加载契约的方便方法。
- en: Using the JUnit approach, you need to register `PactRunner`, set the provider’s
    name with the `@Provider` annotation, and set the contract’s location. Then, you
    create a field of type `au.com.dius.pact.provider.junit.target.Target` that’s
    annotated with `@TestTarget` and instantiates either `au.com.dius.pact.provider.junit.target.HttpTarget`
    to play pact contract files as HTTP requests and assert the response or `au.com.dius.pact.provider.junit.target.AmqpTarget`
    to play pact contract files as AMQP messages.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JUnit 方法，你需要注册 `PactRunner`，使用 `@Provider` 注解设置提供者的名称，并设置契约的位置。然后，你创建一个类型为
    `au.com.dius.pact.provider.junit.target.Target` 的字段，该字段带有 `@TestTarget` 注解，并实例化
    `au.com.dius.pact.provider.junit.target.HttpTarget` 以将 pact 契约文件作为 HTTP 请求播放并断言响应，或者实例化
    `au.com.dius.pact.provider.junit.target.AmqpTarget` 以将 pact 契约文件作为 AMQP 消息播放。
- en: '|  |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Note**'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Advanced Message Queuing Protocol* (AMQP) is an application layer protocol
    for message-oriented middleware. The features it defines are message orientation,
    queuing, routing, reliability, and security.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*高级消息队列协议* (AMQP) 是一种面向消息的中间件的应用层协议。它定义的功能包括消息导向、排队、路由、可靠性和安全性。'
- en: '|  |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Let’s look at an example using `HttpTarget`, from PactTest.java.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个使用`HttpTarget`的例子，来自PactTest.java。
- en: Listing 6.5\. Using the JUnit runner
  id: totrans-230
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.5\. 使用JUnit运行器
- en: '[PRE18]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* Registers PactRunner**'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 注册PactRunner**'
- en: '***2* Sets the provider’s name**'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 设置提供者的名称**'
- en: '***3* Sets where contract files are stored. In this case, the location resolves
    to src/test/resources(pacts).**'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 设置合约文件的存储位置。在这种情况下，位置解析为src/test/resources(pacts)。**'
- en: '***4* Sets the target to use for tests**'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 设置测试的目标**'
- en: '***5* Configures the provider location**'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 配置提供者的位置**'
- en: 'Notice that there’s no test method annotated with `@Test`. This isn’t required,
    because rather than a single test, there are many tests: one for each interaction
    between a consumer and the provider.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，没有使用`@Test`注解的测试方法。这不是必需的，因为这里不是单个测试，而是许多测试：消费者和提供者之间每个交互的一个测试。
- en: When this test is executed, the JUnit runner gets all the contract files from
    the pacts directory and replays all the interactions defined in them against the
    provider location specified in the `HttpTarget` instance.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个测试执行时，JUnit运行器会从pacts目录获取所有合约文件，并针对在`HttpTarget`实例中指定的提供者位置重新播放其中定义的所有交互。
- en: '`PactRunner` automatically loads contracts based on annotations on the test
    class. Pact provides three annotations for this purpose:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`PactRunner`自动根据测试类上的注解加载合约。Pact为此提供了三个注解：'
- en: '`PactFolder`—Retrieves contracts from a project folder or resource folder;
    for example, `@PactFolder("subfolder/in/resource/directory")`.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PactFolder`—从项目文件夹或资源文件夹检索合约；例如，`@PactFolder("subfolder/in/resource/directory")`。'
- en: '`PactUrl`—Retrieves contracts from URLs; for example, `@PactUrl(urls = {"http://myserver/contract1.json"})`.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PactUrl`—从URL检索合约；例如，`@PactUrl(urls = {"http://myserver/contract1.json"})`。'
- en: '`PactBroker`—Retrieves contracts from Pact Broker; for example, `@PactBroker
    (host="pactbroker", port = "80", tags = {"latest", "dev"})`.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PactBroker`—从Pact Broker检索合约；例如，`@PactBroker (host="pactbroker", port = "80",
    tags = {"latest", "dev"})`。'
- en: '`Custom`—To implement a custom retriever, create a class that implements the
    `PactLoader` interface and has one default empty constructor or a constructor
    with one argument of type `Class` (which represents the test class). Annotate
    the test like this: `@PactSource(CustomPactLoader.class)`.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Custom`—要实现自定义检索器，创建一个实现`PactLoader`接口的类，并具有一个默认空构造函数或一个参数类型为`Class`（代表测试类）的构造函数。像这样注解测试：`@PactSource(CustomPactLoader.class)`。'
- en: You can also easily implement your own method.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以轻松实现自己的方法。
- en: Pact states
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Pact状态
- en: When you’re testing, each interaction should be verified in isolation, with
    no context from previous interactions. But with consumer-driven contracts, sometimes
    the consumer wants to set up something on the provider side before the interaction
    is run, so that the provider can send a response that matches what the consumer
    expects. A typical scenario is setting up a datasource with expected data. For
    example, when testing the contract for an authentication operation, the consumer
    may require the provider to insert into a database a concrete login and password
    beforehand, so that when the interaction occurs, the provider logic can react
    appropriately to the data. [Figure 6.11](kindle_split_015_split_002.xhtml#ch06fig11)
    summarizes the interaction between consumer, states, and provider.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试时，每个交互都应该在隔离的情况下进行验证，不包含之前交互的上下文。但是，在使用消费者驱动的合约时，有时消费者希望在交互运行之前在提供者端设置某些内容，以便提供者可以发送与消费者期望相匹配的响应。一个典型的场景是设置带有预期数据的数据源。例如，在测试认证操作的合约时，消费者可能要求提供者在交互发生之前将具体的登录名和密码插入到数据库中，以便当交互发生时，提供者逻辑可以适当地对数据进行响应。[图6.11](kindle_split_015_split_002.xhtml#ch06fig11)总结了消费者、状态和提供者之间的交互。
- en: Figure 6.11\. Interactions between consumer and provider
  id: totrans-247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.11\. 消费者和提供者之间的交互
- en: '![](Images/06fig11_alt.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06fig11_alt.jpg)'
- en: 'First, the consumer side defines that the authentication process should be
    done using a `POST` method containing a JSON body:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，消费者端定义了应该使用包含JSON主体的`POST`方法来完成认证过程：
- en: '[PRE19]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Because this snippet will be used when replaying the contract against the provider,
    the consumer needs to warn the provider that it should prepare the database with
    the given information before executing this interaction. For this reason, the
    consumer creates a state called *state authentication* with all the required data.
    The state information is stored in the contract.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个片段将在与提供商回放合约时使用，所以消费者需要提醒提供商在执行此交互之前，应该使用给定信息准备数据库。因此，消费者创建了一个包含所有必要数据的名为*状态认证*的状态。状态信息存储在合约中。
- en: When the contract is replayed against the provider, before the interaction occurs,
    the state data is injected into the test so the test can prepare the environment
    for contract validation. Finally, contract validation is executed with the database
    containing the expected user information.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当合约与提供商回放时，在交互发生之前，状态数据被注入到测试中，以便测试可以准备合约验证的环境。最后，使用包含预期用户信息的数据库执行合约验证。
- en: 'To define the state from the consumer side, you need to use the special method
    `given` when defining the contract:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要从消费者端定义状态，您需要在定义合约时使用特殊方法 `given`：
- en: '[PRE20]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1* Defines the data required in the state**'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义状态中所需的数据**'
- en: '***2* Registers the state in the contract with a name and parameters**'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在合约中以名称和参数注册状态**'
- en: 'To react to a state on the provider side, you need to create a method annotated
    with `@State`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要对提供商端的状态做出反应，您需要创建一个带有 `@State` 注解的方法：
- en: '[PRE21]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***1* Sets the name of the state to react to**'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 设置要响应的状态名称**'
- en: '***2* The method receives as a Map the parameters defined by the consumer.**'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 该方法接收消费者定义的参数的 Map。**'
- en: Notice that with states, you can share information between consumer and provider,
    so you can configure the state of the test before interaction. Pact states are
    the preferred way to prepare the state of the provider from the consumer side.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用状态，您可以在消费者和提供商之间共享信息，因此您可以在交互之前配置测试的状态。Pact 状态是从消费者端准备提供商状态的推荐方式。
- en: Maven and Gradle integration also provide methods for setting states on the
    provider side. In these cases, for each provider, you specify a state-change URL
    to use for changing the state of the provider. This URL receives the `providerState`
    description from the pact contract file before each interaction, via a POST method.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 和 Gradle 集成还提供了在提供商端设置状态的方法。在这些情况下，对于每个提供商，您指定一个用于更改提供商状态的状态更改 URL。此 URL
    在每次交互之前通过 POST 方法接收来自 pact 合约文件的 `providerState` 描述。
- en: 6.2.3\. Integrating Pact JVM into the Arquillian ecosystem with Algeron
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.3\. 使用 Algeron 将 Pact JVM 集成到 Arquillian 生态系统
- en: '*Arquillian Algeron* is an Arquillian extension that integrates Arquillian
    with contract testing. It provides common ground for integrating Arquillian with
    contract-testing frameworks.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*Arquillian Algeron* 是一个 Arquillian 扩展，它将 Arquillian 与合约测试集成。它为将 Arquillian
    与合约测试框架集成提供了一个共同的基础。'
- en: '*Arquillian Algeron Pact* is the integration of the Arquillian philosophy and
    extensions into the consumer-driven contracts approach using the Pact JVM core.
    By using Arquillian Algeron Pact, you get the best of both worlds: you can use
    the Pact-JVM approach to validate consumers and providers, and you can use Arquillian
    to run tests in an environment similar to production. Let’s see how Arquillian
    Algeron Pact fits into the consumer and provider sides.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '*Arquillian Algeron Pact* 是将 Arquillian 理念和扩展集成到使用 Pact JVM 核心的消费者驱动合约方法中。通过使用
    Arquillian Algeron Pact，您可以兼得两者之优：您可以使用 Pact-JVM 方法验证消费者和提供商，并且可以使用 Arquillian
    在类似生产的环境下运行测试。让我们看看 Arquillian Algeron Pact 如何适应消费者和提供商端。'
- en: To implement a consumer gateway using a JAX-RS client, the code only uses the
    API interfaces (the implementation is usually provided by the application server).
    To run your tests, you’ll need to define an implementation of JAX-RS; Apache CXF
    ([http://cxf.apache.org](http://cxf.apache.org)) is a good choice. You can provide
    an implementation in your build tool, or you can write an Arquillian test. In
    Arquillian, the test and the business code are deployed and run on the application
    server you’ll use in production with the same JAX-RS implementation and version.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 JAX-RS 客户端实现消费者网关，代码仅使用 API 接口（实现通常由应用服务器提供）。要运行您的测试，您需要定义一个 JAX-RS 的实现；Apache
    CXF ([http://cxf.apache.org](http://cxf.apache.org)) 是一个不错的选择。您可以在构建工具中提供实现，或者您可以编写一个
    Arquillian 测试。在 Arquillian 中，测试和业务代码将与您在生产中使用相同的 JAX-RS 实现和版本一起部署和运行在应用服务器上。
- en: On the provider side, you need to replay the contract against a running provider.
    You can rely on the build script to package and deploy the provider application,
    or you can use Arquillian to package and deploy the application in the test, avoiding
    dependence on a build tool.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供者端，你需要将合同回放到一个正在运行的提供者。你可以依赖构建脚本来打包和部署提供者应用程序，或者你可以使用 Arquillian 在测试中打包和部署应用程序，从而避免对构建工具的依赖。
- en: '|  |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: When you’re validating the provider side, you don’t need to run providers with
    real databases or real external services; you can use in-memory databases or stubs.
    For this reason, using an Arquillian microdeployment can help you create deployment
    files that contain configuration files and classes that point to in-memory databases
    or stubbing implementations.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在验证提供者端时，你不需要使用真实数据库或真实的外部服务来运行提供者；你可以使用内存数据库或存根。因此，使用 Arquillian 微部署可以帮助你创建包含配置文件和指向内存数据库或存根实现的类的部署文件。
- en: '|  |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Arquillian Algeron offers other features in addition to integration between
    Pact and Arquillian:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian Algeron 除了提供 Pact 和 Arquillian 之间的集成外，还提供其他功能：
- en: '*Publishers*—On the consumer side, you can configure it to publish contracts
    into a specified repository if they’re successfully generated. Currently supported
    publishers are *folder*, *URL*, *Git server*, and *Pact Broker*, but you can create
    your own as well.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*发布者*—在消费者端，你可以配置它将合同发布到指定的存储库，如果它们成功生成。目前支持的发布者是 *文件夹*、*URL*、*Git 服务器* 和 *Pact
    Broker*，但你也可以创建自己的。'
- en: '*Retrievers*—As with JUnit, you can configure contract loaders. In addition
    to those already supported in Pact JUnit (*folder*, *URL*, and *Pact Broker*),
    Arquillian Algeron supports *Git server* and *Maven artifact*.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检索者*—与 JUnit 类似，你可以配置合同加载器。除了 Pact JUnit 已支持的那些（*文件夹*、*URL* 和 *Pact Broker*）之外，Arquillian
    Algeron 还支持 *Git 服务器* 和 *Maven 软件包*。'
- en: '*Configuration*—Publishers and retrievers can be configured in an arquillian.xml
    file so everything is configured in a central place and not in every test class.
    Note that an annotation-based approach is also supported in retrievers.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*配置*—发布者和检索者可以在 arquillian.xml 文件中进行配置，这样所有配置都在一个中心位置，而不是每个测试类中。请注意，检索者还支持基于注解的方法。'
- en: '*TestNG*—Because Arquillian is test-framework-agnostic, you can use Pact and
    TestNG.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*TestNG*—由于 Arquillian 是测试框架无关的，你可以使用 Pact 和 TestNG。'
- en: Later, we’ll go deep into *publishers* and *retrievers* and how to use them.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将深入探讨 *发布者* 和 *检索者* 以及如何使用它们。
- en: '|  |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-279
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: It isn’t mandatory to use Arquillian Algeron Pact on both the consumer and provider
    sides. You can use Pact JVM or any Pact implementation in any language on either
    the consumer or provider side, and use Arquillian Algeron Pact on the other side.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在消费者和提供者端使用 Arquillian Algeron Pact 不是强制性的。你可以在消费者或提供者端使用 Pact JVM 或任何语言的 Pact
    实现，并在另一端使用 Arquillian Algeron Pact。
- en: '|  |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: As with Pact JVM, Arquillian Algeron Pact is divided into consumer and provider
    parts.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Pact JVM 类似，Arquillian Algeron Pact 被分为消费者和提供者两部分。
- en: '|  |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Because Arquillian Algeron uses Pact Core and not Pact JUnit, annotations are
    specific to Arquillian Algeron and aren’t the same as in Pact JUnit.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Arquillian Algeron 使用 Pact Core 而不是 Pact JUnit，因此注解是特定于 Arquillian Algeron
    的，并且与 Pact JUnit 中的不同。
- en: '|  |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Writing the consumer side with Arquillian Algeron Pact
  id: totrans-287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 Arquillian Algeron Pact 编写消费者端
- en: Following is an example of the consumer part of using Arquillian Algeron Pact,
    from ClientGatewayTest.java.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用 Arquillian Algeron Pact 的消费者部分的示例，来自 ClientGatewayTest.java。
- en: Listing 6.6\. Arquillian Algeron Pact, consumer side
  id: totrans-289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.6\. Arquillian Algeron Pact，消费者端
- en: '[PRE22]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***1* Arquillian runner**'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Arquillian 运行器**'
- en: '***2* To define the contract, you annotate a method or class with org.arquillian.algeron.pact.consumer.spi.Pact
    and set the provider and consumer name.**'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 定义合同，你需要在方法或类上注解 org.arquillian.algeron.pact.consumer.spi.Pact 并设置提供者和消费者名称。**'
- en: '***3* Defines what you want to deploy to the defined container**'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 定义你想要部署到定义的容器中的内容**'
- en: '***4* Returns a fragment of the contract (may be the entire contract)**'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 返回合同的一部分（可能是整个合同）**'
- en: '***5* Typical Arquillian enrichmen**'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 典型的 Arquillian 扩展**'
- en: '***6* Defines which provider is validated when this test method is executed**'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 定义在执行此测试方法时验证哪个提供者**'
- en: '***7* Asserts that the gateway can read the kind of messages sent by the provider**'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 断言网关可以读取提供者发送的消息类型**'
- en: Here, you’re writing a consumer contract test that defines a contract between
    `consumer` and `provider`. The client gateway is implemented using a JAX-RS client;
    it’s an EJB, so it knows to run that gateway under the same runtime it will find
    on production. For this reason, it’s a good approach to use Arquillian Algeron
    instead of Pact JVM alone.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您正在编写一个消费者合约测试，它定义了 `consumer` 和 `provider` 之间的合约。客户端网关使用 JAX-RS 客户端实现；它是一个
    EJB，因此它知道在它将在生产中找到的相同运行时下运行该网关。因此，使用 Arquillian Algeron 而不是单独使用 Pact JVM 是一种很好的方法。
- en: The `@Pact` annotation defines the interaction between consumer and provider.
    The annotation can be used at the class level, which means all contracts defined
    in this test are for the same provider; or, it can be used at the method level,
    which lets you specify that a concrete `PactFragment` defines only the interaction
    for the consumer-provider tuple defined in the annotation. Thus you could define
    contracts for different providers in the same consumer class. When the annotation
    is defined at the method level, it takes precedence over one defined at the class
    level.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Pact` 注解定义了消费者和提供者之间的交互。该注解可以在类级别使用，这意味着在此测试中定义的所有合约都是针对同一提供者；或者，它可以在方法级别使用，这意味着您可以指定一个具体的
    `PactFragment` 仅定义注解中定义的消费者-提供者元组的交互。因此，您可以在同一个消费者类中定义针对不同提供者的合约。当注解在方法级别定义时，它优先于在类级别定义的注解。'
- en: '|  |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Defining contracts for several providers in the same test isn’t something we
    recommend, because doing so breaks the pattern that one class should test one
    thing.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个测试中为多个提供者定义合约不是我们推荐的做法，因为这样做会打破一个类应该测试一个事物的模式。
- en: '|  |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Finally, for each test case, you need to specify which provider is validated
    when that test is run. You do so by using `@PactVerification` and setting the
    provider name. Notice that setting the provider name isn’t mandatory if you’re
    using the `@Pact` annotation at the class level, because the provider name is
    resolved from there.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于每个测试用例，您需要指定在运行测试时验证哪个提供者。您可以通过使用 `@PactVerification` 并设置提供者名称来实现。请注意，如果您在类级别使用
    `@Pact` 注解，则设置提供者名称不是强制性的，因为提供者名称将从那里解析。
- en: 'The steps executed when you use an Arquillian Algeron Pact consumer test are
    similar to a standard Arquillian test:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用 Arquillian Algeron Pact 消费者测试时执行的步骤与标准 Arquillian 测试类似：
- en: '**1**.  The chosen application server is started.'
  id: totrans-306
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 启动所选的应用程序服务器。'
- en: '**2**.  The (micro)deployment application file is deployed.'
  id: totrans-307
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 部署（微）应用程序文件。'
- en: '**3**.  The Pact Stub HTTP server is started.'
  id: totrans-308
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 启动 Pact Stub HTTP 服务器。'
- en: '**4**.  All interactions (`PactFragment`s) are recorded.'
  id: totrans-309
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**. 记录所有交互（`PactFragment`）。'
- en: '**5**.  Tests are executed.'
  id: totrans-310
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**. 执行测试。'
- en: '**6**.  For successful tests, contract files are generated.'
  id: totrans-311
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**6**. 对于成功的测试，生成合约文件。'
- en: '**7**.  The application is undeployed.'
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**7**. 取消部署应用程序。'
- en: '**8**.  The application server is stopped.'
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**8**. 停止应用程序服务器。'
- en: If you’re implementing more than one method that returns a `PactFragment` instance,
    you need to use the `fragment` attribute at `@PactVerification(.. fragment="createFragment")`
    to specify which fragment method is under test for that `@Test` method.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在实现多个返回 `PactFragment` 实例的方法，您需要在 `@PactVerification(.. fragment="createFragment")`
    的 `fragment` 属性中使用，以指定针对该 `@Test` 方法正在测试哪个片段方法。
- en: '|  |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-316
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can use Arquillian standalone with Arquillian Algeron if you want to skip
    the deployment step. This is useful if you’re using a client gateway that doesn’t
    depend on any features of your runtime.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 Arquillian 独立版与 Arquillian Algeron 一起使用，如果您想跳过部署步骤。这在您使用不依赖于您运行时任何功能的客户端网关时很有用。
- en: '|  |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Writing the provider side with Arquillian Algeron Pact
  id: totrans-319
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 Arquillian Algeron Pact 编写提供者端
- en: 'Now, let’s see how to write the provider part using Arquillian Algeron Pact.
    Because Arquillian Algeron uses Pact JVM, the approach is exactly the same: it
    replays all requests defined in the contract against the real provider and validates
    that the response is the expected one.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用 Arquillian Algeron Pact 编写提供者部分。因为 Arquillian Algeron 使用 Pact JVM，所以方法完全相同：它将合约中定义的所有请求回放至真实提供者，并验证响应是否为预期的。
- en: Listing 6.7\. Arquillian Algeron Pact, provider side
  id: totrans-321
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.7\. Arquillian Algeron Pact，提供者端
- en: '[PRE23]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1* Arquillian runner**'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Arquillian 运行器**'
- en: '***2* Sets the name of the provider used in the test**'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 设置测试中使用的提供者名称**'
- en: '***3* Configures where to get the pact contract files**'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 配置获取 pact 合约文件的位置**'
- en: '***4* The test must be run as a client; sets testable to false.**'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 测试必须作为客户端运行；将可测试性设置为 false。**'
- en: '***5* URL where the application is deployed**'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 应用程序部署的 URL**'
- en: '***6* A Target is a class that makes all the requests to the provider. Arquillian
    Algeron Pact uses an HTTP client target by default.**'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 目标是一个类，它向提供者发送所有请求。Arquillian Algeron Pact 默认使用 HTTP 客户端目标。**'
- en: '***7* Executes the interaction against the deployed application, and validates
    the response**'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 执行对已部署应用的交互，并验证响应**'
- en: This test validates that the provider meets the expectations defined by the
    consumer. Because you need to deploy a real provider, this is a good approach,
    because you can use Arquillian features to package, deploy, and start the application.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试验证提供者是否符合消费者定义的期望。因为你需要部署一个真实的提供者，这是一个很好的方法，因为你可以使用 Arquillian 功能来打包、部署和启动应用程序。
- en: The first thing you do in a provider test is specify which provider you’re validating.
    You do so by using `org.arquillian.algeron.pact.provider.spi.Provider` and setting
    the name of the provider given in the consumer test.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供者测试中，你首先需要指定你正在验证的提供者。你可以通过使用 `org.arquillian.algeron.pact.provider.spi.Provider`
    并设置在消费者测试中给出的提供者名称来完成此操作。
- en: 'Arquillian Algeron supports two ways to retrieve contracts: by using annotations
    or by configuring the retriever in arquillian.xml. The latter option will be covered
    in the section “[Registering publishers and retrievers](kindle_split_015_split_002.xhtml#ch06lev3sec12),”
    later in this chapter. In this test, contracts are retrieved from `pact` using
    the `org.arquillian.algeron.provider.core.retriever.ContractsFolder` annotation,
    but other annotations are also supported:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian Algeron 支持两种检索合约的方式：通过使用注解或在 arquillian.xml 中配置检索器。后者将在本章后面的“[注册发布者和检索者](kindle_split_015_split_002.xhtml#ch06lev3sec12)”部分中介绍。在这个测试中，合约是通过使用
    `org.arquillian.algeron.provider.core.retriever.ContractsFolder` 注解从 `pact` 中检索的，但也支持其他注解：
- en: '`org.arquillian.algeron.provider.core.retriever.ContractsUrl`—Retrieves contracts
    from a URL'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.arquillian.algeron.provider.core.retriever.ContractsUrl`—从 URL 中检索合约'
- en: '`org.arquillian.algeron.pact.provider.loader.git.ContractsGit`—Retrieves contracts
    from a Git repository'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.arquillian.algeron.pact.provider.loader.git.ContractsGit`—从 Git 仓库中检索合约'
- en: '`org.arquillian.algeron.pact.provider.loader.maven.ContractsMavenDependency`—Retrieves
    contracts from Maven artifacts'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.arquillian.algeron.pact.provider.loader.maven.ContractsMavenDependency`—从
    Maven 艺术品中检索合约'
- en: '`org.arquillian.algeron.pact.provider.core.loader.pactbroker.PactBroker`—Retrieves
    contracts from a Pact Broker server'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.arquillian.algeron.pact.provider.core.loader.pactbroker.PactBroker`—从
    Pact Broker 服务器检索合约'
- en: It’s important to make this test run as a client, which means the test isn’t
    executed in the application server. You can use Arquillian as the deployer; but
    replaying the interactions must be done from outside the container, as any other
    consumer would do.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是使这个测试作为一个客户端运行，这意味着测试不是在应用服务器中执行的。你可以使用 Arquillian 作为部署者；但是重放交互必须从容器外部进行，就像任何其他消费者一样。
- en: Finally, you need to enrich the test with the URL where the application is deployed
    and an instance of `org.arquillian.algeron.pact.provider.core.httptarget.Target`,
    which you use to replay all interactions by calling the `testInteraction` method.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要丰富测试，包括应用部署的 URL 和 `org.arquillian.algeron.pact.provider.core.httptarget.Target`
    的实例，后者用于通过调用 `testInteraction` 方法重放所有交互。
- en: 'The steps executed in an Arquillian Algeron Pact provider test are similar
    to a standard Arquillian test:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Arquillian Algeron Pact 提供者测试中执行的步骤类似于标准的 Arquillian 测试：
- en: '**1**.  The chosen application server is started.'
  id: totrans-340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 启动了选定的应用服务器。'
- en: '**2**.  The (micro)deployment application file is deployed.'
  id: totrans-341
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 部署了（微）部署应用程序文件。'
- en: '**3**.  Contracts are retrieved from the given location.'
  id: totrans-342
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 从给定位置检索合约。'
- en: '**4**.  For each contract, Arquillian Algeron extracts each request/response
    pair, sends a request to the provider, and validates the response against the
    contract response.'
  id: totrans-343
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**. 对于每个合约，Arquillian Algeron 提取每个请求/响应对，向提供者发送请求，并验证响应是否符合合约响应。'
- en: '**5**.  The application is undeployed.'
  id: totrans-344
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**. 应用程序被卸载。'
- en: '**6**.  The application server is stopped.'
  id: totrans-345
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**6**. 应用服务器被停止。'
- en: Next, let’s examine how you can use a feature provided by Arquillian Algeron
    that lets you publish contracts automatically and retrieve them in the provider.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何使用 Arquillian Algeron 提供的自动发布合约并在提供者中检索合约的功能。
- en: Registering publishers and retrievers
  id: totrans-347
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注册发布者和检索者
- en: As mentioned earlier, Arquillian Algeron offers the possibility of publishing
    contracts to a repository and retrieving them for validation. Publishers are configured
    in an Arquillian configuration file called arquillian.xml. Retrievers can be configured
    using annotations, as you saw in the previous section, or in arquillian.xml.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Arquillian Algeron 提供了将合约发布到存储库并检索它们进行验证的可能性。发布者配置在名为 arquillian.xml 的
    Arquillian 配置文件中。检索器可以使用注解配置，正如您在上一节中看到的，或者在 arquillian.xml 中配置。
- en: 'At the time of writing, Arquillian Algeron defines four publishers out of the
    box:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Arquillian Algeron 默认定义了四个发布者：
- en: '*Folders*—Copies contracts to a given folder'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Folders*—将合约复制到给定的文件夹'
- en: '*Url*—Makes a POST request to a given URL, with the contract as the body'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Url*—向给定的 URL 发送 POST 请求，将合约作为正文'
- en: '*Git*—Pushes contracts into a Git repository'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Git*—将合约推送到 Git 存储库'
- en: '*pact-broker*—A specific publisher to store the contract in Pact Broker'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*pact-broker*—将合约存储在 Pact Broker 中的特定发布者'
- en: '|  |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Microdeployments**'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '**微部署**'
- en: A provider can also be a consumer of other services, or it may have dependencies
    on datasources. This is inconvenient, because to validate the contract against
    the provider, you may have to boot up other providers and datasources, which is
    difficult and sometimes leaves you with flaky tests.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者也可以是其他服务的消费者，或者它可能依赖于数据源。这很麻烦，因为为了验证合约与提供者的兼容性，您可能必须启动其他提供者和数据源，这很困难，有时还会导致测试不稳定。
- en: In the following figure, you can see that provider 1 is also a consumer of two
    services and requires a database.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，您可以看到提供者 1 也是一个两个服务的消费者，并需要数据库。
- en: '![](Images/f0155-01_alt.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0155-01_alt.jpg)'
- en: A provider that’s also a consumer
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 同时是提供者和消费者的提供者
- en: The solution for avoiding dependency problems in tests depends on the kind of
    dependency. If you’re dealing with another provider, you can use the service-virtualization
    approach using WireMock, as explained in [chapter 4](kindle_split_013_split_000.xhtml#ch04).
    If you’re using a datasource, you can use your own stubs at database entry points
    with the required data, or use an in-memory database, as explained in [chapter
    5](kindle_split_014_split_000.xhtml#ch05).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 避免测试中依赖项问题的解决方案取决于依赖项的类型。如果您正在处理另一个提供者，您可以使用 WireMock 的服务虚拟化方法，如[第 4 章](kindle_split_013_split_000.xhtml#ch04)中所述。如果您正在使用数据源，您可以在数据库入口点使用自己的存根以及所需的数据，或者使用内存数据库，如[第
    5 章](kindle_split_014_split_000.xhtml#ch05)中所述。
- en: But in all cases, your deployment file will be different than the one you use
    in production. It contains test-configuration files that point to the service-virtualization
    instances and configure them to use an in-memory database or packaged alternative
    classes as stubs. In this context, as you learned in [chapter 4](kindle_split_013_split_000.xhtml#ch04),
    ShrinkWrap and microdeployment are helpful for generating deployment files dynamically
    in tests.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 但在所有情况下，您的部署文件都将与您在生产中使用的文件不同。它包含指向服务虚拟化实例的测试配置文件，并将它们配置为使用内存数据库或打包的替代类作为存根。在这种情况下，正如您在[第
    4 章](kindle_split_013_split_000.xhtml#ch04)中学到的，ShrinkWrap 和微部署有助于在测试中动态生成部署文件。
- en: '|  |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Arquillian Algeron also provides an SPI so you can implement your own publisher,
    but this topic is beyond the scope of this book. Refer to the Arquillian Algeron
    documentation for more information.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian Algeron 还提供了一个 SPI，以便您可以实现自己的发布者，但这个主题超出了本书的范围。有关更多信息，请参阅 Arquillian
    Algeron 文档。
- en: It’s important to note that a Arquillian Algeron consumer won’t publish contracts
    by default. This is a safety precaution to avoid publishing contracts every time
    consumer tests are run locally. To modify this behavior, you need to set the `publishContracts`
    configuration attribute to `true`. You should only do that if you’re publishing
    a new version of a consumer, and this action should be performed by your continuous
    (CI/CD) environment.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，Arquillian Algeron 的消费者默认不会发布合约。这是一个安全预防措施，以避免每次在本地运行消费者测试时都发布合约。要修改此行为，您需要将
    `publishContracts` 配置属性设置为 `true`。您只有在发布消费者的新版本时才应该这样做，并且此操作应由您的持续（CI/CD）环境执行。
- en: '|  |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-366
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can configure arquillian.xml attributes with system properties or environment
    variables by using a `${system_property}` placeholder or a `${env.environment_variable}`
    placeholder. You can add a default value by following the variable name with a
    colon (`:`) and the value.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用 `${system_property}` 占位符或 `${env.environment_variable}` 占位符来使用系统属性或环境变量配置
    arquillian.xml 属性。您可以通过在变量名称后跟一个冒号（`:`）和值来添加默认值。
- en: '|  |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Here’s an example of how to configure a Git publisher in arquillian.xml:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何在arquillian.xml中配置Git发布者的一个示例：
- en: '[PRE24]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1* Sets the publisher to Git**'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 设置发布者为Git**'
- en: '***2* Retrieves the URL of the Git repository from the giturl environment variable**'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从giturl环境变量中检索Git仓库的URL**'
- en: '***3* The commit’s comment field contains the version number, or 1.0.0 if the
    version isn’t provided.**'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 提交的注释字段包含版本号，如果没有提供，则为1.0.0。**'
- en: '***4* Sets the directory where contracts are generated**'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 设置生成合同的目录**'
- en: This snippet configures the publisher to push generated contracts to a Git repository.
    The publishing process is executed only when the environment variable `publishcontracts`
    is set to `true`; otherwise, contracts are generated in a local directory but
    not published.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段配置发布者将生成的合同推送到Git仓库。只有在环境变量`publishcontracts`设置为`true`时，才会执行发布过程；否则，合同将在本地目录中生成，但不会发布。
- en: Next, we’ll look at how to configure retrievers in arquillian.xml. Registering
    a retriever in arquillian.xml uses the same approach as registering a publisher.
    The same retrievers mentioned in [section 6.2.3](kindle_split_015_split_002.xhtml#ch06lev2sec8),
    which can be used as annotations, are supported here.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何在arquillian.xml中配置检索器。在arquillian.xml中注册检索器的方法与注册发布者的方法相同。与[第6.2.3节](kindle_split_015_split_002.xhtml#ch06lev2sec8)中提到的相同检索器，可以作为注解使用，这里也支持。
- en: 'Here’s how to configure a retriever to get contracts from a Git repository:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何配置检索器以从Git仓库获取合同的方法：
- en: '[PRE25]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The format is similar to that for providers. Obviously, the property name and
    extension name are different, because retrievers are an important part of the
    provider side.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 格式与提供者部分的格式类似。显然，属性名和扩展名是不同的，因为检索器是提供者端的一个重要部分。
- en: After this thorough introduction to contract testing, let’s explore how to apply
    them to the book’s example.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在对合同测试进行了彻底介绍之后，让我们探索如何将这些方法应用到书籍的示例中。
- en: 6.3\. Build-script modifications
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3\. 构建脚本修改
- en: As you now know, contract tests are divided between the consumer side and the
    provider side. Each has its own dependencies. Let’s look at each of these dependency
    cases, when using either Pact JVM or Arquillian Algeron.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，合同测试在消费者端和提供者端之间分配。每个都有自己的依赖项。让我们看看使用Pact JVM或Arquillian Algeron时每个依赖项的情况。
- en: 6.3.1\. Using Pact JVM for contract testing
  id: totrans-383
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.1\. 使用Pact JVM进行合同测试
- en: 'If you’re using Pact JVM for consumer-driven contracts, you need to add dependencies.
    For the consumer part, add the following dependencies:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Pact JVM进行消费者驱动的合同，你需要添加依赖项。对于消费者部分，请添加以下依赖项：
- en: '[PRE26]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And for the provider part, add these dependencies:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 对于提供者部分，请添加以下依赖项：
- en: '[PRE27]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 6.3.2\. Using Arquillian Algeron for contract testing
  id: totrans-388
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.2\. 使用Arquillian Algeron进行合同测试
- en: 'To use Arquillian Algeron with Pact JVM, you need to use at least two dependencies:
    Arquillian Algeron Pact, and Pact itself.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Arquillian Algeron与Pact JVM，你需要至少添加两个依赖项：Arquillian Algeron Pact和Pact本身。
- en: 'For the consumer part, add these dependencies:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 对于消费者部分，请添加以下依赖项：
- en: '[PRE28]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you’re using the Git publisher, you also need to add this dependency:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Git发布者，也需要添加以下依赖项：
- en: '[PRE29]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'For the provider part, add the following dependencies:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 对于提供者部分，请添加以下依赖项：
- en: '[PRE30]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Also add this, if you want to integrate with AssertJ:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想与AssertJ集成，也请添加以下内容：
- en: '[PRE31]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If you’re using the Git retriever, add this dependency:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Git检索器，请添加以下依赖项：
- en: '[PRE32]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you’re using the Maven retriever, add this dependency:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Maven检索器，请添加以下依赖项：
- en: '[PRE33]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And if you’re using the Pact Broker retriever, you also need to add this dependency:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Pact Broker检索器，也需要添加以下依赖项：
- en: '[PRE34]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: After you’ve registered the dependencies in the build script, you can start
    writing contract tests.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在你在构建脚本中注册了依赖项之后，你就可以开始编写合同测试了。
- en: 6.4\. Writing consumer-driven contracts for the Gamer application
  id: totrans-405
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4\. 为Gamer应用程序编写消费者驱动的合同
- en: 'Let’s write a contract test for the unique consumer that’s provided in the
    current application: the aggregator service. We’ll also show you the provider
    side, which validates the given contract. In this case, tests are created in a
    new module/subproject in the main project called, for example, c-tests.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为当前应用程序中提供的唯一消费者编写一个合同测试：聚合服务。我们还将展示提供者端，它验证给定的合同。在这种情况下，测试是在主项目中的新模块/子项目中创建的，例如，称为c-tests。
- en: 6.4.1\. Consumer side of the comments service
  id: totrans-407
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.1\. 评论服务的消费者端
- en: The aggregator service communicates with services such as game and comments,
    so it’s effectively a consumer of all of them. Let’s examine how to write the
    contract between the aggregator service and the comments service. The class responsible
    for communicating with the comments service is `book.aggr.CommentsGateway`. This
    is a simple `boundary` class that acts as a gateway between the aggregator service
    and the comments service. You’ll use Arquillian Algeron, to take advantage of
    its publishing capabilities.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合服务与游戏和评论等服务进行通信，因此它实际上是所有这些服务的消费者。让我们看看如何编写聚合服务与评论服务之间的合同。负责与评论服务通信的类是`book.aggr.CommentsGateway`。这是一个简单的`boundary`类，作为聚合服务与评论服务之间的网关。你将使用Arquillian
    Algeron，以利用其发布功能。
- en: First, here’s the contract for storing comments (code/aggregator/c-tests/src/test/java/book/aggr/CommentsContractTest.java).
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这是存储评论的合同（code/aggregator/c-tests/src/test/java/book/aggr/CommentsContractTest.java）。
- en: Listing 6.8\. Storing comments
  id: totrans-410
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.8\. 存储评论
- en: '[PRE35]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '***1* Arquillian test runner**'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Arquillian测试运行器**'
- en: '***2* Sets the Pact annotation with the consumer and provider names**'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 设置带有消费者和提供者名称的Pact注解**'
- en: '***3* Creates the PactFragment that defines the contract for posting comments**'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 创建定义发布评论合同的PactFragment**'
- en: '***4* Sets the body message**'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 设置正文消息**'
- en: '***5* Configures the method as a contact validator of the fragment defined
    in putCommentFragment**'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将方法配置为putCommentFragment中定义的片段的合同验证器**'
- en: '***6* Connects to the HTTP stub server**'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 连接到HTTP存根服务器**'
- en: This test uses Arquillian standalone, because there’s no `@Deployment` method.
    At this point, you don’t need to deploy anything to the container. The contract
    for sending a comment to the comments service is defined in `putCommentFragment`,
    which defines the contract with the expected body and the canned response. Finally,
    there are the assertions for validating that the `CommentsGateway` class works
    as expected.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试使用Arquillian standalone，因为没有`@Deployment`方法。在这个阶段，你不需要将任何内容部署到容器中。向评论服务发送评论的合同定义在`putCommentFragment`中，它定义了带有预期正文和预设响应的合同。最后，还有验证`CommentsGateway`类按预期工作的断言。
- en: Now let’s write the contract for getting comments for a given `gameId` (code/aggregator/c-tests/src/test/java/book/aggr/CommentsContractTest.java).
    In this case, you need to set a state for telling the provider which data you
    expect to be returned when the contract is validated against it.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写获取特定`gameId`评论的合同（code/aggregator/c-tests/src/test/java/book/aggr/CommentsContractTest.java）。在这种情况下，你需要设置一个状态，告诉提供者当合同与它验证时，你期望返回哪些数据。
- en: Listing 6.9\. Getting comments for a game
  id: totrans-420
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.9\. 获取游戏的评论
- en: '[PRE36]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '***1* Sets state information**'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 设置状态信息**'
- en: '***2* Asserts responses**'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 断言响应**'
- en: Notice that the definition of the contract is similar to the previous one. The
    biggest difference is the use of the `given` method to set a state. In this case,
    you’re setting the data that will be required on the provider side.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，合同的定义与上一个类似。最大的区别是使用了`given`方法来设置状态。在这种情况下，你正在设置在提供者端所需的数据。
- en: Finally, you need to configure Arquillian Algeron to publish contracts in a
    shared place, so the provider can retrieve and validate them (code/aggregator/c-tests/src/test/resources/arquillian.xml).
    For the sake of simplicity, the folder approach is used here, but in the real
    world you’d probably use a Git repository.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要配置Arquillian Algeron，以便在共享位置发布合同，以便提供者可以检索和验证它们（code/aggregator/c-tests/src/test/resources/arquillian.xml）。为了简化，这里使用了文件夹方法，但在现实世界中你可能会使用Git仓库。
- en: Listing 6.10\. Publishing contracts in a shared location
  id: totrans-426
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.10\. 在共享位置发布合同
- en: '[PRE37]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now that you’ve written the contract for the consumer side, let’s see what you
    need to do to validate it against the provider.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经为消费者端写好了合同，让我们看看你需要做什么来验证它是否符合提供者端。
- en: 6.4.2\. Provider side of the comments service
  id: totrans-429
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.2\. 评论服务的提供者端
- en: 'To validate contracts generated on the consumer side, you need to create a
    test on the provider project that downloads contracts and replays them against
    a running instance of the provider (code/comments/c-tests/src/test/java/book/comments/boundary/CommentsProviderTest.java).
    You need to deploy the real comments service, so using Arquillian Algeron is a
    good choice: it takes care of creating the deployment file and deploying it to
    the application server. Contracts are stored in the same folder defined in the
    `publishConfiguration` property, as discussed in the previous section.'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证消费者端生成的合约，您需要在提供者项目中创建一个测试，该测试下载合约并在提供者的运行实例上回放它们（code/comments/c-tests/src/test/java/book/comments/boundary/CommentsProviderTest.java）。您需要部署真实的评论服务，因此使用Arquillian
    Algeron是一个不错的选择：它负责创建部署文件并将其部署到应用程序服务器。合约存储在与前一个部分中讨论的`publishConfiguration`属性定义的同一文件夹中。
- en: Listing 6.11\. Testing the comments service on the provider side
  id: totrans-431
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.11\. 在提供者端测试评论服务
- en: '[PRE38]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '***1* Sets the contract location**'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 设置合约位置**'
- en: '***2* Configures the provider**'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 配置提供者**'
- en: '***3* Sets the MongoDB home directory**'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 设置MongoDB主目录**'
- en: '***4* Uses NoSQLUnit managed MongoDB**'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用NoSQLUnit管理的MongoDB**'
- en: '***5* Configures a MongoDB remote connection**'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 配置MongoDB远程连接**'
- en: '***6* Ensures that the test runs in client mode**'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 确保测试以客户端模式运行**'
- en: '***7* Populates the required data to the provider from the contract definition**'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 从合约定义中向提供者注入所需数据**'
- en: '***8* Injects the Target class for replaying the contract**'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 注入用于回放合约的目标类**'
- en: '***9* Cleans the database after each run**'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 每次运行后清理数据库**'
- en: '|  |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-443
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Be sure to adapt the contract location and MongoDB home to your environment
    before running the test.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行测试之前，务必将合约位置和MongoDB主目录适配到您的环境中。
- en: '|  |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'This test prepares the environment by starting the MongoDB database and Apache
    TomEE. Then it deploys the application and replays the contract against the configured
    environment. Note the following three important things:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试通过启动MongoDB数据库和Apache TomEE来准备环境。然后它部署应用程序并针对配置的环境回放合约。请注意以下三个重要事项：
- en: You use NoSQLUnit to prepare the MongoDB environment. NoSQLUnit can be used
    in integration tests, as you saw in [chapter 5](kindle_split_014_split_000.xhtml#ch05),
    and also in any other kind of test.
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您使用NoSQLUnit来准备MongoDB环境。NoSQLUnit可用于集成测试，正如您在[第5章](kindle_split_014_split_000.xhtml#ch05)中看到的，以及任何其他类型的测试。
- en: The state method `insertGame` is only used by the part of the contract that
    defined the state on the consumer side. This is the part of the contract that
    validates receiving comments from the service.
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态方法`insertGame`仅由定义消费者端状态的合约部分使用。这是合约中验证从服务接收评论的部分。
- en: In the state method, the test uses the POST method to populate the data, so
    you’re effectively using the comments service endpoint to insert data into the
    database. You use the `RestAssured` test framework for this purpose.
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在状态方法中，测试使用POST方法填充数据，因此您实际上正在使用评论服务端点将数据插入数据库。您使用`RestAssured`测试框架来完成此目的。
- en: '[Figure 6.12](kindle_split_015_split_004.xhtml#ch06fig12) summarizes the lifecycle
    when you run this test. First, the Arquillian test uses NoSQLUnit to start an
    instance of MongoDB installed on the system property/environment variable `MONGO_HOME`.
    Then, it starts an instance of Apache TomEE and deploys the comments service inside
    it. If a contract defines a state following the form `A game with id (\d+) with
    rate (\d+) and message (.+)`, some data is populated in MongoDB using the comments
    service. Finally, the test replays each of the contracts, cleaning the database
    before each execution.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6.12](kindle_split_015_split_004.xhtml#ch06fig12)总结了运行此测试时的生命周期。首先，Arquillian测试使用NoSQLUnit启动系统属性/环境变量`MONGO_HOME`上安装的MongoDB的一个实例。然后，它启动Apache
    TomEE的一个实例并在其中部署评论服务。如果合约定义了一个形式为`A game with id (\d+) with rate (\d+) and message
    (.+)`的状态，则使用评论服务在MongoDB中填充一些数据。最后，测试回放每个合约，在每次执行前清理数据库。'
- en: Figure 6.12\. The test lifecycle
  id: totrans-451
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.12\. 测试生命周期
- en: '![](Images/06fig12_alt.jpg)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06fig12_alt.jpg)'
- en: 6.5\. Contract type summary
  id: totrans-453
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5\. 合约类型总结
- en: The following table summarizes the types of contracts we’ve discussed.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了我们所讨论的合约类型。
- en: Table 6.1\. Consumer, provider, and consumer-driven contracts
  id: totrans-455
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表6.1\. 消费者、提供者和消费者驱动合约
- en: '| Contract | Complete | Number | Bounded |'
  id: totrans-456
  prefs: []
  type: TYPE_TB
  zh: '| 合约 | 完成 | 数量 | 有界 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Provider | Yes | Single | Space/Time |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '| 提供者 | 是 | 单一 | 空间/时间 |'
- en: '| Consumer | No | Multiple | Space/Time |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '| 消费者 | 否 | 多个 | 空间/时间 |'
- en: '| Consumer-driven | Yes | Single | Consumers |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '| 消费者驱动 | 是 | 单一 | 消费者 |'
- en: 'The provider- and consumer-driven approaches are *complete*: they provide a
    complete set of functionalities. With the consumer approach, contracts are incomplete
    from the point of view of the functionalities available to the system. In addition,
    the provider- and consumer-driven approaches are *singular* in their expression
    of business functionality; but with the consumer approach, each consumer has its
    own contract.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者和消费者驱动的方案是**完整**的：它们提供了一套完整的功能。从系统可用的功能角度来看，消费者驱动的合同是不完整的。此外，提供者和消费者驱动的方案在表达业务功能方面是**单一**的；但消费者驱动的方案，每个消费者都有自己的合同。
- en: Exercise
  id: totrans-462
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: You should now be able to write any pair of consumer/provider tests. We recommend
    that you try to define the consumer side of the game service, and then the provider
    side.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够编写任何一对消费者/提供者测试。我们建议你尝试定义游戏服务的消费者端，然后是提供者端。
- en: '|  |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-465
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Take a look at [chapter 4](kindle_split_013_split_000.xhtml#ch04), which introduced
    writing tests for WildFly Swarm using Arquillian.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[第4章](kindle_split_013_split_000.xhtml#ch04)，其中介绍了使用Arquillian为WildFly Swarm编写测试。
- en: '|  |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-468
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Using consumer-driven contracts provides faster execution of tests.
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用消费者驱动的合同可以提供测试的更快执行。
- en: You won’t end up with flaky tests, because with HTTP stub servers, you always
    receive reliable responses.
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不会得到不可靠的测试，因为使用HTTP存根服务器，你总是收到可靠的响应。
- en: Tests are split between consumer and provider, so it’s easier to identify the
    cause of a failure.
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试在消费者和提供者之间分割，因此更容易识别失败的原因。
- en: Incorporating consumer-driven contracts is a design process.
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将消费者驱动的合同纳入是设计过程的一部分。
- en: Consumer-driven contracts doesn’t mean *dictator*-consumer-driven contracts.
    The contract is the starting point of a collaborative effort that begins on the
    consumer side, but both sides must work on it.
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者驱动的合同并不意味着**独裁者**驱动的合同。合同是协作努力的起点，始于消费者端，但双方都必须参与其中。
- en: With contract tests, you avoid having to know from the consumer side how to
    package and deploy the provider side. The consumer side only needs to know how
    to deploy its part. When you validate the contract on the provider, the provider
    knows how to deploy itself and how to mock/stub its own dependencies. This is
    a huge difference from end-to-end tests, where you must start a full environment
    to be able to run the tests.
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用合同测试，你可以避免从消费者方面知道如何打包和部署提供者端。消费者端只需要知道如何部署其部分。当你验证提供者的合同时，提供者知道如何部署自己以及如何模拟/存根自己的依赖。这与端到端测试有巨大差异，在端到端测试中，你必须启动一个完整的环境才能运行测试。
- en: A consumer-driven contract may not always be the best approach to follow. Normally
    it is, but in some situations (like those described in [section 6.1.5](kindle_split_015_split_001.xhtml#ch06lev2sec5)),
    you may want to use provider-driven contracts or consumer contracts.
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者驱动的合同不一定总是最佳的方法。通常是的，但在某些情况下（如[第6.1.5节](kindle_split_015_split_001.xhtml#ch06lev2sec5)中描述的情况），你可能想使用提供者驱动的合同或消费者合同。
