- en: 6 Access control and security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 访问控制和安全
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Areas of attack when using GitOps-driven deployment
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GitOps驱动的部署时的攻击区域
- en: Ensuring that critical infrastructure components are protected
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保关键基础设施组件得到保护
- en: Guidelines for choosing the right configuration management pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择正确配置管理模式的指南
- en: Enhancing security to avoid security pitfalls in GitOps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提升安全性以避免GitOps中的安全陷阱
- en: Access control and security topics are always essential and are especially crucial
    for deployment and infrastructure management. In this case, the attack surface
    includes expensive things like infrastructure, dangerous things like policy and
    compliance, and the most important things like data stores that contain user data.
    Modern operations methodologies enable engineering teams to move at a much quicker
    pace and optimize for fast iterations. However, more releases also mean more chances
    of introducing vulnerabilities and lead to new challenges for security teams.
    Traditional security processes that rely on human operational knowledge may still
    work but struggle to scale and meet the needs of enterprises utilizing GitOps
    with automated build and release infrastructure.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 访问控制和安全主题始终是必不可少的，尤其是在部署和基础设施管理方面尤为重要。在这种情况下，攻击面包括像基础设施这样的昂贵事物，像政策和合规性这样的危险事物，以及像包含用户数据的数据存储这样的最重要的事物。现代运维方法使工程团队能够以更快的速度移动，并优化快速迭代。然而，更多的发布也意味着引入漏洞的机会更多，给安全团队带来了新的挑战。依赖于人类操作知识的传统安全流程可能仍然有效，但难以扩展并满足利用GitOps和自动化构建及发布基础设施的企业需求。
- en: We recommend you read chapters 1 and 2 before reading this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章之前，我们建议您先阅读第1章和第2章。
- en: 6.1 Introduction to access control
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 访问控制简介
- en: The security topic is both critical and complex. Usually, it is handled by a
    security specialist or even a whole dedicated security team. So why do we talk
    about it while discussing GitOps? GitOps changes security responsibilities in
    the same way it has altered operational responsibility boundaries. With GitOps
    and Kubernetes, the engineering team is empowered to contribute to security by
    writing Kubernetes access configs and using Git to enforce proper configuration
    change processes. Given that the security team is no longer a bottleneck, it can
    offload some responsibilities to developers and focus on providing security infrastructure.
    GitOps facilitates a tighter and more productive collaboration between security
    engineers and DevOps engineers, allowing any proposed changes that impact an environment’s
    security to undergo proper security reviews and approval before it affects production.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 安全主题既关键又复杂。通常，它由安全专家甚至整个专门的安全团队处理。那么，为什么在讨论GitOps时还要谈论它呢？GitOps以同样的方式改变了安全责任，就像它改变了运营责任边界一样。有了GitOps和Kubernetes，工程团队能够通过编写Kubernetes访问配置和使用Git来强制执行适当的配置更改流程来参与安全。鉴于安全团队不再是瓶颈，它可以卸载一些责任给开发者，并专注于提供安全基础设施。GitOps促进了安全工程师和DevOps工程师之间更紧密和更有效的合作，允许任何影响环境安全性的变更在影响生产之前经过适当的网络安全审查和批准。
- en: 6.1.1 What is access control?
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.1 什么是访问控制？
- en: To better understand the nuances of access control in combination with GitOps,
    let’s learn what access control is first.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解访问控制与GitOps结合的细微差别，让我们首先了解什么是访问控制。
- en: 'Access control is a way of limiting access to a system or to physical or virtual
    resources. It dictates who is allowed to access the protected resources and what
    operations are allowed to be performed. Access control is composed of two parts:
    authentication, ensuring that users are who they say they are; and authorization,
    ensuring they have appropriate access to perform the requested action against
    the specified resources. Regardless of the domain area, access control includes
    three main components: subject, object, and reference monitor.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 访问控制是一种限制对系统或物理或虚拟资源的访问的方式。它规定了谁可以访问受保护资源以及允许执行哪些操作。访问控制由两部分组成：身份验证，确保用户是他们所说的那个人；以及授权，确保他们有权对指定的资源执行请求的操作。无论在哪个领域，访问控制都包括三个主要组件：主体、对象和引用监控器。
- en: 'The most straightforward demonstration of the access control system is a physical
    world example: a person trying to enter the building through the door. The person
    is a subject who is trying to access the object, which is a building. The door
    is a reference monitor that will authorize the access request only if the person
    trying to enter has the door key.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 访问控制系统最直接的演示是现实世界的一个例子：一个人试图通过门进入大楼。这个人是一个主题，他试图访问对象，即大楼。门是一个引用监控器，只有当试图进入的人有门钥匙时，它才会授权访问请求。
- en: '![](Images/CH06_F01_Yuen.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH06_F01_Yuen.png)'
- en: Figure 6.1 The subject is the entity that requests access to an object. The
    object is the entity or resource being accessed. The reference monitor is the
    entity controlling access to the protected object.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 主题是请求访问对象的实体。对象是被访问的实体或资源。引用监控器是控制对受保护对象访问的实体。
- en: Exercise 6.1
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 6.1
- en: An email client is trying to read emails from an email server. Can you identify
    what the subject, object, and reference monitor are for this scenario?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一个电子邮件客户端正在尝试从电子邮件服务器读取电子邮件。你能识别出这个场景中的主题、对象和引用监控器是什么吗？
- en: 6.1.2 What to secure
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.2 要保护什么
- en: When securing the application delivery process to a Kubernetes cluster end to
    end, many different components need to be secured. These include (but are not
    limited to)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在端到端安全应用程序交付到 Kubernetes 集群的过程中，许多不同的组件需要被保护。这些包括（但不限于）
- en: CI/CD pipeline
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CI/CD 管道
- en: Container registry
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器注册库
- en: Git repository
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git 仓库
- en: Kubernetes cluster
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 集群
- en: Cloud provider or data center
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云服务提供商或数据中心
- en: The application itself
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序本身
- en: GitOps operator (if applicable)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitOps 操作员（如果适用）
- en: Each of these components has its unique security concerns, authentication mechanisms,
    and role-based access control (RBAC) models, and will be configured differently
    depending on many factors and considerations. Since security is only as strong
    as the weakest link, all components play an equally important role in the cluster’s
    overall security.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些每个组件都有其独特的安全关注点、身份验证机制和基于角色的访问控制（RBAC）模型，并且将根据许多因素和考虑进行不同的配置。由于安全性的强弱取决于最薄弱的环节，所有组件在集群的整体安全性中都扮演着同等重要的角色。
- en: Generally speaking, security choices are often a balancing act between security
    and convenience. A system that might be extremely secure may be so inconvenient
    that it becomes unusable from a user perspective. As an operator, the goal is
    to make the user experience as convenient as reasonably possible without compromising
    security.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，安全选择往往是安全和便利之间的权衡。一个可能非常安全的系统可能因为不便而变得无法使用。作为一个操作员，目标是尽可能使用户体验方便，同时不牺牲安全。
- en: Some considerations that factor into the security of components include
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 影响组件安全性的考虑因素包括
- en: Potential attack vectors
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能的攻击向量
- en: Worst-case consequences if the component becomes compromised
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果组件被攻破的最坏后果
- en: Who should be allowed access to the service
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该允许哪些人访问该服务
- en: What permissions (RBAC) various users have
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同用户具有的权限（RBAC）
- en: What protections can be put in place to mitigate risk
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以采取哪些保护措施来减轻风险
- en: The next few sections describe these components and some of the unique security
    considerations.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下几节将描述这些组件以及一些独特的安全考虑因素。
- en: CI/CD pipeline
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD 管道
- en: The CI/CD build and deployment pipeline is the starting point for delivering
    freshly built software to the Kubernetes cluster. Jenkins, Circle CI, and Travis
    CI are examples of some popular CI/CD systems. Security is frequently an afterthought
    since most thought and energy is focused on protecting the production environment
    and production data. Still, the CI/CD is an equally important piece of the puzzle.
    This is because the CI/CD pipeline ultimately controls *how* new software is driven
    to the environment. When compromised, it has the capability of delivering *harmful*
    software to the cluster.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD 构建和部署管道是将新构建的软件交付到 Kubernetes 集群的起点。Jenkins、Circle CI 和 Travis CI 是一些流行的
    CI/CD 系统的例子。由于大多数的思考和精力都集中在保护生产环境和生产数据上，安全通常是被事后考虑的。然而，CI/CD 同样是拼图中不可或缺的一部分。这是因为
    CI/CD 管道最终控制着新软件如何被推送到环境中。一旦被攻破，它就有能力将 *有害* 的软件推送到集群中。
- en: A build system is generally configured with sufficient credentials to perform
    its duties. For example, to publish new container images, the CI/CD pipeline might
    require credentials to the container registry. Traditionally, the build system
    is also given access and credentials to the Kubernetes cluster to perform the
    actual deployment. But as we will see later in this chapter, direct access to
    the cluster is no longer necessary with the advent of GitOps.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 构建系统通常配置有足够的凭证来执行其职责。例如，为了发布新的容器镜像，CI/CD管道可能需要访问容器注册表的凭证。传统上，构建系统也被赋予访问和凭证以访问Kubernetes集群，以执行实际的部署。但正如我们将在本章后面看到的那样，随着GitOps的出现，直接访问集群不再必要。
- en: An attacker with access to the CI/CD build system could compromise security
    in many ways. For example, a pipeline could be modified to expose the container
    registry or cluster credentials mentioned previously. Another example is the pipeline
    could become hijacked such that it deploys malicious containers into the cluster
    instead of the intended one.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 能够访问CI/CD构建系统的攻击者可以通过多种方式危害安全。例如，可以将管道修改为暴露之前提到的容器注册表或集群凭证。另一个例子是管道可能被劫持，从而将恶意容器部署到集群中，而不是预期的容器。
- en: There are even some scenarios in which a bad actor might compromise security
    by merely using the CI system’s standard functionality. For example, when a pull
    request is made against a code repo, it kicks off a pipeline performing a series
    of steps to validate and test the change. The contents of these steps are typically
    defined in a file contained in the code repo (such as a Jenkins’ Jenkinsfile or
    Circle CI’s .circleci/config.yml). The ability to open new pull requests is often
    open to the world so that anyone can propose contributions to the project. However,
    an attacker could simply open a pull request that modifies the pipeline to do
    something malicious. For this reason, many CI systems incorporate features to
    prevent pipelines from being executed when an untrusted source makes the PR.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至在某些情况下，恶意行为者可能仅通过使用CI系统的标准功能就可能会危害安全。例如，当对代码仓库发起拉取请求时，它将启动一个执行一系列步骤以验证和测试更改的管道。这些步骤的内容通常定义在代码仓库中的一个文件中（例如Jenkins的Jenkinsfile或Circle
    CI的.circleci/config.yml）。打开新拉取请求的能力通常对公众开放，以便任何人都可以提出对项目的贡献。然而，攻击者可以简单地发起一个修改管道以执行恶意操作的拉取请求。因此，许多CI系统集成了防止在不受信任的来源发起PR时执行管道的功能。
- en: Container registry
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 容器注册表
- en: A container registry houses the container images that will be deployed in the
    cluster. Because the container images in the registry have the potential of running
    in clusters, the contents of the registry need to be trusted, as well as the users
    who can push to that registry. Because anyone can publish images to public registries
    such as DockerHub, Quay.io, and grc.io, it is a standard security measure in enterprises
    to block pulling images from these untrusted container registries entirely. Instead,
    all images would be pulled from an internal, trusted registry, which could be
    periodically scanned for vulnerabilities in the repositories.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 容器注册表存储了将在集群中部署的容器镜像。由于注册表中的容器镜像有可能在集群中运行，因此注册表的内容以及可以向该注册表推送的用户都需要受到信任。由于任何人都可以向公共注册表（如DockerHub、Quay.io和grc.io）发布镜像，因此企业中阻止从这些不受信任的容器注册表拉取镜像是一项标准的安全措施。相反，所有镜像都将从内部、受信任的注册表拉取，该注册表可以定期扫描存储库中的漏洞。
- en: An attacker with privileges to the trusted container registry could push images
    to the registry and overwrite existing, previously trusted images. For example,
    say your cluster is already running some image mycompany/guestbook:v1.0\. An attacker
    with access to the registry could push a new image and overwrite the existing
    guestbook:v1.0 tag, changing the meaning of that image to something malicious.
    Then, the next time the container starts (perhaps due to Pod rescheduling), it
    would run a compromised version of the image.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有对受信任容器注册表权限的攻击者可以向注册表推送镜像并覆盖现有的、之前受信任的镜像。例如，假设您的集群已经运行了某个镜像mycompany/guestbook:v1.0。如果攻击者能够访问注册表，他们可以推送一个新的镜像并覆盖现有的guestbook:v1.0标签，改变该镜像的含义为恶意内容。然后，下一次容器启动（可能是由于Pod重新调度）时，它将运行受损害的镜像版本。
- en: This attack might go undetected since, from the perspective of Kubernetes and
    the GitOps system, everything is as expected; the live manifests match the configuration
    manifests in Git. To combat this issue, image tags (or image versions) can be
    designated as immutable in some registries so that once written, the meaning of
    that image tag can never change.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这种攻击可能不会被检测到，因为从 Kubernetes 和 GitOps 系统的角度来看，一切如预期；实时清单与 Git 中的配置清单相匹配。为了应对这个问题，可以在某些仓库中将镜像标签（或镜像版本）指定为不可变的，这样一旦写入，该镜像标签的含义就永远不会改变。
- en: Immutable image tags Some image registries (such as DockerHub) provide a feature
    that makes image tags immutable. This means that once an image tag already exists,
    no one can overwrite it, essentially preventing image tags from being reused.
    The use of this feature adds additional security by preventing existing deployed
    image tags from being modified.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变镜像标签 一些镜像仓库（如 DockerHub）提供了一种使镜像标签不可变的功能。这意味着一旦镜像标签已经存在，就无法覆盖它，从而本质上防止了镜像标签被重复使用。使用此功能通过防止现有已部署的镜像标签被修改来增加额外的安全性。
- en: Git repository
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Git 仓库
- en: The Git repository, in the context of GitOps, defines *what* resources will
    be installed into the cluster. The Kubernetes manifests, which are stored in the
    Git repo, are the ones that ultimately end up in the cluster. Therefore, anyone
    who can access the Git repository should be trusted in deciding the cluster’s
    makeup, including things like Deployments, container images, Roles, RoleBindings,
    Ingresses, and NetworkPolicies.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitOps 的背景下，Git 仓库定义了将安装到集群中的资源**是什么**。存储在 Git 仓库中的 Kubernetes 清单最终将出现在集群中。因此，任何可以访问
    Git 仓库的人都应该被信任来决定集群的构成，包括像部署（Deployments）、容器镜像、角色（Roles）、角色绑定（RoleBindings）、入口（Ingresses）和网络策略（NetworkPolicies）等。
- en: In the worst case, an attacker with full access to the Git repository could
    push a new commit to the Git repo, updating a Deployment to run a malicious container
    in the cluster. They might also add a Role and RoleBinding that could grant the
    Deployment enough privileges to read Secrets and exfiltrate sensitive information.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在最坏的情况下，一个拥有对 Git 仓库完全访问权限的攻击者可以向 Git 仓库推送一个新的提交，更新部署以在集群中运行恶意容器。他们还可能添加一个角色和角色绑定，这可能会赋予部署足够的权限来读取机密信息并泄露敏感数据。
- en: The good news is that since an attacker would need to push commits to the repository,
    the malicious actions performed would be done in plain sight and could be audited
    and traced. However, commit and pull request access to the Git repository should
    be restricted to a limited set of people who would effectively have full cluster
    administration access.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，由于攻击者需要向仓库推送提交，恶意行为将公然进行，并且可以被审计和追踪。然而，对 Git 仓库的提交和拉取请求访问应该仅限于一小部分人，这些人将有效拥有完整的集群管理权限。
- en: Kubernetes cluster
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 集群
- en: Securing a Kubernetes cluster is deserving of a book unto itself, so we will
    only aim to cover the topics most relevant to GitOps. As you are aware, the Kubernetes
    cluster is the infrastructure platform that runs your application code. An attacker
    who has gained access to the cluster is arguably the worst-case scenario. For
    this reason, Kubernetes clusters are extremely high-value targets for attackers,
    and the security of the cluster is paramount.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 保护 Kubernetes 集群本身就是一个值得单独成书的话题，因此我们只旨在涵盖与 GitOps 最相关的主题。如您所知，Kubernetes 集群是运行您的应用程序代码的基础设施平台。一个已经获得集群访问权限的攻击者可以说是最坏的情况。因此，Kubernetes
    集群对于攻击者来说是一个极具价值的目标，集群的安全性至关重要。
- en: GitOps enables a whole new set of options for how you might decide to grant
    users access to the cluster. This will be covered in depth later in the chapter
    but, at a high level, GitOps gives operators a new way of providing access to
    the cluster (such as through Git), as opposed to the traditional method of giving
    users direct access to the cluster (such as with a personalized kubeconfig file).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps 为您提供了全新的选择，以决定如何授予用户对集群的访问权限。这一点将在本章的后续部分进行深入探讨，但就目前而言，GitOps 为操作员提供了一种新的方式来提供对集群的访问（例如通过
    Git），这与传统的直接授予用户对集群访问的方法（例如使用个性化的 kubeconfig 文件）形成对比。
- en: Traditionally, before GitOps, developers would generally require direct access
    to the Kubernetes cluster to manage and make changes to their environment. But
    with GitOps, direct access to the cluster is no longer strictly required since
    environment management can go through a new medium, Git. And suppose all developer
    access to the cluster can be via Git. In that case, it also means that operators
    can decide to close traditional, direct access to the cluster completely (or at
    least write access) and enforce all changes to go through Git.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，在 GitOps 之前，开发者通常需要直接访问 Kubernetes 集群来管理和更改他们的环境。但有了 GitOps，对集群的直接访问就不再是严格必要的，因为环境管理可以通过一个新的媒介，Git
    来进行。假设所有开发者对集群的访问都可以通过 Git 进行。在这种情况下，这也意味着运营商可以选择完全关闭对集群的传统直接访问（或者至少是写访问），并强制所有更改都通过
    Git 进行。
- en: Cloud provider or data center
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 云提供商或数据中心
- en: Perhaps out of scope in the context of GitOps, but nonetheless important to
    the discussion of security, is the actual underlying cloud provider (such as AWS)
    or physical data center in which Kubernetes clusters are running. Commonly, an
    application that runs in Kubernetes will depend on some number of managed resources
    or services in the cloud for things like databases, DNSs, object storage (such
    as S3), message queues, and many others. Because both developers and applications
    need access to these resources, an operator needs to consider how creation and
    access to these cloud provider resources may be granted to users.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在 GitOps 的背景下可能不在考虑范围内，但这对安全性的讨论仍然很重要，即 Kubernetes 集群运行的底层云提供商（如 AWS）或物理数据中心。通常，在
    Kubernetes 中运行的应用程序将依赖于云中的一些管理资源或服务，例如数据库、DNS、对象存储（如 S3）、消息队列等。由于开发者和应用程序都需要访问这些资源，运营商需要考虑如何授予用户创建和访问这些云提供商资源的权限。
- en: A developer will likely require access to their database to perform things like
    database schema migrations or generating reports. While GitOps in itself does
    not provide a solution for securing the database per se, GitOps does come into
    play when database configuration invariably starts creeping into the Kubernetes
    manifests (which *are* managed via GitOps). For example, one mechanism an operator
    might employ to help secure access to a database is IP whitelisting in a Kubernetes
    NetworkPolicy. And since NetworkPolicy is a standard Kubernetes resource that
    can be managed via Git, the *contents* (IP whitelist) of the NetworkPolicy become
    significant to operators as a security concern.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可能需要访问他们的数据库以执行诸如数据库模式迁移或生成报告之类的操作。虽然 GitOps 本身并不提供针对数据库本身的安全解决方案，但当数据库配置不可避免地开始出现在
    Kubernetes 清单中（这些清单是通过 GitOps 管理的）时，GitOps 就会发挥作用。例如，运营商可能采用的一种帮助确保数据库访问安全的机制是在
    Kubernetes NetworkPolicy 中的 IP 白名单。由于 NetworkPolicy 是可以通过 Git 管理的标准 Kubernetes
    资源，因此 NetworkPolicy 的 *内容*（IP 白名单）对运营商来说作为一个安全问题变得很重要。
- en: A second consideration is that Kubernetes resources can have a profound impact
    on cloud provider resources. For example, a user who is allowed to create ordinary
    Kubernetes Service objects could cause many costly load balancers to be created
    in the cloud provider and unintentionally expose services to the outside world.
    For these reasons, it’s imperative that cluster operators have a deep understanding
    of the relationship between Kubernetes resources and cloud provider resources
    and the consequences of allowing users to manage these resources on their own.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个考虑因素是 Kubernetes 资源可以对云提供商资源产生深远的影响。例如，一个被允许创建普通 Kubernetes 服务对象的用户可能会在云提供商中创建许多昂贵的负载均衡器，并无意中向外界暴露服务。因此，集群运营商对
    Kubernetes 资源与云提供商资源之间的关系以及允许用户自行管理这些资源的后果有深入理解至关重要。
- en: GitOps operator
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps 运营商
- en: Depending on your choice of a GitOps operator, securing the operator may or
    may not be an option. An elementary GitOps operator, such as our poor-man’s CronJob-based
    GitOps operator example from chapter 2, has no other security implications since
    it is not a service that can be exposed externally, nor does it have any form
    of management aspect to it. On the other hand, a tool such as Argo CD, Helm, or
    Jenkins X is intended to be exposed to end users. As a result, it has additional
    security considerations since it could be a vector of attack.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你选择的GitOps操作员，保护操作员可能是一个选项，也可能不是。一个基本的GitOps操作员，例如我们在第2章中的穷人版基于CronJob的GitOps操作员示例，由于它不是一个可以公开暴露的服务，也没有任何管理方面，因此没有其他安全影响。另一方面，像Argo
    CD、Helm或Jenkins X这样的工具旨在向最终用户公开。因此，它有额外的安全考虑，因为它可能成为攻击的途径。
- en: 6.1.3 Access control in GitOps
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.3 GitOps中的访问控制
- en: 'First of all, let’s figure out the access control subjects and objects in the
    continuous delivery (CD) security model. As we’ve learned already, the objects
    are resources that have to be protected. The CD surface attack is large, but the
    idea of immutable infrastructure and Kubernetes narrow it to just two things:
    Kubernetes configuration and deployment artifacts.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们确定在持续交付（CD）安全模型中的访问控制主体和对象。正如我们已经学到的，对象是需要保护的资源。CD表面攻击很大，但不可变基础设施和Kubernetes将其缩小到只有两件事：Kubernetes配置和部署工件。
- en: As you already know, the Kubernetes configuration is represented by a collection
    of Kubernetes resources. The resource manifests are stored in Git and automatically
    applied to the target Kubernetes cluster. The deployment artifacts are container
    images. Having these two, you can shape your production in any way and even re-create
    it from scratch at any time.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知道的那样，Kubernetes配置由一组Kubernetes资源表示。资源清单存储在Git中，并自动应用到目标Kubernetes集群。部署工件是容器镜像。有了这两者，你可以以任何方式塑造你的生产环境，甚至可以在任何时候从头开始重新创建它。
- en: The access control subjects, in this case, are engineers and automated processes,
    such as a CI pipeline. The engineers are leveraging automation to continuously
    produce new container images and update Kubernetes configuration to deploy them.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，访问控制主体是工程师和自动化流程，例如CI管道。工程师正在利用自动化来持续产生新的容器镜像，并更新Kubernetes配置以部署它们。
- en: Unless you are using GitOps, the Kubernetes configuration is either updated
    manually or scripted in continuous integration. This approach, sometimes called
    CIOps,^([1](#pgfId-1076861)) usually makes the security team nervous.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你使用GitOps，否则Kubernetes配置要么是手动更新，要么在持续集成中脚本化。这种方法，有时被称为CIOps^([1](#pgfId-1076861))，通常会让安全团队感到紧张。
- en: '![](Images/CH06_F02_Yuen.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH06_F02_Yuen.png)'
- en: Figure 6.2 The CIOps security model is not safe since it provides cluster access
    to both engineers and CI systems. The problem here is that the CI system gets
    control over the cluster and is allowed to make arbitrary Kubernetes configuration
    changes. That significantly expands the attack surface and makes it difficult
    to secure your cluster.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 CIOps安全模型不安全，因为它允许工程师和CI系统访问集群。这里的问题是CI系统获得了对集群的控制权，并被允许进行任意的Kubernetes配置更改。这大大增加了攻击面，使得保护集群变得困难。
- en: So how does GitOps improve the situation? GitOps unifies the process of applying
    changes from the Git repo to the cluster. That allows keeping access tokens closer
    to the cluster and effectively moves the burden of securing access to the cluster
    to the Git repository.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 那么GitOps是如何改善这种情况的呢？GitOps统一了从Git仓库应用到集群的更改过程。这允许将访问令牌更靠近集群，并将保护集群访问的负担有效地转移到Git仓库。
- en: '![](Images/CH06_F03_Yuen.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH06_F03_Yuen.png)'
- en: Figure 6.3 The GitOps security model limits cluster access to the GitOps operator
    only. The attack surface is greatly reduced, and protecting the cluster is much
    simpler.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 GitOps安全模型仅限制集群访问GitOps操作员。攻击面大大减少，保护集群变得更加简单。
- en: Protecting configuration in the Git repository still requires an effort. The
    great thing about it is that we can use the same tools that are used to protect
    the application source code. Git hosting providers such as GitHub and GitLab allow
    us to define and enforce the change process like mandatory reviews or static analysis
    for every change. Since the GitOps operator is the only subject with cluster access,
    it is much easier to define what can and cannot be deployed into the cluster by
    the engineering team and significantly improves cluster security.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Git 仓库中保护配置仍然需要付出努力。它的好处是我们可以使用与保护应用程序源代码相同的工具。Git 托管提供商，如 GitHub 和 GitLab，允许我们为每个更改定义和执行变更过程，如强制审查或静态分析。由于
    GitOps 操作者是唯一具有集群访问权限的主题，因此定义工程团队能够部署到集群中的内容以及不能部署的内容变得更加容易，从而显著提高了集群的安全性。
- en: Let’s go ahead and learn what it takes to protect Kubernetes configs in the
    Git repository and how to fine-tune Kubernetes access control.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续学习如何在 Git 仓库中保护 Kubernetes 配置以及如何微调 Kubernetes 访问控制。
- en: 6.2 Access limitations
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 访问限制
- en: As discussed at the beginning of the chapter, there are many components involved
    in securing the cluster, including the CI/CD build system, the container registry,
    and the actual Kubernetes cluster. Each component implements specific access control
    mechanisms to allow or deny access.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章开头所述，涉及保护集群的组件有很多，包括 CI/CD 构建系统、容器注册库以及实际的 Kubernetes 集群。每个组件都实现了特定的访问控制机制，以允许或拒绝访问。
- en: 6.2.1 Git repository access
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.1 Git 仓库访问
- en: Git is a completely developer-oriented tool. By default, it is configured to
    make it extremely easy to change anything at any time. This simplicity is what
    made Git so popular in the developer community.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Git 是一个完全面向开发者的工具。默认情况下，它被配置得非常容易在任何时候更改任何内容。这种简单性是 Git 在开发者社区中如此受欢迎的原因。
- en: 'However, Git is built on top of a solid cryptographic foundation: it uses Merkle
    trees as a fundamental underlying data structure. The same data structure is used
    as a foundation for a blockchain.^([2](#pgfId-1076892)) As a result, Git can be
    used as a distributed ledger, making it a great audit log storage.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Git 是建立在坚实的加密基础之上的：它使用 Merkle 树作为基本的数据结构。相同的结构被用作区块链的基础.^([2](#pgfId-1076892))
    因此，Git 可以用作分布式账本，使其成为出色的审计日志存储。
- en: Merkle tree A *Merkle tree* is a tree in which every leaf node is labeled with
    the hash of a data block, and every nonleaf node is labeled with the cryptographic
    hash of the labels of its child nodes.^([3](#pgfId-1076896))
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Merkle 树 *Merkle 树* 是一种树，其中每个叶子节点都标记有数据块的哈希值，每个非叶子节点都标记有其子节点标签的加密哈希值.^([3](#pgfId-1076896))
- en: Here is a brief overview of how Git works. Every time the developer wants to
    save a set of changes, Git calculates an introduced diff and creates a bundle
    that includes introduced changes, various metadata fields, such as the date and
    author, as well as a reference to the parent bundle that represents the previous
    repository state. Finally, the bundle is hashed and stored in a repository. That
    bundle is called a commit. That algorithm used is pretty much the same algorithm
    that is used in a blockchain.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Git 的工作原理的简要概述。每次开发者想要保存一组更改时，Git 都会计算引入的差异并创建一个包含引入的更改、各种元数据字段（如日期和作者）以及指向表示先前仓库状态的父捆绑包的引用的捆绑包。最后，该捆绑包被哈希处理并存储在仓库中。这个捆绑包被称为提交。该算法基本上与在区块链中使用的算法相同。
- en: '![](Images/CH06_F04_Yuen.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH06_F04_Yuen.png)'
- en: Figure 6.4 Each Git commit references the previous commit and forms a treelike
    data structure. All modifications are fully tracked in the Git repository.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 每个 Git 提交都引用前一个提交并形成一个类似树的数据结构。所有修改都在 Git 仓库中得到完全跟踪。
- en: The hash is used as a guarantee that the code used is the same code that was
    committed, and it has not been tampered with. So the Git repository is a chain
    of commits that is cryptographically protected from hidden modifications. It is
    safe to trust the Git implementation thanks to cryptographic algorithms behind
    it, so we can use it as the audit log.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希用作保证所使用的代码与提交的代码相同，并且没有被篡改。因此，Git 仓库是一个由密码学保护的提交链，可以防止隐藏的修改。由于背后有密码学算法的支持，我们可以安全地信任
    Git 实现，因此我们可以将其用作审计日志。
- en: Create deployment repository
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 创建部署仓库
- en: Let’s create a sample deployment repository and then see what it takes to make
    it ready to drive GitOps deployment. For your convenience, let’s use the existing
    deployment repository available at [https://github.com/gitopsbook/sample-app-deployment](https://github.com/gitopsbook/sample-app-deployment).
    The repository contains the deployment manifests of a Kubernetes Service and a
    Deployment resource. The Deployment resource manifest is available in the following
    listing.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个示例部署仓库，然后看看使其准备好进行GitOps部署需要什么。为了您的方便，让我们使用在[https://github.com/gitopsbook/sample-app-deployment](https://github.com/gitopsbook/sample-app-deployment)可用的现有部署仓库。该仓库包含Kubernetes服务和一个部署资源的部署清单。部署资源的清单如下所示。
- en: Listing 6.1 Sample app deployment [(http://mng.bz/ao1z)](https://shortener.manning.com/ao1z)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.1 示例应用部署 [(http://mng.bz/ao1z)](https://shortener.manning.com/ao1z)
- en: '[PRE0]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As has been mentioned, Git is a distributed version control system. That means
    every developer has a full local repository copy with full access to make changes.
    However, there is also a common repository that all team members use to exchange
    their changes. That common remote repository is hosted by a Git hosting service
    like GitHub or GitLab. Hosting services provide a set of security features that
    allow protecting the repository from unwanted modifications, enforcing commit
    author identity, preventing history override, and much more.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前提到的，Git是一个分布式版本控制系统。这意味着每个开发者都有一个完整的本地仓库副本，可以完全访问以进行更改。然而，还有一个所有团队成员都用来交换更改的公共仓库。这个公共远程仓库由GitHub或GitLab等Git托管服务托管。托管服务提供一系列安全功能，允许保护仓库免受未授权修改，强制提交作者身份，防止历史覆盖，等等。
- en: 'As a first step, navigate to the gitopsbook/sample-app-deployment repo and
    create a fork^([4](#pgfId-1076945)) in your GitHub account:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，导航到gitopsbook/sample-app-deployment仓库，并在您的GitHub账户中创建一个分支^([4](#pgfId-1076945))：
- en: '[PRE1]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once the fork is created, use the following command to clone the repository
    locally and get ready to make changes:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了分支，使用以下命令在本地克隆仓库并准备进行更改：
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Although the repository is public, that does not mean that everyone with a GitHub
    account can make a change without proper permission. GitHub ensures that a user
    is either a repository owner or invited as a collaborator.^([5](#pgfId-1076961))
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管仓库是公开的，但这并不意味着拥有GitHub账户的每个人都可以在没有适当权限的情况下进行更改。GitHub确保用户要么是仓库所有者，要么被邀请为协作者.^([5](#pgfId-1076961))
- en: Exercise 6.2
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 练习6.2
- en: 'Clone the repository using the HTTPS URL and try to push any changes without
    providing your GitHub username and password:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HTTPS URL克隆仓库，并尝试推送任何更改，而不提供您的GitHub用户名和密码：
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Instead of creating a personal repository, you might create an organization^([6](#pgfId-1076970))
    and manage access using teams. That set of access management features is very
    comprehensive and covers most use cases, starting from the single developer to
    the large organization. However, this is not enough.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是创建个人仓库，您可能创建一个组织^([6](#pgfId-1076970))并使用团队来管理访问权限。这一套访问管理功能非常全面，涵盖了从单个开发者到大型组织的大部分用例。然而，这还不够。
- en: Exercise 6.3
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 练习6.3
- en: Create a second GitHub user and invite that user as a collaborator. Trying pushing
    any changes using the second GitHub user’s credentials.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 创建第二个GitHub用户，并将该用户邀请为协作者。尝试使用第二个GitHub用户的凭据推送任何更改。
- en: Enforcing a code review process
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 执行代码审查流程
- en: 'Neither the cryptographic protection nor authorization setting can protect
    from vulnerabilities introduced intentionally by a malicious developer or simply
    by mistake through poor coding practices. Whether the vulnerabilities in application
    source code are introduced intentionally or not, the recommended solution is the
    same: all changes in the deployment repository must go through a code review process
    that is enforced by the Git hosting provider.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是通过加密保护还是授权设置都无法防止恶意开发者有意引入或由于糟糕的编码实践不小心引入的漏洞。无论应用程序源代码中的漏洞是有意引入的还是不是，推荐的解决方案是相同的：部署仓库中的所有更改都必须通过Git托管提供商强制执行的代码审查流程。
- en: 'Let’s make sure that every change to the master branch of the sample-app-deployment
    repository goes through the code review process and is approved by at least one
    reviewer. The steps to enable a mandatory review process are described at [http://mng.bz/OExn](http://mng.bz/OExn):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保对sample-app-deployment仓库主分支的任何更改都经过代码审查流程，并且至少由一位审查员批准。启用强制审查流程的步骤在[http://mng.bz/OExn](http://mng.bz/OExn)中描述：
- en: Navigate to the Branches section in the repository settings.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在存储库设置中导航到“分支”部分。
- en: Click the Add Rule button.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“添加规则”按钮。
- en: Enter the required branch name.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入所需的分支名称。
- en: Enable the Require Pull Request Reviews Before Merging and Include Administrators
    settings.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用“合并前要求拉取请求审查”和“包括管理员”设置。
- en: 'Next, let’s try to make a config change and push it to the master:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试进行配置更改并将其推送到主分支：
- en: '[PRE4]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `git` `push` fails because the branch is protected and will require a pull
    request and a review. This guarantees that at least one additional person is going
    to review the change and sign off on the deployment.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于分支受到保护，需要拉取请求和审查，`git` `push` 失败。这保证了至少有一个人将审查更改并签署部署。
- en: 'Don’t forget to run cleanup before moving to the next paragraph. Delete the
    rule that protects the master branch in GitHub and run the following command to
    reset local changes:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动到下一段之前，不要忘记运行清理。删除保护主分支的规则，并运行以下命令以重置本地更改：
- en: '[PRE5]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Exercise 6.4
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 6.4
- en: Explore additional settings under the Require Pull Request Reviews Before Merging
    section. Think which settings combination is suitable for your project or organization.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在“合并前要求拉取请求审查”部分探索额外的设置。考虑哪种设置组合适合您的项目或组织。
- en: Enforce automated checks
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 强制执行自动化检查
- en: In addition to human judgment, pull requests allow us to incorporate an automated
    manifest analysis that can help to catch security issues very early. Although
    the ecosystem of Kubernetes security tools is still emerging, there are already
    several options available. Two good examples are kubeaudit^([7](#pgfId-1077015))
    and kubesec.^([8](#pgfId-1077019)) Both tools are available under the Apache license
    and allow scanning Kubernetes manifests to find weak security parameters.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 除了人工判断外，拉取请求还允许我们结合自动化清单分析，这有助于在早期捕捉到安全问题。尽管 Kubernetes 安全工具生态系统仍在发展，但已经有几个选项可用。两个很好的例子是
    kubeaudit^([7](#pgfId-1077015)) 和 kubesec.^([8](#pgfId-1077019))。这两个工具都受 Apache
    许可证保护，并允许扫描 Kubernetes 清单以查找弱安全参数。
- en: 'Because our repository is open source and hosted by GitHub, we can use a CI
    service such as [https://travis-ci.org](https://travis-ci.org/) or [https://circleci.com](https://circleci.com/)
    for free! Let’s configure an automated kubeaudit usage and enforce successful
    verification for every pull request using [https://travis-ci.org](https://travis-ci.org/):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的存储库是开源的，并由 GitHub 托管，我们可以免费使用 CI 服务，例如 [https://travis-ci.org](https://travis-ci.org/)
    或 [https://circleci.com](https://circleci.com/)！让我们配置自动 kubeaudit 使用，并使用 [https://travis-ci.org](https://travis-ci.org/)
    对每个拉取请求进行成功验证：
- en: '[PRE6]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Listing 6.2 .travis.yml
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.2 .travis.yml
- en: '[PRE7]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once the configuration is ready we just need to enable CI integration at [http://mng.bz/Gxyq](http://mng.bz/Gxyq)
    and create a pull request:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置就绪，我们只需在 [http://mng.bz/Gxyq](http://mng.bz/Gxyq) 上启用 CI 集成并创建拉取请求：
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The CI should be triggered as soon as the PR is created and fails with the
    following error message:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: CI 应在创建 PR 后立即触发，并出现以下错误消息：
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![](Images/CH06_F05_Yuen.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH06_F05_Yuen.png)'
- en: Figure 6.5 Travis runs the CI job that validates deployment manifests. The validation
    fails due to detected vulnerabilities.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 Travis 运行验证部署清单的 CI 作业。验证失败，因为检测到漏洞。
- en: The kubeaudit detected that the Pod security context is missing the `runAsNonRoot`
    property that prevents running a container with root user as part of the Pod.
    This is a valid security concern. To fix the security issue, change the Pod manifest
    as represented in the following code listing.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: kubeaudit 检测到 Pod 安全上下文缺少防止以 root 用户身份运行容器的 `runAsNonRoot` 属性。这是一个有效的安全问题。为了修复安全问题，请按以下代码列表更改
    Pod 清单。
- en: Listing 6.3 Sample app deployment [(http://mng.bz/zxXa)](https://shortener.manning.com/zxXa)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.3 示例应用部署 [(http://mng.bz/zxXa)](https://shortener.manning.com/zxXa)
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Commit changes and update the pull request by pushing the `change1` branch:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 提交更改并通过推送 `change1` 分支更新拉取请求：
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The pull request should pass verification!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 拉取请求应通过验证！
- en: Exercise 6.5
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 6.5
- en: Learn which additional audits are provided by the kubeaudit application. Try
    using the `kubeaudit` `autofix` `-f` `deployment.yaml` command.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 了解 kubeaudit 应用程序提供的附加审计。尝试使用 `kubeaudit` `autofix` `-f` `deployment.yaml` 命令。
- en: Protecting commit author identity
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 保护提交作者身份
- en: At this point, our repository is securely hosted on GitHub. We control which
    GitHub accounts can make changes in the repository, enforce the code review process
    for every change, and even run static analysis for every pull request. This is
    great but still not enough. As often happens, a social engineering attack can
    bypass all these security gates.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的仓库安全托管在GitHub上。我们控制哪些GitHub账户可以在仓库中做出更改，对每个更改执行代码审查流程，甚至对每个拉取请求运行静态分析。这很好，但仍不够。正如经常发生的那样，社会工程攻击可以绕过所有这些安全关卡。
- en: What would you do if your boss sent you a pull request and asked you to merge
    it immediately? Under pressure, an engineer might decide to take a quick look
    at the pull request and approve it without careful testing. Since our repository
    is hosted on GitHub, we know which user authored the commit. It is impossible
    to make a commit on behalf of someone else, right?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的老板给你发送了一个拉取请求并要求你立即合并，你会怎么做？在压力之下，一个工程师可能会决定快速查看拉取请求并未经仔细测试就批准它。由于我们的仓库托管在GitHub上，我们知道哪个用户创建了提交。不可能代表别人进行提交，对吧？
- en: Unfortunately, this is not true. Git was not designed with strong identity guarantees.
    As we mentioned before, Git is a completely developer-oriented tool. Every bit
    of a commit is under the engineers’ control, including information about the commit
    author. So an intruder can easily create a commit and put your boss’s name into
    the commit metadata. Let’s do a simple exercise to demonstrate this vulnerability.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，事实并非如此。Git并非设计为具有强身份保证的工具。正如我们之前提到的，Git是一个完全面向开发者的工具。提交的每一部分都在工程师的控制之下，包括提交作者的信息。因此，入侵者可以轻松创建一个提交并将你老板的名字放入提交元数据中。让我们做一个简单的练习来展示这个漏洞。
- en: 'Open a console, and create a new commit on the master branch using this command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 打开控制台，使用以下命令在master分支上创建一个新的提交：
- en: '[PRE12]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Open the commit history of your repository on GitHub, and check the most recent
    commit information. Look, Joe Beda^([9](#pgfId-1077126)) just updated our Pod
    manifest!
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 打开GitHub上你仓库的提交历史，并检查最新的提交信息。看，Joe Beda^([9](#pgfId-1077126))刚刚更新了我们的Pod清单！
- en: '![](Images/CH06_F06_Yuen.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH06_F06_Yuen.png)'
- en: Figure 6.6 GitHub commit history contains the Joe Beda avatar. By default, GitHub
    does not execute any validation and uses author information stored in the commit
    metadata.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 GitHub提交历史包含Joe Beda的头像。默认情况下，GitHub不会执行任何验证，并使用存储在提交元数据中的作者信息。
- en: That looks pretty scary, but it does not mean that going forward, you need to
    personally verify the identity of every pull request author before approving it.
    Instead of manually verifying who is the commit’s author, you might leverage a
    digital crypto signature.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来相当吓人，但这并不意味着在以后，你需要在批准之前亲自验证每个拉取请求作者的姓名。与其手动验证提交的作者是谁，你可能会利用数字加密签名。
- en: The cryptographic tools like GPG allow you to inject a crypto signature into
    the commit metadata. Later, this signature might be verified by the Git hosting
    service or GitOps operator. It would take too much time to learn exactly how a
    GPG signature works, but we definitely can use it to protect our deployment repo.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 加密工具如GPG允许你在提交元数据中注入加密签名。稍后，这个签名可能会被Git托管服务或GitOps操作员验证。学习GPG签名的工作原理可能需要太多时间，但我们确实可以使用它来保护我们的部署仓库。
- en: Unfortunately, the GPG configuration process might be difficult. It includes
    multiple steps that might vary depending on your operating system. Refer to the
    steps described in appendix C and the GitHub online documentation^([10](#pgfId-1077139))
    to configure the GPG key.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，GPG配置过程可能很困难。它包括多个步骤，这些步骤可能因操作系统而异。请参考附录C中描述的步骤和GitHub在线文档^([10](#pgfId-1077139))来配置GPG密钥。
- en: 'Finally, we are ready to make a commit and sign it. The following command creates
    a new change to the deployment manifest and signs it with the GPG key associated
    with your GitHub account:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们准备好提交并签名。以下命令创建了一个新的更改到部署清单，并使用与你的GitHub账户关联的GPG密钥进行签名：
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now the GitHub commit history includes information about the author that is
    based on a GPG key and cannot be faked.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，GitHub的提交历史包括基于GPG密钥的作者信息，这些信息无法伪造。
- en: GitHub allows you to require that all commits to a particular repository be
    signed. The Require Signed Commits setting is available under the Protected Branches
    section of the repository settings.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub允许你要求对特定仓库的所有提交都必须进行签名。要求签名的提交设置可以在仓库设置的受保护分支部分找到。
- en: '![](Images/CH06_F07_Yuen.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH06_F07_Yuen.png)'
- en: Figure 6.7 Signing Git cryptographically protects author identity. The GitHub
    user interface visualizes GPG verification results.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 使用密码学签名Git可以保护作者身份。GitHub用户界面可视化了GPG验证结果。
- en: In addition to Git hosting service confirmation, you might configure your GitOps
    operator to verify GPG signatures automatically before updating the Kubernetes
    cluster configuration. Fortunately, some GitOps operators have built-in signature
    verification support and don’t require complex configuration. This topic will
    be covered in the following chapters.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Git托管服务确认之外，您可能还需要配置您的GitOps操作员在更新Kubernetes集群配置之前自动验证GPG签名。幸运的是，一些GitOps操作员已经内置了签名验证支持，无需复杂的配置。这一主题将在接下来的章节中介绍。
- en: 6.2.2 Kubernetes RBAC
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.2 Kubernetes RBAC
- en: As you already know, GitOps methodology assumes that a CI pipeline has no access
    to the Kubernetes cluster. The only automation tool with direct cluster access
    is the GitOps operator that lives inside the cluster. This is already a great
    advantage over the traditional DevOps model. However, that does not mean that
    GitOps should have god-level access. We still need to think carefully about which
    permissions level the operator should get. The operator inside of a cluster, the
    so-called pull model, is not the only possibility either. You might consider placing
    the GitOps operator inside of the protected perimeter and reduce management overhead
    by using a push model and managing multiple clusters using one operator. Each
    such consideration has some pros and cons. To make a meaningful decision, you
    need to have a good understanding of the Kubernetes access model. So let’s step
    back and learn which security tools are built into Kubernetes and how we can use
    them.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，GitOps方法假设CI管道没有访问Kubernetes集群的权限。唯一具有直接集群访问权限的自动化工具是位于集群内部的GitOps操作员。这已经比传统的DevOps模型具有很大的优势。然而，这并不意味着GitOps应该拥有神级访问权限。我们仍然需要仔细考虑操作员应该获得哪种权限级别。集群内部的操作员，所谓的拉取模型，并不是唯一的选择。您可以考虑将GitOps操作员放置在受保护的安全区域内，并通过使用推送模型和管理多个集群使用一个操作员来减少管理开销。每种考虑都有其优缺点。为了做出有意义的决策，您需要对Kubernetes访问模型有良好的理解。因此，让我们回顾一下，了解Kubernetes内置了哪些安全工具，以及我们如何使用它们。
- en: Access control types
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 访问控制类型
- en: 'There are four well-known access control flavors:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种著名的访问控制类型：
- en: '*Discretionary access control* (DAC)—With DAC models, the data owner decides
    on access. DAC is a means of assigning access rights based on rules that users
    specify.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于任意访问控制*（DAC）——在DAC模型中，数据所有者决定访问权限。DAC是一种基于用户指定的规则分配访问权限的手段。'
- en: '*Mandatory access control* (MAC)—MAC was developed using a nondiscretionary
    model, in which people are granted access based on an information clearance. MAC
    is a policy in which access rights are assigned based on regulations from a central
    authority.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*强制访问控制*（MAC）——MAC是使用非自主模型开发的，其中人们根据信息清分类别授予访问权限。MAC是一种基于中央权威机构规定的法规分配访问权限的政策。'
- en: '*Role-based access control* (RBAC)—RBAC grants access based on a user’s role
    and implements key security principles, such as least privilege and separation
    of privilege. Thus, someone attempting to access information can only access data
    deemed necessary for their role.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于角色的访问控制*（RBAC）——RBAC根据用户的角色授予访问权限，并实现了关键的安全原则，如最小权限和权限分离。因此，试图访问信息的人只能访问他们认为对其角色必要的数据。'
- en: '*Attribute-based access control* (ABAC)—ABAC, also known as policy-based access
    control, defines an access control paradigm whereby access rights are granted
    to users through the use of policies that combine attributes together.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于属性的访问控制*（ABAC）——ABAC，也称为基于策略的访问控制，定义了一种访问控制范式，通过使用结合属性的策略来授予用户访问权限。'
- en: ABAC is very flexible and probably the most powerful model in the list. Because
    of its power, ABAC was initially chosen as the Kubernetes security model. However,
    later on, the community realized that ABAC concepts and the way they were implemented
    in Kubernetes were hard to understand and use. As a result, a new authorization
    mechanism that is based on RBAC was introduced. In 2017 the RBAC-based authorization
    was moved into beta, and ABAC was declared deprecated. Currently, RBAC is the
    preferred authorization mechanism in Kubernetes and recommended to be used for
    every application running on Kubernetes.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ABAC 非常灵活，可能是列表中最强大的模型。由于其强大功能，ABAC 最初被选为 Kubernetes 安全模型。然而，后来社区意识到 ABAC 概念及其在
    Kubernetes 中的实现方式难以理解和使用。因此，引入了一种基于 RBAC 的新授权机制。2017 年，基于 RBAC 的授权被移至测试版，ABAC
    被宣布为过时。目前，RBAC 是 Kubernetes 中首选的授权机制，并建议用于在 Kubernetes 上运行的每个应用程序。
- en: 'The RBAC model includes the following three main elements: subjects, resources,
    and verbs. Subjects represent users or processes that want to access a resource,
    and a verb is an operation that can be executed against a resource.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC 模型包括以下三个主要元素：主体、资源和动词。主体代表想要访问资源的用户或进程，动词是对资源可以执行的操作。
- en: So how are these elements mapped to Kubernetes API objects? The RBAC resources
    are represented by a regular Kubernetes resource such as Pod or Deployment. In
    order to represent verbs, two new sets of specialized resources were introduced
    in Kubernetes. The verbs are represented by Role and RoleBinding resources, and
    subjects are represented by User and ServiceAccount resources.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这些元素是如何映射到 Kubernetes API 对象的？RBAC 资源由一个常规的 Kubernetes 资源表示，例如 Pod 或 Deployment。为了表示动词，Kubernetes
    中引入了两套新的专用资源。动词由 Role 和 RoleBinding 资源表示，而主体由 User 和 ServiceAccount 资源表示。
- en: '![](Images/CH06_F08_Yuen.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH06_F08_Yuen.png)'
- en: Figure 6.8 Kubernetes RoleBinding grants permissions defined in the Role to
    Users and ServiceAccounts. ServiceAccount provides an identity for processes that
    run in a Pod.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 Kubernetes RoleBinding 授予 Role 中定义的权限给 Users 和 ServiceAccounts。ServiceAccount
    为在 Pod 中运行的进程提供身份。
- en: Role and RoleBinding
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Role 和 RoleBinding
- en: The Role resource is meant to connect verbs and Kubernetes resources. A sample
    Role definition is represented in the following code listing.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Role 资源旨在连接动词和 Kubernetes 资源。以下代码示例展示了 Role 的一个示例定义。
- en: Listing 6.4 Sample Role [(http://mng.bz/0mKx)](https://shortener.manning.com/0mKx)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.4 示例 Role [(http://mng.bz/0mKx)](https://shortener.manning.com/0mKx)
- en: '[PRE14]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `verbs` section contains lists of allowed actions. So altogether that Role
    allows listing config maps with the cluster and getting the detailed information
    of every config map. The advantage of a Role is that it is a reusable object and
    can be used for different subjects. For example, you might define the read-only
    Role and assign it to various subjects without duplicating the `resources` and
    `verbs` definitions.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`verbs` 部分包含允许的操作列表。因此，该 Role 允许列出与集群相关的配置映射，并获取每个配置映射的详细信息。Role 的优点是它是一个可重用的对象，并且可以用于不同的主体。例如，你可以定义只读的
    Role 并将其分配给各种主体，而无需重复 `resources` 和 `verbs` 定义。'
- en: It is important to know that Roles are Namespaced resources and provide access
    to the resources defined in the same Namespace.^([11](#pgfId-1077220)) This means
    that a single Role cannot provide access to the resources in multiple Namespaces
    or cluster-level resources. In order to provide cluster-level access, you might
    use an equivalent resource called ClusterRole. The ClusterRole resource has pretty
    much the same set of fields as a Role, with the exception of the Namespace field.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 需要知道的是，Role 是命名空间资源，并提供对同一命名空间中定义的资源访问权限.^([11](#pgfId-1077220)) 这意味着单个 Role
    不能提供对多个命名空间或集群级别资源的访问权限。为了提供集群级别的访问权限，你可能可以使用一个称为 ClusterRole 的等效资源。ClusterRole
    资源具有与 Role 相当多的字段集，除了命名空间字段外。
- en: The RoleBinding enables the Role to be connected with the subjects. A sample
    RoleBinding definition is represented here.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: RoleBinding 使 Role 能够与主体连接。以下是一个 RoleBinding 的示例定义。
- en: Listing 6.5 Sample RoleBinding [(http://mng.bz/KMeK)](https://shortener.manning.com/KMeK)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.5 示例 RoleBinding [(http://mng.bz/KMeK)](https://shortener.manning.com/KMeK)
- en: '[PRE15]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The sample RoleBinding grants a set of permissions defined in the Role named
    `sample-role` to the ServiceAccount named `sample-service-account`. Similarly
    to a Role, a RoleBinding has an equivalent object, ClusterRoleBinding, that allows
    connecting subjects with the ClusterRole.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 示例RoleBinding将名为`sample-role`的Role中定义的一组权限授予名为`sample-service-account`的ServiceAccount。类似于Role，RoleBinding有一个等效的对象，ClusterRoleBinding，它允许将主体与ClusterRole连接起来。
- en: User and ServiceAccount
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 用户和ServiceAccount
- en: Finally, Kubernetes subjects are represented by ServiceAccounts and Users.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Kubernetes主体由ServiceAccounts和Users表示。
- en: Basic GitOps operator RBAC
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的GitOps操作员RBAC
- en: We configured Kubernetes RBAC in chapter 2 while working on the basic GitOps
    operator implementation. Let’s use the knowledge acquired in this chapter to tighten
    the operator permissions and limit what it can deploy.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2章中，我们在实现基本的GitOps操作员时配置了Kubernetes RBAC。让我们利用本章学到的知识来加强操作员权限，并限制其可以部署的内容。
- en: To get started, make sure you’ve completed the basic GitOps operator tutorial.
    As you might remember, we have configured a CronJob along with a ServiceAccount
    and the ClusterRoleBinding resources. Let’s take a look at a ServiceAccount and
    ClusterRoleBinding definitions one more time and find what should be changed to
    improve security.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请确保你已经完成了基本的GitOps操作员教程。你可能还记得，我们配置了一个CronJob，以及ServiceAccount和ClusterRoleBinding资源。让我们再次查看ServiceAccount和ClusterRoleBinding的定义，并找出应该更改什么来提高安全性。
- en: Listing 6.6 rbac.yaml
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.6 rbac.yaml
- en: '[PRE16]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The ClusterRoleBinding defines the link between the ClusterRole with name admin
    and the ServiceAccount that is used by the GitOps operator CronJob. The admin
    ClusterRole exists by default in the cluster and provides god-level access to
    the whole cluster. That means that the GitOps operator has no limitations and
    can deploy any resource as long as it is defined in the Git repository.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ClusterRoleBinding定义了名为admin的ClusterRole与GitOps操作员CronJob所使用的ServiceAccount之间的联系。admin
    ClusterRole在集群中默认存在，并为整个集群提供上帝级别的访问权限。这意味着GitOps操作员没有限制，只要在Git仓库中定义了资源，就可以部署任何资源。
- en: So what is wrong in this RBAC configuration? The problem is that this is secure
    only if we assume that the developer with Git repository write permissions already
    has full cluster access. Since a GitOps operator can create any resource, the
    developer might add manifests of additional roles and role bindings and grant
    himself admin permissions. This is not what we want, especially in a multitenant
    environment.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这个RBAC配置中有什么问题呢？问题是，这只有在假设具有Git仓库写权限的开发者已经拥有完整的集群访问权限的情况下才是安全的。由于GitOps操作员可以创建任何资源，开发者可能会添加额外的角色和角色绑定清单，并授予自己管理员权限。这不是我们想要的，尤其是在多租户环境中。
- en: Another consideration is human mistakes. When a cluster is used by multiple
    teams, we need to ensure that one team cannot touch the resources of another team.
    As you learned in chapter 3, teams are typically separated from each other using
    Kubernetes Namespaces. So it makes sense to limit GitOps operator permissions
    to one Namespace only.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个考虑因素是人为错误。当多个团队使用一个集群时，我们需要确保一个团队不能触及另一个团队的资源。正如你在第3章所学，团队通常通过Kubernetes
    Namespaces相互隔离。因此，将GitOps操作员权限限制在一个Namespace内是有意义的。
- en: Finally, we want to control what Namespace-level resources can be managed by
    a GitOps operator. While it is perfectly fine to let developers manage resources
    like Deployments, ConfigMaps, and Secrets, there are some resources that should
    be managed by the cluster administrator only. A good example of restricted network
    resources is NetworkPolicy. The NetworkPolicy controls what traffic is allowed
    to the Pods within a Namespace and is typically managed by cluster administrators.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望控制GitOps操作员可以管理的Namespace级别资源。虽然让开发者管理像Deployments、ConfigMaps和Secrets这样的资源是完全可以接受的，但有一些资源应该只由集群管理员管理。网络资源的一个很好的例子是NetworkPolicy。NetworkPolicy控制允许进入Namespace内Pods的流量，通常由集群管理员管理。
- en: 'Let’s go ahead and update the RBAC configuration of the operator. We would
    have to make the following changes to ensure secure configuration:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续更新操作员的RBAC配置。我们需要做出以下更改以确保安全配置：
- en: Limit GitOps operator permissions to only one Namespace.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将GitOps操作员权限限制在一个Namespace内。
- en: Remove permissions to install cluster-level resources.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除安装集群级别资源的权限。
- en: Limit operator permissions to selected Namespaced resources.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将操作员权限限制在选定的Namespaced资源中。
- en: The updated RBAC configuration is represented here.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的RBAC配置在此表示。
- en: Listing 6.7 updated-rbac.yaml
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.7 updated-rbac.yaml
- en: '[PRE17]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here is a summary of the applied changes:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是应用变更的总结：
- en: The ClusterRoleBinding was replaced with the RoleBinding to ensure Namespace-level
    access only.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将ClusterRoleBinding替换为RoleBinding以确保只有命名空间级别的访问。
- en: Instead of using a built-in admin role, we are using the custom Namespace `Role`.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不是使用内置的admin角色，而是使用自定义的命名空间`Role`。
- en: The Namespaced role provides access only to specified Kubernetes resources.
    That ensures that the operator cannot modify resources like NetworkPolicy.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间角色只提供对指定Kubernetes资源的访问。这确保了操作员不能修改像NetworkPolicy这样的资源。
- en: 6.2.3 Image registry access
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.3 镜像注册表访问
- en: By securing the Kubernetes cluster, we guarantee that cluster configuration
    describes the correct workloads that reference the correct Docker images and ultimately
    run the software we want. The protected deployment repository and fully automated
    GitOps-driven deployment process provide auditability and observability. The last
    missing piece that is still not protected is the Docker image itself.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通过确保Kubernetes集群的安全，我们保证集群配置描述了正确的负载，这些负载引用了正确的Docker镜像，并最终运行了我们想要的软件。受保护的部署存储库和完全自动化的GitOps驱动部署流程提供了可审计性和可观察性。仍然没有保护的最后一块拼图是Docker镜像本身。
- en: We’ll discuss Docker image protection last, but this is definitely not the least
    important topic. The image content ultimately defines what binary is going to
    be executed inside of a cluster. So even if everything else is secure, a breach
    in Docker registry protection defeats all other security gates.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在最后讨论Docker镜像保护，但这绝对不是最不重要的话题。镜像内容最终定义了在集群内部将要执行的二进制文件。所以即使其他一切都很安全，Docker注册表保护的漏洞会破坏所有其他安全门。
- en: 'So what does Docker image protection mean in practice? We would have to take
    care of the two following issues:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在实践中Docker镜像保护意味着什么？我们必须注意以下两个问题：
- en: The registry images cannot be changed without permission.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有权限，无法更改注册表中的镜像。
- en: Images are securely delivered into the Kubernetes cluster.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像被安全地交付到Kubernetes集群中。
- en: Registry image protection
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表镜像保护
- en: Similarly to the Git repository, Docker repository protection is provided by
    the hosting service. Probably the most popular Docker repository hosting service
    is DockerHub. The service allows accessing thousands of Docker images. The service
    is provided by Docker Inc. and completely free for any open source project.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于Git仓库，Docker仓库保护由托管服务提供。最流行的Docker仓库托管服务可能是DockerHub。该服务允许访问成千上万的Docker镜像。该服务由Docker
    Inc.提供，并且对任何开源项目都是完全免费的。
- en: 'To get hands-on experience with DockerHub, you need to get an account on DockerHub,
    create a repository, and push an image. Unless you already have an account, navigate
    to [https://hub.docker.com/signup](https://hub.docker.com/signup) and create one.
    As a next step, you need to create a Docker repository named gitops-k8s-security-alpine,
    as described in the DockerHub documentation.^([12](#pgfId-1077365)) Finally, you
    are ready to verify if DockerHub is protecting the repository, but first you need
    to get a sample Docker image. The simplest way to create one is to pull an existing
    image and rename it. The following command pulls the Alpine Linux image from the
    official DockerHub repository and renames it <username>/gitops-k8s-security-alpine,
    where <username> is the name of your DockerHub account:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得DockerHub的实际操作经验，您需要在DockerHub上获取一个账户，创建一个仓库，并推送一个镜像。除非您已经有了账户，否则请导航到[https://hub.docker.com/signup](https://hub.docker.com/signup)并创建一个账户。作为下一步，您需要创建一个名为gitops-k8s-security-alpine的Docker仓库，如DockerHub文档中所述.^([12](#pgfId-1077365))
    最后，您准备好验证DockerHub是否正在保护仓库，但首先您需要获取一个示例Docker镜像。最简单的方法是拉取一个现有的镜像并重命名它。以下命令从官方DockerHub仓库拉取Alpine
    Linux镜像并将其重命名为<username>/gitops-k8s-security-alpine，其中<username>是您的DockerHub账户名称：
- en: '[PRE18]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The next command pushes the image into the gitops-k8s-security-alpine Docker
    registry:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个命令将镜像推送到gitops-k8s-security-alpine Docker注册表：
- en: '[PRE19]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'However, the local Docker client does not have credentials to access the DockerHub
    repository, so the `push` command should fail. To fix the error, run the following
    command and provide your DockerHub account username and password:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，本地的Docker客户端没有访问DockerHub仓库的凭证，所以`push`命令应该失败。为了修复错误，运行以下命令并提供您的DockerHub账户用户名和密码：
- en: '[PRE20]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Once you have logged in successfully, the Docker client knows who you are, and
    the Docker `push` command can be executed.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦成功登录，Docker客户端就知道你是谁，并且可以执行Docker的`push`命令。
- en: Securing image delivery
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 确保图像交付安全
- en: 'The security of image delivery into the cluster means answering the question,
    “Do we trust the source of the image?” And trust means that we want to be sure
    that the image was created by an authorized author, and the image content is not
    being modified while transferring from the repository. So this is the problem
    of protecting image author identity. And the solution is very similar to the solution
    that protects Git commit author identity:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 将镜像安全地交付到集群中意味着回答问题：“我们是否信任镜像的来源？”信任意味着我们想要确保镜像是由授权的作者创建的，并且在从仓库传输过程中镜像内容没有被篡改。因此，这是保护镜像作者身份的问题。解决方案与保护
    Git 提交作者身份的解决方案非常相似：
- en: The person or an automated process uses a digital signature to sign the content
    of the image.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 个人或自动化过程使用数字签名对镜像的内容进行签名。
- en: The signature is used by the consumer to verify that the image was created by
    a trusted author, and the content was not tampered with.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 签名由消费者使用，以验证镜像是由受信任的作者创建的，并且内容没有被篡改。
- en: The good news is that this is already supported by the Docker client and the
    image registry. The Docker feature named Content Trust allows signing the image
    and pushing it into the registry along with the signature. The consumer can use
    the Content Trust feature to verify that the signed image content was not changed.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，这已经由 Docker 客户端和镜像注册库支持。Docker 的功能名为内容信任，允许对镜像进行签名并将其连同签名一起推送到注册库。消费者可以使用内容信任功能来验证已签名的镜像内容未被更改。
- en: So in the perfect scenario, the CI pipeline should publish the signed image,
    and Kubernetes should be configured to require a valid signature for every image
    running in production. The bad news is that Kubernetes, as of version 1.17, still
    does not provide a configuration that enforces image signature verification. So
    the best we can do is verify the image signature before modifying the Kubernetes
    manifests.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在理想场景下，CI 管道应发布已签名的镜像，并且 Kubernetes 应配置为要求每个在生产环境中运行的镜像都具备有效的签名。坏消息是，截至版本
    1.17，Kubernetes 仍然没有提供强制执行镜像签名验证的配置。因此，我们能做的最好的事情就是在修改 Kubernetes 清单之前验证镜像签名。
- en: 'The content trust configuration is fairly simple. You have to set the `DOCKER
    _CONTENT_TRUST` environment variable:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 内容信任配置相当简单。您必须设置 `DOCKER_CONTENT_TRUST` 环境变量：
- en: '[PRE21]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once the environment variable is set, the Docker commands `run` and `pull`
    should verify the image signature. We can confirm that by pulling the unsigned
    image that we just pushed to the gitops-k8s-security-alpine repository:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了环境变量，Docker 命令 `run` 和 `pull` 应该会验证镜像签名。我们可以通过拉取我们刚刚推送到 gitops-k8s-security-alpine
    仓库的未签名镜像来确认这一点：
- en: '[PRE22]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The command fails as expected because the <username>/gitops-k8s-security-alpine:v0.1
    image was not signed. Let’s fix it. Make sure the `DOCKER_CONTENT_TRUST` environment
    variable is still set to `1`, and create a signed image using the following command:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 命令如预期失败，因为 <username>/gitops-k8s-security-alpine:v0.1 镜像未签名。让我们修复它。确保 `DOCKER_CONTENT_TRUST`
    环境变量仍然设置为 `1`，并使用以下命令创建一个已签名的镜像：
- en: '[PRE23]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This time, the `docker push` command signs the image before pushing it. If
    you are pushing the signed image for the first time, Docker will generate keys
    in the ~/.docker/trust/ directory and prompt you for the passphrase to use for
    the root key and repo key. After providing the passphrase, the signed image is
    pushed to the Docker Hub. Finally, we can verify that the pushed image has a proper
    signature by running the `docker` `pull` command one more time:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`docker push` 命令在推送镜像之前对它进行签名。如果您是第一次推送已签名的镜像，Docker 将在 ~/.docker/trust/
    目录中生成密钥，并提示您输入用于根密钥和仓库密钥的密码短语。在提供密码短语后，已签名的镜像将被推送到 Docker Hub。最后，我们可以通过再次运行 `docker
    pull` 命令来验证推送的镜像具有正确的签名：
- en: '[PRE24]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The command successfully completed. Our image has the proper signature, and
    the Docker client was able to verify it!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 命令成功完成。我们的镜像具有正确的签名，并且 Docker 客户端能够验证它！
- en: 6.3 Patterns
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 模式
- en: OK, let’s face it. Brand-new greenfield projects are not necessarily started
    with a perfectly secure deployment process. In fact, young projects don’t even
    have an automated deployment process. The lead engineer may be the only one able
    to deploy the project, which they may do from their laptop. Typically, a team
    starts adding automation as it gets more and more time consuming to deploy all
    the application services. As the potential cost and damage from unauthorized access
    increases, the security of that automation becomes more and more critical.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们面对现实。全新的绿色项目并不一定是以一个完美的部署流程开始的。事实上，年轻的项目甚至没有自动部署流程。首席工程师可能是唯一能够部署项目的人，他们可能从他们的笔记本电脑上部署。通常，随着部署所有应用程序服务的耗时越来越多，团队开始添加自动化。随着未经授权访问的潜在成本和损害的增加，该自动化的安全性变得越来越关键。
- en: 6.3.1 Full access
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.1 完全访问
- en: The initial security model of almost every new project is based completely on
    trust between the team members. Every team member has full access, and deployment
    changes are not necessarily recorded and available for an audit later.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个新项目的初始安全模型完全基于团队成员之间的信任。每个团队成员都有完全访问权限，部署更改不一定被记录并在以后可供审计。
- en: '![](Images/CH06_F09_Yuen.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH06_F09_Yuen.png)'
- en: Figure 6.9 The full-access security model assumes that both engineers and CI
    systems have full access to the Kubernetes cluster. The trade-off is speed over
    security. This model is more applicable for new projects in the beginning stage.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9 全访问安全模型假设工程师和CI系统都有完全访问Kubernetes集群的权限。这种权衡是速度胜过安全。这种模型更适合处于早期阶段的新项目。
- en: Weak security is not necessarily a bad thing in the beginning. Full access means
    fewer barriers, enabling the team to be more flexible and move more quickly. While
    there is no important customer data in production, it is a perfect chance to focus
    on speed and shape the project until you are ready to move into production. But
    probably sooner rather than later, you will need to put proper security controls
    in place, not only for customer data in production but also to ensure the integrity
    of the code being deployed into production.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，弱安全性并不一定是一件坏事。完全访问意味着更少的障碍，使团队能够更加灵活并更快地移动。当生产环境中没有重要客户数据时，这是一个专注于速度并塑造项目直到你准备好进入生产的完美机会。但可能更早而不是更晚，你需要实施适当的控制措施，不仅是为了生产中的客户数据，还要确保部署到生产中的代码的完整性。
- en: 6.3.2 Deployment repo access
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.2 部署存储库访问
- en: Disabling direct Kubernetes access for developers by default is a big step forward
    from a security perspective. This is the most common pattern if you are using
    GitOps. In this model, developers still have full access to the deployment repository
    but must rely on the GitOps operator to push changes to the Kubernetes cluster.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下禁用开发人员的直接Kubernetes访问是一个从安全角度迈出的巨大进步。如果你使用GitOps，这是最常见的模式。在这个模型中，开发人员仍然可以完全访问部署存储库，但必须依赖GitOps操作员将更改推送到Kubernetes集群。
- en: '![](Images/CH06_F10_Yuen.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH06_F10_Yuen.png)'
- en: Figure 6.10 The GitOps operator allows removing cluster access. At this point,
    engineers need access only to the deployment repository.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10 GitOps操作员允许移除集群访问。此时，工程师只需要访问部署存储库。
- en: In addition to better security, this pattern provides auditability. Assuming
    that no one has access to the Kubernetes configuration, the deployment repository
    history contains all cluster configuration changes.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更好的安全性外，此模式还提供了可审计性。假设没有人可以访问Kubernetes配置，部署存储库的历史记录包含了所有集群配置更改。
- en: The pattern is still not perfect. While the project is maturing and the team
    keeps improving the deployment configuration, it feels perfectly fine to update
    the deployment repository manually. However, after some time, each application
    release is going to require only an image tag change. At this stage, maintenance
    of the deployment repository is still very valuable but may feel like a lot of
    overhead.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当项目成熟并且团队不断改进部署配置时，手动更新部署存储库仍然感觉非常合适。然而，经过一段时间，每个应用程序发布可能只需要更改图像标签。在这个阶段，维护部署存储库仍然非常有价值，但可能感觉有很多开销。
- en: 6.3.3 Code access only
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.3 仅代码访问
- en: The code-access-only pattern is a logical continuation of the deployment-repository-access-only
    approach. If release changes in the deployment repository are predictable, it
    is possible to codify the configuration change process in the CI pipeline.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 代码访问仅模式是部署存储库访问仅方法的逻辑延续。如果部署存储库中的发布更改是可预测的，那么在CI管道中可以将其配置更改过程编码化。
- en: '![](Images/CH06_F11_Yuen.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH06_F11_Yuen.png)'
- en: Figure 6.11 The code-access-only model assumes that both the deployment repository
    and Kubernetes cluster changes are fully automated. Engineers need only code repository
    access.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11 代码访问仅模式假设部署存储库和Kubernetes集群的更改都是完全自动化的。工程师只需要对代码存储库的访问权限。
- en: 'The pattern streamlines the development process and significantly reduces the
    amount of manual work. It also improves deployment security in several ways:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式简化了开发过程，并显著减少了手动工作量的需求。它还在几个方面提高了部署的安全性：
- en: The development team no longer needs access to the deployment repository. Only
    the dedicated automation account has permission to push into the repository.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发团队不再需要访问部署存储库。只有专门的自动化账户才有权限向存储库推送。
- en: Since changes in the deployment repository are automated, it is much easier
    to configure the GPG signing process and automate it in the CI pipeline.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于部署存储库的更改是自动化的，因此配置GPG签名过程并将其在CI管道中自动化的过程要容易得多。
- en: Exercise 6.6
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 练习6.6
- en: Choose which pattern fits your project the best. Try to elaborate on the pros
    and cons of each pattern, and explain why you prefer the chosen pattern.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 选择最适合您项目的模式。尽量详细地阐述每种模式的优缺点，并解释您为什么选择该模式。
- en: 6.4 Security concerns
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 安全问题
- en: We’ve learned how to protect our deployment process end to end, starting from
    the most basic, all the way to identity protection of configuration changes and
    new images. Finally, let’s learn important edge cases that must be covered to
    ensure the security of your cluster.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何从最基本的部分开始，保护我们的部署过程端到端，一直到配置更改和新图像的身份保护。最后，让我们学习必须涵盖的重要边缘情况，以确保您集群的安全性。
- en: 6.4.1 Preventing image pull from untrusted registries
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.1 防止从不受信任的注册表拉取图像
- en: In section 6.2.3, we showed how you can implement security controls on public
    registries, such as docker.io, to ensure images have been published by authorized
    users as intended and have not been tampered with when being pulled. However,
    the fact is that a public registry is outside of your visibility and control.
    You must trust that the maintainers of the public registry are following security
    best practices. And even if they are, the fact that they are a public registry
    means that anyone on the internet can push images to it. For some businesses with
    very high security needs, this is not acceptable.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在6.2.3节中，我们展示了如何在对公共注册表（如docker.io）实施安全控制，以确保图像是由授权用户按预期发布的，并且在拉取时没有被篡改。然而，事实是公共注册表超出了您的可见性和控制范围。您必须信任公共注册表维护者遵循安全最佳实践。即使他们确实如此，他们作为公共注册表的事实意味着任何互联网用户都可以向其推送图像。对于一些对安全性要求极高的企业来说，这是不可接受的。
- en: To address this, many enterprises will maintain their own private Docker image
    registry for reliability, performance, privacy, and security. In this case, new
    images should be pushed to the private registry (such as docker.mycompany.com)
    instead of a public registry (such as docker.io). This can be accomplished by
    modifying the CI pipeline to push successfully built new images to the private
    registry.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，许多企业将维护自己的私有Docker图像注册表，以确保可靠性、性能、隐私和安全。在这种情况下，新图像应该推送到私有注册表（如docker.mycompany.com），而不是公共注册表（如docker.io）。这可以通过修改CI管道，将成功构建的新图像推送到私有注册表来实现。
- en: Deployments to Kubernetes should also only pull images from the private registry.
    But how can this be enforced? What if a naive developer accidentally pulls a virus-
    or malware-infected image from docker.io? Or a malicious developer who doesn’t
    have privileges to push images to the private registry tries to side-load an image
    from their public DockerHub repository? Of course, using GitOps will ensure that
    these actions are recorded in the audit trail so those responsible should be able
    to be identified. However, how can this be prevented in the first place?
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 部署到 Kubernetes 应该也只从私有仓库拉取镜像。但如何强制执行这一规定？如果一位天真无邪的开发者不小心从 docker.io 拉取了病毒或恶意软件感染的镜像怎么办？或者，一个没有权限向私有仓库推送镜像的恶意开发者试图从他们的公共
    DockerHub 仓库中侧加载镜像怎么办？当然，使用 GitOps 将确保这些操作被记录在审计跟踪中，因此那些负责的人应该能够被识别。然而，如何从一开始就预防这种情况呢？
- en: This can be accomplished using the Open Policy Agent (OPA) and an admission
    webhook that rejects manifests that reference an image coming from a prohibited
    image registry.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过使用 Open Policy Agent (OPA) 和一个拒绝引用来自禁止镜像仓库的镜像的 admission webhook 来实现。
- en: 6.4.2 Cluster-level resources in a Git repository
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.2 Git 仓库中的集群级资源
- en: As you know from this chapter, the Kubernetes access settings are controlled
    using Kubernetes resources such as Role and ClusterRole. RBAC resources management
    is a perfectly valid use of a GitOps operator. It is common practice to package
    the definition of an application deployment together with required Kubernetes
    access settings. However, there is a potential security hole that can be used
    to escalate privileges. Because Kubernetes access settings are managed by resources,
    these resources can be placed into the deployment repository and delivered by
    the GitOps operator. The intruder might create a ClusterRole and give permissions
    to the service account that later on might be used as a back door.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从本章中了解到的，Kubernetes 访问设置是通过 Kubernetes 资源（如 Role 和 ClusterRole）控制的。RBAC 资源管理是
    GitOps 运营商的一个完全有效的用途。将应用程序部署的定义与所需的 Kubernetes 访问设置打包在一起是一种常见的做法。然而，存在一个可能被用来提升权限的安全漏洞。因为
    Kubernetes 访问设置由资源管理，这些资源可以被放入部署仓库并由 GitOps 运营商交付。入侵者可能会创建一个 ClusterRole 并授予服务账户权限，该服务账户后来可能被用作后门。
- en: The rule of thumb that prevents privileges escalation is to limit the GitOps
    operator privileges. If the development team that leverages the GitOps operator
    is not supposed to manage ClusterRoles, then the GitOps operator should not have
    that permission. If the GitOps operator is shared by multiple teams, the operator
    should be configured appropriately and should enforce team-specific security checks.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 防止权限提升的实用规则是限制 GitOps 运营商的权限。如果利用 GitOps 运营商的开发团队不应该管理 ClusterRoles，那么 GitOps
    运营商就不应该拥有那个权限。如果 GitOps 运营商被多个团队共享，运营商应该适当配置并执行特定于团队的网络安全检查。
- en: Exercise 6.7
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 6.7
- en: Refer to the poor-man’s GitOps operator tutorial. Review the RBAC configuration
    and check if it allows a security privileges escalation attack.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 参考穷人的 GitOps 运营商教程。审查 RBAC 配置并检查它是否允许安全权限提升攻击。
- en: Summary
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The traditional CI Ops security model has a wide attack surface due to access
    by both engineers and CI systems. The GitOps security model significantly reduces
    the attack surface of the cluster because only the GitOps operator has access
    to the cluster.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于工程师和 CI 系统的访问，传统的 CI/Ops 安全模型具有广泛的攻击面。GitOps 安全模型显著减少了集群的攻击面，因为只有 GitOps 运营商可以访问集群。
- en: Git’s underlying data structure uses the Merkle tree, which provides a treelike
    structure with cryptographic protection to provide a tamper-proof commit log.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git 的底层数据结构使用 Merkle 树，它提供了一个具有加密保护的树状结构，以提供防篡改的提交日志。
- en: In addition to Git’s data structure security advantage, the code review process
    using pull request and automated checks using tools such as kubeaudit and kubesec
    can detect security vulnerability in the manifests.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了 Git 的数据结构安全优势外，使用拉取请求进行的代码审查过程以及使用 kubeaudit 和 kubesec 等工具进行的自动化检查可以检测到清单中的安全漏洞。
- en: Git natively does not protect commit author identity. Using GPG can guarantee
    the authenticity of the commit author by injecting a digital crypto signature
    in the commit metadata.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git 本身并不保护提交作者的标识。使用 GPG 可以通过在提交元数据中注入数字加密签名来保证提交作者的认证性。
- en: RBAC is the preferred way to implement access control in Kubernetes. Both users
    and GitOps operators’ access control can be provisioned through RBAC.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RBAC 是在 Kubernetes 中实现访问控制的推荐方式。用户和 GitOps 运营商的访问控制都可以通过 RBAC 进行配置。
- en: Similar to Git, all Docker images should be signed with a digital signature
    to verify authenticity using the Content Trust feature.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Git 类似，所有 Docker 镜像都应该使用数字签名进行签名，以使用内容信任功能验证其真实性。
- en: New projects can start with full access (cluster, deployment repo, and code
    repo) for engineers to focus on development velocity initially. As projects mature
    and get ready for initial production release, both cluster and deployment repo
    access should be restricted to put emphasis on security rather than speed.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新项目可以从完全访问权限（集群、部署仓库和代码仓库）开始，以便工程师最初专注于开发速度。随着项目的成熟和准备进行初始生产发布，集群和部署仓库的访问权限应受到限制，以强调安全性而不是速度。
- en: '* * *'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 1.[http://mng.bz/MXB7](https://shortener.manning.com/MXB7).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 1.[http://mng.bz/MXB7](https://shortener.manning.com/MXB7).
- en: 2.[https://en.wikipedia.org/wiki/Blockchain](https://en.wikipedia.org/wiki/Blockchain).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 2.[https://en.wikipedia.org/wiki/Blockchain](https://en.wikipedia.org/wiki/Blockchain).
- en: 3.[https://en.wikipedia.org/wiki/Merkle_tree](https://en.wikipedia.org/wiki/Merkle_tree).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 3.[https://en.wikipedia.org/wiki/Merkle_tree](https://en.wikipedia.org/wiki/Merkle_tree).
- en: 4.[http://mng.bz/goBl](https://shortener.manning.com/goBl).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 4.[http://mng.bz/goBl](https://shortener.manning.com/goBl).
- en: 5.[http://mng.bz/e51z](https://shortener.manning.com/e51z).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 5.[http://mng.bz/e51z](https://shortener.manning.com/e51z).
- en: 6.[http://mng.bz/pVPG](https://shortener.manning.com/pVPG).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 6.[http://mng.bz/pVPG](https://shortener.manning.com/pVPG).
- en: 7.[https://github.com/Shopify/kubeaudit](https://github.com/Shopify/kubeaudit).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 7.[https://github.com/Shopify/kubeaudit](https://github.com/Shopify/kubeaudit).
- en: 8.[https://kubesec.io/](https://kubesec.io/).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 8.[https://kubesec.io/](https://kubesec.io/).
- en: 9.Joe Beda ([https://www.linkedin.com/in/jbeda](https://www.linkedin.com/in/jbeda))
    is one of the principal founders of Kubernetes.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 9.Joe Beda ([https://www.linkedin.com/in/jbeda](https://www.linkedin.com/in/jbeda))
    是 Kubernetes 的主要创始人之一。
- en: 10.[https://help.github.com/en/github/authenticating-to-github/adding-a-new-gpg-key-to-your-github-account](https://help.github.com/en/github/authenticating-to-github/adding-a-new-gpg-key-to-your-github-account).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 10.[https://help.github.com/en/github/authenticating-to-github/adding-a-new-gpg-key-to-your-github-account](https://help.github.com/en/github/authenticating-to-github/adding-a-new-gpg-key-to-your-github-account).
- en: 11.[http://mng.bz/9MDl](http://mng.bz/9MDl).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 11.[http://mng.bz/9MDl](http://mng.bz/9MDl).
- en: 12.[https://docs.docker.com/docker-hub/repos](https://docs.docker.com/docker-hub/repos/).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 12.[https://docs.docker.com/docker-hub/repos](https://docs.docker.com/docker-hub/repos/).
