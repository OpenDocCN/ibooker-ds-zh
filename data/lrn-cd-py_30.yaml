- en: Lesson 24\. Mutable and immutable objects
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第24课：可变和不可变对象
- en: After reading [lesson 24](#ch24), you’ll be able to
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读完[第24课](#ch24)后，你将能够
- en: Understand what an immutable object is
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解不可变对象是什么
- en: Understand what a mutable object is
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解可变对象是什么
- en: Understand how objects are stored in computer memory
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解对象在计算机内存中的存储方式
- en: 'Consider the following scenario. You buy a house that’s just the right size
    for you; it’s big enough for one person to live in. Then you get married, and
    there’s no space for your spouse. You have two choices: build an addition to the
    house, or tear the whole house down and build a new larger house to hold two people.
    Building an addition makes more sense than demolishing a perfectly good house
    and making an exact copy of it just to make an addition. Now, you have a kid and
    decide you need more room. Again, do you build an addition or tear the house down
    to build a new one to hold three people? Again, it makes more sense to build an
    extension. As you’re adding more people to your house, it’s quicker and less costly
    to keep the same structure and modify it.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下场景。你买了一所房子，大小正好适合你；足够一个人居住。然后你结婚了，没有空间给你的配偶。你有两个选择：给房子扩建，或者拆掉整个房子并建一个更大的新房子来容纳两个人。扩建房子比拆掉一个完好无损的房子并为了扩建而制作一个精确的副本更有意义。现在，你有了孩子，决定你需要更多的空间。再次，你是扩建房子还是拆掉房子建一个能容纳三个人的新房子？再次，扩建房子比拆掉房子建新房子更有意义。当你往房子里添加更多的人时，保持相同的结构并对其进行修改会更快、成本更低。
- en: In some situations, it helps to be able to put your data in some sort of container
    so you can modify the data within the container instead of having to create a
    new container and put the modified data in the new one.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，能够将你的数据放入某种容器中以便修改容器内的数据，而不是必须创建一个新的容器并将修改后的数据放入其中，这很有帮助。
- en: '|  |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: 'This exercise requires a piece of paper and your computer. Think of the names
    of all the countries you’ve visited. If you need inspiration, suppose you’ve visited
    Canada, Brazil, Russia, and Iceland:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习需要一张纸和你的电脑。想想你访问过的所有国家的名字。如果你需要灵感，假设你访问过加拿大、巴西、俄罗斯和冰岛：
- en: On a piece of paper, use a pen to write all the countries you’ve visited in
    alphabetical order, one on each line.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一张纸上，用钢笔按字母顺序写下你访问过的所有国家，每行一个。
- en: On a text editor on your computer, type the same list of countries.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的计算机上的文本编辑器中，输入相同的国家列表。
- en: Suppose you realize that you visited Greenland, not Iceland. Modify your list
    on paper so you have Canada, Brazil, Russia, and Greenland in alphabetical order.
    Can you modify the list (keeping one country per line) without having to rewrite
    it all? Can you modify the list on the computer (keeping one country per line)
    without having to rewrite it all?
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设你意识到你访问过的是格陵兰而不是冰岛。修改你的纸上的列表，使其按字母顺序包含加拿大、巴西、俄罗斯和格陵兰。你能否在不重写整个列表的情况下修改列表（每行一个国家）？你能否在不重写整个列表的情况下在电脑上修改列表（每行一个国家）？
- en: 'Answer:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：
- en: Using a pen, I’d have to rewrite the list. Otherwise, it’d be too messy to scratch
    out and write the new country name beside it. On the text editor, I can replace
    the name directly.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用钢笔，我必须重写列表。否则，划掉并在新国家名称旁边写上新的国家名称会太乱。在文本编辑器中，我可以直接替换名称。
- en: '|  |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 24.1\. Immutable objects
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 24.1. 不可变对象
- en: All Python objects that you’ve seen (Booleans, integers, floats, strings, and
    tuples) are immutable. After you create the object and assign a value to it, you
    can’t modify that value.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你所看到的所有Python对象（布尔值、整数、浮点数、字符串和元组）都是不可变的。在你创建对象并为其分配值之后，你不能修改该值。
- en: '|  |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Definition
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: An *immutable object* is an object whose value can’t change.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*不可变对象*是一个其值不能改变的对象。
- en: '|  |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: What does this mean behind the scenes, in computer memory? An object created
    and given a value is assigned a space in memory. The variable name bound to the
    object points to that place in memory. [Figure 24.1](#ch24fig01) shows the memory
    locations of objects and what happens when you bind the same variable to a new
    object by using the expressions `a = 1` and then `a = 2`. The object with value
    `1` still exists in memory, but you’ve lost the binding to it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机内存中，这背后意味着什么？创建并赋予值的对象会在内存中分配一个空间。绑定到该对象的变量名称指向内存中的那个位置。[图24.1](#ch24fig01)显示了对象的内存位置以及当你使用表达式`a
    = 1`然后`a = 2`将相同的变量绑定到新对象时会发生什么。值为`1`的对象仍然存在于内存中，但你已经失去了对它的绑定。
- en: Figure 24.1\. The variable named `a` is bound to an object with value `1` in
    one memory location. When the variable named `a` is bound to a different object
    with value `2`, the original object with value `1` is still in memory; you just
    can’t access it anymore through a variable.
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 24.1\. 叫做 `a` 的变量绑定到一个值为 `1` 的对象，位于一个内存位置。当 `a` 变量绑定到一个不同的值为 `2` 的对象时，原始的值为
    `1` 的对象仍然在内存中；你只是不能再通过变量访问它了。
- en: '![](images/24fig01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片 24.1](images/24fig01.jpg)'
- en: 'You can see the value of the memory location to which the object has been assigned,
    using the `id()` function. Type the following in the console:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `id()` 函数查看对象被分配的内存位置的值。在控制台中输入以下内容：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The value shown represents the location in memory of the object with value
    `1`, accessed by the variable named `a`. Now, type the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的值代表通过名为 `a` 的变量访问的值为 `1` 的对象在内存中的位置。现在，输入以下内容：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As before, the value shown represents the location in memory of the object with
    value `2`, accessed by the variable named `a`. Why are these values different
    if you’re using variable name `a` in both cases? We come back to the idea that
    the variable name is a name bound to an object. The name points to an object;
    in the first case, the variable points to the integer object with value `1` and
    then to the object with value `2`. The `id()` function tells you the memory location
    of the object pointed to by the variable name, not anything about the variable
    name itself.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，显示的值代表值为 `2` 的对象在内存中的位置，通过名为 `a` 的变量访问。为什么在两种情况下使用变量名 `a` 时这些值不同？我们回到这样一个观点：变量名是一个绑定到对象的名称。名称指向一个对象；在第一种情况下，变量指向值为
    `1` 的整数对象，然后指向值为 `2` 的对象。`id()` 函数告诉你变量名指向的对象的内存位置，而不是关于变量名本身的信息。
- en: 'Objects of the types you’ve seen so far can’t be modified after they’re created.
    Suppose you have the following lines of code, which are executed in the order
    shown. You initialize two variables, `a` and `b`, to two objects with values `1`
    and `2`, respectively. Then you change the binding of variable `a` to a different
    object with a value of `3`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你迄今为止看到的对象类型在创建后不能被修改。假设你有以下几行代码，它们按照显示的顺序执行。你初始化两个变量 `a` 和 `b`，分别绑定到值为 `1`
    和 `2` 的对象。然后你将变量 `a` 的绑定更改为一个值为 `3` 的不同对象：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[Figure 24.2](#ch24fig02) shows the objects that exist in your program’s memory
    with each line of code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 24.2](#ch24fig02) 展示了随着每行代码的执行，你程序内存中存在的对象：'
- en: When you create the object with value `1`, you bind the object to the variable
    named `a`.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你创建一个值为 `1` 的对象时，你将其绑定到名为 `a` 的变量。
- en: When you create the object with value `2`, you bind the object to the variable
    named `b`.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你创建一个值为 `2` 的对象时，你将其绑定到名为 `b` 的变量。
- en: In the final line, you’re rebinding the variable name `a` to a completely new
    object, one whose value is `3`.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在最后一行，你将变量名 `a` 重新绑定到一个全新的对象上，其值为 `3`。
- en: Figure 24.2\. Progression of binding variables to objects. On the left, `a =
    1` shows that object 1 is at some memory location. In the middle, `a = 1` and
    then `b = 2`. Objects with values `1` and `2` are at different memory locations.
    On the right, `a = 1` and then `b = 2` and then `a = 3`. The variable named `a`
    is bound to a different object, but the original object still exists in memory.
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 24.2\. 变量绑定到对象的进程。在左侧，`a = 1` 显示对象 1 位于某个内存位置。在中间，`a = 1` 然后是 `b = 2`。值为 `1`
    和 `2` 的对象位于不同的内存位置。在右侧，`a = 1` 然后是 `b = 2` 和 `a = 3`。名为 `a` 的变量绑定到了一个不同的对象，但原始对象仍然存在于内存中。
- en: '![](images/24fig02_alt.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片 24.2_替代](images/24fig02_alt.jpg)'
- en: The old object with a value of `1` may still exist in computer memory, but you
    lost the binding to it; you don’t have a variable name as a way to refer to it
    anymore.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 值为 `1` 的旧对象可能仍然存在于计算机内存中，但你失去了对其的绑定；你不再有变量名作为引用它的方式。
- en: After an immutable object loses its variable handle, the Python interpreter
    may delete the object to reclaim the computer memory it took up and use it for
    something else. Unlike some other programming languages, you (as the programmer)
    don’t have to worry about deleting old objects; Python takes care of this for
    you through a process called *garbage collection*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个不可变对象失去了其变量引用后，Python 解释器可能会删除该对象，以回收它占用的计算机内存，并将其用于其他目的。与一些其他编程语言不同，你（作为程序员）不必担心删除旧对象；Python
    通过一个称为 *垃圾回收* 的过程为你处理这个问题。
- en: '|  |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 24.1**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 24.1**'
- en: '**[Q1:](kindle_split_056.html#app01qa93q0a1)**'
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_056.html#app01qa93q0a1)**'
- en: ''
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Draw a diagram similar to the one in [figure 24.2](#ch24fig02) to show variables
    and objects that they point to (and any leftover objects) for the following sequence
    of statements:'
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 画出一个类似于[图24.2](#ch24fig02)的图表，以展示变量和它们指向的对象（以及任何剩余的对象）对于以下语句序列：
- en: ''
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '|  |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 24.2\. The need for mutability
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 24.2. 可变性的需求
- en: After you lose the variable binding to an object, there’s no way to get back
    to that object. If you want the program to remember its value, you need to store
    its value in a temporary variable. Using a temporary variable to store values
    that you don’t need right now, but may need in the future, isn’t an efficient
    way of programming. It wastes memory and leads to cluttered code filled with variables
    that, for the most part, will never be used again.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在你失去对象绑定后，就没有办法回到那个对象了。如果你想程序记住它的值，你需要将其值存储在一个临时变量中。使用临时变量来存储你现在不需要但将来可能需要的值，并不是一种高效的编程方式。这浪费了内存，并导致代码杂乱无章，充满了大部分永远不会再次使用的变量。
- en: If immutable objects are objects whose value can’t change after they’re created,
    a mutable object is an object whose value can change after it’s created. Mutable
    objects are often objects that can store a collection of data. In later lessons
    in this unit, you’ll see lists (Python type `list`) and dictionaries (Python type
    `dict`) as examples of mutable objects.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不可变对象是创建后其值不能改变的对象，那么可变对象是创建后其值可以改变的对象。可变对象通常是能够存储数据集合的对象。在本单元的后续课程中，你将看到列表（Python类型`list`）和字典（Python类型`dict`）作为可变对象的例子。
- en: '|  |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Definition
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: A *mutable object* is an object whose value can change.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *可变对象* 是一个其值可以改变的对象。
- en: '|  |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: For example, you can make a list of items you’ll need from the grocery store;
    as you decide what you need, you add items to the list. As you buy things, you
    remove them from the list. Notice that you’re using the same list and modifying
    it (crossing out or adding to the end), as opposed to having many lists in which
    you copy over items every time you want to make a change. As another example,
    you can keep your grocery needs in a dictionary that maps every item you need
    from the store to a number representing the quantity that you need.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以制作一个你需要从杂货店购买的项目清单；当你决定你需要什么时，你将项目添加到清单中。当你购买东西时，你从清单中移除它们。请注意，你正在使用相同的清单并对其进行修改（划掉或添加到末尾），而不是拥有许多清单，每次你想进行更改时都要复制项目。作为另一个例子，你可以将你的杂货需求保存在一个字典中，该字典将商店中你需要购买的每个项目映射到表示你需要数量的数字。
- en: '[Figure 24.3](#ch24fig03) shows what happens in memory when you bind variables
    to mutable objects. When you modify the object, you keep the same variable binding,
    and the object at the same memory location is directly modified.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[图24.3](#ch24fig03)展示了当你将变量绑定到可变对象时在内存中发生的情况。当你修改对象时，你保持相同的变量绑定，并且位于相同内存位置的对象被直接修改。'
- en: Figure 24.3\. On the left, you have a grocery list at a certain memory location.
    On the right, you add another item to your grocery list, and the object at the
    same memory location is directly modified.
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图24.3。在左侧，你有一个位于特定内存位置的购物清单。在右侧，你向购物清单中添加另一项，并且位于相同内存位置的对象被直接修改。
- en: '![](images/24fig03.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](images/24fig03.jpg)'
- en: Mutable objects are more flexible when programming, because you can modify the
    object itself without losing the binding to it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 可变对象在编程中更加灵活，因为你可以在不丢失对其绑定的情况下修改对象本身。
- en: 'First, a mutable object can behave the same way as an immutable object. If
    you rebind a sample grocery list to a variable `a` and check its memory location,
    you see that the memory location changes and the binding to the original list
    is lost:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，可变对象可以表现得和不可变对象一样。如果你将一个示例购物清单重新绑定到变量`a`并检查其内存位置，你会看到内存位置发生变化，并且与原始列表的绑定丢失：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'But you have the option to modify the original object directly without losing
    the binding to it, using operations that work only on mutable objects. In the
    following code, you append one more item (add it to the end of the list). The
    memory location of the object that the variable `a` is bound to remains unchanged.
    The behavior of the following code is shown in [figure 24.3](#ch24fig03):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你有选择直接修改原始对象而不丢失对其绑定的选项。在下面的代码中，你添加了一个额外的项目（将其添加到列表的末尾）。变量`a`绑定的对象的内存位置保持不变。以下代码的行为在[图24.3](#ch24fig03)中显示：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Mutable objects are useful in programing for several reasons.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 可变对象在编程中有几个用途。
- en: First, you can store data that’s part of a collection (for example, lists of
    people or mappings of people to phone numbers) in an object, and you can keep
    the object for use later.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以在对象中存储属于集合的数据（例如，人的列表或人的电话号码映射），并且你可以保留该对象以供以后使用。
- en: After the object is created, you can add data to and remove data from the object
    itself, without creating a new object. When you have the object, you can also
    modify elements in the collection by modifying the elements in the object itself
    instead of creating a new copy of the object with only one of its values modified.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象创建之后，你可以向对象本身添加数据，也可以从对象本身移除数据，而不需要创建一个新的对象。当你拥有这个对象时，你也可以通过修改对象本身中的元素来修改集合中的元素，而不是创建一个只有其中一个值被修改的新对象副本。
- en: Finally, you can rearrange data in the collection by keeping the same object
    and making the rearrangement in place—for example, if you have a list of people
    and you want to sort it alphabetically.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以通过保持相同的对象并在原地进行重新排列来重新排列集合中的数据——例如，如果你有一份人的名单，并且你想按字母顺序对其进行排序。
- en: With large collections of data, copying your collection into a new object every
    time you make a change to it would be inefficient.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大量数据集合，每次你对其做出更改时都将其复制到新对象中将会效率低下。
- en: '|  |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 24.2**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 24.2**'
- en: Would you use a mutable or an immutable type of object to store the following
    information?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你会使用可变类型还是不可变类型的对象来存储以下信息？
- en: '**[1](kindle_split_056.html#app01qa94q0a1)**'
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](kindle_split_056.html#app01qa94q0a1)**'
- en: ''
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Cities in a state
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 州内的城市
- en: '**[2](kindle_split_056.html#app01qa94q0a2)**'
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](kindle_split_056.html#app01qa94q0a2)**'
- en: ''
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Your age
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你的年龄
- en: '**[3](kindle_split_056.html#app01qa94q0a3)**'
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](kindle_split_056.html#app01qa94q0a3)**'
- en: ''
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Group of items in a grocery store and their cost
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 超市中商品组及其成本
- en: '**[4](kindle_split_056.html#app01qa94q0a4)**'
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[4](kindle_split_056.html#app01qa94q0a4)**'
- en: ''
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Color of a car
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 汽车的颜色
- en: '|  |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this lesson, my objective was to teach you how an object exists in computer
    memory. The values of some objects can’t change after they’re created (immutable
    objects). The values of some objects can change after they’re created (mutable
    objects). You may use one kind or another kind of object, depending on the task
    you’re trying to accomplish using programming. Here are the major takeaways:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，我的目标是教你如何理解对象在计算机内存中的存在。一些对象的值在创建后不能改变（不可变对象）。一些对象的值在创建后可以改变（可变对象）。你可能需要使用一种或另一种类型的对象，这取决于你使用编程尝试完成的任务。以下是主要收获：
- en: Immutable objects can’t change their value (for example, strings, integers,
    floats, Booleans).
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变对象不能改变它们的值（例如，字符串、整数、浮点数、布尔值）。
- en: Mutable objects can change their value (in this unit, you’ll see lists and dictionaries).
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变对象可以改变它们的值（在本单元中，你将看到列表和字典）。
- en: Let’s see if you got this...
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否掌握了这个...
- en: '**[Q24.1](kindle_split_056.html#app01qa95q0a1)**'
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q24.1](kindle_split_056.html#app01qa95q0a1)**'
- en: ''
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the following diagram, each panel is showing a new operation of code. Which
    of the following variables are bound to immutable objects? Which are bound to
    mutable objects?
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在以下图中，每个面板展示了一个新的代码操作。以下哪些变量绑定到不可变对象？哪些绑定到可变对象？
- en: ''
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](images/241fig01_alt.jpg)'
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](images/241fig01_alt.jpg)'
- en: ''
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Progression of expressions being added to code that manipulates two variables:
    `one` and `age`'
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 向操作两个变量（`one`和`age`）的代码中添加表达式的进程
