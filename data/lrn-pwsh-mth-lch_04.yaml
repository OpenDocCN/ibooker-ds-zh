- en: 4 Running commands
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 运行命令
- en: 'When you start looking at PowerShell examples on the internet, it’s easy to
    get the impression that PowerShell is some kind of .NET–based scripting or programming
    language. Our fellow Microsoft most valuable professional (MVP) award recipients,
    and hundreds of other PowerShell users, are pretty serious geeks who like to dig
    deep into the shell to see what we can make it do. But almost all of us began
    right where this chapter starts: running commands. That’s what you’ll be doing
    in this chapter: not scripting, not programming, but running commands and command-line
    utilities.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始在网上查看 PowerShell 示例时，很容易产生一种印象，即 PowerShell 是一种基于 .NET 的脚本或编程语言。我们的微软最有价值专家（MVP）获奖者和数百名其他
    PowerShell 用户都是非常严肃的极客，他们喜欢深入研究 shell，看看我们能让它做什么。但几乎我们所有人都是从本章开始的地方开始的：运行命令。这就是你将在本章中做的事情：不是脚本编写，也不是编程，而是运行命令和命令行实用程序。
- en: 4.1 Let’s talk security
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 让我们谈谈安全
- en: Okay, it’s time to talk about the elephant in the room. PowerShell is great,
    and PowerShell is awesome. But the bad guys like PowerShell just as much as we
    do. Securing your production environment is at the top of everyone’s priority
    list. By now, you’re probably starting to get a feel for how powerful PowerShell
    can be—and you’re wondering whether all that power might be a security problem.
    It *might* be. Our goal in this section is to help you understand exactly how
    PowerShell can impact security in your environment and how to configure PowerShell
    to provide exactly the balance of security and power you require.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，是时候谈谈房间里的大象了。PowerShell 很棒，PowerShell 真是太棒了。但是，坏人同样喜欢 PowerShell，就像我们一样。确保生产环境的安全是每个人的首要任务。到现在为止，你可能已经开始感受到
    PowerShell 的强大之处——你可能想知道所有这些力量是否可能成为安全问题。**可能**会。本节的目标是帮助您了解 PowerShell 如何影响您环境中的安全，以及如何配置
    PowerShell 以提供您所需的精确的安全与权力的平衡。
- en: First and foremost, PowerShell doesn’t apply any additional layers of permissions
    on anything it touches. PowerShell enables you to do only what you already have
    permission to do. If you can’t create new users in Active Directory by using the
    graphical console, you won’t be able to do so in PowerShell either. PowerShell
    is another means of exercising whatever permissions you already have.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，PowerShell 不会在其接触的任何事物上应用任何额外的权限层。PowerShell 使你只能做你已经有权做的事情。如果你不能通过图形控制台在
    Active Directory 中创建新用户，你也不会在 PowerShell 中做到。PowerShell 是一种行使你已有权限的另一种方式。
- en: PowerShell is also not a way to bypass any existing permissions. Let’s say you
    want to deploy a script to your users, and you want that script to do something
    that your users don’t normally have permission to do. That script isn’t going
    to work for them. If you want your users to do something, you need to give them
    permission to do it. PowerShell can accomplish only those things that the person
    running a command or script already has permission to do.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 也不是绕过任何现有权限的方法。假设你想将一个脚本部署给你的用户，并且你想让这个脚本执行你的用户通常没有权限执行的操作。这个脚本对他们来说将不起作用。如果你想让你的用户做某事，你需要给他们执行这项操作的权限。PowerShell
    只能完成运行命令或脚本的人已经有权执行的事情。
- en: 'PowerShell’s security system isn’t designed to prevent anyone from typing in,
    and running, whatever commands they have permission to execute. The idea is that
    it’s somewhat difficult to trick a user into typing a long, complicated command,
    so PowerShell doesn’t apply any security beyond the user’s existing permissions.
    But we know from past experience that it’s easy to trick users into running a
    script, which might well contain malicious commands. This is why most of PowerShell’s
    security is designed with the goal of preventing users from unintentionally running
    scripts. The *unintentionally* part is important: nothing in PowerShell’s security
    is intended to prevent a determined user from running a script. The idea is to
    prevent users only from being *tricked* into running scripts from untrusted sources.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 的安全系统并不是为了阻止任何人输入并运行他们有权执行的任何命令。其理念是，欺骗用户输入一个长而复杂的命令有些困难，因此 PowerShell
    不会在用户现有权限之外应用任何安全措施。但我们从以往的经验中知道，很容易欺骗用户运行脚本，而这些脚本可能包含恶意命令。这就是为什么 PowerShell 的大部分安全设计都是为了防止用户无意中运行脚本。**无意中**这部分很重要：PowerShell
    的安全中没有任何东西是为了阻止一个决心运行脚本的用户。其理念是仅阻止用户被**欺骗**运行来自不受信任来源的脚本。
- en: 4.1.1 Execution policy
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 执行策略
- en: 'The first security measure PowerShell includes is an *execution policy*. This
    machine-wide setting governs the scripts that PowerShell will execute. The default
    setting on Windows 10 is Restricted. On Windows Servers, the default is `RemotedSigned`
    and the execution policy on non-Windows devices is not enforced. The Restricted
    setting on Windows 10 devices prevents scripts from being executed at all. That’s
    right: by default, you can use PowerShell to interactively run commands, but you
    can’t use it to run scripts. Let’s pretend that you downloaded a script off the
    internet. If you try to run it, you’ll get the following error message:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 包含的第一项安全措施是 *执行策略*。这个全局设置控制 PowerShell 将执行的脚本。Windows 10 的默认设置是受限。在
    Windows 服务器上，默认是 `RemotedSigned`，而在非 Windows 设备上的执行策略不被强制执行。Windows 10 设备上的受限设置阻止所有脚本执行。没错：默认情况下，您可以使用
    PowerShell 交互式运行命令，但您不能使用它来运行脚本。让我们假设您从互联网上下载了一个脚本。如果您尝试运行它，您将收到以下错误消息：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'View the current execution policy by running `Get-ExecutionPolicy`. You can
    change the execution policy in one of three ways:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行 `Get-ExecutionPolicy` 查看当前的执行策略。您可以通过以下三种方式之一更改执行策略：
- en: '*By running the* `Set-ExecutionPolicy` *command*—This changes the setting in
    the `HKEY_LOCAL_MACHINE` portion of the Windows Registry and usually must be run
    by an administrator, because regular users don’t have permission to write to that
    portion of the Registry.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过运行* `Set-ExecutionPolicy` *命令*—这会更改 Windows 注册表的 `HKEY_LOCAL_MACHINE` 部分的设置，通常必须由管理员运行，因为普通用户没有权限写入该部分的注册表。'
- en: '*By using a Group Policy Object (GPO**)*—Starting with Windows Server 2008
    R2, support for PowerShell-related settings is included. The PowerShell settings
    shown in figure 4.1 are located under Computer Configuration > Policies > Administrative
    Templates > Windows Components > Windows PowerShell. Figure 4.2 displays the policy
    setting as enabled. When configured via a GPO, the setting in the Group Policy
    overrides any local setting. In fact, if you try to run `Set-ExecutionPolicy`,
    it’ll work, but a warning message will tell you that your new setting had no effect
    because of a Group Policy override.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过使用组策略对象（GPO**）*—从 Windows Server 2008 R2 开始，包括了对 PowerShell 相关设置的支持。图 4.1
    中显示的 PowerShell 设置位于计算机配置 > 策略 > 管理模板 > Windows 组件 > Windows PowerShell 下。图 4.2
    显示了策略设置已启用。通过 GPO 配置时，组策略中的设置将覆盖任何本地设置。实际上，如果您尝试运行 `Set-ExecutionPolicy`，它将生效，但警告消息将告诉您，由于组策略覆盖，您的新设置没有效果。'
- en: '*By manually running* `PowerShell.exe` *and using its* `-ExecutionPolicy` *command-line
    switch*—When you run it in this fashion, the specified execution policy overrides
    any local setting as well as any Group Policy–defined setting. Which we can see
    in figure 4.1.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过手动运行* `PowerShell.exe` *并使用其* `-ExecutionPolicy` *命令行开关*—以这种方式运行时，指定的执行策略将覆盖任何本地设置以及任何组策略定义的设置。如图
    4.1 所示。'
- en: '![](Images/CH04_F01_Plunk.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH04_F01_Plunk.png)'
- en: Figure 4.1 Finding the Windows PowerShell settings in a Group Policy Object
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 在组策略对象中查找 Windows PowerShell 设置
- en: '![](Images/CH04_F02_Plunk.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH04_F02_Plunk.png)'
- en: Figure 4.2 Changing the Windows PowerShell execution policy in a Group Policy
    Object
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 在组策略对象中更改 Windows PowerShell 执行策略
- en: 'You can set the execution policy to one of five settings (note that the Group
    Policy Object provides access to only the middle three of the following list):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将执行策略设置为以下五种设置之一（请注意，组策略对象仅提供以下列表中间三个设置）：
- en: '`Restricted`—This is the default, and scripts aren’t executed. The only exceptions
    are a few Microsoft-supplied scripts that set up PowerShell’s default configuration
    settings. Those scripts carry a Microsoft digital signature and won’t execute
    if modified.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Restricted`—这是默认设置，脚本不会执行。唯一的例外是几个由 Microsoft 提供的脚本，用于设置 PowerShell 的默认配置设置。这些脚本带有
    Microsoft 数字签名，如果被修改则不会执行。'
- en: '`AllSigned`—PowerShell will execute any script that has been digitally signed
    by using a code-signing certificate issued by a trusted certification authority
    (CA).'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AllSigned`—PowerShell 将执行任何由受信任的认证机构（CA）签发的代码签名证书数字签名的脚本。'
- en: '`RemoteSigned`—PowerShell will execute any local script and will execute remote
    scripts if they’ve been digitally signed by using a code-signing certificate issued
    by a trusted CA. *Remote scripts* are those that exist on a remote computer, usually
    accessed by a Universal Naming Convention (UNC) path. Scripts marked as having
    come from the internet are also considered remote. Edge, Chrome, Firefox, and
    Outlook all mark downloads as having come from the internet.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoteSigned`—PowerShell将执行任何本地脚本，如果远程脚本由受信任的CA签发的代码签名证书进行数字签名，它也将执行远程脚本。"远程脚本"是指存在于远程计算机上的脚本，通常通过通用命名约定（UNC）路径访问。标记为来自互联网的脚本也被视为远程脚本。Edge、Chrome、Firefox和Outlook都将下载标记为来自互联网。'
- en: '`Unrestricted`—All scripts will run.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Unrestricted`—所有脚本都将运行。'
- en: '`Bypass`—This special setting is intended for use by application developers
    who are embedding PowerShell within their application. This setting bypasses the
    configured execution policy and should be used only when the hosting application
    is providing its own layer of script security. You’re essentially telling PowerShell,
    “Don’t worry. I have security covered.”'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bypass`—这个特殊设置旨在供将PowerShell嵌入其应用程序的应用程序开发人员使用。此设置绕过配置的执行策略，并且仅在托管应用程序提供自己的脚本安全层时使用。你实际上是在告诉PowerShell，“别担心，我已经有安全措施了。”'
- en: Wait, what?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，什么？
- en: Did you notice that you could set the execution policy in a Group Policy Object,
    but also override it by using a parameter of `PowerShell.exe`? What good is a
    GPO-controlled setting that people can easily override? This emphasizes that the
    execution policy is intended to protect only *uninformed* users from *unintentionally*
    running *anonymous* scripts.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到你可以通过组策略对象设置执行策略，但也可以通过`PowerShell.exe`的参数来覆盖它吗？如果人们可以轻松覆盖GPO控制的设置，那么这种设置有什么好处？这强调了执行策略的目的是仅为了保护那些**不知情**的用户免受**无意中**运行**匿名**脚本的风险。
- en: The execution policy isn’t intended to stop an informed user from doing anything
    intentional. It’s not that kind of security setting.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 执行策略的目的是不让一个知情用户有意地做任何事情。它不是那种类型的安全设置。
- en: In fact, a smart malware coder could as easily access the .NET Framework functionality
    directly, without going to the trouble of using PowerShell as a middleman. Or
    to put it another way, if an unauthorized user has admin rights to your computer
    and can run arbitrary code, you’re already in trouble.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，一个聪明的恶意软件编写者可以同样容易地直接访问.NET Framework功能，而无需麻烦地使用PowerShell作为中间人。或者换句话说，如果一个未经授权的用户拥有你的计算机的管理权限并且可以运行任意代码，那么你已经在麻烦之中了。
- en: Microsoft recommends that you use `RemoteSigned` when you want to run scripts
    and that you use it only on computers where scripts must be executed. According
    to Microsoft, all other computers should be left at `Restricted`. They say that
    `RemoteSigned` provides a good balance between security and convenience. `AllSigned`
    is stricter but requires all of your scripts to be digitally signed. The PowerShell
    community as a whole is more divided, with a range of opinions on what a good
    execution policy is. For now, we’ll go with Microsoft’s recommendation and let
    you explore the topic more on your own, if you wish.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 微软建议你在需要运行脚本时使用`RemoteSigned`，并且只在必须执行脚本的计算机上使用它。根据微软的说法，所有其他计算机应保持为`Restricted`。他们说，`RemoteSigned`在安全性和便利性之间提供了良好的平衡。"AllSigned"更严格，但要求所有脚本都必须进行数字签名。PowerShell社区整体上意见分歧，对良好的执行策略有各种看法。现在，我们将遵循微软的建议，并让你自己进一步探索这个话题，如果你愿意的话。
- en: Note Plenty of experts, including Microsoft’s own “Scripting Guy,” suggest using
    the `Unrestricted` setting for `ExecutionPolicy`. Their feeling is that the feature
    doesn’t provide a layer of security, and you shouldn’t give yourself false confidence
    that it’s protecting you from anything.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：许多专家，包括微软自己的“脚本侠”，建议使用`ExecutionPolicy`的`Unrestricted`设置。他们的观点是，这个功能并不提供一层安全保护，你不应该对自己产生错误的信心，认为它在保护你免受任何威胁。
- en: 4.2 Not scripting, but running commands
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 不编写脚本，而是运行命令
- en: PowerShell, as its name indicates, is a *shell*. Other shells you’ve probably
    used or at least heard of include cmd.exe, Bash, Zsh, fish, and ksh. PowerShell
    is not only a shell but also a *scripting language*—but not in the way JavaScript
    or Python are.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，PowerShell是一个*shell*。你可能使用过或至少听说过其他shell，包括cmd.exe、Bash、Zsh、fish和ksh。PowerShell不仅是一个shell，还是一个*脚本语言*——但并非像JavaScript或Python那样。
- en: With those languages, as with most programming languages, you sit down in front
    of a text editor or integrated development environment (IDE) and type a series
    of keywords to form a script. You save that file, and perhaps double-click it
    to test it. PowerShell can work like that, but that’s not necessarily the main
    usage pattern for PowerShell, particularly when you’re getting started. With PowerShell,
    you type a command, add a few parameters to customize the command’s behavior,
    press Enter, and immediately see your results.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些语言，就像大多数编程语言一样，你会在文本编辑器或集成开发环境（IDE）前坐下，输入一系列关键字来形成一个脚本。你保存该文件，也许双击它来测试它。PowerShell
    可以这样做，但这并不是 PowerShell 的主要使用模式，尤其是当你刚开始的时候。使用 PowerShell，你输入一个命令，添加一些参数来定制命令的行为，按
    Enter 键，然后立即看到你的结果。
- en: 'Eventually, you’ll get tired of typing the same command (and its parameters)
    over and over again, so you’ll copy and paste it all into a text file. Give that
    file a .ps1 filename extension, and you suddenly have a *PowerShell script*. Now,
    instead of typing the command over and over, you run that script, and it executes
    whatever commands are inside. It’s typically far less complex than writing a program
    in a full programming language. In fact, it’s a pattern similar to that used by
    UNIX administrators for years. Common UNIX/Linux shells, such as Bash, have a
    similar approach: run commands until you get them right, and then paste them into
    a text file and call it a *script*.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你会厌倦一遍又一遍地输入相同的命令（及其参数），所以你会把它全部复制粘贴到一个文本文件中。给这个文件一个 .ps1 文件扩展名，你突然就有了 *PowerShell
    脚本*。现在，你不再需要一遍又一遍地输入命令，而是运行那个脚本，它会执行里面的任何命令。这通常比用完整的编程语言编写程序要简单得多。实际上，它是一种与 UNIX
    管理员多年来使用的模式相似的模板。常见的 UNIX/Linux shell，如 Bash，也有类似的方法：运行命令直到你做对为止，然后将它们粘贴到文本文件中，并称之为
    *脚本*。
- en: 'Don’t get us wrong: You can get as complex as you need to with PowerShell.
    It does support the same kind of usage patterns as Python and other scripting
    or programming languages. PowerShell gives you access to the full underlying power
    of .NET Core, and we’ve seen PowerShell “scripts” that were practically indistinguishable
    from a C# program written in Visual Studio. PowerShell supports these different
    usage patterns because it’s intended to be useful to a wide range of audiences.
    The point is that just because it *supports* that level of complexity doesn’t
    mean you *have* to use it at that level, and it doesn’t mean you can’t be extremely
    effective with less complexity.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请不要误解我们：你可以用 PowerShell 实现你需要的任何复杂程度。它确实支持与 Python 和其他脚本或编程语言相同的用法模式。PowerShell
    让你可以访问 .NET Core 的全部底层功能，我们见过几乎与在 Visual Studio 中编写的 C# 程序无法区分的 PowerShell “脚本”。PowerShell
    支持这些不同的用法模式，因为它旨在对广泛的受众都有用。重点是，尽管它 *支持* 那种复杂程度，但这并不意味着你 *必须* 在那个级别使用它，也不意味着你不能用更少的复杂性达到极高的效率。
- en: Here’s an analogy. You probably drive a car. If you’re like us, changing the
    oil is the most complex mechanical task you’ll ever do with your car. We’re not
    car geeks and can’t rebuild an engine. We also can’t do those cool, high-speed
    J-turns that you see in the movies. You’ll never see us driving a car on a closed
    course in a car commercial. But the fact that we’re not professional stunt drivers
    doesn’t stop us from being extremely effective drivers at a less complex level.
    Someday we might decide to take up stunt driving for a hobby (our insurance companies
    will be thrilled), and at that point we’ll need to learn a bit more about how
    our cars work, master some new skills, and so on. The option is always there for
    us to grow into. But for now, we’re happy with what we can accomplish as normal
    drivers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个类比。你可能开车。如果你像我们一样，更换机油是你用汽车做的最复杂的机械任务。我们不是汽车爱好者，不能重新组装发动机。我们也不能做那些你在电影中看到的高速
    J 转弯。你永远不会看到我们在汽车商业广告中在封闭赛道上开车。但不是专业特技驾驶员的事实并不会阻止我们在更简单的层面上成为极其有效的驾驶员。总有一天我们可能会决定把特技驾驶作为一项爱好（我们的保险公司会非常高兴），到那时我们需要学习更多关于汽车如何工作的知识，掌握一些新技能，等等。这个选择总是存在的，让我们有机会成长。但到目前为止，我们对我们作为普通驾驶员所能完成的事情感到满意。
- en: For now, we’ll stick with being normal “PowerShell drivers,” operating the shell
    at a lower level of complexity. Believe it or not, users at this level are the
    primary target audience for PowerShell, and you’ll find that you can do a lot
    of incredible stuff without going beyond this level. All you need to do is master
    the ability to run commands within the shell, and you’re on your way.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将坚持作为普通的“PowerShell 驾驶员”，在较低复杂性的层面上操作 shell。信不信由你，处于这个级别的用户是 PowerShell
    的主要目标受众，你会发现你可以在不超出这个级别的情况下做很多令人难以置信的事情。你所需要做的就是掌握在 shell 中运行命令的能力，然后你就上路了。
- en: 4.3 The anatomy of a command
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 命令的结构
- en: Figure 4.3 shows the basic anatomy of a complex PowerShell command. We call
    this the *full-form* syntax of a command. We’re showing a somewhat complex command
    here, so you can see all of the things that might show up.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 显示了一个复杂 PowerShell 命令的基本结构。我们称这为命令的 *完整形式* 语法。这里我们展示了一个相对复杂的命令，这样你可以看到所有可能出现的元素。
- en: '![](Images/CH04_F03_Plunk.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH04_F03_Plunk.png)'
- en: Figure 4.3 The anatomy of a PowerShell command
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 PowerShell 命令的结构
- en: 'To make sure you’re completely familiar with PowerShell’s rules, let’s cover
    each of the elements in the previous figure in more detail:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你完全熟悉 PowerShell 的规则，让我们更详细地介绍前一个图中的每个元素：
- en: The cmdlet name is `Get-Command`. PowerShell cmdlets always have this verb-noun
    naming format. We explain more about cmdlets in the next section.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cmdlet 名称是 `Get-Command`。PowerShell cmdlet 总是采用这种动词-名词的命名格式。我们将在下一节中更详细地解释 cmdlet。
- en: The first parameter name is `-Verb`, and it’s being given the value `Get`. Because
    the value doesn’t contain any spaces or punctuation, it doesn’t need to be in
    quotation marks.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数名称是 `-Verb`，并且被赋予的值是 `Get`。因为该值不包含任何空格或标点符号，所以它不需要用引号括起来。
- en: 'The second parameter name is `-Module`, and it’s being given two values: `PSReadLine`
    and `PowerShellGet`. These are in a comma-separated list, and because neither
    value contains spaces or punctuation, neither value needs to be inside quotation
    marks.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数名称是 `-Module`，并且被赋予两个值：`PSReadLine` 和 `PowerShellGet`。这些值以逗号分隔，并且因为这两个值都不包含空格或标点符号，所以这两个值都不需要用引号括起来。
- en: The final parameter, `-Syntax`, is a switch parameter. That means it doesn’t
    get a value; specifying the parameter is sufficient.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个参数 `-Syntax` 是一个切换参数。这意味着它不需要值；指定参数就足够了。
- en: Note that there’s a mandatory space between the command name and the first parameter.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，命令名称和第一个参数之间必须有一个强制性的空格。
- en: Parameter names always start with a dash (`-`).
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数名称始终以破折号 (`-`) 开头。
- en: There’s a mandatory space after the parameter name and between the parameter’s
    value and the next parameter name.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数名称之后和参数的值与下一个参数名称之间必须有一个强制性的空格。
- en: There’s no space between the dash (`-`) that precedes a parameter name and the
    parameter name itself.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在参数名称前缀的破折号 (`-`) 和参数名称本身之间没有空格。
- en: Nothing here is case sensitive.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里没有任何内容是大小写敏感的。
- en: Get used to these rules. Start being sensitive about accurate, neat typing.
    Paying attention to spaces and dashes and other rules will minimize the silly
    errors that PowerShell throws at you.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 习惯这些规则。开始对准确、整洁的输入敏感。注意空格、破折号和其他规则将最大限度地减少 PowerShell 向你抛出的愚蠢错误。
- en: 4.4 The cmdlet naming convention
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 cmdlet 命名约定
- en: 'First, let’s discuss some terminology. As far as we know, we’re the only ones
    who use this terminology in everyday conversation, but we do it consistently,
    so we may as well explain:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们讨论一些术语。据我们所知，我们是在日常对话中唯一使用这些术语的人，但我们使用得很一致，所以我们不妨解释一下：
- en: A *cmdlet* is a native PowerShell command-line utility. These exist only inside
    PowerShell and are written in a .NET Core language such as C#. The word *cmdlet*
    is unique to PowerShell, so if you add it to your search keywords on your favorite
    search engine, the results you get back will be mainly PowerShell related. The
    word is pronounced *command-let*.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *cmdlet* 是一个本地的 PowerShell 命令行实用程序。这些只存在于 PowerShell 中，并且是用如 C# 这样的 .NET
    Core 语言编写的。*cmdlet* 这个词是 PowerShell 独有的，所以如果你在你的首选搜索引擎中添加它作为搜索关键词，你得到的结果将主要是与
    PowerShell 相关的。这个词的发音是 *command-let*。
- en: A *function* can be similar to a cmdlet, but rather than being written in a
    .NET language, functions are written in PowerShell’s own scripting language.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *函数* 可以与 cmdlet 类似，但与用 .NET 语言编写不同，函数是用 PowerShell 自己的脚本语言编写的。
- en: An *application* is any kind of external executable, including command-line
    utilities such as `ping` and `ipconfig`.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *应用程序* 是任何类型的可执行外部程序，包括如 `ping` 和 `ipconfig` 这样的命令行实用程序。
- en: '*Command* is the generic term that we use to refer to any or all of the preceding
    terms.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*命令* 是我们用来指代上述任何或所有术语的通用术语。'
- en: Microsoft has established a naming convention for cmdlets. That same naming
    convention *should* be used for functions, too, although Microsoft can’t force
    anyone but its own employees to follow that rule.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 微软为 cmdlet 建立了一个命名约定。同样的命名约定 *应该* 也用于函数，尽管微软无法强迫除其员工之外的人遵守该规则。
- en: 'The rule is this: Names start with a standard verb, such as `Get` or `Set`
    or `New` or `Pause`. You can run `Get-Verb` to see a list of approved verbs (you’ll
    see about 100, although only about a dozen are common). After the verb is a dash,
    followed by a singular noun, such as `Job` or `Process` or `Item`. Developers
    get to make up their own nouns, so there’s no *Get-Noun* cmdlet to display them
    all.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 规则是这样的：名称以标准动词开头，例如 `Get` 或 `Set` 或 `New` 或 `Pause`。你可以运行 `Get-Verb` 来查看批准的动词列表（你会看到大约
    100 个，尽管只有大约 12 个是常见的）。动词之后是一个破折号，后面跟着一个单数名词，例如 `Job` 或 `Process` 或 `Item`。开发者可以自己创造名词，因此没有
    `Get-Noun` cmdlet 来显示它们。
- en: 'What’s the big deal about this rule? Well, suppose we told you that there were
    cmdlets named `Start-Job`, `Get-Job`, `Get-Process`, `Stop-Process`, and so forth.
    Could you guess what command would start a new process on your machine? Could
    you guess what command would modify an Azure virtual machine (VM)? If you guessed
    `Start-Process`, you got the first one right. If you guessed `Set-VM`, you were
    close: it’s `Set-AzVM`, and you’ll find the command on Azure VMs in the Az.Compute
    module (we will go over modules in chapter 7). All the Azure commands use that
    same prefix of `Az`, followed by the noun that the command messes with. The point
    is that by having this consistent naming convention with a limited set of verbs,
    it becomes possible for you to guess at command names, and you could then use
    `Help` or `Get-Command`, along with wildcards, to validate your guess. It becomes
    easier for you to figure out the names of the commands you need, without having
    to run to Google or Bing every time.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则有什么大不了的？好吧，假设我们告诉你有一些名为 `Start-Job`、`Get-Job`、`Get-Process`、`Stop-Process`
    等的 cmdlet。你能猜出在您的机器上启动新进程的命令是什么吗？你能猜出修改 Azure 虚拟机 (VM) 的命令是什么吗？如果你猜的是 `Start-Process`，那么第一个就猜对了。如果你猜的是
    `Set-VM`，你很接近了：它是 `Set-AzVM`，你可以在 Az.Compute 模块中找到这个命令（我们将在第 7 章中介绍模块）。所有的 Azure
    命令都使用相同的 `Az` 前缀，后面跟着命令所操作的名词。重点是，通过使用有限动词集的这种一致命名约定，你可以猜测命令名称，然后你可以使用 `Help`
    或 `Get-Command`，结合通配符，来验证你的猜测。这样，你就可以更容易地找出所需的命令名称，而无需每次都跑到 Google 或 Bing 上去。
- en: NOTE Not all of the so-called verbs are really verbs. Although Microsoft officially
    uses the term *verb-noun naming convention*, you’ll see “verbs” like `New`, `Where`,
    and so forth. You’ll get used to it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：并非所有所谓的动词都是动词。尽管微软官方使用术语 *verb-noun 命名约定*，但你也会看到像 `New`、`Where` 这样的“动词”。你会习惯它们的。
- en: '4.5 Aliases: Nicknames for commands'
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 别名：命令的昵称
- en: Although PowerShell command names can be nice and consistent, they can also
    be long. A command name such as `Remove-AzStorageTableStoredAccessPolicy` is a
    lot to type, even with tab completion. Although the command name is clear—looking
    at it, you can probably guess what it does—it’s an *awful* lot to type.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 PowerShell 命令名称可以很优雅且一致，但它们也可以很长。像 `Remove-AzStorageTableStoredAccessPolicy`
    这样的命令名称要输入很多，即使有自动补全功能也是如此。尽管命令名称很清晰——看一眼，你大概能猜出它做什么——但它要输入的字符实在太多了。
- en: 'That’s where PowerShell aliases come in. An *alias* is nothing more than a
    nickname for a command. Tired of typing `Get-Process`? Try this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 PowerShell 别名的作用所在。别名不过是命令的一个昵称。厌倦了输入 `Get-Process`？试试这个：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now you know that `gps` is an alias for `Get-Process`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了 `gps` 是 `Get-Process` 的别名。
- en: When using an alias, the command works in the same way. Parameters are the same;
    everything is the same—the command name is just shorter.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用别名时，命令的工作方式相同。参数相同；一切都是相同的——只是命令名称更短。
- en: 'If you’re staring at an alias (folks on the internet tend to use them as if
    we’ve all memorized the hundreds of built-in aliases) and can’t figure out what
    it is, ask help:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在查看一个别名（互联网上的人倾向于像我们都记住了数百个内置别名一样使用它们），却无法弄清楚它是什么，请寻求帮助：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When asked for help about an alias, the help system will always display the
    help for the full command, which includes the command’s complete name.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要关于别名帮助时，帮助系统将始终显示完整命令的帮助，这包括命令的完整名称。
- en: Above and beyond
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅如此
- en: You can create your own aliases by using `New-Alias`, export a list of aliases
    by using `Export-Alias`, or even import a list of previously created aliases by
    using `Import-Alias`. When you create an alias, it lasts only as long as your
    current shell session. Once you close the window, it’s gone. That’s why you might
    want to export them, so that you can use them in another PowerShell session.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `New-Alias` 创建自己的别名，使用 `Export-Alias` 导出别名列表，或者甚至使用 `Import-Alias` 导入之前创建的别名列表。当您创建一个别名时，它只持续到您的当前shell会话。一旦关闭窗口，它就会消失。这就是为什么您可能想要导出它们，以便在另一个PowerShell会话中使用。
- en: We tend to avoid creating and using custom aliases, though, because they’re
    not available to anyone but the person who made them. If someone can’t look up
    what `xtd` does, we’re creating confusion and incompatibility.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们倾向于避免创建和使用自定义别名，因为它们只对创建它们的人可用。如果某人无法查找 `xtd` 做什么，我们就会造成混淆和不兼容。
- en: And `xtd` doesn’t do anything. It’s a fake alias we made up.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 而 `xtd` 什么也不做。这是我们编造的一个假别名。
- en: We must point out, because PowerShell is now available on non-Windows operating
    systems, that its concept of *alias* is a little different from an alias in, say,
    Bash. In Bash, an alias can be a kind of shortcut for running a command *that
    includes a bunch of parameters.* PowerShell doesn’t behave that way. An alias
    is *only* a nickname for the command name, and the alias can’t include any predetermined
    parameters.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须指出，由于PowerShell现在可在非Windows操作系统上使用，因此其关于*别名*的概念与Bash中的别名略有不同。在Bash中，别名可以是运行包含大量参数的命令的一种快捷方式。PowerShell的行为并非如此。别名*仅*是命令名的昵称，别名不能包含任何预定义的参数。
- en: 4.6 Taking shortcuts
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6 使用快捷方式
- en: Here’s where PowerShell gets tricky. We’d love to tell you that everything we’ve
    shown you so far is the only way to do things, but we’d be lying. And, unfortunately,
    you’re going to be out on the internet stealing (well, repurposing) other people’s
    examples, and you’ll need to know what you’re looking at.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是PowerShell变得复杂的地方。我们很乐意告诉您，到目前为止我们所展示的只是做事的唯一方法，但我们会撒谎。不幸的是，您将不得不在互联网上寻找（好吧，重新利用）别人的例子，您需要知道您在查看什么。
- en: In addition to aliases, which are shorter versions of command names, you can
    also take *shortcuts* with parameters. You have three ways to do this, each potentially
    more confusing than the last.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 除了别名，即命令名的简短版本之外，您还可以使用参数来缩短操作。您有三种方法来做这件事，每种方法都可能比前一种更令人困惑。
- en: 4.6.1 Truncating parameter names
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.1 截断参数名称
- en: PowerShell doesn’t force you to type out entire parameter names. As you might
    recall from chapter 3, instead of typing `-ComputerName`, for example, you could
    go with `-comp`. The rule is that you have to type enough of the name for PowerShell
    to be able to distinguish it. If there’s the `-ComputerName` parameter, the `-Common`
    parameter, and the `-Composite` parameter, you’d have to type at least `-compu`,
    `-comm`, and `-compo`, because that’s the minimum number of letters necessary
    to uniquely identify each.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell不会强迫您输入完整的参数名称。如您在第3章中可能记得的，例如，您可以使用 `-comp` 而不是 `-ComputerName`。规则是您必须输入足够多的名称，以便PowerShell能够区分它。如果有
    `-ComputerName` 参数、`-Common` 参数和 `-Composite` 参数，您至少需要输入 `-compu`、`-comm` 和 `-compo`，因为这是唯一识别每个参数所需的最小字母数。
- en: If you must take shortcuts, this isn’t a bad one to take, if you can remember
    to press Tab after typing that minimum-length parameter so that PowerShell can
    finish typing the rest of it for you.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您必须使用快捷方式，这是一个不错的选择，如果您记得在输入最小长度的参数后按Tab键，以便PowerShell为您完成剩余的输入。
- en: 4.6.2 Using parameter name aliases
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.2 使用参数名称别名
- en: 'Parameters can also have their own aliases, although they can be terribly difficult
    to find, as they aren’t displayed in the help files or anyplace else convenient.
    For example, the `Get-Process` command has the `-ErrorAction` parameter. To discover
    its aliases, you run this command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 参数也可以有自己的别名，尽管它们可能非常难以找到，因为它们没有在帮助文件或其他方便的地方显示。例如，`Get-Process` 命令有 `-ErrorAction`
    参数。要发现其别名，您运行以下命令：
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We’ve boldfaced the command and parameter names; replace these with whatever
    command and parameter you’re curious about. In this case, the output reveals that
    `-ea` is an alias for `-ErrorAction`, so you could run this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经加粗了命令和参数名称；用您好奇的任何命令和参数替换这些。在这种情况下，输出显示 `-ea` 是 `-ErrorAction` 的别名，因此您可以运行以下命令：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tab completion will show you the `-ea` alias; if you typed `Get-Process -e`
    and started pressing Tab, it’d show up. But the help for the command doesn’t display
    `-ea` at all, and tab completion doesn’t indicate that `-ea` and `-ErrorAction`
    are the same thing.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 完成提示将显示 `-ea` 别名；如果您输入 `Get-Process -e` 并开始按 Tab 键，它就会出现。但该命令的帮助文档根本不显示 `-ea`，完成提示也不表明
    `-ea` 和 `-ErrorAction` 是同一件事。
- en: Note These are called *common parameters*. You can run the command `Get-Help
    about_CommonParamaters` to read more about them.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这些被称为 *通用参数*。您可以通过运行命令 `Get-Help about_CommonParameters` 来了解更多关于它们的信息。
- en: 4.6.3 Using positional parameters
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.3 使用位置参数
- en: 'When you’re looking at a command’s syntax in its help file, you can spot positional
    parameters easily:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在帮助文件中查看命令的语法时，您可以轻松地识别位置参数：
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, both `-Path` and `-Filter` are positional, and you know that because
    the parameter name and the accepted input is contained within square brackets.
    A clearer explanation is available in the full help (`help` `Get-ChildItem` `-Full`,
    in this case), which looks like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`-Path` 和 `-Filter` 都是位置参数，您知道这一点是因为参数名称和接受的输入包含在方括号内。更详细的解释可以在完整帮助文档中找到（在这种情况下是
    `help Get-ChildItem -Full`），其内容如下：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'That’s a clear indication that the `-Path` parameter is in position 0, which
    means it’s the first parameter after the cmdlet. For positional parameters, you
    don’t have to type the parameter name; you can provide its value in the correct
    position. For example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个明确的指示，说明 `-Path` 参数位于位置 0，这意味着它是 cmdlet 后的第一个参数。对于位置参数，您不需要输入参数名称；您可以在正确的位置提供其值。例如：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'That’s the same as this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下内容相同：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The problem with positional parameters is that you’re taking on the responsibility
    of remembering what goes where. You must type all positional parameters first,
    in the correct order, before you can add any named (nonpositional) parameters.
    If you mix up the parameter order, the command fails. For simple commands such
    as `Dir`, which you’ve probably used for years, typing `-Path` feels weird, and
    almost nobody does it. But for more-complex commands, which might have three or
    four positional parameters in a row, it can be tough to remember what goes where.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 位置参数的问题在于您需要记住每个参数的位置。在您能够添加任何命名（非位置）参数之前，您必须首先以正确的顺序输入所有位置参数。如果您搞错了参数顺序，命令就会失败。对于像
    `Dir` 这样的简单命令，您可能已经使用了多年，输入 `-Path` 会感觉有些奇怪，而且几乎没有人这样做。但对于更复杂的命令，可能连续有三个或四个位置参数，记住每个参数的位置可能会很困难。
- en: 'For example, this is a bit difficult to read and interpret:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这个版本有点难以阅读和理解：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This version, which uses full cmdlet name and parameter names, is easier to
    follow:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用完整 cmdlet 名称和参数名称的这个版本更容易理解：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This version, which puts the parameters in a different order, is allowed when
    you use the parameter names:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用参数名称时，这种将参数按不同顺序排列的版本是允许的：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We tend to recommend against using positional (unnamed) parameters unless you’re
    banging out something quick and dirty at the command line. In anything that will
    persist, such as a PowerShell script file or a blog post, include all of the parameter
    names. We do that as much as possible in this book, except in a few instances
    where we have to shorten the command line to make it fit within the printed page.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们倾向于不建议使用位置（未命名）参数，除非您在命令行上快速地执行一些粗略的工作。在所有将持久存在的操作中，例如 PowerShell 脚本文件或博客文章，都应包含所有参数名称。在这本书中，我们尽可能这样做，但在一些必须缩短命令行以适应打印页面的情况下，我们会这样做。
- en: 4.7 Support for external commands
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.7 对外部命令的支持
- en: So far, all of the commands you’ve run in the shell (at least the ones we’ve
    suggested that you run) have been built-in cmdlets. Over 2,900 cmdlets come built
    into PowerShell on your Windows machine and over 200 on your Linux or macOS machine.
    You can add more—products such as Azure PowerShell, AWS PowerShell, and SQL Server
    all come with add-ins that include hundreds of additional cmdlets.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您在 shell 中运行的（至少是我们建议您运行的）所有命令都是内置 cmdlet。在您的 Windows 机器上，PowerShell 内置了超过
    2,900 个 cmdlet，在您的 Linux 或 macOS 机器上则超过 200 个。您可以添加更多——例如 Azure PowerShell、AWS
    PowerShell 和 SQL Server 等产品都附带包含数百个额外 cmdlet 的插件。
- en: But you’re not limited to PowerShell cmdlets. You can also use the same external
    command-line utilities that you’ve probably been using for years, including `ping`,
    `nslookup`, `ifconfig` or `ipconfig`, and so forth. Because these aren’t native
    PowerShell cmdlets, you use them the same way that you always have. Go ahead and
    try a few old favorites right now.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 但你不仅限于PowerShell cmdlets。你也可以使用你可能已经使用了多年的相同外部命令行工具，包括`ping`、`nslookup`、`ifconfig`或`ipconfig`等等。因为这些不是本地的PowerShell
    cmdlets，所以你使用它们的方式和你一直使用的方式相同。现在就试试几个老牌的喜欢的工具吧。
- en: It’s the same story on non-Windows operating systems. You can use `grep`, `bash`,
    `sed`, `awk`, `ping`, and whatever other existing command-line tools you may have.
    They’ll run normally, and PowerShell will display their results the same way that
    your old shell (e.g., Bash) would have.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在非Windows操作系统上也是同样的情况。你可以使用`grep`、`bash`、`sed`、`awk`、`ping`以及其他你可能拥有的现有命令行工具。它们将正常运行，PowerShell将以你的旧shell（例如Bash）相同的方式显示它们的结果。
- en: Try it Now Try running some external command-line utilities that you’ve used
    previously. Do they work the same? Do any of them fail?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试运行一些之前使用过的外部命令行工具。它们是否按预期工作？是否有任何失败的情况？
- en: 'This section illustrates an important lesson: with PowerShell, Microsoft (perhaps
    for the first time ever) isn’t saying, “You have to start over and learn everything
    all over again.” Instead, Microsoft is saying, “If you already know how to do
    something, keep doing it that way. We’ll try to provide you with better and more
    complete tools going forward, but what you already know will still work.”'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分说明了重要的一课：使用PowerShell时，Microsoft（可能是有史以来第一次）并没有说，“你必须从头开始，重新学习一切。”相反，Microsoft说的是，“如果你已经知道如何做某事，就继续那样做。我们将努力为你提供更好、更完整的工具，但你所知道的东西仍然会有效。”
- en: In some instances, Microsoft has provided better tools than some of the existing,
    older ones. For example, the native `Test-Connection` cmdlet provides more options
    and more-flexible output than the old, external `ping` command. But if you know
    how to use `ping`, and it’s solving whatever need you have, go right on using
    it. It’ll work fine from within PowerShell.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，Microsoft提供的工具比一些现有的、较旧的工具更好。例如，本地的`Test-Connection` cmdlet提供了比旧的、外部的`ping`命令更多的选项和更灵活的输出。但如果你知道如何使用`ping`，并且它解决了你的需求，那就继续使用它。在PowerShell内部它也能正常工作。
- en: 'All that said, we do have to deliver a harsh truth: not every external command
    will work flawlessly from within PowerShell, at least not without a little tweaking
    on your part. That’s because PowerShell’s parser—the bit of the shell that reads
    what you’ve typed and tries to figure out what you want the shell to do—doesn’t
    always guess correctly. Sometimes you’ll type an external command, and PowerShell
    will mess up, start spitting out errors, and generally not work.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们不得不传达一个残酷的事实：并非每个外部命令都能在PowerShell内部完美运行，至少不是不需要你稍作调整。这是因为PowerShell的解析器——读取你输入的内容并试图弄清楚你想要shell做什么的那部分shell——并不总是猜得正确。有时你会输入一个外部命令，PowerShell会出错，开始输出错误信息，并且通常无法正常工作。
- en: 'For example, things can get tricky when an external command has a lot of parameters—that’s
    where you’ll see PowerShell break the most. We won’t dive into the details of
    why it works, but here’s a way to run a command that ensures that its parameters
    will work properly:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当外部命令有很多参数时，事情可能会变得复杂——这就是你看到PowerShell出错最多的地方。我们不会深入探讨为什么它会这样工作，但这里有一个运行命令的方法，可以确保其参数能够正确工作：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This supposes that you have an external command named `func`. (This real-life
    command-line utility is used to interact with Azure Functions.) If you’ve never
    used it or don’t have it, that’s fine; most old-school command-line utilities
    work the same way, so this is still a good teaching example. It accepts several
    parameters:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这假设你有一个名为`func`的外部命令。（这个现实生活中的命令行工具用于与Azure Functions交互。）如果你从未使用过它或者没有它，那没关系；大多数老式的命令行工具工作方式相同，所以这仍然是一个很好的教学示例。它接受几个参数：
- en: '`"new"` here is the action you want to take, and `–new`, `init`, `start`, and
    `logs` are the options.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"new"在这里是指你想要执行的操作，而`–new`、`init`、`start`和`logs`是选项。'
- en: '`-l` is for the language you want the function to be.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-l`是指你希望函数使用的语言。'
- en: '`-t` is for the template you want to use.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-t`是指你想要使用的模板。'
- en: '`-n` is for the name of the function.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-n`是指函数的名称。'
- en: What we’ve done is put all the various elements—the executable path and name,
    as well as all of the parameter values—into placeholders, which start with the
    `$` character. That forces PowerShell to treat those values as single units, rather
    than trying to parse them to see whether any contain commands or special characters.
    Then we used the invocation operator (`&`), passing it the executable name, all
    of the parameters, and the parameters’ values. That pattern will work for almost
    any command-line utility that’s being grumpy about running within PowerShell.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是将所有各种元素——可执行路径和名称，以及所有参数值——放入占位符中，这些占位符以 `$` 字符开始。这迫使 PowerShell 将这些值视为单个单元，而不是尝试解析它们以查看是否包含命令或特殊字符。然后我们使用了调用运算符
    (`&`)，传递给它可执行名称、所有参数以及参数的值。这种模式几乎适用于任何在 PowerShell 中运行时脾气不好的命令行工具。
- en: 'Sound complicated? Well, here’s some good news: In PowerShell v3 and later,
    you don’t have to mess around so much. Just add two dashes and a percent symbol
    in front of anything, and PowerShell won’t even try to parse it; it’ll just pass
    it right to the command-line utility that you’re using. To be absolutely clear,
    this means you won’t be able to pass variables as parameter values.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来很复杂吗？好吧，这里有一些好消息：在 PowerShell v3 及以后的版本中，你不必那么麻烦。只需在前面加上两个连字符和一个百分号，PowerShell
    就不会尝试解析它；它将直接传递到你正在使用的命令行工具。为了绝对清楚，这意味着你将无法将变量作为参数值传递。
- en: 'Here’s a quick example of what will fail:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个快速示例，说明什么会失败：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We tried to run the command-line utility `func` to list all of our Azure functions
    with the name `"MyFunctionApp"`, but if we explicitly state what we want, PowerShell
    will pass all the parameters to the underlying command without trying to do anything
    with them:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试运行命令行工具 `func` 来列出所有名为 `"MyFunctionApp"` 的 Azure 函数，但如果我们明确指出我们想要什么，PowerShell
    将将所有参数传递给底层命令，而不会尝试对它们做任何事情：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Hopefully this isn’t something you’ll need to do often.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这不会是你要经常做的事情。
- en: 4.8 Dealing with errors
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.8 处理错误
- en: It’s inevitable that you’ll see some ugly red text as you start working with
    PowerShell—and probably from time to time even after you’re an expert-level shell
    user. Happens to us all. But don’t let the red text stress you out. (Personally,
    it takes us back to high school English class and poorly written essays, so *stress*
    is putting it mildly.)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用 PowerShell 的时候，你不可避免地会看到一些难看的红色文字——甚至在你成为专家级 shell 用户之后，可能时不时也会遇到。我们都有过这种情况。但不要让红色文字让你感到压力。（就我个人而言，它让我想起了高中英语课和写得不好的作文，所以“压力”这个词用得有点轻了。）
- en: The alarming red text aside, PowerShell’s error messages have improved greatly
    over the years (a lot of this has to do with the fact that the error messages
    are also open sourced). For example, as shown in figure 4.4, they try to show
    you exactly where PowerShell ran into trouble.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 除了令人警觉的红色文字外，PowerShell 的错误消息在多年中得到了极大的改进（这很大程度上要归功于错误消息也是开源的）。例如，如图 4.4 所示，它们试图显示
    PowerShell 碰到的确切问题。
- en: '![](Images/CH04_F04_Plunk.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH04_F04_Plunk.png)'
- en: Figure 4.4 Interpreting a PowerShell error message
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 解释 PowerShell 错误消息
- en: 'Most error messages are easy to understand. In figure 4.4, right at the beginning,
    it’s saying, “You typed `get`, and I have no idea what that means.” That’s because
    we typed the command name wrong: it’s supposed to be `Get-Command`, not `Get`
    `Command`. Oops. What about figure 4.5?'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数错误消息都很容易理解。在图 4.4 中，一开始就说了，“你输入了 `get`，我不知道那是什么意思。”那是因为我们输入了错误的命令名：它应该是 `Get-Command`，而不是
    `Get` `Command`。哎呀。图 4.5 呢？
- en: '![](Images/CH04_F05_Plunk.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH04_F05_Plunk.png)'
- en: Figure 4.5 What’s a “second path fragment”?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 什么是“第二个路径片段”？
- en: The error message in figure 4.5, “Second path fragment must not be a drive or
    UNC name,” is confusing. What second path? We didn’t type a second path. We typed
    one path, `C:\Users\James` and a command-line parameter, `\s`. Right?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 中的错误消息“第二个路径片段不能是驱动器或 UNC 名称”令人困惑。什么第二个路径？我们没有输入第二个路径。我们输入了一个路径，`C:\Users\James`
    和一个命令行参数，`\s`。对吗？
- en: Well, no. One of the easiest ways to solve this kind of problem is to read the
    help and to type the command out completely. If we’d typed `Get-ChildItem` `-Path
    C:\Users\james`, we’d have realized that `\s` isn’t the correct syntax. We meant
    `-Recurse`. Sometimes the error message might not seem helpful—and if it seems
    like you and PowerShell are speaking different languages, you are. PowerShell
    obviously isn’t going to change its language, so you’re probably the one in the
    wrong, and consulting the help and spelling out the entire command, parameters
    and all, is often the quickest way to solve the problem.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，不是这样。解决这类问题最简单的方法之一是阅读帮助文档，并完整地输入命令。如果我们输入了 `Get-ChildItem -Path C:\Users\james`，我们会意识到
    `\s` 不是一个正确的语法。我们实际上想要的是 `-Recurse`。有时错误信息可能看起来并不有帮助——如果你觉得你和使用 PowerShell 说着不同的语言，那么你可能是错的。显然，PowerShell
    不会改变它的语言，所以你可能做错了，查阅帮助文档并完整地拼写整个命令（包括参数），通常是解决问题的最快方式。
- en: 4.9 Common points of confusion
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.9 常见混淆点
- en: Whenever it seems appropriate, we wrap up each chapter with a brief section
    that covers some of the common mistakes we see. The idea is to help you see what
    most often confuses other administrators like yourself and to avoid those problems—or
    at least to be able to find a solution for them—as you start working with the
    shell.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '每当适当的时候，我们都会在每个章节的末尾添加一个简短的章节，涵盖一些我们常见的错误。目的是帮助你看到最常使其他管理员（就像你一样）感到困惑的事情，并避免这些问题——或者至少在你开始使用外壳时能够找到解决方案。 '
- en: 4.9.1 Typing cmdlet names
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.9.1 输入 cmdlet 名称
- en: 'First up is the typing of cmdlet names. It’s always verb-noun, like `Get-Content`.
    All of these are options we’ll see newcomers try, but they won’t work:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，是 cmdlet 名称的输入。它们总是动词-名词的形式，比如 `Get-Content`。所有这些选项都是新入门者可能会尝试的，但它们都不会工作：
- en: '`Get Content`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`获取内容`'
- en: '`GetContent`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetContent`'
- en: '`Get=Content`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Get=Content`'
- en: '`Get_Content`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Get_Content`'
- en: Part of the problem comes from typos (e.g., `=` instead of `-`) and part from
    verbal laziness. We all pronounce the command as *Get Content*, verbally omitting
    the dash. But you have to type the dash.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 部分问题来自拼写错误（例如，`=` 代替 `-`），部分来自口头上的懒惰。我们都把命令读作 *获取内容*，口头省略了连字符。但你需要输入连字符。
- en: 4.9.2 Typing parameters
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.9.2 输入参数
- en: 'Parameters are also consistently written. Parameters, such as `-Recurse`, get
    a dash before their name. If the parameter has a value, a space will come between
    the parameter name and its value. You need to have spaces separating the cmdlet
    name from its parameters, and the parameters from each other. The following are
    correct:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 参数也是一致书写的。例如，参数 `-Recurse` 在其名称前有一个连字符。如果参数有值，参数名称和其值之间会有一个空格。你需要确保 cmdlet 名称与其参数之间、参数之间都有空格分隔。以下都是正确的：
- en: '`123`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`123`'
- en: '`Dir -rec` (the shortened parameter name is fine)'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dir -rec`（缩写参数名称是可以的）'
- en: '`New-PSDrive` `-name DEMO` `-psprovider` `FileSystem` `-root` `\\Server\Share`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`New-PSDrive -name DEMO -psprovider FileSystem -root \\Server\Share`'
- en: 'But these examples are all incorrect:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 但这些示例都是错误的：
- en: '`Dir-rec` (no space between alias and parameter)'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dir-rec`（别名和参数之间没有空格）'
- en: '`New-PSDrive -nameDEMO` (no space between parameter name and value)'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`New-PSDrive -nameDEMO`（参数名称和值之间没有空格）'
- en: '`New-PSDrive` `-name` `DEMO-psprovider` `FileSystem` (no space between the
    first parameter’s value and the second parameter’s name)'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`New-PSDrive -name DEMO-psprovider FileSystem`（第一个参数的值和第二个参数的名称之间没有空格）'
- en: PowerShell isn’t normally picky about upper- and lowercase, meaning that `dir`
    and `DIR` are the same, as are `-RECURSE` and `-recurse` and `-Recurse`. But the
    shell sure is picky about those spaces and dashes.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 通常不区分大小写，这意味着 `dir` 和 `DIR` 是相同的，同样 `-RECURSE` 和 `-recurse` 以及 `-Recurse`
    也是相同的。但外壳确实对那些空格和连字符很挑剔。
- en: 4.10 Lab
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.10 实验
- en: Note For this lab, you need PowerShell v7 or later running on Windows, macOS,
    or Linux.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：对于这个实验，您需要在 Windows、macOS 或 Linux 上运行 PowerShell v7 或更高版本。
- en: 'Using what you learned in this chapter, and in the previous chapter on using
    the help system, complete the following tasks in PowerShell:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本章以及上一章中关于使用帮助系统的内容，在 PowerShell 中完成以下任务：
- en: Display a list of running processes.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示正在运行的进程列表。
- en: Test the connection to google.com or bing.com without using an external command
    like `ping`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不使用像 `ping` 这样的外部命令测试到 google.com 或 bing.com 的连接。
- en: Display a list of all commands that are of the cmdlet type. (This is tricky—we’ve
    shown you `Get-Command`, but you need to read the help to find out how to narrow
    down the list as we’ve asked.)
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示所有命令列表，这些命令属于 cmdlet 类型。（这有点棘手——我们已经向你展示了 `Get-Command`，但你需要阅读帮助文档以了解如何缩小列表，正如我们要求的那样。）
- en: Display a list of all aliases.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示所有别名的列表。
- en: Make a new alias, so you can run `ntst` to run `netstat` from a PowerShell prompt.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的别名，这样你就可以从 PowerShell 提示符运行 `ntst` 来运行 `netstat`。
- en: Display a list of processes that begin with the letter *p.* Again, read the
    help for the necessary command—and don’t forget that the asterisk (`*`) is a near-universal
    wildcard in PowerShell.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示以字母 *p* 开头的进程列表。再次，阅读必要命令的帮助信息——并且不要忘记在 PowerShell 中星号 (`*`) 是一个几乎通用的通配符。
- en: Make a new folder (aka directory) using the `New-Item` cmdlet with the name
    of MyFolder1\. Then do it again and call it MyFolder2\. Use `Help` if you’re not
    familiar with `New-Item`.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `New-Item` 命令创建一个名为 MyFolder1 的新文件夹（即目录）。然后再次创建一个名为 MyFolder2 的文件夹。如果你不熟悉
    `New-Item`，请使用 `Help`。
- en: Remove the folders from step 7 in a single command. Use `Get-Command` to find
    a similar cmdlet to what we used in step 7—and don’t forget that the asterisk
    (`*`) is a near-universal wildcard in PowerShell.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用单个命令删除步骤 7 中的文件夹。使用 `Get-Command` 查找一个与步骤 7 中使用的类似 cmdlet——并且不要忘记在 PowerShell
    中星号 (`*`) 是一个几乎通用的通配符。
- en: We hope these tasks seem straightforward to you. If so—excellent. You’re taking
    advantage of your existing command-line skills to make PowerShell perform a few
    practical tasks for you. If you’re new to the command-line world, these tasks
    are a good introduction to what you’ll be doing in the rest of this book.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这些任务对你来说看起来很简单。如果是这样——太好了。你正在利用你现有的命令行技能，让 PowerShell 为你执行一些实际的任务。如果你是命令行世界的初学者，这些任务将是这本书其余部分将要介绍内容的良好入门。
- en: 4.11 Lab answers
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.11 实验答案
- en: '`Get-Process`'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get-Process`'
- en: '`Test-Connection google.com`'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Test-Connection google.com`'
- en: '`Get-Command -Type cmdlet`'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get-Command -Type cmdlet`'
- en: '`Get-Alias`'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get-Alias`'
- en: '`New-Alias -Name ntst -Value netstat`'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`New-Alias -Name ntst -Value netstat`'
- en: '`Get-Process -Name p*`'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get-Process -Name p*`'
- en: '`New-Item -Name MyFolder1 -Path c:\scripts -Type Directory;`'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`New-Item -Name MyFolder1 -Path c:\scripts -Type Directory;`'
- en: '`New-Item -Name MyFolder2 -Path c:\scripts -Type Directory`'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`New-Item -Name MyFolder2 -Path c:\scripts -Type Directory`'
- en: '`Remove-item C:\Scripts\MyFolder*`'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Remove-item C:\Scripts\MyFolder*`'
