- en: 11 Runtime type checking revisited and error handling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 重新审视运行时类型检查和错误处理
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Using the `Assert.IsInstanceOfType` test assertion
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Assert.IsInstanceOfType`测试断言
- en: Calling multiple repositories from a service class
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从服务类调用多个存储库
- en: Using the discard operator
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用丢弃运算符
- en: Using multiple `catch` blocks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个`catch`块
- en: Checking types at runtime with the `is` and `as` operators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`is`和`as`运算符在运行时检查类型
- en: After having implemented the database access layer in chapter 5 and the repository
    layer in chapters 6 through 9, we started to implement the `BookingService` in
    chapter 10\. I also introduced you to using mocks in unit testing, and we discussed
    the repository/service pattern. In this chapter, we’ll use those concepts and
    draw on our knowledge of service layers to wrap up the `BookingService` implementation.
    Figure 11.1 shows where we are in the scheme of the book.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5章实现了数据库访问层，在第6至9章实现了存储库层之后，我们开始在第10章实现`BookingService`。我还向您介绍了在单元测试中使用模拟的方法，并讨论了存储库/服务模式。在本章中，我们将使用这些概念，并借鉴我们对服务层知识，来完成`BookingService`的实现。图11.1显示了我们在本书方案中的位置。
- en: '![](../Images/11_01.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11_01.png)'
- en: Figure 11.1 In this chapter we finish implementing the `BookingService` class.
    In the next chapter, we wrap up the Services layer by implementing the `AirportService`
    and `FlightService` classes.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 在本章中，我们完成了`BookingService`类的实现。在下一章中，我们将通过实现`AirportService`和`FlightService`类来完成服务层的封装。
- en: While we finish implementing the `BookingService`, this chapter also discusses
    using the `Assert.IsInstanceOfType` test assertion to verify an object is of a
    certain type (or derived of a certain type), the discard (`_`) operator and its
    effect on Intermediate Language, and using multiple `catch` blocks in a `try-catch`
    code block.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成`BookingService`的实现时，本章还讨论了使用`Assert.IsInstanceOfType`测试断言来验证一个对象是否为特定类型（或派生自特定类型），丢弃（`_`）运算符及其对中间语言的影响，以及在`try-catch`代码块中使用多个`catch`块。
- en: 'To wrap up the `BookingService` implementation, we need to do the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成`BookingService`的实现，我们需要做以下几步：
- en: Validate the input parameters of the `BookingService.CreateBooking` method (section
    11.1).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证`BookingService.CreateBooking`方法的输入参数（第11.1节）。
- en: Verify that the flight we want to book exists in the database (section 11.3).
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证我们想要预订的航班是否存在于数据库中（第11.3节）。
- en: 11.1 Validating input parameters of a service layer method
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 验证服务层方法输入参数的有效性
- en: Many times, a service layer class acts as a pipe between a controller class
    and a repository class. Even though not a lot of logic is involved, the service
    layer still provides an important abstraction layer to combat tight coupling.
    For a discussion on coupling, see section 8.2.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，服务层类充当控制器类和存储库类之间的管道。尽管涉及的逻辑不多，但服务层仍然提供了一个重要的抽象层，以对抗紧密耦合。关于耦合的讨论，请参阅第8.2节。
- en: 'Before we move on, we should recap where we left off in the `BookingService
    .CreateBooking` method:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们应该回顾一下我们在`BookingService.CreateBooking`方法中留下的地方：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To perform the required input validation, we can use the `IsPositiveInteger`
    extension method we implemented in section 9.6 and the `string.IsNullOrEmpty`
    method. If the customer’s name is a null or empty string, or the flight number
    is not a positive integer, we return a set of variables indicating (*false*,*ArgumentException*),
    as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行所需的输入验证，我们可以使用我们在第9.6节中实现的`IsPositiveInteger`扩展方法和`string.IsNullOrEmpty`方法。如果客户的姓名是空或空字符串，或者航班号不是正整数，我们返回一组变量，表示（*false*，*ArgumentException*），如下所示：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, we should add a unit test, shown next, complete with the `[DataRow]` method
    attribute to inline test data that checks that a return value of (*false*,*ArgumentException*)
    comes out of the `BookingService.CreateBooking` method when given invalid input
    arguments. For this unit test, we do not need to set up the mock of `BookingRepository`
    with a return value, because it would never get executed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该添加一个单元测试，如下所示，包括使用`[DataRow]`方法属性内联测试数据，以检查当给定无效输入参数时，`BookingService.CreateBooking`方法返回的值是（*false*，*ArgumentException*）。对于这个单元测试，我们不需要设置返回特定值的`BookingRepository`模拟，因为它永远不会被执行。
- en: Listing 11.1 Testing `BookingService.CreateCustomer`’s input validation
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.1 测试`BookingService.CreateCustomer`的输入验证
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Inline test data
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 内联测试数据
- en: ❷ Sets up mocks
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 设置模拟
- en: ❸ Calls the CreateBooking method
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 调用CreateBooking方法
- en: ❹ The result should be (false, Exception).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 结果应该是（false，Exception）。
- en: That should do it for the invalid input arguments case. But what if the repository
    layer throws an exception? We hope the `try-catch` block in the `BookingService.CreateCustomer`
    method catches the exception, but until we test for that, we do not know for sure.
    I don’t like relying on my interpretation of what I think the code should do.
    Instead, it’s best to “prove” our assumptions and create a unit test. We can create
    a unit test called `CreateBooking_Failure_RepositoryException` and set up a mock
    of `BookingRepository` that returns an `Exception` when `BookingRepository.CreateBooking`
    is called.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无效输入参数的情况，应该就到这里了。但如果存储库层抛出了异常怎么办？我们希望 `BookingService.CreateCustomer` 方法中的
    `try-catch` 块能够捕获到异常，但直到我们测试这一点，我们才确信。我不喜欢依赖我对代码应该做什么的解释。相反，最好是“证明”我们的假设并创建一个单元测试。我们可以创建一个名为
    `CreateBooking_Failure_RepositoryException` 的单元测试，并设置一个模拟的 `BookingRepository`，当调用
    `BookingRepository.CreateBooking` 时，它会返回一个 `Exception`。
- en: What type of `Exception` should we return? The repository returns either an
    `ArgumentException` (on invalid input) or a `CouldNotAddBookingToDatabaseException`
    exception. We could either check that those specific exceptions were thrown or
    check for a general `Exception`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该返回哪种类型的 `Exception`？存储库返回 `ArgumentException`（在无效输入时）或 `CouldNotAddBookingToDatabaseException`
    异常。我们既可以检查是否抛出了这些特定的异常，也可以检查是否抛出了通用的 `Exception`。
- en: 'If a developer changes the type of exception thrown when a database error occurs
    from `CouldNotAddBookingToDatabaseException` to `AirportNotFoundException`, and
    we only test for the base `Exception` class to be thrown, we won’t catch the `AirportNotFoundException`
    exception at the earliest possible moment. This causes the test to incorrectly
    pass. It is for that reason that I propose we set up the following two mock return
    instances:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果开发者在数据库错误发生时，将抛出的异常类型从 `CouldNotAddBookingToDatabaseException` 改为 `AirportNotFoundException`，而我们只测试是否抛出了基类
    `Exception`，那么我们无法在最早的可能时刻捕获到 `AirportNotFoundException` 异常。这会导致测试错误地通过。正因为如此，我建议我们设置以下两个模拟返回实例：
- en: If we pass in the parameter set of `{0, 1}` to the `BookingService.CreateBooking`
    method, throw an `ArgumentException` exception.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们将参数集 `{0, 1}` 传递给 `BookingService.CreateBooking` 方法，则抛出 `ArgumentException`
    异常。
- en: If we pass in the parameter set of `{1, 2}` to the `BookingService.CreateBooking`
    method, throw a `CouldNotAddBookingToDatabaseException` exception.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们将参数集 `{1, 2}` 传递给 `BookingService.CreateBooking` 方法，则抛出 `CouldNotAddBookingToDatabaseException`
    异常。
- en: To set up more than one return value on a mock, we can modify the mock logic
    to cover all the different cases we want to test. There is no practical limit
    on the amount of returned mocks we can add to a method, as long as they are all
    individually distinguishable for the compiler (as with any overridden method).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要在模拟上设置多个返回值，我们可以修改模拟逻辑以覆盖我们想要测试的所有不同情况。只要它们对于编译器来说都是可以区分的（就像任何重写的方法一样），就没有对可以添加到方法中的返回模拟数量的实际限制。
- en: To verify that a thrown `Exception` is of a certain type, we can use the `Assert
    .IsInstanceOfType` assertion along with the `typeof` operator (discussed in section
    4.1.2), shown in the next code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证抛出的 `Exception` 是否为特定类型，我们可以使用 `Assert.IsInstanceOfType` 断言以及 `typeof` 操作符（在第
    4.1.2 节中讨论），如下面的代码所示。
- en: Listing 11.2 `CreateBooking_Failure_RepositoryException`
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.2 `CreateBooking_Failure_RepositoryException`
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Sets up a logic path to throw an ArgumentException exception
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 设置逻辑路径以抛出 `ArgumentException` 异常
- en: ❷ Sets up a logic path to throw a CouldNotAddBookingToDatabaseException exception
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 设置逻辑路径以抛出 `CouldNotAddBookingToDatabaseException` 异常
- en: ❸ Calls the CreateBooking method with (“Galileo Galilei”, 1)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 调用 `CreateBooking` 方法，参数为（“Galileo Galilei”，1）
- en: ❹ Asserts that the returned exception is of type CouldNotAddBookingToDatabaseException
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 断言返回的异常类型为 `CouldNotAddBookingToDatabaseException`
- en: ❺ Calls the CreateBooking method with (“Eise Eisinga”, 2)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 调用 `CreateBooking` 方法，参数为（“Eise Eisinga”，2）
- en: '`Assert.IsInstanceOfType` is an invaluable assertion to have in your toolbox.
    Instead of asserting the type of an object through regular code (using the `typeof`
    operator), you can use this assertion in your tests. Alternatively, you could
    mimic the functionality of the `Assert.IsInstanceType` by adding the `is` syntax
    (as discussed in the next section) to the `Assert.IsTrue` check.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`Assert.IsInstanceOfType` 是你工具箱中的一个非常有价值的断言。你可以在测试中使用这个断言，而不是通过常规代码（使用 `typeof`
    操作符）断言对象的类型。或者，你也可以通过将 `is` 语法（如下一节所述）添加到 `Assert.IsTrue` 检查中，来模拟 `Assert.IsInstanceType`
    的功能。'
- en: 11.1.1 Runtime type checks with the is and as operators
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.1 使用 is 和 as 操作符进行运行时类型检查
- en: '`Assert.IsInstanceOfType` throws an `Exception` when it fails. This works very
    well in unit tests, where an assertion failure means a test failure. In production
    code, things can be different. Sometimes, we don’t want to throw an `Exception`
    when we encounter an object of unexpected type. We already know about the `typeof`
    operator. If we *need* an object to be a specific type in production code, we
    can take the following two other approaches:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`Assert.IsInstanceOfType` 在失败时抛出 `Exception`。这在单元测试中工作得非常好，因为断言失败意味着测试失败。在生产代码中，情况可能不同。有时，当我们遇到意外类型的对象时，我们不想抛出
    `Exception`。我们已经了解了 `typeof` 操作符。如果我们 *需要* 在生产代码中确保一个对象是特定类型，我们可以采取以下两种其他方法：'
- en: Check if we can cast type `T` to type `Y` by using the `is` operator.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用 `is` 操作符检查我们是否可以将类型 `T` 转换为类型 `Y`。
- en: Convert type `T` to type `Y` by using the `as` operator and handling a potential
    `null` return value.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `as` 操作符将类型 `T` 转换为类型 `Y`，并处理可能的 `null` 返回值。
- en: Both the `is` and `as` operators are ways to use the Liskov principle to do
    type checking at run time. Whereas the `typeof` operator only works at compile
    time, we can use the `is` and `as` operators to dynamically determine what type
    something is at run time.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`is` 和 `as` 操作符都是使用 Liskov 原则进行运行时类型检查的方法。而 `typeof` 操作符仅在编译时工作，我们可以使用 `is`
    和 `as` 操作符在运行时动态确定某个对象是什么类型。'
- en: In table 11.1 we see a comparison of the `is` and `as` operators, along with
    their use cases and an example of their syntax.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在表 11.1 中，我们可以看到 `is` 和 `as` 操作符的比较，以及它们的使用案例和语法示例。
- en: Table 11.1 The `is` and `as` operators compared
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11.1 比较 `is` 和 `as` 操作符
- en: '| Operator | Use case | Syntax |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 操作符 | 用例 | 语法 |'
- en: '| `is` | Check whether type `T` is of type `Y` | `apple is Fruit` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `is` | 检查类型 `T` 是否为类型 `Y` | `apple is Fruit` |'
- en: '| `as` | Determine whether type `T` can be cast to type `Y` | `Peugeot as Car`
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `as` | 判断类型 `T` 是否可以被转换为类型 `Y` | `Peugeot as Car` |'
- en: Let’s take the table one step further and examine both operators a little more
    in depth.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步分析这个表格，并对这两个操作符进行更深入的研究。
- en: 11.1.2 *Type checking with the is operator*
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.2 *使用 `is` 操作符进行类型检查*
- en: 'First up: the `is` operator. We often use `is` when we want to do a runtime
    type check in the vein of `GetType` (discussed in section 4.1.2). Let’s say we
    are writing a (very naïve) implementation of an intercontinental internet package-switching
    system. We may have a tree of nodes (switches) containing a root node (an intercontinental
    switch), a continent or region switch, and dedicated country switches. I show
    such a setup in figure 11.2.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是：`is` 操作符。当我们想要进行类似于 `GetType`（在第 4.1.2 节中讨论）的运行时类型检查时，我们经常使用 `is`。假设我们正在编写一个（非常天真的）洲际互联网包交换系统的实现。我们可能有一个包含节点（交换机）的树，其中包含一个根节点（洲际交换机）、一个洲或地区交换机，以及专门的国家级交换机。我在图
    11.2 中展示了这样的设置。
- en: '![](../Images/11_02.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11_02.png)'
- en: Figure 11.2 A possible and simplified network switch tree. The tree contains
    a root node acting as an intercontinental switch, three child nodes acting as
    continental switches, and six country-specific switches.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 一个可能且简化的网络交换树。该树包含一个作为洲际交换机的根节点，三个作为洲际交换机的子节点，以及六个特定国家的交换机。
- en: 'Let’s also assume that two types derive from a base `Packet` class: `ExternalPacket`
    and `LocalPacket`, where `ExternalPacket` means any packet that needs to go to
    a different continent given a specific destination. For example, a packet going
    from leaf 3 (Panama) to leaf 4 (Brazil) is of type `LocalPacket` because it needs
    to travel only through the South/Middle America switch. A packet leaving from
    leaf 6 (Kenya) and going to leaf 1 (Luxembourg) is an `ExternalPacket`, because
    it needs to go through the Intercontinental switch.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 假设还有两种类型从基类 `Packet` 继承而来：`ExternalPacket` 和 `LocalPacket`，其中 `ExternalPacket`
    表示任何需要根据特定目的地前往不同洲的数据包。例如，从叶 3（巴拿马）到叶 4（巴西）的数据包是 `LocalPacket` 类型，因为它只需要通过南/中美洲交换机。从叶
    6（肯尼亚）出发并前往叶 1（卢森堡）的数据包是 `ExternalPacket`，因为它需要通过洲际交换机。
- en: 'How would we write code that directs these packets to the correct switch? One
    possible implementation assumes that we have a `PacketTransfer` class that attempts
    to handle the routing for us. In a `PacketTransfer`, we might have a method called
    `DetermineNextDestination`, which returns an object of type `InternetSwitch`.
    The `InternetSwitch` class could have two derived types as well: `ContinentalSwitch`
    and `GlobalSwitch`.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何编写代码来将这些数据包导向正确的交换机？一种可能的实现方案是假设我们有一个`PacketTransfer`类，该类尝试为我们处理路由。在`PacketTransfer`中，我们可能有一个名为`DetermineNextDestination`的方法，该方法返回一个`InternetSwitch`类型的对象。`InternetSwitch`类也可以有两个派生类型：`ContinentalSwitch`和`GlobalSwitch`。
- en: To know where to route the packet, we need to figure out whether the packet
    is an `ExternalPacke`t or `LocalPacket`. In listing 11.3 you see a potential implementation
    of logic to route external packets.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了知道将数据包路由到何处，我们需要确定数据包是`ExternalPacket`还是`LocalPacket`。在列表11.3中，您可以看到路由外部数据包逻辑的潜在实现。
- en: Listing 11.3 Using the `is` operator for packet routing
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.3 使用is操作符进行数据包路由
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Checks if the packet object can be coerced into the ExternalPacket type
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查数据包对象是否可以强制转换为ExternalPacket类型
- en: ❷ Checks if the packet destination object can be coerced into the ContinentalSwitch
    type
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查数据包目的地对象是否可以强制转换为ContinentalSwitch类型
- en: ❸ Goes to the packet destination or global switch, depending on the current
    location
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 前往数据包目的地或全局交换机，具体取决于当前位置
- en: ❹ If the packet is an ExternalPacket and not at a ContinentalSwitch, sends it
    to one
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果数据包是ExternalPacket且不在ContinentalSwitch上，则将其发送到其中一个
- en: By using polymorphism and the `is` operator, we can easily deduct whether the
    packet being routed is of type `ExternalPacket`. So, that is the `is` operator,
    but what about the `as` operator?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用多态和`is`操作符，我们可以轻松推断出正在路由的数据包是否为`ExternalPacket`类型。所以，这就是`is`操作符，那么`as`操作符又如何呢？
- en: 11.1.3 Type checking with the as operator
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.3 使用as操作符进行类型检查
- en: Let’s imagine we routed a packet to its destination. Now the destination switch
    wants to accept the packet, but this particular switch accepts only local packets
    (not going through the `GlobalSwitch` object). We could try to use the received
    packet as a `LocalPacket`, as shown next, and see what happens.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象我们已经将数据包路由到其目的地。现在，目标交换机想要接受这个数据包，但这个特定的交换机只接受本地数据包（不通过`GlobalSwitch`对象）。我们可以尝试将接收到的数据包用作`LocalPacket`，如下所示，并看看会发生什么。
- en: Listing 11.4 Using the `as` operator for packet acceptance
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.4 使用as操作符进行数据包接受
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Tries to use the packet variable as a LocalPacket instance
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 尝试将数据包变量用作LocalPacket实例
- en: ❷ Verifies the as operator did not return a null pointer
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 验证as操作符没有返回空指针
- en: ❸ Processes the LocalPacket instance
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 处理LocalPacket实例
- en: ❹ Rejects the not LocalPacket instance
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 拒绝非LocalPacket实例
- en: When using the `as` operator, if the variable cannot be cast to the requested
    type, the CLR assigns a null pointer to the variable. Using the `as` operator
    is a powerful tool and can be useful when dealing with incoming unknowns.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`as`操作符时，如果变量无法转换为请求的类型，CLR会将空指针分配给该变量。使用`as`操作符是一个强大的工具，在处理未知输入时可能很有用。
- en: 'And now, for the grand finale: we combine both approaches by using pattern
    matching in the next code sample.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，到了高潮部分：我们通过在下一个代码示例中使用模式匹配来结合两种方法。
- en: Listing 11.5 Using pattern matching for packet acceptance
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.5 使用模式匹配进行数据包接受
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ If a packet can be used as a LocalPacket, it is assigned to receivedPacket
    and processed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果数据包可以用作LocalPacket，则将其分配给receivedPacket并处理。
- en: ❷ If the packet cannot be used as a LocalPacket, calls the RejectPacket method
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果数据包不能用作LocalPacket，则调用RejectPacket方法
- en: 11.1.4 What did we do in section 11.1?
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.4 在11.1节中我们做了什么？
- en: In the `CreateBooking_Failure_RepositoryException` unit test, we tested and
    verified that we can handle exceptions thrown in the repository layer gracefully
    and as expected. We also instantiated the `Mock<BookingRepository>` in the same
    way as we did in the `CreateBooking_Success` and `CreateBooking_Failure_InvalidInputs`
    unit tests. Perhaps we can extract the initialization of the mock into a `TestInitialize`
    method and split up the `CreateBooking_Failure_RepositoryExceptions` into two
    tests. We also learned about using the `is` and `as` operators for runtime type
    checking.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `CreateBooking_Failure_RepositoryException` 单元测试中，我们测试并验证了我们能够优雅地处理在存储库层抛出的异常，并且符合预期。我们以与
    `CreateBooking_Success` 和 `CreateBooking_Failure_InvalidInputs` 单元测试相同的方式实例化了
    `Mock<BookingRepository>`。也许我们可以将模拟的初始化提取到 `TestInitialize` 方法中，并将 `CreateBooking_Failure_RepositoryExceptions`
    分解为两个测试。我们还学习了使用 `is` 和 `as` 运算符进行运行时类型检查。
- en: 11.2 Cleaning up the BookingServiceTests class
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 清理 `BookingServiceTests` 类
- en: 'In wrapping up section 11.1, we identified the following two cleanup areas
    for the `BookingServiceTests` class:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在总结第 11.1 节时，我们确定了 `BookingServiceTests` 类的以下两个清理区域：
- en: Extract the initialization of `Mock<BookingRepository>` to a `TestInitialize`
    method. The current implementation sees us instantiate a mock of `BookingRepository`
    in every test, violating the DRY principle.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `Mock<BookingRepository>` 的初始化提取到 `TestInitialize` 方法中。当前的实现方式是在每个测试中实例化 `BookingRepository`
    的模拟，违反了 DRY 原则。
- en: 'Split the `CreateBooking_Failure_RepositoryException` into two unit tests:
    one for the `ArgumentException` and one for the `CouldNotAddBookingToDatabaseException`
    exception.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `CreateBooking_Failure_RepositoryException` 分解为两个单元测试：一个用于 `ArgumentException`，另一个用于
    `CouldNotAddBookingToDatabaseException` 异常。
- en: Let’s start by extracting the initialization of `Mock<BookingRepository>` to
    the `TestInitialize` method, shown next. We also want to add a private backing
    field for us to store the reference to `Mock<BookingRepository>`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先将 `Mock<BookingRepository>` 的初始化提取到下面的 `TestInitialize` 方法中。我们还想添加一个私有后置字段，以便我们存储对
    `Mock<BookingRepository>` 的引用。
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'All we have to do is change the existing unit tests to use the `_mockBookingRepository`
    field instead of instantiating their own mock. For example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的就是将现有的单元测试修改为使用 `_mockBookingRepository` 字段而不是实例化它们自己的模拟。例如：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We still want to set up any mocked returns because any existing mock instances
    are reset every time we run a new test. Initializing no mocks in the `TestInitialize`
    method allows us to set up different returned mock instances on a per-test basis.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然想要设置任何模拟的返回值，因为每次运行新的测试时，现有的模拟实例都会被重置。在 `TestInitialize` 方法中不初始化任何模拟允许我们根据每个测试设置不同的返回模拟实例。
- en: 'The second improvement we identified was to split the `CreateBooking_Failure
    _RepositoryException` unit test into the following separate unit tests:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确定的第二个改进是将 `CreateBooking_Failure_RepositoryException` 单元测试分解为以下单独的单元测试：
- en: '`CreateBooking_Failure_RepositoryException_ArgumentException`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateBooking_Failure_RepositoryException_ArgumentException`'
- en: '`CreateBooking_Failure_RepositoryException_CouldNotAddBookingToDatabase`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateBooking_Failure_RepositoryException_CouldNotAddBookingToDatabase`'
- en: The two new unit tests each test a logic branch that throws their respective
    `Exception`. In listing 11.6, you see the `CreateBooking_Failure_RepositoryException_ArgumentException`
    unit test. I leave the `CreateBooking_Failure_CouldNotAddBookingToDatabase` for
    you to implement. If you get stuck, you can mimic the pattern in listing 11.6\.
    My versions of both unit tests are provided in the source files for this book.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个新的单元测试各自测试一个抛出相应 `Exception` 的逻辑分支。在列表 11.6 中，你可以看到 `CreateBooking_Failure_RepositoryException_ArgumentException`
    单元测试。我将 `CreateBooking_Failure_CouldNotAddBookingToDatabase` 留给你来实现。如果你遇到困难，可以模仿列表
    11.6 中的模式。这两个单元测试的版本都包含在本书的源文件中。
- en: Listing 11.6 `CreateBooking_Failure_RepositoryException_ArgumentException` unit
    test
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.6 `CreateBooking_Failure_RepositoryException_ArgumentException` 单元测试
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'What have we accomplished in this section? We implemented the `BookingService`
    and have the following three unit tests to back up the functionality in our service
    class:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中我们取得了哪些成果？我们实现了 `BookingService` 并为我们的服务类提供了以下三个单元测试以支持其功能：
- en: '`CreateBooking_Success`—This unit test verifies our “happy path” scenario and
    calls a mocked `BookingRepository` to mimic database operations.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateBooking_Success`—这个单元测试验证了我们的“快乐路径”场景，并调用模拟的 `BookingRepository` 来模拟数据库操作。'
- en: '`CreateBooking_Failure_RepositoryException_ArgumentException`—This unit test
    tells the `BookingRepository` mock to throw an `ArgumentException`. We verify
    whether our service method can appropriately handle the thrown `ArgumentException`.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateBooking_Failure_RepositoryException_ArgumentException`—这个单元测试告诉`BookingRepository`模拟抛出`ArgumentException`。我们验证我们的服务方法是否能够适当地处理抛出的`ArgumentException`。'
- en: '`CreateBooking_Failure_CouldNotAddBookingToDatabase`—This unit test tells the
    `BookingRepository` mock to throw a `CouldNotAddBookingToDatabaseException` exception.
    We verify whether our service method can appropriately handle the thrown `CouldNotAddBookingToDatabaseException`
    exception.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateBooking_Failure_CouldNotAddBookingToDatabase`—这个单元测试告诉`BookingRepository`模拟抛出`CouldNotAddBookingToDatabaseException`异常。我们验证我们的服务方法是否能够适当地处理抛出的`CouldNotAddBookingToDatabaseException`异常。'
- en: 11.3 Foreign key constraints in service classes
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 服务类中的外键约束
- en: 'In section 10.3, we determined that the `BookingService` has to deal with the
    following two outgoing foreign key constraints (also shown in figure 11.3):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在第10.3节中，我们确定`BookingService`必须处理以下两个外键约束（如图11.3所示）：
- en: An outgoing foreign key constraint to `Customer.CustomerID`
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指向`Customer.CustomerID`的外键约束
- en: An outgoing foreign key constraint to `Flight.FlightNumber`
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指向`Flight.FlightNumber`的外键约束
- en: '![](../Images/11_03.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11_03.png)'
- en: 'Figure 11.3 The Flying Dutchman Airlines database schema. The Booking model
    has two outgoing foreign key constraints: one to `Customer.CustomerID` and one
    to `Flight.FlightNumber`.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 飞行荷兰人航空公司数据库模式。预订模型有两个外键约束：一个指向`Customer.CustomerID`，一个指向`Flight.FlightNumber`。
- en: 'How do we “handle” these foreign key constraints? We also determined in section
    10.3 that we want to use the `CustomerRepository.GetCustomerByName` method to
    verify a customer exists in the database with the passed-in `Name` value. The
    method returns a `Customer` object if it is found, which contains the appropriate
    `CustomerID` value. If it does not find a `Customer` object, we want to create
    it using the `CustomerRepository .CreateCustomer` method. For the `flightNumber`
    parameter: if there is no matching flight in the database, we should return out
    of the service method without creating the booking (or a new flight) in the database.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何“处理”这些外键约束？我们还在第10.3节中确定，我们想要使用`CustomerRepository.GetCustomerByName`方法来验证数据库中是否存在具有传入`Name`值的客户。如果找到，该方法将返回一个包含适当`CustomerID`值的`Customer`对象。如果没有找到`Customer`对象，我们想要使用`CustomerRepository.CreateCustomer`方法来创建它。对于`flightNumber`参数：如果没有在数据库中找到匹配的航班，我们应该从服务方法中返回，而不在数据库中创建预订（或新航班）。
- en: This is where the power of a service layer starts to show. Because we allow
    service layers (and only service layers!) to make calls to repositories not directly
    related to their immediate model, we can gather a collection of information to
    return a `View` to the controller, as shown in figure 11.4\. In the case of the
    `BookingService`, its immediate model is the `Booking` entity. However, to correctly
    create a new booking in the database, we need to use the `Customer` and `Flight`’s
    repository layer classes.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是服务层力量的开始展现。因为我们允许服务层（仅限于服务层！）调用与其直接模型不直接相关的存储库，我们可以收集一组信息以返回给控制器，如图11.4所示。在`BookingService`的情况下，其直接模型是`Booking`实体。然而，为了正确地在数据库中创建新的预订，我们需要使用`Customer`和`Flight`的存储库层类。
- en: '![](../Images/11_04.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11_04.png)'
- en: Figure 11.4 The `BookingService` calls across the repository layer. It calls
    the `BookingRepository` (its immediate concern), the `FlightRepository`, and the
    `CustomerRepository`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 `BookingService`跨存储库层的调用。它调用`BookingRepository`（其直接关注点），`FlightRepository`和`CustomerRepository`。
- en: 11.3.1 Calling the Flight repository from a service class
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.1 从服务类调用航班存储库
- en: 'Because the business logic on the `Flight` model is stricter than on the `Customer`
    model, the first check we should do (after input validation) is making sure that
    the requested `Flight` instance lives in the database. Let’s see how far we get
    without getting stuck:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Flight`模型上的业务逻辑比`Customer`模型上的更严格，我们在输入验证之后应该做的第一个检查是确保请求的`Flight`实例存在于数据库中。让我们看看我们能够走多远而不被卡住：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Well, that’s not very far at all. The `FlightRepository` constructor requires
    us to pass (or inject) in an instance of `FlyingDutchmanAirlinesContext`. We do
    not have access to that instance in the service layer. We could instantiate an
    instance of `FlyingDutchmanAirlinesContext`, but we could also take the same approach
    we did for the `BookingRepository`: use dependency injection to provide the `BookingService`
    class with a ready-to-go instance of `FlightRepository`.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这并不远。`FlightRepository`构造函数要求我们传递（或注入）一个`FlyingDutchmanAirlinesContext`实例。我们在服务层没有访问该实例。我们可以实例化一个`FlyingDutchmanAirlinesContext`实例，但我们也可以采取与`BookingRepository`相同的方法：使用依赖注入为`BookingService`类提供一个现成的`FlightRepository`实例。
- en: 'To add an injected instance to the consuming class, we need to do the following,
    as shown in figure 11.5 and listing 11.7:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要将注入的实例添加到消费类中，我们需要执行以下操作，如图11.5和列表11.7所示：
- en: Add a backing field of type `T`, where `T` is the injected type.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个类型为`T`的后置字段，其中`T`是注入的类型。
- en: Add a parameter to the constructor of the consuming class of type `T`.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向消费类的构造函数中添加一个类型为`T`的参数。
- en: Inside the constructor, assign the injected instance of type `T` to the private
    backing field created in step 1.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数内部，将步骤1中创建的私有后置字段注入的类型`T`的实例赋值。
- en: '![](../Images/11_05.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片11_05](../Images/11_05.png)'
- en: Figure 11.5 To use dependency injection, first add a backing field. Then inject
    the wanted type. Finally, assign the injected parameter to the backing field.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 要使用依赖注入，首先添加一个后置字段。然后注入所需类型。最后，将注入的参数赋值给后置字段。
- en: Listing 11.7 `BookingService` injects an instance of `FlightRepository`
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.7 `BookingService`注入`FlightRepository`的实例
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now we have an injected instance of `FlightRepository`, assigned to a backing
    field, that we can use in our `CreateBooking` method. There’s one problem: the
    code in listing 11.7 does not compile. The compiler throws an exception, shown
    in figure 11.6, saying that there are not enough arguments in the calls to the
    `BookingService`’s constructor during our unit tests.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个注入的`FlightRepository`实例，已赋值给后置字段，我们可以在`CreateBooking`方法中使用它。但有一个问题：列表11.7中的代码无法编译。编译器抛出一个异常，如图11.6所示，表示在单元测试中对`BookingService`构造函数的调用中参数不足。
- en: '![](../Images/11_06.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片11_06](../Images/11_06.png)'
- en: Figure 11.6 The compiler throws an exception if you do not have enough parameters
    to call a given method. In this case, we did not provide enough parameters to
    call the constructor of `BookingService` (we are missing the `customerRepository`
    parameter).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 如果没有足够的参数来调用给定方法，编译器会抛出异常。在这种情况下，我们没有提供足够的参数来调用`BookingService`的构造函数（我们缺少`customerRepository`参数）。
- en: 'To solve the compiler error, we need to add a `Mock<FlightRepository>` instance
    to our existing unit tests in the `BookingServiceTests` class. Go ahead and add
    the mock instance to the unit tests. If you mimic the pattern used to instantiate
    the `Mock <BookingRepository>` object, you should be fine. If you get stuck, the
    provided source code contains the answers. You don’t need to set up any return
    calls for the mocked `FlightRepository` class. One final tip: you have to create
    a parameterless constructor for `FlightRepository`. If you want more information
    on why you need to create a parameterless virtual constructor, see section 10.3.3.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决编译器错误，我们需要在`BookingServiceTests`类中现有的单元测试中添加一个`Mock<FlightRepository>`实例。继续添加模拟实例到单元测试中。如果你模仿实例化`Mock
    <BookingRepository>`对象时使用的模式，你应该没问题。如果你卡住了，提供的源代码中包含了答案。你不需要为模拟的`FlightRepository`类设置任何返回调用。最后一点提示：你必须为`FlightRepository`创建一个无参构造函数。如果你需要更多关于为什么需要创建一个无参虚拟构造函数的信息，请参阅第10.3.3节。
- en: Our code now compiles, and our existing unit tests pass. We can move on to verifying
    the flight exists in the database. Our first step, as always, is to add a unit
    test.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的代码可以编译，现有的单元测试也通过了。我们可以继续验证航班是否存在于数据库中。我们的第一步，一如既往，是添加一个单元测试。
- en: 'In `BookingServiceTests`, add a unit test called `CreateBooking_Failure_FlightNotInDatabase`.
    The success case is covered in the `CreateBooking_Success` unit test, as long
    as we add a mock setup call to the `FlightRepository.GetFlightByFlightNumber`
    method as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BookingServiceTests`中添加一个名为`CreateBooking_Failure_FlightNotInDatabase`的单元测试。成功情况已在`CreateBooking_Success`单元测试中覆盖，只要我们向`FlightRepository.GetFlightByFlightNumber`方法添加一个模拟设置调用，如下所示：
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, for the failure path, we implement the `CreateBooking_Failure_FlightNotInDatabase`
    unit test, as shown here:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于失败路径，我们实现`CreateBooking_Failure_FlightNotInDatabase`单元测试，如下所示：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `CreateBooking_Failure_FlightNotInDatabase` unit test compiles but does
    not pass. However, that is exactly what we want at this stage. Remember, in test-driven
    development, we go from not being able to compile or pass a test to implementing
    just enough to make the test pass.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateBooking_Failure_FlightNotInDatabase`单元测试可以编译但无法通过。然而，这正是我们目前想要的。记住，在测试驱动开发中，我们从无法编译或通过测试开始，只实现足够的代码来使测试通过。'
- en: 'In `BookingService.CreateBooking`, we want to make sure that we do not book
    a customer on a flight that does not exist. Taking a look at `FlightRepository.GetFlightByFlightID`,
    we notice that the method accepts the following three parameters:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BookingService.CreateBooking`中，我们想要确保我们不预订一个不存在的航班给客户。查看`FlightRepository.GetFlightByFlightID`，我们注意到该方法接受以下三个参数：
- en: '`flightNumber`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flightNumber`'
- en: '`originAirportId`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`originAirportId`'
- en: '`desinationAirporId`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`desinationAirporId`'
- en: 'Unfortunately, that doesn’t work for us anymore. Luckily, we shouldn’t be afraid
    to change (or delete) our own code. I’d like to give you an assignment: make the
    `FlightRepository.GetFlightByFlightID` accept only the `flightNumber` argument
    and return the correct flight. This allows us to use the method in our service
    layer and forces you to get your hands dirty. If you get stuck, see this chapter’s
    source code. An example implementation is shown in listing 11.8\. Also, make sure
    you update the unit tests.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这已经不再适用于我们了。幸运的是，我们不应该害怕改变（或删除）自己的代码。我想给你一个任务：让`FlightRepository.GetFlightByFlightID`只接受`flightNumber`参数并返回正确的航班。这允许我们在服务层中使用该方法，并迫使你亲自动手。如果你遇到了困难，请参阅本章的源代码。示例实现如列表11.8所示。同时，确保你更新了单元测试。
- en: 'Now that the `FlightRepository.GetFlightByFlightNumber` method accepts only
    a `flightNumber`, we can actually use it. Listing 11.8 shows my implementation.
    You can see that the method offers only two possible return values: either the
    method returns a `Flight` instance, or it throws a `FlightNotFoundException`.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`FlightRepository.GetFlightByFlightNumber`方法只接受`flightNumber`，我们实际上可以使用它。列表11.8显示了我的实现。你可以看到，该方法只提供两种可能的返回值：要么方法返回一个`Flight`实例，要么它抛出一个`FlightNotFoundException`。
- en: Listing 11.8 `FlightRepository.GetFlightByFlightNumber`
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.8 `FlightRepository.GetFlightByFlightNumber`
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: A possible implementation of the flight-verification logic would consist of
    a call to `GetFlightByFlightNumber`, as shown next. If no exception was caught
    by the `try-catch` in `BookingService.CreateBooking`, things must be all right
    and we can move on.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 飞行验证逻辑的可能实现包括对`GetFlightByFlightNumber`的调用，如下所示。如果在`BookingService.CreateBooking`中的`try-catch`没有捕获到异常，那么一切正常，我们可以继续进行。
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This code would work perfectly fine until somebody decides to change the implementation
    of `FlightRepository.GetFlightByFlightNumber`. What if it suddenly returns a null
    pointer instead of throwing an exception when the method cannot find the matching
    flight in the database? The code would execute as if nothing happened and allow
    a customer to be booked on a nonexisting flight.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将完美地工作，直到有人决定更改`FlightRepository.GetFlightByFlightNumber`的实现。如果方法在数据库中找不到匹配的航班时突然返回一个`null`指针而不是抛出异常，代码将像什么都没发生一样执行，并允许客户被预订到一个不存在的航班上。
- en: Instead, let’s do a little due diligence here and check the output of `GetFlightByFlightNumber`,
    as shown in the following code sample. If it is `null`, we also throw an `Exception`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，让我们在这里做一些尽职调查，并检查`GetFlightByFlightNumber`的输出，如下面的代码示例所示。如果它是`null`，我们也抛出一个`Exception`。
- en: Listing 11.9 A better implementation of the flight verification code
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.9：飞行验证代码的更好实现
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Listing 11.9 handles the null case from `GetFlightByFlightNumber` proactively
    by throwing an `Exception`. The code also uses the discard operator (`_`). You
    can use the discard operator to “throw away” a returned value but still use operators
    relying on value assignment (such as the null-coalescing operator).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.9通过抛出`Exception`主动处理`GetFlightByFlightNumber`的`null`情况。代码还使用了丢弃操作符（`_`）。你可以使用丢弃操作符来“丢弃”返回值，但仍然使用依赖于值赋值的操作符（例如空合并操作符）。
- en: The discard operator and intermediate language
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 丢弃操作符和中间语言
- en: The discard operator (`_`) is an interesting case to think about. Does using
    the discard operator mean we aren’t assigning the return value from a method to
    anything? Are we just throwing away the assignment variable immediately? We can
    find an answer by examining how a discard operator is compiled to Intermediate
    Language.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 丢弃操作符（`_`）是一个值得思考的有趣案例。使用丢弃操作符是否意味着我们不会将方法的返回值赋给任何东西？我们是不是立即丢弃了赋值变量？我们可以通过检查丢弃操作符是如何编译成中间语言的来找到答案。
- en: 'Let’s take the method call to `FlightRepository.GetFlightByFlightNumber`, as
    shown in listing 11.9, and remove the null-coalescing operator so we can focus
    on just the discard operator:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看列表11.9中的`FlightRepository.GetFlightByFlightNumber`方法调用，并移除空合并操作符，这样我们就可以专注于丢弃操作符：
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This compiles to a lengthy list of MSIL opcodes, but the assignment portion
    ends with the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这会编译成一系列的MSIL操作码，但赋值部分以以下内容结束：
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `stloc.3` command stores information to location number 3 on the stack.
    It seems that using the discard operator still results in some memory allocation.
    Of course, the allocated spot in memory is collected by the garbage collector
    as soon as possible because there are no calls to it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`stloc.3`命令将信息存储到堆栈上的第3个位置。看起来使用丢弃操作符仍然会导致一些内存分配。当然，分配的内存空间会尽快被垃圾回收器回收，因为没有对它的调用。'
- en: 'So, to answer our initial question: yes, the discard operator allocates memory.
    But, because we cannot directly point at a discard operator and use it like any
    other variable, we still have performance benefits.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为了回答我们最初的问题：是的，丢弃操作符会分配内存。但是，因为我们不能直接指向一个丢弃操作符并像使用任何其他变量一样使用它，所以我们仍然有性能上的优势。
- en: Another benefit of using the discard operator is clean code. It is often very
    confusing to assign values to unused variables. By using the discard operator,
    you explicitly say, “I am not going to use the return value from this method,”
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用丢弃操作符的另一个好处是代码整洁。将值赋给未使用的变量通常非常令人困惑。通过使用丢弃操作符，你明确地表示，“我不会使用这个方法返回的值。”
- en: The code in listing 11.9 is an improvement over what we see in listing 11.8,
    but we can take it one step further. In section 4.2, we talked about code reading
    like a narrative. The code in listing 11.9 seems like an excellent opportunity
    to put that into practice by extracting the flight-verification logic into its
    own separate private method. We can call the method `FlightExistsInDatabase` and
    have it return a Boolean value based on whether or not the return value from `FlightRepository.GetFlightByFlightNumber`
    is `null`, as shown next.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.9中的代码比列表11.8中的代码有所改进，但我们还可以更进一步。在第4.2节中，我们讨论了像叙事一样阅读代码。列表11.9中的代码似乎是一个很好的机会，通过将飞行验证逻辑提取到它自己的独立私有方法中来实现这一点。我们可以调用该方法`FlightExistsInDatabase`，并根据`FlightRepository.GetFlightByFlightNumber`的返回值是否为`null`返回一个布尔值，如下所示。
- en: Listing 11.10 Using `FlightExistsInDatabase` in `CreateBooking`
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.10 在`CreateBooking`中使用`FlightExistsInDatabase`
- en: '[PRE19]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ If the given flight does not exist in the database, throws an exception
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果给定的航班在数据库中不存在，则抛出异常
- en: ❷ If GetFlightByFlightNumber returns a null value, returns false; else, returns
    true
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果`GetFlightByFlightNumber`返回一个null值，则返回false；否则，返回true
- en: ❸ If GetFlightByFlightNumber throws a FlightNotFoundException, returns false
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果`GetFlightByFlightNumber`抛出`FlightNotFoundException`，则返回false
- en: That should do it for the actual implementation of the flight-verification code.
    We still need to update our unit tests, however, because we are not prepared to
    return a correct value when the mocked `FlightRepository`’s `GetFlightByFlightNumber`
    method is called.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了飞行验证代码的实际实现。然而，我们仍然需要更新我们的单元测试，因为我们没有准备好在模拟的`FlightRepository`的`GetFlightByFlightNumber`方法被调用时返回正确的值。
- en: You should be familiar with how to set up a mocked return value by now, so I’m
    going to show you how to set up the return value for the `CreateBooking_Failure_
    FlightNotInDatabase` and `CreateBooking_Success` unit tests, and you can try fixing
    the other unit tests. If you get stuck, the provided source code has the answers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经熟悉了如何设置模拟的返回值，所以我将向你展示如何为`CreateBooking_Failure_FlightNotInDatabase`和`CreateBooking_Success`单元测试设置返回值，你可以尝试修复其他单元测试。如果你遇到了困难，提供的源代码中包含了答案。
- en: 'To tell the `Mock<FlightRepository>` that we want to throw an `Exception` of
    type `FlightNotFound` (which is the real code’s logic) when we see a `flightNumber`
    of `-1`, we use the same syntax as described in section 10.3.3 and shown in the
    next listing: `[MOCK].Setup([`*predicate to call method with arguments*`]).Throws(new`
    [*Type of Exception*]`)`.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了告诉`Mock<FlightRepository>`，当我们看到`flightNumber`为`-1`时，我们希望抛出一个`FlightNotFound`类型的异常（这是真实代码的逻辑），我们使用与第10.3.3节中描述的相同语法，如下一列表所示：`[MOCK].Setup([*调用方法时的参数谓词*]).Throws(new
    [*异常类型*])`。
- en: NOTE As discussed in section 10.3.3, to mock a specific method call we need
    to make the original method `virtual`. Making a method `virtual` allows the Moq
    library to override the method. For a discussion on virtual methods, see section
    5.3.2.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如第10.3.3节所述，为了模拟特定的方法调用，我们需要将原始方法设置为`virtual`。将方法设置为`virtual`允许Moq库覆盖该方法。关于虚拟方法的讨论，请参阅第5.3.2节。
- en: Listing 11.11 Setting up `Mock<FlightRepository>` exception return value
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.11 设置`Mock<FlightRepository>`异常返回值
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With the setup as shown in listing 11.11, when the mock’s `GetFlightByFlightNumber`
    method is called and a value of `-1` is passed in as an input argument, the method
    throws an `Exception` of type `FlightNotFoundException` (mimicking the existing
    code). The `BookingService.FlightExistsInDatabase` method (which called the `GetFlightByFlightNumber`
    method) checks whether or not the return value from the method was `null` (it
    was `null` in this case because an exception was thrown) and returns the value
    of that expression. Based on that result, the `BookingService` throws an `Exception`
    of type `CouldNotAddBookingToDatabaseException`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表11.11所示，当模拟的`GetFlightByFlightNumber`方法被调用，并且传入的输入参数值为`-1`时，该方法会抛出一个`FlightNotFoundException`类型的异常（模拟现有代码）。`BookingService.FlightExistsInDatabase`方法（调用了`GetFlightByFlightNumber`方法）检查该方法返回的值是否为`null`（在这种情况下因为抛出了异常，所以是`null`），并返回该表达式的值。基于这个结果，`BookingService`会抛出一个`CouldNotAddBookingToDatabaseException`类型的异常。
- en: To fix the `CreateBooking_Success` unit test, we need to set up our mock of
    `FlightRepository` to return an instance of `Flight` when the `GetFlightByFlightNumber`
    method is called.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复`CreateBooking_Success`单元测试，我们需要设置我们的`FlightRepository`模拟，以便在调用`GetFlightByFlightNumber`方法时返回一个`Flight`实例。
- en: To add a mocked return of type `Task<Flight>` to the `GetFlightByFlightNumber`
    method, we need to use the asynchronous version of the `[MOCK].Setup` syntax,
    as shown in the next code snippet. If we used the synchronous version, the mock
    would try to return a `Flight` instance instead of a `Task<Flight>` instance,
    causing a compiler error, shown in figure 11.7.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向`GetFlightByFlightNumber`方法添加一个模拟的返回类型为`Task<Flight>`的值，我们需要使用`[MOCK].Setup`语法的异步版本，如下一代码片段所示。如果我们使用同步版本，模拟将尝试返回一个`Flight`实例而不是`Task<Flight>`实例，这会导致编译器错误，如图11.7所示。
- en: '![](../Images/11_07.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/11_07.png)'
- en: Figure 11.7 When trying to return a type not wrapped in a `Task` type, the compiler
    throws an error saying it cannot convert `T` to `Task<T>`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 当尝试返回未包装在`Task`类型中的类型时，编译器会抛出一个错误，表示无法将`T`转换为`Task<T>`。
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Calling the Customer repository
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 调用客户仓库
- en: 'The second input we need to validate is the `name` parameter. To validate the
    `name` parameter, the `BookingService` has to call the `CustomerRepository`’s
    `GetCustomerByName` and (if the customer does not exist in the database) `CreateCustomer`
    methods. In section 10.3.4, we implemented a version of this logic. It’s been
    a while since we looked at those methods (we implemented them in chapter 7), so
    let’s refresh our memories with the next code sample:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要验证的第二个输入参数是`name`。为了验证`name`参数，`BookingService`必须调用`CustomerRepository`的`GetCustomerByName`方法，以及（如果客户不在数据库中）`CreateCustomer`方法。在第10.3.4节中，我们实现了这个逻辑的一个版本。自从我们查看这些方法以来已经有一段时间了（我们在第7章中实现了它们），所以让我们通过下一个代码示例来刷新我们的记忆：
- en: '[PRE22]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Our unit tests are now in good shape . . . so, let’s break them again! Remember,
    when everything goes well, the next stage in test-driven development is to break
    the tests again. In this case, let’s add a new unit test that tests the logic
    when a customer is not in the database: `CreateBooking_Success_CustomerNotInDatabase`.
    Why is this unit test a success case? Did the customer validation not fail? Yes,
    but that just means the customer is not preexisting. In that case, we simply add
    the customer to the database and proceed as usual, as shown in figure 11.8\. To
    call any method in the `CustomerRepository` from the `BookingService`, we use
    the injected instance of `CustomerRepository` as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的单元测试状况良好……那么，让我们再次破坏它们！记住，当一切顺利时，测试驱动开发中的下一个阶段是再次破坏测试。在这种情况下，让我们添加一个新的单元测试来测试客户不在数据库中的逻辑：`CreateBooking_Success_CustomerNotInDatabase`。为什么这个单元测试是一个成功案例？客户验证没有失败吗？是的，但这只是意味着客户不是预先存在的。在这种情况下，我们只需将客户添加到数据库中，并按常规进行，如图
    11.8 所示。要从 `BookingService` 中调用 `CustomerRepository` 的任何方法，我们使用注入的 `CustomerRepository`
    实例如下：
- en: '[PRE23]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The addition of a `CustomerRepository` parameter to the `CustomerRepository`’s
    constructor breaks the existing unit tests. You know what to do: add a `Mock<CustomerRepository>`
    to the constructor call in the unit tests. I leave this for you to do. If you
    get stuck, see the provided source code for this chapter. You will have to set
    up the `CustomerRepository` test with a parameterless constructor and make the
    appropriate methods virtual so Moq instantiates and uses `Mock<CustomerRepository>`.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `CustomerRepository` 构造函数中的 `CustomerRepository` 参数添加到现有单元测试中会破坏它们。你知道该怎么做：在单元测试中向构造函数调用添加
    `Mock<CustomerRepository>`。我将这个任务留给你去做。如果你卡住了，请参阅本章提供的源代码。你将不得不设置一个无参数构造函数的 `CustomerRepository`
    测试，并使适当的方法虚拟化，以便 Moq 实例化和使用 `Mock<CustomerRepository>`。
- en: '![](../Images/11_08.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/11_08.png)'
- en: Figure 11.8 If the customer does not exist in the database, we add the customer
    to the database. In both scenarios, we create a booking.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8 如果客户不存在于数据库中，我们将客户添加到数据库中。在这两种情况下，我们都会创建一个预订。
- en: Using the injected `CustomerRepository` instance, we start by creating two private
    methods that check whether a customer exists in the database and add it to the
    database if not. The `CustomerRepository.GetCustomerByName` method returns an
    `Exception` of type `CustomerNotFoundException`. We can catch this specific error
    in a `catch` code block and create the customer anyway, as shown in the next listing.
    If a different type of `Exception` is thrown, then we know something is wrong,
    so we rethrow the exception (the `CreateBooking` method catches and handles the
    exception). In section 9.4, we discussed how to rethrow exceptions while preserving
    the stack trace of the original problem.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用注入的 `CustomerRepository` 实例，我们首先创建两个私有方法，用于检查客户是否存在于数据库中，如果不存在则将其添加到数据库中。`CustomerRepository.GetCustomerByName`
    方法返回一个类型为 `CustomerNotFoundException` 的 `Exception`。我们可以在 `catch` 代码块中捕获这个特定的错误，并创建客户，如下一列表所示。如果抛出了不同类型的
    `Exception`，那么我们知道出了问题，因此我们重新抛出异常（`CreateBooking` 方法会捕获并处理异常）。在第 9.4 节中，我们讨论了如何在保留原始问题堆栈跟踪的同时重新抛出异常。
- en: Listing 11.12 `GetCustomerFromDatabase` and `AddCustomerToDatabase` methods
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.12 `GetCustomerFromDatabase` 和 `AddCustomerToDatabase` 方法
- en: '[PRE24]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Attempts to retrieve the customer from the database
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 尝试从数据库中检索客户
- en: ❷ If a CustomerNotFoundException is thrown, the customer does not exist in the
    database.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果抛出了 `CustomerNotFoundException`，则表示客户不存在于数据库中。
- en: ❸ If a different exception was thrown, something went wrong. Rethrow the exception.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果抛出了不同的异常，则表示出了问题。重新抛出异常。
- en: ❹ Adds a customer to the database
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 向数据库添加客户
- en: 'The `GetCustomerFromDatabase` and `AddCustomerToDatabase` methods are not called
    anywhere yet, which gives us a good chance to think about how we can test their
    functionality. We know we are going to call at least `GetCustomerFromDatabase`
    in every execution of `CreateBooking`, so let’s start with that. `GetCustomerFromDatabase`
    can determine the following three potential states:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetCustomerFromDatabase` 和 `AddCustomerToDatabase` 方法尚未在任何地方被调用，这给了我们一个很好的机会来思考如何测试它们的功能。我们知道在每次执行
    `CreateBooking` 时，我们至少会调用 `GetCustomerFromDatabase`，所以让我们从它开始。`GetCustomerFromDatabase`
    可以确定以下三种潜在状态：'
- en: The customer exists in the database.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户存在于数据库中。
- en: The customer does not exist in the database.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户不存在于数据库中。
- en: An `Exception` other than `CustomerNotFoundException` was thrown in `CustomerRepository.GetCustomerByName`.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CustomerRepository.GetCustomerByName` 中抛出了除 `CustomerNotFoundException` 之外的
    `Exception`。
- en: As far as success cases are concerned, paths 1 and 2 are relevant. If the customer
    is not found in the database, we add them by way of the `AddCustomerToDatabase`
    method. There is some more logic involved with that path, so, let’s stick to the
    happy path (1) for now. We’ll handle path number 3 (the total failure case) after
    dealing with the happy paths.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 就成功案例而言，路径 1 和 2 是相关的。如果客户在数据库中找不到，我们就通过 `AddCustomerToDatabase` 方法添加他们。该路径涉及一些额外的逻辑，所以，现在让我们专注于快乐路径（1）。在处理快乐路径之后，我们将处理路径编号
    3（完全失败的情况）。
- en: 'Before we can test any of the states, however, we need to add the customer
    database logic to the `CreateBooking` method as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们测试任何状态之前，我们需要将客户数据库逻辑添加到 `CreateBooking` 方法中，如下所示：
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To test the logic path where a customer does not exist in the database, we
    need to set up the `Mock<CustomerRepository>` to throw an exception of type `CustomerNotFoundException`
    when the `GetCustomerByName` method is called, as shown here:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试客户在数据库中不存在时的逻辑路径，我们需要设置 `Mock<CustomerRepository>`，在调用 `GetCustomerByName`
    方法时抛出 `CustomerNotFoundException` 类型的异常，如下所示：
- en: '[PRE26]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'That leaves just the following two code paths we need to provide tests for
    before we wrap up the `BookingService` implementation:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成 `BookingService` 实现之前，我们只需要提供以下两个代码路径的测试：
- en: The `GetCustomerByName` threw an exception other than `CustomerNotFoundException`.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetCustomerByName` 方法抛出了除 `CustomerNotFoundException` 之外的其他异常。'
- en: The `CreateCustomer` method returned a `false` Boolean.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateCustomer` 方法返回了一个 `false` 布尔值。'
- en: 'Luckily, both are easy unit tests to add. What if `BookingRepository.CreateBooking`
    threw an `Exception`? The `BookingService.CreateBooking` code *should* return
    `{false, CouldNotAddBookingToDatabaseException}`, but does it? There’s only one
    way to find out:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这两个都是容易添加的单元测试。如果 `BookingRepository.CreateBooking` 抛出 `Exception` 会怎样？`BookingService.CreateBooking`
    代码 *应该* 返回 `{false, CouldNotAddBookingToDatabaseException}`，但它真的这样做了吗？只有一个方法可以找到答案：
- en: '[PRE27]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It turns out that all is well. And with that, we can wrap up the implementation
    of `BookingService` and `BookingServiceTests`. In this section, we learned more
    about using mocks in unit tests and how to implement a service layer class that
    calls across the repository layer with dependency injection.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 结果证明一切顺利。因此，我们可以完成 `BookingService` 和 `BookingServiceTests` 的实现。在本节中，我们学习了更多关于在单元测试中使用模拟以及如何实现一个调用存储库层的依赖注入的服务层类。
- en: Exercises
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Exercise 11.1
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 11.1
- en: True or false? Repositories act as pass-throughs between controllers and services.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 真的是假的？存储库在控制器和服务之间充当传递者。
- en: Exercise 11.2
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 11.2
- en: 'Fill in the blanks: To add an injected dependency to a class, you have to add
    a class scoped private __________, which is assigned to a value in a __________
    that requires an injected __________.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 填空：要将注入的依赖项添加到类中，您必须添加一个类作用域的私有 __________，并将其分配给一个需要注入 __________ 的 __________
    中。
- en: a. method; constructor; property
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: a. 方法；构造函数；属性
- en: b. class; abstract method; variable
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: b. 类；抽象方法；变量
- en: c. field; constructor; parameter
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: c. 字段；构造函数；参数
- en: Exercise 11.3
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 11.3
- en: Let’s say I have two models in a dataset schema called Apple and Banana. The
    Apple.ID column has an outgoing foreign key relationship to the Banana.TastyWith
    column. Which service is allowed to call what repository?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我在一个名为 Apple 和 Banana 的数据集模式中有两个模型。Apple.ID 列与 Banana.TastyWith 列有一个外键关系。哪个服务允许调用什么存储库？
- en: a. The `Apple` service is allowed to call the `Banana` repository.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: a. 允许 `Apple` 服务调用 `Banana` 存储库。
- en: b. The `Banana` repository is allowed to call the `Apple` repository.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: b. 允许 `Banana` 存储库调用 `Apple` 存储库。
- en: c. The `Kiwi` repository is injected in both the `Apple` and `Banana` services
    and will take it from there.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: c. `Kiwi` 存储库被注入到 `Apple` 和 `Banana` 服务中，并从那里获取。
- en: Exercise 11.4
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 11.4
- en: True or false? A service class is allowed to call an unlimited number of repositories,
    as long as it has a valid reason to call every one of them.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 真的是假的？只要服务类有合法的理由调用每一个，它就可以调用无限数量的存储库。
- en: Exercise 11.5
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 11.5
- en: If you try to instantiate a type without providing the parameters required by
    any of its constructors, what do you get?
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试实例化一个类型而不提供其构造函数所需的任何参数，您会得到什么？
- en: a. A participation trophy
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: a. 参与奖
- en: b. A compilation error
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: b. 编译错误
- en: c. A runtime error
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: c. 运行时错误
- en: Exercise 11.6
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 11.6
- en: True or false? The discard operator ensures you never allocate any memory to
    store an expression’s return value.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 真的是假的？丢弃操作符确保您永远不会为存储表达式的返回值分配任何内存。
- en: Exercise 11.7
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 11.7
- en: You have two `catch` blocks in a `try-catch` code block. The first is a `catch`
    on the `Exception` class; the second is a `catch` on the `ItemSoldOutException`
    class. If an `ItemSoldOutException` is thrown in the `try` part of the `try-catch`
    code block, which `catch` block is entered?
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个`try-catch`代码块中，您有两个`catch`块。第一个是针对`Exception`类的`catch`；第二个是针对`ItemSoldOutException`类的`catch`。如果在`try-catch`代码块的`try`部分抛出了`ItemSoldOutException`，哪个`catch`块会被进入？
- en: a. `catch(Exception exception) {...}`
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: a. `catch(Exception exception) {...}`
- en: b. `catch(ItemSoldOutException exception) {...}`
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: b. `catch(ItemSoldOutException exception) {...}`
- en: Exercise 11.8
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 11.8
- en: You have two `catch` blocks in a `try-catch` code block. The first is a `catch`
    on the `ItemSoldOutException` class; the second is a `catch` on the `Exception`
    class. If an `ItemSoldOutException` is thrown in the `try` part of the `try-catch`
    code block, `which` catch block is entered?
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个`try-catch`代码块中，您有两个`catch`块。第一个是针对`ItemSoldOutException`类的`catch`；第二个是针对`Exception`类的`catch`。如果在`try-catch`代码块的`try`部分抛出了`ItemSoldOutException`，哪个`catch`块会被进入？
- en: a. `catch(ItemSoldOutException exception) {...}`
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: a. `catch(ItemSoldOutException exception) {...}`
- en: b. `catch(Exception exception) {...}`
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: b. `catch(Exception exception) {...}`
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: You can use the `Assert.IsInstanceOfType` to perform a test assertion on an
    object to check whether it is of a certain type (or can be coerced to that type
    using polymorphism). Checking types in unit tests can come in handy if you need
    to be sure a specific type was returned; for example, checking the type of `Exception`
    that was returned from a method.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`Assert.IsInstanceOfType`对对象执行测试断言，以检查它是否为某种类型（或可以使用多态强制转换为该类型）。在单元测试中检查类型，如果您需要确保返回了特定类型，可能会很有用；例如，检查从方法返回的`Exception`的类型。
- en: You can perform runtime type checks by using the `is` and `as` operators. This
    is helpful when dealing with objects that you may not know the exact type of.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`is`和`as`运算符进行运行时类型检查。这在处理可能不知道确切类型的对象时非常有用。
- en: Service classes are allowed to call repository classes where appropriate. You
    use service classes to organize multiple data streams into one view. Calling repository
    classes from a service also allows you to track down foreign key constraints.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在适当的情况下，服务类可以调用存储库类。您使用服务类将多个数据流组织成一个视图。从服务中调用存储库类还可以让您追踪外键约束。
- en: The discard operator (`_`) allows you to explicitly indicate that a method’s
    return value is a throwaway value. Sometimes using the discard operator can improve
    code readability.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛弃运算符（`_`）允许您明确指出方法返回值是一个可丢弃的值。有时使用抛弃运算符可以提高代码的可读性。
- en: The discard operator does allocate blocks of memory, but the garbage collector
    can collect on them as soon as possible because there are no pointers to said
    block of memory. This helps speed up performance.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛弃运算符确实会分配内存块，但由于没有指向该内存块的指针，垃圾收集器可以尽快收集它们。这有助于提高性能。
- en: You can have multiple `catch` blocks in a `try-catch` code block. Only the first
    matching `catch` block is entered. This is useful when dealing with more than
    one derived class of `Exception`, and your logic differs based on particular classes.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在`try-catch`代码块中拥有多个`catch`块。只有第一个匹配的`catch`块会被进入。当处理多个`Exception`的派生类，并且您的逻辑基于特定类而有所不同时，这非常有用。
