- en: Chapter 6\. Dealing with optional data
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6章\. 处理可选数据
- en: '***This chapter covers***'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '***本章涵盖的内容***'
- en: The `null` reference, or “the billion-dollar mistake”
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null`引用，或称为“十亿美元的错误”'
- en: Alternatives to `null` references
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null`引用的替代方案'
- en: Developing an `Option` data type for optional data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为可选数据开发`Option`数据类型
- en: Applying functions to optional values
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数应用于可选值
- en: Composing optional values
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合可选值
- en: '`Option` use cases'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Option`的使用案例'
- en: Representing optional data in computer programs has always been a problem. The
    concept of optional data is very simple in everyday life. Representing the absence
    of something when this something is contained in a container is easy—whatever
    it is, it can be represented by an empty container. An absence of apples can be
    represented by an empty apple basket. The absence of gasoline in a car can be
    visualized as an empty gas tank.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 可选数据的表示在计算机程序中一直是一个问题。在日常生活中，可选数据的概念非常简单。当某物包含在容器中时，表示这种事物的缺失是容易的——无论是什么，都可以用一个空容器来表示。苹果的缺失可以用一个空苹果篮子来表示。汽车中汽油的缺失可以想象成一个空油箱。
- en: Representing the absence of data in computer programs is more difficult. Most
    data is represented as a reference pointing to it, so the most obvious way to
    represent the absence of data is to use a pointer to nothing. This is what a null
    pointer is.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机程序中表示数据的缺失更困难。大多数数据都表示为指向它的引用，所以表示数据缺失的最明显方式是使用一个指向空值的指针。这就是空指针的含义。
- en: In Java, a variable is a pointer to a value. Variables may be created `null`
    (static and instance variables are created `null` by default), and they may then
    be changed to point to values. They can even be changed again to point to `null`
    if data is removed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，变量是一个指向值的指针。变量可以被创建为`null`（静态和实例变量默认创建为`null`），然后它们可以被更改以指向值。如果数据被移除，它们甚至可以被更改回指向`null`。
- en: To handle optional data, Java 8 introduced the `Optional` type. However, in
    this chapter, you’ll develop your own type, which you’ll call `Option`. The goal
    is to learn how this kind of structure works. After completing this chapter, you
    should feel free to use the standard Java 8 library version `Optional`, but you’ll
    see in the upcoming chapters that it’s much less powerful than the type you’ll
    create in this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理可选数据，Java 8引入了`Optional`类型。然而，在本章中，你将开发自己的类型，你将称之为`Option`。目标是了解这种结构是如何工作的。完成本章后，你应该可以自由地使用标准的Java
    8库版本`Optional`，但在接下来的章节中，你会发现它比你在本章中创建的类型要弱得多。
- en: 6.1\. Problems with the null pointer
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1\. `null`指针的问题
- en: One of the most frequent bugs in imperative programs is the `NullPointerException`.
    This error is raised when an identifier is dereferenced and found to be pointing
    to nothing. In other words, some data is expected but is found missing. Such an
    identifier is said to be pointing to `null`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式程序中最常见的错误之一是`NullPointerException`。当标识符被解引用并发现它指向空值时，会引发此错误。换句话说，预期某些数据，但发现数据缺失。这样的标识符被称为指向`null`。
- en: The `null` reference was invented in 1965 by Tony Hoare while he was designing
    the ALGOL object-oriented language. Here’s what he said 44 years later:^([[1](#ch06fn01)])
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`null`引用是在1965年由托尼·霍尔在为设计ALGOL面向对象语言时发明的。以下是他在44年后所说的话：^([[1](#ch06fn01)])'
- en: ¹
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Tony Hoare, “Null References: The Billion Dollar Mistake” (QCon, August 25,
    2009), [http://mng.bz/l2MC](http://mng.bz/l2MC).'
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '托尼·霍尔，“Null References: The Billion Dollar Mistake”（QCon，2009年8月25日），[http://mng.bz/l2MC](http://mng.bz/l2MC)。'
- en: I call it my billion-dollar mistake ... My goal was to ensure that all use of
    references should be absolutely safe, with checking performed automatically by
    the compiler. But I couldn’t resist the temptation to put in a null reference,
    simply because it was so easy to implement. This has led to innumerable errors,
    vulnerabilities, and system crashes, which have probably caused a billion dollars
    of pain and damage in the last forty years.
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我称之为我的十亿美元的错误……我的目标是确保所有引用的使用都绝对安全，由编译器自动执行检查。但我无法抗拒加入一个空引用的诱惑，仅仅因为它很容易实现。这导致了无数的错误、漏洞和系统崩溃，在过去四十年中可能造成了十亿美元的痛苦和损失。
- en: 'Although it should be well known nowadays that `null` references should be
    avoided, that’s far from being the case. The Java standard library contains methods
    and constructors taking optional parameters that must be set to `null` if they’re
    unused. Take, for example, the `java.net.Socket` class. This class defines the
    following constructor:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然现在应该众所周知应该避免`null`引用，但这远非事实。Java标准库包含接受可选参数的方法和构造函数，如果未使用，则必须设置为`null`。以`java.net.Socket`类为例。这个类定义了以下构造函数：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: According to the documentation,
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 根据文档，
- en: If the specified local address is `null`, it is the equivalent of specifying
    the address as the AnyLocal address.
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果指定的本地地址是`null`，它等同于指定地址为AnyLocal地址。
- en: 'Here, the `null` reference is a valid parameter. This is sometimes called a
    *business null*. Note that this way of handling the absence of data isn’t specific
    to objects. The port may also be absent, but it can’t be `null` because it’s a
    primitive:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`null`引用是一个有效的参数。这有时被称为*业务`null`*。请注意，这种处理数据缺失的方式并不仅限于对象。端口也可能不存在，但它不能是`null`，因为它是一个原始类型：
- en: '*A local port number of zero will let the system pick up a free port in the
    bind operation.*'
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*本地端口号为零将允许系统在绑定操作中选取一个空闲端口。*'
- en: This kind of value is sometimes called a *sentinel value*. It’s not used for
    the value itself (it doesn’t mean port 0) but to specify the absence of a port
    value.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的值有时被称为*哨兵值*。它不是用于值本身（它不意味着端口0），而是用于指定端口值的缺失。
- en: There are many other examples of handling the absence of data in the Java library.
    This is really dangerous because the fact that the local address is `null` could
    be unintentional and due to a previous error. But this won’t cause an exception.
    The program will continue working, although not as intended.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Java库中处理数据缺失的例子还有很多。这真的很危险，因为本地地址为`null`可能是无意的，并且是由于之前的错误。但这不会引发异常。程序将继续工作，尽管不是按照预期的方式。
- en: There are other cases of business nulls. If you try to retrieve a value from
    a `HashMap` using a key that’s not in the map, you’ll get a `null`. Is this an
    error? You don’t know. It might be that the key is valid but has not been registered
    in the map; or it might be that the key is supposedly valid and should be in the
    map, but there was a previous error while computing the key. For example, the
    key could be `null`, whether intentionally or due to an error, and this wouldn’t
    raise an exception. It could even return a non-`null` value because the `null`
    key is allowed in a `HashMap`. This situation is a complete mess.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 商业`null`还有其他情况。如果你尝试使用不在映射中的键从`HashMap`中检索值，你会得到一个`null`。这是错误吗？你不知道。可能这个键是有效的但尚未在映射中注册；或者可能这个键被认为是有效的，应该存在于映射中，但在计算键时发生了之前的错误。例如，键可能是`null`，无论是故意还是由于错误，这不会引发异常。它甚至可以返回非`null`值，因为`HashMap`允许`null`键。这种情况是一团糟。
- en: Of course, you know what to do about this. You know that you should never use
    a reference without checking whether it’s `null` or not. (You do this for each
    object parameter received by a method, don’t you?) And you know that you should
    never get a value from a map without first testing whether the map contains the
    corresponding key. And you know that you should never try to get an element from
    a list without verifying first that the list is not empty and that it has enough
    elements if you’re accessing the element through its index. And you do this all
    the time, so you never get a `NullPointerException` or an `IndexOutOfBoundsException`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你知道如何处理这个问题。你知道在使用引用之前，你应该检查它是否为`null`。 (你不为每个方法接收到的对象参数这样做，对吗？) 你知道在从映射中获取值之前，你应该先测试映射是否包含相应的键。你也知道，如果你通过索引访问元素，你应该首先验证列表不为空且具有足够的元素。你一直这样做，所以你永远不会得到`NullPointerException`或`IndexOutOfBoundsException`。
- en: If you’re this kind of perfect programmer, you can live with `null` references.
    But for the rest of us, an easier and safer way of dealing with the absence of
    a value, whether intentional or resulting from an error, is necessary. In this
    chapter, you’ll learn how to deal with absent values that aren’t the result of
    an error. This kind of data is called *optional data*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一位完美的程序员，你可以忍受`null`引用。但对于我们其他人来说，处理值缺失（无论是故意的还是由于错误的结果）的一种更简单、更安全的方法是必要的。在本章中，你将学习如何处理非错误结果的缺失值。这种数据被称为*可选数据*。
- en: 'Tricks for dealing with optional data have always been around. One of the best
    known and most often used is the list. When a method is supposed to return either
    a value or nothing, some programmers use a list as the return value. The list
    may contain zero or one element. Although this works perfectly, it has several
    important drawbacks:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 处理可选数据的技巧一直存在。最知名且最常使用的一种是列表。当一个方法应该返回一个值或无结果时，一些程序员使用列表作为返回值。列表可以包含零个或一个元素。尽管这可以完美工作，但它有几个重要的缺点：
- en: There’s no way to ensure that the list contains at most one element. What should
    you do if you receive a list of several elements?
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有办法确保列表最多只包含一个元素。如果你收到一个包含多个元素的列表，你应该怎么办？
- en: How can you distinguish between a list that’s supposed to hold at most one element
    and a regular list?
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何区分一个应该最多只包含一个元素的列表和一个普通列表？
- en: The `List` class defines many methods and functions to deal with the fact that
    lists may contain several elements. These methods are useless for our use case.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List` 类定义了许多方法和函数来处理列表可能包含多个元素的事实。这些方法对我们的用例来说是无用的。'
- en: Functional lists are recursive structures, and you don’t need this. A much simpler
    implementation is sufficient.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式列表是递归结构，你不需要这个。一个更简单的实现就足够了。
- en: 6.2\. Alternatives to null references
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2. 空引用的替代方案
- en: 'It looks like our goal is to avoid the `NullPointerException`, but this isn’t
    exactly the case. The `NullPointerException` should always indicate a bug. As
    such, you should apply the “fail fast” principle: if there’s an error, the program
    should fail as fast as possible. Totally removing business nulls won’t allow you
    to get rid of the `NullPointerException`. It will just ensure that `null` references
    will only be caused by bugs in the program and not by optional data.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们的目标是避免 `NullPointerException`，但这并不完全是这样。`NullPointerException` 应该始终指示一个错误。因此，你应该应用“快速失败”原则：如果存在错误，程序应该尽可能快地失败。完全移除业务
    `null` 不会让你摆脱 `NullPointerException`。它只会确保 `null` 引用仅由程序中的错误引起，而不是由可选数据引起。
- en: 'The following code is an example of a method returning optional data:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个返回可选数据的方法的示例：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `mean` function is an example of a *partial function*, as you saw in [chapter
    2](kindle_split_009.xhtml#ch02): it’s defined for all lists except the empty list.
    How should you handle the empty list case?'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`mean` 函数是一个部分函数的例子，正如你在[第2章](kindle_split_009.xhtml#ch02)中看到的：它对所有列表（除了空列表）都进行了定义。你应该如何处理空列表的情况？'
- en: 'One possibility is to return a sentinel value. What value should you choose?
    Because the type is `Double`, you can use a value that’s defined in the `Double`
    class:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能性是返回一个哨兵值。你应该选择什么值？因为类型是 `Double`，你可以使用在 `Double` 类中定义的值：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This works because `Double.NaN` (Not a Number) is actually a *double value*
    (note the lowercase *d*). `Double.NaN` is a primitive!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为 `Double.NaN`（不是一个数字）实际上是一个 *double 值*（注意小写的 *d*）。`Double.NaN` 是一个原始值！
- en: 'So far so good, but you have three problems:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利，但你有三个问题：
- en: What if you want to apply the same principle to a function returning an `Integer`?
    There’s no equivalent to the `NaN` value in the integer class.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要将相同的原理应用到返回 `Integer` 的函数上，整数类中没有 `NaN` 值的等价物。
- en: How can you signal to the user of your function that it could return a sentinel
    value?
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何向你的函数的用户发出信号，表明它可能返回一个哨兵值？
- en: How can you handle a parametric function, such as
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何处理一个参数化函数，例如
- en: '[PRE3]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Another solution is to throw an exception:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个解决方案是抛出异常：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'But this solution is ugly and creates more trouble than it solves:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个解决方案很丑陋，并且比解决的问题更多：
- en: Exceptions are generally used for erroneous results, but here there’s no error.
    There’s simply no result, and that’s because there was no input data! Or should
    you consider calling the function with an empty list a bug?
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常通常用于错误结果，但在这里并没有错误。实际上没有结果，这是因为没有输入数据！或者你应该认为调用空列表的函数是一个错误？
- en: What exception should you throw? A custom one (like in the example)? Or a standard
    one?
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该抛出哪种异常？一个自定义的（如示例中所示）？还是标准的一个？
- en: Should you use a checked or unchecked exception? Moreover, your function is
    no longer a pure function. It’s no longer referentially transparent, which leads
    to the numerous problems I talked about in [chapter 2](kindle_split_009.xhtml#ch02).
    Also, your function is no longer composable.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该使用检查型异常还是非检查型异常？此外，你的函数不再是一个纯函数。它不再具有引用透明性，这导致了我[第2章](kindle_split_009.xhtml#ch02)中提到的许多问题。此外，你的函数不再可组合。
- en: 'You could also return `null` and let the caller deal with it:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以返回`null`并让调用者处理它：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Returning `null` is the worst possible solution:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`null`是最糟糕的解决方案：
- en: It forces (ideally) the caller to test the result for `null` and act accordingly.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它强制（理想情况下）调用者测试结果是否为`null`并相应地处理。
- en: It will crash if boxing is used.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用装箱，它将崩溃。
- en: As with the exception solution, the function is no longer composable.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与异常解决方案一样，函数不再可组合。
- en: It allows the potential problem to be propagated far from its origin. If the
    caller forgets to test for a `null` result, a `NullPointerException` could be
    thrown from anywhere in the code.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许潜在的问题从其源头传播得很远。如果调用者忘记测试`null`结果，`NullPointerException`可能会从代码的任何地方抛出。
- en: 'A better solution would be to ask the user to provide a special value that
    will be returned if no data is available. For example, this function computes
    the maximum value of a list:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是要求用户提供一个特殊值，如果数据不可用，则返回该值。例如，这个函数计算列表的最大值：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here’s how you could define a `max` function:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你定义`max`函数的方法：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Remember that you must use a method that returns the function because there’s
    no way to parameterize a property.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你必须使用返回函数的方法，因为没有方法可以参数化属性。
- en: 'If you find this too complex, here’s a functional method version:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得这太复杂，这里有一个函数式方法版本：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This works, but it’s overcomplicated. The simplest solution would be to return
    a list:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这可行，但过于复杂。最简单的解决方案是返回一个列表：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Although this solution works perfectly, it’s a bit ugly because the argument
    type and the return type of the function are the same, although they don’t represent
    the same thing. To solve this problem, you could simply create a new type, similar
    to `List` but with a different name indicating what it’s supposed to mean. And
    while you’re at it, you could select a more suitable implementation ensuring that
    this “list” will have at most one element.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个解决方案工作得很好，但它有点丑陋，因为函数的参数类型和返回类型相同，尽管它们并不代表相同的东西。为了解决这个问题，你可以简单地创建一个新的类型，类似于`List`但具有不同的名称，以表明它的含义。同时，你可以选择一个更合适的实现，确保这个“列表”最多只有一个元素。
- en: 6.3\. The Option data type
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3. `Option`数据类型
- en: The `Option` data type you’ll create in this chapter will be very similar to
    the `List` data type. Using an `Option` type for optional data allows you to compose
    functions even when the data is absent (see [figure 6.1](#ch06fig01)). It will
    be implemented as an abstract class, `Option`, containing two private subclasses
    representing the presence and the absence of data. The subclass representing the
    absence of data will be called `None`, and the subclass representing the presence
    of data will be called `Some`. A `Some` will contain the corresponding data value.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中你将创建的`Option`数据类型将与`List`数据类型非常相似。使用`Option`类型处理可选数据允许你在数据不存在的情况下组合函数（参见[图6.1](#ch06fig01)）。它将作为一个抽象类`Option`实现，包含两个表示数据存在和不存在私有子类。表示数据不存在的子类将被称为`None`，表示数据存在的子类将被称为`Some`。`Some`将包含相应的数据值。
- en: Figure 6.1\. Without the `Option type`, composing functions wouldn’t produce
    a function because the resulting program would potentially throw a `NullPointerException`.
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.1. 没有使用`Option`类型，组合函数不会产生函数，因为生成的程序可能会抛出`NullPointerException`。
- en: '![](Images/06fig01_alt.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06fig01_alt.jpg)'
- en: The following listing shows the code for these three classes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了这三个类的代码。
- en: Listing 6.1\. The `Option data type`
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.1. `Option`数据类型
- en: '![](Images/ch06ex01-0.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch06ex01-0.jpg)'
- en: '![](Images/ch06ex01-1.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch06ex01-1.jpg)'
- en: In this listing, you can see how close `Option` is to `List`. They’re both abstract
    classes with two private implementations. The `None` subclass corresponds to `Nil`
    and the `Some` subclass to `Cons`. The `getOrThrow` method is similar to the `head`
    method in `List`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，你可以看到`Option`与`List`有多接近。它们都是具有两个私有实现的抽象类。`None`子类对应于`Nil`，而`Some`子类对应于`Cons`。`getOrThrow`方法类似于`List`中的`head`方法。
- en: 'You can use `Option` for your definition of the `max` function, as shown here:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`Option`来定义`max`函数，如下所示：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now your function is a total function, which means it has a value for all lists,
    including the empty one. Note how similar this code is to the version returning
    a list. Although the implementation of `Option` is different from the `List` implementation,
    its usage is nearly the same. As you’ll see soon, the similarity extends much
    further.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的函数是一个全函数，这意味着它对所有列表都有值，包括空列表。注意这段代码与返回列表的版本是多么相似。尽管`Option`的实现与`List`的实现不同，但它们的用法几乎相同。正如你很快就会看到的，这种相似性延伸得更远。
- en: But as it is, the `Option` class isn’t very useful. The only way to use an `Option`
    would be to test the actual class to see if it’s a `Some` or a `None`, and call
    the `getOrThrow` method to obtain the value in the former case. And this method
    will throw an exception if there’s no data, which isn’t very functional. To make
    it a powerful tool, you’ll need to add some methods, in the same way you did for
    `List`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 但就目前而言，`Option`类并不很有用。使用`Option`的唯一方法就是测试实际的类以确定它是否是`Some`或`None`，并在前者的情况下调用`getOrThrow`方法来获取值。如果没有数据，这个方法将抛出异常，这并不很实用。为了使其成为一个强大的工具，你需要添加一些方法，就像你为`List`所做的那样。
- en: 6.3.1\. Getting a value from an Option
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.1. 从`Option`获取值
- en: Many methods that you created for `List` will also be useful for `Option`. In
    fact, only methods related to multiple values, such as folds, may be useless here.
    But before you create these methods, let’s start with some `Option`-specific usage.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你为`List`创建的许多方法也将对`Option`有用。实际上，只有与多个值相关的、如折叠等方法可能在这里无用。但在你创建这些方法之前，让我们先从一些`Option`特定的用法开始。
- en: To avoid testing for the subclass of an `Option`, you need to define methods
    that, unlike `getOrThrow`, may be useful in both subclasses, so you can call them
    from the `Option` parent class. The first thing you’ll need is a way to retrieve
    the value in an `Option`. One frequent use case when data is missing is to use
    a default value.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免测试`Option`的子类，你需要定义方法，这些方法与`getOrThrow`不同，可能在两个子类中都很有用，因此你可以从`Option`父类中调用它们。你需要做的第一件事是找到一种方法来检索`Option`中的值。当数据缺失时，使用默认值是一个常见的用例。
- en: Exercise 6.1
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 6.1
- en: 'Implement a `getOrElse` method that will return either the contained value
    if it exists, or a provided default one otherwise. Here’s the method signature:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个`getOrElse`方法，该方法将返回包含的值（如果存在），否则返回提供的默认值。以下是方法签名：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Solution 6.1
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 6.1
- en: 'This method will be implemented as an instance method declared in the abstract
    `Option` class as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将被实现为一个在抽象`Option`类中声明的实例方法，如下所示：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `Some` implementation is obvious and will simply return the value it contains:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Some`实现很明显，它将简单地返回它包含的值：'
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `None` implementation will return the default value:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`None`实现将返回默认值：'
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'So far so good. You can now define methods that return options and use the
    returned value transparently, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利。你现在可以定义返回选项的方法，并像下面这样透明地使用返回值：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, `max1` will be equal to `7` (the maximum value in the list), and `max2`
    will be set to `0` (the default value).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`max1`将等于`7`（列表中的最大值），而`max2`将被设置为`0`（默认值）。
- en: 'But you might be having a problem. Look at the following example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可能遇到了问题。看看下面的例子：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Of course, this example is a bit contrived. The `getDefault` method isn’t functional
    at all. This is only to show you what’s happening. What will this example print?
    If you think it will print 7 and then throw an exception, think again.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个例子有点牵强。`getDefault`方法根本不是函数式的。这只是为了向你展示发生了什么。这个例子会打印什么？如果你认为它会打印7然后抛出异常，那么再想想。
- en: This example will print nothing and will directly throw an exception because
    Java is a strict language. Method parameters are evaluated before the method is
    actually executed, whether they’re needed or not. The `getOrElse` method parameter
    is thus evaluated in any case, whether it’s called on a `Some` or a `None`. The
    fact that the method parameter isn’t needed for a `Some` is irrelevant. This makes
    no difference when the parameter is a literal, but it makes a huge difference
    when it’s a method call. The `getDefault` method will be called in any case, so
    the first line will throw an exception and nothing will be displayed. This is
    generally not what you want.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将不会打印任何内容，并直接抛出异常，因为Java是一种严格的语言。方法参数在方法实际执行之前进行评估，无论它们是否需要。因此，`getOrElse`方法参数在任何情况下都会被评估，无论是调用`Some`还是`None`。对于`Some`来说，方法参数不是必需的这一点无关紧要。当参数是字面量时，这没有区别，但当它是一个方法调用时，这就有很大区别。`getDefault`方法在任何情况下都会被调用，所以第一行将抛出异常，并且不会显示任何内容。这通常不是你想要的。
- en: Exercise 6.2
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习6.2
- en: Fix the previous problem by using lazy evaluation for the `getOrElse` method
    parameter.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对`getOrElse`方法参数使用延迟评估来解决前面的问题。
- en: Hint
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Use the `Supplier` class you defined in [chapter 3](kindle_split_010.xhtml#ch03)
    (exercise 3.2).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你在[第3章](kindle_split_010.xhtml#ch03)（练习3.2）中定义的`Supplier`类。
- en: Solution 6.2
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案6.2
- en: The signature of the method will be changed to
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 方法签名将更改为
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `Some` implementation doesn’t change, except for the method signature,
    because the parameter isn’t used:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`Some`的实现没有变化，除了方法签名，因为参数没有被使用：'
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The most important change is in the `None` class:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是`None`类的变化：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the absence of a value, the parameter is evaluated through a call to the
    `Supplier.get()` method. The `max` example can now be rewritten as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有值的情况下，参数通过调用`Supplier.get()`方法进行评估。现在可以将`max`示例重写如下：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This program prints 7 to the console before throwing an exception.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序在抛出异常之前将7打印到控制台。
- en: Now that you have the `getOrElse` method, you don’t need the `getOrThrow` method
    any longer. But it might be useful when developing other methods for the `Option`
    class, so we’ll keep it and make it protected.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了`getOrElse`方法，你不再需要`getOrThrow`方法了。但在为`Option`类开发其他方法时，它可能很有用，所以我们将保留它并将其设置为受保护的。
- en: 6.3.2\. Applying functions to optional values
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.2\. 将函数应用于可选值
- en: One very important method in `List` is the `map` method, which allows you to
    apply a function from `A` to `B` to each element of a list of `A`, producing a
    list of `B`. Considering that an `Option` is like a list containing at most one
    element, you can apply the same principle.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在`List`中有一个非常重要的方法，即`map`方法，它允许你将一个从`A`到`B`的函数应用于`A`类型列表的每个元素，从而生成一个`B`类型的列表。考虑到`Option`就像一个最多包含一个元素的列表，你可以应用同样的原则。
- en: Exercise 6.3
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习6.3
- en: Create a `map` method to change an `Option<A>` into an `Option<B>` by applying
    a function from `A` to `B`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`map`方法，通过应用从`A`到`B`的函数将`Option<A>`转换为`Option<B>`。
- en: Hint
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Define an abstract method in the `Option` class with one implementation in each
    subclass. The method signature in `Option` will be
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Option`类中定义一个抽象方法，并在每个子类中实现一个。`Option`中的方法签名将是
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Solution 6.3
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案6.3
- en: 'The `None` implementation is simple. You just have to return a `None` instance.
    As I said earlier, the `Option` class contains a `None` singleton that can be
    used for this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`None`的实现很简单。你只需要返回一个`None`实例。正如我之前所说的，`Option`类包含一个`None`单例，可以用于此目的：'
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that although `this` and `none` refer to the same object, you can’t return
    `this` because it’s parameterized with `A`. The `none` reference points to the
    same object, but with a raw type (no parameter). This is why you annotate `none`
    with `@SuppressWarnings ("rawtypes")` in order to keep compiler warnings from
    leaking to the caller. In the same manner, you use a call to the `none()` factory
    method instead of directly accessing the `none` instance in order to avoid the
    “Unchecked assignment warning” that you already avoided in the `none()` method
    by using the `@SuppressWarnings ("unchecked")` annotation.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管`this`和`none`指向同一个对象，但你不能返回`this`，因为它用`A`进行了参数化。`none`引用指向同一个对象，但具有原始类型（没有参数）。这就是为什么你用`@SuppressWarnings
    ("rawtypes")`注解`none`，以防止编译器警告泄露给调用者。同样地，你使用对`none()`工厂方法的调用，而不是直接访问`none`实例，以避免“未检查的赋值警告”，你已经在`none()`方法中通过使用`@SuppressWarnings
    ("unchecked")`注解避免了这种警告。
- en: 'The `Some` implementation isn’t much more complex. All you need to do is get
    the value, apply the function to it, and wrap the result in a new `Some`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Some` 实现并不复杂。你只需要获取值，将其应用于函数，并将结果包装在一个新的 `Some` 中：'
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 6.3.3\. Dealing with Option composition
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.3\. 处理 Option 组合
- en: As you’ll soon realize, functions from `A` to `B` aren’t the most common ones
    in functional programming. At first you may have trouble getting acquainted with
    functions returning optional values. After all, it seems to involve extra work
    to wrap values in `Some` instances and later retrieve these values. But with further
    practice, you’ll see that these operations occur only rarely. When chaining functions
    to build a complex computation, you’ll often start with a value that’s returned
    by some previous computation and pass the result to a new function without seeing
    the intermediate result. In other words, you’ll more often use functions from
    `A` to `Option<B>` than functions from `A` to `B`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你很快就会意识到，从 `A` 到 `B` 的函数在函数式编程中并不是最常见的。一开始你可能难以熟悉返回可选值的函数。毕竟，似乎需要在 `Some` 实例中包装值并在之后检索这些值，这需要额外的工作。但随着进一步的练习，你会发现这些操作很少发生。当链式调用函数构建复杂计算时，你通常会从一个由先前计算返回的值开始，将结果传递给新函数，而不会看到中间结果。换句话说，你将更频繁地使用从
    `A` 到 `Option<B>` 的函数，而不是从 `A` 到 `B` 的函数。
- en: Think about the `List` class. Does this ring a bell? Yes, it leads to the `flatMap`
    method.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下 `List` 类。这让你想起什么吗？是的，它导致了 `flatMap` 方法。
- en: Exercise 6.4
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 6.4
- en: Create a `flatMap` instance method that takes as an argument a function from
    `A` to `Option<B>` and returns an `Option<B>`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个接受从 `A` 到 `Option<B>` 的函数作为参数的 `flatMap` 实例方法，并返回一个 `Option<B>`。
- en: Hint
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: You can define different implementations in both subclasses; but you should
    try to devise a unique implementation that works for both subclasses and put it
    in the `Option` class. Its signature will be
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在两个子类中定义不同的实现；但你应该尝试设计一个适用于两个子类的独特实现，并将其放入 `Option` 类。它的签名将是
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Try using some of the methods you already have (`map` and `getOrElse`).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用你已有的方法（`map` 和 `getOrElse`）。
- en: Solution 6.4
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 6.4
- en: 'The trivial solution would be to define an abstract method in the `Option`
    class, return `none()` in the `None` class, and return `f.apply(this.value)` in
    the `Some` class. This is probably the most efficient implementation. But a more
    elegant solution is to map the `f` function, giving an `Option<Option<B>>`, and
    then use the `getOrElse` method to extract the value (`Option<B>`), providing
    `None` as the default value:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的解决方案是在 `Option` 类中定义一个抽象方法，在 `None` 类中返回 `none()`，在 `Some` 类中返回 `f.apply(this.value)`。这可能是最有效的实现。但一个更优雅的解决方案是映射
    `f` 函数，得到一个 `Option<Option<B>>`，然后使用 `getOrElse` 方法提取值（`Option<B>`），提供 `None`
    作为默认值：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Exercise 6.5
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 6.5
- en: 'Just as you needed a way to map a function that returns an `Option` (leading
    to `flatMap`), you’ll need a version of `getOrElse` for `Option` default values.
    Create the `orElse` method with the following signature:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你需要一种映射返回 `Option` 的函数（导致 `flatMap`），你还需要一个 `getOrElse` 的版本用于 `Option` 默认值。创建一个具有以下签名的
    `orElse` 方法：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Hint
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: 'As you might guess from the name, there’s no need to “get” the value in order
    to implement this method. This is how `Option` is mostly used: through `Option`
    composition rather than wrapping and getting values. One consequence is that the
    same implementation will work for both subclasses.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，为了实现这个方法，不需要“获取”值。这就是 `Option` 主要的使用方式：通过 `Option` 组合而不是包装和获取值。一个结果是，相同的实现将适用于两个子类。
- en: Solution 6.5
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 6.5
- en: 'The solution consists in mapping the function `x -> this`, which results in
    an `Option<Option<A>`, and then using `getOrElse` on this result with the provided
    default value:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案在于映射函数 `x -> this`，这会导致一个 `Option<Option<A>>`，然后使用提供的默认值对这一结果调用 `getOrElse`：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Exercise 6.6
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 6.6
- en: 'In [chapter 5](kindle_split_012.xhtml#ch05), you created a `filter` method
    to remove from a list all elements that didn’t satisfy a condition expressed in
    the form of a predicate (in other words, it was a function returning a `Boolean`).
    Create the same method for `Option`. Here’s its signature:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 5 章](kindle_split_012.xhtml#ch05) 中，你创建了一个 `filter` 方法来从列表中移除所有不满足以谓词形式表达的条件（换句话说，它是一个返回
    `Boolean` 的函数）的所有元素。为 `Option` 创建相同的方法。以下是它的签名：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Hint
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Because an `Option` is like a `List` with at most one element, the implementation
    seems trivial. In the `None` subclass, you simply return `none()`. In the `Some`
    class, you return the original `Option` if the condition holds, and `none()` otherwise.
    But try to devise a smarter implementation that fits in the `Option` parent class.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `Option` 类似于最多只有一个元素的 `List`，所以实现看起来很简单。在 `None` 子类中，你只需返回 `none()`。在 `Some`
    类中，如果条件成立，则返回原始的 `Option`，否则返回 `none()`。但尝试设计一个更智能的实现，使其适合 `Option` 父类。
- en: Solution 6.6
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 6.6
- en: 'The solution is to `flatMap` the function used in the `Some` case:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是将 `Some` 情况下使用的函数 `flatMap`：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 6.3.4\. Option use cases
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.4\. 选项使用案例
- en: If you already know about the Java 8 `Optional` class, you may have remarked
    that `Optional` contains an `isPresent()` method allowing you to test whether
    the `Optional` contains a value or not. (`Optional` has a different implementation
    that’s not based on two different subclasses.) You can easily implement such a
    method, although you’ll call it `isSome()` because it will test whether the object
    is a `Some` or a `None`. You could also call it `isNone()`, which might seem more
    logical because it would be the equivalent of the `List.isEmpty()` method.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经了解 Java 8 的 `Optional` 类，你可能已经注意到 `Optional` 包含一个 `isPresent()` 方法，允许你测试
    `Optional` 是否包含值。（`Optional` 有一个不同的实现，它不基于两个不同的子类。）你可以轻松实现这样一个方法，尽管你会称它为 `isSome()`，因为它将测试对象是否是
    `Some` 或 `None`。你也可以称它为 `isNone()`，这可能更合逻辑，因为它将是 `List.isEmpty()` 方法的等效。
- en: 'Although the `isSome()` method is sometimes useful, it’s not the best way to
    use the `Option` class. If you were to test an `Option` through the `isSome()`
    method before calling `getOrThrow()` to get the value, it wouldn’t be much different
    from testing a reference for `null` before dereferencing it. The only difference
    would be in the case where you forget to test first: you’d risk seeing an `IllegalStateException`
    instead of a `NullPointerException`.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `isSome()` 方法有时很有用，但并不是使用 `Option` 类的最佳方式。如果你在调用 `getOrThrow()` 获取值之前，通过
    `isSome()` 方法测试 `Option`，那么这和在取消引用之前测试 `null` 引用的引用不会有太大区别。唯一的区别在于，如果你忘记先进行测试，你会看到
    `IllegalStateException` 而不是 `NullPointerException`。
- en: 'The best way to use `Option` is through composition. To do this, you must create
    all the necessary methods for all use cases. These use cases correspond to what
    you’d do with the value after testing that it’s not `null`. You could do one of
    the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Option` 的最佳方式是通过组合。为此，你必须为所有用例创建所有必要的函数。这些用例对应于你在测试它不是 `null` 之后会做什么。你可以做以下之一：
- en: Use the value as the input to another function
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将值作为另一个函数的输入
- en: Apply an effect to the value
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对值应用效果
- en: Use the value if it’s not `null`, or use a default value to apply a function
    or an effect
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果值不是 `null`，则使用该值，或者使用默认值应用函数或效果
- en: The first and third use cases have already been made possible through the methods
    you’ve already created. Applying an effect can be done in different ways that
    you’ll learn about in [chapter 13](kindle_split_020.xhtml#ch13).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个和第三个用例已经通过你已创建的方法实现。应用效果可以通过不同的方式完成，你将在第 13 章（kindle_split_020.xhtml#ch13）中了解到。
- en: As an example, look at how the `Option` class can be used to change the way
    you use a map. [Listing 6.2](#ch06ex02) shows the implementation of a functional
    `Map`. This is not a functional implementation, but only a wrapper around a legacy
    `ConcurrentHashMap` to give it a functional interface.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看 `Option` 类如何改变你使用映射的方式。[列表 6.2](#ch06ex02) 展示了函数式 `Map` 的实现。这不是一个函数式实现，而是一个围绕旧版
    `ConcurrentHashMap` 的包装，以提供函数式接口。
- en: Listing 6.2\. Using `Option` in a functional `Map`
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.2\. 在函数式 `Map` 中使用 `Option`
- en: '![](Images/ch06ex02-0.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch06ex02-0.jpg)'
- en: '![](Images/ch06ex02-1.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch06ex02-1.jpg)'
- en: As you can see, `Option` allows you to encapsulate into the map implementation
    the pattern for querying the map with `containsKey` before calling `get`. The
    following listing shows how this is intended to be used.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Option` 允许你在调用 `get` 之前，将查询映射的模式封装到映射实现中。以下列表展示了如何使用它。
- en: Listing 6.3\. Putting `Option` to work
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.3\. 将 `Option` 应用起来
- en: '![](Images/ch06ex03-0.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch06ex03-0.jpg)'
- en: '![](Images/ch06ex03-1.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch06ex03-1.jpg)'
- en: In this (very simplified) program, you can see how various functions returning
    `Option` can be composed. You don’t have to test for anything, and you don’t risk
    a `NullPointer-Exception`, although you may be asking for the email of a `Toon`
    that doesn’t have one, or even for a `Toon` that doesn’t exist in the map.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个（非常简化的）程序中，你可以看到如何组合返回 `Option` 的各种函数。你不需要进行任何测试，也不必担心 `NullPointer-Exception`，尽管你可能会请求一个
    `Toon` 的电子邮件，而这个 `Toon` 没有电子邮件，或者甚至请求一个在映射中不存在的 `Toon`。
- en: But there’s a little problem. This program prints
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里有个小问题。这个程序打印
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The first line is Mickey’s email. The second line says “No data” because Minnie
    has no email. The third line says “No data” because Goofy isn’t in the map. Clearly,
    you’d need a way to distinguish these two cases. The `Option` class doesn’t allow
    you to distinguish the two. You’ll see in the next chapter how you can solve this
    problem.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是米奇的电子邮件。第二行说“无数据”，因为米妮没有电子邮件。第三行说“无数据”，因为高飞不在映射中。显然，你需要一种方法来区分这两种情况。`Option`
    类不允许你区分这两种情况。你将在下一章中看到如何解决这个问题。
- en: Exercise 6.7
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 6.7
- en: 'Implement the `variance` function in terms of `flatMap`. The variance of a
    series of values represents how those values are distributed around the mean.
    If all values are very near to the mean, the variance is low. A variance of 0
    is obtained when all values are equal to the mean. The variance of a series is
    the mean of `Math.pow(x - m, 2)` for each element `x` in the series, `m` being
    the mean of the series. Here’s the signature of the function:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `flatMap` 实现一个 `variance` 函数。一系列值的方差表示这些值围绕平均值分布的情况。如果所有值都非常接近平均值，则方差较低。当所有值都等于平均值时，方差为
    0。一系列的方差是系列中每个元素 `x` 的 `Math.pow(x - m, 2)` 的平均值，其中 `m` 是系列的均值。以下是函数的签名：
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Hint
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: 'To implement this function, you must first implement a function to compute
    the sum of a `List<Double>`. Then you should create a `mean` function like the
    one you created previously in this chapter, but working on doubles. If you have
    trouble defining these functions, refer to [chapters 4](kindle_split_011.xhtml#ch04)
    and [5](kindle_split_012.xhtml#ch05) or use the following functions:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这个函数，你必须首先实现一个计算 `List<Double>` 的总和的函数。然后你应该创建一个 `mean` 函数，就像你在本章前面创建的那样，但针对双精度浮点数。如果你在定义这些函数时遇到困难，请参阅[第
    4 章](kindle_split_011.xhtml#ch04)和[第 5 章](kindle_split_012.xhtml#ch05)或使用以下函数：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Solution 6.7
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 6.7
- en: 'Once you’ve defined the `sum` and `mean` functions, the `variance` function
    is quite simple:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你定义了 `sum` 和 `mean` 函数，`variance` 函数就相当简单：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that using functions isn’t mandatory. You must use functions if you need
    to pass them as arguments to higher-order functions, but when you only need to
    apply them, functional methods may be simpler to use.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用函数不是强制性的。如果你需要将它们作为参数传递给高阶函数，则必须使用函数，但当你只需要应用它们时，函数式方法可能更简单易用。
- en: 'If you prefer to use methods when possible, you may arrive at the following
    solution:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢在可能的情况下使用方法，你可能会得到以下解决方案：
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see, functional methods are simpler to use for two reasons. First,
    you don’t need to write `.apply` between the name of the function and the argument.
    Second, the types are shorter because you don’t need to write the word `Function`.
    For this reason, you’ll use functional methods instead of functions as often as
    possible.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，函数式方法由于两个原因更容易使用。首先，你不需要在函数名称和参数之间写 `.apply`。其次，类型更短，因为你不需要写 `Function`
    这个词。因此，你将尽可能多地使用函数式方法而不是函数。
- en: But remember that it’s very easy to switch from one to the other. Given this
    method,
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 但记住，从一种切换到另一种非常容易。给定这个方法，
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'you can create an equivalent function by writing this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过编写以下内容创建一个等效函数：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Or you can use a method reference:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以使用方法引用：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Conversely, you can create a method from the preceding function:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你可以从前面的函数创建一个方法：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As the implementation of `variance` demonstrates, with `flatMap` you can construct
    a computation with multiple stages, any of which may fail, and the computation
    will abort as soon as the first failure is encountered, because `None.flatMap(f)`
    will immediately return `None` without applying `f`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如 `variance` 的实现所示，使用 `flatMap` 可以构建具有多个阶段的计算，其中任何一个都可能失败，并且一旦遇到第一个失败，计算就会终止，因为
    `None.flatMap(f)` 会立即返回 `None` 而不应用 `f`。
- en: 6.3.5\. Other ways to combine options
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.5\. 其他组合选项的方法
- en: Deciding to use `Option` may seem to have huge consequences. In particular,
    some developers may believe that their legacy code will be made obsolete. What
    can you do now that you need a function from `Option<A>` to `Option<B>`, and you
    only have an API with methods for converting an `A` into a `B`? Do you need to
    rewrite all your libraries? Not at all. You can easily adapt them.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 决定使用 `Option` 可能会带来巨大的影响。特别是，一些开发者可能认为他们的旧代码将变得过时。现在你需要一个从 `Option<A>` 到 `Option<B>`
    的函数，而你只有将 `A` 转换为 `B` 的方法的 API，你该怎么办？你需要重写所有库吗？一点也不用。你可以轻松地适应它们。
- en: Exercise 6.8
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 6.8
- en: Define a `lift` method that takes a function from `A` to `B` as its argument
    and returns a function from `Option<A>` to `Option<B>`. As usual, use the methods
    you’ve defined already. [Figure 6.2](#ch06fig02) shows that the lift method works.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个 `lift` 方法，它接受一个从 `A` 到 `B` 的函数作为其参数，并返回一个从 `Option<A>` 到 `Option<B>` 的函数。像往常一样，使用你已定义的方法。[图
    6.2](#ch06fig02) 显示了 `lift` 方法的工作原理。
- en: Figure 6.2\. Lifting a function
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.2. 提升函数
- en: '![](Images/06fig02_alt.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2](Images/06fig02_alt.jpg)'
- en: Hint
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Use the `map` method to create a static method in the `Option` class.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `map` 方法在 `Option` 类中创建一个静态方法。
- en: Solution 6.8
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解答 6.8
- en: 'The solution is pretty simple:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案相当简单：
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Of course, most of your existing libraries won’t contain functions but methods.
    Converting a method that takes an `A` as its argument and returns a `B` into a
    function from `Option<A>` to `Option<B>` is easy. For example, lifting the method
    `String.toUpperCase` can be done this way:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你现有的大多数库不会包含函数，而是包含方法。将接受 `A` 作为参数并返回 `B` 的方法转换为从 `Option<A>` 到 `Option<B>`
    的函数很容易。例如，提升 `String.toUpperCase` 方法可以这样进行：
- en: '[PRE40]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Or you can use a method reference:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以使用方法引用：
- en: '[PRE41]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Exercise 6.9
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 6.9
- en: Such solutions are useless for methods that throw exceptions. Write a `lift`
    method that works with methods that throw exceptions.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的解决方案对于会抛出异常的方法是无用的。编写一个与抛出异常的方法一起工作的 `lift` 方法。
- en: Solution 6.9
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解答 6.9
- en: 'All you have to do is wrap the implementation of the function returned by `lift`
    in a `try ... catch` block, returning `None` if an exception is thrown:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你所需要做的就是将 `lift` 返回的函数的实现包装在一个 `try ... catch` 块中，如果抛出异常则返回 `None`：
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You might also need to transform a function from `A` to `B` into a function
    from `A` to `Option<B>`. You can apply the same technique:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还需要将一个从 `A` 到 `B` 的函数转换为从 `A` 到 `Option<B>` 的函数。你可以应用相同的技巧：
- en: '[PRE43]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note, however, that this is not very useful, because the exception is lost.
    In the next chapter, you’ll learn how to solve this problem.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，然而，这并不很有用，因为异常被丢失了。在下一章，你将学习如何解决这个问题。
- en: What if you want to use a legacy method taking two arguments? Let’s say you
    want to use the `Integer.parseInt(String s, int radix)` with an `Option<String>`
    and an `Option<Integer>`. How can you do this?
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用接受两个参数的旧方法呢？比如说，你想使用 `Integer.parseInt(String s, int radix)` 与 `Option<String>`
    和 `Option<Integer>` 一起。你该如何做？
- en: 'The first step is to create a function from this method. That’s simple:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建从这个方法来的函数。这很简单：
- en: '[PRE44]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Note that I’ve inverted the arguments here to create a curried function. This
    makes sense because applying the radix only would give us a useful function that
    can parse all strings with a given radix:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我已经在这里反转了参数以创建一个柯里化函数。这很有意义，因为仅应用基数将给我们一个有用的函数，可以解析具有给定基数的所有字符串：
- en: '[PRE45]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The inverse (applying a `String` first) would make much less sense.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 反向（先应用 `String`）将没有太多意义。
- en: Exercise 6.10
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 6.10
- en: Write a method `map2` taking as its arguments an `Option<A>`, an `Option<B>`,
    and a function from `(A, B)` to `C` in curried form, and returning an `Option<C>`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为 `map2` 的方法，它接受一个 `Option<A>`、一个 `Option<B>` 和一个从 `(A, B)` 到 `C` 的函数（以柯里化形式），并返回一个
    `Option<C>`。
- en: Hint
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Use the `flatMap` and possibly the `map` methods.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `flatMap` 和可能还有 `map` 方法。
- en: Solution 6.10
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解答 6.10
- en: Here’s the solution using `flatMap` and `map`. This pattern is very important
    to understand, and you’ll come across it often. We’ll come back to this in [chapter
    8](kindle_split_015.xhtml#ch08).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 `flatMap` 和 `map` 的解决方案。这个模式非常重要，你经常会遇到它。我们将在第 8 章（kindle_split_015.xhtml#ch08）中再次回到这个话题。
- en: '[PRE46]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: With `map2`, you can now use any two-argument method as if it had been created
    for manipulating `Option`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 `map2`，你可以使用任何两个参数的方法，就像它是为操作 `Option` 而创建的一样。
- en: 'What about methods with more arguments? Here’s an example of a `map3` method:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 更多参数的方法怎么办？这里是一个 `map3` 方法的例子：
- en: '[PRE47]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Do you see the pattern?
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到模式了吗？
- en: 6.3.6\. Composing List with Option
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.6. 使用 Option 组合列表
- en: Composing `Option` instances is not all you need. Each new type you define must
    be, at some point, composable with any other. In the previous chapter, you defined
    the `List` type. To write useful programs, you need to be able to compose `List`
    and `Option`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 组合 `Option` 实例并不需要所有功能。你定义的每个新类型都必须在某个时刻与其他任何类型组合。在前一章中，你定义了 `List` 类型。为了编写有用的程序，你需要能够组合
    `List` 和 `Option`。
- en: The most common operation is converting a `List<Option<A>>` into an `Option<List<A>>`.
    A `List<Option<A>>` is what you get when mapping a `List<B>` with a function from
    `B` to `Option<A>`. Usually, what you’ll need for the result is a `Some<List<A>>`
    if all elements are `Some<A>`, and a `None<List<A>>` if at least one element is
    a `None<A>`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的操作是将 `List<Option<A>>` 转换为 `Option<List<A>>`。当你使用从 `B` 到 `Option<A>` 的函数将
    `List<B>` 映射时，你会得到一个 `List<Option<A>>`。通常，如果你需要的结果是 `Some<List<A>>`，则所有元素都是 `Some<A>`，如果至少有一个元素是
    `None<A>`，则结果是 `None<List<A>>`。
- en: Exercise 6.11
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 6.11
- en: 'Write a function `sequence` that combines a `List<Option<T>>` into an `Option<List<T>>`.
    It will be a `Some<List<T>>` if all values in the original list were `Some` instances,
    or a `None<List<T>>` otherwise. Here’s its signature:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数 `sequence`，将 `List<Option<T>>` 合并成一个 `Option<List<T>>`。如果原始列表中的所有值都是
    `Some` 实例，则它将是一个 `Some<List<T>>`，否则是一个 `None<List<T>>`。以下是它的签名：
- en: '[PRE48]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Hint
  id: totrans-248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: To find your way, you can test the list to see whether it’s empty or not and
    make a recursive call to `sequence` if not. Then, remembering that `foldRight`
    and `foldLeft` abstract recursion, you could use one of those methods to implement
    `sequence`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到你的方向，你可以测试列表是否为空，如果不是，则对 `sequence` 进行递归调用。然后，记住 `foldRight` 和 `foldLeft`
    抽象了递归，你可以使用这些方法之一来实现 `sequence`。
- en: Solution 6.11
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 6.11
- en: 'Here’s an explicitly recursive version that could be used if `list.head()`
    and `list.tail()` were made public:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个显式递归版本，如果 `list.head()` 和 `list.tail()` 被公开，则可以用来：
- en: '[PRE49]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: But `list.head()` and `list.tail()` should be usable only inside the `List`
    class, because these methods may throw exceptions. Fortunately, the `sequence`
    method can also be implemented using `foldRight` and `map2`. This is even better,
    because `fold-Right` uses heap-based recursion.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 但 `list.head()` 和 `list.tail()` 应该只能在 `List` 类内部使用，因为这些方法可能会抛出异常。幸运的是，`sequence`
    方法也可以使用 `foldRight` 和 `map2` 来实现。这甚至更好，因为 `foldRight` 使用基于堆的递归。
- en: '[PRE50]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Consider the following example:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE51]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This produces the intended result but is somewhat inefficient, because the `map`
    method and the `sequence` method will both invoke `foldRight`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生预期的结果，但效率不高，因为 `map` 方法和 `sequence` 方法都会调用 `foldRight`。
- en: Exercise 6.12
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 6.12
- en: 'Define a `traverse` method that produces the same result but invokes `foldRight`
    only once. Here’s its signature:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个 `traverse` 方法，它产生相同的结果，但只调用一次 `foldRight`。以下是它的签名：
- en: '[PRE52]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Hint
  id: totrans-261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: You need to implement `sequence` in terms of `traverse`. Don’t use recursion.
    Prefer the `foldRight` method that abstracts recursion for you.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要根据 `traverse` 实现 `sequence`。不要使用递归。优先使用抽象递归的 `foldRight` 方法。
- en: Solution 6.12
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 6.12
- en: 'First define the `traverse` method:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 首先定义 `traverse` 方法：
- en: '[PRE53]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then you can redefine the `sequence` method in terms of `traverse`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以根据 `traverse` 重新定义 `sequence` 方法：
- en: '[PRE54]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 6.4\. Miscellaneous utilities for Option
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4. 其他 `Option` 实用工具
- en: In order to make `Option` as useful as possible, you need to add some utility
    methods. Some of these methods are a must, and others are questionable because
    their use is not in the spirit of functional programming. You nevertheless must
    consider adding them. You may need a method to test whether an `Option` is a `None`
    or a `Some`. You may also need an `equals` method for comparing options, in which
    case you mustn’t forget to define a compatible `hashCode` method.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 `Option` 尽可能有用，你需要添加一些实用方法。其中一些方法是必须的，而其他方法则值得怀疑，因为它们的使用并不符合函数式编程的精神。尽管如此，你仍然需要考虑添加它们。你可能需要一个方法来测试
    `Option` 是否为 `None` 或 `Some`。你可能还需要一个 `equals` 方法来比较选项，在这种情况下，你一定不要忘记定义一个兼容的 `hashCode`
    方法。
- en: 6.4.1\. Testing for Some or None
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.1. 测试 Some 或 None
- en: Until now, you haven’t needed to test an option to know whether it was a `Some`
    or a `None`. Ideally, you should never have to do this. In practice, though, there
    are times when it’s simpler to use this trick than to resort to real functional
    techniques.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你不需要测试选项来知道它是 `Some` 还是 `None`。理想情况下，你永远不应该需要这样做。在实践中，尽管如此，有时使用这个技巧比求助于真正的函数式技术更简单。
- en: For example, you defined the `map2` method as
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你将 `map2` 方法定义为
- en: '[PRE55]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This is very smart, and because you want to look smart, you might prefer this
    solution. But some may find the following version simpler to understand:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常聪明，因为你想要显得聪明，你可能更喜欢这个解决方案。但有些人可能觉得以下版本更容易理解：
- en: '[PRE56]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '|  |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Testing the Code
  id: totrans-277
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 测试代码
- en: If you want to test this code, you’ll have to define the `isSome` method first,
    but this is not to encourage you to use this nonfunctional technique. You should
    always prefer the first form, but you should also understand fully the relation
    between the two forms. Besides, you’ll probably find yourself needing the `isSome`
    method someday.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要测试这段代码，你首先需要定义`isSome`方法，但这并不是鼓励你使用这种非函数式技术。你应该始终首选第一种形式，但也应该完全理解两种形式之间的关系。此外，你可能会发现自己某天需要使用`isSome`方法。
- en: '|  |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 6.4.2\. equals and hashcode
  id: totrans-280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.2\. 等于和hashCode
- en: Much more important are the definitions of the `equals` and `hashcode` methods.
    As you know, these methods are strongly related and must be consistently defined.
    If `equals` is `true` for two instances of `Option`, their `hashcode` methods
    should return the same value. (The inverse is not true. Objects having the same
    `hashcode` may not always be equal.)
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是`equals`和`hashCode`方法的定义。正如你所知，这些方法密切相关，必须保持一致的定义。如果两个`Option`实例的`equals`为`true`，它们的`hashCode`方法应该返回相同的值。（反之则不成立。具有相同`hashCode`的对象可能并不总是相等的。）
- en: 'Here are the implementations of `equals` and `hashcode` for `Some`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Some`的`equals`和`hashCode`方法的实现：
- en: '[PRE57]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'And here are the corresponding implementations for `None`:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`None`的相应实现：
- en: '[PRE58]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 6.5\. How and when to use Option
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5\. 如何以及何时使用Option
- en: As you may know, Java 8 has introduced the `Optional` class that may be seen
    by some as identical to your `Option`, although it’s not implemented in the same
    way at all, and it lacks most of the functional methods you’ve put into `Option`.
    There’s much controversy about whether the new features of Java 8 are a move toward
    functional programming. They certainly are, although this is not official. The
    official position is that `Optional` is not a functional feature.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，Java 8引入了`Optional`类，有些人可能认为它与你的`Option`相同，尽管它的实现方式完全不同，并且缺少了你在`Option`中放入的大多数功能方法。关于Java
    8的新特性是否是向函数式编程迈进的一步，存在很多争议。它们确实如此，尽管这并非官方立场。官方立场是`Optional`不是一个函数式特性。
- en: Here’s how Brian Goetz, Java language architect at Oracle, answered a question
    about this subject on Stack Overflow. The question was “Should Java 8 getters
    return optional types?” Here is Brian Goetz’s answer:^([[2](#ch06fn02)])
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是Oracle的Java语言架构师Brian Goetz在Stack Overflow上关于这个问题的回答。问题是“Java 8的getters应该返回optional类型吗？”以下是Brian
    Goetz的回答:^([[2](#ch06fn02)])
- en: ²
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The full discussion may be read at [http://mng.bz/Rkk1](http://mng.bz/Rkk1).
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 完整的讨论可以在[http://mng.bz/Rkk1](http://mng.bz/Rkk1)阅读。
- en: Of course, people will do what they want. But we did have a clear intention
    when adding this feature, and it was not to be a general purpose `Maybe` or `Some`
    type, as much as many people would have liked us to do so. Our intention was to
    provide a limited mechanism for library method return types where there needed
    to be a clear way to represent “no result” and using `null` for such was overwhelmingly
    likely to cause errors.
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当然，人们会做他们想做的事情。但我们添加这个功能时确实有一个明确的目的，那就是它不是一个通用的`Maybe`或`Some`类型，尽管很多人希望我们这样做。我们的目的是提供一个有限的机制，用于库方法的返回类型，当需要明确表示“无结果”时，使用`null`几乎肯定会引起错误。
- en: ''
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For example, you probably should never use it for something that returns an
    array of results, or a list of results; instead return an empty array or list.
    You should almost never use it as a field of something or a method parameter.
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 例如，你可能永远不应该用它来返回结果数组或结果列表；相反，应该返回一个空数组或列表。你几乎从不应该将它用作某个对象的字段或方法参数。
- en: ''
  id: totrans-295
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I think routinely using it as a return value for getters would definitely be
    over-use.
  id: totrans-296
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我认为将其作为getters的返回值使用肯定是一种过度使用。
- en: ''
  id: totrans-297
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There’s nothing wrong with `Optional` that it should be avoided, it’s just not
    what many people wish it were, and accordingly we were fairly concerned about
    the risk of zealous over-use.
  id: totrans-298
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Optional`没有错误到需要避免，它只是不是许多人希望它成为的那样，因此我们相当关注过度使用的风险。'
- en: ''
  id: totrans-299
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '(Public service announcement: NEVER call `Optional.get` unless you can prove
    it will never be `null`; instead use one of the safe methods like `orElse` or
    `ifPresent`. In retrospect, we should have called get something like getOrElse-ThrowNoSuch-Element-Exception
    or something that made it far clearer that this was a highly dangerous method
    that undermined the whole purpose of `Optional` in the first place. Lesson learned.)'
  id: totrans-300
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: （公共服务公告：除非你能证明它永远不会是`null`，否则永远不要调用`Optional.get`；相反，使用像`orElse`或`ifPresent`这样的安全方法。回顾过去，我们本应该将`get`命名为类似于`getOrElse-ThrowNoSuch-Element-Exception`的东西，这样就可以更清楚地表明这是一个非常危险的方法，它从根本上破坏了`Optional`的整个目的。教训已经吸取。）
- en: 'This is a very important answer that deserves some reflection. First of all,
    and this might be the most important part, “people will do what they want.” Nothing
    to add here. Just do what *you* want. This doesn’t mean you should do whatever
    you want without thinking. But feel free to try every solution that comes to mind.
    You shouldn’t refrain from using `Optional` in a particular way just because it
    wasn’t intended to be used that way. Imagine the first man who ever thought about
    grabbing a stone to hit something with more strength. He had two options (pun
    intended!): refraining from doing it because stones had obviously not been intended
    to be used as hammers, or just trying it.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常重要的答案，值得深思。首先，也许这是最重要的部分，“人们会做他们想做的事情。”这里没有更多要说的。只做你*想*做的事情。这并不意味着你应该不考虑后果地做任何你想做的事情。但你可以自由地尝试所有想到的解决方案。你不应该仅仅因为`Optional`不是用来那样使用的，就避免以特定方式使用它。想象一下第一个想到用石头砸东西的人。他有两个选择（这不是巧合！）：因为显然石头不是用来当锤子的，所以避免这样做，或者只是尝试一下。
- en: Second, Goetz says that `get` shouldn’t be called unless you can prove it will
    never be `null`. Doing this would completely ruin any benefit of using `Option`.
    But you don’t need to give `get` a very long name. `getOrThrow` would do the job.
    Note that returning an empty list to indicate the absence of a result doesn’t
    by itself solve the problem. Forgetting to test whether the list is empty will
    produce an `IndexOutOfBoundException` instead of a `NullPointerException`. Not
    much better!
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，Goetz说，除非你能证明它永远不会是`null`，否则不应该调用`get`。这样做会完全破坏使用`Option`的任何好处。但你不需要给`get`一个很长的名字。`getOrThrow`就可以完成这项工作。请注意，为了表示没有结果而返回一个空列表本身并不能解决问题。忘记测试列表是否为空会导致`IndexOutOfBoundException`而不是`NullPointerException`。这并没有好到哪里去！
- en: '|  |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**When to use getOrThrow**'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**何时使用getOrThrow**'
- en: The correct advice is to avoid `getOrThrow` as much as possible. As a rule of
    thumb, each time you find yourself using this method outside of the `Option` class,
    you should consider whether there’s another way to go. Using `getOrThrow` is exiting
    the functional safety of the `Option` class.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的建议是尽可能避免使用`getOrThrow`。作为一个经验法则，每次你发现自己在外部`Option`类中使用这个方法时，你应该考虑是否有其他可行的方式。使用`getOrThrow`意味着你正在退出`Option`类的函数安全性。
- en: The same thing is true for the `head` and `tail` methods of the `List` class.
    If possible, these methods shouldn’t be used outside of the `List` class. Directly
    accessing the value(s) contained in classes like `List` or `Option` always brings
    the risk of a `NullPointerException` if this is done on the `None` or `Nil` subclasses.
    It may not be possible to avoid in library classes, but it should be avoided in
    business classes. That’s why the best solution is to make this method protected,
    so that it can only be called from inside the `Option` class.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`List`类的`head`和`tail`方法来说，情况也是一样的。如果可能的话，这些方法不应该在`List`类外部使用。直接访问`List`或`Option`等类中包含的值总是存在风险，如果在`None`或`Nil`子类上这样做，可能会引发`NullPointerException`。在库类中可能无法避免这种情况，但在业务类中应该避免。这就是为什么最好的解决方案是将此方法设为受保护的，这样它就只能从`Option`类内部调用。
- en: '|  |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'But the most important point is the original question: should getters return
    `Option` (or `Optional`)? Generally, they shouldn’t, because properties should
    be final and initialized at declaration or in constructors, so there’s absolutely
    no need for getters to return `Option`. (I must admit, however, that initializing
    fields in constructors doesn’t guarantee that access to properties is impossible
    before they’re initialized. This is a marginal problem that’s easily solved by
    making classes final, if possible.)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 但最重要的点是原始问题：getter 应该返回 `Option`（或 `Optional`）吗？通常情况下，它们不应该，因为属性应该是最终的，并且在声明或构造函数中初始化，所以完全没有必要让
    getter 返回 `Option`。（然而，我必须承认，在构造函数中初始化字段并不能保证在它们初始化之前无法访问属性。这是一个可以通过将类设置为最终类来轻松解决的问题，如果可能的话。）
- en: But some properties might be optional. For example, a person will always have
    a first name and a last name, but they might have no email. How can you represent
    this? By storing the property as an `Option`. In such cases, the getter will have
    to return an `Option`. Saying that “routinely using it as a return value for getters
    would definitely be over-use” is like saying that a property without a value should
    be set to `null`, and the corresponding getter should return `null`. This completely
    destroys the benefit of having `Option`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 但有些属性可能是可选的。例如，一个人总是会有一个名字和一个姓氏，但他们可能没有电子邮件。你该如何表示这一点？通过将属性存储为 `Option`。在这种情况下，getter
    将必须返回一个 `Option`。说“常规地将其用作 getter 的返回值肯定是一种过度使用”就像说没有值的属性应该设置为 `null`，相应的 getter
    应该返回 `null`。这完全破坏了拥有 `Option` 的好处。
- en: 'What about methods that take `Option` as their argument? In general, this should
    not occur. To compose methods returning `Option`, you shouldn’t use methods that
    take `Option` as their argument. For example, to compose the three following methods,
    you don’t need to change the methods to make them accept `Option` as their argument:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 那么关于接受 `Option` 作为参数的方法呢？一般来说，这种情况不应该发生。为了组合返回 `Option` 的方法，你不应该使用接受 `Option`
    作为参数的方法。例如，为了组合以下三个方法，你不需要更改方法以使它们接受 `Option` 作为参数：
- en: '[PRE59]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Given that the `validate` method is a static method of class `Validate`, and
    `toonMap` is an instance of `Map` with the `get` instance method, the functional
    way to compose these methods is as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `validate` 方法是 `Validate` 类的静态方法，而 `toonMap` 是一个具有 `get` 实例方法的 `Map` 实例，那么组合这些方法的函数式方法是以下这样：
- en: '[PRE60]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: So there’s little use for methods taking `Option` as parameters in business
    code.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在业务代码中，接受 `Option` 作为参数的方法用途很小。
- en: There’s another reason why `Option` (or `Optional`) should probably be used
    rarely (if ever). Generally, the absence of data is the result of errors that
    you should often handle by throwing an exception in imperative Java. As I said
    previously, returning `Option.None` instead of throwing an exception is like catching
    an exception and swallowing it silently. Usually it’s not a billion-dollar mistake,
    but it’s still a big one. You’ll learn in the next chapter how to deal with this
    situation. After that, you’ll hardly ever need the `Option` data type again. But
    don’t worry. All you’ve learned in this chapter will still be extremely useful.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个原因，为什么 `Option`（或 `Optional`）可能很少（如果有的话）被使用。通常，数据的缺失是错误的结果，你通常应该通过在命令式
    Java 中抛出异常来处理这些错误。正如我之前所说的，返回 `Option.None` 而不是抛出异常就像捕获异常然后默默地吞下它一样。这通常不是一笔价值十亿美元的错误，但它仍然是一个很大的错误。你将在下一章中学习如何处理这种情况。在那之后，你几乎再也不需要
    `Option` 数据类型了。但别担心。你在这个章节中学到的所有内容仍然会非常有用。
- en: The `Option` type is the simplest form of a kind of data type that you’ll use
    again and again. It’s a parameterized type, it has a method to make an `Option<A>`
    from an `A`, and it has a `flatMap` method that can be used to compose `Option`
    instances. Although it’s not very useful by itself, it has acquainted you with
    very fundamental concepts of functional programming.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`Option` 类型是你将反复使用的一种数据类型的简单形式。它是一个参数化类型，它有一个方法可以将 `A` 转换为 `Option<A>`，并且它有一个
    `flatMap` 方法，可以用来组合 `Option` 实例。尽管它本身并不非常有用，但它让你熟悉了函数式编程的非常基本的概念。'
- en: 6.6\. Summary
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6. 摘要
- en: You need a way to represent optional data, which means data that may or may
    not be present.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要一个方法来表示可选数据，这意味着数据可能存在也可能不存在。
- en: The `null` pointer is the most impractical and dangerous way to represent the
    absence of data.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null` 指针是表示数据缺失最不实用且危险的方式。'
- en: Sentinel values and empty lists are other possible ways to represent the absence
    of data, but they don’t compose well.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监视值和空列表是表示数据缺失的另一种可能方式，但它们组合得并不好。
- en: The `Option` data type is a much better way to represent optional data. The
    `Some` subtype represents data, and the `None` subtype represents the absence
    of data.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Option` 数据类型是表示可选数据的一种更好的方式。`Some` 子类型表示数据，而 `None` 子类型表示数据的缺失。'
- en: Functions can be applied to `Option` through the `map` and `flatMap` methods,
    allowing for easy `Option` composition.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数可以通过 `map` 和 `flatMap` 方法应用于 `Option`，从而实现轻松的 `Option` 组合。
- en: Functions operating on values may be lifted to operate on `Option` instances.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作值的函数可以提升为操作 `Option` 实例。
- en: '`List` can be composed with `Option`. A `List<Option>` can be turned into an
    `Option<List>` using the `sequence` method.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List` 可以与 `Option` 组合。使用 `sequence` 方法，`List<Option>` 可以转换为 `Option<List>`。'
- en: '`Option` instances can be compared for equality. Instances of subtype `Some`
    are equal if their wrapped values are equal. Because there’s only one instance
    of `None`, all instances of `None` are equal.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以比较 `Option` 实例的相等性。如果包装的值相等，则 `Some` 子类型的实例是相等的。因为只有一个 `None` 实例，所以所有 `None`
    实例都是相等的。
- en: Although `Option` may represent the result of a computation producing an exception,
    all information about the occurring exception is lost. In the next chapter, you’ll
    learn how to deal with this problem.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然 `Option` 可能代表产生异常的计算结果，但所有关于发生的异常的信息都丢失了。在下一章中，你将学习如何处理这个问题。
