- en: Chapter 10\. Introducing the Forms API
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 10 章\. 介绍表单 API
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Understanding the Angular Forms API
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Angular 表单 API
- en: Working with template-driven forms
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模板驱动表单
- en: Working with reactive forms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用响应式表单
- en: HTML provides basic features for displaying forms, validating entered values,
    and submitting data to the server. But HTML forms may not be good enough for real-world
    applications, which need a way to programmatically process the entered data, apply
    custom validation rules, display user-friendly error messages, transform the format
    of the entered data, and choose the way data is submitted to the server. For business
    applications, one of the most important considerations when choosing a web framework
    is how well it handles forms.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 提供了显示表单、验证输入值以及将数据提交到服务器的基本功能。但 HTML 表单可能不足以满足现实世界的应用需求，这些应用需要一种程序化处理输入数据、应用自定义验证规则、显示用户友好的错误信息、转换输入数据格式以及选择将数据提交到服务器的方式的方法。对于商业应用来说，在选择
    Web 框架时，最重要的考虑因素之一是它处理表单的能力如何。
- en: 'Angular offers rich support for handling forms. It goes beyond regular data
    binding by treating form fields as first-class citizens and providing fine-grained
    control over form data. In this chapter, we’ll introduce you two Forms APIs: template-driven
    and reactive.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 为处理表单提供了丰富的支持。它不仅超越了常规的数据绑定，还将表单字段视为一等公民，并提供了对表单数据的精细控制。在本章中，我们将向您介绍两个表单
    API：模板驱动和响应式。
- en: 10.1\. Two Forms APIs
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1\. 两个表单 API
- en: 'Every Angular-powered form has an underlying model object that stores the form’s
    data. There are two approaches to working with forms in Angular: *template-driven*
    and *reactive*. These two approaches are exposed as two different APIs (sets of
    directives and TypeScript classes).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 每个由 Angular 驱动的表单都有一个底层模型对象，用于存储表单数据。在 Angular 中处理表单有两种方法：*模板驱动*和*响应式*。这两种方法分别作为两个不同的
    API（一组指令和 TypeScript 类）公开。
- en: With the *template-driven* API, forms are fully programmed in the component’s
    template using directives, and the model object is created implicitly by Angular.
    The template defines the structure of the form, the format of its fields, and
    the validation rules. Because you’re limited to HTML syntax while defining the
    form, the template-driven approach suits only simple forms.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *模板驱动* API，表单完全通过组件的模板使用指令编程，模型对象由 Angular 隐式创建。模板定义了表单的结构、字段格式和验证规则。由于在定义表单时你受限于
    HTML 语法，因此模板驱动方法仅适用于简单表单。
- en: With the reactive API, you explicitly create the model object in TypeScript
    code and then link the HTML template elements to that model’s properties using
    special directives. You construct the form model object explicitly using the `FormControl`,
    `FormGroup`, and `FormArray` classes. In the template-driven approach, you don’t
    access these classes directly, whereas in the reactive approach, you explicitly
    create instances of these classes. For non-trivial forms, the reactive approach
    is a better option.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用响应式 API，你需要在 TypeScript 代码中显式创建模型对象，然后使用特殊指令将 HTML 模板元素链接到该模型的属性。你使用 `FormControl`、`FormGroup`
    和 `FormArray` 类显式构建表单模型对象。在模板驱动方法中，你不会直接访问这些类，而在响应式方法中，你显式创建这些类的实例。对于非平凡表单，响应式方法是一个更好的选择。
- en: Both template-driven and reactive APIs need to be explicitly enabled before
    you start using them. To enable reactive forms, add `ReactiveFormsModule` from
    `@angular/forms` to the `imports` list of `NgModule`. For template-driven forms,
    import `FormsModule`, as shown in the following listing.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用之前，模板驱动和响应式 API 都需要显式启用。要启用响应式表单，请将 `ReactiveFormsModule` 从 `@angular/forms`
    添加到 `NgModule` 的 `imports` 列表中。对于模板驱动表单，如以下示例所示，导入 `FormsModule`。
- en: Listing 10.1\. Preparing to use the template-driven Forms API
  id: totrans-12
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.1\. 准备使用模板驱动表单 API
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* Adds support for the template-driven Forms API**'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 添加了对模板驱动表单 API 的支持**'
- en: It’s time to discuss both APIs in greater detail.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候更详细地讨论这两个 API 了。
- en: 10.2\. Template-driven forms
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2\. 模板驱动表单
- en: 'With the template-driven API, you can use only directives in a component’s
    templates. These directives are included in the `FormsModule`: `NgModel`, `NgModelGroup`,
    and `NgForm`. We’ll briefly look at these directives and then apply the template-driven
    approach to the sample registration form.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板驱动 API，你只能在组件的模板中使用指令。这些指令包含在 `FormsModule` 中：`NgModel`、`NgModelGroup` 和
    `NgForm`。我们将简要介绍这些指令，然后应用模板驱动方法到示例注册表单中。
- en: 10.2.1\. Forms directives
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.1\. 表单指令
- en: 'This section briefly describes the three main directives from `FormsModule`:
    `NgModel`, `NgModelGroup`, and `NgForm`. We’ll show you how they can be used in
    the template and highlight their most important features.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本节简要介绍了 `FormsModule` 的三个主要指令：`NgModel`、`NgModelGroup` 和 `NgForm`。我们将向您展示它们如何在模板中使用，并突出它们最重要的功能。
- en: NgForm
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: NgForm
- en: '`NgForm` is the directive that represents the entire form. It’s automatically
    attached to every `<form>` element. `NgForm` implicitly creates an instance of
    the `FormGroup` class that represents the model and stores the form’s data (more
    on `FormGroup` later in this chapter). `NgForm` automatically discovers all child
    HTML elements marked with the `NgModel` directive and adds their values to the
    form model object.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`NgForm` 是表示整个表单的指令。它自动附加到每个 `<form>` 元素上。`NgForm` 隐式创建一个 `FormGroup` 类的实例，该实例表示模型并存储表单数据（关于
    `FormGroup` 的更多内容将在本章后面介绍）。`NgForm` 自动发现所有带有 `NgModel` 指令的子 HTML 元素，并将它们的值添加到表单模型对象中。'
- en: You can bind an implicitly created `NgForm` object to a local template variable
    so you can access values of the `NgForm` object inside the template, as shown
    in the following listing.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将隐式创建的 `NgForm` 对象绑定到局部模板变量，以便在模板内部访问 `NgForm` 对象的值，如下面的列表所示。
- en: Listing 10.2\. Binding `NgForm` to a template variable
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.2\. 将 `NgForm` 绑定到模板变量
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* Declares a local template variable f and binds it to ngForm**'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明一个局部模板变量 f 并将其绑定到 ngForm**'
- en: '***2* Displays the values of the form model**'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 显示表单模型中的值**'
- en: The local template variable `f` points at the instance of `NgForm` attached
    to the `<form>`. Then you can use the `f` variable to access instance members
    of the `NgForm` object. One of them is `value`, which represents a JavaScript
    object containing current values of all form fields. You can pass it through the
    standard `json` pipe to display the form’s value on the page.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 局部模板变量 `f` 指向 `<form>` 元素上附加的 `NgForm` 实例。然后您可以使用 `f` 变量来访问 `NgForm` 对象的实例成员。其中之一是
    `value`，它表示一个包含所有表单字段当前值的 JavaScript 对象。您可以通过标准的 `json` 管道传递它，以在页面上显示表单的值。
- en: '`NgForm` intercepts the standard HTML form’s `submit` event and prevents automatic
    form submission. Instead, it emits the custom `ngSubmit` event:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`NgForm` 截获标准 HTML 表单的 `submit` 事件并阻止自动表单提交。相反，它发出自定义的 `ngSubmit` 事件：'
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This subscribes to the `ngSubmit` event using event-binding syntax. The `onSubmit`
    handler is a method with an arbitrary name defined in the component, and it’s
    invoked when the `ngSubmit` event is emitted. To pass all the form’s values as
    an argument to this method, use a local template variable (for example, `f`) to
    access `NgForm`’s `value` property.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过事件绑定语法订阅 `ngSubmit` 事件。`onSubmit` 处理器是在组件中定义的一个具有任意名称的方法，当 `ngSubmit` 事件发出时会被调用。为了将所有表单的值作为参数传递给此方法，请使用局部模板变量（例如，`f`）来访问
    `NgForm` 的 `value` 属性。
- en: NgModel
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: NgModel
- en: '[Section 2.6.2](kindle_split_011.xhtml#ch02lev2sec3) of [chapter 2](kindle_split_011.xhtml#ch02)
    discusses how the `NgModel` directive can be used for two-way data binding. But
    in the Forms API, `NgModel` plays a different role: it marks the HTML element
    that should become a part of the form model.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 2 章第 2.6.2 节](kindle_split_011.xhtml#ch02lev2sec3) 讨论了如何使用 `NgModel` 指令进行双向数据绑定。但在表单
    API 中，`NgModel` 扮演着不同的角色：它标记了应该成为表单模型一部分的 HTML 元素。'
- en: In the context of the Forms API, `NgModel` represents a single field on the
    form. If an HTML element includes `ngModel`, Angular implicitly creates an instance
    of the `FormControl` class that represents the model and stores the fields’ data
    (more on `FormControl` later in this chapter). Note that the Forms API doesn’t
    require a value assigned to `ngModel`, nor any kind of brackets around this attribute,
    as you can see in the following listing.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在表单 API 的上下文中，`NgModel` 表示表单上的单个字段。如果一个 HTML 元素包含 `ngModel`，Angular 会隐式创建一个
    `FormControl` 类的实例，该实例表示模型并存储字段数据（关于 `FormControl` 的更多内容将在本章后面介绍）。请注意，表单 API 不需要为
    `ngModel` 分配值，也不需要围绕此属性使用任何类型的括号，如下面的列表所示。
- en: Listing 10.3\. Adding the `NgModel` directive to an HTML element
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.3\. 将 `NgModel` 指令添加到 HTML 元素
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* The name attribute is required so you can access its value in the code.**'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 名称属性是必需的，这样您可以在代码中访问其值。**'
- en: '***2* Ensures that this <input> field is included in the form model object**'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 确保此 <input> 字段包含在表单模型对象中**'
- en: The `NgForm.value` property points at the JavaScript object that holds the values
    of all form fields. The value of the field’s name attribute becomes the property
    name of the corresponding property in the JavaScript object in `NgForm.value`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`NgForm.value` 属性指向包含所有表单字段值的 JavaScript 对象。字段名称属性的值成为 `NgForm.value` 中对应属性的属性名。'
- en: '|  |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Although the names of the classes that implement form directives are capitalized,
    their names should start with a lowercase letter in templates (for example, `NgForm`
    versus `ngForm`).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然实现表单指令的类名首字母大写，但在模板中它们的名称应该以小写字母开头（例如，`NgForm` 与 `ngForm`）。
- en: '|  |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: NgModelGroup
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: NgModelGroup
- en: '`NgModelGroup` represents a part of the form and allows you to group form fields
    together. Like `NgForm`, it implicitly creates an instance of the `FormGroup`
    class. `NgModelGroup` creates a nested object inside the object stored in `NgForm.value`.
    All the child fields of `NgModelGroup` become properties of the nested object,
    as you can see in the following listing.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`NgModelGroup` 表示表单的一部分，允许您将表单字段分组在一起。像 `NgForm` 一样，它隐式创建了一个 `FormGroup` 类的实例。`NgModelGroup`
    在存储在 `NgForm.value` 中的对象内部创建一个嵌套对象。`NgModelGroup` 的所有子字段都成为嵌套对象的属性，如下所示。'
- en: Listing 10.4\. A form with a nested form
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.4\. 嵌套表单
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* The ngModelGroup attribute requires a string value, which becomes a property
    name representing the nested form.**'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* ngModelGroup 属性需要一个字符串值，该值成为表示嵌套表单的属性名。**'
- en: '***2* Accesses the values of the password and pconfirm form controls, using
    the nested object passwords for reference**'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用嵌套对象 passwords 作为参考，访问密码和 pconfirm 表单控件的值**'
- en: '[Table 10.1](#ch10table01) contains a summary of directives used in template-driven
    forms.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 10.1](#ch10table01) 包含了在模板驱动表单中使用的指令摘要。'
- en: Table 10.1\. Template-driven forms directives
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 10.1\. 模板驱动表单指令
- en: '| Directive | Description |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 描述 |'
- en: '| --- | --- |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| NgForm | Implicitly created directive that represents the entire form |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| NgForm | 隐式创建的指令，表示整个表单 |'
- en: '| ngForm | Used in templates to bind the template element (for example, <form>)
    to NgForm, typically assigned to a local template variable |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| ngForm | 在模板中使用，用于将模板元素（例如，<form>）绑定到 NgForm，通常分配给本地模板变量 |'
- en: '| NgModel | Implicitly created directive that marks the HTML element to be
    included in the form model |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| NgModel | 隐式创建的指令，用于标记要包含在表单模型中的 HTML 元素 |'
- en: '| ngForm | Used in templates in form elements (for example, <input>) to be
    included in the form model |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| ngForm | 在模板中的表单元素（例如，<input>）中使用，以包含在表单模型中 |'
- en: '| name | Used in templates in form elements to specify its name in the form
    model |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| name | 在模板中的表单元素中使用，用于指定其在表单模型中的名称 |'
- en: '| NgModelGroup | Implicitly created directive that represents a part of the
    form, for example, password and confirm password fields |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| NgModelGroup | 隐式创建的指令，表示表单的一部分，例如密码和确认密码字段 |'
- en: '| ngModelGroup | Used in templates to name a part of the form for future reference
    |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| ngModelGroup | 在模板中使用，用于为表单的一部分命名，以便将来引用 |'
- en: '| ngSubmit | Intercepts the HTML form’s submit event |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| ngSubmit | 拦截 HTML 表单的提交事件 |'
- en: 10.2.2\. Applying the template-driven API to HTML forms
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.2\. 将模板驱动 API 应用到 HTML 表单
- en: Let’s create a simple user registration form, applying the template-driven Forms
    API. You’ll also add validation logic and enable programmatic handling of the
    `ngSubmit` event. You’ll start by creating the template, and then you’ll work
    on the TypeScript part. First, modify the standard HTML `<form>` element to match
    the following listing.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的用户注册表单，应用模板驱动表单 API。您还将添加验证逻辑并启用对 `ngSubmit` 事件的程序性处理。您将从创建模板开始，然后处理
    TypeScript 部分。首先，修改标准的 HTML `<form>` 元素以匹配以下列表。
- en: Listing 10.5\. Angular-aware form
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.5\. Angular 感知表单
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* Binds NgForm to a local template variable**'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 NgForm 绑定到本地模板变量**'
- en: '***2* Submits the form, passing the form model to the event handler**'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 提交表单，将表单模型传递给事件处理器**'
- en: A local template variable `f` points at the `NgForm` object attached to the
    `<form>` element in the DOM. You need this variable to access the form’s properties
    (such as `value` and `valid`), and to check whether the form has errors in a specific
    field.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 本地模板变量 `f` 指向 DOM 中 `<form>` 元素附加的 `NgForm` 对象。您需要此变量来访问表单的属性（例如 `value` 和 `valid`），并检查表单在特定字段中是否有错误。
- en: The `ngSubmit` event is emitted by `NgForm`. You don’t want to listen to the
    standard submit event because `NgForm` intercepts the submit event and stops its
    propagation. This prevents the form from being automatically submitted to the
    server, resulting in a page reload. Instead, `NgForm` emits its own `ngSubmit`
    event.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngSubmit` 事件由 `NgForm` 触发。您不需要监听标准的提交事件，因为 `NgForm` 会拦截提交事件并阻止其传播。这防止了表单自动提交到服务器，从而导致页面刷新。相反，`NgForm`
    会触发它自己的 `ngSubmit` 事件。'
- en: The `onSubmit()` method will handle the `ngSubmit` event, and you’ll add this
    method to the component’s class. It takes one argument—the form’s value—which
    is a plain JavaScript object that keeps the values of all the fields on the form.
    Next, add the `username` and `ssn` fields (SSN is a unique ID that every US resident
    has).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`onSubmit()` 方法将处理 `ngSubmit` 事件，并将此方法添加到组件的类中。它接受一个参数——表单的值，这是一个普通的 JavaScript
    对象，它保存表单上所有字段的值。接下来，添加 `username` 和 `ssn` 字段（SSN 是每个美国居民都有的唯一 ID）。'
- en: Listing 10.6\. The username and ssn fields
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.6\. 用户名和 ssn 字段
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* The ngModel attribute makes this <input> element a part of the NgForm.
    You also add the name attribute with the value username.**'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* ngModel 属性使这个 <input> 元素成为 NgForm 的一部分。您还添加了具有值 username 的 name 属性。**'
- en: '***2* Makes similar changes to the ssn field**'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 对 ssn 字段进行类似的更改**'
- en: Now you’ll add the fields to enter and confirm the password. Because these fields
    are related and represent the same value, it’s natural to combine them into a
    group. Wrapping both passwords into a single object is useful for implementing
    a validator that checks whether both passwords are the same, as you can see in
    the following listing (you’ll see how to do it in section 11.3.1 in [chapter 11](kindle_split_020.xhtml#ch11)).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您将添加输入和确认密码的字段。因为这些字段相关且表示相同的值，所以将它们组合成一个组是自然的。将两个密码包装在一个单独的对象中对于实现一个验证器很有用，该验证器检查两个密码是否相同，如下所示（您将在第
    11.3.1 节中看到如何实现，见[第 11 章](kindle_split_020.xhtml#ch11)）。
- en: Listing 10.7\. The password fields
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.7\. 密码字段
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* The ngModelGroup directive instructs NgForm to create a nested object
    within the form’s value object that keeps the child fields.**'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* ngModelGroup 指令指示 NgForm 在表单的值对象内创建一个嵌套对象，以保存子字段。**'
- en: '***2* Changes for the password and pconfirm fields are similar to those for
    ngModelGroup, but the values of the name attributes differ.**'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 密码和 pconfirm 字段的更改与 ngModelGroup 类似，但 name 属性的值不同。**'
- en: 'The Submit button remains the same as in the plain HTML version of the form:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 提交按钮与表单的纯 HTML 版本相同：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now that you’re done with the template, you’ll use it in a component, as shown
    in the following listing.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经完成了模板，您将在以下列表中将其用于组件。
- en: Listing 10.8\. A component that uses the template-driven Forms API
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.8\. 使用模板驱动的表单 API 的组件
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* Binds NgForm to a local template variable and submits the form**'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 NgForm 绑定到本地模板变量并提交表单**'
- en: '***2* Creates a nested group for passwords**'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 为密码创建一个嵌套组**'
- en: '***3* The method handler for the onSubmit event**'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* onSubmit 事件的处理器方法**'
- en: 'The `onSubmit()` event handler takes a single argument: the form model’s value,
    an object containing the field’s values. As you can see, the handler doesn’t use
    an Angular-specific API. Depending on the validity flag on the model, you can
    decide whether to post the `formData` to the server. In this example, you print
    it to the console.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`onSubmit()` 事件处理器接受一个参数：表单模型值，一个包含字段值的对象。如您所见，处理器不使用 Angular 特定的 API。根据模型上的有效性标志，您可以决定是否将
    `formData` 发送到服务器。在这个例子中，您将其打印到控制台。'
- en: 'To see this app in action, run `npm install` in the directory form-samples,
    and then run the following command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此应用程序的实际运行情况，请在 form-samples 目录中运行 `npm install`，然后运行以下命令：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Fill out the form and click the Submit button. The value of the model object
    will be printed in the browser’s console, as shown in [figure 10.1](#ch10fig01).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 填写表单并点击提交按钮。模型对象的值将在浏览器控制台中打印出来，如图 10.1 所示。
- en: Figure 10.1\. Running a template-driven registration form
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.1\. 运行模板驱动的注册表单
- en: '![](Images/10fig01_alt.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10fig01_alt.jpg)'
- en: '[Figure 10.2](#ch10fig02) displays a sample registration form with the form
    directives applied to it. Each form directive is circled so you can see what makes
    up the form. The complete running application that illustrates how to use form
    directives is located in the template-driven directory.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10.2](#ch10fig02) 显示了一个应用了表单指令的示例注册表单。每个表单指令都被圈出，以便您可以查看构成表单的内容。展示如何使用表单指令的完整运行应用程序位于模板驱动目录中。'
- en: Figure 10.2\. Form directives on the registration form
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.2\. 注册表单上的表单指令
- en: '![](Images/10fig02.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10fig02.jpg)'
- en: '|  |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Source code for this chapter can be found at [https://github.com/Farata/angulartypescript](https://github.com/Farata/angulartypescript)
    and [www.manning.com/books/angular-development-with-typescript-second-edition](http://www.manning.com/books/angular-development-with-typescript-second-edition).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在 [https://github.com/Farata/angulartypescript](https://github.com/Farata/angulartypescript)
    和 [www.manning.com/books/angular-development-with-typescript-second-edition](http://www.manning.com/books/angular-development-with-typescript-second-edition)
    找到。
- en: '|  |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 10.3\. Reactive forms
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3\. 响应式表单
- en: 'Creating a reactive form requires more steps than creating a template-driven
    one. In short, you need to perform the following steps:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 创建响应式表单比创建模板驱动表单需要更多步骤。简而言之，您需要执行以下步骤：
- en: '**1**.  Import `ReactiveFormsModule` in the `NgModule()` where your component
    is declared.'
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 在声明组件的 `NgModule()` 中导入 `ReactiveFormsModule`。'
- en: '**2**.  In your TypeScript code, create an instance of the model object `FormGroup`
    to store the form’s values.'
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 在您的 TypeScript 代码中，创建一个 `FormGroup` 模型对象的实例以存储表单的值。'
- en: '**3**.  Create an HTML form template, adding reactive directives.'
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 创建一个 HTML 表单模板，添加响应式指令。'
- en: '**4**.  Use the instance of the `FormGroup` to access the form’s values.'
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**. 使用 `FormGroup` 的实例来访问表单的值。'
- en: Adding `ReactiveFormsModule` to the `@NgModule()` decorator is a trivial operation.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `ReactiveFormsModule` 添加到 `@NgModule()` 装饰器中是一个简单的操作。
- en: Listing 10.9\. Adding support for reactive forms
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.9\. 添加响应式表单支持
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1* Imports the module that supports reactive forms**'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入支持响应式表单的模块**'
- en: Now let’s talk about how to create a form model.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来谈谈如何创建表单模型。
- en: 10.3.1\. Form model
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.1\. 表单模型
- en: The form model is a data structure that holds the form’s data. It can be constructed
    from `FormControl`, `FormGroup`, and `FormArray` classes. For example, the following
    listing declares a class property of type `FormGroup` and initializes it with
    a new object that will contain instances of the form controls for your form.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 表单模型是一种数据结构，用于存储表单的数据。它可以由 `FormControl`、`FormGroup` 和 `FormArray` 类构建。例如，以下代码示例声明了一个类型为
    `FormGroup` 的类属性，并用一个新对象初始化它，该对象将包含您表单的表单控件实例。
- en: Listing 10.10\. Creating a form model object
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.10\. 创建表单模型对象
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* Creates an instance of a form model**'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建表单模型实例**'
- en: '***2* Adds form controls to the form model**'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 向表单模型添加表单控件**'
- en: FormControl
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: FormControl
- en: '`FormControl` is an atomic form unit. Most often, it corresponds to a single
    `<input>` element, but it can also represent a more complex UI component like
    a calendar or a slider. A `FormControl` instance stores the current value of the
    HTML element it corresponds to, the element’s validity status, and whether it’s
    been modified. Here’s how you can create a control passing its initial value as
    the first argument of the constructor:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormControl` 是一个原子表单单元。它通常对应于一个单独的 `<input>` 元素，但它也可以表示一个更复杂的 UI 组件，如日历或滑块。一个
    `FormControl` 实例存储了它对应的 HTML 元素的当前值、元素的验证状态以及它是否已被修改。以下是如何创建一个控制器的示例，将初始值作为构造函数的第一个参数传递：'
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can also create a `FormControl` attaching one or more built-in or custom
    validators. [Chapter 11](kindle_split_020.xhtml#ch11) covers form validation,
    but the following code listing shows how to attach two built-in Angular validators
    to a form control.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过附加一个或多个内置或自定义验证器来创建 `FormControl`。第 11 章介绍了表单验证，但以下代码示例展示了如何将两个内置的 Angular
    验证器附加到表单控件上。
- en: Listing 10.11\. Adding validators to a form control
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.11\. 向表单控件添加验证器
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1* Creates a form control with the initial value New York**'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建具有初始值“纽约”的表单控件**'
- en: '***2* Adds a required validator to a form control**'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 向表单控件添加必填验证器**'
- en: '***3* Adds a minLength validator to a form control**'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 向表单控件添加最小长度验证器**'
- en: '|  |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You can add a `formControl` directive to a template without wrapping it inside
    an `NgForm` directive—for example, it can be used with a standalone `<input>`
    element. You can find such an example in [chapter 6](kindle_split_015.xhtml#ch06)
    in [section 6.3](kindle_split_015.xhtml#ch06lev1sec3).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在模板中添加`formControl`指令，而无需将其包裹在`NgForm`指令内——例如，它可以与独立的`<input>`元素一起使用。您可以在[第6章](kindle_split_015.xhtml#ch06)的[第6.3节](kindle_split_015.xhtml#ch06lev1sec3)中找到一个这样的例子。
- en: '|  |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: FormGroup
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`FormGroup`'
- en: '`FormGroup` is a collection of `FormControl` objects and represents either
    the entire form or its part. `FormGroup` aggregates the values and validity of
    each `FormControl` in the group. If one of the controls in a group is invalid,
    the entire group becomes invalid. The following listing shows the use of `FormGroup`
    to represent the form or part of it.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormGroup`是一组`FormControl`对象，代表整个表单或其部分。`FormGroup`聚合组中每个`FormControl`的值和有效性。如果组中的一个控制项无效，则整个组变为无效。以下列表显示了使用`FormGroup`来表示表单或其部分的使用方法。'
- en: Listing 10.12\. Creating a form model by instantiating a `FormGroup`
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.12\. 通过实例化`FormGroup`创建表单模型
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* This FormGroup instance represents the entire form.**'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这个`FormGroup`实例代表整个表单。**'
- en: '***2* This FormGroup instance represents a part of the form, grouping two password
    controls together.**'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 这个`FormGroup`实例代表表单的一部分，将两个密码控制项组合在一起。**'
- en: '***3* Declares and initializes the password form control**'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 声明并初始化密码表单控制**'
- en: '***4* Declares and initializes the pconfirm control for password confirmation**'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 声明并初始化密码确认的`pconfirm`控制**'
- en: In section 10.3.6, you’ll see a simplified syntax for creating form models with
    nesting.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在第10.3.6节中，您将看到创建嵌套表单模型的简化语法。
- en: FormArray
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`FormArray`'
- en: When you need to programmatically add (or remove) controls to a form, use `FormArray`.
    It’s similar to `FormGroup` but has a `length` variable. Whereas `FormGroup` represents
    an entire form or a fixed subset of a form’s fields, `FormArray` usually represents
    a collection of form controls that can grow or shrink. For example, you could
    use `FormArray` to allow users to enter an arbitrary number of emails. The following
    listing shows a model that would back such a form.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要以编程方式向表单（或从表单中）添加（或删除）控制项时，请使用`FormArray`。它与`FormGroup`类似，但有一个`length`变量。`FormGroup`代表整个表单或表单的固定子集，而`FormArray`通常代表可以增长或缩小的表单控制项集合。例如，您可以使用`FormArray`允许用户输入任意数量的电子邮件。以下列表显示了支持此类表单的模型。
- en: Listing 10.13\. Adding a `FormArray` to a `FormGroup`
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.13\. 将`FormArray`添加到`FormGroup`
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1* The FormGroup instance represents the entire form.**'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* `FormGroup`实例代表整个表单。**'
- en: '***2* This FormArray initially contains a single email control.**'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 这个`FormArray`最初包含一个电子邮件控制。**'
- en: '***3* Adds an instance of FormControl to the emails array**'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将`FormControl`实例添加到电子邮件数组中**'
- en: In [section 10.3.4](#ch10lev2sec6), we’ll show you an app that allows the user
    add more email controls during runtime, to allow users to enter multiple emails.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10.3.4节](#ch10lev2sec6)中，我们将向您展示一个应用程序，允许用户在运行时添加更多电子邮件控制，以便用户可以输入多个电子邮件。
- en: 10.3.2\. Reactive directives
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.2\. 响应式指令
- en: The reactive approach also requires you to use directives in component templates,
    but these directives are different compared to ones from the template-driven API.
    The reactive directives come with `ReactiveFormsModule` and are prefixed with
    `form`—for example, `formGroup` (note the small `f`).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式方法还要求您在组件模板中使用指令，但这些指令与模板驱动API中的指令不同。响应式指令随`ReactiveFormsModule`一起提供，并以`form`为前缀——例如，`formGroup`（注意小写的`f`）。
- en: You can’t create a local template variable in the template that binds to a reactive
    directive, and it’s not needed. In template-driven forms, the model is created
    implicitly, and local template variables would give you access to the model or
    its properties. In reactive forms, you explicitly create a model in TypeScript
    and don’t need to access the model in the component template.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能在模板中创建一个绑定到响应式指令的局部模板变量，并且这不是必需的。在模板驱动表单中，模型是隐式创建的，局部模板变量会为您提供访问模型或其属性的方法。在响应式表单中，您在TypeScript中显式创建一个模型，并且不需要在组件模板中访问模型。
- en: The reactive directives `formGroup` and `formControl` bind a DOM element to
    the model object using property-binding syntax with square brackets. The directives
    that link a DOM element to a TypeScript model’s properties by name are `formGroupName`,
    `formControlName`, and `formArrayName`. They can only be used inside the HTML
    element marked with the `formGroup` directive. Let’s look at the form directives.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式指令 `formGroup` 和 `formControl` 使用方括号中的属性绑定语法将 DOM 元素绑定到模型对象。通过名称将 DOM 元素链接到
    TypeScript 模型属性的指令是 `formGroupName`、`formControlName` 和 `formArrayName`。它们只能在带有
    `formGroup` 指令标记的 HTML 元素内部使用。让我们看看表单指令。
- en: formGroup
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: formGroup
- en: The `formGroup` directive binds an instance of the `FormGroup` class that represents
    the entire form model to a top-level form’s DOM element, usually a `<form>`. In
    the component template, use `formGroup` with a lowercase `f`, and in TypeScript,
    create an instance of the `FormGroup` class with a capital `F`. All directives
    attached to the child DOM elements will be in the scope of `formGroup` and can
    link model instances by name. To use the `formGroup` directive in a template,
    you need to first create an instance of `FormGroup` in the TypeScript code of
    a component, as shown in the following listing.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`formGroup` 指令将表示整个表单模型的 `FormGroup` 类的实例绑定到顶级表单的 DOM 元素，通常是 `<form>`。在组件模板中，使用小写的
    `f` 来表示 `formGroup`，在 TypeScript 中，使用大写的 `F` 创建 `FormGroup` 类的实例。所有附加到子 DOM 元素上的指令都将位于
    `formGroup` 的作用域内，并且可以通过名称链接模型实例。要在模板中使用 `formGroup` 指令，您需要首先在组件的 TypeScript 代码中创建
    `FormGroup` 的实例，如下面的列表所示。'
- en: Listing 10.14\. Binding `FormGroup` to an HTML form
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.14\. 将 `FormGroup` 绑定到 HTML 表单
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1* Binds the instance of the form model to the formGroup directive**'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将表单模型实例绑定到 formGroup 指令**'
- en: '***2* Creates an instance of the form model**'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建表单模型实例**'
- en: formGroupName
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: formGroupName
- en: The `formGroupName` directive can be used to link nested groups in a form within
    templates. Use `formGroupName` in the scope of a parent `formGroup` directive
    to link its child `FormGroup` instances. The next listing shows how you’d define
    a form model that uses `formGroupName`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`formGroupName` 指令可用于在模板中链接表单内的嵌套组。在父 `formGroup` 指令的作用域中使用 `formGroupName`
    来链接其子 `FormGroup` 实例。下一个列表显示了如何定义使用 `formGroupName` 的表单模型。'
- en: Listing 10.15\. Using `formGroupName`
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.15\. 使用 `formGroupName`
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* Binds the FormGroup that represents the entire form**'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 绑定表示整个表单的 FormGroup**'
- en: '***2* Links this <div> to the FormGroup called dateRange, defined in myFormModel**'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将此 <div> 链接到在 myFormModel 中定义的名为 dateRange 的 FormGroup**'
- en: '***3* This FormGroup is bound to a DOM element using the formGroup directive
    in the template.**'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 此 FormGroup 使用模板中的 formGroup 指令绑定到 DOM 元素。**'
- en: '***4* A child FormGroup named dateRange is bound to a DOM element using the
    formGroupName directive in the template.**'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用模板中的 formGroupName 指令将名为 dateRange 的子 FormGroup 绑定到 DOM 元素。**'
- en: formControlName
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: formControlName
- en: '`formControlName` must be used in the scope of the `formGroup` directive. It
    links an individual `FormControl` instance to a DOM element. Let’s continue adding
    code to the example of the `dateRange` model from the previous section. The component
    and form model remain the same. You only need to add HTML elements with the `formControlName`
    directive to complete the template.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`formControlName` 必须在 `formGroup` 指令的作用域中使用。它将单个 `FormControl` 实例链接到 DOM 元素。让我们继续添加来自上一节中
    `dateRange` 模型的示例代码。组件和表单模型保持不变。您只需要添加带有 `formControlName` 指令的 HTML 元素来完成模板。'
- en: Listing 10.16\. Completed form template
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.16\. 完成的表单模板
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* from is a property name in the model’s nested group dateRange.**'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* from 是模型嵌套组 dateRange 中的一个属性名。**'
- en: '***2* to is a property name in the model’s nested group dateRange.**'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* to 是模型嵌套组 dateRange 中的一个属性名。**'
- en: As in the `formGroupName` directive, you specify the name of a `FormControl`
    you want to link to the DOM element. Again, these are the names you chose when
    defining the form model.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `formGroupName` 指令类似，您指定要链接到 DOM 元素的 `FormControl` 的名称。同样，这些是在定义表单模型时选择的名称。
- en: formControl
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: formControl
- en: The `formControl` directive is used with individual form controls or single-control
    forms, when you don’t want to create a form model with `FormGroup` but still want
    to use Forms API features like validation and the reactive behavior provided by
    the `FormControl.valueChanges` property. You saw it in the weather app in [section
    6.4](kindle_split_015.xhtml#ch06lev1sec4) of [chapter 6](kindle_split_015.xhtml#ch06).
    The following listing shows the essence of that example from the Forms API perspective.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`formControl` 指令用于单个表单控件或单控件表单，当你不想使用 `FormGroup` 创建表单模型，但仍想使用表单 API 的功能，如验证和由
    `FormControl.valueChanges` 属性提供的响应式行为时。你可以在第 6 章的 [6.4 节](kindle_split_015.xhtml#ch06lev1sec4)
    的天气应用中看到它。以下列表展示了从表单 API 视角来看该示例的精髓。'
- en: Listing 10.17\. `FormControl`
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.17\. `FormControl`
- en: '[PRE20]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1* With a standalone FormControl that’s not a part of a FormGroup, you can’t
    use the formControlName directive. Use formControl with the property binding.**'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 对于不是 `FormGroup` 部分的独立 `FormControl`，你不能使用 formControlName 指令。使用带有属性绑定的
    formControl。**'
- en: '***2* Instead of defining a form model with FormGroup, create a standalone
    instance of a FormControl.**'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 不使用 FormGroup 定义表单模型，而是创建一个独立的 `FormControl` 实例。**'
- en: '***3* Use the valueChanges observable to get the value from the form.**'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用 valueChanges 可观察对象从表单中获取值。**'
- en: You could use `ngModel` (as [section 2.6.2](kindle_split_011.xhtml#ch02lev2sec3)
    of [chapter 2](kindle_split_011.xhtml#ch02)) to sync the value entered by the
    user with the component’s property; but because you’re using the Forms API, you
    can use its reactive features. In [listing 10.18](#ch10ex18), you apply two RxJS
    operators to the observable returned by the `valueChanges` property to improve
    the user experience.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `ngModel`（如第 2 章的 [2.6.2 节](kindle_split_011.xhtml#ch02lev2sec3)）来同步用户输入的值与组件的属性；但由于你正在使用表单
    API，你可以使用其响应式功能。在 [列表 10.18](#ch10ex18) 中，你将两个 RxJS 操作符应用到 `valueChanges` 属性返回的可观察对象上，以改善用户体验。
- en: 10.3.3\. Applying the reactive API to HTML forms
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.3\. 将响应式 API 应用到 HTML 表单
- en: Let’s refactor the user registration form from [section 10.2.2](#ch10lev2sec2)
    to use the reactive Forms API. The following listing uses the reactive Forms API,
    starting by creating a model object in TypeScript.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将用户注册表单从 [10.2.2 节](#ch10lev2sec2) 重构为使用响应式表单 API。以下列表使用响应式表单 API，首先在 TypeScript
    中创建一个模型对象。
- en: Listing 10.18\. Creating a form model with the reactive API
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.18\. 使用响应式 API 创建表单模型
- en: '[PRE21]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***1* Declares a component property myFormModel to hold a reference to the
    form model**'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明一个组件属性 myFormModel 以保存对表单模型的引用**'
- en: '***2* Creates an instance of the form model**'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建表单模型的一个实例**'
- en: '***3* Creates a nested group for password fields**'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 为密码字段创建一个嵌套组**'
- en: '***4* Prints the form model’s values**'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 打印表单模型的值**'
- en: The `myFormModel` property holds a reference to the `FormGroup` instance. You’ll
    bind this property to the `formGroup` directive in the component template. The
    `myFormModel` property is initialized by instantiating a model class. The names
    you give to form controls in the parent `FormGroup` will be used in the component’s
    template to link the model to the DOM elements with the `formControlName` and
    `formGroupName` directives.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`myFormModel` 属性保存了对 `FormGroup` 实例的引用。你将在组件模板中将此属性绑定到 `formGroup` 指令。`myFormModel`
    属性通过实例化一个模型类进行初始化。你在父 `FormGroup` 中为表单控件指定的名称将在组件的模板中使用，以通过 `formControlName`
    和 `formGroupName` 指令将模型链接到 DOM 元素。'
- en: The `passwordsGroup` property represents a nested `FormGroup` that encapsulates
    the password and confirm password fields. It will be convenient to manage their
    values as a single object for validation.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`passwordsGroup` 属性表示一个嵌套的 `FormGroup`，它封装了密码和确认密码字段。将它们的值作为一个单独的对象进行验证将会很方便。'
- en: '|  |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In the reactive API, the `onSubmit()` method doesn’t need arguments because
    you access the form values using your component’s `myFormModel` property.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应式 API 中，`onSubmit()` 方法不需要参数，因为你可以通过组件的 `myFormModel` 属性访问表单值。
- en: '|  |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Now that the model is defined, you can write the HTML markup that binds to your
    model object.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在模型已经定义，你可以编写绑定到你的模型对象的 HTML 标记。
- en: Listing 10.19\. HTML binding to the model
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.19\. 将 HTML 绑定到模型
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***1* Binds the <form> element to myFormModel using the formGroup directive**'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用 formGroup 指令将 <form> 元素绑定到 myFormModel**'
- en: '***2* formControlName links input fields to the corresponding FormControl instances
    defined in the model.**'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* formControlName 链接输入字段到模型中定义的相应 `FormControl` 实例。**'
- en: '***3* Links the model’s nested FormGroup to the DOM element using formGroupName**'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用 formGroupName 将模型的嵌套 FormGroup 链接到 DOM 元素**'
- en: '***4* Links the password input field and pconfirm using the formControlName
    directive**'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用 formControlName 指令将密码输入字段和 pconfirm 链接起来**'
- en: 'The behavior of this reactive version of the registration form is identical
    to the template-driven version, but the internal implementation differs. To see
    this app in action, open the form-samples directory in your IDE, and run the following
    command:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 此响应式版本的注册表单的行为与模板驱动的版本相同，但内部实现不同。要查看此应用程序的实际运行情况，请在您的 IDE 中打开 form-samples 目录，并运行以下命令：
- en: '[PRE23]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Fill out the form, and click Submit. The object with the entered values will
    be printed in the browser’s console, as shown in [figure 10.3](#ch10fig03).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 填写表单，并点击提交。包含输入值的对象将在浏览器控制台中打印出来，如图 10.3 所示 [链接](#ch10fig03)。
- en: Figure 10.3\. Running reactive registration form
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.3\. 运行响应式注册表单
- en: '![](Images/10fig03_alt.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/10fig03_alt.jpg)'
- en: This was a rather simple form with predefined controls, but what if you want
    to be able to dynamically add form controls during runtime?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单的表单，具有预定义的控件，但如果你想在运行时动态添加表单控件怎么办？
- en: 10.3.4\. Dynamically adding controls to a form
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.4\. 动态向表单添加控件
- en: When you know in advance all the controls in a particular form, you can associate
    each template form element with a corresponding property of the `FormGroup` instance
    using the `formControlName` directive. But if you want to be able to dynamically
    add/remove controls, you need a different way to link the control names with the
    model properties. By using `FormArray` instead of `FormGroup`, you can specify
    an array index as a name of the corresponding template element.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当您事先知道特定表单中的所有控件时，您可以使用 `formControlName` 指令将每个模板表单元素与 `FormGroup` 实例的相应属性关联起来。但如果你想要能够动态添加/删除控件，你需要一种不同的方式来链接控件名称与模型属性。通过使用
    `FormArray` 而不是 `FormGroup`，您可以指定一个数组索引作为相应模板元素的名称。
- en: Let’s look at an example that allows users to have a form with an arbitrary
    number of email controls. First, you’ll define the model that will include a `FormArray`
    called `emails`, which will initially have just one form control for entering
    an email.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例，允许用户拥有具有任意数量电子邮件控件的表单。首先，您将定义一个模型，该模型将包含一个名为 `emails` 的 `FormArray`，它最初将只有一个用于输入电子邮件的表单控件。
- en: Listing 10.20\. Using `FormArray` in the form model
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.20\. 在表单模型中使用 `FormArray`
- en: '[PRE24]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1* Creates a FormGroup that will represent the form**'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个将表示表单的 FormGroup**'
- en: '***2* Creates a FormArray for the emails form controls**'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 为电子邮件表单控件创建一个 FormArray**'
- en: '***3* Adds a single form control to the emails array**'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 向 emails 数组添加单个表单控件**'
- en: In the template, you’ll create a `<ul>` HTML element and will link it to the
    `emails` array of the model using the `formArrayName` directive. Then, you’ll
    iterate through this array with `*ngFor`, rendering an `<li>` element for each
    form control from this array. Your template will also have an Add Email button,
    and if the user clicks it, you’ll add a new `FormControl` to the `emails` array,
    as shown in the next listing.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中，您将创建一个 `<ul>` HTML 元素，并使用 `formArrayName` 指令将其链接到模型的 `emails` 数组。然后，您将使用
    `*ngFor` 迭代此数组，为该数组中的每个表单控件渲染一个 `<li>` 元素。您的模板还将有一个添加电子邮件按钮，如果用户点击它，您将向 `emails`
    数组添加一个新的 `FormControl`，如下一列表所示。
- en: Listing 10.21\. Iterating through the `FormArray` in a template
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.21\. 在模板中迭代 `FormArray`
- en: '[PRE25]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '***1* Links the emails array to the <ul> element**'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 emails 数组链接到 <ul> 元素**'
- en: '***2* Iterates through the emails array and creates a <li> with an <input>
    field for each array element**'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 迭代 emails 数组并为每个数组元素创建一个 <li> 和 <input> 字段**'
- en: '***3* Uses an emails array element index as a name of the corresponding <input>
    element**'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用 emails 数组元素索引作为相应 <input> 元素的名称**'
- en: '***4* Defines the click event handler**'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 定义点击事件处理程序**'
- en: In Angular templates, the `*ngFor` directive gives you access to a special `index`
    variable that stores the current index while iterating through a collection. The
    `let i` notation in the `*ngFor` loop allows you to automatically bind the value
    `index` to the local template variable `i` available within the loop.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 模板中，`*ngFor` 指令允许您访问一个特殊的 `index` 变量，该变量在迭代集合时存储当前索引。`*ngFor` 循环中的
    `let i` 语法允许您自动将 `index` 值绑定到循环内可用的局部模板变量 `i`。
- en: 'The `formControlName` directive links the `FormControl` in `FormArray` to the
    currently rendered DOM element; but instead of specifying a name, it uses the
    current value of the variable `i`. When the user clicks the Add Email button,
    your component adds a new `FormControl` instance to the `FormArray`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`formControlName` 指令将 `FormArray` 中的 `FormControl` 与当前渲染的 DOM 元素链接；但不是指定一个名称，而是使用变量
    `i` 的当前值。当用户点击“添加电子邮件”按钮时，你的组件会将一个新的 `FormControl` 实例添加到 `FormArray` 中：'
- en: '[PRE26]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the dynamic-form-controls directory, you can find the complete code for
    the app that dynamically adds email form controls on each click of the Add Email
    button. To see this example in action, run the following command:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在 dynamic-form-controls 目录中，你可以找到在每次点击“添加电子邮件”按钮时动态添加电子邮件表单控件的完整代码。要查看此示例的实际效果，请运行以下命令：
- en: '[PRE27]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[Figure 10.4](#ch10fig04) shows what this form will look like after the user
    clicks Add Email. The second email field was added dynamically by adding a new
    `FormControl` instance to the `FormArray` named `emails`, and each control from
    this array was rendered on the page.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10.4](#ch10fig04) 展示了用户点击“添加电子邮件”后此表单的外观。第二个电子邮件字段是通过向名为 `emails` 的 `FormArray`
    添加一个新的 `FormControl` 实例动态添加的，并且页面上的每个控件都是从该数组渲染的。'
- en: Figure 10.4\. Form with growable email controls
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.4. 可增长的电子邮件控件表单
- en: '![](Images/10fig04.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/10fig04.jpg)'
- en: 10.4\. Forms API directives summary
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4. 表单 API 指令摘要
- en: You’ve used+ many different Forms API directives in both template-driven and
    reactive forms. [Table 10.2](#ch10table02) lists what they are for.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在模板驱动和响应式表单中使用了许多不同的 Forms API 指令。[表 10.2](#ch10table02) 列出了它们的作用。
- en: Table 10.2\. Forms API directives
  id: totrans-232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 10.2. 表单 API 指令
- en: '| Directive | Description |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 描述 |'
- en: '| --- | --- |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| *Directives for reactive forms* |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| *响应式表单的指令* |'
- en: '|   | FormGroup | A class that represents the entire form or a subform; create
    its instance in the TypeScript code of the component. Its API is described at
    [https://angular.io/api/forms/FormGroup](https://angular.io/api/forms/FormGroup).
    |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '|   | FormGroup | 表示整个表单或子表单的类；在组件的 TypeScript 代码中创建其实例。其 API 在 [https://angular.io/api/forms/FormGroup](https://angular.io/api/forms/FormGroup)
    中描述。 |'
- en: '|   | formGroup | Used in templates to bind the template element (for example,
    <form>) to the explicitly created FormGroup; typically it’s assigned to a variable
    declared in the component. |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '|   | formGroup | 在模板中使用，将模板元素（例如，<form>）绑定到显式创建的 FormGroup；通常它被分配给在组件中声明的变量。
    |'
- en: '|   | formGroupName | Used in templates to bind a group of the template elements
    (for example, <div>) to the explicitly created FormGroup. |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '|   | formGroupName | 在模板中使用，将一组模板元素（例如，<div>）绑定到显式创建的 FormGroup。 |'
- en: '|   | FormControl | Represents the value, validators, and validity status of
    an individual form control; create its instance in the TypeScript code of the
    component. Its API is described at [https://angular.io/api/forms/FormControl](https://angular.io/api/forms/FormControl).
    |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '|   | FormControl | 表示单个表单控件的值、验证器和有效性状态；在组件的 TypeScript 代码中创建其实例。其 API 在 [https://angular.io/api/forms/FormControl](https://angular.io/api/forms/FormControl)
    中描述。 |'
- en: '|   | formControl | Used in a template to bind an individual HTML element to
    the instance of FormControl. |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '|   | formControl | 在模板中使用，将单个 HTML 元素绑定到 FormControl 的实例。 |'
- en: '|   | formControlName | Used in templates in form elements to link an individual
    FormControl instance to an HTML element. |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '|   | formControlName | 在表单元素中的模板中使用，将单个 FormControl 实例链接到 HTML 元素。 |'
- en: '|   | FormArray | Allows you to create a group of form controls dynamically
    and use the array indexes as control names. You create an instance of FormArray
    in TypeScript code. Its API is described at [https://angular.io/api/forms/FormArray](https://angular.io/api/forms/FormArray).
    |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '|   | FormArray | 允许你动态创建一组表单控件，并使用数组索引作为控件名称。你在 TypeScript 代码中创建 FormArray
    的实例。其 API 在 [https://angular.io/api/forms/FormArray](https://angular.io/api/forms/FormArray)
    中描述。 |'
- en: '|   | formArrayName | Used in a template as a reference to the instance of
    FormArray. |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '|   | formArrayName | 在模板中使用，作为 FormArray 实例的引用。 |'
- en: '| *Directives for template-driven forms* |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| *模板驱动表单的指令* |'
- en: '|   | NgForm | Implicitly created directive that represents the entire form;
    it creates an instance of FormGroup. Its API is described at [https://angular.io/api/forms/NgForm](https://angular.io/api/forms/NgForm).
    |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '|   | NgForm | 隐式创建的指令，代表整个表单；它创建一个 FormGroup 实例。其 API 在 [https://angular.io/api/forms/NgForm](https://angular.io/api/forms/NgForm)
    中描述。 |'
- en: '|   | ngForm | Used in templates to bind the template element (for example,
    <form>) to NgForm; typically, it’s assigned to a local template variable. |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '|   | ngForm | 在模板中使用，用于将模板元素（例如，<form>）绑定到 NgForm；通常，它被分配给局部模板变量。 |'
- en: '|   | NgModel | Implicitly created directive that marks the HTML element to
    be included in the form model. Its API is described at [https://angular.io/api/forms/NgModel](https://angular.io/api/forms/NgModel).
    |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '|   | NgModel | 隐式创建的指令，用于标记要包含在表单模型中的 HTML 元素。其 API 在 [https://angular.io/api/forms/NgModel](https://angular.io/api/forms/NgModel)
    中描述。 |'
- en: '|   | ngModel | Used in templates in form elements (for example, <input>) to
    be included in the form model. |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '|   | ngModel | 在表单元素模板中（例如，<input>）使用，以包含在表单模型中。 |'
- en: '|   | name | Used in templates in form elements to specify its name in the
    form model. |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '|   | name | 在表单元素模板中使用，以指定其在表单模型中的名称。 |'
- en: '|   | NgModelGroup | Implicitly created directive that represents a part of
    the form, such as password and confirm password fields. Its API is described at
    [https://angular.io/api/forms/NgModelGroup](https://angular.io/api/forms/NgModelGroup).
    |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '|   | NgModelGroup | 隐式创建的指令，代表表单的一部分，如密码和确认密码字段。其 API 在 [https://angular.io/api/forms/NgModelGroup](https://angular.io/api/forms/NgModelGroup)
    中描述。 |'
- en: '|   | ngModelGroup | Used in templates to name a part of the form for future
    reference. |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '|   | ngModelGroup | 在模板中使用，用于为表单的一部分命名，以便将来引用。 |'
- en: '| *Both template-driven and reactive forms* |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| *模板驱动和响应式表单* |'
- en: '|   | ngSubmit | Intercepts the HTML form’s submit event. |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '|   | ngSubmit | 拦截 HTML 表单的提交事件。 |'
- en: Note that the name of any directive used in the component template starts with
    a lowercase letter. The name of the underlying class that implements the directive
    starts with a capital letter. In template-driven forms, you don’t need to explicitly
    create instances of these classes, but in reactive forms, you instantiate them
    in the TypeScript code as needed.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在组件模板中使用的任何指令的名称都以小写字母开头。实现指令的底层类的名称以大写字母开头。在模板驱动表单中，你不需要显式创建这些类的实例，但在响应式表单中，你需要根据需要在使用
    TypeScript 代码时实例化它们。
- en: All the code samples in this chapter illustrate use cases of the user entering
    the data in a form, but often you need to populate a form with existing data.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码示例都说明了用户在表单中输入数据的使用案例，但通常你需要用现有数据填充表单。
- en: 10.5\. Updating form data
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5\. 更新表单数据
- en: In some scenarios, a form needs to be populated without the user’s interaction.
    For example, you may need to create a form for editing product data retrieved
    from the server or another source. Another example is implementing a master-detail
    relationship—for example, selecting a product in a list should show its details
    in a form.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些场景中，表单需要在用户交互之前填充。例如，你可能需要创建一个用于编辑从服务器或其他来源检索到的产品数据的表单。另一个例子是实现主从关系——例如，在列表中选择一个产品应在表单中显示其详细信息。
- en: The Angular Forms API offers several functions for updating a form model including
    `reset()`, `setValue()`, and `patchValue()`. The `reset()` function reinitializes
    the form model and resets the flags on the model, like `touched`, `dirty`, and
    others. The `setValue()` function is used for updating all values in a form model.
    The `patchValue()` function is used when you need to update the selected properties
    of a form model. Let’s create a simple app that will have a form with the model
    shown in the following listing.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 表单 API 提供了多个用于更新表单模型的函数，包括 `reset()`、`setValue()` 和 `patchValue()`。`reset()`
    函数重新初始化表单模型并重置模型上的标志，如 `touched`、`dirty` 等。`setValue()` 函数用于更新表单模型中的所有值。`patchValue()`
    函数用于需要更新表单模型选定属性的情况。让我们创建一个简单的应用程序，它将包含以下列表中所示的模式。
- en: Listing 10.22\. Creating a form model
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.22\. 创建表单模型
- en: '[PRE28]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Your app will also have three buttons: Populate, Update Description, and Reset.
    Accordingly, the Populate button uses `setValue()` to populate the object that
    has values for each control defined in the form model.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序还将有三个按钮：填充、更新描述和重置。相应地，填充按钮使用 `setValue()` 来填充具有表单模型中每个控件值的对象。
- en: Listing 10.23\. The data for populating the form
  id: totrans-262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.23\. 用于填充表单的数据
- en: '[PRE29]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The Update Description button uses `patchValue()` for the partial form update
    (just the description) from the object in the next listing.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 更新描述按钮使用 `patchValue()` 从下一列表中的对象进行部分表单更新（仅描述）。
- en: Listing 10.24\. The data for updating the description
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.24\. 用于更新描述的数据
- en: '[PRE30]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The Reset button removes all data from the form and resets all flags on the
    form model. The code of your app is shown in the following listing.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 重置按钮会从表单中删除所有数据并重置表单模型上的所有标志。你的应用的代码如下所示。
- en: Listing 10.25\. The AppComponent
  id: totrans-268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.25\. AppComponent
- en: '[PRE31]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '***1* Binds the form model to formGroup**'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将表单模型绑定到 formGroup**'
- en: '***2* A button to invoke setValue()**'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 一个用于调用 setValue() 的按钮**'
- en: '***3* A button to invoke patchValue()**'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 一个用于调用 patchValue() 的按钮**'
- en: '***4* A button to invoke reset()**'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 一个用于调用 reset() 的按钮**'
- en: '***5* Creates a form model object**'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 创建一个表单模型对象**'
- en: '***6* Invokes setValue() on the form model**'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 在表单模型上调用 setValue()**'
- en: '***7* Invokes patchValue() on the form model**'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 在表单模型上调用 patchValue()**'
- en: 'The code of this app is located in the populate directory. To see it in action,
    run the following command:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用的代码位于 populate 目录中。要查看其运行情况，请运行以下命令：
- en: '[PRE32]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '|  |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-280
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You can’t use `setValue()` in a form that uses `FormArray`. For such forms,
    you need to use `patchValue()` and then invoke the `setControl()` method on the
    form model to reset `FormArray`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能在使用 `FormArray` 的表单中使用 `setValue()`。对于此类表单，你需要使用 `patchValue()`，然后在对表单模型调用
    `setControl()` 方法来重置 `FormArray`。
- en: '|  |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If a form has multiple controls, your code may contain lots of `new` operators
    creating new instances of form elements. Is there a way to avoid polluting your
    code with `new` statements?
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个表单有多个控件，你的代码可能包含很多 `new` 操作符来创建表单元素的实例。有没有一种方法可以避免在代码中污染 `new` 语句？
- en: 10.6\. Using FormBuilder
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.6\. 使用 FormBuilder
- en: The injectable service `FormBuilder` simplifies the creation of form models.
    It doesn’t provide any unique features compared to the direct use of the `FormControl`,
    `FormGroup`, and `FormArray` classes, but its API is terser and saves you from
    the repetitive instantiation of objects.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 注入式服务 `FormBuilder` 简化了表单模型的创建。它与直接使用 `FormControl`、`FormGroup` 和 `FormArray`
    类没有提供任何独特功能，但它的 API 更简洁，可以节省你重复实例化对象的时间。
- en: Let’s refactor the code in the user registration form from [section 10.3.3](#ch10lev2sec5).
    The template will remain exactly the same, but the following listing uses `FormBuilder`
    to construct the form model.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重构用户注册表单中的代码，[第 10.3.3 节](#ch10lev2sec5)。模板将保持完全相同，但以下列表使用 `FormBuilder`
    来构建表单模型。
- en: Listing 10.26\. Creating a `formModel` with `FormBuilder`
  id: totrans-287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.26\. 使用 `FormBuilder` 创建 `formModel`
- en: '[PRE33]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1* Injects the FormBuilder service.**'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 注入 FormBuilder 服务。**'
- en: '***2* FormBuilder.group() creates a FormGroup using a configuration object
    passed to it.**'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* FormBuilder.group() 使用传递给它的配置对象创建一个 FormGroup。**'
- en: '***3* Each FormControl is instantiated using the array that may contain an
    initial control’s value and its validators.**'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 每个 FormControl 都使用可能包含初始控件值及其验证器的数组进行实例化。**'
- en: '***4* Like FormGroup, FormBuilder allows you to create nested groups.**'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 与 FormGroup 类似，FormBuilder 允许你创建嵌套组。**'
- en: The `FormBuilder.group()` method accepts an object with extra configuration
    parameters as the last argument. You can use it to specify group-level validators
    there if needed.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormBuilder.group()` 方法接受一个对象作为最后一个参数，该对象包含额外的配置参数。如果需要，你可以用它来指定组级别的验证器。'
- en: As you can see, configuring a form model with `FormBuilder` is less verbose
    and is based on the configuration object rather than requiring explicit instantiation
    of the control’s classes.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，使用 `FormBuilder` 配置表单模型更加简洁，它基于配置对象而不是需要显式实例化控件类。
- en: To see this app in action, run the command `ng serve --app formbuilder -o`.
    Now that you know how to work with form models and templates, you may be wondering
    how to ensure that the values entered in the form are valid. That’s subject of
    the next chapter.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此应用的运行情况，请运行命令 `ng serve --app formbuilder -o`。现在你了解了如何处理表单模型和模板，你可能想知道如何确保在表单中输入的值是有效的。这是下一章的主题。
- en: Summary
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Angular offers two APIs for working with forms: template-driven and reactive.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 为表单操作提供了两个 API：模板驱动和响应式。
- en: The template-driven approach is easier and quicker to configure, but it has
    limited features.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板驱动方法更容易、更快速地配置，但功能有限。
- en: The reactive approach gives you more control over forms, which can be created
    or modified during runtime.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式方法让你对表单有更多的控制，表单可以在运行时创建或修改。
