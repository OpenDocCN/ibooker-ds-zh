- en: 12 Integrations with CI/CD
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 与 CI/CD 的集成
- en: Konrad Cłapa and Jarosław Gajewski
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Konrad Cłapa 和 Jarosław Gajewski
- en: This chapter covers
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Understanding CI/CD concepts
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 CI/CD 概念
- en: Automating a continuous development workflow
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化持续开发工作流程
- en: Introducing continuous integration for your Anthos application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的 Anthos 应用程序介绍持续集成
- en: Using Cloud Deploy to manage continuous deployment
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Cloud Deploy 管理持续部署
- en: Understanding modern CI/CD platforms
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解现代 CI/CD 平台
- en: In this chapter, we will guide you in developing and deploying Anthos applications.
    To simplify this task, we will use a simple Hello World application. We will go
    through the entire workflow, shown in figure 12.1, using examples in both Python
    and Go. We’ll start with continuous development, where we will learn how we can
    start developing an Anthos application and preview it even before we commit the
    code to the Git repository. We’ll then look at continuous integration, and finally,
    we will discuss continuous deployment and delivery.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将指导您开发和部署 Anthos 应用程序。为了简化这项任务，我们将使用一个简单的 Hello World 应用程序。我们将通过图 12.1
    中显示的整个工作流程，使用 Python 和 Go 中的示例进行说明。我们将从持续开发开始，我们将学习如何开始开发 Anthos 应用程序，并在将代码提交到
    Git 仓库之前预览它。然后，我们将查看持续集成，最后，我们将讨论持续部署和交付。
- en: 'The following three personas interact with CI/CD pipelines:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三个角色与 CI/CD 管道进行交互：
- en: '*Developers*—Develop the application code'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开发者*—开发应用程序代码'
- en: '*Operators*—Configure the application deployments using Kubernetes manifests'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*运维人员*—使用 Kubernetes 清单配置应用程序部署'
- en: '*Security*—Configures the policies to make the Kubernetes Deployments secure'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安全*—配置策略以确保 Kubernetes 部署的安全性'
- en: '![12-01](../../OEBPS/Images/12-01.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![12-01](../../OEBPS/Images/12-01.png)'
- en: Figure 12.1 The CI/CD workflow
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 CI/CD 工作流程
- en: In this chapter, we will concentrate on the first two personas. If you want
    to learn more about the Security persona, refer to chapter 13\.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于前两个角色。如果您想了解更多关于安全角色的信息，请参阅第 13 章。
- en: Looking at the workflow of developers, we see that they develop the application
    code and want to see the preview of the application immediately. Then, if they
    are finished with their changes, they commit the code to the source code repository.
    This is where CI kicks in with code reviews, testing, and builds of container
    images.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 观察开发者的工作流程，我们看到他们开发应用程序代码，并希望立即看到应用程序的预览。然后，如果他们完成了他们的更改，他们会将代码提交到源代码仓库。这就是
    CI 开始介入进行代码审查、测试和容器镜像构建的地方。
- en: When we think about the operators, we see that they are responsible for both
    configuring the Kubernetes infrastructure and deploying the application. They
    need to be able to configure the application for multiple environments, including
    development, test, and production. Once the configuration is ready, the application
    can be deployed using CD tools.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑运维人员时，我们看到他们负责配置 Kubernetes 基础设施和部署应用程序。他们需要能够为多个环境配置应用程序，包括开发、测试和生产。一旦配置就绪，就可以使用
    CD 工具部署应用程序。
- en: Now that we understand the use case, let’s start with a brief introduction to
    CI/CD concepts.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了用例，让我们从 CI/CD 概念的简要介绍开始。
- en: 12.1 Introduction to CI/CD
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1 CI/CD 简介
- en: Modern software development processes are complex. Producing high-quality software
    at a consistent pace and in a sustainable manner involves several processes and
    tools. The implementation of a CI/CD pipeline is one of the best practices to
    achieve this. *Continuous integration (CI)* is the practice of software development
    where developers check in their code frequently, integrating regularly—at least
    once a day—and each integration is followed by validation, which is an automated
    process to build and test integrated change ([http://mng.bz/aMpz](http://mng.bz/aMpz)).
    This process allows us to achieve reliable, repeatable, and reusable builds with
    constant speed and at a proper level while preventing chaos and improving efficiency.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现代软件开发流程复杂。以一致的速度和可持续的方式生产高质量的软件涉及多个流程和工具。实施 CI/CD 管道是达到这一目标的最佳实践之一。*持续集成 (CI)*
    是软件开发的一种实践，其中开发者频繁地检查代码，定期（至少每天一次）集成，每次集成后都进行验证，这是一个自动化的过程，用于构建和测试集成更改 ([http://mng.bz/aMpz](http://mng.bz/aMpz))。这个过程使我们能够以恒定的速度和适当的水平实现可靠、可重复和可重用的构建，同时防止混乱并提高效率。
- en: Continuous integration is only one aspect of the software delivery process.
    For a successful pipeline-driven development, CI must be followed by continuous
    delivery. *Continuous delivery (CD)* ([https://continuousdelivery.com/](https://continuousdelivery.com/))
    is the ability to get changes of all types, including new features, configuration
    changes, bug fixes, and experiments, into production safely and quickly in a sustainable
    way. It applies to infrastructure configurations, application deployment, and
    mobile app publishing, and database and static resource modifications. Continuous
    delivery can be used in any environment, regardless of the regulatory requirements
    for a particular organization. A CD pipeline improves delivery of software from
    source to production by making this process more automated, thus improving reliability,
    predictability, and visibility of the pipeline, which reduces risks.[¹](#pgfId-1068821)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成只是软件交付过程的一个方面。为了成功实现以管道驱动的开发，CI 必须由持续交付（CD）紧随其后。*持续交付（CD）* ([https://continuousdelivery.com/](https://continuousdelivery.com/))
    是以可持续的方式安全且快速地将所有类型的更改（包括新功能、配置更改、错误修复和实验）引入生产的能力。它适用于基础设施配置、应用程序部署、移动应用发布以及数据库和静态资源修改。CD
    管道通过使此过程更加自动化，从而提高了从源到生产的软件交付，改善了管道的可靠性、可预测性和可见性，从而降低了风险。[¹](#pgfId-1068821)
- en: Let’s look at some features that characterize modern CI/CD platforms.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看一些表征现代 CI/CD 平台的特征。
- en: 12.1.1 Repeatability
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.1 可重复性
- en: Repeatability allows for automation of requirements and processes around created
    code and artifacts. Build processes should be deterministic, so developers have
    confidence in produced artifacts. Repeatable builds and testing allow developers
    to run the same processes in their local environments as well. Automation of deployment
    and configuration management helps to provide consistency across environments.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 可重复性允许对创建的代码和工件周围的要求和流程进行自动化。构建过程应该是确定性的，这样开发者才能对产生的工件有信心。可重复的构建和测试允许开发者在其本地环境中运行相同的流程。部署和配置管理的自动化有助于在不同环境中提供一致性。
- en: 12.1.2 Reliability
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.2 可靠性
- en: Reliability improves confidence of the development and operational teams in
    the processes and systems that guarantee availability and suitability of the tools
    as well as the completeness and sufficiency of integration, testing, and operational
    requirements. Automated testing via defined workflows is key to capture and track
    components’ final success and failure states, increasing team confidence and knowledge
    during development and release cycles.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 可靠性提高了开发和运营团队对保证工具可用性和适宜性、集成、测试和操作要求的完整性和充分性的流程和系统的信心。通过定义的工作流程进行自动化测试是捕捉和跟踪组件最终成功和失败状态的关键，这增加了团队在开发和发布周期中的信心和知识。
- en: 12.1.3 Reusability
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.3 可复用性
- en: Reusability enables teams to scale up, simplify, and speed up development workflows.
    A CI/CD pipeline should be implemented in such a way that allows for reusing components
    of the pipeline for similar applications. This not only reduces the cost of setting
    up new pipelines but also improves developer efficiency when working with multiple
    applications across the enterprise.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 可复用性使团队能够扩展、简化并加速开发工作流程。CI/CD 管道应该以允许为类似应用程序重用管道组件的方式进行实施。这不仅降低了设置新管道的成本，而且当跨企业处理多个应用程序时，也提高了开发者的效率。
- en: 12.1.4 Automated tests
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.4 自动化测试
- en: In a high-quality delivery process, it is critical to validate developed systems’
    architecture and functionality. This can be achieved via the implementation of
    a robust automated testing flow as an integral part of the CD pipeline. Modern
    delivery pipelines should have as many automated tests as possible, including
    not only unit, component, and system functional tests but also nonfunctional ones
    that check capability, availability, and security compliance. Automated tests
    provide almost immediate feedback to developers, decreasing the number of bugs
    and the error rate for production deployments.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在高质量交付过程中，验证开发系统的架构和功能至关重要。这可以通过在 CD 管道中实施一个强大的自动化测试流程作为其组成部分来实现。现代交付管道应该尽可能多地包含自动化测试，包括单元、组件和系统功能测试，以及检查能力、可用性和安全合规性的非功能性测试。自动化测试几乎立即为开发者提供反馈，减少了生产部署中的错误数量和错误率。
- en: 12.1.5 Trunk-based development
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.5 基于主干开发
- en: Continuous delivery can be significantly slowed down when developers work in
    “split-brain” environments, where feature or bug-fix code branches have a very
    long lifetime. As a result, in big teams, code changes can cause conflicts when
    integrating long live branches. This may require manual activities, grinding CI
    processes to a halt.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者工作在“分裂大脑”环境中时，持续交付可能会显著减慢，在这种环境中，功能或错误修复代码分支的寿命非常长。结果，在大团队中，代码更改在集成长期存活分支时可能会引起冲突。这可能需要手动活动，使CI流程陷入停滞。
- en: 12.1.6 Environment parity
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.6 环境一致性
- en: Environmental consistency is one of the key aspects of reducing risk in production
    deployments. Deployments to the development and production environment must rely
    on the same processes, architectural principles, and configuration policies. Fully
    automated deployments are essential to enable automated testing and feedback in
    the CD pipeline. It allows easy reproduction of the entire state of the environment
    based on the code and data stored in the version control systems.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 环境一致性是降低生产部署风险的关键方面之一。开发环境和生产环境的部署必须依赖于相同的流程、架构原则和配置策略。完全自动化的部署对于在CD管道中实现自动化测试和反馈至关重要。它允许根据存储在版本控制系统中的代码和数据轻松地复制整个环境的状态。
- en: 12.1.7 Deployment automation
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.7 部署自动化
- en: 'It’s important to acknowledge that deployment automation can be a journey that
    should be realized in small steps. You should start with components that are easy
    to automate, reduce the number of manual steps, and slowly progress to automate
    more complex components. Looking at deployment automation and testing, one factor
    plays an important role: architecture. The best processes and tools used for CD
    cannot help us if our architecture introduces significant limitations and is a
    tightly coupled design.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要承认，部署自动化可能是一个需要分步骤实现的旅程。你应该从易于自动化的组件开始，减少手动步骤的数量，并逐步自动化更复杂的组件。在考虑部署自动化和测试时，一个因素起着重要作用：架构。如果我们架构引入了重大的限制并且是一个紧密耦合的设计，那么用于CD的最佳流程和工具将无法帮助我们。
- en: 12.1.8 Team culture
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.8 团队文化
- en: Full cooperation between operations and development teams is required to automate
    build, testing, deployment, and infrastructure. This ensures the entire process
    is fully understood by all parties and does not introduce unnecessary complexity.
    It is not an easy process, and it often requires long hours spent together to
    rework architecture for existing processes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 运营和开发团队之间的全面合作对于自动化构建、测试、部署和基础设施至关重要。这确保了所有相关方都完全理解整个过程，并且不会引入不必要的复杂性。这不是一个容易的过程，通常需要花费大量时间一起重新设计现有流程的架构。
- en: 12.1.9 Built-in security/DevSecOps
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.9 内置安全/DevSecOps
- en: Prevention is better than cure. The same applies for software delivery and challenges
    related to security. Shortening the feedback loop for teams during software delivery
    is known as the *shifting-left approach*. The same approach is used to introduce
    security processes early in the development process and across the entire continuous
    delivery flow. This approach enables teams to build a development stack that is
    based on preapproved, standardized tools and policies ([http://mng.bz/gJKl](http://mng.bz/gJKl)).
    This tooling helps teams address security requirements as part of their regular
    development and delivery activities. Standardization enables additional testing
    capabilities, where automated tests can be extended to meet security and regulatory
    requirements in the production setups. Like automated deployment, automation for
    security measures can be implemented in small steps, reducing the need for manual
    reviews and tests over time. As a result, developers don’t need to care about
    it anymore.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 预防胜于治疗。这一点同样适用于软件交付和安全相关的挑战。在软件交付过程中缩短团队的反馈循环被称为“左移策略”。同样的方法用于在开发过程早期以及整个持续交付流程中引入安全流程。这种方法使团队能够构建基于预先批准、标准化的工具和政策（[http://mng.bz/gJKl](http://mng.bz/gJKl)）的开发栈。这些工具帮助团队将其常规的开发和交付活动中的安全需求作为一部分来处理。标准化使得额外的测试能力成为可能，其中自动化测试可以扩展以满足生产环境中的安全和监管要求。与自动化部署一样，安全措施的自动化可以分步骤实施，随着时间的推移减少对人工审查和测试的需求。因此，开发者不再需要关心这些。
- en: 12.1.10 Version control
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.10 版本控制
- en: Version control must be applied to every single artifact of our delivery and
    integration pipelines, starting from application code, configuration, and system
    configuration, and closing on scripts used for automated build and configuration
    of environments. It supports developers during application development via auditability
    or scalability of “as a code”-based environments. It also reacts to demand for
    immediate changes or disasters in production caused by vulnerability or defects
    discovered in the system or environment, allowing them to be released in a controlled
    way with an easy way for automated rollback.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制必须应用于我们交付和集成管道的每个工件，从应用程序代码、配置和系统配置开始，到用于自动化构建和配置环境的脚本结束。它通过“代码即配置”环境的可审计性或可伸缩性支持开发者在应用程序开发期间。它还响应对即时更改或由系统或环境中发现的漏洞或缺陷引起的生产中的灾难的需求，允许它们以可控的方式发布，并提供了自动回滚的简单方法。
- en: It is quite simple to maintain a small version control system, but when teams
    are growing, code maintainability becomes more and more challenging. In such cases,
    it is key to allow all team members easy access to code. Due to this, they will
    reuse existing code instead of creating duplicate copies and extend the code for
    new capabilities or to fix bugs globally. Version control promotes quick software
    delivery because knowledge can be passed between teams easily. It results in a
    higher quality of code and, consequently, increases scalability and availability.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 维护一个小型版本控制系统相当简单，但当团队规模扩大时，代码的可维护性变得越来越具有挑战性。在这种情况下，允许所有团队成员轻松访问代码至关重要。因此，他们将重用现有代码而不是创建重复的副本，并扩展代码以实现新的功能或修复全局错误。版本控制通过团队之间轻松传递知识来促进快速软件交付。这导致代码质量更高，从而提高了可扩展性和可用性。
- en: 12.1.11 Artifact versioning
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.11 工件版本控制
- en: Build artifacts need to be idempotent and immutable for teams to trust the integrity
    of the build system. Systems that create artifacts from the same source multiple
    times risk generating slightly different artifacts in each step due to config
    drifts. Managing build artifacts and their versions is important to prevent storing
    different versions of the same artifact in multiple places. Immutable versioned
    artifacts provide full visibility into history and references in a single place.
    This also helps manage dependencies and improves reuse.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 构建工件需要是无条件重复和不可变的，这样团队才能信任构建系统的完整性。从相同源多次创建工件的系统可能会因为配置漂移而在每个步骤中生成略微不同的工件。管理构建工件及其版本对于防止在多个地方存储同一工件的多个版本非常重要。不可变的版本化工件可以在一个地方提供对历史和引用的全面可见性。这也帮助管理依赖关系并提高重用性。
- en: 12.1.12 Monitoring
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.12 监控
- en: The final capability to highlight is *monitoring*. Understanding and monitoring
    the health of a system are critical to mitigate possible problems before they
    occur. Proactive failure notifications based on threshold or rate-of-change warnings
    build operational knowledge about the system’s status. Extended by logging and
    monitoring, failure alerts routed to teams or systems introduce a chance to react
    to these events in a timely manner and prevent outages and downtime.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 需要强调的最后一个能力是*监控*。理解和监控系统的健康状况对于在问题发生之前减轻潜在问题至关重要。基于阈值或变化率的主动故障通知构建了关于系统状态的运营知识。通过日志记录和监控扩展，将故障警报路由到团队或系统为及时对这些事件做出反应提供了机会，并防止了中断和停机。
- en: '*Full-stack monitoring* allows support teams to debug systems and measure their
    behaviors against defined patterns or changes. *Historical monitoring data* allows
    us to introduce continuous improvements fast, which improves efficiency of the
    CI/CD pipelines.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*全栈监控*允许支持团队调试系统并测量其行为与定义的模式或变化。*历史监控数据*使我们能够快速引入持续改进，从而提高了CI/CD管道的效率。'
- en: 12.2 Continuous delivery vs. continuous deployment
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2 持续交付与持续部署的比较
- en: We talked a lot about continuous delivery, which often is mixed with continuous
    deployment. Even though they are hidden behind the same CD abbreviation, a subtle
    difference exists between the concepts. Continuous deployment extends continuous
    delivery by adding autodeployment of delivered artifacts to user environments
    without manual intervention. Though continuous delivery is applied to all kinds
    of software, business applications, mobile apps, and firmware, continuous deployment
    is applicable mostly when code changes can be immediately applied to production.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了很多关于持续交付的内容，它通常与持续部署混合使用。尽管它们都隐藏在相同的CD缩写后面，但这两个概念之间存在细微的差别。持续部署通过添加自动部署交付的工件到用户环境，而不需要人工干预，从而扩展了持续交付。尽管持续交付适用于所有类型的软件，包括商业应用程序、移动应用程序和固件，但持续部署主要适用于代码变更可以立即应用到生产的情况。
- en: As we have familiarized ourselves with the CI/CD concept and capabilities, we
    can now move into detailed description of implementation options, practices, and
    tools.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们熟悉了CI/CD的概念和能力之后，我们现在可以进入实施选项、实践和工具的详细描述。
- en: 12.3 Continuous development
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.3 持续开发
- en: Developing cloud native applications is very exciting but comes with some challenges.
    Figure 12.2 shows the flow that developers need to follow to get the preview of
    a Kubernetes application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 开发云原生应用程序非常令人兴奋，但也带来了一些挑战。图12.2显示了开发者需要遵循的流程，以预览Kubernetes应用程序。
- en: '![12-02](../../OEBPS/Images/12-02.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![12-02](../../OEBPS/Images/12-02.png)'
- en: Figure 12.2 Continuous development workflow
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 持续开发工作流程
- en: As we see, once the code is developed, an image needs to be built and pushed
    to the container registry, following predefined steps. Next, the application needs
    to be deployed to the target cluster. This means that for every change committed
    by the developer, the same workflow is triggered. Imagine a full day of running
    multiple commands just to get your application previewed! This is becoming a developer’s
    nightmare.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，一旦代码开发完成，就需要按照预定义的步骤构建镜像并将其推送到容器注册库。接下来，应用程序需要部署到目标集群。这意味着对于开发者提交的每一个变更，都会触发相同的流程。想象一下，整整一天都在运行多个命令，只是为了预览你的应用程序！这正在成为开发者的噩梦。
- en: In this section, we will look at some tools that will allow us to both deploy
    the Anthos application locally without the need to have a running Anthos cluster
    and automate the entire flow we identified.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一些工具，这些工具将允许我们在不需要运行Anthos集群的情况下本地部署Anthos应用程序，并自动化我们确定的整个流程。
- en: Let’s start by setting our local execution environment based on minikube. Next,
    we will look at how to automate the repeatable and laborious tasks needed to preview
    the application after code changes. Finally, we will discuss how we can use an
    integrated development environment (IDE) to deliver a complete Anthos application
    development experience (DX).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基于minikube设置我们的本地执行环境开始。接下来，我们将探讨如何自动化在代码变更后预览应用程序所需的重复性和繁重任务。最后，我们将讨论如何使用集成开发环境（IDE）提供完整的Anthos应用程序开发体验（DX）。
- en: 12.3.1 Setting up a local preview minikube cluster
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.1 设置本地预览minikube集群
- en: minikube ([https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/))
    is a popular software application that allows you to run Kubernetes applications
    locally on your laptop. It runs on Windows, Linux, and macOS. Instead of deploying
    your application to an Anthos cluster, you can deploy it locally and preview your
    application before pushing the code to the Git repository. This will save you
    time and reduce development environment cost. Even though minikube is not designed
    to host production workloads, it supports most of the features supported by Kubernetes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: minikube ([https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/))
    是一款流行的软件应用程序，允许你在笔记本电脑上本地运行Kubernetes应用程序。它支持Windows、Linux和macOS。你不必将应用程序部署到Anthos集群，而是可以本地部署并预览应用程序，然后再将代码推送到Git仓库。这将节省你的时间并降低开发环境成本。尽管minikube不是为托管生产工作负载而设计的，但它支持Kubernetes支持的大多数功能。
- en: 'You can interact with it like with a regular cluster using the kubectl command-line
    interface. You can Minikube on any laptop that fulfills the following minimum
    requirements:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用kubectl命令行界面与之交互，就像与常规集群一样。Minikube可以在满足以下最低要求的任何笔记本电脑上运行：
- en: 2 CPUs
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2个CPU
- en: 2 GB of free memory
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 GB的空闲内存
- en: 20 GB of free disk space
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 20 GB的空闲磁盘空间
- en: Internet connectivity
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网连接
- en: Virtualization software like Virtual Box
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟化软件，如Virtual Box
- en: Figure 12.3 shows the tools that you can use to interact with minikube. We will
    review Skaffold and Cloud Code in the following sections of this chapter. They
    provide a great alternative for a development Anthos cluster.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3显示了你可以用来与minikube交互的工具。我们将在本章的后续部分回顾Skaffold和Cloud Code。它们为开发Anthos集群提供了一个很好的替代方案。
- en: '![12-03](../../OEBPS/Images/12-03.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![12-03](../../OEBPS/Images/12-03.png)'
- en: Figure 12.3 minikube integrations
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 minikube集成
- en: The installation process is fairly simple but depends on the OS you use. This
    might change with new version releases, so it is recommended you refer to the
    official page at [https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/)
    for the installation procedure. Let’s look at how we can deploy our example application
    using minikube.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 安装过程相当简单，但取决于你使用的操作系统。这可能会随着新版本发布而改变，因此建议你参考[https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/)上的官方页面以获取安装步骤。让我们看看我们如何使用minikube部署我们的示例应用程序。
- en: 'Once minikube is successfully installed, you can start it by running the following
    command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦minikube成功安装，你可以通过运行以下命令来启动它：
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now you can create a simple hello-minikube Deployment and expose it using the
    NodePort service. We will use an already existing container image, echoserver:1.4,
    but you can also build your own image:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以创建一个简单的hello-minikube Deployment，并使用NodePort服务将其公开。我们将使用一个现有的容器镜像，echoserver:1.4，但你也可以构建自己的镜像：
- en: 'Create a Deployment by running the following:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令创建Deployment：
- en: '[PRE1]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Expose the Deployment by creating a service:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建服务来公开Deployment：
- en: '[PRE2]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Check the service exists:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查服务是否存在：
- en: '[PRE3]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should see the following prompt:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到以下提示：
- en: '[PRE4]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Configure port forwarding for the service to your local machine port:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为服务配置端口转发到你的本地机器端口：
- en: '[PRE5]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following prompt will appear indicating the port is forwarded:'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将出现以下提示，指示端口已转发：
- en: '[PRE6]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now we can open the browser and see that the service is responding on the address
    http:/ /localhost:8080, as shown in figure 12.4.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以打开浏览器并看到服务正在地址http:/ /localhost:8080上响应，如图12.4所示。
- en: '![12-04](../../OEBPS/Images/12-04.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![12-04](../../OEBPS/Images/12-04.png)'
- en: Figure 12.4 The browser results page
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 浏览器结果页面
- en: We have now seen how to preview our application. As you may have noticed, it
    still requires us to build the images and use kubectl to update the preview of
    the application followed by a change in code. This process is not very efficient,
    and, ideally, we need a tool to automate these steps. A common tool to achieve
    that is Skaffold.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何预览我们的应用程序。正如你可能已经注意到的，它仍然需要我们构建镜像并使用kubectl更新应用程序的预览，随后是代码的更改。这个过程并不高效，理想情况下，我们需要一个工具来自动化这些步骤。实现这一目标的常用工具是Skaffold。
- en: 12.3.2 Continuous development with Skaffold
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.2 使用Skaffold进行持续开发
- en: Skaffold ([https://skaffold.dev/](https://skaffold.dev/)) is an open source
    project sponsored by Google. It was started to address the needs for continuous
    development for Kubernetes applications. As we learned in the previous section,
    for a developer to deploy an application, they must write the necessary steps
    to create the container image, push the created image to a repo, and finally,
    get it deployed to a cluster.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Skaffold([https://skaffold.dev/](https://skaffold.dev/))是一个由Google赞助的开源项目。它始于解决Kubernetes应用程序持续开发的需求。正如我们在上一节中学到的，为了部署应用程序，开发者必须编写创建容器镜像、将创建的镜像推送到仓库以及最终将其部署到集群的必要步骤。
- en: Skaffold achieves this by handling all those steps automatically. It continuously
    watches the source files and triggers the previously mentioned steps to create
    a preview of the Kubernetes application on a local minikube or remote Anthos cluster.
    The application resources are cleaned up automatically when the developer stops
    Skaffold by simply pressing Ctrl+C.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Skaffold通过自动处理所有这些步骤来实现这一点。它持续监视源文件，并触发之前提到的步骤，在本地minikube或远程Anthos集群上创建Kubernetes应用程序的预览。当开发者通过简单地按Ctrl+C停止Skaffold时，应用程序资源会自动清理。
- en: On top of continuous development capabilities, Skaffold offers building blocks
    for CI/CD pipelines. It supports deployments using kubectl, Helm ([https://helm.sh/](https://helm.sh/)),
    and Kustomize ([https://kustomize.io/](https://kustomize.io/)). Let’s look at
    figure 12.5, which visualizes a flow for how development with Skaffold looks.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在持续开发功能的基础上，Skaffold还提供了CI/CD管道的构建块。它支持使用kubectl、Helm([https://helm.sh/](https://helm.sh/))和Kustomize([https://kustomize.io/](https://kustomize.io/))进行部署。让我们看看图12.5，它可视化了一个使用Skaffold进行开发的流程。
- en: '![12-05](../../OEBPS/Images/12-05.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![12-05](../../OEBPS/Images/12-05.png)'
- en: Figure 12.5 Skaffold functionalities
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 Skaffold功能
- en: In this figure, you can see a simple pipeline visualization. Skaffold is watching
    for source file changes in an indicated folder. When it detects a change, Skaffold
    automatically builds images and pushes them to the registry. Once containers are
    built, Skaffold deploys the container image to a predefined Kubernetes endpoint.
    In an upcoming section, we will explain how Skaffold is integrated with Cloud
    Code ([https://cloud.google.com/code](https://cloud.google.com/code)) for an even
    better developer experience.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，你可以看到一个简单的管道可视化。Skaffold正在监视指定文件夹中的源文件更改。当它检测到更改时，Skaffold会自动构建镜像并将它们推送到注册表。一旦容器构建完成，Skaffold会将容器镜像部署到预定义的Kubernetes端点。在接下来的部分中，我们将解释Skaffold如何与Cloud
    Code ([https://cloud.google.com/code](https://cloud.google.com/code)) 集成，以提供更好的开发者体验。
- en: Working with Skaffold
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Skaffold
- en: 'The user interacts with Skaffold using a command-line interface (CLI). A complete
    guide for Skaffold can be found here: [https://skaffold.dev/docs/references/cli/](https://skaffold.dev/docs/references/cli/).
    For a quick overview of how to work with Skaffold, let’s look at the basic steps.
    We will see how we can deploy the Hello World application written in Go.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 用户通过命令行界面（CLI）与Skaffold交互。Skaffold的完整指南可以在这里找到：[https://skaffold.dev/docs/references/cli/](https://skaffold.dev/docs/references/cli/)。为了快速了解如何使用Skaffold，让我们看看基本步骤。我们将看到如何部署用Go编写的Hello
    World应用程序。
- en: Installing Skaffold
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Skaffold
- en: The process for installing Skaffold varies, depending on the underlying operating
    system. Skaffold can be installed as a component of gcloud. It is also available
    as a container image, gcr.io/k8s-skaffold/skaffold:latest, which can be used directly
    in cloud native CI/CD tools. All installation options are explained at the official
    site ([https://skaffold.dev/docs/install/](https://skaffold.dev/docs/install/)).
    For a local preview, you can use minikube, which will allow you to deploy your
    application on your laptop.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Skaffold的过程因底层操作系统而异。Skaffold可以作为gcloud组件安装。它也可以作为容器镜像gcr.io/k8s-skaffold/skaffold:latest提供，可以直接在云原生CI/CD工具中使用。所有安装选项都在官方网站上解释
    ([https://skaffold.dev/docs/install/](https://skaffold.dev/docs/install/))。对于本地预览，你可以使用minikube，这将允许你在笔记本电脑上部署你的应用程序。
- en: Skaffold configuration file
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Skaffold配置文件
- en: 'Skaffold uses a single configuration YAML file, skaffold.yaml, to define the
    steps in a CD pipeline. It resembles a Kubernetes resource manifest. Let’s look
    at a very basic sample config file here:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Skaffold使用单个配置YAML文件skaffold.yaml来定义CD管道中的步骤。它类似于Kubernetes资源清单。让我们在这里看看一个非常基本的示例配置文件：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Two phases are defined in the previous pipeline: build and deploy. In the build
    phase, Skaffold looks for a Dockerfile definition and uses it to build a container
    image with the name skaffold-example. In the deploy phase, Skaffold uses kubectl
    to deploy all objects defined in the YAML files starting with the k8s- prefix.
    A comprehensive explanation of the configuration file structure can be found on
    the Skaffold site ([https://skaffold.dev/docs/references/yaml/](https://skaffold.dev/docs/references/yaml/)).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的管道中定义了两个阶段：构建和部署。在构建阶段，Skaffold寻找Dockerfile定义，并使用它来构建名为skaffold-example的容器镜像。在部署阶段，Skaffold使用kubectl部署所有以k8s-前缀开始的YAML文件中定义的对象。配置文件结构的详细解释可以在Skaffold网站上找到
    ([https://skaffold.dev/docs/references/yaml/](https://skaffold.dev/docs/references/yaml/))。
- en: Initiating Skaffold
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Skaffold
- en: 'You can generate a skaffold.yaml configuration automatically by running the
    following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令自动生成skaffold.yaml配置：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will detect the source files in the current folder and create a very simple
    configuration file with build and deploy sections. Let’s create the following
    three files, as shown in the next code snippet:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这将检测当前文件夹中的源文件，并创建一个包含构建和部署部分的非常简单的配置文件。让我们创建以下三个文件，如下面的代码片段所示：
- en: '*Dockerfile*—Container image definition'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Dockerfile*—容器镜像定义'
- en: '*main.go*—Simple Hello World Go application'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*main.go*—简单的Hello World Go应用程序'
- en: '*k8s-pod.yaml*—Kubernetes pod definition'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*k8s-pod.yaml*—Kubernetes pod定义'
- en: 'Dockerfile content:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile内容：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will generate a skaffold.yaml file, which we have already seen in the
    previous section, with two phases:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个skaffold.yaml文件，我们已经在上一节中看到了，包含两个阶段：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can take it from here and expand the file as per your needs, using the Skaffold
    documentation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从这里开始，根据你的需要扩展文件，使用Skaffold文档。
- en: Developing with Skaffold
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Skaffold进行开发
- en: 'We ended up having four files in the folder, including the Skaffold config
    file. Now we can start to do continuous development, where Skaffold will be watching
    the source folder for changes and perform all the steps defined in the skaffold.yaml
    file. To start the development, run the next command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最终我们在文件夹中有四个文件，包括 Skaffold 配置文件。现在我们可以开始持续开发，其中 Skaffold 将监视源文件夹中的更改并执行 skaffold.yaml
    文件中定义的所有步骤。要开始开发，请运行以下命令：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Skaffold will automatically tail the logs from the deployed container to the
    console. Now if you change the source file main.go to print hello from Skaffold
    instead of hello world, Skaffold will automatically detect the change, rebuild
    the image, push it to the registry, and deploy it. As the logs tail to the console,
    you should see the message hello from Skaffold.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Skaffold 将自动将部署容器的日志从控制台输出。现在如果您将源文件 main.go 中的内容改为从 Skaffold 打印 hello 而不是 hello
    world，Skaffold 将自动检测更改，重新构建镜像，将其推送到注册表，并部署它。由于日志输出到控制台，您应该看到来自 Skaffold 的消息 hello。
- en: Single run with Skaffold
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Skaffold 单次运行
- en: Although skaffold dev has been continuously watching the source files, you can
    also perform a single execution of the workflow by running the skaffold run command.
    This is useful when you want to run the execution only once and not trigger the
    flow every time your code is modified.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 skaffold dev 一直在监视源文件，但您也可以通过运行 skaffold run 命令来执行单个工作流程。当您只想运行一次执行而不希望每次代码修改时都触发流程时，这很有用。
- en: Supported features
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的功能
- en: By now you should have a basic understanding of how to start development with
    Skaffold, so let’s look at other useful features available.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，您应该已经基本了解了如何使用 Skaffold 开始开发，那么让我们看看其他有用的功能。
- en: Pipelines stages
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 流程阶段
- en: Up to now, we have looked only at the basic functionalities of Skaffold. However,
    the tool has more capabilities that can address advanced pipeline stages. For
    example, a developer might not want to rebuild the images after every code change.
    In such a case, Skaffold can synchronize the files into the container main.go
    source file. To achieve this, you would use the file sync feature. Figure 12.6
    shows all the steps in the workflow.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看了 Skaffold 的基本功能。然而，这个工具还有更多能力可以解决高级流程阶段。例如，开发者可能不希望在每次代码更改后都重新构建镜像。在这种情况下，Skaffold
    可以将文件同步到容器的主.go 源文件中。要实现这一点，您将使用文件同步功能。图 12.6 显示了工作流程中的所有步骤。
- en: '![12-06](../../OEBPS/Images/12-06.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![12-06](../../OEBPS/Images/12-06.png)'
- en: Figure 12.6 Skaffold workflow
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6 Skaffold 工作流程
- en: 'The following list shows all the Skaffold pipeline stages that can be used
    to execute these steps:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了所有可以用来执行这些步骤的 Skaffold 流程阶段：
- en: '*Init*—Generates basic Skaffold configuration'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*初始化*—生成基本的 Skaffold 配置'
- en: '*Build*—Builds images with builders of choice'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*构建*—使用选择的构建器构建镜像'
- en: '*Test*—Tests images with structure tests[²](#pgfId-1069130)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*测试*—使用结构测试测试镜像[²](#pgfId-1069130)'
- en: '*Tag*—Tags images based on different policies'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*标记*—根据不同的策略标记镜像'
- en: '*Deploy*—Deploys the application with kubectl, Kustomize, or Helm'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*部署*—使用 kubectl、Kustomize 或 Helm 部署应用程序'
- en: '*File sync*—Synchronizes the changed files directly to running containers'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文件同步*—将更改的文件直接同步到运行中的容器'
- en: '*Log tailing*—Tails logs from containers'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*日志输出*—输出容器的日志'
- en: '*Port forwarding*—Forwards ports from services to localhost'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*端口转发*—将服务端口转发到本地主机'
- en: '*Cleanup*—Cleans up manifests and images'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*清理*—清理清单和镜像'
- en: As you can see, we have a complete pipeline that allows us to deploy and preview
    Anthos applications.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们有一个完整的流程，使我们能够部署和预览 Anthos 应用程序。
- en: Supported environments
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的环境
- en: Skaffold supports both local and remote Kubernetes clusters. You can use a local
    development cluster like minikube or an Anthos/Kubernetes cluster deployed in
    a remote location.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Skaffold 支持本地和远程 Kubernetes 集群。您可以使用本地开发集群，如 minikube 或在远程位置部署的 Anthos/Kubernetes
    集群。
- en: To connect to a remote Kubernetes cluster, you need to set a context in the
    kubeconfig file as if connecting to any Kubernetes cluster. The default context
    can be overwritten by running
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到远程 Kubernetes 集群，您需要在 kubeconfig 文件中设置一个上下文，就像连接到任何 Kubernetes 集群一样。默认上下文可以通过运行以下命令来覆盖：
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'or by updating the skaffold.yaml file deploy.kubeContext attribute:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 或者通过更新 skaffold.yaml 文件中的 deploy.kubeContext 属性：
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Supported build tools
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的构建工具
- en: 'If you need to use another tool to build container images, the build section
    of the skaffold.yaml configuration file can be configured for custom builders.
    To use a custom builder, define the proper options for using that builder to the
    build section. Details about customer builders are at [http://mng.bz/pdvG](http://mng.bz/pdvG).
    The following tools are currently supported:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要使用其他工具来构建容器镜像，可以在 skaffold.yaml 配置文件的构建部分配置自定义构建器。要使用自定义构建器，请在构建部分定义适当的选项以使用该构建器。有关客户构建器的详细信息，请参阅
    [http://mng.bz/pdvG](http://mng.bz/pdvG)。以下工具目前受到支持：
- en: Docker
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: Jib ([http://mng.bz/Oprn](http://mng.bz/Oprn))
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jib ([http://mng.bz/Oprn](http://mng.bz/Oprn))
- en: Bazel ([http://mng.bz/Y64N](http://mng.bz/Y64N))
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bazel ([http://mng.bz/Y64N](http://mng.bz/Y64N))
- en: Buildpacks ([http://mng.bz/GRAq](http://mng.bz/GRAq))
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Buildpacks ([http://mng.bz/GRAq](http://mng.bz/GRAq))
- en: You can also use custom scripts that are in line with the Skaffold defined standard.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用与 Skaffold 定义的规范一致的定制脚本。
- en: Using Skaffold in CI/CD pipelines
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CI/CD 管道中使用 Skaffold
- en: 'You can also use Skaffold as a tool in your CI/CD pipelines. An existing community-maintained
    builder ([http://mng.bz/zmOa](http://mng.bz/zmOa)) can be directly used with Cloud
    Build, which is a native CI Google Cloud tool (we will have a look at it in detail
    in the next section). Some of the most useful Skaffold commands in CI/CD workflows
    follow:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将 Skaffold 作为 CI/CD 管道中的工具使用。现有的社区维护的构建器 ([http://mng.bz/zmOa](http://mng.bz/zmOa))
    可以直接与 Cloud Build 一起使用，Cloud Build 是 Google Cloud 的原生 CI 工具（我们将在下一节中详细探讨它）。以下是一些在
    CI/CD 工作流程中最有用的 Skaffold 命令：
- en: skaffold build—Builds and tags your image(s)
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: skaffold build—构建和标记您的镜像（们）
- en: skaffold deploy—Deploys the given image(s)
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: skaffold deploy—部署给定的镜像（们）
- en: skaffold delete—Cleans up the deployed artifacts
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: skaffold delete—清理已部署的工件
- en: skaffold render—Builds and tags images and outputs templated Kubernetes manifests
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: skaffold render—构建和标记镜像，并输出模板化的 Kubernetes 清单
- en: Skaffold summary
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Skaffold 概述
- en: In this section, we have learned how to install Skaffold and use it in a continuous
    development workflow. Follow the Skaffold Quickstart guide at [https://skaffold.dev/docs/quickstart/](https://skaffold.dev/docs/quickstart/)
    for more information on using Skaffold with development workflows.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何安装 Skaffold 并将其用于持续开发工作流程。有关使用 Skaffold 与开发工作流程的更多信息，请参考 Skaffold
    快速入门指南 [https://skaffold.dev/docs/quickstart/](https://skaffold.dev/docs/quickstart/)。
- en: '12.3.3 Cloud Code: Developing with a local IDE'
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.3 云代码：使用本地 IDE 进行开发
- en: 'We have learned how we can preview the Anthos application, but now let’s look
    at how we can elevate this experience. One of the unaddressed challenges so far
    is maintaining the configuration for the development environment. Developers want
    to develop their applications without leaving their favorite IDE. Cloud Code improves
    the developer experience by integrating the already known set of tools to provide
    containerization and deployment of applications, including the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何预览 Anthos 应用程序，但现在让我们看看如何提升这一体验。迄今为止尚未解决的问题之一是维护开发环境的配置。开发者希望在他们的首选
    IDE 中开发应用程序。Cloud Code 通过集成已知的工具集来提高开发者体验，提供应用程序的容器化和部署，包括以下内容：
- en: kubectl
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kubectl
- en: Skaffold
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Skaffold
- en: Google Cloud SDK (gcloud)
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Cloud SDK (gcloud)
- en: Cloud Code is a plug-in for IDEs like Visual Studio Code ([https://code.visualstudio.com/](https://code.visualstudio.com/))
    and IntelliJ ([https://www.jetbrains.com/idea/](https://www.jetbrains.com/idea/)).
    It integrates with minikube and Kubernetes clusters, including Anthos clusters.
    It comes with the Google Cloud platform API explorer and Kubernetes objects explorer.
    You can use it to view your Kubernetes resources directly from IDE without running
    a single kubectl command.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Code 是 Visual Studio Code ([https://code.visualstudio.com/](https://code.visualstudio.com/))
    和 IntelliJ ([https://www.jetbrains.com/idea/](https://www.jetbrains.com/idea/))
    等 IDE 的插件。它与 minikube 和 Kubernetes 集群（包括 Anthos 集群）集成。它包含 Google Cloud 平台 API
    探索器和 Kubernetes 对象探索器。您可以直接从 IDE 中查看您的 Kubernetes 资源，而无需运行任何 kubectl 命令。
- en: Figures 12.7 and 12.8 show the collection of prebuilt application templates
    that can run and debug an Anthos application (both Kubernetes and Cloud Run).
    The first figure allows you to generate all the files you need to deploy simple
    applications. The second automatically detects changes to source files, builds
    container images, and deploys to the selected Kubernetes endpoint. All these tasks
    are deployed by Skaffold.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7 和 12.8 展示了可以运行和调试 Anthos 应用程序（包括 Kubernetes 和 Cloud Run）的预构建应用程序模板集合。第一个图允许您生成部署简单应用程序所需的所有文件。第二个图自动检测源文件的变化，构建容器镜像，并将应用程序部署到所选的
    Kubernetes 端点。所有这些任务都是由 Skaffold 部署的。
- en: Figure 12.7 also shows the flow for an Anthos/Kubernetes application, which
    is very similar to the Skaffold flow. The difference is that the developer uses
    an IDE to perform these steps.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7 还显示了 Anthos/Kubernetes 应用程序的流程，这与 Skaffold 流程非常相似。不同之处在于，开发者使用 IDE 来执行这些步骤。
- en: '![12-07](../../OEBPS/Images/12-07.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![12-07](../../OEBPS/Images/12-07.png)'
- en: Figure 12.7 Running and debugging a Kubernetes application with Cloud Code
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7 使用 Cloud Code 运行和调试 Kubernetes 应用程序
- en: As shown in figure 12.8, Cloud Code helps us by setting up an emulator based
    on minikube. It runs locally and enables the developer to run and test the Cloud
    Run applications. It is also possible to deploy to GCP-managed services like Cloud
    Run or Cloud Run for Anthos.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 12.8 所示，Cloud Code 通过基于 minikube 设置模拟器来帮助我们。它在本地上运行，并允许开发者运行和测试 Cloud Run
    应用程序。还可以将应用程序部署到 GCP 管理的服务，如 Cloud Run 或 Cloud Run for Anthos。
- en: '![12-08](../../OEBPS/Images/12-08.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![12-08](../../OEBPS/Images/12-08.png)'
- en: Figure 12.8 Running and debugging a Cloud Run application with Cloud Code
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.8 使用 Cloud Code 运行和调试 Cloud Run 应用程序
- en: For both options, you can debug your code running on the local and remote endpoint
    by creating breakpoints in your code. In the next section, you’ll start working
    on our Hello World Anthos application with Cloud Code.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两种选项，您可以通过在代码中设置断点来调试在本地和远程端点运行的代码。在下一节中，您将开始使用 Cloud Code 开发我们的 Hello World
    Anthos 应用程序。
- en: Starting developing with Cloud Code
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Cloud Code 开始开发
- en: You can kick-start development of your application by using prebuilt templates
    for both Kubernetes and Knative (Cloud Run) applications. This includes both simple
    single-service applications and multiservice apps for a variety of languages.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用为 Kubernetes 和 Knative (Cloud Run) 应用程序预构建的模板来启动您应用程序的开发。这包括简单单服务应用程序和多种语言的复杂多服务应用程序。
- en: 'Let’s look how we can start developing with Cloud Code. This time we will be
    using Visual Studio Code to work on an example Python Hello World application
    using the following steps:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 Cloud Code 开始开发。这次我们将使用以下步骤在 Visual Studio Code 中工作一个示例 Python Hello
    World 应用程序：
- en: Start by installing the Cloud Code from the Visual Studio Code Marketplace.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先从 Visual Studio Code 市场安装 Cloud Code。
- en: Open Visual Studio Code.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio Code。
- en: Find and click </> Cloud Code on the bottom blue bar in the main window, shown
    in figure 12.9.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主窗口底部蓝色栏中找到并点击</> Cloud Code，如图 12.9 所示。
- en: '![12-09](../../OEBPS/Images/12-09.png)'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![12-09](../../OEBPS/Images/12-09.png)'
- en: 'Figure 12.9 Visual Studio Code: starting a new application'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 12.9 Visual Studio Code：启动新应用程序
- en: 'From the drop-down list that appears on the top of the screen, choose the New
    Application option, shown in figure 12.10*.* Note: This is also the starting point
    for other actions, such as the following:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从屏幕顶部的下拉列表中选择“新建应用程序”选项，如图 12.10*.* 注意：这也是以下其他操作的起点：
- en: Running the application on Kubernetes
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Kubernetes 上运行应用程序
- en: Debugging the application on Kubernetes
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Kubernetes 上调试应用程序
- en: Running the application on a Cloud Run emulator
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Cloud Run 模拟器上运行应用程序
- en: Debugging the application on a Cloud Run emulator
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Cloud Run 模拟器上调试应用程序
- en: Deploy the application to Cloud Run
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序部署到 Cloud Run
- en: '![12-10](../../OEBPS/Images/12-10.png)'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![12-10](../../OEBPS/Images/12-10.png)'
- en: Figure 12.10 Cloud Code New Application
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 12.10 Cloud Code 新应用程序
- en: Now choose Kubernetes Application, shown in figure 12.11.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在选择 Kubernetes 应用程序，如图 12.11 所示。
- en: '![12-11](../../OEBPS/Images/12-11.png)'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![12-11](../../OEBPS/Images/12-11.png)'
- en: Figure 12.11 Cloud Code Kubernetes Application
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 12.11 Cloud Code Kubernetes 应用程序
- en: For simplicity, we will use the Python (Flask) Hello World application, as shown
    in figure 12.12.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了简单起见，我们将使用如图 12.12 所示的 Python (Flask) Hello World 应用程序。
- en: '![12-12](../../OEBPS/Images/12-12.png)'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![12-12](../../OEBPS/Images/12-12.png)'
- en: 'Figure 12.12 Cloud Code Python (Flask): Hello World'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 12.12 Cloud Code Python (Flask)：Hello World
- en: Wait a couple of seconds for Cloud Code to pull the templates with all the files,
    including vscode configuration files, Kubernetes manifests, source code, and the
    Skaffold config file, as illustrated in figure 12.13.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待几秒钟，让Cloud Code拉取所有文件模板，包括vscode配置文件、Kubernetes清单、源代码和Skaffold配置文件，如图12.13所示。
- en: '![12-13](../../OEBPS/Images/12-13.png)'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![12-13](../../OEBPS/Images/12-13.png)'
- en: Figure 12.13 The Cloud Code skaffold.yaml
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.13 Cloud Code skaffold.yaml
- en: When all the files are ready, you can run the application by clicking *</> Cloud
    Code* again and choosing *Run on Kubernetes* from the drop-down menu, as shown
    in figure 12.14.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当所有文件准备就绪后，您可以通过再次点击*Cloud Code*并从下拉菜单中选择*在Kubernetes上运行*来运行应用程序，如图12.14所示。
- en: '![12-14](../../OEBPS/Images/12-14.png)'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![12-14](../../OEBPS/Images/12-14.png)'
- en: Figure 12.14 The Cloud Code option to run on Kubernetes
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.14 Cloud Code在Kubernetes上运行的选项
- en: Cloud Code will ask if you want to use the default context. In this case, it
    is pointing to minikube. Confirm with Yes or choose a different context to deploy
    to different clusters, as shown in figure 12.15.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Cloud Code会询问您是否想使用默认上下文。在这种情况下，它指向minikube。通过“是”确认或选择不同的上下文以部署到不同的集群，如图12.15所示。
- en: '![12-15](../../OEBPS/Images/12-15.png)'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![12-15](../../OEBPS/Images/12-15.png)'
- en: 'Figure 12.15 Cloud Code: setting the context to minikube'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.15 云代码：将上下文设置为minikube
- en: In the console, you should see the output shown in figure 12.16 with the URL
    to access the application.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中，您应该看到图12.16所示的输出，包括访问应用程序的URL。
- en: '![12-16](../../OEBPS/Images/12-16.png)'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![12-16](../../OEBPS/Images/12-16.png)'
- en: Figure 12.16 Cloud Code console output
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.16 云代码控制台输出
- en: If you go to the URL, you will see the application is running, as shown in figure
    12.17.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您访问URL，您将看到应用程序正在运行，如图12.17所示。
- en: '![12-17](../../OEBPS/Images/12-17.png)'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![12-17](../../OEBPS/Images/12-17.png)'
- en: Figure 12.17 Cloud Code application output
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.17 Cloud Code应用程序输出
- en: Now you can make a small change to the source code. In the app.py file, find
    the Hello World message, shown in figure 12.18.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您可以对源代码进行一些小的修改。在app.py文件中，找到图12.18所示的“Hello World”消息。
- en: '![12-18](../../OEBPS/Images/12-18.png)'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![12-18](../../OEBPS/Images/12-18.png)'
- en: 'Figure 12.18 Cloud Code: browse the app.yaml.'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.18 云代码：浏览app.yaml。
- en: Change the message to “Hello Anthos” and save the file, as shown in figure 12.19.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将消息更改为“Hello Anthos”并保存文件，如图12.19所示。
- en: '![12-19](../../OEBPS/Images/12-19.png)'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![12-19](../../OEBPS/Images/12-19.png)'
- en: 'Figure 12.19 Cloud Code: change the message to “Hello Anthos.”'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.19 云代码：将消息更改为“Hello Anthos。”
- en: You will notice, as shown in figure 12.20, that Cloud Code has detected the
    change and deployed the app to minikube.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会注意到，如图12.20所示，Cloud Code已检测到更改并将应用程序部署到minikube。
- en: '![12-20](../../OEBPS/Images/12-20.png)'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![12-20](../../OEBPS/Images/12-20.png)'
- en: 'Figure 12.20 Cloud Code: code change detection'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.20 Cloud Code：代码更改检测
- en: Now when we access the application, we see a new message, shown in figure 12.21.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们访问应用程序时，会看到一个新消息，如图12.21所示。
- en: '![12-21](../../OEBPS/Images/12-21.png)'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![12-21](../../OEBPS/Images/12-21.png)'
- en: 'Figure 12.21 Cloud Code: application output'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.21 云代码：应用程序输出
- en: Any changes in the source code will be picked up automatically. Note that you
    can pause or stop the application using the control bar, shown in figure 12.22,
    on the top of the screen.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 任何对源代码的更改都将自动检测。请注意，您可以使用屏幕顶部的控制栏暂停或停止应用程序，如图12.22所示。
- en: '![12-22](../../OEBPS/Images/12-22.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![12-22](../../OEBPS/Images/12-22.png)'
- en: 'Figure 12.22 Cloud Code: continuous development menu'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.22 Cloud Code：持续开发菜单
- en: You have successfully created a preview of the Kubernetes Hello World application.
    Now you can try more complex application examples.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 您已成功创建了Kubernetes Hello World应用程序的预览。现在您可以尝试更复杂的应用程序示例。
- en: As you have seen in the drop-down menu in step 4, you can also create and deploy
    applications to Cloud Run. You can also debug your applications by putting break
    points in your source code. Follow the how-to guide to see a step-by-step tutorial
    on how to do it at [http://mng.bz/0yex](http://mng.bz/0yex).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在步骤4中的下拉菜单中看到的，您还可以创建和部署应用程序到Cloud Run。您还可以通过在源代码中设置断点来调试您的应用程序。遵循如何指南，查看如何一步步操作的详细教程，请访问[http://mng.bz/0yex](http://mng.bz/0yex)。
- en: Summary of Cloud Code
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Code总结
- en: Cloud Code is a tool that not only seamlessly integrates with GCP but also makes
    the development, containerization, and preview of your Anthos application easy.
    It bundles the already discussed Skaffold functionality into your IDE to automate
    continuous development workflows.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Code是一个工具，它不仅无缝集成到GCP，还使您的Anthos应用程序的开发、容器化和预览变得简单。它将之前讨论过的Skaffold功能捆绑到您的IDE中，以自动化持续开发工作流程。
- en: Previewing Kubernetes applications requires a number of steps, like building
    a container image and deploying it to the preview environment every time you make
    changes to the code. With Cloud Code, you can concentrate on your source code
    and let the Cloud Code integrations take care of all those steps. In this section,
    we have used already existing templates to show you what the setup looks like.
    You can take it from there and start developing your own Anthos applications,
    and Cloud Code will make sure the preview will be updated for you.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 预览Kubernetes应用程序需要执行多个步骤，例如每次您对代码进行更改时，都需要构建容器镜像并将其部署到预览环境。使用Cloud Code，您可以专注于源代码，让Cloud
    Code集成处理所有这些步骤。在本节中，我们使用了现有的模板来展示设置的样子。您可以从那里开始开发自己的Anthos应用程序，Cloud Code将确保预览为您更新。
- en: '12.3.4 Anthos Developer Sandbox: Development with a cloud native IDE'
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.4 Anthos开发者沙盒：使用云原生IDE进行开发
- en: 'Anthos Developer Sandbox is a free tool for developers that gives you the feeling
    of what it looks like to develop on Anthos. It allows performing the same tasks
    described in the previous section but using Google Cloud Shell instead of locally.
    It is built of the following components:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Anthos开发者沙盒是开发者免费工具，让您体验在Anthos上开发的感觉。它允许执行上一节中描述的相同任务，但使用Google Cloud Shell而不是本地。它由以下组件组成：
- en: '*Cloud Shell* —A computing environment with the best of Google Cloud Platform
    tooling preinstalled'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*云壳* —一个预装了Google Cloud Platform最佳工具的计算环境'
- en: '*Cloud Code*—The IDE plug-in, which we’ve already seen'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*云代码*—我们之前见过的IDE插件'
- en: '*Minikube*—A single-node Kubernetes cluster, which we’ve already discussed'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Minikube*—一个单节点Kubernetes集群，我们之前已经讨论过'
- en: '*Cloud Build Local Builder*—Runs continuous integration locally in the Cloud
    Shell'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*云构建本地构建器*—在云壳中本地运行持续集成'
- en: 'You don’t need to perform any up-front configuration to use Anthos Developer
    Sandbox. You can access it from [http://mng.bz/KlrK](http://mng.bz/KlrK) and start
    developing your first Anthos application. The most important thing is that it
    is available for free for anyone with a Google account. With Anthos Developer
    Sandbox, you can perform the following day-to-day development tasks:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要进行任何前置配置即可使用Anthos开发者沙盒。您可以通过[http://mng.bz/KlrK](http://mng.bz/KlrK)访问它并开始开发您的第一个Anthos应用程序。最重要的是，它对任何拥有Google账户的人免费提供。使用Anthos开发者沙盒，您可以执行以下日常开发任务：
- en: Run applications locally on an emulated Anthos cluster or Cloud Run emulator
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模拟的Anthos集群或Cloud Run模拟器上本地运行应用程序
- en: Use Cloud Build for testing locally
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用云构建进行本地测试
- en: Iterate on your application with automated live updates as you develop
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发过程中迭代您的应用程序，并自动进行实时更新
- en: Use buildpacks to create your images
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用构建包创建您的镜像
- en: If you just started developing Anthos applications, using Sandbox will help
    you to kick-start your development journey because it comes with tutorials that
    are accessible directly from the interface.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您刚开始开发Anthos应用程序，使用沙盒可以帮助您启动开发之旅，因为它提供了可以直接从界面访问的教程。
- en: Starting with Anthos Developer Sandbox
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 从Anthos开发者沙盒开始
- en: 'Let’s have a quick look at the tool using the next steps:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速查看该工具的下一步操作：
- en: Access the tool by opening the link we mentioned earlier in the browser. You
    will be informed that the Anthos Developer Sandbox will be cloned, as shown in
    figure 12.23.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在浏览器中打开我们之前提到的链接来访问工具。您将被告知Anthos开发者沙盒将被克隆，如图12.23所示。
- en: '![12-23](../../OEBPS/Images/12-23.png)'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![12-23](../../OEBPS/Images/12-23.png)'
- en: 'Figure 12.23 Anthos Developer Sandbox: Welcome screen'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.23 Anthos开发者沙盒：欢迎屏幕
- en: Click Confirm and wait for the environment to be set up. You can see all the
    components being configured for you, as shown in figure 12.24.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击确认并等待环境设置完成。您可以看到为您配置的所有组件，如图12.24所示。
- en: '![12-24](../../OEBPS/Images/12-24.png)'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![12-24](../../OEBPS/Images/12-24.png)'
- en: 'Figure 12.24 Anthos Developer Sandbox: preparation of the environment'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.24 Anthos开发者沙盒：环境准备
- en: Once it is finished, you should see the IDE loaded and the workspace ready with
    the cloned repo, as shown in figure 12.25\. In the right pane, you can see the
    tutorial.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成，您应该会看到 IDE 已加载，工作区已准备好，并克隆了仓库，如图 12.25 所示。在右侧面板中，您可以查看教程。
- en: '![12-25](../../OEBPS/Images/12-25.png)'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![12-25](../../OEBPS/Images/12-25.png)'
- en: 'Figure 12.25 Anthos Developer Sandbox: main screen'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 12.25 Anthos 开发者沙盒：主屏幕
- en: Click Start to begin the tutorial. It will walk you through the same flow we
    had with Cloud Code.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“开始”以开始教程。它将引导您完成与 Cloud Code 相同的流程。
- en: As you have seen, you can start continuous development on Anthos with a few
    clicks and no special configuration.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，您只需点击几下即可在 Anthos 上开始持续开发，无需特殊配置。
- en: 12.4 Continuous integration
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.4 持续集成
- en: 'In this section, we will look at continuous integration. We will first walk
    through the GCP native tools and then see what the third-party alternatives are.
    To introduce continuous integration for your Anthos application, you will need
    the following components:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨持续集成。我们将首先介绍 GCP 原生工具，然后查看第三方替代方案。为了为您的 Anthos 应用程序引入持续集成，您需要以下组件：
- en: Git source repository
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git 源代码仓库
- en: Container registry
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器注册库
- en: CI server
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CI 服务器
- en: Let’s start by creating a Git repository that will store and version the Anthos
    application code.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个 Git 仓库，用于存储和版本控制 Anthos 应用程序代码。
- en: 12.4.1 Cloud Source Repositories
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4.1 Cloud Source Repositories
- en: Cloud Source Repositories ([https://cloud.google.com/source-repositories](https://cloud.google.com/source-repositories))
    are fully featured, private Git repositories hosted on Google Cloud. The service
    helps developers to privately host, track, and manage changes to large codebases
    on Google Cloud Platform. It’s designed to integrate easily with GCP services
    like Anthos, GKE, Cloud Run, App Engine, and Cloud Functions, as shown in figure
    12.26\. You can configure an unlimited number of repositories and also mirror
    Bitbucket and GitHub repositories. Changes in Cloud Source Repositories are monitored
    and can trigger event notifications to Cloud Pub/Sub or a Cloud Function. One
    of the differentiators of Code Source Repositories is that you can use regex expression
    to search for phrases in your repository ([http://mng.bz/91jl](http://mng.bz/91jl)).
    Cloud Source Repository audit logs are available in Cloud Operations, so you always
    know who has accessed your repository, and when.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Source Repositories ([https://cloud.google.com/source-repositories](https://cloud.google.com/source-repositories))
    是功能齐全的私有 Git 仓库，托管在 Google Cloud 上。该服务帮助开发者私下托管、跟踪和管理 Google Cloud Platform 上大型代码库的更改。它旨在轻松集成
    GCP 服务，如 Anthos、GKE、Cloud Run、App Engine 和 Cloud Functions，如图 12.26 所示。您可以配置无限数量的仓库，还可以镜像
    Bitbucket 和 GitHub 仓库。Cloud Source Repositories 中的更改会受到监控，并可以触发事件通知到 Cloud Pub/Sub
    或 Cloud Function。Code Source Repositories 的一个不同之处在于，您可以使用正则表达式在您的仓库中搜索短语 ([http://mng.bz/91jl](http://mng.bz/91jl))。Cloud
    Source Repository 的审计日志可在 Cloud Operations 中查看，因此您始终知道谁访问了您的仓库，以及何时访问。
- en: '![12-26](../../OEBPS/Images/12-26.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![12-26](../../OEBPS/Images/12-26.png)'
- en: Figure 12.26 Cloud Source Repositories integrations
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.26 Cloud Source Repositories 集成
- en: As you see in figure 12.26, the integration for Cloud Run is particularly interesting.
    You can use a combination of Cloud Source Repositories and Cloud Build to create
    a CD pipeline to trigger an automated deploy pipeline of your application whenever
    there is code merge in your code repository. Cloud Run makes the operations more
    streamlined by taking care of your traffic shaping (blue/green, canary, rolling
    updates) based on your configuration under the hood. Refer to chapter 9 for details
    on how to configure it.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在图 12.26 中所见，Cloud Run 的集成特别有趣。您可以使用 Cloud Source Repositories 和 Cloud Build
    的组合来创建 CD 流水线，以便在您的代码仓库中发生代码合并时自动触发应用程序的部署流水线。Cloud Run 通过在幕后处理您的流量整形（蓝绿、金丝雀、滚动更新）来使操作更加流畅。有关如何配置的详细信息，请参阅第
    9 章。
- en: Creating a repository
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 创建仓库
- en: 'To start working with Cloud Source Repositories, you first need to create the
    repository by running the following command:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 Cloud Source Repositories，您首先需要通过运行以下命令来创建仓库：
- en: '[PRE14]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The next snippet will initialize your gcloud command-line tool:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个片段将初始化您的 gcloud 命令行工具：
- en: '[PRE15]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This will create a repository of the name REPO_NAME.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为 REPO_NAME 的仓库。
- en: 'Now that the repository is ready to use, you need to choose one of the following
    three authentication methods:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在仓库已经准备好使用，您需要选择以下三种认证方法之一：
- en: SSH
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSH
- en: Cloud SDK
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cloud SDK
- en: Manually generated credentials
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动生成的凭证
- en: 'Refer to the following link to see a step-by-step guide on how to do it: [http://mng.bz/jmWx](http://mng.bz/jmWx).'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何操作的逐步指南，请参阅以下链接：[http://mng.bz/jmWx](http://mng.bz/jmWx)。
- en: Once the repository is set up and you have successfully authenticated, you can
    interact with it using Git commands like git clone, git pull, and git push.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置好存储库并成功认证，您就可以使用 git clone、git pull 和 git push 等 Git 命令与之交互。
- en: 12.4.2 Artifact Registry
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4.2 艺术品注册库
- en: Artifact Registry is the next iteration of the Google Container Registry service.
    On top of being able to store container images, Artifact Registry can store other
    packages like Maven ([https://maven.apache.org/](https://maven.apache.org/)),
    npm ([https://www.npmjs.com/](https://www.npmjs.com/)), and Python, with more
    capabilities to come soon. The services are fully integrated with the Google Cloud
    Platform ecosystem, so you can control access to your artifacts using IAM policies,
    access Cloud Source Repositories, trigger automatic builds using Cloud Build,
    and deploy to Google Kubernetes Engine, App Engine, and Cloud Functions. You can
    create Artifact Repositories in regions closest to your workloads so you can take
    advantage of the high-speed Google network to pull your artifacts.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 艺术品注册库是 Google 容器注册库服务的下一代迭代。除了能够存储容器镜像之外，艺术品注册库还可以存储其他包，如 Maven ([https://maven.apache.org/](https://maven.apache.org/))、npm
    ([https://www.npmjs.com/](https://www.npmjs.com/)) 和 Python，未来还将提供更多功能。这些服务完全集成在
    Google Cloud Platform 生态系统之中，因此您可以使用 IAM 策略控制对您的艺术品的访问，访问 Cloud Source Repositories，使用
    Cloud Build 触发自动构建，并将应用程序部署到 Google Kubernetes Engine、App Engine 和 Cloud Functions。您可以在离您的作业负载最近的地域创建艺术品存储库，以便利用高速的
    Google 网络来拉取您的艺术品。
- en: From a security standpoint, you can scan your containers for vulnerabilities,
    and Binary Authorization can be used to approve the images that can be pushed
    to production. You can use native tools to interact with Artifact Registry so
    it is easy to integrate them into CI/CD pipelines.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度来看，您可以扫描容器以查找漏洞，并可以使用二进制授权来批准可以推送到生产的镜像。您可以使用原生工具与艺术品注册库交互，因此它们很容易集成到 CI/CD
    管道中。
- en: Using Artifact Registry with Docker
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker 与艺术品注册库
- en: 'Let’s see how you can interact with the Artifact Registry to store container
    images, using the next procedure:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看您如何使用以下程序与艺术品注册库交互以存储容器镜像：
- en: 'Start by creating an artifact repository:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个艺术品存储库：
- en: '[PRE16]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can list your repositories by running the next command:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令列出您的存储库：
- en: '[PRE17]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Before pushing images, you should authenticate to the repository:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在推送镜像之前，您应该对存储库进行认证：
- en: '[PRE18]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, for demo purposes, just pull the official alpine image from Docker Hub
    instead of building a new image:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，出于演示目的，只需从 Docker Hub 拉取官方的 alpine 镜像，而不是构建一个新的镜像：
- en: '[PRE19]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Tag the image with the repository name:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用存储库名称标记镜像：
- en: '[PRE20]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can finally push the image to the Artifact Registry:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您最终可以将镜像推送到艺术品注册库：
- en: '[PRE21]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now you are ready to pull your container images from the registry.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经准备好从注册库中拉取您的容器镜像。
- en: Summary of Artifact Registry
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 艺术品注册库总结
- en: 'At the time of writing, the Artifact Registry is generally available, though
    some of the features might be in preview. As a successor of Container Registry,
    it will eventually be the only container registry available in GCP, so all your
    new projects should be already using Artifact Registry. The step-by-step tutorial
    on how to transition to Artifact Registry for existing projects can be found here:
    [http://mng.bz/WAn0](http://mng.bz/WAn0).'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，艺术品注册库已普遍可用，尽管一些功能可能处于预览状态。作为容器注册库的后继者，它最终将成为 GCP 中唯一的容器注册库，因此您所有的新项目都应该已经使用艺术品注册库。有关如何将现有项目过渡到艺术品注册库的逐步教程，请在此处找到：[http://mng.bz/WAn0](http://mng.bz/WAn0)。
- en: 12.4.3 Cloud Build
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4.3 Cloud Build
- en: We have already seen how we can version the Anthos application code and build
    container images. Now let’s look at how we can create a CI pipeline.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何对 Anthos 应用程序代码进行版本控制和构建容器镜像。现在让我们看看如何创建 CI 管道。
- en: Cloud Build is a managed, GCP-native CI/CD platform and is an alternative for
    tools like GitLab CI/CD, Jenkins, or CircleCI. It allows you to deploy, test,
    and build your application on all Google compute services including Anthos GKE
    and Cloud Run for Anthos. The Cloud Build pipeline steps are run as containers,
    as shown in figure 12.27.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Build 是一个托管、GCP 原生的 CI/CD 平台，是 GitLab CI/CD、Jenkins 或 CircleCI 等工具的替代品。它允许您在包括
    Anthos GKE 和 Cloud Run for Anthos 在内的所有 Google 计算服务上部署、测试和构建您的应用程序。Cloud Build
    的管道步骤作为容器运行，如图 12.27 所示。
- en: '![12-27](../../OEBPS/Images/12-27.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![12-27](../../OEBPS/Images/12-27.png)'
- en: Figure 12.27 Cloud Build steps run as containers.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.27 Cloud Build 步骤作为容器运行。
- en: The pipeline steps are defined in a simple-to-understand cloudbuild.yaml file
    presented here. These steps are read by Cloud Build and executed. Each step defines
    a container to run as a task. The containers used in pipelines are specially built
    for Cloud Build and are called *cloud builders*. We will learn more about them
    in the following section.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 管道步骤在下面提供的简单易懂的 cloudbuild.yaml 文件中定义。这些步骤由 Cloud Build 读取并执行。每个步骤定义了一个作为任务运行的容器。管道中使用的容器是专门为
    Cloud Build 构建的，被称为 *云构建器*。我们将在下一节中了解更多关于它们的信息。
- en: '[PRE22]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Cloud Build is completely serverless and can scale up and down based on the
    load. You pay only for the execution time. It does not require you to install
    any plug-ins and can support a variety of tools with custom cloud builders. Because
    it is connected to the GCP network, it can significantly reduce build and deployment
    time via direct access to repositories, registries, and workloads. You can also
    combine Cloud Build with tools like Spinnaker ([https://spinnaker.io/](https://spinnaker.io/))
    to execute even more complex pipelines that include various deployment scenarios.
    Cloud Build pipelines can be triggered either manually or by code repository pull
    requests.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Build 完全无服务器，可以根据负载进行扩展和缩减。您只需为执行时间付费。它不需要您安装任何插件，并且可以支持各种工具，包括自定义云构建器。因为它连接到
    GCP 网络，可以通过直接访问存储库、注册库和工作负载来显著减少构建和部署时间。您还可以将 Cloud Build 与 Spinnaker ([https://spinnaker.io/](https://spinnaker.io/))
    等工具结合使用，以执行更复杂的管道，包括各种部署场景。Cloud Build 管道可以通过手动或通过代码存储库的拉取请求来触发。
- en: Now that we understand the basis of how Cloud Build works, let’s look at cloud
    builders.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Cloud Build 的工作基础，让我们来看看云构建器。
- en: Cloud builders
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud 构建器
- en: 'As we have already learned, Cloud Build runs a series of steps defined in the
    cloudbuild.yaml file that are executed within containers. The containers are deployed
    using container images defined in the name attribute of each step. Those container
    images are called cloud builders, which are specially packaged images that run
    a specific tool like *Docker, Git, or kubect*l with a set of user-defined attributes.
    Three types of builders follow:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经学到的，Cloud Build 在容器中运行一系列在 cloudbuild.yaml 文件中定义的步骤，这些步骤在容器内执行。这些容器使用每个步骤名称属性中定义的容器镜像进行部署。这些容器镜像被称为云构建器，它们是特别打包的镜像，运行特定的工具，如
    *Docker、Git 或 kubect*，并附带一系列用户定义的属性。以下列出了三种类型的构建器：
- en: Google-supported builders
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google支持的构建器
- en: Community-supported builders
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社区支持的构建器
- en: Custom-developed builders
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义开发的构建器
- en: Let’s look at each type.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每种类型。
- en: Google-supported builders
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Google支持的构建器
- en: 'You can find a full list of Google-supported builders on GitHub at [http://mng.bz/819P](http://mng.bz/819P).
    All the images are available in a container registry under gcr.io/cloud-builders/
    <builder name>. Some of the most important builders in the context of Anthos follow:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到完整的 Google 支持的构建器列表，网址为 [http://mng.bz/819P](http://mng.bz/819P)。所有镜像都可在
    gcr.io/cloud-builders/ <构建器名称> 下的容器注册库中找到。以下是在 Anthos 上下文中一些最重要的构建器：
- en: docker
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: docker
- en: git
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: git
- en: gcloud
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gcloud
- en: gke-deploy
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gke-deploy
- en: kubectl
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kubectl
- en: Community-supported builders
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 社区支持的构建器
- en: 'If no official builder exists that fits your requirements, you can use one
    of the community builders, which are available with tools like Helm, Packer, Skaffold,
    Terraform, and Vault. The complete list of the community cloud builders can be
    found here: [http://mng.bz/ElrJ](http://mng.bz/ElrJ).'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有官方构建器符合您的需求，您可以使用社区构建器之一，这些构建器与 Helm、Packer、Skaffold、Terraform 和 Vault 等工具一起提供。社区云构建器的完整列表可以在此找到：[http://mng.bz/ElrJ](http://mng.bz/ElrJ)。
- en: Custom-developed builders
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义开发的构建器
- en: You can create your own custom builder for use in your builds. A custom builder
    is a container image that Cloud Build pulls and runs with your source. Your custom
    builder can execute any script or binary inside the container. As such, it can
    do anything a container can do. For instructions on creating a custom builder,
    see [http://mng.bz/NmrD](http://mng.bz/NmrD).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建自己的自定义构建器以用于构建。自定义构建器是 Cloud Build 拉取并运行与您的源代码一起的容器镜像。您的自定义构建器可以在容器内执行任何脚本或二进制文件。因此，它可以做任何容器能做的事情。有关创建自定义构建器的说明，请参阅
    [http://mng.bz/NmrD](http://mng.bz/NmrD)。
- en: Building container images
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 构建容器镜像
- en: You can build containers with Cloud Build either using config files or by using
    Dockerfile only. Let’s look at each of the options.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 Cloud Build 通过配置文件或仅使用 Dockerfile 来构建容器。让我们看看每个选项。
- en: Building container images using a configuration file
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 使用配置文件构建容器镜像
- en: The first method of building the container requires you to provide the cloudbuild.yaml
    config file as an input, as shown in figure 12.28.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 构建容器的第一种方法需要您提供cloudbuild.yaml配置文件作为输入，如图12.28所示。
- en: '![12-28](../../OEBPS/Images/12-28.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![12-28](../../OEBPS/Images/12-28.png)'
- en: Figure 12.28 Building container images with Cloud Build config files
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.28 使用Cloud Build配置文件构建容器镜像
- en: 'To build your image from the configuration file, you need to specify the build
    steps in the cloudbuild.yaml file using the Docker cloud builder as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 要从配置文件构建您的镜像，您需要使用以下方式在cloudbuild.yaml文件中指定构建步骤，使用Docker cloud builder：
- en: '[PRE23]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, run the following command to submit the build:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行以下命令提交构建：
- en: '[PRE24]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This builds the image and stores it in Google Artifact Registry as indicated
    in the configuration file. If you don’t specify the [CONFIG_FILE_PATH] and [SOURCE_DIRECTORY]
    parameters, the current directory will be used.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这将构建镜像并将其存储在Google Artifact Registry中，如配置文件中所示。如果您没有指定[CONFIG_FILE_PATH]和[SOURCE_DIRECTORY]参数，将使用当前目录。
- en: Using a Dockerfile to build a container image
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Dockerfile构建容器镜像
- en: You can create container images without using the configuration file because
    your Dockerfile contains all information needed to build a Docker image using
    Cloud Build, as shown in figure 12.29.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以不使用配置文件创建容器镜像，因为您的Dockerfile包含使用Cloud Build构建Docker镜像所需的所有信息，如图12.29所示。
- en: '![12-29](../../OEBPS/Images/12-29.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![12-29](../../OEBPS/Images/12-29.png)'
- en: Figure 12.29 Building an image from a Dockerfile
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.29 从Dockerfile构建镜像
- en: 'To run a build request using your Dockerfile, run the following command from
    the directory containing your application code, Dockerfile, and any other assets:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您的Dockerfile运行构建请求，请从包含您的应用程序代码、Dockerfile以及任何其他资源的目录中运行以下命令：
- en: '[PRE25]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This builds the image and stores it in Google Artifact Registry.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这将构建镜像并将其存储在Google Artifact Registry中。
- en: Cloud Build notifications
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Build通知
- en: You have multiple ways of getting notifications from Cloud Build. You can get
    notified about any changes in the build state, including start, transition, and
    completion of the build.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 您有多种方式从Cloud Build获取通知。您可以收到有关构建状态任何变化的提醒，包括构建的开始、转换和完成。
- en: Cloud Build is well integrated with Pub/Sub and publishes messages to Pub/Sub
    topics. Both push and pull subscription models are supported. Having the message
    in the Pub/Sub queue gives you endless options for sending the notifications to
    the next step.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Build与Pub/Sub集成良好，并将消息发布到Pub/Sub主题。支持推送和拉取订阅模型。在Pub/Sub队列中有消息为您提供了将通知发送到下一步的无限选项。
- en: 'In addition to Pub/Sub, you can also get notifications from Cloud Build using
    one of the following notifications channels:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Pub/Sub之外，您还可以通过以下通知通道之一从Cloud Build获取通知：
- en: '*Slack*—Posts notifications to a Slack channel'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Slack*—将通知发布到Slack频道'
- en: '*SMTP* —Emails notifications via SMTP protocol'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SMTP* —通过SMTP协议发送通知'
- en: '*HTTP* —Sends notifications in JSON format to an HTTP endpoint'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*HTTP* —以JSON格式向HTTP端点发送通知'
- en: All three types of notifications use containers running as a Cloud Run service.
    An example of how to create such notifications can be found at [http://mng.bz/DZrE](http://mng.bz/DZrE).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三种类型的通知都使用作为Cloud Run服务运行的容器。如何创建此类通知的示例可以在[http://mng.bz/DZrE](http://mng.bz/DZrE)找到。
- en: Deploying to Anthos Google Kubernetes Engine
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 部署到Anthos Google Kubernetes Engine
- en: Deployment to Google Kubernetes Engine can be done using either kubectl or the
    gke-deploy builder. Note that gke-deploy ([https://github.com/GoogleCloudPlatform/cloud-builders/tree/master/gke-deploy](https://github.com/GoogleCloudPlatform/cloud-builders/tree/master/gke-deploy))
    is basically a wrapper around kubectl that incorporates Google best practices
    to deploy Kubernetes resources. For example, it adds the label app.kubernetes.io/name
    to the deployed Kubernetes resources.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 使用kubectl或gke-deploy构建器将部署到Google Kubernetes Engine可以完成。请注意，gke-deploy([https://github.com/GoogleCloudPlatform/cloud-builders/tree/master/gke-deploy](https://github.com/GoogleCloudPlatform/cloud-builders/tree/master/gke-deploy))基本上是kubectl的一个包装器，它结合了Google的最佳实践来部署Kubernetes资源。例如，它将标签app.kubernetes.io/name添加到部署的Kubernetes资源中。
- en: 'Next, you can see an example use of the gke-deploy builder to deploy to a GKE
    cluster:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您可以看到使用gke-deploy构建器部署到GKE集群的示例：
- en: '[PRE26]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the future, we can expect other cloud builders like AnthosCLI that will make
    the experience even more unified.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来，我们可以期待其他云构建器，如AnthosCLI，这将使体验更加统一。
- en: Deploying to Cloud Run and Cloud Run for Anthos
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 部署到Cloud Run和Cloud Run for Anthos
- en: 'Cloud Build allows you to build your Cloud Run container image and then deploy
    it to either Cloud Run or Cloud Run for Anthos. In both cases, you would first
    build and push the image using a standard Docker builder:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Build 允许您构建 Cloud Run 容器镜像，然后将其部署到 Cloud Run 或 Cloud Run for Anthos。在两种情况下，您首先使用标准的
    Docker 构建器构建和推送镜像：
- en: '[PRE27]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then use the cloud-sdk builder to run the gcloud run command. For Cloud Run,
    set the --platform flag to ‘managed’:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用 cloud-sdk 构建器运行 gcloud run 命令。对于 Cloud Run，将 --platform 标志设置为 ‘managed’：
- en: '[PRE28]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For Cloud Run for Anthos, set the --platform flag to ‘gke’ and indicate which
    cluster to deploy to by setting the --cluster and --cluster-location flags:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Cloud Run for Anthos，将 --platform 标志设置为 ‘gke’，并通过设置 --cluster 和 --cluster-location
    标志来指定要部署到的集群：
- en: '[PRE29]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Deploying to Anthos using the Connect gateway with Cloud Build
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Cloud Build 和 Connect 网关将应用程序部署到 Anthos
- en: The Connect gateway, shown in figure 12.30, allows users to connect to registered
    clusters outside Google Cloud with their Google Cloud identity in the Cloud console.
    You don’t need to have direct connectivity from the Cloud Build to the Anthos
    cluster API. Anthos Hub acts as a proxy for the kubectl command run in the cloud
    builder.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 12.30 所示的 Connect 网关允许用户使用 Cloud Console 中的 Google Cloud 身份连接到 Google Cloud
    外部的已注册集群。您不需要从 Cloud Build 直接连接到 Anthos 集群 API。Anthos Hub 作为在云构建器中运行的 kubectl
    命令的代理。
- en: '![12-30](../../OEBPS/Images/12-30.png)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![12-30](../../OEBPS/Images/12-30.png)'
- en: Figure 12.30 Connect gateway
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.30 Connect 网关
- en: To configure the Connect gateway and connect your Anthos cluster, follow the
    steps described in the Google documentation at [http://mng.bz/lJ5y](http://mng.bz/lJ5y).
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置 Connect 网关并连接您的 Anthos 集群，请按照 Google 文档中描述的步骤操作，文档链接为 [http://mng.bz/lJ5y](http://mng.bz/lJ5y)。
- en: 'Once the Connect gateway is configured and the Anthos servers are registered,
    check whether they are visible in the fleet by running the following:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置了 Connect 网关并将 Anthos 服务器注册，请运行以下命令以检查它们是否在集群中可见：
- en: '[PRE30]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this case, we see two clusters are registered—one is a GKE on VMware, and
    the other is a GCP GKE cluster:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们看到已注册了两个集群——一个是运行在 VMware 上的 GKE，另一个是 GCP GKE 集群：
- en: '[PRE31]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let’s define the following step to deploy an application defined in the myapp.yaml
    manifest:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义以下步骤以部署 myapp.yaml 清单中定义的应用程序：
- en: '[PRE32]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As we see, in this case, the gateway kubeconfig is used rather than the cluster
    kubeconfig itself. The request will be sent to the gateway, and then the gateway
    will forward it to the my-vmware-cluster. This means that no hybrid connectivity
    like Cloud VPN or Interconnect is required to deploy your Anthos cluster outside
    of GCP.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在这种情况下，使用了网关 kubeconfig 而不是集群 kubeconfig 本身。请求将被发送到网关，然后网关将其转发到 my-vmware-cluster。这意味着在
    GCP 之外部署您的 Anthos 集群不需要混合连接，如 Cloud VPN 或 Interconnect。
- en: Triggering Cloud Build
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 触发 Cloud Build
- en: 'In the previous section, we learned how to deploy the application to any Anthos
    clusters. Now let’s look at how we can trigger a Cloud Build pipeline by using
    either the gcloud command (which we have already looked at in the previous section)
    or automatic triggers. With Cloud Build, you can use the following three types
    of repositories:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何将应用程序部署到任何 Anthos 集群。现在让我们看看如何通过使用 gcloud 命令（我们已经在上一节中查看过）或自动触发器来触发
    Cloud Build 管道。使用 Cloud Build，您可以使用以下三种类型的存储库：
- en: Cloud Source Repositories
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cloud Source Repositories
- en: GitHub
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub
- en: Bitbucket
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bitbucket
- en: 'To create a trigger, you can use both the Google Cloud console and the command
    line. First, add the repository to Cloud Build:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建触发器，您可以使用 Google Cloud Console 和命令行。首先，将存储库添加到 Cloud Build：
- en: '[PRE33]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, add the trigger:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加触发器：
- en: '[PRE34]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: With the --branch-pattern, you can specify which branch will trigger the build.
    In this case, it will be all branches.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 --branch-pattern，您可以指定哪个分支将触发构建。在这种情况下，将触发所有分支。
- en: If you would like know how to create triggers from the other repositories, consult
    the documentation at [http://mng.bz/BlrJ](http://mng.bz/BlrJ).
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解如何从其他存储库创建触发器，请参阅 [http://mng.bz/BlrJ](http://mng.bz/BlrJ) 的文档。
- en: Summary of Cloud Build
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Build 概述
- en: 'Cloud Build, though simple to use, can provide an E2E CI/CD experience for
    delivering your Anthos applications, as shown in figure 12.31\. If you want to
    get more hands-on experience with E2E pipelines, we encourage you to follow a
    tutorial at your own pace: [http://mng.bz/dJGQ](http://mng.bz/dJGQ). In this tutorial,
    you will develop a pipeline that will support the following:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Cloud Build 使用简单，但它可以提供端到端 CI/CD 体验，以交付您的 Anthos 应用程序，如图 12.31 所示。如果您想获得更多关于端到端管道的实践经验，我们鼓励您按照自己的节奏遵循教程：[http://mng.bz/dJGQ](http://mng.bz/dJGQ)。在这个教程中，您将开发一个支持以下内容的管道：
- en: Test of the committed code
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交代码的测试
- en: Build container image
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建容器镜像
- en: Push image to the registry
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将镜像推送到注册表
- en: Update the Kubernetes manifest and push it to the environment repository
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新 Kubernetes 清单并将其推送到环境仓库
- en: Detect changes on the branch
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测分支上的更改
- en: Apply the manifest to an Anthos GKE cluster
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将清单应用到 Anthos GKE 集群
- en: Update the production branch with the Kubernetes manifest applied
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用了 Kubernetes 清单的生产分支更新
- en: '![12-31](../../OEBPS/Images/12-31.png)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![12-31](../../OEBPS/Images/12-31.png)'
- en: Figure 12.31 Steps in the CI/CD pipeline based on Cloud Build
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.31 基于 Cloud Build 的 CI/CD 管道步骤
- en: This tutorial will give you a good idea of how to perform advanced tasks with
    Cloud Build. Note that you can deliver the same result with third-party tools
    like GitHub, GitLab, or Bitbucket, but Cloud Build is a native GCP tool that integrates
    nicely with Anthos.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程将给您一个如何使用 Cloud Build 执行高级任务的清晰思路。请注意，您可以使用 GitHub、GitLab 或 Bitbucket 等第三方工具获得相同的结果，但
    Cloud Build 是一个本地的 GCP 工具，它与 Anthos 集成得很好。
- en: 12.4.4 Kustomize for generating environment-specific configuration
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4.4 使用 Kustomize 生成特定环境的配置
- en: In real-life scenarios, you will deploy your application to multiple environments.
    In the CI/CD pipeline, you need a tool that will adjust the configuration of your
    app for each environment without changing the actual code base.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实场景中，您将应用程序部署到多个环境中。在 CI/CD 管道中，您需要一个工具来调整应用程序的配置，以便为每个环境进行配置，而无需更改实际的代码库。
- en: Kustomize is a standalone tool to customize Kubernetes resources by using a
    kustomization.yaml file. The good news is that since version 1.14 of Kubernetes,
    Kustomize has been merged into the kubectl tool, as shown in figure 12.32.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: Kustomize 是一个独立的工具，通过使用 kustomization.yaml 文件来自定义 Kubernetes 资源。好消息是，自从 Kubernetes
    1.14 版本以来，Kustomize 已被合并到 kubectl 工具中，如图 12.32 所示。
- en: '![12-32](../../OEBPS/Images/12-32.png)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![12-32](../../OEBPS/Images/12-32.png)'
- en: Figure 12.32 Customizing a Kubernetes manifest
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.32 自定义 Kubernetes 清单
- en: As we see in figure 12.32, the basic manifest is patched and applied to each
    of the environments.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在图 12.32 中看到的那样，基本清单被修补并应用到每个环境中。
- en: 'In figure 12.33, we see the following three files residing in a single folder:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.33，我们看到以下三个文件位于同一个文件夹中：
- en: '*Definition of the Deployment*—deployment.yaml'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*部署定义*—deployment.yaml'
- en: '*Kustomize file*—kustomization.yaml'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Kustomize 文件*—kustomization.yaml'
- en: '*Patch file*—patch.yaml, which defines which attributes should be changed in
    the Deployment'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*修补文件*—patch.yaml，它定义了在 Deployment 中应更改哪些属性'
- en: '![12-33](../../OEBPS/Images/12-33.png)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![12-33](../../OEBPS/Images/12-33.png)'
- en: Figure 12.33 Patching deployment images with Kustomize
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.33 使用 Kustomize 修补部署镜像
- en: 'To perform the customization, run the next command:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行自定义，运行以下命令：
- en: '[PRE35]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As a result, the output has the spec.template.containers.image attribute updated.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，输出已更新 spec.template.containers.image 属性。
- en: Kustomize feature list
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: Kustomize 功能列表
- en: 'Kustomize comes with all the features needed to customize your Kubernetes deployment,
    including the following, as shown in figure 12.34:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: Kustomize 包含了自定义您的 Kubernetes 部署所需的所有功能，包括以下内容，如图 12.34 所示：
- en: Generating resources (ConfigMaps and Secrets)
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成资源（ConfigMaps 和 Secrets）
- en: Setting cross-cutting fields
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置跨切面字段
- en: Composing and customizing resources
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合和自定义资源
- en: '![12-34](../../OEBPS/Images/12-34.png)'
  id: totrans-419
  prefs: []
  type: TYPE_IMG
  zh: '![12-34](../../OEBPS/Images/12-34.png)'
- en: Figure 12.34 Kustomize features
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.34 Kustomize 功能
- en: Let’s look at each of them in detail.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看每一个。
- en: Composing
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 组合
- en: 'You can use the resources attribute to define which resource definitions you
    want to customize. If you don’t include any other customization feature in the
    file, the resources will be simply composed into one definition. In the following
    example, we compose the deployment.yaml and service.yaml definitions:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 resources 属性来定义您想要自定义的资源定义。如果您在文件中不包含任何其他自定义功能，资源将简单地组合成一个定义。在以下示例中，我们将
    deployment.yaml 和 service.yaml 定义组合在一起：
- en: '[PRE36]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To run the customization, execute the next command:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行自定义，执行以下命令：
- en: '[PRE37]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Customizing
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义
- en: 'Customization allows you to patch your resources with specific values using
    the following methods:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 定制允许您使用以下方法使用特定值修补您的资源：
- en: patchesStrategicMerge ([http://mng.bz/rdQX](http://mng.bz/rdQX))
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: patchesStrategicMerge ([http://mng.bz/rdQX](http://mng.bz/rdQX))
- en: patchesJson6902 ([http://mng.bz/Vpo5](http://mng.bz/Vpo5))
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: patchesJson6902 ([http://mng.bz/Vpo5](http://mng.bz/Vpo5))
- en: 'For example, you can patch the my-deployment Deployment defined in the deployment.yaml
    file with the number of replicas by creating the following files:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以通过创建以下文件来修补 deployment.yaml 文件中定义的 my-deployment Deployment 的副本数：
- en: '[PRE38]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And run the following code:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行以下代码：
- en: '[PRE39]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In addition to this customize feature, you can also change container images
    in your Deployment by defining the image attribute.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个定制功能之外，您还可以通过定义 image 属性来更改 Deployment 中的容器镜像。
- en: Setting cross-cutting fields
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 设置交叉字段
- en: 'Using cross-cutting fields, you can set the following attributes for your Kubernetes
    resources:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 使用交叉字段，您可以为您 Kubernetes 资源设置以下属性：
- en: namespace
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: namespace
- en: namePrefix
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: namePrefix
- en: nameSuffix
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: nameSuffix
- en: commonLabels
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: commonLabels
- en: commonAnnotation
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: commonAnnotation
- en: 'In the next example, we set the namespace to my-namespace for the deployment.yaml
    definition. Note: You can use the resources attribute to define the resources
    you want to be affected.'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将 namespace 设置为 my-namespace，用于 deployment.yaml 定义。注意：您可以使用 resources
    属性来定义您想要受影响的资源。
- en: '[PRE40]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Generating resources
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 生成资源
- en: 'With Kustomize, you can generate ConfigMaps and Secrets resources. As we have
    already learned, they are used for feeding configuration and credentials to your
    application. You can generate objects either from a literal or a file. The following
    generators are supported:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kustomize，您可以生成 ConfigMaps 和 Secrets 资源。正如我们已经学到的，它们用于向您的应用程序提供配置和凭证。您可以从文本或文件中生成对象。以下是一些支持的生成器：
- en: configMapGenerator
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: configMapGenerator
- en: secretGenerator
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: secretGenerator
- en: 'For example, to generate a ConfigMap with the key-value pair, you can use the
    following file:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要生成具有键值对的 ConfigMap，您可以使用以下文件：
- en: '[PRE41]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And run the next code:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行下一代码：
- en: '[PRE42]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Using variables
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 使用变量
- en: Variables are useful when you want to capture an attribute of one resource and
    pass it to other resources. For example, you might want to use the service name
    to pass it to a container command to be executed. Note that this currently supports
    string types. You can see an example of this usage at [http://mng.bz/xdEB](http://mng.bz/xdEB).
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 变量在您想要捕获一个资源的属性并将其传递给其他资源时非常有用。例如，您可能想使用服务名称将其传递给要执行的容器命令。请注意，目前这支持字符串类型。您可以在
    [http://mng.bz/xdEB](http://mng.bz/xdEB) 看到这个用法的示例。
- en: Bases and overlays
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 基础和覆盖
- en: Now that we have a good understanding of what features Kustomize offers, we
    can look at how we can use them to prepare Kubernetes for different environments
    in your CI/CD pipeline. Kustomize comes with the concepts of *bases* and *overlays*.
    A base is a root directory with Kubernetes resource definitions and the main kustomization.yaml
    file. It performs a first layer of customization. Note that you can also set your
    base in a Git repository. Overlay is a directory that stores the kustomization.yaml
    that customizes resources already customized in the base layer. You can create
    multiple overlays to represent each of your environments, as shown in figure 12.35.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经很好地理解了 Kustomize 提供的功能，我们可以看看如何使用它们来为 CI/CD 管道中的不同环境准备 Kubernetes。Kustomize
    包含了 *bases* 和 *overlays* 的概念。基础是一个包含 Kubernetes 资源定义和主要 kustomization.yaml 文件的根目录。它执行第一层定制。请注意，您也可以在
    Git 仓库中设置您的基。覆盖是一个存储用于定制基础层中已定制的资源的 kustomization.yaml 的目录。您可以根据图 12.35 所示创建多个覆盖，以表示每个环境。
- en: '![12-35](../../OEBPS/Images/12-35.png)'
  id: totrans-457
  prefs: []
  type: TYPE_IMG
  zh: '![12-35](../../OEBPS/Images/12-35.png)'
- en: Figure 12.35 Kustomize base and overlays
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.35 Kustomize 基础和覆盖
- en: 'Next, you can see an example of file structure for a single base with three
    overlays for the dev, test, and prod environments:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您可以看到一个示例文件结构，用于单个基础和三个覆盖，分别针对开发、测试和生产环境：
- en: '[PRE43]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You could use this file structure to set the number of replicas to be different
    for each environment. For example, maybe for development, you don’t need to consume
    as many resources as for tests, where you might want to run performance testing.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这种文件结构来设置每个环境的不同副本数。例如，对于开发环境，可能不需要像测试环境那样消耗那么多资源，在测试环境中，您可能想运行性能测试。
- en: Summary of Kustomize
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: Kustomize 概述
- en: As we have seen, Kustomize can be a powerful tool in your CI/CD pipeline to
    generate and patch Kubernetes resources for each of your environments. If you
    want to learn more about how to use Kustomize, check out the Kustomize examples
    at [http://mng.bz/AlKW](http://mng.bz/AlKW) and the API references at [https://kubectl.docs.kubernetes.io/references/](https://kubectl.docs.kubernetes.io/references/).
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Kustomize 可以是 CI/CD 管道中的一种强大工具，用于为每个环境生成和修补 Kubernetes 资源。如果您想了解更多关于如何使用
    Kustomize 的信息，请查看 [http://mng.bz/AlKW](http://mng.bz/AlKW) 上的 Kustomize 示例和 [https://kubectl.docs.kubernetes.io/references/](https://kubectl.docs.kubernetes.io/references/)
    上的 API 参考。
- en: 12.5 Continuous deployment with Cloud Deploy
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.5 使用 Cloud Deploy 进行持续部署
- en: Cloud deploy is a fully managed CD service that allows you to deliver your applications
    to a defined series of target environments according to a promotion sequence.
    The life cycle of your applications is managed using releases and is controlled
    by delivery pipelines.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud deploy 是一种完全托管的 CD 服务，允许您根据提升序列将应用程序交付到一系列定义的目标环境中。您应用程序的生命周期通过发布进行管理，并由交付管道控制。
- en: 12.5.1 Cloud Deploy in the Anthos CI/CD
  id: totrans-466
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.5.1 Anthos CI/CD 中的 Cloud Deploy
- en: Google Cloud Deploy integrates with the Google Cloud Platform ecosystem of services
    that we have already learned about, as shown in figure 12.36, to complete the
    end-to-end CI/CD solution for GKE and Anthos clusters.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: Google Cloud Deploy 与我们已了解的 Google Cloud Platform 生态系统中的服务集成，如图 12.36 所示，以完成
    GKE 和 Anthos 集群的端到端 CI/CD 解决方案。
- en: '![12-36](../../OEBPS/Images/12-36.png)'
  id: totrans-468
  prefs: []
  type: TYPE_IMG
  zh: '![12-36](../../OEBPS/Images/12-36.png)'
- en: Figure 12.36 The Cloud Deploy CI/CD ecosystem
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.36 Cloud Deploy CI/CD 生态系统
- en: 'Figure 12.36 shows the Google Cloud Deploy interface with the following services:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.36 显示了 Google Cloud Deploy 界面和以下服务：
- en: '*CI tooling*—Calls the Google Cloud Deploy API or CLI to create a release.
    Hence, most of the CI tools are supported, including Cloud Build.'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CI 工具*——调用 Google Cloud Deploy API 或 CLI 创建发布。因此，大多数 CI 工具都受支持，包括 Cloud Build。'
- en: '*Cloud Build*—Used to render the manifests and to deploy to the target runtime.'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Cloud Build*——用于渲染清单并将其部署到目标运行时。'
- en: '*Skaffold*—Used by Cloud Build to render and deploy the manifests. As a result,
    the application is deployed.'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Skaffold*——由 Cloud Build 用于渲染和部署清单。因此，应用程序被部署。'
- en: '*Cloud Storage*—Stores the rendering source and rendered manifests.'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Cloud Storage*——存储渲染源和渲染清单。'
- en: '*Google Cloud’s operations suite*—Collects and stores the audit logs of the
    Cloud Deploy service.'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Google Cloud 的操作套件*——收集并存储 Cloud Deploy 服务的审计日志。'
- en: '*Pub/Sub*—Allows publishing Cloud Deploy messages to Pub/Sub topics. This can
    be used to integrate with external systems.'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Pub/Sub*——允许将 Cloud Deploy 消息发布到 Pub/Sub 主题。这可以用于与外部系统集成。'
- en: '*GKE and Anthos clusters*—The target runtimes to which Google Cloud Deploy
    deploys the applications using Skaffold, through Cloud Build, to your target runtime.'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*GKE 和 Anthos 集群*——Google Cloud Deploy 使用 Skaffold 部署应用程序的目标运行时，通过 Cloud Build
    部署到您的目标运行时。'
- en: Now that we know how Cloud Deploy interacts with the other Anthos CI/CD tools,
    let’s see how we can configure it for CD of Anthos applications.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了 Cloud Deploy 如何与其他 Anthos CI/CD 工具交互，让我们看看如何配置它以进行 Anthos 应用程序的 CD。
- en: 12.5.2 Google Cloud Deploy delivery pipeline for Anthos
  id: totrans-479
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.5.2 Anthos 的 Google Cloud Deploy 交付管道
- en: Cloud Deploy uses delivery pipeline manifests that define the promotion sequence
    to describe the order in which to deploy to targets. The targets are described
    in the pipelines’ definition or in separate files. The Skaffold configuration
    file is used to render and deploy the Kubernetes resource manifest. Figure 12.37
    defines the components and the flow that Cloud Deploy uses.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Deploy 使用交付管道清单来定义提升序列，以描述部署到目标的目标顺序。目标在管道的定义中或单独的文件中描述。Skaffold 配置文件用于渲染和部署
    Kubernetes 资源清单。图 12.37 定义了 Cloud Deploy 使用的组件和流程。
- en: '![12-37](../../OEBPS/Images/12-37.png)'
  id: totrans-481
  prefs: []
  type: TYPE_IMG
  zh: '![12-37](../../OEBPS/Images/12-37.png)'
- en: Figure 12.37 Cloud Deploy workflow
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.37 Cloud Deploy 工作流程
- en: 'Let’s look at the sequences of action needed to configure continuous delivery
    with Cloud Build, shown in the next set of steps. As a prerequisite, we should
    already have three GKE/Anthos clusters deployed for each of your environments,
    as shown in figure 12.38:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看配置与 Cloud Build 一起进行持续交付所需的操作序列，如下一组步骤所示。作为先决条件，我们应该已经为每个环境部署了三个 GKE/Anthos
    集群，如图 12.38 所示：
- en: 'The first step is to define the delivery pipeline with the progressions (the
    promotion sequence) and, optionally, the runtime targets. In this example, we
    will create separate target files, so we can define the following pipeline:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是定义包含进展（提升顺序）和可选的运行时目标的交付管道。在此示例中，我们将创建单独的目标文件，因此可以定义以下管道：
- en: '[PRE44]'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The targets can be defined as separate files. You can define a separate file
    per target and will end up with the following three files:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标可以定义为单独的文件。您可以针对每个目标定义一个单独的文件，最终将得到以下三个文件：
- en: target_test.yaml
  id: totrans-487
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: target_test.yaml
- en: target_staging.yaml
  id: totrans-488
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: target_staging.yaml
- en: target_prod.yaml
  id: totrans-489
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: target_prod.yaml
- en: '![12-38](../../OEBPS/Images/12-38.png)'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![12-38](../../OEBPS/Images/12-38.png)'
- en: Figure 12.38 Target GKE/Anthos clusters
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 12.38 目标 GKE/Anthos 集群
- en: 'In each of the files, you define the name of the target and the target cluster.
    Here you can see an example for the test target:'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在每个文件中，您定义目标名称和目标集群。这里您可以看到一个测试目标的示例：
- en: '[PRE45]'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the next step, you define the Skaffold configuration file needed for the
    rendering and deployment of the application manifest. At this stage, you should
    already have a container image to deploy and a Kubernetes manifest that identifies
    the container image—these should be generated in your CI process. For more information
    on how to use Skaffold with Cloud Deploy, check out section 12.3.2, “Continuous
    development with Skaffold.”
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，您定义用于渲染和部署应用程序清单所需的 Skaffold 配置文件。在此阶段，您应该已经有一个要部署的容器镜像和一个标识容器镜像的 Kubernetes
    清单——这些应该在您的 CI 流程中生成。有关如何使用 Skaffold 与 Cloud Deploy 的更多信息，请参阅第 12.3.2 节，“使用 Skaffold
    进行持续开发。”
- en: 'Your Skaffold configuration might look like the following:'
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您的 Skaffold 配置可能如下所示：
- en: '[PRE46]'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, register the pipeline and the target by running the following commands:'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过运行以下命令注册管道和目标：
- en: '[PRE47]'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now Cloud Deploy knows your application, and it will manage the deployment to
    targets according to your defined promotion sequence.
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在 Cloud Deploy 已了解您的应用程序，并将根据您定义的提升顺序管理部署到目标。
- en: 'Now you can initiate the delivery pipeline by creating a release either from
    the command line or from your CI tooling. Google Cloud Deploy creates a rollout
    resource, which associates the release with the first target environment. Based
    on that rollout, your application is deployed to the first target. Run the following
    command from the directory containing your Skaffold config:'
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以通过从命令行或从 CI 工具创建发布来启动交付管道。Google Cloud Deploy 创建一个部署资源，该资源将发布与第一个目标环境相关联。基于该部署，您的应用程序被部署到第一个目标。从包含您的
    Skaffold 配置的目录运行以下命令：
- en: '[PRE48]'
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If you want to use Cloud Build as your CI tool, the following YAML file shows
    an example Cloud Build configuration, which includes a call to Google Cloud Deploy
    to create a release, with a release name based on the date and Skaffold used for
    the build:'
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想使用 Cloud Build 作为 CI 工具，以下 YAML 文件显示了 Cloud Build 配置的示例，其中包含调用 Google Cloud
    Deploy 创建发布的功能，发布名称基于日期和用于构建的 Skaffold：
- en: '[PRE49]'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Once you are ready to deploy the application to the next target of the sequence,
    you can promote it. Make a call to Google Cloud Deploy and create a new rollout:'
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您准备好将应用程序部署到序列中的下一个目标，您就可以提升它。调用 Google Cloud Deploy 并创建一个新的部署：
- en: '[PRE50]'
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You can continue the promotion to the last environment. In the example sequence,
    shown in figure 12.39, it is production.
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以将提升继续到最后一个环境。在图 12.39 中显示的示例序列中，它是生产环境。
- en: '![12-39](../../OEBPS/Images/12-39.png)'
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![12-39](../../OEBPS/Images/12-39.png)'
- en: Figure 12.39 Promotion sequence
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 12.39 提升顺序
- en: If you want to introduce approvals into the progression process, you can do
    it in the target definitions. For example, we might want to approve all promotions
    in testing to staging and production as shown in figure 12.40.
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想在进展过程中引入批准，您可以在目标定义中这样做。例如，我们可能希望批准图 12.40 中显示的测试到预发布和生产的所有提升。
- en: '![12-40](../../OEBPS/Images/12-40.png)'
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![12-40](../../OEBPS/Images/12-40.png)'
- en: Figure 12.40 Manual approvals
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 12.40 手动批准
- en: 'You can define approvals in each of the target definitions as follows:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在每个目标定义中定义批准，如下所示：
- en: '[PRE51]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The parameter requireApproval: true indicates whether promotion to this target
    requires manual approval. The value can be true or false and is optional; the
    default is false.'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '参数 requireApproval: true 表示是否需要手动批准提升到该目标。其值可以是 true 或 false，且为可选值；默认为 false。'
- en: 'Now you can either approve or reject the rollout. To approve the rollout, run
    the next command:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以选择批准或拒绝部署。要批准部署，请运行以下命令：
- en: '[PRE52]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Or reject the approval by running the following:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 或者通过运行以下命令来拒绝审批：
- en: '[PRE53]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As you can see, this gives you full control over your application rollouts.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这为您提供了对应用程序发布的完全控制。
- en: Summary of Cloud Deploy
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 云部署概述
- en: In this section, we have learned how Cloud Deploy can be used for CD of your
    application. It comes with many important features like approvals, logging, and
    integrations with third-party tools, making it an enterprise-grade solution. It
    seamlessly integrates with the end-to-end CI/CD pipeline for Anthos. To learn
    more about Cloud Deploy, see [https://cloud.google.com/deploy](https://cloud.google.com/deploy).
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用云部署进行应用程序的持续交付。它包含许多重要功能，如审批、日志记录和与第三方工具的集成，使其成为企业级解决方案。它无缝集成到Anthos的端到端CI/CD管道中。要了解更多关于云部署的信息，请参阅[https://cloud.google.com/deploy](https://cloud.google.com/deploy)。
- en: 'If you want to get hands-on experience with Cloud Build, we encourage you to
    look at the example tutorials that cover even more features and integrations:
    [http://mng.bz/ZoKZ](http://mng.bz/ZoKZ).'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想亲身体验云构建，我们鼓励您查看包含更多功能和集成的示例教程：[http://mng.bz/ZoKZ](http://mng.bz/ZoKZ)。
- en: 12.6 Modern CI/CD platform
  id: totrans-523
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.6 现代CI/CD平台
- en: 'Modern CI/CD platforms must allow sustainable software development and operation
    of the entire application delivery pipeline. No single way to achieve that goal
    exists, and it is always dependent on application and organization specifics.
    All of them should follow the same pattern when addressing tree key layers, as
    shown here and in figure 12.41:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 现代CI/CD平台必须允许可持续地开发和运营整个应用程序交付管道。实现这一目标没有单一的方法，它始终依赖于应用程序和组织的具体情况。所有这些平台在解决以下三个关键层时都应遵循相同的模式，如图12.41和图12.42所示：
- en: '*Infrastructure*—Used for hosting'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基础设施*—用于托管'
- en: '*Platforms*—Used by developers to create, maintain, and consume continuous
    integration capabilities'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*平台*—由开发者用于创建、维护和消费持续集成能力'
- en: '*Applications*—Consumption layers for end users'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*应用程序*—面向最终用户的消费层'
- en: '![12-41](../../OEBPS/Images/12-41.png)'
  id: totrans-528
  prefs: []
  type: TYPE_IMG
  zh: '![12-41](../../OEBPS/Images/12-41.png)'
- en: Figure 12.41 CI/CD platform layers
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.41 CI/CD平台层
- en: 'Each layer is under the responsibility of at least the following three types
    of personas:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 每一层至少由以下三种类型的角色负责：
- en: '*Developers*—Mostly focused on application development, automated testing,
    and releases'
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开发者*—主要关注应用程序开发、自动化测试和发布'
- en: '*Operators*—Focused on keeping the application, the underlying platform, and
    the infrastructure working to deliver agreed performance and availability indicators'
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*操作员*—专注于确保应用程序、底层平台和基础设施正常运行，以提供约定的性能和可用性指标'
- en: '*Security officers*—Guarantee that agreed policies and security standards are
    applied, regardless of environment type, structure, or layer'
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安全官*—确保无论环境类型、结构或层，都应用了约定的政策和安全标准'
- en: Depending on the organization, more personas could exist. Each of them not only
    must have different responsibilities and roles and different constraints and restrictions
    applied on them, but they also must share the same methodologies across entire
    teams, which leads to a shared responsibility for delivery, as illustrated in
    figure 12.42.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 根据组织不同，可能存在更多角色。每个角色不仅必须拥有不同的职责和角色，以及不同的约束和限制，而且它们还必须在整个团队中共享相同的方法，这导致了对交付的共同责任，如图12.42所示。
- en: '![12-42](../../OEBPS/Images/12-42.png)'
  id: totrans-535
  prefs: []
  type: TYPE_IMG
  zh: '![12-42](../../OEBPS/Images/12-42.png)'
- en: Figure 12.42 Personas vs. code repositories
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.42 角色与代码仓库对比
- en: Anthos introduced the capabilities to centralize management and unify toolsets
    while maintaining the flexibility to integrate external tools into the pipeline.
    The goal for modern CI/CD platforms is to support enterprise-ready and secure
    GitOps implementations. That means every component must be described as a set
    of configuration files and definitions stored in the version control system. Each
    set is managed and maintained by a separate team. It was already mentioned that
    the modern CI/CD platform relies on shared responsibility. In such models, there
    are always touch points for all parties via common interfaces like the code repository,
    the image build, and the Kubernetes manifest definition stage.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: Anthos 引入了集中管理和统一工具集的能力，同时保持将外部工具集成到管道中的灵活性。现代 CI/CD 平台的目标是支持企业级和安全的 GitOps
    实现。这意味着每个组件都必须描述为一组配置文件和定义，这些文件和定义存储在版本控制系统内。每个集合由一个单独的团队管理和维护。已经提到，现代 CI/CD 平台依赖于共享责任。在这样的模型中，所有各方都通过公共接口（如代码仓库、镜像构建和
    Kubernetes 清单定义阶段）进行接触。
- en: Modern application delivery relies on Kubernetes orchestration and microservices-based
    architecture. In such, there must be separation between developers and the operator
    playground. Implementation depends on defined requirements. We can use single
    cluster with multiple namespaces for single-site or nonproduction setups. If services
    we are delivering must be highly available or deliver high latency across a globe
    or we must limit infrastructure life cycle activity impact, consider using multiple
    Anthos clusters. Multicluster setup allows us to roll out applications in small
    steps to individual clusters before they are fully released.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 现代应用交付依赖于 Kubernetes 调度程序和基于微服务的架构。在这种情况下，开发者和操作者游乐场之间必须有分离。实施取决于定义的需求。我们可以使用单个集群和多个命名空间来设置单站点或非生产环境。如果我们交付的服务必须具有高可用性或在全球范围内提供高延迟，或者我们必须限制基础设施生命周期活动的影响，请考虑使用多个
    Anthos 集群。多集群设置允许我们在完全发布之前以小步骤向各个集群推出应用程序。
- en: 'Let’s define an example application: a simple microservices-based voting system
    capable of visualizing voting results, as presented in figure 12.43.'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个示例应用程序：一个简单的基于微服务的投票系统，能够可视化投票结果，如图 12.43 所示。
- en: '![12-43](../../OEBPS/Images/12-43.png)'
  id: totrans-540
  prefs: []
  type: TYPE_IMG
  zh: '![12-43](../../OEBPS/Images/12-43.png)'
- en: Figure 12.43 Application schema
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.43 应用架构
- en: 'The underlying infrastructure consumes Anthos GKE cluster on GCP. Three namespaces
    are created, one for each service:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施底层使用 GCP 上的 Anthos GKE 集群。创建了三个命名空间，每个服务一个：
- en: Voting
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 投票
- en: Transfer
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转移
- en: Results
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果
- en: 'It also uses the following three Google-managed services:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 它还使用了以下三个 Google 管理的服务：
- en: Cloud Memorystore as managed Redis
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云 Memorystore 作为托管的 Redis
- en: Cloud SQL as a central database for all votes delivered as managed Postgres
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cloud SQL 作为所有作为托管 Postgres 提供的投票的中心数据库
- en: Secret Manager as a secure Secrets management system to store credentials for
    Memorystore and Cloud SQL
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Secret Manager 作为安全的密钥管理系统，用于存储 Memorystore 和 Cloud SQL 的凭证
- en: Developers consume infrastructure and do not care how it is delivered. It must
    meet their requirements related to namespaces and managed services. A responsible
    team must create a CI/CD pipeline that can be used for application-hosting purposes
    and have full flexibility to test any changes.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者消费基础设施，并不关心它是如何交付的。它必须满足他们与命名空间和管理服务相关的需求。一个负责任的团队必须创建一个 CI/CD 管道，可用于应用程序托管目的，并具有完全的灵活性来测试任何更改。
- en: 'To achieve this goal, we can use multiple different tools. If our teams are
    familiar with Terraform, we can use already available knowledge and integrate
    it into our CI/CD pipeline. Such an approach is fully in line with DORA’s State
    of DevOps research program ([https://www.devops-research.com/research.xhtml](https://www.devops-research.com/research.xhtml)).
    It defines one of the key success factors for implementation of DevOps in organizations:
    the freedom to choose the tools developers and operation people are using. One
    more question exists: can we deliver such infrastructure even more simply? Because
    we are using GCP-managed resources instead of using external tools, we can take
    advantage of the Anthos Config Connector capability to deliver Secret Manager,
    Cloud Memorystore, and Cloud SQL as declared objects in our code repository.'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一目标，我们可以使用多种不同的工具。如果我们的团队熟悉 Terraform，我们可以利用已有的知识并将其集成到我们的 CI/CD 流程中。这种做法完全符合
    DORA 的 DevOps 状态研究计划([https://www.devops-research.com/research.xhtml](https://www.devops-research.com/research.xhtml))。它定义了组织实施
    DevOps 的关键成功因素之一：选择开发人员和运维人员使用的工具的自由。还有一个问题存在：我们能否以更简单的方式提供这样的基础设施？因为我们使用的是 GCP
    管理的资源，而不是使用外部工具，我们可以利用 Anthos Config Connector 功能，将 Secret Manager、Cloud Memorystore
    和 Cloud SQL 作为代码仓库中的声明性对象提供。
- en: If we are required to deliver services for other sources like Anthos on-prem,
    it is important to introduce infrastructure changes starting from day one in an
    automated way, as shown in figure 12.44\. Every Anthos on VMware or Anthos on
    bare metal must rely on predefined practices and security policies that can be
    constantly reused if needed.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要为其他来源提供服务，如 Anthos on-prem，那么从第一天开始以自动化的方式引入基础设施更改是很重要的，如图 12.44 所示。每个在
    VMware 或裸金属上运行的 Anthos 都必须依赖于预定义的实践和安全策略，如果需要，可以不断重复使用。
- en: '![12-44](../../OEBPS/Images/12-44.png)'
  id: totrans-553
  prefs: []
  type: TYPE_IMG
  zh: '![12-44](../../OEBPS/Images/12-44.png)'
- en: Figure 12.44 Infrastructure resources
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.44 基础设施资源
- en: 'Going deeper into our modern platform infrastructure, it must deliver the following
    elements to enable successful application delivery:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 深入了解我们的现代平台基础设施，它必须提供以下元素以实现应用程序交付的成功：
- en: '*High performance, high availability, and a stable shared tooling infrastructure*—It
    is used as a central repository for CI/CD, container images, and application and
    infrastructure code and configuration. It can be expanded for additional business
    support tools mandated by your company.'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*高性能、高可用性和稳定的共享工具基础设施*——它被用作 CI/CD、容器镜像以及应用程序和基础设施代码和配置的中心存储库。它可以扩展以支持公司要求的额外业务支持工具。'
- en: '*Separate preproduction and multiple production environments with coherent
    configuration*—Consistent security policies, RBAC, or networking configuration
    improves testing quality and efficiency, reduces error rate, and increases production
    software delivery.'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将预生产和多个生产环境通过一致的配置分开*——一致的安全策略、RBAC 或网络配置可以提高测试质量和效率，降低错误率，并提高生产软件交付。'
- en: '*Development infrastructure*—Used for extensive unit testing and delivering
    freedom to our developers to work in their own namespaces.'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开发基础设施*——用于广泛的单元测试，并赋予我们的开发者在其自己的命名空间中工作的自由。'
- en: 'That moves us into the target CI/CD platform. It is important that platform
    choice is multidimensional and must be driven by the following factors:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 这将我们引入目标 CI/CD 平台。平台选择的多维度性和必须由以下因素驱动是很重要的：
- en: '*The platform must be known to the teams that are operating it.* It is not
    necessary that the platform is already used, but proper training must be delivered,
    and teams must have time to get familiar with it.'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*操作该平台的团队必须了解该平台。* 平台已经被使用并不必要，但必须提供适当的培训，并且团队必须有时间熟悉它。'
- en: '*The platform must fit into the desired state of application and infrastructure
    delivery model.* That includes operational models and business logic implemented
    in enterprise.'
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*平台必须适应应用程序和基础设施交付模型所期望的状态。* 这包括在企业中实施的操作模型和业务逻辑。'
- en: '*The availability and health of the application must be properly measured and
    monitored* *on all levels*. This means starting from infrastructure, through tooling
    platform, and closing at application level itself.'
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*必须在所有层面上正确测量和监控应用程序的可用性和健康状况*。 这意味着从基础设施开始，通过工具平台，最后在应用程序本身级别结束。'
- en: '*As described in the introduction section, the platform must be DevOps ready*.'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如介绍部分所述，平台必须为 DevOps 准备就绪*。'
- en: When choosing a code repository, consider what capabilities are mandatory for
    you. For simple code version management at a small scale, Google Cloud Source
    Repository can be enough. When additional functionality is required, you must
    consider other Git providers. Common patterns for GitLab, GitHub, or Bitbucket
    adoption would be a demand to keep code in your on-prem data center or to introduce
    responsibility for particular folders in Git by implementing code owners. Similar
    choices must be made for integration and deployment tools. Driven by additional
    requirements, we can have already on-prem implementation of GitLab CI/CD. For
    complex application delivery, you can use Spinnaker as a CD tool. The Anthos-based
    platform is flexible in that area. We can use Google Cloud Platform tools or easily
    integrate into external tools and still benefit from out-of-the-box Anthos automation
    and features, as shown in figure 12.45.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择代码仓库时，考虑对你来说哪些功能是必需的。对于小规模的简单代码版本管理，Google Cloud Source Repository 可能足够。当需要额外的功能时，你必须考虑其他
    Git 提供商。GitLab、GitHub 或 Bitbucket 的常见模式可能是要求将代码保留在本地数据中心，或者通过实施代码所有者来对 Git 中的特定文件夹引入责任。对于集成和部署工具，也必须做出类似的选择。受额外需求驱动，我们可能已经在本地上实施了
    GitLab CI/CD。对于复杂的应用交付，你可以使用 Spinnaker 作为 CD 工具。基于 Anthos 的平台在该领域具有灵活性。我们可以使用
    Google Cloud Platform 工具或轻松集成到外部工具，同时仍然从开箱即用的 Anthos 自动化和功能中受益，如图 12.45 所示。
- en: '![12-45](../../OEBPS/Images/12-45.png)'
  id: totrans-565
  prefs: []
  type: TYPE_IMG
  zh: '![12-45](../../OEBPS/Images/12-45.png)'
- en: Figure 12.45 Software resources
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.45 软件资源
- en: As soon as we have our infrastructure and CI/CD platform ready, we can enable
    them for development activities. We defined personas and what interfaces they
    use to cooperate with each other. Let’s look at the end-to-end workflow for that
    cooperation, presented in figure 12.46.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的基础设施和 CI/CD 平台准备就绪，我们就可以为开发活动启用它们。我们定义了角色以及他们使用哪些接口来相互协作。让我们看看图 12.46 中展示的这种协作的端到端工作流程。
- en: '![12-46](../../OEBPS/Images/12-46.png)'
  id: totrans-568
  prefs: []
  type: TYPE_IMG
  zh: '![12-46](../../OEBPS/Images/12-46.png)'
- en: Figure 12.46 Application delivery workflow
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.46 应用交付工作流程
- en: As soon as code is ready, it must be shipped into a production-like environment
    to guarantee quality in the new code update’s validation process. As already described,
    code can be pushed to Cloud Code or any other Git repository, where quality and
    sanity checks are performed. When it passes, you can produce container images
    and push them into the container registry. After the image is acknowledged by
    operators, they apply to them best practices, applications, and company standards
    from an operational practices Git repository. Operators define pipelines using
    tools like Kustomize, creating environment-specific repositories that become the
    source of truth for environment-specific manifests. Moreover, because all environments
    rely on the same application and operational practices code repositories, they
    are guaranteed to be consistent. As a result, nonproduction environments are as
    close to production environments as possible.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码准备就绪，它必须被部署到类似生产环境，以确保新代码更新验证过程中的质量。如前所述，代码可以被推送到 Cloud Code 或任何其他 Git 仓库，在那里进行质量和健全性检查。当它通过时，你可以生成容器镜像并将它们推送到容器注册库。当镜像被操作员确认后，他们将这些最佳实践、应用程序和公司标准应用于它们，这些标准来自操作实践
    Git 仓库。操作员使用 Kustomize 等工具定义管道，创建特定环境的仓库，这些仓库成为特定环境清单的真相来源。此外，因为所有环境都依赖于相同的应用程序和操作实践代码仓库，它们保证是一致的。因此，非生产环境尽可能接近生产环境。
- en: We already mentioned the importance of shifting security adaptation left as
    much as possible in the development life cycle. Kubernetes cluster consistency
    between development and production environments plays an important role in application
    delivery speed. In chapter 13, we will learn how Anthos Policy Controller works,
    whereas in chapter 11, we already learned how Anthos Config Management helps to
    keep the configuration consistent. We can apply both policy and infrastructure
    controllers to the final version of our CI/CD pipeline. Similar to application
    consistency, a single source of truth for all environments guarantees consistency
    for security measures, which allows us to incorporate infrastructure and security
    changes in a modern, declarative way.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到了尽可能在开发生命周期中左移安全适应性的重要性。开发环境和生产环境之间的 Kubernetes 集群一致性在应用交付速度中起着重要作用。在第
    13 章中，我们将学习 Anthos Policy Controller 的工作原理，而在第 11 章中，我们已经学习了 Anthos Config Management
    如何帮助保持配置的一致性。我们可以将策略和基础设施控制器应用到我们的 CI/CD 管道最终版本中。类似于应用一致性，所有环境单一事实来源保证了安全措施的一致性，这使我们能够以现代声明式的方式合并基础设施和安全更改。
- en: Let’s come back to our reference application and look at how the previous workflow
    applies to it. In our case, we can have three separate development teams. Each
    of them is producing a separate image that is handed over to operators responsible
    for the end-to-end application. A Kubernetes cluster delivers an application landing
    zone, as shown in figure 12.47, as a dedicated namespace. This provides us the
    capability for workload isolation between applications on resource, security,
    and connectivity levels.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的参考应用程序，看看之前的流程是如何应用到它上面的。在我们的案例中，我们可以有三个独立的开发生态。每个团队都生产一个单独的镜像，并将其交给负责端到端应用程序的操作员。Kubernetes
    集群以专用命名空间的形式提供应用程序着陆区，如图 12.47 所示。这为我们提供了在资源、安全和连接级别上实现工作负载隔离的能力。
- en: '![12-47](../../OEBPS/Images/12-47.png)'
  id: totrans-573
  prefs: []
  type: TYPE_IMG
  zh: '![12-47](../../OEBPS/Images/12-47.png)'
- en: Figure 12.47 Application landing zones
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.47 应用着陆区
- en: Summary
  id: totrans-575
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Modern application delivery CI/CD platforms play a significant role in the modern
    enterprise application delivery process.
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代应用交付 CI/CD 平台在现代企业应用交付过程中发挥着重要作用。
- en: Developers can focus on applications, which increases the performance and efficiency
    of development teams.
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者可以专注于应用程序，这增加了开发团队的性能和效率。
- en: The same applies to operators that can control application delivery on early
    stages, offload daily routines, and minimize configuration overhead.
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样适用于可以控制早期阶段应用程序交付的运营商，减轻日常任务，并最小化配置开销。
- en: Automated pipelines unify the ways of working with an application and infrastructure.
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化管道统一了与应用程序和基础设施协同工作的方式。
- en: Security teams become an inseparable part of the integration and delivery process.
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全团队成为集成和交付过程不可或缺的一部分。
- en: Modern CI/CD platforms introduced unified tools. They built knowledge, awareness
    of expectations, and a way of working across all involved parties.
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代CI/CD平台引入了统一工具。它们构建了所有相关方的知识、期望意识和工作方式。
- en: Unified toolsets improve cooperation in the shared responsibility model that
    the platform introduced into organization.
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统一的工具集提高了平台引入组织中的共享责任模型下的合作。
- en: Processes, operating models, learning, and communication paths must be adapted
    to fit that new model. Its benefits include reduced lead time for changes, increased
    deployment frequency, and a significant drop in service recovery time.
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流程、运营模式、学习和沟通路径必须适应这一新模型。其好处包括减少变更的提前期、增加部署频率以及显著降低服务恢复时间。
- en: '* * *'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '^(1.)Jez Humble and David Farley, *Continuous Delivery: Reliable Software Releases
    Through Build, Test, and Deployment Automation* (Addison-Wesley Professional,
    2010).'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: ^(1.)Jez Humble 和 David Farley，*持续交付：通过构建、测试和部署自动化实现可靠的软件发布*（Addison-Wesley
    Professional，2010）。
- en: ^(2.)Structure tests are a Google-developed mechanism of testing containers;
    for details consult [http://mng.bz/eJzz](http://mng.bz/eJzz).
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: ^(2.)结构测试是 Google 开发的一种容器测试机制；有关详细信息，请参阅 [http://mng.bz/eJzz](http://mng.bz/eJzz)。
