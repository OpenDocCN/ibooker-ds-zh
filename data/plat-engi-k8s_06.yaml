- en: 6 Let’s build a platform on top of Kubernetes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 让我们在Kubernetes之上构建一个平台
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Identifying features that platforms should provide on Kubernetes
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定平台在Kubernetes上应提供的功能
- en: Learning the challenges with multi-cluster and multi-tenant setups
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解多集群和多租户设置的挑战
- en: Seeing what a platform on top of Kubernetes looks like
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看在Kubernetes之上的平台是什么样的
- en: 'So far, we have looked at what platform engineering is, why we need to think
    about platforms in the context of Kubernetes, and how teams must choose the tools
    they can use from the CNCF landscape (chapter 1). Then we jumped into figuring
    out how our applications would run on top of Kubernetes (chapter 2), and how to
    build, package, and deploy (chapters 3 and 4), and connect these applications
    to other services that they need to work (chapter 5). This chapter puts all the
    pieces together to create a walking skeleton for our platform. We will use some
    of the open-source projects introduced in the previous chapters and new tools
    to solve some of the challenges we will face when creating the first iteration
    of our platform. This chapter is divided into three main sections:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了平台工程是什么，为什么在Kubernetes的背景下我们需要考虑平台，以及团队必须如何从CNCF景观中选择他们可以使用的工具（第1章）。然后我们跳到了探讨我们的应用程序如何在Kubernetes之上运行（第2章），以及如何构建、打包和部署（第3章和第4章），以及将这些应用程序连接到它们需要工作的其他服务（第5章）。本章将所有这些部分组合起来，为我们平台的骨架构建一个行走模型。我们将使用前几章中介绍的一些开源项目和新的工具来解决我们在创建平台的第一迭代时可能面临的挑战。本章分为三个主要部分：
- en: The importance of the platform APIs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台API的重要性
- en: Kubernetes platform architecture and how we can architect a scalable platform
    despite multi-tenancy and multi-cluster challenges
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes平台架构以及如何在多租户和多集群挑战下构建可扩展的平台
- en: Introducing our platform walking skeleton and learning how to build a platform
    on top of Kubernetes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍我们的平台行走骨架，以及如何构建在Kubernetes之上的平台
- en: Let’s start by considering why defining the platform APIs is the first step
    to platform building.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先考虑一下为什么定义平台API是平台构建的第一步。
- en: 6.1 The importance of the platform APIs
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 平台API的重要性
- en: In chapter 1, we looked at existing platforms, such as Google Cloud Platform,
    to understand what key features they offer to teams building and running cloud
    applications. We now need to compare this to the platforms that we are building
    on top of Kubernetes, because these platforms share some common goals and features
    with cloud providers while at the same time being closer to our organizations’
    domains.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1章中，我们研究了现有的平台，例如Google Cloud Platform，以了解它们为构建和运行云应用程序的团队提供了哪些关键功能。我们现在需要将这一点与我们在Kubernetes之上构建的平台进行比较，因为这些平台在共享一些与云提供商的共同目标和功能的同时，也与我们组织的领域更接近。
- en: Platforms are nothing other than software that we will design, create, and maintain.
    As with any good software, our platform will evolve to help teams with new scenarios,
    make our teams more efficient by providing automation, and give us the tools to
    make the business more successful. As with any other software, we will start by
    looking at the platform APIs, which will provide us with a manageable scope to
    start with and define the contracts and behaviors our platform will provide its
    users.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 平台不过是我们将要设计、创建和维护的软件。就像任何优秀的软件一样，我们的平台将不断进化，以帮助团队应对新的场景，通过提供自动化来提高团队效率，并为我们提供使业务更成功的工具。就像其他任何软件一样，我们将从查看平台API开始，这将为我们提供一个可管理的范围来开始，并定义我们的平台将为用户提供哪些合约和行为。
- en: Figure 6.1 shows how the platform APIs are the main entry point for consumers
    of the platform—in this case, developers. These APIs should hide away the complexity
    of the tools, decisions, supported workflows, and golden paths that the platform
    provides to its users while at the same time offering a self-service place for
    teams to get what they need.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1显示了平台API是如何成为平台消费者（在这种情况下，开发者）的主要入口点。这些API应该隐藏平台为用户提供到工具、决策、支持的流程和黄金路径的复杂性，同时同时提供一个自助服务的地方，让团队获取他们所需的东西。
- en: '![](../../OEBPS/Images/06-01.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/06-01.png)'
- en: Figure 6.1 The platform engineering team is responsible for platform APIs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 平台工程团队负责平台API。
- en: Our platform APIs are important, because good APIs can simplify the life of
    development teams wanting to consume services from our platform. If our platform
    APIs are well designed, more tailored tools like CLIs, SDKs, or even user interfaces
    can be created to assist users in consuming our platform services.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的平台API非常重要，因为好的API可以简化希望从我们的平台消费服务的开发团队的生活。如果我们的平台API设计良好，可以创建更多定制工具，如CLIs、SDKs或甚至用户界面，以帮助用户消费我们的平台服务。
- en: If we build custom and more domain-specific APIs for our platform, we can start
    by tackling one problem at a time and then expand these APIs/interfaces to cover
    more and more workflows, even for different teams. Once we understand which workflows
    we want to cover and have an initial platform API dashboard, more tooling can
    be created to help teams adopt the platform.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为我们的平台构建定制和更特定领域的API，我们可以从一次解决一个问题开始，然后将这些API/接口扩展以覆盖更多和更多的工作流程，甚至为不同的团队。一旦我们了解我们想要覆盖哪些工作流程，并且有一个初始的平台API仪表板，就可以创建更多工具来帮助团队采用该平台。
- en: Let’s use an example to make it more concrete. I hope you can translate the
    example I am showing here into more concrete examples inside your organization.
    All the mechanisms should apply in the same way. Let’s enable our development
    teams to request new development environments.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来使其更加具体。我希望你能够将我这里展示的例子翻译成你组织内部更具体的例子。所有机制都应以相同的方式应用。让我们让我们的开发团队能够请求新的开发环境。
- en: 6.1.1 Requesting development environments
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.1 请求开发环境
- en: A common scenario where a platform can help teams get up to speed when they
    start working on new features is provisioning them with all they need to do their
    work. To achieve this task, the platform engineering team must understand what
    they will work on, what tools they need, and which other services must be available
    to succeed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个平台可以帮助团队在开始处理新功能时快速上手的常见场景是为他们提供完成工作所需的一切。为了完成这项任务，平台工程团队必须了解他们将做什么工作，他们需要哪些工具，以及哪些其他服务必须可用才能成功。
- en: Once the platform engineering team understands what development teams require,
    they can define an API to provision new development environments on demand. Behind
    these APIs, the platform has the mechanisms to create, configure, and provide
    access for the requesting team to connect.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦平台工程团队了解开发团队的需求，他们可以定义一个API，以按需提供新的开发环境。在这些API背后，平台有创建、配置和为请求团队提供连接访问权限的机制。
- en: For our Conference application example, if a development team is extending the
    application, we (the platform engineering team) must ensure they have a running
    version to work against and test changes. This isolated application instance will
    also need its databases and other infrastructural components to work. More advanced
    use cases include loading the application with mock data, allowing teams to test
    their changes with pre-populated data, and having the right tools to verify the
    changes. The interactions between the application development team and the platform
    should look like figure 6.2.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的会议应用程序示例，如果一个开发团队正在扩展应用程序，我们（平台工程团队）必须确保他们有一个可运行的版本来工作并测试更改。这个隔离的应用程序实例还需要其数据库和其他基础设施组件才能工作。更高级的用例包括用模拟数据加载应用程序，允许团队使用预先填充的数据测试他们的更改，并拥有验证更改的正确工具。应用程序开发团队与平台之间的交互应类似于图6.2。
- en: '![](../../OEBPS/Images/06-02.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/06-02.png)'
- en: 'Figure 6.2 Application development team interactions with the platform . #1
    App dev teams can request as many Development Environments as they need to the
    platform APIs; #2 The platform has encoded how to provision all the components
    and tools needed for the app dev team to work; #3 The platform needs to give access
    to the app dev team to use the newly provisioned environment.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 应用程序开发团队与平台的交互。#1 应用程序开发团队可以向平台API请求他们需要的任意数量的开发环境；#2 平台已经编码了如何提供应用程序开发团队工作所需的所有组件和工具；#3
    平台需要为应用程序开发团队提供访问权限，以便使用新配置的环境。
- en: As mentioned before, development environments are just an example. You must
    ask yourself what tools your teams need to do their work. A development environment
    might not be the best way to expose tools to a team of data scientists, for example,
    because they might need other tools to gather and process data or train machine
    learning models.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，开发环境只是一个例子。你必须问自己你的团队需要哪些工具来完成他们的工作。例如，对于数据科学家团队来说，开发环境可能不是向他们展示工具的最佳方式，因为他们可能需要其他工具来收集和处理数据或训练机器学习模型。
- en: 'Implementing this simple flow in Kubernetes is not an easy task. To implement
    this scenario, we need to:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中实现这个简单的流程并不容易。为了实现此场景，我们需要：
- en: Create new APIs that understand development environment requests.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图 6.3 显示了最简单的环境定义，它包括环境的名称和我们想要创建的环境类型（我们可能允许团队请求不同的设置，在这个例子中，我们想要一个新的 `开发`
    环境）。环境定义还包括对消费团队有意义的自定义配置。在这种情况下，因为我们将会安装会议应用程序，我们希望允许团队决定是否需要安装基础设施组件。
- en: Have the mechanisms to encode what a development environment means for our teams.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有机制来编码开发环境对我们团队的意义。
- en: Have the mechanisms to provision and configure components and tools.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有机制来配置和设置组件和工具。
- en: Have the mechanisms to enable teams to connect to the newly provisioned environments.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有机制使团队能够连接到新配置的环境。
- en: There are several options for implementing this scenario, including creating
    custom Kubernetes extensions or using more specialized tools for development environments.
    But before diving into implementation details, let’s define what our platform
    API would look like for this scenario.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此场景有多种选择，包括创建自定义的 Kubernetes 扩展或使用更专业的开发环境工具。但在深入实施细节之前，让我们定义一下在此场景下我们的平台
    API 应该是什么样子。
- en: As with object-oriented programming (OOP), our APIs are `Interfaces` that can
    be implemented by different `Classes`, which finally provide concrete behavior.
    For provisioning development environments, we can define a very simple interface
    called `Environment`. Development teams requesting a new development environment
    can create new requests to the platform by creating new environment resources.
    The `Environment` interface represents a contract between the user and the platform.
    This contract can include parameters to define the type of environment the team
    is requesting or options and parameters they need to tune for their specific request.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 就像面向对象编程（OOP）一样，我们的 API 是 `接口`，可以被不同的 `类` 实现，最终提供具体的行为。对于配置开发环境，我们可以定义一个非常简单的接口，称为
    `Environment`。请求新开发环境的开发团队可以通过创建新的环境资源向平台创建新的请求。`Environment` 接口代表了用户和平台之间的合同。此合同可以包括定义团队请求的环境类型或他们需要调整的选项和参数的参数。
- en: Figure 6.3 shows the simplest environment definition, which includes a name
    for the environment and the kind of environment that we want to create (we might
    enable teams to request different setups, and for this example, we want a new
    `development` environment). The environment definition also includes custom configurations
    that make sense for the consuming team to parameterize. In this case, because
    we will install the Conference application, we want to enable teams to decide
    if the infrastructure components need to be installed or not.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 创建理解开发环境请求的新 API。
- en: '![](../../OEBPS/Images/06-03.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/06-03.png)'
- en: Figure 6.3 Environment resource defined by the Platform API
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 平台 API 定义的资源环境
- en: It is important to note that the `Environment` interface shouldn’t include (or
    leak) any implementation details about our environments. These resources (environments
    in this case) serve as our abstraction layer to hide complexity from our platform
    users about how these environments will be created. The simpler these resources
    are, the better for the platform users. In this example, the platform can use
    the `Environment Type` parameter to decide which environment to create, and we
    can plug in new types as we evolve our platform mechanisms.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是，`Environment` 接口不应包含（或泄露）关于我们环境的任何实现细节。这些资源（在这种情况下是环境）作为我们的抽象层，用于隐藏从平台用户那里隐藏这些环境将如何创建的复杂性。这些资源越简单，对平台用户来说越好。在这个例子中，平台可以使用
    `Environment Type` 参数来决定创建哪种环境，并且随着我们平台机制的演变，我们可以插入新的类型。
- en: Once we recognize which interfaces we need, we can slowly add parameters that
    teams can configure. For our example, it might make sense to parameterize some
    features for the services we want to deploy in our environment if we also want
    the application infrastructure to be created or to connect our services to existing
    components. Figure 6.4 shows the definition of an environment that requires the
    platform to install the application infrastructure that the services need. We
    also want to enable some debug features on our Frontend service. The possibilities
    here are endless, depending on what makes sense for your teams to parameterize.
    The platform team can control what is possible and what is not. Expanding the
    environment interface to cover more use cases can look like figure 6.4.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们认识到需要哪些接口，我们就可以逐渐添加团队可以配置的参数。对于我们的示例，如果我们还想创建应用程序基础设施或连接我们的服务到现有组件，那么为我们在环境中要部署的服务参数化一些功能可能是有意义的。图
    6.4 显示了需要平台安装所需应用程序基础设施的环境定义。我们还想在我们的前端服务上启用一些调试功能。这里的可能性是无限的，具体取决于对您的团队来说什么是有意义的参数化。平台团队可以控制什么可行，什么不可行。扩展环境接口以涵盖更多用例可能看起来像图
    6.4。
- en: '![](../../OEBPS/Images/06-04.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/06-04.png)'
- en: Figure 6.4 Extended environment resource to enable/disable the application’s
    services.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 扩展环境资源以启用/禁用应用程序的服务。
- en: Encoding this environment resource into a format like JSON or YAML to implement
    the platform API is straightforward, as shown in listing 6.1.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 将此环境资源编码为 JSON 或 YAML 等格式以实现平台 API 是直接的，如列表 6.1 所示。
- en: Listing 6.1 Environment definition in JSON format
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.1 JSON 格式中的环境定义
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once the interface is defined, the next logical step is to provide one implementation
    to provision these environments for our platform users. Before jumping into implementation
    details, we need to cover two of the main challenges you will face when deciding
    where the mechanisms for implementing these environments will reside.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了接口，下一步合乎逻辑的步骤是为我们的平台用户提供这些环境的实施。在深入实现细节之前，我们需要解决两个主要挑战，这些挑战是在决定实现这些环境的机制将驻留何处时您将面临的。
- en: Note When building these interfaces, we are designing user experiences. From
    a platform engineering perspective, consider these interfaces as layers we are
    building to simplify how teams interact with our platform. But it is also important
    to recognize that we are not trying to build a black-box approach where this interface
    is the only way of interacting with our platform. If teams have the technical
    experience to interact with the underlying layers and tools, they should be able
    to do so.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在构建这些接口时，我们正在设计用户体验。从平台工程的角度来看，将这些接口视为我们正在构建的层，以简化团队与我们的平台交互的方式。但我们也必须认识到，我们并不是试图构建一个黑盒方法，其中这个接口是唯一与我们的平台交互的方式。如果团队有与底层层和工具交互的技术经验，他们应该能够这样做。
- en: 6.2 Platform architecture
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 平台架构
- en: This section discusses how we’ll architect our platform. On the technical side
    of building platforms, we will encounter challenges requiring the platform team
    to make some hard choices. In this section, we will talk about how we can architect
    a platform that allows us to encapsulate a set of tools behind our platform APIs
    and enable development teams to perform their tasks without worrying about which
    tools are being used by the platform to provision and wire up complex resources.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论我们将如何构建我们的平台。在构建平台的技术方面，我们将遇到需要平台团队做出一些艰难选择的挑战。在本节中，我们将讨论如何构建一个平台，使我们能够将一组工具封装在我们的平台
    API 后面，并使开发团队能够执行他们的任务，而无需担心平台使用哪些工具来提供和连接复杂资源。
- en: Because we are already using Kubernetes to deploy our workloads in the Conference
    application, it also makes sense to run the platform services on top of Kubernetes,
    right? But would you run the platform services and components right beside your
    workloads? Probably not. Let’s step back a bit.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在会议应用程序中使用 Kubernetes 来部署我们的工作负载，因此将平台服务运行在 Kubernetes 之上也是合理的，对吧？但是，您会在工作负载旁边运行平台服务和组件吗？可能不会。让我们稍微退后一步。
- en: If your organization adopts Kubernetes, you will likely already deal with multiple
    Kubernetes clusters. As discussed in chapter 4, your organization probably has
    production, staging, or QA environments already in place. If you want your application
    development teams to work on environments that feel like the production environment,
    you must enable them with Kubernetes clusters.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的组织采用Kubernetes，您可能已经处理了多个Kubernetes集群。如第4章所述，您的组织可能已经建立了生产、预演或QA环境。如果您希望应用程序开发团队在感觉像生产环境的环境中工作，您必须通过Kubernetes集群来使他们具备这种能力。
- en: Figure 6.5 shows a typical distribution of Kubernetes clusters inside an organization,
    where tons of small clusters might be created for short periods for development
    purposes. One or more mid-size clusters can be used for staging and testing purposes;
    these clusters tend to stay the same as they might be purposefully created to
    run performance tests or a large set of integration tests. Finally, one or more
    large clusters are created for running our production workloads. Depending on
    how many regions we want to cover, we might need multiple production clusters
    that are geographically distributed. The configuration of these clusters is static
    and does not change. In contrast with development and testing clusters, production
    clusters are the responsibility of Site Reliability Engineering teams, ensuring
    that these clusters and the applications running on them are up and running 24/7.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5展示了组织内部Kubernetes集群的典型分布，其中可能会为开发目的在短时间内创建大量小型集群。一个或多个中等规模的集群可用于预演和测试目的；这些集群往往保持不变，因为它们可能是为了运行性能测试或大量集成测试而有意创建的。最后，创建一个或多个大型集群用于运行我们的生产工作负载。根据我们想要覆盖多少地区，我们可能需要多个地理分布的生产集群。这些集群的配置是静态的，不会改变。与开发和测试集群相比，生产集群是站点可靠性工程团队的责任，确保这些集群及其上运行的应用程序全天候正常运行。
- en: '![](../../OEBPS/Images/06-05.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图6.5](../../OEBPS/Images/06-05.png)'
- en: Figure 6.5 Environment clusters, in case you want to enable developers to have
    their own environments.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 环境集群，如果您想使开发者能够拥有自己的环境。
- en: 'While the production cluster(s) and staging/QA cluster(s) should be handled
    carefully and hardened to serve real-life traffic, development environments tend
    to be more ephemeral and sometimes even run on the development team laptops. Certainly,
    you don’t want to run any platform-related tools in any of these environments.
    The reason is simple: tools like Crossplane, ArgoCD, or Tekton shouldn’t be competing
    for resources with our application’s workloads. Security considerations might
    apply too; we don’t want our application’s security compromised due to a vulnerability
    in our platform tools.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然生产集群和预演/QA集群应谨慎处理并加固以处理真实流量，但开发环境往往更短暂，有时甚至运行在开发团队的笔记本电脑上。当然，您不希望在任何一个环境中运行任何与平台相关的工具。原因很简单：像Crossplane、ArgoCD或Tekton这样的工具不应与我们的应用程序工作负载竞争资源。安全考虑也可能适用；我们不希望我们的应用程序的安全因平台工具中的漏洞而受到损害。
- en: When looking at building platforms on top of Kubernetes, teams tend to create
    one or more special clusters to run platform-specific tools. The terms still need
    to be standardized, but creating a platform or management cluster to install platform-wide
    tools is becoming increasingly popular.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑在Kubernetes之上构建平台时，团队往往会创建一个或多个特殊集群来运行平台特定的工具。术语仍需标准化，但创建一个平台或管理集群来安装平台级工具正变得越来越流行。
- en: Figure 6.6 shows how by having separate platform cluster(s), you can install
    the tools that you need to implement your platform capabilities while at the same
    time building a set of management tools to control environments where your workloads
    run.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6展示了通过拥有独立的平台集群，您可以在同时构建一套管理工具来控制工作负载运行的环境的同时，安装实现平台功能所需的工具。
- en: '![](../../OEBPS/Images/06-06.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图6.6](../../OEBPS/Images/06-06.png)'
- en: Figure 6.6 Platform cluster with platform tools managing environments
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 平台集群与平台工具管理环境
- en: Now that you have a separate place to install these tools, you can also host
    the platform API on this cluster, once again, to not overload your workload clusters
    with platform components. Wouldn’t it be great to reuse or extend the Kubernetes
    API to serve also as our platform API? There are pros and cons to this approach.
    For example, suppose we want our platform API to follow Kubernetes conventions
    and behaviors. In that case, our platform will use the declarative nature of Kubernetes
    and promote all the best practices followed by the Kubernetes APIs, such as versioning,
    the resource model, etc. This API might be too complex for non-Kubernetes users,
    or the organization might follow other standards when creating new APIs that do
    not match the Kubernetes style. *If we reuse the Kubernetes APIs for our platform
    APIs, all the CNCF tools designed to work with these APIs will automatically work
    with our platform.* Our platform automatically becomes part of the ecosystem.
    In the last couple of years, I’ve seen a trend around teams adopting the Kubernetes
    APIs as their platform APIs. How much you lean on the Kubernetes APIs is a decision
    that platform engineering teams will need to make, and there are always tradeoffs.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了一个单独的地方来安装这些工具，你还可以在这个集群上托管平台API，再次避免让你的工作负载集群因平台组件而超载。如果能够重用或扩展Kubernetes
    API以作为我们的平台API，那岂不是很好？这种做法有优点也有缺点。例如，如果我们希望我们的平台API遵循Kubernetes的约定和行为，那么我们的平台将使用Kubernetes的声明性特性，并推广Kubernetes
    API遵循的所有最佳实践，例如版本控制、资源模型等。这个API可能对非Kubernetes用户来说过于复杂，或者组织在创建不遵循Kubernetes风格的API时可能会遵循其他标准。*如果我们重用Kubernetes
    API作为我们的平台API，所有为这些API设计的CNCF工具将自动与我们的平台一起工作。*我们的平台自动成为生态系统的一部分。在过去的几年里，我看到了一个趋势，即团队采用Kubernetes
    API作为他们的平台API。你依赖于Kubernetes API的程度是平台工程团队需要做出的决定，而且总是有权衡。
- en: Figure 6.7 shows the relationship between having the Kubernetes APIs to use
    the CNCF and cloud-native ecosystem while at the same time exposing an organization-specific
    API that follows company standards on how APIs should be created. To make sure
    that the message is clear, these are not exclusive, and as we will see in section
    6.3, it makes a lot of sense to have both.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7展示了在同时使用CNCF和云原生生态系统中的Kubernetes API的同时，暴露一个遵循公司标准的特定组织API的关系。为了确保信息清晰，这些不是互斥的，正如我们将在第6.3节中看到的，同时拥有两者是非常有意义的。
- en: '![](../../OEBPS/Images/06-07.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图6.7](../../OEBPS/Images/06-07.png)'
- en: Figure 6.7 Kubernetes-based platform APIs complemented by company-specific APIs
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7基于Kubernetes的平台API与公司特定API的互补
- en: Adopting the Kubernetes APIs for your platform API doesn’t stop you from building
    a layer on top for other tools to consume or to follow the company’s standards.
    By having a Kubernetes-based API layer, you can access all the amazing tools created
    in the CNCF and cloud-native space. On top of the Kubernetes-based APIs, another
    layer can follow company standards and conformance checks, enabling easier integrations
    with other existing systems.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 采用Kubernetes API作为你的平台API不会阻止你构建一个层，以便其他工具消费或遵循公司的标准。通过拥有基于Kubernetes的API层，你可以访问CNCF和云原生空间中创建的所有令人惊叹的工具。在基于Kubernetes的API之上，可以再添加一层，遵循公司标准和合规性检查，从而更容易与其他现有系统集成。
- en: Following our previous example, we can extend Kubernetes to understand our environment
    requests and provide the mechanisms to define how these environments will be provisioned.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，我们可以扩展Kubernetes以理解我们的环境请求，并提供定义这些环境如何配置的机制。
- en: Figure 6.8 shows a Kubernetes resource used to define our environments. This
    resource can be sent to a Kubernetes API server with an installed set of extensions
    to understand what to do when a new environment definition arrives.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8展示了用于定义我们环境的Kubernetes资源。这个资源可以被发送到安装了扩展集的Kubernetes API服务器，以便理解当新的环境定义到达时应该做什么。
- en: '![](../../OEBPS/Images/06-08.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图6.8](../../OEBPS/Images/06-08.png)'
- en: Figure 6.8 Extending Kubernetes to understand environments and serve as our
    platform APIs
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8扩展Kubernetes以理解环境和作为我们的平台API
- en: In principle, this looks good and doable. Still, before implementing these Kubernetes
    extensions to serve as our platform API and central hub of platform tooling, we
    need to understand the questions that our platform implementation will try to
    answer. Let’s look at the main platform challenges that teams in these scenarios
    will face.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在原则上，这似乎看起来不错且可行。然而，在实现这些Kubernetes扩展以作为我们的平台API和平台工具的中心枢纽之前，我们需要了解我们的平台实现将试图回答的问题。让我们看看在这些场景中团队将面临的主要平台挑战。
- en: 6.2.1 Platform challenges
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.1 平台挑战
- en: Sooner or later, if you are dealing with multiple Kubernetes clusters, you must
    manage them and all the resources related to these clusters. What does it take
    to manage all these resources? The first step to understanding the underlying
    problems is to understand who the users of our platforms are. Are we building
    a platform for external customers or internal teams? What are their needs and
    the level of isolation that they need to operate autonomously without bothering
    their neighbors? What guardrails do they need to be successful?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时，如果你在处理多个Kubernetes集群，你必须管理它们以及与这些集群相关的所有资源。要管理所有这些资源需要什么？理解潜在问题的第一步是了解我们平台的使用者是谁。我们是在为外部客户还是内部团队构建平台？他们的需求是什么，他们需要达到何种隔离水平才能在没有打扰邻居的情况下独立操作？他们需要哪些指导方针才能成功？
- en: While I cannot answer these questions for all use cases, one thing is clear—platform
    tools and workloads need to be separated. We need to encode in our platform our
    tenant boundaries based on each tenant’s expectations. No matter if these tenants
    are customers or internal teams. We must set clear expectations about our tenancy
    model and guarantees for our platform users, so they understand the limitations
    of the resources the platform gives them to do their work.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我不能为所有用例回答这些问题，但有一点很清楚——平台工具和工作负载需要分离。我们需要在我们的平台中编码基于每个租户期望的租户边界。无论这些租户是客户还是内部团队，我们都必须明确设定关于我们的租户模型和平台用户的保证，以便他们了解平台提供给他们的资源限制，以便他们完成工作。
- en: 'The platform we will build needs to encode all these decisions. In the following
    two sections, we will look at the two most common decisions that platform teams
    will need to make early in their journey: (1) managing more than one cluster and
    (2) isolation and multi-tenancy.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的平台需要编码所有这些决策。在接下来的两个部分中，我们将探讨平台团队在其旅程早期将需要做出的两个最常见决策：（1）管理多个集群和（2）隔离和多租户。
- en: 6.2.2 Managing more than one cluster
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.2 管理多个集群
- en: The platform we will build needs to manage and understand which environments
    are available for teams. More importantly, it should enable the team to request
    their own environments whenever needed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的平台需要管理和理解哪些环境可供团队使用。更重要的是，它应该允许团队在需要时请求自己的环境。
- en: Using the Kubernetes APIs as our platform API to request environments, we can
    use tools like ArgoCD (covered in chapter 4) to persist and sync our environment
    configurations to live Kubernetes clusters. Managing our clusters and environments
    becomes just managing Kubernetes resources that must be synced to our platform
    cluster(s).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Kubernetes API作为我们的平台API来请求环境，我们可以使用像ArgoCD（在第4章中介绍）这样的工具来持久化和同步我们的环境配置到实际的Kubernetes集群。管理我们的集群和环境变成了仅仅管理必须同步到我们的平台集群（们）的Kubernetes资源。
- en: Figure 6.9 shows using two tools that we have already used (Crossplane and ArgoCD)
    for our Conference application but use now in the context of managing platform-wide
    resources.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9展示了使用我们已经使用过的两个工具（Crossplane和ArgoCD）来管理我们的会议应用程序，但现在是在管理平台级资源的环境中。
- en: By combining tools like ArgoCD and Crossplane inside our platform clusters,
    we promote the techniques we discussed in chapter 4 for environment pipelines,
    which sync application-level components which we now use for managing high-level
    platform concerns. In this case, tools like Crossplane can help us provision full-fledged
    environments on cloud providers.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在我们的平台集群内部结合像ArgoCD和Crossplane这样的工具，我们推广了在第4章中讨论的技术，即环境管道技术，这些技术同步应用级别的组件，我们现在使用它们来管理高级平台问题。在这种情况下，像Crossplane这样的工具可以帮助我们在云提供商上配置完整的平台环境。
- en: '![](../../OEBPS/Images/06-09.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图6.9](../../OEBPS/Images/06-09.png)'
- en: Figure 6.9 Combining GitOps and Crossplane for managing environments and clusters
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.9 结合GitOps和Crossplane来管理和环境集群](../../OEBPS/Images/06-09.png)'
- en: As you can see in the previous figure, our platform configuration itself will
    become more complex, because it will need to have its source of truth (Git repository)
    to store the environment and resources that the platform manages. It will also
    need to have access to a secret store, such as HashiCorp Vault, to enable Crossplane
    to connect and create resources in different cloud providers. In other words,
    you now have two extra concerns. First, you will need to define, configure, and
    give access to one or more Git repositories to contain the configurations for
    the resources created in the platform. Second, you must manage a set of cloud
    provider accounts and their credentials so the platform cluster(s) can access
    and use these accounts.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的图中所见，我们的平台配置本身将变得更加复杂，因为它需要有一个真实来源（Git 仓库）来存储平台管理的环境和资源。它还需要访问一个密钥存储库，如
    HashiCorp Vault，以使 Crossplane 能够连接并创建不同云提供商中的资源。换句话说，您现在有两个额外的关注点。首先，您需要定义、配置并授予访问权限给一个或多个
    Git 仓库以包含平台中创建的资源配置。其次，您必须管理一组云提供商账户及其凭证，以便平台集群可以访问和使用这些账户。
- en: If you can manage all the platform resources like your workloads (using a GitOps
    approach, managing credentials and users, and exposing the right abstractions/APIs),
    the platform artifacts become just an extension of your development and continuous
    delivery practices.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您能够像管理您的作业（使用 GitOps 方法、管理凭证和用户、以及公开正确的抽象/API）一样管理所有平台资源，平台工件就只是您开发和持续交付实践的扩展。
- en: While the example in section 6.3 doesn’t focus on configuring all these concerns,
    it provides a nice playground to build on top and experiment with more advanced
    setups depending on your teams’ requirements.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然第 6.3 节的示例没有专注于配置所有这些关注点，但它提供了一个很好的游乐场，可以在其基础上构建并根据自己的团队需求进行更高级的设置实验。
- en: I recommend prioritizing which configurations make sense to understand what
    your teams or tenants will do with the resources, expectations, and requirements.
    Let’s dig a bit more into that space.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议优先考虑哪些配置是有意义的，以便了解您的团队或租户将如何使用资源、期望和要求。让我们更深入地探讨这个领域。
- en: 6.2.3 Isolation and multi-tenancy
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.3 隔离和多租户
- en: Depending on your tenants’ (teams, internal or external customers) requirements,
    you might need to create different isolation levels, so they don’t disturb each
    other when working under the same platform roof.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的租户（团队、内部或外部客户）的需求，您可能需要创建不同的隔离级别，这样他们在同一平台屋顶下工作时不会相互干扰。
- en: Multi-tenancy is a complicated topic in the Kubernetes ecosystem. Using Kubernetes
    RBAC (role-based access control), Kubernetes Namespaces, and multiple Kubernetes
    controllers that might have been designed with different tenancy models makes
    it hard to define isolation levels between tenants inside the same cluster.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 多租户是 Kubernetes 生态系统中的一个复杂话题。使用 Kubernetes RBAC（基于角色的访问控制）、Kubernetes 命名空间以及可能设计有不同租户模型的多重
    Kubernetes 控制器使得在同一个集群内定义租户之间的隔离级别变得困难。
- en: 'Companies embarking on adopting Kubernetes tend to take one of the following
    approaches for isolation:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正在采用 Kubernetes 的公司倾向于采取以下一种隔离方法：
- en: 'Kubernetes Namespaces:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 命名空间：
- en: 'Pros:'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优点：
- en: Creating namespaces is very easy, and it has almost zero overhead.
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建命名空间非常简单，并且几乎没有开销。
- en: Creating namespaces is cheap, because it is just a logical boundary that Kubernetes
    uses to separate resources inside the cluster.
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建命名空间成本很低，因为它只是 Kubernetes 用来在集群内部部分隔资源的逻辑边界。
- en: 'Cons:'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺点：
- en: Isolation between namespaces is very basic, and it will require RBAC roles to
    limit users’ visibility outside the namespaces they have been assigned. Resource
    quotas must also be defined to ensure that a single namespace is not consuming
    all the cluster resources.
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间之间的隔离非常基础，它将需要 RBAC 角色来限制用户在他们被分配的命名空间之外的可视性。还必须定义资源配额以确保单个命名空间不会消耗所有集群资源。
- en: Providing access to a single namespace requires sharing access to the same Kubernetes
    APIs endpoints that admins and all the other tenants are using. This limits the
    operations clients can execute on the cluster, such as installing cluster-wide
    resources.
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供对单个命名空间的访问需要共享与管理员和所有其他租户使用的相同 Kubernetes API 端点。这限制了客户端可以在集群上执行的操作，例如安装集群范围内的资源。
- en: All the tenants will be interacting against the same Kubernetes API server,
    which might cause problems depending on the scale and the needs of each of the
    tenants.
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有租户都将与同一个 Kubernetes API 服务器交互，这可能会根据每个租户的规模和需求引起问题。
- en: Sharing the same Kubernetes API server limits the cluster-wide resources that
    can be installed in the cluster. For example, installing two different versions
    of the same extensions is not possible.
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享相同的 Kubernetes API 服务器限制了可以在集群中安装的全局资源。例如，安装同一扩展的两个不同版本是不可能的。
- en: 'Kubernetes clusters:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 集群：
- en: 'Pros:'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优点：
- en: Users interacting with different clusters can have full admin capabilities enabling
    them to install as many tools as they need.
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与不同集群交互的用户可以拥有完整的管理员权限，使他们能够安装他们需要的任何工具。
- en: You have full isolation between clusters, and tenants connecting to different
    clusters will not share the same Kubernetes API server endpoints. Each cluster
    can have different configurations for how scalable and resilient they are. This
    allows you to define different tenants’ categories based on their requirements.
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在集群之间实现完全隔离，连接到不同集群的租户不会共享相同的 Kubernetes API 服务器端点。每个集群都可以有不同的配置，以确定其可扩展性和弹性。这允许您根据其需求定义不同的租户类别。
- en: 'Cons:'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺点：
- en: This approach is expensive, as you will be paying for computing resources to
    run Kubernetes. The more clusters you create, the more money you will spend running
    Kubernetes.
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种方法成本高昂，因为您将支付运行 Kubernetes 的计算资源费用。您创建的集群越多，运行 Kubernetes 的费用就越高。
- en: Managing multiple Kubernetes clusters becomes complex if you enable teams to
    create (or request) their own. Zombie clusters (clusters nobody uses and are abandoned)
    start to pop up, wasting valuable resources.
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您允许团队创建（或请求）他们自己的集群，管理多个 Kubernetes 集群会变得复杂。僵尸集群（无人使用且被遗弃的集群）开始出现，浪费了宝贵的资源。
- en: Sharing resources, installing, and maintaining tools across a fleet of different
    Kubernetes clusters is challenging and a full-time job.
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个不同的 Kubernetes 集群之间共享资源、安装和维护工具具有挑战性，并且是一项全职工作。
- en: Based on my experience, teams will create isolated Kubernetes clusters for sensitive
    environments such as production environments and performance testing. These sensitive
    environments tend to stay the same and are only managed by operation and site
    reliability teams. Using a big cluster with namespaces is a common practice when
    you shift towards development teams and more ephemeral environments for testing
    or day-to-day development tasks.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，团队会为敏感环境，如生产环境和性能测试，创建隔离的 Kubernetes 集群。这些敏感环境通常保持不变，并且仅由运维和站点可靠性团队管理。当您转向开发团队和更短暂的测试或日常开发任务环境时，使用带有命名空间的集群是一种常见做法。
- en: Choosing between these two options is hard, but what is important is not to
    overcommit to just a single option. Different teams might have different requirements,
    so in the next section, we will look at how the platform can abstract these decisions,
    enabling teams to access different setups depending on their needs.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种选项之间做出选择很难，但重要的是不要过度承诺于单一选项。不同的团队可能有不同的需求，因此在下文中，我们将探讨平台如何抽象这些决策，使团队能够根据他们的需求访问不同的配置。
- en: My recommendation for platform teams making these decisions is to build and
    have practices in place that enable you to pivot from one solution to another.
    Starting with simple solutions such as namespace isolation is quite common, but
    after a while, when having a single cluster with tons of namespaces is not enough,
    you need a more robust plan. To make this decision easier, ask yourself if your
    consumers need access to the Kubernetes APIs. If they don’t, you might want to
    evaluate following an approach similar to Google Cloud Run ([https://cloud.google.com/run](https://cloud.google.com/run)),
    Azure Container Apps ([https://azure.microsoft.com/en-us/products/container-apps](https://azure.microsoft.com/en-us/products/container-apps)
    ), or AWS App Runner ([https://aws.amazon.com/apprunner/](https://aws.amazon.com/apprunner/)),
    which enables teams to run containers without the need of accessing the orchestrator
    APIs.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我对做出这些决策的平台团队的建议是，建立并实施能够让您从一种解决方案切换到另一种解决方案的实践。从简单的解决方案，如命名空间隔离开始是很常见的，但过了一段时间，当单个集群和大量命名空间不足以满足需求时，您需要更稳健的计划。为了使这个决定更容易，问问自己您的消费者是否需要访问
    Kubernetes API。如果他们不需要，您可能希望评估采用类似于 Google Cloud Run ([https://cloud.google.com/run](https://cloud.google.com/run))、Azure
    Container Apps ([https://azure.microsoft.com/en-us/products/container-apps](https://azure.microsoft.com/en-us/products/container-apps))
    或 AWS App Runner ([https://aws.amazon.com/apprunner/](https://aws.amazon.com/apprunner/))
    的方法，这些方法使团队能够在不访问编排器 API 的情况下运行容器。
- en: 6.3 Our platform walking skeleton
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 我们的平台原型
- en: This section looks into creating a simple platform allowing internal teams to
    create development environments. Because our teams are deploying the conference
    application to Kubernetes clusters, we want to offer them the same developer experience.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨了创建一个简单的平台，允许内部团队创建开发环境。由于我们的团队正在将会议应用程序部署到Kubernetes集群中，我们希望为他们提供相同的开发者体验。
- en: Note You can follow a step-by-step tutorial, where you will install and interact
    with the platform walking skeleton at [https://github.com/salaboy/platforms-on-k8s/tree/main/chapter-6](https://github.com/salaboy/platforms-on-k8s/tree/main/chapter-6).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可以通过一个逐步教程来跟随，在该教程中，您将安装并交互使用平台行走骨架，请参阅[https://github.com/salaboy/platforms-on-k8s/tree/main/chapter-6](https://github.com/salaboy/platforms-on-k8s/tree/main/chapter-6)。
- en: To achieve this, we will use some tools that we used before, like Crossplane,
    to extend Kubernetes to understand development environments. Then, we will use
    a project called `vcluster` ([https://vcluster.com](https://vcluster.com)) to
    provision small Kubernetes clusters for our teams. These clusters are isolated,
    allowing teams to install extra tools without worrying about what other teams
    are doing. Because teams will have access to the Kubernetes APIs, they can do
    whatever they need with the cluster without requesting complicated permissions
    to debug their workloads.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将使用之前使用的一些工具，如Crossplane，来扩展Kubernetes以理解开发环境。然后，我们将使用一个名为`vcluster`的项目([https://vcluster.com](https://vcluster.com))为我们的团队提供小型Kubernetes集群。这些集群是隔离的，允许团队安装额外的工具而不用担心其他团队正在做什么。因为团队将能够访问Kubernetes
    API，他们可以自由地对集群进行操作，而无需请求复杂的权限来调试他们的工作负载。
- en: Figure 6.10 shows how the process works. Teams can request new environments
    by creating environment Kubernetes resources. The platform will take these resources
    and provision small Kubernetes clusters with `vcluster` for them to use. We will
    keep things simple for the walking skeleton, but the platforms are complicated.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10展示了这个过程是如何工作的。团队可以通过创建环境Kubernetes资源来请求新的环境。平台将获取这些资源，并为它们使用`vcluster`提供小型Kubernetes集群。对于这个行走骨架，我们将保持简单，但平台本身是复杂的。
- en: '![](../../OEBPS/Images/06-10.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/06-10.png)'
- en: Figure 6.10 Building a platform prototype to provision development environments
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10 构建一个平台原型以提供开发环境
- en: I can’t stress enough the importance that this example, on purpose, is using
    existing tools instead of creating our custom Kubernetes extensions. If you create
    custom controllers to manage environments, you create a complex component that
    will require maintenance and probably overlaps 95% with the mechanisms shown in
    this example. In other words, no custom Kubernetes controllers have been created
    while building this example.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须强调，这个例子故意使用现有工具而不是创建我们自己的自定义Kubernetes扩展的重要性。如果你创建自定义控制器来管理环境，你将创建一个复杂的组件，这将需要维护，并且可能与本例中展示的机制重叠95%。换句话说，在构建这个例子时，没有创建任何自定义Kubernetes控制器。
- en: In the same way that we started this chapter talking about our platform APIs,
    let’s look at how we can build these APIs without creating custom Kubernetes extensions
    that we will need to test, maintain, and release. We will use Crossplane compositions
    as we did for our databases and message brokers in chapter 5, but now we will
    implement our environment custom Crossplane Composition Resource Definition. We
    can keep the environment resource simple and use Kubernetes label matches and
    selectors to match a resource with one of the possible compositions we can create
    to provision our environments.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章开头讨论我们的平台API时一样，让我们看看我们如何构建这些API，而不需要创建我们需要测试、维护和发布的自定义Kubernetes扩展。我们将使用与第5章中我们的数据库和消息代理相同的Crossplane组合，但现在我们将实现我们的环境自定义Crossplane组合资源定义。我们可以保持环境资源简单，并使用Kubernetes标签匹配和选择器来匹配一个资源与我们可以创建的可能的组合之一，以提供我们的环境。
- en: Figure 6.11 shows how changing a property/label from our environment helps Crossplane
    to pick the right composition for our team.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11展示了如何通过更改环境中的属性/标签来帮助Crossplane为我们的团队选择正确的组合。
- en: '![](../../OEBPS/Images/06-11.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/06-11.png)'
- en: Figure 6.11 Mapping environment resources to Crossplane compositions
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11 将环境资源映射到Crossplane组合
- en: Crossplane compositions offer the flexibility to use different providers to
    provision and configure resources together, and as we saw in chapter 5, multiple
    compositions (implementations) can be provided for different kinds of environments.
    For this example, we want each environment to be isolated from the other to avoid
    teams unintentionally deleting others’ team resources. The two most intuitive
    ways of creating isolated environments would be to create a new namespace per
    environment or a full-blown Kubernetes cluster for each environment.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Crossplane 组合提供了使用不同的提供程序一起配置和部署资源的灵活性，正如我们在第 5 章中看到的，可以为不同类型的多个环境提供不同的组合（实现）。对于这个例子，我们希望每个环境都能与其他环境隔离，以避免团队无意中删除其他团队的资源。创建隔离环境的最直观的两种方式可能是为每个环境创建一个新的命名空间，或者为每个环境创建一个完整的
    Kubernetes 集群。
- en: Figure 6.12 shows how another Crossplane provider (called Kubernetes provider)
    can be used to create Kubernetes resources such as Namespaces. This compares against
    using a cloud-provider Crossplane provider that enables us to create a full-blown
    cluster, in this case in Google Cloud Platform (GCP). Once we have a cluster,
    we can install our Conference application Helm Chart.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12 展示了如何使用另一个 Crossplane 提供程序（称为 Kubernetes 提供程序）来创建 Kubernetes 资源，例如命名空间。这与使用允许我们创建完整集群的云提供商
    Crossplane 提供程序形成对比，在这种情况下是在 Google Cloud Platform（GCP）中。一旦我们有一个集群，我们就可以安装我们的会议应用程序
    Helm 图表。
- en: '![](../../OEBPS/Images/06-12.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/06-12.png)'
- en: Figure 6.12 Different environment compositions, Namespace, and GKECluster
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12 不同环境组成、命名空间和 GKECluster
- en: While creating a fully-fledged Kubernetes cluster might be overkill for every
    development team, a Kubernetes Namespace might not provide enough isolation for
    your use case, because all teams will interact with the same Kubernetes API server.
    For this reason, we will use `vcluster` in conjunction with the Crossplane Helm
    provider, which gives us the best of both worlds without the costs of creating
    new clusters. Figure 6.13 shows how we can reuse the Crossplane Helm provider
    to create `vclusters`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然为每个开发团队创建一个完整的 Kubernetes 集群可能有些过度，但 Kubernetes 命名空间可能不足以满足你的使用案例，因为所有团队都将与同一个
    Kubernetes API 服务器交互。因此，我们将使用 `vcluster` 与 Crossplane Helm 提供程序结合使用，这让我们在不需要创建新集群的成本下，获得了两者的最佳之处。图
    6.13 展示了我们可以如何重复使用 Crossplane Helm 提供程序来创建 `vclusters`。
- en: '![](../../OEBPS/Images/06-13.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/06-13.png)'
- en: Figure 6.13 Using vcluster to create isolated environments
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.13 使用 vcluster 创建隔离环境
- en: 'You might be wondering: what is a `vcluster`? And why are we using the Crossplane
    Helm provider to create one? While `vcluster` is just another option that you
    can use to build your platforms, I consider it a key tool in every platform engineer
    toolbox.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道：什么是 `vcluster`？为什么我们要使用 Crossplane Helm 提供程序来创建一个？虽然 `vcluster` 只是你可以使用来构建你的平台的选择之一，但我认为它是每个平台工程师工具箱中的关键工具。
- en: 6.3.1 vcluster for virtual Kubernetes clusters
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.1 vcluster 用于虚拟 Kubernetes 集群
- en: I am a big fan of the `vcluster` project. If you are discussing multi-tenancy
    on top of Kubernetes, `vcluster` tends to pop up in the conversation, because
    it offers a really nice alternative to the Kubernetes Namespaces vs. Kubernetes
    clusters discussions.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我是非常喜欢 `vcluster` 项目。如果你在讨论基于 Kubernetes 的多租户，`vcluster` 往往会在对话中出现，因为它为 Kubernetes
    命名空间与 Kubernetes 集群之间的讨论提供了一个非常好的替代方案。
- en: '`vcluster` focuses on providing Kubernetes API server isolation between different
    tenants by creating virtual clusters inside your existing Kubernetes cluster (host
    cluster). Figure 6.14 shows how `vcluster` works inside an existing Kubernetes
    cluster (HOST).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`vcluster` 通过在现有的 Kubernetes 集群（宿主集群）内部创建虚拟集群，专注于为不同的租户提供 Kubernetes API 服务器隔离。图
    6.14 展示了 `vcluster` 在现有 Kubernetes 集群（宿主）内部的工作方式。'
- en: '![](../../OEBPS/Images/06-14.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/06-14.png)'
- en: Figure 6.14 vcluster provides isolation at the Kubernetes (K8s) API server
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.14 vcluster 在 Kubernetes (K8s) API 服务器上提供隔离
- en: By creating new virtual clusters, we can share an isolated API server with tenants
    where they can do whatever they need without worrying about what other tenants
    are doing or installing. For scenarios where you want each tenant to have cluster-wide
    access and full control of the Kubernetes API server, `vcluster` provides a simple
    alternative to implement this. If you don’t need to provide your teams with access
    to the Kubernetes APIs, I recommend using the namespace approach mentioned before.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建新的虚拟集群，我们可以与租户共享一个隔离的API服务器，他们可以在其中做任何需要的事情，无需担心其他租户正在做什么或安装什么。对于希望每个租户都能拥有集群级访问权限和完全控制Kubernetes
    API服务器的场景，`vcluster`提供了一个简单的替代方案来实现这一点。如果你不需要为你的团队提供访问Kubernetes API的权限，我建议使用之前提到的命名空间方法。
- en: 'Creating a `vcluster` is easy: you can create a new `vcluster` by installing
    the `vcluster` Helm Chart. Alternatively, you can use the `vcluster` CLI to create
    one and connect to it.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`vcluster`很简单：你可以通过安装`vcluster` Helm图表来创建一个新的`vcluster`。或者，你可以使用`vcluster`
    CLI来创建一个并连接到它。
- en: Finally, a great table comparing `vcluster`, Kubernetes Namespaces and Kubernetes
    clusters can be found in their documentation. If you are already having these
    conversations with your teams, this table explains the advantages and tradeoffs
    in crystal clear language (figure 6.15).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以在他们的文档中找到一个很好的比较`vcluster`、Kubernetes Namespaces和Kubernetes集群的表格。如果你已经与你的团队进行了这些对话，这个表格以清晰的语言解释了优势和权衡（图6.15）。
- en: '![](../../OEBPS/Images/06-15.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/06-15.png)'
- en: Figure 6.15 Pros and cons of Kubernetes Namespaces vs. vcluster vs. Kubernetes
    cluster tenants
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15 Kubernetes Namespaces与vcluster与Kubernetes集群租户的优缺点
- en: I strongly recommend checking their website ([https://vcluster.com](https://vcluster.com))
    and the blog post available at [https://www.salaboy.com/2023/06/19/cost-effective-multi-tenancy-on-kubernetes/](https://www.salaboy.com/2023/06/19/cost-effective-multi-tenancy-on-kubernetes/)
    to learn more about this project and how it can help your teams provision cost-effective
    clusters.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议查看他们的网站([https://vcluster.com](https://vcluster.com))和可用的博客文章[https://www.salaboy.com/2023/06/19/cost-effective-multi-tenancy-on-kubernetes/](https://www.salaboy.com/2023/06/19/cost-effective-multi-tenancy-on-kubernetes/)，以了解更多关于这个项目以及它如何帮助你的团队配置成本效益高的集群。
- en: Next, let’s see what our platform walking skeleton looks like for teams that
    want to create, connect, and work against new environments that use `vcluster`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们的平台行走骨架对于想要创建、连接并针对使用`vcluster`的新环境工作的团队是什么样的。
- en: 6.3.2 The platform experience
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.2 平台体验
- en: The platform walking skeleton implemented in the GitHub repository at [https://github.com/salaboy/platforms-on-k8s/tree/main/chapter-6](https://github.com/salaboy/platforms-on-k8s/tree/main/chapter-6)
    allows teams connected to the platform API to create new environment resources
    and submit a request for the platform to provision it for them.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub仓库[https://github.com/salaboy/platforms-on-k8s/tree/main/chapter-6](https://github.com/salaboy/platforms-on-k8s/tree/main/chapter-6)中实现的平台行走骨架允许连接到平台API的团队创建新的环境资源，并向平台提交请求以供其为他们配置。
- en: Figure 6.16 shows the architecture for our platform walking skeleton. First,
    application development teams can create requests to the platform APIs for new
    development environments. The platform will provision a new environment—in this
    case, following a Crossplane composition that uses the Crossplane Helm provider
    to create a new virtual cluster (using `vcluster`)—and then install the Conference
    application Helm Chart for development teams to do their work. Second, application
    development teams can connect to this new isolated environment without fearing
    breaking other teams’ setups.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16展示了我们平台行走骨架的架构。首先，应用开发团队可以向平台API提交创建新开发环境的请求。平台将为开发团队配置一个新的环境——在这种情况下，遵循使用Crossplane
    Helm提供程序创建新虚拟集群（使用`vcluster`）的Crossplane组合——然后为开发团队安装Conference应用Helm图表以进行工作。其次，应用开发团队可以连接到这个新的隔离环境，无需担心破坏其他团队的设置。
- en: '![](../../OEBPS/Images/06-16.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/06-16.png)'
- en: Figure 6.16 Using Crossplane and `vcluster` to create isolated environments
    for application development teams
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16 使用Crossplane和`vcluster`为应用开发团队创建隔离环境
- en: Note It makes a lot of sense to have a large cluster to host all the ephemeral
    development environment clusters. The tools we used for building the platform
    walking skeleton can be easily configured to implement that setup, but it is quite
    hard to demonstrate running on a single and local KinD cluster.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：拥有一个大型集群来托管所有临时开发环境集群是非常有意义的。我们用于构建平台行走骨架的工具可以轻松配置以实现该设置，但在单个本地KinD集群上运行则相当困难。
- en: The platform cluster uses Crossplane and Crossplane compositions to define how
    to provision the environment. To run the Crossplane composition in a local Kubernetes
    cluster (and not require access to a specific cloud provider), the walking skeleton
    uses `vcluster` to provision each environment on its own (virtual) Kubernetes
    cluster. Having separate Kubernetes clusters enables teams to connect to these
    environments and do the work they need to do with our Conference application,
    which is by default installed when the environment is created.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 平台集群使用Crossplane和Crossplane组合来定义如何配置环境。为了在一个本地Kubernetes集群中运行Crossplane组合（而不需要访问特定的云提供商），行走骨架使用`vcluster`为其自己的（虚拟）Kubernetes集群配置每个环境。拥有独立的Kubernetes集群使团队能够连接到这些环境，并使用我们默认在创建环境时安装的会议应用程序完成他们需要的工作。
- en: Application teams need to be connected to the platform API (Kubernetes clusters
    hosting the platform tools—in this case, Crossplane and the `vcluster` configurations)
    to request new environments using tools like `kubectl`. For the walking skeleton,
    sending an environment resource to the platform APIs will result in the platform
    provisioning a new `vcluster` that the team can connect to. See listing 6.2, which
    shows an environment resource definition that we can send to the Kubernetes API
    server.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 应用团队需要连接到平台API（托管平台工具的Kubernetes集群——在本例中，是Crossplane和`vcluster`配置），使用如`kubectl`之类的工具来请求新的环境。对于行走骨架，将环境资源发送到平台API将导致平台配置一个新的`vcluster`，团队可以连接到它。请参阅列表6.2，它显示了我们可以发送到Kubernetes
    API服务器的环境资源定义。
- en: Listing 6.2 Environment definition as a Kubernetes resource
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.2 作为Kubernetes资源的环境定义
- en: '[PRE1]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ① The name for the environment that we want to create
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们想要创建的环境名称
- en: ② The type of environment we want is defined using labels
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们想要的环境类型是通过标签定义的
- en: ③ Parameters are custom to your specific use case. Depending on what you want
    to enable teams to configure, you can iteratively define more and more parameters
    for them to fine-tune when requesting environments.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 参数是针对您特定用例定制的。根据您想要使团队能够配置的内容，您可以为他们在请求环境时迭代定义更多和更多的参数以进行微调。
- en: Because these are Kubernetes resources, teams can query these resources using
    `kubectl`, as shown in listing 6.3.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些是Kubernetes资源，团队可以使用`kubectl`查询这些资源，如列表6.3所示。
- en: Listing 6.3 Listing environment resources
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.3 列出环境资源
- en: '[PRE2]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once the environment is ready, teams will be able to connect to it. Because
    we are using `vcluster`, connecting to it is just like connecting to any other
    Kubernetes cluster. Luckily, `vcluster` makes our life easier, and we can use
    their CLI to configure the access tokens for us.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦环境准备就绪，团队就可以连接到它。因为我们使用`vcluster`，连接到它就像连接到任何其他Kubernetes集群一样。幸运的是，`vcluster`使我们的生活变得更简单，我们可以使用它们的CLI为我们配置访问令牌。
- en: 'Running the following command will connect you to the `vcluster` instance that
    has been just created and host the Conference application installed by the Crossplane
    composition:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令将连接到刚刚创建的`vcluster`实例，并托管由Crossplane组合安装的会议应用程序：
- en: '[PRE3]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note When running `vcluster connect`, you are now connected to a new cluster
    context, meaning that if you list all the pods and Namespaces, you will only see
    the resources that are available in this new cluster. You shouldn’t see any Crossplane
    resources, for example.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当运行`vcluster connect`时，您现在连接到了一个新的集群上下文，这意味着如果您列出所有Pod和Namespaces，您将只会看到在这个新集群中可用的资源。您不应该看到任何Crossplane资源，例如。
- en: A natural extension to the walking skeleton would be to use Crossplane compositions
    to create environments spawning Kubernetes clusters on a cloud provider. Managing
    these environment resources inside a Git repository using ArgoCD is also a natural
    step forward. In such cases and in contrast to requiring application development
    teams to connect directly with the platform APIs, teams can request new environments
    by sending a pull request to a repository that can be validated and automatically
    merged.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对行走骨架的自然扩展是使用Crossplane组合在云服务提供商上创建环境，以启动Kubernetes集群。使用ArgoCD在Git仓库内管理这些环境资源也是一个自然的进步。在这种情况下，与要求应用开发团队直接与平台API连接相比，团队可以通过向一个可以验证并自动合并的仓库发送拉取请求来请求新的环境。
- en: The step-by-step tutorial ([https://github.com/salaboy/platforms-on-k8s/tree/main/chapter-6](https://github.com/salaboy/platforms-on-k8s/tree/main/chapter-6))
    finishes by deploying a custom Platform Admin User Interface application. This
    Platform Admin application enables teams to consume the platform features without
    connecting to the Kubernetes platform APIs, commonly called “Click Ops,” because
    we are trying to avoid teams writing complex YAML files or long commands like
    cloud providers do. This application exposes REST endpoints and the functionality
    provided by the user interface to reduce the cognitive load from application teams
    who need to know how the platform is operating behind the covers. Figure 6.17
    shows the Platform Portal admin interface (this is not part of the Conference
    application).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步教程([https://github.com/salaboy/platforms-on-k8s/tree/main/chapter-6](https://github.com/salaboy/platforms-on-k8s/tree/main/chapter-6))以部署自定义平台管理员用户界面应用程序结束。这个平台管理员应用程序使团队能够在不连接到Kubernetes平台API的情况下使用平台功能，通常称为“点击操作”，因为我们试图避免团队编写复杂的YAML文件或像云服务提供商那样执行长命令。此应用程序公开REST端点以及用户界面提供的功能，以减少需要了解平台幕后操作的应用团队的认知负荷。图6.17显示了平台门户管理员界面（这不是会议应用程序的一部分）。
- en: '![](../../OEBPS/Images/06-17.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图6.17](../../OEBPS/Images/06-17.png)'
- en: Figure 6.17 Platform Admin user interface allows teams to create and manage
    environments without connecting to the platform’s Kubernetes APIs.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17 平台管理员用户界面允许团队在不连接到平台Kubernetes API的情况下创建和管理环境。
- en: This Platform Admin application also exposes REST endpoints to perform all the
    actions by sending REST requests, which can be used for further automation and
    integrations with existing systems.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此平台管理员应用程序还公开REST端点，通过发送REST请求执行所有操作，这可以用于进一步的自动化和与现有系统的集成。
- en: To recap, the walking skeleton offers the platform users different ways of interaction.
    First, it extends the Kubernetes APIs to enable platform workflows such as creating
    development environments using Crossplane. Then it provides a user interface and
    simplified REST endpoints for teams that don’t want or can’t use the extended
    Kubernetes APIs. These simplified REST APIs, SDKs, and CLIs can be created for
    teams to manage their environments.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，行走骨架为平台用户提供不同的交互方式。首先，它扩展了Kubernetes API，以启用平台工作流程，例如使用Crossplane创建开发环境。然后，它为不希望或不能使用扩展的Kubernetes
    API的团队提供用户界面和简化的REST端点。这些简化的REST API、SDK和CLI可以为团队创建，以便他们管理自己的环境。
- en: There is value in having both options always available. It’s good to use the
    power of the Kubernetes APIs and the cloud-native ecosystem, when possible, but
    it’s also important to have a simplified option for reducing the cognitive load
    and following company API standards when needed.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 总是提供这两种选项都是有价值的。当可能的时候，使用Kubernetes API和云原生生态系统的力量是好的，但同样重要的是，在需要时有一个简化的选项来减少认知负荷并遵循公司API标准。
- en: Before closing this chapter, let’s bring back all the topics and projects we
    have seen together. How are all these tools and configurations related to platform
    engineering? Who is responsible for which component? And what comes next?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章之前，让我们回顾一下我们共同看到的主题和项目。所有这些工具和配置与平台工程有何关联？谁负责哪个组件？接下来又是什么？
- en: 6.4 Linking back to platform engineering
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 回顾平台工程
- en: So far, we have explored open-source projects that tackle different challenges
    we face when building distributed applications. Most of these tools are not focused
    on application developers, requiring skills and knowledge that are usually not
    needed to build business applications and features. The common denominator across
    all tools has been Kubernetes, and in most cases, projects have extended Kubernetes
    to perform tasks besides running our workloads. In this short section, I want
    to recap how all these projects fit together to delineate responsibilities, contracts,
    and expectations.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了处理我们在构建分布式应用程序时面临的不同挑战的开源项目。这些工具中的大多数都不是针对应用程序开发者的，需要通常在构建业务应用程序和功能时不需要的技能和知识。所有工具的共同点是Kubernetes，在大多数情况下，项目都扩展了Kubernetes以执行除了运行我们的工作负载之外的任务。在本节中，我想回顾一下所有这些项目是如何结合在一起以界定责任、合同和期望的。
- en: 'If we look at all these examples from a distance, there are two kinds of teams:
    platform and application development teams. These two teams have different responsibilities
    and require different tools to do their job. From what we have seen so far:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从远处观察所有这些例子，有两种类型的团队：平台和应用开发团队。这两个团队有不同的责任，需要不同的工具来完成他们的工作。从我们迄今为止所看到的情况来看：
- en: 'Platform teams are responsible for the following:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台团队负责以下事项：
- en: Understanding the needs of different teams related to IT services, cloud resources,
    and tools.
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解与IT服务、云资源和工具相关的不同团队的需求。
- en: Facilitating access to credentials and to different resources.
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 便于访问凭证和不同资源。
- en: Creating automation for other teams to get what they need.
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为其他团队创建自动化工具以满足他们的需求。
- en: 'Application development teams are responsible for the following:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序开发团队负责以下事项：
- en: Defining the customer-facing architecture and tech stack.
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义面向客户的架构和技术栈。
- en: Creating customer-facing features.
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建面向客户的特性。
- en: Releasing new versions to continuously improve how the business operates.
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布新版本以持续改进业务运营方式。
- en: These responsibilities materialize in software artifacts that can be managed
    similarly. Figure 6.18 shows the artifacts we have used for the platform walking
    skeleton. The tools not included in the step-by-step tutorial are drawn with dashed
    lines.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这些责任体现在可以类似管理的软件工件中。图6.18显示了我们在平台行走骨架中使用的工件。未包含在逐步教程中的工具用虚线表示。
- en: '![](../../OEBPS/Images/06-18.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/06-18.png)'
- en: Figure 6.18 Platform walking skeleton tools, configurations, and services
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.18 平台行走骨架工具、配置和服务
- en: 'As you can see, even for a very simple platform, the platform team is managing
    and administrating different tools that need to be highly available for our application
    development teams to consume. I haven’t focused on managing credentials or secrets,
    but this is something that the platform team will face early on in their journey.
    Using tools like the external-secrets project ([https://github.com/external-secrets/external-secrets](https://github.com/external-secrets/external-secrets))
    and/or tools like Vault by HashiCorp ([https://www.vaultproject.io/](https://www.vaultproject.io/))
    would make managing and storing credentials much easier and more centralized.
    This level of complexity has historically led to two implementation scenarios:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，即使是对于一个非常简单的平台，平台团队也在管理和维护需要高度可用以供我们的应用程序开发团队使用的不同工具。我还没有专注于管理凭证或机密，但这是平台团队在其旅程早期将面临的问题。使用像外部机密项目（[https://github.com/external-secrets/external-secrets](https://github.com/external-secrets/external-secrets)）和/或像HashiCorp的Vault（[https://www.vaultproject.io/](https://www.vaultproject.io/)）这样的工具将使管理和存储凭证变得更加容易和集中化。这种复杂程度在历史上导致了两种实施场景：
- en: Purchase a solution that provides fantastic application developer experience
    but limited platform engineering customization or operability (e.g., Heroku, CloudFoundry)
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 购买提供出色应用程序开发者体验但平台工程定制或可操作性有限的解决方案（例如，Heroku、CloudFoundry）
- en: Build a solution from a set of primitives, including scripting languages (BASH,
    Python, etc.), declarative infrastructure languages (Crossplane, Terraform, Chef,
    Ansible), and workflow engines (ArgoCD Workflows, CircleCI, GitHub Actions).
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一组原语构建解决方案，包括脚本语言（BASH、Python等）、声明式基础设施语言（Crossplane、Terraform、Chef、Ansible）和工作流引擎（ArgoCD
    Workflows、CircleCI、GitHub Actions）。
- en: Recently there has been an explosion of new tools that enable the first scenario
    (e.g., Vercel, Fly.io). However, for many organizations, these solutions have
    needed help managing their business process and compliance requirements fully.
    To address this challenge, there is more focus on lowering the cost of building
    bespoke internal offerings. For example, a project called Kratix ([https://kratix.io/](https://kratix.io/)),
    which is a framework that optimizes the definition and implementation of experiences
    as a service to other internal teams.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，出现了大量新的工具，使得第一种场景（例如，Vercel、Fly.io）成为可能。然而，对于许多组织来说，这些解决方案在全面管理其业务流程和合规性要求方面仍需要帮助。为了应对这一挑战，人们更加关注降低定制内部产品构建的成本。例如，有一个名为Kratix（[https://kratix.io/](https://kratix.io/)）的项目，它是一个框架，旨在优化定义和实施作为服务提供给其他内部团队的经验。
- en: Kratix is centered around the platform-building experience instead of the application
    user experience. A framework like Kratix can enable an internal marketplace where
    specialists can offer capabilities as a service while maintaining consistency
    across offerings, similar to what we explored with Crossplane compositions.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Kratix围绕平台构建体验，而不是应用用户体验。像Kratix这样的框架可以启用一个内部市场，专家可以在保持提供的一致性同时，将能力作为服务提供，类似于我们通过Crossplane组合所探索的。
- en: Whether you use an external tool or build your own, the platform engineering
    team must build a knowledge base about the projects they are using to build the
    platform and have a release process to manage changes when the tools are online
    for other teams to use.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您使用外部工具还是构建自己的工具，平台工程团队都必须构建关于他们用于构建平台的项目知识库，并有一个发布流程来管理工具上线供其他团队使用时的变更。
- en: Similar to this book’s examples repository at [https://github.com/salaboy/platforms-on-k8s/](https://github.com/salaboy/platforms-on-k8s/),
    the platform engineering team will need to manage all the configuration files
    to install and recreate all the tools and resources the platform needs to work.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书的示例存储库[https://github.com/salaboy/platforms-on-k8s/](https://github.com/salaboy/platforms-on-k8s/)类似，平台工程团队需要管理所有配置文件，以安装和重新创建平台工作所需的所有工具和资源。
- en: Note Ideally, as with Kubernetes, if the control plane (tools we installed)
    is down, our teams should be able to keep working. We (as platform engineering
    teams) need to build resilient platforms and ensure that if something goes wrong,
    we don’t block teams and the important work they are doing. While the platform
    we build should speed up software delivery, it shouldn’t be on the critical path
    for the teams’ success. In other words, there should always be a way around the
    platform, meaning that if teams want to directly access some of the tools that
    the platform is using, they should be able to do so.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：理想情况下，与Kubernetes一样，如果控制平面（我们安装的工具）出现故障，我们的团队应该能够继续工作。我们（作为平台工程团队）需要构建具有弹性的平台，并确保如果出现问题，我们不会阻碍团队及其正在进行的重要工作。虽然我们构建的平台应该加快软件交付，但它不应该是团队成功的关键路径。换句话说，总应该有绕过平台的方法，这意味着如果团队想直接访问平台使用的某些工具，他们应该能够做到。
- en: The walking skeleton we built in this chapter offers different layers for different
    users to work and integrate with. If your team understands the platform’s tools,
    they can access the Kubernetes APIs of the platform cluster for full flexibility
    and control. If they choose, they can also use the provided user interface and
    REST endpoints to integrate with other systems. Figure 6.19 shows our platform
    walking skeleton, how it provides teams with predefined workflows exposed by the
    platform APIs, and the tools and behaviors implemented under the hood by the platform
    team.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们构建的行走骨架为不同用户提供了不同的层，以便他们进行工作和集成。如果你的团队理解了平台工具，他们可以访问平台集群的Kubernetes API，以获得完全的灵活性和控制。如果他们选择，他们也可以使用提供的用户界面和REST端点与其他系统集成。图6.19展示了我们的平台行走骨架，它如何为团队提供由平台API公开的预定义工作流程，以及平台团队在底层实现的工具和行为。
- en: I strongly recommend platform teams document their journey with each of the
    tools that they are planning to use as part of their platform initiatives, because
    bringing team members up to speed on these decisions is usually the most challenging
    aspect of maintaining a platform like the one described here.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议平台团队记录他们使用计划作为其平台倡议一部分的每个工具的旅程，因为让团队成员熟悉这些决策通常是维护像这里描述的平台最具有挑战性的方面。
- en: '![](../../OEBPS/Images/06-19.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图6.19](../../OEBPS/Images/06-19.png)'
- en: Figure 6.19 Platform responsibilities and boundaries
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.19 平台责任和边界
- en: In the next couple of chapters, we will explore some core capabilities the platform
    should provide when creating environments for teams. Which functionalities can
    be provided to the application development teams so they can be more efficient
    when delivering software? Chapter 7 covers release strategies and why they are
    important to enable teams to experiment and release more software. Chapter 8 covers
    shared concerns that you will need to provide to all services of your applications
    and different approaches to facilitate these mechanisms to your developers.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，我们将探讨平台在为团队创建环境时应提供的一些核心功能。可以为应用开发团队提供哪些功能，以便他们在交付软件时更加高效？第7章涵盖了发布策略及其为什么对团队进行实验和发布更多软件很重要。第8章涵盖了你需要为应用程序的所有服务提供的一些共享关注点，以及为开发者提供这些机制的不同方法。
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Building platforms on top of Kubernetes is a complex task that involves combining
    different tools to serve teams with different requirements.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kubernetes之上构建平台是一项复杂的工作，需要结合不同的工具来满足不同团队的需求。
- en: Platforms are software projects as your business applications. Starting by understanding
    who the main users will be and defining clear APIs is the key to prioritizing
    tasks on how to build your platform.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台就像你的业务应用程序一样是软件项目。首先理解主要用户是谁，并定义清晰的API，这是确定如何构建平台时任务优先级的关键。
- en: Managing multiple Kubernetes clusters and dealing with tenant isolations are
    two main challenges that platform teams face early on in their platform-building
    journey.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理多个Kubernetes集群和处理租户隔离是平台团队在平台构建初期面临的主要挑战。
- en: Having a platform walking skeleton can help you to demonstrate to internal teams
    what can be built to speed up their cloud-native journey.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有一个平台的基础框架可以帮助你向内部团队展示可以构建的内容，以加快他们的云原生之旅。
- en: Using tools like Crossplane, ArgoCD, `vcluster`, and others can help you promote
    cloud-native best practices at the platform level but, most importantly, avoid
    the urge to create your custom tools and ways to provision and maintain complex
    configurations of cloud-native resources.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Crossplane、ArgoCD、`vcluster`和其他工具可以帮助你在平台级别推广云原生最佳实践，但最重要的是，避免创建自定义工具和用于配置和维持云原生资源复杂配置的方法的冲动。
- en: If you followed the step-by-step tutorial, you got hands-on experience using
    tools like Crossplane and `vcluster` to provision on-demand development environments.
    You also interacted with a simplified API that reduces the cognitive load for
    teams that don’t want or can’t interact with a full-blown Kubernetes API server.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你遵循了逐步教程，你将获得使用Crossplane和`vcluster`等工具来提供按需开发环境的实践经验。你还与一个简化的API进行了交互，这有助于减少不希望或无法与完整的Kubernetes
    API服务器交互的团队的认知负荷。
