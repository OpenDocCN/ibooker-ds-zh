- en: Chapter 15\. Regular Expressions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章。正则表达式
- en: Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In [Chapter 14](ch14.xhtml#chp-strings), you learned a whole bunch of useful
    functions for working with strings. This chapter will focus on functions that
    use *regular expressions*, a concise and powerful language for describing patterns
    within strings. The term *regular expression* is a bit of a mouthful, so most
    people abbreviate it to *regex*^([1](ch15.xhtml#idm44771294160112)) or *regexp*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第14章](ch14.xhtml#chp-strings)中，你学习了许多处理字符串的有用函数。本章将重点介绍使用*正则表达式*描述字符串模式的简洁而强大的语言的函数。术语*正则表达式*有点冗长，因此大多数人将其缩写为*regex*^([1](ch15.xhtml#idm44771294160112))或*regexp*。
- en: The chapter starts with the basics of regular expressions and the most useful
    stringr functions for data analysis. We’ll then expand your knowledge of patterns
    and cover seven important new topics (escaping, anchoring, character classes,
    shorthand classes, quantifiers, precedence, and grouping). Next, we’ll talk about
    some of the other types of patterns that stringr functions can work with and the
    various “flags” that allow you to tweak the operation of regular expressions.
    We’ll finish with a survey of other places in the tidyverse and base R where you
    might use regexes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从正则表达式的基础知识和最有用的字符串分析函数开始。然后，我们将扩展您对模式的理解，并介绍七个重要的新主题（转义、锚定、字符类、简写类、量词、优先级和分组）。接下来，我们将讨论一些其他类型的模式，stringr函数可以处理的以及各种“标志”，这些标志允许您调整正则表达式的操作。最后，我们将概述tidyverse和基础R中可能使用正则表达式的其他位置。
- en: Prerequisites
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先决条件
- en: 'In this chapter, we’ll use regular expression functions from stringr and tidyr,
    both core members of the tidyverse, as well as data from the babynames package:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用来自stringr和tidyr的正则表达式函数，它们都是tidyverse的核心成员，以及来自babynames包的数据：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Through this chapter, we’ll use a mix of simple inline examples so you can
    get the basic idea, the baby names data, and three character vectors from stringr:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将使用简单的内联示例混合，以便您可以了解基本概念，以及来自stringr的婴儿姓名数据和三个字符向量：
- en: '`fruit` contains the names of 80 fruits.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fruit` 包含80种水果的名称。'
- en: '`words` contains 980 common English words.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`words` 包含980个常见的英文单词。'
- en: '`sentences` contains 720 short sentences.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sentences` 包含720个短句子。'
- en: Pattern Basics
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式基础
- en: We’ll use [`str_view()`](https://stringr.tidyverse.org/reference/str_view.xhtml)
    to learn how regex patterns work. We used [`str_view()`](https://stringr.tidyverse.org/reference/str_view.xhtml)
    in the previous chapter to better understand a string versus its printed representation,
    and now we’ll use it with its second argument, a regular expression. When this
    is supplied, [`str_view()`](https://stringr.tidyverse.org/reference/str_view.xhtml)
    will show only the elements of the string vector that match, surrounding each
    match with `<>` and, where possible, highlighting the match in blue.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用[`str_view()`](https://stringr.tidyverse.org/reference/str_view.xhtml)来学习正则表达式模式的工作原理。在前一章中，我们使用[`str_view()`](https://stringr.tidyverse.org/reference/str_view.xhtml)更好地理解了字符串与其打印表示之间的区别，现在我们将使用它的第二个参数，即正则表达式。当提供这个参数时，[`str_view()`](https://stringr.tidyverse.org/reference/str_view.xhtml)将仅显示与之匹配的字符串向量的元素，并用`<>`包围每个匹配项，并在可能时以蓝色突出显示匹配项。
- en: 'The simplest patterns consist of letters and numbers that match those characters
    exactly:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的模式由精确匹配这些字符的字母和数字组成：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Letters and numbers match exactly and are called *literal characters*. Most
    punctuation characters, like `.`, `+`, `*`, `[`, `]`, and `?`, have special meanings^([2](ch15.xhtml#idm44771294089152))
    and are called *metacharacters*. For example, `.` will match any character,^([3](ch15.xhtml#idm44771294083376))
    so `"a."` will match any string that contains an “a” followed by another character:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 字母和数字精确匹配并称为*字面字符*。大多数标点符号字符，如`.`、`+`、`*`、`[`、`]`和`?`，具有特殊含义^([2](ch15.xhtml#idm44771294089152))，称为*元字符*。例如，`.`将匹配任何字符^([3](ch15.xhtml#idm44771294083376))，因此`"a."`将匹配包含“a”后跟另一个字符的任何字符串：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Or we could find all the fruits that contain an “a,” followed by three letters,
    followed by an “e”:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以找到所有包含“a”后跟三个字母，再跟一个“e”的水果：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Quantifiers* control how many times a pattern can match:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*量词*控制模式可以匹配多少次：'
- en: '`?` makes a pattern optional (i.e., it matches 0 or 1 times).'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?` 使模式变为可选的（即匹配0次或1次）。'
- en: '`+` lets a pattern repeat (i.e., it matches at least once).'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+` 允许模式重复（即至少匹配一次）。'
- en: '`*` lets a pattern be optional or repeat (i.e., it matches any number of times,
    including 0).'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*` 允许模式是可选的或重复的（即匹配任意次数，包括0次）。'
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Character classes* are defined by `[]` and let you match a set of characters;
    e.g., `[abcd]` matches “a”, “b”, “c”, or “d.” You can also invert the match by
    starting with `^`: `[^abcd]` matches anything *except* “a”, “b”, “c”, or “d.”
    We can use this idea to find the words containing an “x” surrounded by vowels
    or a “y” surrounded by consonants:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符类*由`[]`定义，允许您匹配一组字符；例如，`[abcd]`匹配“a”、“b”、“c”或“d”。您还可以通过使用`^`来反转匹配：`[^abcd]`匹配除了“a”、“b”、“c”或“d”之外的任何字符。我们可以利用这个思路来查找包含元音字母“x”或辅音字母“y”的单词：'
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can use *alternation*, `|`, to pick between one or more alternative patterns.
    For example, the following patterns look for fruits containing “apple,” “melon,”
    or “nut” or a repeated vowel:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用*交替*，`|`，来选择一个或多个备选模式。例如，以下模式寻找包含“apple”、“melon”或“nut”或重复元音字母的水果：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Regular expressions are very compact and use a lot of punctuation characters,
    so they can seem overwhelming and hard to read at first. Don’t worry: you’ll get
    better with practice, and simple patterns will soon become second nature. Let’s
    kick off that process by practicing with some useful stringr functions.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式非常紧凑，使用了许多标点字符，因此一开始可能看起来令人生畏且难以阅读。不要担心：通过练习，您会变得更好，简单的模式很快就会变得熟悉起来。让我们通过使用一些有用的stringr函数来开始这个过程。
- en: Key Functions
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关键功能
- en: Now that you understand the basics of regular expressions, let’s use them with
    some stringr and tidyr functions. In the following section, you’ll learn how to
    detect the presence or absence of a match, how to count the number of matches,
    how to replace a match with fixed text, and how to extract text using a pattern.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了正则表达式的基础知识，让我们在一些stringr和tidyr函数中使用它们。在接下来的部分中，您将学习如何检测匹配的存在或不存在，如何计算匹配的数量，如何用固定文本替换匹配项，以及如何使用模式提取文本。
- en: Detect Matches
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测匹配项
- en: '[`str_detect()`](https://stringr.tidyverse.org/reference/str_detect.xhtml)
    returns a logical vector that is `TRUE` if the pattern matches an element of the
    character vector and `FALSE` otherwise:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[`str_detect()`](https://stringr.tidyverse.org/reference/str_detect.xhtml)返回一个逻辑向量，如果模式与字符向量的元素匹配，则为`TRUE`，否则为`FALSE`：'
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Since [`str_detect()`](https://stringr.tidyverse.org/reference/str_detect.xhtml)
    returns a logical vector of the same length as the initial vector, it pairs well
    with [`filter()`](https://dplyr.tidyverse.org/reference/filter.xhtml). For example,
    this code finds all the most popular names containing a lowercase “x”:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于[`str_detect()`](https://stringr.tidyverse.org/reference/str_detect.xhtml)返回与初始向量相同长度的逻辑向量，因此它与[`filter()`](https://dplyr.tidyverse.org/reference/filter.xhtml)配合使用效果很好。例如，这段代码找出所有包含小写字母“x”的最流行的名字：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can also use [`str_detect()`](https://stringr.tidyverse.org/reference/str_detect.xhtml)
    with [`summarize()`](https://dplyr.tidyverse.org/reference/summarise.xhtml) by
    pairing it with [`sum()`](https://rdrr.io/r/base/sum.xhtml) or [`mean()`](https://rdrr.io/r/base/mean.xhtml):
    `sum(str_detect(x, pattern))` tells you the number of observations that match,
    and `mean(str_detect(x, pattern))` tells you the proportion that match. For example,
    the following snippet computes and visualizes the proportion of baby names^([4](ch15.xhtml#idm44771293675344))
    that contain “x,” broken down by year. It looks like they’ve radically increased
    in popularity lately!'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用[`str_detect()`](https://stringr.tidyverse.org/reference/str_detect.xhtml)与[`summarize()`](https://dplyr.tidyverse.org/reference/summarise.xhtml)配合使用，再配合[`sum()`](https://rdrr.io/r/base/sum.xhtml)或[`mean()`](https://rdrr.io/r/base/mean.xhtml)：`sum(str_detect(x,
    pattern))`告诉您匹配的观测数量，而`mean(str_detect(x, pattern))`告诉您匹配的比例。例如，以下代码片段计算并可视化了包含“x”的婴儿姓名^([4](ch15.xhtml#idm44771293675344))的比例，按年份分解。看起来它们最近的流行度有了显著增加！
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![A time series showing the proportion of baby names that contain the letter
    x. The proportion declines gradually from 8 per 1000 in 1880 to 4 per 1000 in
    1980, then increases rapidly to 16 per 1000 in 2019.](assets/rds2_15in01.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![一个时间序列图显示包含字母x的婴儿姓名比例。该比例从1880年的每千个名字中的8个逐渐下降到1980年的每千个名字中的4个，然后迅速增加到2019年的每千个名字中的16个。](assets/rds2_15in01.png)'
- en: 'There are two functions that are closely related to [`str_detect()`](https://stringr.tidyverse.org/reference/str_detect.xhtml):
    [`str_subset()`](https://stringr.tidyverse.org/reference/str_subset.xhtml) and
    [`str_which()`](https://stringr.tidyverse.org/reference/str_which.xhtml). [`str_subset()`](https://stringr.tidyverse.org/reference/str_subset.xhtml)
    returns a character vector containing only the strings that match. [`str_which()`](https://stringr.tidyverse.org/reference/str_which.xhtml)
    returns an integer vector giving the positions of the strings that match.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个与[`str_detect()`](https://stringr.tidyverse.org/reference/str_detect.xhtml)密切相关的函数：[`str_subset()`](https://stringr.tidyverse.org/reference/str_subset.xhtml)和[`str_which()`](https://stringr.tidyverse.org/reference/str_which.xhtml)。[`str_subset()`](https://stringr.tidyverse.org/reference/str_subset.xhtml)返回一个只包含匹配字符串的字符向量。[`str_which()`](https://stringr.tidyverse.org/reference/str_which.xhtml)返回一个整数向量，给出匹配的字符串位置。
- en: Count Matches
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算匹配次数
- en: 'The next step up in complexity from [`str_detect()`](https://stringr.tidyverse.org/reference/str_detect.xhtml)
    is [`str_count()`](https://stringr.tidyverse.org/reference/str_count.xhtml): rather
    than a true or false, it tells you how many matches there are in each string.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 比[`str_detect()`](https://stringr.tidyverse.org/reference/str_detect.xhtml)更复杂的下一个步骤是[`str_count()`](https://stringr.tidyverse.org/reference/str_count.xhtml)：它不像返回真或假，而是告诉你每个字符串中有多少匹配项。
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note that each match starts at the end of the previous match; i.e., regex matches
    never overlap. For example, in `"abababa"`, how many times will the pattern `"aba"`
    match? Regular expressions say two, not three:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每个匹配从前一个匹配的末尾开始；即，正则表达式匹配不重叠。例如，在`"abababa"`中，模式`"aba"`会匹配多少次？正则表达式说是两次，而不是三次：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It’s natural to use [`str_count()`](https://stringr.tidyverse.org/reference/str_count.xhtml)
    with [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml). The following
    example uses [`str_count()`](https://stringr.tidyverse.org/reference/str_count.xhtml)
    with character classes to count the number of vowels and consonants in each name:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 自然而然地使用[`str_count()`](https://stringr.tidyverse.org/reference/str_count.xhtml)和[`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml)。以下示例使用[`str_count()`](https://stringr.tidyverse.org/reference/str_count.xhtml)和字符类来计算每个名称中元音和辅音的数量：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you look closely, you’ll notice that there’s something off with our calculations:
    “Aaban” contains three a’s, but our summary reports only two vowels. That’s because
    regular expressions are case sensitive. There are three ways we could fix this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，会发现我们的计算有些问题：“Aaban”包含三个a，但我们的汇总报告只有两个元音。这是因为正则表达式区分大小写。我们有三种方法可以解决这个问题：
- en: 'Add the uppercase vowels to the character class: `str_count(name, "[aeiouAEIOU]")`.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将大写元音添加到字符类中：`str_count(name, "[aeiouAEIOU]")`。
- en: 'Tell the regular expression to ignore case: `str_count(name, regex("[aeiou]",
    ignore_case = TRUE))`. We’ll talk about more in [“Regex Flags”](#sec-flags).'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 告诉正则表达式忽略大小写：`str_count(name, regex("[aeiou]", ignore_case = TRUE))`。我们将在[“正则表达式标志”](#sec-flags)中详细讨论。
- en: 'Use [`str_to_lower()`](https://stringr.tidyverse.org/reference/case.xhtml)
    to convert the names to lowercase: `str_count(str_to_lower(name), "[aeiou]")`.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用[`str_to_lower()`](https://stringr.tidyverse.org/reference/case.xhtml)将名称转换为小写：`str_count(str_to_lower(name),
    "[aeiou]")`。
- en: This variety of approaches is pretty typical when working with strings—there
    are often multiple ways to reach your goal, either by making your pattern more
    complicated or by doing some preprocessing on your string. If you get stuck trying
    one approach, it can often be useful to switch gears and tackle the problem from
    a different perspective.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 处理字符串时，常见的方法有多种——通常可以通过使模式更复杂或对字符串进行预处理来达到目标。如果尝试一种方法时遇到困难，通常切换角度从不同的视角解决问题会更有用。
- en: 'Since we’re applying two functions to the name, I think it’s easier to transform
    it first:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们对名称应用了两个函数，我认为先将其转换会更容易：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Replace Values
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换值
- en: 'As well as detecting and counting matches, we can also modify them with [`str_replace()`](https://stringr.tidyverse.org/reference/str_replace.xhtml)
    and [`str_replace_all()`](https://stringr.tidyverse.org/reference/str_replace.xhtml).
    [`str_replace()`](https://stringr.tidyverse.org/reference/str_replace.xhtml) replaces
    the first match, and as the name suggests, [`str_replace_all()`](https://stringr.tidyverse.org/reference/str_replace.xhtml)
    replaces all matches:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 除了检测和计数匹配项，我们还可以使用[`str_replace()`](https://stringr.tidyverse.org/reference/str_replace.xhtml)和[`str_replace_all()`](https://stringr.tidyverse.org/reference/str_replace.xhtml)修改它们。[`str_replace()`](https://stringr.tidyverse.org/reference/str_replace.xhtml)替换第一个匹配项，而[`str_replace_all()`](https://stringr.tidyverse.org/reference/str_replace.xhtml)则替换所有匹配项：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[`str_remove()`](https://stringr.tidyverse.org/reference/str_remove.xhtml)
    and [`str_remove_all()`](https://stringr.tidyverse.org/reference/str_remove.xhtml)
    are handy shortcuts for `str_replace(x, pattern, "")`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[`str_remove()`](https://stringr.tidyverse.org/reference/str_remove.xhtml)和[`str_remove_all()`](https://stringr.tidyverse.org/reference/str_remove.xhtml)是`str_replace(x,
    pattern, "")`的便捷快捷方式：'
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These functions are naturally paired with [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml)
    when doing data cleaning, and you’ll often apply them repeatedly to peel off layers
    of inconsistent formatting.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据清洗时，这些函数与[`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml)自然配对，你经常会重复应用它们来逐层去除不一致的格式。
- en: Extract Variables
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取变量
- en: 'The last function we’ll discuss uses regular expressions to extract data out
    of one column into one or more new columns: [`separate_wider_regex()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml).
    It’s a peer of the [`separate_wider_position()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml)
    and [`separate_wider_delim()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml)
    functions that you learned about in [“Separating into Columns”](ch14.xhtml#sec-string-columns).
    These functions live in tidyr because they operate on (columns of) data frames,
    rather than individual vectors.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论的最后一个函数使用正则表达式从一列中提取数据到一个或多个新列：[`separate_wider_regex()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml)。它与你在[“分列”](ch14.xhtml#sec-string-columns)章节学到的[`separate_wider_position()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml)和[`separate_wider_delim()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml)函数是同类。这些函数存在于tidyr中，因为它们操作（列的）数据框，而不是单个向量。
- en: Let’s create a simple dataset to show how it works. Here we have some data derived
    from `babynames` where we have the name, gender, and age of a bunch of people
    in a rather weird format:^([5](ch15.xhtml#idm44771293255808))
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的数据集来展示它的工作原理。这里有一些从`babynames`衍生出的数据，其中我们有一些人的姓名、性别和年龄，格式相当奇怪：^([5](ch15.xhtml#idm44771293255808))
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To extract this data using [`separate_wider_regex()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml)
    we just need to construct a sequence of regular expressions that match each piece.
    If we want the contents of that piece to appear in the output, we give it a name:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用[`separate_wider_regex()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml)提取这些数据，我们只需构造一系列正则表达式，匹配每个片段。如果我们希望输出中出现该片段的内容，我们给它一个名称：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If the match fails, you can use `too_short = "debug"` to figure out what went
    wrong, just like [`separate_wider_delim()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml)
    and [`separate_wider_position()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果匹配失败，你可以使用`too_short = "debug"`来找出问题所在，就像[`separate_wider_delim()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml)和[`separate_wider_position()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml)一样。
- en: Exercises
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'What baby name has the most vowels? What name has the highest proportion of
    vowels? (Hint: What is the denominator?)'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个婴儿名字有最多的元音？哪个名字的元音比例最高？（提示：分母是什么？）
- en: Replace all forward slashes in `"a/b/c/d/e"` with backslashes. What happens
    if you attempt to undo the transformation by replacing all backslashes with forward
    slashes? (We’ll discuss the problem very soon.)
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`"a/b/c/d/e"`中用反斜杠替换所有正斜杠。如果尝试通过替换所有反斜杠为正斜杠来撤销转换，会发生什么？（我们很快会讨论这个问题。）
- en: Implement a simple version of [`str_to_lower()`](https://stringr.tidyverse.org/reference/case.xhtml)
    using [`str_replace_all()`](https://stringr.tidyverse.org/reference/str_replace.xhtml).
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用[`str_replace_all()`](https://stringr.tidyverse.org/reference/str_replace.xhtml)实现一个简单版本的[`str_to_lower()`](https://stringr.tidyverse.org/reference/case.xhtml)。
- en: Create a regular expression that will match telephone numbers as commonly written
    in your country.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个正则表达式，匹配你国家中常见的电话号码写法。
- en: Pattern Details
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式细节
- en: Now that you understand the basics of the pattern language and how to use it
    with some stringr and tidyr functions, it’s time to dig into more of the details.
    First, we’ll start with *escaping*, which allows you to match metacharacters that
    would otherwise be treated specially. Next, you’ll learn about *anchors*, which
    allow you to match the start or end of the string. Then, you’ll more learn about
    *character classes* and their shortcuts, which allow you to match any character
    from a set. Next, you’ll learn the final details of *quantifiers*, which control
    how many times a pattern can match. Then, we have to cover the important (but
    complex) topic of *operator precedence* and parentheses. And we’ll finish off
    with some details of *grouping* components of the pattern.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你理解了模式语言的基础以及如何与一些stringr和tidyr函数一起使用它的基础，现在是时候深入探讨更多细节了。首先，我们将从*转义*开始，这允许你匹配本应特殊处理的元字符。接下来，你将了解*锚点*，它允许你匹配字符串的开始或结束。然后，你将更多地了解*字符类*及其快捷方式，它们允许你匹配来自集合的任何字符。接下来，你将学习*量词*的最后细节，它控制模式可以匹配的次数。然后，我们需要涵盖*运算符优先级*和括号这个重要（但复杂）的主题。最后，我们会详细讨论模式组件的*分组*细节。
- en: The terms we use here are the technical names for each component. They’re not
    always the most evocative of their purpose, but it’s helpful to know the correct
    terms if you later want to google for more details.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的术语是每个组件的技术名称。它们并不总是最具感染力的用途，但如果以后你想要搜索更多细节，知道正确的术语是有帮助的。
- en: Escaping
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转义
- en: 'To match a literal `.`, you need an *escape*, which tells the regular expression
    to match metacharacters^([6](ch15.xhtml#idm44771293083536)) literally. Like strings,
    regexps use the backslash for escaping. So, to match a `.`, you need the regexp
    `\.`. Unfortunately, this creates a problem. We use strings to represent regular
    expressions, and `\` is also used as an escape symbol in strings. So to create
    the regular expression `\.`, we need the string `"\\."`, as the following example
    shows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要匹配一个字面上的`.`，你需要进行*转义*，这告诉正则表达式匹配元字符^([6](ch15.xhtml#idm44771293083536))的字面意思。与字符串类似，正则表达式使用反斜杠进行转义。因此，要匹配`.`，你需要正则表达式`\.`。不幸的是，这会造成问题。我们使用字符串表示正则表达式，而`\`也用作字符串中的转义符号。因此，要创建正则表达式`\.`，我们需要字符串`"\\."`，如下面的示例所示：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this book, we’ll usually write regular expression without quotes, like `\.`.
    If we need to emphasize what you’ll actually type, we’ll surround it with quotes
    and add extra escapes, like `"\\."`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们通常会写出没有引号的正则表达式，例如`\.`。如果我们需要强调你实际上要输入的内容，我们会用引号括起来并添加额外的转义符号，例如`"\\."`。
- en: If `\` is used as an escape character in regular expressions, how do you match
    a literal `\`? Well, you need to escape it, creating the regular expression `\\`.
    To create that regular expression, you need to use a string, which also needs
    to escape `\`. That means to match a literal `\` you need to write `"\\\\"`—you
    need four backslashes to match one!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`\`在正则表达式中用作转义字符，那么如何匹配一个字面上的`\`？嗯，你需要对它进行转义，创建正则表达式`\\`。要创建这样的正则表达式，你需要使用一个字符串，而在字符串中，你也需要转义`\`。这意味着要匹配一个字面上的`\`，你需要写成`"\\\\"`——你需要四个反斜杠来匹配一个！
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Alternatively, you might find it easier to use the raw strings you learned
    about in [“Raw Strings”](ch14.xhtml#sec-raw-strings). That lets you avoid one
    layer of escaping:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可能会发现使用你在[“原始字符串”](ch14.xhtml#sec-raw-strings)中学到的原始字符串更容易些。这样可以避免一层转义：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you’re trying to match a literal `.`, `$`, `|`, `*`, `+`, `?`, `{`, `}`,
    `(`, `)`, there’s an alternative to using a backslash escape. You can use a character
    class: `[.]`, `[$]`, `[|]`, ... all match the literal values:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试匹配一个字面上的`.`、`$`、`|`、`*`、`+`、`?`、`{`、`}`、`(`、`)`，使用反斜杠转义的替代方法。你可以使用字符类：`[.]`、`[$]`、`[|]`，...都可以匹配字面值：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Anchors
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 锚点
- en: 'By default, regular expressions will match any part of a string. If you want
    to match at the start or end you need to *anchor* the regular expression using
    `^` to match the start or `$` to match the end:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，正则表达式将匹配字符串的任何部分。如果你想匹配开头或结尾，你需要使用`^`锚定正则表达式的开始或使用`$`锚定结束：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It’s tempting to think that `$` should match the start of a string, because
    that’s how we write dollar amounts, but that’s not what regular expressions want.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 很诱人地认为`$`应该匹配字符串的开始，因为这是我们写金额的方式，但这并不是正则表达式想要的。
- en: 'To force a regular expression to match only the full string, anchor it with
    both `^` and `$`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要强制正则表达式仅匹配整个字符串，请同时使用`^`和`$`锚定它：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can also match the boundary between words (i.e., the start or end of a
    word) with `\b`. This can be particularly useful when using RStudio’s find and
    replace tool. For example, to find all uses of [`sum()`](https://rdrr.io/r/base/sum.xhtml),
    you can search for `\bsum\b` to avoid matching `summarize`, `summary`, `rowsum`,
    and so on:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `\b` 匹配单词边界（即单词的开始或结束）。在使用 RStudio 的查找和替换工具时，这可能特别有用。例如，要查找所有使用 [`sum()`](https://rdrr.io/r/base/sum.xhtml)
    的地方，您可以搜索 `\bsum\b` 以避免匹配 `summarize`、`summary`、`rowsum` 等：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When used alone, anchors will produce a zero-width match:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当单独使用时，锚点将产生零宽匹配：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This helps you understand what happens when you replace a standalone anchor:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这帮助您了解替换独立锚点时会发生什么：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Character Classes
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符类
- en: 'A *character class*, or character *set*, allows you to match any character
    in a set. As we discussed, you can construct your own sets with `[]`, where `[abc]`
    matches “a,” “b,” or “c” and `[^abc]` matches any character except “a,” “b,” or
    “c.” Apart from `^` there are two other characters that have special meaning inside
    `[]`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符类* 或 *字符集* 允许您匹配集合中的任何字符。正如我们讨论过的，您可以使用 `[]` 构建自己的集合，其中 `[abc]` 匹配“a”、“b”或“c”，`[^abc]`
    匹配除“a”、“b”或“c”之外的任何字符。除了 `^` 之外，还有两个其他在 `[]` 内具有特殊含义的字符：'
- en: '`-` defines a range; e.g., `[a-z]` matches any lowercase letter, and `[0-9]`
    matches any number.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-` 定义一个范围；例如 `[a-z]` 匹配任何小写字母，`[0-9]` 匹配任何数字。'
- en: '`\` escapes special characters, so `[\^\-\]]` matches `^`, `-`, or `]`.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\` 转义特殊字符，因此 `[\^\-\]]` 匹配 `^`、`-` 或 `]`。'
- en: 'Here are a few examples:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个例子：
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Some character classes are used so commonly that they get their own shortcut.
    You’ve already seen `.`, which matches any character apart from a newline. There
    are three other particularly useful pairs:^([7](ch15.xhtml#idm44771292559200))
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一些字符类使用得如此普遍，它们得到了自己的快捷方式。您已经看到了 `.`，它匹配除换行符之外的任何字符。还有另外三对特别有用的字符：^([7](ch15.xhtml#idm44771292559200))
- en: '`\d` matches any digit.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\d` 匹配任何数字字符。'
- en: '`\D` matches anything that isn’t a digit.'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`\D` 匹配任何非数字字符。'
- en: '`\s` matches any whitespace (e.g., space, tab, newline).'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\s` 匹配任何空白字符（例如空格、制表符、换行符）。'
- en: '`\S` matches anything that isn’t whitespace.'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`\S` 匹配任何非空白字符。'
- en: '`\w` matches any “word” character, i.e., letters and numbers.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\w` 匹配任何“单词”字符，即字母和数字。'
- en: '`\W` matches any “nonword” character.'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`\W` 匹配任何“非单词”字符。'
- en: 'The following code demonstrates the six shortcuts with a selection of letters,
    numbers, and punctuation characters:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了六个快捷方式，包括一些字母、数字和标点符号的选择：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Quantifiers
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 量词
- en: '*Quantifiers* control how many times a pattern matches. In [“Pattern Basics”](#sec-reg-basics)
    you learned about `?` (0 or 1 matches), `+` (1 or more matches), and `*` (0 or
    more matches). For example, `colou?r` will match American or British spelling,
    `\d+` will match one or more digits, and `\s?` will optionally match a single
    item of whitespace. You can also specify the number of matches precisely with
    [`{}`](https://rdrr.io/r/base/Paren.xhtml):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*量词* 控制模式匹配的次数。在 [“模式基础”](#sec-reg-basics) 中，您学到了 `?`（0 或 1 次匹配）、`+`（1 次或多次匹配）和
    `*`（0 次或多次匹配）。例如，`colou?r` 将匹配美式或英式拼写，`\d+` 将匹配一个或多个数字，`\s?` 将可选择匹配一个空格项。您还可以使用
    `{}` 精确指定匹配次数：[`{}`](https://rdrr.io/r/base/Paren.xhtml)'
- en: '`{n}` matches exactly n times.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{n}` 精确匹配 n 次。'
- en: '`{n,}` matches at least n times.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{n,}` 至少匹配 n 次。'
- en: '`{n,m}` matches between n and m times.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{n,m}` 匹配 n 到 m 次。'
- en: Operator Precedence and Parentheses
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运算符优先级和括号
- en: What does `ab+` match? Does it match “a” followed by one or more “b”s, or does
    it match “ab” repeated any number of times? What does `^a|b$` match? Does it match
    the complete string a or the complete string b, or does it match a string starting
    with a or a string ending with b?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`ab+` 匹配什么？它是匹配以一个或多个“b”后跟“a”，还是匹配任意次数重复的“ab”？`^a|b$` 匹配什么？它是匹配完整的字符串 a 或完整的字符串
    b，还是匹配以 a 开头或以 b 结尾的字符串？'
- en: 'The answer to these questions is determined by operator precedence, similar
    to the PEMDAS or BEDMAS rules you might have learned in school. You know that
    `a + b * c` is equivalent to `a + (b * c)` not `(a + b) * c` because `*` has higher
    precedence and `+` has lower precedence: you compute `*` before `+`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题的答案取决于操作符优先级，类似于您可能在学校学到的 PEMDAS 或 BEDMAS 规则。您知道 `a + b * c` 等同于 `a + (b
    * c)` 而不是 `(a + b) * c`，因为 `*` 有更高的优先级，而 `+` 有较低的优先级：您在 `+` 之前计算 `*`。
- en: 'Similarly, regular expressions have their own precedence rules: quantifiers
    have high precedence, and alternation has low precedence, which means that `ab+`
    is equivalent to `a(b+)`, and `^a|b$` is equivalent to `(^a)|(b$)`. Just like
    with algebra, you can use parentheses to override the usual order. But unlike
    algebra, you’re unlikely to remember the precedence rules for regexes, so feel
    free to use parentheses liberally.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，正则表达式有其自己的优先级规则：量词具有较高的优先级，而交替具有较低的优先级，这意味着`ab+`等价于`a(b+)`，`^a|b$`等价于`(^a)|(b$)`。就像代数一样，您可以使用括号来覆盖通常的顺序。但与代数不同的是，您不太可能记住正则表达式的优先级规则，因此请随意大量使用括号。
- en: Grouping and Capturing
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分组和捕获
- en: 'As well as overriding operator precedence, parentheses have another important
    effect: they create *capturing groups* that allow you to use subcomponents of
    the match.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 除了覆盖运算符优先级外，括号还具有另一个重要的作用：它们创建*捕获组*，允许您使用匹配的子组件。
- en: 'The first way to use a capturing group is to refer to it within a match with
    a *back reference*: `\1` refers to the match contained in the first parenthesis,
    `\2` in the second parenthesis, and so on. For example, the following pattern
    finds all fruits that have a repeated pair of letters:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用捕获组的第一种方法是在匹配中引用它：*反向引用* `\1` 指的是第一个括号中包含的匹配，`\2` 指的是第二个括号中的匹配，依此类推。例如，以下模式找到所有具有重复的字母对的水果：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This one finds all words that start and end with the same pair of letters:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式找到所有以相同的字母对开头和结尾的单词：
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can also use back references in [`str_replace()`](https://stringr.tidyverse.org/reference/str_replace.xhtml).
    For example, this code switches the order of the second and third words in `sentences`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[`str_replace()`](https://stringr.tidyverse.org/reference/str_replace.xhtml)中使用反向引用。例如，此代码交换了`sentences`中第二个和第三个单词的顺序：
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If you want to extract the matches for each group, you can use [`str_match()`](https://stringr.tidyverse.org/reference/str_match.xhtml).
    But [`str_match()`](https://stringr.tidyverse.org/reference/str_match.xhtml) returns
    a matrix, so it’s not particularly easy to work with:^([8](ch15.xhtml#idm44771292399008))
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要提取每个组的匹配项，可以使用[`str_match()`](https://stringr.tidyverse.org/reference/str_match.xhtml)。但[`str_match()`](https://stringr.tidyverse.org/reference/str_match.xhtml)返回一个矩阵，因此使用起来并不是特别方便：^([8](ch15.xhtml#idm44771292399008))
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You could convert to a tibble and name the columns:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以转换为一个 tibble 并命名列：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: But then you’ve basically re-created your own version of [`separate_wider_regex()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml).
    Indeed, behind the scenes, [`separate_wider_regex()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml)
    converts your vector of patterns to a single regex that uses grouping to capture
    the named components.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 但这样你基本上重新创建了自己版本的[`separate_wider_regex()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml)。事实上，[`separate_wider_regex()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml)在幕后将您的模式向量转换为使用分组以捕获命名组件的单一正则表达式。
- en: Occasionally, you’ll want to use parentheses without creating matching groups.
    You can create a noncapturing group with `(?:)`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您会想在不创建匹配组的情况下使用括号。您可以使用 `(?:)` 创建一个非捕获组。
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Exercises
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: How would you match the literal string `"'\`? How about `"$^$"`?
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何匹配文字字符串`"'`？以及`"$^$"`？
- en: 'Explain why each of these patterns don’t match a `\`: `"\"`, `"\\"`, `"\\\"`.'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释为什么以下每个模式都不匹配`\`：`"\"`，`"\\"`，`"\\\"`。
- en: 'Given the corpus of common words in [`stringr::words`](https://stringr.tidyverse.org/reference/stringr-data.xhtml),
    create regular expressions that find all words that:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定[`stringr::words`](https://stringr.tidyverse.org/reference/stringr-data.xhtml)中的常用词库，创建正则表达式以找到所有满足以下条件的单词：
- en: Start with “y.”
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以“y”开头。
- en: Don’t start with “y.”
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不以“y”开头。
- en: End with “x.”
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以“x”结尾。
- en: Are exactly three letters long. (Don’t cheat by using [`str_length()`](https://stringr.tidyverse.org/reference/str_length.xhtml)!)
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恰好长三个字母。（不要作弊使用[`str_length()`](https://stringr.tidyverse.org/reference/str_length.xhtml)！）
- en: Have seven letters or more.
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有七个或更多个字母。
- en: Contain a vowel-consonant pair.
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含元音辅音对。
- en: Contain at least two vowel-consonant pairs in a row.
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至少包含两个元音辅音对。
- en: Only consist of repeated vowel-consonant pairs.
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只由重复的元音辅音对组成。
- en: 'Create 11 regular expressions that match the British or American spellings
    for each of the following words: airplane/aeroplane, aluminum/aluminium, analog/analogue,
    ass/arse, center/centre, defense/defence, donut/doughnut, gray/grey, modeling/modelling,
    skeptic/sceptic, summarize/summarise. Try to make the shortest possible regex!'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建11个正则表达式，匹配以下每个词的英式或美式拼写：airplane/aeroplane, aluminum/aluminium, analog/analogue,
    ass/arse, center/centre, defense/defence, donut/doughnut, gray/grey, modeling/modelling,
    skeptic/sceptic, summarize/summarise。尽量制作最短的正则表达式！
- en: Switch the first and last letters in `words`. Which of those strings are still
    `words`?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换`words`中的第一个和最后一个字母。哪些字符串仍然是`words`？
- en: 'Describe in words what these regular expressions match (read carefully to see
    if each entry is a regular expression or a string that defines a regular expression):'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用文字描述这些正则表达式匹配的内容（仔细阅读以查看每个条目是正则表达式还是定义正则表达式的字符串）：
- en: '`^.*$`'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`^.*$`'
- en: '`"\\{.+\\}"`'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`"\\{.+\\}"`'
- en: '`\d{4}-\d{2}-\d{2}`'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`\d{4}-\d{2}-\d{2}`'
- en: '`"\\\\{4}"`'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`"\\\\{4}"`'
- en: '`\..\..\..`'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`\..\..\..`'
- en: '`(.)\1\1`'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`(.)\1\1`'
- en: '`"(..)\\1"`'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`"(..)\\1"`'
- en: Solve the [beginner regexp crosswords](https://oreil.ly/Db3NF).
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决[初学者正则表达式跨字谜](https://oreil.ly/Db3NF)。
- en: Pattern Control
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式控制
- en: It’s possible to exercise extra control over the details of the match by using
    a pattern object instead of just a string. This allows you to control the so-called
    regex flags and match various types of fixed strings, as described next.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用模式对象而不仅仅是字符串，可以对匹配的详细信息进行额外控制。这允许你控制所谓的正则表达式标志，并匹配各种类型的固定字符串，如下所述。
- en: Regex Flags
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正则表达式标志
- en: 'A number of settings can be used to control the details of the regexp. These
    settings are often called *flags* in other programming languages. In stringr,
    you can use them by wrapping the pattern in a call to [`regex()`](https://stringr.tidyverse.org/reference/modifiers.xhtml).
    The most useful flag is probably `ignore_case = TRUE` because it allows characters
    to match either their uppercase or lowercase forms:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用多种设置来控制正则表达式的详细信息。这些设置在其他编程语言中通常称为*标志*。在stringr中，可以通过将模式包装在[`regex()`](https://stringr.tidyverse.org/reference/modifiers.xhtml)调用中来使用它们。可能最有用的标志是`ignore_case
    = TRUE`，因为它允许字符匹配它们的大写或小写形式：
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you’re doing a lot of work with multiline strings (i.e., strings that contain
    `\n`), `dotall` and `multiline` may also be useful:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理大量包含`\n`的多行字符串（即多行文本），`dotall`和`multiline`可能也会有用：
- en: '`dotall = TRUE` lets `.` match everything, including `\n`:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotall = TRUE`允许`.`匹配所有内容，包括`\n`：'
- en: '[PRE36]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`multiline = TRUE` makes `^` and `$` match the start and end of each line rather
    than the start and end of the complete string:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`multiline = TRUE`使得`^`和`$`分别匹配每行的开头和结尾，而不是整个字符串的开头和结尾：'
- en: '[PRE37]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, if you’re writing a complicated regular expression and you’re worried
    you might not understand it in the future, you might try `comments = TRUE`. It
    tweaks the pattern language to ignore spaces and new lines, as well as everything
    after `#`. This allows you to use comments and whitespace to make complex regular
    expressions more understandable,^([9](ch15.xhtml#idm44771291954256)) as in the
    following example:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你正在编写复杂的正则表达式，并且担心将来可能不理解它，可以尝试使用`comments = TRUE`。它调整模式语言，忽略空格、换行以及`#`后的所有内容。这允许你使用注释和空白来使复杂的正则表达式更易于理解，^([9](ch15.xhtml#idm44771291954256))
    如下例所示：
- en: '[PRE38]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If you’re using comments and want to match a space, newline, or `#`, you’ll
    need to escape it with `\`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用注释并希望匹配空格、换行或`#`，则需要用`\`转义它。
- en: Fixed Matches
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 固定匹配
- en: 'You can opt out of the regular expression rules by using [`fixed()`](https://stringr.tidyverse.org/reference/modifiers.xhtml):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用[`fixed()`](https://stringr.tidyverse.org/reference/modifiers.xhtml)来退出正则表达式规则：
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[`fixed()`](https://stringr.tidyverse.org/reference/modifiers.xhtml) also gives
    you the ability to ignore case:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[`fixed()`](https://stringr.tidyverse.org/reference/modifiers.xhtml)也允许你忽略大小写：'
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If you’re working with non-English text, you will probably want [`coll()`](https://stringr.tidyverse.org/reference/modifiers.xhtml)
    instead of [`fixed()`](https://stringr.tidyverse.org/reference/modifiers.xhtml),
    as it implements the full rules for capitalization as used by the `locale` you
    specify. See [“Non-English Text”](ch14.xhtml#sec-other-languages) for more details
    on locales.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你处理非英文文本，可能需要使用[`coll()`](https://stringr.tidyverse.org/reference/modifiers.xhtml)而不是[`fixed()`](https://stringr.tidyverse.org/reference/modifiers.xhtml)，因为它按照指定的`locale`实现大写规则的完整规则。详见[“非英文文本”](ch14.xhtml#sec-other-languages)获取更多关于locales的详细信息。
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Practice
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'To put these ideas into practice, we’ll solve a few semi-authentic problems
    next. We’ll discuss three general techniques:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这些想法付诸实践，我们将接下来解决几个半真实的问题。我们将讨论三种常用的技术：
- en: Checking your work by creating simple positive and negative controls
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过创建简单的正负控制来检查你的工作
- en: Combining regular expressions with Boolean algebra
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将正则表达式与布尔代数结合使用
- en: Creating complex patterns using string manipulation
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字符串操作创建复杂的模式
- en: Check Your Work
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查你的工作
- en: 'First, let’s find all sentences that start with “The.” Using the `^` anchor
    alone is not enough:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们找到所有以“The”开头的句子。仅使用`^`锚点是不够的：
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'That pattern also matches sentences starting with words like `They` or `These`.
    We need to make sure that the “e” is the last letter in the word, which we can
    do by adding a word boundary:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式还匹配以“They”或“These”开头的句子。我们需要确保“e”是单词的最后一个字母，可以通过添加单词边界来实现：
- en: '[PRE43]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: What about finding all sentences that begin with a pronoun?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如何找到所有以代词开头的句子？
- en: '[PRE44]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'A quick inspection of the results shows that we’re getting some spurious matches.
    That’s because we’ve forgotten to use parentheses:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 快速检查结果显示我们得到了一些误匹配。这是因为我们忘记使用括号：
- en: '[PRE45]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You might wonder how you might spot such a mistake if it didn’t occur in the
    first few matches. A good technique is to create a few positive and negative matches
    and use them to test that your pattern works as expected:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在最初几次匹配中没有出现这样的错误，你可能会想知道如何发现这样的错误。一个好的技巧是创建几个正面和负面的匹配，并使用它们来测试你的模式是否按预期工作：
- en: '[PRE46]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'It’s typically much easier to come up with good positive examples than negative
    examples, because it takes a while before you’re good enough with regular expressions
    to predict where your weaknesses are. Nevertheless, they’re still useful: as you
    work on the problem, you can slowly accumulate a collection of your mistakes,
    ensuring that you never make the same mistake twice.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，提供好的正面示例比负面示例更容易，因为在熟练掌握正则表达式之前，预测自己的弱点需要一段时间。尽管如此，负面示例仍然很有用：在解决问题时，您可以逐渐积累自己的错误集合，确保不再犯同样的错误。
- en: Boolean Operations
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔运算
- en: 'Imagine we want to find words that contain only consonants. One technique is
    to create a character class that contains all letters except for the vowels (`[^aeiou]`),
    then allow that to match any number of letters (`[^aeiou]+`), and then force it
    to match the whole string by anchoring to the beginning and the end (`^[^aeiou]+$`):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想找到只包含辅音字母的单词。一种技术是创建一个包含所有字母但不包含元音字母的字符类（`[^aeiou]`），然后允许它匹配任意数量的字母（`[^aeiou]+`），然后通过锚定到字符串的开头和结尾来确保匹配整个字符串（`^[^aeiou]+$`）：
- en: '[PRE47]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'But you can make this problem a bit easier by flipping the problem around.
    Instead of looking for words that contain only consonants, we could look for words
    that don’t contain any vowels:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果将问题稍微转变一下，你可以使这个问题变得更简单。我们不再寻找只包含辅音字母的单词，而是寻找不包含任何元音字母的单词：
- en: '[PRE48]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This is a useful technique whenever you’re dealing with logical combinations,
    particularly those involving “and” or “not.” For example, imagine if you want
    to find all words that contain “a” and “b.” There’s no “and” operator built in
    to regular expressions, so we have to tackle it by looking for all words that
    contain an “a” followed by a “b,” or a “b” followed by an “a”:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种在处理逻辑组合时特别有用的技术，特别是涉及“与”或“非”运算的情况。例如，想象一下，如果你想找到所有包含“a”和“b”的单词。正则表达式中没有“与”运算符，因此我们必须通过查找所有包含“a”后跟“b”或“b”后跟“a”的单词来解决这个问题：
- en: '[PRE49]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'It’s simpler to combine the results of two calls to [`str_detect()`](https://stringr.tidyverse.org/reference/str_detect.xhtml):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两次调用[`str_detect()`](https://stringr.tidyverse.org/reference/str_detect.xhtml)的结果组合起来更简单：
- en: '[PRE50]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'What if we wanted to see if there was a word that contains all vowels? If we
    did it with patterns, we’d need to generate `5!` (120) different patterns:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要查看是否有一个单词包含所有元音字母怎么办？如果我们使用模式来做，我们需要生成`5!`（120）种不同的模式：
- en: '[PRE51]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'It’s much simpler to combine five calls to [`str_detect()`](https://stringr.tidyverse.org/reference/str_detect.xhtml):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`str_detect()`](https://stringr.tidyverse.org/reference/str_detect.xhtml)的五次调用来组合要素显然更为简单：
- en: '[PRE52]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In general, if you get stuck trying to create a single regexp that solves your
    problem, take a step back and think if you could break the problem down into smaller
    pieces, solving each challenge before moving onto the next one.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果你试图创建一个单一的正则表达式来解决问题，而陷入困境，那么退一步思考一下，看看是否可以将问题分解成更小的部分，在解决每个挑战之前解决它们。
- en: Creating a Pattern with Code
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用代码创建模式
- en: 'What if we wanted to find all `sentences` that mention a color? The basic idea
    is simple: we just combine alternation with word boundaries:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想找出所有提到颜色的 `sentences`，基本思路很简单：我们只需将选择与单词边界结合起来：
- en: '[PRE53]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: But as the number of colors grows, it would quickly get tedious to construct
    this pattern by hand. Wouldn’t it be nice if we could store the colors in a vector?
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 但随着颜色数量的增加，手动构建这个模式会很快变得乏味。如果我们能将颜色存储在一个向量中，那不是更好吗？
- en: '[PRE54]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Well, we can! We’d just need to create the pattern from the vector using [`str_c()`](https://stringr.tidyverse.org/reference/str_c.xhtml)
    and [`str_flatten()`](https://stringr.tidyverse.org/reference/str_flatten.xhtml):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们可以！我们只需使用 [`str_c()`](https://stringr.tidyverse.org/reference/str_c.xhtml)
    和 [`str_flatten()`](https://stringr.tidyverse.org/reference/str_flatten.xhtml)
    从向量中创建模式：
- en: '[PRE55]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We could make this pattern more comprehensive if we had a good list of colors.
    One place we could start from is the list of built-in colors that R can use for
    plots:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个好的颜色列表，我们可以使这个模式更加全面。我们可以从 R 用于绘图的内置颜色列表开始：
- en: '[PRE56]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'But let’s first eliminate the numbered variants:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们首先消除编号变体：
- en: '[PRE57]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Then we can turn this into one giant pattern. We won’t show the pattern here
    because it’s huge, but you can see it working:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以将这些内容整合成一个巨大的模式。我们不会在这里展示模式，因为它非常庞大，但你可以看到它在运行时的效果：
- en: '[PRE58]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In this example, `cols` contains only numbers and letters, so you don’t need
    to worry about metacharacters. But in general, whenever you create patterns from
    existing strings, it’s wise to run them through [`str_escape()`](https://stringr.tidyverse.org/reference/str_escape.xhtml)
    to ensure they match literally.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`cols` 只包含数字和字母，所以你不需要担心元字符。但通常情况下，当你从现有字符串创建模式时，最好通过 [`str_escape()`](https://stringr.tidyverse.org/reference/str_escape.xhtml)
    确保它们的字面匹配。
- en: Exercises
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'For each of the following challenges, try solving them by using both a single
    regular expression and a combination of multiple [`str_detect()`](https://stringr.tidyverse.org/reference/str_detect.xhtml)
    calls:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于以下每个挑战，尝试通过单个正则表达式和多个 [`str_detect()`](https://stringr.tidyverse.org/reference/str_detect.xhtml)
    调用来解决它们：
- en: Find all `words` that start or end with `x`.
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出所有以 `x` 开头或结尾的 `words`。
- en: Find all `words` that start with a vowel and end with a consonant.
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出所有以元音开头并以辅音结尾的 `words`。
- en: Are there any `words` that contain at least one of each different vowel?
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否有任何包含每个不同元音字母的 `words`？
- en: Construct patterns to find evidence for and against the rule “i before e except
    after c.”
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建模式以找到支持和反对“在 c 之后 e 之前的 i”规则的证据。
- en: '[`colors()`](https://rdrr.io/r/grDevices/colors.xhtml) contains a number of
    modifiers like “lightgray” and “darkblue.” How could you automatically identify
    these modifiers? (Think about how you might detect and then remove the colors
    that are modified.)'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[`colors()`](https://rdrr.io/r/grDevices/colors.xhtml) 包含一些修饰符，如“lightgray”和“darkblue”。你如何自动识别这些修饰符？（思考如何检测并删除被修饰的颜色。）'
- en: 'Create a regular expression that finds any base R dataset. You can get a list
    of these datasets via a special use of the [`data()`](https://rdrr.io/r/utils/data.xhtml)
    function: `data(package = "datasets")$results[, "Item"]`. Note that a number of
    old datasets are individual vectors; these contain the name of the grouping “data
    frame” in parentheses, so you’ll need to strip them off.'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个正则表达式，可以找到任何基本的R数据集。你可以通过 [`data()`](https://rdrr.io/r/utils/data.xhtml)
    函数的特殊用法获取这些数据集的列表：`data(package = "datasets")$results[, "Item"]`。请注意，一些旧的数据集是单独的向量；它们包含了带括号的分组“数据框”的名称，因此你需要去掉它们。
- en: Regular Expressions in Other Places
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他地方的正则表达式
- en: Just like in the stringr and tidyr functions, there are many other places in
    R where you can use regular expressions. The following sections describe some
    other useful functions in the wider tidyverse and base R.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在 stringr 和 tidyr 函数中一样，R 中有许多其他地方可以使用正则表达式。下面的章节描述了更广泛的 tidyverse 和 base
    R 中一些其他有用的函数。
- en: Tidyverse
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tidyverse
- en: 'There are three other particularly useful places where you might want to use
    regular expressions:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 还有三个特别有用的地方，你可能想使用正则表达式：
- en: '`matches(pattern)` will select all variables whose name matches the supplied
    pattern. It’s a “tidyselect” function that you can use anywhere in any tidyverse
    function that selects variables (e.g., [`select()`](https://dplyr.tidyverse.org/reference/select.xhtml),
    [`rename_with()`](https://dplyr.tidyverse.org/reference/rename.xhtml), and [`across()`](https://dplyr.tidyverse.org/reference/across.xhtml)).'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`matches(pattern)`将选择所有名称与提供的模式匹配的变量。这是一个“tidyselect”函数，您可以在选择变量的任何tidyverse函数中使用它（例如[`select()`](https://dplyr.tidyverse.org/reference/select.xhtml)、[`rename_with()`](https://dplyr.tidyverse.org/reference/rename.xhtml)和[`across()`](https://dplyr.tidyverse.org/reference/across.xhtml)）。'
- en: '`pivot_longer()`’s `names_pattern` argument takes a vector of regular expressions,
    just like [`separate_wider_regex()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml).
    It’s useful when extracting data from variable names with a complex structure.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pivot_longer()`的`names_pattern`参数接受正则表达式向量，就像[`separate_wider_regex()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml)一样。在从具有复杂结构的变量名中提取数据时非常有用。'
- en: The `delim` argument in [`separate_longer_delim()`](https://tidyr.tidyverse.org/reference/separate_longer_delim.xhtml)
    and [`sepa⁠rate_​wider_delim()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml)
    usually matches a fixed string, but you can use [`regex()`](https://stringr.tidyverse.org/reference/modifiers.xhtml)
    to make it match a pattern. This is useful, for example, if you want to match
    a comma that is optionally followed by a space, i.e., `regex(", ?")`.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`separate_longer_delim()`](https://tidyr.tidyverse.org/reference/separate_longer_delim.xhtml)和[`separate_wider_delim()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml)中的`delim`参数通常匹配固定字符串，但您可以使用[`regex()`](https://stringr.tidyverse.org/reference/modifiers.xhtml)使其匹配模式。例如，如果您想匹配一个可能后跟空格的逗号，即`regex(",
    ?")`，这将非常有用。'
- en: Base R
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础R
- en: '`apropos(pattern)` searches all objects available from the global environment
    that match the given pattern. This is useful if you can’t quite remember the name
    of a function:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`apropos(pattern)`搜索全局环境中与给定模式匹配的所有可用对象。如果您记不清函数的名称，这将非常有用：'
- en: '[PRE59]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '`list.files(path, pattern)` lists all files in `path` that match a regular
    expression `pattern`. For example, you can find all the R Markdown files in the
    current directory with:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`list.files(path, pattern)`列出了路径`path`中与正则表达式`pattern`匹配的所有文件。例如，您可以在当前目录中找到所有R
    Markdown文件：'
- en: '[PRE60]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: It’s worth noting that the pattern language used by base R is slightly different
    from that used by stringr. That’s because stringr is built on top of the [stringi
    package](https://oreil.ly/abQNx), which is in turn built on top of the [ICU engine](https://oreil.ly/A9Gbl),
    whereas base R functions use either the [TRE engine](https://oreil.ly/yGQ5U) or
    the [PCRE engine](https://oreil.ly/VhVuy), depending on whether you’ve set `perl
    = TRUE`. Fortunately, the basics of regular expressions are so well established
    that you’ll encounter few variations when working with the patterns you’ll learn
    in this book. You only need to be aware of the difference when you start to rely
    on advanced features like complex Unicode character ranges or special features
    that use the `(?…)` syntax.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，基础R使用的模式语言与stringr使用的略有不同。这是因为stringr建立在[stringi包](https://oreil.ly/abQNx)的基础上，而stringi包则建立在[ICU引擎](https://oreil.ly/A9Gbl)的基础上，而基础R函数则使用[TRE引擎](https://oreil.ly/yGQ5U)或[PCRE引擎](https://oreil.ly/VhVuy)，具体取决于您是否设置了`perl
    = TRUE`。幸运的是，正则表达式的基础已经非常成熟，所以在使用本书学到的模式时，您很少会遇到差异。只有在开始依赖像复杂的Unicode字符范围或使用`(?…)`语法的特殊功能时，您才需要注意这种差异。
- en: Summary
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: With every punctuation character potentially overloaded with meaning, regular
    expressions are one of the most compact languages out there. They’re definitely
    confusing at first, but as you train your eyes to read them and your brain to
    understand them, you unlock a powerful skill that you can use in R and in many
    other places.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个标点符号都可能具有多重含义，正则表达式是最紧凑的语言之一。起初它们确实令人困惑，但随着您的眼睛和大脑的训练，您将能够解读并理解它们，从而掌握一项在R和许多其他领域中都可以使用的强大技能。
- en: In this chapter, you’ve started your journey to become a regular expression
    master by learning the most useful stringr functions and the most important components
    of the regular expression language. And there are plenty of resources to learn
    more.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，通过学习最有用的stringr函数和正则表达式语言的最重要组成部分，您已经开始了成为正则表达式大师的旅程。还有许多资源可以进一步学习。
- en: 'A good place to start is [`vignette("regular-expressions", package = "stringr")`](https://stringr.tidyverse.org/articles/regular-expressions.xhtml):
    it documents the full set of syntax supported by stringr. Another useful reference
    is [*https://oreil.ly/MVwoC*](https://oreil.ly/MVwoC). It’s not R specific, but
    you can use it to learn about the most advanced features of regexes and how they
    work under the hood.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的起点是 [`vignette("regular-expressions", package = "stringr")`](https://stringr.tidyverse.org/articles/regular-expressions.xhtml)：它记录了
    stringr 支持的完整语法集。另一个有用的参考是 [*https://oreil.ly/MVwoC*](https://oreil.ly/MVwoC)。它并非专门针对
    R，但你可以用它来了解正则表达式的最高级功能及其内部工作原理。
- en: It’s also good to know that stringr is implemented on top of the stringi package
    by Marek Gagolewski. If you’re struggling to find a function that does what you
    need in stringr, don’t be afraid to look in stringi. You’ll find stringi easy
    to pick up because it follows many of the same conventions as stringr.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串包 stringr 是基于 Marek Gagolewski 的 stringi 包实现的。如果你在 stringr 中找不到需要的功能，不要害怕去看看
    stringi。由于 stringr 遵循许多相同的约定，你会很容易掌握 stringi。
- en: 'In the next chapter, we’ll talk about a data structure closely related to strings:
    factors. Factors are used to represent categorical data in R, i.e., data with
    a fixed and known set of possible values identified by a vector of strings.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论与字符串密切相关的数据结构：因子。因子用于在 R 中表示分类数据，即由字符串向量标识的具有固定和已知可能值集合的数据。
- en: ^([1](ch15.xhtml#idm44771294160112-marker)) You can pronounce it with either
    a hard-g (“reg-x”) or a soft-g (“rej-x”).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch15.xhtml#idm44771294160112-marker)) 你可以用硬音 g（“reg-x”）或软音 g（“rej-x”）来发音它。
- en: ^([2](ch15.xhtml#idm44771294089152-marker)) You’ll learn how to escape these
    special meanings in [“Escaping”](#sec-regexp-escaping).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch15.xhtml#idm44771294089152-marker)) 你将学会如何在 [“转义”](#sec-regexp-escaping)
    中避免这些特殊含义。
- en: ^([3](ch15.xhtml#idm44771294083376-marker)) Well, any character apart from `\n`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch15.xhtml#idm44771294083376-marker)) 嗯，除了 `\n` 之外的任何字符。
- en: ^([4](ch15.xhtml#idm44771293675344-marker)) This gives us the proportion of
    *names* that contain an “x”; if you wanted the proportion of babies with a name
    containing an x, you’d need to perform a weighted mean.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch15.xhtml#idm44771293675344-marker)) 这给出了包含 “x” 的*名称*比例；如果你想要包含 “x” 的名字比例，你需要进行加权平均。
- en: ^([5](ch15.xhtml#idm44771293255808-marker)) We wish we could reassure you that
    you’d never see something this weird in real life, but unfortunately over the
    course of your career you’re likely to see much weirder!
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch15.xhtml#idm44771293255808-marker)) 我们希望能够向你保证，你在实际生活中不会看到这么奇怪的东西，但不幸的是，在你的职业生涯中，你可能会遇到更多奇怪的事情！
- en: ^([6](ch15.xhtml#idm44771293083536-marker)) The complete set of metacharacters
    is `.^$\|*+?{}[]()`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch15.xhtml#idm44771293083536-marker)) 元字符的完整集合是 `.^$\|*+?{}[]()`。
- en: ^([7](ch15.xhtml#idm44771292559200-marker)) Remember, to create a regular expression
    containing `\d` or `\s`, you’ll need to escape the `\` for the string, so you’ll
    type `"\\d"` or `"\\s"`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch15.xhtml#idm44771292559200-marker)) 记住，要创建包含 `\d` 或 `\s` 的正则表达式，你需要为字符串转义
    `\`，因此你会输入 `"\\d"` 或 `"\\s"`。
- en: ^([8](ch15.xhtml#idm44771292399008-marker)) Mostly because we never discuss
    matrices in this book!
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch15.xhtml#idm44771292399008-marker)) 主要是因为我们在这本书中从未讨论过矩阵！
- en: ^([9](ch15.xhtml#idm44771291954256-marker)) `comments = TRUE` is particularly
    effective in combination with a raw string, as we use here.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch15.xhtml#idm44771291954256-marker)) 在这里我们使用的原始字符串中，`comments = TRUE`
    特别有效。
