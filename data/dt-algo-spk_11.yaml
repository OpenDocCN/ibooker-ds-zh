- en: Chapter 8\. Ranking Algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。排名算法
- en: 'This chapter introduces the following two ranking algorithms and presents their
    associated implementations in PySpark:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍以下两种排名算法，并在PySpark中提供它们的相关实现：
- en: Rank product
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 排名产品
- en: This algorithm finds the ranks of items (such as genes) among all items. It
    was originally developed for the detection of differentially expressed genes in
    replicated microarray experiments, but has since achieved widespread acceptance
    and is now used more broadly, including in machine learning. Spark does not provide
    an API for the rank product, so I will present a custom solution.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此算法在所有项目（如基因）中查找排名。它最初是为检测复制的微阵列实验中不同表达基因而开发的，但目前已被广泛接受，并且现在更广泛地用于包括机器学习在内的多个领域。Spark不提供排名产品的API，因此我将提供一个定制的解决方案。
- en: PageRank
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: PageRank
- en: PageRank is an iterative algorithm for measuring the importance of nodes in
    a given graph. This algorithm is used heavily by search engines (such as Google)
    to find the importance of each web page (document) relative to all web pages (a
    set of documents). In a nutshell, given a set of web pages, the PageRank algorithm
    calculates a quality ranking for each page. The Spark API offers multiple solutions
    for the PageRank algorithm. I’ll present one of those, using the GraphFrames API,
    as well as two custom solutions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: PageRank是一种用于衡量给定图中节点重要性的迭代算法。这个算法被搜索引擎（如Google）广泛使用，以找出每个网页（文档）相对于所有网页（一组文档）的重要性。简而言之，给定一组网页，PageRank算法计算每个页面的质量排名。Spark
    API为PageRank算法提供了多种解决方案。我将介绍其中一种，使用GraphFrames API，以及两种定制解决方案。
- en: Rank Product
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排名产品
- en: The rank product is an algorithm commonly used in the field of bioinformatics,
    also known as computational biology. It was originally developed as a biologically
    motivated test for the detection of differentially expressed genes in replicated
    micro-array experiments. As well as expression profiling, it can be used to combine
    ranked lists in other application domains, such as for statistical meta-analysis
    and general feature selection. In bioinformatics and machine learning, the rank
    product has emerged as a simple and intuitive yet powerful ranking method.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 排名产品是生物信息学领域常用的算法，也称为计算生物学。最初开发为检测复制的微阵列实验中不同表达基因的生物学动机测试。除了表达谱分析外，它还可以用于其他应用领域中的排名列表组合，例如统计元分析和一般特征选择。在生物信息学和机器学习中，排名产品已经成为一种简单直观但功能强大的排名方法。
- en: The algorithm does not use any statistics (such as mean or variance), but rather
    scores items (such as genes) on the basis of their ranks in multiple comparisons.
    It’s particularly useful if you have very few replicates (in the context of gene
    analysis), or if you want to analyze how well the results from two studies agree.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法不使用任何统计数据（如均值或方差），而是根据它们在多个比较中的排名对项目（如基因）进行评分。如果你只有非常少的复制品（在基因分析的背景下）或者想要分析两项研究结果的一致性，这一点尤为有用。
- en: 'The rank product algorithm is based on the assumption that under the null hypothesis,
    given that the order of all items is random, the probability (*p*) of finding
    a specific item among the top *r* of *n* items in a list is:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 排名产品算法基于这样的假设：在零假设下，假设所有项目的顺序是随机的，找到特定项目在列表前*r*个中的概率(*p*)是：
- en: <math alttext="dollar-sign p equals StartFraction r Over n EndFraction dollar-sign"><mrow><mi>p</mi>
    <mo>=</mo> <mfrac><mi>r</mi> <mi>n</mi></mfrac></mrow></math>
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign p equals StartFraction r Over n EndFraction dollar-sign"><mrow><mi>p</mi>
    <mo>=</mo> <mfrac><mi>r</mi> <mi>n</mi></mfrac></mrow></math>
- en: 'Multiplying these probabilities leads to the definition of the rank product:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些概率相乘得到排名产品的定义：
- en: <math alttext="dollar-sign upper R upper P equals left-parenthesis product Underscript
    i Endscripts StartFraction r Subscript i Baseline Over n Subscript i Baseline
    EndFraction right-parenthesis dollar-sign right-bracket"><mrow><mi>R</mi> <mi>P</mi>
    <mo>=</mo> <mo>(</mo> <munder><mo>∏</mo> <mi>i</mi></munder> <mfrac><msub><mi>r</mi>
    <mi>i</mi></msub> <msub><mi>n</mi> <mi>i</mi></msub></mfrac> <mo>)</mo></mrow></math>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign upper R upper P equals left-parenthesis product Underscript
    i Endscripts StartFraction r Subscript i Baseline Over n Subscript i Baseline
    EndFraction right-parenthesis dollar-sign right-bracket"><mrow><mi>R</mi> <mi>P</mi>
    <mo>=</mo> <mo>(</mo> <munder><mo>∏</mo> <mi>i</mi></munder> <mfrac><msub><mi>r</mi>
    <mi>i</mi></msub> <msub><mi>n</mi> <mi>i</mi></msub></mfrac> <mo>)</mo></mrow></math>
- en: where *r[i]* is the rank of the item in the *i*th list and *n[i]* is the total
    number of items in the *i*th list. The smaller the *RP* value is, the smaller
    the probability is that the observed placement of the item at the top of the lists
    is due to chance. The rank product is equivalent to calculating the geometric
    mean rank; replacing the product by the sum leads to a statistic (average rank)
    that is slightly more sensitive to outlier data and puts a higher premium on consistency
    between the ranks in various lists.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*r[i]*是第*i*个列表中项目的排名，*n[i]*是第*i*个列表中项目的总数。*RP*值越小，观察到项目在列表顶部的位置不是偶然的概率越小。排名产品等同于计算几何平均排名；用总和替换乘积导致了稍微对异常数据更敏感的统计量（平均排名），并且更加看重各个列表中排名的一致性。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Is this a big data problem? Consider 100 studies, each with 1,000,000 assays
    and each assay with 60,000 records. This translates to 100 × 1,000,000 × 60,000
    = 6,000,000,000,000 records, which is definitely big data.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个大数据问题吗？考虑100个研究，每个研究有1,000,000个测定，每个测定有60,000条记录。这转换为100 × 1,000,000 × 60,000
    = 6,000,000,000,000条记录，这绝对是大数据。
- en: Calculation of the Rank Product
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算排名产品
- en: Given *n* genes and *k* replicates, let *e[g,i]* be the fold change and *r[g,i]*
    the rank of gene *g* in the *i^(th)* replicate.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 给定 *n* 个基因和 *k* 个重复试验，令 *e[g,i]* 为倍数变化，*r[g,i]* 为基因 *g* 在第 *i* 个重复试验中的排名。
- en: 'Compute the rank product (*RP*) via the geometric mean:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过几何平均计算排名产品（*RP*）：
- en: <math alttext="dollar-sign upper R upper P left-parenthesis g right-parenthesis
    equals left-parenthesis product Underscript i equals 1 Overscript k Endscripts
    r Subscript g comma i Baseline right-parenthesis Superscript 1 slash k dollar-sign"><mrow><mi>R</mi>
    <mi>P</mi> <mrow><mo>(</mo> <mi>g</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mfenced
    separators="" open="(" close=")"><munderover><mo>∏</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>k</mi></munderover> <msub><mi>r</mi> <mrow><mi>g</mi><mo>,</mo><mi>i</mi></mrow></msub></mfenced>
    <mrow><mn>1</mn><mo>/</mo><mi>k</mi></mrow></msup></mrow></math>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign upper R upper P left-parenthesis g right-parenthesis
    equals left-parenthesis product Underscript i equals 1 Overscript k Endscripts
    r Subscript g comma i Baseline right-parenthesis Superscript 1 slash k dollar-sign"><mrow><mi>R</mi>
    <mi>P</mi> <mrow><mo>(</mo> <mi>g</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mfenced
    separators="" open="(" close=")"><munderover><mo>∏</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>k</mi></munderover> <msub><mi>r</mi> <mrow><mi>g</mi><mo>,</mo><mi>i</mi></mrow></msub></mfenced>
    <mrow><mn>1</mn><mo>/</mo><mi>k</mi></mrow></msup></mrow></math>
- en: or
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: <math alttext="dollar-sign upper R upper P left-parenthesis g right-parenthesis
    equals RootIndex k StartRoot left-parenthesis product Underscript i equals 1 Overscript
    k Endscripts r Subscript g comma i Baseline right-parenthesis EndRoot dollar-sign"><mrow><mi>R</mi>
    <mi>P</mi> <mrow><mo>(</mo> <mi>g</mi> <mo>)</mo></mrow> <mo>=</mo> <mroot><mfenced
    separators="" open="(" close=")"><munderover><mo>∏</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>k</mi></munderover> <msub><mi>r</mi> <mrow><mi>g</mi><mo>,</mo><mi>i</mi></mrow></msub></mfenced>
    <mi>k</mi></mroot></mrow></math>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign upper R upper P left-parenthesis g right-parenthesis
    equals RootIndex k StartRoot left-parenthesis product Underscript i equals 1 Overscript
    k Endscripts r Subscript g comma i Baseline right-parenthesis EndRoot dollar-sign"><mrow><mi>R</mi>
    <mi>P</mi> <mrow><mo>(</mo> <mi>g</mi> <mo>)</mo></mrow> <mo>=</mo> <mroot><mfenced
    separators="" open="(" close=")"><munderover><mo>∏</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>k</mi></munderover> <msub><mi>r</mi> <mrow><mi>g</mi><mo>,</mo><mi>i</mi></mrow></msub></mfenced>
    <mi>k</mi></mroot></mrow></math>
- en: Formalizing Rank Product
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正式化排名产品
- en: To help you understand the rank product algorithm, I will provide a concrete
    example. Let `{A[1], …, A[k]}` be datasets of (key, value) pairs, where the keys
    are unique per dataset. For example, a key might be an item, a user, or a gene,
    and a value might be the number of items sold, the number of friends of that user,
    or a gene value such as fold change or test expression. Ranks are assigned (typically
    based on the sorted values of the datasets), and the rank product of `{A[1], …,
    A[k]}` is computed based on the ranks `r[i]` for key `i` across all datasets.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您理解排名产品算法，我将提供一个具体的例子。让 `{A[1], …, A[k]}` 是（键，值）对数据集，其中每个数据集的键是唯一的。例如，键可以是一个物品，一个用户或一个基因，而值可以是出售的物品数量，该用户的朋友数量或基因值，如倍数变化或测试表达。根据（通常基于数据集的排序值）分配排名，并且根据所有数据集中键
    `i` 的排名 `r[i]` 计算 `{A[1], …, A[k]}` 的排名产品。
- en: 'Let’s work through a very simple example using three datasets, `A[1]`, `A[2]`,
    `A[3]`. Suppose dataset `A[1]` is composed of the following (key, value) pairs:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个非常简单的例子来使用三个数据集 `A[1]`, `A[2]`, `A[3]`。假设数据集 `A[1]` 由以下（键，值）对组成：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we assign the ranks based on the descending sorted values of the keys, we
    get:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们基于键的降序排序值分配排名，我们得到：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'since `80 > 60 > 30 > 10`. Note that 1 is the highest rank (assigned to the
    largest value). We then do the same for dataset `A[2]`, which has the following
    contents:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `80 > 60 > 30 > 10`。注意，1 是最高的排名（分配给最大的值）。然后我们为数据集 `A[2]` 做同样的操作，该数据集的内容如下：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This gives us:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'since `90 > 70 > 50 > 40`. Finally, dataset `A[3]` looks like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `90 > 70 > 50 > 40`。最后，数据集 `A[3]` 如下所示：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this case assigning the ranks gives us:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，分配排名会给我们带来：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'since `8 > 4`. The rank product of `{A[1], A[2], A[3]}` is then expressed as:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `8 > 4`。然后 `{A[1], A[2], A[3]}` 的排名产品表示为：
- en: <math alttext="dollar-sign left-parenthesis upper K 1 comma RootIndex 3 StartRoot
    3 times 1 times 2 EndRoot right-parenthesis comma dollar-sign"><mrow><mo>(</mo>
    <msub><mi>K</mi> <mn>1</mn></msub> <mo>,</mo> <mroot><mrow><mn>3</mn><mo>×</mo><mn>1</mn><mo>×</mo><mn>2</mn></mrow>
    <mn>3</mn></mroot> <mo>)</mo> <mo>,</mo></mrow></math><math alttext="dollar-sign
    left-parenthesis upper K 2 comma RootIndex 3 StartRoot 2 times 2 times 1 EndRoot
    right-parenthesis comma dollar-sign"><mrow><mo>(</mo> <msub><mi>K</mi> <mn>2</mn></msub>
    <mo>,</mo> <mroot><mrow><mn>2</mn><mo>×</mo><mn>2</mn><mo>×</mo><mn>1</mn></mrow>
    <mn>3</mn></mroot> <mo>)</mo> <mo>,</mo></mrow></math><math alttext="dollar-sign
    left-parenthesis upper K 3 comma RootIndex 2 StartRoot 4 times 4 EndRoot right-parenthesis
    comma dollar-sign"><mrow><mo>(</mo> <msub><mi>K</mi> <mn>3</mn></msub> <mo>,</mo>
    <mroot><mrow><mn>4</mn><mo>×</mo><mn>4</mn></mrow> <mn>2</mn></mroot> <mo>)</mo>
    <mo>,</mo></mrow></math><math alttext="dollar-sign left-parenthesis upper K 4
    comma RootIndex 2 StartRoot 1 times 3 EndRoot right-parenthesis dollar-sign"><mrow><mo>(</mo>
    <msub><mi>K</mi> <mn>4</mn></msub> <mo>,</mo> <mroot><mrow><mn>1</mn><mo>×</mo><mn>3</mn></mrow>
    <mn>2</mn></mroot> <mo>)</mo></mrow></math>
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign left-parenthesis upper K 1 comma RootIndex 3 StartRoot
    3 times 1 times 2 EndRoot right-parenthesis comma dollar-sign"><mrow><mo>(</mo>
    <msub><mi>K</mi> <mn>1</mn></msub> <mo>,</mo> <mroot><mrow><mn>3</mn><mo>×</mo><mn>1</mn><mo>×</mo><mn>2</mn></mrow>
    <mn>3</mn></mroot> <mo>)</mo> <mo>,</mo></mrow></math><math alttext="dollar-sign
    left-parenthesis upper K 2 comma RootIndex 3 StartRoot 2 times 2 times 1 EndRoot
    right-parenthesis comma dollar-sign"><mrow><mo>(</mo> <msub><mi>K</mi> <mn>2</mn></msub>
    <mo>,</mo> <mroot><mrow><mn>2</mn><mo>×</mo><mn>2</mn><mo>×</mo><mn>1</mn></mrow>
    <mn>3</mn></mroot> <mo>)</mo> <mo>,</mo></mrow></math><math alttext="dollar-sign
    left-parenthesis upper K 3 comma RootIndex 2 StartRoot 4 times 4 EndRoot right-parenthesis
    comma dollar-sign"><mrow><mo>(</mo> <msub><mi>K</mi> <mn>3</mn></msub> <mo>,</mo>
    <mroot><mrow><mn>4</mn><mo>×</mo><mn>4</mn></mrow> <mn>2</mn></mroot> <mo>)</mo>
    <mo>,</mo></mrow></math><math alttext="dollar-sign left-parenthesis upper K 4
    comma RootIndex 2 StartRoot 1 times 3 EndRoot right-parenthesis dollar-sign"><mrow><mo>(</mo>
    <msub><mi>K</mi> <mn>4</mn></msub> <mo>,</mo> <mroot><mrow><mn>1</mn><mo>×</mo><mn>3</mn></mrow>
    <mn>2</mn></mroot> <mo>)</mo></mrow></math>
- en: Rank Product Example
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排名 产品 示例
- en: 'Now let’s walk through a real-world example of using rank product:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过一个实际例子来演示使用排名产品：
- en: Let `S = {S[1], S[2], …, S[k]}` be a set of `k` studies, where `k > 0` and each
    study represents a micro-array experiment.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让 `S = {S[1], S[2], …, S[k]}` 是一个包含 `k` 个研究的集合，其中 `k > 0`，每个研究代表一个微阵列实验。
- en: Let `S[i] (i=1, 2, …, k)` be a study, which has an arbitrary number of assays
    identified by `{A[i1], A[i2], …}`.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让 `S[i] (i=1, 2, …, k)` 是一个研究，其中有一个由 `{A[i1], A[i2], …}` 标识的任意数量的检测。
- en: 'Let each assay (which can be represented as a text file) be a set of an arbitrary
    number of records in the following format:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让每个检测（可以表示为文本文件）是一个任意数量记录的集合，格式如下：
- en: '[PRE6]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let `gene_id` be in `{g[1], g[2], …, g[n]}` (we have `n` genes).
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让 `gene_id` 在 `{g[1], g[2], …, g[n]}` 中（我们有 `n` 个基因）。
- en: To find the rank product of all studies, first we find the mean of values per
    gene per study, then for each study we sort the genes by value and assign each
    one a rank. For example, suppose our first study has three assays with the values
    shown in [Table 8-1](#table_assays).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到所有研究的排名积，首先我们找到每个基因每个研究的值的均值，然后对每个研究的基因按值排序并分配排名。例如，假设我们的第一项研究有三个检测，其值显示在[表8-1](#table_assays)中。
- en: Table 8-1\. Gene values for study 1
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-1\. 研究1的基因值
- en: '| Assay 1 | Assay 2 | Assay 3 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 检测 1 | 检测 2 | 检测 3 |'
- en: '| --- | --- | --- |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `g1,1.0` | `g1,2.0` | `g1,12.0` |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `g1,1.0` | `g1,2.0` | `g1,12.0` |'
- en: '| `g2,3.0` | `g2,5.0` | `null` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `g2,3.0` | `g2,5.0` | `null` |'
- en: '| `g3,4.0` | `null` | `g3,2.0` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `g3,4.0` | `null` | `g3,2.0` |'
- en: '| `g4,1.0` | `g4,3.0` | `g4,15.0` |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `g4,1.0` | `g4,3.0` | `g4,15.0` |'
- en: 'The first step is to find the mean of values for each gene (per study). This
    gives us:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是找到每个基因的平均值（每个研究）。这给了我们：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Sorting by value will generate the following results:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 按值排序将产生以下结果：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we assign each gene a rank for that study, based on the sorted values.
    In this case, the result will be as follows (where the last column is the rank):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为该研究中的每个基因分配一个排名，基于排序后的值。在这种情况下，结果将如下所示（最后一列是排名）：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We repeat this process for all the studies to find the rank product (RP) for
    each gene per study. If:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重复这个过程，为所有研究找到每个基因的排名积（RP）。如果：
- en: <math alttext="dollar-sign upper S 1 equals StartSet left-parenthesis g 1 comma
    r 11 right-parenthesis comma left-parenthesis g 2 comma r 12 right-parenthesis
    comma period period period EndSet dollar-sign"><mrow><msub><mi>S</mi> <mn>1</mn></msub>
    <mo>=</mo> <mrow><mo>{</mo> <mrow><mo>(</mo> <msub><mi>g</mi> <mn>1</mn></msub>
    <mo>,</mo> <msub><mi>r</mi> <mn>11</mn></msub> <mo>)</mo></mrow> <mo>,</mo> <mrow><mo>(</mo>
    <msub><mi>g</mi> <mn>2</mn></msub> <mo>,</mo> <msub><mi>r</mi> <mn>12</mn></msub>
    <mo>)</mo></mrow> <mo>,</mo> <mo>.</mo> <mo>.</mo> <mo>.</mo> <mo>}</mo></mrow></mrow></math><math
    alttext="dollar-sign upper S 2 equals StartSet left-parenthesis g 1 comma r 21
    right-parenthesis comma left-parenthesis g 2 comma r 22 right-parenthesis comma
    period period period EndSet dollar-sign"><mrow><msub><mi>S</mi> <mn>2</mn></msub>
    <mo>=</mo> <mrow><mo>{</mo> <mrow><mo>(</mo> <msub><mi>g</mi> <mn>1</mn></msub>
    <mo>,</mo> <msub><mi>r</mi> <mn>21</mn></msub> <mo>)</mo></mrow> <mo>,</mo> <mrow><mo>(</mo>
    <msub><mi>g</mi> <mn>2</mn></msub> <mo>,</mo> <msub><mi>r</mi> <mn>22</mn></msub>
    <mo>)</mo></mrow> <mo>,</mo> <mo>.</mo> <mo>.</mo> <mo>.</mo> <mo>}</mo></mrow></mrow></math>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign upper S 1 equals StartSet left-parenthesis g 1 comma
    r 11 right-parenthesis comma left-parenthesis g 2 comma r 12 right-parenthesis
    comma period period period EndSet dollar-sign"><mrow><msub><mi>S</mi> <mn>1</mn></msub>
    <mo>=</mo> <mrow><mo>{</mo> <mrow><mo>(</mo> <msub><mi>g</mi> <mn>1</mn></msub>
    <mo>,</mo> <msub><mi>r</mi> <mn>11</mn></msub> <mo>)</mo></mrow> <mo>,</mo> <mrow><mo>(</mo>
    <msub><mi>g</mi> <mn>2</mn></msub> <mo>,</mo> <msub><mi>r</mi> <mn>12</mn></msub>
    <mo>)</mo></mrow> <mo>,</mo> <mo>.</mo> <mo>.</mo> <mo>.</mo> <mo>}</mo></mrow></mrow></math><math
    alttext="dollar-sign upper S 2 equals StartSet left-parenthesis g 1 comma r 21
    right-parenthesis comma left-parenthesis g 2 comma r 22 right-parenthesis comma
    period period period EndSet dollar-sign"><mrow><msub><mi>S</mi> <mn>2</mn></msub>
    <mo>=</mo> <mrow><mo>{</mo> <mrow><mo>(</mo> <msub><mi>g</mi> <mn>1</mn></msub>
    <mo>,</mo> <msub><mi>r</mi> <mn>21</mn></msub> <mo>)</mo></mrow> <mo>,</mo> <mrow><mo>(</mo>
    <msub><mi>g</mi> <mn>2</mn></msub> <mo>,</mo> <msub><mi>r</mi> <mn>22</mn></msub>
    <mo>)</mo></mrow> <mo>,</mo> <mo>.</mo> <mo>.</mo> <mo>.</mo> <mo>}</mo></mrow></mrow></math>
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: <math alttext="dollar-sign upper S Subscript k Baseline equals StartSet left-parenthesis
    g 1 comma r Subscript k Baseline 1 Baseline right-parenthesis comma left-parenthesis
    g 2 comma r Subscript k Baseline 2 Baseline right-parenthesis comma period period
    period EndSet dollar-sign"><mrow><msub><mi>S</mi> <mi>k</mi></msub> <mo>=</mo>
    <mrow><mo>{</mo> <mrow><mo>(</mo> <msub><mi>g</mi> <mn>1</mn></msub> <mo>,</mo>
    <msub><mi>r</mi> <mrow><mi>k</mi><mn>1</mn></mrow></msub> <mo>)</mo></mrow> <mo>,</mo>
    <mrow><mo>(</mo> <msub><mi>g</mi> <mn>2</mn></msub> <mo>,</mo> <msub><mi>r</mi>
    <mrow><mi>k</mi><mn>2</mn></mrow></msub> <mo>)</mo></mrow> <mo>,</mo> <mo>.</mo>
    <mo>.</mo> <mo>.</mo> <mo>}</mo></mrow></mrow></math>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign upper S Subscript k Baseline equals StartSet left-parenthesis
    g 1 comma r Subscript k Baseline 1 Baseline right-parenthesis comma left-parenthesis
    g 2 comma r Subscript k Baseline 2 Baseline right-parenthesis comma period period
    period EndSet dollar-sign"><mrow><msub><mi>S</mi> <mi>k</mi></msub> <mo>=</mo>
    <mrow><mo>{</mo> <mrow><mo>(</mo> <msub><mi>g</mi> <mn>1</mn></msub> <mo>,</mo>
    <msub><mi>r</mi> <mrow><mi>k</mi><mn>1</mn></mrow></msub> <mo>)</mo></mrow> <mo>,</mo>
    <mrow><mo>(</mo> <msub><mi>g</mi> <mn>2</mn></msub> <mo>,</mo> <msub><mi>r</mi>
    <mrow><mi>k</mi><mn>2</mn></mrow></msub> <mo>)</mo></mrow> <mo>,</mo> <mo>.</mo>
    <mo>.</mo> <mo>.</mo> <mo>}</mo></mrow></mrow></math>
- en: 'Then, the rank product of gene *g[j]* can be expressed as:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，基因 *g[j]* 的排名积可以表示为：
- en: <math alttext="dollar-sign upper R upper P left-parenthesis g Subscript j Baseline
    right-parenthesis equals left-parenthesis product Underscript i equals 1 Overscript
    k Endscripts r Subscript i comma j Baseline right-parenthesis Superscript 1 slash
    k dollar-sign"><mrow><mi>R</mi> <mi>P</mi> <mrow><mo>(</mo> <msub><mi>g</mi> <mi>j</mi></msub>
    <mo>)</mo></mrow> <mo>=</mo> <msup><mfenced separators="" open="(" close=")"><munderover><mo>∏</mo>
    <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mi>k</mi></munderover> <msub><mi>r</mi>
    <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></mfenced> <mrow><mn>1</mn><mo>/</mo><mi>k</mi></mrow></msup></mrow></math>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign upper R upper P left-parenthesis g Subscript j Baseline
    right-parenthesis equals left-parenthesis product Underscript i equals 1 Overscript
    k Endscripts r Subscript i comma j Baseline right-parenthesis Superscript 1 slash
    k dollar-sign"><mrow><mi>R</mi> <mi>P</mi> <mrow><mo>(</mo> <msub><mi>g</mi> <mi>j</mi></msub>
    <mo>)</mo></mrow> <mo>=</mo> <msup><mfenced separators="" open="(" close=")"><munderover><mo>∏</mo>
    <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mi>k</mi></munderover> <msub><mi>r</mi>
    <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></mfenced> <mrow><mn>1</mn><mo>/</mo><mi>k</mi></mrow></msup></mrow></math>
- en: 'or:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 或：
- en: <math alttext="dollar-sign upper R upper P left-parenthesis g Subscript j Baseline
    right-parenthesis equals RootIndex k StartRoot left-parenthesis product Underscript
    i equals 1 Overscript k Endscripts r Subscript i comma j Baseline right-parenthesis
    EndRoot dollar-sign"><mrow><mi>R</mi> <mi>P</mi> <mrow><mo>(</mo> <msub><mi>g</mi>
    <mi>j</mi></msub> <mo>)</mo></mrow> <mo>=</mo> <mroot><mfenced separators="" open="("
    close=")"><munderover><mo>∏</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mi>k</mi></munderover>
    <msub><mi>r</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></mfenced>
    <mi>k</mi></mroot></mrow></math>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign upper R upper P left-parenthesis g Subscript j Baseline
    right-parenthesis equals RootIndex k StartRoot left-parenthesis product Underscript
    i equals 1 Overscript k Endscripts r Subscript i comma j Baseline right-parenthesis
    EndRoot dollar-sign"><mrow><mi>R</mi> <mi>P</mi> <mrow><mo>(</mo> <msub><mi>g</mi>
    <mi>j</mi></msub> <mo>)</mo></mrow> <mo>=</mo> <mroot><mfenced separators="" open="("
    close=")"><munderover><mo>∏</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mi>k</mi></munderover>
    <msub><mi>r</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></mfenced>
    <mi>k</mi></mroot></mrow></math>
- en: Now, let’s dig into a solution using PySpark.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入研究一个使用PySpark的解决方案。
- en: PySpark Solution
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PySpark解决方案
- en: As mentioned previously, Spark does not provide an API for the rank product
    algorithm, so I’ve developed my own solution.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Spark并没有提供排名积算法的API，因此我开发了自己的解决方案。
- en: Note
  id: totrans-70
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A webcast presenting my solution for rank product using the Java API for Spark
    is available on the [O’Reilly website](https://oreil.ly/clYwx), and the associated
    Java Spark code is available on [GitHub](https://oreil.ly/pPmOX).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一部分展示了使用Java API for Spark解决排名积问题的网络直播，可以在[O’Reilly网站](https://oreil.ly/clYwx)上找到，相关的Java
    Spark代码在[GitHub](https://oreil.ly/pPmOX)上找到。
- en: 'The PySpark solution presented here will accept `K` input paths (continuing
    with the previous example, we’ll say that each path represents a study, which
    may have any number of assay files). At a high level, these are the steps we’ll
    use to find the rank product of each gene that appears in these studies:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此处介绍的PySpark解决方案将接受`K`个输入路径（继续使用前面的示例，每个路径代表一个研究，可以有任意数量的测定文件）。在高层次上，以下是我们将用来查找在这些研究中出现的每个基因的排名产品的步骤：
- en: Find the mean value per gene per study (in some situations you may prefer to
    apply other functions to find the median). We’ll use COPA scores as our values.^([1](ch08.xhtml#idm45713536222368))
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到每项研究中每个基因的平均值（在某些情况下，您可能更喜欢应用其他函数来找到中位数）。我们将使用COPA分数作为我们的值。^([1](ch08.xhtml#idm45713536222368))
- en: Sort the genes by value per study and then assign rank values (rank values will
    be `{1, 2, …, *N*}` where `1` is assigned to the highest value and *`N`* is assigned
    to the lowest).
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据每项研究中的值对基因进行排序，然后分配排名值（排名值将是`{1, 2, …, *N*}`，其中`1`分配给最高值，*`N`*分配给最低值）。
- en: Finally, compute the rank product per gene for all studies. This can be accomplished
    by grouping all ranks by key.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，计算所有研究的每个基因的排名产品。这可以通过按键分组所有排名来完成。
- en: To implement the final step, we may use `RDD.groupByKey()` or `RDD.combineByKey()`.
    Both solutions are available on [GitHub](https://oreil.ly/SFfH3), labeled as *rank_product_using_groupbykey.py*
    and *rank_product_using_combinebykey.py*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现最终步骤，我们可以使用`RDD.groupByKey()`或`RDD.combineByKey()`。这两种解决方案都在[GitHub](https://oreil.ly/SFfH3)上可用，标记为*rank_product_using_groupbykey.py*和*rank_product_using_combinebykey.py*。
- en: Note that the PySpark solution using `combineByKey()` is more efficient than
    the `groupByKey()` solution. As discussed in [Chapter 4](ch04.xhtml#unique_chapter_id_04),
    this is because `combineByKey()` intermediate values are reduced (or combined)
    by local workers before being sent for the final reduction, whereas with `groupByKey()`
    there is no local reduction; all values are sent to one location for further processing.
    I will only present the solution with `combineByKey()` in detail here.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用`combineByKey()`的PySpark解决方案比使用`groupByKey()`解决方案更有效。如第4章中讨论的，这是因为`combineByKey()`中间值在发送给最终减少之前由本地工作人员减少（或合并），而使用`groupByKey()`则没有本地减少；所有值都发送到一个位置进行进一步处理。我只会在这里详细介绍使用`combineByKey()`的解决方案。
- en: Input data format
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输入数据格式
- en: 'Each assay (which can be represented as a text file) is a set of an arbitrary
    number of records in the following format:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测定（可以表示为文本文件）是以下格式中任意数量记录的集合：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: where `gene_id` is a key which has an associated value of type `Double`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`gene_id`是一个关键字，具有类型为`Double`的相关值。
- en: 'For demonstration purposes, where `K=3` (number of studies), I will use the
    following sample input:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，其中`K=3`（研究数量），我将使用以下示例输入：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Output data format
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输出数据格式
- en: 'We will generate output in the following format:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以以下格式生成输出：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: where *`<R>`* is the rank product among all the input datasets and *`<N>`* is
    the number of values participating in computing the rank product.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的*`<R>`*是所有输入数据集中的排名产品，*`<N>`*是参与计算排名产品的值的数量。
- en: Rank product solution using combineByKey()
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`combineByKey()`计算排名产品解决方案
- en: 'The complete solution is presented in the program *rank_product_using_combinebykey.py*.
    It requires the following input/output parameters:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的解决方案在程序*rank_product_using_combinebykey.py*中展示。它需要以下输入/输出参数：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To implement a PySpark solution to the rank product problem using the `combineByKey()`
    transformation I used the following driver program, which calls several Python
    functions:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现使用`combineByKey()`转换的PySpark排名产品问题的解决方案，我使用了以下驱动程序，该程序调用了几个Python函数：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let’s take a closer look at the three main steps.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看三个主要步骤。
- en: 'Step 1: Compute the mean per gene per study'
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第1步：计算每项研究中每个基因的平均值
- en: 'To find the rank product of our dataset, we first need to find the mean value
    of each gene per study. This is accomplished with the `compute_mean()` function.
    To calculate the mean of values per key (`gene_id`) using the `combineByKey()`
    transformation, we can create a combined data type as `(Double, Integer)` which
    denotes `(sum-of-values, count-of-values)`. Finally, to find the means, we divide
    `sum-of-values` by `count-of-values`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到数据集的排名产品，我们首先需要找到每个基因在每项研究中的平均值。这可以通过`compute_mean()`函数完成。使用`combineByKey()`转换来计算键（`gene_id`）的值的平均值，我们可以创建一个组合数据类型`(Double,
    Integer)`，表示`(值的总和，值的数量)`。最后，为了找到平均值，我们将`值的总和`除以`值的数量`：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Step 2: Compute the rank of each gene per study'
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第2步：计算每项研究中每个基因的排名
- en: 'To compute the rank of each `gene_id`, we perform the following three substeps:
    . Sort values based on absolute value of COPA scores. To sort by COPA score, we
    will swap the keys with the values and then sort by key. . Assign a rank from
    1 (for the gene with the highest COPA score) to *`n`* (for the gene with the lowest
    COPA score). . Calculate the rank for each `gene_id` using `Math.power(R[1] *
    R[2] * … * R[n], 1/n)`.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算每个`gene_id`的排名，我们执行以下三个子步骤： . 根据COPA分数的绝对值排序值。为了按COPA分数排序，我们将键与值交换，然后按键排序。
    . 为每个基因分配从1（具有最高COPA分数的基因）到*`n`*（具有最低COPA分数的基因）的排名。 . 使用`Math.power(R[1] * R[2]
    * … * R[n], 1/n)`计算每个`gene_id`的排名。
- en: 'This entire step is accomplished by the `assign_rank()` function. Ranks are
    assigned by using `RDD.zipWithIndex()`, which zips this RDD with its element indices
    (these indices will be the ranks). Spark indices start from 0, so we add 1 when
    computing the rank product:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 该整个步骤由`assign_rank()`函数完成。通过使用`RDD.zipWithIndex()`为排名分配排名，该函数将此RDD与其元素索引进行压缩（这些索引将是排名）。Spark索引从0开始，因此在计算排名乘积时我们加1：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Step 3: Calculate the rank product for each gene'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第3步：计算每个基因的排名乘积
- en: 'Finally, we call `compute_rank_products()` to calculate the rank product for
    each gene, which combines all the ranks into one RDD and then calculates the rank
    product for each gene using the `combineByKey()` transformation:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`compute_rank_products()`来计算每个基因的排名乘积，该方法将所有排名组合成一个RDD，然后使用`combineByKey()`转换来计算每个基因的排名乘积：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let’s go through a sample run using `combineByKey()`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用`combineByKey()`进行一个示例运行：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here is the final output per key:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是每个键的最终输出：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Rank product solution using groupByKey()
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`groupByKey()`进行排名乘积解决方案
- en: 'A rank product solution using the `groupByKey()` transformation instead of
    `combineByKey()` is available on GitHub, as *rank_product_using_groupbykey.py*.
    Overall, the `combineByKey()` solution is more scalable because of how the shuffle
    step is implemented by these two transformations: `combineByKey()` uses combiners
    as much as possible, but `groupByKey()` takes all the values to a single place
    and then applies the required algorithms.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub上提供了一个使用`groupByKey()`转换而不是`combineByKey()`的排名乘积解决方案，命名为*rank_product_using_groupbykey.py*。总体来说，由于这两种转换实现了shuffle步骤的方式不同，`combineByKey()`解决方案更具可扩展性：`combineByKey()`尽可能使用组合器，但`groupByKey()`将所有值传输到一个位置，然后应用所需的算法。
- en: PageRank
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PageRank
- en: 'In this section we’ll turn our attention to another ranking algorithm: PageRank.
    This algorithm made Google stand out from other search engines, and it is still
    an essential part of how search engines know what pages a user is likely to want
    to see, as it allows them to determine a page’s relevance or importance with respect
    to others. Extensions of the PageRank algorithm have also been used to fight against
    spam.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将注意力转向另一个排名算法：PageRank。该算法使Google脱颖而出，成为其他搜索引擎的重要组成部分，至今仍不可或缺，因为它允许它们确定用户可能希望查看的页面，从而确定页面与其他页面的相关性或重要性。PageRank算法的扩展也用于打击垃圾邮件。
- en: Note
  id: totrans-112
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: For details on how PageRank works under the hood (or at least, how it used to),
    see the article [“Understanding Google Page Rank”](https://oreil.ly/9DDEn) by
    Ian Rogers.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有关PageRank如何在底层工作的详细信息（或者至少是以前的工作方式），请参阅Ian Rogers的文章[“理解Google Page Rank”](https://oreil.ly/9DDEn)。
- en: The PageRank algorithm measures the importance of each node in a graph (such
    as the web pages on the internet), assuming an edge from node `u` to node `v`
    represents an endorsement of `v`’s importance by `u`. The main premise is that
    a node is important if other important nodes point to it. For example, if a Twitter
    user is followed by many other users—particularly users who themselves have large
    numbers of followers—then that user will be ranked highly. Any web designer who
    wants to improve their site’s search engine ranking should take the time to fully
    understand how PageRank really works. (Note that PageRank is purely a link analysis
    algorithm and says nothing about the language, content, or size of a page.)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: PageRank算法衡量图中每个节点的重要性（例如互联网上的网页），假设从节点`u`到节点`v`的边表示`u`对`v`重要性的认可。其主要前提是，如果其他重要节点指向某节点，则该节点重要。例如，如果一个Twitter用户被许多其他用户关注，特别是那些拥有大量粉丝的用户，则该用户的排名将很高。任何希望提高其网站搜索引擎排名的网页设计师都应该花时间充分理解PageRank的工作原理。（请注意，PageRank纯粹是一种链接分析算法，与页面的语言、内容或大小无关。）
- en: '[Figure 8-1](#pagranks_example) illustrates the concept of PageRank using a
    simple graph representing a set of linked documents.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-1](#pagranks_example)说明了使用简单图表示一组链接文档的PageRank概念。'
- en: '![PageRanks Example](Images/daws_0801.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![PageRanks示例](Images/daws_0801.png)'
- en: Figure 8-1\. PageRank example
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-1\. PageRank示例
- en: Notice that page C has a higher PageRank than page E, even though there are
    fewer links to C; this is because the one link to C comes from a very important
    page (page B) and hence is of high value. Without damping, all web surfers would
    eventually end up on pages B or C (since they have the highest PageRank scores),
    and all other pages would have PageRank scores close to zero.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，页面C的PageRank比页面E高，即使C的链接较少；这是因为指向C的一个链接来自非常重要的页面B（因此具有高价值）。没有阻尼的话，所有的网络冲浪者最终都会进入页面B或C（因为它们具有最高的PageRank分数），而所有其他页面的PageRank分数接近零。
- en: The PageRank algorithm is an iterative and converging algorithm. It begins at
    step one with some initial PageRank (as a `Double` data type) assigned to all
    pages, and the algorithm is then applied iteratively until it arrives at a steady
    state called the convergence point. This is the point at which a PageRank has
    been distributed to all pages, and a subsequent iteration of the algorithm will
    produce little or no further change in the distribution (you can specify the threshold
    for this).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: PageRank算法是一种迭代且收敛的算法。它从第一步开始，将一些初始PageRank（作为`Double`数据类型）分配给所有页面，然后迭代应用该算法，直到到达称为收敛点的稳定状态。这是一个页面已分配了PageRank，并且算法的后续迭代将在分布中产生很少或没有进一步的变化的点（您可以为此指定阈值）。
- en: 'Let’s take a look at how the algorithm is defined. Here, we’ll assume page
    A is pointed to (cited) by pages {*T*[1], …, *T*[n]}. The PageRank (*PR*) of page
    `A` is then given as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看算法是如何定义的。在这里，我们假设页面A被页面{*T*[1]，…，*T*[n]}所指向（引用）。然后，页面`A`的PageRank（*PR*）定义如下：
- en: <math alttext="dollar-sign upper P upper R left-parenthesis upper A right-parenthesis
    equals left-parenthesis 1 minus d right-parenthesis plus d times left-bracket
    StartFraction upper P upper R left-parenthesis upper T 1 right-parenthesis Over
    upper L left-parenthesis upper T 1 right-parenthesis EndFraction plus period period
    period plus StartFraction upper P upper R left-parenthesis upper T Subscript n
    Baseline right-parenthesis Over upper L left-parenthesis upper T Subscript n Baseline
    right-parenthesis EndFraction right-bracket dollar-sign"><mrow><mi>P</mi> <mi>R</mi>
    <mrow><mo>(</mo> <mi>A</mi> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo> <mn>1</mn>
    <mo>-</mo> <mi>d</mi> <mo>)</mo></mrow> <mo>+</mo> <mi>d</mi> <mo>×</mo> <mfenced
    separators="" open="[" close="]"><mstyle scriptlevel="0" displaystyle="true"><mfrac><mrow><mi>P</mi><mi>R</mi><mo>(</mo><msub><mi>T</mi>
    <mn>1</mn></msub> <mo>)</mo></mrow> <mrow><mi>L</mi><mo>(</mo><msub><mi>T</mi>
    <mn>1</mn></msub> <mo>)</mo></mrow></mfrac></mstyle> <mo>+</mo> <mo>.</mo> <mo>.</mo>
    <mo>.</mo> <mo>+</mo> <mstyle scriptlevel="0" displaystyle="true"><mfrac><mrow><mi>P</mi><mi>R</mi><mo>(</mo><msub><mi>T</mi>
    <mi>n</mi></msub> <mo>)</mo></mrow> <mrow><mi>L</mi><mo>(</mo><msub><mi>T</mi>
    <mi>n</mi></msub> <mo>)</mo></mrow></mfrac></mstyle></mfenced></mrow></math>
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign upper P upper R left-parenthesis upper A right-parenthesis
    equals left-parenthesis 1 minus d right-parenthesis plus d times left-bracket
    StartFraction upper P upper R left-parenthesis upper T 1 right-parenthesis Over
    upper L left-parenthesis upper T 1 right-parenthesis EndFraction plus period period
    period plus StartFraction upper P upper R left-parenthesis upper T Subscript n
    Baseline right-parenthesis Over upper L left-parenthesis upper T Subscript n Baseline
    right-parenthesis EndFraction right-bracket dollar-sign"><mrow><mi>P</mi> <mi>R</mi>
    <mrow><mo>(</mo> <mi>A</mi> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo> <mn>1</mn>
    <mo>-</mo> <mi>d</mi> <mo>)</mo></mrow> <mo>+</mo> <mi>d</mi> <mo>×</mo> <mfenced
    separators="" open="[" close="]"><mstyle scriptlevel="0" displaystyle="true"><mfrac><mrow><mi>P</mi><mi>R</mi><mo>(</mo><msub><mi>T</mi>
    <mn>1</mn></msub> <mo>)</mo></mrow> <mrow><mi>L</mi><mo>(</mo><msub><mi>T</mi>
    <mn>1</mn></msub> <mo>)</mo></mrow></mfrac></mstyle> <mo>+</mo> <mo>.</mo> <mo>.</mo>
    <mo>.</mo> <mo>+</mo> <mstyle scriptlevel="0" displaystyle="true"><mfrac><mrow><mi>P</mi><mi>R</mi><mo>(</mo><msub><mi>T</mi>
    <mi>n</mi></msub> <mo>)</mo></mrow> <mrow><mi>L</mi><mo>(</mo><msub><mi>T</mi>
    <mi>n</mi></msub> <mo>)</mo></mrow></mfrac></mstyle></mfenced></mrow></math>
- en: where *d* is a damping factor that can be set between 0 and 1 (the usual value
    is 0.85), *PR*(*T[i]*) is the PageRank of page *T[i]* that links to page A, and
    *L*(*T[i]*) is the number of outbound links on page *T[i]*. Note that the PageRanks
    form a probability distribution over web pages, so the sum of all web pages’ PageRanks
    will be 1.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*d*是可以设置在0和1之间的阻尼因子（通常值为0.85），*PR*(*T[i]*)是链接到页面A的页面*T[i]*的PageRank，*L*(*T[i]*)是页面*T[i]*上的出站链接数。注意，PageRanks形成对网页的概率分布，因此所有网页的PageRanks之和将为1。
- en: Note
  id: totrans-123
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: Why is a damping factor added? PageRank is based on the random surfer model.
    Essentially, the damping factor is a decay factor. It represents the chance that
    a user will stop clicking links and request another random page (e.g., by directly
    typing in a new URL rather than following a link on the current page). A damping
    factor of 0.85 indicates that we assume there is about a 15% chance that a typical
    user won’t follow any links on the page and instead will navigate to a new random
    URL.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么添加阻尼因子？PageRank基于随机冲浪者模型。本质上，阻尼因子是一个衰减因子。它表示用户停止点击链接并请求另一个随机页面的机会（例如，直接键入新的URL而不是跟随当前页面上的链接）。阻尼因子为0.85表示我们假设典型用户不会在页面上跟随任何链接的概率约为15%，而是会导航到一个新的随机URL。
- en: Given a graph of web pages with incoming and outgoing links, the PageRank algorithm
    can tell us the importance or relevance of each node. The PageRank of each page
    depends on the PageRanks of the pages pointing to it. In short, PageRank is a
    “vote,” by all the other pages on the web, about how important a page is.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 给定具有传入和传出链接的网页图，PageRank算法可以告诉我们每个节点的重要性或相关性。每个页面的PageRank取决于指向它的页面的PageRank。简而言之，PageRank是所有其他网页关于一个页面重要性的“投票”。
- en: PageRank’s Iterative Computation
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PageRank的迭代计算
- en: 'Given a set of *N* web pages, PageRank can be computed either iteratively or
    algebraically. The iterative method can be defined as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一组*N*个网页，PageRank可以通过迭代或代数方法计算。迭代方法可以定义如下：
- en: 'At (`t = 0`), an initial probability distribution is assumed, usually:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在（`t = 0`）时，假定一个初始概率分布通常是：
- en: <math alttext="dollar-sign upper P upper R left-parenthesis p Subscript i Baseline
    comma 0 right-parenthesis equals StartFraction 1 Over upper N EndFraction dollar-sign"><mrow><mi>P</mi>
    <mi>R</mi> <mrow><mo>(</mo> <msub><mi>p</mi> <mi>i</mi></msub> <mo>,</mo> <mn>0</mn>
    <mo>)</mo></mrow> <mo>=</mo> <mstyle scriptlevel="0" displaystyle="true"><mfrac><mn>1</mn>
    <mi>N</mi></mfrac></mstyle></mrow></math>
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign upper P upper R left-parenthesis p Subscript i Baseline
    comma 0 right-parenthesis equals StartFraction 1 Over upper N EndFraction dollar-sign"><mrow><mi>P</mi>
    <mi>R</mi> <mrow><mo>(</mo> <msub><mi>p</mi> <mi>i</mi></msub> <mo>,</mo> <mn>0</mn>
    <mo>)</mo></mrow> <mo>=</mo> <mstyle scriptlevel="0" displaystyle="true"><mfrac><mn>1</mn>
    <mi>N</mi></mfrac></mstyle></mrow></math>
- en: 'At each time step, the computation, as detailed above, yields:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个时间步骤，如上所述的计算结果如下：
- en: <math alttext="upper P upper R left-parenthesis p Subscript i Baseline comma
    t plus 1 right-parenthesis equals StartFraction 1 minus d Over upper N EndFraction
    plus d sigma-summation Underscript p Subscript j Baseline element-of upper B Subscript
    p Sub Subscript i Baseline Endscripts StartFraction upper P upper R left-parenthesis
    p Subscript j Baseline comma t right-parenthesis Over upper L left-parenthesis
    p Subscript j Baseline right-parenthesis EndFraction" display="block"><mrow><mi>P</mi>
    <mi>R</mi> <mrow><mo>(</mo> <msub><mi>p</mi> <mi>i</mi></msub> <mo>,</mo> <mi>t</mi>
    <mo>+</mo> <mn>1</mn> <mo>)</mo></mrow> <mo>=</mo> <mstyle scriptlevel="0" displaystyle="true"><mfrac><mrow><mn>1</mn><mo>-</mo><mi>d</mi></mrow>
    <mi>N</mi></mfrac></mstyle> <mo>+</mo> <mi>d</mi> <munder><mo>∑</mo> <mrow><msub><mi>p</mi>
    <mi>j</mi></msub> <mo>∈</mo><msub><mi>B</mi> <msub><mi>p</mi> <mi>i</mi></msub></msub></mrow></munder>
    <mstyle scriptlevel="0" displaystyle="true"><mfrac><mrow><mi>P</mi><mi>R</mi><mo>(</mo><msub><mi>p</mi>
    <mi>j</mi></msub> <mo>,</mo><mi>t</mi><mo>)</mo></mrow> <mrow><mi>L</mi><mo>(</mo><msub><mi>p</mi>
    <mi>j</mi></msub> <mo>)</mo></mrow></mfrac></mstyle></mrow></math>
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="upper P upper R left-parenthesis p Subscript i Baseline comma
    t plus 1 right-parenthesis equals StartFraction 1 minus d Over upper N EndFraction
    plus d sigma-summation Underscript p Subscript j Baseline element-of upper B Subscript
    p Sub Subscript i Baseline Endscripts StartFraction upper P upper R left-parenthesis
    p Subscript j Baseline comma t right-parenthesis Over upper L left-parenthesis
    p Subscript j Baseline right-parenthesis EndFraction" display="block"><mrow><mi>P</mi>
    <mi>R</mi> <mrow><mo>(</mo> <msub><mi>p</mi> <mi>i</mi></msub> <mo>,</mo> <mi>t</mi>
    <mo>+</mo> <mn>1</mn> <mo>)</mo></mrow> <mo>=</mo> <mstyle scriptlevel="0" displaystyle="true"><mfrac><mrow><mn>1</mn><mo>-</mo><mi>d</mi></mrow>
    <mi>N</mi></mfrac></mstyle> <mo>+</mo> <mi>d</mi> <munder><mo>∑</mo> <mrow><msub><mi>p</mi>
    <mi>j</mi></msub> <mo>∈</mo><msub><mi>B</mi> <msub><mi>p</mi> <mi>i</mi></msub></msub></mrow></munder>
    <mstyle scriptlevel="0" displaystyle="true"><mfrac><mrow><mi>P</mi><mi>R</mi><mo>(</mo><msub><mi>p</mi>
    <mi>j</mi></msub> <mo>,</mo><mi>t</mi><mo>)</mo></mrow> <mrow><mi>L</mi><mo>(</mo><msub><mi>p</mi>
    <mi>j</mi></msub> <mo>)</mo></mrow></mfrac></mstyle></mrow></math>
- en: It is believed that Google (and other search engines) recalculates PageRank
    scores each time it crawls the web and rebuilds its search index. As the number
    of documents in the collection increases, the accuracy of the initial approximation
    of PageRank decreases for all documents. Therefore, the PageRank algorithm ranks
    websites by the number and quality of incoming links. The quality of an incoming
    link is defined as a function of the PageRank of the site that provides the link.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 据信Google（以及其他搜索引擎）在每次爬网并重建其搜索索引时会重新计算PageRank分数。随着收藏中文档数量的增加，对所有文档的PageRank的初始近似精度会降低。因此，PageRank算法通过入站链接的数量和质量对网站进行排名。入站链接的质量定义为提供链接的站点的PageRank函数。
- en: Note
  id: totrans-133
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that this is an extremely simplified description of the original
    PageRank algorithm. Google (and others who use similar PageRank algorithms) take
    many other factors, such as keyword density, traffic, domain age, etc., into consideration
    for calculating the PageRank of a web page.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这只是对原始PageRank算法的极其简化的描述。Google（以及其他使用类似PageRank算法的公司）考虑许多其他因素，如关键词密度、流量、域名年龄等，以计算网页的PageRank。
- en: 'Next, I’ll show you how the PageRank is calculated. Suppose we have the following
    simple graph:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将向您展示如何计算PageRank。假设我们有以下简单的图：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Setting `d = 0.85`, we can write:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 设定`d = 0.85`，我们可以写成：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'where:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 'where:'
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: To calculate these `PR()` iteratively, we need to initialize `PR(A)`, `PR(B)`,
    `PR(D)`. We’ll initialize all of them to `1.0`, then iteratively calculate `PR(A)`,
    `PR(B)`, `PR(D)` until these values do not change (i.e., converge). The results
    are shown in [Table 8-2](#pagerank_iterations_1).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步计算这些`PR()`，我们需要初始化`PR(A)`、`PR(B)`、`PR(D)`。我们将它们全部初始化为`1.0`，然后迭代计算`PR(A)`、`PR(B)`、`PR(D)`，直到这些值不再改变（即收敛）。结果显示在[表 8-2](#pagerank_iterations_1)中。
- en: Table 8-2\. PageRank iterations with initial value of 1.00
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-2\. 初始值为1.00的PageRank迭代
- en: '| Iteration | PR(A) | PR(B) | PR(D) |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 迭代次数 | PR(A) | PR(B) | PR(D) |'
- en: '| --- | --- | --- | --- |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0 | 1.0000 | 1.0000 | 1.0000 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1.0000 | 1.0000 | 1.0000 |'
- en: '| 1 | 1.8500 | 0.9362 | 0.9362 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1.8500 | 0.9362 | 0.9362 |'
- en: '| … | … | … | … |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| … | … | … | … |'
- en: '| 99 | 1.4595 | 0.7703 | 0.7703 |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 99 | 1.4595 | 0.7703 | 0.7703 |'
- en: '| 100 | 1.4595 | 0.7703 | 0.7703 |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 100 | 1.4595 | 0.7703 | 0.7703 |'
- en: Note that no matter what you use as the initial value, the PageRank algorithm
    converges and you get the desired results. [Table 8-3](#pagerank_iterations_40)
    shows the results with an initialization value of 40.00.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，无论您使用什么作为初始值，PageRank算法都会收敛，并且您将获得期望的结果。[表 8-3](#pagerank_iterations_40)显示了使用初始值40.00的结果。
- en: Table 8-3\. PageRank iterations with initial value of 40.00
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-3\. 初始值为40.00的PageRank迭代
- en: '| Iteration | PR(A) | PR(B) | PR(D) |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 迭代次数 | PR(A) | PR(B) | PR(D) |'
- en: '| --- | --- | --- | --- |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0 | 40.0000 | 40.0000 | 40.0000 |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 40.0000 | 40.0000 | 40.0000 |'
- en: '| 1 | 68.1500 | 29.1138 | 29.1137 |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 68.1500 | 29.1138 | 29.1137 |'
- en: '| … | … | … | … |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| … | … | … | … |'
- en: '| 99 | 1.4595 | 0.7703 | 0.7703 |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 99 | 1.4595 | 0.7703 | 0.7703 |'
- en: '| 100 | 1.4595 | 0.7703 | 0.7703 |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 100 | 1.4595 | 0.7703 | 0.7703 |'
- en: 'In both cases, the results are the same after 100 iterations:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，100次迭代后的结果是相同的：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you saw in [Chapter 6](ch06.xhtml#unique_chapter_id_06), Spark provides APIs
    for implementing the PageRank algorithm through the GraphX and GraphFrames libraries.
    To help you understand how the algorithm works, here I’ll present a couple of
    custom PageRank solutions in PySpark.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在[第6章](ch06.xhtml#unique_chapter_id_06)中看到的那样，Spark提供了通过GraphX和GraphFrames库实现PageRank算法的API。为了帮助您理解算法的工作原理，我将介绍几种在PySpark中实现的自定义PageRank解决方案。
- en: Custom PageRank in PySpark Using RDDs
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用RDDs在PySpark中进行自定义PageRank
- en: I’ll start by providing a simple custom solution using PySpark. The complete
    program and sample input data are available in the book’s GitHub repository, in
    the files *pagerank.py* and *pagerank_data.txt*.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从提供一个简单的自定义解决方案开始，使用PySpark。完整的程序和示例输入数据可在本书的GitHub存储库中找到，文件为*pagerank.py*和*pagerank_data.txt*。
- en: This solution uses Spark RDDs to implement the PageRank algorithm. It does not
    use GraphX or GraphFrames, but I’ll present a GraphFrames example later.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 该解决方案使用Spark RDDs实现PageRank算法。它不使用GraphX或GraphFrames，但稍后我会展示一个GraphFrames的例子。
- en: Input data format
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输入数据格式
- en: 'Let’s assume that our input has the following syntax:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的输入具有以下语法：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Output data format
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输出数据格式
- en: 'The goal of the PageRank algorithm is to generate output of the form:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: PageRank算法的目标是生成以下形式的输出：
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The result will look something like this, if the algorithm is run for 15 iterations:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果算法运行15次迭代，结果将如下所示：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: PySpark Solution
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PySpark解决方案
- en: 'Our custom solution involves the following steps:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的自定义解决方案涉及以下步骤：
- en: 'Read the input path and the number of iterations:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取输入路径和迭代次数：
- en: '[PRE28]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create an instance of `SparkSession`:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`SparkSession`的实例：
- en: '[PRE29]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create an `RDD[String]` from the input path:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从输入路径创建一个`RDD[String]`：
- en: '[PRE30]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Load all the URLs from the input file and initialize their neighbors:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从输入文件加载所有URL并初始化它们的相邻节点：
- en: '[PRE31]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[![1](Images/1.png)](#co_ranking_algorithms_CO1-1)'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_ranking_algorithms_CO1-1)'
- en: Create a pair of `(source_URL, neighbor_URL)`.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建一对`（source_URL，neighbor_URL）`。
- en: '[![2](Images/2.png)](#co_ranking_algorithms_CO1-2)'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_ranking_algorithms_CO1-2)'
- en: Make sure there are no duplicate pairs.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保没有重复的对。
- en: '[![3](Images/3.png)](#co_ranking_algorithms_CO1-3)'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_ranking_algorithms_CO1-3)'
- en: Find all neighbor URLs.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查找所有相邻的URL。
- en: '[![4](Images/4.png)](#co_ranking_algorithms_CO1-4)'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_ranking_algorithms_CO1-4)'
- en: Cache the result, because it will be used many times in the iteration.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 缓存结果，因为在迭代中会多次使用它。
- en: 'Transform URL neighbors into ranks of 1.0:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将URL相邻节点转换为1.0的排名：
- en: '[PRE32]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[![1](Images/1.png)](#co_ranking_algorithms_CO2-1)'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_ranking_algorithms_CO2-1)'
- en: '`ranks` is an `RDD[(String, Float)]`.'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ranks` 是一个`RDD[(String, Float)]`。'
- en: 'Calculate and update the URL ranks iteratively. To perform this step, we need
    two basic functions:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算并迭代更新URL排名。要执行此步骤，我们需要两个基本函数：
- en: '[PRE33]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, let’s perform the iterations:'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，让我们执行迭代：
- en: '[PRE34]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[![1](Images/1.png)](#co_ranking_algorithms_CO3-1)'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_ranking_algorithms_CO3-1)'
- en: Note that `links.join(ranks)` will create elements of the form `[(URL_ID, (ResultIterable,
    <rank-as-float>)), ...]`.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，`links.join(ranks)` 将创建形如`[(URL_ID，（ResultIterable，<rank-as-float>）)，…]`的元素。
- en: 'Collect the PageRank values for all the URLs and dump them to the console:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集所有URL的PageRank值并将其转储到控制台：
- en: '[PRE35]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Sample output
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例输出
- en: 'Sample output is provided for 20 iterations. You can observe the convergence
    of the PageRank algorithm in the higher iterations (iteration numbers 16 to 20):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为20次迭代提供了示例输出。你可以观察PageRank算法在更高的迭代中的收敛（迭代次数为16到20）：
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Custom PageRank in PySpark Using an Adjacency Matrix
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PySpark在邻接矩阵中自定义PageRank
- en: 'This section presents another custom solution for the PageRank algorithm, using
    an adjacency matrix as input. An adjacency matrix is a matrix used to represent
    a finite graph. The elements of the matrix indicate whether or not pairs of nodes
    are adjacent in the graph. For example, if node `A` links to three other nodes
    (say, `B`, `C`, and `D`), that is presented as an adjacency matrix row like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了另一种使用邻接矩阵作为输入的PageRank算法的自定义解决方案。邻接矩阵是用于表示有限图的矩阵。矩阵的元素指示图中是否相邻的节点。例如，如果节点`A`链接到其他三个节点（比如`B`、`C`和`D`），那么它的邻接矩阵行如下所示：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Suppose we have the graph shown in [Figure 8-2](#directed_graph_with_5_nodes).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有如下图所示的图[图8-2](#directed_graph_with_5_nodes)。
- en: '![Directed Graph with 5 Nodes](Images/daws_0802.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![带有五个节点的有向图](Images/daws_0802.png)'
- en: Figure 8-2\. A simple directed graph with five nodes
  id: totrans-211
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-2。具有五个节点的简单有向图
- en: 'The adjacency matrix for this graph looks like this (where the first item in
    each row is the source node and the other items are target nodes):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此图的邻接矩阵如下（每行中的第一个项目是源节点，其他项目是目标节点）：
- en: '[PRE38]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: A visual inspection of the graph or the matrix suggests that `E` is an important
    node, since it’s referenced by many other nodes. Therefore, we expect that the
    PageRank value of node `E` will be higher than that of the other nodes.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 对图或矩阵进行视觉检查建议`E`是一个重要节点，因为它被许多其他节点引用。因此，我们预计节点`E`的PageRank值将高于其他节点。
- en: This solution again uses Spark RDDs to implement the PageRank algorithm and
    does not use GraphX or GraphFrames. The complete program and sample input data
    are available in the book’s GitHub repository, in the files *pagerank_2.py* and
    *pagerank_data_2.txt*.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 此解决方案再次使用Spark RDD来实现PageRank算法，并不使用GraphX或GraphFrames。完整的程序和示例输入数据可在本书的GitHub存储库中的文件*pagerank_2.py*和*pagerank_data_2.txt*中找到。
- en: Input data format
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输入数据格式
- en: 'Let’s assume that our input has the following syntax, where `S` is a single
    space:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设我们的输入具有以下语法，其中`S`是一个空格：
- en: '[PRE39]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Output data format
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输出数据格式
- en: 'The goal of the PageRank algorithm is to generate output of the form:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: PageRank算法的目标是生成如下形式的输出：
- en: '[PRE40]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: PySpark solution
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PySpark解决方案
- en: 'Our second PySpark solution consists of three main steps:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个PySpark解决方案包括三个主要步骤：
- en: 'Mapping: For each node `i`, calculate the value to assign to each outlink (rank
    / number of neighbors) and propagate it to the adjacent nodes.'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 映射：对于每个节点 `i`，计算要分配给每个出链的值（排名 / 邻居节点数），并传播到相邻节点。
- en: 'Reducing: For each node `i`, sum the upcoming votes/values and update the rank
    `(R[i])`.'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 减少：对于每个节点 `i`，计算即将到来的投票/值的总和并更新排名 `(R[i])`。
- en: 'Iteration: Repeat until the values converge (stable or within a defined margin).'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代：重复直到值收敛（稳定或在定义的边界内）。
- en: 'The complete PySpark solution is presented here. First, we import the required
    libraries and read the input parameters:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这里呈现了完整的 PySpark 解决方案。首先，我们导入所需的库并读取输入参数：
- en: '[PRE41]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, we read the matrix and create pairs of `(K, V)`, where `K` is the source
    node and `V` is a list of target nodes:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们读取矩阵并创建 `(K, V)` 对，其中 `K` 是源节点，`V` 是目标节点的列表：
- en: '[PRE42]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We count the nodes and initialize the rank of each to `1.0`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计数节点并初始化每个节点的排名为 `1.0`：
- en: '[PRE43]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then we implement the three steps of the PageRank algorithm:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们实现了 PageRank 算法的三个步骤：
- en: '[PRE44]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Partial output is given here:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这里给出了部分输出：
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The PageRank algorithm indicates that node `E` is the most important node,
    since its page rank (`0.3191`) is the highest. We also observe that, since the
    PageRanks form a probability distribution, the sum of the values for all the nodes
    will be 1:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: PageRank 算法表明节点 `E` 是最重要的节点，因为其页面排名（`0.3191`）最高。我们还观察到，由于页面排名形成概率分布，所有节点的值的总和为
    `1`：
- en: '[PRE46]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: To wrap up this section, I’ll quickly run through an example using GraphFrames.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 结束本节，我将快速通过一个使用 GraphFrames 的示例进行说明。
- en: PageRank with GraphFrames
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 GraphFrames 的 PageRank
- en: 'The following example in PySpark shows how to find the PageRank of a graph
    using the GraphFrames package introduced in [Chapter 6](ch06.xhtml#unique_chapter_id_06).
    There are at least two ways to calculate the page rank of a given graph:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 PySpark 示例展示了如何使用 GraphFrames 包找到图的 PageRank，该包在 [第 6 章](ch06.xhtml#unique_chapter_id_06)
    中介绍。有至少两种计算给定图的页面排名的方法：
- en: Tolerance
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容差
- en: 'Specify the tolerance allowed at convergence (note that a smaller tolerance
    results in greater accuracy of the PageRank results):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 指定在收敛时允许的容差（请注意，较小的容差会导致 PageRank 结果的更高精度）：
- en: '[PRE47]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Maximum iterations
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最大迭代次数
- en: 'Specify the maximum number of iterations for which the algorithm can run (more
    iterations results in greater accuracy):'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 指定算法可运行的最大迭代次数（迭代次数越多，精度越高）：
- en: '[PRE48]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Summary
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'To recap:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 总结：
- en: We covered two ranking algorithms, rank product (mostly used in gene analysis)
    and PageRank (primarily used in search engine algorithms).
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们涵盖了两种排名算法，排名乘积（主要用于基因分析）和 PageRank（主要用于搜索引擎算法）。
- en: Spark does not provide an API for the rank product, but I presented a custom
    PySpark solution.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spark 不提供排名乘积的 API，但我提供了一个自定义的 PySpark 解决方案。
- en: Spark is capable of handling record-level algorithms as well as graph algorithms—two
    custom PySpark implementations of PageRank were presented, in addition to the
    use of the GraphFrames API.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spark 能够处理记录级算法以及图算法——除了使用 GraphFrames API 外，还提出了两种自定义的 PySpark 实现 PageRank
    的方法。
- en: In the following chapters, we’ll turn our attention to some practical fundamental
    data design patterns.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将关注一些实际的基础数据设计模式。
- en: ^([1](ch08.xhtml#idm45713536222368-marker)) Cancer Outlier Profile Analysis
    (COPA) is an outlier detection method used in gene analysis. Genes are grouped
    into mutually exclusive gene pairs, and ranked according to the number of tumor
    samples in which either of them is an outlier.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch08.xhtml#idm45713536222368-marker)) 癌症异常基因剖析（COPA）是一种在基因分析中使用的异常检测方法。基因被分组成互斥的基因对，并根据它们在肿瘤样本中的异常值数量进行排名。
