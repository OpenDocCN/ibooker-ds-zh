- en: 9 Hex dumper
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 十六进制转储器
- en: I’ve looked with my own eyes and I just can’t see files stored on media. This
    task was easier in the old days, when you could pop out a floppy disk and see
    the actual media. The data on the media, however, remains encoded as teensy electronic
    particles, invisible to the naked eye—or even to an eye with clothes on. No, the
    only way to peer into a file’s raw contents is to use a utility, something like
    *hexdump*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我亲自看过，但我就是看不到存储在介质上的文件。在以前，你可以取出软盘并看到实际的介质。然而，介质上的数据仍然以微小的电子粒子形式编码，肉眼甚至穿着衣服的眼睛都看不见。不，唯一能够窥视文件原始内容的方法是使用工具，比如
    *hexdump*。
- en: 'Yes, *hexdump* is a Linux utility, available as part of the default installation.
    It’s quite capable and popular among the nerds. There’s no need to re-create it—unless
    you want to improve upon it. Or perhaps you want to expand your knowledge of programming
    and learn a few tricks along the way, such as:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，*hexdump* 是一个 Linux 工具，作为默认安装的一部分提供。它在技术人员中非常受欢迎，功能强大。没有必要重新创建它——除非你想改进它。或者你可能想扩展你的编程知识，并在过程中学习一些技巧，例如：
- en: Examining storage at the basic level
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基本级别上检查存储
- en: Properly outputting byte-size data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确输出字节数据
- en: Reading raw data from a file
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件中读取原始数据
- en: Adjusting and aligning program output
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整和定位程序输出
- en: Adding and processing command-line switches
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加和处理命令行开关
- en: The goal of this chapter isn’t to ape the hexdump utility but rather to see
    how much you can understand what it does and appreciate it more by doing it yourself.
    Along the way, you’ll discover more about writing such utilities and how to hone
    your own programs to work the way you prefer.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标并不是模仿十六进制转储工具，而是通过自己动手操作来了解它能做什么，并更加欣赏它。在这个过程中，你将发现更多关于编写此类工具以及如何优化自己的程序以符合你偏好的方法。
- en: 9.1 Bytes and data
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 字节和数据
- en: Computers know nothing of bytes. Digital information is stored in bits—*bit*
    is a collision of the words *bi*nary and digi*t*. Binary digits are 1 and 0, and
    a bit is either 1 or 0\. Bytes cluster bits into convenient, happy groups, where
    they represent larger numbers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机对字节一无所知。数字信息以比特形式存储——*比特*是*二进制*和*数字*这两个词的碰撞。二进制数字是1和0，比特要么是1要么是0。字节将比特聚集成方便、快乐的组，它们代表更大的数字。
- en: One question raised from the early days of computing is how many bits pack into
    a byte? If the techies wanted to do so, a computer’s entire storage space could
    be a single byte that is billions of bits long. Such length would be painfully
    impractical. So, the nerds organized bits into smaller chunks, with byte sizes
    ranging from a few bits to over a dozen bits per byte.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从计算机的早期就提出了一个问题：一个字节可以容纳多少比特？如果技术人员想要这样做，计算机的整个存储空间可以是一个长达数十亿的比特的单字节。这样的长度将是非常不切实际的。因此，技术人员将比特组织成更小的块，字节大小从几个比特到每个字节超过十几个比特不等。
- en: Today the standard is eight bits per byte. But even then, larger-capacity storage
    is necessary when dealing with information in a computer.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，标准是每字节8位。但即使如此，在处理计算机中的信息时，也需要更大的存储容量。
- en: 9.1.1 Reviewing storage units and size mayhem
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.1 回顾存储单位和大小混乱
- en: Way back when computer nerds sported slicked-back hair, skinny black ties, horn-rimmed
    glasses, and prized pocket protectors—yes, even the women—a byte, or *syllable*,
    as it was known, was composed of any number of bits, depending on the system hardware.
    I remember using mainframes with 12-bit bytes. I know of smaller, custom systems
    that used 6-bit bytes. When the microcomputer craze transformed these machines
    into the must-have-computers-for-business craze in the early 1980s, the computer
    world settled on 8-bit bytes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机爱好者梳着油亮的背头、系着细黑领带、戴着圆框眼镜、珍视口袋保护器的时候——是的，甚至女性也是如此——字节，或者称为 *音节*，由任意数量的比特组成，这取决于系统硬件。我记得使用过12位字节的巨型机。我知道有使用6位字节的更小、定制的系统。当微型计算机热潮在20世纪80年代初将这些机器转变为必备的商业计算机时，计算机世界就确定了8位字节。
- en: In C, the 8-bit byte corresponds directly to the *char* data type. Although
    you won’t find any of the C grand poohbahs who openly admit that, yes, “a byte
    is a *char*,” it’s pretty much true. (Even so, be aware that data types are implementation-dependent
    in C.)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中，8位字节直接对应于 *char* 数据类型。尽管你不会找到任何公开承认“字节就是 *char*”的C语言大人物，但这基本上是正确的。（即便如此，请记住，在C语言中，数据类型是依赖于实现的。）
- en: Computers deal with larger values than bytes, which requires their organization
    into chunks called *words* (16-bit), *doublewords* (32-bit), *quadwords* (64-bits),
    and *double-quad words* (128-bits). This word-jumble-worthy mayhem is summarized
    in table 9.1, minus the double-quad word because its values can’t fit in the table.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机处理比字节更大的值，这需要将它们组织成称为*words*（16位）、*doublewords*（32位）、*quadwords*（64位）和*double-quad
    words*（128位）的块。这种单词混乱的混乱在表9.1中总结，除了双倍四倍字，因为其值无法放入表格中。
- en: Table 9.1 Bit width descriptions and details
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.1 位宽描述和细节
- en: '| Bit width | Description | Data type | Value range (signed) | Value range
    (unsigned) |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 位宽 | 描述 | 数据类型 | 值范围（有符号） | 值范围（无符号） |'
- en: '| 8 | Byte | *char* | -128 to 127 | 0 to 255 |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 字节 | *char* | -128到127 | 0到255 |'
- en: '| 16 | Word | *short* | -32,768 to 32,767 | 0 to 65,535 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 字词 | *short* | -32,768到32,767 | 0到65,535 |'
- en: '| 32 | Doubleword | *Int* | -2,147,483,648 to 2,147,483,647 | 0 to 4,294,967,295
    |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 32 | 双字 | *Int* | -2,147,483,648到2,147,483,647 | 0到4,294,967,295 |'
- en: '| 64 | Quadword | *long* | -9,223,372,036,854,775,808 to 9,233,372,036,854,775,807
    | 0 to 18,446,744,073,709,551,615 |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 64 | 四倍字 | *long* | -9,223,372,036,854,775,808到9,233,372,036,854,775,807
    | 0到18,446,744,073,709,551,615 |'
- en: Values shown in table 9.1 are related to the data chunk’s bit width. For example,
    the range of a doubleword is from -2^(31) to 2^(31) - 1\. If a 128-bit integer
    were available in C (and some language extensions offer it), its signed value
    would range from -2^(127) to 2^(127) - 1\. Were this book’s margins wide enough,
    I’d write out the specific values in full. Or—better—if this book had a centerfold,
    I’m sure that the value 2^(127) - 1 printed out would be appealing to some programmers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.1中显示的值与数据块的字宽相关。例如，双字的范围从 -2^(31) 到 2^(31) - 1。如果C语言中可用128位整数（某些语言扩展提供了它），其有符号值范围从
    -2^(127) 到 2^(127) - 1。如果这本书的边距足够宽，我会把具体的值全部写出来。或者——更好的是——如果这本书有一个中心折页，我相信打印出的2^(127)
    - 1的值会对一些程序员有吸引力。
- en: 'You can quickly cobble together a C program that reveals the values of the
    various data types and their bit widths. To do so, you need to know the size of
    each data type. For example, use this expression to obtain the size of a byte
    in bits:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以快速拼凑一个C程序来揭示各种数据类型及其位宽的值。为此，你需要知道每种数据类型的大小。例如，使用这个表达式来获取字节的位数：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The *sizeof* operator returns the number of bytes used by a specific C language
    data type, *char*, described earlier. This value is multiplied by eight to obtain
    the number of bits. The result is stored in unsigned long variable byte; the *sizeof*
    operator returns an unsigned *long* value. Similar statements are used for word/*short*,
    doubleword/*int*, and quadword/*long* variables and data types.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*sizeof*运算符返回先前描述的C语言数据类型*char*使用的字节数。这个值乘以八以获得位数。结果存储在无符号长变量byte中；*sizeof*运算符返回无符号*long*值。类似的语句用于word/*short*、doubleword/*int*和quadword/*long*变量和数据类型。'
- en: 'Use this *printf()* statement to output the values:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个*printf()*语句来输出值：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The *printf()* function’s format string ensures that values output are spaced
    properly, formatted for a table. Several statement output details for each data
    type, resulting in a table that lists the data size, the number of bits, and then
    the decimal size value. The *pow()* function raises the power of two to the number
    of bits pow(2,byte). The *pow()* function requires inclusion of the math.h header
    file.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*printf()*函数的格式字符串确保输出的值被适当地间隔，并格式化为表格。每个数据类型都有几个输出细节的语句，结果是一个列出数据大小、位数以及十进制大小值的表格。*pow()*函数将2的位数提升到pow(2,byte)。*pow()*函数需要包含math.h头文件。'
- en: 'The source code file containing all the *printf()* statements to output a data
    type table is available in this book’s online archive as byte_sizes.c. It requires
    you to link the math library: in Linux, ensure that you specify the -lm switch
    as the compiler’s final command-line option to link in the math (m) library. Here
    is sample output:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 包含所有*printf()*语句以输出数据类型表的源代码文件byte_sizes.c可在本书的在线存档中找到。它需要你链接数学库：在Linux中，确保你在编译器的最终命令行选项中指定-lm开关以链接数学（m）库。以下是示例输出：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You don’t need to perform the math and overhead used in the byte_sizes.c code.
    The reason is that the compiler itself has a limit. Specifically, the limit values
    are set as defined constants in the appropriately named limits.h header file.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要执行byte_sizes.c代码中使用的数学和开销。原因是编译器本身有一个限制。具体来说，限制值被设置为在相应命名的limits.h头文件中定义的常量。
- en: The next listing outputs the popular constants defined in limits.h. Run this
    code on your system to see what the values and ranges are, though for most programmers
    these values align with those shown back in table 9.1\. The key to the code is
    identifying the defined constants in limits.h. These defined constants appear
    here.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表输出了在 limits.h 中定义的常用常量。请在您的系统上运行此代码以查看值和范围，尽管对于大多数程序员来说，这些值与表 9.1 中显示的值一致。代码的关键在于识别
    limits.h 中定义的常量。这些定义的常量如下所示。
- en: Listing 9.1 Source code for limits.c
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.1 limits.c 的源代码
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ The *char* type is the only one that seems to have the “BIT” defined constant.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ *char* 类型似乎是唯一具有“BIT”定义常量的类型。
- en: ❷ Signed *char* maximum
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 有符号 *char* 最大值
- en: ❸ Signed *char* minimum
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 有符号 *char* 最小值
- en: ❹ Unsigned *char* maximum; zero is minimum.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 无符号 *char* 最大值；零是最小值。
- en: ❺ Unsigned integer max uses the %u placeholder.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 无符号整数最大值使用 %u 占位符。
- en: ❻ Long integers require the %ld placeholder.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 长整型需要 %ld 占位符。
- en: ❼ Unsigned long requires %lu placeholder.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 无符号长整型需要 %lu 占位符。
- en: ❽ Double-longs require %lld.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 双长整型需要 %lld。
- en: ❾ The double-unsigned long placeholder is %llu.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 双无符号长整型的占位符是 %llu。
- en: 'The output appears here, though the point of the exercise is that these minimum
    and maximum values can be obtained from the constants defined in the limits.h
    header file; your code need not do the math:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将在这里显示，但练习的重点是，可以从 limits.h 头文件中定义的常量中获取这些最小和最大值；您的代码不需要进行数学计算：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When you desire a specific size integer, it’s best to use the specific integer
    type variables. The following types are available:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要一个特定大小的整数时，最好使用特定的整数类型变量。以下类型是可用的：
- en: '*int8_t* for 8-bit integers'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*int8_t* 用于 8 位整数'
- en: '*int16_t* for 16-bit integers'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*int16_t* 用于 16 位整数'
- en: '*int32_t* for 32-bit integers'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*int32_t* 用于 32 位整数'
- en: '*int64_t* for 64-bit integers'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*int64_t* 用于 64 位整数'
- en: Variables declared with these types are always at the specific width indicated.
    These *typedef* values (which is what the _t suffix indicates) are defined in
    the stdint.h header file, which is automatically included in stdio.h for most
    C compilers. So, feel free to use these data type definitions to utilize an integer
    value of a specific width.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些类型声明的变量总是具有指示的特定宽度。这些 *typedef* 值（即_t 后缀表示的含义）在 stdint.h 头文件中定义，对于大多数 C
    编译器，该头文件会自动包含在 stdio.h 中。因此，请随意使用这些数据类型定义来利用特定宽度的整数值。
- en: The reason for these exact integer width types is historical. When I first learned
    to program C, the *int* data type was 16 bits wide. Today, it’s 32\. Yet the *int16_t*
    and *int32_t* types are always set to the width indicated.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这些精确的整数宽度类型的原因是历史性的。当我最初学习编程 C 语言时，*int* 数据类型是 16 位宽。如今，它是 32 位。然而，*int16_t*
    和 *int32_t* 类型总是设置为指示的宽度。
- en: 'Given the variety of integer widths, a byte is still the basic counting unit
    in a computer. Memory capacity, media storage, file size—all these quantities
    are measured in 8-bit bytes, *char* values. This yardstick gives rise to two systems
    for counting bytes: one based on the powers of two (binary), the other on the
    powers of 10 (decimal).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到整数宽度的多样性，字节仍然是计算机中的基本计数单位。内存容量、媒体存储、文件大小——所有这些量都是以 8 位字节、*char* 值来衡量的。这个标准产生了两种字节计数系统：一种基于
    2 的幂（二进制），另一种基于 10 的幂（十进制）。
- en: 'The traditional way to count bytes, what I grew up with, is the kilobyte system:
    when I was a proto-nerd, 1 K was one kilobyte of data, or 1024 bytes. The value
    1,024 is 2^(10), which seemed good enough for computer nerds; 1,024 is close enough
    to 1,000 for digital accounting purposes, with the extra 24 bytes often taken
    away by the government in the form of taxes. It was proper in the day to tell
    beginners that 1 K was “about 1,000 bytes.” Alas, this logical, binary definition
    no longer holds.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 计算字节的传统方式，我成长过程中所熟悉的方式，是千字节系统：当我还是一个准极客时，1 K 是 1 千字节的数据，或 1024 字节。值 1,024 是
    2^(10)，这似乎对计算机极客来说足够好了；1,024 对于数字会计目的来说足够接近 1,000，额外的 24 字节通常被政府以税收的形式拿走。当时告诉初学者
    1 K 是“大约 1,000 字节”是合适的。唉，这种逻辑的二元定义现在不再适用了。
- en: Today, 1,024 bytes is known as a *kibibyte*. If you refer to a kilobyte, the
    experts now claim this value is 1,000 bytes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，1,024 字节被称为千字节。如果您提到千字节，专家现在声称这个值是 1,000 字节。
- en: A kilobyte (KB) is 1,000 bytes.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 千字节（KB）是 1,000 字节。
- en: A kibibyte (KiB) is 1,024 bytes.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 千字节（KiB）是 1,024 字节。
- en: 'The reason for the change is that the terms *kilo*, *mega*, *giga*, and so
    on mean one thousand, one million, and one billion exactly when describing quantities
    in the noncomputer world: a kilometer is 1,000 meters, not 1,024 meters. For consistency,
    our digital overlords decreed that the term *kilobyte* must also mean exactly
    1,000 bytes. The traditional value of 1,024 bytes, or 2^(10), is demoted to the
    silly term *kibibyte*, which sounds like a dog food.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 变化原因在于，术语*kilo*、*mega*、*giga*等在描述非计算机世界的数量时，确实意味着一千、一百万和十亿。为了保持一致，我们的数字统治者规定，术语*kilobyte*也必须恰好意味着1000字节。传统的1,024字节，或2^(10)，被降级为愚蠢的术语*kibibyte*，听起来像狗粮。
- en: Other values to annoy me include mebibyte (MiB) for 2^(20) or 1,048,576, and
    gibibyte (GiB) for 2^(30) or 1,073,741,824\. To me, these are still megabyte (MB)
    and gigabyte (GB). Anything else is just foolhardy conformist insanity.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 其他让我烦恼的值包括2^(20)或1,048,576的mebibyte (MiB)和2^(30)或1,073,741,824的gibibyte (GiB)。对我来说，这些仍然是megabyte
    (MB)和gigabyte (GB)。其他都是愚蠢的、盲目从众的疯狂行为。
- en: 9.1.2 Outputting byte values
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.2 输出字节值
- en: Forget those wishy-washy C overlords, and in this section accept that a byte
    is the same size as a character. When you allocate 1 K of memory, you’re setting
    aside 1,024 (yes) *char*-sized pieces of memory as a single chunk. Output a value
    in the range from 0 to 255, and you’re outputting a byte. To deal with memory,
    you deal with bytes, *char*-sized chunks. This information is common; nerds everywhere
    accept it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 忘掉那些犹豫不决的C语言统治者，在本节中接受一个字节的大小与字符相同。当你分配1 K的内存时，你正在为单个块预留1,024（是的）个*char*大小的内存块。输出0到255范围内的值，你就是在输出一个字节。要处理内存，你处理字节，*char*大小的块。这些信息很常见；全世界的技术爱好者都接受这一点。
- en: Exercise 9.1
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 练习9.1
- en: Write code that outputs *char* values from 0 to 255\. Each value is output on
    a line by itself. This exercise may seem mindlessly simple, but I strongly urge
    you to try it. Come on! It’s just a few lines of code. Save your solution as byte_values01.c.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码输出从0到255的*char*值。每个值单独占一行。这个练习可能看起来毫无意义地简单，但我强烈建议你尝试一下。来吧！这只需要几行代码。将你的解决方案保存为byte_values01.c。
- en: 'Here is the output from my solution, minus a long chunk of numbers in the middle:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我的解决方案的输出，中间省略了一大段数字：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Without peeking ahead at my solution, did you try a *for* loop? Did you first
    attempt the solution by using a *char* variable and then attempt with *unsigned
    char*? Did you force the output using a technique that didn’t seem obvious at
    first?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看我的解决方案之前，你尝试了*for*循环吗？你首先尝试使用*char*变量，然后尝试使用*unsigned char*吗？你使用一种一开始看起来不明显的技术强制输出吗？
- en: 'Seriously: if you haven’t attempted to code a solution, do so now.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 严肃地说：如果你还没有尝试编写解决方案，现在就试试。
- en: My solution appears in the next listing. It uses an endless *while* loop, carefully
    constructed so that the loop terminates when the value of variable a is equal
    to 255.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我的解决方案将在下一部分列出。它使用了一个无限循环的*while*，精心构造以确保当变量a的值等于255时循环终止。
- en: Listing 9.2 Source code for byte_values01.c
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.2 byte_values01.c的源代码
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ The range for *unsigned* *char* is from 0 to 255.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ *unsigned* *char*的范围是从0到255。
- en: ❷ Loops endlessly
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 无限循环
- en: ❸ Outputs the value
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 输出值
- en: ❹ Once the value hits 255, breaks the loop
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 当值达到255时，中断循环
- en: ❺ Otherwise, increments variable a
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 否则，增加变量a的值
- en: 'The solution shown in listing 9.2 isn’t my first attempt. No, like you (if
    you actually completed the exercise), I started with a *for* loop:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.2中显示的解决方案不是我的第一次尝试。不，就像你（如果你实际上完成了练习）一样，我从*for*循环开始：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This *for* loop never terminates. The compiler may warn, but the loop has no
    end. Even though the maximum value for an *unsigned char* is 255 and it seems
    like the condition is met, it never will be: The value of variable a wraps from
    255 down to 0 again and again.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个*for*循环永远不会终止。编译器可能会警告，但循环没有结束。尽管*unsigned char*的最大值是255，看起来条件似乎已经满足，但它永远不会：变量a的值会从255不断回绕到0。
- en: Further, if you want to examine bytes, output them, or otherwise deal with their
    values, you must use the *int* data type. All *char* or byte-size values easily
    fit within an integer-sized chunk. The int data type avoids any wrapping that
    occurs with a *char*, which is probably one reason why functions like *getchar()*
    and *putchar()* use integers instead of *char* types.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你想检查字节、输出它们或以其他方式处理它们的值，你必须使用*int*数据类型。所有*char*或字节数值都容易适应整数大小的块。int数据类型避免了*char*可能发生的任何回绕，这可能是像*getchar()*和*putchar()*这样的函数使用整数而不是*char*类型的原因之一。
- en: The next listing modifies the source code from listing 9.2 by storing the 256
    char values in a char array, data[]. Two for loops process the array, the first
    to fill it and the second to output its values. Though the array stores only byte
    values, int variable b is used to store the values.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表通过将256个字符值存储在字符数组data[]中来修改列表9.2中的源代码。两个for循环处理数组，第一个用于填充它，第二个用于输出其值。尽管数组只存储字节值，但int变量b用于存储这些值。
- en: Listing 9.3 Source code for byte_values02.c
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.3 byte_values02.c的源代码
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Room for the full variety of byte values
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 存储所有字节值的空间
- en: ❷ Fills the array with values 0 through 255
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 用0到255的值填充数组
- en: ❸ Outputs the array, with each value on a line by itself
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将数组输出，每个值单独一行
- en: The output from byte_values02.c is identical to the first program, but the new
    format, with an array holding the values, allows for modifications and manipulations
    to be made to the stored data. The goal is to accurately present the data in a
    readable format. The inelegant term for doing so is *dump*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从byte_values02.c输出的内容与第一个程序相同，但新的格式，即使用数组存储值，允许对存储的数据进行修改和操作。目标是准确以可读的格式呈现数据。这样做的不优雅术语是*dump*。
- en: 9.1.3 Dumping data
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.3 数据导出
- en: 'Dump is both a noun and a verb, neither of which is flattering. Case in point:
    no type of food preparation uses the word *dump*. The term is inelegant and crude,
    and what’s being dumped isn’t considered useful—unless it’s data.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Dump既是名词也是动词，两者都不太令人愉快。以食物准备为例：没有任何一种食物准备会使用到这个词*dump*。这个术语不够优雅，也很粗俗，而且被丢弃的东西通常被认为是没有用的——除非它是数据。
- en: In the digital realm, a *dump* is the movement of data from one place to another.
    You may be familiar with the notorious term *core dump*, which is what happens
    when your program horrifically screws up and the operating system barfs memory
    and processor content in the vain hope that you’ll examine the data to determine
    what’s wrong. Don’t worry—you won’t.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在数字领域，*dump*是从一个地方到另一个地方的数据移动。你可能熟悉臭名昭著的术语*core dump*，这是当你的程序严重出错时，操作系统试图通过将内存和处理器内容导出到打印机来检查数据以确定错误所在的情况。别担心——你不会。
- en: Computer hobbyists from the early days may remember the term *screen dump*.
    It was a copy of all the text on the screen sent to a printer. IBM curtailed the
    term’s use when they added the Print Screen key to their first PC’s keyboard.
    Suddenly the screen dump became a “print screen,” though pressing the key still
    dumped all text from the screen to the printer.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 早期计算机爱好者可能还记得*screen dump*这个术语。它是将屏幕上的所有文本发送到打印机的副本。当IBM在他们的第一台PC键盘上添加Print
    Screen键时，他们限制了该术语的使用。突然之间，屏幕导出变成了“print screen”，尽管按这个键仍然会将屏幕上的所有文本导出到打印机。
- en: To dump data in C, you copy it from one location to another. You can dump a
    chunk of memory, though only the memory the program has access to. More frequently,
    you dump the contents of a file as hexadecimal output on the screen. A programmer
    can examine the raw data and hopefully gain insight into what’s going on or glean
    some other useful tidbit of information. I’ve experienced many “aha!” moments
    while examining file dumps.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中，要导出数据，你需要将其从一个位置复制到另一个位置。你可以导出内存块，尽管只有程序可以访问的内存。更常见的是，你将文件的内容以十六进制形式输出到屏幕上。程序员可以检查原始数据，并希望从中获得对正在发生的事情的洞察或获取一些其他有用的信息。我在检查文件导出时经历了许多“啊哈！”的时刻。
- en: To dump data from memory, you can modify the existing source code file byte_values01.c.
    The first change is to dump the data in hexadecimal. Decimal byte values are familiar
    to humans, but hex digits for values 0 through 255 all neatly pack into two-digit
    sequences. Further, most nerds recognize hex values and their binary equivalents.
    This relationship makes it easy to troubleshoot. For non-nerd reference, table
    9.2 lists hex values and their relationship to binary with decimal thrown in just
    because.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要从内存中导出数据，你可以修改现有的源代码文件byte_values01.c。第一个更改是将数据以十六进制形式导出。人类对十进制字节值很熟悉，但0到255的十六进制值都整齐地打包成两位数序列。此外，大多数极客都认识十六进制值及其二进制等效值。这种关系使得故障排除变得容易。对于非极客参考，表9.2列出了十六进制值及其与二进制的关系，还加入了十进制值。
- en: Table 9.2 Decimal, hexadecimal, and binary values
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.2 十进制、十六进制和二进制值
- en: '| Decimal | Hex | Binary | Decimal | Hex | Binary |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 十进制 | 十六进制 | 二进制 | 十进制 | 十六进制 | 二进制 |'
- en: '| 0 | 0 | 0000 | 8 | 8 | 1000 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0000 | 8 | 8 | 1000 |'
- en: '| 1 | 1 | 0001 | 9 | 9 | 1001 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0001 | 9 | 9 | 1001 |'
- en: '| 2 | 2 | 0010 | 10 | A | 1010 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2 | 0010 | 10 | A | 1010 |'
- en: '| 3 | 3 | 0011 | 11 | B | 1011 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 3 | 0011 | 11 | B | 1011 |'
- en: '| 4 | 4 | 0100 | 12 | C | 1100 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 4 | 0100 | 12 | C | 1100 |'
- en: '| 5 | 5 | 0101 | 13 | D | 1101 |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 5 | 0101 | 13 | D | 1101 |'
- en: '| 6 | 6 | 0110 | 14 | E | 1110 |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 6 | 0110 | 14 | E | 1110 |'
- en: '| 7 | 7 | 0111 | 15 | F | 1111 |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 7 | 0111 | 15 | F | 1111 |'
- en: Hex dumps are brief and useful. After all, a nerd who may not understand “01001000
    01100101 01101100 01101100 01101111 00101100 00100000 01101110 01100101 01110010
    01100100 00100001” certainly understands “48 65 6C 6F 2C 20 6E 65 72 64 21”.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制转储简短且有用。毕竟，一个可能不理解“01001000 01100101 01101100 01101100 01101111 00101100
    00100000 01101110 01100101 01110010 01100100 00100001”的极客当然能理解“48 65 6C 6F 2C
    20 6E 65 72 64 21”。
- en: 'To output hex, line 12 in the source code for byte_values02.c is altered: the
    %d placeholder is replaced by %02X to output a 2-digit uppercase hex value with
    a leading zero when necessary:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要输出十六进制，byte_values02.c 的源代码第 12 行进行了修改：将 %d 占位符替换为 %02X，以输出一个带前导零的2位大写十六进制值：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The updated code’s output now ranges from 00 through FF, the full spectrum of
    byte values. But it’s all still output in a single column, which isn’t efficient.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的代码的输出范围从 00 到 FF，涵盖了字节值的全部范围。但它仍然输出在单个列中，这并不高效。
- en: 'The second change pads each byte value output with a leading space and eliminates
    the newline:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个更改在每个字节值输出前填充一个空格，并消除了换行符：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To keep output clean, a *putchar()* statement is added after the second *for*
    loop:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持输出整洁，在第二个 *for* 循环之后添加了一个 *putchar()* 语句：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The code’s output now appears all on one screen, but inelegantly:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出现在全部显示在单个屏幕上，但不够优雅：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To improve the code further, a newline is output every 16 bytes, because 16
    is a happy value for hexadecimal. The following modification to the code’s second
    *for* loop adds the newline, which incorporates the recently added *putchar()*
    statement:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步改进代码，每输出16个字节就输出一个换行符，因为16是十六进制的一个快乐值。代码第二个 *for* 循环的以下修改添加了换行符，该换行符结合了最近添加的
    *putchar()* 语句：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The *if* test uses variable b’s value to determine when to add a newline. One
    is added to the value of b, (b+1), to avoid a newline popping out after the first
    value (zero). Otherwise, each time the value of b is evenly divisible by 16, a
    newline is output. Here is the result:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*if* 测试使用变量 b 的值来确定何时添加换行符。将 b 的值加一（b+1），以避免在第一个值（零）之后出现换行符。否则，每当 b 的值能被16整除时，就输出一个换行符。以下是结果：'
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The full source code file is available as byte_values03.c in the online repository.
    The output is better, but it could still use some improvement. Because the data
    dump is sequential, it’s easy to see patterns and reference rows and columns.
    However, data won’t always look so pretty.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码文件作为 byte_values03.c 在在线仓库中可用。输出效果更好，但仍可进行一些改进。因为数据转储是顺序的，所以很容易看到模式和参考行和列。然而，数据并不总是看起来这么漂亮。
- en: Exercise 9.2
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 9.2
- en: Improve the code in byte_values03.c in two stages. First, add an initial column
    showing the byte values’ offset. Output this value as a 5-digit hexadecimal number.
    Then output the row of 16 bytes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 分两步改进 byte_values03.c 中的代码。首先，添加一个初始列，显示字节值的偏移量。将此值输出为5位十六进制数。然后输出16字节的行。
- en: Second, add an extra space to separate the eighth and ninth byte columns. This
    space makes the rows and columns more readable.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，添加一个额外的空格来分隔第八列和第九列。这个空格使行和列更容易阅读。
- en: 'The output from my solution, byte_values04.c, is shown here:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我解决方案的输出，byte_values04.c，如下所示：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The hex display reads better after you’ve completed exercise 9.2.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 完成练习 9.2 后，十六进制显示看起来更好。
- en: A final improvement is to add a third ASCII column after the byte values. This
    additional information cross-references the hex bytes of displayable ASCII text,
    providing a handy way for humans to quickly scan the dump for relevant information.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的改进是添加一个第三列 ASCII，在字节值之后。这个附加信息将可显示的 ASCII 文本的十六进制字节进行交叉引用，为人类快速扫描转储以获取相关信息提供了一个方便的方法。
- en: 'The ordeal of adding an ASCII column to the output is complicated due to stream
    output. Each row must be processed sequentially: 16 bytes are output as hex values,
    and then the same bytes are output as printable ASCII characters. To resolve this
    issue, I concocted the *line_out()* function, which is found in the source code
    file byte_values05.c, available in the online repository.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于流输出，向输出添加 ASCII 列的过程很复杂。每一行都必须顺序处理：先输出16个字节的十六进制值，然后以可打印的 ASCII 字符形式输出相同的字节。为了解决这个问题，我发明了
    *line_out()* 函数，该函数位于源代码文件 byte_values05.c 中，该文件可在在线仓库中找到。
- en: 'The *line_out()* function features three arguments, as shown in the next listing:
    an offset representing a byte count, the length of the data chunk, and the data
    itself as an *unsigned char* pointer. Most of the code is yanked from the earlier
    byte_values04.c source code, though variable a tracks progress in the *for* loops,
    and is used with the data pointer to fetch specific byte values: *(data+a). This
    function outputs a single row of the dump, so it’s called from the *main()* function
    to output all the data.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*line_out()*函数有三个参数，如下所示：表示字节计数的偏移量，数据块长度，以及数据本身作为一个*unsigned char*指针。大部分代码是从早期的byte_values04.c源代码中提取的，尽管变量a跟踪循环中的进度，并与数据指针一起使用来获取特定的字节值：*(data+a)。这个函数输出一个转储的行，因此它从*main()*函数中调用以输出所有数据。'
- en: Listing 9.4 The *line_out()* function
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.4 *line_out()*函数
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Outputs the offset value
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 输出偏移值
- en: ❷ The first loop outputs the hex values.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 第一个循环输出十六进制值。
- en: ❸ The hex value calculation is based on the start of the data plus the looping
    value.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 十六进制值的计算基于数据的起始位置加上循环值。
- en: ❹ After the eighth hex byte output, adds an extra space for readability
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在第八个十六进制字节输出后，为了可读性添加额外的空格
- en: ❺ Adds another space after the hex columns
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在十六进制列之后添加另一个空格
- en: ❻ The second loop outputs the ASCII values—if any.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 第二个循环输出ASCII值（如果有）。
- en: ❼ Checks the printable character range
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 检查可打印字符范围
- en: ❽ Outputs a printable character
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 输出一个可打印字符
- en: ❾ Otherwise, outputs a space
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 否则，输出一个空格
- en: 'The *line_out()* function isn’t perfect, which I discuss in a later section,
    but it works for now. Here is some sample output:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*line_out()*函数并不完美，我将在后面的部分讨论这个问题，但至少目前它是可行的。以下是一些示例输出：'
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The ASCII column appears on the far right, reflecting the printable character
    values from the hex bytes shown in the center columns. Nonprintable characters
    appear as spaces.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII列出现在最右边，反映了中心列中显示的十六进制字节的可打印字符值。不可打印字符以空格形式出现。
- en: Exercise 9.3
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 练习9.3
- en: Sadly, the sample output from the *byte_values* series of programs is predictable—a
    swath of 256-byte values from 0x00 through 0xFF. Why not spice things up a bit
    and repopulate the data[] buffer with random values?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，从*byte_values*系列程序中得到的样本输出是可预测的——从0x00到0xFF的256字节值的一块。为什么不稍微加点料，并用随机值重新填充data[]缓冲区呢？
- en: Modify the source code for byte_values05.c into a new source code file, byte_
    values 06.c. Have the *main()* function fill the data[] array with 256 random
    values, each in the range of 0 through 255\. Run the program a few times to confirm
    that the program properly interprets the hexadecimal and ASCII values of the bytes
    stored.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 将byte_values05.c的源代码修改为一个新的源代码文件，byte_values06.c。让*main()*函数用256个随机值填充data[]数组，每个值在0到255的范围内。运行程序几次以确认程序正确地解释了存储的字节的十六进制和ASCII值。
- en: 9.2 Dump that file!
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 转储那个文件！
- en: A dump utility is designed to peer into a file’s data. Well, a *file* dump utility.
    This detail is something that the operating system doesn’t supply at a glance.
    No, you can tell a file’s name, size, and date from a directory listing. The file
    type is based on the filename extension, so it could be misleading. No, the only
    way to peer into a file and examine its brooding data is to dump.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 转储实用程序旨在深入查看文件的数据。好吧，这是一个文件转储实用程序。这个细节是操作系统一眼就能提供的信息。不，你可以从目录列表中得知文件名、大小和日期。文件类型基于文件名扩展名，因此可能会误导。不，唯一深入查看文件并检查其暗藏数据的方法是转储。
- en: The Linux *hexdump* utility performs the file dumping task quite well. So, this
    chapter is over.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Linux的*hexdump*实用程序在文件转储任务上表现得相当出色。所以，这一章就结束了。
- en: Seriously, using the utility doesn’t help you learn how to write your own file
    utilities, customized the way you like. I call this new utility *dumpfile*. It
    works like *hexdump*, but it works the way I like it to.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 严肃地说，使用这个实用程序并不能帮助你学习如何编写自己的文件实用程序，按照你喜欢的定制方式。我称这个新实用程序为*dumpfile*。它的工作方式与*hexdump*类似，但按照我的喜好来操作。
- en: 9.2.1 Reading file data
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.1 读取文件数据
- en: A *dumpfile* utility could be written as a filter, just like Linux’s *hexdump*.
    As a filter, hexdump chews through all input whether it originates from a file
    or is the output from some program. If you’re interested in such a task, review
    chapter 4 for information on filters in the Linux environment. You can adapt the
    *dumpfile* code presented in this chapter as a filter, though I prefer that *dumpfile*
    work as a traditional command-line utility.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将 *dumpfile* 实用程序编写为过滤器，就像 Linux 的 *hexdump* 一样。作为一个过滤器，hexdump 会处理所有输入，无论它来自文件还是来自某个程序的输出。如果你对这样的任务感兴趣，请查看第4章以获取有关
    Linux 环境中过滤器的信息。你可以将本章中提供的 *dumpfile* 代码作为过滤器进行修改，尽管我更希望 *dumpfile* 作为传统的命令行实用程序工作。
- en: 'Utilities that read data from a file use two approaches. The first is to specify
    the filename at the command prompt—usually, as the first (and often only) argument.
    The second way is to prompt for a filename after the utility starts, or to prompt
    for the filename if it’s missing as a command-line argument. For now, I assume
    that the filename argument is supplied as a command-line argument. Therefore,
    the utility must check for such an argument. This confirmation requires that the
    *main()* function specify and use its arguments:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件中读取数据的实用程序使用两种方法。第一种是在命令提示符中指定文件名——通常作为第一个（并且往往是唯一）参数。第二种方法是在实用程序启动后提示输入文件名，或者如果命令行参数中缺少文件名，则提示输入文件名。目前，我假设文件名参数作为命令行参数提供。因此，实用程序必须检查是否存在这样的参数。这种确认需要
    *main()* 函数指定并使用其参数：
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The value of argc is always at least 1, which is the program’s filename. If
    the user types any arguments, the value of argc is greater than 1\. The program
    first confirms that an argument is present. If not, a warning message is sent
    to the standard error device (*stderr*) and the program terminates:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: argc 的值始终至少为 1，这是程序的文件名。如果用户输入了任何参数，argc 的值将大于 1。程序首先确认是否存在参数。如果没有，则会向标准错误设备（*stderr*）发送警告消息，并终止程序：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The *exit()* function requires that the stdlib.h header file be included. Otherwise,
    you could use return(1) to exit the *main()* function at this point in the code.
    I prefer *exit()* in that it can be used in any function to terminate a program,
    plus it’s tied into other functions such as *atexit()* or *on_exit()*, which gives
    using *exit()* a strategic advantage over the *return* keyword. Also, it’s shorter
    to type.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*exit()* 函数需要包含 stdlib.h 头文件。否则，你可以在代码的这一部分使用 return(1) 来退出 *main()* 函数。我更喜欢使用
    *exit()*，因为它可以在任何函数中用来终止程序，并且它与 *atexit()* 或 *on_exit()* 等其他函数相关联，这使得使用 *exit()*
    相比于 *return* 关键字具有战略优势。此外，它也更短，更容易输入。'
- en: 'After the argument count is confirmed, the string held in argv[1] is used in
    the *fopen()* function to read the file’s data. This step not only opens the file
    but also, upon success, determines whether the file is present. I use the char
    pointer filename to reference the string in argv[1], which aids readability:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在确认参数数量后，argv[1] 中持有的字符串被用于 *fopen()* 函数来读取文件数据。这一步不仅打开了文件，而且在成功的情况下，还会确定文件是否存在。我使用
    char 指针 filename 来引用 argv[1] 中的字符串，这有助于提高可读性：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: My first choice for processing a file’s data was to use the *fgets()* function
    to read in 16 bytes at a time; 16 is the number of hex bytes in a row of output.
    But if I want to use my existing *line_out()* function as is, I can’t have the
    16th byte in the data be the null character. This byte is what the *fgets()* function
    adds to the buffer it reads, unless a newline is encountered first.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我处理文件数据的第一选择是使用 *fgets()* 函数一次读取16个字节；16是输出行中十六进制字节的数量。但如果我想直接使用现有的 *line_out()*
    函数，就不能让数据中的第16个字节是空字符。这个字节是 *fgets()* 函数添加到它所读取的缓冲区中的，除非首先遇到换行符。
- en: My second choice was to use *fread()*. Where *fgets()* is a string-reading function,
    *fread()* consumes data in a given chunk size. It could easily fill a 16-byte
    buffer with raw data, which is what I want. Even so, I opted instead to use the
    *fgetc()* function, which reads one character a time. Set in a *while* loop, this
    function gobbles characters, adding them to a 16-byte buffer and handling the
    EOF condition when it’s encountered.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我的第二个选择是使用 *fread()*. 虽然 *fgets()* 是一个字符串读取函数，但 *fread()* 会以给定的块大小消耗数据。它可以轻松地将16字节的缓冲区填满原始数据，这正是我所需要的。即便如此，我还是选择了使用
    *fgetc()* 函数，它一次读取一个字符。将这个函数放在 *while* 循环中，它会吞噬字符，将它们添加到16字节的缓冲区中，并在遇到文件结束符（EOF）时处理该条件。
- en: The following listing shows the core of the *main()* function from the source
    code file dumpfile01.c. The while loop repeats until the end of file (EOF) is
    found for FILE pointer fp. Byte value ch is fetched from the file and immediately
    tested for the EOF marker. After the EOF is detected, the value of variable index
    is tested against zero, meaning the buffer still has data to print. If so, the
    *line_out()* function is called. Otherwise, the file still has data to read, and
    character ch is stored in the buffer. Once the buffer is full (index==length),
    the *line_out()* function is called. The full code can be found in the online
    repository as dumpfile01.c.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了源代码文件 dumpfile01.c 中 *main()* 函数的核心。while循环重复，直到找到文件指针 fp 的文件结束（EOF）。从文件中获取字节值
    ch，并立即检查EOF标记。检测到EOF后，测试变量 index 的值是否为零，这意味着缓冲区仍有数据要打印。如果是这样，则调用 *line_out()*
    函数。否则，文件仍有数据要读取，并将字符 ch 存储在缓冲区中。一旦缓冲区满（index==length），则调用 *line_out()* 函数。完整的代码可以在在线存储库中找到，作为
    dumpfile01.c。
- en: Listing 9.5 The character-reading loop from dumpfile01.c
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.5 来自 dumpfile01.c 的字符读取循环
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Loops until the end of file is encountered
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 循环直到遇到文件结束
- en: ❷ Fetches a character
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 获取一个字符
- en: ❸ Immediately tests for the end of file
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 立即检查文件结束
- en: ❹ If the index is zero, the buffer is empty; otherwise . . .
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果索引为零，缓冲区为空；否则 . . .
- en: ❺ . . . it outputs the final line of the hex dump.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ . . . 输出十六进制转储的最后一行。
- en: ❻ Terminates the loop
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 终止循环
- en: ❼ Stores the character
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 存储字符
- en: ❽ Increments the index into the buffer
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 增加缓冲区中的索引
- en: ❾ If the buffer is full, outputs a row of the hex dump
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 如果缓冲区已满，则输出一行十六进制转储
- en: ❿ Outputs the row
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 输出行
- en: ⓫ Adjusts the offset
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 调整偏移量
- en: ⓬ Resets the index to start reading the next length (16) bytes
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ⓬ 将索引重置为开始读取下一个长度（16）字节
- en: After reading all bytes from the file, and the while loop has terminated, the
    file is closed and the program finishes.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 读取文件中的所有字节后，while循环终止，文件被关闭，程序结束。
- en: 'I’ve created a test data file to read, bytes.dat. It’s available in the online
    repository along with all this chapter’s source code files. This file contains
    sequential byte values from 0x00 through 0xFF, which I used to test and debug
    the program created from the dumpfile01.c source code file. Here is some sample
    output:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了一个测试数据文件 bytes.dat 以供读取。它可在在线存储库中找到，与本章的所有源代码文件一起。此文件包含从 0x00 到 0xFF 的顺序字节值，我使用这些值来测试和调试从
    dumpfile01.c 源代码文件创建的程序。以下是一些示例输出：
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 9.2.2 Fixing uneven output
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.2 修复不均匀输出
- en: Only a few files in the digital realm have sizes of a value evenly divided by
    16\. For these files, the *dumpfile* program works perfectly. True, the program
    can handle reading bytes from any file size, but when the file size isn’t exactly
    divisible by 16, it has an ugly effect on the output.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在数字领域中，只有少数文件的大小是16的倍数。对于这些文件，*dumpfile* 程序工作得非常完美。确实，程序可以处理从任何大小的文件中读取字节，但当文件大小不是16的精确倍数时，它会对输出产生丑陋的影响。
- en: 'Here you see the tail end of the *dumpfile* utility’s output applied to the
    text of Shakespeare’s *18th Sonnet*:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你可以看到 *dumpfile* 工具输出的末尾应用于莎士比亚的 *第18首十四行诗*：
- en: '[PRE23]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: At offset 0x00270 (the last line), you see the file’s final byte, 0A, immediately
    followed by the line’s ASCII column. The text “to thee” is several spaces to the
    left of where it should line up—if the file ended exactly at a 16-byte boundary.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在偏移量 0x00270（最后一行），你可以看到文件的最后一个字节，0A，紧接着是行的ASCII列。文本“to thee”在它应该对齐的地方左侧好几个空格——如果文件正好在16字节边界结束。
- en: 'To resolve this problem, the *line_out()* function must be modified. It must
    know when a line of output doesn’t match the default output length of 16 bytes.
    Speaking of which, in all the code presented so far, the output width is consistently
    16 bytes. This specifies this value as a constant in the *main()* function:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，必须修改 *line_out()* 函数。它必须知道当一行输出不匹配默认的16字节输出长度时。说到这里，到目前为止展示的所有代码中，输出宽度始终是16字节。在
    *main()* 函数中将此值指定为常量：
- en: '[PRE24]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Defined here, the constant’s value is seen only inside the *main()* function.
    Because this value is also now relevant to the *line_out()* functions, I’ve reestablished
    it as a defined constant. The following preprocessor directive creates it:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在此处定义的常量值仅在 *main()* 函数内部可见。因为这个值现在也与 *line_out()* 函数相关，所以我将其重新定义为常量。以下预处理指令创建了它：
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This change is found in the updated source code file, dumpfile02.c.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更改可以在更新的源代码文件 dumpfile02.c 中找到。
- en: In the next listing, you see how defined constant SIZE is used in the *line_out()*
    function to help test when the final line of output is shorter than 16 bytes.
    This change requires the addition of an if statement between the two existing
    *for* loops. The *if* decision helps to balance out the remainder of the last
    row of output so that the ASCII column lines up.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个列表中，你可以看到如何使用定义的常量 SIZE 在 `*line_out()` 函数中，以帮助测试输出最后行是否短于 16 字节。此更改需要在两个现有的
    `*for` 循环之间添加一个 `if` 语句。`if` 决策有助于平衡最后输出行的剩余部分，以便 ASCII 列对齐。
- en: Listing 9.6 Updating the *line_out()* function to account for a short, final
    line
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.6 更新 `*line_out()` 函数以处理短的最后行
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ If the row has fewer than SIZE (16) bytes . . .
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果行中少于 SIZE (16) 字节 . . .
- en: ❷ Continues the loop using variable a
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用变量 a 继续循环
- en: ❸ Outputs three spaces
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 输出三个空格
- en: ❹ Adds an extra space after the 8th and 16th bytes
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在第 8 个和第 16 个字节后添加一个额外的空格
- en: The *for* loop (refer to listing 9.6) lacks an initializing condition, as it
    just continues with the current value of variable a as it left the preceding loop.
    The loop outputs a set of three spaces to balance out any missing hex byte values.
    The if( (a+1)%8==0 ) test accounts for the extra space added after every eight
    bytes, which separates the two hex columns.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`*for` 循环（参见图表 9.6）缺少初始化条件，因为它只是继续使用变量 a 的当前值，就像它离开前面的循环一样。循环输出一组三个空格以平衡任何缺失的十六进制字节值。if(
    (a+1)%8==0 ) 测试考虑了每八字节后添加的额外空格，这分隔了两个十六进制列。'
- en: 'The full source code is available in the repository as dumpfile02.c. Here is
    the output using the same file used earlier, but improved now over the first version
    of the code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可在仓库中找到，作为 `dumpfile02.c`。以下是使用之前使用的相同文件，但改进后的代码的输出：
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Exercise 9.4
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 9.4
- en: Is programming ever done? To further update the source code for dumpfile02.c,
    modify the *main()* function so that if the filename argument is missing, the
    program prompts for it.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 编程是否永远完成？为了进一步更新 `dumpfile02.c` 的源代码，修改 `*main()` 函数，以便如果缺少文件名参数，程序会提示输入。
- en: It’s important that your code identify when the user just presses Enter or otherwise
    dismisses the filename prompt. There’s no point in the program attempting to open
    a NULL string filename. Beyond this requirement, you don’t need to otherwise validate
    the filename, because the *fopen()* statement does so automatically. My solution
    is available in the online repository as dumpfile03.c.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是你的代码能够识别用户只是按下 Enter 键或以其他方式忽略文件名提示。程序尝试打开一个 NULL 字符串文件名是没有意义的。除了这个要求之外，你不需要对文件名进行其他验证，因为
    `*fopen()` 语句会自动这样做。我的解决方案可在在线仓库中找到，作为 `dumpfile03.c`。
- en: 9.3 Command-line options
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 命令行选项
- en: What can you add to the *dumpfile* program? For starters, how about abbreviated
    output, showing only the hex bytes? Or for you old timers, how about adding an
    option to display the bytes in octal, base 8? You can probably think of more features
    to add, perhaps color-coded output? Obviously, such complications would require
    a Help system to provide some documentation. Oh, I could go on!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为 `*dumpfile` 程序添加什么？首先，简化的输出如何，只显示十六进制字节？或者对于老用户，添加一个选项来以八进制（基数 8）显示字节如何？你可能还能想到更多要添加的功能，比如彩色编码输出？显然，这样的复杂性需要帮助系统提供一些文档。哦，我可以继续说！
- en: 'As a command-line utility, options and features are controlled by *switches*—additional
    command-line arguments that activate, deactivate, or specify quantities and limits.
    In Linux, these switches have a format: -a, where a letter is preceded by a dash
    or hyphen. (Windows uses the slash character (/), which was a dumb decision Microsoft
    made years ago, before Bill Gates was eligible to vote.)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 作为命令行实用程序，选项和功能由 `*switches` 控制——激活、停用或指定数量和限制的附加命令行参数。在 Linux 中，这些开关的格式为：-a，其中字母前面有一个连字符或短横线。（Windows
    使用斜杠字符 (/)，这是微软多年前做出的一个愚蠢的决定，在比尔·盖茨有资格投票之前。）
- en: 'In Linux, you can specify multiple switches:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中，你可以指定多个开关：
- en: '[PRE28]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'These can be bunched together:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以一起使用：
- en: '[PRE29]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And some switches can have options:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开关可以有选项：
- en: '[PRE30]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You could toil with tests and loops to examine the switches. Or you can take
    advantage of a handy C library feature: the *getopt()* function. It helps your
    program process switches so that you don’t have to write the code.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过测试和循环来劳作，检查开关。或者，你可以利用一个方便的 C 库特性：`*getopt()` 函数。它帮助你的程序处理开关，这样你就不必编写代码。
- en: 9.3.1 Using the getopt() function
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.1 使用 `getopt()` 函数
- en: 'The *getopt()* function helps your code process command-line switches. I’m
    certain it’s used by just about every Linux command-line utility in existence,
    including several from the multiverse. Here is its *man* page format:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*getopt()* 函数帮助您的代码处理命令行开关。我确信它被几乎所有现有的 Linux 命令行工具使用，包括来自多元宇宙的几个工具。以下是它的 *man*
    页面格式：'
- en: '[PRE31]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The first two arguments are identical to the *main()* function’s argc and *argv[]
    arguments. The final argument, optstring, is a list of valid switch characters.
    For example:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个参数与 *main()* 函数的 argc 和 *argv[] 参数相同。最后一个参数，optstring，是有效开关字符的列表。例如：
- en: '[PRE32]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Valid switches here are -a, -b, and -c. The function is called repeatedly, each
    time returning the ASCII code for a valid character (an *int* value), the character
    '?' for an unknown option, or -1 when the function has exhausted all command-line
    options.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有效的开关是 -a、-b 和 -c。函数被反复调用，每次返回一个有效字符的 ASCII 码（一个 *int* 值），未知选项的字符 '?'，或者当函数耗尽所有命令行选项时返回
    -1。
- en: The companion *getopt_long()* function handles full word switches, though for
    this chapter I explore only the *getopt()* function to handle the traditional,
    single-character switches.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随的 *getopt_long()* 函数处理完整的单词开关，尽管在本章中我只探索了 *getopt()* 函数来处理传统的、单字符的开关。
- en: Both *getopt()* and *getopt_long()* require that the unistd.h header file be
    included in your code.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*getopt()* 和 *getopt_long()* 都要求在您的代码中包含 unistd.h 头文件。'
- en: Listing 9.7 shows code I used as a test before adding the *getopt()* function
    to my *dumpfile* code. Global variable opterr is set to zero to ensure that *getopt()*
    doesn’t output its own error messages. The *getopt()* function itself resides
    inside a *while* loop’s condition. The function’s return value is compared with
    -1, meaning that all command-line arguments have been examined, which stops the
    loop. Otherwise, the value returned in variable r is used in a *switch-case* structure
    to indicate which option is set. This setup is how the *getopt()* function is
    typically implemented.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.7 显示了在将 *getopt()* 函数添加到我的 *dumpfile* 代码之前，我用作测试的代码。全局变量 opterr 设置为零，以确保
    *getopt()* 不输出其自己的错误消息。*getopt()* 函数本身位于 *while* 循环的条件中。函数的返回值与 -1 进行比较，表示已检查所有命令行参数，这会停止循环。否则，变量
    r 中返回的值在 *switch-case* 结构中使用，以指示设置了哪个选项。这种设置通常是 *getopt()* 函数的实现方式。
- en: Listing 9.7 Source code for options01.c
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.7 options01.c 的源代码
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ The unistd.h header file is required for the *getopt()* function.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 需要 unistd.h 头文件才能使用 *getopt()* 函数。
- en: ❷ Suppresses error output from *getopt()*
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 抑制 *getopt()* 的错误输出
- en: ❸ Scans the arguments, repeating the loop until every argument is processed
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 扫描参数，重复循环直到处理完所有参数
- en: ❹ Examines the character returned
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 检查返回的字符
- en: ❺ The *case* statements examine each valid option letter.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ *case* 语句检查每个有效选项字母。
- en: ❻ A question mark is returned for unknown/invalid options.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 对于未知/无效选项，返回一个问号。
- en: ❼ I doubt the *default* condition is ever met.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 我怀疑 *default* 条件永远不会满足。
- en: 'The fun comes when testing the program built from the options01.c source code.
    First, try no options:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试从 options01.c 源代码构建的程序时，乐趣开始了。首先，尝试不使用任何选项：
- en: '[PRE34]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: No output is generated. Good.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 没有生成输出。很好。
- en: 'All options are specified here:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 所有选项都在这里指定：
- en: '[PRE35]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And they can be specified in any order:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以按任何顺序指定：
- en: '[PRE36]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Or a single pair, but bunched together:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 或者一个单独的配对，但紧凑在一起：
- en: '[PRE37]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The *getopt()* function allows you all the flexibility to read options in this
    manner without having to code the complex comparisons and processing yourself.
    Of course, the code so far does nothing with the options. The next step is to
    add variables that represent on-off switches for what the options attempt to accomplish.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '*getopt()* 函数允许您以这种方式读取选项，而不必自己编写复杂的比较和处理代码。当然，到目前为止的代码对选项没有任何操作。下一步是添加表示选项尝试完成的开关的变量。'
- en: 'In my update from options01.c to options02.c, I add three *int* variables:
    alfa, bravo, and charlie. Each is initialized before the *getopt()* statement
    in the *while* loop:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在我从 options01.c 更新到 options02.c 的过程中，我添加了三个 *int* 变量：alfa、bravo 和 charlie。每个变量都在
    *while* 循环中的 *getopt()* 语句之前初始化：
- en: '[PRE38]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the *switch-case* structure, remove the *puts()* statements and replace
    them with statements that set the variables value to 1 (TRUE) for active:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *switch-case* 结构中，移除 *puts()* 语句，并用将变量值设置为 1（TRUE）的语句替换它们，以表示激活状态：
- en: '[PRE39]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, after the *while* loop, add a series of *if* statements to output the
    results:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 *while* 循环之后，添加一系列 *if* 语句以输出结果：
- en: '[PRE40]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The final *if* statement displays a message when no options are set.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的 *if* 语句在未设置任何选项时显示一条消息。
- en: 'The source code for options02.c is found in this book’s online repository.
    Here are some sample runs:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 选项02.c的源代码可以在本书的在线仓库中找到。以下是一些示例运行结果：
- en: '[PRE41]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Because the switches can be examined in this new code, a lack of options is
    easily identified.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 因为可以在新代码中检查开关，所以很容易识别缺少选项的情况。
- en: 'The output for setting all options is the same as with the first version of
    the code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 设置所有选项的输出与代码的第一个版本相同：
- en: '[PRE42]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The remaining variations for the switches have the same output as the original
    program. The difference is that the program is now aware of the settings and can
    examine the variables to perform whatever magic is requested.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开关的剩余变体，其输出与原始程序相同。区别在于程序现在能够识别设置并检查变量以执行所需的任何魔法操作。
- en: 9.3.2 Updating the dumpfile program code
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.2 更新转储文件程序代码
- en: To add command-line options to a utility, you must know what the options do.
    Then you use a function like *getopt()* to scan for and set the options. Finally,
    the options must be implemented in code.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要向实用程序添加命令行选项，你必须知道这些选项的作用。然后你使用像*getopt()*这样的函数来扫描和设置选项。最后，必须在代码中实现这些选项。
- en: 'For the *dumpfile* program, here are options I’m presenting:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*dumpfile*程序，以下是我提供的选项：
- en: -a for abbreviated output
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -a 用于缩写输出
- en: -o for octal output
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -o 用于八进制输出
- en: -h for help
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -h 用于帮助
- en: 'These switches can be processed as shown earlier with the *options* series
    of source code files. With the *dumpfile* program, however, the first argument
    is a filename. In fact, it must be a filename: to help process command-line switches,
    the program can no longer prompt for a filename if one is missing (if you completed
    exercise 9.4). Further, the filename must always be the first argument, argv[1].
    (Technically, it’s the second argument, because the program filename is first
    or argv[0].)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这些开关可以像之前展示的那样，通过*options*系列源代码文件进行处理。然而，对于*dumpfile*程序，第一个参数是一个文件名。实际上，它必须是一个文件名：为了帮助处理命令行开关，如果缺少文件名（如果你完成了9.4练习），程序将不再提示输入文件名。此外，文件名必须始终是第一个参数，argv[1]。技术上讲，它是第二个参数，因为程序文件名是第一个或argv[0]。
- en: 'The first step to adding and processing arguments is to modify the *main()*
    function. If a prompt for a missing filename was added in exercise 9.4, it’s now
    removed. The code is honed to assume that the first argument is a filename. The
    following statements are added before the while loop in the *main()* function:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 添加和处理参数的第一步是修改*main()*函数。如果在9.4练习中添加了提示缺少文件名的步骤，现在应该移除。代码被优化，假设第一个参数是文件名。在*main()*函数中的while循环之前添加以下语句：
- en: '[PRE43]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If the program survives this *if* test, the next new chunk of code checks to
    see whether the -h “help” switch is specified first. If not, the program may attempt
    to open the file -h. So, a quick comparison is made for -h as the first argument.
    If found, the *help()* function is called:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序通过了这个*if*测试，接下来的新代码块将检查是否指定了-h “帮助”开关。如果没有，程序可能会尝试打开文件-h。因此，对-h作为第一个参数进行了快速比较。如果找到，将调用*help()*函数：
- en: '[PRE44]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Because the program assumes the first argument is a filename, this step is necessary
    even if you use the *getopt()* function elsewhere in the code to look for the
    -h switch. In fact, this type of comparison is how I would test for switches if
    the *getopt()* function were unavailable. If the -h switch is the first argument,
    the *help()* function is called and helpful text is output. The program ends.
    Otherwise, the program can continue testing options.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 因为程序假设第一个参数是文件名，所以即使你在代码的其他地方使用*getopt()*函数查找-h开关，这一步也是必要的。实际上，如果*getopt()*函数不可用，这种比较方式就是测试开关的方法。如果-h开关是第一个参数，将调用*help()*函数并输出有用的文本。程序结束。否则，程序可以继续测试选项。
- en: 'To process the rest of the switches, I use a single *int* variable options.
    This variable is declared externally—a global variable, which gives all functions
    access to its value:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理剩余的开关，我使用一个单独的*int*变量options。这个变量是在外部声明的——一个全局变量，它允许所有函数访问其值：
- en: '[PRE45]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As with the *options* series of programs, in the updated code for *dumpfile*
    each of the three valid switches—-a, -o, and -h—are tested for in a *while* loop,
    shown in the following listing. I use only one variable, the external integer
    options, to track the settings. It’s initialized to zero, along with other variables
    used elsewhere in the *main()* function. For two of the switches, a macro alters
    the value of variable options: *set_abbr()* for -a and *set_oct()* for -o. If
    the help switch is specified, the *help()* function is called where text is output
    and the program terminates.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 与 *options* 系列程序一样，在 *dumpfile* 的更新代码中，三个有效的开关——-a, -o 和 -h——都在 *while* 循环中进行了测试，如下所示。我仅使用一个外部整数变量
    options 来跟踪设置，它被初始化为零，以及其他在 *main()* 函数中其他地方使用的变量。对于两个开关，宏会改变变量 options 的值：*set_abbr()*
    用于 -a 和 *set_oct()* 用于 -o。如果指定了帮助开关，则调用 *help()* 函数，输出文本并终止程序。
- en: Listing 9.8 The *while* loop inside the *main()* function, in dumpfile04.c
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.8 在 dumpfile04.c 中的 *main()* 函数内的 *while* 循环
- en: '[PRE46]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ❶ Variables offset and index are used elsewhere in the *main()* function.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在 *main()* 函数中其他地方使用 offset 和 index 变量。
- en: ❷ Valid switches are a, o, s, and h.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 有效的开关有 a, o, s 和 h。
- en: ❸ For the -a switch, the *set_abbr()* macro modifies variable options.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 对于 -a 开关，*set_abbr()* 宏修改变量 options。
- en: ❹ For the -o switch, the *set_oct()* macro modifies variable options.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 对于 -o 开关，*set_oct()* 宏修改变量 options。
- en: ❺ For -h, the *help()* function is called and the program quits.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 对于 -h，调用 *help()* 函数并退出程序。
- en: By making variable options external, the *line_out()* function need not be modified.
    Otherwise, I’d have to add another argument to the list, one to accept the variable
    options to examine the command-line switches. Having a single variable options
    also avoids adding even more arguments to the *line_out()* function. Its declaration
    would eventually become a mess. No, this situation is one of those rare times
    a global variable is an effective solution to a problem.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使变量 options 成为外部变量，*line_out()* 函数无需修改。否则，我必须向列表中添加另一个参数，一个用于接受变量 options
    以检查命令行开关的参数。只有一个变量 options 还可以避免向 *line_out()* 函数添加更多参数。它的声明最终会变得混乱。不，这种情况是那些罕见的情况下全局变量是解决问题的有效解决方案之一。
- en: The macros *set_abbr()* and *set_oct()* allow the code to modify variable options
    by setting specific bits. Each of the set macros has a companion *test* macro
    that can be used in the *line_out()* function. The test macro returns TRUE (1)
    when the option is set, which allows the macro to be used as an *if* condition
    to activate a feature.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 宏 *set_abbr()* 和 *set_oct()* 允许代码通过设置特定位来修改变量 options。每个设置宏都有一个配套的 *test* 宏，可以在
    *line_out()* 函数中使用。当选项被设置时，测试宏返回 TRUE (1)，这使得宏可以用作 *if* 条件来激活功能。
- en: The next listing shows the macros as they’re defined at the start of the source
    code file. First, the options variable is declared, and then binary values are
    assigned for the options, ABBR and OCT. Finally, the set and *test* macros are
    defined, using bitwise logic to set and evaluate the bits in variable options.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了在源代码文件开头定义的宏。首先，声明了 options 变量，然后为选项、ABBR 和 OCT 分配了二进制值。最后，定义了设置和 *test*
    宏，使用位逻辑来设置和评估变量 options 中的位。
- en: Listing 9.9 Creating macros to modify and test variable options
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.9 创建宏来修改和测试变量 options
- en: '[PRE47]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: ❶ Declares the external variable before it’s used
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在使用之前声明外部变量
- en: ❷ Size value is used elsewhere in the code, 16 bytes per line.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 大小值在代码的其他地方使用，每行 16 字节。
- en: ❸ Abbreviation status is bit 1.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 缩写状态是位 1。
- en: ❹ Octal output status is bit 2.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 八进制输出状态是位 2。
- en: ❺ Uses the bitwise logical OR to set bit 1 (ABBR) in variable options
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用位逻辑或来设置变量 options 中的位 1 (ABBR)
- en: ❻ Uses the bitwise logical AND to test bit 1 (ABBR) in variable options
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 使用位逻辑与来测试变量 options 中的位 1 (ABBR)
- en: ❼ Uses the bitwise logical OR to set bit 2 (OCT) in variable options
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 使用位逻辑或来设置变量 options 中的位 2 (OCT)
- en: ❽ Uses the bitwise logical AND to test bit 2 (OCT) in variable options
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 使用位逻辑与来测试变量 options 中的位 2 (OCT)
- en: The defined constants ABBR and OCT represent bit positions in the variable options
    that don’t overlap. Each bit can be set or examined without changing the other
    bits. This approach allows for more options to be added in the same manner, on
    up to the full bit width of an *int* variable.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 定义常量 ABBR 和 OCT 代表变量 options 中的位位置，它们不重叠。每个位都可以设置或检查而不改变其他位。这种方法允许以相同的方式添加更多选项，直到
    *int* 变量的完整位宽。
- en: The macros add to readability, but more important, by creating a macro, I make
    updating the code easier. For example, changing an option is done in one location
    as opposed to fishing around the code for everywhere it’s referenced.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 宏增加了可读性，但更重要的是，通过创建宏，我使代码更新更容易。例如，更改选项只需在一个位置进行，而不是在代码中到处查找引用。
- en: The full code for the modified *dumpfile* program is available in the online
    repository as dumpfile04.c. The only item I haven’t discussed is the *help()*
    function. It’s shown here. The next few sections cover the code required to implement
    the -a and -o switches.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的*dumpfile*程序的完整代码可在在线仓库中找到，作为dumpfile04.c。我还没有讨论的是*help()*函数。它在这里展示。接下来的几节将涵盖实现-a和-o选项所需的代码。
- en: Listing 9.10 The *help()* function from dumpfile04.c
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.10 dumpfile04.c中的*help()*函数
- en: '[PRE48]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 9.3.3 Setting abbreviated output
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.3 设置缩略输出
- en: The *dumpfile* program’s current output is good for nerds who want to examine
    bytes in files. It shows an offset column, hex bytes, and then character representation
    of ASCII codes. This presentation is what I prefer, though at times all that’s
    needed is just the byte dump. To accomplish this goal, users can specify the -a
    switch for abbreviated program output.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '*dumpfile*程序当前的输出对于想要检查文件中字节的极客来说很好。它显示了偏移量列、十六进制字节以及ASCII码的字符表示。这种展示方式是我所偏好的，尽管有时只需要简单的字节转储。为了实现这个目标，用户可以指定-a开关以获得缩略程序输出。'
- en: 'The mechanics behind the -a switch are already present in the dumpfile04.c
    source code. All that’s required is implementing the on-off portions of the code:
    with abbreviated output active, some items in the *line_out()* function are suppressed.
    For these items, an if statement is added with the *test_abbr()* macro as its
    condition. The result is a toggle that activates portions of the output only when
    the -a switch isn’t specified.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: -a选项背后的机制已经在dumpfile04.c源代码中存在。所需做的只是实现代码的开关部分：在缩略输出激活时，*line_out()*函数中的一些项被抑制。对于这些项，添加了一个带有*test_abbr()*宏作为条件的if语句。结果是，只有当没有指定-a选项时，才会激活输出的一部分。
- en: 'Modifications must be made at three points in the *line_out()* function. The
    first is for the initial column, which outputs the offset. The *printf()* statement
    is executed only when the *test_abbr()* macro returns zero. The not operator (!)
    is used to negate the macro:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 必须在*line_out()*函数的三个地方进行修改。第一个是为初始列，它输出偏移量。只有当*test_abbr()*宏返回零时，才会执行*printf()*语句。使用非操作符(!)来否定宏：
- en: '[PRE49]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If the -a switch is specified, the *printf()* statement is skipped. Otherwise,
    for normal output, it’s executed.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定了-a选项，则跳过*printf()*语句。否则，对于正常输出，它会被执行。
- en: 'Next, in the *for* loop that outputs the hex bytes, the existing code adds
    an extra space for readability:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在输出十六进制字节的*for*循环中，现有的代码为了可读性添加了额外的空格：
- en: '[PRE50]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This space isn’t needed for a plain hex dump. Again, the *test_abbr()* macro
    is added to the if condition to disable the space output when the -a switch is
    specified. Here is the modification:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这个空格对于纯十六进制转储是不需要的。同样，*test_abbr()*宏被添加到if条件中，以在指定-a选项时禁用空格输出。以下是修改内容：
- en: '[PRE51]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Another space is added when the line length is less than the LENGTH constant.
    This statement (at line 37 in the dumpfile05.c source code file) need not be modified
    because the ASCII column is also suppressed.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当行长度小于LENGTH常量时，会添加另一个空格。这个语句（在dumpfile05.c源代码文件的37行）不需要修改，因为ASCII列也被抑制了。
- en: 'Finally, the last part of the *line_out()* function to be modified is the *for*
    loop that outputs the ASCII column. This chunk of code is enclosed in an *if*
    test like the first column:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，需要修改的*line_out()*函数的最后一部分是输出ASCII列的*for*循环。这段代码被一个类似于第一列的*if*测试包围：
- en: '[PRE52]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Each time the *test_abbr()* macro is used, it’s prefixed with the not (!) operator.
    This may cause you to think about rewriting the macro so that its evaluation is
    reversed. You could do so, though I chose to be consistent with both macros in
    that they return 1 when the switch is active.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 每次使用*test_abbr()*宏时，它前面都会加上非操作符(!)。这可能会让你考虑重新编写宏，使其评估结果相反。虽然我可以这样做，但我选择与两个宏保持一致，当开关激活时，它们返回1。
- en: 'The full source code for adding the -a switch is available in the online repository
    as dumpfile05.c. Here is a sample run on the bytes.dat file, which contains sequential
    value 0 through 255:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 添加-a开关的完整源代码可在在线仓库中找到，作为dumpfile05.c。以下是对bytes.dat文件的示例运行，该文件包含从0到255的顺序值：
- en: '[PRE53]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 9.3.4 Activating octal output
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.4 激活八进制输出
- en: Older programmers have more of an attraction to octal than younger coders. I’m
    on the cusp, at the age where octal was introduced to me as a young coder, but
    we never got a chance to date.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 与年轻的程序员相比，老程序员对八进制的吸引力更大。我正处于一个临界点，在那个年龄，八进制被介绍给我，当时我还是一个年轻的程序员，但我们从未有机会去约会。
- en: Octal is the base-8 counting system, which fits in nicely with three bits of
    data. Before the microcomputer era, this counting base was commonly used on mainframes
    and in programming. You still see vestiges of octal, primarily in file permission
    bits in a Linux directory listing. The octal counting base is shown in table 9.3.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 八进制是基数为8的计数系统，它与三个数据位很好地匹配。在微型计算机时代之前，这种计数基在大型机编程中普遍使用。您仍然可以在Linux目录列表的文件权限位中看到八进制的痕迹。八进制计数基如表9.3所示。
- en: Table 9.3 Octal, decimal, and hexadecimal values
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.3 八进制、十进制和十六进制值
- en: '| Octal | Decimal | Hex | Binary | Octal | Decimal | Hex | Binary |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| 八进制 | 十进制 | 十六进制 | 二进制 | 八进制 | 十进制 | 十六进制 | 二进制 |'
- en: '| 0 | 0 | 0 | 0000 | 10 | 8 | 8 | 1000 |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 0000 | 10 | 8 | 8 | 1000 |'
- en: '| 1 | 1 | 1 | 0001 | 11 | 9 | 9 | 1001 |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 0001 | 11 | 9 | 9 | 1001 |'
- en: '| 2 | 2 | 2 | 0010 | 12 | 10 | A | 1010 |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2 | 2 | 0010 | 12 | 10 | A | 1010 |'
- en: '| 3 | 3 | 3 | 0011 | 13 | 11 | B | 1011 |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 3 | 3 | 0011 | 13 | 11 | B | 1011 |'
- en: '| 4 | 4 | 4 | 0100 | 14 | 12 | C | 1100 |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 4 | 4 | 0100 | 14 | 12 | C | 1100 |'
- en: '| 5 | 5 | 5 | 0101 | 15 | 13 | D | 1101 |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 5 | 5 | 0101 | 15 | 13 | D | 1101 |'
- en: '| 6 | 6 | 6 | 0110 | 16 | 14 | E | 1110 |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 6 | 6 | 0110 | 16 | 14 | E | 1110 |'
- en: '| 7 | 7 | 7 | 0111 | 17 | 15 | F | 1111 |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 7 | 7 | 0111 | 17 | 15 | F | 1111 |'
- en: 'Like many programming languages, C deftly handles octal values. To specify
    octal, you use the zero prefix: 01 is octal 1, 010 is octal 10 (decimal 8), and
    so on. Your source code editor may be wise enough to pick up on octal values and
    highlight them accordingly.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多编程语言一样，C 语言巧妙地处理八进制值。要指定八进制，您使用零前缀：01是八进制1，010是八进制10（十进制8），依此类推。您的源代码编辑器可能足够聪明，能够识别八进制值并相应地突出显示。
- en: The *printf()* and *scanf()* placeholder for octal values is %o. Like other
    placeholders, it features width values and zero-padding.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 八进制值的 *printf()* 和 *scanf()* 占位符是 %o。像其他占位符一样，它具有宽度值和零填充。
- en: For the sake of the old timers, I added an octal output switch to the *dumpfile*
    program. This switch required several updates to the code, for not only octal
    output but also spacing and alignment in the program’s output.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足老用户的需要，我在 *dumpfile* 程序中添加了一个八进制输出开关。这个开关需要对代码进行几个更新，不仅包括八进制输出，还包括程序输出的间距和对齐。
- en: Three changes are required to activate the -o switch, updating the dumpfile05.c
    source code file to its next iteration, dumpfile06.c. Each of these changes is
    found in the *line_out()* function. The *test_oct()* macro is used as an *if*
    condition, which returns TRUE when the -o switch has been specified.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 需要三个更改来激活 -o 开关，将 dumpfile05.c 源代码文件更新到其下一个迭代版本，dumpfile06.c。这些更改中的每一个都在 *line_out()*
    函数中找到。*test_oct()* 宏用作 *if* 条件，当指定 -o 开关时返回 TRUE。
- en: 'When the octal switch is active, the first column needs to output octal values
    instead of hex. This decision is in addition to whether the column is output when
    *test_abbr()* macro is true (or false). An *if-else* structure handles the differing
    output:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 当八进制开关处于活动状态时，第一列需要输出八进制值而不是十六进制值。这个决定是在 *test_abbr()* 宏为真（或假）时输出的列的基础上做出的。一个
    *if-else* 结构处理不同的输出：
- en: '[PRE54]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The %05o placeholder outputs the value of variable offset as an octal number
    five digits wide with zeros padded on the left.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '%05o 占位符将变量 offset 的值以五个字符宽的八进制数输出，左端填充零。'
- en: 'The next change takes place in the *fo* loop that outputs the bytes. It’s pretty
    much the same type of decision: when the *test_oct()* macro returns TRUE, octal
    values are output instead of decimal:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个更改发生在输出字节的 *fo* 循环中。这基本上是相同类型的决策：当 *test_oct()* 宏返回 TRUE 时，输出八进制值而不是十进制值：
- en: '[PRE55]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The placeholder %03o outputs an octal value three digits wide with zeros padded
    on the left. The effect on the output is that each line of bytes is now wider
    than a typical 80-column screen. Still, if the user wants octal output, the program
    provides.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 占位符 %03o 输出一个宽度为三个八进制数字，左端填充零的八进制值。对输出的影响是，现在每一行的字节宽度比典型的80列屏幕要宽。尽管如此，如果用户需要八进制输出，程序会提供。
- en: 'The final change is made when the last line of output is shorter than 16 bytes.
    Because the octal values are output three characters wide instead of two, four
    spaces are needed for each missing byte to line up the ASCII column:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 当输出最后一行小于16字节时，进行最后的更改。因为八进制值以三个字符宽输出而不是两个字符宽，所以每个缺失的字节需要四个空格来对齐ASCII列：
- en: '[PRE56]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'These changes are included in the source code file dumpfile06.c, available
    in this book’s online repository. Here is output from the *dumpfile* program on
    the bytes.dat file with both the -a and -o switches specified:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改包含在源代码文件 dumpfile06.c 中，可在本书的在线仓库中找到。以下是 *dumpfile* 程序在 bytes.dat 文件上使用
    -a 和 -o 开关指定的输出：
- en: '[PRE57]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Output with the -o switch alone is too wide to show as text. Figure 9.1 illustrates
    how the output looks in a terminal window with the dimensions 100 columns by 24
    rows.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用 -o 开关的输出太宽，无法作为文本显示。图 9.1 展示了在 100 列 x 24 行尺寸的终端窗口中输出的外观。
- en: '![09-01](Images/09-01.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![09-01](Images/09-01.png)'
- en: Figure 9.1 Output from the *dumpfile* program with the -o switch is kinda wide.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 使用 -o 开关的 *dumpfile* 程序输出有点宽。
- en: Exercise 9.5
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 9.5
- en: 'How about adding one more switch to the *dumpfile* program? The -v switch is
    commonly used to output the program’s version number. I would recommend setting
    these values as defined constants: separate major and minor version numbers, or
    a complete version number string.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 有关在 *dumpfile* 程序中添加一个额外的开关，您怎么看？-v 开关通常用于输出程序的版本号。我建议将这些值设置为定义的常量：分别设置主版本号和次版本号，或者一个完整的版本号字符串。
- en: Add both the -v switch as well as the code (the *version()* function) to output
    the version number. The program can quit after performing this task. And remember
    that some users may use the -v switch as the program’s only argument. My solution
    to this exercise is found in the online repository as dumpfile07.c.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 将 -v 开关以及代码（*version()* 函数）添加到输出版本号。程序执行此任务后可以退出。并且请记住，一些用户可能会将 -v 开关作为程序的唯一参数。我对这个练习的解决方案可以在在线仓库中找到，文件名为
    dumpfile07.c。
