- en: 8 Constructing a nearest neighbor similarity network
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 构建最近邻相似性网络
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Manually extracting node features
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动提取节点特征
- en: Presenting network motifs and graphlets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示网络基元和图小类
- en: Introducing betweenness and closeness centralities
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍中介中心性和接近中心性
- en: Constructing a monopartite network based on pairwise cosine similarities
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于成对余弦相似度构建单部分网络
- en: Using the community detection algorithm to complete a user segmentation task
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用社区检测算法完成用户细分任务
- en: This chapter will describe constructing a similarity network based on node properties
    or features. Like a typical machine learning preprocessing workflow, each data
    point or node is represented as a vector. In the machine learning context, a vector
    is a list of one or more numerical values. When dealing with graphs, there are
    generally two approaches you could take to describe a node as a vector. You could
    manually produce a set of features that describes a node, or you could use various
    graph algorithms to produce vectors representing a node in the network. In this
    chapter, you will manually create representations of nodes to describe their roles
    in the network and then use those representations to construct an inferred similarity
    network.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将描述基于节点属性或特征的相似性网络的构建。类似于典型的机器学习预处理工作流程，每个数据点或节点都表示为一个向量。在机器学习环境中，向量是一组一个或多个数值的列表。处理图时，通常有两种方法可以用来描述一个节点为向量。你可以手动生成一组描述节点的特征，或者可以使用各种图算法生成表示网络中节点的向量。在本章中，你将手动创建节点的表示，以描述它们在网络中的角色，然后使用这些表示来构建一个推断的相似性网络。
- en: Figure 8.1 shows the process of extracting node features from the follower network.
    There are multiple approaches to describing a node as a vector. In this chapter,
    you will manually identify and extract relevant features that will be used to
    construct a similarity network. After that, you will evaluate how similar the
    nodes are based on the extracted features. The most common metric to evaluate
    the similarity between two vectors is *cosine similarity*. Cosine similarity is
    defined as the cosine of the angle between two vectors. You will calculate cosine
    similarity between pairs of nodes and store the relationship between nodes deemed
    similar. As in the last chapter, you will define the similarity threshold of when
    a relationship should be created. Notice that nodes connected in the original
    network are not necessarily connected in the inferred similarity network.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1展示了从关注者网络中提取节点特征的过程。描述一个节点为向量的方法有多种。在本章中，你将手动识别和提取用于构建相似性网络的相关特征。之后，你将根据提取的特征评估节点之间的相似度。评估两个向量之间相似度的最常见指标是**余弦相似度**。余弦相似度定义为两个向量之间角度的余弦值。你将计算节点对之间的余弦相似度，并存储被认为相似的节点之间的关系。与上一章类似，你将定义创建关系的相似度阈值。请注意，在原始网络中连接的节点在推断的相似性网络中不一定连接。
- en: '![08-01](../../OEBPS/Images/08-01.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![08-01](../../OEBPS/Images/08-01.png)'
- en: Figure 8.1 Extracting node representations and constructing a similarity network
    based on them
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 基于节点表示构建相似性网络的过程
- en: Cosine similarity is defined as the cosine of the angle between two vectors,
    as visualized in figure 8.2\. The measure ranges between -1 and 1\. When a pair
    of vectors has an identical direction, meaning the angle between the vectors is
    0, the cosine similarity is 1\. On the other hand, when the two vectors have opposite
    directions, the cosine similarity is -1\. In practice, you deem two vectors similar
    when their cosine similarity is close to 1.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 余弦相似度定义为两个向量之间角度的余弦值，如图8.2所示。这个度量范围在-1到1之间。当一对向量具有相同方向时，意味着向量之间的角度为0，余弦相似度为1。另一方面，当两个向量方向相反时，余弦相似度为-1。在实践中，当两个向量的余弦相似度接近1时，你认为这两个向量是相似的。
- en: Imagine you work as an analyst at Twitter. Your supervisor gives you the task
    of identifying the types of users on the platform but doesn’t tell you exactly
    what to look for or how to group users. There are several features in the dataset
    you could use to describe a user. For example, you know how often and what hashtags
    they use in their tweets or retweets. You are also aware of who they follow or
    mention on the platform.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你是一名Twitter的分析师。你的上司给你分配了一个任务，即识别平台上的用户类型，但没有告诉你具体要寻找什么或如何分组用户。数据集中有几个特征可以用来描述一个用户。例如，你知道他们发推文或转发推文时使用哪些标签或标签组。你也很清楚他们关注或提及的人。
- en: '![08-02](../../OEBPS/Images/08-02.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![08-02](../../OEBPS/Images/08-02.png)'
- en: Figure 8.2 Cosine similarity is measured as the cosine of the angle between
    two vectors.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 余弦相似度是通过测量两个向量之间角度的余弦值来衡量的。
- en: Additionally, you also have some timeline information about when a user or a
    tweet was created. As with all manual feature engineering, you first must decide
    which metrics or features you will use to describe a node. Since you have a small
    subset of tweets from a small time window, it doesn’t make sense to analyze whether
    users have become inactive by not posting or retweeting anymore. On the other
    hand, exploring features that would help you split users by content creators versus
    those who primarily only retweet might be interesting. For example, you could
    take the total count of tweets and the ratio between retweets and all tweets as
    the first two features.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还有一些关于用户或推文创建时间的时序信息。与所有手动特征工程一样，你首先必须决定你将使用哪些指标或特征来描述一个节点。由于你只有一小部分来自小时间窗口的推文，分析用户是否由于不再发布或转发而变得不活跃是没有意义的。另一方面，探索有助于你根据内容创作者与主要仅转发的人来划分用户的特征可能很有趣。例如，你可以将推文总数和转发与所有推文之间的比率作为前两个特征。
- en: Another interesting metric could be the average time it takes a user to retweet.
    You could assume that if the average retweet time is minimal, you are most likely
    dealing with a bot. Another metric that could help you identify bots is inspecting
    whether multiple users post identical content at similar times. Since you have
    information about followers available, exploring some metrics that encapsulate
    the position and roles of nodes in the follower network might be worth considering.
    You will learn how to characterize a node’s immediate neighborhood as well as
    investigate its role in the whole network. A node’s *role* is a subjective interpretation
    of the part it plays in the network. For example, you can use the betweenness
    centrality algorithm to evaluate which nodes act as bridges between various communities
    or parts of the network. Similarly, you can use closeness centrality to evaluate
    how close a node is to all the other nodes in the network. Assuming most, if not
    all, information on Twitter is spread through follower relationships, you could
    identify nodes that can disseminate information through the network the fastest
    due to their position in the network.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的指标可能是用户转发所需平均时间。你可以假设，如果平均转发时间是最低的，那么你很可能在处理一个机器人。另一个可以帮助你识别机器人的指标是检查多个用户是否在相似时间发布相同内容。由于你有关于关注者的信息，探索一些包含节点在关注者网络中位置和角色的指标可能值得考虑。你将学习如何描述节点的直接邻域以及调查它在整个网络中的作用。节点的*角色*是对它在网络中所扮演部分的主观解释。例如，你可以使用介数中心性算法来评估哪些节点充当不同社区或网络部分之间的桥梁。同样，你可以使用接近中心性来评估节点在网络中与其他所有节点的接近程度。假设大多数，如果不是所有，关于Twitter的信息都是通过关注者关系传播的，你可以识别出由于在网络中的位置，可以最快通过网络传播信息的节点。
- en: After the feature extraction process, you will construct a similarity network
    between users based on pairwise cosine similarity between their feature vectors.
    You will then use a community detection algorithm like the label propagation algorithm,
    introduced in the previous chapter, to identify various segments of users. Since
    the relationships connect similar nodes, the community detection algorithm will
    identify groups of nodes that are densely interconnected in the inferred similarity
    network. The identified groups of users can be interpreted as user segmentation
    based on the manually extracted features. In a business environment, the task
    of grouping individuals based on specific characteristics is known as *user segmentation*,
    while in a technical setting, it is referred to as *unsupervised clustering* or
    *community detection*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在特征提取过程之后，你将根据用户特征向量之间的成对余弦相似度构建用户之间的相似性网络。然后，你将使用前一章中介绍的标签传播算法等社区检测算法来识别用户的各个部分。由于关系连接了相似节点，社区检测算法将识别在推断的相似性网络中紧密互联的节点组。识别出的用户组可以解释为基于手动提取特征的用户细分。在商业环境中，根据特定特征对个体进行分组的工作被称为*用户细分*，而在技术环境中，它被称为*无监督聚类*或*社区检测*。
- en: Figure 8.3 shows the process of using a community detection algorithm on the
    inferred similarity network to identify groups of users that can be interpreted
    as segments. The density of the inferred similarity network will directly correlate
    with the size of communities. You cannot predefine how many segments or clusters
    you want to identify with this approach; however, you can influence the size of
    clusters by tuning the density of the inferred similarity network.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 展示了在推断相似性网络上使用社区检测算法的过程，以识别可以解释为段的用户组。推断相似性网络的密度将直接与社区的大小相关。您不能使用这种方法预先定义您想要识别的段或聚类的数量；然而，您可以通过调整推断相似性网络的密度来影响聚类的大小。
- en: '![08-03](../../OEBPS/Images/08-03.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![08-03](../../OEBPS/Images/08-03.png)'
- en: Figure 8.3 Using a community detection algorithm to identify segments of users
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 使用社区检测算法识别用户段
- en: Several research papers (for example, Tinati & Carr, 2012; Beguerisse-Díaz et
    al., 2014) focus on defining user roles on the Twitter network. Although extracted
    features vary from paper to paper, and one can use multiple community detection
    or clustering techniques to group users together, the underlying idea seems to
    be always identical. The first part involves identifying and extracting relevant
    features that describe a user. The feature extraction is done manually, allowing
    the analyst to explain all the features and their relevance. For example, if you
    use a model that automatically transforms nodes into vectors, it is hard to explain
    what those vectors mean. Finally, researchers then use various community detection
    or clustering techniques to group users into segments.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 几篇研究论文（例如，Tinati & Carr，2012年；Beguerisse-Díaz 等人，2014年）专注于在 Twitter 网络上定义用户角色。尽管提取的特征因论文而异，并且可以使用多个社区检测或聚类技术将用户分组，但基本思想似乎是始终如一的。第一部分涉及识别和提取描述用户的有关特征。特征提取是手动完成的，允许分析师解释所有特征及其相关性。例如，如果您使用一个将节点自动转换为向量的模型，那么很难解释这些向量代表什么。最后，研究人员然后使用各种社区检测或聚类技术将用户分组到段中。
- en: You could use the approach of constructing a nearest neighbor graph and evaluating
    its community structure to identify specific groups or clusters in many other
    domains. For example, you could use this technique to segment users to create
    personalized services (Voulodimos et al., 2011) or cluster customers to improve
    market forecasting and planning research (Kashwan & Velu, 2013). You could also
    use a similar approach to cluster research papers by examining the relevance of
    specific sentence structures in their abstracts (Fukuda & Tomiura, 2018). While
    the feature extraction might look very different in different analyses, ranging
    from employing simple statistics to extracting network features or even document
    embeddings, the input to the analysis will always be a vector representing each
    data point. Next, plenty of algorithms are available to group data points based
    on their vector representations, and I am not here to argue which is best and
    why. Instead, I want to give you an example of using a graph-based approach to
    unsupervised clustering, where the number of final clusters or communities is
    not predefined. To follow the exercises in this chapter, you need to have the
    Twitter network imported into the Neo4j database, as described in chapter 3.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用构建最近邻图并评估其社区结构的方法，在许多其他领域识别特定的组或聚类。例如，您可以使用这种技术对用户进行细分以创建个性化服务（Voulodimos
    等人，2011年）或聚类客户以改善市场预测和规划研究（Kashwan & Velu，2013年）。您还可以使用类似的方法通过检查其摘要中特定句子结构的相关性来聚类研究论文（Fukuda
    & Tomiura，2018年）。虽然特征提取在不同的分析中可能看起来非常不同，从使用简单的统计到提取网络特征或甚至文档嵌入，分析输入始终是一个表示每个数据点的向量。接下来，有大量的算法可以根据数据点的向量表示对数据进行分组，我并不在这里争论哪个最好以及为什么。相反，我想给你一个使用基于图的方法进行无监督聚类的例子，其中最终聚类的数量或社区不是预先定义的。为了跟随本章的练习，您需要将
    Twitter 网络导入到第 3 章中描述的 Neo4j 数据库中。
- en: 8.1 Feature extraction
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 特征提取
- en: As mentioned, the first step in the user segmentation process is feature extraction.
    Every node feature will be stored as its property. First, you will use your Cypher
    knowledge to extract the number of tweets and the ratio between retweets and tweets
    for each user.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，用户细分过程的第一步是特征提取。每个节点特征都将存储为其属性。首先，您将使用您的 Cypher 知识提取每个用户的推文数量以及转发与推文的比率。
- en: Exercise 8.1
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 8.1
- en: Calculate the number of tweets for each user and store it as the `tweetCount`
    property. Make sure to include those users that have zero published tweets. Additionally,
    calculate the ratio between retweets and tweets for each user. Specifically, divide
    the count of retweets by the sum of retweets plus tweets, and store it as the
    `retweetRatio` property. When a user has no retweets or tweets, use a default
    value of zero. You can use a single or two Cypher statements to calculate both
    features, whatever is easier for you.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 计算每个用户的推文数量，并将其存储为`tweetCount`属性。确保包括那些发布了零条推文的用户。此外，计算每个用户的转发与推文之间的比率。具体来说，将转发的数量除以转发和推文的总和，并将其存储为`retweetRatio`属性。当一个用户没有转发或推文时，使用默认值零。您可以使用一个或两个Cypher语句来计算这两个特征，您觉得哪个更容易。
- en: Next, you will evaluate the distribution of how long it takes on average for
    a user to retweet a tweet after it has been published. You could hypothesize that
    if a user retweets a lot almost instantly, it is likely a bot. The following listing
    introduces the `duration .between()` function, which is used to calculate the
    duration between two datetimes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将评估用户在推文发布后平均需要多长时间转发推文的分布。您可以假设如果一个用户几乎立即转发很多推文，那么它很可能是机器人。以下列表介绍了`duration.between()`函数，该函数用于计算两个日期时间之间的持续时间。
- en: Listing 8.1 Evaluating the distribution of average duration between a retweet
    and tweet created dates
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.1评估转发和创建推文日期之间的平均持续时间分布
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Uses the duration.between() function to calculate the duration between two
    datetimes
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用`duration.between()`函数计算两个日期时间之间的持续时间
- en: ❷ Calculates the average retweet delay, grouped by user
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 按用户分组计算平均转发延迟
- en: 'The `duration` temporal type behaves like an object and has multiple methods
    to extract the duration in years, days, minutes, and more. You can review all
    the available methods in the documentation: [http://mng.bz/NVnd](http://mng.bz/NVnd).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`duration`时间类型表现得像一个对象，并且有多个方法来提取年、天、分钟等持续时间。您可以在文档中查看所有可用的方法：[http://mng.bz/NVnd](http://mng.bz/NVnd)。'
- en: The results of the Cypher statement in listing 8.1 are shown in table 8.1.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.1中Cypher语句的结果显示在表8.1中。
- en: Table 8.1 Distribution of average time between retweet and original tweet per
    user
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.1每个用户转发和原始推文之间的平均时间分布
- en: '| `total` | 1,385 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `total` | 1,385 |'
- en: '| `min` | 0.0 |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `min` | 0.0 |'
- en: '| `minNonZero` | 0.05769228935241699 |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `minNonZero` | 0.05769228935241699 |'
- en: '| `0.1` | 2.583343267440796 |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `0.1` | 2.583343267440796 |'
- en: '| `max` | 1,439 |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `max` | 1,439 |'
- en: '| `0.05` | 1.0000073909759521 |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `0.05` | 1.0000073909759521 |'
- en: '| `mean` | 372.21522092560997 |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `mean` | 372.21522092560997 |'
- en: '| `0.25` | 22.00012183189392 |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `0.25` | 22.00012183189392 |'
- en: '| `0.5` | 206.00097632408142 |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `0.5` | 206.00097632408142 |'
- en: '| `0.9` | 1,057.0078122615814 |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `0.9` | 1,057.0078122615814 |'
- en: '| `stdev` | 410.56837279615803 |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `stdev` | 410.56837279615803 |'
- en: You can observe that you have information for only 1,385 users, slightly less
    than 40% of all users. Five percent of users retweet within a minute, and 10%
    of users retweet within 2.5 minutes. You could use a combination of retweets and
    average time to retweet to identify bots. If a user consistently retweets within
    a minute or two, you are likely dealing with a bot. You can observe that, otherwise,
    the average time to retweet is around 6 hours, which makes sense for a normal
    human being who is not constantly looking at their Twitter feed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以观察到，您只有1,385个用户的信息，略少于所有用户的40%。5%的用户在1分钟内转发，10%的用户在2.5分钟内转发。您可以使用转发和平均转发时间来识别机器人。您可以观察到，否则，平均转发时间约为6小时，这对于一个不是一直在查看Twitter动态的正常人来说是有意义的。
- en: Exercise 8.2
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 练习8.2
- en: Calculate the average duration in minutes between tweet and retweet per user
    and store it as a `timeToRetweet` property. Use the mean value of 372 minutes
    for users that have never retweeted (have missing values).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 计算每个用户之间推文和转发的时间间隔（以分钟为单位）的平均值，并将其存储为`timeToRetweet`属性。对于从未转发过的用户（有缺失值），使用372分钟的平均值。
- en: Another feature that might indicate bots is whether multiple users are posting
    identical content.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能表明是机器人的特征是多个用户是否发布相同的内容。
- en: Exercise 8.3
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 练习8.3
- en: Inspect pairs of tweets with identical content that are not retweets. The content
    is available in the `text` property. Additionally, ignore occurrences when a single
    author posts multiple tweets with the same content.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 检查内容相同但不是转发的推文对。内容可在`text`属性中找到。此外，忽略单个作者发布相同内容的多个推文的情况。
- en: By solving exercise 8.3, you can observe that there are only five tweets that
    all have identical content. Since this feature is present with only 5 users, only
    1 per 1,000 users, you will ignore it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过解决练习8.3，你可以观察到只有五条推文内容完全相同。由于这个特征只出现在5个用户中，每1000个用户中只有1个，所以你会忽略它。
- en: 8.1.1 Motifs and graphlets
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.1 模式和图子
- en: Next, you will focus on encoding a user’s role in the follower network. Nodes
    with similar roles do not have to be next to one another in the network. For example,
    you could say users with a large following have a role in producing certain types
    of content. There could be multiple users with a large following, and they don’t
    have to follow one another or be close in the network, but they still hold a similar
    role. In this example, you are effectively examining only the direct neighborhood
    of a node. You can encode a node’s local neighborhood by counting its *graphlets*.
    A graphlet is a position of a node in a distinctly connected subgraph consisting
    of *k* nodes. You might already be familiar with two-node graphlets, although
    you have probably never heard that name before.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将专注于编码用户在跟随网络中的角色。具有相似角色的节点在网络上不必相邻。例如，你可以这样说，拥有大量追随者的用户在产生某些类型的内容中扮演着角色。可能有多个拥有大量追随者的用户，他们不必相互跟随或在网络中接近，但他们仍然扮演着相似的角色。在这个例子中，你实际上只检查了一个节点的直接邻域。你可以通过计算节点的*图子*来编码一个节点的局部邻域。图子是一个节点在由*k*个节点组成的明显连通子图中的位置。你可能已经熟悉了两节点图子，尽管你可能从未听说过这个名字。
- en: Figure 8.4 shows all the two-node directed graphlets. A two-node directed graphlet
    consists of two nodes and has directed relationships. There are three possible
    variations of directed relations between two nodes. When you are counting graphlets,
    you are essentially counting how many times a node is present in that graph pattern.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4显示了所有两节点有向图子。一个两节点有向图子由两个节点组成，并具有有向关系。两个节点之间有三种可能的有向关系变体。当你计算图子时，你实际上是在计算一个节点在那个图模式中出现的次数。
- en: '![08-04](../../OEBPS/Images/08-04.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![08-04](../../OEBPS/Images/08-04.png)'
- en: Figure 8.4 Two-node graphlets
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 两节点图子
- en: Figure 8.5 presents a visual representation of the count of two-node graphlets
    for node A. As shown in figure 8.4, a graphlet with a node at position 0 has an
    outgoing connection. So if you want to count the graphlet at position zero for
    node A, you count the number of outgoing connections, which is 2 in the example
    in figure 8.5\. Similarly, by evaluating its incoming degree, you can count the
    graphlets at position 1 for node A. Finally, with a directed graph, you can have
    relationships in both directions between two nodes, as shown on the right side
    of figure 8.5\. In some social networks, two users can be regarded as friends
    when they follow one another. In figure 8.5, only nodes A and D follow one another.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5展示了节点A的两节点图子计数可视化表示。如图8.4所示，位于位置0的图子有一个出向连接。所以如果你想计算节点A在位置零的图子，你计算出向连接的数量，在图8.5的例子中是2。同样，通过评估其入度，你可以计算节点A在位置1的图子。最后，在有向图中，两个节点之间可以有两个方向的关系，如图8.5的右侧所示。在某些社交网络中，当两个用户相互关注时，可以认为他们是朋友。在图8.5中，只有节点A和D相互关注。
- en: '![08-05](../../OEBPS/Images/08-05.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![08-05](../../OEBPS/Images/08-05.png)'
- en: Figure 8.5 Counting two-node graphlets
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 计算两节点图子
- en: Exercise 8.4
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 练习8.4
- en: Calculate the incoming and outgoing degrees for all the users in the follower
    network, and store the results under the `inDegree` and `outDegree` properties.
    Additionally, count how many friends (graphlet two) patterns are present for each
    user and store the output as the `friendCount` property.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 计算跟随网络中所有用户的入度和出度，并将结果存储在`inDegree`和`outDegree`属性下。此外，计算每个用户存在的“朋友”（图子二）模式数量，并将输出存储为`friendCount`属性。
- en: Next, you will look at three-node graphlets and calculate some of them to encode
    a node’s local neighborhood. Figure 8.6 shows all the 30 variations of directed
    three-node graphlets. It would be a nice exercise in Cypher to calculate all of
    them; however, you will only calculate the three visualized graphlets in figure
    8.6.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将研究三节点图子，并计算其中一些来编码一个节点的局部邻域。图8.6显示了所有30种有向三节点图子的变体。在Cypher中进行所有这些计算将是一个很好的练习；然而，你将只计算图8.6中可视化的三个图子。
- en: '![08-06](../../OEBPS/Images/08-06.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![08-06](../../OEBPS/Images/08-06.png)'
- en: Figure 8.6 Three-node graphlets
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 三节点图子
- en: You may also notice that figure 8.6 shows motif numbers as well as graphlet
    numbers. What is the difference between the two? A *motif* is a distinctly connected
    subgraph, while a *graphlet* describes a node’s position in the motif. For example,
    if you look at motif 1, you can observe that it consists of three nodes and two
    relationships. With motifs, you only count how often this pattern occurs in a
    network. On the other hand, you can observe there are three options for a node
    position in this motif 1; therefore, there are three graphlets available. Motifs
    are used to characterize a network structure (Kim et al., 2011), while graphlets
    come in handy when you want to describe a local neighborhood of a node (Pržulj
    et al., 2004).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还会注意到图 8.6 不仅显示了基序数量，还显示了图子数量。这两者之间有什么区别？一个 *基序* 是一个明显连接的子图，而一个 *图子* 描述了节点在基序中的位置。例如，如果你看基序
    1，你可以观察到它由三个节点和两个关系组成。使用基序，你只计算这种模式在网络中出现的频率。另一方面，你可以观察到在这个基序 1 中，节点位置有三种选择；因此，有三种图子可用。基序用于表征网络结构（Kim
    等人，2011），而图子在你想要描述节点的局部邻域时非常有用（Pržulj 等人，2004）。
- en: While you may not ordinarily find scenarios in which people focus solely on
    calculating graphlet or motif counts, it’s essential not to overlook their significance.
    Many algorithms, in fact, use them as key components in deriving representations
    of individual nodes (Rossi et al., 2017) or even entire graphs (Dutta et al.,
    2020; Gorrec et al., 2022).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能不会经常遇到人们只专注于计算图子或基序计数的情况，但不容忽视它们的的重要性。实际上，许多算法将它们作为推导单个节点（Rossi 等人，2017）甚至整个图（Dutta
    等人，2020；Gorrec 等人，2022）表示的关键组成部分。
- en: Exercise 8.5
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 8.5
- en: Calculate graphlets 5, 8, and 11 shown in figure 8.6 for each user in the follower
    network and store them as node properties. Store graphlet 5 under the `graphlet5`
    node property and so on. I recommend you use a separate Cypher statement for each
    graphlet calculation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为跟随网络中的每个用户计算图 8.6 中显示的图子 5、8 和 11，并将它们存储为节点属性。将图子 5 存储在 `graphlet5` 节点属性下，依此类推。我建议你为每个图子计算使用单独的
    Cypher 语句。
- en: 8.1.2 Betweenness centrality
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.2 介数中心性
- en: You have used graphlets to encode the local neighborhood of a node; however,
    you have not yet extracted any features that would describe a user’s position
    in the global network. You will start by executing the betweenness centrality
    algorithm to extract a feature that describes how often a user acts as a bridge
    between various communities. The *betweenness centrality* algorithm assumes all
    information travels along the shortest paths between nodes. The more often a node
    lies on those shortest paths, the higher its betweenness centrality rank.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经使用图子来编码节点的局部邻域；然而，你还没有提取任何描述用户在全局网络中位置的特性。你将首先执行介数中心性算法来提取一个描述用户作为不同社区之间桥梁频率的特性。*介数中心性*
    算法假设所有信息都沿着节点之间的最短路径传输。一个节点越频繁地位于这些最短路径上，它的介数中心性排名就越高。
- en: Figure 8.7 visualizes a Marvel network of characters, where relationships appear
    between characters that appeared in the same comic book. Both the size of the
    node and the size of the character name are calculated using betweenness centrality.
    The higher the betweenness centrality rank is, the larger the node and caption
    size is. You can observe that nodes that connect different communities are the
    largest. For example, Captain America is at the center of the network and acts
    as a bridge between the central community and all other communities. Another excellent
    example of betweenness centrality is the Beast character, who is the only link
    between the central and the bottom communities in figure 8.7\. If he were to be
    removed from the network, the network would be split into two separate components.
    Therefore, the Beast character acts as a bridge between the bottom community and
    the rest of the network. Acting as a bridge also gives a node influence over the
    information flow between the two communities.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 可视化了一个超级英雄网络，其中关系出现在出现在同一漫画书中的角色之间。节点的大小和角色名称的大小都是使用介数中心性计算的。介数中心性排名越高，节点和标题的大小就越大。你可以观察到连接不同社区的角色节点是最大的。例如，美国队长位于网络的中心，在中央社区和其他所有社区之间充当桥梁。另一个介数中心性的优秀例子是野兽角色，他是图
    8.7 中中央和底部社区之间的唯一联系。如果他被从网络中移除，网络将分裂成两个单独的部分。因此，野兽角色充当了底部社区和整个网络之间的桥梁。充当桥梁也使节点对两个社区之间的信息流有影响力。
- en: '![08-07](../../OEBPS/Images/08-07.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![08-07](../../OEBPS/Images/08-07.png)'
- en: 'Figure 8.7 Sample visualization of the betweenness centrality rank (Source:
    Sanhueza. Licensed under CC BY 3.0 license)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 示例：中间中心性排名的可视化（来源：Sanhueza。许可协议为CC BY 3.0）
- en: Before executing the betweenness centrality algorithm on the follower network,
    you must project an in-memory graph, as shown in listing 8.2\. You will use the
    same projected graph to execute graph algorithms and then construct the nearest
    neighbor graph. For that reason, you also need to include all the previously calculated
    node features in the projection. Completing exercises 8.1 through 8.5 is a requirement
    to execute the following Cypher statement that projects an in-memory graph.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在对关注者网络执行中间中心性算法之前，你必须投影一个内存图，如图8.2所示。你将使用相同的投影图来执行图算法，然后构建最近邻图。因此，你还需要在投影中包含所有之前计算过的节点特征。完成8.1至8.5的练习是执行以下Cypher语句以投影内存图的必要条件。
- en: Listing 8.2 Projecting the in-memory graph that describes the follower network
    and includes all the precalculated node features
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.2 投影描述关注者网络并包含所有预计算节点特征的内存图
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, you can execute the betweenness centrality algorithm. You will use the
    `mutate` mode to store the results back to the projected graph in the following
    listing.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以执行中间中心性算法。你将使用`mutate`模式将结果存储回以下列表中的投影图中。
- en: Listing 8.3 Mutating the betweenness centrality algorithm
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.3 修改中间中心性算法
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 8.1.3 Closeness centrality
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.3 接近中心性
- en: '*Closeness centrality* is a measure that indicates how close a node is to all
    the other nodes in the network. The algorithm starts by calculating the shortest
    paths from a node to all the other nodes in the network. Once the shortest paths
    are calculated, the algorithm sums the distance to all the other nodes. By default,
    it returns an inverse of the distance sum so that a higher score means that a
    node has a higher closeness centrality rank. One can interpret closeness as the
    potential ability to reach all the other nodes as quickly as possible.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*接近中心性*是一种衡量指标，表示一个节点在网络中与其他所有节点的接近程度。算法首先计算从节点到网络中所有其他节点的最短路径。一旦计算出最短路径，算法将计算到所有其他节点的距离之和。默认情况下，它返回距离之和的倒数，因此分数越高意味着节点的接近中心性排名越高。可以将接近性解释为尽可能快地到达所有其他节点的潜在能力。'
- en: Figure 8.8 shows the same Marvel network as figure 8.7\. The difference is that
    here, the node and the caption size are calculated by the closeness centrality
    algorithm instead of the betweenness centrality algorithm. You can observe that
    the largest nodes are in the center of the network, which makes sense, as they
    can reach all the other nodes the fastest. On the other hand, characters on the
    outskirts of the network have a minimal closeness centrality rank. Captain America
    is in such a privileged position that he leads in both categories of centralities.
    On the other hand, for example, Iron Man is trailing far behind Spider-Man and
    Beast by the betweenness centrality. However, he is in front of them when looking
    at the closeness centrality rank, due to his position in the center of the network.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8显示了与图8.7相同的漫威网络。不同之处在于，这里节点和标题的大小是通过接近中心性算法而不是中间中心性算法计算的。你可以观察到最大的节点位于网络的中心，这是有道理的，因为它们可以最快地到达所有其他节点。另一方面，网络外围的角色具有最小的接近中心性排名。美国队长处于如此有利的地位，他在中心性的两个类别中都领先。另一方面，例如，钢铁侠在中间中心性排名上落后于蜘蛛侠和野兽。然而，当查看接近中心性排名时，他由于在网络中的中心位置而领先于他们。
- en: '![08-08](../../OEBPS/Images/08-08.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![08-08](../../OEBPS/Images/08-08.png)'
- en: Figure 8.8 Sample visualization of closeness centrality rank
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 示例：网络中节点接近中心性排名的可视化
- en: The first variant of closeness centrality might be unreliable on disconnected
    graphs. Remember, the algorithm tries to find the shortest path to all the other
    nodes in the graph. If the original variant is used on disconnected graphs, the
    shortest path might not exist, and therefore, the sum of all shortest paths from
    a node might be infinite. In practice, there are several variations of the closeness
    centrality formula that deal with disconnected graphs. In this example, you will
    use the Wasserman and Faust variation of the formula (Wasserman & Faust, 1994).
    You can execute the `mutate` mode of the closeness centrality algorithm with the
    following Cypher statement.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接近中心性的第一个变体在无连接图中可能不可靠。记住，该算法试图找到图中所有其他节点的最短路径。如果使用原始变体在无连接图中，最短路径可能不存在，因此，从节点到所有最短路径的总和可能是无限的。在实践中，存在几种处理无连接图的接近中心性公式的变体。在这个例子中，你将使用
    Wasserman 和 Faust 公式的变体（Wasserman & Faust, 1994）。你可以使用以下 Cypher 语句执行接近中心性算法的 `mutate`
    模式。
- en: Listing 8.4 Mutating the closeness centrality algorithm
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.4 修改接近中心性算法
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 8.2 Constructing the nearest neighbor graph
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 构建最近邻图
- en: You have completed the first step of the user segmentation process by manually
    extracting the features. The second step is to group or cluster users into segments.
    As mentioned, several different methods are available to cluster data points based
    on vector representations. Here, you will construct a nearest neighbor graph based
    on pairwise cosine similarity between vector representations. Since evaluating
    cosine similarity between many data points is a relatively frequent process, some
    algorithm implementations do an intelligent search and avoid comparing all pairs
    of data points, since that doesn’t scale well. The Neo4j Graph Data Science (GDS)
    library implements an efficient similarity search based on the cosine similarity
    metric. Before constructing the nearest neighbor graph, it is advisable to explore
    the distributions and correlations between the features.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经通过手动提取特征完成了用户细分过程的第一个步骤。第二个步骤是将用户分组或聚类成细分市场。如前所述，有几种不同的方法可以根据向量表示聚类数据点。在这里，你将基于向量表示之间的成对余弦相似性构建最近邻图。由于评估许多数据点之间的余弦相似性是一个相对频繁的过程，一些算法实现会进行智能搜索并避免比较所有数据点对，因为那样扩展性不好。Neo4j
    图数据科学（GDS）库实现了一个基于余弦相似性度量的高效相似性搜索。在构建最近邻图之前，探索特征之间的分布和相关性是明智的。
- en: 8.2.1 Evaluating features
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.1 评估特征
- en: To utilize Cypher’s full expressivity and flexibility to analyze features, you
    must store the `closeness` and `betweenness` properties from the projected in-memory
    graph back to the stored graph. You can use the `gds.graph.writeNodeProperties`
    to store the mutated properties back to the database.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用 Cypher 的完整表达性和灵活性来分析特征，你必须将投影到内存图中的 `closeness` 和 `betweenness` 属性存储回存储的图中。你可以使用
    `gds.graph.writeNodeProperties` 将修改后的属性存储回数据库。
- en: Listing 8.5 Storing the mutated properties to the database
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.5 将修改后的属性存储到数据库中
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You will start by examining which node features correlate the most. The GDS
    library offers a `gds.similarity.pearson(vector1,` `vector2)` function that calculates
    the correlation between two vectors. You will compare all pairs of features and
    identify the ones that correlate most. Many clustering techniques are influenced
    by feature collinearity, which can skew results. *Feature collinearity* is a phenomenon
    during which one feature highly correlates with another one. You can use the following
    Cypher statement to identify the most correlating features.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你将首先检查哪些节点特征相关性最高。GDS 库提供了一个 `gds.similarity.pearson(vector1, vector2)` 函数，用于计算两个向量之间的相关性。你将比较所有特征对并识别相关性最高的那些。许多聚类技术受特征共线性影响，这可能导致结果偏差。*特征共线性*
    是一种现象，其中一个特征与另一个特征高度相关。你可以使用以下 Cypher 语句来识别最相关的特征。
- en: Listing 8.6 Identifying the five most frequently correlating pairs of features
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.6 识别最频繁相关的特征对
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Uses two UNWINDs to compare each feature to all the others
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用两个 UNWIND 语句比较每个特征与其他所有特征
- en: ❷ Avoids comparing a feature with itself and removes duplicates
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 避免比较特征与其自身并移除重复项
- en: ❸ Calculates the correlation
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 计算相关性
- en: Table 8.2 shows the resulting pairs.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8.2 显示了结果对。
- en: Table 8.2 The top five correlating pairs of features
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8.2 特征的前五对相关性
- en: '| `feature1` | `feature2` | `correlation` |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `feature1` | `feature2` | `correlation` |'
- en: '| friendCount | graphlet5 | 0.8173954540589915 |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| friendCount | graphlet5 | 0.8173954540589915 |'
- en: '| graphlet8 | outDegree | 0.7867637411832583 |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| graphlet8 | outDegree | 0.7867637411832583 |'
- en: '| graphlet11 | graphlet5 | 0.7795975711131173 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| graphlet11 | graphlet5 | 0.7795975711131173 |'
- en: '| friendCount | graphlet11 | 0.6578582639591071 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| friendCount | graphlet11 | 0.6578582639591071 |'
- en: '| betweenness | friendCount | 0.6370096424048863 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| betweenness | friendCount | 0.6370096424048863 |'
- en: It appears that some of the features are highly correlated. For example, the
    `friendCount` highly correlates with `graphlet5`, `graphlet11`, and `betweenness`
    features. Also, the `graphlet8` variable correlates with the outgoing degree.
    To remove some of the highly correlated pairs of features, you will ignore the
    `friendCount`, `graphlet8`, and `graphlet5` features from your segmentation process.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来，一些特征高度相关。例如，`friendCount` 与 `graphlet5`、`graphlet11` 和 `betweenness` 特征高度相关。此外，`graphlet8`
    变量与出度相关。为了消除一些高度相关的特征对，您将在分割过程中忽略 `friendCount`、`graphlet8` 和 `graphlet5` 特征。
- en: Next, you will quickly evaluate the distributions of the remaining features.
    You can use the following Cypher statement to calculate basic distribution statistics.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将快速评估剩余特征的分布。您可以使用以下 Cypher 语句来计算基本的分布统计信息。
- en: Listing 8.7 Mutating the hashtag co-occurrence network to the in-memory graph
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.7 将 hashtag 共现网络转换为内存图
- en: '[PRE6]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Table 8.3 shows the resulting distribution.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8.3 显示了结果分布。
- en: Table 8.3 Feature distribution
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8.3 特征分布
- en: '| `feature` | `min` | `max` | `mean` | `stdev` | `p50` | `p75` | `p90` | `p95`
    | `p99` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `feature` | `min` | `max` | `mean` | `stdev` | `p50` | `p75` | `p90` | `p95`
    | `p99` |'
- en: '| "tweetCount" | 0.0 | 754.0 | 0.96 | 13.74 | 0.0 | 1.0 | 1.0 | 2.0 | 6.0 |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| "tweetCount" | 0.0 | 754.0 | 0.96 | 13.74 | 0.0 | 1.0 | 1.0 | 2.0 | 6.0 |'
- en: '| "retweetRatio" | 0.0 | 1.0 | 0.37 | 0.48 | 0.0 | 1.0 | 1.0 | 1.0 | 1.0 |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| "retweetRatio" | 0.0 | 1.0 | 0.37 | 0.48 | 0.0 | 1.0 | 1.0 | 1.0 | 1.0 |'
- en: '| "timeToRetweet" | 0.0 | 1439.0 | 372.08 | 254.87 | 372.0 | 372.0 | 613.0
    | 944.0 | 1353.01 |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| "timeToRetweet" | 0.0 | 1439.0 | 372.08 | 254.87 | 372.0 | 372.0 | 613.0
    | 944.0 | 1353.01 |'
- en: '| "inDegree" | 0.0 | 540.0 | 6.92 | 22.76 | 0.0 | 4.0 | 16.0 | 35.0 | 112.0
    |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| "inDegree" | 0.0 | 540.0 | 6.92 | 22.76 | 0.0 | 4.0 | 16.0 | 35.0 | 112.0
    |'
- en: '| "outDegree" | 0.0 | 143.0 | 6.92 | 11.95 | 2.0 | 8.0 | 21.0 | 32.0 | 57.0
    |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| "outDegree" | 0.0 | 143.0 | 6.92 | 11.95 | 2.0 | 8.0 | 21.0 | 32.0 | 57.0
    |'
- en: '| "graphlet11" | 0.0 | 75.0 | 0.2 | 1.88 | 0.0 | 0.0 | 0.0 | 0.0 | 4.0 |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| "graphlet11" | 0.0 | 75.0 | 0.2 | 1.88 | 0.0 | 0.0 | 0.0 | 0.0 | 4.0 |'
- en: '| "closeness" | 0.0 | 0.25 | 0.04 | 0.06 | 0.0 | 0.11 | 0.13 | 0.14 | 0.15
    |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| "closeness" | 0.0 | 0.25 | 0.04 | 0.06 | 0.0 | 0.11 | 0.13 | 0.14 | 0.15
    |'
- en: '| "betweenness" | 0.0 | 199788.66 | 2385.97 | 10885.16 | 0.0 | 17.57 | 4075.66
    | 11850.37 | 48312.5 |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| "betweenness" | 0.0 | 199788.66 | 2385.97 | 10885.16 | 0.0 | 17.57 | 4075.66
    | 11850.37 | 48312.5 |'
- en: Interestingly, the first thing I noticed is that more than 95% of users have
    a `graphlet11` count of 0\. Some might say you could drop the `graphlet11` feature
    due to its low variance; however, you will keep it in this example. The closeness
    centrality scores range from 0.0 to 0.25 with an average of 0.04\. On the other
    hand, the betweenness centrality is not normalized, so the scores are much higher,
    as it ranges from 0.0 to nearly 200,000.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我首先注意到的是，超过 95% 的用户 `graphlet11` 计数为 0。有些人可能会说，由于方差低，可以删除 `graphlet11`
    特征；然而，在这个例子中，您将保留它。接近中心性分数的范围从 0.0 到 0.25，平均值为 0.04。另一方面，中介中心性没有归一化，因此分数要高得多，其范围从
    0.0 到近 200,000。
- en: '*Normalization* in the context of machine learning refers to the process of
    transforming the range of features or variables in data. It’s a crucial preprocessing
    step in many machine learning algorithms. Normalization makes the features more
    comparable by changing their scale to a standard range, typically between 0 and
    1 or -1 and 1\. While you do not need to normalize features if you are using the
    cosine similarity metric to infer a similarity network, you must be careful if
    you are using any other metrics. For example, with Euclidean distance, which is
    simply the distance between two points, a normalization would definitely affect
    the results.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习的背景下，*归一化*指的是将数据中特征或变量的范围进行转换的过程。它是许多机器学习算法中的关键预处理步骤。归一化通过将特征或变量的尺度转换为标准范围（通常在
    0 到 1 或 -1 到 1 之间）来使特征更具有可比性。虽然如果您使用余弦相似度指标来推断相似性网络，则不需要对特征进行归一化，但如果您使用任何其他指标，则必须小心。例如，使用欧几里得距离（即两点之间的距离），归一化肯定会影响结果。
- en: 8.2.2 Inferring the similarity network
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.2 推断相似性网络
- en: You have preprocessed and evaluated the node features. Everything is ready to
    continue with the user segmentation process. To run the community detection algorithm
    and identify user segments, you must first infer a similarity network based on
    a pairwise cosine similarity metric between user vectors. The Neo4j GDS library
    offers an efficient cosine similarity search with the `gds.knn` algorithm. The
    `gds.knn` algorithm is used to construct a nearest neighbor similarity graph and
    should not be confused with more mainstream kNN classification or regression models.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经预处理并评估了节点特征。一切准备就绪，可以继续用户细分过程。要运行社区检测算法并识别用户细分，您必须首先基于用户向量之间的成对余弦相似性度量推断一个相似性网络。Neo4j
    GDS 库提供了使用 `gds.knn` 算法的有效余弦相似性搜索。`gds.knn` 算法用于构建最近邻相似性图，不应与更主流的 kNN 分类或回归模型混淆。
- en: Similarly, as in the previous chapter, you can affect how dense or sparse the
    inferred similarity network will be with the `topK` and `similarityCutoff` parameters.
    In this example, if you infer a denser network, the resulting communities will
    be larger; therefore, the user segmentation process will output fewer segments
    or groups of users. On the other hand, if you infer a sparser similarity network,
    the segmentation will be more granular. There is no right or wrong way to define
    the `topK` and `similarityCutoff` parameters—it always depends on your task. In
    this example, you will use the `topK` value of 65 and leave the `similarityCutoff`
    at the default value.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，与上一章类似，您可以通过 `topK` 和 `similarityCutoff` 参数影响推断出的相似性网络的密集或稀疏程度。在本例中，如果您推断出一个更密集的网络，生成的社区将更大；因此，用户细分过程将输出更少的细分或用户组。另一方面，如果您推断出一个更稀疏的相似性网络，细分将更细粒度。定义
    `topK` 和 `similarityCutoff` 参数没有对错之分——它始终取决于您的任务。在本例中，您将使用 `topK` 值为 65，并将 `similarityCutoff`
    保持为默认值。
- en: Since you need to execute a community detection algorithm on the output of the
    `gds.knn` algorithm, you will use the `mutate` mode to store the results to the
    projected graph. The `gds.knn` algorithm creates new relationships between users
    that pass the similarity threshold defined with the `topK` and `similarityCutoff`
    parameters. Run the following Cypher statement to execute the `mutate` mode of
    the `gds.knn` algorithm.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您需要在 `gds.knn` 算法的输出上执行社区检测算法，您将使用 `mutate` 模式将结果存储到投影图中。`gds.knn` 算法通过 `topK`
    和 `similarityCutoff` 参数定义的相似性阈值创建了用户之间新的关系。运行以下 Cypher 语句以执行 `gds.knn` 算法的 `mutate`
    模式。
- en: Listing 8.8 Mutating the user similarity network to the in-memory graph
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.8 将用户相似性网络转换为内存图
- en: '[PRE7]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 8.3 User segmentation with the community detection algorithm
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 使用社区检测算法进行用户细分
- en: The last step in the user segmentation process is to execute a community detection
    algorithm to identify groups or segments of users. So far, you have used the label
    propagation algorithm to evaluate the community structure of a network. In this
    chapter, you will instead use the Louvain algorithm. The Louvain algorithm has
    a task identical to the label propagation algorithm to group densely connected
    nodes into groups or communities. However, it uses slightly different underlying
    mathematics to achieve this. If you are interested in mathematics, you can read
    the article in which the Louvain algorithm was proposed (Blondel et al., 2008).
    Run the following Cypher statement to `mutate` the results of the Louvain algorithm
    to the projected in-memory graph.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 用户细分过程的最后一步是执行社区检测算法以识别用户组或细分。到目前为止，您已经使用标签传播算法评估了网络的社区结构。在本章中，您将改用 Louvain
    算法。Louvain 算法有一个与标签传播算法相同的任务，即将密集连接的节点分组或社区化。然而，它使用略微不同的底层数学来实现这一点。如果您对数学感兴趣，可以阅读提出
    Louvain 算法的文章（Blondel et al., 2008）。运行以下 Cypher 语句将 Louvain 算法的输出 `mutate` 到投影内存图中。
- en: Listing 8.9 Storing the mutated property `userSegmentation` to the database
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.9 将转换后的属性 `userSegmentation` 存储到数据库
- en: '[PRE8]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the `communityCount` output, there are 22 identified communities.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `communityCount` 输出中，有 22 个已识别的社区。
- en: Note Like label propagation, the Louvain method is not deterministic. Therefore,
    you can get different results on every run, due to the stochastic nature of the
    algorithm.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：与标签传播类似，Louvain 方法不是确定性的。因此，由于算法的随机性质，每次运行都可能得到不同的结果。
- en: To further investigate, you must store the mutated `userSegmentation` property
    to analyze the segmentation with Cypher.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要进一步调查，您必须将转换后的 `userSegmentation` 属性存储起来，以便使用 Cypher 分析细分。
- en: Listing 8.10 Mutating the hashtag co-occurrence network to the in-memory graph
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.10 将标签共现网络转换为内存图
- en: '[PRE9]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Finally, you can evaluate the user segmentation results. Use the following Cypher
    statement to evaluate average feature values for the five largest user segments.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以评估用户细分结果。使用以下Cypher语句来评估五个最大用户细分平均特征值。
- en: Listing 8.11 Evaluating the user segmentation results
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.11 评估用户细分结果
- en: '[PRE10]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Table 8.4 shows the resulting user segmentation.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.4显示了结果用户细分。
- en: Table 8.4 User segmentation results
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.4 用户细分结果
- en: '| `community` | `memberCount` | `tweetCount` | `retweetRatio` | `timeToRetweet`
    | `inDegree` | `outDegree` | `graphlet11` | `betweenness` | `closeness` |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `community` | `memberCount` | `tweetCount` | `retweetRatio` | `timeToRetweet`
    | `inDegree` | `outDegree` | `graphlet11` | `betweenness` | `closeness` |'
- en: '| 270 | 217 | 3.5 | 0.007 | 385.3 | 15.28 | 19.12 | 1.09 | 10283.99 | 0.08
    |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 270 | 217 | 3.5 | 0.007 | 385.3 | 15.28 | 19.12 | 1.09 | 10283.99 | 0.08
    |'
- en: '| 84 | 197 | 1.0 | 0.001 | 375.43 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 84 | 197 | 1.0 | 0.001 | 375.43 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 |'
- en: '| 725 | 179 | 0.92 | 0.2 | 376.72 | 19.13 | 7.82 | 0.78 | 4692.19 | 0.12 |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 725 | 179 | 0.92 | 0.2 | 376.72 | 19.13 | 7.82 | 0.78 | 4692.19 | 0.12 |'
- en: '| 737 | 156 | 0.0 | 0.0 | 372.0 | 0.0 | 0.03 | 0.0 | 0.0 | 0.0 |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 737 | 156 | 0.0 | 0.0 | 372.0 | 0.0 | 0.03 | 0.0 | 0.0 | 0.0 |'
- en: '| 381 | 145 | 0.0 | 1.0 | 35.68 | 2.5 | 4.43 | 0.55 | 845.37 | 0.04 |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 381 | 145 | 0.0 | 1.0 | 35.68 | 2.5 | 4.43 | 0.55 | 845.37 | 0.04 |'
- en: The largest segment contains 217 members, and its members have, on average,
    3.5 tweets. They do almost no retweeting, since their retweet ratio is 0.07\.
    On the other hand, they have, on average, 15 followers and follow 19 other users.
    Judging by their high betweenness score, they act as bridges between various communities.
    On the other hand, the fourth-largest community seems to contain inactive and
    isolated users, at least from our dataset point of view. They don’t have any tweets
    or retweets and don’t follow anyone or have any followers.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的细分包含217名成员，他们的平均推文数为3.5条。由于他们的转发率仅为0.07，所以他们几乎不做转发。另一方面，他们平均有15个关注者，并关注了19个其他用户。根据他们较高的中介中心性得分，他们充当了不同社区之间的桥梁。另一方面，第四大社区似乎包含不活跃和孤立的用户，至少从我们的数据集角度来看。他们没有推文或转发，也没有关注任何人或拥有任何关注者。
- en: You can remove the `LIMIT` clause from the Cypher statement in listing 8.11
    to evaluate all 22 segments. Additionally, you can play around with various `topK`
    and `similarityCutoff` values of the `gds.knn` algorithm to evaluate how its values
    affect user segmentation.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从列表8.11中的Cypher语句中移除`LIMIT`子句以评估所有22个细分。此外，您还可以尝试不同的`topK`和`similarityCutoff`值来评估`gds.knn`算法的值如何影响用户细分。
- en: Exercise 8.6
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 练习8.6
- en: In chapter 7, you used the PageRank algorithm to identify representatives of
    hashtag communities. Apply the same technique to identify segment representatives.
    First, use the graph filtering procedure to filter only users in the largest segment.
    After that, use the PageRank algorithm on the newly filtered projection to identify
    its representatives.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7章中，您使用了PageRank算法来识别标签社区的代表。应用相同的技巧来识别细分代表。首先，使用图过滤过程仅过滤出最大细分中的用户。之后，在新过滤的投影上使用PageRank算法来识别其代表。
- en: Congratulations! You have learned how to manually extract node features and
    complete a user segmentation process based on them with the help of the k-nearest
    neighbor graph and community detection algorithms.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已经学会了如何手动提取节点特征，并在k近邻图和社区检测算法的帮助下，基于这些特征完成用户细分过程。
- en: 8.4 Solutions to exercises
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 练习题解答
- en: The solution to exercise 8.1 is as follows.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 练习8.1的解答如下。
- en: Listing 8.12 Calculating the tweet count and retweet ratio for each user
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.12 计算每个用户的推文计数和转发率
- en: '[PRE11]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The solution to exercise 8.2 is as follows.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 练习8.2的解答如下。
- en: Listing 8.13 Calculating the average time to retweet per user and storing it
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.13 计算每个用户的平均转发时间和存储它
- en: '[PRE12]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The solution to exercise 8.3 is as follows.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 练习8.3的解答如下。
- en: Listing 8.14 Inspecting pairs of tweets with identical content that are not
    retweets
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.14 检查具有相同内容但不是转发的推文对
- en: '[PRE13]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The solution to exercise 8.4 is as follows.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 练习8.4的解答如下。
- en: Listing 8.15 Calculating the two-node graphlets and storing them as node properties
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.15 计算两个节点的图元并将它们存储为节点属性
- en: '[PRE14]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The solution to exercise 8.5 is as follows.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 练习8.5的解答如下。
- en: Listing 8.16 Calculating and storing the count of graphlet 5
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.16 计算并存储图元的计数5
- en: '[PRE15]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Listing 8.17 Calculating and storing the count of graphlet 8
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.17 计算并存储图元的计数8
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Listing 8.18 Calculating and storing the count of graphlet 11
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.18 计算和存储图元的计数11
- en: '[PRE17]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The solution to exercise 8.6 is as follows.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 练习8.6的解决方案如下。
- en: Listing 8.19 Filtering a subgraph that contains only the largest community of
    hashtags
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.19 过滤只包含最大标签社区子图
- en: '[PRE18]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Listing 8.20 Identifying representatives of the community with the PageRank
    algorithm
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.20 使用PageRank算法识别社区的代表
- en: '[PRE19]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: A node’s role in a network can be described with various local neighborhood
    and global features.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个节点在网络中的作用可以用各种局部邻域和全局特征来描述。
- en: Nodes with a similar role in the network don’t need to be close in the network.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网络中具有相似角色的节点不需要在网络中靠近。
- en: Motifs are used to characterize a network structure.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式被用来描述网络结构。
- en: Graphlets are used to encode a node’s direct neighborhood.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图元被用来编码一个节点的直接邻域。
- en: Betweenness centrality is used to identify nodes that act as bridges between
    various communities.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介数中心性用于识别在各个社区之间充当桥梁作用的节点。
- en: Closeness centrality identifies nodes that have the potential to share information
    to all the other nodes the fastest.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亲近中心性识别那些能够最快与其他所有节点共享信息的节点。
- en: A nearest neighbor graph is constructed by evaluating one of the vector similarity
    measures.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过评估其中一个向量相似度度量来构建最近邻图。
- en: The most common vector similarity measure used is cosine similarity.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最常用的向量相似度度量是余弦相似度。
- en: Cosine similarity is measured by the cosine of the angle between two vectors.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 余弦相似度是通过两个向量之间角度的余弦值来衡量的。
- en: Feature collinearity is a phenomenon that occurs when one feature highly correlates
    with another one.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特征共线性是一种现象，当某个特征与另一个特征高度相关时发生。
- en: The `gds.graph.writeNodeProperties` procedure can be used to store the node
    properties from the in-memory graph to the database.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`gds.graph.writeNodeProperties`过程将内存图中的节点属性存储到数据库中。
- en: The Louvain algorithm is very similar to label propagation but uses different
    underlying mathematics.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 洛文算法与标签传播非常相似，但使用不同的底层数学。
- en: The Louvain algorithm is not deterministic, meaning it can produce different
    results on each execution.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 洛文算法是非确定性的，这意味着它在每次执行中可能会产生不同的结果。
- en: PageRank can be used to find representative nodes in the inferred similarity
    network.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用PageRank算法来找到推断相似网络中的代表性节点。
