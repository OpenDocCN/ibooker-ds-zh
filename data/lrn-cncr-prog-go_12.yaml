- en: Part 3\. More concurrency
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：更多并发
- en: 'In this part of the book, we’ll look at more advanced concurrency topics: concurrency
    patterns, deadlocking, atomic variables, and futexes.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，我们将探讨更高级的并发主题：并发模式、死锁、原子变量和futexes。
- en: We’ll start by reviewing some common patterns used to break down problems into
    multiple parts that can be executed in parallel, and we’ll see how some patterns
    are better suited for different types of problems. We’ll also explore patterns
    such as loop-level parallelism, fork/join, worker pools, and pipelining, and we’ll
    discuss the properties of each.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先回顾一些常用的模式，这些模式可以将问题分解成多个部分，以便并行执行，我们还将看到哪些模式更适合不同类型的问题。我们还将探讨诸如循环级并行性、分支/合并、工作池和流水线等模式，并讨论每个模式的特点。
- en: Deadlocks can be a bad side effect of a concurrent system. Deadlocks happen
    when we have two or more threads of execution blocking each other in a circular
    fashion. We’ll examine some examples of deadlocks, with both memory sharing and
    message passing, and discuss various options for avoiding and preventing deadlocks
    in our programs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 死锁可能是并发系统的一个不良副作用。当两个或更多执行线程以循环方式相互阻塞时，就会发生死锁。我们将检查一些死锁的例子，包括内存共享和消息传递，并讨论在程序中避免和防止死锁的各种选项。
- en: 'In this book, we’ve looked at the implementations of various concurrency tools.
    Here we’ll look at the most primitive of our concurrent tools: the mutex. We’ll
    explore how the mutex uses an atomic operation internally, together with an operating
    system call, to achieve the best results in terms of performance.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们已经探讨了各种并发工具的实现。在这里，我们将查看我们并发工具中最原始的一个：互斥锁。我们将探讨互斥锁如何通过内部使用原子操作，结合操作系统调用，以实现性能方面的最佳结果。
