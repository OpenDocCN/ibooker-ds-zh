- en: Unit 3\. Building blocks
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元 3\. 构建块
- en: '*Programming is the breaking of one big impossible task into several very small
    possible tasks.*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*编程是将一个大的不可能的任务分解成几个非常小的可能任务的过程。*'
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Jazzwant*'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Jazzwant*'
- en: '*Functions* are the building blocks of computer programs. You can call on functions
    like `Printf` to format and display values. The pixels that end up on your screen
    are delivered by layers of functions in Go and your operating system.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数* 是计算机程序的基本构建块。你可以调用像 `Printf` 这样的函数来格式化和显示值。最终出现在你屏幕上的像素是由 Go 和你的操作系统中的一层层函数传递的。'
- en: You can write functions too. Functions help you organize your code, reuse functionality,
    and think about a problem in smaller pieces.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以编写函数。函数帮助你组织代码，重用功能，并以更小的部分来思考问题。
- en: Not only that, by learning how to declare functions and methods in Go, you’ll
    be equipped to explore the rich functionality provided by the standard library
    and documented at [golang.org/pkg](http://golang.org/pkg).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅如此，通过学习如何在 Go 中声明函数和方法，你将能够探索标准库提供的丰富功能，这些功能在 [golang.org/pkg](http://golang.org/pkg)
    上有文档记录。
- en: Lesson 12\. Functions
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 12 课\. 函数
- en: After reading [lesson 12](#ch12), you’ll be able to
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读 [第 12 课](#ch12) 之后，你将能够
- en: Identify the parts of a function declaration
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别函数声明的各个部分
- en: Write reusable functions to build up larger programs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写可重用函数来构建更大的程序
- en: This lesson begins by examining the standard library documentation for functions
    that were used in earlier lessons.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这节课首先检查了之前课程中使用过的函数的标准库文档。
- en: Once you’re familiar with the syntax for declaring functions, you’ll write functions
    for a weather station program. The Rover Environmental Monitoring Station (REMS)
    gathers weather data on the surface of Mars. You’ll write functions that could
    conceivably be part of a REMS program, such as converting temperatures.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你熟悉了声明函数的语法，你将为气象站程序编写函数。火星表面的罗弗环境监测站（REMS）收集气象数据。你将编写可能成为 REMS 程序一部分的函数，例如转换温度。
- en: '![](f0093-01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](f0093-01.jpg)'
- en: '|  |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: Make a sandwich. It sounds simple, but many steps are involved. Wash the lettuce,
    slice a tomato, and so on. Maybe you go so far as to harvest the grain, grind
    it into flour, and bake the bread, or maybe those functions are provided by a
    farmer and a baker.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 做一个三明治。听起来很简单，但涉及许多步骤。洗生菜，切番茄，等等。也许你会进一步收获谷物，磨成面粉，然后烤面包，或者也许这些功能是由农民和面包师傅提供的。
- en: Break down the process with a function for each step. Then later, if you need
    tomato slices for a pizza, that function can be reused.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用每个步骤的函数来分解过程。然后，如果你需要为披萨准备番茄片，这个函数就可以重用。
- en: What is something else from your daily life that you can break down into functions?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你日常生活中还有什么可以分解成函数的？
- en: '|  |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 12.1\. Function declarations
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1\. 函数声明
- en: The Go package documentation at [golang.org/pkg](http://golang.org/pkg) lists
    the functions that are declared in every package of the standard library. There
    are a lot of handy functions—more than this book can possibly cover.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Go 包文档在 [golang.org/pkg](http://golang.org/pkg) 上列出了标准库中每个包声明的函数。有很多实用的函数——这本书可能无法全部涵盖。
- en: To use these functions in your own project, you’ll often need to read the function
    declaration in the documentation to know how to call the function. After scrutinizing
    the declarations for `Intn`, `Unix`, `Atoi`, `Contains`, and `Println`, you’ll
    be able to apply your newfound knowledge when exploring other functions on your
    own, and when writing functions yourself.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要在自己的项目中使用这些函数，你通常需要阅读文档中的函数声明来了解如何调用该函数。在仔细审查了 `Intn`、`Unix`、`Atoi`、`Contains`
    和 `Println` 的声明后，你将能够在探索其他函数时应用你新获得的知识，并在自己编写函数时使用这些知识。
- en: You used the `Intn` function in [lesson 2](kindle_split_011.html#ch02) to generate
    pseudorandom numbers. Navigate to [golang.org/pkg](http://golang.org/pkg) and
    the `math/rand` package to find the `Intn` function. You can also use the search
    box to find `Intn`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 [第 2 课](kindle_split_011.html#ch02) 中使用了 `Intn` 函数来生成伪随机数。导航到 [golang.org/pkg](http://golang.org/pkg)
    和 `math/rand` 包以找到 `Intn` 函数。你还可以使用搜索框来查找 `Intn`。
- en: 'The declaration for `Intn` from the `rand` package looks like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`rand` 包中 `Intn` 的声明看起来是这样的：'
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As a refresher, here’s an example of using the `Intn` function:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 作为复习，这里有一个使用 `Intn` 函数的例子：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In [figure 12.1](#ch12fig01) the parts of the declaration are identified, as
    is the syntax to call the `Intn` function. The `func` keyword lets Go know this
    is a function declaration. Then comes the function name, `Intn`, which begins
    with a capital letter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 12.1](#ch12fig01) 中，声明部分被识别，以及调用 `Intn` 函数的语法。`func` 关键字让 Go 知道这是一个函数声明。然后是函数名
    `Intn`，它以大写字母开头。
- en: Figure 12.1\. The `Intn` function declaration and calling the `Intn` function
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.1\. `Intn` 函数声明和调用 `Intn` 函数
- en: '![](12fig01_alt.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](12fig01_alt.jpg)'
- en: In Go, the functions, variables, and other identifiers that begin with an uppercase
    letter are *exported* and become available to other packages. The `rand` package
    contains functions that begin with a lowercase letter too, but they’re not accessible
    from the `main` package.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，以大写字母开头的函数、变量和其他标识符是 *导出的*，并可供其他包使用。`rand` 包中也包含以小写字母开头的函数，但它们不能从 `main`
    包中访问。
- en: 'The `Intn` function accepts a single *parameter*, which is surrounded by parentheses.
    The parameter is a variable name followed by a type, consistent with variable
    declarations:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Intn` 函数接受一个 *参数*，该参数被括号包围。参数是一个变量名后跟一个类型，与变量声明一致：'
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When calling the `Intn` function, the integer 10 is passed as a single *argument*,
    also surrounded by parentheses. The argument corresponds to the single parameter
    `Intn` expects. If no argument is passed, or if the argument isn’t of type `int`,
    the Go compiler reports an error.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `Intn` 函数时，整数 10 被作为单个 *参数* 传递，同样被括号包围。该参数对应 `Intn` 所期望的单个参数。如果没有传递参数，或者参数不是
    `int` 类型，Go 编译器会报告错误。
- en: '|  |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Parameter and argument are terms from mathematics, with a subtle distinction.
    A function accepts parameters and is invoked with arguments, though at times people
    may use the terms interchangeably.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 参数和参数是数学术语，有细微的区别。一个函数接受参数并通过参数被调用，尽管有时人们可能互换使用这些术语。
- en: '|  |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The `Intn` function returns a single result, a pseudorandom integer of type
    `int`. The result is passed back to the caller, where it’s used to initialize
    the newly declared variable `num`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`Intn` 函数返回单个结果，一个 `int` 类型的伪随机整数。结果被返回给调用者，用于初始化新声明的变量 `num`。'
- en: 'The `Intn` function only accepts a single parameter, but functions can accept
    multiple parameters with a comma-separated list. If you recall from [lesson 7](kindle_split_017.html#ch07),
    the `Unix` function from the `time` package accepts two `int64` parameters, corresponding
    to the number of seconds and the number of nanoseconds since January 1, 1970\.
    The declaration from the documentation looks like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`Intn` 函数只接受一个参数，但函数可以通过逗号分隔的列表接受多个参数。如果你还记得 [第 7 课](kindle_split_017.html#ch07)，`time`
    包中的 `Unix` 函数接受两个 `int64` 参数，分别对应自 1970 年 1 月 1 日起的秒数和纳秒数。文档中的声明看起来像这样：'
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here’s the example of calling the `Unix` function with two arguments, corresponding
    to the `sec` and `nsec` parameters respectively:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用两个参数调用 `Unix` 函数的示例，这两个参数分别对应 `sec` 和 `nsec` 参数：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The result returned by `Unix` is of the type `Time`. Thanks to type inference,
    the code that calls `Unix` doesn’t need to specify the result type, which would
    be more verbose.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Unix` 函数返回的结果是 `Time` 类型。得益于类型推断，调用 `Unix` 的代码不需要指定结果类型，这会使代码更加简洁。'
- en: '|  |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '[Lesson 13](kindle_split_024.html#ch13) demonstrates how to declare new types
    like `time.Time` and `big.Int`.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 13 课](kindle_split_024.html#ch13) 展示了如何声明新类型，如 `time.Time` 和 `big.Int`。'
- en: '|  |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The `time` package declares and exports the `Time` type, which begins with an
    uppercase letter, just like the `Unix` function. By using capitalization to indicate
    what’s exported, it’s apparent that the `Time` type is accessible from other packages.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`time` 包声明并导出 `Time` 类型，该类型以大写字母开头，就像 `Unix` 函数一样。通过使用大写字母来指示导出内容，很明显 `Time`
    类型可以从其他包中访问。'
- en: 'The `Unix` function accepts two parameters of the same type, documented as
    follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`Unix` 函数接受两个相同类型的参数，如下所述：'
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'But when parameters are listed in a function declaration, you only need to
    specify the type when it changes, so it could have been written like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 但当在函数声明中列出参数时，只有当类型发生变化时才需要指定类型，因此它可以写成这样：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This shortcut is optional, but it’s used elsewhere, such as the `Contains`
    function in the `strings` package, which accepts two parameters of type `string`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个快捷方式是可选的，但它在其他地方也被使用，例如 `strings` 包中的 `Contains` 函数，它接受两个 `string` 类型的参数：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|  |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: The documentation at [golang.org/pkg](http://golang.org/pkg) sometimes has examples
    that can be expanded, and you’ll find additional examples at gobyexample.com.
    If you’re forging ahead on your own projects while learning Go, these examples
    can be invaluable.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [golang.org/pkg](http://golang.org/pkg) 的文档中，有时会有可以扩展的示例，你可以在 gobyexample.com
    找到更多示例。如果你在学习 Go 的同时在自己的项目中前进，这些示例可能非常有价值。
- en: '|  |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Many programming languages have functions that accept multiple parameters,
    but Go functions can also return multiple results. First shown in [lesson 10](kindle_split_020.html#ch10),
    the `Atoi` function converts a string to a number and returns two results, which
    are assigned to `countdown` and `err` here:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编程语言都有接受多个参数的函数，但 Go 函数也可以返回多个结果。首次在 [第10课](kindle_split_020.html#ch10) 中展示的
    `Atoi` 函数将字符串转换为数字，并返回两个结果，这里分别赋值给 `countdown` 和 `err`：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The documentation for the `strconv` package declares `Atoi` like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`strconv` 包的文档声明 `Atoi` 如下：'
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Two results are specified between parentheses, much like the parameter list,
    with a name followed by a type for each result. In function declarations you can
    also list the result types without names:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 两个结果被指定在括号中，就像参数列表一样，每个结果都有一个名称后跟一个类型。在函数声明中，你也可以列出没有名称的结果类型：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|  |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The `error` type is a built-in type for errors, which [lesson 28](kindle_split_042.html#ch28)
    covers in depth.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`error` 类型是一个用于错误的内置类型，[第28课](kindle_split_042.html#ch28) 将深入介绍。'
- en: '|  |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'A function you’ve been using since the beginning of this book is `Println`.
    It’s a rather unique function in that it can accept one parameter, or two, or
    more. It can also accept parameters of different types, including integers and
    strings:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你从本书开始就一直在使用的函数是 `Println`。它是一个非常独特的函数，因为它可以接受一个参数，也可以接受两个或更多参数。它还可以接受不同类型的参数，包括整数和字符串：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The function declaration in the documentation may look a bit strange, because
    it uses features we haven’t yet covered:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 文档中的函数声明可能看起来有点奇怪，因为它使用了我们尚未介绍的功能：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `Println` function accepts a single parameter, `a`, but you’ve already
    seen that passing it multiple arguments is possible. More specifically, you can
    pass the `Println` function a variable number of arguments, a feature indicated
    by the ellipsis (`...`). There’s a special term for this: `Println` is said to
    be a *variadic* function. The parameter `a` is a collection of the arguments passed
    to the function. We’ll return to variadic functions in [lesson 18](kindle_split_030.html#ch18).'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`Println` 函数接受一个参数 `a`，但你已经看到传递多个参数是可能的。更具体地说，你可以向 `Println` 函数传递可变数量的参数，这由省略号
    (`...`) 表示。有一个专门的术语来描述这一点：`Println` 被称为 *可变参数* 函数。参数 `a` 是传递给函数的参数集合。我们将在 [第18课](kindle_split_030.html#ch18)
    中回到可变参数函数。'
- en: The type of the `a` parameter is `interface{}`, known as the *empty interface*
    type. We won’t be covering interfaces until [lesson 24](kindle_split_037.html#ch24),
    but now you know that this special type is what enables `Println` to accept an
    `int`, `float64`, `string`, `time.Time`, or any other type without the Go compiler
    reporting an error.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`a` 参数的类型是 `interface{}`，被称为 *空接口* 类型。我们将在 [第24课](kindle_split_037.html#ch24)
    中介绍接口，但现在你知道这种特殊类型是使 `Println` 能够接受 `int`、`float64`、`string`、`time.Time` 或任何其他类型而不会在
    Go 编译器中报告错误的原因。'
- en: The combination of variadic functions and the empty interface, written together
    as `...interface{}`, means you can pass `Println` any number of arguments of any
    type. It does a good job of displaying whatever you throw at it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 可变参数函数和空接口的组合，写作 `...interface{}`，意味着你可以传递任意数量和类型的参数给 `Println`。它能够很好地显示你向它投掷的任何内容。
- en: '|  |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: So far we’ve been ignoring the two results that `Println` returns, even though
    ignoring errors is considered a bad practice. Good error-handling practices are
    covered in [lesson 28](kindle_split_042.html#ch28).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在忽略 `Println` 返回的两个结果，尽管忽略错误被认为是一种不良实践。良好的错误处理实践将在 [第28课](kindle_split_042.html#ch28)
    中介绍。
- en: '|  |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 12.1**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 12.1**'
- en: '**[1](#ch12qa2q0a1)**'
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch12qa2q0a1)**'
- en: ''
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do you call a function with arguments or parameters?
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你是用参数还是参数调用函数？
- en: '**[2](#ch12qa2q0a2)**'
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch12qa2q0a2)**'
- en: ''
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does a function accept arguments or parameters?
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 函数接受参数还是参数？
- en: '**[3](#ch12qa2q0a3)**'
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](#ch12qa2q0a3)**'
- en: ''
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How does a function with an uppercase first letter (`Contains`) differ from
    one with a lower-case first letter (`contains`)?
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以大写字母开头的函数（`Contains`）与以小写字母开头的函数（`contains`）有何不同？
- en: '**[4](#ch12qa2q0a4)**'
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[4](#ch12qa2q0a4)**'
- en: ''
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What does the ellipsis (`...`) in a function declaration indicate?
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 函数声明中的省略号（`...`）表示什么？
- en: '|  |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 12.1 answer**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 12.1 答案**'
- en: '**[1](#ch12qa1q1)**'
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch12qa1q1)**'
- en: ''
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Arguments
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参数
- en: '**[2](#ch12qa1q2)**'
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch12qa1q2)**'
- en: ''
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Parameters
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参数
- en: '**[3](#ch12qa1q3)**'
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](#ch12qa1q3)**'
- en: ''
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Lowercase indicates functions that can only be used by the package they are
    declared in, whereas capitalized functions are exported for use anywhere.
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 小写表示只能在其声明的包中使用的函数，而大写函数是导出的，可以在任何地方使用。
- en: '**[4](#ch12qa1q4)**'
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[4](#ch12qa1q4)**'
- en: ''
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The function is variadic. You can pass it a variable number of arguments.
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 该函数是可变参数的。你可以传递给它任意数量的参数。
- en: '|  |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 12.2\. Writing a function
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2\. 编写函数
- en: So far, the code in this book has been placed in the `main` function. When approaching
    larger applications, such as an environmental monitoring program, splitting the
    problem into smaller pieces becomes valuable. Organizing your code into functions
    makes it easier to understand, reuse, and maintain.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这本书中的代码都放在了 `main` 函数中。当处理更大的应用程序，如环境监测程序时，将问题分解成更小的部分变得很有价值。将代码组织成函数可以使代码更容易理解、重用和维护。
- en: Temperature data from sensor readouts should be reported in units that are meaningful
    to Earthlings. The sensors provide data on the Kelvin scale, where 0° K is absolute
    zero, the lowest temperature possible. A function in the next listing converts
    temperatures to Celsius. Once the conversion function is written, it can be reused
    whenever that temperature conversion is needed.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从传感器读数中读取的温度数据应以对地球人有意义的方式报告。传感器提供开尔文尺度的数据，其中0° K是绝对零度，即可能达到的最低温度。下一段代码中的函数将温度转换为摄氏度。一旦编写了转换函数，就可以在需要温度转换时重复使用它。
- en: 'Listing 12.1\. Kelvin to Celsius: kelvin.go'
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.1\. 开氏到摄氏度：kelvin.go
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1* Declares a function that accepts one parameter and returns one result**'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明一个接受一个参数并返回一个结果的函数**'
- en: '***2* Calls the function passing kelvin as the first argument**'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将kelvin作为第一个参数传递给函数**'
- en: '***3* Prints 294° K is 20.850000000000023° C**'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 打印294° K等于20.850000000000023° C**'
- en: The `kelvinToCelsius` function in [listing 12.1](#ch12ex01) accepts one parameter
    with the name `k` and the type `float64`. Following Go conventions, the comment
    for `kelvinToCelsius` begins with the function’s name, followed by what it does.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 12.1](#ch12ex01) 中的 `kelvinToCelsius` 函数接受一个名为 `k` 的参数，类型为 `float64`。遵循
    Go 的约定，`kelvinToCelsius` 的注释从函数名开始，然后是它所做的工作。'
- en: This function returns one value of type `float64`. The result of the calculation
    is delivered back to the caller with the `return` keyword, which is then used
    to initialize a new `celsius` variable in the `main` function.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回一个 `float64` 类型的值。计算结果通过 `return` 关键字返回给调用者，然后在 `main` 函数中用此值初始化一个新的 `celsius`
    变量。
- en: Notice that functions within the same package are invoked without specifying
    a package name.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，同一包内的函数调用不需要指定包名。
- en: '|  |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Isolation can be a good thing**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**隔离可能是一件好事**'
- en: The `kelvinToCelsius` function in [listing 12.1](#ch12ex01) is isolated from
    other functions. Its only input is the parameter it accepts, and its only output
    is the result it returns. It makes no modifications to external state. Such functions
    are *side-effect-free* and are the the easiest to understand, test, and reuse.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 12.1](#ch12ex01) 中的 `kelvinToCelsius` 函数与其他函数隔离。它的唯一输入是它接受的参数，唯一输出是它返回的结果。它不对外部状态进行任何修改。这样的函数是*无副作用的*，也是最容易理解、测试和重用的。'
- en: The `kelvinToCelsius` function does modify the variable `k`, but `k` and `kelvin`
    are completely independent variables, so assigning a new value to `k` inside the
    function has no impact on the `kelvin` variable in `main`. This behavior is called
    *pass by value*, because the `k` parameter is initialized with the value of the
    `kelvin` argument. Pass by value facilitates the boundary between functions, helping
    to isolate one function from another.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`kelvinToCelsius` 函数确实修改了变量 `k`，但 `k` 和 `kelvin` 是完全独立的变量，因此在函数内部为 `k` 赋新值不会影响
    `main` 中的 `kelvin` 变量。这种行为被称为*按值传递*，因为 `k` 参数是用 `kelvin` 参数的值初始化的。按值传递有助于函数之间的边界，有助于隔离一个函数与另一个函数。'
- en: We’ve given the variables different names, but pass by value applies even if
    arguments and parameters have the same names.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给变量取了不同的名字，但即使参数和参数有相同的名字，按值传递也适用。
- en: Additionally, the variable named `k` in `kelvinToCelsius` is completely independent
    from any variable named `k` in other functions, thanks to variable scope. Scope
    is covered in [lesson 4](kindle_split_013.html#ch04), but to reiterate, the parameters
    in a function declaration and the variables declared within a function body have
    *function scope*. Variables declared in different functions are completely independent,
    even if they have the same name.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`kelvinToCelsius` 中的变量 `k` 与其他函数中名为 `k` 的任何变量完全独立，这要归功于变量作用域。作用域在[第 4 课](kindle_split_013.html#ch04)中有所介绍，但为了重申，函数声明中的参数和函数体内声明的变量具有*函数作用域*。在不同函数中声明的变量完全独立，即使它们具有相同的名称。
- en: '|  |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 12.2**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 12.2**'
- en: '**[Q1:](#ch12qa4q0a1)**'
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch12qa4q0a1)**'
- en: ''
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are some advantages of splitting code into functions?
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将代码拆分为函数有哪些优点？
- en: '|  |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 12.2 answer**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 12.2 答案**'
- en: '**[1:](#ch12qa3q1)**'
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch12qa3q1)**'
- en: ''
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Functions are reusable, they provide isolation for variables through function
    scope, and they provide a name for the action they perform which makes code easier
    to follow and understand.
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 函数是可重用的，它们通过函数作用域为变量提供隔离，并为它们执行的操作提供名称，这使得代码更容易跟踪和理解。
- en: '|  |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Functions are declared with a name, a list of parameters, and a list of results.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数通过名称、参数列表和结果列表进行声明。
- en: Capitalized function names and types are made available to other packages.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大写函数名称和类型可供其他包使用。
- en: Each parameter or result is a name followed by a type, though types may be elided
    when multiple named parameters or results have the same type. Results can also
    be listed as types without names.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个参数或结果都是一个名称后跟一个类型，尽管当多个命名参数或结果具有相同类型时，类型可以省略。结果也可以无名称地列出为类型。
- en: Function calls are prefixed with the name of the package where the function
    is declared, unless the function is declared in the same package it’s called from.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数调用以声明函数的包的名称为前缀，除非函数是在调用它的同一包中声明的。
- en: Functions are called with arguments that correspond to the parameters they accept.
    Results are returned to the caller with the `return` keyword.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数通过与它们接受的参数对应的参数进行调用。结果通过 `return` 关键字返回给调用者。
- en: Let’s see if you got this...
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否掌握了这一点...
- en: 'Experiment: functions.go'
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实验：functions.go
- en: 'Use the Go Playground at play.golang.org to type in [listing 12.1](#ch12ex01)
    and declare additional temperature conversion functions:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 play.golang.org 上的 Go Playground 输入[列表 12.1](#ch12ex01)并声明额外的温度转换函数：
- en: Reuse the `kelvinToCelsius` function to convert 233° K to Celsius.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新使用 `kelvinToCelsius` 函数将 233° K 转换为摄氏度。
- en: 'Write and use a `celsiusToFahrenheit` temperature conversion function. Hint:
    the formula for converting to Fahrenheit is: (c * 9.0 / 5.0) + 32.0.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写并使用一个 `celsiusToFahrenheit` 温度转换函数。提示：转换为华氏度的公式是：(c * 9.0 / 5.0) + 32.0。
- en: Write a `kelvinToFahrenheit` function and verify that it converts 0° K to approximately
    –459.67° F.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个 `kelvinToFahrenheit` 函数并验证它将 0° K 转换为大约 -459.67° F。
- en: Did you use `kelvinToCelsius` and `celsiusToFahrenheit` in your new function
    or write an independent function with a new formula? Both approaches are perfectly
    valid.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你在你的新函数中使用了 `kelvinToCelsius` 和 `celsiusToFahrenheit`，还是编写了一个具有新公式的独立函数？两种方法都是完全有效的。
- en: Lesson 13\. Methods
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 13 课\. 方法
- en: After reading [lesson 13](#ch13), you’ll be able to
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读[第 13 课](#ch13)之后，你将能够
- en: Declare new types
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明新类型
- en: Rewrite functions as methods
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数重写为方法
- en: '*Methods* are like functions that enhance types with additional behavior. Before
    you can declare a method, you need to declare a new type. This lesson takes the
    `kelvinToCelsius` function from [lesson 12](kindle_split_023.html#ch12) and transforms
    it into a type with methods.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*方法*类似于增强类型以提供额外行为的函数。在你可以声明一个方法之前，你需要声明一个新的类型。本课将 [第 12 课](kindle_split_023.html#ch12)
    中的 `kelvinToCelsius` 函数转换为一个具有方法的类型。'
- en: At first it may look like methods are just a different syntax for doing what
    functions already do, and you would be right. Methods provide another way to organize
    code, an arguably nicer way for the examples in this lesson. Later lessons, those
    in [unit 5](kindle_split_033.html#part06) in particular, demonstrate how methods
    can be combined with other language features to bring new capabilities.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，它可能看起来像方法只是函数已做事情的另一种语法，你会是对的。方法提供了另一种组织代码的方式，对于本课的例子来说，这是一种更令人满意的方式。后面的课程，特别是[第
    5 单元](kindle_split_033.html#part06)的课程，展示了方法如何与其他语言特性结合以带来新的功能。
- en: '|  |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: When you type numbers on a calculator versus a typewriter, the expected behavior
    is quite different. Go has built-in functionality to operate on numbers and text
    (`+`) in unique ways, as demonstrated in [lesson 10](kindle_split_020.html#ch10).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在计算器上输入数字与在打字机上输入数字时，预期的行为相当不同。Go 有内置的功能以独特的方式操作数字和文本（`+`），如第 10 节所示。
- en: What if you want to represent a new type of thing and bundle behaviors with
    it? A `float64` is too generic to adequately represent a thermometer, and a dog’s
    `bark()` is entirely different from the bark of a tree. Functions have a place,
    but types and methods provide another useful way to organize code and represent
    the world around you.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想表示一种新的类型并将行为与之捆绑在一起呢？`float64` 类型过于通用，不足以充分表示温度计，而狗的 `bark()` 声音与树的 bark
    声音完全不同。函数有它的位置，但类型和方法提供了另一种组织代码和表示周围世界的有用方式。
- en: Before you start on this lesson, look around and consider the types around you
    and the behaviors they each have.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本节课之前，四处看看并考虑你周围的类型及其各自的行为。
- en: '|  |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 13.1\. Declaring new types
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1. 声明新类型
- en: Go declares a number of types, many of which are covered in [unit 2](kindle_split_015.html#part03).
    Sometimes those types don’t adequately describe the kind of values you want to
    hold.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Go 声明了许多类型，其中许多在第 2 单元中介绍。有时这些类型不足以描述你想要持有的值的类型。
- en: A temperature isn’t a `float64`, though that may be its underlying representation.
    Temperature is a measurement in Celsius, Fahrenheit, or Kelvin. Declaring new
    types not only makes code clearer, it can help prevent errors.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 温度不是一个 `float64`，尽管它可能有其底层表示。温度是以摄氏度、华氏度或开尔文为单位的测量值。声明新类型不仅使代码更清晰，还可以帮助防止错误。
- en: The `type` keyword declares a new type with a name and an underlying type, as
    shown in the following listing.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`type` 关键字用于声明一个带有名称和底层类型的新类型，如下所示。'
- en: 'Listing 13.1\. A Celsius type: celsius.go'
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.1. `Celsius` 类型：celsius.go
- en: '[PRE14]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1* The underlying type is float64.**'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 底层类型是 float64。**'
- en: '***2* Prints 20**'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 20**'
- en: The numeric literal 20, like all numeric literals, is an *untyped* constant.
    It can be assigned to a variable of type `int`, `float64`, or any other numeric
    type. The `celsius` type is a new numeric type with the same behavior and representation
    as a `float64`, so the assignment in the previous listing works.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 数值字面量 20，像所有数值字面量一样，是一个 *未指定类型的* 常量。它可以赋值给 `int`、`float64` 或任何其他数值类型的变量。`celsius`
    类型是一个新的数值类型，其行为和表示与 `float64` 相同，因此前述列表中的赋值是有效的。
- en: You can also add values to temperature and generally use it as though it were
    a `float64`, as shown in the next listing.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以向温度添加值，并且通常可以像使用 `float64` 一样使用它，如下所示。
- en: 'Listing 13.2\. A celsius type behaves like a `float64`: celsius-addition.go'
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.2. `celsius` 类型的行为类似于 `float64`：celsius-addition.go
- en: '[PRE15]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `celsius` type is a unique type, not a type alias like those mentioned
    in [lesson 9](kindle_split_019.html#ch09). If you try to use it with a `float64`,
    you’ll get a mismatched types error:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`celsius` 类型是一个独特的类型，而不是像第 9 节中提到的那些类型别名。如果你尝试用 `float64` 使用它，你会得到一个类型不匹配的错误：'
- en: '[PRE16]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1* Invalid operation: mismatched types**'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 无效操作：类型不匹配**'
- en: 'To add `warmUp`, it must first be converted to the `celsius` type. This version
    works:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加 `warmUp`，必须首先将其转换为 `celsius` 类型。这个版本是有效的：
- en: '[PRE17]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Being able to define your own types can be incredibly useful for improving both
    readability and reliability. The following listing demonstrates that `celsius`
    and `fahrenheit` types can’t accidentally be compared or combined.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 能够定义自己的类型可以非常有助于提高代码的可读性和可靠性。以下列表演示了 `celsius` 和 `fahrenheit` 类型不能意外地比较或组合。
- en: Listing 13.3\. Types can’t be mixed
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.3. 类型不能混合
- en: '[PRE18]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* Invalid operation: mismatched types celsius and fahrenheit**'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 无效操作：celsius 和 fahrenheit 类型不匹配**'
- en: '|  |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 13.1**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 13.1**'
- en: '**[Q1:](#ch13qa2q0a1)**'
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch13qa2q0a1)**'
- en: ''
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are some advantages of declaring new types, such as `celsius` and `fahrenheit`?
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 声明新类型，如 `celsius` 和 `fahrenheit`，有哪些优点？
- en: '|  |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 13.1 answer**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 13.1 答案**'
- en: '**[1:](#ch13qa1q1)**'
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch13qa1q1)**'
- en: ''
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The new type can better describe the value it contains, such as `celsius` instead
    of `float64`. Having unique types helps avoid silly mistakes, like adding a Fahrenheit
    value to a Celsius value.
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 新类型可以更好地描述它包含的值，例如 `celsius` 而不是 `float64`。拥有独特的类型有助于避免愚蠢的错误，比如将华氏度值添加到摄氏度值上。
- en: '|  |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 13.2\. Bring your own types
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2. 带上你的类型
- en: The previous section declared new `celsius` and `fahrenheit` types, bringing
    the domain of temperatures to the code, while de-emphasizing the underlying storage
    representation. Whether a temperature is represented as a `float64` or `float32`
    says little about the value a variable contains, whereas types like `celsius`,
    `fahrenheit`, and `kelvin` convey their purpose.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节声明了新的 `celsius` 和 `fahrenheit` 类型，将温度域引入代码中，同时弱化了底层存储表示。温度是表示为 `float64`
    还是 `float32` 对变量包含的值几乎没有什么影响，而像 `celsius`、`fahrenheit` 和 `kelvin` 这样的类型则传达了它们的目的。
- en: Once you declare a type, you can use it everywhere you would use a predeclared
    Go type (`int`, `float64`, `string`, and so on), including function parameters
    and results, as shown in the following listing.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦声明了一个类型，您就可以在任何可以使用预定义 Go 类型（`int`、`float64`、`string` 等等）的地方使用它，包括函数参数和结果，如下面的列表所示。
- en: 'Listing 13.4\. Functions with custom types: temperature-types.go'
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.4\. 带有自定义类型的函数：temperature-types.go
- en: '[PRE19]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* A type conversion is necessary.**'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 需要进行类型转换。**'
- en: '***2* The argument must be of type kelvin.**'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 参数必须是 kelvin 类型。**'
- en: '***3* Prints 294° K is 20.850000000000023° C**'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 打印 294° K 是 20.850000000000023° C**'
- en: The `kelvinToCelsius` function will only accept an argument of the `kelvin`
    type, which can prevent silly mistakes. It won’t accept an argument of the wrong
    type, such as `fahrenheit`, `kilometers`, or even `float64`. Go is a pragmatic
    language, so it’s still possible to pass a literal value or untyped constant.
    Rather than write `kelvinToCelsius(kelvin(294))`, you can write `kelvinToCelsius(294)`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`kelvinToCelsius` 函数只接受 `kelvin` 类型的参数，这可以防止愚蠢的错误。它不会接受错误类型的参数，例如 `fahrenheit`、`kilometers`
    或甚至 `float64`。Go 语言是一种务实的语言，因此仍然可以传递字面值或无类型的常量。与其写 `kelvinToCelsius(kelvin(294))`，您可以直接写
    `kelvinToCelsius(294)`。'
- en: The result returned from `kelvinToCelsius` is of type `celsius`, not `kelvin`,
    so the type must be converted to `celsius` before it can be returned.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `kelvinToCelsius` 返回的结果是 `celsius` 类型，而不是 `kelvin` 类型，因此必须在返回之前将类型转换为 `celsius`。
- en: '|  |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 13.2**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 13.2**'
- en: '**[Q1:](#ch13qa4q0a1)**'
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch13qa4q0a1)**'
- en: ''
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a `celsiusToKelvin` function that uses the `celsius` and `kelvin` types
    defined in [listing 13.4](#ch13ex04). Use it to convert 127° C, the surface temperate
    of the sunlit moon, to degrees Kelvin.
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写一个 `celsiusToKelvin` 函数，该函数使用 [列表 13.4](#ch13ex04) 中定义的 `celsius` 和 `kelvin`
    类型。使用它将 127° C（太阳照射的月球表面温度）转换为开尔文度。
- en: '|  |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 13.2 answer**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 13.2 答案**'
- en: '**[1:](#ch13qa3q1)**'
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch13qa3q1)**'
- en: ''
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ''
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '***1* Prints 127° C is 400.15° K**'
  id: totrans-221
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 127° C 是 400.15° K**'
- en: '|  |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 13.3\. Adding behavior to types with methods
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3\. 使用方法向类型添加行为
- en: '*Though this be madness, yet there is method in ‘t.*'
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*纵然这是疯狂，但其中自有方法。*'
- en: ''
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Shakespeare, *Hamlet**'
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*莎士比亚，*《哈姆雷特》*'
- en: For decades classical object-oriented languages have taught that methods belong
    with classes. Go is different. There are no classes or even objects, really, yet
    Go has methods. That may seem odd, maybe even a bit crazy, but methods in Go are
    actually more flexible than in languages of the past.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 几十年来，传统的面向对象语言都教导方法属于类。Go 语言则不同。实际上，Go 语言中没有类，甚至没有对象，但 Go 语言还是有方法的。这听起来可能有些奇怪，甚至有些疯狂，但
    Go 语言中的方法实际上比过去任何语言都更加灵活。
- en: Functions like `kelvinToCelsius`, `celsiusToFahrenheit`, `fahrenheitToCelsius`,
    and `celsiusToKelvin` get the job done, but we can do better. Declaring a few
    methods in their place will make temperature-conversion code nice and concise.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `kelvinToCelsius`、`celsiusToFahrenheit`、`fahrenheitToCelsius` 和 `celsiusToKelvin`
    的函数可以完成工作，但我们可以做得更好。在它们的位置声明几个方法将使温度转换代码更加简洁。
- en: '![](f0105-01.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](f0105-01.jpg)'
- en: 'You can associate methods with any type declared in the same package, but not
    with predeclared types (`int`, `float64`, and so forth). You’ve already seen how
    to declare a type:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将方法与同一包中声明的任何类型关联，但不能与预定义类型（`int`、`float64` 等等）关联。您已经看到了如何声明一个类型：
- en: '[PRE21]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `kelvin` type has the same behavior as its underlying type, a `float64`.
    You can add, multiply, and perform other operations on `kelvin` values, just like
    floating-point numbers. Declaring a method to convert `kelvin` to `celsius` is
    as easy as declaring a function. They both begin with the `func` keyword, and
    the function body is identical to the method body:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`kelvin` 类型与其底层类型 `float64` 具有相同的行为。您可以对 `kelvin` 值进行加法、乘法和其他操作，就像浮点数一样。声明将
    `kelvin` 转换为 `celsius` 的方法就像声明一个函数一样简单。它们都以 `func` 关键字开始，函数体与方法体相同：'
- en: '[PRE22]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***1* kelvinToCelsius function**'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* kelvinToCelsius 函数**'
- en: '***2* celsius method on the kelvin type**'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 关于 kelvin 类型的摄氏度方法**'
- en: The `celsius` method doesn’t accept any parameters, but it has something like
    a parameter before the name. It’s called a *receiver*, as shown in [figure 13.1](#ch13fig01).
    Methods and functions can both accept multiple parameters, but methods must have
    exactly one receiver. Inside the `celsius` method body, the receiver acts like
    any other parameter.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`celsius`方法不接受任何参数，但它有一个类似参数的东西在名称之前。它被称为*接收器*，如图[图13.1](#ch13fig01)所示。方法和函数都可以接受多个参数，但方法必须恰好有一个接收器。在`celsius`方法体内，接收器表现得就像任何其他参数一样。'
- en: Figure 13.1\. A method declaration
  id: totrans-237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.1\. 方法声明
- en: '![](13fig01_alt.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](13fig01_alt.jpg)'
- en: 'The syntax to use a method is different than calling a function:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法的语法与调用函数不同：
- en: '[PRE23]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1* Calls the kelvinToCelsius function**'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 调用`kelvinToCelsius`函数**'
- en: '***2* Calls the celsius method**'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 调用`celsius`方法**'
- en: Methods are called with *dot notation*, which looks like calling a function
    in another package. But in this case a variable of the correct type is followed
    by a dot and the method name.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 方法使用*点符号*调用，这看起来就像在另一个包中调用函数。但在这个情况下，正确的类型的变量后面跟着一个点和方法名称。
- en: 'Now that temperature conversion is a method on the `kelvin` type, a name like
    `kelvinToCelsius` is superfluous. A package can only have a single function with
    a given name, and it can’t be the same name as a type, so a `celsius` function
    that returns a `celsius` type isn’t possible. But each temperature type can provide
    a `celsius` method, so for example, the `fahrenheit` type can be enhanced as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在温度转换是`kelvin`类型的`celsius`方法，名称如`kelvinToCelsius`是多余的。一个包只能有一个具有给定名称的函数，并且它不能与类型名称相同，所以返回`celsius`类型的`celsius`函数是不可能的。但每个温度类型都可以提供一个`celsius`方法，所以例如，`fahrenheit`类型可以增强如下：
- en: '[PRE24]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This creates a nice symmetry, where every type of temperature can have a `celsius`
    method to convert to Celsius.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这创造了一种很好的对称性，每种温度类型都可以有一个`celsius`方法来转换为摄氏度。
- en: '|  |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 13.3**'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 13.3**'
- en: '**[Q1:](#ch13qa6q0a1)**'
  id: totrans-249
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch13qa6q0a1)**'
- en: ''
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Identify the receiver in this method declaration: `func (f fahrenheit) celsius()
    celsius`'
  id: totrans-251
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 识别这个方法声明中的接收器：`func (f fahrenheit) celsius() celsius`
- en: '|  |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 13.3 answer**'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 13.3 答案**'
- en: '**[1:](#ch13qa5q1)**'
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch13qa5q1)**'
- en: ''
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The receiver is `f` of type `fahrenheit`.
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 接收器是`f`类型的`fahrenheit`。
- en: '|  |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: Declaring your own types can help with readability and reliability.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明自己的类型可以帮助提高可读性和可靠性。
- en: Methods are like functions associated to a type by way of a receiver specified
    before the method name. Methods can accept multiple parameters and return multiple
    results, just like functions, but they must always have exactly one receiver.
    Within the method body, the receiver behaves just like any other parameter.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法就像通过在方法名称之前指定的接收器与类型相关联的函数。方法和函数一样可以接受多个参数并返回多个结果，但它们必须始终恰好有一个接收器。在方法体内，接收器表现得就像任何其他参数一样。
- en: The calling syntax for methods uses dot notation, with a variable of the appropriate
    type followed by a dot, the method name, and any arguments.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法调用的语法使用点符号，后面跟着适当的类型的变量，然后是点、方法名称和任何参数。
- en: Let’s see if you got this...
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否掌握了这个...
- en: 'Experiment: methods.go'
  id: totrans-264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实验：methods.go
- en: Write a program with `celsius`, `fahrenheit`, and `kelvin` types and methods
    to convert from any temperature type to any other temperature type.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，包含`celsius`、`fahrenheit`和`kelvin`类型和方法，以将任何温度类型转换为任何其他温度类型。
- en: Lesson 14\. First-class functions
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第14课\. 一等函数
- en: After reading [lesson 14](#ch14), you’ll be able to
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读了[第14课](#ch14)之后，你将能够
- en: Assign functions to variables
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数赋值给变量
- en: Pass functions to functions
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数传递给函数
- en: Write functions that create functions
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写创建函数的函数
- en: In Go you can assign functions to variables, pass functions to functions, and
    even write functions that return functions. Functions are *first-class*—they work
    in all the places that integers, strings, and other types work.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，你可以将函数赋值给变量，将函数传递给函数，甚至编写返回函数的函数。函数是*一等*的——它们在整数、字符串和其他类型工作的所有地方都能工作。
- en: This lesson explores some potential uses of first-class functions as part of
    a theoretical Rover Environmental Monitoring Station (REMS) program that reads
    from (fake) temperature sensors.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 本课探讨了作为理论上的Rover环境监测站(REMS)程序一部分的一等函数的潜在用途，该程序从（假的）温度传感器读取数据。
- en: '|  |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: A recipe for tacos calls for salsa. You can either turn to page 93 of the cookbook
    to make homemade salsa or open a jar of salsa from the store.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 一个玉米卷食谱需要莎莎酱。你可以翻到食谱书的第93页制作自制的莎莎酱，或者打开商店里的一罐莎莎酱。
- en: First-class functions are like tacos that call for salsa. As code, the `makeTacos`
    function needs to call a function for the salsa, whether that be `makeSalsa` or
    `openSalsa`. The salsa functions could be used independently as well, but the
    tacos won’t be complete without salsa.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 首类函数就像需要莎莎酱的玉米卷。作为代码，`makeTacos` 函数需要调用莎莎酱的函数，无论是 `makeSalsa` 还是 `openSalsa`。莎莎酱函数也可以独立使用，但没有莎莎酱的玉米卷就不完整。
- en: Other than recipes and temperature sensors, what’s another example of a function
    that can be customized with a function?
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 除了食谱和温度传感器之外，还有哪些函数可以通过函数进行自定义的例子？
- en: '|  |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 14.1\. Assigning functions to variables
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1. 将函数分配给变量
- en: The weather station sensors provide an air temperature reading from 150–300°
    K. You have functions to convert Kelvin to other temperature units once you have
    the data, but unless you have a sensor attached to your computer (or Raspberry
    Pi), retrieving the data is a bit problematic.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 天气站传感器提供150–300° K的空气温度读数。一旦你有了数据，你可以使用函数将开尔文转换为其他温度单位，但除非你的计算机（或树莓派）上连接了传感器，否则获取数据会有点问题。
- en: For now you can use a fake sensor that returns a pseudorandom number, but then
    you need a way to use `realSensor` or `fakeSensor` interchangeably. The following
    listing does just that. By designing the program this way, different real sensors
    could also be plugged in, for example, to monitor both ground and air temperature.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 目前你可以使用一个返回伪随机数的假传感器，但随后你需要一种方法来交替使用 `realSensor` 或 `fakeSensor`。下面的代码示例正是如此。通过这种方式设计程序，还可以插入不同的真实传感器，例如，用于监测地面和空气温度。
- en: 'Listing 14.1\. Interchangeable sensor functions: sensor.go'
  id: totrans-282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 代码列表 14.1. 可互换的传感器函数：sensor.go
- en: '[PRE25]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '***1* To-do: implement a real sensor**'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 待办：实现一个真实传感器**'
- en: '***2* Assigns a function to a variable**'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将函数分配给变量**'
- en: In the previous listing, the `sensor` variable is assigned to the `fakeSensor`
    function itself, not the result of calling the function. Function and method calls
    always have parentheses, such as `fakeSensor()`, which isn’t the case here.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码示例中，`sensor` 变量被分配给了 `fakeSensor` 函数本身，而不是函数调用的结果。函数和方法调用总是带有括号，例如 `fakeSensor()`，但这里并非如此。
- en: Now calling `sensor()` will effectively call either `realSensor` or `fakeSensor`,
    depending on which function `sensor` is assigned to.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在调用 `sensor()` 将会根据 `sensor` 被分配到哪个函数而实际调用 `realSensor` 或 `fakeSensor`。
- en: 'The `sensor` variable is of type function, where the function accepts no parameters
    and returns a `kelvin` result. When not relying on type inference, the sensor
    variable would be declared like this:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`sensor` 变量是函数类型，其中该函数不接受任何参数并返回一个 `kelvin` 结果。当不依赖类型推断时，`sensor` 变量可以这样声明：'
- en: '[PRE26]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|  |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You can reassign `sensor` to `realSensor` in [listing 14.1](#ch14ex01) because
    it matches the *function signature* of `fakeSensor`. Both functions have the same
    number and type of parameters and return values.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[代码列表 14.1](#ch14ex01)中将 `sensor` 重新分配给 `realSensor`，因为它与 `fakeSensor` 的*函数签名*相匹配。这两个函数具有相同数量和类型的参数以及返回值。
- en: '|  |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 14.1**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 14.1**'
- en: '**[1](#ch14qa2q0a1)**'
  id: totrans-296
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch14qa2q0a1)**'
- en: ''
  id: totrans-297
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How can you distinguish between assigning a function to a variable versus assigning
    the result of calling the function?
  id: totrans-298
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你如何区分将函数分配给变量与将函数调用的结果分配给变量？
- en: '**[2](#ch14qa2q0a2)**'
  id: totrans-299
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch14qa2q0a2)**'
- en: ''
  id: totrans-300
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If there existed a `groundSensor` function that returned a `celsius` temperature,
    could it be assigned to the `sensor` in [listing 14.1](#ch14ex01)?
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果存在一个返回摄氏温度的 `groundSensor` 函数，它能否被分配到[代码列表 14.1](#ch14ex01)中的 `sensor`？
- en: '|  |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 14.1 answer**'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 14.1 答案**'
- en: '**[1](#ch14qa1q1)**'
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch14qa1q1)**'
- en: ''
  id: totrans-306
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Function and method calls always have parentheses (for example, `fn()`) whereas
    the function itself can be assigned by specifying a function name without parentheses.
  id: totrans-307
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 函数和方法调用总是带有括号（例如，`fn()`），而函数本身可以通过指定不带括号的函数名来分配。
- en: '**[2](#ch14qa1q2)**'
  id: totrans-308
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch14qa1q2)**'
- en: ''
  id: totrans-309
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'No. The parameters and return values must be of the same type to reassign the
    sensor variable. The Go compiler will report an error: cannot use groundSensor
    in assignment.'
  id: totrans-310
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不。参数和返回值必须具有相同的类型才能重新分配传感器变量。Go 编译器将报告错误：不能在赋值中使用 groundSensor。
- en: '|  |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 14.2\. Passing functions to other functions
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2. 将函数传递给其他函数
- en: Variables can refer to functions, and variables can be passed to functions,
    which means Go allows you to pass functions to other functions.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以引用函数，并且变量可以被传递给函数，这意味着 Go 允许你将函数传递给其他函数。
- en: To log temperature data every second, [listing 14.2](#ch14ex02) declares a new
    `measureTemperature` function that accepts a sensor function as a parameter. It
    calls the sensor function periodically, whether it’s a `fakeSensor` or a `realSensor`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 为了每秒记录温度数据，[列表14.2](#ch14ex02)声明了一个新的`measureTemperature`函数，它接受一个传感器函数作为参数。它定期调用传感器函数，无论是`fakeSensor`还是`realSensor`。
- en: The ability to pass functions around gives you a powerful way to split up your
    code. If not for first-class functions, you would likely end up with `measureRealTemperature`
    and `measureFakeTemperature` functions containing nearly identical code.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 能够传递函数的能力为你提供了一种强大的方式来分割你的代码。如果没有一等函数，你可能会得到包含几乎相同代码的`measureRealTemperature`和`measureFakeTemperature`函数。
- en: 'Listing 14.2\. A function as a parameter: function-parameter.go'
  id: totrans-316
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.2\. 函数作为参数：function-parameter.go
- en: '[PRE27]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1* measureTemperature accepts a function as the second parameter.**'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* measureTemperature接受一个函数作为第二个参数。**'
- en: '***2* Passes the name of a function to a function**'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将函数的名称传递给另一个函数**'
- en: 'The `measureTemperature` function accepts two parameters, with the second parameter
    being of type `func() kelvin`. This declaration looks like a variable declaration
    of the same type:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`measureTemperature`函数接受两个参数，第二个参数的类型为`func() kelvin`。这种声明看起来像同一类型的变量声明：'
- en: '[PRE28]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `main` function is able to pass the name of a function to `measureTemperature`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数能够将函数的名称传递给`measureTemperature`。'
- en: '|  |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 14.2**'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 14.2**'
- en: '**[Q1:](#ch14qa4q0a1)**'
  id: totrans-325
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch14qa4q0a1)**'
- en: ''
  id: totrans-326
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How is the ability to pass functions to other functions beneficial?
  id: totrans-327
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将函数传递给其他函数的能力有什么好处？
- en: '|  |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 14.2 answer**'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 14.2 答案**'
- en: '**[1:](#ch14qa3q1)**'
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch14qa3q1)**'
- en: ''
  id: totrans-332
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: First-class functions provide another way to divide and reuse code.
  id: totrans-333
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一等函数提供了另一种分割和重用代码的方法。
- en: '|  |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 14.3\. Declaring function types
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3\. 声明函数类型
- en: 'It’s possible to declare a new type for a function to condense and clarify
    the code that refers to it. You used the `kelvin` type to convey a unit of temperature
    rather than the underlying representation. The same can be done for functions
    that are being passed around:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 可以声明一个新的函数类型来压缩和澄清引用它的代码。你使用了`kelvin`类型来传达温度的单位，而不是底层表示。同样也可以为正在传递的函数做同样的事情：
- en: '[PRE29]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Rather than a function that accepts no parameters and returns a `kelvin` value,
    the code is about `sensor` functions. This type can be used to condense other
    code, so the declaration
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是接受无参数并返回`kelvin`值的函数，代码是关于`sensor`函数的。这种类型可以用来压缩其他代码，因此声明
- en: '[PRE30]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'can now be written like this:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以写成这样：
- en: '[PRE31]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this example, it may not seem like an improvement, as you now need to know
    what `sensor` is when looking at this line of code. But if `sensor` were used
    in several places, or if the function type had multiple parameters, using a type
    would significantly reduce the clutter.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，可能看起来没有改进，因为你现在需要知道当查看这一行代码时`sensor`是什么。但如果`sensor`在多个地方使用，或者如果函数类型有多个参数，使用类型将显著减少混乱。
- en: '|  |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 14.3**'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 14.3**'
- en: '**[Q1:](#ch14qa6q0a1)**'
  id: totrans-345
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch14qa6q0a1)**'
- en: ''
  id: totrans-346
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Rewrite the following function signature to use a function type:'
  id: totrans-347
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将以下函数签名重写为使用函数类型：
- en: ''
  id: totrans-348
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-349
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '|  |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 14.3 answer**'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 14.3 答案**'
- en: '**[1:](#ch14qa5q1)**'
  id: totrans-353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch14qa5q1)**'
- en: ''
  id: totrans-354
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-355
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '|  |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 14.4\. Closures and anonymous functions
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.4\. 闭包和匿名函数
- en: An *anonymous function*, also called a *function literal* in Go, is a function
    without a name. Unlike regular functions, function literals are *closures* because
    they keep references to variables in the surrounding scope.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*匿名函数*，在Go中也称为*函数字面量*，是一个没有名称的函数。与常规函数不同，函数字面量是*闭包*，因为它们保留了周围作用域中变量的引用。
- en: '![](f0113-01_alt.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![](f0113-01_alt.jpg)'
- en: You can assign an anonymous function to a variable and then use that variable
    like any other function, as shown in the following listing.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将匿名函数赋值给变量，然后像使用任何其他函数一样使用该变量，如下面的列表所示。
- en: 'Listing 14.3\. Anonymous function: masquerade.go'
  id: totrans-361
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.3\. 匿名函数：masquerade.go
- en: '[PRE34]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '***1* Assigns an anonymous function to a variable**'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将匿名函数赋值给变量**'
- en: '***2* Prints Dress up for the masquerade.**'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印为化装舞会打扮。**'
- en: The variable you declare can be in the scope of the package or within a function,
    as shown in the next listing.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 你声明的变量可以在包的作用域内，或者在函数内部，如下一个列表所示。
- en: 'Listing 14.4\. Anonymous function: funcvar.go'
  id: totrans-366
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.4\. 匿名函数：funcvar.go
- en: '[PRE35]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '***1* Assigns an anonymous function to a variable**'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将匿名函数赋值给变量**'
- en: '***2* Prints Go to the party.**'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印去参加派对。**'
- en: You can even declare and invoke an anonymous function in one step, as shown
    in the following listing.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以一步声明和调用匿名函数，如下面的列表所示。
- en: 'Listing 14.5\. Anonymous function: anonymous.go'
  id: totrans-371
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.5\. 匿名函数：anonymous.go
- en: '[PRE36]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '***1* Declares an anonymous function**'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明一个匿名函数**'
- en: '***2* Invokes the function**'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 调用函数**'
- en: Anonymous functions can come in handy whenever you need to create a function
    on the fly. One such circumstance is when returning a function from another function.
    Although it’s possible for a function to return an existing named function, declaring
    and returning a new anonymous function is much more useful.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数在需要即时创建函数时非常有用。这种情况之一是从另一个函数返回一个函数。虽然函数可以返回现有的命名函数，但声明和返回一个新的匿名函数更有用。
- en: In [listing 14.6](#ch14ex06) the `calibrate` function adjusts for errors in
    air temperature readings. Using first-class functions, `calibrate` accepts a fake
    or real sensor as a parameter and returns a replacement function. Whenever the
    new `sensor` function is called, the original function is invoked, and the reading
    is adjusted by an offset.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表14.6](#ch14ex06)中，`calibrate`函数调整了空气温度读数中的错误。使用一等函数，`calibrate`接受一个假传感器或真实传感器作为参数，并返回一个替换函数。每次调用新的`sensor`函数时，都会调用原始函数，并通过偏移量调整读数。
- en: 'Listing 14.6\. Sensor calibration: calibrate.go'
  id: totrans-377
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.6\. 传感器校准：calibrate.go
- en: '[PRE37]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '***1* To-do: implement a real sensor**'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 待办：实现真实传感器**'
- en: '***2* Declares and returns an anonymous function**'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 声明并返回一个匿名函数**'
- en: '***3* Prints 5**'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 打印5**'
- en: The anonymous function in the preceding listing makes use of closures. It references
    the `s` and `offset` variables that the `calibrate` function accepts as parameters.
    Even after the `calibrate` function returns, the variables captured by the closure
    survive, so calls to `sensor` still have access to those variables. The anonymous
    function *encloses* the variables in scope, which explains the term *closure*.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的列表中的匿名函数使用了闭包。它引用了`calibrate`函数接受的参数`s`和`offset`变量。即使在`calibrate`函数返回之后，闭包捕获的变量仍然存在，因此对`sensor`的调用仍然可以访问这些变量。匿名函数*封装*了作用域内的变量，这就是为什么称之为*闭包*的原因。
- en: 'Because a closure keeps a *reference* to surrounding variables rather than
    a copy of their values, changes to those variables are reflected in calls to the
    anonymous function:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 由于闭包保留了对周围变量的引用而不是它们值的副本，因此对这些变量的更改会反映在匿名函数的调用中：
- en: '[PRE38]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '***1* Prints 294**'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印294**'
- en: '***2* Prints 295**'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印295**'
- en: Keep this in mind, particularly when using closures inside `for` loops.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住这一点，尤其是在使用`for`循环中的闭包时。
- en: '|  |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 14.4**'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查14.4**'
- en: '**[1](#ch14qa8q0a1)**'
  id: totrans-390
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch14qa8q0a1)**'
- en: ''
  id: totrans-391
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What’s another name for an anonymous function in Go?
  id: totrans-392
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Go中匿名函数的另一个名称是什么？
- en: '**[2](#ch14qa8q0a2)**'
  id: totrans-393
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch14qa8q0a2)**'
- en: ''
  id: totrans-394
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do closures provide that regular functions don’t?
  id: totrans-395
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 闭包提供了哪些常规函数没有的功能？
- en: '|  |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 14.4 answer**'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 14.4 答案**'
- en: '**[1](#ch14qa7q1)**'
  id: totrans-399
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch14qa7q1)**'
- en: ''
  id: totrans-400
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An anonymous function is also called a function literal in Go.
  id: totrans-401
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在Go中，匿名函数也称为函数字面量。
- en: '**[2](#ch14qa7q2)**'
  id: totrans-402
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch14qa7q2)**'
- en: ''
  id: totrans-403
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Closures keep references to variables in the surrounding scope.
  id: totrans-404
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 闭包保留了对周围作用域中变量的引用。
- en: '|  |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: When functions are treated as first-class, they open up new possibilities for
    splitting up and reusing code.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当函数被视为一等公民时，它们为拆分和重用代码开辟了新的可能性。
- en: To create functions on the fly, use anonymous functions with closures.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要即时创建函数，请使用具有闭包的匿名函数。
- en: Let’s see if you got this...
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否明白了...
- en: 'Experiment: calibrate.go'
  id: totrans-410
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实验：calibrate.go
- en: 'Type [listing 14.6](#ch14ex06) into the Go Playground to see it in action:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 将[列表14.6](#ch14ex06)输入Go游乐场以查看其效果：
- en: Rather than passing 5 as an argument to `calibrate`, declare and pass a variable.
    Modify the variable and you’ll notice that calls to `sensor()` still result in
    5\. That’s because the `offset` parameter is a copy of the argument (pass by value).
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而不是将5作为参数传递给`calibrate`，声明并传递一个变量。修改该变量，你会注意到对`sensor()`的调用仍然结果是5。这是因为`offset`参数是参数的副本（按值传递）。
- en: Use `calibrate` with the `fakeSensor` function from [listing 14.2](#ch14ex02)
    to create a new `sensor` function. Call the new `sensor` function multiple times
    and notice that the original `fakeSensor` is still being called each time, resulting
    in random values.
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用来自[列表14.2](#ch14ex02)的`fakeSensor`函数与`calibrate`一起创建一个新的`sensor`函数。多次调用新的`sensor`函数，并注意每次仍然调用原始的`fakeSensor`，导致随机值。
- en: 'Lesson 15\. Capstone: Temperature tables'
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第15课：总结：温度表
- en: 'Write a program that displays temperature conversion tables. The tables should
    use equals signs (`=`) and pipes (`|`) to draw lines, with a header section:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个显示温度转换表的程序。这些表格应使用等号（`=`）和管道符（`|`）来绘制线条，并包含一个标题部分：
- en: '[PRE39]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The program should draw two tables. The first table has two columns, with °C
    in the first column and °F in the second column. Loop from –40° C through 100°
    C in steps of 5° using the temperature conversion methods from [lesson 13](kindle_split_024.html#ch13)
    to fill in both columns.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 程序应绘制两张表格。第一张表格有两列，第一列是摄氏度（°C），第二列是华氏度（°F）。从-40°C通过100°C以5°C的步长循环，使用第[13课](kindle_split_024.html#ch13)中的温度转换方法来填充两列。
- en: After completing one table, implement a second table with the columns reversed,
    converting from °F to °C.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 完成一张表格后，实现第二张表格，并将列反转，将华氏度（°F）转换为摄氏度（°C）。
- en: Drawing lines and padding values is code you can reuse for any data that needs
    to be displayed in a two-column table. Use functions to separate the table drawing
    code from the code that calculates the temperatures for each row.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制线条和填充值是您可以用于任何需要显示在两列表格中的数据的代码。使用函数将表格绘制代码与计算每行温度的代码分开。
- en: '![](f0117-01.jpg)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![](f0117-01.jpg)'
- en: Implement a `drawTable` function that takes a first-class function as a parameter
    and calls it to get data for each row drawn. Passing a different function to `drawTable`
    should result in different data being displayed.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个`drawTable`函数，该函数接受一个一等函数作为参数，并调用它来获取每行绘制的数据。向`drawTable`传递不同的函数应导致显示不同的数据。
