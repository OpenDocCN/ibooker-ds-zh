- en: Chapter 8\. Data Manipulation and Visualization in R
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章\. R中的数据操作和可视化
- en: 'American statistician Ronald Thisted once quipped: “Raw data, like raw potatoes,
    usually require cleaning before use.” Data manipulation takes time, and you’ve
    felt the pain if you’ve ever done the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 美国统计学家罗纳德·蒂斯特德曾经说过：“原始数据就像生土豆一样，通常在使用之前需要清理。” 数据操作需要时间，如果你曾经做过以下工作，你可能感受到了痛苦：
- en: Select, drop, or create calculated columns
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择、删除或创建计算列
- en: Sort or filter rows
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序或筛选行
- en: Group by and summarize categories
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按组汇总和总结类别
- en: Join multiple datasets by a common field
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过公共字段连接多个数据集
- en: Chances are, you’ve done all of these in Excel…*a lot*, and you’ve probably
    dug into celebrated features like `VLOOKUP()` and PivotTables to accomplish them.
    In this chapter, you’ll learn the R equivalents of these techniques, particularly
    with the help of `dplyr`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，你在Excel中已经*大量*进行了所有这些操作，并且可能深入研究了`VLOOKUP()`和透视表等著名功能来完成它们。在本章中，你将学习这些技术的R语言等效方法，特别是借助`dplyr`。
- en: 'Data manipulation often goes hand in hand with visualization: as mentioned,
    humans are remarkably adept at visually processing information, so it’s a great
    way to size up a dataset. You’ll learn how to visualize data using the gorgeous
    `ggplot2` package, which like `dplyr` is part of the `tidyverse`. This will put
    you on solid footing to explore and test relationships in data using R, which
    will be covered in [Chapter 9](ch09.html#r-capstone). Let’s get started by calling
    in the relevant packages. We’ll also be using the *star* dataset from the book’s
    [companion repository](https://oreil.ly/lmZb7) in this chapter, so we can import
    it now:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 数据操作通常与可视化紧密相关：正如前文所述，人类在视觉处理信息方面非常擅长，因此这是评估数据集的一种绝佳方式。您将学习如何使用美丽的`ggplot2`包可视化数据，该包与`dplyr`一样属于`tidyverse`。这将使您在使用R探索和测试数据关系时站稳脚跟，这将在[第9章](ch09.html#r-capstone)中介绍。让我们通过调用相关的包开始。在本章中，我们还将使用书籍的伴随存储库中的*star*数据集（https://oreil.ly/lmZb7）。
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Data Manipulation with dplyr
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用dplyr进行数据操作
- en: '`dplyr` is a popular package built to manipulate tabular data structures. Its
    many functions, or *verbs*, work similarly and can be easily used together. [Table 8-1](#dplyr-grammar)
    lists some common `dplyr` functions and their uses; this chapter covers each of
    these.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`dplyr`是一个用于操作表格数据结构的流行包。它的许多函数，或者*动词*，工作方式类似，并且可以轻松地一起使用。[表 8-1](#dplyr-grammar)列出了一些常见的`dplyr`函数及其用途；本章将详细介绍每一个。'
- en: Table 8-1\. Frequently used verbs of `dplyr`
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 表8-1\. `dplyr`经常使用的动词
- en: '| Function | What it does |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 功能 | 它的作用 |'
- en: '| --- | --- |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `select()` | Selects given columns |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `select()` | 选择给定列 |'
- en: '| `mutate()` | Creates new columns based on existing columns |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `mutate()` | 根据现有列创建新列 |'
- en: '| `rename()` | Renames given columns |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `rename()` | 对给定列进行重命名 |'
- en: '| `arrange()` | Reorders rows given criteria |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `arrange()` | 根据条件重新排序行 |'
- en: '| `filter()` | Selects rows given criteria |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `filter()` | 根据条件选择行 |'
- en: '| `group_by()` | Groups rows by given columns |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `group_by()` | 根据给定列分组行 |'
- en: '| `summarize()` | Aggregates values for each group |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `summarize()` | 汇总每个组的值 |'
- en: '| `left_join()` | Joins matching records from Table B to Table A; result is
    `NA` if no match found in Table B |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `left_join()` | 将表B中匹配的记录连接到表A；如果在表B中找不到匹配项，则结果为`NA` |'
- en: For the sake of brevity, I won’t cover all of the functions of `dplyr` or even
    all the ways to use the functions that we do cover. To learn more about the package,
    check out [*R for Data Science*](https://oreil.ly/KGoCV) by Hadley Wickham and
    Garrett Grolemund (O’Reilly). You can also access a helpful cheat sheet summarizing
    how the many functions of `dplyr` work together by navigating in RStudio to Help
    → Cheatsheets → Data Transformation with `dplyr`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我不会涵盖`dplyr`的所有函数，甚至不会涵盖我们所涵盖的函数的所有使用方式。要了解更多关于该包的信息，请查看Hadley Wickham和Garrett
    Grolemund（O’Reilly）的《*R for Data Science*》。您还可以通过在RStudio中导航到帮助→ 速查表→ 使用`dplyr`进行数据转换来访问一张有用的速查表，总结`dplyr`的许多函数是如何一起工作的。
- en: Column-Wise Operations
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列操作
- en: 'Selecting and dropping columns in Excel often requires hiding or deleting them.
    This can be difficult to audit or reproduce, because hidden columns are easily
    overlooked, and deleted columns aren’t easily recovered. The `select()` function
    can be used to choose given columns from a data frame in R. For `select()`, as
    with each of these functions, the first argument will be which data frame to work
    with. Additional arguments are then provided to manipulate the data in that data
    frame. For example, we can select *tmathssk*, *treadssk*, and *schidkin* from
    `star` like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Excel 中选择和删除列通常需要隐藏或删除它们。这可能会导致审计或重现困难，因为隐藏的列容易被忽略，而删除的列不容易恢复。`select()` 函数可用于从
    R 的数据框中选择指定列。对于 `select()`，以及每个这样的函数，第一个参数将是要处理的数据框。然后，提供其他参数来操作该数据框中的数据。例如，我们可以像这样从
    `star` 中选择 *tmathssk*、*treadssk* 和 *schidkin*：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can also use the `-` operator with `select()` to *drop* given columns:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在 `select()` 函数中使用 `-` 运算符来*删除*指定列：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A more elegant alternative here is to pass all unwanted columns into a vector,
    *then* drop it:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里的一个更加优雅的替代方法是将所有不需要的列传递给一个向量，*然后*将其删除：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Keep in mind that in the previous examples, we’ve just been calling functions:
    we didn’t actually assign the output to an object.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在前面的示例中，我们只是调用函数而没有实际将输出分配给对象。
- en: 'One more bit of shorthand for `select()` is to use the `:` operator to select
    everything between two columns, inclusive. This time, I will assign the results
    of selecting everything from *tmathssk* to *totexpk* back to `star`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `select()` 的另一个简写方法是使用 `:` 运算符选择两个列之间的所有内容，包括两列。这一次，我将选择从 *tmathssk* 到 *totexpk*
    的所有内容，再将结果分配回 `star`：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You’ve likely created calculated columns in Excel; `mutate()` will do the same
    in R. Let’s create a column *new_column* of combined reading and math scores.
    With `mutate()`, we’ll provide the name of the new column *first*, then an equal
    sign, and finally the calculation to use. We can refer to other columns as part
    of the formula:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能在 Excel 中创建了计算列；`mutate()` 将在 R 中执行相同的操作。让我们创建一个 *new_column* 列，其中包括阅读和数学分数的组合。使用
    `mutate()`，我们首先提供新列的名称 *first*，然后是等号，最后是要使用的计算公式。我们可以在公式中引用其他列：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`mutate()` makes it easy to derive relatively more complex calculated columns
    such as logarithmic transformations or lagged variables; check out the help documentation
    for more.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`mutate()` 函数使得派生比如对数变换或者滞后变量等相对复杂的计算列变得更加容易；详见帮助文档获取更多信息。'
- en: '*new_column* isn’t a particularly helpful name for total score. Fortunately,
    the `rename()` function does what it sounds like it would. We’ll specify what
    to name the new column in place of the old:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*new_column* 对于总分并不是特别有帮助的名称。幸运的是，`rename()` 函数就像其名字所暗示的那样工作。我们将指定如何命名新列，取代旧列：'
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Row-Wise Operations
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逐行操作
- en: Thus far we’ve been operating on *columns*. Now let’s focus on *rows*; specifically
    sorting and filtering. In Excel, we can sort by multiple columns with the Custom
    Sort menu. Say for example we wanted to sort this data frame by *classk*, then
    *treadssk*, both ascending. Our menu in Excel to do this would look like [Figure 8-1](#custom-sort-excel).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在*列*上操作。现在让我们专注于*行*；具体来说是排序和过滤。在 Excel 中，我们可以使用自定义排序菜单按多列排序。例如，如果我们希望按升序排序此数据框的
    *classk*，然后按 *treadssk* 排序。在 Excel 中进行此操作的菜单看起来会像 [图 8-1](#custom-sort-excel)。
- en: '![Custom sort menu in Excel](assets/aina_0801.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![Excel 中的自定义排序菜单](assets/aina_0801.png)'
- en: Figure 8-1\. The Custom Sort menu in Excel
  id: totrans-41
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-1\. Excel 中的自定义排序菜单
- en: 'We can replicate this in `dplyr` by using the `arrange()` function, including
    each column in the order in which we want the data frame sorted:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `arrange()` 函数在 `dplyr` 中复制这一过程，按照希望数据框排序的顺序包括每一列：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can pass the `desc()` function to a column if we’d like that column to be
    sorted descendingly.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望某列按降序排序，可以将 `desc()` 函数传递给该列。
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Excel tables include helpful drop-down menus to filter any column by given
    conditions. To filter a data frame in R, we’ll use the aptly named `filter()`
    function. Let’s filter `star` to keep only the records where `classk` is equal
    to `small.class`. Remember that because we are checking for equality rather than
    assigning an object, we’ll have to use `==` and not `=` here:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Excel 表包括有助于根据给定条件过滤任何列的下拉菜单。要在 R 中过滤数据框，我们将使用名为 `filter()` 的函数。让我们过滤 `star`，仅保留
    `classk` 等于 `small.class` 的记录。请记住，因为我们检查的是相等性而不是分配对象，所以在这里我们必须使用 `==` 而不是 `=`：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can see from the tibble output that our `filter()` operation *only* affected
    the number of rows, *not* the columns. Now we’ll find the records where `treadssk`
    is at least `500`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从 tibble 输出中我们可以看到，我们的 `filter()` 操作 *仅* 影响了行数，*而不是* 列数。现在让我们找出 `treadssk` 至少为
    `500` 的记录：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It’s possible to filter by multiple conditions using the `&` operator for “and”
    along with the `|` operator for “or.” Let’s combine our two criteria from before
    with `&`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `&` 运算符进行多条件过滤，“与” 和 `|` 运算符进行“或”运算。让我们将之前的两个条件用 `&` 结合起来：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Aggregating and Joining Data
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聚合和连接数据
- en: 'I like to call PivotTables “the WD-40 of Excel” because they allow us to get
    our data “spinning” in different directions for easy analysis. For example, let’s
    recreate the PivotTable in [Figure 8-2](#excel-pivot-table) showing the average
    math score by class size from the *star* dataset:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢称透视表为 Excel 的“WD-40”，因为它们允许我们将数据“旋转”到不同的方向，以便进行简单的分析。例如，让我们重新创建 [Figure 8-2](#excel-pivot-table)
    中显示的按班级规模的平均数学分数的透视表：
- en: '![How Excel PivotTables work](assets/aina_0802.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![Excel 透视表的工作原理](assets/aina_0802.png)'
- en: Figure 8-2\. How Excel PivotTables work
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 8-2\. Excel 透视表的工作原理
- en: 'As [Figure 8-2](#excel-pivot-table) calls out, there are two elements to this
    PivotTable. First, I aggregated our data by the variable *classk*. Then, I summarized
    it by taking an average of *tmathssk*. In R, these are discrete steps, using different
    `dplyr` functions. First, we’ll aggregate the data using `group_by()`. Our output
    includes a line, `# Groups: classk [3]`, indicating that `star_grouped` is split
    into three groups with the `classk` variable:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '如 [Figure 8-2](#excel-pivot-table) 所示，此透视表包括两个要素。首先，我按变量 *classk* 进行了数据聚合。然后，我通过计算
    *tmathssk* 的平均值进行了总结。在 R 中，这些是离散的步骤，使用了不同的 `dplyr` 函数。首先，我们将使用 `group_by()` 进行数据聚合。我们的输出包括一行
    `# Groups: classk [3]`，表示 `star_grouped` 根据 `classk` 变量分为三组：'
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We’ve *grouped* our data by one variable; now let’s *summarize* it by another
    with the `summarize()` function (`summarise()` also works). Here we’ll specify
    what to name the resulting column, and how to calculate it. [Table 8-2](#dplyr-agg-types)
    lists some common aggregation functions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过一个变量进行了 *分组*，现在让我们用另一个变量来 *汇总* 它，使用 `summarize()` 函数（`summarise()` 也可以）。在这里，我们将指定结果列的名称以及如何计算它。[Table 8-2](#dplyr-agg-types)
    列出了一些常见的聚合函数。
- en: Table 8-2\. Helpful aggregation functions for `dplyr`
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Table 8-2\. `dplyr` 的有用聚合函数
- en: '| Function | Aggregation type |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 聚合类型 |'
- en: '| --- | --- |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `sum()` | Sum |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `sum()` | 总和 |'
- en: '| `n()` | Count values |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `n()` | 计数 |'
- en: '| `mean()` | Average |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `mean()` | 平均值 |'
- en: '| `max()` | Highest value |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `max()` | 最高值 |'
- en: '| `min()` | Lowest value |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `min()` | 最低值 |'
- en: '| `sd()` | Standard deviation |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `sd()` | 标准差 |'
- en: 'We can get the average math score by class size by running `summarize()` on
    our grouped data frame:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在我们的分组数据框上运行 `summarize()` 来获取按班级规模的平均数学分数：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `` `summarise()` ungrouping output `` error is a warning that you’ve ungrouped
    the grouped tibble by aggregating it. Minus some formatting differences, we have
    the same results as [Figure 8-2](#excel-pivot-table).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `summarise()` ungrouping output `` 错误是一个警告，说明您通过聚合操作取消了分组 tibble 的分组。减去一些格式上的差异，我们得到了与
    [Figure 8-2](#excel-pivot-table) 相同的结果。'
- en: 'If PivotTables are the WD-40 of Excel, then `VLOOKUP()` is the duct tape, allowing
    us to easily combine data from multiple sources. In our original *star* dataset,
    *schidkin* is a school district indicator. We dropped this column earlier in this
    chapter, so let’s read it in again. But what if in addition to the indicator number
    we actually wanted to know the *names* of these districts? Fortunately, *districts.csv*
    in the book repository has this information, so let’s read both in and come up
    with a strategy for combining them:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果透视表是 Excel 的 WD-40，那么 `VLOOKUP()` 就是胶带，可以轻松地从多个来源合并数据。在我们最初的 *star* 数据集中，*schidkin*
    是一个学区指示器。我们在本章早些时候删除了此列，所以让我们重新读取它。但是，如果除了指示器编号外，我们还想知道这些区域的 *名称* 怎么办？幸运的是，书库中的
    *districts.csv* 包含了这些信息，所以让我们将它们一起读取，并制定一个组合策略：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It appears that what’s needed is like a `VLOOKUP()`: we want to “read in” the
    *school_name* (and possibly the *county*) variables from *districts* into *star*,
    given the shared *schidkn* variable. To do this in R, we’ll use the methodology
    of *joins*, which comes from relational databases, a topic that was touched on
    in [Chapter 5](ch05.html#data-analytics-stack). Closest to a `VLOOKUP()` is the
    left outer join, which can be done in `dplyr` with the `left_join()` function.
    We’ll provide the “base” table first (*star*) and then the “lookup” table (*districts*).
    The function will look for and return a match in *districts* for every record
    in *star*, or return `NA` if no match is found. I will keep only some columns
    from *star* for less overwhelming console output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来需要的类似于`VLOOKUP()`的功能：我们希望从*districts*中“读入”*school_name*（可能还包括*county*）变量到*star*，给定共享的*schidkn*变量。要在R中实现这一点，我们将使用*joins*的方法，它来自关系数据库，这是在[第5章](ch05.html#data-analytics-stack)中讨论过的主题。与`VLOOKUP()`最接近的是左外连接，在`dplyr`中可以使用`left_join()`函数实现。我们将首先提供“基本”表(*star*)，然后是“查找”表(*districts*)。该函数将在*star*的每条记录中查找并返回*districts*中的匹配项，如果没有找到匹配项则返回`NA`。为了减少控制台输出的过多信息，我将仅保留来自*star*的一些列：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`left_join()` is pretty smart: it knew to join on `schidkn`, and it “looked
    up” not just *school_name* but also *county*. To learn more about joining data,
    check out the help documentation.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`left_join()`非常智能：它知道在`schidkn`上进行连接，并“查找”不仅*school_name*还包括*county*。要了解更多关于数据连接的信息，请查看帮助文档。'
- en: In R, missing observations are represented as the special value `NA`. For example,
    it appears that no match was found for the name of district 5\. In a `VLOOKUP()`,
    this would result in an `#N/A` error. An `NA` does *not* mean that an observation
    is equal to zero, only that its value is missing. You may see other special values
    such as `NaN` or `NULL` while programming R; to learn more about them, launch
    the help documentation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中，缺失的观察结果表示为特殊值`NA`。例如，似乎没有找到第5区的地区名的匹配项。在`VLOOKUP()`中，这将导致`#N/A`错误。`NA`并*不*意味着观察结果等于零，只是其值缺失。在编程R时，你可能会看到其他特殊值，例如`NaN`或`NULL`；要了解更多信息，请查看帮助文档。
- en: dplyr and the Power of the Pipe (%>%)
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: dplyr与管道操作符（%>%）
- en: 'As you’re beginning to see, `dplyr` functions are powerful and rather intuitive
    to anyone who’s worked with data, including in Excel. And as anyone who’s worked
    with data knows, it’s rare to prepare the data as needed in just one step. Take,
    for example, a typical data analysis task that you might want to do with *star*:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`dplyr`函数对于任何曾在Excel中处理数据的人来说都非常强大且直观。并且，任何曾处理过数据的人都知道，仅需一步就能准备好数据是非常罕见的。例如，你可能想用*star*进行典型的数据分析任务：
- en: Find the average reading score by class type, sorted high to low.
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 按班级类型查找平均阅读分数，从高到低排序。
- en: 'Knowing what we do about working with data, we can break this into three distinct
    steps:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们对数据处理的了解，我们可以将其分解为三个明确的步骤：
- en: Group our data by class type.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按班级类型分组我们的数据。
- en: Find the average reading score for each group.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到每个组的平均阅读分数。
- en: Sort these results from high to low.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些结果从高到低排序。
- en: 'We could carry this out in `dplyr` doing something like the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`dplyr`中执行类似以下操作：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This gets us to an answer, but it took quite a few steps, and it can be hard
    to follow along with the various functions and object names. The alternative is
    to link these functions together with the `%>%`, or pipe, operator. This allows
    us to pass the output of one function directly into the input of another, so we’re
    able to avoid continuously renaming our inputs and outputs. The default keyboard
    shortcut for this operator is Ctrl+Shift+M for Windows, Cmd-Shift-M for Mac.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们得到了一个答案，但需要相当多的步骤，并且很难跟踪各种函数和对象名称。另一种方法是使用管道运算符`%>%`将这些函数链接在一起。这使我们能够将一个函数的输出直接传递给另一个函数的输入，因此我们能够避免不断重命名我们的输入和输出。此运算符的默认键盘快捷键为Windows下的Ctrl+Shift+M，Mac下的Cmd-Shift-M。
- en: 'Let’s re-create the previous steps, this time with the pipe operator. We’ll
    place each function on its own line, combining them with `%>%`. While it’s not
    necessary to place each step on its own line, it’s often preferred for legibility.
    When using the pipe operator, it’s also not necessary to highlight the entire
    code block to run it; simply place your cursor anywhere in the following selection
    and execute:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新创建上述步骤，这次使用管道操作符。我们将每个函数放在自己的一行上，用`%>%`将它们组合起来。虽然不必将每个步骤放在自己的行上，但通常出于可读性考虑。使用管道操作符时，无需突出显示整个代码块即可运行它；只需将光标放在所需选择中的任何位置并执行即可：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It can be pretty disorienting at first to no longer be explicitly including
    the data source as an argument in each function. But compare the last code block
    to the one before and you can see how much more efficient this approach can be.
    What’s more, the pipe operator can be used with non-`dplyr` functions. For example,
    let’s just assign the first few rows of the resulting operation by including `head()`
    at the end of the pipe:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 起初不再在每个函数中显式包含数据源作为参数可能会令人困惑。但是将最后一个代码块与之前的比较，你会看到这种方法效率有多高。此外，管道运算符可以与非`dplyr`函数一起使用。例如，让我们只将操作结果的前几行分配给`head()`：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Reshaping Data with tidyr
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用tidyr重塑数据
- en: Although it’s true that `group_by()` along with `summarize()` serve as a PivotTable
    equivalent in R, these functions can’t do everything that an Excel PivotTable
    can do. What if, instead of just aggregating the data, you wanted to *reshape*
    it, or change how rows and columns are set up? For example, our *star* data frame
    has two separate columns for math and reading scores, *tmathssk* and *treadssk*,
    respectively. I would like to combine these into one column called *score*, with
    another called *test_type* indicating whether each observation is for math or
    reading. I’d also like to keep the school indicator, *schidkn*, as part of the
    analysis.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在R中，`group_by()`和`summarize()`与Excel中的透视表类似，但这些函数不能做到Excel透视表所能做的一切。如果你想要*重塑*数据，或者改变行和列的设置怎么办？例如，我们的*star*数据框有两列分别用于数学和阅读成绩，*tmathssk*和*treadssk*。我想将它们合并为一个名为*score*的列，并且用另一个名为*test_type*的列指示每个观察是数学还是阅读。我还想保留学校指示符*schidkn*作为分析的一部分。
- en: '[Figure 8-3](#excel-reshape) shows what this might look like in Excel; note
    that I relabeled the Values fields from *tmathssk* and *treadssk* to *math* and
    *reading*, respectively. If you would like to inspect this PivotTable further,
    it is available in the [book repository as *ch-8.xlsx*](https://oreil.ly/Kq93s).
    Here I am again making use of an index column; otherwise, the PivotTable would
    attempt to “roll up” all values by *schidkn*.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8-3](#excel-reshape)展示了在Excel中的样子；请注意，我将*Values*字段从*tmathssk*和*treadssk*改名为*math*和*reading*。如果你想进一步查看此透视表，它在[书籍仓库中作为*ch-8.xlsx*可供查阅](https://oreil.ly/Kq93s)。在这里我再次使用了索引列；否则，透视表将尝试通过*schidkn*“汇总”所有值。'
- en: '![Reshaping Excel](assets/aina_0803.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![Excel中的重塑](assets/aina_0803.png)'
- en: Figure 8-3\. Reshaping *star* in Excel
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-3\. 在Excel中重塑*star*
- en: 'We can use `tidyr`, a core `tidyverse` package, to reshape *star*. Adding an
    index column will also be helpful when reshaping in R, as it was in Excel. We
    can make one with the `row_number()` function:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`tidyr`，这是`tidyverse`核心包，来重塑*star*。在R中重塑时，添加一个索引列也会很有帮助，就像在Excel中一样。我们可以用`row_number()`函数来创建一个：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To reshape the data frame, we’ll use `pivot_longer()` and `pivot_wider()`,
    both from `tidyr`. Consider in your mind’s eye and in [Figure 8-3](#excel-reshape)
    what would happen to our dataset if we consolidated scores from *tmathssk* and
    *treadssk* into one column. Would the dataset get longer or wider? We’re adding
    rows here, so our dataset will get longer. To use `pivot_longer()`, we’ll specify
    with the `cols` argument what columns to lengthen by, and use `values_to` to name
    the resulting column. We’ll also use `names_to` to name the column indicating
    whether each score is math or reading:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要重塑数据框，我们将使用`tidyr`中的`pivot_longer()`和`pivot_wider()`。在你的脑海中和[图8-3](#excel-reshape)中考虑一下，如果我们将*tmathssk*和*treadssk*的分数合并到一列中，数据集会发生什么变化。数据集会变得更长，因为我们在这里添加了行。要使用`pivot_longer()`，我们将使用`cols`参数指定要拉长的列，并使用`values_to`来命名结果列。我们还将使用`names_to`来命名指示每个分数是数学还是阅读的列：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Great work. But is there a way to rename *tmathssk* and *treadssk* to *math*
    and *reading*, respectively? There is, with `recode()`, yet another helpful `dplyr`
    function that can be used with `mutate()`. `recode()` works a little differently
    than other functions in the package because we include the name of the “old” values
    *before* the equals sign, then the new. The `distinct()` function from `dplyr`
    will confirm that all rows have been named either *math* or *reading*:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。但是是否有一种方法可以将*tmathssk*和*treadssk*重命名为*math*和*reading*呢？有的，使用`recode()`，这是`dplyr`中另一个有用的函数，可以与`mutate()`一起使用。`recode()`与包中的其他函数有些不同，因为我们在等号之前包括“旧”值的名称，然后是新值。`dplyr`中的`distinct()`函数将确认所有行都已命名为*math*或*reading*：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now that our data frame is lengthened, we can widen it back with `pivot_wider()`.
    This time, I’ll specify which column has values in its rows that should be columns
    with `values_from`, and what the resulting columns should be named with `names_from`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的数据框已经延长了，我们可以   现在我们的数据框已经拉长，我们可以使用`pivot_wider()`将其扩展回来。这次，我将指定哪些列包含其行中的值应该作为列，使用`values_from`，以及结果列的名称使用`names_from`：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Reshaping data is a relatively trickier operation in R, so when in doubt, ask
    yourself: *am I making this data wider or longer? How would I do it in a PivotTable?*
    If you can logically walk through what needs to happen to achieve the desired
    end state, coding it will be that much easier.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 数据重塑在R中是相对复杂的操作，所以在疑惑时，问问自己：*我是在将数据做宽还是做长？在数据透视表中我该怎么做？* 如果你能逻辑地走通实现所需最终状态的过程，编码就会容易得多。
- en: Data Visualization with ggplot2
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ggplot2进行数据可视化
- en: There’s so much more that `dplyr` can do to help us manipulate data, but for
    now let’s turn our attention to data visualization. Specifically, we’ll focus
    on another `tidyverse` package, `ggplot2`. Named and modeled after the “grammar
    of graphics” devised by computer scientist Leland Wilkinson, `ggplot2` provides
    an ordered approach for constructing plots. This structure is patterned after
    how elements of speech come together to make a sentence, hence the “grammar” of
    graphics.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`dplyr`还能做很多帮助我们操作数据的事情，但现在让我们将注意力转向数据可视化。具体来说，我们将关注另一个`tidyverse`包，`ggplot2`。该包的名称和模型是根据计算机科学家利兰·威尔金森（Leland
    Wilkinson）设计的“图形语法”来命名和建模的，`ggplot2`提供了一种构建图形的有序方法。这种结构模仿了语音元素如何结合在一起形成句子，因此被称为“图形语法”。'
- en: 'I’ll cover some of the basic elements and plot types of `ggplot2` here. For
    more about the package, check out *ggplot2: Elegant Graphics for Data Analysis*
    by the package’s original author, Hadley Wickham (Springer). You can also access
    a helpful cheat sheet for working with the package by navigating in RStudio to
    Help → Cheatsheets → Data Visualization with ggplot2\. Some essential elements
    of `ggplot2` are found in [Table 8-3](#elements-of-ggplot2). Other elements are
    available; for more information, check out the resources mentioned earlier.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '我将在这里介绍一些`ggplot2`的基本元素和图表类型。更多关于该包的信息，请查阅包的原作者哈德利·威克汉姆（Hadley Wickham）所著的*ggplot2:
    Elegant Graphics for Data Analysis*（Springer）。你还可以通过在RStudio中导航到Help → Cheatsheets
    → Data Visualization with ggplot2来访问一个有用的速查表。一些`ggplot2`的基本元素可以在[表8-3](#elements-of-ggplot2)中找到。还有其他元素可用；更多信息，请查看前面提到的资源。'
- en: Table 8-3\. The foundational elements of `ggplot2`
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 表8-3。`ggplot2`的基础元素
- en: '| Element | Description |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 元素 | 描述 |'
- en: '| --- | --- |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `data` | The source data |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `data` | 数据源 |'
- en: '| `aes` | The aesthetic mappings from data to visual properties (x- and y-axes,
    color, size, and so forth) |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `aes` | 从数据到视觉属性（x轴和y轴、颜色、大小等）的美学映射 |'
- en: '| `geom` | The type of geometric object observed in the plot (lines, bars,
    dots, and so forth) |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `geom` | 图中观察到的几何对象类型（线条、条形、点等） |'
- en: 'Let’s get started by visualizing the number of observations for each level
    of *classk* as a barplot. We’ll start with the `ggplot()` function and specify
    the three elements from [Table 8-3](#elements-of-ggplot2):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从可视化*classk*每个级别的观测数量作为条形图开始。我们将从`ggplot()`函数开始，指定[表8-3](#elements-of-ggplot2)中的三个元素：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[![1](assets/1.png)](#co_data_manipulation_and_visualization_in_r_CO1-1)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_data_manipulation_and_visualization_in_r_CO1-1)'
- en: The data source is specified with the `data` argument.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 数据源通过`data`参数指定。
- en: '[![2](assets/2.png)](#co_data_manipulation_and_visualization_in_r_CO1-2)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_data_manipulation_and_visualization_in_r_CO1-2)'
- en: The aesthetic mappings from the data to the visualization are specified with
    the `aes()` function. Here we are calling for *classk* to be mapped to the x-axis
    of the eventual plot.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据到可视化的美学映射通过`aes()`函数指定。在这里，我们要求*classk*映射到最终图表的x轴。
- en: '[![3](assets/3.png)](#co_data_manipulation_and_visualization_in_r_CO1-3)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_data_manipulation_and_visualization_in_r_CO1-3)'
- en: We plot a geometric object based on our specified data and aesthetic mappings
    with the `geom_bar()` function. The results are shown in [Figure 8-4](#barplot-ggplot2).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`geom_bar()`函数根据指定的数据和美学映射绘制一个几何对象。结果显示在[图8-4](#barplot-ggplot2)中。
- en: '![Countplot](assets/aina_0804.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![计数图](assets/aina_0804.png)'
- en: Figure 8-4\. A barplot in `ggplot2`
  id: totrans-123
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-4。`ggplot2`中的条形图
- en: Similar to the pipe operator, it’s not necessary to place each layer of the
    plot on its own line, but it’s often preferred for legibility. It’s also possible
    to execute the entire plot by placing the cursor anywhere inside the code block
    and running.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于管道操作符，不必将每一层图形放在单独的行中，但通常为了可读性而更倾向于这样做。还可以通过将光标放置在代码块的任何位置并运行来执行整个绘图。
- en: 'Because of its modular approach, it’s easy to iterate on visualizations with
    `ggplot2`. For example, we can switch our plot to a histogram of *treadssk* by
    changing our `x` mapping and plotting the results with `geom_histogram()`. This
    results in the histogram shown in [Figure 8-5](#histogram-ggplot2):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因其模块化方法，使用 `ggplot2` 迭代可视化很容易。例如，我们可以通过将 *x* 映射更改为 *treadssk* 并使用 `geom_histogram()`
    绘制结果，将我们的绘图切换为直方图。这导致了图 [8-5](#histogram-ggplot2) 中显示的直方图：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![Histogram](assets/aina_0805.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![直方图](assets/aina_0805.png)'
- en: Figure 8-5\. A histogram in `ggplot2`
  id: totrans-128
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-5\. `ggplot2` 中的直方图
- en: 'There are also many ways to customize `ggplot2` plots. You may have noticed,
    for example, that the output message for the previous plot indicated that 30 bins
    were used in the histogram. Let’s change that number to 25 and use a pink fill
    with a couple of additional arguments in `geom_histogram()`. This results in the
    histogram shown in [Figure 8-6](#custom-histogram-ggplot2):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多方法可以自定义 `ggplot2` 绘图。例如，您可能已经注意到，上一个绘图的输出消息指出直方图使用了 30 个柱。让我们将该数字更改为 25，并在
    `geom_histogram()` 中使用粉色填充以及几个其他参数。这导致了图 [8-6](#custom-histogram-ggplot2) 中显示的直方图：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![Custom Histogram](assets/aina_0806.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![自定义直方图](assets/aina_0806.png)'
- en: Figure 8-6\. A customized histogram in `ggplot2`
  id: totrans-132
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-6\. `ggplot2` 中的自定义直方图
- en: 'Use `geom_boxplot()` to create a boxplot, as shown in [Figure 8-7](#boxplot-ggplot2):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `geom_boxplot()` 创建箱线图，如 [图 8-7](#boxplot-ggplot2) 所示：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![Boxplot](assets/aina_0807.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![箱线图](assets/aina_0807.png)'
- en: Figure 8-7\. A boxplot
  id: totrans-136
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-7\. 箱线图
- en: 'In any of the cases thus far, we could have “flipped” the plot by including
    the variable of interest in the `y` mapping instead of the `x`. Let’s try it with
    our boxplot. [Figure 8-8](#reverse-boxplot-ggplot2) shows the result of the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的任何情况下，我们都可以通过将兴趣变量包含在 `y` 映射中而不是 `x` 映射中来“翻转”图形。让我们尝试在我们的箱线图中进行此操作。图 [8-8](#reverse-boxplot-ggplot2)
    展示了以下操作的结果：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![Flipped boxplot](assets/aina_0808.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![翻转的箱线图](assets/aina_0808.png)'
- en: Figure 8-8\. A “flipped” boxplot
  id: totrans-140
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-8\. “翻转”的箱线图
- en: 'Now let’s make a boxplot for each level of class size by mapping *classk* to
    the x-axis and *treadssk* to the y, resulting in the boxplot shown in [Figure 8-9](#grouped-boxplot-ggplot2):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过将 *classk* 映射到 x 轴和 *treadssk* 映射到 y 轴，为每个班级大小级别制作一个箱线图。这导致了图 [8-9](#grouped-boxplot-ggplot2)
    中显示的箱线图：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Similarly, we can use `geom_point()` to plot the relationship of *tmathssk*
    and *treadssk* on the x- and y-axes, respectively, as a scatterplot. This results
    in [Figure 8-10](#scatterplot-ggplot2):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用 `geom_point()` 在 x 和 y 轴上绘制 *tmathssk* 和 *treadssk* 的关系，作为散点图。这导致了图
    [8-10](#scatterplot-ggplot2) 中显示的结果：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![Grouped boxplot](assets/aina_0809.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![分组箱线图](assets/aina_0809.png)'
- en: Figure 8-9\. A boxplot by group
  id: totrans-146
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-9\. 按组绘制的箱线图
- en: '![Scatterplot](assets/aina_0810.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![散点图](assets/aina_0810.png)'
- en: Figure 8-10\. A scatterplot
  id: totrans-148
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-10\. 散点图
- en: 'We can use some additional `ggplot2` functions to layer labels onto the x-
    and y-axes, along with a plot title. [Figure 8-11](#labeled-plot-ggplot2) shows
    the result:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一些额外的 `ggplot2` 函数在 x 和 y 轴上叠加标签，以及一个绘图标题。图 [8-11](#labeled-plot-ggplot2)
    展示了结果：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![Scatterplot with custom labels and title](assets/aina_0811.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![具有自定义标签和标题的散点图](assets/aina_0811.png)'
- en: Figure 8-11\. A scatterplot with custom axis labels and title
  id: totrans-152
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-11\. 带有自定义轴标签和标题的散点图
- en: Conclusion
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: 'There’s so much more that `dplyr` and `ggplot2` can do, but this is enough
    to get you started with the true task at hand: to explore and test relationships
    in data. That will be the focus of [Chapter 9](ch09.html#r-capstone).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`dplyr` 和 `ggplot2` 还可以做更多事情，但这已足以让您开始真正的任务：探索和测试数据中的关系。这将是 [第9章](ch09.html#r-capstone)
    的重点。'
- en: Exercises
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'The [book repository](https://oreil.ly/kBk3e) has two files in the *census*
    subfolder of *datasets*, *census.csv* and *census-divisions.csv*. Read these into
    R and do the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[书籍库](https://oreil.ly/kBk3e)在 *datasets* 的 *census* 子文件夹中有两个文件，*census.csv*
    和 *census-divisions.csv*。将它们读入 R 并执行以下操作：'
- en: Sort the data by region ascending, division ascending, and population descending.
    (You will need to combine datasets to do this.) Write the results to an Excel
    worksheet.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按地区升序、部门升序和人口降序对数据进行排序（您需要合并数据集来执行此操作）。将结果写入 Excel 工作表。
- en: Drop the postal code field from your merged dataset.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从合并数据集中删除邮政编码字段。
- en: Create a new column *density* that is a calculation of population divided by
    land area.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为*density*的新列，计算人口除以土地面积的结果。
- en: Visualize the relationship between land area and population for all observations
    in 2015.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可视化2015年所有观测点的土地面积与人口之间的关系。
- en: Find the total population for each region in 2015.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找2015年每个地区的总人口。
- en: Create a table containing state names and populations, with the population for
    each year 2010–2015 kept in an individual column.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含州名和人口的表格，每年2010年至2015年的人口分别放在一个单独的列中。
