- en: 12 Arithmetic with quantum computers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 使用量子计算机进行算术
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Programming with the Q# Numerics library
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Q#数值库进行编程
- en: Implementing Shor’s algorithm to factor integers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现Shor算法以分解整数
- en: Recognizing the implications of quantum computing for security infrastructure
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认识量子计算对安全基础设施的影响
- en: 'In chapter 11, we used a quantum programming technique called amplitude amplification
    in Grover’s algorithm to speed up searching unstructured data sets. While Grover’s
    was not the most efficient search approach for smaller data sets, as we looked
    to scaling up to larger and larger problems, our quantum approach offered a clear
    advantage. In this final chapter, we’ll build on the skills we’ve developed throughout
    the book to tackle one of the most famous quantum algorithms: Shor’s algorithm.
    We’ll implement Shor’s and show how it can give us an advantage when trying to
    factor large integers. While that may not seem like the most interesting task,
    the difficulty of factoring integers actually underpins much of our current cryptographic
    infrastructure.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在第11章中，我们使用了Grover算法中的一种量子编程技术——振幅放大，来加速搜索非结构化数据集。虽然对于较小的数据集来说，Grover的搜索方法并不是最有效的方法，但当我们着眼于解决更大和更大的问题时，我们的量子方法提供了明显的优势。在本章的最后，我们将利用本书中开发的所有技能来处理最著名的量子算法之一：Shor算法。我们将实现Shor算法，并展示它如何在我们尝试分解大整数时给我们带来优势。虽然这可能不是最有意思的任务，但分解整数的难度实际上支撑着我们当前的大部分加密基础设施。
- en: 12.1 Factoring quantum computing into security
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1 将量子计算分解为安全性
- en: In part 1 of the book, we saw how quantum concepts can be applied to send data
    securely using techniques such as quantum key distribution. Even without QKD,
    though, critical data is shared secretly over the internet all the time. The internet
    is used to share payment data, personal health data, and dating preferences and
    even to organize political movements. In this chapter, we’ll take a look at how
    classical computers can protect our privacy and how quantum computing changes
    the way we decide what tools to use to protect our data.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第一部分，我们看到了量子概念如何应用于使用量子密钥分发等技术安全地发送数据。尽管如此，没有QKD，关键数据也一直在互联网上秘密共享。互联网被用来共享支付数据、个人健康数据和约会偏好，甚至用来组织政治运动。在本章中，我们将探讨经典计算机如何保护我们的隐私，以及量子计算如何改变我们决定使用哪些工具来保护我们的数据的方式。
- en: 'Note Now that we have what we need to solve harder problems with quantum computers,
    this chapter’s scenario is a bit more complicated than most of our earlier games
    and scenarios. Don’t worry if things don’t make sense off the bat: take your time
    and read more slowly. We promise it will be worth your while!'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：现在我们有了用量子计算机解决更难问题的工具，本章的场景比我们之前的大部分游戏和场景都要复杂一些。如果一开始事情没有弄明白，请不要担心：慢慢来，仔细阅读。我们保证这会物有所值！
- en: 'To begin, let’s look at the state of the art for securing data with classical
    computers. As it turns out, there are many different problems in classical mathematics,
    some of which are really easy to solve (e.g., “What’s 2 + 2?”) and others of which
    are really difficult to solve (e.g., “Is P equal to NP?”). Between those two extremes,
    we get problems that are hard to solve unless someone gives us a hint, in which
    case they become easy. These problems tend to look more like *puzzles* and can
    be useful for hiding data: we have to know the secret hint or use huge amounts
    of computing time to solve them.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看使用经典计算机保护数据的最先进技术。实际上，在经典数学中存在许多不同的问题，其中一些非常容易解决（例如，“2 + 2等于多少？”），而另一些则非常困难（例如，“P是否等于NP？”）。在这两个极端之间，我们得到一些问题，除非有人给我们提示，否则它们很难解决。在这种情况下，它们变得容易解决。这些问题往往看起来更像*谜题*，可以用于隐藏数据：我们必须知道秘密提示或使用大量的计算时间来解决它们。
- en: Tip In chapter 3, we saw quantum key distribution, which is a great way to share
    information securely that relies on quantum mechanics rather than puzzles. We
    may not always be able to send qubits to our friends, though, so understanding
    how to use puzzles to communicate securely and privately still matters.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：在第3章中，我们看到了量子密钥分发，这是一种依靠量子力学而不是谜题来安全分享信息的好方法。尽管如此，我们可能并不总是能将量子比特发送给我们的朋友，因此理解如何使用谜题来安全且私密地交流仍然很重要。
- en: As we will see later in the chapter, factoring numbers can be one of these puzzles
    that cryptographic algorithms can rely on for security. A number of very important
    algorithms and cryptographic protocols are currently in use that rely on the fact
    that it is difficult for computers to solve puzzles that involve factoring large
    numbers. If you guessed that quantum computers can help us factor large numbers,
    you’re on the right track.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在本章后面看到的那样，分解数字可以是这些密码学算法可以依赖的谜题之一，以实现安全性。目前正在使用许多非常重要的算法和密码学协议，它们依赖于分解大数难题的难度。如果你猜到量子计算机可以帮助我们分解大数，你就在正确的道路上。
- en: 'Enter *Shor’s algorithm*. With a classical computer, we can reduce the problem
    or puzzle of finding factors of integers to solving a kind of puzzle about how
    quickly functions repeat themselves when using *modular arithmetic* (also known
    as *clock arithmetic*, as we’ll see more of later in the chapter). If we use Shor’s
    algorithm, estimating how quickly functions repeat themselves is precisely the
    sort of puzzle we can solve easily on a quantum computer. Let’s dig into the steps
    of Shor’s and then look at an example of using it:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 *Shor算法*。使用经典计算机，我们可以将寻找整数因子的难题或谜题简化为解决一种关于在模运算（也称为 *时钟运算*，我们将在本章后面看到更多）中使用函数重复速度的谜题。如果我们使用Shor算法，估计函数重复速度正是我们可以在量子计算机上轻松解决的谜题。让我们深入研究Shor算法的步骤，然后看看如何使用它的一个例子：
- en: '*Scenario: Factoring an integer* *N*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*场景：分解整数* *N*'
- en: '*Suppose we’re trying to factor the integer* *N*, *and we know in advance that*
    *N* *has exactly two prime factors. Using Q#, implement Shor’s algorithm to factor*
    *N*.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*假设我们正在尝试分解整数* *N*，*并且我们事先知道* *N* *恰好有两个质因数。使用Q#实现Shor算法来分解* *N*。'
- en: Coprime and semiprime
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 同余数和半同余数
- en: As a helpful bit of terminology, we say two numbers that share no common factors
    other than 1 are *coprime*. For example, neither 15 nor 16 is prime, but 15 and
    16 are coprime with respect to each other.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项有用的术语，我们说两个除了1以外没有其他公因数的数是 *互质数*。例如，15和16都不是质数，但就它们彼此而言，15和16是互质的。
- en: Similarly, we say that a number with exactly two prime factors is *semiprime*.
    For example, 15 is semiprime since 15 = 3 × 5 and since both 3 and 5 are prime.
    On the other hand, 28 isn’t semiprime since 28 = 4 × 7 = 2 × 2 × 7\. Semiprime
    numbers come up often when considering cryptography, so it’s often useful to make
    that assumption in our scenarios.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们说一个恰好有两个质因数的数是 *半同余数*。例如，15是半同余数，因为15 = 3 × 5，并且因为3和5都是质数。另一方面，28不是半同余数，因为28
    = 4 × 7 = 2 × 2 × 7。在考虑密码学时，半同余数经常出现，因此在我们的场景中通常假设这一点是有用的。
- en: We can perform the steps in algorithm 12.1 (shown as a flowchart in figure 12.1)
    to use what we learned about phase estimation in chapters 9 and 10 together with
    some classical math to find the factors of *N*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以执行算法12.1中的步骤（如图12.1所示的流程图），结合我们在第9章和第10章中学到的相位估计知识以及一些经典数学，来找到 *N* 的因子。
- en: The mod squad
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 模运算小组
- en: 'In algorithm 12.1, we need one more bit of classical math: the mod operator.
    If you haven’t seen that operator before, don’t worry; we’ll go through it in
    more detail later in the chapter.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在算法12.1中，我们需要一个额外的经典数学运算符：模运算符。如果你之前没有见过这个运算符，不要担心；我们将在本章后面更详细地介绍它。
- en: '*Algorithm 12.1: Pseudocode for factoring an integer with Shor’s algorithm*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*算法12.1：使用Shor算法分解整数的伪代码*'
- en: Pick a random integer *g*, which we call the *generator*.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个随机整数 *g*，我们称之为 *生成器*。
- en: Check to see if the generator is accidentally a factor by determining whether
    *g* and *N* are coprime. If they share a common factor, then we have a new factor
    of *N*; else continue with the rest of the algorithm.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过确定生成器 *g* 和 *N* 是否互质来检查生成器是否意外地是一个因子。如果它们共享一个公因数，那么我们就有了一个新的 *N* 因子；否则继续执行算法的其余部分。
- en: Use iterative phase estimation to find the *frequency* of the classical function
    *f*(*x*) = *g^x* mod *N*. The frequency tells us how quickly *f* returns to the
    same value as *x* increases.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用迭代相位估计来找到经典函数 *f*(*x*) = *g^x* mod *N* 的 *频率*。频率告诉我们当 *x* 增加时，*f* 多快会回到相同的值。
- en: Use a classical algorithm known as the *continued fractions expansion* to convert
    the frequency from the previous step into a period (*r*). The period *r* should
    then have the property that *f*(*x*) = *f*(*x* + *r*) for all inputs *x*.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一个称为 *连分数展开* 的经典算法，将上一步中的频率转换为周期 (*r*)。周期 *r* 应该具有这样的性质，即对于所有输入 *x*，*f*(*x*)
    = *f*(*x* + *r*)。
- en: If the period *r* that we find is odd, go back to step 1 and make a new guess.
    If *r* is even, go to the next step.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们找到的周期*r*是奇数，则回到步骤1并做出新的猜测。如果*r*是偶数，则进入下一步。
- en: Either *g*^(*r*/2) − 1 or *g*^(*r*/2) + 1 shares a factor with *N*.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要么是*g*^(*r*/2) − 1，要么是*g*^(*r*/2) + 1与*N*共享一个因子。
- en: Note In algorithm 12.1, it is important to note that only step 3 involves any
    quantum computation. Most of the steps for Shor’s algorithm are best suited for
    classical hardware and demonstrate how quantum hardware will likely be used. That
    is to say, quantum hardware and algorithms work well as *subroutines* for combined
    quantum-classical algorithms.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在算法12.1中，需要注意的是，只有第3步涉及任何量子计算。Shor算法的大部分步骤最适合经典硬件，并展示了量子硬件可能会如何被使用。也就是说，量子硬件和算法作为量子经典算法的*子程序*工作得很好。
- en: '![](../Images/12-1.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/12-1.png)'
- en: Figure 12.1 Shor's algorithm represented as a flowchart. To factor an integer
    *N*, Shor's algorithm uses phase estimation and a quantum computer to find the
    period of a function that takes powers of another integer a using modular arithmetic
    mod *N*. After some classical postprocessing, that period can be used to find
    the factors of *N*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 将Shor算法表示为流程图。为了分解整数*N*，Shor算法使用相估计和量子计算机来找到另一个整数a的幂在模*N*下的函数的周期。经过一些经典的后处理，这个周期可以用来找到*N*的因子。
- en: 'Now that we have seen the steps for Shor’s algorithm, listing 12.1 shows what
    the final implementation might look like. The operation `FactorSemiprimeInteger`
    is the entry point to the algorithm: it takes as input the integer we want to
    factor and returns its two factors.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了Shor算法的步骤，列表12.1展示了最终实现可能的样子。操作`FactorSemiprimeInteger`是算法的入口点：它接受我们想要分解的整数作为输入，并返回它的两个因子。
- en: Listing 12.1 Q# code for factoring a semiprime integer
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.1 分解半素整数Q#代码
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ First checks if we were asked to factor an even number, since then 2 must
    be a factor
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 首先检查我们是否被要求分解一个偶数，因为在这种情况下2必须是因子
- en: ❷ Following step 1 of algorithm 12.1, we pick a random number to define the
    periodic function that we use to factor “number”.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 按照算法12.1的第1步，我们选择一个随机数来定义我们用来分解“数字”的周期函数。
- en: ❸ In this chapter, we learn how to write an EstimatePeriod operation to handle
    steps 3 and 4 of algorithm 12.1 using what we’ve learned about phase estimation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在本章中，我们学习如何编写一个EstimatePeriod操作来处理算法12.1的第3步和第4步，使用我们关于相估计所学的知识。
- en: ❹ Once we have the period, we can use steps 5 and 6 of algorithm 12.1 to guess
    the factors of “number”; we’ll write MaybeFactorsFromPeriod later in the chapter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 一旦我们得到了周期，我们就可以使用算法12.1的第5步和第6步来猜测“数字”的因子；我们将在本章后面写MaybeFactorsFromPeriod。
- en: ❺ If something goes wrong (e.g., our generator has an odd period), we use a
    repeat/until loop to try again.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果出现问题（例如，我们的发生器有一个奇数周期），我们使用重复/直到循环再次尝试。
- en: ❻ Returns the two factors of “number” that we found using our quantum program
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 返回我们使用量子程序找到的“数字”的两个因子
- en: Luck isn’t everything, but it can help!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运不是一切，但它可以有所帮助！
- en: In listing 12.1, we use `IsCoprimeI` to check whether `generator` is a factor
    of `number` before proceeding with the rest of Shor’s algorithm. If we’re really
    lucky, then `generator` is already a factor, in which case we don’t need a quantum
    computer to help factor `number`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表12.1中，我们在继续Shor算法的其余步骤之前，使用`IsCoprimeI`来检查`generator`是否是`number`的因子。如果我们真的很幸运，那么`generator`已经是因子，在这种情况下我们不需要量子计算机来帮助分解`number`。
- en: While we may be lucky pretty often in the small examples we can simulate on
    a laptop or desktop, as `number` gets bigger, it becomes harder and harder to
    guess the right factors by accident, such that Shor’s algorithm is really helpful
    almost all the time.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在笔记本电脑或台式机上可以模拟的小例子中可能经常幸运，但随着“数字”变大，偶然猜对正确因子的难度越来越大，因此Shor算法几乎总是非常有帮助。
- en: 'Since this is the last chapter of the book, we have all of the *quantum* concepts
    we need to understand what’s happening in listing 12.1; the only things missing
    are the classical parts that connect what we’ve learned so far to the problem
    of factoring semiprime numbers, as well as a few useful parts of the Q# libraries
    that can help. As mentioned before, only one step here uses quantum technology,
    and it does so by creating an oracle that implements the classical function we
    want to learn about. By using a superposition state, applying the oracle, and
    doing phase estimation, we can learn properties about the classical function:
    here, the period. In the rest of the chapter, we’ll go through algorithm 12.1
    in detail and cover the last pieces that we need to run Shor’s algorithm. The
    first piece we need to understand algorithm 12.1 is a bit of classical math known
    as *modular arithmetic*, so let’s jump on in!'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是本书的最后一章，我们拥有了理解列表 12.1 中发生的事情所需的全部量子概念；唯一缺少的是将我们所学内容与分解半素数问题相联系的经典部分，以及一些有用的
    Q# 库的部分，这些部分可以帮助我们。如前所述，这里只使用了一步量子技术，它是通过创建一个实现我们想要学习的经典函数的或然函数来实现的。通过使用叠加态，应用或然函数，并进行相位估计，我们可以了解经典函数的性质：在这里，是周期。在本章的其余部分，我们将详细讲解算法
    12.1，并涵盖运行 Shor 算法所需的最后几块拼图。我们需要理解算法 12.1 的第一块拼图是经典数学中称为 *模数算术* 的一部分，所以让我们开始吧！
- en: 12.2 Connecting modular math to factoring
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2 将模数数学与分解相联系
- en: One way to find puzzles that can be used in security contexts is to look at
    how *modular arithmetic* works. Unlike normal arithmetic, in modular arithmetic,
    everything wraps back around like hours on a clock. For instance, if someone asked
    us what time comes two hours after 11 o’clock, we would get a very odd look if
    we responded with “13 o’clock.” Much more likely, the person was hoping to get
    an answer like “1 o’clock”— that is, if they don’t use 24-hour time.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一种寻找可用于安全环境中的谜题的方法是观察模数算术是如何工作的。与普通算术不同，在模数算术中，一切就像时钟上的小时一样循环回来。例如，如果有人问我们在
    11 点之后两小时是什么时间，如果我们回答说“13 点”，我们可能会得到一个非常奇怪的表情。更有可能的是，那个人希望得到一个像“1 点”这样的答案——也就是说，如果他们不使用
    24 小时制的话。
- en: Using modular arithmetic, we can capture this idea by saying that 11 + 2 = 1
    mod. In that equation, mod 12 indicates that we want anything that goes past 12
    to wrap around, as illustrated in figure 12.2.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模运算，我们可以通过以下方式表达这个想法：11 + 2 = 1 mod。在这个等式中，mod 12 表示我们希望任何超过 12 的数都循环回到起点，如图
    12.2 所示。
- en: '![](../Images/12-2.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/12-2.png)'
- en: Figure 12.2 Using clocks to understand modular arithmetic. When adding and multiplying
    numbers “mod *N*,” we can think of a normal number line as being wrapped around
    a clock face with *N* hours. Just as two hours past 11 o’clock is 1 o’clock, 11
    + 2 = 1 when working mod 12.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 使用时钟来理解模数运算。当进行“mod *N*”的加法和乘法运算时，我们可以将正常的数线想象成被 *N* 个小时环绕的时钟面。就像 11
    点过两小时是 1 点一样，当在 mod 12 下工作时，11 + 2 = 1。
- en: When arithmetic is allowed to wrap around like this, it can be difficult to
    figure out where different calculations started. If we’re working with ordinary
    real numbers, for example, it’s easy to calculate *b* if we’re given *a* and *a^b*;
    we can take the logarithm of *a^b* to find *b*. If we try to solve the same problem
    in modular arithmetic, it can quickly get tricky. For instance, when computing
    mod 21, the powers of 5 are 1, 5, 4, 20, 16, 17, 1, .... On the face of it, 5,
    4, and 16 don’t seem like powers of the same number, much less in increasing order,
    such that when we’re working backward from having taken an exponent mod 21, we
    have more possible starting places that we need to check.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当算术可以像这样循环时，确定不同的计算起点可能会变得困难。如果我们处理的是普通实数，例如，如果我们已知 *a* 和 *a^b*，那么计算 *b* 是很容易的；我们可以通过对
    *a^b* 取对数来找到 *b*。如果我们尝试在模数算术中解决相同的问题，它可能会很快变得复杂。例如，当计算 mod 21 时，5 的幂是 1, 5, 4,
    20, 16, 17, 1，……。表面上，5, 4 和 16 不像是同一个数的幂，更不用说按递增顺序排列了，当我们从取模 21 的指数反向工作时，我们需要检查的起点可能更多。
- en: 'Exercise 12.1: Powers of 11'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 12.1：11 的幂
- en: What are the powers of 11 when computed mod 21? How long does it take to loop
    back around to 11⁰ = 1?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算 mod 21 时，11 的幂是多少？需要多长时间才能循环回到 11⁰ = 1？
- en: Does it matter if you take the modulus by 21 at the end, or whether you compute
    the modulus at each step?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后取模 21 是否重要，或者是否在每一步都计算模数？
- en: '*Hint*: Either Python or Q# works great for this, as both define the modulus
    operator `%`.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*提示*：Python 或 Q# 都非常适合这个任务，因为两者都定义了模运算符 `%`。'
- en: Exercise solutions
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 练习解答
- en: 'All solutions for exercises in this book can be found in the companion code
    repo: [https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp).
    Just go to the folder for the chapter we are in and open the Jupyter notebook
    with the name that mentions exercise solutions.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有练习题解答都可以在配套代码仓库中找到：[https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp)。只需进入我们当前章节的文件夹，然后打开名为练习题解答的
    Jupyter notebook。
- en: 'The observation that finding the power *b* given *a^b* mod *N* is hard already
    gives us a puzzle we can use to hide some data! This puzzle is commonly called
    the *discrete logarithm* problem. If Alice wants to share a secret with us, we
    can start by publicly agreeing on a small number like *g* = 13 and a big number
    like *N* = 71\. We then each pick a secret number at random: suppose Alice picks
    *a* = 4 and we pick *b* = 5\. Alice then sends us *g^a* mod *N* = 19, and we send
    back *g^b* mod *N* = 34\. If we compute (*g^a*)^(*b*) mod *N* = 19⁵ mod 71 = 45
    and Alice computes (*g^b*)^(*a*) mod 71 = 34⁴ mod 71 = 45, we both get the same
    number, but an eavesdropper would have to solve the clockface-jumping puzzle we
    saw earlier to work it out (see figure 12.3). Since *g^(ab)* = 45 is a number
    that we and Alice know, but no one else knows, we can use *g^(ab)* as a key to
    hide our messages using what we learned in chapter 3.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到给定 *a^b* mod *N* 求解 *b* 是困难的这一事实，已经给我们提供了一个可以用来隐藏一些数据的谜题！这个谜题通常被称为**离散对数问题**。如果爱丽丝想与我们分享一个秘密，我们可以先公开地同意一个小的数字，比如
    *g* = 13，和一个大的数字，比如 *N* = 71。然后我们各自随机选择一个秘密数字：假设爱丽丝选择了 *a* = 4，而我们选择了 *b* = 5。爱丽丝随后发送给我们
    *g^a* mod *N* = 19，而我们发送回 *g^b* mod *N* = 34。如果我们计算 (*g^a*)^(*b*) mod *N* = 19⁵
    mod 71 = 45 和爱丽丝计算 (*g^b*)^(*a*) mod 71 = 34⁴ mod 71 = 45，我们都会得到相同的数字，但窃听者必须解决我们之前看到的时钟跳跃谜题才能计算出结果（见图
    12.3）。由于 *g^(ab)* = 45 是我们和爱丽丝都知道但其他人不知道的数字，我们可以使用 *g^(ab)* 作为密钥，利用我们在第 3 章中学到的知识来隐藏我们的信息。
- en: 'Warning: Don’t try this at home'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：不要在家中尝试
- en: A lot of this protocol’s technical conditions go well beyond the scope of this
    book. Choosing *g* and *N* badly can undermine any security offered by this technique,
    making it trivial for an experienced attacker to break. It’s also very easy to
    introduce bugs by doing this on your own, so please consider this only a conceptual
    example!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个协议的许多技术条件超出了本书的范围。选择 *g* 和 *N* 不当可能会破坏这种技术提供的任何安全性，使经验丰富的攻击者轻易破解。自己这样做也很容易引入错误，所以请仅将其视为一个概念示例！
- en: If you’re interested in learning more about the practical aspects of using these
    kinds of puzzles to keep your data secure, *Cryptography Engineering* by Niels
    Ferguson, Bruce Schneier, and Tadayoshi Kohno (Wiley, 2010) is a great book from
    which to continue learning.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对使用这类谜题来保护数据安全的实际方面感兴趣，Niels Ferguson、Bruce Schneier 和 Tadayoshi Kohno 的《密码学工程》（Wiley，2010）是一本很好的书，你可以从中继续学习。
- en: '![](../Images/12-3.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/12-3.png)'
- en: Figure 12.3 Using the discrete logarithm problem as a puzzle to hide secret
    messages. Here, the messages we share with Alice are protected if it’s hard for
    someone to compute undo modular arithmetic operations such as the exponential
    function.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3 使用离散对数问题作为谜题来隐藏秘密信息。在这里，我们与爱丽丝分享的信息受到保护，如果某人难以计算撤销模运算操作，如指数函数，那么这些信息就是安全的。
- en: Unlike QKD, this way of sharing secret data (known as the *Diffie–Hellman protocol*)
    relies on the assumption that the puzzle we and Alice used is hard to solve without
    a hint that our eavesdropper doesn’t have access to. If someone can efficiently
    work out puzzles like solving *g^a* mod *N* for *a* given *g* and *N*, our data
    might as well be public.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 与 QKD 不同，这种共享秘密数据的方式（称为**迪菲-赫尔曼协议**）依赖于我们和爱丽丝使用的谜题在没有窃听者可以访问的提示下难以解决的假设。如果有人可以有效地解决像为
    *a* 给定 *g* 和 *N* 求解 *g^a* mod *N* 这样的谜题，那么我们的数据几乎就是公开的。
- en: 'One other puzzle that’s commonly used to protect data today is the *RSA algorithm*,
    which uses more advanced classical math to make a puzzle out of factoring really
    large integers. Just as we can break Diffie–Hellman by solving *g^a* mod *N*,
    we can break RSA by solving *N* = *pq* for *p* or *q* given only *N*. In the RSA
    puzzle, we call *N* a *public key* and the factors *p* and *q* the *private key*;
    if we can factor *N* easily, we can get access to private keys given only public
    keys. With that in mind, we can make the scenario from earlier a bit more precise:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常用于保护数据的谜题是 *RSA 算法*，它使用更高级的经典数学将分解大整数变成一个谜题。正如我们可以通过解 *g^a* mod *N* 来破解
    Diffie–Hellman，我们也可以通过解 *N* = *pq* 来破解 RSA，给定只有 *N*。在 RSA 谜题中，我们称 *N* 为 *公钥*，因子
    *p* 和 *q* 为 *私钥*；如果我们能够轻松地分解 *N*，我们就可以仅通过公钥获得私钥。考虑到这一点，我们可以使之前的情况更加精确：
- en: '*Scenario: Breaking RSA*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*场景：破解 RSA*'
- en: '*Suppose that we know a public key* *N*. *Using Q#, implement Shor’s algorithm
    to factor* *N* *to recover the private keys* *p* *and* *q*.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*假设我们知道一个公钥* *N*。使用 Q# 实现 Shor 算法来分解 *N* 以恢复私钥 *p* 和 *q*。'
- en: Break it 'til we make it
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 破解它，直到我们成功
- en: This scenario may seem a bit ... nefarious when compared to those in previous
    chapters. In practice, though, it’s essential to understand attacks on the tools
    and protocols that we use to keep our data safe so that we can adjust our approach
    accordingly. If we use a cryptographic algorithm like RSA to protect data, implementing
    quantum attacks on that algorithm can help us understand how large a quantum device
    our attackers would need to compromise our data. After all, there are claims ranging
    from “There’s no problem with RSA at all” to “We should be terrified”; separating
    those extremes requires understanding the resources an attacker would need.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章的场景相比，这个场景可能显得有点 ... 恶劣。然而，在实践中，理解对我们保持数据安全所使用的工具和协议的攻击是至关重要的，这样我们才能相应地调整我们的方法。如果我们使用像
    RSA 这样的加密算法来保护数据，那么在该算法上实施量子攻击可以帮助我们了解攻击者需要多大的量子设备来破坏我们的数据。毕竟，有从“RSA 完全没问题”到“我们应该感到恐慌”的各种说法；区分这些极端需要了解攻击者所需的资源。
- en: In other words, by exploring a scenario that puts us in the role of an attacker
    for a moment, we can understand how much quantum computing power would be required
    to successfully attack RSA. We’ll come back to this point at the end of the chapter,
    but for now, it helps to think like an attacker. Understanding how quantum computers
    could attack classical cryptography serves as a great scenario to practice applying
    our quantum computing skills!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，通过探索一个让我们暂时扮演攻击者角色的场景，我们可以了解成功攻击 RSA 需要多少量子计算能力。我们将在本章末尾回到这个话题，但就目前而言，像攻击者一样思考是有帮助的。了解量子计算机如何攻击经典密码学是一个很好的场景，可以练习应用我们的量子计算技能！
- en: It’s worth being cautious in using this example, though. The impact of quantum
    computing on information security depends on what assumptions we make about classical
    algorithms, improvements in quantum algorithms, the progress of quantum hardware
    development, how long we need forward secrecy to last, and many other such concerns.
    Covering all of these well enough to make *responsible* decisions about how best
    to deploy cryptography would take more space than is left in this book, unfortunately,
    so we recommend keeping in mind that the RSA scenario in this chapter is an example
    and not a complete analysis of the subject.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，使用这个例子时仍需谨慎。量子计算对信息安全的影响取决于我们对经典算法的假设、量子算法的改进、量子硬件发展的进展、我们需要前向保密持续多长时间，以及许多其他此类担忧。不幸的是，要充分涵盖所有这些内容以做出关于如何最佳部署密码学的负责任决策，需要的空间比这本书剩下的空间要多，因此我们建议记住，本章中的
    RSA 场景只是一个例子，而不是对该主题的完整分析。
- en: It turns out that even though Diffie–Hellman and RSA look very different, we
    can use some classical math to turn the factoring puzzle of RSA into another example
    of figuring out how quickly we move around a clock face when we perform modular
    arithmetic (the Diffie–Hellman puzzle). That problem can then be solved easily
    on a quantum computer using what we learned in chapter 10\. Let’s run through
    a quick example of using Shor’s algorithm to factor a small integer so that we
    can see all of those parts at work.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，尽管Diffie–Hellman和RSA看起来非常不同，我们仍然可以使用一些经典数学将RSA分解难题转化为另一个例子，即当我们执行模运算时如何快速在时钟面上移动（Diffie–Hellman难题）。然后，我们可以使用第10章中学到的知识在量子计算机上轻松解决这个问题。让我们快速通过一个使用Shor算法分解小整数的例子，以便我们可以看到所有这些部分是如何工作的。
- en: 12.2.1 Example of factoring with Shor’s algorithm
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.1 使用Shor算法分解的例子
- en: The steps listed for Shor’s algorithm can seem very abstract, so before we get
    into how they work, let’s try an example using what we learned earlier about modular
    arithmetic. Say the number we want to factor is 21; real RSA public keys will
    be much larger, but let’s use 21 for the sake of working through the math by hand.
    Trust us—it keeps the math much, *much* easier.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Shor算法列出的步骤可能看起来非常抽象，所以在我们深入探讨它们是如何工作之前，让我们尝试一个例子，使用我们之前学到的关于模运算的知识。比如说，我们想要分解的数是21；真实的RSA公钥将会大得多，但为了手动计算方便，我们还是用21。请相信我们——这样可以使数学问题简单得多。
- en: 'Here are the steps from algorithm 12.1 to factor 21:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是算法12.1分解21的步骤：
- en: Choose a random integer as a generator; let’s say we use 11.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个随机整数作为生成器；让我们假设我们使用11。
- en: We can verify that since 11 shares no common factors with 21, we can use it
    as the generator for the next step.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以验证，由于11与21没有公共因子，我们可以将其用作下一步的生成器。
- en: 'We can’t do the quantum step in our head, unfortunately, so we use the Q# iterative
    phase estimation operation to estimate the phase generated by applying an oracle
    that implements the classical function *f*(*x*) = 11^(*x*) mod 21\. It returns
    a phase *ϕ* that we can convert to a frequency of 427 by the following equation:
    (*ϕ* * 2⁹)) / 2*π*.'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 很遗憾，我们无法在脑海中完成量子步骤，因此我们使用Q#迭代相位估计操作来估计通过应用实现经典函数 *f*(*x*) = 11^(*x*) mod 21的或然函数产生的相位。它返回一个相位
    *ϕ*，我们可以通过以下方程将其转换为频率427：(*ϕ* * 2⁹)) / 2*π*。
- en: We use the continued fractions algorithm on 427 to get a guess for what the
    period might be. Doing it by hand, we get an estimate of 6 for the period.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在427上使用连分数算法来猜测周期可能是什么。手动计算，我们得到周期的估计值为6。
- en: The period we found is even, so we can continue to the next step.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们找到的周期是偶数，因此我们可以继续到下一步。
- en: Using the period 6 gives us that either 11^(6/2) − 1 mod 21 = 7 or 11^(6/2)
    + 1 mod 21 = 9 shares a factor with 21\. We can check and verify each possibility
    to confirm that 7 is indeed a factor of 21.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用周期6，我们得到11^(6/2) − 1 mod 21 = 7或者11^(6/2) + 1 mod 21 = 9与21有公共因子。我们可以检查并验证每个可能性，以确认7确实是21的因子。
- en: 'Exercise 12.2: Looking for common factors'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 练习12.2：寻找公共因子
- en: Try step 6 from the previous process, but using 35 as the number to factor,
    17 as the generator, and 12 as the period. Check that either or both of the answers
    that you get from step 6 share a common factor with 35.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试从上一个过程中的第6步开始，但使用35作为要分解的数，17作为生成器，12作为周期。检查从第6步得到的答案中，是否有任何一个或两个与35有公共因子。
- en: Using either Python or Q#, try the same thing with *N* = 143, *g* = 19, and
    the period *r* = 60.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python或Q#，尝试用 *N* = 143，*g* = 19，和周期 *r* = 60进行相同的操作。
- en: '*Note*: In the next section, we’ll see how to easily use a classical computer
    to factor a number when given another number that shares some of its factors.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意*：在下一节中，我们将看到如何使用经典计算机轻松分解一个数，当给定另一个与其共享一些因子的数时。'
- en: While this is a lot of work to factor a number as small as 21, 35, or 143, the
    exact same process also works for much larger integers, such as those we might
    encounter when trying to solve the puzzle that the RSA algorithm uses to protect
    data.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然分解像21、35或143这样小的数需要做很多工作，但完全相同的过程也适用于更大的整数，例如我们在尝试解决RSA算法用于保护数据的难题时可能会遇到的整数。
- en: The rest of the chapter goes through each of these steps in detail and shows
    how they can work together to factor integers. To kick off that process, let’s
    look at the classical math behind how period finding helps us factor integers
    and how we can use Q# to implement that classical math.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分将详细说明每个步骤，并展示它们如何协同工作以分解整数。为了启动这个过程，让我们看看周期查找如何帮助我们分解整数，以及我们如何可以使用Q#来实现这种经典数学。
- en: 12.3 Classical algebra and factoring
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.3 经典代数和分解
- en: With the concrete example of using Shor’s algorithm in mind, we can see how
    classical arithmetic and algebra help to take advantage of quantum computing.
    Before going over the core quantum part of the algorithm, it’s helpful to explore
    the classical part a little more to understand why finding the period of `generator`
    helps factor integers.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在心中考虑使用 Shor 算法的具体例子，我们可以看到经典算术和代数如何帮助利用量子计算。在深入探讨算法的核心量子部分之前，了解经典部分为什么有助于分解整数是有帮助的。
- en: We may remember from algebra that for any number *x*, *x*² − 1 = (*x* + 1)(*x*
    − 1). As it turns out, that works in modular (clock) arithmetic as well. If we
    find that the period *r* of our generator *g* is even,
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能从代数中记得，对于任何数 *x*，*x*² − 1 = (*x* + 1)(*x* − 1)。实际上，这在模（时钟）算术中同样适用。如果我们发现生成器
    *g* 的周期 *r* 是偶数，
- en: Then that means there’s an integer *k* ...
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那就意味着存在一个整数 *k* ...
- en: Such that *g^r* = *g*^(2*k*) mod *N* = 1.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使得 *g^r* = *g*^(2*k*) mod *N* = 1。
- en: Subtracting one from each side, we get (*g*^(2*k*) − 1) mod *N* = 0,
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从每一侧减去 1，我们得到 (*g*^(2*k*) − 1) mod *N* = 0，
- en: So that using *x*² − 1 = (*x* + 1)(*x* − 1) gives us ...
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，使用 *x*² − 1 = (*x* + 1)(*x* − 1) 可以给我们带来...
- en: (*g^k* + 1)(*g^k* − 1) mod *N* = 0.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (*g^k* + 1)(*g^k* − 1) mod *N* = 0。
- en: Why does this matter? If we have that *x* mod *N* = 0, that tells us *x* is
    a multiple of *N*. Thinking back to the clock analogy, 0, 12, 24, 36, and so forth
    are all equal to zero mod 12\. Put differently, if *x* mod *N* = 0, then there’s
    some integer *y* such that *x* = *yN*. Using that with what we got from the period,
    we know there’s some integer *y* such that (*g^k* + 1)(*g^k* − 1) = *yN*. If either
    *g^k* − 1 or *g^k* + 1 is a multiple of *N*, we haven’t learned much; but in any
    other case, it tells us that either *g^k* − 1 or *g^k* + 1 has to share a factor
    with *N*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这有什么关系呢？如果我们有 *x* mod *N* = 0，那么这告诉我们 *x* 是 *N* 的倍数。回想一下时钟的类比，0，12，24，36 等等都等于零模
    12。换句话说，如果 *x* mod *N* = 0，那么存在某个整数 *y* 使得 *x* = *yN*。利用这一点和周期，我们知道存在某个整数 *y*
    使得 (*g^k* + 1)(*g^k* − 1) = *yN*。如果 *g^k* − 1 或 *g^k* + 1 是 *N* 的倍数，我们并没有学到多少；但在任何其他情况下，它告诉我们
    *g^k* − 1 或 *g^k* + 1 必须与 *N* 共享一个因子。
- en: To figure out whether *g^k* − 1 or *g^k* + 1 shares a factor with *N*, we can
    compute the *greatest common divisor* (GCD) of each guess with *N*. This is straightforward
    to do with a classical computer using a technique called *Euclid’s algorithm*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定 *g^k* − 1 或 *g^k* + 1 是否与 *N* 共享一个因子，我们可以计算每个猜测与 *N* 的最大公约数（GCD）。使用称为欧几里得算法的技术，在经典计算机上这样做是直截了当的。
- en: Note Since the GCD is so easy to compute classically, why do we need a quantum
    computer to help factor? By this point in Shor’s algorithm, we’ve already narrowed
    the potential factors to two very good guesses and are using the GCD just on those
    guesses. If we didn’t have things narrowed down so well, we’d have to use the
    GCD on many, many more guesses to have a good chance of finding the factors of
    *N*. Even as easy as the GCD is to determine, we still need a good way to narrow
    it down to a good set of guesses first.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：由于最大公约数（GCD）在经典计算中非常容易计算，为什么我们需要量子计算机来帮助分解？在 Shor 算法的这个阶段，我们已经将潜在的因子缩小到两个非常好的猜测，并且只使用
    GCD 在这些猜测上进行。如果我们没有将事情缩小到如此好的程度，我们就需要在许多许多更多的猜测上使用 GCD，才有可能找到 *N* 的因子。即使最大公约数（GCD）的确定如此简单，我们仍然需要一种好方法来首先将其缩小到一组好的猜测。
- en: 'In Q#, we can compute the GCD using the `GreatestCommonDivisorI` function,
    as shown in listing 12.2, where the code is run in a Q# Jupyter Notebook. One
    way we can check that we get the right output from `GreatestCommonDivisorI` is
    to start with two integers expressed as the product of prime factors: for example,
    *a* = 2 × 3 × 113 and *b* = 2 × 3 × 5 × 13\. Since these two integers only share
    2 and 3 as factors, their GCD should be 2 × 3 = 6.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Q# 中，我们可以使用 `GreatestCommonDivisorI` 函数来计算最大公约数（GCD），如列表 12.2 所示，其中代码在 Q#
    Jupyter Notebook 中运行。我们可以通过以下方式检查是否从 `GreatestCommonDivisorI` 获得了正确的输出：从两个以质因数乘积表示的整数开始：例如，*a*
    = 2 × 3 × 113 和 *b* = 2 × 3 × 5 × 13。由于这两个整数只共享 2 和 3 作为因子，它们的最大公约数应该是 2 × 3 =
    6。
- en: The Q# standard library documentation
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Q# 标准库文档
- en: As usual, listing 12.2 starts with `open` statements that allow us to use functions
    and operations provided in the Q# standard library. In this case, the Q# function
    that computes the GCD of two integers is in the `Microsoft.Quantum.Math` namespace,
    so we begin by opening that namespace to make that functionality available. Similarly,
    the facts and assertions we need to test our new `GcdExample` function can be
    used by opening the `Microsoft.Quantum.Diagnostics` namespace.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，列表 12.2 以 `open` 语句开始，允许我们使用 Q# 标准库中提供的函数和操作。在这种情况下，计算两个整数 GCD 的 Q# 函数位于
    `Microsoft.Quantum.Math` 命名空间中，因此我们首先打开该命名空间以使该功能可用。同样，我们需要打开 `Microsoft.Quantum.Diagnostics`
    命名空间来使用测试我们新 `GcdExample` 函数所需的事实和断言。
- en: For a complete list of what is available in the Q# standard library, check out
    [https://docs.microsoft.com/en-us/qsharp/api/](https://docs.microsoft.com/en-us/qsharp/api/)
    for a full reference.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 Q# 标准库中可用的完整列表，请查看 [https://docs.microsoft.com/en-us/qsharp/api/](https://docs.microsoft.com/en-us/qsharp/api/)
    以获取完整参考。
- en: Listing 12.2 Finding the greatest common divisor of two integers
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.2 查找两个整数的最大公约数
- en: '[PRE1]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ This function is a simple test case to see how the GCD works.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这个函数是一个简单的测试案例，用来查看 GCD 的工作原理。
- en: ❷ To compute the GCD, we call GreatestCommonDivisorI from the Microsoft.Quantum.Math
    namespace that we opened earlier.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ 要计算 GCD，我们调用之前打开的 Microsoft.Quantum.Math 命名空间中的 GreatestCommonDivisorI。 '
- en: ❸ Uses the EqualityFactI function to confirm that the answer we got matches
    what we expected (2 × 3 = 6)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用 EqualityFactI 函数来确认我们得到的答案符合预期（2 × 3 = 6）
- en: ❹ As usual, we can use %simulate to run a function or operation on a simulator.
    Here, we get the output () back since GcdExample returns an output of type Unit.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如同往常，我们可以使用 %simulate 在模拟器上运行函数或操作。在这里，我们得到空输出 ()，因为 GcdExample 返回的是类型为 Unit
    的输出。
- en: Input types and naming conventions in Q#
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Q# 中的输入类型和命名约定
- en: Note the `I` at the end of the name `GreatestCommonDivisorI`. This tells us
    that `GreatestCommonDivisorI` works on inputs of type `Int`. When using Shor’s
    algorithm in practice, *N* will be much, much larger than we can fit into an ordinary
    `Int` value, so Q# also provides another type called `BigInt` to help.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `GreatestCommonDivisorI` 名称末尾的 `I`。这告诉我们 `GreatestCommonDivisorI` 在 `Int`
    类型的输入上工作。当实际使用 Shor 算法时，*N* 将比我们能够放入普通 `Int` 值的数值大得多，因此 Q# 还提供了一个名为 `BigInt` 的其他类型来帮助。
- en: To work with `BigInt` inputs, Q# also provides the `GreatestCommonDivisorL`
    function. Why `L` and not `B`? In this case, `L` stands for “long,” helping disambiguate
    from other types starting with “B,” such as `Bool`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理 `BigInt` 输入，Q# 还提供了 `GreatestCommonDivisorL` 函数。为什么是 `L` 而不是 `B`？在这种情况下，`L`
    代表“长”，有助于区分以“B”开头的其他类型，例如 `Bool`。
- en: This convention is used throughout the rest of the Q# standard libraries as
    well. For instance, the equality fact that we used earlier compared two integers
    and so is called `EqualityFactI`. The corresponding fact for comparing two big
    integers is called `EqualityFactL`, while the fact for comparing two `Result`
    values is called `EqualityFactR`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个约定也适用于 Q# 标准库的其余部分。例如，我们之前使用的等式事实比较了两个整数，因此被称为 `EqualityFactI`。比较两个大整数的对应事实被称为
    `EqualityFactL`，而比较两个 `Result` 值的事实被称为 `EqualityFactR`。
- en: 'Exercise 12.3: Greatest common denominators'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 12.3：最大公约数
- en: What’s the GCD of 35 and 30? Does that help you find the factors of 35?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 35 和 30 的最大公约数是多少？这能帮助你找到 35 的因子吗？
- en: '*Hint*: Think of this as step 2 of the previous exercise.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*提示*：将此视为上一个练习的第 2 步。'
- en: Putting everything together, if we have the period of our generator, the following
    listing shows how we can use that to write `MaybeFactorsFromPeriod` in Q#. The
    function name starts with “maybe” because there is a chance the period that was
    found will not meet conditions necessary to learn something about the factors
    of the number.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容综合起来，如果我们有了生成器的周期，以下列表展示了我们如何在 Q# 中使用它来编写 `MaybeFactorsFromPeriod`。函数名以“maybe”开头，因为找到的周期可能不会满足了解数的信息所必需的条件。
- en: 'Listing 12.3 operations.qs: computing possible factors from a period'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.3 operations.qs：从周期计算可能的因子
- en: '[PRE2]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ To compute possible factors from a period, we need to take inputs for the
    number *N* that we’re trying to factor, the period *r*, and the generator.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 要从周期计算可能的因子，我们需要为要分解的数 *N*、周期 *r* 和生成器提供输入。
- en: ❷ If either *g*^(*r*/2) + 1 or *g*^(*r*/2) − 1 is a multiple of *N*, we can’t
    find any factors and need to try again. The Bool output lets the caller know to
    retry.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果 *g*^(*r*/2) + 1 或 *g*^(*r*/2) − 1 是 *N* 的倍数，我们就无法找到任何因子，需要再次尝试。布尔输出让调用者知道需要重试。
- en: ❸ If the period is odd, we can’t use the *x*² − 1 = (*x* + 1)(*x* − 1) trick,
    so we start by checking that the period is even.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果周期是奇数，我们不能使用 *x*² − 1 = (*x* + 1)(*x* − 1) 的技巧，所以我们首先检查周期是否为偶数。
- en: ❹ The Q# function Microsoft.Quantum.Math.ExpModI returns modular arithmetic
    exponentials of the form *g*^x mod *N*. We can use that to find *g*^(*r*/2) mod
    *N* given *g*, *r*, and *N*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ Microsoft.Quantum.Math.ExpModI 函数返回形式为 *g*^x mod *N* 的模算术指数。我们可以利用这个函数来找到给定
    *g*、*r* 和 *N* 的情况下 *g*^(*r*/2) mod *N*。
- en: ❺ Checks that *g*^(*r*/2) + 1 is not a multiple of *N*, so we know it’s safe
    to continue
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 检查 *g*^(*r*/2) + 1 是否是 *N* 的倍数，因此我们知道可以安全地继续
- en: ❻ The GCD tells us if one of our guesses has a common factor with *N*. If our
    guess has no common factors, the GCD returns 1\. This checks both guesses and
    takes whichever gives something other than 1.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 最大公约数告诉我们我们的猜测中是否有一个与 *N* 有公共因子。如果我们的猜测没有公共因子，最大公约数返回 1。这检查了两个猜测，并取了除了 1 以外的任何结果。
- en: 'Now that we know how to convert a period to potential factors, let’s see the
    core of Shor’s algorithm: using phase estimation to estimate the period of our
    generator. To do so, we’ll use what we’ve learned throughout the rest of the book
    together with a couple of new Q# operations to do arithmetic on a quantum computer.
    Let’s jump in!'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何将周期转换为潜在的因子，让我们看看 Shor 算法的核心：使用相位估计来估计生成器的周期。为此，我们将使用本书其余部分所学的内容以及一些新的
    Q# 操作，在量子计算机上进行算术运算。让我们开始吧！
- en: 'Deep dive: Here’s looking at Euclid'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 深入探讨：这里看看欧几里得
- en: Earlier, we used the `GreatestCommonDivisorI` function provided with the Q#
    standard libraries to compute the GCD of two integers. This function works by
    using Euclid’s algorithm, which recursively attempts to divide an integer into
    another integer until no remainder is left over.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们使用了 Q# 标准库中提供的 `GreatestCommonDivisorI` 函数来计算两个整数的最大公约数。这个函数通过使用欧几里得算法，递归地尝试将一个整数除以另一个整数，直到没有余数为止。
- en: 'Suppose that we want to find the GCD of two integers *a* and *b*. We begin
    Euclid’s algorithm by finding two additional integers *q* and *r* (short for “quotient”
    and “remainder”) such that *a* = *qb* + *r*. It’s straightforward to find *q*
    and *r* using integer division instructions, so this step isn’t too hard on a
    classical computer. At that point, if *r* = 0, we’re done: *b* is a divisor of
    both *a* and of itself, so there can’t possibly be a larger common divisor. If
    not, we know the GCD of *a* and *b* has to also be a divisor of *r*, so we can
    recurse by finding the GCD of *b* and *r*, instead. Eventually, this process has
    to end, since the integers whose GCD we’re looking for get smaller and smaller
    as we go but never become negative.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要找到两个整数 *a* 和 *b* 的最大公约数。我们通过找到两个额外的整数 *q* 和 *r*（简称“商”和“余数”）来开始欧几里得算法，使得
    *a* = *qb* + *r*。使用整数除法指令找到 *q* 和 *r* 是直截了当的，所以在经典计算机上这一步并不太难。在那个点上，如果 *r* = 0，我们就完成了：*b*
    是 *a* 和它自己的除数，所以不可能有一个更大的公约数。如果不是，我们知道 *a* 和 *b* 的最大公约数也必须是 *r* 的除数，因此我们可以通过找到
    *b* 和 *r* 的最大公约数来递归。最终，这个过程必须结束，因为我们正在寻找的整数的最大公约数会随着我们的进行而越来越小，但永远不会变成负数。
- en: To make things a bit more concrete, we can work through the example from listing
    12.2, as shown in the following table.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情更加具体，我们可以通过以下表格来处理列表 12.2 中的示例。
- en: Using Euclid’s algorithm to find the GCD of 678 and 390
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用欧几里得算法求 678 和 390 的最大公约数
- en: '| *a* | *b* | *q* | *r* |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| *a* | *b* | *q* | *r* |'
- en: '| 678 | 390 | 1 | 288 |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 678 | 390 | 1 | 288 |'
- en: '| 390 | 288 | 1 | 102 |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 390 | 288 | 1 | 102 |'
- en: '| 288 | 102 | 2 | 84 |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 288 | 102 | 2 | 84 |'
- en: '| 102 | 84 | 1 | 18 |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 102 | 84 | 1 | 18 |'
- en: '| 84 | 18 | 4 | 12 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 84 | 18 | 4 | 12 |'
- en: '| 18 | 12 | 1 | 6 |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 18 | 12 | 1 | 6 |'
- en: '| 12 | 6 (answer) | 2 | 0 (done) |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 6 (答案) | 2 | 0 (完成) |'
- en: 12.4 Quantum arithmetic
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.4 量子算术
- en: We have seen quite a few different parts of the Q# standard libraries by now,
    and with the focus of this chapter on arithmetic, it makes sense to introduce
    some functions and operations from the `Microsoft.Quantum.Arithmetic` namespace
    provided by the numerics library for Q#. As you might guess, this namespace provides
    lots of helpful functions, operations, and types that simplify doing arithmetic
    in quantum systems. In particular, we can use implementations for things like
    adding and multiplying numbers represented in qubit registers with support for
    multiple-qubit register encodings like `BigEndian` (where the least significant
    bit is on the left) and `LittleEndian` (where the least significant bit is on
    the right). Let’s look at some example code using the Q# numerics library to add
    two integers.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了Q#标准库的许多不同部分，而本章的重点是算术，因此介绍一些由Q#的数值库提供的`Microsoft.Quantum.Arithmetic`命名空间中的函数和操作是有意义的。正如你可能猜到的，这个命名空间提供了许多有用的函数、操作和类型，这些都可以简化在量子系统中进行算术运算。特别是，我们可以使用支持像`BigEndian`（最低有效位在左侧）和`LittleEndian`（最低有效位在右侧）这样的多量子位寄存器编码的添加和乘法等操作的实现。让我们看看使用Q#数值库添加两个整数的示例代码。
- en: Note A Q# notebook in the samples repo ([https://github.com/crazy4pi314/ learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp))
    has all of these snippets written out for you!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在samples仓库中的Q#笔记本（[https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp)）中，所有这些片段都已为你编写出来！
- en: First, since the numerics package is not loaded by default, we need to ask the
    Q# kernel to load it with the magic command `%package`. The `%package` magic command
    adds a new package to our IQ# session, making the functions, operations, and user-defined
    types implemented by that package available to us in our session.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，由于数值包默认没有加载，我们需要使用魔法命令`%package`请求Q#内核加载它。`%package`魔法命令将一个新的包添加到我们的IQ#会话中，使得该包实现的函数、操作和用户定义的类型在我们的会话中可用。
- en: To make things easier, we can also turn off displaying small amplitudes from
    diagnostic outputs like `DumpMachine`, as shown in the next listing.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化操作，我们还可以关闭显示来自诊断输出（如`DumpMachine`）的小振幅，如下一个列表所示。
- en: Listing 12.4 Loading packages and setting preferences in IQ#
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.4 在IQ#中加载包和设置首选项
- en: '[PRE3]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Uses %package to load the Microsoft.Quantum.Numerics package, which provides
    additional operations and functions for working with numbers represented by registers
    of qubits
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用`%package`加载Microsoft.Quantum.Numerics包，该包提供了用于处理由量子位寄存器表示的数字的额外操作和函数。
- en: ❷ After running %package, IQ# reports what packages are currently available
    in our IQ# session. Your version numbers will likely vary.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 运行`%package`后，IQ#会报告我们当前IQ#会话中可用的包。你的版本号可能会有所不同。
- en: ❸ The %config magic command sets various preferences for our current IQ# session.
    Here, for example, we can use %config to tell the DumpRegister and DumpMachine
    callables to leave out parts of each state vector that have very small amplitudes.
    That makes it much easier to visualize states on several qubits, as printing out
    each computational basis state can quickly get unwieldy.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ `%config`魔法命令设置我们当前IQ#会话的各种首选项。例如，我们可以使用`%config`来告诉`DumpRegister`和`DumpMachine`可调用对象省略每个状态向量中具有非常小振幅的部分。这使得在多个量子位上可视化状态变得容易得多，因为打印出每个计算基态可能会很快变得难以控制。
- en: Tip When we’re working with Q# from within Jupyter Notebooks, the IQ# kernel
    provides several other magic commands to help write quantum programs, in addition
    to commands like `%simulate`, `%package`, and `%config` that we’ve seen so far.
    For a complete list, check out the documentation at [https://docs.microsoft.com/qsharp/api/iqsharp-magic](https://docs.microsoft.com/qsharp/api/iqsharp-magic).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：当我们从Jupyter Notebooks内部使用Q#时，IQ#内核提供了几个其他魔法命令来帮助我们编写量子程序，除了我们之前看到的`%simulate`、`%package`和`%config`等命令之外。要获取完整列表，请查看[https://docs.microsoft.com/qsharp/api/iqsharp-magic](https://docs.microsoft.com/qsharp/api/iqsharp-magic)上的文档。
- en: 12.4.1 Adding with qubits
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4.1 使用量子位进行加法
- en: Now, let’s get to coding an example that adds two integers while they are encoded
    in qubit registers. Listing 12.5 uses the `AddI` operation to add the contents
    of two quantum registers to each other. This listing uses the `LittleEndian` UDT
    provided by the Q# standard library to mark that each register of qubits is meant
    to be interpreted as an integer using little-endian encoding (also known as *least-significant
    order*). That is, when interpreting a `LittleEndian` register as an integer, treat
    the lowest qubit index as the least significant bit. For instance, to represent
    the integer 6 as a three-qubit quantum state in little-endian notation, we write
    |011〉, since 6 = 0 × 2⁰ + 1 × 2¹ + 1 × 2² = 2 + 4.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个示例，演示在量子比特寄存器编码整数时如何将两个整数相加。列表12.5使用`AddI`操作将两个量子寄存器的内容相加。此列表使用Q#标准库提供的`LittleEndian`
    UDT来标记每个量子比特寄存器都应解释为使用小端编码（也称为*最低有效顺序*）的整数。也就是说，当将`LittleEndian`寄存器解释为整数时，将最低量子比特索引视为最低有效位。例如，为了表示整数6作为小端表示法中的三量子比特量子态，我们写|011〉，因为6
    = 0 × 2⁰ + 1 × 2¹ + 1 × 2² = 2 + 4。
- en: Listing 12.5 Using the numerics library to add integers encoded in qubits
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.5 使用数值库将量子比特编码的整数相加
- en: '[PRE4]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Our registers must be big enough to hold the largest possible sum of the two
    integers. At most, we need one more bit than is required to represent the largest
    input.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们的数据寄存器必须足够大，以便能够存储两个整数可能的最大和。最多，我们需要的位数比表示最大输入所需的位数多一位。
- en: ❷ Indicates that we want to interpret reg1 and reg2 as being integers, represented
    using little-endian encoding
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 表示我们希望将reg1和reg2解释为整数，使用小端编码表示
- en: ❸ Prepares the LittleEndian representation of an integer into the qubit register,
    since *x* ⊕ 0 = *x* whether *x* is 0 or 1
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将整数的LittleEndian表示准备到量子比特寄存器中，因为*x* ⊕ 0 = *x*，无论*x*是0还是1
- en: ❹ Using the operation AddI loaded from the numerics package, we can add integers
    represented by the two input registers qubits1 and qubits2
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用从数值包加载的操作AddI，我们可以将两个输入寄存器qubits1和qubits2表示的整数相加
- en: ❺ Resets the first register so it can be deallocated, and then measures the
    register with the results
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 重置第一个寄存器，以便可以释放它，然后测量寄存器以获得结果
- en: We can see the output of running this snippet in figure 12.4\.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在图12.4中看到运行此代码片段的输出。
- en: '![](../Images/12-4.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/12-4.png)'
- en: Figure 12.4 Output of using the numerics library to add integers encoded in
    qubit registers
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 使用数值库在量子比特寄存器中编码的整数相加的输出
- en: 12.4.2 Multiplying with qubits in superposition
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4.2 使用叠加态的量子比特进行乘法
- en: 'We have seen how to do some basic modular arithmetic in Q#, but like most of
    our quantum algorithms, unless we use uniquely quantum properties/operations,
    we just have a very, very expensive calculation. In this section, we’ll use the
    fact that we can have qubits in *superpositions* of numbers to help us gain the
    advantage we need to make Shor’s algorithm work. Fortunately, `AddI` and many
    other similar arithmetic operations work in superposition: a property we need
    to use these arithmetic operations with phase estimation in the next part of the
    chapter. Before jumping to that, though, it’s helpful to play around a little
    with what it means to add or multiply integers in superposition.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何在Q#中进行一些基本的模运算，但像我们的大多数量子算法一样，除非我们使用独特的量子属性/操作，否则我们只是进行了一次非常、非常昂贵的计算。在本节中，我们将利用我们可以有量子比特在数字的*叠加态*中的事实来帮助我们获得使Shor算法工作所需的优势。幸运的是，`AddI`和许多其他类似的算术操作可以在叠加态中工作：这是我们将在本章下一部分使用相位估计进行这些算术操作时需要使用的属性。在跳到那之前，玩一玩在叠加态中加法或乘法整数的含义可能会有所帮助。
- en: Here, we see how to apply what we’ve learned about superposition to arithmetic
    by using `MultiplyByModularInteger` as an example. Shortly, we’ll use the same
    operation to construct the oracle we need for Shor’s factoring algorithm later,
    so it’s a pretty practical application.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到如何通过使用`MultiplyByModularInteger`作为示例来应用我们关于叠加在算术中的知识。很快，我们将使用相同的操作来构建稍后用于Shor分解算法所需的预言机，所以这是一个相当实用的应用。
- en: First, let’s look at an operation that we can use to prepare a register in a
    superposition of two integers. Listing 12.6 shows how to do so using what we learned
    about the `ApplyXorInPlace` operation in the previous section and the `Controlled`
    functor in chapter 9.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看我们可以用来准备一个寄存器以两个整数的叠加态的操作。列表12.6展示了如何使用我们在上一节中学到的`ApplyXorInPlace`操作和第9章中的`Controlled`函子来完成这一操作。
- en: As we saw with other uses of `Controlled`, controlled operations do something
    when their control registers are in the all-ones state (|11⋅⋅⋅1〉). Listing 12.6
    controls on the zero state, instead, by using the `X` operation to map the |0〉
    state to the |1〉 state. By placing the call to `X` in a `within`/`apply` block,
    we make sure Q# undoes our call to `X` after we apply our controlled operation.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们通过其他 `Controlled` 的使用所看到的，当控制寄存器处于全 1 状态（|11⋅⋅⋅1〉）时，受控操作会执行某些操作。列表 12.6
    通过使用 `X` 操作将 |0〉 状态映射到 |1〉 状态，而不是使用 `X` 操作来控制零状态。通过将 `X` 的调用放在 `within`/`apply`
    块中，我们确保 Q# 在我们应用受控操作后撤销我们的 `X` 调用。
- en: Tip Using `within`/`apply` this way achieves something very similar to the `ControlledOnInt`
    function that we used in chapter 11 and is how that function is implemented in
    the Q# standard libraries.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 使用 `within`/`apply` 的这种方式实现了与我们在第 11 章中使用的 `ControlledOnInt` 函数非常相似的功能，这也是该函数在
    Q# 标准库中实现的方式。
- en: Listing 12.6 Preparing a register in a superposition of integers
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.6 准备一个整数叠加的寄存器
- en: '[PRE5]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Takes a register and a pair of integers and prepares that register in a superposition
    of those integers in a LittleEndian encoding
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 接收一个寄存器和一对整数，并以 LittleEndian 编码准备该寄存器，使其处于这些整数的叠加态
- en: ❷ Prepares our control qubit in the |+〉 = (|0〉 + |1〉) / √2 state so that when
    we control later operations on that qubit, they are also in superposition
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 准备我们的控制量子比特处于 |+〉 = (|0〉 + |1〉) / √2 状态，以便当我们随后对该量子比特进行控制操作时，它们也处于叠加态
- en: ❸ As noted previously, using X in a within/apply block lets us control on the
    |0〉 state instead of on the |1〉 state.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如前所述，在 within/apply 块中使用 X 允许我们控制 |0〉 状态而不是 |1〉 状态。
- en: '❹ Adds a new input for the control register (see chapter 9). The other input
    is a tuple with the original arguments: the integer we want to prepare as a state,
    and the register on which we want to prepare that state.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 为控制寄存器添加一个新的输入（参见第 9 章）。另一个输入是一个元组，包含原始参数：我们想要准备为状态的整数，以及我们想要在该寄存器上准备该状态的寄存器。
- en: ❺ Does the same thing with the second integer in intPair, and encodes it in
    the register as controlled on the ctrl qubit
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 对 intPair 中的第二个整数执行相同操作，并将其编码在寄存器中，作为受控于 ctrl 量子比特的状态
- en: ❻ Adds some phase to one of the two branches of our superposition by using the
    Y operation to rotate, controlled on our control qubit being in the |1〉 state
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 通过使用 Y 操作旋转，并在我们的控制量子比特处于 |1〉 状态时进行控制，向我们的叠加态的两个分支之一添加一些相位
- en: Tip The `Y` operation isn’t needed in this case, but it helps us see how the
    phase applied by the controlled `Y` operation propagates through later steps.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 在这种情况下不需要 `Y` 操作，但它有助于我们了解受控 `Y` 操作施加的相位如何传播到后续步骤。
- en: Once we have a quantum register representing the superposition of two integers,
    we can apply other arithmetic operations across that superposition. In the following
    listing, for instance, we use the `DumpMachine` callable to see how the state
    of our register changes when using the `MultiplyByModularInteger` operation provided
    by the Q# standard libraries.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个表示两个整数叠加的量子寄存器，我们就可以在该叠加上应用其他算术操作。在下面的列表中，例如，我们使用 `DumpMachine` 可调用函数来查看当使用
    Q# 标准库提供的 `MultiplyByModularInteger` 操作时，我们的寄存器状态如何变化。
- en: Listing 12.7 Using the numerics library to multiply in superposition
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.7 使用数值库在叠加中进行乘法
- en: '[PRE6]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ The first thing we need to do is allocate a big enough register. Here, since
    we are doing modular multiplication, the largest possible value our register has
    to hold is modulus − 1.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们需要做的第一件事是分配一个足够大的寄存器。在这里，由于我们正在进行模乘法，寄存器必须能够持有的最大可能值是模数 - 1。
- en: ❷ Uses the operation we defined in listing 12.6 to prepare our target register
    in a superposition of integers
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用列表 12.6 中定义的操作来准备我们的目标寄存器，使其处于整数的叠加态
- en: ❸ The numerics package provides MultiplyByModularInteger, which takes a LittleEndian
    register and multiplies it by the value of a classical multiplier, modulo a given
    modulus.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 数值包提供了 MultiplyByModularInteger 函数，它接受一个 LittleEndian 寄存器，并将其乘以经典乘数，模一个给定的模数。
- en: ❹ Measures a register, and returns the classical Int represented by that register
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 测量一个寄存器，并返回由该寄存器表示的经典 Int
- en: 'If we run the code in listings 12.6 and 12.7 in the sample notebook, we see
    the output shown in figure 12.5: the registers correctly show a superposition
    of 2 and 3 before multiplication and then show a superposition of 1 and 6 afterward.
    What would we expect the correct output to be? If we multiply as usual, it should
    be 6 and 9; but since we are doing arithmetic mod 8, the 9 is 1\. When we then
    measure that register, we get 6 half the time and 1 the other half since they
    are in an equal superposition, as we can see from the state amplitude bars depicted
    in figure 12.5.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在示例笔记本中运行列表 12.6 和 12.7 中的代码，我们会看到图 12.5 所示的输出：在乘法之前，寄存器正确地显示了 2 和 3 的叠加，然后显示乘法之后的
    1 和 6 的叠加。我们期望正确的输出是什么？如果我们像平常一样乘法，应该是 6 和 9；但由于我们在模 8 的算术中进行运算，9 是 1。当我们测量该寄存器时，我们有一半的时间得到
    6，另一半时间得到 1，因为它们处于相等的叠加状态，正如我们可以从图 12.5 中描述的状态振幅条中看到的那样。
- en: '![](../Images/12-5.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/12-5.png)'
- en: Figure 12.5 Output of multiplying 3 by 2 and 3 in superposition mod 8
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.5 乘以 2 和 3 的叠加模 8 的输出
- en: 'Exercise 12.4: Modular multiplication'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 12.4：模乘法
- en: Suppose that you have prepared a register in the 1 / √2 (|2〉 + |7〉) state, with
    each ket representing an integer in little-endian encoding. What state would your
    register be in after multiplying by 5 modulo 9? Write a Q# program that uses `DumpMachine`
    to confirm your answer.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已将寄存器准备在 1 / √2 (|2〉 + |7〉) 状态，每个基态表示一个以小端编码的整数。在用 5 模 9 乘法之后，你的寄存器将处于什么状态？写一个
    Q# 程序，使用 `DumpMachine` 来确认你的答案。
- en: 'Exercise 12.5: Bonus'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 12.5：附加题
- en: If you run the same program as in the previous exercise but try to multiply
    by 3 modulo 9, you’ll get an error. Why?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行与上一练习相同的程序，但尝试用 3 乘以模 9，你会得到一个错误。为什么？
- en: '*Hint*: Consider what you learned in chapter 8 has to be true of a classical
    function in order for it to be represented by a quantum oracle. If you’re stuck,
    the answer is provided next, lightly hidden using [https://rot13.com](https://rot13.com).'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*提示*：考虑你在第 8 章中学到的关于经典函数必须满足的条件，以便它能够被量子或然子表示。如果你卡住了，答案将在下面提供，使用 [https://rot13.com](https://rot13.com)
    轻微隐藏。'
- en: '*Answer*: Zhygvcylvat ol guerr zbq avar vf abg erirefvoyr. Sbe vafgnapr, obgu
    bar gvzrf guerr naq sbhe gvzrf guerr zbq avar tvir mreb, rira gubhtu bar naq sbhe
    nera’g rdhny zbq avar. Fvapr pynffvpny shapgvbaf unir gb or erirefvoyr va beqre
    gb or ercerfragrq ol dhnaghz bcrengvbaf, gur `ZhygvcylOlZbqhyneVagrtre` envfrf
    na reebe va guvf pnfr.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案*：Zhygvcylvat ol guerr zbq avar vf abg erirefvoyr. Sbe vafgnapr, obgu bar
    gvzrf guerr naq sbhe gvzrf guerr zbq avar tvir mreb, rira gubhtu bar naq sbhe
    nera’g rdhny zbq avar. Fvapr pynffvpny shapgvbaf unir gb or erirefvoyr va beqre
    gb or ercerfragrq ol dhnaghz bcrengvbaf, gur `ZhygvcylOlZbqhyneVagrtre` envfrf
    na reebe va guvf pnfr.'
- en: 'Note Notice what we’ve done here: we’ve used a quantum program to multiply
    an integer represented by a quantum register by a classical integer. The computation
    happens entirely on the quantum device and doesn’t use any measurement; that means
    when our register starts in superposition, *the multiplication happens in superposition*
    as well.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：注意我们在这里做了什么：我们使用量子程序乘以由量子寄存器表示的整数和经典整数。计算完全在量子设备上完成，不使用任何测量；这意味着当我们的寄存器以叠加状态开始时，*乘法也在叠加中进行*。
- en: 12.4.3 Modular multiplication in Shor’s algorithm
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4.3 Shor 算法中的模乘法
- en: Now that we have seen a bit of the numerics library, let’s return to the factoring
    scenario. The main places from algorithm 12.1 where we need to do some modular
    arithmetic and utilize the numerics library are steps 3 and 4 (repeated next).
    We can implement three operations to make short work of implementing those steps
    of Shor’s algorithm and help us get to factoring integers.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了一些数值库，让我们回到分解场景。算法 12.1 中我们需要进行一些模运算并利用数值库的主要地方是步骤 3 和 4（下面重复）。我们可以实现三个操作来简化
    Shor 算法中这些步骤的实现，并帮助我们分解整数。
- en: The first operation we can take a look at from the sample code in this chapter
    implements step 3 of algorithm 12.1, the `EstimateFrequency` operation (listing
    12.8).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从本章示例代码中查看的第一个操作实现了算法 12.1 的步骤 3，即 `EstimateFrequency` 操作（列表 12.8）。
- en: '*Algorithm 12.1, steps 3 and 4 (pseudocode for factoring an integer with Shor’s
    algorithm)*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*算法 12.1，步骤 3 和 4（Shor 算法分解整数的伪代码）*'
- en: Use iterative phase estimation to find the *frequency* of the classical function
    *f*(*x*) = *a^x* mod *N*. The frequency tells us about how quickly *f* returns
    to the same value as *x* increases.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用迭代相位估计来找到经典函数 *f*(*x*) = *a^x* mod *N* 的 *频率*。频率告诉我们当 *x* 增加时，*f* 多快会回到相同的值。
- en: Use a classical algorithm known as *continued fractions expansion* to convert
    the frequency from the previous step into a period (*r*). The period *r* should
    then have the property that *f*(*x*) = *f*(*x* + *r*) for all inputs *x*.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一个名为**连分数展开**的经典算法将前一步骤中的频率转换为周期（*r*）。周期*r*应该具有这样的性质：对于所有输入*x*，*f*(x) = *f*(x
    + *r*)。
- en: Tip This operation uses the phase estimation operations provided with the Q#
    standard libraries and that we saw in chapter 10\. If you need a refresher, head
    back to chapter 9 for an overview of phase estimation or chapter 10 for how to
    run phase estimation with the standard libraries.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：此操作使用Q#标准库中提供的相位估计操作，我们在第10章中已经看到过。如果您需要复习，请回到第9章了解相位估计的概述，或回到第10章了解如何使用标准库运行相位估计。
- en: 'Listing 12.8 operations.qs: learning a generator’s frequency with phase estimation'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.8 operations.qs：使用相位估计学习生成器的频率
- en: '[PRE7]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Since this is the primary step that uses qubits, we need to allocate a register
    that is big enough to represent the modulus.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 由于这是使用量子比特的主要步骤，我们需要分配一个足够大的寄存器来表示模数。
- en: ❷ The freshly allocated register has to specify how to encode the integers it
    will be representing so we can use the LittleEndian UDT to wrap our newly allocated
    register.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 新分配的寄存器必须指定如何编码它将要表示的整数，因此我们可以使用LittleEndian UDT来包装我们新分配的寄存器。
- en: ❸ Takes an Int and XORs it with the integer stored in the register provided
    in the second argument. Since registerLE starts as 0, this prepares the register
    as 1.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 接收一个整数，并将其与第二个参数提供的寄存器中存储的整数进行异或运算。由于registerLE从0开始，这会将寄存器准备为1。
- en: ❹ Uses RobustPhaseEstimation (see chapter 10) to learn the phase of inputOracle,
    and passes a quantum register and the number of bits of precision to which we
    want the phase estimated
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用RobustPhaseEstimation（见第10章）学习inputOracle的相位，并传递一个量子寄存器和我们想要估计的相位精度的位数。
- en: ❺ Wrapping inputOracle in the DiscreteOracle UDT makes it clear to RobustPhaseEstimation
    that we want inputOracle to be interpreted as an oracle.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将inputOracle包装在DiscreteOracle UDT中，使RobustPhaseEstimation清楚地知道我们希望inputOracle被解释为或门。
- en: ❻ Once the phase estimation is done, resets all the qubits in the register
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 一旦完成相位估计，就重置寄存器中的所有量子比特。
- en: '❼ The phase we estimated is just that: a phase. This equation converts it to
    a frequency: (phase * 2^(nBitsPrecision) − 1) / *π*.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 我们估计的相位就是相位本身。此方程将其转换为频率：（相位 * 2^(nBitsPrecision) − 1) / *π*。
- en: 'Now that we have the scaffolding for `EstimateFrequency` under our belt, we
    can take a look at an operation that implements the oracle we need for this algorithm.
    The `ApplyPeriodFindingOracle` operation is just that: an operation that is structured
    like an oracle for the function *f*(power) = generator^(power) mod modulus. The
    next listing shows an implementation of `ApplyPeriodFindingOracle`.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了`EstimateFrequency`的框架，我们可以看看实现此算法所需的或门的操作。`ApplyPeriodFindingOracle`操作正是这样：一个结构类似于函数*f*(power)
    = generator^(power) mod modulus的或门的操作。下一个列表显示了`ApplyPeriodFindingOracle`的实现。
- en: 'Listing 12.9 operations.qs: implementing an oracle for the function *f*'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.9 operations.qs：实现函数*f*的或门
- en: '[PRE8]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Does some input checking that the provided generator and modulus are coprime
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对提供的生成器和模数进行一些输入检查，确保它们互质。
- en: ❷ The same as in listing 12.7\. Here, it helps this oracle multiply the integer
    represented in the target register by *f*(power) = generator^(power) mod modulus.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 与列表12.7中的相同。这里，它帮助这个或门将目标寄存器中表示的整数乘以*f*(power) = generator^(power) mod modulus。
- en: ❸ Microsoft.Quantum.Math also has the ExpModI function, which allows us to easily
    calculate *f*(power) = generator^(power) mod modulus.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ Microsoft.Quantum.Math还提供了ExpModI函数，它允许我们轻松计算*f*(power) = generator^(power)
    mod modulus。
- en: ❹ LittleEndian tells us that the qubit register that ApplyPeriodFindingOracle
    takes is interpreted as an integer in the little-endian encoding.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ LittleEndian告诉我们，ApplyPeriodFindingOracle函数所接受的量子比特寄存器是以小端编码方式解释为整数的。
- en: 'The previous two operations form the basis for step 3 of algorithm 12.1\. Now
    we need an operation that takes care of step 4, where we convert the estimated
    frequency of the generator to a period. The operation `EstimatePeriod` in the
    following listing does just that: given a `generator` and a `modulus`, it repeats
    estimating the frequency using `EstimateFrequency` and uses the continued fractions
    algorithm to ensure that the estimated frequency yields a valid period.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个操作构成了算法 12.1 的第 3 步的基础。现在我们需要一个操作来处理第 4 步，即将生成器的估计频率转换为周期。以下列表中的 `EstimatePeriod`
    操作正是这样做的：给定一个 `generator` 和一个 `modulus`，它重复使用 `EstimateFrequency` 估计频率，并使用连分数算法确保估计的频率产生一个有效的周期。
- en: 'Listing 12.10 operations.qs: estimating periods from frequencies'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.10 operations.qs：从频率估计周期
- en: '[PRE9]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Does some input checking that the provided generator and modulus are coprime
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对提供的生成器和模数是否互质进行一些输入检查。
- en: ❷ The IsCoprimeI function from the Microsoft.Quantum.Math namespace simplifies
    checking whether the generator and modulus are coprime.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Microsoft.Quantum.Math 命名空间中的 IsCoprimeI 函数简化了检查生成器和模数是否互质的操作。
- en: ❸ The largest integer a register of qubits would need to hold is the modulus,
    so we use BitSizeI to help calculate the number of bits such that modulus ≤ 2^({#
    of bits}).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 一个量子比特寄存器需要存储的最大整数是模数，因此我们使用 BitSizeI 来帮助计算位数，使得模数 ≤ 2^({# of bits})。
- en: '❹ To use a floating-point to represent *k*/*r* where *r* is the period and
    *k* is some other integer, we need enough bits of precision to approximate *k*/*r*:
    that is, one more bit than required to represent both *k* and *r*.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 要使用浮点数来表示 *k*/*r*（其中 *r* 是周期，*k* 是另一个整数），我们需要足够的精度位来近似 *k*/*r*：即比表示 *k* 和
    *r* 所需的位数多一位。
- en: ❺ The result mutable variable keeps track of our current best guess for a period
    as we repeat the “repeat” block.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 结果可变变量跟踪我们在重复“repeat”块时的当前最佳周期猜测。
- en: ❻ Repeats the frequency estimation steps as many times as necessary to ensure
    that we have a viable period estimate to move forward with
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 重复频率估计步骤，直到我们有足够的周期估计值可以继续前进。
- en: ❼ Calls the EstimateFrequency operation that we looked at earlier and passes
    it the appropriate arguments
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ⓬ 调用我们之前查看的 EstimateFrequency 操作，并传递适当的参数。
- en: ❽ Partially applies ApplyPeriodFindingOracle to ensure that EstimateFrequency
    can apply it to the right power and register values
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 部分应用 ApplyPeriodFindingOracle 以确保 EstimateFrequency 可以将其应用于正确的幂和寄存器值
- en: ❾ If frequencyEstimate is 0, we need to try again, since that doesn’t make sense
    as a period (1/0). If we get 0, then the “repeat” block runs again, as the “until”
    condition isn’t met in that case.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 如果频率估计值为 0，则需要再次尝试，因为那不是一个合理的周期（1/0）。如果我们得到 0，那么“repeat”块将再次运行，因为在这种情况下“until”条件不满足。
- en: ❿ Captures step 4 of algorithm 12.1, which uses the continued fractions algorithm
    in the Q# standard library to calculate the period from the frequency.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 捕获算法 12.1 的第 4 步，该步骤使用 Q# 标准库中的连分数算法从频率计算周期。
- en: ⓫ Repeats the frequency estimation and period calculation until we have a period
    such that generatorresult mod modulus = 1.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 重复频率估计和周期计算，直到我们得到一个周期，使得生成器结果模模数等于 1。
- en: ⓬ If the “until” condition is not met, then the fixup block is run, which just
    issues a message that it is going to try again.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ⓬ 如果“until”条件未满足，则运行修复块，它只是发出一条消息，表示它将再次尝试。
- en: With this last operation, we have all the code we need to fully implement Shor’s
    algorithm! In the next section, we’ll put it all together and explore the implication
    of this integer factoring algorithm.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个最后的操作，我们拥有了完全实现 Shor 算法所需的所有代码！在下一节中，我们将把它们全部放在一起，并探讨这个整数分解算法的含义。
- en: 12.5 Putting it all together
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.5 将一切整合
- en: We have now learned and practiced all the skills it takes to program and run
    Shor’s algorithm. The quantum part of Shor’s algorithm was pretty familiar, thanks
    to what we learned in chapters 9 and 10 about phase estimation; and we worked
    through classical algebra that links the tasks of factoring numbers and finding
    the period of a generator. This is no small feat—you should be quite proud of
    yourself for making it this far in your quantum journey!
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学习和实践了编写和运行 Shor 算法所需的所有技能。Shor 算法的量子部分相当熟悉，这得益于我们在第 9 章和第 10 章中关于相位估计的学习；并且我们解决了将分解数字和寻找生成器周期联系起来的经典代数问题。这并非易事——你应该为自己的量子之旅走到这一步而感到自豪！
- en: Continued fraction convergents
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 连分数收敛
- en: 'You may have noticed one other bit of classical math happening in Shor’s algorithm
    that we haven’t touched on yet. In particular, the `PeriodFromFrequency` function
    is called on the output we get from phase estimation before continuing:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了Shor算法中发生的一个其他经典数学问题，我们还没有涉及。特别是，在继续之前，我们在相位估计的输出上调用`PeriodFromFrequency`函数：
- en: '[PRE10]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is needed because phase estimation doesn’t tell us *exactly* what we need.
    Instead of telling us *how long* it takes our function to spin around a clock
    (the period of our function), it tells us how *fast* our function spins around
    said clock: something more like a frequency. Unfortunately, we can’t do something
    like taking the reciprocal of our frequency to get back to our period, as we’re
    looking for the period as an integer. Thus, if we get a frequency estimate of
    *f*, we need to search near *f*/2*n* for the closest fraction of the form *N*/*r*
    to find our period *r*.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为相位估计并没有告诉我们我们确切需要什么。它不是告诉我们我们的函数围绕时钟旋转需要多长时间（函数的周期），而是告诉我们我们的函数围绕这个时钟旋转有多快：更像是频率。不幸的是，我们不能像取频率的倒数来回到我们的周期一样做，因为我们正在寻找一个整数的周期。因此，如果我们得到频率估计为*f*，我们需要在*f*/2*n*附近搜索最接近的分数形式*N*/*r*来找到我们的周期*r*。
- en: This is an entirely classical arithmetic problem and has fortunately been well
    solved using a technique known as *continued fraction convergents*. This solution
    is made available in the Q# standard libraries by the `ContinuedFractionConvergentI`
    function, making it easy to go from the estimate we get from phase estimation
    to something about the period of our function.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个完全经典的算术问题，幸运的是，它已经通过一种称为**连分数收敛**的技术得到了很好的解决。这个解决方案通过`ContinuedFractionConvergentI`函数在Q#标准库中提供，使得从相位估计得到的估计值到关于函数周期的某些信息变得容易转换。
- en: Let’s take a moment to review the `FactorSemiprimeInteger` operation that we
    saw at the beginning of the chapter, in light of what we have now learned. If
    you need a refresher, check out figure 12.6.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间回顾一下我们在本章开头看到的`FactorSemiprimeInteger`操作，考虑到我们现在所学的知识。如果你需要复习，请查看图12.6。
- en: '![](../Images/12-6.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/12-6.png)'
- en: Figure 12.6 Shor’s algorithm represented as a flowchart. To factor an integer
    *N*, Shor’s algorithm uses phase estimation and a quantum computer to find the
    *period* of a function that takes powers of another integer *a* using modular
    arithmetic mod *N*. After some classical post-processing, that period can be used
    to find the factors of *N*.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 将Shor算法表示为流程图。为了分解整数*N*，Shor算法使用相位估计和量子计算机来找到函数的周期，该函数使用模运算mod*N*对另一个整数*a*的幂进行运算。经过一些经典的后处理，该周期可以用来找到*N*的因子。
- en: 'Listing 12.11 operations.qs: factoring semiprime integers with Shor’s algorithm'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.11 operations.qs：使用Shor算法分解半素数整数
- en: '[PRE11]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Checks whether the integer to factor is even. If so, then 2 is a factor, and
    we can stop early.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查要分解的整数是否为偶数。如果是，那么2是一个因子，我们可以提前停止。
- en: ❷ Uses the mutable variable factors to keep track of the factors we find for
    “number” as we step through the algorithm.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用可变变量`factors`来跟踪我们在算法步骤中找到的“number”的因子。
- en: ❸ Uses the mutable flag foundFactors to keep track of whether we find any factors
    for “number” as we step through the algorithm
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用可变标志`foundFactors`来跟踪我们在算法步骤中是否找到“number”的因子。
- en: ❹ Implements step 1 in algorithm 12.1, using DrawRandomInt to select a random
    integer in the range from 1 to “number” − 1 as our generator
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 实现算法12.1中的步骤1，使用`DrawRandomInt`在1到“number”-1的范围内选择一个随机整数作为我们的生成器。
- en: ❺ Step 2 in algorithm 12.1, where we verify that the generator is coprime to
    the integer we want to factor; if it’s not, the “else” clause handles returning
    the common factor between the two.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 算法12.1中的步骤2，其中我们验证生成器是否与我们要分解的整数互质；如果不是，则“else”子句处理返回两个之间的公共因子。
- en: ❻ Covers steps 3 and 4 in algorithm 12.1\. It returns a period that it computes
    with continued fractions from the frequency estimation inside EstimatePeriod.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 覆盖算法12.1中的步骤3和4。它返回一个通过从EstimatePeriod内部的频率估计中计算出的连分数得到的周期。
- en: ❼ Uses algebra to turn the estimated period into integers that might be factors.
    Sometimes it fails, so it also returns a Bool value indicating whether it succeeded.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 使用代数将估计的周期转换为可能是因子的整数。有时它可能失败，因此它还返回一个Bool值，指示是否成功。
- en: ❽ Handles the case that the generator we guessed at the beginning has a common
    factor with the number we are trying to factor
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 处理这种情况：我们在一开始猜测的生成器与我们要分解的数有一个公共因子。
- en: ❾ Adds the condition for how long we should repeat the preceding block. Here
    we want to continue looking until we find the factors we are looking for.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 添加重复前面块的持续时间条件。这里我们希望继续寻找，直到找到我们想要的因子。
- en: ❿ Tells the program what to do before repeating the main loop. Here we have
    it let us know that our Q# program will try again.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 在重复主循环之前告诉程序要做什么。这里它让我们知道我们的Q#程序将再次尝试。
- en: ⓫ Returns the tuple of factors for the input integer
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 返回输入整数的因子元组
- en: Here’s what it looks like if we run this operation in an IQ# notebook to factor
    21.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在IQ#笔记本中运行此操作以分解21，它看起来是这样的。
- en: Listing 12.12 Output of running `FactorSemiprimeInteger`
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.12 运行`FactorSemiprimeInteger`的输出
- en: '[PRE12]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ To call the FactorSemiprimeInteger operation from within a notebook, it’s
    helpful to write a new operation that provides the input 21.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 要在笔记本中调用`FactorSemiprimeInteger`操作，编写一个新的操作来提供输入21是有帮助的。
- en: 'Each time, our code correctly returned the prime factors of 21: 3 and 7\. The
    operation was run three times to show some possible different outcomes we might
    get. In `In [2]`, when we tried to guess a generator, our call to `DrawRandomInt`
    ended up returning an integer that was not coprime to 21\. Thus, we were able
    to use `GreatestCommonDivisorI` to find a factorization. In `In [3]`, our call
    to `DrawRandomInt` selected a generator of 19 and then had to run the frequency
    estimation twice to ensure that the continued fractions algorithm succeeded. In
    the final run, `In [4]`, one full round of the period-finding task completed but
    failed to yield a correct factor; and when it tried to pick a new generator, it
    guessed a factor by accident.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们的代码都正确地返回了21的质因子：3和7。操作运行了三次，以展示我们可能得到的一些不同结果。在`In [2]`中，当我们尝试猜测一个生成器时，我们的`DrawRandomInt`调用最终返回了一个与21不互质的整数。因此，我们能够使用`GreatestCommonDivisorI`找到分解。在`In
    [3]`中，我们的`DrawRandomInt`选择了一个生成器19，然后必须运行两次频率估计以确保连续分数算法成功。在最后的运行中，`In [4]`，周期查找任务完成了一轮，但没有产生正确的因子；当它尝试选择一个新的生成器时，意外地猜测了一个因子。
- en: Note Given the limitations of running this on simulators or small hardware devices,
    we will frequently guess the correct factors when selecting the generator. We’ll
    also get unlucky more often with small integers, guessing trivial factors like
    1\. These edge cases happen less often as the number we are trying to factor increases.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：鉴于在模拟器或小型硬件设备上运行的局限性，我们将在选择生成器时经常猜测正确的因子。我们也会在小整数上更频繁地运气不佳，猜测像1这样的平凡因子。随着我们试图分解的数字的增加，这些边缘情况发生的频率会降低。
- en: Using a simulator on a laptop, a desktop, or in the cloud, we likely won’t be
    able to factor anything terribly large with Shor’s algorithm. For example, it
    would be quite challenging to factor a 30-bit number by simulating Shor’s algorithm
    on a classical computer, but 40-bit numbers were already considered woefully insufficient
    at standing up against classical factoring algorithms in 1992\. This might seem
    like it makes Shor’s algorithm useless, but all it really tells us is that it’s
    hard to use a classical computer to simulate large quantum programs; we saw why
    that was the case in chapters 4 and 5.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 使用笔记本电脑、台式机或云中的模拟器，我们可能无法使用Shor算法分解任何特别大的数字。例如，在经典计算机上模拟Shor算法来分解30位数字将非常具有挑战性，但在1992年，40位数字已经被认为在抵御经典分解算法方面严重不足。这可能会让人觉得Shor算法毫无用处，但它真正告诉我们的是，使用经典计算机模拟大型量子程序很难；我们在第4章和第5章中看到了为什么是这样的情况。
- en: Indeed, since the same algorithm works for much larger numbers (using 4,096-bit
    keys isn’t overkill for protecting personal data, for example), such as those
    commonly used to protect data online, understanding how Shor’s algorithm and other
    similar quantum algorithms work can help us appreciate the assumptions that go
    into modern uses of cryptography and what else we need going forward.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，由于相同的算法适用于更大的数字（例如，使用4096位密钥来保护个人数据并不过度，例如），这些数字通常用于在线保护数据，理解Shor算法和其他类似量子算法的工作原理可以帮助我们欣赏现代加密应用中涉及的假设以及我们未来还需要什么。
- en: What’s next for privacy?
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 隐私的下一步是什么？
- en: Given what we’ve learned about Shor’s algorithm, it might seem as though the
    cryptography that protects everything from our health records to our chat history
    is doomed. Fortunately, there are both quantum technologies (such as quantum key
    distribution, which we learned about in chapter 3) and new classical technologies
    meant to resist algorithms such as Shor’s. The latter class of technologies, known
    as *post-quantum cryptography*, is the subject of much ongoing research and exploration.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们对Shor算法的了解，可能会觉得保护我们健康记录到聊天记录的密码学似乎已经注定要失败。幸运的是，既有量子技术（如我们在第3章中了解到的量子密钥分发）和旨在抵抗如Shor算法等算法的新经典技术。后者被称为*后量子密码学*，是当前许多研究探索的主题。
- en: As it turns out, Q# can play an important role in cryptography research by making
    it easier to understand how large a quantum computer would be required to attack
    a given cryptosystem. For instance, researchers at Google recently used Q# and
    Python to improve the cost required to implement the modular multiplication step
    of Shor’s algorithm,^a helping them estimate that 20 million qubits would be required
    to attack reasonable RSA instances using current quantum algorithms.^b Similarly,
    [https://github.com/Microsoft/grover-blocks](https://github.com/Microsoft/grover-blocks)
    is a great example of using Q# to understand how Grover’s algorithm (from chapter
    11) affects symmetric-key algorithms like AES.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Q#可以通过使理解需要多少量子计算机来攻击特定的密码系统变得更加容易，在密码学研究领域发挥重要作用。例如，谷歌的研究人员最近使用Q#和Python改进了Shor算法中模乘步骤的成本，这帮助他们估计，使用当前的量子算法攻击合理的RSA实例需要2000万个量子位。同样，[https://github.com/Microsoft/grover-blocks](https://github.com/Microsoft/grover-blocks)是使用Q#理解Grover算法（第11章）如何影响对称密钥算法（如AES）的一个很好的例子。
- en: In both cases, Q# is a valuable tool for understanding how much quantum computing
    power an attacker would need to compromise current cryptosystems. Together with
    assumptions about the speed at which quantum algorithms and hardware will continue
    to improve, assumptions about how much quantum computing power will be feasible
    for attackers to purchase, and requirements for how long algorithms like RSA need
    to be secure to guarantee our privacy, the understanding developed by using Q#
    can help us to recognize how quickly current cryptosystems need to be replaced.
    Like anything in information security, guaranteeing privacy against quantum attackers
    is a very complex topic, not to mention one without any easy answers. Fortunately,
    tools like Q# and the Quantum Development Kit help make the problem a bit more
    tractable.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，Q#是理解攻击者需要多少量子计算能力来破坏当前密码系统的宝贵工具。结合对量子算法和硬件将继续以多快速度改进的假设，对攻击者能够购买的量子计算能力的假设，以及对RSA等算法需要保持安全多长时间以保证我们隐私的要求，使用Q#开发的理解可以帮助我们认识到当前密码系统需要多快被替换。像信息安全中的任何事物一样，保证隐私不受量子攻击者侵犯是一个非常复杂的话题，更不用说没有简单答案了。幸运的是，像Q#和量子开发工具包这样的工具有助于使问题变得更容易处理。
- en: ^(a )Craig Gidney, “Asymptotically Efficient Quantum Karatsuba Multiplication”
    (2018), [https://arxiv.org/abs/1904.07356](https://arxiv.org/abs/1904.07356).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ^a Craig Gidney, “Asymptotically Efficient Quantum Karatsuba Multiplication”
    (2018), [https://arxiv.org/abs/1904.07356](https://arxiv.org/abs/1904.07356).
- en: ^b Craig Gidney and Martin Ekerå, “How to Factor 2048-bit RSA Integers in 8
    Hours Using 20 Million Noisy Qubits (2019), [https://arxiv.org/abs/1905.09749](https://arxiv.org/abs/1905.09749).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ^b Craig Gidney和Martin Ekerå, “How to Factor 2048-bit RSA Integers in 8 Hours
    Using 20 Million Noisy Qubits (2019), [https://arxiv.org/abs/1905.09749](https://arxiv.org/abs/1905.09749).
- en: Summary
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Modern cryptography works by hiding secrets with mathematical puzzles that are
    hard for classical computers to solve, like factoring numbers. Large quantum computers
    can be used to factor numbers, changing how we think about cryptography.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代密码学通过隐藏数学难题来保护秘密，这些难题对经典计算机来说很难解决，例如分解数字。大型量子计算机可以用来分解数字，这改变了我们对密码学的看法。
- en: 'Modular arithmetic generalizes how the hands of a clock move: for example,
    25 + 5 is 3 on a clock face with 27 hours.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模算术推广了时钟指针的运动方式：例如，在27小时制的时钟面上，25 + 5等于3。
- en: Integers with exactly two prime factors are called *semiprime* and can be factored
    by using quantum computers to solve modular arithmetic problems together with
    phase estimation.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恰好有两个质因数的整数被称为*半素数*，可以通过使用量子计算机解决模算术问题和相位估计来分解。
- en: The Q# numerics library provides useful functions and operations for working
    with modular integers on quantum computers.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Q#数值库为在量子计算机上处理模整数提供了有用的函数和操作。
- en: Shor’s algorithm combines the classical pre- and post-processing required with
    phase estimation on a quantum computer to quickly factor integers using modular
    arithmetic.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shor算法结合了在量子计算机上进行的经典预处理和后处理，以及相位估计，以快速使用模运算分解整数。
- en: Wrapping up
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Before we say goodbye, it’s helpful to take a step back and appreciate how all
    the various skills we learned throughout the book came together in this chapter
    to help us understand a real-world application for quantum computers. In part
    1, we learned the basics of how we can describe and simulate quantum computers,
    and about the basic quantum effects that make quantum computing unique. We learned
    in chapter 3 how to use single qubits and superposition to share cryptographic
    keys securely with quantum key distribution. In chapters 4–6, we entangled multiple
    qubits to play games and move data around a quantum device. We even built our
    own quantum simulator in Python to implement these games and learn about the math
    that helps us describe quantum effects.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们告别之前，回顾一下我们在本书中学到的各种技能是如何在这一章中汇聚起来，帮助我们理解量子计算机在现实世界中的应用是非常有帮助的。在第一部分，我们学习了如何描述和模拟量子计算机的基础知识，以及使量子计算独特的量子效应。在第3章，我们学习了如何使用单个量子比特和叠加来通过量子密钥分发安全地共享加密密钥。在第4至6章，我们通过纠缠多个量子比特来玩游戏并在量子设备周围移动数据。我们甚至使用Python构建了自己的量子模拟器来实施这些游戏并了解帮助我们描述量子效应的数学。
- en: With all of those basics under our belt, in part 2, we started writing quantum
    algorithms to help the crew in Camelot play some games. In chapter 7, we learned
    about Q#, a new programming language specifically designed to easily write programs
    for a quantum computer. In chapter 8, we implemented the Deutsch–Jozsa algorithm
    to select a new king, but along the way, we also learned about oracles and how
    they can help us evaluate classical functions in a quantum program. We also developed
    our own phase-estimation program in chapter 9, where we learned how to manipulate
    phase and use it with phase kickback to examine operations in our quantum programs.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了所有这些基础知识之后，在第二部分，我们开始编写量子算法来帮助卡美洛的船员玩游戏。在第7章，我们学习了Q#，这是一种专门设计用来轻松编写量子计算机程序的编程语言。在第8章，我们实现了Deutsch–Jozsa算法来选择新的国王，但在这个过程中，我们也学习了或然以及它们如何帮助我们评估量子程序中的经典函数。在第9章，我们还开发了我们的相位估计程序，在那里我们学习了如何操纵相位并使用相位回弹来检查我们的量子程序中的操作。
- en: Having a new toolbox of quantum development techniques at our disposal, we tackled
    some of the most exciting applications of quantum computing. In chapter 10, we
    learned about Hamiltonian simulation and how we can use the quantum systems in
    our quantum computers to simulate the energy levels in various chemicals. In chapter
    11, we implemented Grover’s algorithm to search for information in unstructured
    data with amplitude amplification. In this chapter, we used everything from Q#
    diagnostic functions and operations to phase estimation and everything from `within`/
    `apply` blocks to oracle representations of classical functions to factor numbers
    on a quantum computer. Using what we learned in the rest of the book, most of
    the hard parts of writing Shor’s algorithm were the *classical* parts required
    to connect the problem of factoring numbers to one of period finding.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有新的量子开发技术工具箱，我们解决了量子计算中最激动人心的应用之一。在第10章，我们学习了哈密顿量模拟以及我们如何可以使用量子计算机中的量子系统来模拟各种化学物质中的能级。在第11章，我们实现了Grover算法，通过振幅放大在非结构化数据中搜索信息。在这一章中，我们使用了从Q#诊断函数和操作到相位估计的一切，以及从`within`/
    `apply`块到经典函数的或然表示，在量子计算机上分解数字。利用本书中其他部分学到的知识，Shor算法的难点主要在于连接分解数字问题到周期查找问题的**经典**部分。
- en: While this book did not exhaust all there is to learn about quantum computing—a
    lot has happened since 1985, after all!—what you’ve learned gives you what you
    need to keep learning, exploring, and pushing forward with quantum computing.
    Using Python and Q# together, you have the tools to take part in one of the most
    exciting advances in computing, to help your peers and colleagues learn along
    with you, and to build a community that can put quantum computing to good use.
    Go have fun!
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这本书并没有涵盖量子计算的所有内容——毕竟，自1985年以来已经发生了许多事情！——但你所学到的知识为你提供了继续学习、探索和推动量子计算前进所需的一切。使用Python和Q#共同，你拥有了参与计算领域最激动人心的进步的工具，帮助你同行和同事与你一起学习，并建立一个能够将量子计算用于良好目的的社区。去享受乐趣吧！
- en: What’s next?
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: 'While there’s always more to learn about quantum computing, you now have what
    you need to start developing quantum applications using Python and Q# together.
    If you’re interested in learning and doing more with quantum computing, here are
    some resources to help you take your next step:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然关于量子计算总有更多东西要学习，但你现在已经有了一切，可以开始使用Python和Q#共同开发量子应用。如果你对学习和在量子计算方面做更多的事情感兴趣，以下是一些资源，可以帮助你迈出下一步：
- en: '*Q# Community* (qsharp.community)—An open source community around quantum programming
    in Q#, including blogs, code repositories, and online meetups'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Q# 社区*（qsharp.community）—围绕Q#量子编程的开源社区，包括博客、代码仓库和在线聚会'
- en: '*Microsoft Quantum Docs* ([https://docs.microsoft.com/azure/quantum/](https://docs.microsoft.com/azure/quantum/))—Full
    reference documentation for all things related to the Quantum Development Kit'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*微软量子文档*（[https://docs.microsoft.com/azure/quantum/](https://docs.microsoft.com/azure/quantum/)）—与量子开发套件相关的所有内容的完整参考文档'
- en: '*arXiv* (arxiv.org)—An online repository for scientific papers and manuscripts,
    including a huge amount of research about quantum computing'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*arXiv*（arxiv.org）—科学论文和手稿的在线存储库，包括大量关于量子计算的研究'
- en: '*Unitary Fund* (unitary.fund)—Nonprofit that provides grants and financial
    support for open source quantum software, along with neat suggestions for open
    source projects we can take on'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《单元基金》*（unitary.fund）—一个非营利组织，为开源量子软件提供补助金和财务支持，以及我们可承担的开源项目的精美建议'
- en: '*Quantum Open Source Foundation* ([www.qosf.org](http://www.qosf.org))—Foundation
    for developing open source quantum software, including a list of current projects
    and resources for further learning'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*量子开源基金会*（[www.qosf.org](http://www.qosf.org)）—开发开源量子软件的基金会，包括当前项目列表和进一步学习的资源'
- en: '*QC Ethics* (qcethics.org)—Resources for ethics in quantum computing'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*量子计算伦理*（qcethics.org）—量子计算伦理的资源'
- en: '*Q-Turn* (q-turn.org)—An inclusive quantum computing conference series'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Q-Turn*（q-turn.org）—包容性的量子计算会议系列'
- en: '*Quantum Algorithm Zoo* (quantumalgorithmzoo.org)—List of known quantum algorithms,
    with links to papers about each'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《量子算法动物园》*（quantumalgorithmzoo.org）—已知量子算法列表，包括每个算法的论文链接'
- en: '*Quantum Computing: A Gentle Introduction* (Jack D. Hidary, Springer, 2019)—More
    details about the math behind the quantum algorithms we learned about in this
    book'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《量子计算：轻松入门》*（Jack D. Hidary, Springer, 2019）—关于我们在本书中学到的量子算法背后的数学的更多细节'
- en: Many universities and colleges also have courses or research programs that may
    be of interest as you continue exploring quantum computing. However you decide
    to continue, we hope you have fun and work to make the quantum computing community
    even more wonderful!
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 许多大学和学院也提供了一些课程或研究项目，这些项目可能在你继续探索量子计算时对你感兴趣。无论你决定如何继续，我们都希望你能享受乐趣，并努力使量子计算社区变得更加美好！
