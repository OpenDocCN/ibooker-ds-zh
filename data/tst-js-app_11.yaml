- en: 9 Test-driven development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 测试驱动开发
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: What test-driven development (TDD) is and how to apply it
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动开发（TDD）是什么以及如何应用它
- en: Reasons to adopt TDD
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采用TDD的原因
- en: How TDD fosters intrateam and extrateam collaboration
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TDD如何促进团队内和团队间的协作
- en: Different approaches to applying TDD
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用TDD的不同方法
- en: When to apply TDD and when not to
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时应用TDD以及何时不应用
- en: How to create an adequate environment for TDD to succeed
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为TDD的成功创造一个合适的环境
- en: What behavior-driven development is, how it relates to TDD, and why to adopt
    it
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为驱动开发是什么，它与TDD的关系以及为什么应该采用它
- en: Imagine that today is one of those days you woke up inspired to bake the best
    banoffee pies the east side of London has ever tasted. You’ve already bought all
    the biscuits, the bananas, tons of sugar, and the tastiest condensed milk one
    can find. Your industrial oven is preheated and ready for some serious baking.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，今天是你醒来想要烘焙伦敦东区有史以来最好吃的香蕉派的一天。你已经买好了所有的饼干、香蕉、大量的糖和最美味的炼乳。你的工业烤箱预热好了，准备进行一些严肃的烘焙。
- en: After preparing quite a few pies, you put them in the oven, and, when the timer
    rings, you run straight back to the kitchen to try one. The smell is so delightful
    it makes your eyes gleam, but, when you try a slice, it’s not nearly as good as
    you expected.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好相当多的派之后，你将它们放入烤箱，当计时器响起时，你立刻跑回厨房尝一块。那香味如此美妙，让你的眼睛闪闪发光，但当你尝了一片后，它远不如你预期的那么好。
- en: 'Unfortunately, it looks like you’ve bought the wrong kinds of bananas. Besides
    being the wrong species, they were just like your tests should be: too green.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，看起来你买错了种类的香蕉。除了种类不对，它们就像你的测试应该一样：太绿了。
- en: Imagine how frustrating it would be to bake an entire batch of banoffee pies
    only to find out in the end that none of them turned out to meet your expectations.
    After a whole batch, it’s too late to correct course.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果你烘焙了一整批香蕉派，最后发现它们没有一个达到你的预期，那会有多令人沮丧。一整批之后，纠正方向已经太晚了。
- en: When it comes to baking, test-driven development itself can’t help much, but
    its principles can. Test-driven development is all about tightening the feedback
    loop so that you can correct course earlier and be more confident about what you’re
    building. By testing earlier, testing often, and being disciplined, you can produce
    better results, with less frustration, and, most importantly, less fear.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到烘焙时，测试驱动开发本身可能帮不上太多忙，但它的原则可以。测试驱动开发全部关于缩短反馈循环，这样你可以更早地纠正方向，并对你所构建的内容更有信心。通过尽早测试、经常测试和保持纪律，你可以产生更好的结果，减少挫折，最重要的是，减少恐惧。
- en: In this chapter, you will learn through practical examples *what* test-driven
    development is, *how* to apply it, and *when* to apply it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将通过实际示例了解**什么是**测试驱动开发，**如何**应用它，以及**何时**应用它。
- en: First, I’ll talk about the philosophy behind test-driven development and explain
    what it is and how it can help you.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将讨论测试驱动开发的哲学，并解释它是什么以及它如何能帮助你。
- en: This section is crucial to the understanding of the entire chapter because,
    on the internet, there seem to be many misconceptions about what TDD is actually
    about. You’ll learn that, contrary to what most people think—and contrary to what
    the name may lead people to believe—**test-driven development is *not* about tests**.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节对于理解整个章节至关重要，因为在互联网上，关于TDD真正含义的误解似乎有很多。你会了解到，与大多数人的想法相反——与名字可能让人相信的相反——**测试驱动开发****不是**关于测试的。
- en: Once I’ve explained what TDD is and how it works, I’ll walk you through the
    test-driven approach to writing code. Together, we’ll write a JavaScript module
    for you to generate reports for the bakery’s staff to make optimal decisions about
    which desserts to sell, how many to bake, and in which ways they can optimize
    their inventory management.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我解释了TDD是什么以及它是如何工作的，我将带你了解编写代码的测试驱动方法。我们一起为你编写一个JavaScript模块，用于为面包店的员工生成报告，以便他们做出关于销售哪些甜点、烘焙多少以及如何优化库存管理的最佳决策。
- en: This chapter’s third section covers different ways to apply test-driven development.
    In it, you’ll learn in which order to tackle distinct pieces of your software
    and the pros and cons of tackling certain parts first or last. Additionally, I’ll
    teach you how to calibrate how gradual your steps should be, depending on how
    confident you feel and a few other aspects of how you’re structuring your software.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第三部分涵盖了应用测试驱动开发的不同方式。在其中，你将学习如何按顺序处理软件的不同部分，以及先处理某些部分或最后处理的优缺点。此外，我还会教你如何根据你对自己软件结构的信心和其他几个方面来调整你的步骤应该有多渐进。
- en: Like I’ve been doing throughout the whole book, in the fourth section, I’ll
    reveal the impact that TDD has on your project’s costs and your team’s output.
    I’ll explain how to balance delivery speed and reliability to obtain the best
    possible results and stay within both the budget and the schedule.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我在整本书中一直做的那样，在第四章中，我将揭示TDD（测试驱动开发）对项目成本和团队产出的影响。我会解释如何平衡交付速度和可靠性，以获得最佳结果，并保持在预算和进度范围内。
- en: This fourth section goes a step beyond the technical aspects of test-driven
    development. This section is about how you can create an adequate environment
    for test-driven development to succeed. Like many other techniques for software
    development, the success of TDD relies on people adopting a similar attitude toward
    how they write tests and how they deliver code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这第四章在测试驱动开发的技术方面更进一步。本节是关于如何为测试驱动开发的成功创造一个适当的环境。像许多其他软件开发技术一样，TDD的成功依赖于人们采用类似的态度来编写测试和交付代码。
- en: Last, I’ll talk about behavior-driven development, which is a similar and more
    agile approach to TDD. I’ll explain how it relates to test-driven development
    and how it can facilitate collaboration among developers and expedite exchanging
    information with other teams. I’ll talk about how it can help you clarify requirements,
    structure your tests in such a way that they’ll be more useful to the business,
    and ensure that your software does what’s important for your customers.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我将谈谈行为驱动开发，这是一种类似于TDD且更敏捷的方法。我会解释它与测试驱动开发的关系，以及它如何促进开发者之间的协作并加快与其他团队交换信息。我会讨论它如何帮助你明确需求，以更有利于业务的方式构建测试，并确保你的软件做对你客户重要的事情。
- en: Test-driven development is one of the tools that helped the most in my career.
    It helps me write better code faster, communicate more efficiently, and make better
    decisions.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发是我职业生涯中最有帮助的工具之一。它帮助我更快地编写更好的代码，更有效地沟通，并做出更好的决策。
- en: Because test-driven development is such a powerful technique and an invaluable
    mental framework for tackling problems, I couldn’t help but devote an entire chapter
    to it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于测试驱动开发是一种如此强大且宝贵的解决问题的思维框架，我忍不住为它专门写了一章。
- en: 9.1 The philosophy behind test-driven development
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 测试驱动开发的哲学
- en: If you notice that your bananas aren’t yet ripe enough before you use them in
    your recipes, that’s a cheap mistake to fix. On the other hand, if you notice
    this mistake only after you’ve baked an entire batch of pies, you will have wasted
    lots of ingredients and a considerable amount of time.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在使用香蕉之前发现它们还没有完全成熟，那是一个容易修复的错误。另一方面，如果你在烘焙完一整批派之后才注意到这个错误，你将浪费很多原料和相当多的时间。
- en: Similarly, when writing software, it would be much harder to debug a feature
    once it’s complete than it would have been if you had written tests along the
    way.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在编写软件时，一旦某个功能完成，调试它会比你在过程中编写测试要困难得多。
- en: As you’ve learned in this book’s first chapter, **the earlier you notice that
    you’ve made a mistake, the cheaper it is to fix**. By writing tests, you tighten
    your feedback loop and make development less costly, less frustrating, and more
    predictable.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本书的第一章中学到的，**你越早意识到自己犯了错误，修复它就越便宜**。通过编写测试，你缩短了反馈循环，使开发成本更低、更少令人沮丧，并更具可预测性。
- en: Test-driven development, which is this section’s main subject, pushes even further
    the idea of tightening your feedback loop. Therefore, it amplifies the benefits
    of writing tests.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的主要主题——测试驱动开发，进一步推进了缩短反馈循环的想法。因此，它放大了编写测试的好处。
- en: In this section, you’ll learn *what* test-driven development is, *how* to apply
    it, and *why* it improves your software development process.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习什么是测试驱动开发，如何应用它，以及为什么它改进了你的软件开发过程。
- en: First, I’ll cover the steps involved in the test-driven development cycle, teach
    you how to apply them, and explain how the cycle changes as your confidence evolves.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将介绍测试驱动开发周期中涉及的步骤，教你如何应用它们，并解释随着你的信心增强，周期是如何变化的。
- en: Once you’ve learned *what* test-driven development is and *how* it works, I’ll
    show you *why* it works. I’ll explain how TDD reduces fear, improves your code’s
    design, and makes your software development process less frustrating and more
    efficient.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你了解了什么是测试驱动开发以及它是如何工作的，我将向你展示它为什么有效。我会解释TDD如何减少恐惧，改进你的代码设计，并使软件开发过程更加不令人沮丧且更有效率。
- en: 9.1.1 What test-driven development is
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.1 什么是测试驱动开发
- en: Names can often be misleading. Mince pies, for example, aren’t made of mincemeat.
    To be honest, I don’t know what actually goes into a mince pie, but I’d like to
    believe it’s magic.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 名称有时可能会误导。例如，肉馅饼并不是由肉馅制成的。说实话，我不知道肉馅饼里到底有什么，但我愿意相信它是魔法。
- en: Similarly, test-driven development is *not* really about tests. Test-driven
    development is about taking small incremental steps towards a solution. **When
    I hear the words “test-driven development,” the first thing that comes to my mind
    is iterative software development**.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，测试驱动开发实际上并不是真的关于测试。测试驱动开发是关于朝着解决方案采取小步骤的增量过程。**当我听到“测试驱动开发”这个词时，我首先想到的是迭代软件开发**。
- en: 'TDD is a software development technique that breaks down your development process
    into a cycle consisting of multiple small steps. These steps are as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: TDD是一种软件开发技术，它将你的开发过程分解成由多个小步骤组成的周期。这些步骤如下：
- en: Creating a small failing test
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个小的失败的测试
- en: Writing whichever pieces of code are necessary for the test to pass
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写使测试通过所需的任何代码
- en: Refactoring your tests **and** your code
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重构你的测试和你的代码
- en: The order of these steps is crucial when performing TDD. **When doing test-driven
    development, you should *not* write code without having a failing test first**.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行TDD时，这些步骤的顺序至关重要。**在进行测试驱动开发时，你应该在编写代码之前先有一个失败的测试**。
- en: Important When performing test-driven development, always start with a failing
    test.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 重要事项 在进行测试驱动开发时，始终从一个失败的测试开始。
- en: In the testing community, these steps are popularly known as *red, green, refactor*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试社区中，这些步骤普遍被称为“红、绿、重构”。
- en: NOTE The names “red” and “green” refer to the output colors commonly used by
    test runners when tests fail or succeed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：“red”和“green”这两个名字指的是测试运行器在测试失败或成功时常用的输出颜色。
- en: You can repeat this cycle (figure 9.1) as many times as you need. It ends only
    when the unit under test does what you want it to do and its tests are passing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要重复这个周期（图9.1）多次。只有当被测试的单元按照你的期望执行并且测试通过时，这个周期才会结束。
- en: '![](../Images/CH09_F01_DaCosta.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH09_F01_DaCosta.png)'
- en: Figure 9.1 The three steps in the test-driven development cycle
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 测试驱动开发周期的三个步骤
- en: To demonstrate how you’d apply TDD in a real-world situation, you’ll take a
    test-driven approach to writing a function that calculates the final price for
    a customer’s cart. This function should take an array of individual prices and
    a discount percentage and will return the total value due.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示如何在现实世界中应用TDD，你将采用测试驱动的方法来编写一个计算客户购物车最终价格的函数。这个函数应该接受一个包含单个价格的数组和一个折扣百分比，并返回应支付的总价值。
- en: '**When performing test-driven development, instead of starting with the unit
    under test, you start with the test itself**.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**在进行测试驱动开发时，你从测试本身开始，而不是从被测试的单元开始**。'
- en: Initially, your tests don’t always need to cover the unit under test’s full
    spectrum of functionality. They can validate only the bare minimum you’re comfortable
    implementing at once. For the function you’ll implement, for example, you initially
    won’t care about whether it can calculate a discount percentage.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，你的测试不一定需要覆盖被测试单元的全部功能范围。它们可以验证你一次性可以舒适实现的最小范围。例如，对于你要实现的函数，你最初可能不会关心它是否能计算折扣百分比。
- en: Important Writing a failing test—no matter how small—is the first step in the
    test-driven development cycle.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 重要事项 编写一个失败的测试——无论多小——是测试驱动开发周期的第一步。
- en: Go ahead and write a test that calls the `calculateCartPrice` function with
    a few item’s prices and expects it to return 7.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试编写一个测试，调用`calculateCartPrice`函数并使用几个商品的价格，并期望它返回7。
- en: Listing 9.1 calculateCartPrice.test.js
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.1 calculateCartPrice.test.js
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Imports the calculateCartPrice function
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入calculateCartPrice函数
- en: ❷ Invokes the calculateCartPrice function with a few item’s prices, and expects
    it to return 7
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用几个商品的价格调用 `calculateCartPrice` 函数，并期望它返回 7
- en: Because there is no file named `calculateCartPrice.js` yet, this test file will
    fail and, thus, be *red*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因为还没有名为 `calculateCartPrice.js` 的文件，这个测试文件将会失败，因此会变成 *红色*。
- en: The advantage of having started with a small test is that you won’t have to
    write `calculateCartPrice` all at once. Instead, you can implement just the bare
    minimum for the test to pass and become *green*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个小测试开始的优势是，你不需要一次性编写 `calculateCartPrice`。相反，你可以实现测试通过所需的最小代码量，使其变成 *绿色*。
- en: In this case, the bare minimum you need to do for your test to pass is to create
    a `calculateCartPrice.js` file that exports a `calculateCartPrice` function that
    always returns 7.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个情况下，为了使测试通过，你需要做的最基本的事情是创建一个 `calculateCartPrice.js` 文件，该文件导出一个总是返回 7 的 `calculateCartPrice`
    函数。
- en: Listing 9.2 calculateCartPrice.js
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.2 `calculateCartPrice.js`
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Creates a calculateCartPrice function that always returns 7
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个总是返回 7 的 `calculateCartPrice` 函数
- en: ❷ Exports the calculateCartPrice function
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 导出 `calculateCartPrice` 函数
- en: Once your tests can import the `calculateCartPrice` function from `calculateCartPrice.js`,
    they should become *green*, taking you to the second stage of the test-driven
    development cycle.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的测试能够从 `calculateCartPrice.js` 中导入 `calculateCartPrice` 函数，它们应该变成 *绿色*，带你进入测试驱动开发周期的第二阶段。
- en: Important In test-driven development, you should write only the bare minimum
    amount of code necessary for your tests to pass.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：在测试驱动开发中，你应该只编写使测试通过所需的最小代码量。
- en: Even though your code doesn’t yet implement the desired functionality for `calculateCartPrice`,
    it has already given you some confidence. By writing this small test and making
    it pass, you became confident that you have created the correct file, in the correct
    place, and exported the correct function.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你的代码还没有实现 `calculateCartPrice` 所需的功能，但它已经给你带来了一些信心。通过编写这个小测试并使其通过，你确信你已经创建了正确的文件，在正确的位置，并导出了正确的函数。
- en: Even though your test and your code are incomplete, they helped you take a small
    step in the right direction.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你的测试和代码是不完整的，但它们帮助你朝着正确的方向迈出了小小的一步。
- en: After you’ve received feedback on the piece of code you’ve written, you can
    proceed to increase your test’s scope and make it more thorough.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在你收到对你所写的代码的反馈后，你可以继续扩大测试的范围，使其更加全面。
- en: To move toward what the final implementation of `calculateCartPrice` should
    be, you will proceed to the third stage in the TDD cycle and refactor your test
    to make it more thorough.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向 `calculateCartPrice` 的最终实现迈进，你将继续进行 TDD 周期的第三阶段，并重构你的测试以使其更加全面。
- en: Your test will now call `calculateCartPrice` multiple times with different arrays
    and expect it to return the correct values.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你的测试现在将多次调用 `calculateCartPrice` 并使用不同的数组，并期望它返回正确的值。
- en: Listing 9.3 calculateCartPrice.test.js
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.3 `calculateCartPrice.test.js`
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Invokes calculateCartPrice several times with different item’s prices and
    expects it to return the correct values
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用 `calculateCartPrice` 函数多次，并使用不同的商品价格，期望它返回正确的值
- en: 'After this change, you’re back to the first stage of the TDD cycle: your tests
    are *red*.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次更改之后，你回到了 TDD 周期的第一阶段：你的测试是 *红色*。
- en: Once tests are failing, it’s time to take another small step toward the final
    implementation of `calculateCartPrice`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦测试失败，就是朝着 `calculateCartPrice` 的最终实现迈出另一个小步骤的时候了。
- en: To make your tests *green*, you’ll again write *only* the bare minimum amount
    of code necessary.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使你的测试 *通过*，你将再次只编写必要的最小代码量。
- en: Now that you have plenty of assertions, the easiest way of making your test
    pass again is to make `calculateCartPrice` sum all the prices in the array.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了大量的断言，使测试再次通过的最简单方法是让 `calculateCartPrice` 计算数组中的所有价格。
- en: Listing 9.4 calculateCartPrice.js
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.4 `calculateCartPrice.js`
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Adds to total each number in the prices array
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将价格数组中的每个数字加到总和中
- en: ❷ Returns the cart’s total price
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回购物车的总价
- en: After implementing this piece of functionality, your test should pass, indicating
    that `calculateCartPrice` was able to calculate the given carts’ total prices
    correctly.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现这一功能后，你的测试应该通过，表明 `calculateCartPrice` 能够正确计算给定购物车的总价。
- en: Even though your function can’t yet apply a discount percentage to the total
    price, you’ve taken another small step toward its final implementation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你的函数还不能将折扣百分比应用到总价上，但你已经朝着最终实现迈出了另一个小步骤。
- en: This procedure will make you more confident that you’re on the right path because
    you’re iteratively implementing `calculateCartPrice` and getting instantaneous
    feedback along the way.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程将使你更有信心你走在正确的道路上，因为你正在迭代地实现 `calculateCartPrice` 并在过程中获得即时反馈。
- en: Now that you have a thorough test to validate whether this function correctly
    calculates a cart’s final price, you can safely refactor `calculateCartPrice`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个彻底的测试来验证这个函数是否正确地计算了购物车的最终价格，你可以安全地重构 `calculateCartPrice`。
- en: If you’re a fan of functional programming like I am, you can, for example, rewrite
    `calculateCartPrice` to use `reduce` instead of a `for` loop, as shown next.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像我一样喜欢函数式编程，例如，你可以将 `calculateCartPrice` 重写为使用 `reduce` 而不是 `for` 循环，如下所示。
- en: Listing 9.5 calculateCartPrice.js
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.5 calculateCartPrice.js
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Adds to the accumulated sum, which starts at zero, each item’s price
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将每个商品的价格添加到初始为零的累计总和中
- en: After refactoring `calculateCartPrice`, if you make a mistake that causes `calculateCartPrice`
    to yield an incorrect total price for the given cart, your test will fail.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在重构 `calculateCartPrice` 后，如果你犯了一个错误，导致 `calculateCartPrice` 为给定的购物车返回不正确的总价，你的测试将失败。
- en: Thanks to TDD, you were able to write the most naive implementation first. Only
    then, when you were confident that you had thorough tests and working code, you
    refactored your function to a version you considered to be better.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了 TDD（测试驱动开发），你首先能够写出最简单的实现。只有在你确信你有彻底的测试和可工作的代码之后，你才重构了你的函数，使其成为一个你认为更好的版本。
- en: Finally, it’s time to make `calculateCartPrice` able to apply a discount percentage
    to a cart’s total price.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是时候让 `calculateCartPrice` 能够将折扣百分比应用到购物车的总价格上了。
- en: Again, because you’re taking a test-driven approach to implementing this function,
    you will start with a failing test.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，因为你正在采用测试驱动的方法来实现这个函数，所以你会从一个失败的测试开始。
- en: Go ahead and write a small test that passes a number as the second argument
    to `calculateCartPrice`, and expect that function to apply the correct discount.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 继续编写一个小测试，将一个数字作为 `calculateCartPrice` 的第二个参数传递，并期望该函数应用正确的折扣。
- en: Listing 9.6 calculateCartPrice.test.js
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.6 calculateCartPrice.test.js
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Calls calculateCartPrice, passing a few item’s prices and a discount percentage,
    and expects it to return 3
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用 `calculateCartPrice`，传递几个商品的价格和折扣百分比，并期望它返回 3
- en: Now that you have a failing test, you can go ahead and implement the bare minimum
    for this test to pass.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个失败的测试，你可以继续实现这个测试的最小实现，使其通过。
- en: Again, you’ll update `calculateCartPrice` so that it returns the correct hardcoded
    value when passed a second argument.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你需要更新 `calculateCartPrice`，以便在传递第二个参数时返回正确的硬编码值。
- en: Listing 9.7 calculateCartPrice.js
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.7 calculateCartPrice.js
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Calculates the cart’s total price
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 计算购物车的总价
- en: ❷ If discountPercentage has been passed, return 3; otherwise, return the total.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果传递了折扣百分比，则返回 3；否则，返回总价。
- en: Despite your `calculateCartPrice` not calculating a discount percentage yet,
    you have already put in place the structure necessary for doing so. When the time
    comes for you to calculate actual discounted prices, you’ll have to change only
    a single line of code. Again, you’ve safely taken a small step in the right direction.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你的 `calculateCartPrice` 还没有计算折扣百分比，但你已经为这样做建立了必要的结构。当你需要计算实际的折扣价格时，你只需要更改一行代码。再次强调，你安全地迈出了正确方向的一小步。
- en: For you to be able to implement the actual discount calculation and get instantaneous
    feedback on whether you’ve done it correctly, make your last test more thorough
    by adding more assertions to it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够实现实际的折扣计算并获得是否正确完成的即时反馈，通过向测试中添加更多断言来使你的最后一个测试更加彻底。
- en: Listing 9.8 calculateCartPrice.test.js
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.8 calculateCartPrice.test.js
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Calls calculateCartPrice several times, passing a few item’s prices and discount
    percentages, and expects it return the correct final prices with discounts applied
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用 `calculateCartPrice` 多次，传递几个商品的价格和折扣百分比，并期望它返回应用折扣后的正确最终价格
- en: After seeing this test fail, you’re now sure that it will alert you if `calculateCartPrice`
    incorrectly applies a discount to one of the given carts.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到这个测试失败后，你现在可以确信，如果 `calculateCartPrice` 错误地将折扣应用到给定的购物车之一，它会发出警报。
- en: To make your tests pass again, go ahead and implement the actual discount calculation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让测试再次通过，继续实现实际的折扣计算。
- en: Listing 9.9 calculateCartPrice.js
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.9 calculateCartPrice.js
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Calculates the cart’s total price
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 计算购物车的总价
- en: ❷ If discountPercentage has been passed, applies it to the total price; otherwise,
    returns the full amount
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果传递了折扣百分比，则将其应用于总价；否则，返回全额
- en: Once again, all your tests should pass, but `calculateCartPrice` isn’t complete
    yet.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，所有你的测试都应该通过，但 `calculateCartPrice` 还未完成。
- en: Currently, if you pass `string` as the second argument to this function, it
    will return `NaN`, which stands for “not a number.” Instead of returning `NaN`,
    `calculateCartPrice` should *not* apply any discounts when it receives a string
    as its second argument.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，如果你将字符串作为此函数的第二个参数传递，它将返回 `NaN`，代表“不是一个数字”。`calculateCartPrice` 应该**不**在接收到字符串作为其第二个参数时应用任何折扣。
- en: Before fixing that bug, you’ll write a failing test.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在修复那个错误之前，你会编写一个失败的测试。
- en: Listing 9.10 calculateCartPrice.test.js
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.10 calculateCartPrice.test.js
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Calls calculateCartPrice, passing a few item’s prices and string as a discount
    percentage, and expects the result to be 6
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用 `calculateCartPrice`，传递一些商品的价格和字符串作为折扣百分比，并期望结果为 6
- en: By adding a test *before* fixing the bug, you can be sure that the test is capable
    of detecting whether this particular bug is present. Had you written the test
    *after* solving the bug, you wouldn’t be sure whether it passed because the defect
    was resolved or because your test couldn’t catch it.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在修复错误之前添加测试，你可以确保测试能够检测到是否存在这个特定的错误。如果你在解决问题之后编写测试，你就无法确定它是否通过，因为缺陷已经解决，或者是因为你的测试无法捕获它。
- en: Finally, you’ll update `calculateCartPrice` so that it applies a discount percentage
    to the cart’s price only when the second argument is a number.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将更新 `calculateCartPrice` 以确保仅在第二个参数是数字时才将折扣百分比应用于购物车价格。
- en: Listing 9.11 calculateCartPrice.js
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.11 calculateCartPrice.js
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ If the given discountPercentage has the type “number,” applies the discount
    to the total price; otherwise, returns the full amount
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果给定的折扣百分比是“数字”类型，则将其应用于总价；否则，返回全额
- en: Because JavaScript can sometimes be a bit weird, `NaN`, which stands for “not
    a number,” actually has the type “number.” Therefore, `calculateCartPrice` will
    still return `NaN` when a caller passes `NaN` itself as the second argument.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JavaScript 有时可能有点奇怪，代表“不是一个数字”的 `NaN` 实际上具有“数字”类型。因此，当调用者将 `NaN` 本身作为第二个参数传递时，`calculateCartPrice`
    仍然会返回 `NaN`。
- en: As you should always do when applying test-driven development, you’ll write
    a failing test before fixing the bug.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在应用测试驱动开发时应该做的，你会在修复错误之前编写一个失败的测试。
- en: Listing 9.12 calculateCartPrice.test.js
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.12 calculateCartPrice.test.js
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Calls calculateCartPrice, passing a few item’s prices and NaN as a discount
    percentage, and expects the result to be 6
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用 `calculateCartPrice`，传递一些商品的价格和 `NaN` 作为折扣百分比，并期望结果为 6
- en: Now that you’ve written a test and have seen it failing to ensure that it can
    catch that bug, update the code so that it can adequately handle `NaN`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经编写了一个测试，并看到它失败以确保它可以捕获那个错误，更新代码以便它可以适当地处理 `NaN`。
- en: Listing 9.13 calculateCartPrice.js
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.13 calculateCartPrice.js
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ If the given discountPercentage has the type “number” and is not NaN, applies
    the discount to the total price; otherwise, returns the full amount
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果给定的折扣百分比是“数字”类型且不是 `NaN`，则将其应用于总价；否则，返回全额
- en: The `calculateCartPrice` is now finally done.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculateCartPrice` 现在终于完成了。'
- en: Even though it may have taken you a bit longer to get to its final implementation,
    you got precise feedback throughout the entire process. Had you made any mistakes,
    you would found and fixed them much more quickly because you wrote smaller chunks
    of code at a time.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 即使到达最终实现可能花费了你更长的时间，但你整个过程中都得到了精确的反馈。如果你犯了任何错误，你会更快地发现并修复它们，因为你一次只编写了较小的代码块。
- en: Because you’ve written tests *before* writing code, you’ve certified that your
    tests would alert you if `calculateCartPrice` yielded incorrect results for any
    of the passed arguments. Starting with a failing test helps you avoid tests that
    *always* pass and, therefore, won’t catch bugs.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你在编写代码之前编写了测试，你确保了如果 `calculateCartPrice` 对于任何传递的参数产生了不正确的结果，你的测试会提醒你。从失败的测试开始可以帮助你避免总是通过测试，因此无法捕获错误。
- en: As you approached the final implementation of `calculateCartPrice`, you didn’t
    become as wary as you would be if you hadn’t tested it along the way. By validating
    each step taken, you’ve guaranteed that you were on the right path the whole time.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当你接近 `calculateCartPrice` 的最终实现时，你没有像没有在过程中测试那样谨慎。通过验证每一步，你确保了整个过程中你都在正确的道路上。
- en: Unlike when you implement a large feature all at once, test-driven development
    also didn’t let you go astray. Your failing tests were, at all times, telling
    you what to do next.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 与一次性实现一个大型功能不同，测试驱动开发也没有让你走错路。你的失败的测试始终在告诉你下一步该做什么。
- en: Finally, when fixing the remaining bugs, you’ve written tests first, so that
    you could see them failing and, therefore, be sure that they could detect the
    bugs you were trying to fix. These failing tests gave you confidence that you’d
    be alerted if these bugs reappear.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在修复剩余的错误时，你首先编写了测试，这样你就能看到它们失败，因此可以确信它们能够检测到你试图修复的错误。这些失败的测试让你有信心，如果这些错误再次出现，你会得到通知。
- en: 9.1.2 Adjusting the size of your iterations
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.2 调整迭代的大小
- en: An experienced pastry chef like Louis doesn’t need to taste his recipes frequently.
    His years of experience allow him to get perfect banoffee pies without having
    to stick his fingers in them before they’re out of the oven.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 就像路易斯这样的经验丰富的糕点师不需要经常品尝他的食谱。他多年的经验使他能够在饼干出炉前不用手指去尝就能做出完美的香蕉焦糖派。
- en: Similarly, when programmers feel confident enough to implement a function all
    at once, they don’t need to write numerous tests along the way.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当程序员有足够的自信一次性实现一个函数时，他们不需要在过程中编写许多测试。
- en: Remember that **test-driven development is *not* about tests; it is a fear-reduction
    tool**.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，**测试驱动开发不是关于测试；它是一种减少恐惧的工具**。
- en: If you’re about to implement a complex function but don’t yet know how to do
    it, you may choose to write smaller tests, so that you can write smaller chunks
    of code at a time, as you did in the previous example.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你即将实现一个复杂的函数，但还不知道如何实现，你可能选择编写较小的测试，这样你就可以一次编写一小段代码，就像在之前的例子中那样。
- en: The less confident you feel, the more steps you should take so that you build
    up confidence as you approach your unit-under-test’s final implementation, as
    illustrated in the workflow shown in figure 9.2.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 感觉越不自信，你应该采取的步骤越多，这样你就可以在接近单元测试的最终实现时逐渐建立信心，如图 9.2 所示的工作流程所示。
- en: '![](../Images/CH09_F03_DaCosta.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH09_F03_DaCosta.png)'
- en: Figure 9.2 The less confident you feel, the smaller your steps should be, and
    the more times you’ll go through the test-driven development cycle.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 感觉越不自信，你的步骤应该越小，你将越多次地经历测试驱动开发周期。
- en: As your confidence increases, you can start taking bigger steps, as shown in
    figure 9.3, and, therefore, iterate more quickly.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 随着自信心的增加，你可以开始采取更大的步骤，如图 9.3 所示，因此可以更快地迭代。
- en: '![](../Images/CH09_F03_DaCosta.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH09_F03_DaCosta.png)'
- en: Figure 9.3 As your confidence increases, you can increase the size of your steps
    to decrease the number of iterations necessary to implement a particular piece
    of code.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 随着自信心的增加，你可以增加步骤的大小，以减少实现特定代码片段所需的迭代次数。
- en: When feeling confident, instead of incrementally writing numerous small tests,
    you can create a larger test and write your function’s final implementation all
    at once, as shown in figure 9.4.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当你感到自信时，你不必逐步编写许多小测试，你可以创建一个更大的测试，并一次性编写你函数的最终实现，如图 9.4 所示。
- en: '![](../Images/CH09_F04_DaCosta.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH09_F04_DaCosta.png)'
- en: Figure 9.4 If you feel very confident that you know how to implement a particular
    piece of code, you can write a full-blown test and the final implementation straightaway.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 如果你非常自信地知道如何实现特定的代码片段，你可以直接编写一个完整的测试和最终实现。
- en: Imagine, for example, that you need to write a function that takes an array
    with multiple carts’ items and picks the most expensive cart.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象你需要编写一个函数，该函数接受一个包含多个购物车商品的数组，并选择最昂贵的购物车。
- en: If you’re confident that you know how to write this function and want to do
    it more quickly, instead of writing a small failing test, you can write one or
    more full-blown tests straightaway.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你自信地知道如何编写这个函数，并想更快地完成它，你不必编写一个小型失败的测试，可以直接编写一个或多个完整的测试。
- en: Listing 9.14 pickMostExpensive.test.js
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.14 pickMostExpensive.test.js
- en: '[PRE13]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Calls the pickMostExpensive function several times with different carts’ contents,
    and expects it to return the most expensive cart
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 几次调用 pickMostExpensive 函数，并使用不同购物车的商品内容，期望它返回最昂贵的购物车
- en: ❷ Verifies whether pickMost-Expensive returns null when given an empty array
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 验证当给 pickMost-Expensive 函数一个空数组时，它是否返回 null
- en: With these thorough tests, you can proceed directly to the final implementation
    of `pickMostExpensive`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些彻底的测试，你可以直接进入 `pickMostExpensive` 的最终实现。
- en: Listing 9.15 pickMostExpensive.js
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.15 pickMostExpensive.js
- en: '[PRE14]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Iterates through the given carts
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 遍历给定的购物车
- en: ❷ Calculates the current cart’s price
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 计算当前购物车的价格
- en: ❸ Checks if the current cart’s price is higher than the previous most expensive
    cart’s
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查当前购物车的价格是否高于之前最贵的购物车的价格
- en: ❹ If the current cart is the most expensive, updates most-ExpensivePrice with
    its price
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果当前购物车是最贵的，则更新most-ExpensivePrice及其价格
- en: ❺ If the current cart is the most expensive, updates mostExpensiveCart with
    its contents
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果当前购物车是最贵的，则更新mostExpensiveCart及其内容
- en: ❻ Returns the most expensive cart’s contents
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 返回最贵购物车的商品内容
- en: In this example, you still followed the TDD cycle, but you’ve taken larger steps
    at a time. First, you wrote a test, and only then you made it pass. If you wanted,
    you could also refactor `pickMostExpensive` once its tests had passed.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你仍然遵循了TDD周期，但你一次采取了更大的步骤。首先，你编写了一个测试，然后才让它通过。如果你愿意，你还可以在测试通过后重构`pickMostExpensive`。
- en: Even though you’ve taken steps of different sizes for this example and the one
    that came before it, the order of the steps and each step’s goal remains the same.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你为这个例子和之前的例子采取了不同大小的步骤，但步骤的顺序和每个步骤的目标保持不变。
- en: By taking bigger steps when implementing `pickMostExpensive`, you were able
    to get to a final result quicker. Yet, those quick results came at the cost of
    a smooth and predictable development process. Had your tests failed, you would
    have received coarse feedback, and you would have had more lines of code to investigate.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在实现`pickMostExpensive`时采取更大的步骤，你能够更快地得到最终结果。然而，这些快速的结果是以一个平稳且可预测的开发过程为代价的。如果你的测试失败了，你会收到粗糙的反馈，并且你将需要调查更多的代码行。
- en: Because you were already sure about the implementation of `pickMostExpensive`,
    you explicitly chose to trade granular feedback for speed.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你对`pickMostExpensive`的实现已经确信无疑，你明确选择以速度换取细粒度反馈。
- en: '**When applying test-driven development, the more confident you feel, the bigger
    the steps you take**.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**在应用测试驱动开发时，你感觉越自信，你采取的步骤就越大**。'
- en: The smaller your steps are, the more granular their feedback is, and the tinier
    the chunks of code you have to write at a time are.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你的步骤越小，它们的反馈就越细粒度，你一次需要编写的代码块就越小。
- en: As your steps get larger, their feedback becomes more coarse, and you write
    bigger pieces of code in each iteration.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你采取的步骤变大，它们的反馈变得更加粗糙，你每次迭代中编写的代码块也更大。
- en: By varying the size of your steps according to your confidence, you can adapt
    test-driven development to suit whichever piece of code you’re implementing.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通过根据你的信心调整步骤的大小，你可以将测试驱动开发适应你正在实现的任何代码片段。
- en: When feeling insecure, take small steps to get granular feedback and reduce
    your fear as you proceed toward your unit under test’s final implementation. As
    you build up confidence, you can take bigger steps because you won’t need your
    feedback loop to be as tight anymore.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当感到不安全时，通过逐步进行以获取细粒度反馈，并在向测试单元的最终实现迈进的过程中减少你的恐惧。
- en: 9.1.3 Why adopt test-driven development?
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.3 为什么采用测试驱动开发？
- en: When I teach people how to apply test-driven development, they are usually happy
    with the results. I often hear them saying that it made their development experience
    smoother and that it improved the quality of the code they deliver.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当我教人们如何应用测试驱动开发时，他们通常对结果感到满意。我经常听到他们说，这使他们的开发体验更加顺畅，并且提高了他们交付的代码质量。
- en: However, even though these people experience the benefits of applying test-driven
    development, sometimes they struggle to explain this choice to nontechnical managers
    or to advocate for it when talking to other developers.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管这些人体验到了应用测试驱动开发的好处，有时他们很难向非技术经理解释这个选择，或者在与其他开发者交谈时为其辩护。
- en: In the final part of this section, I’ll articulate the reasons engineers should
    apply test-driven development.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后部分，我将阐述工程师应该应用测试驱动开发的原因。
- en: Test-driven development reduces costs
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发降低成本
- en: The longer you take to try one of your banoffee pies, the longer it’ll take
    to realize that you’ve used the wrong kind of banana. Additionally, once your
    pies are done, it will be much more difficult to tell what went wrong.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你尝试你的香蕉布丁派的时间越长，你意识到你使用了错误类型的香蕉所需的时间就越长。此外，一旦你的派做好了，告诉你哪里出了问题将会更加困难。
- en: Had you tried one of the bananas before you started baking, you wouldn’t have
    had to throw away the entire batch, and you’d have known which ingredient to replace.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你开始烘焙之前尝试了一块香蕉，你就不会不得不丢弃整个批次，并且你会知道需要替换哪种成分。
- en: Similarly, the longer you take to write a test, the more time it takes to realize
    your code is wrong, and the longer it takes to fix it. When you correct course
    too late, there will be more places for bugs to hide and more lines of code to
    undo, as explained in figure 9.5.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你花费的时间越长去编写测试，你意识到代码错误所需的时间就越长，修复它所需的时间也就越长。当你纠正方向太晚时，错误就有更多的藏身之处，需要撤销的代码行数也就越多，如图9.5所示。
- en: '![](../Images/CH09_F05_DaCosta.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 DaCosta](../Images/CH09_F05_DaCosta.png)'
- en: Figure 9.5 As time passes, the amount of code changed increases. The longer
    you take to find a bug, the more lines of code you’ll have to investigate.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 随着时间的推移，代码变更的数量增加。你花费的时间越长去寻找一个错误，你将需要调查的代码行数就越多。
- en: By taking small steps when writing both your test and your code, you will be
    able to obtain much more granular feedback. This precise feedback will make it
    much quicker for you to identify the sources of bugs and fix them.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在编写测试和代码时采取小步骤，你将能够获得更细粒度的反馈。这种精确的反馈将使你更快地识别错误来源并修复它们。
- en: Besides reducing the time it takes to find bugs, catching them earlier also
    makes them cheaper to fix. A defect in your production environment can cause you
    to lose a considerable amount of money. Similarly, a buggy commit in your repository
    can cause other developers to waste a lot of time. Yet, catching a bug as you’re
    writing a feature tends to cost virtually nothing.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 除了减少查找错误所需的时间外，更早地捕捉错误也会使修复它们变得更便宜。你生产环境中的缺陷可能导致你损失相当数量的金钱。同样，你仓库中的有缺陷的提交可能导致其他开发者浪费大量时间。然而，当你编写功能时捕捉到错误通常几乎不花费任何成本。
- en: 'Important Test-driven development reduces costs for two main reasons: it makes
    it quicker to find and fix bugs and allows you to catch them earlier.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 重要 测试驱动开发由于两个主要原因降低了成本：它使得查找和修复错误更快，并允许你更早地捕捉到它们。
- en: Test-driven development reduces fear and anxiety
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发减少恐惧和焦虑
- en: If you’ve never prepared tiramisu before, it’s wise to compare each part of
    the process to the pictures in the recipe book. If your tiramisu looks like the
    book’s all along, chances are, it will turn out to be superb. On the other hand,
    if you do everything at once, you may lose sleep worrying about whether you’ve
    wasted all that mascarpone.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前从未准备过提拉米苏，明智的做法是将每个步骤与食谱书中的图片进行比较。如果你的提拉米苏一直看起来像书中的那样，那么它很可能非常出色。另一方面，如果你一次性做所有的事情，你可能会因为担心是否浪费了所有的马斯卡彭奶酪而失眠。
- en: By carefully validating each step along the way, you become less fearful about
    the end result. That’s true both for making tiramisu and for writing software.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过仔细验证每一步，你对最终结果会感到不那么恐惧。这无论是对于制作提拉米苏还是编写软件都是正确的。
- en: At first, it may seem like a waste of time to do all that testing. Nonetheless,
    baking a dessert once is still quicker than baking it twice.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，可能觉得花那么多时间进行测试是一种浪费时间。然而，烘焙一次甜点仍然比烘焙两次要快。
- en: The same is valid for writing code. If you write a marvelous piece of software
    once, even though you might have taken more time to finish it, you will be sure
    it works when it’s time to commit the code.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样适用于编写代码。如果你一次写出一个出色的软件作品，即使你可能花费了更多的时间来完成它，你也会确信它在提交代码时是能够正常工作的。
- en: Test-driven development makes you less fearful because it gives you feedback
    all along the way, instead of making you wonder whether your program will work
    up until you fully finish it.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发让你不那么恐惧，因为它在整个过程中都给你提供反馈，而不是让你在完全完成程序之前一直猜测程序是否能够正常工作。
- en: Important If you thoroughly test your code as you write it, you will be sure
    it works when you finish it.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 重要 如果你在编写代码时彻底测试它，你将确信它在完成时是能够正常工作的。
- en: Test-driven development leads to better-designed code
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发导致代码设计更优
- en: A test-driven workflow incentivizes developers to make each piece of code as
    easy as possible to test. Because it’s easier to test small, focused functions
    than it is to test big multipurpose ones, developers end up creating code that’s
    more modular, and functions that do one thing and do it well.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动的工作流程激励开发者使每一块代码尽可能容易进行测试。因为测试小型、专注的函数比测试大型多功能的函数要容易，开发者最终会创建出更模块化的代码，以及只做一件事并且做得很好的函数。
- en: By creating modular pieces of code, software becomes more flexible and robust
    because it favors the reuse of focused and well-tested code.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建模块化的代码片段，软件变得更加灵活和健壮，因为它优先考虑了重用经过关注和良好测试的代码。
- en: Additionally, instead of being concerned about *how* a function does something,
    developers pay more attention to *what* the function does.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，开发者们不再关注函数是如何完成某事的，而是更加关注函数**做什么**。
- en: This shift in focus happens because starting with a test incentivizes developers
    to write APIs from a consumer-centric perspective. Instead of thinking about what’s
    easier for them to implement, they think about what the unit under test’s consumer
    expects the function to do. In this case, the target’s consumer is represented
    by the target’s tests.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关注点的转变发生是因为从测试开始可以激励开发者从以用户为中心的角度编写API。他们不再考虑什么更容易实现，而是思考测试单元的用户期望函数能做什么。在这种情况下，目标用户的消费者由目标测试来代表。
- en: Once developers get to an implementation that matches the needs of the target’s
    consumer, they can to refactor the unit under test in whichever way they want.
    Nonetheless, this refactor will be constrained by the interface defined in the
    existing tests. Even though the developer can change *how* a function does something,
    they can’t change *what* it does, unless they also change its tests.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦开发者达到了满足目标用户需求的实现，他们就可以以任何他们想要的方式重构测试单元。尽管如此，这种重构将受到现有测试中定义的接口的限制。即使开发者可以改变函数**如何**做某事，他们也不能改变它**做什么**，除非他们也改变其测试。
- en: By writing tests, developers are creating a contract to which they must abide.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写测试，开发者正在创建一个他们必须遵守的契约。
- en: In essence, writing tests before writing code encourages developers to “program
    an interface, not an implementation.”
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，在编写代码之前编写测试鼓励开发者“编写接口，而不是实现”。
- en: NOTE Programming to an interface, not to an implementation is advice from the
    excellent book *Design Patterns*, by Erich Gamma, Richard Helm, Ralph Johnson,
    and John Vlissides (Addison-Wesley Professional, 1994).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：面向接口而不是面向实现是来自优秀书籍《设计模式》的建议，作者为Erich Gamma、Richard Helm、Ralph Johnson和John
    Vlissides（Addison-Wesley Professional，1994年）。
- en: The need to create high-fidelity test doubles is another factor that encourages
    developers to program to interfaces when they take a test-driven approach to work.
    Because developers must be able to replace certain pieces of software with test
    doubles easily, they are encouraged to keep their interfaces clean, uniform, and
    understandable.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 需要创建高保真度测试替身是另一个因素，它鼓励开发者在使用测试驱动方法工作时编写面向接口的代码。因为开发者必须能够轻松地用测试替身替换某些软件片段，所以他们被鼓励保持接口干净、统一和可理解。
- en: Test-driven development makes tests more thorough
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发使测试更加全面
- en: The most dangerous tests aren’t the ones that fail. The most dangerous tests
    are the ones that always pass.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最危险的不是那些失败的测试。最危险的是那些总是通过的测试。
- en: By writing tests before fixing bugs, as you’ve previously done, you will ensure
    that the test you’ve written can catch the defect you will fix. If the test passes
    even before you fix the bug, that’s a signal that the test you’ve written is *useless*.
    It can’t tell you whether the bug is present.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在修复错误之前编写测试，就像你之前做的那样，你可以确保你编写的测试可以捕捉到你将要修复的缺陷。如果在修复错误之前测试就通过了，那么这是一个信号，表明你编写的测试是**无用的**。它不能告诉你错误是否存在。
- en: When performing test-driven development, because I haven’t written any code
    yet, I tend to end up finding edge cases I wouldn’t have thought of if I had already
    written the code.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行测试驱动开发时，因为我还没有编写任何代码，所以我往往会发现一些边缘情况，如果我已经编写了代码，我就不会想到这些情况。
- en: When you write tests before you write code, you’re concerned about writing thorough
    tests to guide you through the process of implementing the unit under test. On
    the other hand, if you write the code first, you’ll usually be concerned about
    proving that your code works instead of catching bugs.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在编写代码之前编写测试时，你关心的是编写全面的测试来指导你完成实现测试单元的过程。另一方面，如果你先编写代码，你通常更关心证明你的代码是有效的，而不是捕捉错误。
- en: Important Test-driven development makes tests more thorough because it allows
    you to verify whether the test can catch bugs. It helps you think about edge cases
    that prove that your software *won’t* work, instead of trying to prove it does,
    which leads to unreliable guarantees.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的测试驱动开发使测试更加全面，因为它允许你验证测试是否能够捕捉到错误。它帮助你思考边缘情况，证明你的软件**不会**工作，而不是试图证明它确实工作，这会导致不可靠的保证。
- en: Test-driven development guides you through the development process
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发引导你通过开发过程
- en: How many times have you had to throw away a bunch of work and start from scratch
    because you didn’t even know where you were anymore? Have you ever gone home after
    a long day at work, and the next day you had no idea what you were doing?
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你有多少次不得不丢弃一堆工作并从头开始，因为你甚至不知道自己在哪里了？你有没有在辛苦工作了一天后回到家，第二天却不知道自己在做什么？
- en: Test-driven development solves these two problems. By writing failing tests
    first, you always know what to do next.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发解决了这两个问题。通过首先编写失败的测试，你总是知道下一步该做什么。
- en: 'Failing tests will help you keep only the necessary information in your head
    at a time. Whenever you have to make changes to your code, you’ll need the context
    only for the problem at hand: making your tests pass.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 失败的测试将帮助你一次只保留必要的知识。每次你不得不更改代码时，你只需要当前问题的上下文：让你的测试通过。
- en: Before I leave work, if I’m in the middle of writing code, I’ll always leave
    failing tests as a gift for my future self. The next day, when future Lucas gets
    to work, he immediately knows what to do and is pleased with Lucas from the past.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在离开工作之前，如果我在编写代码，我总会留下失败的测试作为给未来自己的礼物。第二天，当未来的卢卡斯开始工作时，他会立刻知道该做什么，并对过去的卢卡斯感到满意。
- en: Important Test-driven development guides you through the development process
    because it always tells you what you should do next.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 重要测试驱动开发引导你通过开发过程，因为它总是告诉你下一步该做什么。
- en: 9.1.4 When not to apply test-driven development
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.4 不适用测试驱动开发的情形
- en: Anyone can learn how to bake a cake by reading a recipe, but only the best pastry
    chefs know which steps and ingredients to change so that they can bake an authentic
    dessert and make a name for themselves.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 任何人都可以通过阅读食谱学会如何烘焙蛋糕，但只有最好的糕点师才知道哪些步骤和成分需要改变，以便他们可以烘焙出正宗的甜点并为自己赢得声誉。
- en: In baking as well as in software engineering, two of the most dangerous words
    are *always* and *never*. Throughout my career I’ve noticed that the more experienced
    an professional is, the more often they’ll say *it depends.*
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在烘焙以及软件工程中，最危险的两个字是**总是**和**永远**。在我的整个职业生涯中，我注意到，一个专业人士越有经验，他们就越经常说**视情况而定**。
- en: Even though I’d say that test-driven development is helpful in *most* cases,
    it may not *always* be the ideal choice.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我会说测试驱动开发在**大多数**情况下是有帮助的，但它可能并不总是理想的选择。
- en: When writing code that will live on for a long time, such as implementing features
    in your team’s codebase, it is beneficial to adopt a test-driven approach. These
    tests will help you stick to the unit under test’s specification, and they will
    live on to help your team quickly identify and fix bugs.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写将长期存在的代码时，例如在你的团队代码库中实现功能，采用测试驱动的方法是有益的。这些测试将帮助你坚持单元测试的规范，并且它们将长期存在，帮助你的团队快速识别和修复错误。
- en: Test-driven development can also be useful if you aren’t feeling confident about
    the code you’re about to write. By taking a test-driven approach to writing code,
    you will get precise feedback along the way. This tight feedback loop will smooth
    your development process and reduce fear and anxiety.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对自己的代码没有信心，测试驱动开发也可能很有用。通过采用测试驱动的方法编写代码，你将在过程中获得精确的反馈。这种紧密的反馈循环将使你的开发过程更加顺畅，并减少恐惧和焦虑。
- en: Even in cases in which you’re working on legacy codebases or poorly designed
    projects, adopting a test-driven approach can be beneficial.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在你正在处理遗留代码库或设计不良的项目的情况下，采用测试驱动的方法也可能是有益的。
- en: By writing tests *before* you change legacy or poorly designed and untested
    code, you will be more confident that the unit under test’s behavior remains the
    same *after* the refactor. Furthermore, as I’ve already mentioned, this attitude
    will improve the code’s design.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在更改遗留代码或设计不良且未经测试的代码之前编写测试，你将更有信心在重构后单元测试的行为保持不变。此外，正如我之前提到的，这种态度将提高代码的设计。
- en: Nonetheless, adopting a test-driven approach may *not* be productive if you’re
    learning a new language, framework, or building a disposable prototype.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你正在学习一门新的语言、框架或构建一个可丢弃的原型，采用测试驱动的方法可能**不会**提高效率。
- en: In this case, you need to have the freedom to explore and make mistakes. Because
    this kind of code is usually short lived, your tests won’t generate much value
    because you won’t run them often enough.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你需要有自由去探索和犯错。因为这种代码通常生命周期很短，你的测试不会产生太多价值，因为你不会经常运行它们。
- en: 'Additionally, the time you take to learn how to test a new tool can add an
    unnecessary extra cost to what you’re trying to build: a quick proof of concept.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您学习如何测试新工具所花费的时间可能会给您试图构建的内容增加不必要的额外成本：一个快速的概念验证。
- en: When learning new technologies or building a quick proof of concept, it can
    often be more productive to learn how a tool works first, so that you can write
    tests easier later.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当学习新技术或构建快速的概念验证时，首先了解工具的工作原理通常会更加高效，这样您以后编写测试会更加容易。
- en: As a rule of thumb, if you’re not learning or exploring, you should take a test-driven
    approach to writing code.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条经验法则，如果您不是在学习或探索，那么您应该采用测试驱动的方法来编写代码。
- en: 9.2 Writing a JavaScript module using TDD
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 使用 TDD 编写 JavaScript 模块
- en: You can learn how to make macaroons by baking a single batch, but, to master
    this fine art, even the best pastry chefs need to **practice**.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过烘焙一个单独的批次来学习如何制作马卡龙，但要掌握这门精细的艺术，即使是最好的糕点师也需要**练习**。
- en: Deliberate practice is what this section is all about. In it, you’ll apply to
    a real-world situation what you’ve already learned about test-driven development.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 故意练习正是本节的主题。在这里，您将应用您已经学到的关于测试驱动开发的知识到实际场景中。
- en: For you to practice test-driven development, I will guide you through implementing
    a JavaScript module that generates reports about the bakery’s sales and inventory.
    Other developers will be able to integrate this module with the bakery’s online
    store codebase to allow the bakery’s staff to generate reports that can produce
    useful insights on the business’s performance and operations.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您练习测试驱动开发，我将引导您实现一个生成面包店销售和库存报告的 JavaScript 模块。其他开发者可以将此模块集成到面包店的在线商店代码库中，以便面包店的员工生成报告，这些报告可以产生关于业务表现和运营的有用见解。
- en: As usual, you’ll start by creating a new folder for this module and adding a
    `package.json` to it. To quickly create a `package.json` file, you can use `npm
    init -y`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，您将首先为这个模块创建一个新的文件夹并向其中添加一个 `package.json` 文件。要快速创建一个 `package.json` 文件，您可以使用
    `npm init -y`。
- en: Once you’ve created this folder and added a `package.json` file to it, use `npm
    install --save-dev jest` to install Jest as a dev dependency.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您创建了此文件夹并向其中添加了 `package.json` 文件，请使用 `npm install --save-dev jest` 来将 Jest
    安装为开发依赖项。
- en: To facilitate running tests, you’ll also add to your `package.json` file a `test`
    script that runs `jest`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便运行测试，您还将向 `package.json` 文件中添加一个 `test` 脚本，该脚本运行 `jest`。
- en: Listing 9.16 package.json
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.16 package.json
- en: '[PRE15]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: After completing the setup, you’ll write your first failing test for a function
    that will produce an item’s row for your reports. This function will later be
    used by the functions that will generate complete reports.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 完成设置后，您将为生成报告项行的函数编写第一个失败的测试。这个函数将后来被用于生成完整报告的函数。
- en: Your failing test should invoke a function called `generateItemRow` and expect
    it to return a comma-separated string with the item’s name, unit price, quantity,
    and the total price of all products of that kind. This test should go into a file
    called `inventoryReport.test.js`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 您的失败测试应该调用名为 `generateItemRow` 的函数，并期望它返回一个包含项名称、单价、数量和该种类所有产品总价的逗号分隔字符串。这个测试应该放入一个名为
    `inventoryReport.test.js` 的文件中。
- en: NOTE These reports will be in CSV (comma-separated values) format. This format
    delineates cells with commas and rows with newline characters.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这些报告将以 CSV（逗号分隔值）格式呈现。此格式使用逗号分隔单元格，使用换行符分隔行。
- en: Listing 9.17 inventoryReport.test.js
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.17 inventoryReport.test.js
- en: '[PRE16]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Calls generateItemRow, and expects it to generate the correct string representing
    an item’s row in the CSV file
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用 generateItemRow，并期望它生成代表 CSV 文件中项行的正确字符串
- en: To see this test fail, run `npm test`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此测试失败，请运行 `npm test`。
- en: Because you have created a failing test, you’re ready to implement `generateItemRow`
    and get instant feedback on it.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 因为您已经创建了一个失败的测试，您现在可以实施 `generateItemRow` 并立即获得关于它的反馈。
- en: Go ahead and implement an initial version of `generateItemRow` so that your
    test passes.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 继续实现 `generateItemRow` 的初始版本，以便您的测试通过。
- en: Listing 9.18 inventoryReport.js
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.18 inventoryReport.js
- en: '[PRE17]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Uses interpolation to generate a string with each row’s values
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用插值生成包含每行值的字符串
- en: Run `npm test` again, and you should see that your test now passes.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行 `npm test`，您应该会看到您的测试现在通过了。
- en: There are still a few things to improve. In this case, you could, for example,
    test multiple inputs to make sure you haven’t missed any edge cases.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有一些事情需要改进。在这种情况下，例如，您可以测试多个输入以确保您没有错过任何边缘情况。
- en: Listing 9.19 inventoryReport.test.js
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.19 inventoryReport.test.js
- en: '[PRE18]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Calls generateItemRow with multiple items, and expects the generated row strings
    to be correct
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用 `generateItemRow` 并传入多个项目，并期望生成的行字符串是正确的
- en: After rerunning your tests to make sure that none of these assertions causes
    your test to fail, you can also refactor `generateItemRow` if you want.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新运行测试以确保没有这些断言导致测试失败后，你也可以根据需要重构 `generateItemRow`。
- en: During the refactoring step, you can update `generateItemRow` in whichever way
    you want. As long as it yields the same output for each given input, your tests
    will pass.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在重构步骤中，你可以按任何方式更新 `generateItemRow`。只要它对每个给定的输入产生相同的输出，你的测试就会通过。
- en: Listing 9.20 inventoryReport.test.js
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.20 inventoryReport.test.js
- en: '[PRE19]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Creates an array with each cell’s value, and joins those values in a single
    comma-separated string
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个包含每个单元格值的数组，并将这些值连接成一个逗号分隔的字符串
- en: Once again, run your tests, and make sure that this refactor didn’t cause any
    tests to fail.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行你的测试，并确保这次重构没有导致任何测试失败。
- en: TIP By now, you might have already noticed how repetitive it is to manually
    execute `npm test` whenever you make a change. To make your tests rerun whenever
    you change a file, you can use Jest’s `--watch` option.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：到现在为止，你可能已经注意到了每次你进行更改时手动执行 `npm test` 的重复性。为了使更改文件时测试自动重新运行，你可以使用 Jest
    的 `--watch` 选项。
- en: If you append this option to your `npm` `test` command by running `npm` `test
    -- --watch`, Jest will automatically rerun your tests when it detects changes.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过运行 `npm test -- --watch` 将此选项附加到你的 `npm` `test` 命令，Jest 将在检测到更改时自动重新运行你的测试。
- en: Jest’s `watch` mode is ideal for practicing test-driven development.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 的 `watch` 模式非常适合练习测试驱动开发。
- en: While in `watch` mode, you can also filter tests by pressing the keys displayed
    when `watch` mode is in standby.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `watch` 模式下，你也可以通过按 standby 模式下显示的键来过滤测试。
- en: Another improvement you can make to the `generateItemRow` function is to make
    it return `null` for items whose quantity or price is zero so that your reports
    won’t include rows that are irrelevant to the inventory’s total value.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对 `generateItemRow` 函数进行另一个改进，使其对于数量或价格为零的项返回 `null`，这样你的报告中就不会包含与库存总价值无关的行。
- en: Before implementing that functionality, you should once again start with a failing
    test. Because this feature requires a small amount of code, and because you’ve
    already built some confidence with your previous test, you can write full-blown
    tests straightaway.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现该功能之前，你应该再次从失败的测试开始。因为这个特性需要少量的代码，而且因为你已经通过之前的测试建立了一些信心，你可以直接编写完整的测试。
- en: One of the tests you will write should call `generateItemRow` with items whose
    *quantity* is zero. The other test will call this function with items whose *price*
    is zero.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要编写的测试之一应该使用数量为零的项目调用 `generateItemRow`。另一个测试将使用价格为零的项目调用此函数。
- en: Listing 9.21 inventoryReport.test.js
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.21 inventoryReport.test.js
- en: '[PRE20]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Calls generateItemRow with sold-out items, and expects its result to be null
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用 `generateItemRow` 并传入售罄的项目，并期望其结果为 `null`
- en: ❷ Calls generateItemRow with items whose price is zero, and expects its result
    to be null
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 调用 `generateItemRow` 并传入价格为零的项目，并期望其结果为 `null`
- en: If you’re using Jest in `watch` mode, your tests will rerun as soon as you save
    the `inventoryReport.test.js` file, showing that your code doesn’t yet comply
    with these requisites.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Jest 的 `watch` 模式，当你保存 `inventoryReport.test.js` 文件时，你的测试将立即重新运行，这表明你的代码尚未符合这些要求。
- en: Because you’ve written more tests at once, you will have to write a larger chunk
    of code to make them pass. You’ve written bigger tests this time because you were
    already feeling confident about implementing the functionality you need, so you’ve
    exchanged granular feedback for the ability to iterate more quickly.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 因为一次编写了更多的测试，你将不得不编写更多的代码来使它们通过。这次你写了更大的测试，因为你已经对实现所需的功能有信心，所以你用更快的迭代能力交换了更细粒度的反馈。
- en: To make your tests pass, update `generateItemRow` so that it returns `null`
    for items whose `price` or `quantity` property is zero.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使测试通过，更新 `generateItemRow` 以使其对于价格或数量属性为零的项返回 `null`。
- en: Listing 9.22 inventoryReport.js
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.22 inventoryReport.js
- en: '[PRE21]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ If either the item’s quantity or price is zero, returns null
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果项目的数量或价格为零，则返回 `null`
- en: ❷ Returns a comma-separated string with the row’s values
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回一个包含行值的逗号分隔字符串
- en: While in Jest’s `watch` mode, save this file, and you should see all your tests
    passing.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jest 的 `watch` 模式下保存此文件，你应该会看到所有测试都通过了。
- en: Instead of having written small tests and doing tiny changes to your code multiple
    times, you’ve written bigger tests and updated your code all at once. Bigger steps
    led to quicker iteration.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 与多次编写小的测试和进行微小的代码更改相比，你编写了更大的测试，并一次性更新了你的代码。更大的步骤导致了更快的迭代。
- en: Now that `generateItemRow` is complete, you’ll implement `generateTotalRow`.
    This function will take an array of items and generate a row with the inventory’s
    total price.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`generateItemRow`已经完成，你将实现`generateTotalRow`。这个函数将接受一个项目数组，并生成一个包含库存总价的行。
- en: Before implementing `generateTotalRow`, write a failing test. If you’re feeling
    confident, as you may be by now, write a full-blown test straightaway.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现`generateTotalRow`之前，编写一个失败的测试。如果你现在感觉自信，可以立即编写一个完整的测试。
- en: Listing 9.23 inventoryReport.test.js
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.23 inventoryReport.test.js
- en: '[PRE22]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Uses generateTotalRow to generate the row with the items’ final prices, and
    expects the generated rows to be correct
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用`generateTotalRow`生成包含项目最终价格的行，并期望生成的行是正确的
- en: NOTE These extra commas are here to ensure that the cells are correctly positioned
    within the .csv file you will soon generate.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这些额外的逗号在这里是为了确保单元格在即将生成的.csv文件中正确定位。
- en: Having written this failing test, proceed to implement `generateTotalRow`. Because
    you have a test that will help you safely refactor this function, you can start
    with a naive or suboptimal implementation.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写了这个失败的测试之后，继续实现`generateTotalRow`。因为你有一个可以帮助你安全重构这个函数的测试，你可以从一个简单或次优的实现开始。
- en: Listing 9.24 inventoryReport.test.js
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.24 inventoryReport.test.js
- en: '[PRE23]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Adds to total the total price of each kind of item
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将每种项目的总价添加到总和中
- en: ❷ Returns a string representing the total value for the given set of items
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回表示给定项目集合的总价值的字符串
- en: After implementing a working version of `generateTotalRow`, you can proceed
    to refactor it if you want. You now have a test to help you avoid breaking your
    function and an initial implementation upon which you can inspire the refactor.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现了`generateTotalRow`的工作版本之后，如果你想的话，可以继续重构它。现在你有一个可以帮助你避免破坏函数的测试，以及一个可以启发重构的初始实现。
- en: Listing 9.25 inventoryReport.js
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.25 inventoryReport.js
- en: '[PRE24]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Calculates the total price of a set of items
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 计算一组项目的总价
- en: ❷ Returns a string representing the total value for the given set of items
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回表示给定项目集合的总价值的字符串
- en: At last, you will create a `createInventoryValuesReport` function that uses
    the previous two to save a .csv report to the disk.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将创建一个`createInventoryValuesReport`函数，该函数使用前两个函数将.csv报告保存到磁盘上。
- en: Because this function will be a bit more challenging to implement and involve
    multiple different moving parts, you’ll go back to writing smaller tests at a
    time, and you’ll iterate more slowly. By taking smaller steps, you’ll be able
    to get granular feedback as you implement `createInventoryValuesReport`. This
    granular feedback will make the development process smoother, help you identify
    and fix bugs more quickly, and reduce your anxiety.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个函数的实现可能会更具挑战性，并涉及多个不同的部分，你将一次编写更小的测试，并且迭代速度会慢一些。通过采取更小的步骤，你将能够在实现`createInventoryValuesReport`时获得更细致的反馈。这种细致的反馈将使开发过程更加顺畅，帮助你更快地识别和修复错误，并减少你的焦虑。
- en: Your first failing test for `createInventoryValuesReport` should call for passing
    an array with one item and expect `createInventoryValuesReport` to return a single
    line with that item’s row.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`createInventoryValuesReport`的第一个失败的测试应该要求传递一个包含一个项目的数组，并期望`createInventoryValuesReport`返回一个包含该项目行的单行。
- en: Listing 9.26 inventoryReport.test.js
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.26 inventoryReport.test.js
- en: '[PRE25]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ Calls createInventoryValuesReport, and expects it to return a string with
    the inventory’s only item
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用`createInventoryValuesReport`，并期望它返回一个包含库存唯一项目的单行字符串
- en: Because you’ve written a small test, you need to write only a small chunk of
    `createInventoryValuesReport` for the test to pass.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 因为已经编写了一个小的测试，所以只需要编写一小块`createInventoryValuesReport`代码，以便测试通过。
- en: To make your test pass, you’ll write the bare minimum amount of code. You’ll
    make `createInventoryValuesReport` pick the first item in the array and return
    the result of `generateTotalRow` for that item.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让测试通过，你需要编写最少的代码。你将让`createInventoryValuesReport`函数选择数组中的第一个项目，并返回该项目的`generateTotalRow`函数的结果。
- en: Listing 9.27 inventoryReport.js
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.27 inventoryReport.js
- en: '[PRE26]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Returns a comma-separated string representing the first item in the given
    array
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 返回表示给定数组中第一个项目的逗号分隔字符串
- en: Once you’ve seen your test pass, you can make your test more thorough so that
    it fails again.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你看到测试通过，你可以使测试更加彻底，以便它再次失败。
- en: Listing 9.28 inventoryReport.test.js
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.28 inventoryReport.test.js
- en: '[PRE27]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Calls createInventoryValuesReport with multiple items, and expects it to return
    a string correctly representing both item’s rows
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用多个项目调用 `createInventoryValuesReport`，并期望它返回正确表示项目行的字符串
- en: Now you will need to implement some more logic within `createInventoryValuesReport`
    for the test to pass. You will have to generate item rows for each item and, when
    concatenating those lines, separate them with a newline character.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要在 `createInventoryValuesReport` 中实现一些更多逻辑，以便测试通过。你必须为每个项目生成行，并在连接这些行时，用换行符分隔它们。
- en: Because you have a failing test to help you refactor later, you can go for the
    most naive implementation first.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你有一个失败的测试来帮助你稍后重构，你可以首先尝试最简单实现。
- en: Listing 9.29 inventoryReport.js
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.29 inventoryReport.js
- en: '[PRE28]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ Iterates through all the passed items
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 遍历所有传递的项目
- en: ❷ For each passed item, generates a comma-separated string representing it
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对于每个传递的项目，生成一个表示它的逗号分隔字符串
- en: ❸ If the current item is not the last in the given array, appends a line break
    to the accumulated content
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果当前项目不是给定数组中的最后一个，则将换行符追加到累积的内容中
- en: After implementing this functionality and making your tests pass, you can make
    your test more rigorous before refactoring the `createInventoryValuesReport`.
    This thorough test will give you extra safety when refactoring later.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现此功能并使测试通过后，你可以在重构 `createInventoryValuesReport` 之前使测试更加严格。这种详尽的测试将在稍后重构时为你提供额外的安全性。
- en: Listing 9.30 inventoryReport.test.js
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.30 inventoryReport.test.js
- en: '[PRE29]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ Calls createInventoryValues-Report with multiple sets of items, and expects
    it to return strings that correctly represent each set’s rows
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用多个项目集调用 `createInventoryValues-Report`，并期望它返回正确表示每个集行的字符串
- en: Now that you have thorough tests to prevent you from breaking `createInventoryValuesReport`
    and an initial implementation upon which you can do the refactoring, go ahead
    and update `createInventoryValuesReport` to make it more concise.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了详尽的测试来防止你破坏 `createInventoryValuesReport`，并且有一个可以在此基础上进行重构的初始实现，继续更新 `createInventoryValuesReport`
    以使其更加简洁。
- en: Listing 9.31 inventoryReport.js
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.31 inventoryReport.js
- en: '[PRE30]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ Creates an array of comma-separated strings representing each item’s row
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个表示每个项目行的逗号分隔字符串数组
- en: ❷ Joins each item’s row in a string, separating each row with a line break
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将每个项目的行连接成字符串，每行之间用换行符分隔
- en: Thanks to your thorough tests, you’ve implemented part of the functionality
    that `createInventoryValuesReport` should have with much more safety and without
    surprises along the way.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了详尽的测试，你以更高的安全性和没有意外的过程中实现了 `createInventoryValuesReport` 应有的部分功能。
- en: Your next task will be to generate one last row containing the accumulated value
    of all items.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 你的下一个任务将是生成包含所有项目累积价值的最后一行。
- en: As you’ve been doing up to now, you’ll change your test only slightly. You’ll
    make it validate whether the returned string includes that last row.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如你至今所做的那样，你只需稍微更改测试，使其验证返回的字符串是否包含最后一行。
- en: Listing 9.32 inventoryReport.test.js
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.32 inventoryReport.test.js
- en: '[PRE31]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ Calls createInventoryValuesReport with multiple sets of items, and expects
    it to return strings representing the expected value for each set’s report
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用多个项目集调用 `createInventoryValuesReport`，并期望它返回代表每个集报告预期值的字符串
- en: This update to the test will yield precise feedback telling you that the generated
    rows are lacking the column with an aggregated value.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这次测试的更新将提供精确的反馈，告诉你生成的行缺少包含聚合值的列。
- en: As usual, a small update to the test requires a small change to the code.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，测试的小更新需要代码的小改动。
- en: Go ahead and make your tests pass by making `createInventoryValuesReport` include
    that last row in the string it returns.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使测试通过，让 `createInventoryValuesReport` 在返回的字符串中包含最后一行。
- en: Listing 9.33 inventoryReport.js
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.33 inventoryReport.js
- en: '[PRE32]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ Creates an array of comma-separated strings representing each item’s row
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个表示每个项目行的逗号分隔字符串数组
- en: ❷ Joins each item’s row in a string, separating each row with a line break
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将每个项目的行连接成字符串，每行之间用换行符分隔
- en: ❸ Generates a row containing the inventory’s total value
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 生成包含库存总价值的行
- en: ❹ Returns a string with each item’s rows, and appends another line break followed
    by the row that indicates the inventory’s total value
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 返回包含每个项目行的字符串，并追加一个换行符，然后是表示库存总价值的行
- en: With these small iterations, you were able to validate whether `createInventoryValuesReport`
    produces the correct string before having to worry about reading or writing files
    to the disk. These multiple small iterations allowed you to build confidence as
    you implemented your report-generation function.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些小的迭代，你能够在担心读取或写入磁盘文件之前验证 `createInventoryValuesReport` 是否产生了正确的字符串。这些多次的小迭代让你在实现报告生成函数的过程中建立起信心。
- en: Now that you know how to produce a report’s content, you’ll need to make only
    a small change to write a file to the disk. Instead of returning the report’s
    contents, you’ll use Node.js’s `fs` module to write that content to the disk.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何生成报告内容，你只需要对写入磁盘进行少量更改。而不是返回报告内容，你将使用 Node.js 的 `fs` 模块将内容写入磁盘。
- en: Before updating your code, make a small update to your test so that it reads
    the report from the disk after calling `createInventoryValuesReport`.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新代码之前，对你的测试进行小更新，以便在调用 `createInventoryValuesReport` 之后从磁盘读取报告。
- en: Listing 9.34 inventoryReport.test.js
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.34 inventoryReport.test.js
- en: '[PRE33]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ Uses createInventoryValuesReport to create reports for different sets of items,
    and then reads the file written to the disk to check whether the report’s contents
    are correct
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 createInventoryValuesReport 为不同的项目集创建报告，然后读取写入磁盘的文件以检查报告内容是否正确
- en: Finally, update `createInventoryValuesReport` so that it saves the report’s
    contents to `/tmp/inventoryValues.csv`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新 `createInventoryValuesReport` 函数，使其将报告内容保存到 `/tmp/inventoryValues.csv`。
- en: Listing 9.35 inventoryReport.js
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.35 inventoryReport.js
- en: '[PRE34]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ❶ Creates an array of comma-separated strings representing each item’s row
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个表示每个项目行的逗号分隔字符串数组
- en: ❷ Joins each item’s row in a string, separating each row with a line break
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将每个项目的行连接成一个字符串，每行之间用换行符分隔
- en: ❸ Produces a row containing the inventory’s total value
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 生成包含库存总价值的行
- en: ❹ Generates the report’s contents by joining the strings with each item’s rows
    with a row indicating the inventory’s total value
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 通过将每个项目的行与表示库存总价值的行连接起来生成报告内容
- en: ❺ Writes the report’s contents to a .csv file
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将报告内容写入 .csv 文件
- en: Throughout this section, you’ve slowly built up confidence until you finished
    implementing the entire report-generation feature.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你逐渐建立起信心，直到完成了整个报告生成功能的实现。
- en: When implementing smaller and straightforward pieces of functionality, you took
    larger steps and iterated more quickly. Then, as things started getting more complicated,
    you took shorter steps and iterated slowly, so that you could build up confidence
    and get quick and precise feedback along the way.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现较小且简单的功能时，你采取了较大的步骤并快速迭代。然后，随着事情开始变得复杂，你采取了更短的步骤并缓慢迭代，以便在过程中建立信心并获得快速准确的反馈。
- en: As an exercise, try creating functions that generate different reports by applying
    test-driven development. For example, you could try creating a function that produces
    a report detailing each month’s total sales.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，尝试创建通过应用测试驱动开发生成不同报告的函数。例如，你可以尝试创建一个生成详细说明每月总销售额的函数。
- en: As you create those functions, remember to write tests first, then make the
    tests pass and refactor your code.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建这些函数时，请记住先编写测试，然后使测试通过并重构你的代码。
- en: The more confident you are, the bigger should be the steps you will take. In
    that case, you should write bigger tests and larger amounts of code at a time.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 你越自信，你采取的步骤就应该越大。在这种情况下，你应该编写更大的测试和一次写入更多的代码。
- en: If you’re implementing a complex function, reduce the size of your steps. Write
    smaller tests and tiny pieces of code in each iteration.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在实现一个复杂的函数，请减小步骤的大小。在每个迭代中编写更小的测试和更小的代码片段。
- en: 9.3 Testing top-down versus testing bottom-up
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 测试自顶向下与自底向上
- en: 'As a specialist in French desserts, when Louis prepares éclairs, he rarely
    has to stop to taste the pastry or the filling that goes into them. Because of
    how confident he is, Louis prefers to try his éclairs when they’re at their best:
    after they’re out of the oven and filled with cream.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一位法国甜点的专家，当路易斯制作闪电泡芙时，他很少停下来品尝糕点或填充其中的馅料。由于他非常自信，路易斯更喜欢在他认为最好的时候尝试他的闪电泡芙：出炉后并填充了奶油。
- en: Even though Louis doesn’t try each part of the recipe, by testing éclairs once
    they’re done he can confirm that he’s prepared them correctly.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管路易斯没有尝试食谱的每一部分，但他通过在泡芙完成后进行测试，可以确认他已经正确地准备好了它们。
- en: Cannoli, on the other hand, are a whole different story. Because Louis rarely
    makes them, he needs to taste each of the recipe’s steps. Imagine how disastrous
    it would be to fry a whole batch of cannoli molds only to find out that their
    filling isn’t nearly as good as you expected.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，卡纳洛则完全是另一回事。因为路易斯很少制作它们，他需要品尝食谱的每个步骤。想象一下，如果你只发现卡纳洛的馅料远不如你预期的那么好，就炸了一整批卡纳洛模具，那将是多么灾难性的。
- en: 'TIP For the next time you’re in Italy: in Italian, the word *cannoli* is the
    plural for *cannolo.*'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：下次你到意大利时：在意大利语中，*cannoli*这个词是*cannolo*的复数形式。
- en: An engineer’s testing workflow, similar to a pastry chef’s, varies depending
    on what they’re creating and how confident they’re feeling. When engineers feel
    more confident, they write tests at a higher level of abstraction, covering larger
    parts of their code at a time. When they aren’t, they write smaller tests, for
    smaller pieces of functionality, and build confidence as they go.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 工程师的测试工作流程，类似于糕点师，根据他们所创造的内容以及他们的信心程度而有所不同。当工程师感到更有信心时，他们会编写更高层次的抽象测试，一次覆盖他们代码的更大部分。当他们不那么自信时，他们会编写更小的测试，针对更小的功能部分，并在过程中建立信心。
- en: In this section, you’ll learn how to test your software at different levels
    of abstraction and how it impacts your business and your test-driven workflow.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何在不同层次上测试你的软件，以及它如何影响你的业务和你的测试驱动工作流程。
- en: By analyzing the previous section’s example, you’ll learn the difference between
    top-down and bottom-up approaches to writing tests, when to use each, and their
    pros and cons.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分析上一节的示例，你会了解自上而下和自下而上测试方法的区别，何时使用每种方法，以及它们的优缺点。
- en: 9.3.1 What bottom-up and top-down testing mean
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.1 自下而上和自上而下测试的含义
- en: Bottom-up testing is the testing approach for Louis’s cannoli. It consists of
    checking individual ingredient first, then each mixture of ingredients, and, finally,
    the cannoli themselves, as shown in figure 9.6.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 自下而上的测试是路易斯制作卡纳洛的测试方法。它包括首先检查单个成分，然后是各种成分的混合物，最后是卡纳洛本身，如图9.6所示。
- en: '![](../Images/CH09_F06_DaCosta.png)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH09_F06_DaCosta.png)'
- en: Figure 9.6 When making cannoli, Louis tests from the bottom up, starting with
    individual ingredients, then intermediary parts of the recipe, and, finally, the
    finished cannoli.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 在制作卡纳洛时，路易斯从下而上进行测试，从单个成分开始，然后是食谱的中间部分，最后是完成的卡纳洛。
- en: In software, the equivalent approach would be to test your smaller functions
    first and the functions that depend on them later, as figure 9.7 illustrates.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件中，等效的方法是首先测试你的较小函数，然后是依赖于它们的函数，如图9.7所示。
- en: '![](../Images/CH09_F07_DaCosta.png)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH09_F07_DaCosta.png)'
- en: Figure 9.7 Taking a bottom-up approach to testing means covering granular individual
    functions first and then moving up toward more coarse pieces of software.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 采用自下而上的测试方法意味着首先覆盖粒度更细的个体函数，然后向上移动到更粗的软件部分。
- en: When building the reporting module in the previous section, you’ve taken a bottom-up
    approach.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节构建报告模块时，你已经采取了自下而上的方法。
- en: Top-down testing, in contrast, is the approach Louis takes when making éclairs.
    As he prepares them, he doesn’t stop to taste each part of the recipe. Instead,
    he tries an éclair once the batch is done.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，自上而下的测试是路易斯制作闪电泡芙时采取的方法。在他准备它们时，他不会停下来品尝食谱的每一部分。相反，他在一批泡芙完成后尝试一次。
- en: Tasting the finished éclair attests to the quality of the previous steps because
    for it to taste good, its dough and filling must also have been made correctly,
    as shown in figure 9.8.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 品尝完成的闪电泡芙证明了之前步骤的质量，因为为了使其味道好，它的面团和馅料也必须制作正确，如图9.8所示。
- en: '![](../Images/CH09_F08_DaCosta.png)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH09_F08_DaCosta.png)'
- en: Figure 9.8 Tasting a sublime éclair indirectly ensures that each individual
    ingredient is good and that each intermediary part of the recipe went well.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 通过间接品尝完美的闪电泡芙确保每个单个成分都是好的，以及每个中间步骤的食谱都进行得很好。
- en: If you were to take a similar approach to the software you write, you’d start
    with a test for the topmost function in your dependency hierarchy, *not* with
    the tests for each of the functions in the bottom.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你采取与所编写的软件相似的方法，你将从一个测试开始，这个测试是依赖层次结构中最顶层的函数，*而不是*从底层每个函数的测试开始。
- en: Because the topmost function relies on the ones on the bottom, testing the topmost
    function also attests to the quality of its dependencies, as shown in figure 9.9\.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 因为最顶层的函数依赖于底层的函数，测试最顶层的函数也证明了其依赖项的质量，如图9.9所示。
- en: '![](../Images/CH09_F09_DaCosta.png)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH09_F09_DaCosta.png)'
- en: Figure 9.9 Testing the topmost function indirectly attests to the quality of
    its dependencies.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 测试最顶层的函数间接证明了其依赖项的质量。
- en: 9.3.2 How top-down and bottom-up approaches impact a test-driven workflow
  id: totrans-390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.2 从上到下和自下而上的方法如何影响测试驱动的工作流程
- en: In this chapter’s first section, you’ve learned that when doing test-driven
    development, the size of your steps should vary according to your confidence.
    The more confident you are, the bigger your steps should be, so that you can iterate
    more quickly. Conversely, the less confident you are, the smaller your steps will
    be, and, therefore, the slower you will iterate.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一节中，你已经了解到在进行测试驱动开发时，你的步骤大小应根据你的信心程度来变化。你越自信，你的步骤就应该越大，这样你就可以更快地迭代。相反，如果你不太自信，你的步骤就会越小，因此迭代速度会慢一些。
- en: '**Besides changing how big your tests are and how much code you write at a
    time, another way of increasing or decreasing the size of your tests is to adopt
    either a top-down or bottom-up approach.**'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '**除了改变测试的大小和每次编写的代码量之外，增加或减少测试大小的另一种方法是采用从上到下或自下而上的方法。**'
- en: In the previous section, for example, you’ve taken a bottom-up approach to writing
    tests. You’ve first tested the `generateItemRow` and `generateTotalRow` functions.
    Then, you tested the function that uses those two, as illustrated in figure 9.10.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在前一节中，你采用了自下而上的方法来编写测试。你首先测试了`generateItemRow`和`generateTotalRow`函数。然后，你测试了使用这两个函数的函数，如图9.10所示。
- en: '![](../Images/CH09_F10_DaCosta.png)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH09_F10_DaCosta.png)'
- en: Figure 9.10 When taking a bottom-up approach to writing tests, you validated
    the most granular pieces of software first and the most coarse later.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10 当采用自下而上的方法编写测试时，你首先验证了最细粒度的软件组件，然后才是最粗粒度的。
- en: Because you validated individual functions as you implemented them, by the time
    you tested the topmost function, you were already confident that its dependencies
    were going to work. The downside of having taken a bottom-up approach to testing
    is that you’ve had to write more tests, and, therefore, you iterated more slowly.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你在实现过程中验证了各个函数，所以在测试最顶层的函数时，你已经对其依赖项能够正常工作有了信心。采用自下而上测试方法的缺点是，你不得不编写更多的测试，因此迭代速度会慢一些。
- en: If you were to take a top-down approach to testing the same functionality, you
    could start with a test for the topmost function instead. Because the topmost
    function depends on the other two functions to work, by testing it, you’ll indirectly
    cover the functions upon which it depends.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你采用从上到下的方法来测试相同的功能，你可以从测试最顶层的函数开始。因为最顶层的函数依赖于其他两个函数才能工作，通过测试它，你将间接覆盖它所依赖的函数。
- en: Because you would test your software at a higher level of abstraction, you would
    need fewer tests to cover the same lines of code, and, therefore, you’ll have
    iterated more quickly. The problem with this approach is that its feedback is
    not as granular, and you’ll only know whether the unit under test is correct after
    having written a bigger chunk of code, as illustrated by figure 9.11.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你会以更高的抽象层次测试你的软件，所以你需要更少的测试来覆盖相同的代码行，因此你会更快地迭代。这种方法的缺点是它的反馈不够细粒度，你只有在写了一块更大的代码之后，才能知道被测试的单元是否正确，如图9.11所示。
- en: '![](../Images/CH09_F11_DaCosta.png)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH09_F11_DaCosta.png)'
- en: Figure 9.11 A top-down approach to testing your code would require you to start
    with more coarse pieces of software, which also indirectly cover the dependencies
    of the unit under test.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11 从上到下测试你的代码需要你从更粗粒度的软件组件开始，这也会间接覆盖被测试单元的依赖。
- en: By taking a bottom-up approach to testing, you’ll have granular feedback and
    build confidence as you write code, but you’ll have to write more tests, and,
    therefore, you’ll iterate more slowly.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采用自下而上的测试方法，你会在编写代码时获得细粒度的反馈并建立信心，但你需要编写更多的测试，因此迭代速度会慢一些。
- en: On the other hand, if you’re feeling more confident and want to iterate more
    quickly at the expense of having granular feedback, you should take a top-down
    approach to testing. By testing your software at a higher level of abstraction,
    you’ll need to write fewer tests to cover the same lines of code.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你感觉更自信，并愿意牺牲细粒度反馈以加快迭代速度，你应该采用自顶向下的测试方法。通过在更高的抽象级别测试你的软件，你需要编写更少的测试来覆盖相同的代码行。
- en: Important Taking a top-down or bottom-up approach to writing tests is another
    way of increasing or decreasing the size of your steps. The more confident you
    feel, the higher the layer of abstraction from which you’ll test your software
    should be.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：采用自顶向下或自底向上的测试方法是增加或减少你的步骤大小的一种方式。你感觉越自信，你测试软件时应采用的抽象层次就越高。
- en: Regardless of whether you choose to test your software from the top down or
    bottom up, you should still follow the same sequence of steps.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择从顶部向下还是从底部向上测试你的软件，你都应该遵循相同的步骤序列。
- en: The approach you choose will impact *exclusively* the granularity of your steps.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择的方法将**仅**影响你步骤的粒度。
- en: 9.3.3 The pros and cons of bottom-up versus top-down approaches
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.3 自底向上与自顶向下方法的优缺点
- en: When it comes to test-driven development, I have already mentioned the pros
    and cons of a bottom-up versus a top-down approach.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到测试驱动开发时，我已经提到了自底向上与自顶向下方法的优缺点。
- en: Bottom-up testing gives you more granular feedback but slows down your iteration
    speed.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自底向上测试为你提供更细粒度的反馈，但会减慢你的迭代速度。
- en: Top-down testing allows you to iterate more quickly but will generate more coarse
    feedback.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自顶向下测试允许你更快地迭代，但会产生更粗略的反馈。
- en: 'In this subsection, I’ll cover three other aspects to consider when deciding
    which strategy to adopt: reliability, costs, and coverage.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我将介绍在决定采用哪种策略时需要考虑的三个其他方面：可靠性、成本和覆盖率。
- en: After explaining each strategy’s pros and cons, I’ll teach you how to weight
    them so that you can decide what’s adequate for what you’re building.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释了每种策略的优缺点之后，我将教你如何权衡它们，以便你可以决定对你所构建的内容来说什么是足够的。
- en: Reliability
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 可靠性
- en: When preparing éclairs, tasting each of its ingredients or intermediary steps
    of the recipe can’t guarantee that the éclair that will come out of the oven is
    going to be sublime. On the other hand, tasting an éclair right out of the oven
    is a flawless strategy to ensure it tastes amazing.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 当准备马卡龙时，品尝其每个成分或食谱的中间步骤并不能保证从烤箱中取出的马卡龙将是完美的。另一方面，从烤箱中直接品尝马卡龙是确保其味道美妙的无懈可击的策略。
- en: Similarly, when taking a top-down approach to tests, you’ll write tests at a
    higher level of abstraction. Those tests will be closer to the layers of your
    software with which users will interact and therefore generate more reliable guarantees.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当你采用自顶向下的测试方法时，你将在更高的抽象级别编写测试。这些测试将更接近用户将与之交互的软件层，因此会生成更可靠的保证。
- en: Consider, for example, the function you’ve written for generating inventory
    reports. That function will be directly consumed by the programmers who use it.
    Therefore, by testing it as your consumers would use it, you’ll have more reliable
    guarantees that it works as expected.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑你为生成库存报告编写的函数。这个函数将由使用它的程序员直接消费。因此，通过像你的消费者一样测试它，你将更有可靠的保证它按预期工作。
- en: In the testing pyramid, the test for that function goes above unit tests because
    its scope is broader. It covers multiple pieces of code.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试金字塔中，该函数的测试位于单元测试之上，因为其范围更广。它覆盖了多段代码。
- en: 'The benefits of taking a top-down approach to testing are the same benefits
    you get when moving up the pyramid: you create more reliable guarantees at the
    expense of precise feedback.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 采用自顶向下测试方法的好处与你在向上移动金字塔时获得的好处相同：你以牺牲精确反馈为代价创建更可靠的保证。
- en: If you were to take a bottom-up approach to testing the same function, the tests
    for `generateItemRow` and `generateTotalRow` could give you more confidence that
    the topmost function will work. Still, you wouldn’t be sure unless you tested
    the topmost function itself.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你采用自底向上的方法测试相同的函数，`generateItemRow`和`generateTotalRow`的测试可能会让你更有信心，最高层的函数将工作。然而，除非你测试了最高层的函数本身，否则你不会确定。
- en: By writing tests for individual functions, you’ll be moving down the testing
    pyramid because your tests’ scope will be smaller.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为单个函数编写测试，你将向下移动测试金字塔，因为你的测试范围将更小。
- en: In the same way that a top-down approach yields the same results as when ascending
    the testing pyramid, a bottom-up approach produces the same results as descending.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 与自上而下的方法在测试金字塔上升时产生相同的结果一样，自下而上的方法在下降时也会产生相同的结果。
- en: As you move toward the bottom of the pyramid, you’ll have more precise feedback
    but will create less reliable guarantees. The inverse happens when moving toward
    its top.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向金字塔的底部移动时，你会得到更精确的反馈，但会创建更不可靠的保证。当你向金字塔的顶部移动时，情况则相反。
- en: Costs
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 成本
- en: Even though tasting each part of your recipes as you bake them makes you more
    confident that your desserts will be sublime, it involves a higher cost in terms
    of time.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在烘焙过程中品尝每一部分食谱可以让你更有信心你的甜点将是美味的，但这在时间成本上会更高。
- en: Similarly, taking a bottom-up approach to testing will result in slower iterations
    and, therefore, will make it more expensive to implement the unit under test.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，采用自下而上的测试方法会导致迭代速度变慢，因此，实现被测试单元的成本会更高。
- en: By testing `generateItemRow` and `generateTotalRow` individually, for example,
    you took longer to implement the functionality you wanted because you took smaller
    steps when iterating. In this case, the bottom-up approach taken has increased
    the implementation cost.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，通过单独测试`generateItemRow`和`generateTotalRow`，你因为迭代时采取了更小的步骤，所以实现所需功能的时间更长。在这种情况下，采用的自下而上的方法增加了实施成本。
- en: On the other hand, if you wanted to decrease the cost of implementing that feature,
    you could’ve tested only the topmost function, which depends on the other two.
    By doing that, you’d still have covered its dependencies but would’ve had to write
    fewer tests.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你想降低实现该特性的成本，你可以只测试最顶层的函数，该函数依赖于其他两个函数。通过这样做，你仍然覆盖了其依赖项，但需要编写的测试会更少。
- en: Even though this difference in implementation cost can be notable when implementing
    a particular piece of code, the difference in **maintenance** costs is much more
    significant.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在实现特定代码片段时，实施成本的不同可能相当明显，但维护成本的不同则更为显著。
- en: If you take a top-down approach to testing your code and, therefore, have tests
    only for the function that generates reports itself, you’ll have to update only
    its own tests if you decide to change, for example, the format of the report’s
    rows.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你采用自上而下的方法测试你的代码，并且因此只有为生成报告的函数编写测试，那么如果你决定更改，例如报告行的格式，你只需要更新其自身的测试。
- en: On the other hand, if you were to do the same change having taken a bottom-up
    approach, you’d have to update the tests not only for the function that generates
    the report but also for the individual functions that produce each row.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你采用自下而上的方法进行相同的更改，你将不得不更新生成报告的函数以及生成每一行数据的各个单独函数的测试。
- en: This extra cost is incurred because you have a significant amount of overlap
    in your tests. The test for the topmost functions will cover the same lines of
    code as the tests for the functions upon which it depends.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 这种额外的成本产生是因为你的测试中有大量的重叠。最顶层函数的测试将覆盖与它所依赖的函数的测试相同的代码行。
- en: A top-down approach to writing tests decreases the overlap between tests and,
    therefore, reduces maintenance costs. Taking a bottom-up approach has the opposite
    effect. It will cause your tests to have more overlap and, thus, will increase
    maintenance costs.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 采用自上而下的测试方法可以减少测试之间的重叠，从而降低维护成本。采用自下而上的方法则会产生相反的效果。它会导致你的测试有更多的重叠，从而增加维护成本。
- en: Coverage
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖率
- en: An everyday customer’s palate may not be as accurate as a food critic. For the
    first, an éclair with a little bit more sugar or cornstarch will still taste amazing.
    For the latter, just a bit too much butter can completely ruin it.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 普通顾客的味蕾可能没有美食评论家那么敏锐。对于前者来说，闪电泡芙中稍微多一点糖或玉米淀粉仍然会非常美味。对于后者来说，仅仅多一点黄油就可以完全破坏它的味道。
- en: If your palate is not as accurate as the critic’s, tasting your éclairs once
    they’re done may not be enough to guarantee you’ll get an extra star in that famous
    food guide. If you try the éclairs only once they’ve come out of the oven, the
    different ingredients will make it more challenging to notice imperfections.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的味蕾没有评论家那么敏锐，那么在糕点完成之后品尝你的闪电泡芙可能不足以保证你能在那本著名的美食指南中获得额外的一颗星。如果你只在泡芙从烤箱中取出后尝试一次，不同的成分会使你更难注意到瑕疵。
- en: A similar effect can happen when taking a top-down approach to testing. By testing
    coarser pieces of code, sometimes it will be more difficult to trigger side effects
    or examine in which cases individual functions will fail.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 当采用自顶向下的测试方法时，可能会产生类似的效果。通过测试较粗粒度的代码，有时会难以触发副作用或检查哪些情况下单个函数会失败。
- en: If you were to test only the function that generates reports, for example, you
    wouldn’t be able to check how `generateTotalRow` behaves when you pass it `null`
    or `undefined`. If you were to give `null` or `undefined` to the topmost function,
    it would fail before even executing `generateTotalRow`.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你只测试生成报告的函数，你将无法检查当传递给它`null`或`undefined`时`generateTotalRow`的行为。如果你将`null`或`undefined`传递给最顶层的函数，它会在执行`generateTotalRow`之前就失败。
- en: On the other hand, testing that aspect of `generateTotalRow` can be considered
    unnecessary if it’s used only by the function that generates the inventory report.
    One may argue, for example, that the only important thing is for the topmost function
    to work because it is the only function that others will directly consume.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果`generateTotalRow`只被生成库存报告的函数使用，测试该方面的行为可能被认为是多余的。例如，有人可能会争辩说，最重要的是顶层函数能够正常工作，因为它是唯一一个其他人会直接使用的函数。
- en: The problem arises when another piece of code needs to use `generateTotalRow`.
    In that case, it would be worth having covered whether `generateTotalRow` will
    behave appropriately when given different kinds of inputs, like `null` or `undefined`.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 当另一段代码需要使用`generateTotalRow`时，问题就出现了。在这种情况下，检查`generateTotalRow`在给定不同类型的输入（如`null`或`undefined`）时是否表现适当是值得的。
- en: Had you taken a bottom-up approach to testing, you could pass to `generateTotalRow`
    whichever inputs you wanted. Therefore, you’d be able to examine how it behaves
    in multiple situations without depending on how its caller uses it.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你采取自底向上的测试方法，你可以向`generateTotalRow`传递任何你想要的输入。因此，你将能够检查它在多种情况下的行为，而无需依赖于调用者如何使用它。
- en: When adopting a bottom-up strategy, you’ll directly exercise the unit under
    test. Therefore, it will be easier for you to cover its multiple branches of execution
    and give it inputs that to check how it behaves on edge cases.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 当采用自底向上的策略时，你会直接测试被测试的单元。因此，你将更容易覆盖其多个执行分支，并给出输入以检查它在边缘情况下的行为。
- en: 'As I’ve mentioned when talking about costs, that extra coverage comes at a
    price: it will be more expensive to maintain your tests.'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在谈论成本时提到的，额外的覆盖率是有代价的：维护测试的成本会更高。
- en: Deciding which approach to take
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 决定采取哪种方法
- en: Similarly to how Louis takes different approaches depending on whether he’s
    making cannoli or éclairs, you should consider different testing strategies depending
    on what you’re building.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于路易斯根据他是在制作卡纳洛尼还是闪电泡芙而采取不同的方法，你应该根据你正在构建的内容考虑不同的测试策略。
- en: The first and most important thing to consider is how confident you are in the
    code you need to write. This aspect is crucial because that’s what dictates how
    big your steps should be when taking a test-driven approach to writing code. Everything
    is secondary to being able to implement a unit under test that works as expected.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 首先也是最重要的考虑因素是，你对需要编写的代码有多大的信心。这一点至关重要，因为它决定了当你采用测试驱动的方法编写代码时，你的步骤应该有多大。其他一切都是次要的，能够实现一个按预期工作的单元测试是最重要的。
- en: When feeling confident, it’s fine to take a top-down approach to writing tests.
    You can write a test whose scope is broader and write bigger chunks of code at
    a time. This strategy will help you iterate more quickly and will still give you
    the reliability guarantees you need.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 当你感到自信时，采用自顶向下的测试方法来编写测试是完全可以的。你可以编写一个范围更广的测试，并一次编写更大的代码块。这种策略将帮助你更快地迭代，同时仍然提供你需要的安全保证。
- en: If you *already* know that the unit under test works as expected, such as when
    dealing with an untested legacy codebase, top-down testing is even more beneficial.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经知道被测试的单元按预期工作，例如在处理未经测试的遗留代码库时，自顶向下的测试就更有益。
- en: By writing broader tests, you will indirectly validate the small functions upon
    which the pieces of code you’re testing depend. Because each test’s scope is larger,
    you will need fewer tests to cover your application, and, therefore, you will
    take less time to test it.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写更广泛的测试，你将间接验证你正在测试的代码所依赖的小函数。因为每个测试的范围更大，所以你需要更少的测试来覆盖你的应用程序，因此，测试所需的时间会更少。
- en: On the other hand, when you need to build confidence as you go, it’s better
    to go for a bottom-up strategy. You’ll write tests whose scope is smaller, but
    you will be able to iterate smoothly and reduce your fear as you move toward the
    correct implementation.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当你需要逐步建立信心时，采用自下而上的策略会更好。你会编写范围较小的测试，但你将能够平滑地迭代，并在向正确实现迈进的过程中减少恐惧。
- en: Even if you go for a bottom-up approach during the implementation phase, you
    can always delete tests during the code’s maintenance phase.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你在实现阶段采用自下而上的方法，你仍然可以在代码的维护阶段删除测试。
- en: When implementing your code, you can leave your passing tests alone. You’ve
    already spent the time to write them, and there wouldn’t be any benefit in deleting
    them now.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现代码时，你可以保留你的通过测试。你已经花费了时间来编写它们，现在删除它们不会有任何好处。
- en: During the code’s maintenance phase, for example, if you change your unit under
    test so that the tests for individual functions start to fail, you can choose
    to delete those tests and update only the test for the topmost function instead.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在代码的维护阶段，如果你改变了你的测试单元，导致单个函数的测试开始失败，你可以选择删除这些测试，只更新最顶层函数的测试。
- en: If the topmost function already covers the ones in the bottom, you can save
    yourself the time of updating the more granular tests and stick to updating only
    the more coarse ones.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 如果最顶层的函数已经覆盖了底层的函数，你可以节省更新更细粒度测试的时间，只需更新更粗粒度的测试即可。
- en: The second most important aspect to consider when deciding which approach to
    take is to look at your dependency graph.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定采用哪种方法时，考虑的第二重要方面是查看你的依赖图。
- en: When Louis bakes éclairs, for example, it may not be worth it for him to test
    each step of the recipe, but because multiple steps and other desserts depend
    on the same ingredients, it will be worth for him to check whether those ingredients
    are good.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当路易斯烘焙马卡龙时，他可能不需要测试食谱的每一步，但由于多个步骤和其他甜点依赖于相同的原料，他检查这些原料是否良好是有价值的。
- en: Individually inspecting critical ingredients like eggs, milk, butter, and sugar,
    as illustrated in figure 9.12, will save him a lot of headaches when baking multiple
    other desserts, especially éclairs.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 如图9.12所示，单独检查像鸡蛋、牛奶、黄油和糖这样的关键原料，在烘焙其他多个甜点，尤其是马卡龙时，将节省他很多麻烦。
- en: '![](../Images/CH09_F12_DaCosta.png)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH09_F12_DaCosta.png)'
- en: Figure 9.12 It’s more valuable to individually inspect milk, eggs, butter, and
    sugar because they will be key ingredients for multiple recipes.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12 单独检查牛奶、鸡蛋、黄油和糖更有价值，因为它们将是多个食谱的关键原料。
- en: The same principle is valid for software testing.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的原则也适用于软件测试。
- en: Consider, for example, that you’ll adapt your `generateTotalRow` function so
    that it works for multiple kinds of reports.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一下你可能需要调整你的`generateTotalRow`函数，使其适用于多种类型的报告。
- en: In that case, it would be wise to write tests for `generateTotalRow` itself
    so that you can ensure it will work for whichever reports that depend on it, as
    figure 9.13 shows.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，为`generateTotalRow`本身编写测试是明智的，这样你可以确保它将适用于所有依赖于它的报告，如图9.13所示。
- en: '![](../Images/CH09_F13_DaCosta.png)'
  id: totrans-461
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH09_F13_DaCosta.png)'
- en: Figure 9.13 By testing a function that many parts of your software will use,
    you can create a solid foundation upon which you can build confidently.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13 通过测试你的软件将广泛使用的函数，你可以创建一个坚实的基础，在此基础上你可以自信地构建。
- en: By taking this bottom-up approach to testing `generateTotalRow`, you’ll create
    more reliable guarantees, which means that you’ll be more confident it will work
    for whichever new reports depend on it.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采用自下而上的方法测试`generateTotalRow`，你会创建更可靠的保证，这意味着你将更有信心它将适用于所有依赖于它的新报告。
- en: Additionally, because you’ll directly test `generateTotalRow`, you can more
    easily validate many different kinds of edge cases, ensuring that it will not
    fail if other reports that depend on it end up passing it unusual arguments.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，因为你将直接测试`generateTotalRow`，你可以更容易地验证许多不同类型的边缘情况，确保如果其他依赖于它的报告最终传递了不寻常的参数，它不会失败。
- en: In this case, your costs maintenance will still go up, but they will be justified
    because `generateTotalRow` has grown in importance. Because various other pieces
    of code depend on it, it’s more critical for it to work adequately.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你的维护成本会增加，但这是有道理的，因为`generateTotalRow`的重要性增加了。由于各种其他代码依赖于它，它能够适当地工作变得更加关键。
- en: The more functions of code depend on a piece of code, the more thorough your
    tests for that piece of code should be.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的更多功能依赖于某段代码，那么对该段代码的测试就应该越彻底。
- en: To make your tests more thorough but increase costs, take a bottom-up approach,
    and check the unit under test directly. To make them less rigorous but reduce
    costs, take a top-down approach and cover the unit under test through validating
    the piece of code that depends on it.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 要使你的测试更彻底但增加成本，采用自下而上的方法，并直接检查测试单元。要使它们不那么严格但减少成本，采用自上而下的方法，并通过验证依赖于它的代码片段来覆盖测试单元。
- en: 9.4 Balancing maintenance costs, delivery speed, and brittleness
  id: totrans-468
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 平衡维护成本、交付速度和脆弱性
- en: For a bakery to be successful, selling the tastiest desserts is not enough.
    Besides amazing macaroons, it needs to make some sweet profit.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一家面包店来说，仅仅出售最美味的甜点是不够的。除了惊人的马卡龙，它还需要赚取一些甜美的利润。
- en: Even if its pastries are sublime, and the bakery’s profit margin is large, it
    also needs to produce and sell a reasonable quantity of sugary goods so that its
    revenue exceeds its costs.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 即使它的糕点非常美味，面包店的利润率很高，它也需要生产和销售一定数量的甜食，以便其收入超过成本。
- en: This introduction may lead you to think this is the subject of your first class
    in Capitalism 101, but it actually says a lot about tests, too.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 这篇介绍可能会让你认为这是你的第一堂《资本主义101》课程的课题，但实际上它也说了很多关于测试的事情。
- en: When it comes to producing software, if you can’t deliver new features and fix
    bugs quickly enough, it doesn’t matter how good your code is and how thorough
    its tests are. On the other hand, quickly producing software is worthless if it
    doesn’t work.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到生产软件时，如果你不能快速交付新功能并修复错误，那么你的代码有多好，其测试有多彻底，都没有关系。另一方面，如果软件不能工作，快速生产软件也是毫无价值的。
- en: In this section, you’ll learn how to balance a test-driven workflow with delivery
    speed, so that you can keep your tests maintainable and robust.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何平衡测试驱动的工作流程和交付速度，以便你可以保持你的测试可维护和健壮。
- en: To have thorough tests that instill confidence but don’t hinder delivering new
    features, you need to understand that the tests you need for implementing a feature
    are different from the tests you need for maintaining it.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 要有详尽的测试来建立信心但又不阻碍交付新功能，你需要理解，你为实现一个功能所需的测试与为维护它所需的测试是不同的。
- en: As I’ve mentioned in the previous section, these different phases in your software’s
    life cycle demand different kinds of tests, which I’ll cover separately within
    this section.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在上一节中提到的，你的软件生命周期中的不同阶段需要不同类型的测试，我将在本节中分别介绍。
- en: NOTE Different parts of your software can be in different phases. You can follow
    a test-driven approach to implementing *new* functionality on a codebase whose
    other features are *already* in their maintenance phase.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你的软件的不同部分可能处于不同的阶段。你可以在其他功能已经处于维护阶段的基础上，采用测试驱动的方法来实现*新*功能。
- en: 9.4.1 Test-driven implementation
  id: totrans-477
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.1 测试驱动实现
- en: When creating code, you want to focus on correctness and iteration speed over
    all else. You want to build up confidence and gradually move toward your unit
    under test’s final implementation.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时，你希望专注于正确性和迭代速度，而不仅仅是其他方面。你希望建立信心，并逐渐向你的测试单元的最终实现迈进。
- en: To achieve a working implementation, the most important attitude to have is
    to adjust the size of your steps according to how confident you feel.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现一个可工作的实现，最重要的态度是根据你感觉有多自信来调整你的步骤大小。
- en: When implementing a piece of code for the first time, it’s common to be not
    as confident as you’d be when maintaining it. Therefore, your implementation phase
    will usually demand more tests.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次实现一段代码时，通常不会像在维护时那样自信。因此，你的实现阶段通常需要更多的测试。
- en: The more steps you need to implement a feature, the higher its costs will be.
    More steps lead to more iterations, which cause you to take more time to get to
    a final result.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要更多步骤来实现一个功能，其成本就会越高。更多的步骤会导致更多的迭代，这会让你花费更多的时间才能得到最终的结果。
- en: Even though smaller steps and more granular tests will incur at a higher cost,
    that doesn’t mean you should necessarily write fewer tests. If you *need* those
    tests to get to a final result that fulfills the specification given to you, those
    are the tests you *should* write.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 即使较小的步骤和更细粒度的测试会产生更高的成本，但这并不意味着你一定需要写更少的测试。如果你*需要*这些测试才能得到一个满足你给出的规格的最终结果，那么这些就是你应该写的测试。
- en: '**If your software doesn’t work, it doesn’t matter how quickly you can write
    it**. Yet, there are a few techniques that could help you accelerate your test-driven
    implementation phase.'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果你的软件不能正常工作，那么你写得有多快都没有关系**。然而，有一些技术可以帮助你加速你的测试驱动实现阶段。'
- en: The first of these techniques is to alternate between top-down and bottom-up
    approaches, depending on your dependency graph.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术中的第一个是交替使用自顶向下和自底向上的方法，这取决于你的依赖图。
- en: Whenever a piece of software has multiple dependants, it’s worth testing it
    in isolation.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个软件组件有多个依赖项时，对其进行单独测试是值得的。
- en: If, for example, multiple report-generation functions use the previous module’s
    `generateTotalRow` function, by testing it, you will also generate guarantees
    that apply to all of its dependants, as shown in figure 9.14.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果有多个报告生成函数使用了前一个模块的 `generateTotalRow` 函数，通过对其进行测试，你也将为所有依赖它的函数生成保证，如图 9.14
    所示。
- en: '![](../Images/CH09_F14_DaCosta.png)'
  id: totrans-487
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH09_F14_DaCosta.png)'
- en: Figure 9.14 A test that covers the `generateTotalRow` function will indirectly
    create reliability guarantees that impact all of its dependants.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.14 一个涵盖 `generateTotalRow` 函数的测试将间接创建影响所有依赖项的可靠性保证。
- en: By writing a specific test for `generateTotalRow`, when you add a new function
    that depends on it, you’ll be able to take bigger steps because you’ll already
    be confident that `generateTotalRow` works. These bigger steps lead to a quicker
    iteration and, therefore, reduce implementation costs without compromising quality
    guarantees.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为 `generateTotalRow` 编写特定的测试，当你添加一个依赖于它的新函数时，你将能够迈出更大的步伐，因为你已经对 `generateTotalRow`
    的工作有信心。这些更大的步伐导致迭代速度更快，因此在不影响质量保证的情况下，减少了实施成本。
- en: Having specific tests for `generateTotalRow` doesn’t mean you shouldn’t rigorously
    test the functions that use it. It means that when testing them, you’ll be quicker
    because you’ll take bigger steps and need fewer iterations.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `generateTotalRow` 有特定的测试并不意味着你不应该严格测试使用它的函数。这意味着在测试它们时，你会更快，因为你会迈出更大的步伐，需要更少的迭代。
- en: Testing in isolation functions that have multiple dependants makes you more
    confident when implementing those dependants. Therefore, they can help you accelerate
    your test-driven workflow.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 对具有多个依赖项的函数进行单独测试，使你在实现这些依赖项时更有信心。因此，这可以帮助你加速你的测试驱动工作流程。
- en: Considering that testing these common pieces of code can lead to more confidence
    and, therefore, increase your development speed, another way to take advantage
    of this technique is to reuse more code.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到测试这些常见的代码片段可以带来更多的信心，从而提高你的开发速度，利用这种技术的另一种方法是重用更多的代码。
- en: If your future `generatePendingOrdersReport` has rows that are similar to the
    ones generated by `generateItemRow`, instead of creating a new function and testing
    it from scratch, you can update `generateItemRow` and its tests.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的未来 `generatePendingOrdersReport` 包含与 `generateItemRow` 生成的行相似的行，那么你不需要从头创建一个新函数并对其进行测试，而是可以更新
    `generateItemRow` 及其测试。
- en: By updating `generateItemRow` so that it can cover both use cases, you can avoid
    creating multiple new tests and, instead, just update the ones you already have,
    as shown in figure 9.15.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更新 `generateItemRow` 以使其能够覆盖两种用例，你可以避免创建多个新的测试，而是只需更新你已有的测试，如图 9.15 所示。
- en: '![](../Images/CH09_F15_DaCosta.png)'
  id: totrans-495
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH09_F15_DaCosta.png)'
- en: Figure 9.15 To avoid adding a new function and extra tests for it, you can update
    the `generateItemRow` function’s tests and reuse them in multiple places.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.15 为了避免添加新的函数和额外的测试，你可以更新 `generateItemRow` 函数的测试，并在多个地方重用它们。
- en: This reuse leads to more modular software and way less code to maintain because
    you reduce the quantity of application code you have *and* the number of tests
    you need.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 这种重用导致软件模块化程度更高，维护代码量大大减少，因为你减少了应用程序代码的数量以及你需要进行的测试数量。
- en: The problem with this approach is that you won’t always be able to reuse code
    so easily. Therefore you’ll have no choice but to end up having to write multiple
    new tests for the individual functions you’ll create.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，你并不总是能够轻松地重用代码。因此，你将不得不为你要创建的各个函数编写多个新的测试。
- en: In that case, as we discussed in the previous section, it’s worth pushing for
    a top-down approach. If you have a single function that uses `generateDealRow`,
    such as the one in figure 9.16 for example, it’s worth writing tests only for
    the topmost function so that you can obtain reliable guarantees with fewer tests.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在上一节讨论的那样，在这种情况下，推动自顶向下的方法是有价值的。如果你有一个单独的函数使用`generateDealRow`，例如图9.16中的例子，那么只为最高层的函数编写测试是有价值的，这样你可以用更少的测试获得可靠的保证。
- en: '![](../Images/CH09_F16_DaCosta.png)'
  id: totrans-500
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH09_F16_DaCosta.png)'
- en: Figure 9.16 Because `generateSalesReport` is the only function that uses `generateDealRow`,
    it’s more valuable to add a test for the topmost function that indirectly covers
    its dependants.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16 因为`generateSalesReport`是唯一使用`generateDealRow`的函数，所以为最高层的函数添加测试，间接覆盖其依赖项，更有价值。
- en: Unfortunately, you won’t always be confident enough to take this approach, especially
    if you’re writing a piece of code that you consider to be complex to implement.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，你并不总是有足够的信心采取这种方法，尤其是如果你正在编写你认为实现起来复杂的代码。
- en: If that’s the case, don’t be afraid to take smaller steps. Remember that your
    main goal in the implementation phase is to write software that works.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，不要害怕采取更小的步骤。记住，在实现阶段，你的主要目标是编写出工作的软件。
- en: 9.4.2 Test-driven maintenance
  id: totrans-504
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.2 测试驱动维护
- en: When maintaining code, your main goal is to update its functionality or fix
    bugs without breaking what’s already working. To make your costs low in this phase
    of your software’s life cycle, you must be able to do it as reliably and quickly
    as possible.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 在维护代码时，你的主要目标是更新其功能或修复错误，而不会破坏已经正常工作的部分。为了使你在软件生命周期这一阶段的成本保持低，你必须能够尽可能可靠和快速地完成它。
- en: By the time you get to this phase, you’ll already have tests for the pieces
    of code you’ll update. Therefore, you must take advantage of this moment to decide
    which tests you still need, which deserve a refactor, and which you can delete.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一阶段，你将已经为将要更新的代码片段编写了测试。因此，你必须利用这个时刻来决定哪些测试仍然需要，哪些值得重构，以及哪些可以删除。
- en: Keeping tests “green”
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 保持测试“绿色”
- en: Suppose the thermometer Louis uses to calibrate the bakery’s ovens doesn’t measure
    temperatures correctly. In that case, he will miscalibrate his ovens, and his
    macaroons will not be on par with the bakery’s usual *standard d’excellence*.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 假设路易斯用来校准面包店烤箱的温度计不能正确测量温度。在这种情况下，他将无法正确校准他的烤箱，他的马卡龙将无法达到面包店通常的*卓越标准*。
- en: Similarly, for a team to maintain software that works, they must have thorough
    passing tests. Teams that commit failing tests won’t know whether the test is
    out of date or their code has a problem.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，为了维护一个工作的软件，团队必须拥有全面的通过测试。提交失败测试的团队将不知道测试是否过时，或者他们的代码有问题。
- en: If you allow failing tests to be merged to your codebase, as the codebase gets
    older, the number of failing tests is likely to proliferate, making it harder
    to distinguish signal from noise.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你允许失败的测试合并到你的代码库中，随着代码库的逐渐老化，失败的测试数量很可能会激增，这使得区分信号和噪声变得更加困难。
- en: '**Merged code should always have all of its tests passing**.'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '**合并的代码应该始终通过所有测试**。'
- en: If the unit under test’s behavior changed, update its tests. If you have tests
    that cover edge cases or functionalities that don’t exist anymore, delete them.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 如果被测试的单元的行为发生了变化，更新其测试。如果你有覆盖边缘情况或不再存在的功能的测试，删除它们。
- en: Refactoring tests
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 重构测试
- en: In the same way that it’s difficult to update poorly written code, it’s difficult
    to update poorly written tests.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 就像更新编写糟糕的代码很难一样，更新编写糟糕的测试也很困难。
- en: Refactoring tests reduces costs because it makes developers update tests and
    understand a codebase more quickly.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 重构测试可以降低成本，因为它使得开发者能够更快地更新测试和理解代码库。
- en: '**When tests are well written and easily understandable, you take less time
    to update them, which causes you to deliver more code sooner**.'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '**当测试编写得很好且易于理解时，你更新它们的时间会更少，这会导致你更快地交付代码**。'
- en: If you follow good design principles, such as not repeating yourself, you will
    have less code to update at a time, which, in turn, will lead to shorter, faster
    iterations.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循良好的设计原则，例如不要重复自己，你每次更新的代码会更少，这反过来又会导致更短、更快的迭代。
- en: Furthermore, **by making tests more readable, you create better documentation**.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，**通过使测试更易于阅读，你可以创建更好的文档**。
- en: When a colleague, or maybe even your future self, needs to check how a particular
    piece of code works, they can look at its tests. Well-written tests will provide
    them with clear examples of how to use the unit under test’s APIs and what edge
    cases it can handle.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 当同事或甚至你未来的自己需要检查特定代码片段的工作方式时，他们可以查看其测试。编写良好的测试将为他们提供如何使用被测试单元的API的清晰示例以及它可以处理的边缘情况。
- en: Whenever you have tests which are repetitive, unreadable, or unintelligible,
    refactor them if you have the time.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时你都有重复、难以阅读或不清晰的测试，如果你有时间，就重构它们。
- en: Deleting redundant tests
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 删除冗余测试
- en: Deleting redundant tests leads to quicker iterations because you won’t have
    to fix them if they break or read or update them in future tasks. Nonetheless,
    it’s essential to preserve quality guarantees.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 删除冗余测试可以加快迭代速度，因为你不必在它们损坏或在未来任务中读取或更新它们时修复它们。然而，保留质量保证是至关重要的。
- en: To determine which tests you can delete, you need to think about which tests
    overlap.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定你可以删除哪些测试，你需要考虑哪些测试重叠。
- en: Consider, for example, the last example of this section’s previous part. In
    it, I encouraged you to, if possible, take a top-down approach to testing the
    `generateSalesReport` function, like the one shown in figure 9.17\. If you weren’t
    feeling confident enough to do that, you might have ended up with multiple tests
    for `generateDealRow` as well as a test for the topmost `generateSalesReport`
    function.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑本节前一部分的最后一个例子。在它里面，我鼓励你如果可能的话，采用自顶向下的方法测试`generateSalesReport`函数，就像图9.17中所示的那样。如果你没有足够的信心这样做，你可能会得到针对`generateDealRow`的多个测试以及针对最顶层`generateSalesReport`函数的测试。
- en: In this case, it wouldn’t have been worth it to delete the individual tests
    you’ve written during your implementation phase because they were already providing
    reliable guarantees.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，删除你在实现阶段编写的单独测试是不值得的，因为它们已经提供了可靠的保证。
- en: '![](../Images/CH09_F17_DaCosta.png)'
  id: totrans-526
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH09_F17_DaCosta.png)'
- en: Figure 9.17 When performing test-driven development, you added tests that target
    the `generateDealRow` function itself. Because you also implemented a test for
    the topmost `generateSalesReport`, the tests for `generateDealRow` ended up being
    redundant.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.17 在进行测试驱动开发时，你添加了针对`generateDealRow`函数本身的测试。因为你也为最顶层的`generateSalesReport`实现了测试，所以`generateDealRow`的测试最终变得冗余。
- en: Additionally, at the time, you couldn’t predict whether you’d ever have to change
    either `generateSalesReport` or `generateDealRow`. Therefore, because you have
    already taken the time to write these functions, it’s better to keep them.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在当时，你无法预测你是否需要更改`generateSalesReport`或`generateDealRow`。因此，因为你已经花时间编写了这些函数，所以最好保留它们。
- en: Now that you’re in your software’s maintenance phase, you can decide whether
    you still need those tests or whether they overlap with the tests for `generateSalesReport`
    that you’ll write or update.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经进入软件的维护阶段，你可以决定是否还需要那些测试，或者它们是否与你要编写或更新的`generateSalesReport`测试重叠。
- en: Imagine, for example, that you’ll have to update `generateSalesReport` and change
    the format of each individual deal row. To do that, you’d update your tests first
    and then update the unit under test itself.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下你可能需要更新`generateSalesReport`并更改每个单独的交易行的格式。为此，你首先更新测试，然后更新被测试单元本身。
- en: After updating `generateSalesReport`, the individual tests for `generateDealRow`
    will break because their unit under test has had to change, as shown in figure
    9.18.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新`generateSalesReport`之后，针对`generateDealRow`的单独测试将会失败，因为它们的被测试单元已经发生了变化，如图9.18所示。
- en: '![](../Images/CH09_F18_DaCosta.png)'
  id: totrans-532
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH09_F18_DaCosta.png)'
- en: Figure 9.18 You can delete overlapping tests with weaker reliable guarantees
    during your software’s maintenance phase.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.18 在软件的维护阶段，你可以删除具有较弱可靠保证的重叠测试。
- en: In that case, if the topmost test already proves that the report produced is
    correct, you can safely delete the tests for `generateDealRow` because they overlap
    with the tests for the topmost `generateSalesReport` and provide weaker reliability
    guarantees.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 在那种情况下，如果最顶层的测试已经证明了生成的报告是正确的，你可以安全地删除`generateDealRow`的测试，因为它们与最顶层的`generateSalesReport`测试重叠，并且提供了较弱的可靠性保证。
- en: Deleting these tests will save you the time you’d have to take to update them
    and will preserve the quality guarantees you have because you’re already covering
    those tests’ assertion targets within the topmost test for `generateSalesReport`.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 删除这些测试将节省你更新它们的时间，并将保持你已有的质量保证，因为你已经在`generateSalesReport`的最高测试中覆盖了这些测试的断言目标。
- en: Even though you had to take a bottom-up approach when writing these functions,
    you were able to migrate to a top-down approach during your maintenance phase
    and, therefore, reduce overlap and preserve quality.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你在编写这些函数时不得不采取自下而上的方法，但在维护阶段你能够迁移到自上而下的方法，因此减少了重叠并保持了质量。
- en: By deleting tests whose assertion targets overlap, you’ll save yourself the
    time of fixing those tests and removing unnecessary tests for the next developer
    who’s going to update that piece of code.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 通过删除断言目标重叠的测试，你将节省修复这些测试和为下一个更新该代码块的开发者移除不必要的测试的时间。
- en: 9.5 Setting up an environment for TDD to succeed
  id: totrans-538
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5 为TDD成功设置环境
- en: Being a successful pastry chef is as much about sugar, eggs, and flour as it
    is about building a brand and an inviting environment for customers to enjoy.
    For a bakery to succeed, it would be magnificent if they could be featured in
    a popular TV series or have photogenic desserts. New York City bakeries, I’m looking
    at you.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的糕点师不仅关乎糖、鸡蛋和面粉，还关乎建立品牌和吸引顾客的环境，让他们享受。如果面包店能出现在热门电视剧中或拥有吸引人的甜点，那将是了不起的。纽约市的面包店，我在看着你。
- en: Similarly, to succeed in adopting a test-driven workflow, businesses should
    do more than just follow the “red, green, refactor” mantra. For a company to create
    an environment in which test-driven development can thrive, they must adapt their
    practices, processes, and attitudes toward producing software.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，为了成功采用测试驱动的工作流程，企业应该做的不仅仅是遵循“红色、绿色、重构”的咒语。为了创造一个测试驱动开发可以繁荣的环境，公司必须调整他们的实践、流程和对待软件生产的态度。
- en: In this section, I’ll explain what these changes to practices, processes, and
    attitudes are and how they can help software businesses thrive when adopting test-driven
    development.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将解释这些对实践、流程和态度的改变，以及它们如何帮助软件企业在采用测试驱动开发时繁荣发展。
- en: 9.5.1 Teamwide adoption
  id: totrans-542
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.1 全员采用
- en: The best pastry chefs have their staff follow their recipes because they want
    all of their desserts to be on par with the bakery’s reputation. Imagine, for
    example, how disastrous it could be if each baker used different quantities and
    kinds of sugar and cacao powder to make chocolate frostings. By not following
    the bakery’s standards, they’d risk ruining not only the frosting itself but also
    the dessert with which they will combine it.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的糕点师会让他们的员工遵循他们的食谱，因为他们希望所有的甜点都能与面包店的声誉相匹配。例如，想象一下，如果每个糕点师使用不同数量和种类的糖和可可粉来制作巧克力糖霜，那可能会多么灾难性。如果不遵循面包店的标准，他们不仅会破坏糖霜本身，还会破坏与之结合的甜点。
- en: Similarly, engineers who don’t practice test-driven development put at risk
    the work of others whose pieces of software will interact with theirs.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，不实践测试驱动开发的工程师将使其他人的工作处于风险之中，这些软件将与他们的软件交互。
- en: Imagine, for example, that you’ll be responsible for implementing the function
    that generates all of the different kinds of reports the bakery needs.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，例如，你将负责实现生成面包店需要的所有不同类型报告的函数。
- en: Even if you take a disciplined test-driven approach to your work, it will still
    be at risk if the people who implement each individual report take a careless
    approach to theirs.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你对自己的工作采取严格的测试驱动方法，如果实施每个单独报告的人采取粗心大意的方法，它仍然会处于风险之中。
- en: If any of the reports upon which your work relies happen to be incorrect, your
    work will produce inadequate results, too.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你依赖的任何报告都是错误的，你的工作将产生不充分的结果。
- en: Not having tests for the underlying functions upon which yours depend will undermine
    your confidence in taking small steps toward a working solution. As you implement
    your `generateAllReports` function, you won’t know whether it’s your code and
    your tests that are incorrect or others’, requiring you to investigate and fix
    bigger chunks of code at a time.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你依赖的底层函数没有测试，将削弱你朝着工作解决方案迈出小步的信心。当你实现`generateAllReports`函数时，你不知道是代码和测试错误还是别人的，这需要你一次调查和修复更大的代码块。
- en: By limiting your capacity to take small iterative steps toward a solution, the
    fear-reducing and design-improving benefits of test-driven development will be
    significantly limited.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 通过限制你向解决方案迈进的小步骤的能力，测试驱动开发减少恐惧和改进设计的益处将受到显著限制。
- en: Important Engineers should consider tests to be an integral part of the development
    process. When practicing test-driven development, tests are as much of a deliverable
    as your application code is.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的 工程师应该将测试视为开发过程的一个组成部分。在实践测试驱动开发时，测试与你的应用程序代码一样是交付成果。
- en: When engineers don’t consider tests to be an integral part of their development
    process, tests tend to be more superficial, and coverage tends to be poorer.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 当工程师不认为测试是他们开发过程的一个组成部分时，测试往往更加肤浅，覆盖率也往往较差。
- en: Besides demanding others to take bigger steps, developers who don’t take a disciplined
    test-driven approach to their work will increase the workload of others who do.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 除了要求他人采取更大的步骤外，不采取纪律性的、以测试为导向的方法来处理工作的开发者会增加其他采取这种方法的人的工作量。
- en: Consider, for example, the `generateAllReports` function, which I’ve just mentioned.
    If you were to take a disciplined test-driven approach to writing it without having
    tests for the functions upon which it depends, you’d have to start by validating
    for these dependencies.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一下我刚刚提到的`generateAllReports`函数。如果你在编写它时采取了一种纪律性的、以测试为导向的方法，而没有为它所依赖的函数编写测试，你将不得不首先验证这些依赖项。
- en: By taking a test-driven approach and building confidence from the bottom up,
    you’ll again be able to create a situation in which you’ll be able to make smaller
    iterative steps toward a solution.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采取以测试为导向的方法并从底部建立信心，你将再次能够创造一个能够逐步向解决方案迈进的小步骤的情况。
- en: The problem with having to test other’s functions is that you will take longer
    to write these tests. If the first person to implement each piece of code creates
    tests for their own work, others won’t necessarily have to read or even update
    them. Instead, they can work on a higher level of abstraction and be more confident
    that the code upon which they depend has been correctly implemented.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 必须测试他人函数的问题是你将花费更长的时间来编写这些测试。如果每个代码片段的第一个实现者为他们自己的工作创建测试，其他人就不一定需要阅读或甚至更新它们。相反，他们可以在更高的抽象级别上工作，并更有信心他们所依赖的代码已被正确实现。
- en: Additionally, because a function’s original implementer has more context in
    their heads as they write it, they’ll be able to write more thorough tests and
    think about more unconvential edge cases.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于函数的原始实现者编写它时在脑海中拥有更多的上下文，他们将能够编写更全面的测试，并考虑更多非常规的边缘情况。
- en: Important Testing your own code is a compromise with yourself and your coworkers.
    By taking a disciplined, test-driven approach to the code you write, you will
    improve your workflow *and* others’.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的 测试自己的代码是与自己和同事之间的妥协。通过采取一种纪律性的、以测试为导向的方法来编写代码，你将改善自己的工作流程*并且*他人的。
- en: On top of these technical benefits, **adopting test-driven development tends
    to make time and complexity estimations more precise**.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些技术优势之上，**采用测试驱动开发往往会使时间和复杂度估计更加精确**。
- en: By always delivering rigorously tested code, developers are less likely to find
    incorrect pieces of code as they implement other functionalities in the future.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 通过始终交付经过严格测试的代码，开发者将来在实现其他功能时不太可能发现错误的代码片段。
- en: When estimation happens *before* developers have tested their previous work,
    they may have to take extra time to fix existing mistakes for which they didn’t
    account.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 当估计发生在开发者测试他们之前的工作之前时，他们可能需要额外的时间来修复他们没有考虑到现有错误。
- en: Furthermore, tests serve as documentation for the code. When interfacing with
    a piece of code written by someone else, developers can consult existing tests
    to see usage examples and possible edge cases. Checking these usage examples is
    usually way quicker than having to read and interpret various lines of application
    code.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，测试还充当了代码的文档。当与别人编写的代码进行交互时，开发者可以查阅现有的测试来查看使用示例和可能的边缘情况。检查这些使用示例通常比阅读和解释各种应用程序代码要快得多。
- en: Finally, because developers “inherit” a tight feedback loop from the previous
    person who wrote the pieces of code they’re dealing with, they’ll be able to work
    in a much more iterative fashion. Instead of having to write tests for the existing
    code themselves, they’ll have all the infrastructure they need to make small changes
    at a time. Therefore, it will be more natural for them to follow TDD’s “red, green,
    refactor” mantra right from the beginning.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于开发者“继承”了之前编写他们正在处理的代码的人的紧密反馈循环，他们能够以更迭代的模式工作。他们不需要自己编写现有代码的测试，他们将有所有必要的基础设施来一次进行小改动。因此，他们从一开始就遵循TDD的“红、绿、重构”箴言将更加自然。
- en: 9.5.2 Keeping distinct lanes
  id: totrans-563
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.2 保持独立车道
- en: No matter how big or ambitious a wedding cake recipe is, Louis never has more
    than one or two employees working on it at a time.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 无论婚礼蛋糕食谱有多大或多宏伟，路易斯一次最多只有一到两名员工在工作。
- en: The more people he assigns to the project, the more they’ll need to communicate—they’ll
    interrupt each other to coordinate how the frosting will look and to decide who
    is responsible for each layer’s fillings and toppings.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 他分配给项目的员工越多，他们之间的沟通需求就越大——他们会互相打扰以协调糖霜的外观，并决定谁负责每一层的填充和装饰。
- en: By having fewer people assigned to a project at a time, discussions take less
    time and happen more efficiently, and it becomes easier to reach consensus.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一次分配较少的人参与项目，讨论时间会更短，效率更高，并且更容易达成共识。
- en: As the number of employees assigned to a task grows, the less productive each
    individual becomes. This decline in productivity happens because adding more people
    to a project increases the demand for communication among them, as illustrated
    in figure 9.19\. Therefore, it’s more productive for Louis to start preparing
    orders earlier but to prepare them in parallel.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 随着分配给任务的员工数量的增加，每个个体的生产力就会下降。这种生产力下降是因为向项目中增加更多的人会增加他们之间的沟通需求，如图9.19所示。因此，路易斯更有效率的做法是尽早开始准备订单，但并行准备它们。
- en: '![](../Images/CH09_F19_DaCosta.png)'
  id: totrans-568
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH09_F19_DaCosta.png)'
- en: Figure 9.19 The more developers on a team, the more different communication
    channels exist among them.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.19 团队中开发者的数量越多，他们之间的不同沟通渠道就越多。
- en: 'In software, the same principle applies. As Brooks’s law (*The Mythical Man-Month*;
    Addison-Wesley, 1975) states:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件领域，同样的原则也适用。正如布鲁克斯定律（《神话般的软件月》；Addison-Wesley，1975）所述：
- en: Adding manpower to a late software project makes it later.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 向晚期的软件项目增加人力会使项目延期。
- en: The more engineers assigned to tackle a particular deliverable, the more often
    they need to communicate and the harder it is for them to reach consensus. They’ll
    frequently need to stop to fix conflicts, make sure they’re not overwriting each
    other’s code, and, if they’re working on interdependent pieces of code, test their
    work in integration.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 分配给特定可交付成果的工程师越多，他们需要沟通的频率就越高，达成共识就越困难。他们经常需要停下来解决冲突，确保他们不会覆盖彼此的代码，如果他们正在处理相互依赖的代码片段，还需要在集成中测试他们的工作。
- en: The more engineers assigned to work on the same tasks, the less productive each
    new engineer is, as the graph in figure 9.20 illustrates.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 分配给同一任务的工作工程师越多，每个新工程师的效率就越低，如图9.20所示。
- en: '![](../Images/CH09_F20_DaCosta.png)'
  id: totrans-574
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH09_F20_DaCosta.png)'
- en: Figure 9.20 Each new engineer assigned to a task will contribute less to the
    team’s overall productivity.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.20 分配给任务的每个新工程师对团队整体生产力的贡献会减少。
- en: NOTE Having a competent technical leader can often be the most effective way
    of keeping developers working into separate lanes. It’s usually a technical leader’s
    job to break tasks into smaller independent deliverables on which developers can
    work in parallel.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：拥有一个合格的技术领导者通常是最有效的保持开发者各自独立工作的方式。通常，技术领导者的工作是将任务分解成更小的独立可交付成果，开发者可以在这些成果上并行工作。
- en: This problem is not exclusive to projects whose engineers adopt a test-driven
    workflow. Nevertheless, it’s in test-driven projects that this problem becomes
    more prominent.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题并不局限于采用测试驱动工作流程的工程师的项目。尽管如此，在测试驱动项目中，这个问题更为突出。
- en: Imagine, for example, that you and another developer have added new functionality
    to the function that generates all of your business’s reports.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下你和另一位开发者已经为生成所有业务报告的功能添加了新功能。
- en: Because both of you have taken a test-driven approach, you will have conflicts
    in your application code *and* in your tests, increasing the size of the conflicts
    that you need to resolve.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你们两人都采用了测试驱动的方法，你们的应用代码和测试中都会出现冲突，增加了你们需要解决的冲突规模。
- en: Besides being more significant, these conflicts will also be more challenging
    to solve, because even after resolving the conflicts within your tests, you’ll
    have to decide which are still valid and how to adapt existing tests.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更重要之外，这些冲突还将更加难以解决，因为即使在解决了测试中的冲突之后，你们还必须决定哪些仍然有效，以及如何调整现有的测试。
- en: Had you worked on a different functionality while your colleague changed the
    report-generation function, there would have been fewer conflicts, and it would
    have been easier for you to build upon their code. You would be able to rely on
    their tests to avoid breaking existing features and to look for examples on how
    to use what they’ve implemented.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你同事在更改报告生成函数时你在处理不同的功能，那么冲突将会更少，你将更容易基于他们的代码进行构建。你将能够依赖他们的测试来避免破坏现有功能，并寻找如何使用他们所实现功能的示例。
- en: When developers take a test-driven approach to writing *different* pieces of
    code, they hand over to their team a set of tests to catch eventual bugs so that
    the next person to work on that code will be more confident in changing it. Additionally,
    as previously mentioned, these tests also serve as usage examples, making it quicker
    for others to understand how to use the pieces of software under test.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者采用测试驱动的方式来编写*不同*的代码片段时，他们会向团队交付一系列测试来捕捉潜在的bug，这样下一个处理该代码的人就会更有信心对其进行修改。此外，正如之前提到的，这些测试也充当了使用示例，使其他人更快地了解如何使用正在测试的软件组件。
- en: By avoiding having multiple developers working on the same pieces of code, you
    reduce the likelihood of having conflicts and create an environment that’s more
    conducive for test-driven development to happen.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 通过避免多个开发者同时处理相同的代码片段，你们减少了冲突的可能性，并创造了一个更有利于测试驱动开发的环境。
- en: 9.5.3 Pairing
  id: totrans-584
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.3 配对
- en: Often it will be better for one person to supervise another’s cake than for
    them to work in parallel. An additional mouth and an extra pair of eyes can help
    a pastry chef achieve the perfect flavor in a bittersweet topping and prevent
    them from mismeasuring how much sugar goes into a chocolate frosting.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，让一个人监督另一个人的蛋糕比他们并行工作更好。额外的嘴和额外的眼睛可以帮助糕点师在苦甜顶料中达到完美的风味，并防止他们错误地测量巧克力奶油中的糖量。
- en: In software engineering, the benefits of having an extra pair of eyes are even
    more noticeable. By programming together, engineers can design more elegant and
    efficient solutions and detect bugs earlier.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件工程中，拥有额外一双眼睛的好处甚至更加明显。通过共同编程，工程师可以设计更优雅、更高效的解决方案，并更早地发现bug。
- en: If you and your colleague from the previous situation had paired, for example,
    you’d have had way fewer conflicts (if any), and you’d probably have come to a
    better solution because you’d have thought about multiple approaches. Additionally,
    you’d more quickly find critical flaws in each other’s ideas.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你和之前情况中的同事进行了配对，你们将会有更少的冲突（如果有的话），并且你们可能会找到更好的解决方案，因为你们会考虑多种方法。此外，你们会更快地发现彼此想法中的关键缺陷。
- en: '**Pairing is an excellent alternative to avoid having engineers working on
    conflicting tasks. When combined with a test-driven approach, it can be exceptionally
    productive.**'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '**配对是避免工程师处理冲突任务的绝佳替代方案。当与测试驱动方法结合使用时，它可以非常高效。**'
- en: One of the main advantages of taking a test-driven approach to pairing is that
    it improves communication.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 采用测试驱动方法进行配对的一个主要优势是它改善了沟通。
- en: Instead of discussing what a function should do, you will write a test that
    illustrates how a caller would use it. Concrete examples make it easier for people
    to understand ideas.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是讨论一个函数应该做什么，你将编写一个测试来展示调用者如何使用它。具体的例子使人们更容易理解想法。
- en: Especially in a pairing context, tests eliminate misunderstandings because they’re
    an unambiguous language for specifying requirements.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是在配对的情况下，测试消除了误解，因为它们是明确指定需求的语言。
- en: Important Test-driven development makes it easier for developers to communicate
    because the tests you’ll write will demonstrate what the unit under test’s interface
    looks like and which output it should produce for each kind of input.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 重要：测试驱动开发使开发者更容易沟通，因为你要编写的测试将展示测试单元的接口看起来像什么，以及它应该为每种输入产生哪些输出。
- en: Besides improving communication, test-driven development smooths the pairing
    workflow because it clarifies what the next piece of code to implement is.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提高沟通，测试驱动开发简化了配对工作流程，因为它阐明了接下来要实现的代码片段是什么。
- en: 'Instead of digressing while discussing what to do next, you and your coworker
    will always have a clear goal in mind: making tests pass.'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在讨论下一步要做什么时走题，你和你的同事总是会有一个清晰的目标：使测试通过。
- en: TIP Sometimes when I’m pairing with a coworker, I will suggest that we take
    turns on who writes tests and who writes application code.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：有时当我与同事配对时，我会建议我们轮流写测试和写应用程序代码。
- en: For example, if I’m the first to drive, I’ll write failing tests and transfer
    the control to my colleague for them to write the application code necessary for
    my tests to pass. Once they’ve made my tests pass, they will also write failing
    tests and give the control back to me so that I can make *their* tests pass.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我是第一个驾驶的人，我会编写失败的测试并将控制权转交给我的同事，让他们编写使我的测试通过所需的应用程序代码。一旦他们使我的测试通过，他们也会编写失败的测试并将控制权交回给我，这样我就可以使他们的测试通过。
- en: We follow this process until we finalize our task.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遵循这个流程，直到我们最终完成任务。
- en: This technique helps you decouple your tests from a target’s particular implementation.
    Because the person writing the test will not be the one implementing its target,
    they’re incentivized to think about a caller’s needs and possible edge cases,
    not about a particular implementation.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术帮助你将测试与目标的具体实现解耦。因为编写测试的人不会是实施其目标的人，所以他们更有动力去考虑调用者的需求和可能的边缘情况，而不是特定的实现。
- en: Besides improving the quality of your tests and your code, this technique makes
    work more fun and engaging, because the “driver” and the “navigator” switch roles
    more often.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提高测试和代码的质量，这种技术使工作更加有趣和吸引人，因为“驾驶员”和“导航员”的角色转换更加频繁。
- en: 9.5.4 Supplementary testing
  id: totrans-600
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.4 补充测试
- en: Besides carefully inspecting cakes as they’re prepared, Louis also makes sure
    to supplement his quality control process by frequently calibrating his ovens
    and regularly deep cleaning his kitchen.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 除了仔细检查准备过程中的蛋糕，路易斯还确保通过经常校准他的烤箱和定期深度清洁他的厨房来补充他的质量控制流程。
- en: Similarly, when it comes to writing tests, taking a further step toward creating
    extra reliability guarantees goes a long way.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当涉及到编写测试时，进一步采取步骤以创建额外的可靠性保证大有裨益。
- en: To create a separate report-generation function, for example, even though you
    may have written plenty of tests during your development process, it’s still worth
    adding another test to ensure that the button that triggers this action is working.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了创建一个单独的报告生成功能，即使你在开发过程中已经编写了很多测试，仍然值得添加另一个测试来确保触发此操作的按钮正在正常工作。
- en: When adopting a test-driven workflow, the tests you produce are likely to be
    more granular than they would have been if you had written tests separately from
    your development routine.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 当采用测试驱动的工作流程时，你产生的测试可能比如果你从开发常规中单独编写测试要更细粒度。
- en: These granular tests go on the bottom of the testing pyramid, because their
    scope is small and their reliability guarantees are weak. Even though they are
    useful, especially during your unit under test’s implementation phases, they are
    not the most reliable kinds of tests.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 这些细粒度测试位于测试金字塔的底部，因为它们的范围较小，可靠性保证较弱。尽管它们很有用，尤其是在你的测试单元实施阶段，但它们并不是最可靠的测试类型。
- en: To create reliable quality guarantees, you must create tests other than the
    ones you’ve written ***during*** a unit under test’s implementation.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建可靠的质量保证，你必须创建除了你在测试单元实施期间编写的测试之外的其他测试。
- en: Especially when practicing test-driven development, it’s easy to get carried
    away by the number of tests you’ve written throughout the process instead of focusing
    on the bigger picture and writing more coarse and reliable tests.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是在实践测试驱动开发时，很容易被在整个过程中编写的测试数量冲昏头脑，而不是专注于更大的图景，编写更粗略和可靠的测试。
- en: Important The testing pyramid still applies if you adopt a test-driven workflow.
    You should constantly think about which kinds of tests you’re writing and follow
    the pyramid’s guidance in regard to how many tests of each type you should have.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：如果你采用测试驱动的工作流程，测试金字塔仍然适用。你应该不断思考你正在编写的测试类型，并遵循金字塔的指导，关于每种类型的测试你应该有多少。
- en: 9.6 TDD, BDD, validations, and specificationsBDD (behavior-driven development)
  id: totrans-609
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.6 TDD, BDD, 验证和规范BDD (行为驱动开发)
- en: When a customer is allergic to pistachios, not even the best cannoli in the
    world will please them. For this reason, in Louis’s bakery, baking a dessert right
    is as important as baking the right dessert for each customer.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个客户对开心果过敏时，即使是世界上最好的卡纳洛利也无法取悦他们。因此，在路易的面包店中，正确烘焙甜点与为每位客户烘焙正确的甜点一样重要。
- en: In software engineering, likewise, **building the correct software is as important
    as building software correctly**. When your software has bugs, you can fix them,
    but if you’ve built the wrong kind of software, you’ll have to rewrite it.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件工程中，同样，**构建正确的软件与正确地构建软件一样重要**。当你的软件出现错误时，你可以修复它们，但如果你构建了错误类型的软件，你可能需要重写它。
- en: Up to now, I’ve presented tests *only* as a way of making you more confident
    that your software is correct. In this section, I will show how you can use a
    technique called behavior-driven development (BDD) to facilitate the communication
    and collaboration between multiple stakeholders and thus ensure that the software
    you’re building is what they want and what your customers need.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我仅将测试作为一种让你更有信心你的软件是正确的方法。在本节中，我将展示如何使用一种称为行为驱动开发（BDD）的技术来促进多个利益相关者之间的沟通和协作，从而确保你构建的软件正是他们想要的，也是客户需要的。
- en: Important Besides helping you build software that works, behavior-driven development
    helps you deliver what stakeholders *want* and customers *need*.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：除了帮助你构建出工作的软件外，行为驱动开发还帮助你提供利益相关者和客户所*需要*的。
- en: In the bakery’s situation, what customers want are more croissants, as fresh
    as they can possibly be. What Louis wants is an efficient way of managing orders
    so that he can deliver the fresh croissants his customers crave in a timely fashion.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 在面包店的情况下，客户想要的是更多尽可能新鲜的羊角面包。路易想要的是一种高效管理订单的方式，以便他能够及时地为客户提供他们渴望的新鲜羊角面包。
- en: As a software engineer, the fine art of baking and the logistics involved in
    delivering fresh croissants probably aren’t your specialities. Therefore, you
    must liaise with Louis to understand what is it that the order system should do
    to help him efficiently deliver fresh croissants.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名软件工程师，烘焙的精细艺术以及配送新鲜羊角面包所涉及的物流可能不是你的专长。因此，你必须与路易沟通，了解订单系统应该做什么来帮助他高效地配送新鲜羊角面包。
- en: Louis needs to translate his needs into requirements upon which you can work,
    and you need to translate technical limitations and edge cases into Louis’s language
    so that he can suggest how to proceed according to how the bakery works.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 路易需要将他的需求翻译成你可以工作的需求，而你则需要将技术限制和边缘情况翻译成路易的语言，以便他可以根据面包店的运作方式提出如何继续的建议。
- en: To explain what he needs, Louis could write down a series of specifications
    or have a meeting with you and talk you through how he’d use the order system.
    He will tell you, for example, that the system must cluster deliveries to the
    same areas around the same time so that the croissants can be fresh. He may also
    say that further delivery locations should appear on top of the list so that their
    croissants can go out earlier and arrive on time.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释他的需求，路易可以写下一系列规范或与你开会，并指导你如何使用订单系统。例如，他会告诉你，系统必须将同一地区的配送集中安排在相同的时间，以便羊角面包保持新鲜。他可能还会说，应将进一步的配送地点放在列表的顶部，以便他们的羊角面包可以更早发出并准时到达。
- en: The problem with this unilateral approach is that you don’t have enough information
    to decide what to do when edge cases appear. What if, for example, two customers
    live equally as far from the bakery? What if their order contains items that don’t
    need to be delivered as quickly as croissants?
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 这种单方面方法的缺点是，当出现边缘情况时，你没有足够的信息来决定如何行动。例如，如果两个客户离面包店同样远，会怎样？如果他们的订单包含不需要像羊角面包那样快速配送的项目，会怎样？
- en: If you run into edge cases like these, you’ll have to choose between interrupting
    your work and going back to Louis to ask questions or take the risk of making
    incorrect assumptions and having to redo work later.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到这些边缘情况，你将不得不在打断你的工作并回到路易斯那里提问或承担做出错误假设并不得不稍后重做工作的风险之间做出选择。
- en: When taking a behavior-driven approach to software development, you and Louis
    will adopt a common language to describe what should happen in different scenarios.
    You will then use those scenarios to write automated tests that help you be more
    confident that your software works and that it does what Louis’ needs.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 当采用以行为驱动的软件开发方法时，你和路易斯将采用一种共同的语言来描述在不同场景中应该发生什么。然后，你将使用这些场景来编写自动化测试，帮助你更有信心地确保你的软件工作，并且它确实做了路易斯需要它做的事情。
- en: Instead of receiving a document or listening to Louis talk about his needs,
    you will collaboratively write specifications using the “given, when, then” framework.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是收到一份文档或听路易斯谈论他的需求，你将使用“给定、当、然后”框架共同编写规范。
- en: 'To decide, for example, what to do when two delivery locations are equally
    as far from the bakery, you’ll write a piece of specification that looks like
    this:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当两个配送地点离面包房同样远时，决定要做什么，你需要编写一段看起来像这样的规范：
- en: '**Given** that there’s an order for location A that is two miles east of the
    bakery;'
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**给定**，有一个位于面包房东边两英里的A地点的订单；'
- en: '**When** an order is placed for location B, that is two miles west of the bakery;'
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当**在距离面包房两英里西边的B地点下单时；'
- en: '**Then** the order with more items should appear on the top of the priority
    list.'
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**然后**，包含更多项目的订单应出现在优先级列表的顶部。'
- en: In the “given” step, you’ll describe the system’s initial context. In the “when”
    step, you’ll describe the action that is carried out. Finally, in the “then” step,
    you’ll describe what the expected output is.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 在“给定”步骤中，你将描述系统的初始上下文。在“当”步骤中，你将描述执行的动作。最后，在“然后”步骤中，你将描述预期的输出。
- en: TIP The “given, when, then” formula is analogous to the three As pattern—“arrange,
    act, assert.”
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: TIP “给定、当、然后”公式与三个A模式——“安排、行动、断言”类似。
- en: When it comes time to implement tests that cover this behavior, they will match
    the language used to describe the specification.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要实现覆盖此行为的测试时，它们将与描述规范所使用的语言相匹配。
- en: Your tests’ descriptions will be sentences that illustrate the desired outcome
    of a specific action in a particular scenario.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 你的测试描述将是说明特定场景中特定动作期望结果的句子。
- en: To make your tests read more like specifications, you can use `describe` to
    describe a scenario, and the `it` function, which is equivalent to the `test`
    function, to write your tests.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你的测试读起来更像规范，你可以使用`describe`来描述一个场景，以及`it`函数，它相当于`test`函数，来编写你的测试。
- en: Because these sets of tests are “automated specification validators”—acceptance
    focused tests—I like to use `.spec` instead of `.test` in their names.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些测试集是“自动化规范验证器”——以验收为重点的测试——我喜欢在它们的名称中使用`.spec`而不是`.test`。
- en: Listing 9.36 orderScheduler.spec.js
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.36 orderScheduler.spec.js
- en: '[PRE35]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This syntax helps you keep tests focused and makes it easier to figure out the
    part of the specification to which your code does not comply if your tests fail.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法帮助你保持测试的专注性，并在测试失败时更容易找出你的代码不遵守的规范部分。
- en: Because you and Louis have elaborated the specifications in a way that’s easier
    for engineers to translate into software tests, you’ll have automated guarantees
    that your software does what Louis needs it to do.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你和路易斯将规范阐述得更容易让工程师将其转化为软件测试，因此你将获得自动保证，确保你的软件做路易斯需要它做的事情。
- en: This collaboration between you and Louis, the technical and nontechnical stakeholders,
    respectively, results in a specification that’s more well thought out. This approach
    makes it easier for you to explain and expose edge cases so that Louis can decide
    what the system should do when they happen. For Louis, it will be easier to communicate
    what he wants and how that generates value to customers so that engineers can
    implement software that solves his problem.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 你和路易斯（技术和非技术利益相关者）之间的这种合作，产生了一个更加周全的规范。这种方法使你更容易解释和暴露边缘情况，以便路易斯可以决定当它们发生时系统应该做什么。对于路易斯来说，这将更容易沟通他的需求以及这如何为客户创造价值，以便工程师可以实施解决他问题的软件。
- en: During the process of creating this specification, technical stakeholders will
    understand more about the business and ask questions about which the nontechnical
    stakeholders might not have thought. Conversely, nontechnical stakeholders will
    be able to influence the system’s design so that its abstractions match the realities
    of the business, facilitating future conversations among the different teams.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建此规范的过程中，技术利益相关者将更多地了解业务，并就非技术利益相关者可能未考虑过的问题提出问题。相反，非技术利益相关者将能够影响系统的设计，使其抽象与业务的现实情况相匹配，从而促进不同团队之间的未来对话。
- en: Additionally, when implementing these functionalities, you can use the specification
    you have translated into code in a test-driven workflow. You can write tests in
    this format first and write code later.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在实现这些功能时，你可以使用你已翻译成代码的规范在测试驱动的工作流程中使用。你可以先以这种格式编写测试，然后再编写代码。
- en: Given that you feel confident in taking bigger steps at a time because your
    scope has enlarged, adopting this workflow will help you generate more reliable
    guarantees. Nonetheless, if you still need to iterate in smaller steps, you can
    always write your own short unit tests to build up confidence and only then implement
    larger behavioral tests.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你感到自信，可以一次迈出更大的步伐，因为你的范围已经扩大，采用此工作流程将帮助你生成更可靠的保证。尽管如此，如果你仍然需要以较小的步骤迭代，你始终可以编写自己的简短单元测试来建立信心，然后仅在此之后实现更大的行为测试。
- en: Summary
  id: totrans-640
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Test-driven development is a software development methodology that uses tests
    to help you iteratively produce correct code.
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动开发是一种软件开发方法，它使用测试来帮助你迭代地生成正确的代码。
- en: When performing test-driven development, you’ll follow a three-step process,
    which you can repeat as many times as you need until you reach a final working
    implementation. You’ll write a failing test first, then you’ll write the code
    necessary to make the test pass, and finally, you’ll refactor the code you’ve
    written. These three steps are also known as “red, green, refactor,” which is
    TDD’s mantra.
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行测试驱动开发时，你将遵循一个三步流程，你可以根据需要重复多次，直到达到最终的可行实现。首先，你会编写一个失败的测试，然后编写必要的代码来使测试通过，最后，你会重构你编写的代码。这三个步骤也被称为“红、绿、重构”，这是TDD的座右铭。
- en: In a test-driven workflow, the more confident you are, the bigger your steps
    should be. If you’re feeling confident about the code you need to write, you can
    start with bigger tests and implement larger chunks of code at a time. If not,
    you can begin with tiny tests and write smaller pieces of code at a time.
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试驱动的工作流程中，你越自信，你的步子就应该越大。如果你对需要编写的代码感到自信，你可以从更大的测试开始，一次实现更大的代码块。如果不自信，你可以从微小的测试开始，一次编写较小的代码片段。
- en: Test-driven development reduces costs because it helps you detect mistakes earlier
    in the development process. The sooner your tests detect bugs, the fewer places
    there will be for them to hide, and the fewer lines of code you’ll have to undo.
    Additionally, catching bugs during development prevents them from affecting customers
    and impacting your costs or revenue.
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动开发可以降低成本，因为它帮助你更早地检测到开发过程中的错误。你的测试越早检测到错误，它们可以隐藏的地方就越少，你将不得不撤销的代码行就越少。此外，在开发过程中捕获错误可以防止它们影响客户，影响你的成本或收入。
- en: By taking an iterative approach to writing code, you tighten your feedback loop,
    and your confidence builds as you write code. This tight feedback loop reduces
    anxiety and guides you through the development process.
  id: totrans-645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过采用迭代的方法编写代码，你紧缩了你的反馈循环，随着你编写代码，你的信心也在增强。这个紧密的反馈循环减少了焦虑，并引导你通过开发过程。
- en: Because in test-driven development you’ll see your tests failing before writing
    the necessary code, you’ll be more confident that your tests can detect flaws
    in your software.
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为在测试驱动开发中，你将在编写必要的代码之前看到测试失败，所以你会更有信心你的测试可以检测到软件中的缺陷。
- en: Taking a bottom-up approach to your tests mean testing smaller pieces of software
    first and moving up toward higher layers of abstraction. A top-down approach consists
    of testing higher layers of abstraction first, so that you can also cover the
    underlying pieces of software upon which they depend.
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采用自下而上的测试方法意味着首先测试较小的软件片段，然后向上移动到更高层次的抽象。自上而下的方法首先测试更高层次的抽象，这样你还可以覆盖它们所依赖的底层软件片段。
- en: A bottom-up approach to testing allows you to take smaller steps and help you
    build confidence as you iterate. When you’re not feeling confident about the code
    you need to write, you should adopt this approach. The problem with a bottom-up
    testing strategy is that it’s slow when compared to a top-down approach. It also
    creates an overlap between your tests, increasing your maintenance costs.
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试的底层方法允许你采取更小的步骤，并在迭代过程中帮助你建立信心。当你对需要编写的代码没有信心时，你应该采用这种方法。底层测试策略的问题在于，与自顶向下的方法相比，它比较慢。它还导致你的测试之间产生重叠，增加了你的维护成本。
- en: A top-down approach to testing will force you to write bigger chunks of code
    at a time, which results in a more loose feedback loop. Because this loose feedback
    loop will make it more difficult for you to find bugs, you should adopt it only
    when you’re feeling confident. The advantage of using a top-down testing strategy
    is that it allows you to iterate more quickly and creates less overlap between
    tests, reducing maintenance costs.
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自顶向下的测试方法将迫使你一次编写更大的代码块，这导致反馈循环更加松散。因为这种松散的反馈循环会使你更难找到错误，所以你应该只在感到自信时采用它。使用自顶向下测试策略的优势在于，它允许你更快地迭代，并在测试之间创建更少的重叠，从而降低维护成本。
- en: Creating code demands that you focus on correctness and iteration speed over
    maintenance costs. To decide whether you should take a bottom-up or top-down approach
    to your tests during your unit under test’s implementation phase, you should take
    into account how confident you feel and adjust the size of your steps accordingly.
    If you’re feeling confident, adopt a top-down approach; otherwise, try testing
    from the bottom up.
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建代码需要你关注正确性和迭代速度，而不是维护成本。为了决定在单元测试的实现阶段，你应该采取自底向上还是自顶向下的测试方法，你应该考虑你有多自信，并相应地调整你的步骤大小。如果你感到自信，采用自顶向下的方法；否则，尝试从底部向上测试。
- en: When maintaining code, you can turn the granular tests you’ve created when taking
    a bottom-up approach into more coarse tests, whose scope is bigger and quality
    guarantees are more reliable. During the maintenance phase of your unit under
    test, you can spend more time to reduce your tests’ overlap and, therefore, their
    costs.
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在维护代码时，你可以将采用自底向上方法时创建的细粒度测试转换为更粗粒度的测试，其范围更大，质量保证更可靠。在单元测试的维护阶段，你可以花更多的时间来减少测试的重叠，从而降低其成本。
- en: To create an environment in which test-driven development can flourish, you
    need your whole team to embrace it. When an entire team adopts a test-driven workflow,
    developers will build each new feature upon solid foundations and will have automated
    checks to help them produce code with more confidence.
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了创造一个测试驱动开发可以繁荣的环境，你需要你的整个团队都接受它。当整个团队采用测试驱动的工作流程时，开发者将基于坚实的基础构建每个新功能，并将拥有自动检查来帮助他们更有信心地生成代码。
- en: When bundling tests and code deliveries, communication is facilitated because
    the tests demonstrate how to use the software, serving as documentation for the
    units under test.
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当捆绑测试和代码交付时，沟通得到了促进，因为测试展示了如何使用软件，为正在测试的单元提供了文档。
- en: Especially when adopting a test-driven workflow, try to keep engineers working
    on distinct parts of the code. By working on different parts of the software,
    engineers will be more efficient, because they’ll need to interrupt each other
    less often and will have fewer conflicts to fix.
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尤其是在采用测试驱动的工作流程时，尽量让工程师专注于代码的不同部分。通过在不同的软件部分工作，工程师将更加高效，因为他们需要更少地打断彼此，并且需要修复的冲突更少。
- en: Pairing is an excellent alternative to avoid having engineers simultaneously
    working in conflicting pieces of code. It can be especially productive when combined
    with a test-driven workflow, because test-driven development makes pairing sessions
    more interactive and makes it easier for engineers to agree on the result they
    want to achieve.
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配对是一种避免工程师同时工作在冲突代码片段中的优秀替代方案。当与测试驱动的工作流程结合使用时，它尤其富有成效，因为测试驱动开发使配对会话更加互动，并使工程师们更容易就他们想要实现的结果达成一致。
- en: Test-driven development does not eliminate the need for writing tests separately
    from your application’s code development process. Even when adopting a test-driven
    workflow, you should still write extra tests at multiple levels of integration,
    and the testing pyramid indications in regard to the scope and quantities of tests
    are still valid.
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动开发并不消除在应用程序代码开发过程中单独编写测试的需求。即使在采用测试驱动的工作流程时，你也应该仍然在多个集成级别编写额外的测试，并且关于测试范围和数量的测试金字塔指示仍然有效。
- en: Behavior-driven development is a software development practice that facilitates
    the communication between the technical and nontechnical stakeholders of a project
    by creating a collaborative process in which members of different teams express
    requirements in a shared language.
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为驱动开发是一种软件开发实践，通过创建一个协作过程，使不同团队成员能够用一种共享的语言表达需求，从而促进项目的技术和非技术利益相关者之间的沟通。
- en: By writing requirements in a language that’s shared between multiple members
    of different teams, engineers can deliver precisely what the business needs. Additionally,
    edge cases can be exposed and solved earlier, without the need for rework.
  id: totrans-658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过用多个不同团队成员共享的语言编写需求，工程师可以精确地交付业务所需的内容。此外，边缘情况可以更早地暴露和解决，无需返工。
- en: When taking a behavior-driven approach to software development, the business
    requirements are translated into automated tests that match the specification’s
    language, resulting in tests that validate the software’s *functional* requirements.
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当采用行为驱动的方法进行软件开发时，业务需求被翻译成与规范语言匹配的自动化测试，从而产生验证软件*功能*要求的测试。
