- en: Part 2\. Organizing your programs
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二部分\. 组织你的程序
- en: Sharing code is common among programmers; many problems have been solved by
    others already, and your solutions could prove useful in your own future projects,
    to your team, or to the wider developer community. When code modules are shared,
    it’s important to make clear how others should use them by defining a clear *interface*,
    or set of properties and functions you expect users to utilize. The internals
    of a module—how you make it do its job—should be protected. [Part 2](#part02)
    looks at ways of using local rather than global variables to hide a module’s implementation
    from other code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序员中共享代码很常见；许多问题已经被其他人解决，你的解决方案可能在你自己的未来项目中，在你的团队中，或者更广泛的开发者社区中非常有用。当代码模块被共享时，通过定义一个清晰的*接口*，或一组你期望用户使用的属性和函数，来明确其他人应该如何使用它们是很重要的。模块的内部——你如何让它完成工作——应该受到保护。[第二部分](#part02)探讨了使用局部变量而不是全局变量来隐藏模块实现的方法。
- en: As your programs grow, the need for organization increases, and you’ll start
    to notice patterns and procedures you use again and again. [Part 2](#part02) also
    looks at ways of using *modules* in your code to improve flexibility, reuse, and
    maintainability. Your code’s flexibility may be improved by executing parts of
    it only if certain conditions are met, and you’ll see how to specify those conditions
    with `if` statements.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的程序的增长，组织的需求增加，你将开始注意到你反复使用的模式和程序。[第二部分](#part02)还探讨了在代码中使用*模块*的方法来提高灵活性、重用性和可维护性。你的代码的灵活性可以通过仅在满足某些条件时执行其部分来提高，你将看到如何使用`if`语句来指定这些条件。
- en: The modules you create will usually perform specific, well-defined tasks within
    a project. Three common types of module are *models*, for representing and working
    with data, *views* for presenting the data in models, and *controllers* for updating
    models and views in response to user or system actions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建的模块通常会在项目中执行特定的、定义良好的任务。三种常见的模块类型是*模型*，用于表示和处理数据，*视图*用于在模型中展示数据，以及*控制器*用于根据用户或系统操作更新模型和视图。
- en: 'By the end of [part 2](#part02), you’ll have broken *The Crypt* into modules
    and updated the game to include challenges: puzzles for players to overcome.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到[第二部分](#part02)结束时，你将把*The Crypt*分解成模块，并更新游戏以包括挑战：玩家需要克服的谜题。
- en: 'Chapter 11\. Scope: hiding information'
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第11章\. 范围：隐藏信息
- en: '***This chapter covers***'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: The dangers of global variables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局变量的危险
- en: The benefits of local variables
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 局部变量的好处
- en: Using namespaces to reduce global variables
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命名空间来减少全局变量
- en: Creating local variables with functions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数创建局部变量
- en: Returning an interface for the user
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回用户接口
- en: 'You want the user to be able to interact with your console-based programs.
    But you don’t want to give them too much control! This chapter explores ways of
    hiding parts of your program from the user at the console and clearly defining
    the properties and methods you expect them to use. For example, for a quiz program
    the user should be able to submit an answer but not change their score:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望用户能够与你的基于控制台的程序进行交互。但你不想给他们太多的控制！本章探讨了在控制台中隐藏程序的一部分以及明确定义你期望他们使用的属性和方法的方法。例如，对于一个问答程序，用户应该能够提交答案但不能更改他们的分数：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: By separating the public interface from the private variables and functions
    that make the program work, you declare your intentions, setting out what a user
    *can* do and what other programmers using your code *should* do, and reduce the
    risk of code being misused. That’s good for the program, for the players, and
    for other programmers.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将公共接口与使程序工作的私有变量和函数分开，你声明了你的意图，说明了用户*可以*做什么，以及使用你的代码的其他程序员*应该*做什么，并减少了代码被误用的风险。这对程序、玩家和其他程序员都有好处。
- en: Functions are the key. Whereas variables declared outside functions are accessible
    everywhere in the program, those declared inside functions are accessible only
    within the function. This chapter will show you how to return objects from functions
    with only those properties and methods you want to be accessible to users. Constructors
    are functions too, and you’ll see how to use their special `this` object to set
    up public properties and methods.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是关键。与在函数外部声明的变量可以在程序中的任何地方访问不同，在函数内部声明的变量只能在函数内部访问。本章将向你展示如何从函数中返回对象，只包含你希望用户可以访问的属性和方法。构造函数也是函数，你将看到如何使用它们的特殊`this`对象来设置公共属性和方法。
- en: 'Finally, you’ll apply what you’ve learned to *The Crypt*, removing user access
    to constructors, places, and player properties and providing methods to display
    player and place information and to navigate the map. Users will be able to do
    this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将应用所学知识到*The Crypt*，移除用户对构造函数、地点和玩家属性的访问权限，并提供显示玩家和地点信息以及导航地图的方法。用户将能够这样做：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Users won’t be able to cheat the game by doing this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 用户无法通过这种方式来欺骗游戏：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s start by highlighting the pitfalls of variables you can see anywhere
    in the program; they seem like such a good idea! *[Spoiler: they’re not.]*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先强调一下程序中任何地方都可以看到的变量的陷阱；它们看起来是个不错的想法！[剧透：它们并不好。]*
- en: 11.1\. The dangers of global variables
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1\. 全局变量的危险
- en: 'Way back in [chapter 2](kindle_split_010.html#ch02), at the start of your adventures
    in JavaScript, you discovered how to declare, assign, and use variables. The following
    listing shows a really simple example of the process that displays the name of
    a mountain on the console:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](kindle_split_010.html#ch02)中，在你开始JavaScript冒险之旅的时候，你发现了如何声明、赋值和使用变量。以下列表展示了显示在控制台上的山脉名称的简单示例过程：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Listing 11.1\. Declare, assign, and use a variable ([http://jsbin.com/gujacum/edit?js,console](http://jsbin.com/gujacum/edit?js,console))
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.1\. 声明、赋值和使用变量 ([http://jsbin.com/gujacum/edit?js,console](http://jsbin.com/gujacum/edit?js,console))
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You declare the variable, `mountain`, on the first line of the program. You
    can then use the variable throughout the code; you assign it a value and pass
    it to `console.log` as an argument.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你在程序的第一行声明了变量`mountain`。然后你可以在整个代码中使用这个变量；你给它赋值，并将其作为参数传递给`console.log`。
- en: Functions in the program can also access the `mountain` variable ([figure 11.1](#ch11fig01)).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中的函数也可以访问`mountain`变量（[图11.1](#ch11fig01)）。
- en: Figure 11.1\. The function can see the `mountain` variable that’s outside the
    function body.
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.1\. 函数可以看到函数体外的`mountain`变量。
- en: '![](11fig01_alt.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](11fig01_alt.jpg)'
- en: The next listing shows a `showMountain` function using `mountain`, leading to
    the same output as [listing 11.1](#ch11ex01).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表展示了使用`mountain`的`showMountain`函数，其输出与[列表11.1](#ch11ex01)相同。
- en: Listing 11.2\. Accessing a variable from within a function ([http://jsbin.com/zojida/edit?js,console](http://jsbin.com/zojida/edit?js,console))
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.2\. 在函数内部访问变量 ([http://jsbin.com/zojida/edit?js,console](http://jsbin.com/zojida/edit?js,console))
- en: '![](173fig01_alt.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](173fig01_alt.jpg)'
- en: 'Variables like `mountain`, declared outside any function and so accessible
    everywhere, are called *global variables*. You may think these global variables
    sound really useful: declare them once and then use them freely from anywhere
    in your code. Unfortunately, they have some serious downsides and are generally
    considered to be *a bad thing*. Let’s investigate reasons for avoiding these naughty
    globals.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 像在函数外部声明的`mountain`这样的变量，可以在任何地方访问，被称为*全局变量*。你可能认为这些全局变量听起来非常有用：一旦声明，就可以在代码的任何地方自由使用。不幸的是，它们有一些严重的缺点，通常被认为*是个坏主意*。让我们调查一下避免这些淘气的全局变量的原因。
- en: 11.1.1\. Access all areas—peeking and tweaking
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.1\. 访问所有区域——偷看和修改
- en: You want users to be able to interact with your programs at the console. You
    don’t want them to have a sneaky peek at all the geeky variables. The next listing
    shows a tiny quiz.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望用户能够在控制台与你的程序交互。你不想让他们偷偷查看所有技术变量。下一个列表展示了一个小小的测验。
- en: Listing 11.3\. A tiny quiz ([http://jsbin.com/nubipi/edit?js,console](http://jsbin.com/nubipi/edit?js,console))
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.3\. 一个小小的测验 ([http://jsbin.com/nubipi/edit?js,console](http://jsbin.com/nubipi/edit?js,console))
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Because `question` and `answer` are global variables, they’re accessible throughout
    the program and via the console. At the console prompt, once users run the program,
    they can type `answer` and press Enter and display the value of the `answer` variable.
    A sneaky peek at our geeky peak!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`question`和`answer`是全局变量，它们可以在整个程序和通过控制台访问。在控制台提示符下，一旦用户运行程序，他们可以输入`answer`并按Enter键来显示`answer`变量的值。偷偷一瞥我们的技术高峰！
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It’s not just sneaky peeks that are a problem; it’s sneaky tweaks too! Users
    can change the value of global variables at will, updating scores, bank balances,
    velocities, prices, and answers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅仅是偷偷查看是个问题；偷偷修改也是个问题！用户可以随意更改全局变量的值，更新分数、银行余额、速度、价格和答案。
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 11.1.2\. Access all areas—relying on an implementation
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.2\. 访问所有区域——依赖于实现
- en: The idea of not relying on an implementation is important but might require
    time to appreciate fully. Don’t worry if not everything clicks the first time
    through—you can always return to it after reading the other examples in the chapter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 不依赖实现的观念很重要，但可能需要时间来完全理解。如果你第一次阅读时没有完全理解，不要担心——你可以在阅读本章中的其他示例之后返回来。
- en: Sneaky peeks and tweaks can be a problem for programmers too (see the sidebar
    “[Who’s using your code?](#ch11sb01)”). If you’ve written code that is then used
    by other programmers, you probably don’t want them to be tinkering under the hood,
    writing their own code that relies on the internals of yours. When you release
    a new version of your code that uses a more efficient algorithm internally, other
    code that has been relying on some of your variables may break.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 暗中窥视和调整也可能成为程序员的麻烦（参见侧边栏 “[谁在使用你的代码？](#ch11sb01)”）。如果你编写的代码被其他程序员使用，你可能不希望他们暗中修改，编写依赖于你代码内部结构的自己的代码。当你发布使用更高效算法的代码的新版本时，依赖于你一些变量的其他代码可能会出错。
- en: '|  |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Who’s using your code?**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**谁在使用你的代码？**'
- en: Consider the `spacer` functions you created in [chapter 7](kindle_split_015.html#ch07).
    You’ve been using them in your code for *The Crypt* ever since. That’s an example
    of *you* using your own code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑你在 [第 7 章](kindle_split_015.html#ch07) 中创建的 `spacer` 函数。自从那时起，你一直在你的代码中使用它们来编写
    *The Crypt*。这是 *你* 使用你自己的代码的一个例子。
- en: It’s common for programmers to be part of a *team*, small or large. The team
    could be working on different aspects of the same program. There’s no need for
    each programmer to create their own formatting functions, so they all use your
    `spacer` namespace.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于程序员来说，成为 *团队* 的一员，无论是小团队还是大团队，是很常见的。团队可以共同开发同一个程序的不同方面。没有必要每个程序员都创建他们自己的格式化函数，所以他们都会使用你的
    `spacer` 命名空间。
- en: Your team members are so impressed by your formatting prowess that they encourage
    you to share the `spacer` namespace more widely. You upload your code to a *community*
    repository like [Github.com](http://www.Github.com) ([https://github.com](https://github.com))
    or [npmjs.com](http://npmjs.com) ([https://www.npmjs.com](https://www.npmjs.com)).
    Other programmers can then download and use your code and even contribute improvements
    and extensions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你的团队成员对你的格式化能力印象深刻，鼓励你更广泛地分享 `spacer` 命名空间。你将你的代码上传到像 [Github.com](http://www.Github.com)
    ([https://github.com](https://github.com)) 或 [npmjs.com](http://npmjs.com) ([https://www.npmjs.com](https://www.npmjs.com))
    这样的 *社区* 仓库。然后，其他程序员可以下载并使用你的代码，甚至贡献改进和扩展。
- en: The `spacer` code catches on and is developed further by a team of dedicated
    enthusiasts. It even gets its own website! It’s so popular that *everyone* is
    using the spacer.js library.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`spacer` 代码被一个由热心的爱好者组成的团队所采用，并进一步发展。它甚至拥有自己的网站！它如此受欢迎，以至于 *每个人* 都在使用 spacer.js
    库。'
- en: '|  |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Users should be able to rely on your *interface*—the functionality you make
    public—and not be concerned with your *implementation*—how you program that functionality.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 用户应该能够依赖你的 *界面*——你公开的功能性——而不是担心你的 *实现*——你如何编程这些功能。
- en: '|  |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Definition
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: An *interface* is a set of properties and functions that you want users to access.
    It’s how they interact with your application. For example, the screen, buttons,
    and cash dispenser on an ATM.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*界面* 是一组你希望用户访问的属性和函数。它是他们与你的应用程序交互的方式。例如，自动柜员机的屏幕、按钮和现金分配器。'
- en: '|  |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Definition
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: An *implementation* is the code you use to make an application do its job behind
    the scenes. It isn’t usually visible to users. For example, the code that makes
    an ATM work, how it communicates with your bank, and how it counts the cash.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*实现* 是你用来使应用程序在幕后完成其工作的代码。它通常对用户不可见。例如，使自动柜员机工作的代码，它是如何与你的银行通信的，以及它是如何计算现金的。'
- en: '|  |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: For example, to implement links between places in *The Crypt* you might use
    an `exits` array for exit directions and a `destinations` array for the places
    to which the exits lead.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了在 *The Crypt* 中的地方之间实现链接，你可能使用一个 `exits` 数组来表示出口方向，以及一个 `destinations`
    数组来表示出口所指向的地方。
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Then, to manage adding new exits you write an `addExit` function.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了管理添加新的出口，你编写一个 `addExit` 函数。
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You expect other programmers working with your `Place` objects to use the `addExit`
    function ([figure 11.2](#ch11fig02)).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你期望与其他程序员一起使用你的 `Place` 对象的程序员使用 `addExit` 函数 ([图 11.2](#ch11fig02))。
- en: Figure 11.2\. Users should use the interface, not the implementation.
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.2\. 用户应使用界面，而不是实现。
- en: '![](11fig02.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![11fig02.jpg](11fig02.jpg)'
- en: You document the fact that `addExit` is part of the *interface*, the set of
    properties and functions that users—in this case programmers—should work with.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您记录了 `addExit` 是 *接口* 的一部分的事实，即用户（在这种情况下是程序员）应与之交互的属性和函数集。
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: But if they have access to the `exits` and `destinations` variables, they might
    choose to use those variables directly, bypassing the function.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果他们可以访问 `exits` 和 `destinations` 变量，他们可能会选择直接使用这些变量，绕过函数。
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Everything seems fine and the other programmers’ programs are working well.
    Then, after reviewing your code, you decide you can improve on having two separate
    arrays by using a single object.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎一切都很正常，其他程序员的程序运行良好。然后，在审查您的代码后，您决定可以通过使用单个对象来改进使用两个单独数组的方法。
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To use the new way you’ve implemented `exits`, you update the `addExit` function.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用您已实现的新的 `exits` 方法，您需要更新 `addExit` 函数。
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Programmers who were using the interface will see no change in their programs.
    But programmers who bypassed the interface and accessed the variables directly
    will see their programs break! (See [figure 11.3](#ch11fig03).)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该接口的程序员将不会在其程序中看到任何变化。但是绕过接口直接访问变量的程序员将看到他们的程序崩溃！（见[图 11.3](#ch11fig03)）
- en: Figure 11.3\. Relying on the implementation can lead to errors if it changes.
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.3. 如果实现发生变化，依赖实现可能会导致错误。
- en: '![](11fig03.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](11fig03.jpg)'
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Allowing access to all areas of our programs by using global variables blurs
    the line between implementation and interface, giving users freedom to peek and
    tweak and setting up programs to fail when implementation details change.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 允许通过使用全局变量访问我们程序的所有区域，模糊了实现和接口之间的界限，给用户提供了窥视和调整的自由，并使程序在实现细节更改时容易失败。
- en: 11.1.3\. Naming collisions
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.3. 命名冲突
- en: Because our programs can be made up from lots of pieces of code written by different
    teams or programmers, it’s quite possible that the same variable names will be
    used in multiple places. If one programmer declares a variable name, say `spacer`
    (a namespace of formatting functions), and then later in the program another programmer
    declares the same variable name, `spacer` (a canine character in a console-based
    space-adventure game), the second will overwrite the first—a collision! We really
    need a way to protect our variables from such collisions. ([Chapter 13](kindle_split_022.html#ch13)
    looks at collisions in more detail.)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的程序可能由不同团队或程序员编写的许多代码片段组成，因此很可能在多个地方使用相同的变量名。如果一个程序员声明了一个变量名，比如 `spacer`（格式化函数的命名空间），然后在程序稍后另一个程序员声明了相同的变量名，`spacer`（基于控制台的空间冒险游戏中的犬类角色），第二个将覆盖第一个——冲突！我们真的需要一种方法来保护我们的变量免受此类冲突的影响。（[第
    13 章](kindle_split_022.html#ch13) 详细探讨了冲突。）
- en: 11.1.4\. Crazy bugs
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.4. 疯狂的虫子
- en: Programs can be thousands of lines long. Relying on global variables that may
    be declared a long way away in the code and that may be peeked at and tweaked
    by functions and instructions throughout the program leads to a fragile program.
    If anything goes wrong with the program (and it probably will), it could be difficult
    to follow the flow of the code and pin down the location of the problems.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 程序可能长达数千行。依赖可能声明在代码较远处的全局变量，并且可能被程序中的函数和指令查看和调整，会导致程序脆弱。如果程序出现任何问题（这很可能会发生），可能很难追踪代码的流程并确定问题的位置。
- en: 11.2\. The benefits of local variables
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2. 局部变量的好处
- en: Variables declared inside the body of a function can’t be accessed outside the
    function. They’re called *local variables*; they are local to the function in
    which they’re declared ([figure 11.4](#ch11fig04)).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内声明的变量不能在函数外部访问。它们被称为 *局部变量*；它们仅限于声明它们的函数内（[图 11.4](#ch11fig04)）。
- en: Figure 11.4\. Variables declared inside a function are local to the function.
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.4. 函数内声明的变量是局部变量。
- en: '![](11fig04_alt.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](11fig04_alt.jpg)'
- en: 'Trying to access a local variable outside its function will cause an error.
    [Listing 11.4](#ch11ex04) tries to log the value of the `mountain` variable to
    the console but produces a message like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在函数外部访问局部变量将导致错误。[列表 11.4](#ch11ex04) 尝试将 `mountain` 变量的值记录到控制台，但会显示如下信息：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: (The error you get might look slightly different. Different browsers may format
    the error messages in different ways.)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: （您得到的错误可能略有不同。不同的浏览器可能会以不同的方式格式化错误信息。）
- en: Listing 11.4\. A variable hidden from the console ([http://jsbin.com/bobilu/edit?js,console](http://jsbin.com/bobilu/edit?js,console))
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.4. 隐藏在控制台中的变量 ([http://jsbin.com/bobilu/edit?js,console](http://jsbin.com/bobilu/edit?js,console))
- en: '![](177fig01_alt.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](177fig01_alt.jpg)'
- en: The collection of variables outside all functions is called the *global scope*.
    Each function creates its own *local scope*, its own collection of variables.
    In [listing 11.4](#ch11ex04), the variable `mountain` is not in the global scope
    outside the function and so an error is reported when it’s used in the `console.log`
    statement.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 所有函数之外的所有变量集合称为 *全局作用域*。每个函数都创建自己的 *局部作用域*，即自己的变量集合。在 [列表 11.4](#ch11ex04) 中，变量
    `mountain` 不在函数外的全局作用域中，因此在 `console.log` 语句中使用时报告了错误。
- en: Using a variable from within the same scope causes no trouble, as shown in the
    following listing.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一作用域内使用变量不会引起任何麻烦，如下面的列表所示。
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Listing 11.5\. The variable is visible from within the function ([http://jsbin.com/raluqu/edit?js,console](http://jsbin.com/raluqu/edit?js,console))
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.5\. 变量在函数内部可见 ([http://jsbin.com/raluqu/edit?js,console](http://jsbin.com/raluqu/edit?js,console))
- en: '![](178fig01_alt.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](178fig01_alt.jpg)'
- en: '[Listing 11.6](#ch11ex06) combines global and local variables. You can access
    the global variables anywhere, but you can only use the local variable, `secretMountain`,
    inside the `show` function.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11.6](#ch11ex06) 结合了全局变量和局部变量。你可以在任何地方访问全局变量，但只能在 `show` 函数内部使用局部变量 `secretMountain`。'
- en: '[Listing 11.6](#ch11ex06) produces the following output:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11.6](#ch11ex06) 产生以下输出：'
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Listing 11.6\. Global and local variables ([http://jsbin.com/riconi/edit?js,console](http://jsbin.com/riconi/edit?js,console))
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.6\. 全局和局部变量 ([http://jsbin.com/riconi/edit?js,console](http://jsbin.com/riconi/edit?js,console))
- en: '![](178fig02_alt.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](178fig02_alt.jpg)'
- en: 11.3\. Interfaces—controlling access and providing functionality
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3\. 接口——控制访问和提供功能
- en: You want users to interact with your program on the console but you don’t want
    them digging into its implementation to make changes you didn’t intend. The set
    of properties and actions you make available to a user is called an *interface*.
    You need a way to provide a simple interface while hiding everything else.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望用户在控制台上与你的程序交互，但你不想让他们深入到实现中做出你未打算的改变。你提供给用户的属性和动作集合称为 *接口*。你需要一种方法来提供简单的接口，同时隐藏其他所有内容。
- en: In this section you use a very simple program, a counter, as an example. In
    [section 11.4](#ch11lev1sec4), you develop an interface for a quiz app and in
    [sections 11.5](#ch11lev1sec5), [11.6](#ch11lev1sec6), and [11.7](#ch11lev1sec7)
    you apply what you’ve learned to *The Crypt*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你使用一个非常简单的程序，一个计数器，作为示例。在 [第 11.4 节](#ch11lev1sec4) 中，你为问答应用程序开发了一个接口，在
    [第 11.5 节](#ch11lev1sec5)、[11.6 节](#ch11lev1sec6) 和 [11.7 节](#ch11lev1sec7) 中，你将所学知识应用到
    *The Crypt*。
- en: The following listing shows the first version of the counter program, using
    a global variable to hold the current count.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了计数程序的第一版本，使用全局变量来保存当前计数。
- en: Listing 11.7\. A counter ([http://jsbin.com/yagese/edit?js,console](http://jsbin.com/yagese/edit?js,console))
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.7\. 计数器 ([http://jsbin.com/yagese/edit?js,console](http://jsbin.com/yagese/edit?js,console))
- en: '![](179fig01_alt.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](179fig01_alt.jpg)'
- en: Run the program and follow these steps at the console prompt. (Your actions
    show the prompt, `>`, but the responses do not.)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台提示符下运行程序并遵循以下步骤。（你的操作显示提示符 `>`，但响应不显示。）
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It seems to be working, so what’s the problem? Well, because `counter` is a
    global variable, the user can change it at any time.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 它似乎正在正常工作，那么问题是什么？嗯，因为 `counter` 是一个全局变量，用户可以随时更改它。
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You probably don’t want the user tweaking your counting variable like that.
    Next, you use what you learned about local variables in [section 11.2](#ch11lev1sec2)
    to hide the `counter` variable from the user.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不希望用户像那样调整计数变量。接下来，你使用在 [第 11.2 节](#ch11lev1sec2) 中学到的关于局部变量的知识来隐藏 `counter`
    变量，使其对用户不可见。
- en: 11.3.1\. Using a function to hide variables
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.1\. 使用函数隐藏变量
- en: 'You want to achieve two outcomes with your counting app:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望通过你的计数应用程序实现两个结果：
- en: The `counter` variable is hidden from the user.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`counter` 变量对用户不可见。'
- en: The `count` function can be seen by the user.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count` 函数对用户可见。'
- en: '[Listing 11.8](#ch11ex08) shows a solution. Running the program enables the
    following console interaction, as required:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11.8](#ch11ex08) 展示了一个解决方案。运行程序可以启用以下所需的控制台交互：'
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: (Again, the error your browser displays may be slightly different.)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: （再次强调，浏览器显示的错误可能略有不同。）
- en: Listing 11.8\. Hiding the counter variable ([http://jsbin.com/fuwuvi/edit?js,console](http://jsbin.com/fuwuvi/edit?js,console))
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.8\. 隐藏计数变量 ([http://jsbin.com/fuwuvi/edit?js,console](http://jsbin.com/fuwuvi/edit?js,console))
- en: '![](180fig01_alt.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](180fig01_alt.jpg)'
- en: '[Table 11.1](#ch11table01) summarizes the key ideas as a series of problems
    and solutions; [figure 11.5](#ch11fig05) illustrates how the returned counting
    function, assigned to `count`, still has access to the local `counter` variable.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 11.1](#ch11table01) 以一系列问题和解决方案的形式总结了关键思想；[图 11.5](#ch11fig05) 阐述了返回的计数函数，即分配给
    `count` 的函数，仍然可以访问局部 `counter` 变量。'
- en: Figure 11.5\. The returned function still has access to the local `counter`
    variable.
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.5\. 返回的函数仍然可以访问局部 `counter` 变量。
- en: '![](11fig05_alt.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](11fig05_alt.jpg)'
- en: Table 11.1\. Problems and solutions for the counter app
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 11.1\. 计数器应用程序的问题和解决方案
- en: '| Problem | Solution |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 问题 | 解决方案 |'
- en: '| --- | --- |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| I want the counter variable to be hidden from the user. | Declare the counter
    variable inside the getCounter function. As a local variable, counter won’t be
    accessible by the user. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 我希望计数器变量对用户不可见。 | 在 `getCounter` 函数内部声明计数器变量。作为一个局部变量，计数器对用户不可访问。 |'
- en: '| My function, countUpBy1, which increments the counter, needs access to the
    counter variable. | Define the countUpBy1 function inside the getCounter function
    as well. Because it’s inside getCounter, it will have access to the counter variable.
    |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 我的函数 `countUpBy1`，它增加计数器，需要访问计数器变量。 | 在 `getCounter` 函数内部定义 `countUpBy1`
    函数。因为它在 `getCounter` 内部，所以它将可以访问计数器变量。 |'
- en: '| I want the user to be able to call the counting function. | Return the counting
    function, countUpBy1, from the getCounter function. It can then be assigned to
    a global variable. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 我希望用户能够调用计数函数。 | 从 `getCounter` 函数返回计数函数 `countUpBy1`。然后它可以被分配给全局变量。 |'
- en: By returning a function and assigning it to the `count` variable ([figure 11.5](#ch11fig05)),
    you’ve given the user a way to use the program; you’ve given them an interface—they
    just call `getCounter()` to obtain a counting function and then `count()` to increment
    the counter.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过返回一个函数并将其赋值给 `count` 变量 ([图 11.5](#ch11fig05))，你为用户提供了使用程序的方法；你给了他们一个接口——他们只需调用
    `getCounter()` 来获取计数函数，然后调用 `count()` 来增加计数。
- en: 11.3.2\. Creating multiple independent counters with getCount
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.2\. 使用 `getCount` 创建多个独立的计数器
- en: 'In [listing 11.8](#ch11ex08) you defined a function, `getCounter`, to create
    counters. Each time you call `getCounter` it executes the same three steps:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [代码列表 11.8](#ch11ex08) 中，你定义了一个函数 `getCounter` 来创建计数器。每次调用 `getCounter` 时，它都会执行以下三个相同的步骤：
- en: '**1**.  Declare a `counter` variable and assign it the value `0`.'
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  声明一个 `counter` 变量并将其赋值为 `0`。'
- en: '**2**.  Define a function to do the counting. The function uses the `counter`
    variable from step 1.'
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  定义一个用于计数的函数。该函数使用步骤 1 中的 `counter` 变量。'
- en: '**3**.  Return the function that does the counting.'
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**.  返回执行计数的函数。'
- en: Each time you call `getCounter`, it declares a `counter` variable and defines
    a counting function. If you call `getCounter` multiple times, don’t the `counter`
    variables interfere with each other? No, because `getCounter` creates a fresh
    local scope each time it runs; you get multiple copies of the `counter` variable,
    each within its own isolated collection of variables, its own local scope.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用 `getCounter` 时，它都会声明一个 `counter` 变量并定义一个计数函数。如果你多次调用 `getCounter`，`counter`
    变量不会相互干扰吗？不，因为 `getCounter` 每次运行时都会创建一个新的局部作用域；你将获得多个 `counter` 变量的副本，每个副本都在其自己的隔离变量集合中，即其自己的局部作用域中。
- en: '[Listing 11.9](#ch11ex09) updates the `getCounter` code to create two counters.
    You can then perform the following console interactions:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11.9](#ch11ex09) 更新了 `getCounter` 代码以创建两个计数器。然后你可以执行以下控制台交互：'
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`peakCount` and `climbCount` do not interfere with each other.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`peakCount` 和 `climbCount` 不会相互干扰。'
- en: Listing 11.9\. Multiple counters ([http://jsbin.com/sicoce/edit?js,console](http://jsbin.com/sicoce/edit?js,console))
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.9\. 多个计数器 ([http://jsbin.com/sicoce/edit?js,console](http://jsbin.com/sicoce/edit?js,console))
- en: '![](182fig01_alt.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](182fig01_alt.jpg)'
- en: Having `counter` as a local variable allows you to have multiple independent
    counters.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `counter` 作为局部变量允许你拥有多个独立的计数器。
- en: 11.3.3\. Creating multiple independent counters with a constructor function
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.3\. 使用构造函数创建多个独立的计数器
- en: 'If you’re going to be creating lots of counters, you could use a constructor
    function to define what a counter is and does. As detailed in [chapter 9](kindle_split_017.html#ch09),
    a constructor function streamlines the common process of creating objects with
    similar properties and methods. You call a constructor by using the `new` keyword.
    For counters, you might have the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将要创建很多计数器，您可以使用构造函数来定义计数器是什么以及它做什么。如 [第 9 章](kindle_split_017.html#ch09)
    中详细说明的，构造函数简化了创建具有相似属性和方法的对象的常见过程。您通过使用 `new` 关键字来调用构造函数。对于计数器，您可能如下所示：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The constructor will automatically create an object assigned to the special
    `this` variable and return it. You can set the counting function as a property
    of `this` to make it available outside the constructor; see [listing 11.10](#ch11ex10).
    On the console, you might call the counting function like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数将自动创建一个分配给特殊 `this` 变量的对象，并返回它。您可以将计数函数设置为 `this` 的属性，使其在构造函数外部可用；参见 [listing
    11.10](#ch11ex10)。在控制台上，您可能调用计数函数如下：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Listing 11.10\. A counter constructor ([http://jsbin.com/yidomap/edit?js,console](http://jsbin.com/yidomap/edit?js,console))
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.10\. 计数器构造函数 ([http://jsbin.com/yidomap/edit?js,console](http://jsbin.com/yidomap/edit?js,console))
- en: '![](183fig01_alt.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](183fig01_alt.jpg)'
- en: Compare [listings 11.9](#ch11ex09) and [11.10](#ch11ex10). They’re almost identical!
    The only difference is that in [listing 11.10](#ch11ex10) you set the counting
    function as a property of `this` rather than returning it. The constructor function
    automatically returns the `this` object, so you don’t need to. The constructor
    is still a function, so `counter` is still a local variable. Either approach,
    the plain function or the constructor function, is valid. They both let you return
    an interface while hiding the implementation details.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 比较以下列表 11.9 ([listings 11.9](#ch11ex09)) 和 11.10 ([11.10](#ch11ex10))。它们几乎完全相同！唯一的区别在于在
    [listing 11.10](#ch11ex10) 中，你将计数函数设置为 `this` 的属性，而不是返回它。构造函数会自动返回 `this` 对象，因此你不需要这样做。构造函数仍然是一个函数，所以
    `counter` 仍然是一个局部变量。无论是普通函数还是构造函数，都是有效的。它们都允许你返回一个接口，同时隐藏实现细节。
- en: The counter was a nice, simple example. Let’s look at something with a few more
    moving parts, the quiz app. No cheating!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 计数器是一个简单、清晰的例子。让我们看看有更多移动部件的东西，即问答应用。不要作弊！
- en: 11.4\. Creating a quick quiz app
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4\. 创建一个快速问答应用
- en: 'You want to create a simple quiz app. The app should be able to do three things:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要创建一个简单的问答应用。该应用应该能够做三件事：
- en: '**1**.  Display a question on the console.'
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 在控制台显示一个问题。'
- en: '**2**.  Display the answer to the current question on the console.'
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 在控制台显示当前问题的答案。'
- en: '**3**.  Move to the next question in the question bank.'
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 将问题库中的下一个问题移动到下一个问题。'
- en: 'The start of a typical interaction on the console might look like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台典型交互的开始可能看起来像这样：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, there are three functions, `quizMe`, `showMe`, and `next`, that
    satisfy the app’s three requirements. You also need an array of questions and
    answers and a variable to keep track of which is the current question. Global
    variables, those declared outside any functions, are said to be in the *global
    namespace*. To avoid *polluting the global namespace* with all those quiz variables,
    you can set them as properties of a single object. As you saw in [chapter 7](kindle_split_015.html#ch07),
    when a single object is used to collect related variables together in this way,
    it’s often called a *namespace*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有三个函数 `quizMe`、`showMe` 和 `next` 满足应用的三项要求。您还需要一个问题和答案的数组以及一个变量来跟踪当前的问题。在函数外部声明的变量被称为在
    *全局命名空间* 中。为了避免将所有这些问答变量 *污染全局命名空间*，您可以将其设置为单个对象的属性。正如您在 [第 7 章](kindle_split_015.html#ch07)
    中所看到的，当以这种方式使用单个对象收集相关变量时，它通常被称为 *命名空间*。
- en: 11.4.1\. Using an object as a namespace
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.4.1\. 使用对象作为命名空间
- en: 'The app will create a single global variable, `quiz`. All of your variables
    can then be set as properties of the `quiz` object, as shown in [listing 11.11](#ch11ex11).
    The array of questions and answers starts like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 应用将创建一个全局变量 `quiz`。然后，您可以将所有变量设置为 `quiz` 对象的属性，如 [listing 11.11](#ch11ex11)
    中所示。问题和答案的数组开始如下：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You then access the array via `quiz.questions`. Remember, array indexes start
    at 0, so to access the first question-and-answer object, use `quiz.questions[0]`.
    To get the first question and the first answer from the `questions` array, use
    the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过 `quiz.questions` 访问数组。请记住，数组索引从 0 开始，因此要访问第一个问题-答案对象，请使用 `quiz.questions[0]`。要从
    `questions` 数组中获取第一个问题和第一个答案，请使用以下代码：
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You keep track of the current question with the `qIndex` property.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用 `qIndex` 属性跟踪当前问题。
- en: Listing 11.11\. Improving the quiz app ([http://jsbin.com/tupoto/edit?js,console](http://jsbin.com/tupoto/edit?js,console))
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.11\. 改进测验应用程序 ([http://jsbin.com/tupoto/edit?js,console](http://jsbin.com/tupoto/edit?js,console))
- en: '![](ch11ex11-0.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图 ch11ex11-0.jpg](ch11ex11-0.jpg)'
- en: '![](ch11ex11-1.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图 ch11ex11-1.jpg](ch11ex11-1.jpg)'
- en: '[Listing 11.11](#ch11ex11) satisfies the three requirements of your app and
    is polite enough to use only a single global variable, `quiz`. Everything it needs
    is within the `quiz` object. Because all of the properties are accessed as properties
    of `quiz`, we say they’re in the `quiz` namespace.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11.11](#ch11ex11) 满足您应用程序的三个要求，并且足够礼貌地只使用一个全局变量，`quiz`。它所需的一切都在 `quiz`
    对象内部。因为所有属性都是作为 `quiz` 的属性访问的，所以我们说它们位于 `quiz` 命名空间中。'
- en: Unfortunately, your app doesn’t overcome the *access all areas* drawback of
    global variables seen in [section 11.1.1](#ch11lev2sec1). All of the properties
    of the `quiz` object are *public*—the user can still steal a peak and tweak all
    the values.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，您的应用程序没有克服 [第 11.1.1 节](#ch11lev2sec1) 中看到的全局变量的 *访问所有区域* 缺点。`quiz` 对象的所有属性都是
    *公共的*——用户仍然可以偷看并调整所有值。
- en: 11.4.2\. Hiding the questions array
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.4.2\. 隐藏问题数组
- en: 'In [listing 11.11](#ch11ex11), players can access all of the `quiz` object’s
    properties at the console. This allows them to cause mischief, changing properties
    on a whim:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 11.11](#ch11ex11) 中，玩家可以在控制台中访问 `quiz` 对象的所有属性。这使他们可以随心所欲地造成破坏，更改属性：
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: But you want them to use only `quiz.quizMe`, `quiz.showMe`, and `quiz.next`.
    Let’s make the `questions` array and the `qIndex` value *private* by using local
    variables, as shown in [figure 11.6](#ch11fig06).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 但您希望他们只使用 `quiz.quizMe`、`quiz.showMe` 和 `quiz.next`。让我们通过使用局部变量将 `questions`
    数组和 `qIndex` 值设为 *私有*，如图 11.6 所示。
- en: Figure 11.6\. Use local variables to make `qIndex` and `questions` private
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.6\. 使用局部变量使 `qIndex` 和 `questions` 成为私有
- en: '![](11fig06_alt.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图 11fig06_alt.jpg](11fig06_alt.jpg)'
- en: The next listing uses the `getQuiz` function to create a local scope in which
    to hide the `questions` array and the `qIndex` value.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表使用 `getQuiz` 函数创建一个局部作用域，用于隐藏 `questions` 数组和 `qIndex` 值。
- en: Listing 11.12\. Hiding the questions and answers ([http://jsbin.com/qahedu/edit?js,console](http://jsbin.com/qahedu/edit?js,console))
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.12\. 隐藏问题和答案 ([http://jsbin.com/qahedu/edit?js,console](http://jsbin.com/qahedu/edit?js,console))
- en: '![](ch11ex12-0.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图 ch11ex12-0.jpg](ch11ex12-0.jpg)'
- en: '![](ch11ex12-1.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图 ch11ex12-1.jpg](ch11ex12-1.jpg)'
- en: 'The program returns an object with three properties: `quizMe`, `showMe`, and
    `next`. The last line assigns the returned object to the `quiz` variable. You
    can then use `quiz` to access the three functions:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 程序返回一个具有三个属性的对象：`quizMe`、`showMe` 和 `next`。最后一行将返回的对象赋值给 `quiz` 变量。然后您可以使用 `quiz`
    来访问这三个函数：
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The code that makes the quiz app work is called its *implementation*. Some of
    the implementation is hidden in the `getQuiz` function by using local variables.
    The object returned by the function provides the user with an *interface*, a public
    way of interacting with the program. The user can call the `quizMe`, `showMe`,
    and `next` functions because they’re methods of the interface object. The user
    can’t access the `qIndex` and `questions` variables because they’re local to the
    `getQuiz` function.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使测验应用程序工作的代码称为其 *实现*。其中一些实现通过使用局部变量隐藏在 `getQuiz` 函数中。该函数返回的对象向用户提供了一个 *接口*，一种与程序交互的公共方式。用户可以调用
    `quizMe`、`showMe` 和 `next` 函数，因为它们是接口对象的成员方法。用户无法访问 `qIndex` 和 `questions` 变量，因为它们是
    `getQuiz` 函数的局部变量。
- en: '[Figure 11.7](#ch11fig07) shows how errors are thrown when an attempt is made
    to access the variables `qIndex` and `questions` at the console prompt on JS Bin.
    (Your error messages may be slightly different.)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.7](#ch11fig07) 展示了在 JS Bin 控制台中尝试访问变量 `qIndex` 和 `questions` 时抛出的错误。（您的错误信息可能略有不同。）'
- en: Figure 11.7\. Trying to access `qIndex` and `questions` from the console now
    causes errors.
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.7\. 现在尝试从控制台访问 `qIndex` 和 `questions` 会导致错误。
- en: '![](11fig07_alt.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图 11fig07_alt.jpg](11fig07_alt.jpg)'
- en: 11.5\. The Crypt—hiding player info
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5\. 保密室——隐藏玩家信息
- en: In this section, and in [sections 11.6](#ch11lev1sec6) and [11.7](#ch11lev1sec7),
    you update your code for *The Crypt* to hide variables, properties, and functions
    that are part of the implementation and that should not be spied by outside eyes.
    At the same time, you consider what form your interfaces should take—what information
    and actions you’ll make available to players and to programmers.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节以及[第11.6节](#ch11lev1sec6)和[11.7节](#ch11lev1sec7)中，你更新了*The Crypt*的代码，以隐藏实现中的一部分变量、属性和函数，这些不应该被外界窥视。同时，你考虑了你的接口应该采取什么形式——你将向玩家和程序员提供哪些信息和操作。
- en: 11.5.1\. Our current Player constructor—everything is public
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.5.1\. 我们当前的玩家构造函数——一切都是公开的
- en: Up to this point, you haven’t made any attempt to control a user’s access to
    the data in a `Player` object. The following listing shows the current form of
    your `Player` constructor.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你还没有尝试控制用户对`Player`对象中数据的访问。以下列表显示了你的`Player`构造函数的当前形式。
- en: Listing 11.13\. The Player constructor ([http://jsbin.com/dacedu/edit?js,console](http://jsbin.com/dacedu/edit?js,console))
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.13\. 玩家构造函数([http://jsbin.com/dacedu/edit?js,console](http://jsbin.com/dacedu/edit?js,console))
- en: '![](187fig01_alt.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图片](187fig01_alt.jpg)'
- en: You set all of the player data and all of the functions as properties of the
    special `this` object. The constructor creates the `this` object automatically
    when you call it with the `new` keyword. In the snippet that follows, you call
    the `Player` constructor to create a new player.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你将所有玩家数据和所有函数都设置为特殊`this`对象的属性。当你使用`new`关键字调用构造函数时，它会自动创建`this`对象。在下面的代码片段中，你调用`Player`构造函数来创建一个新的玩家。
- en: '[PRE29]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The constructor function automatically returns the `this` object, and you then
    assign the object to the `player1` variable. Because you attached everything to
    `this` within the constructor, and `this` was returned and assigned to `player1`,
    you can now use `player1` to access data and methods: `player1.name`, `player1.items`,
    `player1.addItem`, `player1.getInfo`, and `player1.showInfo` are all accessible,
    for example.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数会自动返回`this`对象，然后你将对象分配给`player1`变量。因为你将所有内容都附加到了构造函数中的`this`上，并且`this`被返回并分配给了`player1`，你现在可以使用`player1`来访问数据和方法：例如，`player1.name`、`player1.items`、`player1.addItem`、`player1.getInfo`和`player1.showInfo`都是可访问的。
- en: 11.5.2\. An updated Player constructor—some variables are hidden
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.5.2\. 更新的玩家构造函数——一些变量被隐藏
- en: To control users’ access to player data you can use parameters and variables
    without assigning values to properties of the `this` object. Parameters, between
    the opening parentheses in a function definition, act just like variables declared
    within the function body. They’re local to the function and can be used anywhere
    within the function but can’t be accessed by code outside the function.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制用户对玩家数据的访问，你可以使用参数和变量，而不必为`this`对象的属性赋值。在函数定义的开括号之间，参数的作用就像函数体内声明的变量。它们是函数本地的，可以在函数的任何地方使用，但不能被函数外的代码访问。
- en: '[PRE30]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[Figure 11.8](#ch11fig08) shows the change in visibility of variables and properties
    from the old `Player` constructor ([listing 11.13](#ch11ex13)) to the new ([listing
    11.14](#ch11ex14)). The new constructor hides most of the functions in the local
    scope, assigning only four functions to the special `this` object as an interface.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11.8](#ch11fig08)显示了从旧的`Player`构造函数（[列表11.13](#ch11ex13)）到新的（[列表11.14](#ch11ex14)）中变量和属性可见性的变化。新的构造函数隐藏了局部作用域中的大多数函数，只将四个函数分配给特殊的`this`对象作为接口。'
- en: Figure 11.8\. Hiding variables and functions in the local scope of the constructor
    function
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.8\. 在构造函数的局部作用域中隐藏变量和函数
- en: '![](11fig08_alt.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图片](11fig08_alt.jpg)'
- en: The next listing shows the changes in code; local variables, declared with `var`,
    are used to prevent direct access to a player’s data.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 下一列表显示了代码中的变化；使用`var`声明的局部变量用于防止直接访问玩家的数据。
- en: Listing 11.14\. Hiding player info in the constructor ([http://jsbin.com/fuyaca/edit?js,console](http://jsbin.com/fuyaca/edit?js,console))
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.14\. 在构造函数中隐藏玩家信息([http://jsbin.com/fuyaca/edit?js,console](http://jsbin.com/fuyaca/edit?js,console))
- en: '![](ch11ex14-0.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch11ex14-0.jpg)'
- en: '![](ch11ex14-1.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch11ex14-1.jpg)'
- en: The properties and functions you don’t want to be seen outside the constructor
    you assign to local variables. The methods you want to make visible you assign
    as properties of the `this` object.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你将不想在外部构造函数中看到的属性和函数分配给局部变量。你希望公开的方法作为`this`对象的属性分配。
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `setPlace` and `getPlace` methods give users access to the `place` variable.
    Why bother using a variable to make `place` private if you’re only going to provide
    methods to access it anyway? They provide an interface and allow you to hide the
    implementation and also let you mediate access. When the `setPlace` method is
    called, you can check that the `destination` argument is a valid place before
    assigning it to the `place` variable. When the `getPlace` method is called, you
    can check that the user is allowed to get access before returning the place. You
    haven’t put those extra checks in place yet, but your two methods are ready for
    when you need to add any conditions.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`setPlace`和`getPlace`方法使用户能够访问`place`变量。如果你只是提供访问它的方法，为什么还要费心使用变量来使`place`私有？它们提供了一个接口，并允许你隐藏实现细节，同时也让你能够控制访问。当调用`setPlace`方法时，你可以在将其分配给`place`变量之前检查`destination`参数是否是一个有效的位置。当调用`getPlace`方法时，你可以在返回位置之前检查用户是否有权访问。你还没有实施这些额外的检查，但你的两个方法已经准备好在你需要添加任何条件时使用。'
- en: 'You’ve also simplified the information displayed by `showInfo` so that it no
    longer includes the current place. `Place` objects have their own `showInfo` method,
    so there’s no need to double up and display place details as part of a player’s
    information. When you display player info on the console, it now looks like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你还简化了`showInfo`显示的信息，使其不再包括当前位置。`Place`对象有自己的`showInfo`方法，因此没有必要重复显示位置详情作为玩家信息的一部分。当你现在在控制台显示玩家信息时，它看起来像这样：
- en: '[PRE32]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The player’s health is shown in parentheses after their name. To show information
    about a player’s current location, you can call `getPlace` to retrieve the place
    object and then call the place object’s `showInfo` method:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家的健康状态显示在他们名字的括号中。要显示关于玩家当前位置的信息，你可以调用`getPlace`来检索位置对象，然后调用该位置对象的`showInfo`方法：
- en: '[PRE33]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 11.6\. The Crypt—hiding place info
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.6\. 密室——隐藏位置信息
- en: You now do for the `Place` constructor what you did for the `Player` constructor.
    You hide the data and provide methods that access it as required. The next listing
    shows the structure of the previous `Place` constructor, from [chapter 10](kindle_split_018.html#ch10),
    with data and methods set on the `this` object.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在对`Place`构造函数所做的，与对`Player`构造函数所做的相同。你隐藏了数据，并提供了按需访问它的方法。下一个列表显示了之前`Place`构造函数的结构，来自第10章，数据和方法都设置在`this`对象上。
- en: Listing 11.15\. The Place constructor ([http://jsbin.com/kavane/edit?js,console](http://jsbin.com/kavane/edit?js,console))
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.15\. 位置构造函数 ([http://jsbin.com/kavane/edit?js,console](http://jsbin.com/kavane/edit?js,console))
- en: '![](191fig01_alt.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](191fig01_alt.jpg)'
- en: The following listing shows your updated version of the `Place` constructor,
    using parameters and variables to hide data, a new `getExit` function to return
    the destination for a specified direction, and a new `getLastItem` method to return
    the last item from the items array.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了你的更新后的`Place`构造函数版本，使用参数和变量来隐藏数据，一个新的`getExit`函数来返回指定方向的目的地，以及一个新的`getLastItem`方法来返回物品数组中的最后一个项目。
- en: Listing 11.16\. Hiding place info in the constructor ([http://jsbin.com/riviga/edit?js,console](http://jsbin.com/riviga/edit?js,console))
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.16\. 在构造函数中隐藏位置信息 ([http://jsbin.com/riviga/edit?js,console](http://jsbin.com/riviga/edit?js,console))
- en: '![](ch11ex16-0.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](ch11ex16-0.jpg)'
- en: '![](ch11ex16-1.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](ch11ex16-1.jpg)'
- en: You’ve hidden certain properties and functions in the `Player` and `Place` constructors
    while making a small set of methods—your interface—visible via the `this` object.
    Other parts of your program that use the constructors (or programmers who may
    use your code in their own adventure game programs) can use only the methods in
    the interface.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建一个小的方法集——你的接口——通过`this`对象使其可见的同时，你在`Player`和`Place`构造函数中隐藏了某些属性和函数。你的程序的其他部分使用构造函数（或者可能在他们的冒险游戏程序中使用你的代码的程序员）只能使用接口中的方法。
- en: For players typing commands at a console, you’ll preserve their enjoyment of
    the game by preventing them from stumbling inadvertently over important game values
    they find they can change. (*Cheating* is such a nasty word.) You’ll present the
    players with a small, simple set of actions they can take to explore, collect,
    smite, and destroy—whatever is appropriate as they journey through *The Crypt*.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在控制台输入命令的玩家，你将通过防止他们意外地发现并更改重要的游戏值来保留他们对游戏的乐趣。（*作弊*是一个如此令人讨厌的词。）你将向玩家展示一组小而简单的动作，他们可以用来探索、收集、打击和摧毁——在他们穿越*密室*的过程中，任何适当的事情。
- en: 11.7\. The Crypt—user interaction
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.7\. 密室——用户交互
- en: In [chapter 10](kindle_split_018.html#ch10) you created a version of *The Crypt*
    that let the player move from place to place and pick up items they found. Unfortunately,
    you polluted the global namespace with all of your variables. Don’t beat yourself
    up about it; you were young and naïve. Now you have a way to hide the implementation
    from the user.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](kindle_split_018.html#ch10)中，您创建了一个版本的《密室》，允许玩家从一个地点移动到另一个地点并捡起他们找到的物品。不幸的是，您将所有变量都污染了全局命名空间。不要为此自责；那时你还年轻且天真。现在您有了一种方法来隐藏实现，不让用户看到。
- en: '[Listing 11.17](#ch11ex17) shows an outline of the current implementation;
    the full version is on JS Bin. It’s almost the same as the version from [chapter
    10](kindle_split_018.html#ch10) but uses the `getPlace` and `setPlace` player
    methods and the `getExit` and `getLastItem` place methods from this chapter’s
    constructor updates. The code that uses them is shown in full.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11.17](#ch11ex17) 展示了当前实现的概要；完整版本在JS Bin上。它与第10章的版本几乎相同，但使用了本章构造函数更新中的`getPlace`和`setPlace`玩家方法以及`getExit`和`getLastItem`地点方法。使用它们的代码已全部展示。'
- en: Listing 11.17\. Lots of global variables in the game ([http://jsbin.com/dateqe/edit?js,console](http://jsbin.com/dateqe/edit?js,console))
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.17\. 游戏中有许多全局变量 ([http://jsbin.com/dateqe/edit?js,console](http://jsbin.com/dateqe/edit?js,console))
- en: '[PRE34]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Notice all the global variables—the `spacer` namespace, the `Player` and `Place`
    constructors, the game control functions, all the places, and the player—are assigned
    to variables outside any functions. Smelly pollution. Only the game control functions,
    `go` and `get`, need to be available to players. You can hide the rest.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意所有全局变量——`spacer`命名空间、`Player`和`Place`构造函数、游戏控制函数、所有地点以及玩家——都被分配到任何函数之外的外部变量中。这是臭名昭著的全局污染。只有游戏控制函数`go`和`get`需要对玩家可用。您可以隐藏其余部分。
- en: 11.7.1\. The interface—go and get
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.7.1\. 接口——前往和获取
- en: 'There are only two actions you want the user to take for now:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 目前您希望用户执行的操作只有两个：
- en: '[PRE35]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To hide the implementation, you wrap the game code inside a function. Then,
    to allow the user to take the two desired actions and no more, you return an interface
    object from the function, with the two methods:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要隐藏实现，您将游戏代码封装在一个函数中。然后，为了允许用户执行两个期望的操作而不再执行更多操作，您从函数中返回一个接口对象，包含两个方法：
- en: '[PRE36]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The interface methods use the functionality of player and place objects to do
    their jobs, with those objects created by their respective constructor functions.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 接口方法使用玩家和地点对象的功能来完成它们的工作，这些对象由各自的构造函数创建。
- en: 11.7.2\. Hiding the implementation
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.7.2\. 隐藏实现
- en: To hide the rest of the code from the users, you wrap it in a function to create
    a local scope. Only your interface object is returned. The listing that follows
    shows highlights from the updated code. The full listing is available on JS Bin.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为了隐藏代码的其余部分，您将其封装在一个函数中，以创建局部作用域。只返回您的接口对象。下面的列表显示了更新后的代码的亮点。完整的列表可在JS Bin上找到。
- en: Listing 11.18\. Letting users interact with the game via an interface object
    ([http://jsbin.com/yuporu/edit?js,console](http://jsbin.com/yuporu/edit?js,console))
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.18\. 通过接口对象让用户与游戏交互 ([http://jsbin.com/yuporu/edit?js,console](http://jsbin.com/yuporu/edit?js,console))
- en: '![](ch11ex18-0.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](ch11ex18-0.jpg)'
- en: '![](ch11ex18-1.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](ch11ex18-1.jpg)'
- en: 'The last statement of the listing calls the `getGame` function. The function
    executes and then returns the interface object that has the `go` and `get` methods.
    The statement assigns the interface object to the `game` variable. The player
    can access the `go` and `get` methods via the `game` variable by using dot notation:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的最后一条语句调用了`getGame`函数。函数执行后返回具有`go`和`get`方法的接口对象。该语句将接口对象赋值给`game`变量。玩家可以通过使用点符号通过`game`变量访问`go`和`get`方法：
- en: '[PRE37]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The player can’t access any other variables or functions from the game. Your
    work is done! At least for this chapter.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家无法访问游戏中的任何其他变量或函数。您的工作完成了！至少对于这一章来说。
- en: The *wrap-and-return* process of wrapping code in a function from which you
    then return an interface object is called the *module pattern*. It’s a common
    way of separating the interface from the implementation and helps package your
    code for portability and reuse. You’ll see it a lot from now on, particularly
    in [chapter 13](kindle_split_022.html#ch13) when you investigate importing modules
    by using HTML `script` tags. Before you get to that, you have some decisions to
    make in [chapter 12](kindle_split_021.html#ch12). *If* you’re ready, read on;
    *else* take a break, chill out, try the Further Adventures, and gird your loins.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码包裹在函数中，然后从该函数返回接口对象的`wrap-and-return`过程称为*模块模式*。这是一种常见的将接口与实现分离的方法，有助于打包你的代码以实现可移植性和重用。从现在开始，你将经常看到它，尤其是在第13章（[kindle_split_022.html#ch13]）中，当你使用HTML
    `script`标签调查导入模块时。在你到达那里之前，你需要在第12章（[kindle_split_021.html#ch12]）中做出一些决定。*如果*你准备好了，请继续阅读；*否则*休息一下，放松一下，尝试进一步冒险，并做好准备。
- en: 11.8\. Summary
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.8。总结
- en: 'Reduce the number of global variables in your programs. Global variables are
    variables declared outside all functions. They can be accessed anywhere in the
    program but pollute the global namespace, expose your implementation, can create
    naming collisions, and can help introduce hard-to-find bugs:'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少程序中的全局变量数量。全局变量是在所有函数外部声明的变量。它们可以在程序的任何地方访问，但会污染全局命名空间，暴露你的实现，可能造成命名冲突，并可能帮助引入难以发现的错误：
- en: '[PRE38]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Reduce the number of global variables by collecting related variables and functions
    as properties of a single object. Such an object is often called a namespace:'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过收集相关变量和函数作为单个对象的属性来减少全局变量的数量。这样的对象通常被称为命名空间：
- en: '[PRE40]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Wrap code in functions to create local scopes, collections of local variables:'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码包裹在函数中以创建局部作用域，局部变量的集合：
- en: '[PRE41]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Wrap code in functions to make variables private, hide your implementation,
    avoid naming collisions, and reduce the risk of hard-to-find bugs.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码包裹在函数中以使变量私有，隐藏你的实现，避免命名冲突，并减少难以发现的错误的风险。
- en: Return public interfaces from functions to clearly define the properties and
    methods you expect users to access (the module pattern).
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从函数中返回公共接口以清楚地定义用户期望访问的属性和方法（模块模式）。
- en: 'Return a single function:'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个单独的函数：
- en: '[PRE42]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Return an object:'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个对象：
- en: '[PRE44]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Remember that constructor functions create a local scope, just like any other
    functions. The special `this` variable is automatically returned. It acts as the
    public interface:'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住，构造函数创建一个局部作用域，就像任何其他函数一样。特殊的`this`变量会自动返回。它充当公共接口：
- en: '[PRE46]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Chapter 12\. Conditions: choosing code to run'
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第12章。条件：选择要运行的代码
- en: '***This chapter covers***'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '***本章涵盖***'
- en: Comparing values with comparison operators
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用比较运算符比较值
- en: Checking conditions that are `true` or `false`
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查`true`或`false`的条件
- en: The `if` statement—running code only if a condition is met
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if`语句——仅在满足条件时运行代码'
- en: The `else` clause—running code when a condition is not met
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`else`子句——当条件不满足时运行代码'
- en: Making sure user input won’t break your code
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保用户输入不会破坏你的代码
- en: Generating random numbers with `Math.random()`
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Math.random()`生成随机数
- en: So far, all of your code follows a single path. When you call a function, every
    statement in the function body is executed. You’ve managed to get a lot done and
    covered quite a few core ideas in JavaScript but your programs have lacked flexibility;
    they haven’t been able to decide whether or not to execute blocks of code.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你所有的代码都遵循单一路径。当你调用一个函数时，函数体内的每个语句都会被执行。你已经完成了很多工作，并覆盖了JavaScript中的许多核心概念，但你的程序缺乏灵活性；它们无法决定是否执行代码块。
- en: In this chapter you learn how to run code only when specified conditions are
    met. Suddenly, your programs can branch, providing options, flexibility, and richness.
    You can increase a player’s score *if* they splat a kumquat, move to a new location
    *if* the user specifies a valid direction, or post a tweet *if* it’s less than
    141 characters long.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何在满足特定条件时运行代码。突然之间，你的程序可以分支，提供选项、灵活性和丰富性。你可以增加玩家的分数*如果*他们击中了金桔，*如果*用户指定了有效的方向，或者*如果*推文的长度少于141个字符。
- en: If you want to find out how your programs can make decisions, read on, else,
    ... well, read on anyway. You really need to know this stuff!
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解你的程序如何做出决定，请继续阅读，否则，... 好吧，无论如何都要继续阅读。你真的需要知道这些内容！
- en: 12.1\. Conditional execution of code
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1。代码的条件执行
- en: 'To start, create a simple program that asks the user to guess a secret number.
    If they guess correctly, the program says, “Well done!” An interaction at the
    console might look like this:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个简单的程序，要求用户猜测一个秘密数字。如果他们猜对了，程序会说，“做得好！”控制台交互可能看起来像这样：
- en: '[PRE47]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: What’s with the ugly appearances of `undefined`? When you call a function at
    the console, its code is executed and then its return value is displayed. The
    `guess` function in the following listing doesn’t include a return statement so
    it automatically returns `undefined`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`undefined`的丑陋外观是怎么回事？当你控制台调用一个函数时，它的代码被执行，然后显示其返回值。以下列表中的`guess`函数没有包含返回语句，因此它自动返回`undefined`。'
- en: Listing 12.1\. Guess the number [http://jsbin.com/feholi/edit?js,console](http://jsbin.com/feholi/edit?js,console)
  id: totrans-280
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.1\. 猜数字 [http://jsbin.com/feholi/edit?js,console](http://jsbin.com/feholi/edit?js,console)
- en: '![](199fig01_alt.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](199fig01_alt.jpg)'
- en: The `guess` function checks to see if the user’s number is equal to the secret
    number. It uses the *strict equality operator*, `===`, and an *if statement* so
    that you display the “Well done!” message only if the numbers match. The following
    sections look at the strict equality operator and the `if` statement in more detail
    and introduce the *else clause*.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`guess`函数检查用户的数字是否等于秘密数字。它使用*严格的相等运算符*，`===`，以及一个*if语句*，以确保只有在数字匹配时才显示“做得好！”消息。以下几节将更详细地探讨严格的相等运算符和`if`语句，并介绍*else子句*。'
- en: 12.1.1\. The strict equality operator, ===
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.1.1\. 严格的相等运算符，===
- en: 'The strict equality operator compares two values. If they’re equal it returns
    `true`; if they’re not equal it returns `false`. You can test it at the console:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 严格的相等运算符比较两个值。如果它们相等，则返回`true`；如果不相等，则返回`false`。你可以在控制台测试它：
- en: '[PRE48]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the third example, you can see that the strict equality operator doesn’t
    consider the number `8` and the string `"8"` to be equal. That’s because numbers
    and strings are different types of data. The values `true` and `false` are a third
    type of data; they’re called *boolean* values. In fact, `true` and `false` are
    the only possible boolean values. Boolean values are useful when deciding what
    a program should do next; for example, by using an `if` statement.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三个例子中，你可以看到严格的相等运算符并不认为数字`8`和字符串`"8"`相等。这是因为数字和字符串是不同类型的数据。`true`和`false`是第三种类型的数据；它们被称为*布尔值*。实际上，`true`和`false`是唯一的可能布尔值。布尔值在决定程序下一步应该做什么时很有用；例如，通过使用`if`语句。
- en: 12.1.2\. The if statement
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.1.2\. `if`语句
- en: To execute a block of code only when a specified condition is met, you use an
    `if` statement.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要在满足指定条件时仅执行代码块，你使用`if`语句。
- en: '[PRE49]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If the condition in parentheses evaluates to `true`, then JavaScript executes
    the statements in the code block between the curly braces. If the condition evaluates
    to `false`, then JavaScript skips the code block. Notice there’s no semicolon
    after the curly braces at the end of an `if` statement.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果括号中的条件评估为`true`，则JavaScript执行花括号之间的代码块中的语句。如果条件评估为`false`，则JavaScript跳过代码块。注意，在`if`语句末尾的花括号后面没有分号。
- en: '[Listing 12.1](#ch12ex01) used the strict equality operator to return a `true`
    or `false` value for the condition.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表12.1](#ch12ex01)使用了严格的相等运算符来为条件返回`true`或`false`值。'
- en: '[PRE50]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The code logs the “Well done!” message to the console only if the value of
    `user-Number` is equal to the value of `secret`. For example, say the `secret`
    is `8` and the user chooses `2`:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 代码仅在`user-Number`的值等于`secret`的值时将“做得好！”消息记录到控制台。例如，假设`secret`是`8`，而用户选择了`2`：
- en: '[PRE51]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If the user chooses `8`, the `if` statement becomes
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户选择`8`，则`if`语句变为
- en: '[PRE52]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 12.1.3\. The else clause
  id: totrans-297
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.1.3\. `else`子句
- en: Sometimes we want different code to be executed if the condition in an `if`
    statement evaluates to `false`. We can make that happen by appending an `else`
    clause to the `if` statement ([figure 12.1](#ch12fig01)).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们希望在`if`语句中的条件评估为`false`时执行不同的代码。我们可以通过在`if`语句后附加一个`else`子句来实现这一点（[图12.1](#ch12fig01)）。
- en: Figure 12.1\. Executing code depending on the value of a condition, with `if`
    and `else`
  id: totrans-299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.1\. 根据条件值执行代码，使用`if`和`else`
- en: '![](12fig01_alt.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](12fig01_alt.jpg)'
- en: 'From [listing 12.2](#ch12ex02):'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 从[列表12.2](#ch12ex02)：
- en: '[PRE53]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If `userNumber` and `secret` are equal, JavaScript displays “Well done!” Otherwise,
    it displays “Unlucky, try again.” Notice there’s no semicolon after the curly
    braces at the end of an `else` clause. Once again, say the `secret` is `8` and
    the user chooses `2`:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `userNumber` 和 `secret` 相等，JavaScript 显示 “做得好！” 否则，它显示 “不幸，再试一次。” 注意在 `else`
    子句末尾的括号后面没有分号。再次假设 `secret` 是 `8`，用户选择 `2`：
- en: '[PRE54]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If the user chooses `8`, the `if` statement becomes
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户选择 `8`，则 `if` 语句变为
- en: '[PRE55]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'A guessing game interaction at the console might now look something like this:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台上的猜数字交互可能现在看起来像这样：
- en: '[PRE56]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Listing 12.2\. Guess the number—the `else` clause ([http://jsbin.com/nakosi/edit?js,console](http://jsbin.com/nakosi/edit?js,console))
  id: totrans-309
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.2\. 猜数字——`else` 子句 ([http://jsbin.com/nakosi/edit?js,console](http://jsbin.com/nakosi/edit?js,console))
- en: '![](202fig01_alt.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![](202fig01_alt.jpg)'
- en: Next, you use local variables to make `secret` secret.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你使用局部变量使 `secret` 变得神秘。
- en: 12.1.4\. Hide the secret number inside a function
  id: totrans-312
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.1.4\. 在函数内部隐藏秘密数字
- en: 'In [listing 12.2](#ch12ex02), both the `secret` and the `guess` variables are
    declared outside any function. You saw in [chapter 11](kindle_split_020.html#ch11)
    how that makes them global variables, accessible at the console and throughout
    the program. That’s great for `guess`—you want users to be able to guess numbers—but
    it’s a disaster for `secret`—users can peek and tweak its value at will. If you
    run the code in [listing 12.2](#ch12ex02), you can then perform the following
    actions at the console:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 12.2](#ch12ex02) 中，`secret` 和 `guess` 变量都在任何函数外部声明。你在 [第 11 章](kindle_split_020.html#ch11)
    中看到了这样做是如何使它们成为全局变量的，可以在控制台和整个程序中访问。这对 `guess` 来说很好——你希望用户能够猜测数字——但对 `secret`
    来说却是一场灾难——用户可以随意查看和调整其值。如果你在 [列表 12.2](#ch12ex02) 中运行代码，你可以在控制台执行以下操作：
- en: '[PRE57]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: That’s not much of a guessing game!
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个很好的猜数字游戏！
- en: '[Chapter 11](kindle_split_020.html#ch11) also discussed how functions are used
    in JavaScript to create a local scope, a collection of variables accessible only
    within the function. [Listing 12.3](#ch12ex03) uses the `getGuesser` function
    to hide the secret number. The function returned by `getGuesser` is assigned to
    the `guess` variable ([figure 12.2](#ch12fig02)).'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 11 章](kindle_split_020.html#ch11) 也讨论了如何在 JavaScript 中使用函数创建局部作用域，一个仅在函数内部可访问的变量集合。[列表
    12.3](#ch12ex03) 使用 `getGuesser` 函数来隐藏秘密数字。`getGuesser` 返回的函数被分配给 `guess` 变量 ([图
    12.2](#ch12fig02))。'
- en: Figure 12.2\. The function returned by `getGuesser` is assigned to the `guess`
    variable
  id: totrans-317
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.2\. `getGuesser` 返回的函数被分配给 `guess` 变量
- en: '![](12fig02_alt.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](12fig02_alt.jpg)'
- en: '`guess` is a global variable, available at the console:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`guess` 是一个全局变量，在控制台可用：'
- en: '[PRE58]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Listing 12.3\. Guess the number—using local scope ([http://jsbin.com/hotife/edit?js,console](http://jsbin.com/hotife/edit?js,console))
  id: totrans-321
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.3\. 猜数字——使用局部作用域 ([http://jsbin.com/hotife/edit?js,console](http://jsbin.com/hotife/edit?js,console))
- en: '![](203fig01_alt.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![](203fig01_alt.jpg)'
- en: The function assigned to `getGuesser` creates a local scope that lets you protect
    the `secret` variable from the user. It returns another function that lets the
    user guess a number. That function is assigned to the `guess` variable. Because
    the guess-checking function is defined in the local scope created by the `getGuesser`
    function, it has access to the `secret` variable and is able to do its checking.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 分配给 `getGuesser` 的函数创建了一个局部作用域，允许你保护 `secret` 变量不被用户访问。它返回另一个允许用户猜测数字的函数。该函数被分配给
    `guess` 变量。因为猜测检查函数是在 `getGuesser` 函数创建的局部作用域中定义的，所以它可以访问 `secret` 变量并执行其检查。
- en: You have a guessing game but it’s always the same secret number. Really, it’s
    a not-so-secret number! Let’s make use of a couple of methods from JavaScript’s
    `Math` namespace to inject some extra mystery into our guessing game.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一个猜数字游戏，但总是同一个秘密数字。实际上，这根本不是一个秘密数字！让我们利用 JavaScript 的 `Math` 命名空间中的几个方法，给我们的猜数字游戏增加一些神秘感。
- en: 12.2\. Generating random numbers with Math.random()
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2\. 使用 Math.random() 生成随机数
- en: 'The `Math` namespace provides you with a `random` method for generating random
    numbers. It always returns a number greater than or equal to 0 and less than 1\.
    Give it a whirl at the console prompt:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math` 命名空间为你提供了一个 `random` 方法来生成随机数。它总是返回一个大于或等于 0 且小于 1 的数字。在控制台提示符中试一试：'
- en: '[PRE59]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Obviously, your numbers will be different because they’re random! Unless you’re
    really into guessing games and have a lot of free time, those random numbers are
    probably a bit too tricky for your purposes.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你的数字会不同，因为它们是随机的！除非你真的很喜欢猜数字并且有很多空闲时间，否则这些随机数字可能对你来说有点太复杂了。
- en: 'To tame the numbers, scale them up to fall in a range you want and then convert
    them to whole numbers (integers). Because they start off less than 1, multiplying
    by 10 will make them less than 10\. Here’s a series of assignments using `Math.random`:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 要驯服数字，将它们放大到所需的范围内，然后转换为整数。因为它们最初小于1，乘以10会使它们小于10。以下是一系列使用`Math.random`的赋值示例：
- en: '[PRE60]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'To scale the possible numbers, multiply:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 要缩放可能的数字，乘以：
- en: '[PRE61]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To shift the possible numbers up or down, add or subtract:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 要上下调整可能的数字，加或减：
- en: '[PRE62]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'To scale and then shift, multiply and then add:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 要缩放并移动，先乘后加：
- en: '[PRE63]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Notice for the last assignment the numbers will be between 1 and 11; they can
    equal 1 but will be less than 11\. The `<=` symbol means less than or equal to,
    whereas the `<` symbol means less than. The inequality `0 <= number < 1` means
    the number is between 0 and 1 and can equal 0 but not 1 (see [section 12.3.1](#ch12lev2sec5)).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在最后一个任务中，数字将在1到11之间；它们可以等于1，但将小于11。`<=`符号表示小于或等于，而`<`符号表示小于。不等式`0 <= number
    < 1`表示数字在0到1之间，可以等于0但不能等于1（见[第12.3.1节](#ch12lev2sec5)）。
- en: 'Okay, so you’ve scaled up the random numbers, but they’re still a trifle tricky.
    At the console you can see the kind of numbers you’re generating:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以你放大了随机数，但它们仍然有点棘手。在控制台中，你可以看到你生成的数字类型：
- en: '[PRE64]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The last step is to lose the decimal fraction part of each number, to round
    the numbers down to integers. For that you use the `floor` method of the `Math`
    namespace.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是去除每个数字的小数部分，将数字四舍五入到整数。为此，你使用`Math`命名空间中的`floor`方法。
- en: '[PRE65]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `floor` method *always rounds down*, whatever the decimals are: 10.00001,
    10.2, 10.5, 10.8, and 10.99999 are all rounded down to 10, for example. You use
    `floor` to get an expression that returns a random integer between 1 and 10 inclusive:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`floor`方法*总是向下取整*，无论小数是多少：10.00001、10.2、10.5、10.8和10.99999都向下取整到10，例如。你使用`floor`来获取返回随机整数的表达式，范围在1到10（包括1）之间：'
- en: '[PRE66]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'There’s also a `Math.ceil` method that always rounds up and a `Math.round`
    method that rounds up or down, following the usual rules for mathematical rounding.
    More information about JavaScript’s `Math` object can be found on the *Get Programming
    with JavaScript* website: [http://www.room51.co.uk/js/math.html](http://www.room51.co.uk/js/math.html).'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个`Math.ceil`方法总是向上取整，还有一个`Math.round`方法根据数学四舍五入的常规规则进行四舍五入。有关JavaScript的`Math`对象更多信息，可以在*Get
    Programming with JavaScript*网站上找到：[http://www.room51.co.uk/js/math.html](http://www.room51.co.uk/js/math.html)。
- en: '[Listing 12.4](#ch12ex04) puts the `Math` methods into practice. The `guess`
    function now *returns* strings rather than logging them; the console automatically
    displays the return values, tidying up the interactions:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表12.4](#ch12ex04) 将`Math`方法应用于实践。`guess`函数现在*返回*字符串而不是记录它们；控制台自动显示返回值，整理了交互：'
- en: '[PRE67]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Listing 12.4\. Guess the random number ([http://jsbin.com/mezowa/edit?js,console](http://jsbin.com/mezowa/edit?js,console))
  id: totrans-347
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.4. 猜测随机数 ([http://jsbin.com/mezowa/edit?js,console](http://jsbin.com/mezowa/edit?js,console))
- en: '![](205fig01_alt.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![](205fig01_alt.jpg)'
- en: Using random numbers has made your guessing game more interesting. But there
    isn’t a great deal of strategy involved; it’s just straight guessing. The game
    could be improved by giving better feedback after each guess.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 使用随机数使你的猜测游戏更有趣。但其中并不涉及太多策略；这只是直接的猜测。游戏可以通过在每次猜测后提供更好的反馈来得到改进。
- en: 12.3\. Further conditions with else if
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3. 使用else if的进一步条件
- en: By receiving better feedback for each guess, users can develop more efficient
    strategies when battling your guessing game. And strategy games are always more
    fun than guessing games. If a user’s guess is incorrect, tell them if it’s too
    high or too low.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为每次猜测获得更好的反馈，用户可以在与你的猜测游戏对抗时发展出更有效的策略。策略游戏总是比猜测游戏更有趣。如果用户的猜测不正确，告诉他们是否过高或过低。
- en: '[PRE68]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[Figure 12.3](#ch12fig03) shows the conditions used to produce the three possible
    types of feedback for a user’s guess.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12.3](#ch12fig03) 展示了用于生成用户猜测的三种可能反馈类型的条件。'
- en: Figure 12.3\. Nesting conditions can provide multiple options.
  id: totrans-354
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.3. 嵌套条件可以提供多个选项。
- en: '![](12fig03_alt.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![](12fig03_alt.jpg)'
- en: The following listing shows how an extra `if` statement can be used to differentiate
    between the two types of incorrect answer.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了如何使用额外的`if`语句来区分两种类型的错误答案。
- en: Listing 12.5\. Higher or lower ([http://jsbin.com/cixeju/edit?js,console](http://jsbin.com/cixeju/edit?js,console))
  id: totrans-357
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.5. 高于或低于 ([http://jsbin.com/cixeju/edit?js,console](http://jsbin.com/cixeju/edit?js,console))
- en: '![](206fig01_alt.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![](206fig01_alt.jpg)'
- en: 'If a code block contains a single statement, JavaScript lets us leave out the
    curly braces; the following three statements are equivalent:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码块只包含一个语句，JavaScript允许我们省略大括号；以下三个语句是等价的：
- en: '[PRE69]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: As `if` and `else` clauses get more complicated and when code gets updated over
    time, if you leave out the curly braces it can sometimes be hard to spot which
    statements go with which clauses. Many programmers (including me) recommend that
    you always use curly braces for the code blocks (apart from the case of nested
    `if` statements, as shown shortly). Others aren’t so strict. Ultimately, it can
    come down to personal (or team) preferences. For now, I’d go with whatever you
    find easiest to understand.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 当`if`和`else`子句变得复杂，并且代码随时间更新时，如果你省略了大括号，有时很难找到哪些语句与哪些子句相对应。许多程序员（包括我）建议你始终为代码块使用大括号（除了嵌套`if`语句的情况，如稍后所示）。其他人则不那么严格。最终，这可以归结为个人（或团队）的偏好。现在，我会选择你最容易理解的方式。
- en: 'An `if` statement, even with an `else` clause, counts as one statement. When
    an `else` clause contains a single `if` statement, it’s common to leave out the
    curly braces. The following three code snippets are equivalent:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`if`语句，即使带有`else`子句，也只算作一个语句。当`else`子句只包含一个`if`语句时，通常省略大括号。以下三个代码片段是等价的：
- en: First, the code as shown in [listing 12.5](#ch12ex05). The nested `if-else`
    statement is inside a pair of curly braces.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如[列表12.5](#ch12ex05)中所示。嵌套的`if-else`语句位于一对大括号内。
- en: '[PRE70]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The inner `if-else` is a single statement, so it doesn’t need to be wrapped
    in curly braces.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 内层的`if-else`是一个单独的语句，因此不需要用大括号括起来。
- en: '[PRE71]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: And finally, because JavaScript mostly ignores spaces and tab characters, the
    inner `if-else` statement can be moved to follow on from the initial `else`.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于JavaScript主要忽略空格和制表符，内层的`if-else`语句可以移动到初始`else`之后。
- en: '[PRE72]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The last version is the format most commonly seen. The next listing shows the
    neater `else-if` block in context.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个版本是最常见的格式。下一个列表显示了上下文中的更整洁的`else-if`块。
- en: Listing 12.6\. A neater else-if block ([http://jsbin.com/cidoru/edit?js,console](http://jsbin.com/cidoru/edit?js,console))
  id: totrans-370
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.6. 一个更整洁的else-if块 ([http://jsbin.com/cidoru/edit?js,console](http://jsbin.com/cidoru/edit?js,console))
- en: '[PRE73]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The second `if` statement is shown in bold for comparison with [listing 12.5](#ch12ex05).
    You’ve removed the curly braces for the first `else` block and moved the second
    `if` next to the first `else`. [Listing 12.6](#ch12ex06) shows the most common
    way of writing `else-if` blocks. If you prefer the longer version in [listing
    12.5](#ch12ex05), feel free to stick with it; there are no *Block Judges* waiting
    to sentence you for syntax abuse. (*At this point the author is called away to
    deal with a ruckus—some very loud banging on the door to his apartment ... it’s
    The Law!*)
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`if`语句以粗体显示，以便与[列表12.5](#ch12ex05)进行比较。你移除了第一个`else`块的大括号，并将第二个`if`移动到第一个`else`旁边。[列表12.6](#ch12ex06)显示了编写`else-if`块最常见的方式。如果你更喜欢[列表12.5](#ch12ex05)中的较长的版本，请随意坚持使用它；没有*块法官*在等待对你进行语法滥用判决。（*在此处，作者被叫去处理一场骚乱——他公寓门上非常响亮的撞击声……是法律！*）
- en: All possible outcomes are catered for in the guessing game; the guess could
    be correct or too high or too low. If the guess is not correct and it’s not too
    high, then it must be too low.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 猜测游戏中考虑了所有可能的结果；猜测可能是正确的，也可能太高或太低。如果猜测不正确且不是太高，那么它一定是太低了。
- en: 12.3.1\. Comparison operators
  id: totrans-374
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.3.1. 比较运算符
- en: '[Listings 12.5](#ch12ex05) and [12.6](#ch12ex06) both make use of the *greater
    than operator*, `>`. It operates on two values and returns `true` or `false`.
    It’s one of a family of operators that compare two values. Some of the operators
    are shown in [table 12.1](#ch12table01).'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表12.5](#ch12ex05)和[12.6](#ch12ex06)都使用了*大于运算符* `>`。它作用于两个值并返回`true`或`false`。它是比较两个值的一组运算符之一。其中一些运算符在[表12.1](#ch12table01)中显示。'
- en: Table 12.1\. Comparison operators
  id: totrans-376
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表12.1. 比较运算符
- en: '| Operator | Name | Example | Evaluates to |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 名称 | 示例 | 评估结果 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| > | Greater than | 5 > 3 3 > 10 7 > 7 | true false false |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| > | 大于 | 5 > 3 3 > 10 7 > 7 | true false false |'
- en: '| >= | Greater than or equal to | 5 >= 3 3 >= 10 7 >= 7 | true false true |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| >= | 大于或等于 | 5 >= 3 3 >= 10 7 >= 7 | true false true |'
- en: '| < | Less than | 5 < 3 3 < 10 7 < 7 | false true false |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| < | 小于 | 5 < 3 3 < 10 7 < 7 | false true false |'
- en: '| <= | Less than or equal to | 5 <= 3 3 <= 10 7 <= 7 | false true true |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| <= | 小于或等于 | 5 <= 3 3 <= 10 7 <= 7 | false true true |'
- en: '| === | Strictly equal to | 5 === 3 7 === 7 7 === "7" | false true false |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| === | 严格等于 | 5 === 3 7 === 7 7 === "7" | false true false |'
- en: '| !== | Not strictly equal to | 5 !== 3 7 !== 7 7 !== "7" | true false true
    |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| !== | 不严格等于 | 5 !== 3 7 !== 7 7 !== "7" | true false true |'
- en: Because the operators in [table 12.1](#ch12table01) return `true` or `false`,
    they can be used in the condition for `if` statements. You may be wondering about
    the strict part of the strict equality operator—something we’ll be sticking to
    throughout the book—and whether there’s a non-strict version. Yes, there is. For
    non-strict equality you can use `==`. See the “[Loose equality and coercion](#ch12sb01)”
    sidebar.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 因为[表 12.1](#ch12table01)中的运算符返回`true`或`false`，它们可以用作`if`语句的条件。你可能想知道严格相等运算符的严格部分——我们将贯穿整本书——以及是否存在非严格版本。是的，存在。对于非严格相等，你可以使用`==`。参见“[宽松相等和强制转换](#ch12sb01)”侧边栏。
- en: '|  |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Loose equality and coercion**'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '**宽松相等和强制转换**'
- en: The *loose equality operator*, `==`, is allowed to *coerce* values into different
    types in order to compare them for equality.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '*宽松相等运算符* `==` 允许将值强制转换为不同类型以便进行比较。'
- en: '*Coercion* is the process of converting a value from one type to another, for
    example, from a string to a number.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '*强制转换*是将一个值从一种类型转换为另一种类型的过程，例如，从字符串转换为数字。'
- en: So, whereas the strict comparison `7 === "7"` evaluates to `false`, because
    one value is a number and the other is a string, the loose comparison `7 == "7"`
    evaluates to `true`, because the string is first coerced to a number and `7 ==
    7` is `true`.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然严格比较`7 === "7"`的结果是`false`，因为一个值是数字，另一个是字符串，但宽松比较`7 == "7"`的结果是`true`，因为字符串首先被转换为数字，`7
    == 7`是`true`。
- en: The rules for coercion are beyond the scope of this book (although ignore people
    who say they’re not worth learning), and we’ll stick to strict equality comparisons.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 强制转换的规则超出了本书的范围（尽管可以忽略那些说它们不值得学习的人），我们将坚持使用严格相等比较。
- en: '|  |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now, obviously, guessing numbers is great fun, but you can learn more from a
    fact-based quiz like the one you’ve considered a few times earlier in the book.
    Adding the ability to check your answers will help raise the quiz app above a
    mere trivial pursuit.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，显然，猜测数字是非常有趣的，但你可以从像书中几次提到的基于事实的测验中学到更多。添加检查答案的能力将有助于提升测验应用，使其不仅仅是一个简单的游戏。
- en: 12.4\. Checking answers in the quiz app
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4\. 在测验应用中检查答案
- en: 'Now that you can check conditions in an `if` statement, you’re finally able
    to keep a score for the number of questions a user gets right in the quiz program.
    A typical console interaction could be this:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以在`if`语句中检查条件了，你终于可以保留用户在测验程序中答对问题的数量了。一个典型的控制台交互可能是这样的：
- en: '[PRE74]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The code for the quiz program is shown in the next listing. The `getQuiz` function
    contains the implementation of the quiz and returns an interface object with only
    two methods, `quizMe` and `submit`. You take a good look at how the program works
    after the listing.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 测验程序代码在下一列表中展示。`getQuiz`函数包含了测验的实现，并返回一个只包含两个方法（`quizMe`和`submit`）的接口对象。在列表之后，你可以仔细看看程序是如何工作的。
- en: Listing 12.7\. Checking quiz answers ([http://jsbin.com/hidogo/edit?js,console](http://jsbin.com/hidogo/edit?js,console))
  id: totrans-398
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.7\. 检查测验答案 ([http://jsbin.com/hidogo/edit?js,console](http://jsbin.com/hidogo/edit?js,console))
- en: '![](ch12ex07-0.jpg)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![](ch12ex07-0.jpg)'
- en: '![](ch12ex07-1.jpg)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![](ch12ex07-1.jpg)'
- en: Your new quiz program has a number of moving parts; let’s break it down into
    smaller pieces.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 你新的测验程序有几个动态部分；让我们将其分解成更小的部分。
- en: 12.4.1\. Multiple declarations with a single var keyword
  id: totrans-402
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.1\. 使用单个`var`关键字进行多重声明
- en: 'Up until now you’ve been using a `var` keyword for each variable you’ve declared:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你一直在为每个声明的变量使用`var`关键字：
- en: '[PRE75]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'JavaScript allows you to declare a list of variables with a single `var` keyword.
    Commas separate the variables, with a semicolon ending the list. The previous
    declarations can be rewritten in the following shorter form:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 允许你使用单个`var`关键字声明一系列变量。变量之间用逗号分隔，列表以分号结束。之前的声明可以用以下更简短的形式重写：
- en: '[PRE76]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'You could even declare the variables on a single line:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以在一行中声明变量：
- en: '[PRE77]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Most programmers prefer one variable per line. You can include assignments
    too:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数程序员喜欢每行一个变量。你还可以包括赋值：
- en: '[PRE78]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The aim is to make sure all variables are declared and the code is easy to read
    and understand. The style in [listing 12.7](#ch12ex07) is what I tend to prefer;
    I find it slightly easier to read and it’s slightly less typing. Some programmers
    declare each variable on its own line with a `var` keyword, just as we’ve been
    doing in our listings up until now; it’s easier to cut and paste variables if
    each has its own `var` keyword. It’s not worth worrying about—you’ll probably
    settle on one style over time.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是确保所有变量都已声明，代码易于阅读和理解。在[列表 12.7](#ch12ex07)中的风格是我倾向于选择的；我发现它稍微容易阅读一些，而且输入的代码也稍微少一些。一些程序员使用`var`关键字在单独的一行上声明每个变量，就像我们到目前为止在列表中做的那样；如果每个变量都有自己的`var`关键字，那么剪切和粘贴变量会更容易。这并不值得担心——你可能会随着时间的推移而确定一种风格。
- en: 12.4.2\. Displaying a question
  id: totrans-412
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.2\. 显示问题
- en: The `getQuestion` function returns a question from the `questions` array. It
    uses the `qIndex` variable to pick the current question-and-answer object from
    the array. It returns the `question` property of the question-and-answer object.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '`getQuestion`函数从`questions`数组中返回一个问题。它使用`qIndex`变量从数组中选择当前的问题和答案对象。它返回问题和答案对象的`question`属性。'
- en: '[PRE79]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'But it returns the question only if the quiz is still in progress. Otherwise,
    it returns a string to say the quiz is finished:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 但只有当测验仍在进行时，它才会返回问题。否则，它返回一个字符串说明测验已完成：
- en: '[PRE80]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The program uses the `inPlay` variable to flag when the quiz is in progress
    and when it has finished. The `inPlay` variable has a value of `true` while the
    quiz is in progress and `false` when it has finished. The `getQuestion` function
    uses the `inPlay` variable as the condition in an `if` statement:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用`inPlay`变量来标记测验正在进行和已完成。当测验进行时，`inPlay`变量的值为`true`，当测验完成后为`false`。`getQuestion`函数使用`inPlay`变量作为`if`语句中的条件：
- en: '[PRE81]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: When `inPlay` is `true`, the question is returned. When `inPlay` is `false`,
    the message is returned. (Remember, when you call a function at the console prompt,
    the console automatically displays the return value.)
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 当`inPlay`为`true`时，返回问题。当`inPlay`为`false`时，返回消息。（记住，当你从控制台提示符调用函数时，控制台会自动显示返回值。）
- en: 12.4.3\. Moving to the next question
  id: totrans-420
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.3\. 转到下一个问题
- en: The program calls the `next` function to move from one question to the next.
    It moves by incrementing the `qIndex` variable.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 程序调用`next`函数从一个问题移动到下一个问题。它通过增加`qIndex`变量来实现移动。
- en: '[PRE82]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The program stores the index of the current element in the `questions` array
    in `qIndex`. Remember that the array index is zero based, so for an array of length
    4 the index could be 0, 1, 2, or 3\. An index of 4 would be past the end of the
    array (3 is the last index). In general, if the index is greater than or equal
    to the length of the array, you’re past the end of the array. All arrays have
    a `length` property. In the quiz, it represents the number of questions.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将`questions`数组中当前元素的索引存储在`qIndex`中。记住，数组索引是从零开始的，所以对于一个长度为4的数组，索引可以是0、1、2或3。索引4将超出数组的末尾（3是最后一个索引）。一般来说，如果索引大于或等于数组的长度，你就超出了数组的末尾。所有数组都有一个`length`属性。在测验中，它代表问题的数量。
- en: 'The `next` function checks the index to see if it is past the last question:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '`next`函数检查索引是否超出了最后一个问题：'
- en: '[PRE83]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: If the index is past the end of the array, then all the questions have been
    asked and the quiz is over, so `inPlay` is set to `false`.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 如果索引超出了数组的末尾，那么所有问题都已提出，测验结束，因此`inPlay`被设置为`false`。
- en: '[PRE84]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 12.4.4\. Checking the player’s answer
  id: totrans-428
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.4\. 检查玩家的答案
- en: The `checkAnswer` function is straightforward. If the player’s submitted answer
    is equal to the current answer from the questions array, the player’s score is
    incremented. Otherwise, the correct answer is displayed.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkAnswer`函数很简单。如果玩家提交的答案等于问题数组中的当前答案，则玩家的分数增加。否则，显示正确答案。'
- en: '[PRE85]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 12.4.5\. Handling a player’s answer
  id: totrans-431
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.5\. 处理玩家的答案
- en: The `submit` function orchestrates what happens when a player submits an answer.
    It returns either a message with the player’s score or a message to say the quiz
    is over.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '`submit`函数协调玩家提交答案时发生的事情。它返回一个包含玩家分数的消息或表示测验结束的消息。'
- en: '[PRE86]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: If the quiz is still in progress, `submit` calls two other functions, `checkAnswer`
    and `next`. Each will execute its code in turn. You’re using the functions to
    run code on demand.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测验仍在进行中，`submit`会调用两个其他函数，`checkAnswer`和`next`。每个函数将依次执行其代码。你正在使用函数按需运行代码。
- en: '[PRE87]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 12.4.6\. Returning the interface object
  id: totrans-436
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.6\. 返回界面对象
- en: You’ve kept the interface object returned by `getQuiz` simple. It has no implementation
    code of its own. You assign its two properties functions from within the local
    scope of `getQuiz`.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 你保持了`getQuiz`返回的接口对象简单。它没有自己的实现代码。你从`getQuiz`的局部作用域中分配其两个属性函数。
- en: '[PRE88]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: As discussed in [chapter 11](kindle_split_020.html#ch11), the interface object
    allows you to maintain a consistent interface over time, even if the implementation
    within `getQuiz` is changed. The user will always call `quiz.quizMe()` and `quiz.submit()`.
    You can change which functions are assigned to those two properties of the interface
    object and how those functions work, but you never remove or rename those properties.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 如第11章[第11章](kindle_split_020.html#ch11)中所述，接口对象允许你在时间上保持一致的接口，即使`getQuiz`内部的实现发生了变化。用户将始终调用`quiz.quizMe()`和`quiz.submit()`。你可以更改分配给接口对象这两个属性的函数以及这些函数的工作方式，但你永远不要删除或重命名这些属性。
- en: Notice how the program is made up of small pieces working together to build
    its functionality. As ever, your aim is to make the code readable, understandable,
    and easy to follow. The `if` statement and its `else` clause help you to direct
    the flow of the program to take the appropriate actions at each stage.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 注意程序是如何由许多小部分组成，共同构建其功能的。一如既往，你的目标是使代码可读、易懂且易于跟踪。`if`语句及其`else`子句帮助你指导程序的流程，在每个阶段采取适当的行动。
- en: It’s time to put these new ideas to work in *The Crypt*.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候将这些新想法应用到*The Crypt*上了。
- en: 12.5\. The Crypt—checking user input
  id: totrans-442
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.5\. The Crypt—检查用户输入
- en: 'In [chapter 11](kindle_split_020.html#ch11), you created a `getGame` function
    that returns a public interface for *The Crypt*. Players can call a `go` method
    to move from place to place and a `get` method to pick up items:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](kindle_split_020.html#ch11)中，你创建了一个`getGame`函数，它返回了*The Crypt*的公共接口。玩家可以调用`go`方法从一个地方移动到另一个地方，以及调用`get`方法来拾取物品：
- en: '[PRE89]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 12.5.1\. Step by step through the go method
  id: totrans-445
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.5.1\. 逐步分析`go`方法
- en: Let’s step through the first three lines of the `go` method. See if you can
    spot where a problem could arise.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分析`go`方法的前三行。看看你是否能发现可能出现问题的位置。
- en: Retrieve the player’s location
  id: totrans-447
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 获取玩家的位置
- en: You start with the `getPlace` method. It returns the player’s current location.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 你从`getPlace`方法开始。它返回玩家的当前位置。
- en: '[PRE90]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: You then assign the location to the `place` variable. If the player is currently
    in the kitchen, then the code is equivalent to
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你将位置分配给`place`变量。如果玩家目前位于厨房，那么代码等同于
- en: '[PRE91]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The program assigned the player’s starting location earlier, using the `setPlace`
    method:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 程序之前使用`setPlace`方法分配了玩家的起始位置：
- en: '[PRE92]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Use the direction to find the destination
  id: totrans-454
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用方向找到目的地
- en: Now that you have the current place, you can call its `getExit` method to retrieve
    the destination for a given direction.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了当前位置，你可以调用它的`getExit`方法来获取给定方向的目的地。
- en: '[PRE93]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: When the player calls the `go` method, the argument is assigned to the `direction`
    parameter.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家调用`go`方法时，参数被分配给`direction`参数。
- en: '[PRE94]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The previous command will execute code equivalent to the following:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将执行以下等效代码：
- en: '[PRE95]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: If The Library is south of The Kitchen, then the code is equivalent to
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 如果图书馆在厨房的南方，那么代码等同于
- en: '[PRE96]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Move the player to the destination
  id: totrans-463
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将玩家移动到目的地
- en: You have the destination; you only need to update the player’s location.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经有了目的地；你只需要更新玩家的位置。
- en: '[PRE97]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Fantastic! The user can decide where to go in the game. So, can you let them
    loose in your carefully crafted castles? Well, no. You see, users are evil. Pure
    evil!
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！用户可以决定在游戏中去哪里。那么，你能让他们在你的精心设计的城堡中自由行动吗？不，你看到，用户是邪恶的。纯粹的邪恶！
- en: 12.5.2\. Never trust user input
  id: totrans-467
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.5.2\. 永远不要相信用户输入
- en: Sorry, I panicked. Of course users aren’t evil. But they do make mistakes. And
    they sometimes own cats. And most cats can’t type. Whenever a user is expected
    to provide input for a program, we must guard against mistakes, whether typos
    (possibly of cat origin), misunderstandings (which may be our fault), or curiosity-driven
    explorations of what the program can do.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 抱歉，我慌了。当然，用户并不邪恶。但他们确实会犯错误。他们有时会养猫。而且大多数猫都不会打字。每当需要用户为程序提供输入时，我们必须防范错误，无论是打字错误（可能是猫引起的），还是误解（可能是我们的错），或者是出于对程序能做什么的好奇心而进行的探索。
- en: The `go` method expects the user to enter a valid direction as a string. It
    uses that direction to find a destination, the place to which the player is to
    be moved. If the user enters a direction that doesn’t exist, the whole game breaks!
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '`go` 方法期望用户输入一个有效的方向作为字符串。它使用该方向来查找目的地，即玩家将被移动的地方。如果用户输入一个不存在的方向，整个游戏就会崩溃！'
- en: '[PRE98]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[Figure 12.4](#ch12fig04) shows what happened on JS Bin when I entered the
    previous command while playing the [chapter 11](kindle_split_020.html#ch11) version
    of *The Crypt* at [http://jsbin.com/yuporu/edit?js,console](http://jsbin.com/yuporu/edit?js,console).'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12.4](#ch12fig04) 展示了在播放 *The Crypt* 的 [第11章](kindle_split_020.html#ch11)
    版本时，我在 JS Bin 中输入上一条命令所发生的情况。[http://jsbin.com/yuporu/edit?js,console](http://jsbin.com/yuporu/edit?js,console)'
- en: Figure 12.4\. Specifying a direction that doesn’t exist breaks *The Crypt*.
  id: totrans-472
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.4\. 指定一个不存在的方向会导致 *The Crypt* 游戏崩溃。
- en: '![](12fig04_alt.jpg)'
  id: totrans-473
  prefs: []
  type: TYPE_IMG
  zh: '![](12fig04_alt.jpg)'
- en: 'Error messages on your browser might be slightly different. Even entering a
    valid direction after the mistake doesn’t fix things. From the errors in [figure
    12.4](#ch12fig04) it looks like there may be a problem with the `place` variable.
    The key statement in the `go` method is the one that uses the user input:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器上的错误消息可能略有不同。即使在错误之后输入一个有效的方向也无法解决问题。从 [图12.4](#ch12fig04) 中的错误来看，似乎 `place`
    变量存在问题。`go` 方法中的关键语句是使用用户输入的那个：
- en: '[PRE99]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'If the specified direction is not one of the place’s exits, then the `getExit`
    function will return `undefined`. The program assigns `undefined` to the `destination`
    variable and sets that value as the new place for the player:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定的方向不是地点的出口之一，那么 `getExit` 函数将返回 `undefined`。程序将 `undefined` 赋值给 `destination`
    变量，并将该值设置为玩家的新位置：
- en: '[PRE100]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: So the player’s location is now `undefined`, not a place constructed with the
    `Place` constructor. `undefined` has no `showInfo` or `getExit` methods; it has
    no methods at all! The errors in [figure 12.4](#ch12fig04) should now make more
    sense.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，玩家的位置现在是 `undefined`，而不是使用 `Place` 构造函数构建的地方。`undefined` 没有提供 `showInfo`
    或 `getExit` 方法；它没有任何方法！[图12.4](#ch12fig04) 中的错误现在应该更容易理解。
- en: So how can you guard against users (and their cats) making errors?
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如何防止用户（以及他们的猫）犯错误呢？
- en: 12.5.3\. Safe exploration—using the if statement to avoid problems
  id: totrans-480
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.5.3\. 安全探索——使用 `if` 语句避免问题
- en: 'You can use an `if` statement to check that you have a valid destination before
    updating the player’s location:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `if` 语句在更新玩家位置之前检查是否有有效的目的地：
- en: '[PRE101]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The `getExit` method returns `undefined` if the current place doesn’t have an
    exit for the specified direction. You just need to check that the destination
    is not `undefined` before calling `setPlace`.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前地点没有指定方向的出口，`getExit` 方法将返回 `undefined`。你只需要在调用 `setPlace` 之前检查目的地是否不是 `undefined`。
- en: '[PRE102]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Remember from [table 12.1](#ch12table01) that the `!==` operator returns `true`
    when two values are *not* equal and `false` when they *are* equal. You can add
    an `else` clause to catch the cases where the destination *is* `undefined`.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 记住从 [表12.1](#ch12table01) 中，`!==` 操作符在两个值不相等时返回 `true`，在它们相等时返回 `false`。你可以添加一个
    `else` 子句来捕获目的地是 `undefined` 的情况。
- en: '[PRE103]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[Listing 12.8](#ch12ex08) shows an updated version of the `go` and `get` methods
    returned from the `getGame` function. Entering a nonexistent direction at the
    console now looks like this:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表12.8](#ch12ex08) 展示了从 `getGame` 函数返回的 `go` 和 `get` 方法的更新版本。在控制台中输入一个不存在的方向现在看起来是这样的：'
- en: '[PRE104]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Calling `get` when there are no items to pick up looks like this:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有物品可以拾取时调用 `get` 的样子如下：
- en: '[PRE105]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Only partial code is shown in this listing. The full listing with `Player` and
    `Place` constructors and more places is on JS Bin.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表中只显示了部分代码。包含 `Player` 和 `Place` 构造函数以及更多地点的完整列表在 JS Bin 上。
- en: Listing 12.8\. Checking user input ([http://jsbin.com/zoruxu/edit?js,console](http://jsbin.com/zoruxu/edit?js,console))
  id: totrans-492
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.8\. 检查用户输入 ([http://jsbin.com/zoruxu/edit?js,console](http://jsbin.com/zoruxu/edit?js,console))
- en: '![](ch12ex08-0.jpg)'
  id: totrans-493
  prefs: []
  type: TYPE_IMG
  zh: '![](ch12ex08-0.jpg)'
- en: '![](ch12ex08-1.jpg)'
  id: totrans-494
  prefs: []
  type: TYPE_IMG
  zh: '![](ch12ex08-1.jpg)'
- en: In the printed [listing 12.8](#ch12ex08), the details of the `Player` and `Place`
    constructors were left out to make it easier to focus on the changes to the `go`
    and `get` methods. In [chapter 13](kindle_split_022.html#ch13) you’ll move each
    constructor function to its own file and see how to import the files in JS Bin.
    Such increased modularity can help you focus on one thing at a time and make it
    easier to reuse code across multiple projects.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 在打印的[列表12.8](#ch12ex08)中，省略了`Player`和`Place`构造函数的细节，以便更容易关注对`go`和`get`方法的变化。在第13章[kindle_split_022.html#ch13]中，你将每个构造函数移动到自己的文件中，并了解如何在JS
    Bin中导入文件。这种增加的模块化可以帮助你一次关注一件事，并使在多个项目中重用代码更容易。
- en: 12.6\. Summary
  id: totrans-496
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.6. 摘要
- en: 'Use comparison operators to compare two values. The operators return `true`
    or `false`, boolean values:'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用比较运算符比较两个值。运算符返回`true`或`false`，布尔值：
- en: '[PRE106]'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Use an `if` statement to execute code only if a condition is met:'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`if`语句仅在满足条件时执行代码：
- en: '[PRE107]'
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Set conditions using comparison operators and/or variables:'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用比较运算符和/或变量设置条件：
- en: '[PRE108]'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Add an `else` clause to execute code when a condition is not met:'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当条件不满足时，添加`else`子句以执行代码：
- en: '[PRE109]'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Include extra `if` statements in the `else` clause to cover all possibilities:'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`else`子句中包含额外的`if`语句以覆盖所有可能性：
- en: '[PRE110]'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Generate random numbers with `Math.random()`. The numbers generated are between
    0 and 1\. They can equal 0 but not 1:'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Math.random()`生成随机数。生成的数字介于0和1之间。它们可以等于0但不能等于1：
- en: '[PRE111]'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Scale up the random numbers to the range you want:'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将随机数扩展到你想要的范围：
- en: '[PRE112]'
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Round the random numbers to integers with `Math.floor()`:'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Math.floor()`将随机数四舍五入为整数：
- en: '[PRE113]'
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Never trust user input. Put checks in place to make sure any input is valid.
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不要相信用户输入。放置检查以确保任何输入都是有效的。
- en: 'Chapter 13\. Modules: breaking a program into pieces'
  id: totrans-514
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第13章。模块：将程序分解成片段
- en: '***This chapter covers***'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '***本章涵盖***'
- en: Importing code into JS Bin with script elements
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用脚本元素将代码导入JS Bin
- en: Avoiding repeated variable names
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免重复的变量名
- en: Running functions without assigning them to variables
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不将函数分配给变量而运行它们
- en: Using modules to organize your (shared) codebase
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模块来组织你的（共享）代码库
- en: As the applications you develop become larger, involving more and more variables,
    objects, arrays, and functions, it can become harder and harder to work efficiently
    within a single program file. Good text editors and development environments can
    help, but even with their tools, it quickly becomes a good idea to split the code
    across multiple files.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你开发的应用程序变得更大，涉及越来越多的变量、对象、数组和函数，在单个程序文件中高效工作可能会变得越来越困难。好的文本编辑器和开发环境可以帮助，但即使有了它们的工具，很快就会变成一个很好的主意，将代码分散到多个文件中。
- en: For example, in *The Crypt* you have `spacer`, players, places, maps, and the
    game logic itself. You’ve probably noticed how long the code listings have become
    on JS Bin when all of the elements are included. Putting the code for each element
    in its own file can help you to focus on one piece of the program at a time and
    make it easier for different programmers to develop and test different parts of
    applications. [Figure 13.1](#ch13fig01) shows your aim of splitting one large
    program into modules.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在*The Crypt*中，你有`spacer`、玩家、地点、地图以及游戏逻辑本身。你可能已经注意到，当所有元素都包含在内时，JS Bin上的代码列表变得有多长。将每个元素的代码放在自己的文件中可以帮助你一次专注于程序的一个部分，并使不同程序员开发和应用测试应用程序的不同部分更容易。[图13.1](#ch13fig01)显示了将一个大型程序分解为模块的目标。
- en: Figure 13.1\. Breaking one large program into modules
  id: totrans-522
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.1. 将一个大型程序分解为模块
- en: '![](13fig01_alt.jpg)'
  id: totrans-523
  prefs: []
  type: TYPE_IMG
  zh: '![图片](13fig01_alt.jpg)'
- en: Having discrete pieces of functionality and data in different files also promotes
    code reuse. Rather than cutting and pasting useful functions and snippets of JavaScript
    from one project into others, they can stay in a single library file that’s imported
    into other projects when needed. For example, our trusty `spacer` namespace from
    [chapter 7](kindle_split_015.html#ch07), for formatting text on the console, could
    be used in a quiz app and a blog app. Rather than repeating the `spacer` code
    in each app, you could place it in its own file and import it when needed ([figure
    13.2](#ch13fig02)).
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的文件中拥有离散的功能和数据也促进了代码的重用。与其从一项项目中将有用的函数和JavaScript片段剪切粘贴到其他项目中，不如将它们保留在单个库文件中，当需要时将其导入到其他项目中。例如，我们可靠的`spacer`命名空间来自第7章[章节7](kindle_split_015.html#ch07)，用于在控制台上格式化文本，可以在问答应用和博客应用中使用。与其在每个应用中重复`spacer`代码，不如将其放在自己的文件中，并在需要时导入它([图13.2](#ch13fig02))。
- en: Figure 13.2\. Moving `spacer` into a module allows the same single file to be
    used in many projects.
  id: totrans-525
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.2. 将`spacer`移动到模块中允许相同的单个文件在许多项目中使用。
- en: '![](13fig02_alt.jpg)'
  id: totrans-526
  prefs: []
  type: TYPE_IMG
  zh: '![13fig02_alt.jpg](13fig02_alt.jpg)'
- en: I’m going to loosely call such files *modules*. There are a number of published
    JavaScript projects and standards for managing modules that will have their own,
    stricter definitions for what form a module must take, and the latest versions
    of JavaScript itself are introducing a native module system, but I’m happy to
    keep things simple for now.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 我将松散地称这样的文件为*模块*。有许多已发布的JavaScript项目和模块管理标准，它们将为自己定义模块必须采取的形式，而JavaScript的最新版本也在引入原生的模块系统，但我现在很高兴保持简单。
- en: This chapter looks at how to import modules into JS Bin using HTML `script`
    elements. You’ll see how a random number generator function and the text-formatting
    capabilities of the `spacer` namespace can be incorporated into other projects.
    When you start to include code from various modules into a single program, you
    have to keep a close eye on which variable names are being used; there’s a danger
    that imported files could overwrite your variables. You also take a look at how
    to minimize such problems by using namespaces and by making use of immediately
    invoked function expressions, a way of running function code without assigning
    the functions to variables.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨如何使用HTML `script`元素将模块导入JS Bin。你将看到随机数生成函数和`spacer`命名空间的文本格式化功能如何被纳入其他项目中。当你开始将来自不同模块的代码包含到一个程序中时，你必须密切关注正在使用的变量名；有可能会覆盖你的变量。你还将了解如何通过使用命名空间和利用立即执行函数表达式来最小化这些问题，这是一种运行函数代码而不将其分配给变量的方法。
- en: First up, let’s look at how JS Bin works with files.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看JS Bin是如何与文件一起工作的。
- en: 13.1\. Understanding bins and files on JS Bin
  id: totrans-530
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1. 理解JS Bin上的bins和文件
- en: 'In [chapter 12](kindle_split_021.html#ch12) you created a simple game that
    challenged players to guess a number between 1 and 10\. You generated the number
    using the `Math.random` method. In a similar way, you now want to update your
    quiz app to display a random question from its bank of questions. Both the guessing
    game and the quiz need to be able to generate a random whole number between two
    limits. They can both use a function like the following:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](kindle_split_021.html#ch12)中，你创建了一个简单的游戏，挑战玩家猜测一个介于1到10之间的数字。你使用`Math.random`方法生成这个数字。现在，你希望更新你的测验应用，以显示其问题库中的随机问题。猜数字游戏和测验都需要能够生成两个限制之间的随机整数。它们都可以使用以下类似的功能：
- en: '[PRE114]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: In this section, you create and save a JavaScript file on JS Bin that contains
    the Number Generator code. In [section 13.2](#ch13lev1sec2) you learn how to load
    the file, and in [section 13.3](#ch13lev1sec3) you load it into the guessing game
    and the quiz app, as illustrated in [figure 13.3](#ch13fig03).
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将在JS Bin上创建并保存一个包含数字生成器代码的JavaScript文件。在[第13.2节](#ch13lev1sec2)中，你将学习如何加载该文件，在[第13.3节](#ch13lev1sec3)中，你将如何将其加载到猜数字游戏和测验应用中，如图13.3所示。
- en: Figure 13.3\. The Number Generator code is imported by the quiz app and the
    guessing game.
  id: totrans-534
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.3. 测验应用和猜数字游戏导入了数字生成器代码。
- en: '![](13fig03_alt.jpg)'
  id: totrans-535
  prefs: []
  type: TYPE_IMG
  zh: '![13fig03_alt.jpg](13fig03_alt.jpg)'
- en: Before you learn how to import files, we need to take a brief look at how JS
    Bin saves your work.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 在你学习如何导入文件之前，我们需要简要地看看JS Bin是如何保存你的工作的。
- en: JS Bin is a simple development environment that lets you work on HTML, CSS,
    and JavaScript code in separate panels. [Figure 13.4](#ch13fig04) shows those
    three panels open at the same time, all containing code.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: JS Bin是一个简单的开发环境，它允许你在单独的面板中工作HTML、CSS和JavaScript代码。[图13.4](#ch13fig04)显示了这三个面板同时打开，都包含代码。
- en: Figure 13.4\. HTML, CSS, and JavaScript panels on JS Bin
  id: totrans-538
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.4. JS Bin上的HTML、CSS和JavaScript面板
- en: '![](13fig04_alt.jpg)'
  id: totrans-539
  prefs: []
  type: TYPE_IMG
  zh: '![13fig04_alt.jpg](13fig04_alt.jpg)'
- en: JS Bin combines the code in the HTML, CSS, and JavaScript panels to produce
    your web page, which it shows in the Output panel ([figure 13.5](#ch13fig05)).
    You’ll look at HTML (and a little CSS) in more detail in [part 3](kindle_split_026.html#part03).
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: JS Bin将HTML、CSS和JavaScript面板中的代码组合起来，生成你的网页，并在输出面板中显示（[图13.5](#ch13fig05)）。你将在第3部分（kindle_split_026.html#part03）中更详细地了解HTML（以及一点CSS）。
- en: Figure 13.5\. The HTML, CSS, and JavaScript code are all used to produce the
    web page output.
  id: totrans-541
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.5. HTML、CSS和JavaScript代码都被用来生成网页输出。
- en: '![](13fig05_alt.jpg)'
  id: totrans-542
  prefs: []
  type: TYPE_IMG
  zh: '![13fig05_alt.jpg](13fig05_alt.jpg)'
- en: Any errors or warnings that occur when you run your code appear in the Console
    panel. You can also log messages to the Console panel from within your JavaScript
    code—that’s how you’ve been displaying your output so far. You’re focusing on
    JavaScript, so you haven’t been bothered about the web page generated in the Output
    panel. You can see the page from [figures 13.4](#ch13fig04) and [13.5](#ch13fig05)
    on JS Bin at [http://jsbin.com/jejunu/edit?output](http://jsbin.com/jejunu/edit?output).
    Toggle the panels to see the code.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行代码时出现的任何错误或警告都会显示在控制台面板中。您也可以从 JavaScript 代码中向控制台面板记录消息——这就是您迄今为止显示输出的方式。您专注于
    JavaScript，所以您没有关心输出面板中生成的网页。您可以从 [图 13.4](#ch13fig04) 和 [图 13.5](#ch13fig05)
    在 JS Bin 的 [http://jsbin.com/jejunu/edit?output](http://jsbin.com/jejunu/edit?output)
    上看到页面。切换面板以查看代码。
- en: 'As well as providing a combined environment for you to edit the different types
    of code that make up a web page, JS Bin gives you access to the HTML, the CSS,
    and the JavaScript code as separate files. To create JavaScript code and see it
    as a separate file, follow these steps on JS Bin:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供一个综合环境供您编辑构成网页的不同类型的代码外，JS Bin 还允许您以单独的文件形式访问 HTML、CSS 和 JavaScript 代码。要在
    JS Bin 中创建 JavaScript 代码并查看它作为单独的文件，请按照以下步骤操作：
- en: '**1**.  Create a bin'
  id: totrans-545
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  创建一个 bin'
- en: '**2**.  Write some code in the JavaScript panel'
  id: totrans-546
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  在 JavaScript 面板中编写一些代码'
- en: '**3**.  Make a note of the filename'
  id: totrans-547
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**.  记录文件名'
- en: '**4**.  View an individual code file'
  id: totrans-548
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**.  查看单个代码文件'
- en: 13.1.1\. Creating a bin
  id: totrans-549
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.1\. 创建一个 bin
- en: On the File menu on JS Bin, click New. JS Bin will create HTML, CSS, and JavaScript
    files for you. It calls those three files together a *bin* and displays the contents
    of each file on its matching panel. The HTML file includes some boilerplate code
    that’s common to most new web pages; the CSS and JavaScript files are blank.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JS Bin 的文件菜单上点击新建。JS Bin 会为你创建 HTML、CSS 和 JavaScript 文件。它将这些三个文件统称为 *bin*，并在对应的面板上显示每个文件的内容。HTML
    文件包含一些常见的模板代码，适用于大多数新网页；CSS 和 JavaScript 文件为空。
- en: 13.1.2\. Writing some code
  id: totrans-551
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.2\. 编写一些代码
- en: Add the following code to the JavaScript panel.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到 JavaScript 面板中。
- en: '[PRE115]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The `between` function returns a random whole number between the values of `lowest`
    and `highest` inclusive. For example, `between(3, 5)` will return `3` or `4` or
    `5`.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '`between` 函数返回 `lowest` 和 `highest` 之间的一个随机整数（包括这两个值）。例如，`between(3, 5)` 将返回
    `3`、`4` 或 `5`。'
- en: 13.1.3\. Making a note of the filename
  id: totrans-555
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.3\. 记录文件名
- en: JS Bin assigns each bin a code used to edit the bin’s files and to access them
    individually. Take a look at the current URL in your browser’s address bar. (You
    may have to click the address bar to see the full address.) [Figure 13.6](#ch13fig06)
    shows the URL with the bin code and visible panels highlighted.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: JS Bin 为每个 bin 分配一个用于编辑 bin 文件和单独访问它们的代码。查看浏览器地址栏中的当前 URL。（您可能需要点击地址栏才能看到完整的地址。）[图
    13.6](#ch13fig06) 展示了带有 bin 代码和可见面板的高亮 URL。
- en: Figure 13.6\. Breaking down a JS Bin URL
  id: totrans-557
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.6\. 分解 JS Bin URL
- en: '![](13fig06.jpg)'
  id: totrans-558
  prefs: []
  type: TYPE_IMG
  zh: '![](13fig06.jpg)'
- en: Make a note of the bin code for your current work on JS Bin—it will be different
    from [figure 13.6](#ch13fig06). The bin code for my work is `qezoce`.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 记录您在 JS Bin 上当前工作的 bin 代码——它将不同于 [图 13.6](#ch13fig06)。我的工作 bin 代码是 `qezoce`。
- en: 13.1.4\. Viewing an individual code file
  id: totrans-560
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.4\. 查看单个代码文件
- en: To access individual code files, you use a different format of URL, shown in
    [figure 13.7](#ch13fig07). It has a prefix of `output` and ends with the bin code
    and a file extension. The file extension specifies what type of file you want
    to load. Use `js` for JavaScript.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问单个代码文件，您使用不同的 URL 格式，如图 [图 13.7](#ch13fig07) 所示。它以 `output` 为前缀，以 bin 代码和文件扩展名结尾。文件扩展名指定了您想要加载的文件类型。使用
    `js` 用于 JavaScript。
- en: Figure 13.7\. The JS Bin URL for a JavaScript file
  id: totrans-562
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.7\. JavaScript 文件的 JS Bin URL
- en: '![](13fig07.jpg)'
  id: totrans-563
  prefs: []
  type: TYPE_IMG
  zh: '![](13fig07.jpg)'
- en: Visiting [http://output.jsbin.com/qezoce.js](http://output.jsbin.com/qezoce.js)
    loads just the JavaScript file, as shown in [figure 13.8](#ch13fig08). All the
    panels and menus and controls that are part of the JS Bin editing environment
    are not loaded; it’s just the plain text of the JavaScript file.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [http://output.jsbin.com/qezoce.js](http://output.jsbin.com/qezoce.js) 只会加载
    JavaScript 文件，如图 [图 13.8](#ch13fig08) 所示。JS Bin 编辑环境中的所有面板、菜单和控制都不会加载；它只是 JavaScript
    文件的纯文本。
- en: Figure 13.8\. A JavaScript file on JS Bin
  id: totrans-565
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.8\. JS Bin 上的 JavaScript 文件
- en: '![](13fig08_alt.jpg)'
  id: totrans-566
  prefs: []
  type: TYPE_IMG
  zh: '![](13fig08_alt.jpg)'
- en: (The output isn’t always formatted nicely for human readers; unnecessary spaces
    and line-breaks may have been removed.) Have a go at loading your version of the
    file, using your bin code from JS Bin.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: （输出并不总是格式化得很好，以便人类阅读；可能已经删除了不必要的空格和换行符。）尝试使用你的JS Bin中的bin代码加载你的文件版本。
- en: Great! You can get your hands on your pure JavaScript. But how do you make it
    appear in another program?
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！你可以接触到你的纯JavaScript。但是，你如何让它出现在另一个程序中？
- en: 13.2\. Importing files into other projects
  id: totrans-569
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2. 导入文件到其他项目中
- en: 'You’re going to create a program that uses the number generation function,
    `between`, from the last section. You take these steps:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 你将创建一个程序，使用上一节中的数字生成函数`between`。你需要采取以下步骤：
- en: '**1**.  Create a bin'
  id: totrans-571
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 创建一个bin'
- en: '**2**.  Write some code in the JavaScript panel'
  id: totrans-572
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 在JavaScript面板中编写一些代码'
- en: '**3**.  Add a `script` element to the HTML panel'
  id: totrans-573
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 在HTML面板中添加一个`script`元素'
- en: '**4**.  Refresh the page'
  id: totrans-574
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**. 刷新页面'
- en: '**5**.  Run the program'
  id: totrans-575
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**. 运行程序'
- en: 13.2.1\. Creating a bin
  id: totrans-576
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.1. 创建一个bin
- en: Create a bin on JS Bin by clicking New on the File menu. The HTML, CSS, and
    Java-Script panels are reset.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击文件菜单上的“新建”来在JS Bin上创建一个bin。HTML、CSS和JavaScript面板将被重置。
- en: 13.2.2\. Writing some code
  id: totrans-578
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.2. 编写一些代码
- en: 'Enter the following code in the JavaScript panel:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript面板中输入以下代码：
- en: '[PRE116]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Running the program now will cause an error—there’s no `between` variable declared
    or function defined. The `between` function is in a separate file. This brings
    up the issue of *dependencies*; when splitting code into modules, it’s not uncommon
    for one module to depend on another in order to function. The previous code depends
    on the Number Generator module. More advanced module systems usually let you explicitly
    record and automatically load dependencies; for now, you can add comments to show
    any required modules.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行程序将导致错误——没有声明`between`变量或定义函数。`between`函数在单独的文件中。这提出了*依赖性*的问题；当将代码拆分成模块时，一个模块依赖于另一个模块以正常工作并不罕见。前面的代码依赖于数字生成器模块。更高级的模块系统通常允许你明确记录并自动加载依赖项；目前，你可以添加注释来显示任何所需的模块。
- en: 13.2.3\. Adding a script element
  id: totrans-582
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.3. 添加一个`script`元素
- en: It’s time to make use of the HTML panel on JS Bin. HTML is the code used for
    the structure and content of web pages; it’s how you specify headings and paragraphs
    and lists and links and so on. You’ll get a proper introduction in [chapter 17](kindle_split_027.html#ch17)
    and make good use of it throughout [part 3](kindle_split_026.html#part03). For
    now, your focus is still very much on the JavaScript and using JS Bin to help
    you learn and explore. You’re going to use only a tiny snippet of HTML to help
    you break up longer programs into separate files and load them as needed.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候利用JS Bin上的HTML面板了。HTML是用于网页结构和内容的代码；它是如何指定标题、段落、列表和链接等的。你将在第17章中得到适当的介绍，并在第3部分（kindle_split_026.html#part03）中充分利用它。现在，你的重点仍然非常集中在JavaScript上，并使用JS
    Bin来帮助你学习和探索。你将只使用一小段HTML来帮助你将较长的程序拆分成单独的文件，并在需要时加载它们。
- en: You use an HTML `script` element to specify the JavaScript file you want to
    load. [Figure 13.9](#ch13fig09) shows the parts that make up the element.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用HTML的`script`元素来指定你想要加载的JavaScript文件。[图13.9](#ch13fig09)显示了组成该元素的各个部分。
- en: Figure 13.9\. The parts that make up a `script` element
  id: totrans-585
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.9. 组成`script`元素的各个部分
- en: '![](13fig09_alt.jpg)'
  id: totrans-586
  prefs: []
  type: TYPE_IMG
  zh: '![](13fig09_alt.jpg)'
- en: Don’t worry too much for now about the names of all of the parts. You can use
    the `script` element to load files without a full understanding of HTML elements,
    tags, and attributes. You’ll focus on those in [chapter 17](kindle_split_027.html#ch17).
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 目前不必太担心所有部分的名称。你可以使用`script`元素来加载文件，而不需要完全理解HTML元素、标签和属性。你将在第17章中专注于这些内容。
- en: Show the HTML panel on JS Bin. You’ll see some default HTML already in place.
    You don’t need that for your purposes—you’re not building a web page; you’re just
    interested in loading a JavaScript file. Replace the default HTML with code to
    load the JavaScript, using the bin code of the file you created in the last section.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 在JS Bin上显示HTML面板。你会看到一些默认的HTML已经就位。对于你的目的来说，你不需要这些——你并不是在构建一个网页；你只是对加载一个JavaScript文件感兴趣。用你上一节创建的文件的bin代码替换默认的HTML，以加载JavaScript。
- en: '[PRE117]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The HTML included is a single `script` element with an `src` attribute. You
    use the `script` element to load the JavaScript file specified by the `src` attribute.
    (`src` is short for *source*—the address of the file.) In general, to load a file,
    use the following format:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 包含的 HTML 是一个带有 `src` 属性的单个 `script` 元素。您使用 `script` 元素来加载由 `src` 属性指定的 JavaScript
    文件。（`src` 是 *source* 的缩写——文件的地址。）通常，要加载文件，请使用以下格式：
- en: '[PRE118]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Modern browsers will assume the file contains JavaScript. For older browsers,
    you can include a `type` attribute as well.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器会假设文件包含 JavaScript。对于旧浏览器，您还可以包含一个 `type` 属性。
- en: '[PRE119]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 13.2.4\. Refreshing the page
  id: totrans-594
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.4\. 刷新页面
- en: JS Bin doesn’t always load files automatically; you may need to refresh the
    page in your browser after you add the `script` element.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: JS Bin 并非总是自动加载文件；您可能需要在浏览器中刷新页面，在添加 `script` 元素后。
- en: 13.2.5\. Running the program
  id: totrans-596
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.5\. 运行程序
- en: Click Run. The Console panel should show a number between 3 and 7\. Keep clicking
    Run to generate more random numbers.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 点击运行。控制台面板应显示一个介于 3 和 7 之间的数字。继续点击运行以生成更多随机数字。
- en: '[Listings 13.1](#ch13ex01) and [13.2](#ch13ex02) repeat the HTML and JavaScript
    you’ve used. The JS Bin links for the two listings lead to the same bin. Running
    the program five times produces output something like this (it *is* random!):'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 13.1](#ch13ex01) 和 [13.2](#ch13ex02) 重复了您使用的 HTML 和 JavaScript。这两个列表的 JS
    Bin 链接都指向同一个 bin。运行程序五次会产生类似以下输出（它是随机的！）：'
- en: '[PRE120]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Listing 13.1\. Loading JavaScript with a script tag (HTML) ([http://jsbin.com/lifugam/edit?html,js,console](http://jsbin.com/lifugam/edit?html,js,console))
  id: totrans-600
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.1\. 使用 script 标签加载 JavaScript（HTML）([http://jsbin.com/lifugam/edit?html,js,console](http://jsbin.com/lifugam/edit?html,js,console)）
- en: '[PRE121]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Listing 13.2\. Code in the JavaScript panel as well ([http://jsbin.com/lifugam/edit?html,js,console](http://jsbin.com/lifugam/edit?html,js,console))
  id: totrans-602
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.2\. 在 JavaScript 面板中的代码（[http://jsbin.com/lifugam/edit?html,js,console](http://jsbin.com/lifugam/edit?html,js,console)）
- en: '[PRE122]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'When you run the program, JS Bin will first load and run the file specified
    in the `script` element’s `src` attribute. Then it will run any code in the JavaScript
    panel. The loaded file and JavaScript panel code together form the following single
    program:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行程序时，JS Bin 将首先加载并运行 `script` 元素的 `src` 属性中指定的文件。然后它将运行 JavaScript 面板中的任何代码。加载的文件和
    JavaScript 面板代码一起形成以下单个程序：
- en: '[PRE123]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: When you click the Run button in the Console panel, it can take a moment for
    JS Bin to load the file specified in the `script` tag. Once the code runs, the
    random number is logged to the console.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在控制台面板中点击运行按钮时，JS Bin 可能需要一段时间来加载 `script` 标签中指定的文件。一旦代码运行，随机数就会被记录到控制台。
- en: 13.3\. Importing the Number Generator—further examples
  id: totrans-607
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3\. 导入数字生成器——更多示例
- en: You’ve seen how JS Bin assigns a code to each bin you create and how you can
    use that code to access individual files from your project. You created a random
    number generator function, `between`, and accessed the JavaScript file containing
    the code. One of the goals of splitting your work into modules is to use the same
    code in multiple projects by importing it rather than copying and pasting it;
    see [figure 13.10](#ch13fig10).
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了 JS Bin 如何为每个创建的 bin 分配一个代码，以及您如何使用该代码来访问项目中的单个文件。您创建了一个随机数生成器函数 `between`，并访问了包含代码的
    JavaScript 文件。将工作拆分成模块的一个目标是通过导入而不是复制粘贴来在多个项目中使用相同的代码；请参阅[图 13.10](#ch13fig10)。
- en: Figure 13.10\. Importing the Number Generator function into two projects
  id: totrans-609
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.10\. 将数字生成器函数导入两个项目
- en: '![](13fig10_alt.jpg)'
  id: totrans-610
  prefs: []
  type: TYPE_IMG
  zh: '![图片 13fig10_alt.jpg](13fig10_alt.jpg)'
- en: 'Let’s see that idea in action by importing the Number Generator into two other
    projects: the quiz app and the guessing game.'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过将数字生成器导入到其他两个项目中来验证这个想法：测验应用和猜谜游戏。
- en: 13.3.1\. Picking random questions in the quiz app
  id: totrans-612
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.3.1\. 在测验应用中挑选随机问题
- en: 'It’s time to randomize your quiz app. The new version of the app displays a
    random question from its question bank each time you call `quizMe` on the console:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候随机化您的测验应用了。应用的新版本每次在控制台调用 `quizMe` 时都会从其题库中显示一个随机问题：
- en: '[PRE124]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[Listing 13.4](#ch13ex04) shows the JavaScript for the main quiz app. You import
    the code for the `between` function by using a `script` element on the HTML panel
    ([listing 13.3](#ch13ex03)).'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 13.4](#ch13ex04) 展示了主测验应用的 JavaScript 代码。您可以通过 HTML 面板上的 `script` 元素导入
    `between` 函数的代码（[列表 13.3](#ch13ex03)）。'
- en: Listing 13.3\. Using the Number Generator with the quiz app (HTML) ([http://jsbin.com/ponogi/edit?html,js,console](http://jsbin.com/ponogi/edit?html,js,console))
  id: totrans-616
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.3\. 在测验应用中使用数字生成器（HTML）([http://jsbin.com/ponogi/edit?html,js,console](http://jsbin.com/ponogi/edit?html,js,console)）
- en: '[PRE125]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Listing 13.4\. Using the Number Generator with the quiz app ([http://jsbin.com/ponogi/edit?html,js,console](http://jsbin.com/ponogi/edit?html,js,console))
  id: totrans-618
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.4. 在问答应用中使用数字生成器 ([http://jsbin.com/ponogi/edit?html,js,console](http://jsbin.com/ponogi/edit?html,js,console))
- en: '![](ch13ex04-0.jpg)'
  id: totrans-619
  prefs: []
  type: TYPE_IMG
  zh: '![](ch13ex04-0.jpg)'
- en: '![](ch13ex04-1.jpg)'
  id: totrans-620
  prefs: []
  type: TYPE_IMG
  zh: '![](ch13ex04-1.jpg)'
- en: You use the `between` function to pick a random question from the question bank.
    The number of elements in the `questions` array is given by `questions.length`
    (every array has a `length` property) and the question indexes run from 0 to one
    less than the length. If there are four elements in the array, then the indexes
    run from 0 to 3\. So, to pick a random index you use
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用 `between` 函数从题库中随机选择一个问题。`questions` 数组中的元素数量由 `questions.length` 给出（每个数组都有一个
    `length` 属性），问题索引从 0 开始，到长度减 1。如果数组中有四个元素，那么索引从 0 到 3。因此，要选择一个随机索引，你使用
- en: '[PRE126]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: You use the wrap-and-return module pattern from [chapter 11](kindle_split_020.html#ch11),
    hiding your implementation (the code that makes everything work) inside the `getQuiz`
    function and returning the public interface as an object.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用了 [第 11 章](kindle_split_020.html#ch11) 中的 wrap-and-return 模块模式，将实现（使一切工作的代码）隐藏在
    `getQuiz` 函数内部，并作为对象返回公共接口。
- en: 'Follow the listing link to the game on JS Bin and test your knowledge of multiplication
    facts! The answers are stored as strings, so make sure you submit strings for
    the program to check: `quiz.submit("30")`, not `quiz.submit(30)`.'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 点击列表链接访问 JS Bin 上的游戏并测试你对乘法事实的了解！答案存储为字符串，所以请确保你提交字符串以便程序进行检查：`quiz.submit("30")`，而不是
    `quiz.submit(30)`。
- en: 13.3.2\. Using the between function in your guessing game
  id: totrans-625
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.3.2. 在你的猜测游戏中使用 between 函数
- en: '[Listing 13.6](#ch13ex06) shows the JavaScript code for your guessing game.
    At the console prompt, players have to guess a number between 5 and 10, inclusive:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 13.6](#ch13ex06) 展示了你的猜测游戏的 JavaScript 代码。在控制台提示符下，玩家必须猜测一个介于 5 和 10 之间的数字（包括
    5 和 10）：'
- en: '[PRE127]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: The app uses the `between` function, so you import it using a `script` element
    on the HTML panel (see the following listing).
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序使用 `between` 函数，因此你需要在 HTML 面板上的 `script` 元素中导入它（见以下列表）。
- en: Listing 13.5\. Using the Number Generator in the guessing game (HTML) ([http://jsbin.com/tixina/edit?html,js,console](http://jsbin.com/tixina/edit?html,js,console))
  id: totrans-629
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.5. 在猜测游戏中使用数字生成器（HTML）([http://jsbin.com/tixina/edit?html,js,console](http://jsbin.com/tixina/edit?html,js,console))
- en: '[PRE128]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Listing 13.6\. Using the Number Generator in the guessing game ([http://jsbin.com/tixina/edit?html,js,console](http://jsbin.com/tixina/edit?html,js,console))
  id: totrans-631
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.6. 在猜测游戏中使用数字生成器 ([http://jsbin.com/tixina/edit?html,js,console](http://jsbin.com/tixina/edit?html,js,console))
- en: '![](232fig01_alt.jpg)'
  id: totrans-632
  prefs: []
  type: TYPE_IMG
  zh: '![](232fig01_alt.jpg)'
- en: Again, follow the listing link to JS Bin and get guessing!
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，点击列表链接访问 JS Bin 并开始猜测吧！
- en: Both the quiz app and the guessing game now import the same Number Generator
    file. The number generation code is in one place; there is *a single source of
    truth*. Any updates or fixes can be performed on that one file, and all the projects
    that use it will load the new version.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 问答应用和猜测游戏现在都导入相同的数字生成器文件。数字生成代码在一个地方；这是一个唯一的真相来源。任何更新或修复都可以在这个文件上执行，所有使用它的项目都将加载新版本。
- en: Importing one file is useful, but can you load more than one?
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 导入一个文件很有用，但你能否加载多个文件呢？
- en: 13.4\. Importing multiple files
  id: totrans-636
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4. 导入多个文件
- en: In [chapters 7](kindle_split_015.html#ch07) and [11](kindle_split_020.html#ch11),
    you saw that an object can be used as a namespace, a way of organizing properties
    and methods so that only a single variable is required. As an example, you created
    `spacer`, a namespace of functions for formatting text on the console. The `spacer`
    namespace could be useful in a number of projects, whenever you want to format
    your text output with borders and boxes. Rather than copying and pasting the `spacer`
    code into every program where it’s used, it seems like an obvious candidate to
    be saved to its own file and imported as needed. You can view the `spacer` code
    at [http://jsbin.com/juneqo/edit?js](http://jsbin.com/juneqo/edit?js).
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 7 章](kindle_split_015.html#ch07) 和 [第 11 章](kindle_split_020.html#ch11)
    中，你看到可以使用对象作为命名空间，这是一种组织属性和方法的方式，以便只需要一个变量。作为一个例子，你创建了 `spacer`，一个用于在控制台上格式化文本的函数命名空间。`spacer`
    命名空间在许多项目中都可能很有用，无论何时你想用边框和框来格式化你的文本输出。与其将 `spacer` 代码复制粘贴到每个使用它的程序中，不如将其保存到自己的文件中，并在需要时导入。你可以在
    [http://jsbin.com/juneqo/edit?js](http://jsbin.com/juneqo/edit?js) 查看`spacer`
    代码。
- en: 'Let’s put `spacer` to work straight away. In [listing 13.6](#ch13ex06) you
    updated your guessing game to import the `between` function and used it to generate
    the secret number to be guessed. Say you now want to format the feedback you give
    to players by wrapping the messages in boxes. That’s what `spacer` is for! A game
    on the console will look something like this:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们立即使用`spacer`。在[列表13.6](#ch13ex06)中，你更新了你的猜测游戏，以导入`between`函数并使用它来生成要猜测的秘密数字。假设你现在想通过将消息包装在框中来格式化你提供给玩家的反馈。这正是`spacer`的作用！控制台游戏看起来可能像这样：
- en: '[PRE129]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[Figure 13.11](#ch13fig11) shows the guessing game app importing the `Number
    Generator` and `spacer` modules.'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '[图13.11](#ch13fig11)显示了猜测游戏应用导入`Number Generator`和`spacer`模块。'
- en: Figure 13.11\. Importing the `Number Generator` and `spacer` modules
  id: totrans-641
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.11\. 导入`Number Generator`和`spacer`模块
- en: '![](13fig11_alt.jpg)'
  id: totrans-642
  prefs: []
  type: TYPE_IMG
  zh: '![](13fig11_alt.jpg)'
- en: The following listing shows the script elements added to the HTML panel to import
    the two modules you’re using.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了添加到HTML面板中的脚本元素，用于导入你正在使用的两个模块。
- en: Listing 13.7\. Using `spacer` and `between` in the guessing game (HTML) ([http://jsbin.com/foqowa/edit?html,js,console](http://jsbin.com/foqowa/edit?html,js,console))
  id: totrans-644
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表13.7\. 在猜测游戏中使用`spacer`和`between`（HTML）([http://jsbin.com/foqowa/edit?html,js,console](http://jsbin.com/foqowa/edit?html,js,console))
- en: '[PRE130]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Comments have been added to note which modules are being imported; JS Bin addresses
    aren’t very user friendly, so it’s helpful to make it clear what you’re trying
    to load. The comments are HTML comments, so they look a little different from
    Java-Script comments.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了注释来标记正在导入的模块；JS Bin地址不太友好，所以清楚地说明你试图加载的内容很有帮助。这些注释是HTML注释，所以它们看起来与Java-Script注释略有不同。
- en: The next listing shows the guessing game code using the two imported modules,
    `between` and `spacer`.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了使用两个导入模块`between`和`spacer`的猜测游戏代码。
- en: Listing 13.8\. Using `spacer` and `between` in the guessing game ([http://jsbin.com/foqowa/edit?html,js,console](http://jsbin.com/foqowa/edit?html,js,console))
  id: totrans-648
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表13.8\. 在猜测游戏中使用`spacer`和`between`([http://jsbin.com/foqowa/edit?html,js,console](http://jsbin.com/foqowa/edit?html,js,console))
- en: '![](233fig01_alt.jpg)'
  id: totrans-649
  prefs: []
  type: TYPE_IMG
  zh: '![](233fig01_alt.jpg)'
- en: Putting previously written and tested code into separate files like this also
    helps you focus on new code you’re working on; [listing 13.8](#ch13ex08) can be
    short and sweet because your trusted `spacer` code is packaged off in an external
    file.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 将之前编写和测试过的代码放入这样的单独文件中也有助于你专注于正在工作的新代码；[列表13.8](#ch13ex08)可以简短而甜蜜，因为你的信任的`spacer`代码被包装在外部文件中。
- en: When you import JavaScript, it’s as if all of the imported code is joined to
    form a single file. If different imported files use the same variable names, it’s
    possible for later code to inadvertently overwrite earlier code. Boom—you have
    variable collisions!
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 当你导入JavaScript时，就像所有导入的代码都被合并成一个单独的文件。如果不同的导入文件使用了相同的变量名，后来的代码可能会无意中覆盖早期的代码。嘭——你遇到了变量冲突！
- en: 13.5\. Collisions—when imported code overwrites your variables
  id: totrans-652
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.5\. 冲突——当导入的代码覆盖你的变量时
- en: 'You decide the boxed messages for your guessing game feedback are a bit too
    much. You’d like the feedback to look like this:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为你的猜测游戏反馈中的框式消息有点过多。你希望反馈看起来像这样：
- en: '[PRE131]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'The messages take up less room but are nicely spaced out with dashes between
    characters. Fortunately, a friend of yours, Kallie, has been working on her own
    formatting functions and has kindly bundled them into a module you can import.
    The function you need is called `dasher` and is really easy to use:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 消息占用的空间更少，但字符之间用破折号分隔得很好。幸运的是，你的一个朋友，Kallie，一直在开发她自己的格式化函数，并且已经友好地将它们打包成一个你可以导入的模块。你需要的功能叫做`dasher`，使用起来非常简单：
- en: '[PRE132]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: You add a script element to the guessing game HTML panel to import Kallie’s
    code, as shown next.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 你向猜测游戏的HTML面板添加一个脚本元素来导入Kallie的代码，如下所示。
- en: Listing 13.9\. Importing Kallie’s code (HTML) ([http://jsbin.com/zusodu/edit?html,js,console](http://jsbin.com/zusodu/edit?html,js,console))
  id: totrans-658
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表13.9\. 导入Kallie的代码（HTML）([http://jsbin.com/zusodu/edit?html,js,console](http://jsbin.com/zusodu/edit?html,js,console))
- en: '[PRE133]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: No, I haven’t shown you the JavaScript of Kallie’s code. You know `dasher` is
    part of the interface, the variables and functions you’re expected to use, and
    you know what `dasher` does; you shouldn’t need to know *how* it does what it
    does, the implementation. Of course, you might (and probably should) be interested
    in the implementation, but you don’t need to understand it in order to use the
    interface, the `dasher` function.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 不，我还没有向你展示Kallie的代码中的JavaScript。你知道`dasher`是界面的一部分，是你预期使用的变量和函数，你也知道`dasher`的功能；你不需要知道它是如何做到的，即实现。当然，你可能（并且可能应该）对实现感兴趣，但你不需要理解它就能使用界面，`dasher`函数。
- en: You update the guessing game to use the `dasher` function, as shown here.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 你更新猜谜游戏以使用`dasher`函数，如下所示。
- en: Listing 13.10\. Using Kallie’s code ([http://jsbin.com/zusodu/edit?html,js,console](http://jsbin.com/zusodu/edit?html,js,console))
  id: totrans-662
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表13.10\. 使用Kallie的代码 ([http://jsbin.com/zusodu/edit?html,js,console](http://jsbin.com/zusodu/edit?html,js,console))
- en: '![](235fig01_alt.jpg)'
  id: totrans-663
  prefs: []
  type: TYPE_IMG
  zh: '![图片](235fig01_alt.jpg)'
- en: Happy with your work, you run the program and make a guess. Error! What? Where
    has `spacer.wrap` gone? [Figure 13.12](#ch13fig12) shows what happened in my browser.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的工作感到满意，你运行程序并做出猜测。错误！什么？`spacer.wrap`去哪里了？[图13.12](#ch13fig12)显示了在我的浏览器中发生的情况。
- en: Figure 13.12\. For some reason, the program can’t find `spacer.wrap.`
  id: totrans-665
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.12\. 由于某种原因，程序找不到`spacer.wrap`。
- en: '![](13fig12.jpg)'
  id: totrans-666
  prefs: []
  type: TYPE_IMG
  zh: '![图片](13fig12.jpg)'
- en: There seems to be a problem with `spacer.wrap`, which has been a working part
    of your `spacer` namespace since [chapter 7](kindle_split_015.html#ch07). Why
    has it chosen now to break? It’s time to check inside Kallie’s module. If you
    take a look at her code in the following listing, you might spot the problem.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '`spacer.wrap`似乎出了问题，它一直是你的`spacer`命名空间中工作的一部分，从第7章([kindle_split_015.html#ch07](kindle_split_015.html#ch07))开始。为什么它现在选择崩溃？是时候检查Kallie的模块内部了。如果你查看以下列表中的她的代码，你可能会发现问题。'
- en: Listing 13.11\. Kallie’s formatting code ([http://jsbin.com/soxeke/edit?js,console](http://jsbin.com/soxeke/edit?js,console))
  id: totrans-668
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表13.11\. Kallie的格式化代码 ([http://jsbin.com/soxeke/edit?js,console](http://jsbin.com/soxeke/edit?js,console))
- en: '![](235fig02_alt.jpg)'
  id: totrans-669
  prefs: []
  type: TYPE_IMG
  zh: '![图片](235fig02_alt.jpg)'
- en: Kallie’s code doesn’t only include the `dasher` function; it also has a `spacer`
    function. The three variables she has used, `spreader`, `spacer`, and `dasher`,
    are global variables. Your `spacer` namespace also uses a global variable, `spacer`.
    Her `spacer` has overwritten your `spacer`, as shown in [figure 13.13](#ch13fig13).
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: Kallie的代码不仅包括`dasher`函数；它还有一个`spacer`函数。她使用的三个变量，`spreader`、`spacer`和`dasher`，都是全局变量。你的`spacer`命名空间也使用一个全局变量，`spacer`。她的`spacer`已经覆盖了你的`spacer`，如图13.13([#ch13fig13](#ch13fig13))所示。
- en: Figure 13.13\. Two modules declare the same global variable, leading to a collision.
  id: totrans-671
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.13\. 两个模块声明了相同的全局变量，导致冲突。
- en: '![](13fig13_alt.jpg)'
  id: totrans-672
  prefs: []
  type: TYPE_IMG
  zh: '![图片](13fig13_alt.jpg)'
- en: The problem isn’t with the implementation of the functions—they work just fine—it’s
    with how the functions have been made available within the module. When variables
    are added to the global scope, possibly by different people in different modules,
    there’s always the chance that the same name will be used in more than one declaration.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 问题不在于函数的实现——它们工作得很好——而在于函数如何在模块内部提供。当变量被添加到全局作用域中，可能是由不同模块中的不同人添加的，总有可能在多个声明中使用相同的名称。
- en: 13.5.1\. Variable collisions
  id: totrans-674
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.5.1\. 变量冲突
- en: Your modules make their functionality available by using at least one global
    variable. But what happens if the same variable is used by more than one module?
    Well, the last module wins, assigning its own value to the variable. In the guessing
    game code, you load two modules that use a global `spacer` variable and then you
    try to use that variable later in the program. The following snippet shows how
    the second `spacer` overwrites the first, leading to an error when you try to
    use `spacer.wrap`.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 你的模块通过使用至少一个全局变量来提供其功能。但如果同一个变量被多个模块使用怎么办？嗯，最后一个模块获胜，将其自己的值赋给变量。在猜谜游戏代码中，你加载了两个使用全局`spacer`变量的模块，然后你试图在程序中稍后使用该变量。以下片段显示了第二个`spacer`如何覆盖第一个，导致尝试使用`spacer.wrap`时出错。
- en: '[PRE134]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: When one declaration supersedes another like this it’s called a *variable collision*;
    the second variable declaration clobbers the first. You can appreciate why declaring
    lots of global variables is called *polluting the global namespace*—the more variables
    you declare, the greater the chance of collisions. Reduce the number of global
    variables by using namespaces, discussed next, and immediately invoked function
    expressions, discussed in [section 13.6](#ch13lev1sec6).
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个声明像这样取代另一个时，这被称为 *变量冲突*；第二个变量声明覆盖了第一个。你可以理解为什么声明大量全局变量被称为 *污染全局命名空间*——你声明的变量越多，冲突的可能性就越大。通过使用下一部分讨论的命名空间和立即调用的函数表达式来减少全局变量的数量。
- en: 13.5.2\. Minimizing collisions by using namespaces
  id: totrans-678
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.5.2\. 通过使用命名空间最小化冲突
- en: Your `spacer` namespace module is well behaved because it uses only a single
    global variable. Rather than separate global variables for the `line`, `wrap`,
    and `box` functions, it uses an object as a namespace and assigns the functions
    to properties of the object. The object is then assigned to the single variable,
    `spacer`.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `spacer` 命名空间模块表现良好，因为它只使用了一个全局变量。而不是为 `line`、`wrap` 和 `box` 函数分别使用不同的全局变量，它使用一个对象作为命名空间，并将函数分配给对象的属性。然后，这个对象被分配给单个变量，`spacer`。
- en: Kallie apologizes for the pollution her module caused—she’s been busy—and updates
    the module to use a namespace, as shown in the next listing.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: Kallie 为她的模块造成的污染道歉——她一直很忙——并将模块更新为使用命名空间，如下一清单所示。
- en: Listing 13.12\. Kallie’s formatting code in a namespace ([http://jsbin.com/moheka/edit?js,console](http://jsbin.com/moheka/edit?js,console))
  id: totrans-681
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单 13.12\. 在命名空间中的 Kallie 格式化代码 ([http://jsbin.com/moheka/edit?js,console](http://jsbin.com/moheka/edit?js,console))
- en: '![](237fig01_alt.jpg)'
  id: totrans-682
  prefs: []
  type: TYPE_IMG
  zh: '![图片 237](237fig01_alt.jpg)'
- en: You update your guessing game HTML to import the updated module ([listing 13.13](#ch13ex13))
    and your JavaScript code to call the `dasher` function from within the `kalliesCode`
    namespace ([listing 13.14](#ch13ex14)).
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 您将猜谜游戏的 HTML 更新为导入更新的模块 ([清单 13.13](#ch13ex13))，并将您的 JavaScript 代码更新为在 `kalliesCode`
    命名空间内调用 `dasher` 函数 ([清单 13.14](#ch13ex14))。
- en: Listing 13.13\. Importing Kallie’s namespace (HTML) ([http://jsbin.com/seqahi/edit?html,js,console](http://jsbin.com/seqahi/edit?html,js,console))
  id: totrans-684
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单 13.13\. 导入 Kallie 的命名空间 (HTML) ([http://jsbin.com/seqahi/edit?html,js,console](http://jsbin.com/seqahi/edit?html,js,console))
- en: '[PRE135]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Listing 13.14\. Using Kallie’s code ([http://jsbin.com/seqahi/edit?html,js,console](http://jsbin.com/seqahi/edit?html,js,console))
  id: totrans-686
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单 13.14\. 使用 Kallie 的代码 ([http://jsbin.com/seqahi/edit?html,js,console](http://jsbin.com/seqahi/edit?html,js,console))
- en: '![](238fig01_alt.jpg)'
  id: totrans-687
  prefs: []
  type: TYPE_IMG
  zh: '![图片 238](238fig01_alt.jpg)'
- en: Follow the listing link to JS Bin, run the program, and play the game. Using
    a namespace has fixed the problem.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 按照清单链接访问 JS Bin，运行程序并玩游戏。使用命名空间已经解决了问题。
- en: '[PRE136]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Another important way of avoiding polluting the global namespace, this time
    by using functions, is covered next. It has a great name ... and here it is!
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 避免污染全局命名空间的重要方法之一，这次是通过使用函数，将在下一部分介绍。它有一个很棒的名字...现在就来看看吧！
- en: 13.6\. Immediately invoked function expressions (IIFE)
  id: totrans-691
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.6\. 立即调用的函数表达式 (IIFE)
- en: If the name of this section has immediately invoked a funky expression on your
    face, I hope it’s one of curiosity, intrigue, and adventure rather than befuddlement,
    fear, or horror. *Immediately invoked function expressions* are just functions
    that you call straight away, without even bothering to use a variable. But why
    would you do that?
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个章节的标题立即在你的脸上引起了古怪的表情，我希望那是一种好奇、兴趣和冒险的感觉，而不是困惑、恐惧或惊恐。*立即调用的函数表达式*只是你直接调用的函数，甚至都不用使用变量。但你为什么要这样做呢？
- en: In [section 13.5](#ch13lev1sec5), you imported a module of code written by a
    friend, Kallie. (Honestly, you’ve known her for years.) Unfortunately, Kallie’s
    global variables collided with yours (ouch!) and overwrote your beloved `spacer`
    namespace. You learned an important lesson about the dangers of global variables
    and vowed to do whatever you can to reduce pollution of the global namespace.
    You decide to review some of your code, on the lookout for global variables you
    can remove.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 13.5 节](#ch13lev1sec5) 中，您导入了一个由朋友 Kallie 编写的代码模块。（说实话，您已经认识她很多年了。）不幸的是，Kallie
    的全局变量与您的冲突了（ouch！）并覆盖了您心爱的 `spacer` 命名空间。您学到了关于全局变量危险的重要教训，并发誓要尽一切可能减少全局命名空间的污染。您决定回顾一些代码，寻找可以删除的全局变量。
- en: You start your review with the quiz app from earlier in the chapter. The following
    listing shows the structure of your code, with global variables, local variables,
    and the interface object.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 你从本章早些时候的测验应用程序开始复习。以下列表显示了你的代码结构，包括全局变量、局部变量和接口对象。
- en: Listing 13.15\. Random quiz questions with two global variables ([http://jsbin.com/ponogi/edit?html,js,console](http://jsbin.com/ponogi/edit?html,js,console))
  id: totrans-695
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表13.15\. 带有两个全局变量的随机测验问题 ([http://jsbin.com/ponogi/edit?html,js,console](http://jsbin.com/ponogi/edit?html,js,console))
- en: '![](239fig01_alt.jpg)'
  id: totrans-696
  prefs: []
  type: TYPE_IMG
  zh: '![图片](239fig01_alt.jpg)'
- en: 'The program declares two global variables: `getQuiz` and `quiz`. On the first
    line you define a function and assign it to `getQuiz`.'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 程序声明了两个全局变量：`getQuiz`和`quiz`。在第一行中，你定义了一个函数并将其赋值给`getQuiz`。
- en: '[PRE137]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Then, on the last line, you immediately call the function.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在最后一行，你立即调用该函数。
- en: '[PRE138]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: So, you declare `getQuiz` as a global variable—nasty pollution—and then use
    it only once before leaving it hanging around in the global scope like a bad smell.
    Shame on you! Remember, global variables run the risk of clobbering other global
    variables; they may seem fine in small pieces of code, but as projects grow and
    modules are created and imported, a faint whiff of unease soon builds to the furious
    stench of despair.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你将`getQuiz`声明为全局变量——这是一种恶臭的污染——然后只使用一次，就让它像恶臭一样悬挂在全局作用域中。真丢脸！记住，全局变量有覆盖其他全局变量的风险；在小段代码中可能看起来不错，但随着项目的增长和模块的创建和导入，不久就会产生一种不安的微弱气息，最终变成绝望的恶臭。
- en: '|  |'
  id: totrans-702
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-703
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Avoid declaring *global* variables, polluting the global namespace. Reduce the
    number of global variables by using objects as namespaces. Declare *local* variables
    inside functions.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 避免声明*全局*变量，污染全局命名空间。通过使用对象作为命名空间来减少全局变量的数量。在函数内声明*局部*变量。
- en: '|  |'
  id: totrans-705
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'You can use an immediately invoked function expression to cut the number of
    global variables in half. To appreciate how to use an IIFE for the benefit of
    your programs, consider the following points:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用立即调用的函数表达式将全局变量的数量减半。为了理解如何使用IIFE（立即调用的函数表达式）来提高程序的性能，请考虑以下要点：
- en: Recognizing function expressions
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别函数表达式
- en: Invoking functions
  id: totrans-708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用函数
- en: Immediately invoking function expressions
  id: totrans-709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立即调用函数表达式
- en: Returning information from an IIFE
  id: totrans-710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从IIFE返回信息
- en: 13.6.1\. Recognizing function expressions
  id: totrans-711
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.6.1\. 识别函数表达式
- en: You’ve been using function expressions since [chapter 4](kindle_split_012.html#ch04).
    You’ve assigned them to variables and properties, passed them as arguments, and
    returned them from other functions.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 你从[第4章](kindle_split_012.html#ch04)开始就一直在使用函数表达式。你已经将它们赋值给变量和属性，将它们作为参数传递，并从其他函数中返回它们。
- en: '[PRE139]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: You’ve used functions to create blocks of code you can call on demand and to
    create local scopes, hiding variables you want to be private from the peeks and
    tweaks of users and programmers.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经使用函数来创建可以在需要时调用的代码块，以及创建局部作用域，隐藏你希望保持私密的变量，防止用户和程序员的查看和修改。
- en: 13.6.2\. Invoking functions
  id: totrans-715
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.6.2\. 调用函数
- en: 'To *invoke*, or *call*, a function, you use the *function invocation operator*,
    `()`, a pair of parentheses. Here’s how to invoke the four example function expressions
    in the last section:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 要*调用*或*调用*一个函数，你使用*函数调用操作符*，`()`，一对括号。以下是调用上一节中提到的四个示例函数表达式的步骤：
- en: '[PRE140]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: You pass arguments to the functions between the parentheses of the invocation
    operator. Any values that the functions return replace the function call.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 你在调用操作符的括号内传递参数给函数。函数返回的任何值将替换函数调用。
- en: 13.6.3\. Immediately invoking function expressions
  id: totrans-719
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.6.3\. 立即调用函数表达式
- en: 'You don’t need to assign a function expression to a variable in order to invoke
    it. Just wrap the function expression in parentheses and append the function invocation
    operator:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要将函数表达式赋值给变量来调用它。只需将函数表达式放在括号内，并附加函数调用操作符：
- en: '[PRE141]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[Figure 13.14](#ch13fig14) shows an annotated version of the code pattern.'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: '[图13.14](#ch13fig14) 展示了代码模式的注释版本。'
- en: Figure 13.14\. An immediately invoked function expression
  id: totrans-723
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.14\. 立即调用的函数表达式
- en: '![](13fig14_alt.jpg)'
  id: totrans-724
  prefs: []
  type: TYPE_IMG
  zh: '![图片](13fig14_alt.jpg)'
- en: The code in the function body runs immediately. But no global variable is used.
    The function expression has no impact on the global namespace. Breathe in the
    pollution-free, piquant freshness.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 函数体内的代码立即执行。但未使用任何全局变量。函数表达式对全局命名空间没有影响。呼吸无污染、清新可口的空气。
- en: 13.6.4\. Returning information from an IIFE
  id: totrans-726
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.6.4\. 从IIFE返回信息
- en: 'So, immediately invoked functions reduce pollution and are great for hiding
    your privates. But there’s more! Just like any other functions, immediately invoked
    functions can return values, such as objects acting as interfaces, giving you
    controlled access to the secret goodies inside the functions. (Note: please think
    carefully about just how much access to your privates is appropriate.)'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，立即执行函数减少了污染，并且对于隐藏你的私有变量非常有用。但还有更多！就像任何其他函数一样，立即执行函数可以返回值，例如作为接口的对象，这让你可以控制访问函数内部的秘密好东西。（注意：请仔细考虑你的私有变量应该有多少访问权限。）
- en: '[Listing 13.16](#ch13ex16) demonstrates how an IIFE can return an interface
    object that you then assign to a variable. If you run the program, you can access
    the `quiz` interface at the console:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 13.16](#ch13ex16) 展示了如何使用立即执行函数表达式（IIFE）返回一个接口对象，然后将其分配给一个变量。如果你运行程序，你可以在控制台访问
    `quiz` 接口：'
- en: '[PRE142]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Listing 13.16\. Using an IIFE with the quiz app ([http://jsbin.com/titano/edit?html,js,console](http://jsbin.com/titano/edit?html,js,console))
  id: totrans-730
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.16. 在测验应用中使用 IIFE ([http://jsbin.com/titano/edit?html,js,console](http://jsbin.com/titano/edit?html,js,console))
- en: '![](242fig01_alt.jpg)'
  id: totrans-731
  prefs: []
  type: TYPE_IMG
  zh: '![](242fig01_alt.jpg)'
- en: You define a function, immediately invoke it, and assign the object returned
    to the `quiz` variable. Using an immediately invoked function expression just
    does away with the extra variable. Rather than
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 你定义一个函数，立即调用它，并将返回的对象分配给 `quiz` 变量。使用立即执行函数表达式可以消除额外的变量。而不是
- en: '[PRE143]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: you have
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 你有
- en: '[PRE144]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: You don’t need to use the `getQuiz` variable.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要使用 `getQuiz` 变量。
- en: '*The Crypt* uses a number of constructors and functions and objects to build
    the game. You’ve seen the benefit of modules and immediately invoked function
    expressions; let’s break the game code into modules.'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 《密码学》使用了多个构造函数、函数和对象来构建游戏。你已经看到了模块和立即执行函数表达式的优势；让我们将游戏代码分解成模块。
- en: 13.7\. The Crypt—organizing code into modules
  id: totrans-738
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.7. 《密码学》——将代码组织成模块
- en: Back at the start of this chapter, you saw how the growing amount of code in
    *The Crypt* is motivation for breaking the program into modules. Now that you’ve
    learned the hows and whys, it’s time to do the deed.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，你看到了随着《密码学》代码量的增加，将程序分解成模块的动机。现在你已经了解了如何做以及为什么这样做，是时候采取行动了。
- en: The next listing shows the five HTML script elements you use to load the different
    modules that make up the game.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了用于加载构成游戏的各个模块的五个 HTML 脚本元素。
- en: Listing 13.17\. Importing modules for *The Crypt* (HTML) ([http://jsbin.com/zikuta/edit?html,js,console](http://jsbin.com/zikuta/edit?html,js,console))
  id: totrans-741
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.17. 为《密码学》导入模块（HTML）([http://jsbin.com/zikuta/edit?html,js,console](http://jsbin.com/zikuta/edit?html,js,console))
- en: '[PRE145]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Notice that the address for the `spacer` module is the same one you’ve been
    using throughout the chapter. That’s the beauty of modules! You have a single
    file that’s used in multiple projects. If you were to add a new formatting function
    to the `spacer` namespace, it would immediately be available to all of the projects
    that import the module.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `spacer` 模块的地址与你在本章中一直使用的地址相同。这就是模块的美丽之处！你有一个文件，可以在多个项目中使用。如果你要向 `spacer`
    命名空间添加一个新的格式化函数，它将立即对所有导入该模块的项目可用。
- en: The next listing shows the single line of JavaScript needed to get the game
    started.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了启动游戏所需的单行 JavaScript 代码。
- en: Listing 13.18\. Importing modules for *The Crypt* ([http://jsbin.com/zikuta/edit?html,js,console](http://jsbin.com/zikuta/edit?html,js,console))
  id: totrans-745
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.18. 为《密码学》导入模块 ([http://jsbin.com/zikuta/edit?html,js,console](http://jsbin.com/zikuta/edit?html,js,console))
- en: '[PRE146]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Run the game; it should work just the same in modular form. All of the functionality
    is defined in the modules; it requires minimal code to get the game started.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏；它应该以模块形式正常工作。所有功能都在模块中定义；启动游戏只需要最少的代码。
- en: Apart from `spacer`, the modules for *The Crypt* all share the same namespace,
    `theCrypt` ([figure 13.15](#ch13fig15)). You start the game by calling the `getGame`
    method of the `theCrypt` namespace, `theCrypt.getGame()`;
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `spacer` 模块外，《密码学》的其他模块都共享相同的命名空间 `theCrypt` ([图 13.15](#ch13fig15))。你通过调用
    `theCrypt` 命名空间的 `getGame` 方法来启动游戏，即 `theCrypt.getGame()`；
- en: Figure 13.15\. The game imports five modules. Four of them need to share a namespace.
  id: totrans-749
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.15. 游戏导入了五个模块。其中四个需要共享一个命名空间。
- en: '![](13fig15_alt.jpg)'
  id: totrans-750
  prefs: []
  type: TYPE_IMG
  zh: '![](13fig15_alt.jpg)'
- en: You know that using a namespace is a good way to reduce the number of global
    variables and group related functions, but how can code in different module files
    share the same namespace?
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道使用命名空间是减少全局变量数量和分组相关函数的好方法，但不同的模块文件中的代码如何共享相同的命名空间？
- en: 13.7.1\. Sharing a namespace across modules
  id: totrans-752
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.7.1. 在模块间共享命名空间
- en: 'Using what you’ve learned in this chapter, you want to do the following:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 利用本章所学，你想做以下事情：
- en: Use a single global namespace, `theCrypt`, for all of the modules that form
    *The Crypt.*
  id: totrans-754
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单个全局命名空间 `theCrypt` 为所有构成 *The Crypt* 的模块。
- en: Assign to the namespace only those properties and functions that are needed
    by other modules.
  id: totrans-755
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只将那些其他模块需要的属性和函数分配给命名空间。
- en: Hide everything else in the local scope of functions.
  id: totrans-756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其他所有内容隐藏在函数的局部作用域中。
- en: 'Modules add properties to the namespace `theCrypt` just as they would to any
    other object:'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 模块向命名空间 `theCrypt` 添加属性，就像它们向任何其他对象添加属性一样：
- en: '[PRE147]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: But which module creates the namespace in the first place? Trying to access
    an undeclared variable will cause an error. But it would be inconvenient to have
    to load the modules in a certain order to ensure whichever one declares `theCrypt`
    is first. Fortunately, in browsers, global variables are automatically assigned
    to the special global object, `window`.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 但哪个模块首先创建了命名空间？尝试访问未声明的变量将导致错误。但必须按特定顺序加载模块以确保首先声明 `theCrypt` 的模块将是不方便的。幸运的是，在浏览器中，全局变量会自动分配给特殊的全局对象，`window`。
- en: The global object, window
  id: totrans-760
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 全局对象，window
- en: 'The `window` object is part of the way JavaScript works with global variables
    in browsers. You can test out global variable declarations and `window` at the
    console prompt:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: '`window` 对象是 JavaScript 在浏览器中处理全局变量的方式之一。你可以在控制台提示符中测试全局变量声明和 `window`：'
- en: '[PRE148]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'You declare a global variable, `test`, and it’s automatically assigned as a
    property of `window`. Back at the prompt, try accessing a nonexistent global variable:'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 你声明一个全局变量 `test`，它将自动分配为 `window` 的属性。回到提示符，尝试访问一个不存在的全局变量：
- en: '[PRE149]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'An error is thrown (although your browser may display a slightly different
    error message). On the other hand, trying to access a nonexistent property of
    `window` doesn’t throw an error; it returns `undefined`:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 会抛出错误（尽管你的浏览器可能显示一个略有不同的错误消息）。另一方面，尝试访问 `window` 中不存在的属性不会抛出错误；它返回 `undefined`：
- en: '[PRE150]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: You can use the `window` object to check if `theCrypt` has been declared as
    a namespace without causing any errors.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `window` 对象检查 `theCrypt` 是否已声明为命名空间，而不会引发任何错误。
- en: Using window to check for global variables
  id: totrans-768
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 window 检查全局变量
- en: The next listing shows the `Player` module. Extra code has been wrapped around
    the constructor to modularize it.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表展示了 `Player` 模块。构造函数周围添加了额外的代码以模块化它。
- en: Listing 13.19\. The Player constructor as a module ([http://jsbin.com/nubijex/edit?js](http://jsbin.com/nubijex/edit?js))
  id: totrans-770
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.19. 将 Player 构造函数作为模块（[http://jsbin.com/nubijex/edit?js](http://jsbin.com/nubijex/edit?js)）
- en: '![](245fig01_alt.jpg)'
  id: totrans-771
  prefs: []
  type: TYPE_IMG
  zh: '![](245fig01_alt.jpg)'
- en: 'In [listing 13.19](#ch13ex19) the `Player` module checks the `window` object
    to see if `theCrypt` has been declared as a global variable. If the module can’t
    find `theCrypt`, then it declares it:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 13.19](#ch13ex19) 中，`Player` 模块检查 `window` 对象以查看 `theCrypt` 是否已声明为全局变量。如果模块找不到
    `theCrypt`，则它将声明它：
- en: '[PRE151]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Once the module has ensured that the namespace is present, it adds the `Player`
    constructor as a property:'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦模块确保命名空间存在，它就会将 `Player` 构造函数作为属性添加：
- en: '[PRE152]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: The `Player` constructor is now available to other code that needs it, via the
    global variable `theCrypt`.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: '`Player` 构造函数现在可以通过全局变量 `theCrypt` 供其他需要它的代码使用。'
- en: The next listing shows the `Place` module using the same global namespace.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表展示了使用相同全局命名空间的 `Place` 模块。
- en: Listing 13.20\. The Place constructor as a module ([http://jsbin.com/dofuci/edit?js](http://jsbin.com/dofuci/edit?js))
  id: totrans-778
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.20. Place 构造函数作为模块（[http://jsbin.com/dofuci/edit?js](http://jsbin.com/dofuci/edit?js)）
- en: '![](245fig02_alt.jpg)'
  id: totrans-779
  prefs: []
  type: TYPE_IMG
  zh: '![](245fig02_alt.jpg)'
- en: Having each module check for `theCrypt` as a global variable on the `window`
    object means no one module is required to be loaded first because it’s the one
    that creates the namespace. They all check for `theCrypt`. The first module to
    be loaded won’t find it and will create it before using it. Modules loaded after
    the first will find `theCrypt` and assign to it the properties they want to be
    shared.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块检查 `window` 对象上的 `theCrypt` 作为全局变量意味着不需要任何模块首先加载，因为它是创建命名空间的那个。它们都检查 `theCrypt`。第一个加载的模块将找不到它，并在使用之前创建它。之后加载的模块将找到
    `theCrypt` 并将其属性分配给它想要共享的属性。
- en: Assigning namespace properties to local variables
  id: totrans-781
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将命名空间属性分配给局部变量
- en: 'You like the way a namespace cuts down on global variables, but you’re not
    so keen on having to do more typing to use the shared properties. For example,
    the map code module needs to create places in *The Crypt* using the `Place` constructor:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 您喜欢命名空间减少全局变量的方式，但您不太喜欢使用共享属性时需要输入更多。例如，地图代码模块需要使用`Place`构造函数在*The Crypt*中创建地点：
- en: '[PRE153]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'But you’ve moved the `Place` constructor into a namespace, `theCrypt`. You
    could change all of the references to `Place` in the map code:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 但您已经将`Place`构造函数移动到了命名空间`theCrypt`中。您可以在地图代码中更改所有对`Place`的引用：
- en: '[PRE154]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'But it can be easier to create a local `Place` variable and leave the original
    code alone:'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 但创建一个局部的`Place`变量并保留原始代码可能会更容易：
- en: '[PRE155]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: That’s a handy way to reduce typing if you need to use a namespace property
    multiple times.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要多次使用命名空间属性，这是一个减少输入的好方法。
- en: 'Having moved sections of code into their own modules, you can start to think
    carefully about what each module does. Could they be split into smaller modules
    that have more specific tasks? The next three chapters look at some common tasks
    and the code patterns that are often seen in programs that use and display data
    that changes: models, views, and controllers.'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码部分移动到它们自己的模块后，您可以开始仔细思考每个模块的作用。它们可以被分成更小的、具有更具体任务的模块吗？接下来的三个章节将探讨一些常见任务和常见于使用和显示变化数据的程序中的代码模式：模型、视图和控制器。
- en: 13.8\. Summary
  id: totrans-790
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.8\. 摘要
- en: Break up programs into modules, sections of code that can be loaded independently.
  id: totrans-791
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将程序分解成模块，即可以独立加载的代码部分。
- en: Use the same module in multiple projects.
  id: totrans-792
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个项目中使用相同的模块。
- en: 'Load modules in JS Bin by using an HTML script element:'
  id: totrans-793
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用HTML脚本元素在JS Bin中加载模块：
- en: '[PRE156]'
  id: totrans-794
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Specify the location of the module file in the script element’s `src` attribute.
  id: totrans-795
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在脚本元素的`src`属性中指定模块文件的位置。
- en: Minimize variable collisions, where one variable is overwritten by another,
    by using namespaces and immediately invoked function expressions.
  id: totrans-796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用命名空间和立即调用的函数表达式来最小化变量冲突，其中一个变量被另一个变量覆盖。
- en: Create immediately invoked function expressions by wrapping a function definition
    in parentheses and appending the function invocation operator, `()`.
  id: totrans-797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将函数定义括在括号中并附加函数调用运算符`()`来创建立即调用的函数表达式。
- en: '[PRE157]'
  id: totrans-798
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Return an interface from the immediately invoked function expression. This
    is called the module pattern:'
  id: totrans-799
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从立即调用的函数表达式中返回一个接口。这被称为模块模式：
- en: '[PRE158]'
  id: totrans-800
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: Make sure you load any modules that other modules depend on.
  id: totrans-801
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保加载其他模块所依赖的任何模块。
- en: 'Chapter 14\. Models: working with data'
  id: totrans-802
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第14章\. 模型：与数据一起工作
- en: '***This chapter covers***'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: '***本章涵盖***'
- en: Building models from data
  id: totrans-804
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数据构建模型
- en: Using the same data in multiple projects
  id: totrans-805
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个项目中使用相同的数据
- en: Switching between data files
  id: totrans-806
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据文件之间切换
- en: Specifying map data in *The Crypt*
  id: totrans-807
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*The Crypt*中指定映射数据
- en: In [chapter 13](kindle_split_022.html#ch13), you saw how you can use modules
    to break a program into separate files. You can then work on the modules independently,
    easily switch between modules, and reuse them across multiple projects. You can
    even publish your modules and import published modules written by others.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第13章](kindle_split_022.html#ch13)中，您看到了如何使用模块将程序分解成单独的文件。然后您可以独立地工作在模块上，轻松地在模块之间切换，并在多个项目中重用它们。您甚至可以发布您的模块并导入其他人编写的已发布的模块。
- en: This chapter maintains that spirit of modularization and reuse. You look at
    moving data out of constructors and functions. You represent the data simply so
    that multiple apps can use the data, even if the apps are written in different
    programming languages. You then consider how to feed that data into constructors
    and functions to build models that add extra functionality. Finally, you define
    map data for *The Crypt*, adding challenges to make the game more engaging.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 本章保持了模块化和重用的精神。您会看到将数据从构造函数和函数中移出。您以简单的方式表示数据，以便多个应用可以使用这些数据，即使这些应用是用不同的编程语言编写的。然后，您考虑如何将数据输入到构造函数和函数中，以构建添加额外功能模型的模型。最后，您为*The
    Crypt*定义映射数据，增加挑战，使游戏更具吸引力。
- en: 14.1\. Building a fitness app—data and models
  id: totrans-810
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1\. 构建健身应用—数据和模型
- en: Your development work has really gotten you noticed (*The Fruitinator!* was
    a global smash), and you’re now part of a team developing a fitness application.
    Health-conscious users track their exercise, logging the date and duration of
    each session.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 您的开发工作已经引起了人们的注意（*The Fruitinator!*成为全球热门），您现在是一个团队开发健身应用的一部分。注重健康的使用者跟踪他们的锻炼，记录每次会话的日期和持续时间。
- en: '[PRE159]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: The team is working on an Android version of the app using the Python programming
    language, an iOS version using Swift, and a web-based version using JavaScript.
    The same data will be used in all versions ([figure 14.1](#ch14fig01)).
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 团队正在使用 Python 编程语言开发应用程序的 Android 版本，使用 Swift 开发 iOS 版本，以及使用 JavaScript 开发的基于网络的版本。所有版本都将使用相同的数据（[图
    14.1](#ch14fig01)）。
- en: Figure 14.1\. The same data is used by the different versions of the app.
  id: totrans-814
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 14.1\. 不同版本的应用程序使用相同的数据。
- en: '![](14fig01_alt.jpg)'
  id: totrans-815
  prefs: []
  type: TYPE_IMG
  zh: '![图片](14fig01_alt.jpg)'
- en: 'Tasks involved in building the app include:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 构建应用程序涉及的任务包括：
- en: '**1**.  Retrieve user data as a string'
  id: totrans-817
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 以字符串形式检索用户数据'
- en: '**2**.  Convert user data into user models'
  id: totrans-818
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 将用户数据转换为用户模型'
- en: '**3**.  Display user data'
  id: totrans-819
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 显示用户数据'
- en: '**4**.  Provide an interface for users to add sessions'
  id: totrans-820
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**. 为用户提供添加会话的界面'
- en: The data is transferred across the internet as text. The format of the text
    is JSON, which you’ll look at in [chapter 20](kindle_split_030.html#ch20). As
    you’ll see then, the text is easy to convert into a JavaScript object. The team
    has asked you to concentrate on the second task, building user models from user
    data.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 数据以文本形式通过互联网传输。文本的格式是 JSON，你将在第 20 章中查看。正如你将看到的，文本很容易转换为 JavaScript 对象。团队要求你专注于第二个任务，即从用户数据构建用户模型。
- en: 14.1.1\. Defining a User constructor
  id: totrans-822
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.1.1\. 定义用户构造函数
- en: 'You’ve been asked to write JavaScript code to model a fitness app user. Your
    model needs to do the following:'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 你被要求编写 JavaScript 代码来模拟一个健身应用程序的用户。你的模型需要执行以下操作：
- en: '**1**.  Store the user’s name.'
  id: totrans-824
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 存储用户的姓名。'
- en: '**2**.  Store a list of exercise sessions for the user, each with a date and
    duration.'
  id: totrans-825
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 存储用户的锻炼会话列表，每个会话都有一个日期和时长。'
- en: '**3**.  Include a method for adding sessions to the list.'
  id: totrans-826
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 包含一个将会话添加到列表中的方法。'
- en: '**4**.  Include a method for retrieving data about the user.'
  id: totrans-827
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**. 包含一个用于检索用户数据的方法。'
- en: '[Listing 14.1](#ch14ex01) shows your initial constructor function. You test
    it on the console:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 14.1](#ch14ex01) 显示了你的初始构造函数。你可以在控制台测试它：'
- en: '[PRE160]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: Listing 14.1\. The User constructor ([http://jsbin.com/suzala/edit?js,console](http://jsbin.com/suzala/edit?js,console))
  id: totrans-830
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.1\. 用户构造函数([http://jsbin.com/suzala/edit?js,console](http://jsbin.com/suzala/edit?js,console))
- en: '![](250fig01_alt.jpg)'
  id: totrans-831
  prefs: []
  type: TYPE_IMG
  zh: '![图片](250fig01_alt.jpg)'
- en: The constructor includes a `name` parameter, some private variables declared
    using `var`, and two public methods assigned to the `this` object, `addSession`
    and `getData`. The `getData` method uses `slice` with no arguments to grab a copy
    of the `sessions` array. (See [chapter 8](kindle_split_016.html#ch08) for a reminder
    on array methods like `slice`.) Providing a copy of the session information prevents
    users from tweaking the `sessions` array outside the `addSession` method. The
    object that `getData` returns also includes a `total` property, holding the total
    duration of the logged sessions.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数包含一个 `name` 参数，一些使用 `var` 声明的私有变量，以及分配给 `this` 对象的两个公共方法，`addSession` 和
    `getData`。`getData` 方法使用不带参数的 `slice` 来获取 `sessions` 数组的副本。（有关 `slice` 等数组方法的提醒，请参阅第
    8 章[章节 8](kindle_split_016.html#ch08)。）提供会话信息的副本可以防止用户在 `addSession` 方法之外调整 `sessions`
    数组。`getData` 返回的对象还包括一个 `total` 属性，用于存储已记录会话的总时长。
- en: When you create a JavaScript object using the `User` constructor, you create
    a user *model*. The model is more than just data; it includes private variables
    and public methods for managing the data, as shown in [figure 14.2](#ch14fig02).
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `User` 构造函数创建一个 JavaScript 对象时，你创建了一个用户 *模型*。该模型不仅仅是数据；它包括私有变量和用于管理数据的公共方法，如图
    14.2 所示。
- en: Figure 14.2\. A user model created by the `User` constructor function
  id: totrans-834
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 14.2\. 使用 `User` 构造函数函数创建的用户模型
- en: '![](14fig02_alt.jpg)'
  id: totrans-835
  prefs: []
  type: TYPE_IMG
  zh: '![图片](14fig02_alt.jpg)'
- en: If the model is more than the data, what does the data look like?
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模型不仅仅是数据，那么数据看起来是什么样子？
- en: 14.1.2\. Getting a feel for the data as a JavaScript object
  id: totrans-837
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.1.2\. 感知数据作为 JavaScript 对象
- en: 'The data for a user is a simple JavaScript object:'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 用户的 数据是一个简单的 JavaScript 对象：
- en: '[PRE161]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: You can access its properties, like `userData.name`. But it’s still just data;
    it doesn’t have the extra capabilities of a model built with the `User` constructer,
    like an `addSession` or `getData` method. The data object is shown again in [figure
    14.3](#ch14fig03) for comparison with [figure 14.2](#ch14fig02).
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以访问其属性，如 `userData.name`。但它仍然只是数据；它没有使用 `User` 构造函数构建的模型所具有的额外功能，如 `addSession`
    或 `getData` 方法。数据对象再次在图 14.3 中显示，以与图 14.2 进行比较。
- en: Figure 14.3\. User data represented as a simple JavaScript object
  id: totrans-841
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 14.3\. 以简单 JavaScript 对象表示的用户数据
- en: '![](14fig03.jpg)'
  id: totrans-842
  prefs: []
  type: TYPE_IMG
  zh: '![图片](14fig03.jpg)'
- en: Using simple JavaScript objects as the format for data is very common, even
    in other programming languages and especially on the web. Your team developing
    the fitness app is very happy that the user data is represented in such a well-supported
    form.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 使用简单的JavaScript对象作为数据格式非常常见，即使在其他编程语言中也是如此，尤其是在网络上。你的团队开发健身应用非常高兴用户数据以这种广泛支持的形式表示。
- en: In order to make the most of the extra methods provided by a user model, `addSession`
    and `getData`, you need to define a function to build a model from the basic data
    object.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用用户模型提供的额外方法`addSession`和`getData`，你需要定义一个函数，从基本数据对象构建模型。
- en: 14.1.3\. Converting the data into a user model
  id: totrans-845
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.1.3\. 将数据转换为用户模型
- en: 'In [listing 14.3](#ch14ex03), you define the `buildUser` function that takes
    data for a single user as a JavaScript object and creates a model by calling the
    User constructor. You test the `buildUser` function by creating a user model with
    it from a JavaScript object. Adding one extra exercise session for the created
    user produces the following output on the console:'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表14.3](#ch14ex03)中，你定义了`buildUser`函数，该函数接受单个用户的JavaScript对象数据，并通过调用User构造函数创建一个模型。你通过使用JavaScript对象创建一个用户模型来测试`buildUser`函数。为创建的用户添加一个额外的锻炼课程会在控制台产生以下输出：
- en: '[PRE162]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: You’re using the User constructor from [listing 14.1](#ch14ex01), so you import
    that by adding an HTML `script` element to the project (see [chapter 13](kindle_split_022.html#ch13)),
    as shown first in the next listing.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在使用[列表14.1](#ch14ex01)中的User构造函数，因此通过向项目中添加HTML `script`元素来导入它（见[第13章](kindle_split_022.html#ch13)），如下一个列表所示。
- en: Listing 14.2\. A function to build a user model from user data (HTML) ([http://jsbin.com/zenire/edit?html,js,console](http://jsbin.com/zenire/edit?html,js,console))
  id: totrans-849
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.2\. 从用户数据构建用户模型的功能（HTML）([http://jsbin.com/zenire/edit?html,js,console](http://jsbin.com/zenire/edit?html,js,console))
- en: '[PRE163]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: Listing 14.3\. A function to build a user model from user data ([http://jsbin.com/zenire/edit?html,js,console](http://jsbin.com/zenire/edit?html,js,console))
  id: totrans-851
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.3\. 从用户数据构建用户模型的功能([http://jsbin.com/zenire/edit?html,js,console](http://jsbin.com/zenire/edit?html,js,console))
- en: '![](252fig01_alt.jpg)'
  id: totrans-852
  prefs: []
  type: TYPE_IMG
  zh: '![252fig01_alt.jpg]'
- en: With the `buildUser` function you can now upgrade plain user data, stored as
    a simple JavaScript object, to an enhanced user *model* that hides the data as
    private variables but adds methods to manage the state of the model and access
    a copy of the data.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`buildUser`函数，你现在可以将存储为简单JavaScript对象的普通用户数据升级为增强的用户*模型*，该模型将数据作为私有变量隐藏，但添加了管理模型状态和访问数据副本的方法。
- en: 14.1.4\. What’s next for the fitness app?
  id: totrans-854
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.1.4\. 健身应用的下一步是什么？
- en: 'Your team is pleased with your work on the app; you’ve fulfilled the requirements
    for this chapter. The full set of requirements for the app is repeated here:'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 你的团队对你的应用工作感到满意；你已经完成了本章的要求。以下是应用的全部要求：
- en: '**1**.  Retrieve user data as a string'
  id: totrans-856
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 将用户数据作为字符串检索'
- en: '**2**.  Convert user data into user models'
  id: totrans-857
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 将用户数据转换为用户模型'
- en: '**3**.  Display user data'
  id: totrans-858
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 显示用户数据'
- en: '**4**.  Provide an interface for users to add sessions'
  id: totrans-859
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**. 为用户提供添加会话的接口'
- en: You’ve completed the second requirement. You’ll work on the others later in
    the book. For now, it’s back to *The Crypt*. Can you separate the map data from
    the place models just as you separated user data from user models in the fitness
    app?
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经完成了第二个要求。你将在本书后面的章节中处理其他要求。现在，让我们回到*The Crypt*。你能像在健身应用中将用户数据从用户模型中分离出来一样，将地图数据从地点模型中分离出来吗？
- en: 14.2\. The Crypt—separating map data from the game
  id: totrans-861
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2\. The Crypt—将地图数据从游戏中分离出来
- en: 'In this section you apply what you learned from working with the fitness app
    to *The Crypt*. In particular, you complete these tasks:'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将应用在健身应用中学习到的知识来*The Crypt*。特别是，你将完成以下任务：
- en: '**1**.  Use a basic JavaScript object to represent map data in the game'
  id: totrans-863
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 使用基本的JavaScript对象在游戏中表示地图数据'
- en: '**2**.  Add exit challenges to the map data'
  id: totrans-864
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 将退出挑战添加到地图数据中'
- en: '**3**.  Update the `Place` constructor with methods to set and get challenges'
  id: totrans-865
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 更新`Place`构造函数以包含设置和获取挑战的方法'
- en: '**4**.  Write a function to build place models from the map data'
  id: totrans-866
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**. 编写一个从地图数据构建地点模型的功能'
- en: Currently, you build the map for *The Crypt* manually within the program by
    calling the `Place` constructor for each place you create and then by calling
    methods to add items and exits.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你通过在程序中手动调用`Place`构造函数为每个创建的地点调用方法，然后调用添加项目和出口的方法来构建*The Crypt*的地图。
- en: '[PRE164]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: The map data (the descriptions of places, exits, and items) are bound up with
    the JavaScript that creates the objects used by the game; the only place in the
    code you can find out about map locations is inside calls to the `Place` constructor.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 地图数据（地方、出口和物品的描述）与创建游戏使用的对象的JavaScript绑定在一起；你可以在代码中找到有关地图位置的唯一地方是`Place`构造函数的调用中。
- en: '[PRE165]'
  id: totrans-870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Details about exits and items for places are separated from the places themselves.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 关于地方出口和物品的详细信息与地方本身是分开的。
- en: You saw in [section 14.1](#ch14lev1sec1) that data can be more easily shared
    when represented in a common format; other programs and programming languages
    can read data formatted as simple JavaScript objects but don’t know about your
    `Place` objects. If you separate the raw map data from the constructor function
    and methods like `addItem` and `addExit`, it will be easier to define new maps,
    store them, switch them, and share them ([figure 14.4](#ch14fig04)).
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第14.1节](#ch14lev1sec1)中看到，当数据以通用格式表示时可以更容易地共享；其他程序和编程语言可以读取格式化为简单JavaScript对象的格式，但不知道你的`Place`对象。如果你将原始地图数据与构造函数以及`addItem`和`addExit`等方法分离，将更容易定义新地图、存储它们、切换它们和共享它们（[图14.4](#ch14fig04)）。
- en: Figure 14.4\. Splitting the map data from the map builder makes it easier to
    switch maps.
  id: totrans-873
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在图14.4中，你可以看到将地图数据从地图构建器中分离出来使得切换地图变得更加容易。
- en: '![](14fig04_alt.jpg)'
  id: totrans-874
  prefs: []
  type: TYPE_IMG
  zh: '![](14fig04_alt.jpg)'
- en: To achieve such a separation of data and game code, you have to decide what
    form the data will take and then write a function to convert the data into the
    `Place` models that the game uses.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现数据与游戏代码的这种分离，你必须决定数据将采取什么形式，然后编写一个函数将数据转换为游戏使用的`Place`模型。
- en: 14.2.1\. Map data
  id: totrans-876
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.1. 地图数据
- en: A JavaScript object with a title, a list of places, and the name of the starting
    place will represent each map.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有标题、地点列表和起始地点名称的JavaScript对象将代表每个地图。
- en: '[PRE166]'
  id: totrans-878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Each place within the `places` array will also be an object. The following
    snippet shows one such place:'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: '`places`数组中的每个地方也将是一个对象。以下片段显示了这样一个地方：'
- en: '[PRE167]'
  id: totrans-880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: Each exit is an object with properties for its direction and the title of the
    place to which it leads. The data is compact and readable and keeps items and
    exits with the places to which they belong.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 每个出口都是一个具有方向属性和它所引导的地方名称的对象。数据紧凑且易于阅读，并保持物品和出口与其所属的地方。
- en: The following listing shows a section of map data. The four complete locations
    are on JS Bin.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了地图数据的一部分。四个完整的位置在JS Bin上。
- en: Listing 14.4\. Map data ([http://jsbin.com/qonoje/edit?js,console](http://jsbin.com/qonoje/edit?js,console))
  id: totrans-883
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.4. 地图数据 ([http://jsbin.com/qonoje/edit?js,console](http://jsbin.com/qonoje/edit?js,console))
- en: '![](ch14ex04-0.jpg)'
  id: totrans-884
  prefs: []
  type: TYPE_IMG
  zh: '![](ch14ex04-0.jpg)'
- en: '![](ch14ex04-1.jpg)'
  id: totrans-885
  prefs: []
  type: TYPE_IMG
  zh: '![](ch14ex04-1.jpg)'
- en: The map data is only the description of each place; the constructed `Place`
    models will add the functionality your program expects.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 地图数据只是每个地方的描述；构建的`Place`模型将添加程序期望的功能。
- en: 14.2.2\. Adding challenges to the map data
  id: totrans-887
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.2. 向地图数据添加挑战
- en: '*The Crypt*, as it stands, lets you explore strange new worlds. You can find
    items in exotic locations. You can even pick up those items and add them to your
    hoard. But there’s something missing. Your adventures are more like holidays (albeit
    with a bit of casual theft thrown in). You need to be challenged!'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 如其目前所示，*The Crypt*让你探索奇异的新世界。你可以在异国他乡找到物品。你甚至可以捡起这些物品并将它们添加到你的收藏中。但还有一样东西缺失。你的冒险更像是一次假期（尽管夹杂着一些随意的盗窃）。你需要挑战！
- en: 'To make the game more fun, you add challenges to exits. When trying to go in
    a certain direction, you may be presented with a problem to solve. The game play
    will look something like this:'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使游戏更有趣，你会在出口处添加挑战。当试图向某个方向行进时，你可能会遇到一个需要解决的问题。游戏玩法可能看起来像这样：
- en: '[PRE168]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: The challenge prevented you from going south. To overcome the challenge, you
    had to use a particular item in the direction of the challenge.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战阻止了你向南行进。为了克服挑战，你必须使用特定物品来应对挑战的方向。
- en: '[PRE169]'
  id: totrans-892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: If you don’t have the required item, you have to go adventuring in a different
    direction, overcoming other challenges, until you find the item you need. So,
    how do you create challenges in the game?
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有所需的物品，你必须向不同的方向探险，克服其他挑战，直到找到你需要的物品。那么，你如何在游戏中创建挑战呢？
- en: 'All of the information about an adventure in *The Crypt* needs to be represented
    in its map data. At the moment, the exits from a place are simple:'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 关于《The Crypt》冒险的所有信息都需要在其地图数据中表示。目前，地方的出口很简单：
- en: '[PRE170]'
  id: totrans-895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'They have a direction and the title of the place to which they lead. To add
    a challenge to a particular exit, include a `challenge` property, like this:'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 它们有一个方向和它们所引导的地方的标题。要向特定的出口添加一个挑战，包括一个 `challenge` 属性，如下所示：
- en: '[PRE171]'
  id: totrans-897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[Table 14.1](#ch14table01) lists the properties of the challenge object along
    with their purpose and whether they’re required.'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 14.1](#ch14table01) 列出了挑战对象的属性及其用途和是否必需。'
- en: Table 14.1\. Challenge properties
  id: totrans-899
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 14.1\. 挑战属性
- en: '| Property | What is it for? | Required? |'
  id: totrans-900
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 它是用来做什么的？ | 必需？ |'
- en: '| --- | --- | --- |'
  id: totrans-901
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| message | The message displayed to the player when they try to go in the
    direction of the exit and the challenge has not been overcome | Yes |'
  id: totrans-902
  prefs: []
  type: TYPE_TB
  zh: '| 信息 | 当玩家试图朝向出口的方向移动且挑战尚未克服时，显示给玩家的信息 | 是 |'
- en: '| success | The message displayed to the player when they use the item required
    to overcome the challenge | Yes |'
  id: totrans-903
  prefs: []
  type: TYPE_TB
  zh: '| 成功 | 当玩家使用克服挑战所需的物品时，显示给玩家的信息 | 是 |'
- en: '| failure | The message displayed to the player when they try to use the wrong
    object to overcome the challenge | Yes |'
  id: totrans-904
  prefs: []
  type: TYPE_TB
  zh: '| 失败 | 当玩家试图使用错误的物品克服挑战时，显示给玩家的信息 | 是 |'
- en: '| requires | The item required to overcome the challenge | Yes |'
  id: totrans-905
  prefs: []
  type: TYPE_TB
  zh: '| 需要 | 克服挑战所需的物品 | 是 |'
- en: '| itemConsumed | If the item is removed from the player’s list of items once
    it is used | No |'
  id: totrans-906
  prefs: []
  type: TYPE_TB
  zh: '| 项目消耗 | 一旦使用，项目将从玩家物品列表中移除 | 否 |'
- en: '| damage | The amount subtracted from the player’s health when they try to
    go in the direction of the exit before they have overcome the challenge | No |'
  id: totrans-907
  prefs: []
  type: TYPE_TB
  zh: '| 损伤 | 当玩家在克服挑战之前试图朝向出口的方向移动时，从玩家健康值中减去的数量 | 否 |'
- en: To accommodate the challenges, you need to update the `Place` constructor.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应挑战，你需要更新 `Place` 构造函数。
- en: 14.2.3\. Updating the Place constructor to include challenges
  id: totrans-909
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.3\. 更新 Place 构造函数以包含挑战
- en: You have to update the `Place` model to allow for challenges. It needs an object
    in which to store the challenges, and methods, `addChallenge` and `getChallenge`,
    for adding and retrieving challenges for a specified direction. The next listing
    shows the changes to the `Place` constructor.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须更新 `Place` 模型以允许挑战。它需要一个对象来存储挑战，以及添加和检索指定方向挑战的方法，`addChallenge` 和 `getChallenge`。下一个列表显示了
    `Place` 构造函数的更改。
- en: Listing 14.5\. A Place constructor with challenges ([http://jsbin.com/ruviso/edit?js,console](http://jsbin.com/ruviso/edit?js,console))
  id: totrans-911
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.5\. 带有挑战的 Place 构造函数 ([http://jsbin.com/ruviso/edit?js,console](http://jsbin.com/ruviso/edit?js,console))
- en: '![](258fig01_alt.jpg)'
  id: totrans-912
  prefs: []
  type: TYPE_IMG
  zh: '![](258fig01_alt.jpg)'
- en: You create a private `challenges` object to store any challenges. Just like
    for exits, you use directions as the keys for stored challenges. If a player must
    overcome a challenge before moving south, the details of the challenge will be
    stored in `challenges["south"]`.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建一个私有的 `challenges` 对象来存储任何挑战。就像出口一样，你使用方向作为存储挑战的键。如果玩家在向南移动之前必须克服一个挑战，那么挑战的详细信息将存储在
    `challenges["south"]` 中。
- en: To store a challenge use the `addChallenge` method, and to retrieve a challenge
    for a specified direction use the `getChallenge` method.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 要存储一个挑战，请使用 `addChallenge` 方法，要获取指定方向的挑战，请使用 `getChallenge` 方法。
- en: 14.2.4\. Using the map data to build a game map
  id: totrans-915
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.4\. 使用地图数据构建游戏地图
- en: Your implementation of *The Crypt* uses models created with the `Place` constructor
    linked with exits. Now that your map data is no longer tied up with the game logic,
    you need a way to convert the map into a set of place models.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 你实现 *The Crypt* 时使用的模型是通过 `Place` 构造函数创建的，并通过出口连接。现在，由于你的地图数据不再与游戏逻辑绑定，你需要一种方法将地图转换为一系列的地方模型。
- en: You write a function called `buildMap` that takes a map data object as an argument
    and creates the place models, linked by their exits. It returns the model of the
    first place on the map, the starting point of the game.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 你编写一个名为 `buildMap` 的函数，该函数接受一个地图数据对象作为参数，并创建通过其出口连接的地方模型。它返回地图上第一个地方的模式，即游戏的起点。
- en: '[PRE172]'
  id: totrans-918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[Figure 14.5](#ch14fig05) shows how the `buildMap` function uses `forEach`
    twice: first to create the place models and then to join the models by adding
    exits.'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14.5](#ch14fig05) 展示了 `buildMap` 函数如何两次使用 `forEach`：首先创建地方模型，然后通过添加出口将模型连接起来。'
- en: Figure 14.5\. First, all of the place models are created; then they’re linked
    via their exits.
  id: totrans-920
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 14.5\. 首先，创建所有的地方模型；然后通过它们的出口将它们连接起来。
- en: '![](14fig05_alt.jpg)'
  id: totrans-921
  prefs: []
  type: TYPE_IMG
  zh: '![](14fig05_alt.jpg)'
- en: 'The `buildMap` function is shown in [listing 14.6](#ch14ex06) and follows these
    steps:'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildMap` 函数在 [代码列表 14.6](#ch14ex06) 中展示，并遵循以下步骤：'
- en: '**1**.  Create a model for each place (`buildPlace`)'
  id: totrans-923
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  为每个地方创建一个模型 (`buildPlace`)'
- en: ''
  id: totrans-924
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Call the `Place` constructor with the title and description
  id: totrans-925
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用标题和描述调用 `Place` 构造函数
- en: Add any items to the newly created place model
  id: totrans-926
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向新创建的地点模型添加任何物品
- en: Put the place model in the places store
  id: totrans-927
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将地点模型放入地点存储中
- en: '**2**.  Add the exits and challenges for each place (`buildExits`)'
  id: totrans-928
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 添加每个地点的出口和挑战（`buildExits`）'
- en: ''
  id: totrans-929
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Retrieve the place model from the places store
  id: totrans-930
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从地点存储中检索地点模型
- en: Add an exit to the model for each exit in the place’s data
  id: totrans-931
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为地点数据中的每个出口的模型添加一个出口
- en: Add a challenge for each exit in the place’s data
  id: totrans-932
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为地点数据中的每个出口添加一个挑战
- en: '**3**.  Return the model for the first place in the game'
  id: totrans-933
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 返回游戏中的第一个地点的模型'
- en: Listing 14.6\. The map builder ([http://jsbin.com/paqihi/edit?js,console](http://jsbin.com/paqihi/edit?js,console))
  id: totrans-934
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.6. 地图构建器 ([http://jsbin.com/paqihi/edit?js,console](http://jsbin.com/paqihi/edit?js,console))
- en: '![](ch14ex06-0.jpg)'
  id: totrans-935
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch14ex06-0.jpg)'
- en: '![](ch14ex06-1.jpg)'
  id: totrans-936
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch14ex06-1.jpg)'
- en: The `buildPlace` function converts the data for a single place into a place
    model by using the `Place` constructor. Remember, the game modules use a global
    namespace, `theCrypt` (see [chapter 13](kindle_split_022.html#ch13)), so the constructor
    is accessed via `theCrypt.Place`. Before you can link the place models via their
    exits, all the place models need to exist. You call `buildPlace` for every place
    in the map data by iterating over the `mapData.places` array with `forEach`.
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildPlace` 函数通过使用 `Place` 构造函数将单个地点的数据转换为地点模型。记住，游戏模块使用一个全局命名空间 `theCrypt`（见第
    13 章），因此构造函数通过 `theCrypt.Place` 访问。在你可以通过出口将地点模型链接起来之前，所有地点模型都需要存在。你通过使用 `forEach`
    方法遍历 `mapData.places` 数组为地图数据中的每个地点调用 `buildPlace`。'
- en: '[PRE173]'
  id: totrans-938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: Within `buildPlace`, you add each place you create to the `placesStore` object.
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `buildPlace` 中，你将创建的每个地点添加到 `placesStore` 对象中。
- en: The `buildExits` function assigns the data for a place to a parameter, `placeData`,
    and grabs the matching place model from `placesStore`.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildExits` 函数将一个地点的数据分配给一个参数，`placeData`，并从 `placesStore` 中获取匹配的地点模型。'
- en: '[PRE174]'
  id: totrans-941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'It assigns the model to the `here` variable. Because place models have an `addExit`
    method, you can use `here.addExit` to add exits for the current model. The exits
    data looks like this:'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 它将模型分配给 `here` 变量。因为地点模型有一个 `addExit` 方法，所以你可以使用 `here.addExit` 为当前模型添加出口。出口数据看起来像这样：
- en: '[PRE175]'
  id: totrans-943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: So, `buildExits` runs through the exit data, if it exists, and calls `addExit`
    and `add-Challenge` for each exit it finds.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`buildExits` 函数会遍历出口数据，如果存在，并为每个找到的出口调用 `addExit` 和 `add-Challenge`。
- en: '[PRE176]'
  id: totrans-945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: The `to` property of each exit gives the title of the place to which the exit
    leads. The place model to which the exit leads can thus be found in `placesStore`
    by using `exit.to` as the key.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 每个出口的 `to` 属性给出了出口所指向的地点的标题。因此，可以通过使用 `exit.to` 作为键在 `placesStore` 中找到出口所指向的地点模型。
- en: You add a challenge to every exit, whether or not a challenge is present in
    the map data.
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 你为每个出口添加一个挑战，无论地图数据中是否已经存在挑战。
- en: '[PRE177]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: If there’s no challenge for the exit in the map data, then `exit.challenge`
    will be `undefined`. When you write code to work with challenges in [chapter 16](kindle_split_025.html#ch16),
    you’ll check if a challenge is `undefined` before trying to use it.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 如果地图数据中没有为出口设置挑战，那么 `exit.challenge` 将是 `undefined`。当你编写与第 16 章中的挑战一起工作的代码时，你将在尝试使用挑战之前检查挑战是否为
    `undefined`。
- en: Et voila! By calling `buildPlaces` and `buildExits` for every place, you’ve
    created an interlinked map of place models for intrepid adventurers to explore.
    Will they find riches and glory? Will they discover enlightenment? Or will they
    meet their doom? Well, they’ll need to start somewhere, and that’s why the `buildMap`
    function returns the place model specified as the first model on the map.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 哈哈！通过为每个地点调用 `buildPlaces` 和 `buildExits`，你已经创建了一个相互链接的地点模型地图，供勇敢的探险者探索。他们会发现财富和荣耀吗？他们会发现启迪吗？或者他们会遭遇厄运？好吧，他们需要从某个地方开始，这就是为什么
    `buildMap` 函数返回地图上指定的第一个地点模型。
- en: '[PRE178]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: You’ve successfully separated the map data from the game implementation. The
    data is in a form that can be reused across projects and programming languages.
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经成功地将地图数据与游戏实现分离。这些数据以可以跨项目和编程语言重用的形式存在。
- en: If you follow the JS Bin link for [listing 14.6](#ch14ex06), you’ll see that
    the full code wraps the `buildMap` function in an immediately invoked function
    expression and assigns `buildMap` to your global namespace, `theCrypt`. It’s the
    same mechanism used for all of your modules, so it isn’t shown in the printed
    listing.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击 JS Bin 链接 [列表 14.6](#ch14ex06)，您会看到完整的代码将 `buildMap` 函数包裹在一个立即调用的函数表达式中，并将
    `buildMap` 赋值给您的全局命名空间 `theCrypt`。这是您所有模块使用的相同机制，因此在打印的列表中未显示。
- en: 14.2.5\. Bringing all the pieces together to run the game
  id: totrans-954
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.5. 将所有部件组合起来运行游戏
- en: The game initialization module requires a tiny tweak. Here you update the call
    to `buildMap`, passing it the data from the new map data module.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏初始化模块需要微调。在这里，您更新对 `buildMap` 的调用，传递来自新地图数据模块的数据。
- en: Listing 14.7\. Using the new map builder ([http://jsbin.com/mogano/edit?js,console](http://jsbin.com/mogano/edit?js,console))
  id: totrans-956
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.7. 使用新的地图构建器 ([http://jsbin.com/mogano/edit?js,console](http://jsbin.com/mogano/edit?js,console))
- en: '![](262fig01_alt.jpg)'
  id: totrans-957
  prefs: []
  type: TYPE_IMG
  zh: '![](262fig01_alt.jpg)'
- en: The `buildMap` function returns the place where the adventure begins, and that
    is set as the player’s location.
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildMap` 函数返回冒险开始的地方，并将其设置为玩家的位置。'
- en: You also need to add an HTML `script` element to import the map data module
    in *The Crypt*. The next listing shows the HTML panel for the latest version of
    the game.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要在 *The Crypt* 中添加一个 HTML `script` 元素来导入地图数据模块。下面的列表显示了游戏最新版本的 HTML 面板。
- en: Listing 14.8\. Using the map builder (HTML) ([http://jsbin.com/rulayu/edit?html,console](http://jsbin.com/rulayu/edit?html,console))
  id: totrans-960
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.8. 使用地图构建器（HTML）([http://jsbin.com/rulayu/edit?html,console](http://jsbin.com/rulayu/edit?html,console))
- en: '[PRE179]'
  id: totrans-961
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: Have a play. It should work exactly as it did before, with the two commands
    `game.go` and `game.get` available. You won’t spot the zombie (although it’s there,
    lurking in the shadows of the map data)—you’ll incorporate the challenges into
    the gameplay in [chapter 16](kindle_split_025.html#ch16).
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试玩玩。它应该和之前一样工作，提供两个命令 `game.go` 和 `game.get`。您可能找不到僵尸（尽管它在那里，潜伏在地图数据的阴影中）——您将在第
    16 章（kindle_split_025.html#ch16）中将挑战融入游戏玩法中。
- en: One of the aims of separating map data from the map building code was to more
    easily switch between maps. So because you’ve done so well, here’s the exact same
    game code but with a different map file. (It’s an old Jedi map trick!)
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 将地图数据与地图构建代码分离的一个目标是为了更容易地在地图之间切换。因此，由于您做得很好，这里提供了完全相同的游戏代码，但使用了不同的地图文件。（这是一个古老的绝地武士技巧！）
- en: The Sparrow
  id: totrans-964
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 麻雀
- en: 'Map data: [http://jsbin.com/woniqo/edit?js](http://jsbin.com/woniqo/edit?js)'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 地图数据：[http://jsbin.com/woniqo/edit?js](http://jsbin.com/woniqo/edit?js)
- en: 'Game: [http://jsbin.com/dequzi/edit?console](http://jsbin.com/dequzi/edit?console)'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏：[http://jsbin.com/dequzi/edit?console](http://jsbin.com/dequzi/edit?console)
- en: You can take this whole modularization drive even further and separate the display
    of players and places from the models. [Chapter 15](kindle_split_024.html#ch15)
    guides you on the next leg of your journey.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以将整个模块化驱动进一步分离，将玩家和地点的显示与模型分离。[第 15 章](kindle_split_024.html#ch15) 将引导您进入旅程的下一阶段。
- en: 14.3\. Summary
  id: totrans-968
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3. 概述
- en: Represent data in a form that’s easy to reuse across projects, apps, and programming
    languages. Simple JavaScript objects are a common format for exchanging data on
    the web.
  id: totrans-969
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以一种易于在项目、应用程序和编程语言之间重用的形式表示数据。简单的 JavaScript 对象是网络数据交换的常见格式。
- en: Separate the data from the program logic to make it easier to switch between
    data sources.
  id: totrans-970
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据与程序逻辑分离，以便更容易地在数据源之间切换。
- en: Define models that enhance the data, adding functionality and hiding private
    variables, ready to be used by other parts of your program.
  id: totrans-971
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义增强数据的模型，添加功能并隐藏私有变量，以便其他程序部分使用。
- en: Define functions to create models from the data.
  id: totrans-972
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义函数从数据中创建模型。
- en: 'Chapter 15\. Views: displaying data'
  id: totrans-973
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 15 章. 视图：显示数据
- en: '***This chapter covers***'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: '***本章涵盖的内容***'
- en: Presenting data with views
  id: totrans-975
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用视图展示数据
- en: Removing display code from constructors
  id: totrans-976
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从构造函数中移除显示代码
- en: Passing the same model to multiple views
  id: totrans-977
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将相同的模型传递给多个视图
- en: The console isn’t the only place where you can display information for your
    users; I’m pretty sure you’re keen to see how to output data on a web page! There
    are also desktop and phone applications, emails, and print documents to consider.
    Even on the console you may want the flexibility of a number of different formats
    for your output; maybe you want a simple text version and a fancy version with
    boxes and borders. You don’t want to have to rewrite large portions of your programs
    to change the way they present information.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台并不是唯一可以显示用户信息的地方；我非常确信你很想知道如何在网页上输出数据！还有桌面和手机应用、电子邮件和打印文档需要考虑。即使在控制台上，你可能也希望输出有多个不同格式；也许你想要一个简单的文本版本和一个带有框和边框的华丽版本。你不想重写大量程序来改变它们展示信息的方式。
- en: '*Views* are focused modules of code that concentrate on displaying information.
    They take data and create visual output based on it. They may include controls
    like buttons and text boxes, but you’ll leave that for [part 3](kindle_split_026.html#part03).
    Moving your display code into views lets you switch the type of output you want
    or display data in multiple ways without having to change other parts of your
    code, like the constructor functions for models.'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: '*视图*是专注于显示信息的代码模块。它们根据数据创建视觉输出。它们可能包括按钮和文本框等控件，但那部分内容留到[第3部分](kindle_split_026.html#part03)再讲。将你的显示代码移入视图可以让你切换所需的输出类型或以多种方式显示数据，而无需更改代码的其他部分，比如模型的构造函数。'
- en: In this chapter, you create views in the context of two examples, the fitness
    app and *The Crypt*. For the fitness app, you build a simple console view and
    then an enhanced version using the `spacer` namespace for formatting. For *The
    Crypt*, you separate out the display code that’s currently in the `Player` and
    `Place` constructor functions, moving it into new player and place views.
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将在两个示例的背景下创建视图，即健身应用和*The Crypt*。对于健身应用，你将构建一个简单的控制台视图，然后使用`spacer`命名空间进行格式化来创建一个增强版本。对于*The
    Crypt*，你将分离出目前位于`Player`和`Place`构造函数中的显示代码，将其移动到新的玩家和地点视图中。
- en: All this modularization you’ve been pursuing throughout [part 2](kindle_split_019.html#part02)
    may seem like an uphill struggle, but the flexibility it gives you to update functionality
    by switching simple blocks of code in and out of a project is well worth the effort.
    And the views are magnificent!
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第2部分](kindle_split_019.html#part02)中追求的所有这些模块化可能看起来像是一场艰难的攀登，但通过切换简单代码块来更新功能所提供的灵活性非常值得努力。而且视图非常出色！
- en: 15.1\. Building a fitness app—displaying the latest user data
  id: totrans-982
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1. 构建健身应用——显示最新的用户数据
- en: 'You and your team are hard at work writing a multiplatform fitness app that
    lets users log their exercise. The tasks involved in building the app include:'
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 你和你的团队正在努力编写一个多平台健身应用，让用户记录他们的锻炼。构建应用涉及的任务包括：
- en: '**1**.  Retrieving user data as a string.'
  id: totrans-984
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 以字符串形式检索用户数据。'
- en: '**2**.  Converting user data into user models.'
  id: totrans-985
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 将用户数据转换为用户模型。'
- en: '**3**.  Displaying user data.'
  id: totrans-986
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 显示用户数据。'
- en: '**4**.  Providing an interface for users to add sessions.'
  id: totrans-987
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**. 为用户提供添加会话的界面。'
- en: You’ve already managed to convert a user’s data from a simple JavaScript object
    into a user model with added functionality, including `addSession` and `getData`
    methods (see [chapter 14](kindle_split_023.html#ch14)). Now it’s time to work
    on displaying the user data.
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经成功将用户数据从简单的JavaScript对象转换为具有附加功能（包括`addSession`和`getData`方法）的用户模型（见[第14章](kindle_split_023.html#ch14)）。现在，你需要着手显示用户数据。
- en: You’re going to create two views, code that takes a user model and displays
    data from the model. [Figure 15.1](#ch15fig01) shows how different views can work
    with the same single model to produce different output.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 你将创建两个视图，这些代码接受用户模型并显示模型中的数据。[图15.1](#ch15fig01)展示了不同的视图如何与同一个单一模型协同工作以产生不同的输出。
- en: Figure 15.1\. The same user model is used by different views to produce different
    output.
  id: totrans-990
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图15.1. 同一个用户模型被不同的视图用来产生不同的输出。
- en: '![](15fig01_alt.jpg)'
  id: totrans-991
  prefs: []
  type: TYPE_IMG
  zh: '![](15fig01_alt.jpg)'
- en: You’re going to stick with console views for now, but in [part 3](kindle_split_026.html#part03)
    of *Get Programming with JavaScript,* you’ll switch to views that generate HTML
    for output on a web page.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在将坚持使用控制台视图，但在*用JavaScript编程入门*的[第3部分](kindle_split_026.html#part03)中，你将切换到生成网页输出的视图。
- en: 15.1.1\. Creating your first fitness app view
  id: totrans-993
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.1.1. 创建你的第一个健身应用视图
- en: 'Your first view for the fitness app is simple but effective, displaying user
    information on the console that looks like this:'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 你为健身应用创建的第一个视图简单但有效，在控制台上显示用户信息，看起来像这样：
- en: '[PRE180]'
  id: totrans-995
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'To produce the output you need a view and a user model:'
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 要产生输出，你需要一个视图和一个用户模型：
- en: '[PRE181]'
  id: totrans-997
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-998
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: In the [listing 15.1](#ch15ex01) you define and immediately invoke a function
    that creates the user view, returning a simple interface object. You assign the
    interface to the `userView` variable. To test the view you call `userView.render`,
    which produces the display shown previously.
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表15.1](#ch15ex01)中，你定义并立即调用一个函数来创建用户视图，返回一个简单的接口对象。你将接口分配给`userView`变量。为了测试视图，你调用`userView.render`，它产生了之前显示的显示效果。
- en: Listing 15.1\. A simple user view ([http://jsbin.com/goqinep/edit?js,console](http://jsbin.com/goqinep/edit?js,console))
  id: totrans-1000
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表15.1\. 简单的用户视图([http://jsbin.com/goqinep/edit?js,console](http://jsbin.com/goqinep/edit?js,console))
- en: '![](ch15ex01-0.jpg)'
  id: totrans-1001
  prefs: []
  type: TYPE_IMG
  zh: '![](ch15ex01-0.jpg)'
- en: '![](ch15ex01-1.jpg)'
  id: totrans-1002
  prefs: []
  type: TYPE_IMG
  zh: '![](ch15ex01-1.jpg)'
- en: You wrap the view code in an immediately invoked function expression to create
    a local scope, hiding implementation details, without the need for an extra global
    variable. (See [chapter 13](kindle_split_022.html#ch13) for more on IIFEs and
    the perils of global pollution.)
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 你将视图代码包裹在一个立即调用的函数表达式中，以创建一个局部作用域，隐藏实现细节，无需额外的全局变量。（有关IIFEs和全局污染的弊端，请参阅第13章。）
- en: 'The `User` constructor for user models from [chapter 14](kindle_split_023.html#ch14)
    is included at the start of the listing. The user model provides a `getData` method
    that returns a simple JavaScript object:'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第14章](kindle_split_023.html#ch14)中包含的`User`构造函数用于用户模型。用户模型提供了一个`getData`方法，它返回一个简单的JavaScript对象：
- en: '[PRE183]'
  id: totrans-1005
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: The view’s `getInfo` function uses that data object to build the string of information
    shown before the listing.
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 视图的`getInfo`函数使用该数据对象来构建在列表之前显示的信息字符串。
- en: But why stop at one view when you can have two?
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么只限于一个视图，当你可以有多个视图呢？
- en: 15.1.2\. Using modules to switch fitness app views
  id: totrans-1008
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.1.2\. 使用模块切换健身应用视图
- en: 'Ultimately, you’ll present a number of views to your team from which they’ll
    choose the best to go into production with the fitness app. The second view you
    add to your portfolio uses the formatting functions from the `spacer` namespace
    to add borders and boxes to the view’s output. It’s called `fitnessApp.userViewEnhanced`,
    and you can see the view’s code as a module on JS Bin: [http://jsbin.com/puculi/edit?js,console](http://jsbin.com/puculi/edit?js,console).
    It produces output like this:'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你将向你的团队展示多个观点，他们将从这些观点中选择最佳的一个用于与健身应用一起投入生产。你添加到你的组合中的第二个视图使用了`spacer`命名空间中的格式化功能来为视图的输出添加边框和框。它被称为`fitnessApp.userViewEnhanced`，你可以在JS
    Bin上查看视图的代码作为一个模块：[http://jsbin.com/puculi/edit?js,console](http://jsbin.com/puculi/edit?js,console)。它产生的输出如下：
- en: '[PRE184]'
  id: totrans-1010
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: (The code for the second view is similar to the first. Here, I’m more interested
    in showing how multiple views can be used, so I’ve omitted the second view’s code
    from the book.)
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: （第二个视图的代码与第一个类似。在这里，我更感兴趣的是展示如何使用多个视图，所以我省略了书中第二个视图的代码。）
- en: The next listing shows the HTML `script` elements used to import the `spacer`
    and `fitnessApp` modules. Notice, two view modules are imported.
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 下一列表显示了用于导入`spacer`和`fitnessApp`模块的HTML `script`元素。注意，导入了两个视图模块。
- en: Listing 15.2\. Testing two user views (HTML) ([http://jsbin.com/vamuzu/edit?html,js,console](http://jsbin.com/vamuzu/edit?html,js,console))
  id: totrans-1013
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表15.2\. 测试两个用户视图（HTML）([http://jsbin.com/vamuzu/edit?html,js,console](http://jsbin.com/vamuzu/edit?html,js,console))
- en: '[PRE185]'
  id: totrans-1014
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: The following listing shows the JavaScript used to test the two views you’ve
    created.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了用于测试你创建的两个视图的JavaScript代码。
- en: Listing 15.3\. Testing two user views ([http://jsbin.com/vamuzu/edit?html,js,console](http://jsbin.com/vamuzu/edit?html,js,console))
  id: totrans-1016
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表15.3\. 测试两个用户视图([http://jsbin.com/vamuzu/edit?html,js,console](http://jsbin.com/vamuzu/edit?html,js,console))
- en: '![](268fig01_alt.jpg)'
  id: totrans-1017
  prefs: []
  type: TYPE_IMG
  zh: '![](268fig01_alt.jpg)'
- en: What lovely views! They both work well, displaying data from the same user model,
    so it will be easy to use whichever your team chooses. And it will be easy for
    you or others on the team to create more views if needed (that web view would
    be nice) without having to touch the user model code.
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 多么可爱的视图！它们都工作得很好，显示来自相同用户模型的数据，所以使用哪个团队选择将很容易。而且，如果你或团队中的其他人需要创建更多视图（那个网页视图会很棒），你将很容易做到，而无需触摸用户模型代码。
- en: 15.1.3\. What’s next for the fitness app?
  id: totrans-1019
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.1.3\. 健身应用下一步是什么？
- en: You’ve created user models from data and displayed that data in a number of
    ways using views. Your next job is to give users a simple way to log their exercise
    sessions at the console, getting the views to re-render the display as the data
    changes. You’ll do that by creating a fitness app *controller* in [chapter 16](kindle_split_025.html#ch16).
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经从数据中创建了用户模型，并使用视图以多种方式显示这些数据。您的下一个任务是让用户能够在控制台中简单地记录他们的锻炼课程，随着数据的变化，让视图重新渲染显示。您将通过在[第16章](kindle_split_025.html#ch16)中创建一个健身应用*控制器*来实现这一点。
- en: 15.2\. The Crypt—moving view code from Player and Place
  id: totrans-1021
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2\. 密室——将视图代码从Player和Place移动
- en: In the last section you saw how to create a *view* from scratch. You had a user
    *model* that provided data, and you wrote view code to display the data. In this
    section you work with existing models, `Player` and `Place`, from *The Crypt*.
    The code to display model data is currently mixed in with the models themselves.
    [Figure 15.2](#ch15fig02) shows all of the modules in the current and new versions
    of the game. To change to the new version, you’ll separate the display code from
    the `Player` and `Place` models, creating two views, `playerView` and `placeView`.
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，您看到了如何从头创建一个*视图*。您有一个提供数据的用户*模型*，并且您编写了视图代码来显示数据。在本节中，您使用来自*The Crypt*的现有模型`Player`和`Place`。显示模型数据的代码目前与模型本身混合在一起。[图15.2](#ch15fig02)显示了游戏当前版本和新版本中的所有模块。要切换到新版本，您将显示代码从`Player`和`Place`模型中分离出来，创建两个视图，`playerView`和`placeView`。
- en: Figure 15.2\. Move the view functions from the `Player` and `Place` models into
    their own modules
  id: totrans-1023
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图15.2\. 将视图函数从`Player`和`Place`模型移动到它们自己的模块中
- en: '![](15fig02_alt.jpg)'
  id: totrans-1024
  prefs: []
  type: TYPE_IMG
  zh: '![15fig02_alt.jpg](15fig02_alt.jpg)'
- en: You’ll update players first and then places.
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 您将首先更新玩家，然后更新地点。
- en: 15.2.1\. Creating a view for players
  id: totrans-1026
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.2.1\. 为玩家创建视图
- en: On the left of [figure 15.3](#ch15fig03) are the functions currently defined
    in the `Player` model, before you make any changes. As it stands, the model includes
    six functions (on the top left) for the display of player information. You want
    the model to be concerned only with the management of player data, not with its
    display. The right of [figure 15.3](#ch15fig03) shows an updated `Player` model
    with some extra methods to be added as well as a new module called `playerView`,
    concerned only with the display of player information. You create those two modules
    now.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图15.3](#ch15fig03)的左侧是您在做出任何更改之前在`Player`模型中定义的函数，目前模型包括六个函数（左上角）用于显示玩家信息。您希望模型只关注玩家数据的**管理**，而不是其显示。在[图15.3](#ch15fig03)的右侧显示了更新后的`Player`模型，其中添加了一些额外的方法，以及一个新的名为`playerView`的模块，该模块只关注玩家信息的显示。您现在创建这两个模块。
- en: Figure 15.3\. Move the display functions from the `Player` model into their
    own module.
  id: totrans-1028
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图15.3\. 将显示函数从`Player`模型移动到它们自己的模块中。
- en: '![](15fig03_alt.jpg)'
  id: totrans-1029
  prefs: []
  type: TYPE_IMG
  zh: '![15fig03_alt.jpg](15fig03_alt.jpg)'
- en: The model
  id: totrans-1030
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 模型
- en: Models are more than just data. They provide methods for managing the data—adding,
    deleting, updating—and can prevent direct access to the data. To create a player
    model you call the `Player` constructor with the `new` keyword.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 模型不仅仅是数据。它们提供用于管理数据的方法——添加、删除、更新——并且可以防止直接访问数据。要创建玩家模型，您使用`new`关键字调用`Player`构造函数。
- en: '[PRE186]'
  id: totrans-1032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[Listing 15.4](#ch15ex04) shows the new `Player` constructor. Although you
    don’t want the `Player` model to bother with the display of its data, you do need
    to make that data available to any view that requires it. You still want to protect
    the private data from cheeky tweaks, so you create a method, `getData`, that returns
    a *copy* of the data. The data returned will look like this:'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表15.4](#ch15ex04)显示了新的`Player`构造函数。尽管您不希望`Player`模型担心其数据的显示，但您确实需要让这些数据对任何需要它的视图可用。您仍然想要保护私有数据免受无赖的篡改，因此您创建了一个方法，`getData`，它返回数据的*副本*。返回的数据将如下所示：'
- en: '[PRE187]'
  id: totrans-1034
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'In order to work with challenges in [chapter 16](kindle_split_025.html#ch16),
    you add three more methods to the `Player` constructor: `hasItem`, `removeItem`,
    and `applyDamage`. If you head to JS Bin and run the code for the new constructor,
    you can perform the following actions at the console prompt (responses of `undefined`
    have been left out):'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在[第16章](kindle_split_025.html#ch16)中处理挑战，您在`Player`构造函数中添加了三个更多的方法：`hasItem`、`removeItem`和`applyDamage`。如果您前往JS
    Bin并运行新构造函数的代码，您可以在控制台提示符中执行以下操作（省略了`undefined`的响应）：
- en: 'Create a player, add a couple of items, and get the player’s data:'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个玩家，添加一些项目，并获取玩家的数据：
- en: '[PRE188]'
  id: totrans-1037
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'Use the new item methods to check if the player has an item and to remove an
    item:'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的项目方法来检查玩家是否有物品并移除一个物品：
- en: '[PRE189]'
  id: totrans-1039
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'Apply damage to the player and check their health:'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 对玩家施加伤害并检查他们的健康：
- en: '[PRE190]'
  id: totrans-1041
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Listing 15.4\. The `Player` constructor ([http://jsbin.com/yaneye/edit?js,console](http://jsbin.com/yaneye/edit?js,console))
  id: totrans-1042
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.4\. `Player` 构造函数 ([http://jsbin.com/yaneye/edit?js,console](http://jsbin.com/yaneye/edit?js,console))
- en: '![](ch15ex04-0.jpg)'
  id: totrans-1043
  prefs: []
  type: TYPE_IMG
  zh: '![](ch15ex04-0.jpg)'
- en: '![](ch15ex04-1.jpg)'
  id: totrans-1044
  prefs: []
  type: TYPE_IMG
  zh: '![](ch15ex04-1.jpg)'
- en: The `Player` constructor no longer assigns any display methods to the models
    it creates. The methods that are left from the previous version, `addItem`, `setPlace`,
    and `getPlace`, are purely for managing the player data the model holds. The display
    methods have been moved to the new view object.
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: '`Player` 构造函数不再将其创建的模型分配任何显示方法。从上一个版本中保留的方法，`addItem`、`setPlace` 和 `getPlace`，纯粹是为了管理模型持有的玩家数据。显示方法已移动到新的视图对象。'
- en: Both `hasItem` and `removeItem` use the `indexOf` array method. If a specified
    item is in the `items` array, `indexOf` will return the index of that item. If
    the item is not in the array, `indexOf` will return `-1`.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: '`hasItem` 和 `removeItem` 都使用了 `indexOf` 数组方法。如果指定的项在 `items` 数组中，`indexOf`
    将返回该项的索引。如果该项不在数组中，`indexOf` 将返回 `-1`。'
- en: '[PRE191]'
  id: totrans-1047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: The `removeItem` method also uses `splice` to remove an item from the `items`
    array.
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeItem` 方法也使用 `splice` 从 `items` 数组中移除一个项。'
- en: '[PRE192]'
  id: totrans-1049
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: The first argument to `splice` is the index in the array at which to start removing
    items. The second argument is the number of items to remove. In `removeItem`,
    you want to remove a single specified item, so the second argument to `splice`
    is `1`.
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: '`splice` 的第一个参数是要开始移除项的数组中的索引。第二个参数是要移除的项数。在 `removeItem` 中，你想要移除一个指定的项，所以
    `splice` 的第二个参数是 `1`。'
- en: The view
  id: totrans-1051
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 视图
- en: 'Your player view will re-create the representation that used to be generated
    by the player objects themselves. To display a player, you call the view’s `render`
    method, passing the player model as an argument:'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 你的玩家视图将重新创建以前由玩家对象本身生成的表示。要显示一个玩家，你调用视图的 `render` 方法，并将玩家模型作为参数传递：
- en: '[PRE193]'
  id: totrans-1053
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'The `render` method calls `getInfo`, the function that builds up a string of
    player information, and displays the string returned on the console:'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: '`render` 方法调用 `getInfo` 函数，该函数构建玩家信息字符串，并在控制台上显示返回的字符串：'
- en: '[PRE194]'
  id: totrans-1055
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: The next listing shows the code for `playerView`. The interface assigned to
    `theCrypt .playerView` has the single method, `render`.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了 `playerView` 的代码。分配给 `theCrypt .playerView` 的接口只有一个方法，`render`。
- en: Listing 15.5\. A player view ([http://jsbin.com/zucifu/edit?js,console](http://jsbin.com/zucifu/edit?js,console))
  id: totrans-1057
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.5\. 玩家视图 ([http://jsbin.com/zucifu/edit?js,console](http://jsbin.com/zucifu/edit?js,console))
- en: '![](ch15ex05-0.jpg)'
  id: totrans-1058
  prefs: []
  type: TYPE_IMG
  zh: '![](ch15ex05-0.jpg)'
- en: '![](ch15ex05-1.jpg)'
  id: totrans-1059
  prefs: []
  type: TYPE_IMG
  zh: '![](ch15ex05-1.jpg)'
- en: '`render` is the only function that produces any output that the user can see,
    logging the generated player information string to the console. In it, you pass
    the player’s data to `getInfo`, and it passes the data on to the helper functions
    that each build a part of the overall information string.'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: '`render` 是唯一一个产生用户可以看到的输出的函数，它将生成的玩家信息字符串记录到控制台上。在其中，你将玩家的数据传递给 `getInfo`，然后它将数据传递给辅助函数，每个函数都构建整体信息字符串的一部分。'
- en: You’ve split the player model from the player view. You’ll see in [chapter 17](kindle_split_027.html#ch17)
    how easy it is to change the view so it displays the player information on a web
    page rather than on the console. First, you follow the steps you used for players
    to create a model and a view for places in *The Crypt*.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经将玩家模型从玩家视图中分离出来。你将在[第 17 章](kindle_split_027.html#ch17)中看到，如何轻松地更改视图，使其在网页上显示玩家信息而不是在控制台上。首先，你遵循为玩家创建模型和视图的步骤，在
    *The Crypt* 中创建地点的模型和视图。
- en: 15.2.2\. Creating a view for places
  id: totrans-1062
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.2.2\. 为地点创建视图
- en: Just as you did for players in the last section, you rewrite the constructor
    function for places so that it creates models that hold the data for each place
    and that provide some methods for manipulating that data. The models will also
    have a `getData` method so that views can get hold of a copy of each place’s data
    for display. Then you create a view to log place data on the console. [Figure
    15.4](#ch15fig04) shows how the old model code will be split to form the new.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上一节中对玩家所做的那样，你重新编写了地点的构造函数，以便它创建包含每个地点数据的模型，并提供一些用于操作这些数据的方法。这些模型还将有一个 `getData`
    方法，以便视图可以获取每个地点数据的副本以进行显示。然后你创建一个视图来在控制台上记录地点数据。[图 15.4](#ch15fig04) 显示了旧模型代码将如何拆分以形成新的。
- en: Figure 15.4\. Move the display functions from the `Place` model into their own
    module
  id: totrans-1064
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 15.4\. 将显示函数从 `Place` 模型移动到它们自己的模块
- en: '![](15fig04_alt.jpg)'
  id: totrans-1065
  prefs: []
  type: TYPE_IMG
  zh: '![](15fig04_alt.jpg)'
- en: The model
  id: totrans-1066
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 模型
- en: '[Listing 15.6](#ch15ex06) shows a new version of the `Place` constructor, with
    its presentation code removed and a `getData` method added. The data returned
    by `getData` will have this form:'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表15.6](#ch15ex06)显示了一个新的`Place`构造函数版本，其中移除了展示代码并添加了`getData`方法。`getData`返回的数据将具有以下形式：'
- en: '[PRE195]'
  id: totrans-1068
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: The other methods are unchanged from previous incarnations of the constructor.
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 其他方法与构造函数的先前版本保持不变。
- en: Listing 15.6\. A simplified `Place` constructor ([http://jsbin.com/vuwave/edit?js,console](http://jsbin.com/vuwave/edit?js,console))
  id: totrans-1070
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表15.6. 简化的`Place`构造函数 ([http://jsbin.com/vuwave/edit?js,console](http://jsbin.com/vuwave/edit?js,console))
- en: '![](ch15ex06-0.jpg)'
  id: totrans-1071
  prefs: []
  type: TYPE_IMG
  zh: '![](ch15ex06-0.jpg)'
- en: '![](ch15ex06-1.jpg)'
  id: totrans-1072
  prefs: []
  type: TYPE_IMG
  zh: '![](ch15ex06-1.jpg)'
- en: Each place model links to destinations. The destinations are also place models.
    The destinations are stored in a place model’s `exits` object. The keys of the
    `exits` object are the directions of the destinations. For example, `exits["south"]`
    might be the place model with a `title` property of `"The Old Library"`. The `Object.keys`
    method returns all of the keys of an object as an array. So, `Object.keys(exits)`
    returns all of the directions of exits from the current place, for example, `["south",
    "east", "west"]`.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 每个地点模型都链接到目的地。目的地也是地点模型。目的地存储在地点模型的`exits`对象中。`exits`对象的键是目的地的方向。例如，`exits["south"]`可能是一个具有`title`属性为`"The
    Old Library"`的地点模型。`Object.keys`方法返回一个对象的所有键的数组。因此，`Object.keys(exits)`返回从当前位置出发的所有出口方向，例如，`["south",
    "east", "west"]`。
- en: The `getData` method in the `Place` constructor returns a copy of some of the
    data about a place, including an array of exit directions generated by using `Object
    .keys(exits)`. The view will use that array to display the available exits from
    which players can choose to continue their adventures.
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Place`构造函数中的`getData`方法返回关于某个地点的一些数据的副本，包括使用`Object .keys(exits)`生成的出口方向数组。视图将使用该数组来显示玩家可以选择继续冒险的可用出口。
- en: The view
  id: totrans-1075
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 视图
- en: '[Listing 15.7](#ch15ex07) shows the code for the place view module. How it
    works should be pretty familiar by now. It produces output on the console like
    this:'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表15.7](#ch15ex07)显示了地点视图模块的代码。它的工作原理现在应该很熟悉了。它会在控制台上产生如下输出：'
- en: '[PRE196]'
  id: totrans-1077
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: Listing 15.7\. A place view ([http://jsbin.com/royine/edit?js,console](http://jsbin.com/royine/edit?js,console))
  id: totrans-1078
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表15.7. 地点视图 ([http://jsbin.com/royine/edit?js,console](http://jsbin.com/royine/edit?js,console))
- en: '![](ch15ex07-0.jpg)'
  id: totrans-1079
  prefs: []
  type: TYPE_IMG
  zh: '![](ch15ex07-0.jpg)'
- en: '![](ch15ex07-1.jpg)'
  id: totrans-1080
  prefs: []
  type: TYPE_IMG
  zh: '![](ch15ex07-1.jpg)'
- en: Just like the view module for players, the view for places calls some helper
    functions, in this case `getItemsInfo`, `getExitsInfo`, and `getTitleInfo`, from
    a main display function, `getInfo`, to build up a string of information about
    a model. The `render` function is the only one that produces output that the user
    can see, displaying the assembled place information on the console.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 就像玩家视图模块一样，地点视图调用了一些辅助函数，在这种情况下是从主显示函数`getInfo`中调用的`getItemsInfo`、`getExitsInfo`和`getTitleInfo`，以构建关于模型的信息字符串。`render`函数是唯一一个产生用户可以看到的输出的函数，它在控制台上显示组装好的地点信息。
- en: You now have model constructors and views for players and places. The data and
    the presentation of the data have been separated. The models are concerned only
    with the manipulation of the data and have nothing to do with its display. The
    views are concerned only with displaying the data and have nothing to do with
    changing it.
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了玩家和地点的模型构造函数和视图。数据和数据的展示已经被分离。模型只关注数据的操作，与展示无关。视图只关注展示数据，与更改数据无关。
- en: 'The views have been written to be used in the same way. They both have a `render`
    method that’s passed the model to be displayed, as shown in the following snippet:'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 视图被编写成可以以相同的方式使用。它们都包含一个`render`方法，该方法传递要显示的模型，如下面的代码片段所示：
- en: '[PRE197]'
  id: totrans-1084
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: As well as displaying information about players and places, you need to display
    messages to users as they play the game. They probably want to know if they’ve
    been bitten by a zombie or lacerated by a leopard!
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 除了显示玩家和地点的信息外，你还需要在玩家玩游戏时显示消息。他们可能想知道是否被僵尸咬了或者被豹子划伤了！
- en: 15.3\. Talking to players—a message view
  id: totrans-1086
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3. 与玩家交流——消息视图
- en: As adventurers make their way around *The Crypt*, you need to let them know
    what’s going on. You use the player view to give them updates on their health
    and the items they carry. You use the place view to display each place’s title
    and description and to list its items and exits. You also need a way of displaying
    feedback when the players attempt an invalid action or succumb to their injuries.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 当冒险者在*The Crypt*中四处走动时，你需要让他们知道发生了什么。你使用玩家视图来更新他们的健康和携带的物品。你使用地点视图来显示每个地点的标题和描述，并列出其物品和出口。你还需要一种方式来显示当玩家尝试无效操作或因受伤而屈服时的反馈。
- en: '[PRE198]'
  id: totrans-1088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'To handle such messages, you create a message view. Like your other views,
    it has a single method in its public interface, `render`. You pass the text to
    be displayed to the `render` method:'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理此类消息，你创建一个消息视图。像你的其他视图一样，它在公共接口中有一个单独的方法，`render`。你将显示的文本传递给`render`方法：
- en: '[PRE199]'
  id: totrans-1090
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: The next listing shows the code for the view. The local `getMessageInfo` function
    returns a string for display, and the `render` function logs it to the console.
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了视图的代码。本地的`getMessageInfo`函数返回一个用于显示的字符串，而`render`函数将其记录到控制台。
- en: Listing 15.8\. A message view ([http://jsbin.com/jatofe/edit?js,console](http://jsbin.com/jatofe/edit?js,console))
  id: totrans-1092
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表15.8\. 消息视图（[http://jsbin.com/jatofe/edit?js,console](http://jsbin.com/jatofe/edit?js,console)）
- en: '![](278fig01_alt.jpg)'
  id: totrans-1093
  prefs: []
  type: TYPE_IMG
  zh: '![图片](278fig01_alt.jpg)'
- en: You use the `console.error` method in the `render` function. It’s similar to
    `console .log` but developers use it to flag errors in programs. The console normally
    displays errors differently from standard logged messages. The errors are often
    shown in red. That suits your purposes for displaying messages to players on the
    console.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 你在`render`函数中使用`console.error`方法。它与`console.log`类似，但开发者用它来标记程序中的错误。控制台通常以与标准日志消息不同的方式显示错误。错误通常以红色显示。这符合你在控制台上向玩家显示消息的目的。
- en: In [chapter 14](kindle_split_023.html#ch14) you added challenges to the map
    data for *The Crypt*. You’ll use the message view to display the various success
    and failure messages associated with each challenge. Knowing when to show those
    messages requires some code that checks user actions against challenges, updates
    player and place models as a result, and uses views to display the latest state
    of the game. You need *controllers*. [Chapter 16](kindle_split_025.html#ch16)
    has you covered.
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第14章](kindle_split_023.html#ch14)中，你为*The Crypt*的地图数据添加了挑战。你将使用消息视图来显示与每个挑战相关的各种成功和失败消息。知道何时显示这些消息需要一些代码来检查用户操作与挑战，根据结果更新玩家和地点模型，并使用视图显示游戏的最新状态。你需要*控制器*。[第16章](kindle_split_025.html#ch16)将为你提供解决方案。
- en: 15.4\. Summary
  id: totrans-1096
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.4\. 摘要
- en: Create views to display data from models.
  id: totrans-1097
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建视图以显示模型数据。
- en: Maintain a separation of concerns where models manipulate data and views display
    data.
  id: totrans-1098
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持关注点的分离，模型操作数据，视图显示数据。
- en: Create multiple views to display the same model data in different ways.
  id: totrans-1099
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建多个视图以不同的方式显示相同模型数据。
- en: 'Keep the interface consistent for all views. For example, all of the views
    in this chapter have a `render` method as their interface. They can all be called
    the same way:'
  id: totrans-1100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持所有视图的接口一致。例如，本章中的所有视图都使用`render`方法作为接口。它们都可以以相同的方式调用：
- en: '[PRE200]'
  id: totrans-1101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'Chapter 16\. Controllers: linking models and views'
  id: totrans-1102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第16章\. 控制器：连接模型和视图
- en: '***This chapter covers***'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: '***本章涵盖***'
- en: Acting on user input
  id: totrans-1104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对用户输入采取行动
- en: Updating models in response to user actions
  id: totrans-1105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据用户操作更新模型
- en: Passing updated models to views for display
  id: totrans-1106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将更新的模型传递给视图进行显示
- en: Completing the console version of *The Crypt*
  id: totrans-1107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成*The Crypt*的控制台版本
- en: '[Part 2](kindle_split_019.html#part02) of *Get Programming with JavaScript*
    has been about organizing your code. As your programs grow, that organization
    pays dividends, making it easier to focus on individual pieces, switch modules
    to alter functionality, and reuse code in multiple projects.'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: '*《用JavaScript编程入门》*的第二部分（[Part 2](kindle_split_019.html#part02)）是关于组织你的代码。随着你的程序增长，这种组织会带来回报，使你更容易关注单个部分，切换模块以改变功能，并在多个项目中重用代码。'
- en: Breaking programs into modules encourages you to give each module a specific
    task. [Chapters 14](kindle_split_023.html#ch14), [15](kindle_split_024.html#ch15),
    and [16](#ch16) form a trilogy, with each chapter looking at a common task a module
    might perform. You met *models* in [chapter 14](kindle_split_023.html#ch14) and
    *views* in [chapter 15](kindle_split_024.html#ch15) and now you link them with
    *controllers*.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 将程序分解为模块可以鼓励你为每个模块分配一个特定的任务。[第14章](kindle_split_023.html#ch14)、[第15章](kindle_split_024.html#ch15)和[第16章](#ch16)构成三部曲，每章都探讨一个模块可能执行的共同任务。你在[第14章](kindle_split_023.html#ch14)中遇到了*模型*，在[第15章](kindle_split_024.html#ch15)中遇到了*视图*，现在你将它们与*控制器*联系起来。
- en: 'To see controllers in action and how they act on user input to manage models
    and update views, you continue your work on two projects: the fitness app and
    *The Crypt*. In the fitness app, users will log sessions of exercise, and in *The
    Crypt,* players will face puzzles to solve as they explore perilous places. But
    will they escape before their health reaches zero?'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看控制器的作用以及它们如何对用户输入做出反应来管理模型并更新视图，你将继续在两个项目中工作：健身应用和*The Crypt*。在健身应用中，用户将记录锻炼会话，而在*The
    Crypt*中，玩家将面对在探索危险地方时需要解决的谜题。但他们能在健康值降到零之前逃脱吗？
- en: 16.1\. Building a fitness app—controllers
  id: totrans-1111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.1\. 构建健身应用—控制器
- en: 'Your team members have been telling friends and family about the fitness app
    you’re creating and they have a list of people lined up to test it out; they’re
    a super-keen bunch and have been diligently logging their exercise on paper. Your
    work has gone well so far—what’s left to do? Here are the requirements set out
    by the team:'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 你的团队成员一直在向朋友和家人介绍你正在创建的健身应用，他们已经排好了一长串的人来试用它；他们是一群超级热情的人，一直在认真地记录他们的锻炼情况。到目前为止，你的工作进展顺利—接下来还有什么要做？以下是团队设定的要求：
- en: '**1**.  Retrieve user data as a string.'
  id: totrans-1113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 将用户数据作为字符串检索。'
- en: '**2**.  Convert user data into user models.'
  id: totrans-1114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 将用户数据转换为用户模型。'
- en: '**3**.  Display user data.'
  id: totrans-1115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 显示用户数据。'
- en: '**4**.  Provide an interface for users to add sessions.'
  id: totrans-1116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**. 为用户提供添加会话的界面。'
- en: You’ve completed tasks 2 and 3, building models in [chapter 14](kindle_split_023.html#ch14)
    and views in [chapter 15](kindle_split_024.html#ch15). Task 1 involves retrieving
    data across the internet—you’ll work on that in [part 3](kindle_split_026.html#part03).
    That leaves task 4—you need to provide a simple way for those eager fitness fanatics
    to log the sessions of exercise they complete.
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经完成了任务2和3，在[第14章](kindle_split_023.html#ch14)中构建了模型，在[第15章](kindle_split_024.html#ch15)中构建了视图。任务1涉及从互联网检索数据—你将在[第3部分](kindle_split_026.html#part03)中处理这项工作。这留下了任务4—你需要为那些渴望的健身爱好者提供一个简单的方法来记录他们完成的锻炼会话。
- en: 'You decide to provide a single command for users of the app to log their activity:'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 你决定为应用用户提供一个单独的命令来记录他们的活动：
- en: '[PRE201]'
  id: totrans-1119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: The users call the `app.log` method, passing in the date of their session and
    the duration of their exercise in minutes. But how does that command reach the
    user model? And how does the view know to update the display? That’s the job of
    the *controller*.
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 用户调用`app.log`方法，传入会话的日期和锻炼的分钟数。但是，这个命令是如何到达用户模型的？视图又是如何知道更新显示的？这就是*控制器*的工作。
- en: 16.1.1\. What does the controller do?
  id: totrans-1121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.1.1\. 控制器执行什么操作？
- en: The controller orchestrates the other pieces of the program, reacting to user
    input and updating the models and views. [Figure 16.1](#ch16fig01) shows the modules
    that your fitness app will load when opened in JS Bin. You already have data,
    the `User` constructor, and views from [chapters 14](kindle_split_023.html#ch14)
    and [15](kindle_split_024.html#ch15). You need to create a controller to handle
    the interactions between the different parts.
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器协调程序的其他部分，对用户输入做出反应，并更新模型和视图。[图16.1](#ch16fig01)显示了在JS Bin中打开时健身应用将加载的模块。你已经有了数据、`User`构造函数和来自[第14章](kindle_split_023.html#ch14)和[第15章](kindle_split_024.html#ch15)的视图。你需要创建一个控制器来处理不同部分之间的交互。
- en: Figure 16.1\. The four modules of the fitness app
  id: totrans-1123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图16.1\. 健身应用的四模块
- en: '![](16fig01_alt.jpg)'
  id: totrans-1124
  prefs: []
  type: TYPE_IMG
  zh: '![](16fig01_alt.jpg)'
- en: '[Figure 16.2](#ch16fig02) shows how your controller is involved in initializing
    the app, using the `User` constructor to build a user model from the data. And
    when the app is running, the controller reacts to users calling `app.log` by adding
    the logged session to the user model and then passing the updated model to the
    view for display.'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: '[图16.2](#ch16fig02)显示了你的控制器如何参与初始化应用，使用`User`构造函数从数据中构建用户模型。当应用运行时，控制器会响应用户调用`app.log`，将记录的会话添加到用户模型中，然后将更新的模型传递给视图进行显示。'
- en: Figure 16.2\. The tasks the controller performs in the fitness app
  id: totrans-1126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 16.2\. 控制器在健身应用中执行的任务
- en: '![](16fig02_alt.jpg)'
  id: totrans-1127
  prefs: []
  type: TYPE_IMG
  zh: '![](16fig02_alt.jpg)'
- en: You know what the controller needs to do; how will you make it do it?
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道控制器需要做什么；你将如何让它做到这一点？
- en: 16.1.2\. Building the fitness app controller
  id: totrans-1129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.1.2\. 构建健身应用控制器
- en: 'The snippets that follow show the kind of code you’d expect to see in the controller:'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段展示了你可能会在控制器中看到的代码类型：
- en: '[PRE202]'
  id: totrans-1131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: The first listing shows the full code for the controller.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个列表显示了控制器的完整代码。
- en: Listing 16.1\. The fitness app controller ([http://jsbin.com/goniro/edit?js,console](http://jsbin.com/goniro/edit?js,console))
  id: totrans-1133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 16.1\. 健身应用控制器 ([http://jsbin.com/goniro/edit?js,console](http://jsbin.com/goniro/edit?js,console))
- en: '![](ch16ex01-0.jpg)'
  id: totrans-1134
  prefs: []
  type: TYPE_IMG
  zh: '![](ch16ex01-0.jpg)'
- en: '![](ch16ex01-1.jpg)'
  id: totrans-1135
  prefs: []
  type: TYPE_IMG
  zh: '![](ch16ex01-1.jpg)'
- en: When the controller module is loaded, it adds its `init` function to the `fitnessApp`
    namespace. You’ll be able to start the app by calling `init` and passing it the
    user data.
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 当控制器模块被加载时，它会将它的 `init` 函数添加到 `fitnessApp` 命名空间中。你可以通过调用 `init` 并传递用户数据来启动应用。
- en: '[PRE203]'
  id: totrans-1137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: The `init` function returns an interface with a single method, `log`. By assigning
    the returned interface to `app`, you let users record their sessions by calling
    `app.log`.
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: '`init` 函数返回一个包含单个方法 `log` 的接口。通过将返回的接口分配给 `app`，你可以让用户通过调用 `app.log` 来记录他们的会话。'
- en: 16.1.3\. Putting the pieces together for a working fitness app
  id: totrans-1139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.1.3\. 组装组件以创建一个可工作的健身应用
- en: '[Listings 16.2](#ch16ex02) and [16.3](#ch16ex03) show the HTML and JavaScript
    for the fitness app on JS Bin. Running the program lets you log a session like
    this:'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 16.2](#ch16ex02) 和 [16.3](#ch16ex03) 展示了 JS Bin 上的健身应用的 HTML 和 JavaScript
    代码。运行程序让你可以记录像这样的会话：'
- en: '[PRE204]'
  id: totrans-1141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'The controller adds your logged session to the user model and passes the updated
    model to the view, producing this output:'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器将你的记录的会话添加到用户模型中，并将更新后的模型传递给视图，产生以下输出：
- en: '[PRE205]'
  id: totrans-1143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: The following listing uses HTML `script` elements to load your four fitness
    app modules. The modules share properties, objects, and functions by assigning
    them to the `fitnessApp` namespace.
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表使用 HTML `script` 元素来加载你的四个健身应用模块。这些模块通过将它们分配给 `fitnessApp` 命名空间来共享属性、对象和函数。
- en: Listing 16.2\. The fitness app (HTML) ([http://jsbin.com/huxuti/edit?html,js,console](http://jsbin.com/huxuti/edit?html,js,console))
  id: totrans-1145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 16.2\. 健身应用（HTML）([http://jsbin.com/huxuti/edit?html,js,console](http://jsbin.com/huxuti/edit?html,js,console))
- en: '[PRE206]'
  id: totrans-1146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: The next listing shows the single line of JavaScript needed to initialize the
    program and make the `app.log` method available to users.
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表展示了初始化程序并使 `app.log` 方法对用户可用的所需单行 JavaScript 代码。
- en: Listing 16.3\. The fitness app ([http://jsbin.com/huxuti/edit?js,console](http://jsbin.com/huxuti/edit?js,console))
  id: totrans-1148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 16.3\. 健身应用 ([http://jsbin.com/huxuti/edit?js,console](http://jsbin.com/huxuti/edit?js,console))
- en: '[PRE207]'
  id: totrans-1149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: Run the program and have a go at logging some sessions.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序并尝试记录一些会话。
- en: 16.1.4\. What’s next for the fitness app?
  id: totrans-1151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.1.4\. 健身应用下一步是什么？
- en: The last step for your app is to grab user data as text from across the internet
    and then convert that text into a JavaScript object ready to pass to `fitnessApp.init`.
    You’ll return to your work on the app in [chapter 20](kindle_split_030.html#ch20).
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用的最后一步是从互联网上获取用户数据作为文本，然后将其转换为 JavaScript 对象，以便传递给 `fitnessApp.init`。你将在第
    20 章中返回到你对应用的工作。[章节 20](kindle_split_030.html#ch20)。
- en: 16.2\. The Crypt—adding a game controller
  id: totrans-1153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.2\. 密码库——添加游戏控制器
- en: 'Okay, this is it for *The Crypt* in [part 2](kindle_split_019.html#part02)
    of *Get Programming with JavaScript*. By the end of the chapter, you’ll have a
    working console app with challenges for players to overcome and the danger of
    their health falling to zero, ending the game. There’s one more piece of the puzzle
    needed to get the game fully working: a controller.'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这是《用 JavaScript 编程入门》第二部分中的 *The Crypt* 的全部内容。到本章结束时，你将拥有一个带有挑战供玩家克服以及健康降至零的风险的运行控制台应用，结束游戏。为了使游戏完全运行，还需要一个额外的拼图：一个控制器。
- en: You have the data, the models, and the views for *The Crypt*. The *controller*
    is the module that ties everything together. It feeds the map data to the map
    builder and passes the model data to the views. It provides the interface that
    users will access to play the game and responds to player commands. That’s quite
    a lot of jobs for one game module, so it’s worth taking a minute to see how it
    fits in with the other modules that make up *The Crypt*.
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 你有《密室》的数据、模型和视图。`controller`是连接一切的模块。它将地图数据传递给地图构建器，并将模型数据传递给视图。它提供了用户访问以玩游戏和响应玩家命令的接口。对于一个游戏模块来说，这确实有很多工作要做，所以花一分钟看看它如何与其他构成《密室》的模块相匹配是值得的。
- en: '[Figure 16.3](#ch16fig03) shows all of the modules that make up *The Crypt*.
    The `Controller` module has replaced the module that used to be labelled “Game
    init.” Now that you’re working with models and views, it’s more appropriate to
    call the module a controller. But why? What does the controller do?'
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: '[图16.3](#ch16fig03) 展示了构成《密室》的所有模块。`Controller`模块已取代了之前标记为“游戏初始化”的模块。现在你正在使用模型和视图，将模块称为控制器更为合适。但为什么？控制器做什么？'
- en: Figure 16.3\. The modules that make up *The Crypt*
  id: totrans-1157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图16.3\. 构成《密室》的模块
- en: '![](16fig03_alt.jpg)'
  id: totrans-1158
  prefs: []
  type: TYPE_IMG
  zh: '![图16.3](16fig03_alt.jpg)'
- en: 16.2.1\. What does the controller do?
  id: totrans-1159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.2.1\. 控制器做什么？
- en: Your controller will initialize the game and act on user input while the game
    is running, updating models and views in response to the players’ actions.
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 你的控制器将在游戏运行时初始化游戏并对用户输入采取行动，根据玩家的动作更新模型和视图。
- en: Initialize the game
  id: totrans-1161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 初始化游戏
- en: 'When the game first loads, the controller will:'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏首次加载时，控制器将：
- en: '**1**.  Use the `Place` constructor to build place models from the map data.'
  id: totrans-1163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  使用`Place`构造函数从地图数据中构建地点模型。'
- en: '**2**.  Use the `Player` constructor to build a player model.'
  id: totrans-1164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  使用`Player`构造函数构建玩家模型。'
- en: '**3**.  Assign the place specified as first in the map data as the player’s
    location.'
  id: totrans-1165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**.  将地图数据中指定的第一个地点分配为玩家的位置。'
- en: '**4**.  Provide a UI.'
  id: totrans-1166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**.  提供用户界面。'
- en: Steps 1 and 2 are shown in [figure 16.4](#ch16fig04).
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤1和2在[图16.4](#ch16fig04)中展示。
- en: Figure 16.4\. When the game loads, the controller builds the player and place
    models.
  id: totrans-1168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图16.4\. 当游戏加载时，控制器构建玩家和放置模型。
- en: '![](16fig04_alt.jpg)'
  id: totrans-1169
  prefs: []
  type: TYPE_IMG
  zh: '![图16.4](16fig04_alt.jpg)'
- en: Act on user input
  id: totrans-1170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 对用户输入采取行动
- en: 'While the game is running, the controller will:'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏运行期间，控制器将：
- en: '**1**.  Check that player actions are valid.'
  id: totrans-1172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  检查玩家动作是否有效。'
- en: '**2**.  Update player and place models.'
  id: totrans-1173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  更新玩家和地点模型。'
- en: '**3**.  Pass updated models to views for display.'
  id: totrans-1174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**.  将更新后的模型传递给视图进行显示。'
- en: '**4**.  Pass feedback messages to the message view.'
  id: totrans-1175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**.  将反馈消息传递给消息视图。'
- en: '**5**.  Stop the game if the player’s health reaches zero.'
  id: totrans-1176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**.  如果玩家的健康值达到零，停止游戏。'
- en: Steps 2, 3, and 4 are shown in [figure 16.5](#ch16fig05).
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤2、3和4在[图16.5](#ch16fig05)中展示。
- en: Figure 16.5\. The controller responds to user actions and updates models and
    views.
  id: totrans-1178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图16.5\. 控制器响应用户操作并更新模型和视图。
- en: '![](16fig05_alt.jpg)'
  id: totrans-1179
  prefs: []
  type: TYPE_IMG
  zh: '![图16.5](16fig05_alt.jpg)'
- en: The player model includes a `getPlace` method that the controller uses to access
    the player’s current location (notice how the `Place` model is connected to the
    `Player` model in [figure 16.5](#ch16fig05)).
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家模型包含一个`getPlace`方法，控制器使用它来访问玩家的当前位置（注意`Place`模型如何在[图16.5](#ch16fig05)中连接到`Player`模型）。
- en: 16.2.2\. Approaching the controller code
  id: totrans-1181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.2.2\. 接近控制器代码
- en: You’ve seen what the controller does in *The Crypt* and are ready to explore
    the code that makes it work. Even though you’ve seen a lot of the code before,
    presenting it as one long listing can make it seem more daunting than it deserves,
    so your exploration is broken across sections.
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了《密室》中的控制器是如何工作的，并准备好探索使其工作的代码。尽管你之前已经看到了很多代码，但将其作为一段长列表展示可能会让它显得比实际更令人畏惧，所以你的探索被分成了几个部分。
- en: (16.3) The overall structure of the controller
  id: totrans-1183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (16.3) 控制器的整体结构
- en: (16.4) Initializing the game, monitoring player health, updating the display,
    and ending the game
  id: totrans-1184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (16.4) 初始化游戏、监控玩家健康、更新显示和结束游戏
- en: (16.5) Handling player commands and challenges—`get`, `go`, and `use`
  id: totrans-1185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (16.5) 处理玩家命令和挑战——`get`、`go`和`use`
- en: (16.6) Running the game
  id: totrans-1186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (16.6) 运行游戏
- en: Let the games begin!
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 让游戏开始吧！
- en: 16.3\. The Crypt—the structure of the controller code
  id: totrans-1188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.3\. 《密室》——控制器代码的结构
- en: As you’ve seen, the controller has a number of tasks to perform to start, monitor,
    and end a game in *The Crypt*. To help you get a feel for how the parts make up
    the whole, [listing 16.4](#ch16ex04) omits the function bodies and focuses on
    the variables in the code. You can see the full listing, function bodies and all,
    by following the link to JS Bin, and the code is also shown in the sections that
    follow in this chapter.
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，控制器在《地牢》中执行许多任务以开始、监控和结束游戏。为了帮助你了解各个部分如何组成整体，[列表16.4](#ch16ex04)省略了函数体，专注于代码中的变量。你可以通过点击JS
    Bin的链接查看完整的列表，函数体和代码也将在本章后续部分展示。
- en: Listing 16.4\. The game controller ([http://jsbin.com/yeqicu/edit?js](http://jsbin.com/yeqicu/edit?js))
  id: totrans-1190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表16.4\. 游戏控制器 ([http://jsbin.com/yeqicu/edit?js](http://jsbin.com/yeqicu/edit?js))
- en: '![](287fig01_alt.jpg)'
  id: totrans-1191
  prefs: []
  type: TYPE_IMG
  zh: '![图片](287fig01_alt.jpg)'
- en: '[Listing 16.4](#ch16ex04) also includes comments pointing you to the listings
    in this chapter that investigate the missing function bodies.'
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表16.4](#ch16ex04)还包括注释，指导你查看本章中调查缺失函数体的列表。'
- en: It’s time to start the game! And stop it! And monitor player health! And update
    the display! (Sorry for the excitement, but the full game is so close.)
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始游戏了！停止它！监控玩家健康！更新显示！（抱歉这么兴奋，但完整的游戏即将完成。）
- en: 16.4\. The Crypt—starting and stopping the game
  id: totrans-1194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.4\. 地牢——开始和停止游戏
- en: While the main game action takes place in the `get`, `go`, and `use` functions,
    you also need to easily start and stop the game and keep the display updated with
    the latest info. And now that players are facing cruel challenges, challenges
    that may drain their health, you need to check that they are still hale and hearty
    enough to carry on.
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然主要游戏动作发生在`get`、`go`和`use`函数中，但你还需要轻松地开始和停止游戏，并保持显示最新信息。现在玩家面临着残酷的挑战，这些挑战可能会耗尽他们的健康，你需要检查他们是否仍然足够健康和强壮以继续游戏。
- en: 16.4.1\. Initializing the game
  id: totrans-1196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.4.1\. 初始化游戏
- en: To get the game started, it needs to be initialized by calling the `init` method.
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始游戏，需要通过调用`init`方法进行初始化。
- en: '[PRE208]'
  id: totrans-1198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '`init` builds the map, creates the player model, sets the player’s location
    to the correct place, and then displays the player and place information, as shown
    in the following listing.'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`构建地图，创建玩家模型，将玩家的位置设置为正确的地方，然后显示玩家和地点信息，如以下列表所示。'
- en: Listing 16.5\. The init function ([http://jsbin.com/yeqicu/edit?js](http://jsbin.com/yeqicu/edit?js))
  id: totrans-1200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表16.5\. `init`函数 ([http://jsbin.com/yeqicu/edit?js](http://jsbin.com/yeqicu/edit?js))
- en: '![](288fig01_alt.jpg)'
  id: totrans-1201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](288fig01_alt.jpg)'
- en: You declare the `player` and `inPlay` variables outside the `init` function
    so other functions in the controller can access them. The `buildMap` function
    returns the starting place in the game, and then you set that place as the player’s
    current location. The `init` function calls `render` to display the starting place
    and player information.
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在`init`函数外部声明`player`和`inPlay`变量，这样控制器中的其他函数就可以访问它们。`buildMap`函数返回游戏中的起始位置，然后你将那个位置设置为玩家的当前位置。`init`函数调用`render`来显示起始位置和玩家信息。
- en: The `render`, `get`, `go`, and `use` functions use the `inPlay` variable. They
    perform their usual tasks only when `inPlay` is `true`. When a player’s health
    drops to zero, the controller sets `inPlay` to `false`. For that to happen, you
    have to keep an eye on the player’s health.
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: '`render`、`get`、`go`和`use`函数使用`inPlay`变量。只有当`inPlay`为`true`时，它们才会执行常规任务。当玩家的健康值降至零时，控制器将`inPlay`设置为`false`。为了实现这一点，你必须密切关注玩家的健康值。'
- en: 16.4.2\. Monitoring player health
  id: totrans-1204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.4.2\. 监控玩家健康
- en: Whenever a player takes damage, you need to check if their health has reached
    zero, because that’s “Game over, man. Game over!” The controller’s `checkGameStatus`
    function does the checking, setting the `isPlay` variable to `false` if the player
    has succumbed to the litany of zombie bites, leopard lacerations, and nasty splinters
    they encounter, as shown in the next listing.
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 每当玩家受到伤害时，你需要检查他们的健康值是否已达到零，因为那意味着“游戏结束，伙计。游戏结束！”控制器的`checkGameStatus`函数负责检查，如果玩家因遭遇僵尸咬伤、豹子撕裂和讨厌的木刺而屈服，将`isPlay`变量设置为`false`，如下一列表所示。
- en: Listing 16.6\. Checking if health has dropped to zero ([http://jsbin.com/yeqicu/edit?js](http://jsbin.com/yeqicu/edit?js))
  id: totrans-1206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表16.6\. 检查健康值是否降至零 ([http://jsbin.com/yeqicu/edit?js](http://jsbin.com/yeqicu/edit?js))
- en: '![](289fig01_alt.jpg)'
  id: totrans-1207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](289fig01_alt.jpg)'
- en: The condition uses the less than or equal to comparison operator, `<=`, to check
    if the health is less than or equal to zero.
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 条件使用小于或等于比较运算符`<=`来检查健康值是否小于或等于零。
- en: '[PRE209]'
  id: totrans-1209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: If the player has died, you stop the game and display a final message. If they’re
    fit enough to carry on, `checkGameStatus` does nothing.
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家已经死亡，你将停止游戏并显示一条最终消息。如果他们足够健康可以继续，`checkGameStatus` 将不执行任何操作。
- en: 16.4.3\. Updating the display—functions that use the view modules
  id: totrans-1211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.4.3\. 更新显示—使用视图模块的函数
- en: Rather than calling the render methods of view modules directly, the controller
    uses its own functions. This makes it easier to switch to different view modules
    if required because the views are referenced in only one place, as shown in the
    following listing.
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 与直接调用视图模块的渲染方法相比，控制器使用自己的函数。这使得在需要时切换到不同的视图模块变得更容易，因为视图只在一个地方被引用，如下所示。
- en: Listing 16.7\. Updating the display ([http://jsbin.com/yeqicu/edit?js](http://jsbin.com/yeqicu/edit?js))
  id: totrans-1213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 16.7\. 更新显示 ([http://jsbin.com/yeqicu/edit?js](http://jsbin.com/yeqicu/edit?js))
- en: '![](289fig02_alt.jpg)'
  id: totrans-1214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](289fig02_alt.jpg)'
- en: The `init` function gets things started, and then `checkGameStatus`, `render`,
    and `render-Message` are used throughout the game. The main action comes from
    the `get`, `go`, and `use` functions, with `go` and `use` making some tricky decisions
    based on items, exits, and challenges. It’s time to investigate the player commands—make
    it so!
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: '`init` 函数负责启动游戏，随后在整个游戏中使用 `checkGameStatus`、`render` 和 `render-Message`。主要动作来自
    `get`、`go` 和 `use` 函数，其中 `go` 和 `use` 函数会根据物品、出口和挑战做出一些复杂的决策。现在是时候调查玩家命令了——让它变得如此吧！'
- en: 16.5\. The Crypt—giving commands and solving puzzles
  id: totrans-1216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.5. The Crypt—发出命令和解决谜题
- en: 'Users are permitted to take only a small set of actions when exploring *The
    Crypt*. The controller module assigns the following interface to the global `window`
    object:'
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 用户在探索 *The Crypt* 时只能执行一小套动作。控制器模块将以下接口分配给全局 `window` 对象：
- en: '[PRE210]'
  id: totrans-1218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: The user initiates actions in the game by calling the game controller interface
    methods at the console (`game.get()` or `game.go("south")`, for example). The
    game controller then creates, accesses, or updates models in response to the user’s
    instructions and passes changed models to the views for display.
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 用户通过在控制台调用游戏控制器接口方法来在游戏中启动动作（例如 `game.get()` 或 `game.go("south")`）。然后，游戏控制器根据用户的指示创建、访问或更新模型，并将更改后的模型传递给视图进行显示。
- en: You’ve already looked at the `init` function; this section (16.5) steps through
    the `get`, `go`, and `use` functions. The `get` function hasn’t evolved much,
    but the `go` function now checks for challenges. And `use` is a completely new
    function.
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看过 `init` 函数；本节（16.5）将逐步介绍 `get`、`go` 和 `use` 函数。`get` 函数变化不大，但 `go` 函数现在会检查挑战。而
    `use` 是一个全新的函数。
- en: 16.5.1\. Picking up items with game.get
  id: totrans-1221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.5.1\. 使用 game.get 拾取物品
- en: Players exploring *The Crypt* will find items as they travel from place to place.
    The items will help them to overcome challenges they may face. The `get` method
    gives them a way of picking up the items they find, as shown next.
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 探索 *The Crypt* 的玩家在从一个地方移动到另一个地方的过程中会发现物品。这些物品将帮助他们克服可能遇到的挑战。`get` 方法为他们提供了一种捡起所发现物品的方式，如下所示。
- en: Listing 16.8\. The get function ([http://jsbin.com/yeqicu/edit?js](http://jsbin.com/yeqicu/edit?js))
  id: totrans-1223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 16.8\. `get` 函数 ([http://jsbin.com/yeqicu/edit?js](http://jsbin.com/yeqicu/edit?js))
- en: '![](290fig01_alt.jpg)'
  id: totrans-1224
  prefs: []
  type: TYPE_IMG
  zh: '![图片](290fig01_alt.jpg)'
- en: An item is removed from the end of the place’s list of items and added to the
    player’s list of items. If the place has no items, `getLastItem` will return `undefined`.
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 从地点的物品列表末尾移除一个物品并添加到玩家的物品列表中。如果地点没有物品，`getLastItem` 将返回 `undefined`。
- en: Both the `go` and `use` functions involve checking challenges. A quick refresher
    is in order.
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: '`go` 和 `use` 函数都涉及到检查挑战。需要快速复习一下。'
- en: 16.5.2\. Listing the properties of a challenge
  id: totrans-1227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.5.2\. 列出挑战的属性
- en: You’re keen on the idea of challenges and want to add a splash of jeopardy.
    Players have had a health property right from the start of the book; you’re ready
    to do dastardly damage to players as they meekly move around your maze.
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: 你对挑战的想法很感兴趣，想要添加一些冒险元素。玩家从书本一开始就有一个健康属性；你现在准备好在玩家在你的迷宫中谦卑地移动时对他们造成恶劣的伤害了。
- en: 'You first saw challenges in *The Crypt* when developing map data in [chapter
    14](kindle_split_023.html#ch14), but you haven’t put them to use until now. Two
    of the player commands, `go` and `use`, check for challenges in a specified direction,
    so it’s worth reminding yourself of the properties that make up a challenge:'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 [第 14 章](kindle_split_023.html#ch14) 开发地图数据时第一次看到了挑战，但直到现在你还没有使用它们。两个玩家命令
    `go` 和 `use` 会检查指定方向上的挑战，所以值得提醒自己构成挑战的属性：
- en: '[PRE211]'
  id: totrans-1230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[Table 16.1](#ch16table01) lists the properties of the challenge object along
    with their purpose and whether they are required.'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: '[表16.1](#ch16table01)列出了挑战对象的属性及其用途以及是否必需。'
- en: Table 16.1\. Properties of the challenge object
  id: totrans-1232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表16.1\. 挑战对象的属性
- en: '| Property | What is it for? | Required? |'
  id: totrans-1233
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 它是用来做什么的？ | 是否必需？ |'
- en: '| --- | --- | --- |'
  id: totrans-1234
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| message | The message displayed to the player when they try to go in the
    direction of the exit and the challenge has not been overcome. | Yes |'
  id: totrans-1235
  prefs: []
  type: TYPE_TB
  zh: '| 消息 | 当玩家试图朝出口方向移动且挑战未克服时显示给玩家的消息。 | 是 |'
- en: '| success | The message displayed to the player when they use the item required
    to overcome the challenge. | Yes |'
  id: totrans-1236
  prefs: []
  type: TYPE_TB
  zh: '| 成功 | 当玩家使用克服挑战所需的物品时显示给玩家的消息。 | 是 |'
- en: '| failure | The message displayed to the player when they try to use the wrong
    object to overcome the challenge. | Yes |'
  id: totrans-1237
  prefs: []
  type: TYPE_TB
  zh: '| 失败 | 当玩家试图使用错误的物品克服挑战时显示给玩家的消息。 | 是 |'
- en: '| requires | The item required to overcome the challenge. | Yes |'
  id: totrans-1238
  prefs: []
  type: TYPE_TB
  zh: '| 需要 | 克服挑战所需的物品。 | 是 |'
- en: '| itemConsumed | If the item is removed from the player’s list of items once
    it is used. | No |'
  id: totrans-1239
  prefs: []
  type: TYPE_TB
  zh: '| 物品消耗 | 如果物品在使用后从玩家的物品列表中移除。 | 否 |'
- en: '| damage | The amount subtracted from the player’s health when they try to
    go in the direction of the exit before they have overcome the challenge. | No
    |'
  id: totrans-1240
  prefs: []
  type: TYPE_TB
  zh: '| 损伤 | 当玩家在克服挑战之前试图朝出口方向移动时，从玩家健康值中减去的数量。 | 否 |'
- en: '| complete | Whether the challenge has been completed. Usually missing in the
    initial data, it’s set to true during the game when a challenge is solved. | No
    |'
  id: totrans-1241
  prefs: []
  type: TYPE_TB
  zh: '| 完成 | 挑战是否已完成。通常在初始数据中缺失，当在游戏中解决挑战时设置为`true`。 | 否 |'
- en: 'To retrieve a challenge from a place object, call `getChallenge`, specifying
    a direction:'
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 要从位置对象中检索挑战，请调用`getChallenge`，指定一个方向：
- en: '[PRE212]'
  id: totrans-1243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: If there’s no challenge in that direction, `getChallenge` returns `undefined`.
    The first command that uses challenges is `game.go`.
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果那个方向没有挑战，`getChallenge`返回`undefined`。第一个使用挑战的命令是`game.go`。
- en: 16.5.3\. Moving with game.go
  id: totrans-1245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.5.3\. 使用game.go移动
- en: 'Players use the controller’s `go` function to move from place to place. But
    if a lock or a leap or a leopard blocks their path, the controller needs to let
    them know. Players call `go`, specifying the direction in which they wish to travel:'
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家使用控制器的`go`函数从一个地方移动到另一个地方。但如果锁、跳跃或豹子阻挡了他们的道路，控制器需要通知他们。玩家调用`go`，指定他们希望旅行的方向：
- en: '[PRE213]'
  id: totrans-1247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: The full `go` function is shown here. A walkthrough of the code follows the
    listing.
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示了完整的`go`函数。代码的说明如下。
- en: Listing 16.9\. The go function ([http://jsbin.com/yeqicu/edit?js](http://jsbin.com/yeqicu/edit?js))
  id: totrans-1249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表16.9\. go函数 ([http://jsbin.com/yeqicu/edit?js](http://jsbin.com/yeqicu/edit?js))
- en: '![](ch16ex09-0.jpg)'
  id: totrans-1250
  prefs: []
  type: TYPE_IMG
  zh: '![](ch16ex09-0.jpg)'
- en: '![](ch16ex09-1.jpg)'
  id: totrans-1251
  prefs: []
  type: TYPE_IMG
  zh: '![](ch16ex09-1.jpg)'
- en: 'The function starts by collecting the information it needs to act on the player’s
    request:'
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 函数首先收集它需要处理玩家请求的信息：
- en: '[PRE214]'
  id: totrans-1253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'It could be that there’s no exit in the direction the player specified. You
    need to check for that:'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 可能玩家指定的方向没有出口。你需要检查这一点：
- en: '[PRE215]'
  id: totrans-1255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: Okay, say the player isn’t walking into a wall and there’s an exit in the direction
    specified. If there’s no challenge, or if the player has completed the challenge,
    you can move them to the destination.
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，假设玩家没有撞墙，并且指定方向有出口。如果没有挑战，或者玩家已经完成了挑战，你可以将他们移动到目的地。
- en: '[PRE216]'
  id: totrans-1257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: The `||` symbol in the `if` condition is the logical OR operator. It lets you
    check a condition made up of two expressions at once. If either the first expression,
    `challenge === undefined`, or the second expression, `challenge.complete`, evaluates
    to `true`, then the whole condition is `true`. If both expressions evaluate to
    `false`, then the whole condition is `false`. (JavaScript also has a logical AND
    operator, `&&`, that evaluates to `true` if both expressions are `true,` and `false`
    otherwise.)
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`条件中的`||`符号是逻辑或运算符。它允许你同时检查由两个表达式组成的条件。如果第一个表达式`challenge === undefined`或第二个表达式`challenge.complete`中的任何一个评估为`true`，则整个条件为`true`。如果两个表达式都评估为`false`，则整个条件为`false`。（JavaScript还有一个逻辑与运算符`&&`，如果两个表达式都为`true`，则评估为`true`，否则为`false`。）'
- en: If the player hasn’t completed a challenge, you need to apply any damage that
    the challenge causes (bumps, bruises, leopard bites, and so on).
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家没有完成挑战，你需要应用挑战造成的任何伤害（碰撞、擦伤、豹子咬伤等）。
- en: '[PRE217]'
  id: totrans-1260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: Finally, update the display to show any changes to health, show the challenge’s
    initial message, and check that the player’s health is still above zero—the game
    remains in play.
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新显示以显示对健康状态的任何更改，显示挑战的初始信息，并检查玩家的健康是否仍然高于零——游戏仍在进行中。
- en: '[PRE218]'
  id: totrans-1262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: That takes care of player peregrinations. But what if there *is* a big, hungry
    cat blocking the path? How can players lick the leopard?
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就处理了玩家的探索。但如果路上真的有一只大、饿的猫怎么办？玩家如何擦掉豹子？
- en: 16.5.4\. Licking the leopard with game.use
  id: totrans-1264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.5.4\. 使用 game.use 擦掉豹子
- en: 'If a lock or a leap or a leopard blocks a player’s path, the player can call
    the controller’s `use` function to overcome the challenge. They specify the item
    to use and the direction in which to use it:'
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果锁、跳跃或豹子阻挡了玩家的道路，玩家可以调用控制器的 `use` 函数来克服挑战。他们指定要使用的物品和使用的方向：
- en: '[PRE219]'
  id: totrans-1266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'The full `use` function is shown in [listing 16.10](#ch16ex10). It has a number
    of nested `if` statements, but don’t worry: the key decisions are shown in [figure
    16.6](#ch16fig06), and you venture down the rabbit hole to see how it works following
    the listing.'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 `use` 函数在 [列表 16.10](#ch16ex10) 中显示。它包含多个嵌套的 `if` 语句，但不要担心：关键决策在 [图 16.6](#ch16fig06)
    中显示，你可以跟随列表了解其工作原理。
- en: Figure 16.6\. The key decisions made by the `use` function
  id: totrans-1268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 16.6\. `use` 函数做出的关键决策
- en: '![](16fig06_alt.jpg)'
  id: totrans-1269
  prefs: []
  type: TYPE_IMG
  zh: '![](16fig06_alt.jpg)'
- en: Listing 16.10\. The use function ([http://jsbin.com/yeqicu/edit?js](http://jsbin.com/yeqicu/edit?js))
  id: totrans-1270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 16.10\. `use` 函数([http://jsbin.com/yeqicu/edit?js](http://jsbin.com/yeqicu/edit?js))
- en: '![](ch16ex10-0.jpg)'
  id: totrans-1271
  prefs: []
  type: TYPE_IMG
  zh: '![](ch16ex10-0.jpg)'
- en: '![](ch16ex10-1.jpg)'
  id: totrans-1272
  prefs: []
  type: TYPE_IMG
  zh: '![](ch16ex10-1.jpg)'
- en: 'The function starts by collecting the information it needs to act on the player’s
    request:'
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 函数首先收集它需要用来响应玩家请求的信息：
- en: '[PRE220]'
  id: totrans-1274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: 'It could be that there’s no challenge in the direction the player specified.
    You need to check for that:'
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是玩家指定的方向没有挑战。你需要检查这一点：
- en: '[PRE221]'
  id: totrans-1276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'Some players are sneaky! You need to check that they have the item they’re
    trying to use. If they don’t, send them a polite message:'
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 一些玩家很狡猾！你需要检查他们是否拥有他们试图使用的物品。如果没有，给他们发送一条礼貌的信息：
- en: '[PRE222]'
  id: totrans-1278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'Okay, so they’re using an item they have against an actual challenge. Is it
    the right tool for the job? Let them know if it’s not:'
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，他们正在使用他们拥有的物品来对抗真正的挑战。这是否是正确的工具？如果它不是，让他们知道：
- en: '[PRE223]'
  id: totrans-1280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: 'And finally, at the bottom of the rabbit hole, if they’ve passed all the checks,
    complete the challenge:'
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在兔子洞的底部，如果他们通过了所有检查，完成挑战：
- en: '[PRE224]'
  id: totrans-1282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: Well done; you made it through the `get`, `go`, and `use` function wonderland.
    The pieces aren’t too taxing, but when you have deeply nested ifs and buts, they
    can get quite hairy. Throw yourself a tea party! But don’t be late for [section
    16.6](#ch16lev1sec6)—that’s where your adventure really begins.
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好；你通过了 `get`、`go` 和 `use` 函数的奇妙世界。这些部分并不太复杂，但当你有深层嵌套的 `if` 和 `but` 语句时，它们可能会变得相当复杂。给自己举办一个茶会吧！但不要迟到
    [第 16.6 节](#ch16lev1sec6)——那里才是你的冒险真正开始的地方。
- en: 16.6\. The Crypt—running the game
  id: totrans-1284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.6\. 《密码》——运行游戏
- en: To get the game running, you need to include all of the modules you’ve created
    and then call the `game.init` method, passing it the map data and the player’s
    name. [Figure 16.7](#ch16fig07) shows all of the modules involved.
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行游戏，你需要包含你创建的所有模块，然后调用 `game.init` 方法，传递地图数据和玩家的名字。[图 16.7](#ch16fig07) 显示了所有涉及的模块。
- en: Figure 16.7\. The many modules of *The Crypt*
  id: totrans-1286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 16.7\. 《密码》的众多模块
- en: '![](16fig07_alt.jpg)'
  id: totrans-1287
  prefs: []
  type: TYPE_IMG
  zh: '![](16fig07_alt.jpg)'
- en: The next listing shows the HTML `script` elements used to load the modules.
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了用于加载模块的 HTML `script` 元素。
- en: Listing 16.11\. Loading the game modules (HTML) ([http://jsbin.com/fociqo/edit?html,console](http://jsbin.com/fociqo/edit?html,console))
  id: totrans-1289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 16.11\. 加载游戏模块（HTML）([http://jsbin.com/fociqo/edit?html,console](http://jsbin.com/fociqo/edit?html,console))
- en: '![](ch16ex11-0.jpg)'
  id: totrans-1290
  prefs: []
  type: TYPE_IMG
  zh: '![](ch16ex11-0.jpg)'
- en: '![](ch16ex11-1.jpg)'
  id: totrans-1291
  prefs: []
  type: TYPE_IMG
  zh: '![](ch16ex11-1.jpg)'
- en: The HTML includes an initial `script` element that’s different from the rest.
    It has no `src` attribute. Rather than linking to a file to load, it includes
    the JavaScript directly between the `script` tags. The module files can take a
    moment to load, so it’s nice to give players feedback that something is happening.
    Putting the code in the HTML lets it run straight away; no need to wait for a
    file to load.
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 包含一个与其它不同的初始 `script` 元素。它没有 `src` 属性。它不是链接到一个文件来加载，而是在 `script` 标签之间直接包含
    JavaScript。模块文件可能需要一点时间来加载，所以给玩家一些反馈，表明正在发生某些事情是很好的。将代码放在 HTML 中可以让它立即运行；无需等待文件加载。
- en: The following listing shows the code needed to get things up and running.
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了启动所需的所有代码。
- en: Listing 16.12\. Running the game ([http://jsbin.com/fociqo/edit?js,console](http://jsbin.com/fociqo/edit?js,console))
  id: totrans-1294
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 16.12\. 运行游戏 ([http://jsbin.com/fociqo/edit?js,console](http://jsbin.com/fociqo/edit?js,console))
- en: '[PRE225]'
  id: totrans-1295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: Hide the JavaScript panel, run the game, and start exploring! Be careful though;
    challenges chip away at your health.
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏JavaScript面板，运行游戏，并开始探索！不过要小心；挑战会消耗你的健康。
- en: 16.7\. The Crypt—what’s next for the app?
  id: totrans-1297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.7\. 密室——应用的下一步是什么？
- en: Congratulations! You’ve created a working console-based adventure game with
    swappable maps and a modular architecture (a fancy way of saying it’s made up
    of lots of bits).
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经创建了一个具有可交换地图和模块化架构（一种说法，意思是它由许多部分组成）的工作控制台冒险游戏。
- en: '[Part 2](kindle_split_019.html#part02) of *Get Programming with JavaScript*
    was all about organizing your code to better cope with larger programs. Your knowledge
    of private variables, modules, models, views, and controllers equips you to cope
    with more ambitious projects. By sticking to the console, you were able to focus
    on the key JavaScript language concepts; now it’s time to make the jump to HTML
    and web interfaces. As you’ll see, the work you’ve done building a well-organized
    program will make your first steps as a web developer much easier.'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: '[第二部分](kindle_split_019.html#part02)的《用JavaScript编程入门》主要讲述了如何组织代码以更好地应对更大的程序。你对私有变量、模块、模型、视图和控制器知识的掌握使你能够应对更雄心勃勃的项目。通过坚持使用控制台，你能够专注于JavaScript语言的关键概念；现在是时候跳转到HTML和网页界面了。正如你将看到的，你构建的有序程序将使你作为网页开发者的第一步变得容易得多。'
- en: 16.8\. Summary
  id: totrans-1300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.8\. 摘要
- en: Use a *controller* to manage the models and the views. The controller updates
    the models in response to user input and passes data from the models to the views
    for display.
  id: totrans-1301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*控制器*来管理模型和视图。控制器根据用户输入更新模型，并将数据从模型传递到视图进行显示。
