- en: Chapter 9\. Reading and writing raster data
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9章. 读取和写入栅格数据
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Understanding raster data basics
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解栅格数据基础知识
- en: Introducing GDAL
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍GDAL
- en: Reading and writing raster data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取和写入栅格数据
- en: Resampling data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重采样数据
- en: If you have a geographic dataset that’s made of continuous data such as elevation
    or temperature, it’s probably a raster dataset. Spectral data such as aerial photographs
    and satellite imagery are also stored this way. These types of datasets don’t
    assume strict boundaries exist between objects in the way that vector datasets
    do. Think of a digital photograph and how each pixel can be a slightly different
    color than the pixels next to it. The fact that pixel values can vary continuously
    like this makes for a much better-looking photo than if there were only a few
    colors to choose from. This trait also makes rasters appropriate for continuously
    varying data such as elevation.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个由连续数据（如高程或温度）组成的地理数据集，那么它很可能是一个栅格数据集。光谱数据，如航空照片和卫星图像，也是以这种方式存储的。这些类型的数据库不假设对象之间存在严格的边界，就像矢量数据库那样。想想数字照片，每个像素可以比相邻像素略有不同的颜色。像素值可以连续变化这一事实，使得照片看起来比只有几种颜色可选要好得多。这种特性也使得栅格适合于连续变化的数据，如高程。
- en: Working with raster datasets is different from working with vectors. Instead
    of having individual geometries, you have a collection of pixels which is essentially
    a large two- or three-dimensional array of numbers. A raster dataset is made of
    bands instead of layers, and each of these bands is a two-dimensional array. The
    collection of bands becomes a 3D array. It’s a different way of thinking about
    spatial data, and if you have a math phobia, this description might make it sound
    scary, too. But you’ll soon see that it’s not.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 与矢量数据集相比，处理栅格数据集有所不同。你拥有的是像素集合，这本质上是一个大型的二维或三维数字数组。栅格数据集由波段组成，而不是层，每个波段都是一个二维数组。波段的集合成为一个三维数组。这是一种不同的空间数据处理方式，如果你有数学恐惧症，这个描述可能会让你觉得它很可怕。但很快你就会看到，其实并不难。
- en: In this chapter you’ll learn basic theory of raster data, including tips for
    keeping them to manageable sizes. Then you’ll see how to use Python and GDAL to
    read these datasets into memory and how to write them back out to disk. The easiest
    case is to read and write an entire dataset at once, but sometimes you don’t need
    the entire spatial extent, and other times the amount of memory is a limiting
    factor, so you’ll also learn how to deal with a spatial subset of the data. It’s
    also possible to change the pixel size while reading or writing, and you’ll see
    how to do that as well.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习栅格数据的基本理论，包括保持其可管理大小的技巧。然后，你将了解如何使用Python和GDAL将这些数据集读入内存，以及如何将它们写回磁盘。最简单的情况是一次性读取和写入整个数据集，但有时你不需要整个空间范围，有时内存量是限制因素，因此你还将学习如何处理数据的空间子集。在读取或写入时，还可以更改像素大小，你将看到如何做到这一点。
- en: 9.1\. Introduction to raster data
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1. 栅格数据简介
- en: As mentioned, raster datasets can hold pretty much any type of data you’d like.
    That doesn’t mean that it’s always a good idea to use rasters, however. Objects
    that can be thought of as points, lines, or polygons are usually better left as
    vectors. For example, country boundaries lend themselves perfectly to a polygon
    vector dataset. This same data could be stored in a raster, but it would take
    up more disk space and the boundaries wouldn’t be nice, smooth lines. You also
    couldn’t use vector data analysis functions such as buffering and intersecting.
    These would still be possible using raster techniques, but you’d be better off
    sticking to vector in this case.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，栅格数据集可以存储几乎任何类型的数据。但这并不意味着总是使用栅格是一个好主意。那些可以被看作点、线或多边形的对象通常最好保持为矢量。例如，国家边界非常适合使用多边形矢量数据集。同样的数据也可以存储在栅格中，但会占用更多的磁盘空间，而且边界线不会是平滑的。你也不能使用矢量数据分析函数，如缓冲区和相交。虽然使用栅格技术仍然可以实现这些功能，但在此情况下坚持使用矢量会更好。
- en: Raster is a perfect choice when values change continuously instead of at sharply
    defined boundaries. This includes common datasets such as elevation, slope, aspect,
    precipitation, temperature, and satellite data, but it can include many other
    things, too. It could be evapotranspiration, distance from roads, soil moisture,
    or anything else you might need to model as a continuous variable. Sometimes you
    need what would normally be vector data to be represented as a raster. For example,
    rivers and streams are good candidates for vector data, but rasters are required
    for modeling flow accumulation or groundwater flow, such as what would be needed
    to track the flow of a contaminant in the water supply.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当值连续变化而不是在明确界定的边界上变化时，栅格是一个完美的选择。这包括常见的数据集，如高程、坡度、方位、降水量、温度和卫星数据，但它还可以包括许多其他事物。这可能包括蒸散量、道路距离、土壤湿度或你可能需要作为连续变量建模的任何其他事物。有时你需要将通常的矢量数据表示为栅格。例如，河流和溪流是矢量数据的良好候选者，但建模水流累积或地下水流动（例如，追踪水源中污染物流动）则需要栅格数据。
- en: Also, raster datasets don’t have to contain continuous data. In fact, I see
    many rasters made of categorical data such as land cover type. One reason for
    this is that rasters are used in the models used to produce these datasets in
    the first place. For example, land cover models typically use visible and nonvisible
    wavelengths of light from satellite imagery, along with ancillary data such as
    elevation. The model output is a raster because the inputs are rasters, and it
    makes sense to leave it that way. It also makes the data easy to use as an input
    to other raster-based models.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，栅格数据集不必包含连续数据。事实上，我看到许多由分类数据（如土地覆盖类型）组成的栅格。其中一个原因是栅格被用于最初产生这些数据集的模型中。例如，土地覆盖模型通常使用卫星图像的可见光和不可见光波长，以及辅助数据（如高程）。由于输入是栅格，模型输出是栅格，因此保持这种形式是有意义的。这也使得数据作为其他基于栅格的模型的输入变得容易使用。
- en: Other examples include viewshed analysis, which takes topology into account
    when determining what’s visible from a certain location. Maybe a ski resort would
    use this to decide where to locate a restaurant for the best views, and I know
    of a case where this type of analysis is being used to determine if ground bird
    nesting sites are visible to hawks perched on power lines (unpublished, but see
    Hovick et al.^([[1](#ch09fn01)]) for related research). Speaking of wildlife,
    rasters can also be used for habitat modeling, which might be done purely for
    the sake of knowledge, or to help select conservation areas. You might think of
    elevation as a fairly static dataset, but I know researchers who use ground-based
    lasers (in the form of LIDAR systems) to create elevation models of riverbeds,
    and then they do the same thing after a flood event so they can compare the before
    and after elevation profiles (Schaffrath et al.^([[2](#ch09fn02)])). The possibilities
    are endless, really.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 其他例子包括视域分析，这种分析在确定从某个位置可以看到什么时会考虑拓扑结构。也许滑雪胜地会使用这种方法来决定餐厅的最佳位置，以便获得最佳景观，我知道有一个案例中这种分析被用来确定地面鸟巢是否对停在电线上的鹰可见（未发表，但可参见
    Hovick 等人^([[1](#ch09fn01)])的相关研究）。说到野生动物，栅格数据也可以用于栖息地建模，这可能纯粹是为了知识，或者为了帮助选择保护区。你可能认为高程是一个相当静态的数据集，但我知道一些研究人员使用地面激光（以激光雷达系统的形式）来创建河床的高程模型，然后在洪水事件之后做同样的事情，以便他们可以比较前后高程剖面（Schaffrath
    等人^([[2](#ch09fn02)])）。实际上，可能性是无限的。
- en: ¹
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Hovick, T. J., Elmore, R. D., Dahlgren, D. K., Fuhlendorf, S. D., Engle, D.
    M. 2014\. REVIEW: Evidence of negative effects of anthropogenic structures on
    wildlife: a review of grouse survival and behavior. Journal of Applied Ecology,
    51: 1680–1689. DOI: 10.1111/1365-2664.12331.'
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Hovick, T. J., Elmore, R. D., Dahlgren, D. K., Fuhlendorf, S. D., Engle, D.
    M. 2014\. 评论：人类结构对野生动物的负面影响证据：关于松鸡生存和行为的评论。应用生态学杂志，51: 1680–1689. DOI: 10.1111/1365-2664.12331.'
- en: ²
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Schaffrath, K. R., P. Belmont, and J.M Wheaton. 2015\. Landscape-scale geomorphic
    change detection: Quantifying spatially variable uncertainty and circumventing
    legacy data issues. Geomorphology, 250: 334-348\. DOI: 10.1016/j.geomorph.2015.09.020.'
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Schaffrath, K. R., P. Belmont, 和 J.M Wheaton. 2015\. 地貌尺度地貌变化检测：量化空间变量不确定性并规避遗产数据问题。地貌学，250:
    334-348\. DOI: 10.1016/j.geomorph.2015.09.020.'
- en: Now let’s talk a bit about the details of raster datasets. You can probably
    envision a digital photograph as a two-dimensional array of pixels. In fact, that’s
    what we talk about when discussing the dimensions of a photo—the numbers of rows
    and columns in that 2D array. This is what raster datasets are, except that they
    aren’t limited to two dimensions. They can have a third dimension in the form
    of bands. Digital photos have multiple bands, too, although you don’t usually
    think of them that way. But they have one each for red, green, and blue wavelengths
    of light. Your computer (or printer) combines these together to produce the colors
    you see on your monitor screen. You’re familiar with this concept if you’ve ever
    created a webpage and specified a color using HEX notation, where the first two
    numbers correspond to red, the second two to green, and the last two to blue,
    or RGB notation where you provide a separate number for each of these colors.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们谈谈栅格数据集的细节。你可能能想象一个数字照片是一个像素的二维数组。实际上，这就是我们讨论照片维度时所谈论的——那个二维数组中的行数和列数。这就是栅格数据集，只不过它们并不限于二维。它们可以有一个以波段形式存在的第三维度。数字照片也有多个波段，尽管你通常不会这样想。但它们分别对应于红光、绿光和蓝光波长。如果你曾经创建过网页并使用十六进制符号指定颜色，那么你对此概念就很熟悉，其中前两个数字对应于红色，后两个对应于绿色，最后两个对应于蓝色，或者RGB符号，其中为这些颜色中的每一个提供单独的数字。
- en: Also, just as with a photograph, each band in a dataset has the same numbers
    of rows and columns, so the pixels from one fall in the same spatial location
    as the pixels in another. If the pixels for each individual color in a photograph
    didn’t line up correctly, I imagine the results would look fairly blurry.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，就像照片一样，数据集中的每个波段都有相同的行数和列数，因此一个波段的像素与另一个波段的像素在相同的空间位置上。如果照片中每个单独颜色的像素没有正确对齐，我想结果看起来会相当模糊。
- en: Obviously not all raster datasets are photographs, so pixel values don’t have
    to correspond to colors. Pixel values in a digital elevation model (DEM), for
    example, correspond to elevation values. Generally DEM datasets only contain one
    band, because elevation is the only value required to create a useful dataset.
    [Figure 9.1](#ch09fig01) shows a single-band raster landcover map for the state
    of Utah, where each unique pixel value represents a different landcover classification.
    This dataset contains discrete, rather than continuous, data.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，并非所有栅格数据集都是照片，因此像素值不必与颜色相对应。例如，在数字高程模型（DEM）中的像素值对应于高程值。通常，DEM数据集只包含一个波段，因为高程是创建有用数据集所需唯一的值。[图9.1](#ch09fig01)显示了犹他州的单波段栅格土地覆盖图，其中每个唯一的像素值代表不同的土地覆盖分类。此数据集包含离散数据，而不是连续数据。
- en: Figure 9.1\. A landcover classification map, where each unique pixel value corresponds
    to a specific landcover classification
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.1\. 土地覆盖分类图，其中每个唯一的像素值对应于特定的土地覆盖分类
- en: '![](09fig01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](09fig01.jpg)'
- en: '|  |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Note to Print Book Readers: Color Graphics'
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意：打印书籍读者：彩色图形
- en: Many graphics in this book are best viewed in color. The eBook versions display
    the color graphics, so they should be referred to as you read. To get your free
    eBook in PDF, ePub, and Kindle formats, go to [https://www.manning.com/books/geoprocessing-with-python](https://www.manning.com/books/geoprocessing-with-python)
    to register your print book.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的许多图形以彩色查看最佳。电子书版本显示彩色图形，因此在阅读时应参考。要获取免费电子书（PDF、ePub和Kindle格式），请访问[https://www.manning.com/books/geoprocessing-with-python](https://www.manning.com/books/geoprocessing-with-python)注册您的印刷版书籍。
- en: '|  |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Satellite imagery, on the other hand, contains measurements of various wavelengths,
    many of which aren’t visible to our eyes. While the image might contain bands
    corresponding to visible red, green, and blue wavelengths, there might also be
    bands for infrared or thermal radiation. False color images such as those shown
    in [figure 9.2](#ch09fig02) are created by displaying an infrared band along with
    visible light. This figure illustrates another use case for satellite imagery
    in the form of raster data. The image on the left was created using visible light
    wavelengths, like a traditional photograph. The camera also captured a near infrared
    wavelength as another band at the same time, and it was used along with the visible
    red and green bands to create the false color image on the right. The near infrared
    band is brighter for growing vegetation, and it’s displayed as red, so red areas
    are vegetation. This band combination is useful for monitoring vegetation. The
    field in the stadium and the practice fields outside are both green and look like
    grass in the natural color image, but the field inside the stadium is dark gray
    in the false color image, so it must be artificial. The practice fields outside
    the stadium are bright red, however, so they must be grass.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 卫星图像，另一方面，包含了各种波长的测量，其中许多波长肉眼是看不见的。虽然图像可能包含对应可见红、绿和蓝波长的波段，但也可能有红外或热辐射的波段。如图9.2所示[图9.2](#ch09fig02)中的假彩色图像是通过显示红外波段与可见光一起创建的。此图展示了卫星图像作为栅格数据的另一种用途。左侧的图像是使用可见光波长创建的，就像传统照片一样。同时，相机还捕捉到了近红外波长作为另一个波段，并与可见的红、绿波段一起用于创建右侧的假彩色图像。近红外波段对生长的植被来说更亮，显示为红色，因此红色区域是植被。这种波段组合对于监测植被很有用。体育场内的草坪和体育场外的练习场在自然色彩图像中都是绿色，看起来像草地，但在假彩色图像中，体育场内的草坪是深灰色，所以它必须是人工的。然而，体育场外的练习场是鲜红色，所以它们必须是草地。
- en: Figure 9.2\. Two images of Gillette Stadium, home of the New England Patriots,
    in Foxborough, Massachusetts. The field inside the stadium looks like grass in
    the natural color image on the left, and it looks gray in the false color image
    on the right, which makes it clear that it’s actually artificial. The practice
    fields, on the other hand, also look like grass in the natural color image on
    the left, but are red in the image on the right, signifying that they are indeed
    grass.
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.2. 麦斯威尔体育场（新英格兰爱国者队的主场）在马萨诸塞州福克斯伯勒的两张图像。在自然色彩图像的左侧，体育场内的草坪看起来像草地，而在假彩色图像的右侧看起来是灰色，这清楚地表明它实际上是人工的。另一方面，练习场在自然色彩图像的左侧也看起来像草地，但在右侧的图像中是红色，这表明它们确实是草地。
- en: '![](09fig02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2](09fig02.jpg)'
- en: Let’s make another comparison to photographs. Although pictures you take with
    your phone might be geotagged, meaning that metadata in the image specifies where
    you were standing when you took the photo, each pixel doesn’t correspond to a
    specific location on the ground. That wouldn’t even make sense for most of the
    photos you take, but what if you took one from an airplane, looking straight down?
    A photo like that could be overlaid on a map if you had the appropriate spatial
    information. Having only the geotagged coordinates isn’t enough, even if you knew
    exactly what part of the photo the coordinates corresponded to, such as a corner
    or the center. For example, think how different your photo would look if you were
    in a Cessna flying relatively close to the ground as opposed to a 747 much higher
    up. Your photo would cover a much larger area in the second case, even if the
    photo was taken with the same camera and had the same number of rows and columns.
    The difference is the pixel size or the area on the ground that a single pixel
    covers. The pixels in the photo taken from the Cessna would each cover a smaller
    area than a pixel in the 747 photo. If you knew how much area they each covered,
    along with the coordinates of one of them, you could figure out how to stretch
    the photo so that it overlaid on a map. This is assuming that your camera was
    pointed exactly straight down so the pixels aren’t skewed to one side. It also
    assumes that you had things aligned perfectly so that the top of the photo was
    exactly north, although you could rotate the image to compensate for that.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再拿照片做一个比较。虽然你用手机拍摄的照片可能带有地理标签，意味着图像中的元数据指定了你拍照时的位置，但每个像素并不对应地面上的一个特定位置。对于你拍摄的大多数照片来说，这甚至都不合理，但如果你是从飞机上拍摄的，直视下方呢？如果你有适当的空间信息，这样的照片可以叠加到地图上。仅有地理标签的坐标是不够的，即使你知道坐标对应照片的哪个部分，比如角落或中心。例如，想象一下，如果你在地面相对较近的塞斯纳飞机上拍照，而不是在更高的747飞机上拍照，你的照片看起来会有多不同。在第二种情况下，即使照片是用相同的相机拍摄的，并且有相同行和列的数量，照片覆盖的区域也会更大。区别在于像素大小或单个像素覆盖的地面面积。从塞斯纳飞机上拍摄的照片中的每个像素覆盖的面积会比747照片中的像素小。如果你知道它们各自覆盖了多少面积，以及其中一个的坐标，你就可以找出如何拉伸照片，使其叠加到地图上。这是假设你的相机正好直指下方，所以像素没有向一侧倾斜。这也假设你将事物完美对齐，使得照片的顶部正好朝北，尽管你可以旋转图像来补偿这一点。
- en: Knowing the pixel size is important if you want to overlay your photo on a map,
    but you obviously need coordinates to go with it. With vector data it’s enough
    to know the spatial reference system because the coordinates for each feature
    are stored in the vertices. Given the SRS, each vertex can be placed in the correct
    location with lines drawn between them, and you have your geometry. Raster datasets
    don’t use vertices, and instead commonly use one set of coordinates, the pixel
    size, and the amount the dataset is rotated to determine coordinates for the rest
    of the image. This is called an *affine transformation*, and is a common way to
    georeference a raster dataset, although it isn’t the only way. The set of coordinates
    is generally for the upper-left corner of the image and is called the *origin*.
    For the simple (and common) case of a raster that has the top of the dataset facing
    north, you only need these coordinates and the pixel size to find the coordinates
    of any pixel in the image. All you need to do is figure out the offsets from the
    origin, multiply those by the pixel size, and add that to the origin coordinates.
    [Figure 9.3](#ch09fig03) shows how to get the upper-left coordinates for the pixel
    in the fifth column and fourth row. The first row and column have offsets 0, so
    your offsets in this case are 4 and 3\. To get the easting coordinate, multiply
    the pixel width by 4 to get the distance across those four columns. Then add that
    to the origin’s easting coordinate, and you’re done. You can get northings the
    same way, but by using the row offset instead of the column. As you can see, it’s
    extremely important that the origin coordinates are correct and using the right
    SRS, or else you can’t calculate coordinates for any part of the dataset.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 了解像素大小对于你想要将照片叠加到地图上非常重要，但你显然还需要相应的坐标。对于矢量数据，知道空间参考系统就足够了，因为每个要素的坐标都存储在顶点中。给定空间参考系统（SRS），每个顶点都可以放置在正确的位置，通过它们之间画线，你就得到了你的几何形状。栅格数据集不使用顶点，而是通常使用一组坐标，即像素大小，以及数据集旋转的量来确定图像其余部分的坐标。这被称为*仿射变换*，是地理参考栅格数据集的常见方法，尽管它不是唯一的方法。这组坐标通常是指图像的左上角，被称为*原点*。对于简单（且常见）的情况，即数据集的顶部朝北的栅格，你只需要这些坐标和像素大小就可以找到图像中任何像素的坐标。你所需要做的就是计算出原点的偏移量，将这些偏移量乘以像素大小，然后加到原点坐标上。[图9.3](#ch09fig03)展示了如何获取第五列和第四行像素的左上坐标。第一行和第一列的偏移量为0，所以在这种情况下，你的偏移量是4和3。要获取经度坐标，将像素宽度乘以4，得到跨越这四列的距离。然后将这个距离加到原点的经度坐标上，就完成了。你可以用同样的方法获取纬度坐标，但使用的是行偏移量而不是列。正如你所看到的，确保原点坐标正确和使用正确的SRS极其重要，否则你无法计算数据集任何部分的坐标。
- en: Figure 9.3\. An example showing how to get the upper-left coordinates for the
    pixel in the fifth column and fourth row
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.3\. 一个示例，展示如何获取第五列和第四行像素的左上坐标
- en: '![](09fig03.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](09fig03.jpg)'
- en: As you’ve no doubt noticed, the more pixels contained in a photo, the more disk
    space that photo requires. Similarly, raster datasets can take up a lot of space
    on disk and in RAM, so you should ensure that you’re not using smaller pixels
    or larger data types than are necessary. For example, if your data are only good
    down to 10 meters, it doesn’t make sense to have 1-meter pixels because the smaller
    pixels inside your 10-meter block will all have the same value. As a comparison,
    you may have seen compact digital cameras with more megapixels than high-end digital
    SLRs. The SLR still takes better photos, though, because higher quality data is
    collected. More pixels aren’t a substitute for quality data or effective resolution.
    Not only would they fail to improve your data, all of these extra pixels would
    greatly increase the size of your file. Doubling the number of rows and columns
    doesn’t double the size of the image. Instead, it quadruples it! For example,
    an image with 250 rows and 250 columns would have 250 x 250 = 62,500 pixels, while
    an image with 500 rows and columns has 250,000 pixels.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，照片中包含的像素越多，该照片所需的磁盘空间就越多。同样，栅格数据集可以在磁盘和RAM中占用大量空间，因此你应该确保你没有使用比必要的更小的像素或更大的数据类型。例如，如果你的数据只精确到10米，那么拥有1米像素是没有意义的，因为你的10米块内的较小像素都将具有相同的值。作为比较，你可能见过比高端数码单反相机像素更多的紧凑型数码相机。尽管如此，单反相机仍然能拍出更好的照片，因为收集了更高质量的数据。更多的像素不能替代高质量数据或有效分辨率。它们不仅不能提高你的数据，所有这些额外的像素还会极大地增加文件的大小。行和列的数量加倍并不会使图像的大小加倍。相反，它会使其四倍增加！例如，一个250行250列的图像将有250
    x 250 = 62,500像素，而一个500行500列的图像将有250,000像素。
- en: The data type you choose for your data is also important when it comes to storage
    space. For example, if your pixel values all fall in the range of 0 to 254, then
    you should use a byte data type (254 is the largest value a byte can hold). In
    this case, each pixel will take up a byte, or 8 bits, of disk space, no matter
    the value, unless you’re using compression. If you were to store this same data
    as 32-bit integer, each pixel would take up four times as much space as before.
    You’d be taking up four times as much memory with absolutely no benefit. With
    a small dataset, this might not matter so much, but it certainly does with large
    datasets.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你为数据选择的数据类型在存储空间方面也很重要。例如，如果你的像素值都落在0到254的范围内，那么你应该使用字节数据类型（254是字节能持有的最大值）。在这种情况下，每个像素将占用一个字节，即8位磁盘空间，无论其值如何，除非你使用压缩。如果你将相同的数据存储为32位整数，每个像素将占用之前四倍的空间。你会占用四倍多的内存，但没有任何好处。对于小数据集，这可能不是很重要，但对于大数据集来说，这确实很重要。
- en: If rasters can be so large and take a while to process, how can they be drawn
    on your screen in a reasonable amount of time? This is where *overview layers*
    come in. You might have also heard them called *pyramid layers* or *reduced resolution
    datasets* (hence the .rrd extension that several types of overviews have). Overview
    layers are reduced resolution layers—they’re rasters that cover the same area
    as the original, but are resampled to larger pixel sizes. A raster dataset can
    have many different overviews, each with a different resolution. When you’re zoomed
    out and looking at the whole image, the coarse resolution layer is drawn. Because
    the pixels are so large, that layer doesn’t take much memory and can draw quickly,
    but you can’t tell the difference at that zoom level. As you zoom in, a higher
    resolution layer is drawn, but only the part you’re viewing needs to be loaded
    and shown. If you zoom in enough, you’ll see the original pixels, but because
    you’re only looking at a small subset of the image, it still draws quickly.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果栅格数据可以如此之大，并且处理需要一段时间，那么它们如何在合理的时间内绘制到你的屏幕上呢？这就是*概览层*发挥作用的地方。你可能也听说过它们被称为*金字塔层*或*低分辨率数据集*（因此，几种类型的概览都有.rrd扩展名）。概览层是低分辨率层——它们是覆盖与原始图相同的区域的栅格，但被重采样到更大的像素大小。栅格数据集可以有许多不同的概览，每个概览都有不同的分辨率。当你放大并查看整个图像时，会绘制出粗分辨率层。因为像素很大，所以该层不需要太多内存，并且可以快速绘制，但你在这个缩放级别上无法看出差异。当你放大时，会绘制出更高分辨率的层，但只需要加载和显示你正在查看的部分。如果你放大足够多，你会看到原始像素，但由于你只查看图像的一小部分，它仍然可以快速绘制。
- en: '[Figure 9.4](#ch09fig04) shows how this works. Each successive overview layer
    has a pixel size twice as large as the previous one. All resolutions look the
    same when viewing the entire image, but you can see the difference when you’re
    zoomed into a smaller area. The upper-left image in the figure is a full resolution
    (1 x 1-meter pixel) image of San Diego Harbor. You can see individual cars, boats,
    and trees. The middle-top image is the first set of overviews, with pixels 2 meters
    on a side. The pixels in the upper-right image are 4 x 4 meters. Along the bottom
    row, the pixels are 8, 16, and 32 meters on a side. If you’re zoomed out so you
    can see all of San Diego, you can’t tell the difference between the first and
    the last image, but the last one is a small fraction of the size of the full-resolution
    one and draws much faster. A good rule of thumb is to create overview layers of
    decreasing resolution until the coarsest one has 256 pixels or less in one dimension.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.4](#ch09fig04)展示了这是如何工作的。每个后续的概览层像素大小是前一个的两倍。当查看整个图像时，所有分辨率看起来都一样，但当你放大到更小的区域时，你可以看到差异。图中的左上角图像是圣地亚哥港的全分辨率（1
    x 1米像素）图像。你可以看到单个汽车、船只和树木。中间顶部的图像是第一组概览，像素边长为2米。右上角的图像像素边长为4 x 4米。在底部行，像素边长为8、16和32米。如果你放大到可以看到整个圣地亚哥，你无法区分第一张和最后一张图像，但最后一张图像是全分辨率图像的一小部分，并且绘制得更快。一个很好的经验法则是创建分辨率逐渐降低的概览层，直到最粗糙的一层在一个维度上不超过256像素。'
- en: Figure 9.4\. Example of how each overview is a coarser resolution than the previous
    one. The image in the upper left (A) is full resolution, and each successive image
    uses a pixel size twice as large as the previous one. The last image (F) only
    looks good when zoomed way out, but it draws much faster than the full image at
    that scale.
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.4示例展示了每个概览图都比前一个概览图分辨率更低。左上角的图像（A）是全分辨率，每个后续图像使用的像素大小是前一个图像的两倍。最后一个图像（F）只有在放大很多倍时才看起来不错，但在这个比例下它比全图绘制得快得多。
- en: '![](09fig04_alt.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig04_alt.jpg)'
- en: Incidentally, the ubiquitous web-mapping services use this same technique to
    display aerial photography, except that the reduced resolution layers are stored
    as collections of individual tiles. Your browser downloads whichever tiles are
    required to cover the area you’re looking at, and as you zoom in, you get tiles
    that have a higher resolution and cover a smaller area, until eventually the resolution
    is so good that you can see your house or car.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，无处不在的在线地图服务使用相同的技巧来显示航空摄影，只不过这些降低分辨率的层是以单个瓦片集合的形式存储的。你的浏览器下载覆盖你正在查看区域的所需瓦片，当你放大时，你会得到更高分辨率且覆盖面积更小的瓦片，直到最终分辨率足够高，你可以看到你的房子或汽车。
- en: Another aspect of raster datasets that influences access speed is how they’re
    stored on disk. Rasters are made up of blocks, which have to do with how the data
    are arranged on the disk. As you’d expect, each format does this differently.
    (If not, they wouldn’t really be different formats, would they?) Blocks of pixels
    are all physically stored next to each other on disk, so they can be accessed
    together efficiently. It’s possible that other blocks belonging to the same image
    are stored on another part of the disk; this is the sort of problem you solve
    by defragmenting your drive. It’s faster to grab data that are close to each other
    physically, just as it’s faster for you to pull two books off the same shelf instead
    of from two different bookshelves. If you need to read or write data, it’s most
    efficient to use blocks. For example, GeoTIFFs come in tiled and untiled formats.
    Untiled GeoTIFFs store each row of pixels as a block, but tiled ones use square
    sets of pixels instead, with 256 x 256 being a common block (or tile) size. It’s
    faster to read data from a tiled GeoTIFF in the square chunks corresponding to
    blocks, but it’s faster to deal with entire rows when it comes to untiled GeoTIFFs.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 影响栅格数据集访问速度的另一个方面是它们在磁盘上的存储方式。栅格由块组成，这与数据在磁盘上的排列方式有关。正如你所预期的，每种格式都以不同的方式做这件事。（如果不是这样，它们实际上就不会是不同的格式，对吧？）像素块在磁盘上物理上相邻存储，因此可以一起高效地访问。可能同一图像的其他块存储在磁盘的另一部分；这是通过磁盘碎片整理来解决的那种问题。物理上靠近的数据访问速度更快，就像你从同一书架上而不是从两个不同的书架上取两本书一样快。如果你需要读取或写入数据，使用块是最有效率的。例如，GeoTIFFs有瓦片和未瓦片两种格式。未瓦片的GeoTIFFs将每一行的像素存储为一个块，但瓦片式的使用的是像素的正方形集合，256
    x 256是一个常见的块（或瓦片）大小。从瓦片GeoTIFF中读取数据时，以对应块的方形块读取更快，但处理整个行时，未瓦片的GeoTIFF更快。
- en: You’re probably also wondering about data compression, because this is regularly
    used with digital photos in .jpeg format and can significantly reduce the size
    of a file. This is certainly possible, and multiple types of compression are available,
    depending on the data format. You might have heard of *lossy* versus *lossless*
    compression. Lossy compression loses information in the act of compressing the
    data. When saving .jpegs, you’ve probably noticed the compression quality option.
    The higher the quality, the less data you lose and the better the resulting image
    looks. The .png format, however, is lossless, which is why you aren’t asked for
    a compression quality when saving one of those. That doesn’t mean that the data
    can’t be compressed. It means that you won’t lose any data in the act of compression,
    and the image can be perfectly reconstructed into the original uncompressed dataset.
    If you plan to compress your data but you also need to perform analyses on it,
    make sure you select a lossless algorithm. Otherwise, your analysis won’t be operating
    on the actual pixel values because several will have been lost. GeoTIFF is a popular
    lossless format.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也在想关于数据压缩的问题，因为这在数字照片的.jpeg格式中经常使用，并且可以显著减小文件的大小。这当然是可以的，并且根据数据格式，有多种压缩类型可用。你可能听说过**有损**与**无损**压缩。有损压缩在压缩数据的过程中会丢失信息。当保存.jpeg文件时，你可能注意到了压缩质量选项。质量越高，你损失的数据越少，最终图像看起来越好。然而，.png格式是无损的，这就是为什么在保存这类文件时不会询问压缩质量。这并不意味着数据不能被压缩。这意味着在压缩过程中你不会丢失任何数据，并且图像可以被完美地重建为原始未压缩的数据集。如果你计划压缩数据但还需要对其进行分析，请确保选择一个无损算法。否则，你的分析将不会在实际的像素值上操作，因为其中一些已经丢失了。GeoTIFF是一种流行的无损格式。
- en: I have one more important concept you need to understand if you’re going to
    use raster data, and that’s the difference between resampling methods. You don’t
    have a one-to-one mapping between pixels when a raster is resampled to a different
    cell size or reprojected to another spatial reference system, so new pixel values
    have to be calculated. The simplest and fastest method, called *nearest-neighbor*,
    is to use the value from the old pixel that’s closest to the new one. Another
    possible algorithm, shown in [figure 9.5](#ch09fig05), is to take the average
    of the four closest pixels. Several other methods use multiple input pixels, such
    as bilinear, which uses a weighted average of the four closest input pixels.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算使用栅格数据，还有一个重要的概念你需要理解，那就是重采样方法之间的区别。当栅格被重采样到不同的单元格大小或重新投影到另一个空间参考系统时，像素之间没有一对一的映射，因此需要计算新的像素值。最简单、最快的方法是称为**最近邻**的方法，即使用最接近新像素的旧像素的值。另一种可能的算法，如[图9.5](#ch09fig05)所示，是取四个最近像素的平均值。还有其他几种方法使用多个输入像素，例如双线性，它使用四个最近输入像素的加权平均值。
- en: Figure 9.5\. Simple resampling example, where the average of four pixels is
    used to calculate the value for a new pixel that covers the same extent as the
    four smaller pixels
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.5\. 简单重采样示例，其中使用四个像素的平均值来计算覆盖与四个较小像素相同范围的新的像素值。
- en: '![](09fig05_alt.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![09fig05_alt.jpg](09fig05_alt.jpg)'
- en: You should always use nearest-neighbor resampling when dealing with datasets
    containing discrete values, such as the landcover classifications from [figure
    9.1](#ch09fig01). Otherwise, you might end up with a value that doesn’t correspond
    to a classification, or with a number that denotes a completely unrelated classification.
    Continuous data, on the other hand, are well-suited to the other resampling methods.
    For example, taking an average elevation value makes perfect sense, and you’ll
    get smoother output that way than if you used nearest-neighbor.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理包含离散值的集合数据时，例如[图9.1](#ch09fig01)中的土地覆盖分类，你应该始终使用最近邻重采样。否则，你可能会得到一个与分类不对应的价值，或者是一个表示完全无关分类的数字。另一方面，连续数据非常适合其他重采样方法。例如，取平均海拔值是很有意义的，而且使用这种方法得到的输出会比使用最近邻方法更平滑。
- en: 9.2\. Introduction to GDAL
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2\. GDAL简介
- en: Now that the theory is out of the way, let’s learn how to work with these datasets
    using GDAL. Numerous different file formats exist for raster data, and GDAL is
    an extremely popular and robust library for reading and writing many of them.
    The GDAL library is open source, but has a permissive license, so even many commercial
    software packages use it. Unfortunately, they don’t necessarily use it to read
    as many formats as possible, so I have students and colleagues ask me on a regular
    basis if I can convert their data into a format their software can read. Every
    time I get asked this, I point the person to GDAL and its command-line utilities.
    They’re usually amazed with what they can do with free software, and if they knew
    how to write their own code, they could do even more.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 既然理论部分已经讲完，让我们学习如何使用GDAL来处理这些数据集。栅格数据存在多种不同的文件格式，GDAL是一个极为流行且健壮的库，用于读写其中许多格式。GDAL库是开源的，但拥有宽松的许可证，因此许多商业软件包也使用它。不幸的是，它们并不一定使用它来读取尽可能多的格式，所以我经常有学生和同事问我能否将他们的数据转换成他们软件可以读取的格式。每次有人问我这个问题，我都会指向GDAL及其命令行工具。他们通常对免费软件能做什么感到惊讶，如果他们知道如何编写自己的代码，他们可以做更多的事情。
- en: The GDAL library is well known for its ability to read and write so many different
    formats, but it also contains a few data processing functions such as proximity
    analysis. You’ll still have to write your own processing code in many cases, but
    this is relatively easy for many types of analyses. There’s a Python module called
    NumPy that’s designed for processing large arrays of data, and you can use GDAL
    to read data directly into NumPy arrays. After manipulating the data however you
    need, using NumPy or another module that works with these arrays, you can write
    the array back out to disk as a raster dataset. It’s a pretty painless process.
    You’ll learn how to work directly with NumPy arrays in [chapter 11](kindle_split_019.html#ch11).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: GDAL库因其能够读写众多不同格式而广为人知，但它还包含一些数据处理功能，例如邻近度分析。在许多情况下，你仍然需要编写自己的处理代码，但对于许多类型的分析来说，这相对容易。有一个名为NumPy的Python模块，专为处理大量数据数组而设计，你可以使用GDAL将数据直接读入NumPy数组。然而，在你需要以任何方式操作数据之后，使用NumPy或与之兼容的其他模块，你可以将数组写回磁盘作为一个栅格数据集。这是一个相当无痛苦的过程。你将在第11章[chapter
    11](kindle_split_019.html#ch11)中学习如何直接与NumPy数组工作。
- en: I only use a small handful of raster formats on a regular basis, and I imagine
    that most readers of this book do the same, but nonetheless there are well over
    100 different format drivers available for GDAL, listed online at [http://www.gdal.org/formats_list.html](http://www.gdal.org/formats_list.html).
    Each one of these drivers handles reading and writing a specific data format.
    You probably won’t have all of them available with your version of GDAL, but they
    do exist. If you need a particular driver and can’t find a precompiled GDAL binary
    with that specific one, you can always compile your own customized version of
    GDAL (although this might be tricky, especially if you have no experience with
    that sort of thing). Not all drivers support the same operations, however. While
    many support reading and writing, some are read-only, and others won’t let you
    modify existing datasets, although you can create new ones. Assuming the driver
    supports the operation you have in mind, you use all of the drivers the same way.
    Most of my examples will use GeoTIFFs, but they’d work fine with other formats
    as well.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我只经常使用一小部分栅格格式，我想大多数这本书的读者也是这样，但尽管如此，GDAL有超过100种不同的格式驱动程序可用，可以在[http://www.gdal.org/formats_list.html](http://www.gdal.org/formats_list.html)上在线找到。每个驱动程序都处理读取和写入特定的数据格式。你可能不会在GDAL的版本中找到所有这些驱动程序，但它们确实存在。如果你需要一个特定的驱动程序，找不到带有该特定驱动程序的预编译GDAL二进制文件，你总是可以编译自己的定制版本的GDAL（尽管这可能很棘手，尤其是如果你没有这方面的经验）。然而，并非所有驱动程序都支持相同的操作。虽然许多支持读取和写入，但有些是只读的，还有一些不允许你修改现有的数据集，尽管你可以创建新的数据集。假设驱动程序支持你打算进行的操作，你将以相同的方式使用所有驱动程序。我的大多数示例将使用GeoTIFFs，但它们也可以与其他格式很好地工作。
- en: The basic structure of a GDAL dataset is shown in [figure 9.6](#ch09fig06) and
    matches what you’ve learned about raster datasets in general. Each dataset contains
    one or more bands, which in turn contain the pixel data and possibly overviews.
    The georeferencing information is contained in the dataset because all of the
    bands use the same information for this.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: GDAL数据集的基本结构如图[图9.6](#ch09fig06)所示，与您对栅格数据集的一般了解相匹配。每个数据集包含一个或多个波段，这些波段反过来包含像素数据和可能的概览。地理参考信息包含在数据集中，因为所有波段都使用相同的信息进行此操作。
- en: Figure 9.6\. The basic structure of a GDAL dataset. Each dataset contains one
    or more bands, which in turn contain the pixel data.
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.6. GDAL数据集的基本结构。每个数据集包含一个或多个波段，这些波段反过来包含像素数据和可能的概览。地理参考信息包含在数据集中，因为所有波段都使用相同的信息进行此操作。
- en: '![](09fig06_alt.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6的替代图](09fig06_alt.jpg)'
- en: To illustrate how to use GDAL to read and write raster data, let’s start with
    an example that combines three individual Landsat bands into one stacked image,
    as shown in [figure 9.7](#ch09fig07). The Landsat program is a joint initiative
    between the United States Geological Survey (USGS) and the National Aeronautics
    and Space Administration (NASA), and has been collecting moderate-resolution satellite
    imagery worldwide since 1972\. Landsat images are distributed by the USGS as a
    collection of GeoTIFFs, one for each collected band. With the exception of bands
    6 (thermal) and 8 (panchromatic), each of these has a 30-meter resolution and
    because they’re from the same Landsat scene, the same dimensions. This makes things
    easy, because the bands go directly on top of one another with no fiddling required.
    [Listing 9.1](#ch09ex01) shows how to create a three-band dataset with these same
    dimensions, and then copy bands 3, 2, and 1 into it. These three bands correspond
    to red, green, and blue wavelengths of visible light, respectively, so putting
    them in this order will result in an RGB (red, green, blue) image that will look
    much like it would to your own eyes. [Figure 9.7](#ch09fig07) shows the individual
    red, blue, and green bands in black and white, along with the resulting three-band
    natural color image. If you preview your images in a GIS, they’ll probably look
    similar to this because the GIS will most likely stretch them. If you view them
    somewhere else, they’ll look washed out compared to this. I chose to include the
    stretched images because you can’t see any detail at all in the others on the
    printed page. Let’s take a look at the following code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何使用GDAL读取和写入栅格数据，让我们从一个示例开始，该示例将三个单独的Landsat波段合并成一个堆叠的图像，如图[图9.7](#ch09fig07)所示。Landsat项目是美国地质调查局（USGS）和国家航空航天局（NASA）的联合倡议，自1972年以来一直在全球范围内收集中分辨率卫星影像。Landsat影像由USGS作为GeoTIFF集合分发，每个收集到的波段一个。除了波段6（热红外）和8（全色）之外，每个波段都具有30米的分辨率，并且由于它们来自相同的Landsat场景，因此具有相同的尺寸。这使得事情变得简单，因为波段直接堆叠在一起，无需调整。[代码清单9.1](#ch09ex01)展示了如何创建具有相同尺寸的三波段数据集，然后将波段3、2和1复制到其中。这三个波段分别对应于可见光的红色、绿色和蓝色波长，因此按照这个顺序将产生一个RGB（红色、绿色、蓝色）图像，看起来几乎与您自己的眼睛看到的一样。[图9.7](#ch09fig07)显示了黑白中的单个红色、蓝色和绿色波段，以及由此产生的三波段自然色彩图像。如果您在GIS中预览您的图像，它们可能看起来与此类似，因为GIS很可能会拉伸它们。如果您在其他地方查看它们，与这个相比，它们可能会显得褪色。我选择包含拉伸的图像，因为在打印页面上您几乎看不到任何细节。让我们看一下以下代码。
- en: Figure 9.7\. Red (A), green (B), and blue (C) Landsat bands are shown in black
    and white, and you can see that they look a bit different from each other. Part
    D shows these three bands stacked into an RGB image like that created by [listing
    9.1](#ch09ex01).
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.7. 黑白显示红色（A）、绿色（B）和蓝色（C）Landsat波段，您可以看到它们彼此之间略有不同。部分D显示了这三个波段堆叠成一个RGB图像，就像[代码清单9.1](#ch09ex01)中创建的那样。
- en: '![](09fig07.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7的图像](09fig07.jpg)'
- en: Listing 9.1\. Stacking individual raster bands into one image
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 代码清单9.1. 将单个栅格波段堆叠成一个图像
- en: '![](ch09ex01-0.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例的替代图](ch09ex01-0.jpg)'
- en: '![](ch09ex01-1.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例](ch09ex01-1.jpg)'
- en: What happens here? Well, the first thing you do is import the `gdal` module.
    Then you set your current directory and specify which file corresponds to which
    Landsat band. Then you open the GeoTIFF containing the first band by passing the
    filename to `gdal.Open`. You also grab a handle to the first and only band inside
    the dataset, although you haven’t read any data in yet. Notice that you use an
    index of 1 instead of 0 to get the first band. Band numbers always start with
    1 when you use `GetRasterBand`, although I frequently forget and use 0 and then
    have to fix my error. Anyway, you need this band object before creating the output
    image because it has information you need.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？好吧，你首先做的事情是导入 `gdal` 模块。然后你设置你的当前目录并指定哪个文件对应于哪个Landsat波段。然后通过传递文件名到
    `gdal.Open` 打开包含第一个波段的GeoTIFF文件。你还在数据集中获取了第一个和唯一的波段句柄，尽管你还没有读取任何数据。注意，你使用索引1而不是0来获取第一个波段。当你使用
    `GetRasterBand` 时，波段编号总是从1开始，尽管我经常忘记并使用0，然后不得不修复我的错误。无论如何，在创建输出图像之前你需要这个波段对象，因为它包含你需要的信息。
- en: '|  |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember that band indices start at 1 instead of 0.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 记住波段索引从1开始而不是0。
- en: '|  |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Next you create a new dataset to copy the pixel data into. You have to use
    a driver object to create a new dataset, so you find the GeoTIFF driver and then
    use its `Create` function. Here’s the full signature for that function:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你创建一个新的数据集以将像素数据复制进去。你必须使用驱动程序对象来创建新数据集，所以你找到GeoTIFF驱动程序然后使用它的 `Create`
    函数。这是该函数的完整签名：
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`filename` is the path to the dataset to create.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filename` 是要创建的数据集的路径。'
- en: '`xsize` is the number of columns in the new dataset.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xsize` 是新数据集中的列数。'
- en: '`ysize` is the number of rows in the new dataset.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ysize` 是新数据集中的行数。'
- en: '`bands` is the number of bands in the new dataset. The default value is 1.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bands` 是新数据集中的波段数。默认值为1。'
- en: '`data_type` is the type of data that will be stored in the new dataset. The
    default value is `GDT_Byte`.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data_type` 是新数据集中存储的数据类型。默认值为 `GDT_Byte`。'
- en: '`options` is a list of creation option strings. The possible values depend
    on the type of dataset being created.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`options` 是创建选项字符串的列表。可能的值取决于正在创建的数据集类型。'
- en: Because you use the GeoTIFF driver, the output file will be a GeoTIFF no matter
    what file extension you give it. The extension isn’t added automatically, however,
    so you do need to provide it. In this case, you call it nat_color.tif and save
    it in the D:\osgeopy-data\Landsat\Washington folder, because that’s the current
    folder set with `os.chdir`. You’re also required to provide the numbers of columns
    and rows when creating a new dataset, so you use the `XSize` and `YSize` properties,
    respectively, to get that information from the input band. The next argument to
    `Open` is the number of bands, and you want this new raster to have three of them.
    The next optional parameter is the data type, which has to be one of the values
    from [table 9.1](#ch09table01). You obtain this information from the input band,
    although you could have ignored it in this case because these images use the default
    type of `GDT_Byte`. You can also provide format-specific creation options, but
    you don’t do that here. Because every format has its own options, you need to
    consult [www.gdal.org/formats_list.html](http://www.gdal.org/formats_list.html)
    for your format of interest.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你使用了GeoTIFF驱动程序，无论你给出什么文件扩展名，输出文件都将是一个GeoTIFF。然而，扩展名不会自动添加，因此你需要提供它。在这种情况下，你将其命名为nat_color.tif并将其保存在D:\osgeopy-data\Landsat\Washington文件夹中，因为这是当前通过
    `os.chdir` 设置的文件夹。在创建新数据集时，你还必须提供列数和行数，因此你使用 `XSize` 和 `YSize` 属性分别从输入波段获取这些信息。`Open`
    函数的下一个参数是波段数，你希望这个新的栅格有三个波段。下一个可选参数是数据类型，它必须是 [表9.1](#ch09table01) 中的值之一。你可以从输入波段获取此信息，尽管在这种情况下你可以忽略它，因为这些图像使用默认类型
    `GDT_Byte`。你也可以提供特定格式的创建选项，但在这里你没有这样做。因为每个格式都有自己的选项，你需要查阅 [www.gdal.org/formats_list.html](http://www.gdal.org/formats_list.html)
    来了解你感兴趣的格式。
- en: Table 9.1\. GDAL data type constants
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表9.1\. GDAL数据类型常量
- en: '| Constant | Data type |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 常量 | 数据类型 |'
- en: '| --- | --- |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| GDT_Unknown | Unknown |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| GDT_Unknown | 未知 |'
- en: '| GDT_Byte | Unsigned 8-bit integer (byte) |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| GDT_Byte | 无符号8位整数（字节） |'
- en: '| GDT_UInt16 | Unsigned 16-bit integer |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| GDT_UInt16 | 无符号16位整数 |'
- en: '| GDT_Int16 | Signed 16-bit integer |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| GDT_Int16 | 有符号16位整数 |'
- en: '| GDT_UInt32 | Unsigned 32-bit integer |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| GDT_UInt32 | 无符号32位整数 |'
- en: '| GDT_Int32 | Signed 32-bit integer |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| GDT_Int32 | 有符号32位整数 |'
- en: '| GDT_Float32 | 32-bit floating point |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| GDT_Float32 | 32位浮点数 |'
- en: '| GDT_Float64 | 64-bit floating point |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| GDT_Float64 | 64位浮点数 |'
- en: '| GDT_CInt16 | 16-bit complex integer |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| GDT_CInt16 | 16位复数整数 |'
- en: '| GDT_CInt32 | 32-bit complex integer |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| GDT_CInt32 | 32位复数整数 |'
- en: '| GDT_CFloat32 | 32-bit complex floating point |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| GDT_CFloat32 | 32位复数浮点数 |'
- en: '| GDT_CFloat64 | 64-bit complex floating point |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| GDT_CFloat64 | 64位复数浮点数 |'
- en: '| GDT_TypeCount | Number of available data types |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| GDT_TypeCount | 可用数据类型数量 |'
- en: 'At this point you have an empty three-band dataset, but you probably want it
    to know what SRS it uses and where it’s located on the planet. The next two lines
    take care of those details, and they’re repeated here:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，您有一个空的三波段数据集，但您可能希望知道它使用什么SRS以及它在地球上的位置。接下来的两行处理这些细节，并且它们在这里重复：
- en: '[PRE1]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You get the projection (SRS) from the input dataset and copy it to the new dataset,
    and then you do the same for the *geotransform*. The geotransform is important
    because it provides the origin coordinates and pixel sizes, along with rotation
    values if the image isn’t situated so the top faces north. As you learned earlier,
    the origin and pixel size are extremely important when it comes to placing the
    dataset in the correct spatial location. Although you don’t have to add the projection
    and geotransform information before adding pixel values, I prefer to get this
    out of the way as soon as I create the new dataset.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您从输入数据集中获取投影（SRS）并将其复制到新数据集中，然后对*地理变换*也进行相同的操作。地理变换很重要，因为它提供了原点坐标和像素大小，如果图像不是面向北方的顶部，则还包括旋转值。正如您之前所学的，原点和像素大小在将数据集放置在正确的空间位置时非常重要。尽管您在添加像素值之前不必添加投影和地理变换信息，但我更喜欢在创建新数据集时立即处理这些信息。
- en: 'After setting up your dataset, it’s time to add pixel values. Because you already
    have the band object from the GeoTIFF for Landsat band 1, you can read the pixel
    values from it into a NumPy array. If you don’t provide any parameters to `ReadAsArray,`
    then all pixel values are returned in a two-dimensional array with the same dimensions
    as the raster itself. At this point your `in_data` variable holds a two-dimensional
    array of pixel values:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置完数据集后，是时候添加像素值了。因为您已经有了Landsat波段1的GeoTIFF的波段对象，您可以从其中读取像素值到一个NumPy数组中。如果您没有为`ReadAsArray`提供任何参数，则所有像素值都返回为一个与栅格本身具有相同维度的二维数组。此时，您的`in_data`变量包含一个像素值的二维数组：
- en: '[PRE2]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, because band 1 of a Landsat image is the blue band, you need to put that
    into the third band of your output image to get the bands in RGB order. The next
    thing you do is get the third band from `out_ds` and then use `WriteArray` to
    copy the values in the `in_data` array into the third band of your new dataset:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于Landsat图像的波段1是蓝色波段，您需要将其放入输出图像的第三波段，以获得RGB顺序的波段。接下来，您需要从`out_ds`获取第三波段，然后使用`WriteArray`将`in_data`数组中的值复制到新数据集的第三波段：
- en: '[PRE3]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You still need to add the green and red Landsat bands to your dataset, so then
    you open the second band’s GeoTIFF. Notice that you don’t get the band object
    from the dataset, though, because you’re going to read pixel data directly from
    the dataset itself this time. Because the second Landsat band is the green one,
    you then get a handle to the second (green) band in your stacked dataset, and
    copy the data from the Landsat file to your stacked dataset:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您仍然需要将绿色和红色Landsat波段添加到数据集中，因此您打开第二个波段的GeoTIFF。请注意，这次您并没有从数据集中获取波段对象，因为您将直接从数据集本身读取像素数据。由于第二个Landsat波段是绿色波段，因此您然后获取到堆叠数据集中第二个（绿色）波段的处理句柄，并将Landsat文件中的数据复制到堆叠数据集中：
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When you call `ReadAsArray` on a dataset, you get a three-dimensional array
    if the dataset you’re reading from has multiple bands. Because the Landsat file
    only has one band, `ReadAsArray` on the dataset returns the same two-dimensional
    array that you’d get from the band object. Instead of saving the data into an
    intermediate variable, this time you immediately send it to the output band. Then
    you do the same thing for the red pixel values, but compress it into even less
    code. The result is the same, however:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当您对一个数据集调用`ReadAsArray`时，如果您正在读取的数据集具有多个波段，您将得到一个三维数组。因为Landsat文件只有一个波段，所以对数据集的`ReadAsArray`调用返回与从波段对象获得的相同二维数组。这次您不是将数据保存到中间变量中，而是直接将其发送到输出波段。然后您对红色像素值做同样的事情，但将其压缩到更少的代码中。结果是相同的：
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the next bit of code, you compute statistics on each band in your dataset.
    This isn’t strictly necessary, but it makes it easier for some software to display
    it nicely. The statistics include mean, minimum, maximum, and standard deviation.
    A GIS can use this information to stretch the data on the screen and make it look
    better. You’ll see an example of how to stretch data manually in a later chapter.
    Before computing statistics, you have to ensure that the data have been written
    to disk instead of only cached in memory, so that’s what the call to `FlushCache`
    does. Then you loop through the bands and compute the statistics for each one.
    Passing `False` to this function tells it that you want actual statistics instead
    of estimates, which it might get from overview layers (which don’t exist yet)
    or from sampling a subset of the pixels. If an estimate is acceptable, then you
    can pass `True` instead; this will also make the calculation go faster because
    not every pixel needs to be inspected:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的代码片段中，你计算数据集中每个波段上的统计数据。这并不是严格必要的，但它使某些软件更容易以良好的方式显示它。这些统计数据包括平均值、最小值、最大值和标准差。GIS可以使用这些信息在屏幕上拉伸数据，使其看起来更好。你将在后面的章节中看到如何手动拉伸数据的示例。在计算统计数据之前，你必须确保数据已经写入磁盘而不是仅缓存在内存中，这就是调用`FlushCache`的作用。然后你遍历波段，并计算每个波段的统计数据。将`False`传递给此函数告诉它你想要实际的统计数据而不是估计值，它可能从概览层（目前还不存在）或从采样像素子集中获得。如果估计值是可以接受的，那么你可以传递`True`；这也会使计算更快，因为不需要检查每个像素：
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The last thing you do is build overview layers for the dataset. Because these
    pixel values are continuous data, you use average interpolation instead of the
    default of nearest-neighbor. You also specify five levels of overviews to build.
    It happens that five levels are what you’d need to get tiles of size 256 for this
    particular image:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你最后要做的事情是为数据集构建概览层。因为这些像素值是连续数据，所以你使用平均插值而不是默认的最邻近插值。你还指定了五个概览级别来构建。碰巧五个级别是你需要为这个特定图像获取256像素大小瓦片所需的所有级别：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Oh, and don’t forget to delete the output dataset. This will happen automatically
    when the variable goes out of scope, but this may not be when your script finishes
    running if you’re using an interactive Python environment. This is a regular occurrence
    when my students are working on their homework. They don’t flush the cache or
    delete the variable, and their IDE doesn’t release the dataset object when the
    script finishes, so they end up with an empty image and don’t know why.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，别忘了删除输出数据集。当变量超出作用域时，这会自动发生，但如果你使用的是交互式Python环境，脚本运行结束后可能不会这样。当我的学生做作业时，这经常发生。他们没有刷新缓存或删除变量，而且当脚本结束时，他们的IDE没有释放数据集对象，所以他们最终得到一个空白的图像，却不知道为什么。
- en: '|  |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Other modules for working with raster data**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**用于处理栅格数据的其他模块**'
- en: If you’d like to play with a module that uses more “Pythonic” syntax but still
    harnesses the power of GDAL, check out rasterio at [https://github.com/mapbox/rasterio](https://github.com/mapbox/rasterio).
    This module depends on GDAL and uses it internally to read and write data, but
    it tries to make the process of working with raster data a little easier.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要尝试一个使用更多“Pythonic”语法但仍然利用GDAL功能的模块，请查看[rasterio](https://github.com/mapbox/rasterio)。此模块依赖于GDAL并在内部使用它来读取和写入数据，但它试图使处理栅格数据的过程变得更容易一些。
- en: Another module that might be of interest is imageio. This one is written in
    pure Python and doesn’t rely on GDAL. It doesn’t focus on geospatial data, but
    it can read and write many different raster formats, including video formats.
    You can read more about it at [http://imageio.github.io/](http://imageio.github.io/).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能引起你兴趣的模块是imageio。这个模块是用纯Python编写的，不依赖于GDAL。它不专注于地理空间数据，但可以读取和写入许多不同的栅格格式，包括视频格式。你可以在[http://imageio.github.io/](http://imageio.github.io/)了解更多关于它的信息。
- en: '|  |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 9.3\. Reading partial *datasets*
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3\. 读取部分 *数据集*
- en: In [listing 9.1](#ch09ex01) you read and wrote entire bands of data at a time.
    You can break it up into chunks if you need to, however. This might be because
    you only need a spatial subset of the data to begin with, or maybe you don’t have
    enough RAM to hold it all at once. Let’s a take a look at how you can access subsets
    instead of the entire images.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表9.1](#ch09ex01)中，你一次读取和写入整个数据带。然而，如果你需要，你可以将其分成块。这可能是因为你最初只需要数据的空间子集，或者可能你没有足够的RAM一次性存储所有内容。让我们看看如何访问子集而不是整个图像。
- en: The `ReadAsArray` function has several optional parameters, although they differ
    depending on whether you’re using a dataset or a band.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadAsArray` 函数有几个可选参数，尽管它们取决于你是在使用数据集还是波段。'
- en: 'Here’s the signature for the band version:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是波段版本的签名：
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`xoff` is the column to start reading at. The default value is 0.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xoff` 是开始读取的列。默认值是 0。'
- en: '`yoff` is the row to start reading at. The default value is 0.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yoff` 是开始读取的行。默认值是 0。'
- en: '`win_xsize` is the number of columns to read. The default is to read them all.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`win_xsize` 是要读取的列数。默认情况下，读取所有列。'
- en: '`win_ysize` is the number of rows to read. The default is to read them all.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`win_ysize` 是要读取的行数。默认情况下，读取所有行。'
- en: '`buf_xsize` is the number of columns in the output array. The default is to
    use the `win_xsize` value. Data will be resampled if this value is different than
    `win_xsize`.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buf_xsize` 是输出数组中的列数。默认情况下，使用 `win_xsize` 值。如果此值与 `win_xsize` 不同，则将进行数据重采样。'
- en: '`buf_ysize` is the number of rows in the output array. The default is to use
    the `win_ysize` value. Data will be resampled if this value is different than
    `win_ysize`.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buf_ysize` 是输出数组中的行数。默认情况下，使用 `win_ysize` 值。如果此值与 `win_ysize` 不同，则将进行数据重采样。'
- en: '`buf_obj` is a NumPy array to put the data into instead of creating a new array.
    Data will be resampled, if needed, to fit into this array. Values will also be
    converted to the data type of this array.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buf_obj` 是一个 NumPy 数组，用于将数据放入其中而不是创建新数组。如果需要，数据将重采样以适应此数组。值也将转换为此数组的数据类型。'
- en: The `xoff` and `yoff` parameters specify the column and row offsets, respectively,
    to start reading at. The default is to start reading at the first row and column.
    The `win_xsize` and `win_ysize` parameters indicate how many rows and columns
    to read, and the default is to read them all. The `buf_xsize` and `buf_ysize`
    parameters allow you to specify the size of the output array. If these values
    are different than the `win_xsize` and `win_ysize` values, then the data will
    be resampled as it’s read to match the output array size. The `buf_obj` parameter
    is a NumPy array that the data will be stored in instead of a new array being
    created. The pixel data type will be changed to match the data type of this array.
    You’ll get an error if you provide `buf_xsize` and `buf_ysize` values that don’t
    match the dimensions of this array, but there’s no reason to provide sizes in
    that case anyway, because they can be determined from the array itself.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`xoff` 和 `yoff` 参数分别指定开始读取的列和行偏移量。默认情况下，从第一行和第一列开始读取。`win_xsize` 和 `win_ysize`
    参数指示要读取的行和列数，默认情况下读取所有行。`buf_xsize` 和 `buf_ysize` 参数允许你指定输出数组的大小。如果这些值与 `win_xsize`
    和 `win_ysize` 值不同，则数据在读取时将进行重采样以匹配输出数组大小。`buf_obj` 参数是一个 NumPy 数组，数据将存储在此数组中而不是创建新数组。像素数据类型将更改为与此数组的数据类型匹配。如果你提供的
    `buf_xsize` 和 `buf_ysize` 值与数组的维度不匹配，则会出错，但在此情况下提供大小也没有必要，因为它们可以从数组本身确定。'
- en: 'For example, to read the three rows and six columns starting at row 6000 and
    column 1400 shown in [figure 9.8](#ch09fig08), you could do something like the
    following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要读取从第 6000 行和第 1400 列开始的 3 行和 6 列，如 [图 9.8](#ch09fig08) 所示，你可以执行以下操作：
- en: '[PRE9]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Figure 9.8\. Use `ReadAsArray(1400, 6000, 6, 3)` to read three rows and six
    columns starting at row 6000 and column 1400.
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 `ReadAsArray(1400, 6000, 6, 3)` 读取从第 6000 行和第 1400 列开始的 3 行和 6 列。
- en: '![](09fig08.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](09fig08.jpg)'
- en: 'If you need the pixel values as floating-point instead of byte, you can convert
    them using NumPy after you’ve read them in, like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要以浮点数而不是字节的形式获取像素值，你可以在读取后使用 NumPy 进行转换，如下所示：
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Or you could have GDAL do the conversion for you as it reads the data. To use
    this method, you create a floating-point array and then pass it as the `buf_obj`
    parameter to `ReadAsArray`. Make sure you create the array with the same dimensions
    as the data being read.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在读取数据时让 GDAL 帮你进行转换。要使用此方法，你创建一个浮点数组，然后将它作为 `buf_obj` 参数传递给 `ReadAsArray`。确保你创建的数组与正在读取的数据具有相同的维度。
- en: '[PRE11]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The NumPy `empty` function creates an array that hasn’t been initialized with
    any values, so it contains garbage until you fill it somehow. The first parameter
    to the function is a tuple containing the dimensions of the array to create. If
    it’s a two-dimensional array, the tuple contains the number of rows and then the
    number of columns. The `dtype` parameter is optional and specifies the type of
    data that the array will hold. If not provided, the array will hold floating-point
    numbers.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy的`empty`函数创建一个未初始化任何值的数组，因此它包含垃圾数据，直到你以某种方式填充它。函数的第一个参数是一个包含要创建的数组维度的元组。如果是一个二维数组，元组包含行数和列数。`dtype`参数是可选的，它指定数组将持有的数据类型。如果没有提供，数组将包含浮点数。
- en: To write a data array out to a specific location in other dataset, pass the
    offsets to `WriteArray`. It will write out all data in the array you pass to the
    function, beginning at the offsets you provide.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据数组写入其他数据集的特定位置，请将偏移量传递给`WriteArray`。它将从你提供的偏移量开始，将你传递给函数的数组中的所有数据写出来。
- en: '[PRE12]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: One important thing to remember when reading partial datasets is that you have
    to make sure you don’t try to read more data than exists, or you’ll get an error.
    For example, if an image has 100 rows, and you ask it to start reading at offset
    75 and read in 30 rows, that would go past the end of the image and will fail.
    A similar problem will occur if you pass an array to `WriteArray` that’s too large
    to fit in the raster, given your starting offsets.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取部分数据集时，有一件重要的事情要记住，你必须确保不要尝试读取比存在更多的数据，否则你会得到一个错误。例如，如果一个图像有100行，而你要求它从偏移量75开始读取30行，那么它就会超出图像的末尾并失败。如果你传递给`WriteArray`的数组太大而无法适应栅格，给定你的起始偏移量，也会出现类似的问题。
- en: '|  |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Access window out of range error messages**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**超出范围的访问窗口错误信息**'
- en: The following message means that I tried to read a 30 x 30 array from band 1
    of testio.tif, starting at column 0 and row 75. The problem is that testio.tif
    only has 100 rows and 100 columns, so there aren’t 30 rows to read if I start
    at number 75.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下信息意味着我尝试从testio.tif的波段1读取一个30x30的数组，从列0和行75开始。问题是testio.tif只有100行和100列，所以如果我从75开始，就没有30行可以读取。
- en: '“ERROR 5: testio.tif, band 1: Access window out of range in RasterIO(). Requested
    (0,75) of size 30x30 on raster of 100x100.”'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: “错误5：testio.tif，波段1：在RasterIO()中访问窗口超出范围。请求的(0,75)大小为30x30，在100x100的栅格上。”
- en: '|  |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: How might you use this information to process a large dataset that won’t fit
    in RAM? Well, one way would be to deal with a single block at a time. Remember
    that rasters store their data on disk in blocks. Because the data in a block are
    stored together on disk, it’s efficient to process images in these chunks.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何使用这些信息来处理一个无法装入RAM的大数据集呢？嗯，一种方法是一次处理一个数据块。记住，栅格数据在磁盘上以块的形式存储数据。因为一个块中的数据在磁盘上是存储在一起的，所以以这些块为单位处理图像是高效的。
- en: The basic idea is shown in [figure 9.9](#ch09fig09). You start with the first
    block of rows and columns, and then go to the next block in either the x or y
    direction (this example uses the latter). Each time you jump to the next block,
    you need to make sure there’s really a full block’s worth of data to read. For
    example, if the block size is 64 rows, you need to check that at least 64 rows
    are left that you haven’t read yet. If there aren’t, then you can only read in
    as many as are left, and you’ll get an error if you try to access more. Once you’ve
    worked your way to the end, you move to the next block of columns and start over,
    working through the rows. Again, you always need to make sure that you don’t try
    to read more columns than exist in the raster.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 基本思想在[图9.9](#ch09fig09)中展示。你从第一行的第一个块开始，然后要么在x方向要么在y方向移动到下一个块（这个例子使用后者）。每次跳转到下一个块时，你需要确保确实有足够的数据来读取一个完整的块。例如，如果块大小是64行，你需要检查至少还有64行是你还没有读取的。如果没有，那么你只能读取剩下的所有行，如果你尝试读取更多，你会得到一个错误。一旦你到达末尾，你移动到下一列的块并重新开始，逐行处理。同样，你总是需要确保不要尝试读取比栅格中存在的列更多的列。
- en: Figure 9.9\. The process for reading and writing a raster block by block
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.9。按块读取和写入栅格的过程
- en: '![](09fig09_alt.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](09fig09_alt.jpg)'
- en: '[Listing 9.2](#ch09ex02) shows how you might convert a digital elevation model
    from meters to feet, one block at a time. This is a small dataset, so you probably
    wouldn’t need to break it up like this in the real world, but you would process
    a large dataset in the same way. This also shows you an example of dealing with
    `NoData` values in your raster, which are pixels that are considered to have a
    null value. Pixels must have a value, but a specific value can be specified as
    `NoData`, and therefore ignored.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表9.2](#ch09ex02)展示了如何将数字高程模型从米转换为英尺，一次处理一个块。这是一个小型数据集，所以在现实世界中你可能不需要这样分割，但你将以相同的方式处理大型数据集。这也展示了处理栅格中的`NoData`值的例子，这些像素被认为是具有空值的。像素必须有值，但可以指定一个特定的值作为`NoData`，因此被忽略。'
- en: Listing 9.2\. Processing a raster by block
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.2\. 通过块处理栅格
- en: '![](ch09ex02-0.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex02-0.jpg)'
- en: '![](ch09ex02-1.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex02-1.jpg)'
- en: You can probably figure out what’s happening at the beginning of this example.
    You open the dataset and get information about the band, including the size of
    its blocks and its `NoData` value. After creating the output dataset, you start
    looping through the blocks in the horizontal (x) direction. You start at column
    0 and go up to the last column, represented with index `xsize`. The twist is that
    each time through the loop, you increment `x` by the number of columns in a block
    (the third argument to `range` is the amount to increment by), so you skip from
    the beginning of one block to the beginning of the next. Then you store the number
    of columns to read in a variable called `cols`. If there’s a full block’s worth
    of columns left to read, this variable is set to the number of columns in a block.
    But if there aren’t enough columns, as would be the case when `x` is equal to
    10 in [figure 9.10](#ch09fig10), the number of remaining columns (three in the
    figure) is used instead. You need to do this because you’ll get an error if you
    try to read more rows or columns than exist.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经能猜出这个例子开始时发生了什么。你打开数据集并获取有关波段的信息，包括其块的大小和`NoData`值。在创建输出数据集后，你开始按水平方向（x）遍历块。你从列0开始，直到最后一个列，用索引`xsize`表示。转折点是每次通过循环时，你将`x`增加一个块中的列数（`range`的第三个参数是增加的量），因此你从一块的开始跳到下一块的开始。然后你将需要读取的列数存储在一个名为`cols`的变量中。如果有足够的列可以读取一个完整的块，这个变量就设置为块中的列数。但如果列数不足，就像在图9.10中`x`等于10时的情况，就使用剩余的列数（图中为三列）代替。你需要这样做，因为如果你尝试读取比实际存在的行或列更多的数据，你会得到一个错误。
- en: Figure 9.10\. A small example image with a block size of five rows and five
    columns. Alternating blocks are shaded to make it easy to see. The upper-left
    pixel has offset 0,0.
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.10\. 一个具有五行五列块大小的示例图像。交替的块被阴影覆盖，以便于观察。左上角的像素偏移为0,0。
- en: '![](09fig10.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig10.jpg)'
- en: After computing the number of columns to read, you repeat the process for the
    number of rows. As shown in [figure 9.10](#ch09fig10), the first two times through
    that second loop you read five rows, but the third time there’s only one row left
    to read. After processing the first five columns of all rows, you go to the next
    iteration of the outer loop and process the next five columns, and then the last
    three columns.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算要读取的列数之后，你重复这个过程来读取行数。如图9.10所示，在第二次循环的前两次迭代中，你读取了五行，但在第三次迭代时只剩下了一行需要读取。在处理完所有行的前五列之后，你进入外层循环的下一个迭代，并处理下一组五列，然后是最后的三列。
- en: 'Once you figure out how many rows and columns to read, you pass those numbers,
    along with the current row and column offsets, to `ReadAsArray` to get a block’s
    worth of data back:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确定了要读取的行数和列数，你就可以将这些数字，连同当前的行和列偏移量，传递给`ReadAsArray`以获取一个数据块的数据：
- en: '[PRE13]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The next step is to convert the values, which come in as meters, to feet. You
    use the NumPy `where` function to help with this. This function is like an if-else
    statement. The first parameter is the condition to check, in this case whether
    or not the pixel value is equal to the `NoData` value. The second parameter is
    the output value if the condition is true. If the incoming pixel is `NoData`,
    you output `NoData` as well. The third parameter is the value to output if the
    condition is false, so this is where you convert the values to feet by multiplying
    them by 3.28084:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将值从米转换为英尺。你使用 NumPy 的 `where` 函数来帮助完成这项工作。这个函数就像一个 if-else 语句。第一个参数是要检查的条件，在这种情况下是像素值是否等于
    `NoData` 值。第二个参数是在条件为真时的输出值。如果传入的像素是 `NoData`，你也输出 `NoData`。第三个参数是在条件为假时的输出值，因此你在这里通过乘以
    3.28084 将值转换为英尺：
- en: '[PRE14]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After converting valid pixels to feet, you pass the data to `WriteArray` using
    the current row and column offsets before continuing on to the next block:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在将有效像素转换为英尺后，你将数据传递给 `WriteArray`，使用当前的行和列偏移量，然后再继续到下一个块：
- en: '[PRE15]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: After processing all of the blocks, you calculate statistics and build the overviews.
    To exclude the `NoData` pixels from the statistics calculation, you have to tell
    the band which value represents `NoData` before calling `ComputeStatistics`. You
    might be tempted to calculate statistics inside your loop, but you want the statistics
    to be based on all of the pixels in the band, so you need to wait until all of
    the pixel values have been calculated.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完所有块后，你计算统计数据并构建预览。为了从统计数据计算中排除 `NoData` 像素，你必须在调用 `ComputeStatistics` 之前告诉波段哪个值代表
    `NoData`。你可能想在你循环内部计算统计数据，但你想让统计数据基于波段中的所有像素，因此你需要等待所有像素值都被计算出来。
- en: Obviously this method of looping through blocks is more complicated than reading
    and writing an entire band at once, but it’s invaluable if you’re low on RAM.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这种方法通过循环块比一次性读取和写入整个波段更复杂，但如果你的 RAM 不足，它非常有价值。
- en: 9.3.1\. Using real-world coordinates
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.1\. 使用实际世界坐标
- en: Until now, we’ve only considered pixel offsets when deciding where to start
    reading or writing data, but most of the time you’ll have real-world coordinates
    instead. Fortunately, converting between the two is easy, as long as your coordinates
    use the same SRS as the raster. You saw earlier how to calculate coordinates of
    individual pixels, and now you need to reverse that process. All of the data required,
    including the origin coordinates, pixel sizes, and rotation values, are stored
    in the geotransform you’ve been copying between datasets. The geotransform is
    a tuple containing the six values shown in [table 9.2](#ch09table02). The rotation
    values are usually 0; in fact, I can’t recall ever using an image that wasn’t
    north up, but they’re certainly out there.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一直以来，我们在决定从何处开始读取或写入数据时，只考虑了像素偏移，但大多数情况下，你会有实际世界的坐标。幸运的是，只要你的坐标使用与栅格相同的 SRS，两者之间的转换就很容易。你之前已经看到了如何计算单个像素的坐标，现在你需要进行相反的过程。所需的所有数据，包括原始坐标、像素大小和旋转值，都存储在你一直在数据集之间复制的地理变换中。地理变换是一个包含
    [表 9.2](#ch09table02) 中所示六个值的元组。旋转值通常是 0；实际上，我想不起来曾经使用过不是北向上的图像，但它们确实存在。
- en: Table 9.2\. `GeoTransform` items
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 9.2\. `GeoTransform` 项
- en: '| Index | Description |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| Index | 描述 |'
- en: '| --- | --- |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 | Origin x coordinate |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 原始 x 坐标 |'
- en: '| 1 | Pixel width |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 像素宽度 |'
- en: '| 2 | x pixel rotation (0° if image is north up) |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 2 | x 像素旋转（如果图像为北向上，则为 0°） |'
- en: '| 3 | Origin y coordinate |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 原始 y 坐标 |'
- en: '| 4 | y pixel rotation (0° if image is north up) |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 4 | y 像素旋转（如果图像为北向上，则为 0°） |'
- en: '| 5 | Pixel height (negative) |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 像素高度（负值） |'
- en: 'You could use this information to apply the affine transformation yourself,
    but GDAL provides a function that does it for you, called `ApplyGeoTransform`,
    that takes a geotransform, an x value, and a y value. When used with a dataset’s
    geotransform, this function converts image coordinates (offsets) to real-world
    coordinates. But right now you’re interested in going the other direction, so
    you need to get the inverse of the dataset’s geotransform. Fortunately, a function
    exists for that, but you use it differently depending on the version of GDAL that
    you’re using. If you’re using GDAL 1.x, the `InvGeoTransform` function returns
    a success flag and a new geotransform that can be used to go the other direction:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些信息来自己应用仿射变换，但GDAL提供了一个名为`ApplyGeoTransform`的函数，它为你完成这项工作，该函数接受一个地理变换、一个x值和一个y值。当与数据集的地理变换一起使用时，此函数将图像坐标（偏移量）转换为实际坐标。但你现在感兴趣的是相反的方向，所以你需要获取数据集地理变换的逆变换。幸运的是，存在一个函数可以做到这一点，但根据你使用的GDAL版本，你使用它的方式不同。如果你使用GDAL
    1.x，`InvGeoTransform`函数返回一个成功标志和一个可以用于相反方向的新地理变换：
- en: '[PRE16]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If all went well, then the success flag will be 1, but if the affine transformation
    couldn’t be inverted, it returns 0 instead. Because of this, you should check
    the value of the success flag before continuing if you’re not certain that the
    geotransform can be inverted.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，则成功标志将为1，但如果仿射变换无法反转，则返回0。因此，如果你不确定地理变换是否可以反转，你应该在继续之前检查成功标志的值。
- en: 'If you’re using GDAL 2.x, then the `InvGeoTransform` function only returns
    one item: a geotransform if one could be calculated, or `None` if not. In this
    case, you need to make sure that the returned value isn’t equal to `None`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用GDAL 2.x，那么`InvGeoTransform`函数只返回一个项目：如果可以计算，则返回地理变换，否则返回`None`。在这种情况下，你需要确保返回的值不等于`None`：
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now that you have an inverse geotransform, you can use it to convert real-world
    coordinates to image coordinates. For example, say you need the pixel value at
    coordinates 465200, 5296000\. The following code would get it, assuming that the
    raster covers that location:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了逆地理变换，你可以使用它将实际坐标转换为图像坐标。例如，假设你需要坐标465200，5296000处的像素值。以下代码可以获取它，假设栅格覆盖了该位置：
- en: '[PRE18]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `ApplyGeoTransform` function returns an x and a y value as floating-point
    numbers, but you need integer offsets to pass to `ReadAsArray`. If you forget
    to convert the offsets to integers, you’ll get an error. After getting the integers,
    you read in one row and one column starting at those offsets. You might think
    that this would return a number, but not quite. Remember that `ReadAsArray` returns
    a two-dimensional array, and it does this even for only one row and/or one column.
    To get the actual pixel value, you still have to get the value in the first row
    and first column (position [0,0]) in the array.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApplyGeoTransform`函数返回一个x值和一个y值作为浮点数，但你需要整数偏移量来传递给`ReadAsArray`。如果你忘记将偏移量转换为整数，你会得到一个错误。在得到整数后，你从这些偏移量开始读取一行和一列。你可能认为这将返回一个数字，但并非如此。记住，`ReadAsArray`返回一个二维数组，即使只读取一行和/或一列也是如此。要获取实际的像素值，你仍然需要在数组的第一个行和第一个列（位置[0,0]）中获取该值。'
- en: 'This method is extremely inefficient if you need to sample pixel values at
    many different locations, however. In that case, you’re better off reading in
    the entire band and then pulling the appropriate values from that array. This
    is because read and write operations are expensive, so doing a new read operation
    for each point is much slower than doing one large read operation for the whole
    band. The code to get the same pixel value using this method might look like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在不同位置采样像素值，这种方法非常低效。在这种情况下，你最好读取整个波段，然后从该数组中提取适当的值。这是因为读写操作很昂贵，所以为每个点进行新的读取操作比为整个波段进行一次大读取操作要慢得多。使用这种方法获取相同像素值的代码可能如下所示：
- en: '[PRE19]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Obviously, you wouldn’t read the whole band in for each point; you’d do that
    once but then repeat the last two lines for each point. Notice that the row and
    column offsets are reversed when pulling the pixel value from the NumPy array,
    because NumPy wants offsets as [row, column], not [x, y] (which is the same as
    [column, row]).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你不会为每个点都读取整个波段；你只会做一次，然后为每个点重复最后两行。请注意，在从NumPy数组中提取像素值时，行和列的偏移量是相反的，因为NumPy希望偏移量为[row,
    column]，而不是[x, y]（这与[column, row]相同）。
- en: '|  |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Use [row, column] offsets for NumPy arrays. This is the reverse of what you’re
    used to using with GDAL.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [行, 列] 偏移量来表示 NumPy 数组。这与你习惯使用的 GDAL 方式相反。
- en: '|  |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The ability to convert between real-world coordinates and offsets is also important
    if you want to extract a spatial subset and save it to a new image, because you
    need to change the origin coordinates in the geotransform. Say you wanted to extract
    Vashon Island ([figure 9.11](#ch09fig11)) out of the natural color Landsat image
    you created earlier, and you’re given the upper-left and lower-right coordinates
    of the area of interest. You need to convert these into pixel offsets so you know
    what data to read, but it’s unlikely that these bounding coordinates correspond
    exactly to pixel boundaries, so you also need to find the true upper-left coordinates
    for the subset you extracted. The following listing shows an example of this.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想提取空间子集并将其保存到新图像中，那么在真实世界坐标和偏移量之间进行转换的能力也很重要，因为你需要更改地理变换中的原点坐标。比如说，你想要从之前创建的自然色
    Landsat 图像中提取瓦肖岛（[图 9.11](#ch09fig11)），并且你得到了感兴趣区域的左上角和右下角坐标。你需要将这些坐标转换为像素偏移量，以便知道要读取哪些数据，但很可能这些边界坐标并不完全对应于像素边界，因此你还需要找到你提取的子集的真正左上角坐标。下面的列表展示了这个例子。
- en: Figure 9.11\. The goal of [listing 9.3](#ch09ex03) is to extract Vashon Island
    out of the natural color Landsat image created earlier.
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.11\. 列表 9.3 的目标是提取之前创建的自然色 Landsat 图像中的瓦肖岛。
- en: '![](09fig11.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig11.jpg)'
- en: Listing 9.3\. Extracting and saving a subset of an image
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.3\. 提取并保存图像的子集
- en: '![](ch09ex03-0.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex03-0.jpg)'
- en: '![](ch09ex03-1.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex03-1.jpg)'
- en: You’ve seen everything in this example before, but you haven’t seen it put together
    quite like this. The important parts are where you compute the offsets for the
    upper-left and lower-right corners of Vashon Island, based on the coordinates
    at the top of the script (in real life you probably wouldn’t want the coordinates
    hardcoded in, but it works for the example). Then you subtract the upper-left
    offsets from the lower-right offsets to get the total numbers of rows and columns
    to extract.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这个例子中之前已经看到过所有这些内容，但你还没有看到它们以这种方式组合在一起。重要的部分是你在脚本顶部（在现实生活中你可能不希望硬编码坐标，但这对示例来说是可以的）根据坐标计算瓦肖岛左上角和右下角的偏移量。然后你从右下角的偏移量中减去左上角的偏移量，以得到要提取的总行数和列数。
- en: Once you have that basic information, you create an output image with these
    new dimensions, rather than the dimensions of the original image. The projection
    information is copied over unchanged, but you have to alter the geotransform to
    reflect the upper-left coordinates of the subset. You can’t use the upper-left
    coordinates that you calculated because those probably fall in the middle of a
    pixel somewhere, but you need the coordinates of the pixel corner. Notice that
    you use the original geotransform for this, not the inverted one, because you’re
    converting offsets to real-world coordinates. Then, because the geotransform is
    returned as a tuple, you have to convert it to a list before you can insert the
    new upper-left coordinates.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了这些基本信息，你将创建一个具有这些新尺寸的输出图像，而不是原始图像的尺寸。投影信息保持不变，但你需要修改地理变换以反映子集的左上角坐标。你不能使用你计算出的左上角坐标，因为它们可能位于某个像素的中间，但你需要像素角落的坐标。请注意，你使用原始地理变换来完成这个任务，而不是反转的地理变换，因为你是将偏移量转换为真实世界坐标。然后，因为地理变换是以元组的形式返回的，你必须在插入新的左上角坐标之前将其转换为列表。
- en: After all that housekeeping, you copy the data from the original to the new
    image. You start reading at the upper-left offsets, and grab the numbers of columns
    and rows that you computed earlier. There’s no reason to provide offsets when
    writing the data out because the new image will only contain the subset, so you
    want to start writing at the origin.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有这些准备工作之后，你将数据从原始图像复制到新图像中。你从左上角的偏移量开始读取，并获取之前计算出的列数和行数。在写入数据时提供偏移量没有理由，因为新图像将只包含子集，所以你想要从原点开始写入。
- en: You’d probably also compute statistics and build overviews, but those steps
    aren’t absolutely necessary, so I left them out in the interest of space.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还会计算统计数据并构建预览，但这些步骤并不是绝对必要的，所以为了节省空间，我省略了它们。
- en: 9.3.2\. Resampling data
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.2\. 重采样数据
- en: 'A nice feature of the `ReadAsArray` function is that you can use it to resample
    data as it’s read in, either by specifying the output buffer size or passing an
    existing buffer array. As a reminder, here’s what the function signature looks
    like:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadAsArray` 函数的一个优点是，你可以用它来在读取数据时进行重采样，无论是通过指定输出缓冲区大小还是传递现有的缓冲区数组。提醒一下，这个函数的签名看起来是这样的：'
- en: '[PRE20]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `win` parameters specify the number of rows and columns to read from the
    band, and the `buf` parameters specify the size of the array to put those pixel
    values into. An array with larger dimensions than the original will resample to
    smaller pixels, while one with smaller dimensions will resample to larger pixels
    using nearest-neighbor interpolation.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`win` 参数指定从波段中读取的行数和列数，而 `buf` 参数指定将那些像素值放入的数组的大小。一个比原始数据维度更大的数组将重采样到更小的像素，而一个比原始数据维度小的数组将使用最近邻插值重采样到更大的像素。'
- en: Resampling to smaller pixels
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 重采样到更小的像素
- en: 'To resample data to a finer resolution, provide an array that’s larger than
    the data being read in so that the pixel values need to be repeated to fill the
    target array. For example, this will create four pixels for every one pixel, essentially
    cutting the pixel size in half, as shown in [figure 9.12](#ch09fig12):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据重采样到更精细的分辨率，提供一个比正在读取的数据更大的数组，这样像素值就需要重复以填充目标数组。例如，这将创建每个像素四个像素，实际上将像素大小减半，如图
    9.12 所示：
- en: '[PRE21]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Figure 9.12\. Pixel values are repeated four times each when the numbers of
    rows and columns are doubled.
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.12\. 当行数和列数翻倍时，像素值重复四次。
- en: '![](09fig12_alt.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig12_alt.jpg)'
- en: This works because you’re reading three columns and two rows from the band,
    but putting that data into an array with six columns and four rows, so each row
    and column is duplicated to fill the output array.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为你从波段中读取了三列和两行，但将这些数据放入一个六列四行的数组中，所以每一行和每一列都被复制以填充输出数组。
- en: This is all well and good, but how do you deal with the new cell size if you
    need to write the data out to a new image? It’s easy, because all you have to
    do is alter the geotransform so that it specifies a smaller pixel size. Take a
    look at the following listing to see how you might resample an entire image to
    a smaller pixel size.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这都很好，但如果你需要将数据写入新的图像，如何处理新的单元格大小？这很简单，因为你只需要修改地理变换，使其指定更小的像素大小。看看以下列表，看看你如何将整个图像重采样到更小的像素大小。
- en: Listing 9.4\. Resample an image to a smaller pixel size
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.4\. 将图像重采样到更小的像素大小
- en: '![](ch09ex04-0.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex04-0.jpg)'
- en: '![](ch09ex04-1.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex04-1.jpg)'
- en: This example has a few important things to note. First, you double the number
    of rows and columns when creating the new dataset, and you pass these same numbers
    as parameters to `ReadAsArray`. This ensures that your input data dimensions match
    your output data dimensions, and also causes the data to be resampled to those
    larger dimensions. Instead of using the `buf_xsize` and `buf_ysize` parameters,
    you could have used an existing array for the `buf_obj` parameter and gotten the
    same results. You could also have provided the `win_xsize` and `win_ysize` parameters,
    but they default to the original numbers of rows and columns, which is what you
    want.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子有几个需要注意的重要事项。首先，在创建新的数据集时，你将行数和列数翻倍，并将这些相同的数字作为参数传递给 `ReadAsArray`。这确保了你的输入数据维度与输出数据维度相匹配，并且也会导致数据被重采样到更大的维度。你本可以使用现有的数组作为
    `buf_obj` 参数的值来获得相同的结果。你也可以提供 `win_xsize` 和 `win_ysize` 参数，但它们的默认值是原始的行数和列数，这正是你想要的。
- en: You also edit the geotransform to reflect the smaller pixel size. The second
    item in the geotransform is the pixel width, and the sixth is the pixel height,
    so you divide each of those values by two and overwrite the original values. Because
    this image still covers the same spatial extent as the original, you don’t need
    to change any of the other values. Once you finish editing, you set the geotransform
    onto the new dataset. Fortunately, editing the geotransform doesn’t alter the
    geotransform for the original image because the tuple isn’t linked to the dataset,
    so you’re not introducing any complications there.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以编辑地理变换来反映更小的像素大小。地理变换中的第二项是像素宽度，第六项是像素高度，所以你需要将每个值除以二并覆盖原始值。因为这个图像仍然覆盖了与原始图像相同的空间范围，所以你不需要更改其他任何值。一旦完成编辑，你将地理变换设置到新的数据集上。幸运的是，编辑地理变换不会改变原始图像的地理变换，因为元组没有链接到数据集，所以你不会引入任何复杂性。
- en: If you hadn’t changed the pixel size and instead copied the original geotransform
    to the new dataset, your output would have looked like the larger image shown
    in [figure 9.13](#ch09fig13). As you may recall, the spatial extent of a raster
    is determined from the origin coordinates and the pixel size. The upper-left corner
    coordinates would be the same, but the incorrect pixel size would cause the image
    to cover twice the distance in each direction. In this case, a satellite image
    of northwestern Washington State would appear to extend into eastern Washington
    and south into Oregon, which is obviously incorrect. It should be clear by now
    how important an accurate geotransform is. If a raster appears to be in the wrong
    location or the wrong size when opened in a GIS, then an incorrect geotransform
    is a likely culprit, as is an erroneous spatial reference system.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有改变像素大小，而是将原始地理变换复制到新的数据集中，你的输出将看起来像[图9.13](#ch09fig13)中显示的较大图像。你可能还记得，栅格的空间范围是由原点坐标和像素大小确定的。左上角的坐标将是相同的，但错误的像素大小会导致图像在每个方向上覆盖两倍的距离。在这种情况下，华盛顿州西北部的卫星图像看起来会延伸到华盛顿州东部和向南到俄勒冈州，这显然是不正确的。现在应该很清楚准确的地理变换有多么重要。如果一个栅格在GIS中打开时看起来位置或大小不正确，那么一个不正确的地理变换很可能是罪魁祸首，同样，一个错误的空间参考系统也是如此。
- en: Figure 9.13\. This illustrates the result of resampling to a smaller pixel size
    without changing the size in the geotransform. The smaller image in the upper
    left is correct. The larger one was created by using the unedited geotransform
    from the input image.
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.13\. 这说明了在不改变地理变换大小的情况下重采样到更小像素尺寸的结果。左上角的较小图像是正确的。较大的图像是通过使用输入图像的未编辑地理变换创建的。
- en: '![](09fig13.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](09fig13.jpg)'
- en: Resampling to larger pixels
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 重采样到更大的像素
- en: 'You can also resample to a coarser resolution by providing a smaller buffer
    array when reading the data. In this case, one pixel takes the place of several
    cells, and nearest-neighbor interpolation is used to determine which value is
    used ([figure 9.14](#ch09fig14)). The following example replaces four pixels with
    one:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取数据时，你也可以通过提供一个较小的缓冲区数组来重采样到一个更粗糙的分辨率。在这种情况下，一个像素代替了几个单元格，并使用最近邻插值来确定使用哪个值（[图9.14](#ch09fig14)）。以下示例将四个像素替换为一个：
- en: '[PRE22]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Figure 9.14\. Nearest-neighbor interpolation is used to select a pixel value
    when resampling to smaller dimensions. In this case, the lower-right pixel value
    for each block of four pixels is used in the output.
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.14\. 在重采样到更小的维度时，使用最近邻插值来选择像素值。在这种情况下，每个四像素块的右下角像素值用于输出。
- en: '![](09fig14_alt.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图片](09fig14_alt.jpg)'
- en: Here, an empty integer NumPy array with three columns and two rows is created
    beforehand and then passed as an argument to `ReadAsArray`. The six columns and
    four rows requested from the image are resampled to fit into this smaller array.
    By the way, you don’t need to catch the return value from `ReadAsArray` in this
    case, because you already have the `data` variable. But not only is the `data`
    variable filled automatically, it’s also returned from the function, so you can
    grab it that way if you’d like, but it’s not necessary.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，事先创建了一个具有三列和两行的空整数NumPy数组，然后将其作为参数传递给`ReadAsArray`。从图像中请求的六列和四行被重采样以适应这个较小的数组。顺便说一下，在这种情况下，你不需要捕获`ReadAsArray`的返回值，因为你已经有`data`变量了。但不仅`data`变量会自动填充，它还会从函数中返回，所以如果你想这样做，你可以通过这种方式获取它，但这是不必要的。
- en: Although this technique usually uses nearest-neighbor interpolation to resample,
    if you have an overview layer of the requested resolution, then that will be used
    instead. If the appropriate overview was built with average interpolation, then
    that’s what you’d get when using `ReadAsArray,` rather than nearest-neighbor.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种技术通常使用最近邻插值进行重采样，但如果你有请求分辨率的概览层，那么将使用该概览层。如果适当的概览是通过平均插值构建的，那么使用`ReadAsArray`时你会得到这个结果，而不是最近邻。
- en: As with resampling to smaller pixels, you need to change the pixel size in the
    geotransform when writing the data back out to another dataset. The only difference
    is that in this case, you want to decrease the number of rows and columns and
    increase the pixel size. You could alter [listing 9.4](#ch09ex04) to resample
    to coarser pixels by dividing the rows and columns by 2 instead of multiplying,
    and multiplying instead of dividing the pixel size. You could also get away with
    building fewer overview layers. Other than that, the technique is the same. If
    you forget to change the pixel size, then you end up with an image that’s compressed
    into too small of an area instead of the too large area shown back in [figure
    9.13](#ch09fig13).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 与重采样到更小的像素类似，在将数据写回到另一个数据集时，你需要更改geotransform中的像素大小。唯一的区别在于，在这种情况下，你想要减少行和列的数量并增加像素大小。你可以修改[列表9.4](#ch09ex04)，通过将行和列除以2而不是乘以2来重采样到更粗的像素，而不是乘以像素大小。你也可以通过构建更少的概述层来避免这个问题。除此之外，技术是相同的。如果你忘记更改像素大小，那么最终你会得到一个压缩到过小区域而不是像[图9.13](#ch09fig13)中显示的过大区域的图像。
- en: 9.4\. Byte sequences
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4. 字节序列
- en: 'If you’ve looked through appendix E, you’ve probably noticed that `ReadAsArray`
    and `WriteArray` aren’t the only ways to read and write data with GDAL. (Appendixes
    C through E are available online on the Manning Publications website at [https://www.manning.com/books/geoprocessing-with-python](https://www.manning.com/books/geoprocessing-with-python).)
    You can also read data into a sequence of Python bytes, which is much like a string
    made up of the ASCII codes corresponding to the numeric pixel values. Unlike strings,
    byte sequences can’t be modified, although you’ll learn how to get around that
    in this section. This is a bit faster than converting to a NumPy array, but I
    prefer to get an array so that I can manipulate it mathematically. But if you’d
    like to use bytes instead, or don’t need to manipulate the data, the parameters
    for `ReadRaster` are similar to those for `ReadAsArray`. Here’s the signature
    for the dataset version of `ReadRaster`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经查阅了附录E，你可能已经注意到`ReadAsArray`和`WriteArray`并不是GDAL读取和写入数据的唯一方式。（附录C至E可在Manning
    Publications网站上在线获取，网址为[https://www.manning.com/books/geoprocessing-with-python](https://www.manning.com/books/geoprocessing-with-python)。）你还可以将数据读入一个Python字节序列中，这类似于由对应于数值像素值的ASCII码组成的字符串。与字符串不同，字节序列不能被修改，尽管你将在本节中学习如何绕过这一点。这比转换为NumPy数组要快一些，但我更喜欢得到一个数组，这样我就可以进行数学操作。但如果你想使用字节而不是数组，或者不需要操作数据，`ReadRaster`的参数与`ReadAsArray`的参数相似。以下是`ReadRaster`数据集版本的签名：
- en: '[PRE23]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`xoff` is the column to start reading at. The default value is 0.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xoff`是开始读取的列。默认值为0。'
- en: '`yoff` is the row to start reading at. The default value is 0.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yoff`是开始读取的行。默认值为0。'
- en: '`xsize` is the number of columns to read. The default is to read them all.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xsize`是要读取的列数。默认情况下读取所有列。'
- en: '`ysize` is the number of rows to read. The default is to read them all.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ysize`是要读取的行数。默认情况下读取所有行。'
- en: '`buf_xsize` is the number of columns in the returned sequence. The default
    is to use the `xsize` value. Data will be resampled if this value is different
    than `xsize`.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buf_xsize`是返回序列中的列数。默认情况下使用`xsize`值。如果这个值与`xsize`不同，数据将被重采样。'
- en: '`buf_ysize` is the number of rows in the returned sequence. The default is
    to use the `ysize` value. Data will be resampled if this value is different than
    `ysize`.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buf_ysize`是返回序列中的行数。默认情况下使用`ysize`值。如果这个值与`ysize`不同，数据将被重采样。'
- en: '`buf_type` is the target GDAL data type for the returned sequence. The default
    is the same as the original data.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buf_type`是返回序列的目标GDAL数据类型。默认情况下与原始数据相同。'
- en: '`band_list` is a list of band indices to read. The default is to read all bands.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`band_list`是要读取的波段索引列表。默认情况下读取所有波段。'
- en: '`buf_pixel_space` is the byte offset between pixels in the sequence. The default
    is the size of `buf_type`.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buf_pixel_space`是序列中像素之间的字节偏移量。默认情况下是`buf_type`的大小。'
- en: '`buf_line_space` is the byte offset between lines in the sequence. The default
    is the size of `buf_type` multiplied by `xsize`.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buf_line_space`是序列中各行之间的字节偏移量。默认情况下是`buf_type`的大小乘以`xsize`。'
- en: '`buf_band_space` is the byte offset between bands in the sequence. The default
    is the size of `buf_line_space` multiplied by `ysize`.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buf_band_space`是序列中各波段之间的字节偏移量。默认情况下是`buf_line_space`的大小乘以`ysize`。'
- en: The first six parameters are the same as for `ReadAsArray`. The `buf_type` parameter
    is a GDAL data type constant from [table 9.1](#ch09table01) and is used to specify
    the data type used for the byte sequence. This can be used to change the data
    type as it’s read in. For example, if the raster is of type `byte`, but you provide
    `GDT_float32` for this parameter, then the resulting byte string will represent
    the pixel values as floating-point instead of byte. You can also provide a list
    of bands to read, and they’ll be returned in the order you specify. You can even
    include a band more than once, although I’m not sure why you’d want to. The last
    three parameters change the spacing of data in the returned byte string and can
    be used to work with unusually interleaved datasets, but chances are that you’ll
    never need these. The parameters for the band version of `ReadRaster` are the
    same, except that `band_list` and `buf_band_space` are missing.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 前六个参数与 `ReadAsArray` 相同。`buf_type` 参数是来自 [表 9.1](#ch09table01) 的 GDAL 数据类型常量，用于指定字节序列使用的数据类型。这可以用于在读取时更改数据类型。例如，如果栅格是
    `byte` 类型，但你为该参数提供了 `GDT_float32`，则生成的字节字符串将表示像素值作为浮点数而不是字节。你也可以提供要读取的波段列表，并将按你指定的顺序返回。你甚至可以将波段多次包含在内，尽管我不确定你为什么想要这样做。最后三个参数更改返回的字节字符串中数据的间距，可以用于处理不寻常的交错数据集，但很可能你永远不会需要这些。`ReadRaster`
    的波段版本参数与这些参数相同，除了缺少 `band_list` 和 `buf_band_space`。
- en: 'Anyway, if you were to print out the results of a call to `ReadRaster`, the
    result would be something like `b''\x1c\x1d\x1c\x1e''`, which doesn’t mean a whole
    lot to me. You can access elements by index, however, and those will look more
    familiar. Byte strings are immutable, which means they can’t change, but you can
    convert them to byte arrays if you need to edit values. The following interactive
    session shows you an example of this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，如果你要打印出对 `ReadRaster` 的调用结果，结果可能类似于 `b'\x1c\x1d\x1c\x1e'`，这对我来说并没有太多意义。然而，你可以通过索引访问元素，这些元素看起来会更熟悉。字节字符串是不可变的，这意味着它们不能改变，但如果你需要编辑值，可以将它们转换为字节数组。以下交互会话展示了这一示例：
- en: '[PRE24]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You can also convert a byte string to a tuple using the built-in struct module.
    Here you need to provide a format string that specifies what type, and how many,
    elements are contained in the string. In this example, you’re using a format string
    such as “BBBB” to specify four bytes. See the Python struct documentation for
    other formats.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用内置的 struct 模块将字节字符串转换为元组。在这里，你需要提供一个格式字符串，该字符串指定了字符串中包含的类型和元素数量。在这个例子中，你使用了一个如“BBBB”的格式字符串来指定四个字节。有关其他格式的信息，请参阅
    Python struct 文档。
- en: '[PRE25]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you want to turn the byte string into a NumPy array, you can do that using
    the tuple from `unpack`, or by using the NumPy `fromstring` function to convert
    the byte string directly (although if you want a NumPy array, maybe you should
    use `ReadAsArray`). As with using `unpack`, you have to provide the data type
    that the sequence uses when converting it to a NumPy array. Both of these methods
    return a one-dimensional array, so you’ll have to reshape it to multidimensional
    if needed. Examples of these operations are shown here:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将字节字符串转换为 NumPy 数组，可以使用 `unpack` 的元组，或者使用 NumPy 的 `fromstring` 函数直接转换字节字符串（尽管如果你想要一个
    NumPy 数组，也许你应该使用 `ReadAsArray`）。与使用 `unpack` 一样，你必须提供序列在转换为 NumPy 数组时使用的数据类型。这两种方法都返回一维数组，所以如果需要，你必须将其重塑为多维数组。这里展示了这些操作的示例：
- en: '[PRE26]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The parameters for writing data from byte strings are similar to those for
    reading, although the first five arguments are required instead of optional:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 从字节字符串写入数据的参数与读取的参数类似，尽管前五个参数是必需的而不是可选的：
- en: '[PRE27]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`xoff` is the column to start writing at.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xoff` 是开始写入的列。'
- en: '`yoff` is the row to start writing at.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yoff` 是开始写入的行。'
- en: '`xsize` is the number of columns to write.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xsize` 表示要写入的列数。'
- en: '`ysize` is the number of rows to write.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ysize` 表示要写入的行数。'
- en: '`buf_string` is the byte sequence to write.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buf_string` 是要写入的字节序列。'
- en: '`buf_xsize` is the number of columns in the byte sequence. The default is to
    use the `xsize` value. Data will be resampled if this value is different than
    `xsize`.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buf_xsize` 是字节序列中的列数。默认情况下使用 `xsize` 值。如果此值与 `xsize` 不同，则将重新采样数据。'
- en: '`buf_ysize` is the number of rows in the byte sequence. The default is to use
    the `ysize` value. Data will be resampled if this value is different than `ysize`.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buf_ysize` 是字节序列中的行数。默认情况下使用 `ysize` 值。如果此值与 `ysize` 不同，则将重新采样数据。'
- en: '`buf_type` is the GDAL data type of the byte sequence. The default is the same
    as the dataset being written to.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buf_type`是字节序列的GDAL数据类型。默认值与要写入的数据集相同。'
- en: '`band_list` is a list of band indices to write. The default is to write all
    bands.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`band_list`是要写入的波段索引列表。默认是写入所有波段。'
- en: '`buf_pixel_space` is the byte offset between pixels in the byte sequence. The
    default is the size of `buf_type`.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buf_pixel_space`是字节序列中像素之间的字节偏移量。默认值是`buf_type`的大小。'
- en: '`buf_line_space` is the byte offset between lines in the byte sequence. The
    default is the size of `buf_type` multiplied by `xsize`.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buf_line_space`是字节序列中行之间的字节偏移量。默认值是`buf_type`的大小乘以`xsize`。'
- en: '`buf_band_space` is the byte offset between bands in the byte sequence. The
    default is the size of `buf_line_space` multiplied by `ysize`.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buf_band_space`是字节序列中波段之间的字节偏移量。默认值是`buf_line_space`的大小乘以`ysize`。'
- en: Once again, the band version is the same, except that the `band_list` and `buf_band_space`
    parameters don’t exist.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，波段版本是相同的，只是`band_list`和`buf_band_space`参数不存在。
- en: 'You could write a byte sequence, called `data`, that contains six columns and
    four rows out to a dataset like this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编写一个名为`data`的字节序列，包含六列和四行，输出到类似这样的数据集中：
- en: '[PRE28]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Let’s try resampling an image to a larger pixel size using bytes instead of
    NumPy arrays.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用字节而不是NumPy数组来将图像重采样到更大的像素大小。
- en: Listing 9.5\. Resample an image to a larger pixel size using byte sequences
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.5. 使用字节序列重采样图像到更大的像素大小
- en: '![](ch09ex05-0.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch09ex05-0.jpg)'
- en: '![](ch09ex05-1.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch09ex05-1.jpg)'
- en: In many ways this example is similar to [listing 9.4](#ch09ex04), except that
    the numbers of output rows and columns are halved instead of doubled, and the
    pixel size is doubled instead of halved. Notice that in this case you need to
    ensure that the numbers of rows and columns are integers, because the result of
    the division might be floating-point, and the dataset creation function doesn’t
    like that.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，这个例子与[列表9.4](#ch09ex04)类似，除了输出行和列的数量减半，而不是加倍，像素大小加倍，而不是减半。请注意，在这种情况下，你需要确保行和列的数量是整数，因为除法的结果可能是浮点数，而数据集创建函数不喜欢这种情况。
- en: The interesting part is where you read and write the data. Because all rows,
    columns, and bands are read by default, you didn’t have to do anything about those.
    But because you want the data resampled into half as many rows and columns, you
    pass these smaller numbers in using the `buf_xsize` and `buf_ysize` parameters.
    This causes the data to be resampled as GDAL reads it into the byte sequence.
    Then you write the data out to the new dataset starting at the first row and column.
    You also tell `WriteRaster` how many rows and columns are contained in the byte
    sequence, because unlike a NumPy array, this isn’t obvious. A byte sequence that
    is 32 bytes long might contain one 32-bit integer, or it might contain four 8-bit
    integers. Although `Write-Raster` can figure out how many bytes are in the sequence,
    it doesn’t know how to convert those to pixel values until you tell it how many
    values there are supposed to be.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的部分在于读取和写入数据。因为默认情况下所有行、列和波段都会被读取，所以你不必对那些做任何事情。但是，因为你希望数据被重采样到一半的行和列，所以你需要使用`buf_xsize`和`buf_ysize`参数传递这些较小的数字。这会导致数据在GDAL将其读入字节序列时被重采样。然后，你将数据写入到新的数据集中，从第一行和第一列开始。你还必须告诉`WriteRaster`字节序列中包含多少行和列，因为与NumPy数组不同，这并不明显。一个32字节长的字节序列可能包含一个32位整数，也可能包含四个8位整数。尽管`Write-Raster`可以找出序列中有多少字节，但它不知道如何将这些字节转换为像素值，直到你告诉它应该有多少个值。
- en: 9.5\. Subdatasets
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5. 子数据集
- en: Several types of datasets can contain other datasets, which each in turn contain
    bands ([figure 9.15](#ch09fig15)). One example of this is the MODIS imagery distributed
    by the United States Geological Service, which comes as a hierarchical data format
    (HDF) file. If your dataset contains subdatasets, you can get a list of them with
    the `GetSubDatasets` function and then use that information to open the one you
    want.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 几种类型的数据集可以包含其他数据集，每个数据集又包含波段（[图9.15](#ch09fig15)）。一个例子是美国地质调查局分发的MODIS影像，它以分层数据格式（HDF）文件的形式提供。如果你的数据集包含子数据集，你可以使用`GetSubDatasets`函数获取它们的列表，然后使用该信息打开你想要的数据集。
- en: Figure 9.15\. Several types of datasets include subdatasets. Each of these subdatasets
    is structured like a normal dataset and contains its own bands and georeferencing
    information.
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.15. 几种数据集包括子数据集。这些子数据集的结构与正常数据集类似，并包含自己的波段和地理参考信息。
- en: '![](09fig15_alt.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图片](09fig15_alt.jpg)'
- en: 'As an example, let’s open a subdataset contained in a MODIS file. Note that
    the HDF driver isn’t included in GDAL by default, so this example won’t work for
    you if your GDAL version doesn’t include HDF support. Assuming you can work with
    HDF files, the first step is to open the HDF file as a dataset:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，让我们打开一个包含在MODIS文件中的子数据集。请注意，HDF驱动程序默认不包含在GDAL中，因此如果您的GDAL版本不包含HDF支持，此示例将无法为您工作。假设您可以处理HDF文件，第一步是将HDF文件作为数据集打开：
- en: '[PRE29]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now you can get the list of subdatasets contained in this open dataset. The
    `GetSub-Datasets` method returns a list of tuples, with one tuple per subdataset.
    Each tuple contains the name and the description of the subdataset, in that order.
    The following snippet gets this list and then prints out the name and description
    for each of the subdatasets:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以获取包含在此公开数据集中的子数据集列表。`GetSub-Datasets` 方法返回一个元组列表，每个子数据集一个元组。每个元组包含子数据集的名称和描述，顺序如下。以下代码片段获取此列表，然后打印出每个子数据集的名称和描述：
- en: '[PRE30]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The first few lines of output look like this, and show the information for
    the first subdataset, which is the NDVI (normalized difference vegetation index),
    but there are 11 more not shown:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的前几行看起来像这样，显示了第一个子数据集的信息，即NDVI（归一化植被指数），但还有11个未显示：
- en: '[PRE31]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To open a subdataset, pass its name to `gdalOpen`. For example, this gets the
    tuple corresponding to the first subdataset, gets the first item (the name) from
    the tuple, and then uses that to open the subdataset:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开子数据集，将它的名称传递给 `gdalOpen`。例如，这获取与第一个子数据集对应的元组，从元组中获取第一个元素（名称），然后使用它来打开子数据集：
- en: '[PRE32]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Similarly, you would use `subdatasets[4][0]` to open the fifth subdataset. Once
    you’ve opened a subdataset like this, it can be treated like any other dataset.
    For example, you could get the first band in the NDVI subdataset using `ndvi_ds.GetRasterBand(1)`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以使用 `subdatasets[4][0]` 来打开第五个子数据集。一旦以这种方式打开了一个子数据集，它就可以像任何其他数据集一样处理。例如，您可以使用
    `ndvi_ds.GetRasterBand(1)` 获取NDVI子数据集的第一波段。
- en: 9.6\. Web map services
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.6\. Web地图服务
- en: Let’s take a quick look at web map services, which are used to serve images
    across the web for things like basemaps. We’ll try out an OGC web map service
    that creates an image based on your request, but you have other methods of accessing
    basemaps. For example, both OpenStreetMap and Google use pre-rendered tiled images.
    To use those, you need to know the tile that you want, and nothing is rendered
    on the fly (well, it could be, depending on how the images are cached on the server,
    but the idea is that the tiles already exist so they provide fast access).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速了解一下Web地图服务，这些服务用于在网络上提供图像，例如底图。我们将尝试一个OGC Web地图服务，该服务根据您的请求创建图像，但您还有其他访问底图的方法。例如，OpenStreetMap和Google都使用预渲染的瓦片图像。要使用这些，您需要知道您想要的瓦片，并且不会即时渲染（好吧，可能会，这取决于服务器上图像的缓存方式，但理念是瓦片已经存在，因此它们提供了快速访问）。
- en: GDAL allows you to use XML files to specify the parameters for a map service,
    and all of the possibilities are documented at [http://www.gdal.org/frmt_wms.html](http://www.gdal.org/frmt_wms.html).
    The following listing shows the XML describing an imagery basemap from the US
    National Map.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: GDAL允许您使用XML文件来指定地图服务的参数，所有可能性都在[http://www.gdal.org/frmt_wms.html](http://www.gdal.org/frmt_wms.html)上进行了文档记录。以下列表显示了描述美国国家地图影像底图的XML：
- en: Listing 9.6\. XML describing a web map service
  id: totrans-286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.6\. 描述Web地图服务的XML
- en: '[PRE33]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You need to know certain information about the service to create an XML specification,
    however. OGC web map services allow you to request information about them using
    a GetCapabilities request. If you don’t know the base URL for the service, you’re
    out of luck, but assuming you do know it, tack “?request=GetCapabilities&service=WMS”
    onto the end and view the result in a browser. For example, the URL for the service
    defined in [listing 9.6](#ch09ex06) is [http://raster.nationalmap.gov/arcgis/services/Orthoimagery/USGS_EROS_Ortho_1Foot/ImageServer/WMSServer?request=GetCapabilities&service=WMS](http://raster.nationalmap.gov/arcgis/services/Orthoimagery/USGS_EROS_Ortho_1Foot/ImageServer/WMSServer?request=GetCapabilities&service=WMS).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要了解有关服务的一些信息来创建XML规范。OGC Web地图服务允许您使用GetCapabilities请求请求有关它们的信息。如果您不知道服务的基准URL，您就无能为力了，但假设您知道它，将“?request=GetCapabilities&service=WMS”附加到末尾，并在浏览器中查看结果。例如，[列表9.6](#ch09ex06)中定义的服务URL是[http://raster.nationalmap.gov/arcgis/services/Orthoimagery/USGS_EROS_Ortho_1Foot/ImageServer/WMSServer?request=GetCapabilities&service=WMS](http://raster.nationalmap.gov/arcgis/services/Orthoimagery/USGS_EROS_Ortho_1Foot/ImageServer/WMSServer?request=GetCapabilities&service=WMS)。
- en: 'This is a lot of information, but we’ll focus on a few parts that are important
    for the Service section of the XML. Look at the first line of output:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这有很多信息，但我们将重点关注XML服务部分中重要的几个部分。查看输出的第一行：
- en: '[PRE34]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Part of that line specifies the WMS version as 1.3.0\. Add that information
    to the Version section of your XML. Now look through the GetCapabilities results
    until you find the GetMap section. The first part of it looks like this:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 该行的一部分指定了WMS版本为1.3.0。将此信息添加到XML的Version部分。现在查看GetCapabilities结果，直到您找到GetMap部分。它的第一部分看起来像这样：
- en: '[PRE35]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'These are the formats that the service can provide, and you should include
    one of them in the ImageFormat section of your XML. Now look for the Layer section
    in the GetCapabilities output. Here are the first few lines of that section:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是服务可以提供的格式，您应该在XML的ImageFormat部分包含其中之一。现在在GetCapabilities输出中查找Layer部分。以下是该部分的几行内容：
- en: '[PRE36]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We want to use the layer called USGS_EROS_Ortho_1Foot, but the Name value is
    the important one. In this case, the name is “0,” which isn’t too descriptive,
    but it’s what you need to add to the Layer section of the XML. If you keep looking
    at the Layer section of the capabilities, you’ll see a lengthy list of CRS values,
    which are the coordinate systems supported by the service. Here are the first
    few:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想使用名为USGS_EROS_Ortho_1Foot的图层，但重要的是Name值。在这种情况下，名称是“0”，这不是很描述性，但这是您需要添加到XML的Layer部分的。如果您继续查看能力的Layer部分，您将看到一个包含CRS值的冗长列表，这些是服务支持的坐标系统。以下是前几个：
- en: '[PRE37]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You guessed it. Select one of these for your output and add it to the CRS section
    of your XML.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经猜到了。为您的输出选择其中一个，并将其添加到XML的CRS部分。
- en: Now that the service is defined in your XML, you need to specify the geographic
    extent that you want to retrieve. You do this with the DataWindow section. The
    Upper-LeftX, UpperLeftY, LowerRightX, and LowerRightY are the minimum x, maximum
    y, maximum x, and minimum y values, respectively. The SizeX and SizeY parameters
    specify the number of columns and rows for the output image.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在服务已在您的XML中定义，您需要指定要检索的地理范围。您可以通过DataWindow部分来完成此操作。Upper-LeftX、UpperLeftY、LowerRightX和LowerRightY分别代表最小x值、最大y值、最大x值和最小y值。SizeX和SizeY参数指定输出图像的列数和行数。
- en: 'Once you have your XML saved, pass the filename to the GDAL `Open` function,
    and if everything is configured correctly, it will be opened as a dataset. At
    this point you could get the bands and read the data into an array, or you could
    save the image to a local file using `CreateCopy`. For example, this snippet uses
    the XML from [listing 9.6](#ch09ex06) to save a local image of Liberty Island
    in New York Harbor ([figure 9.16](#ch09fig16)):'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您保存了XML，将文件名传递给GDAL的`Open`函数，如果一切配置正确，它将作为一个数据集打开。此时，您可以获取波段并将数据读入数组，或者您可以使用`CreateCopy`将图像保存到本地文件。例如，此代码片段使用[列表9.6](#ch09ex06)中的XML保存纽约港自由岛的本地图像（[图9.16](#ch09fig16)）：
- en: '[PRE38]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Figure 9.16\. An image of Liberty Island in New York Harbor obtained using an
    OGC web map service
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.16\. 使用OGC网络地图服务获取的纽约港自由岛的图像
- en: '![](09fig16.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图片](09fig16.jpg)'
- en: If you need to request images with different spatial extents or other parameters
    that regularly change, it would make sense to create an XML template and format
    it with the desired values when required.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要请求具有不同空间范围或其他经常变化的参数的图像，创建一个XML模板并在需要时使用所需值进行格式化是有意义的。
- en: 9.7\. Summary
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7\. 摘要
- en: Raster datasets are ideal for continuous data without sharp boundaries, such
    as elevation, precipitation, or satellite imagery.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栅格数据集非常适合没有尖锐边界的连续数据，例如高程、降水量或卫星图像。
- en: In the interest of disk space, don’t use smaller pixel sizes or larger data
    types than necessary.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了节省磁盘空间，不要使用比必要的更小的像素大小或更大的数据类型。
- en: If you need to use your data for analysis, be sure to use a lossless compression
    algorithm or no compression at all.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您需要使用数据进行分析，请确保使用无损压缩算法或完全不进行压缩。
- en: Use overviews for rapid display of raster data.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用概述来快速显示栅格数据。
- en: Always use nearest-neighbor resampling for non-continuous raster data because
    other methods will result in new pixel values that don’t correspond to the originals.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于非连续的栅格数据，始终使用最近邻重采样，因为其他方法会导致新的像素值与原始值不对应。
- en: For best performance, make as few read/write calls as possible, but don’t try
    to keep more data in memory than you have RAM.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了获得最佳性能，尽可能减少读写调用，但不要尝试在内存中保留比您RAM更多的数据。
- en: Don’t forget to edit the geotransform if you change spatial extent or pixel
    size.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您更改空间范围或像素大小，不要忘记编辑地理变换。
- en: Don’t try to read or write past the edge of an image.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要尝试读取或写入图像的边缘。
- en: Use the buffer parameters to resample data while reading or writing.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用缓冲参数在读取或写入时重新采样数据。
- en: Use `ReadAsArray` if you want to use NumPy to manipulate your data in memory,
    but `ReadRaster` is slightly faster if you only need to copy data.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想使用 NumPy 在内存中操作数据，请使用 `ReadAsArray`，但如果您只需要复制数据，则 `ReadRaster` 会稍微快一些。
