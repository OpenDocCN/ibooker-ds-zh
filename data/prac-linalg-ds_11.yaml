- en: Chapter 11\. General Linear Models and Least Squares
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç¬¬11ç« . å¹¿ä¹‰çº¿æ€§æ¨¡å‹å’Œæœ€å°äºŒä¹˜æ³•
- en: The universe is a really big and really complicated place. All animals on Earth
    have a natural curiousity to explore and try to understand their environment,
    but we humans are privileged with the intelligence to develop scientific and statistical
    tools to take our curiousity to the next level. Thatâ€™s why we have airplanes,
    MRI machines, rovers on Mars, vaccines, and, of course, books like this one.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: å®‡å®™æ˜¯ä¸€ä¸ªéå¸¸å¤§è€Œå¤æ‚çš„åœ°æ–¹ã€‚åœ°çƒä¸Šçš„æ‰€æœ‰åŠ¨ç‰©éƒ½æœ‰ä¸€ç§æ¢ç´¢å’Œç†è§£å…¶ç¯å¢ƒçš„è‡ªç„¶å¥½å¥‡å¿ƒï¼Œä½†æˆ‘ä»¬äººç±»åˆ™æœ‰å¹¸èƒ½å¤Ÿå‘å±•ç§‘å­¦å’Œç»Ÿè®¡å·¥å…·ï¼Œå°†æˆ‘ä»¬çš„å¥½å¥‡å¿ƒæå‡åˆ°æ›´é«˜çš„æ°´å¹³ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆæˆ‘ä»¬æœ‰é£æœºã€MRIæœºå™¨ã€ç«æ˜Ÿæ¢æµ‹å™¨ã€ç–«è‹—ï¼Œå½“ç„¶è¿˜æœ‰åƒæœ¬ä¹¦è¿™æ ·çš„ä¹¦ç±ã€‚
- en: How do we understand the universe? By developing mathematically grounded theories,
    and by collecting data to test and improve those theories. And this brings us
    to statistical models. A statistical model is a simplified mathematical representation
    of some aspect of the world. Some statistical models are simple (e.g., predicting
    that the stock market will increase over decades); others are much more sophisticated,
    like the Blue Brain Project that simulates brain activity with such exquisite
    detail that one second of simulated activity requires 40 minutes of computation
    time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¦‚ä½•ç†è§£å®‡å®™ï¼Ÿé€šè¿‡å‘å±•æ•°å­¦åŸºç¡€çš„ç†è®ºï¼Œå¹¶æ”¶é›†æ•°æ®æ¥æµ‹è¯•å’Œæ”¹è¿›è¿™äº›ç†è®ºã€‚è¿™å°†æˆ‘ä»¬å¸¦åˆ°äº†ç»Ÿè®¡æ¨¡å‹ã€‚ç»Ÿè®¡æ¨¡å‹æ˜¯ä¸–ç•ŒæŸäº›æ–¹é¢çš„ç®€åŒ–æ•°å­¦è¡¨ç¤ºã€‚ä¸€äº›ç»Ÿè®¡æ¨¡å‹å¾ˆç®€å•ï¼ˆä¾‹å¦‚ï¼Œé¢„æµ‹è‚¡å¸‚æ•°åå¹´æ¥ä¼šä¸Šæ¶¨ï¼‰ï¼Œè€Œå…¶ä»–ä¸€äº›åˆ™æ›´ä¸ºå¤æ‚ï¼Œæ¯”å¦‚è“è„‘é¡¹ç›®ä»¥å¦‚æ­¤ç²¾ç»†çš„ç»†èŠ‚æ¨¡æ‹Ÿè„‘æ´»åŠ¨ï¼Œä»¥è‡³äºæ¨¡æ‹Ÿä¸€ç§’é’Ÿçš„æ´»åŠ¨éœ€è¦40åˆ†é’Ÿçš„è®¡ç®—æ—¶é—´ã€‚
- en: A key distinction of *statistical* models (as opposed to other mathematical
    models) is that they contain free parameters that are fit to data. For example,
    I know that the stock market will go up over time, but I donâ€™t know by how much.
    Therefore, I allow the change in stock market price over time (that is, the slope)
    to be a free parameter whose numerical value is determined by data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*ç»Ÿè®¡* æ¨¡å‹çš„ä¸€ä¸ªå…³é”®åŒºåˆ«ï¼ˆä¸å…¶ä»–æ•°å­¦æ¨¡å‹ç›¸å¯¹ï¼‰æ˜¯å®ƒä»¬åŒ…å«å¯æ ¹æ®æ•°æ®è¿›è¡Œæ‹Ÿåˆçš„è‡ªç”±å‚æ•°ã€‚ä¾‹å¦‚ï¼Œæˆ‘çŸ¥é“è‚¡å¸‚ä¼šéšæ—¶é—´ä¸Šæ¶¨ï¼Œä½†æˆ‘ä¸çŸ¥é“ä¸Šæ¶¨å¹…åº¦æ˜¯å¤šå°‘ã€‚å› æ­¤ï¼Œæˆ‘å…è®¸éšæ—¶é—´å˜åŒ–çš„è‚¡å¸‚ä»·æ ¼ï¼ˆå³æ–œç‡ï¼‰æ˜¯ä¸€ä¸ªç”±æ•°æ®å†³å®šæ•°å€¼çš„è‡ªç”±å‚æ•°ã€‚'
- en: Crafting a statistical model can be difficult and requires creativity, experience,
    and expertise. But finding the free parameters based on fitting the model to data
    is a simple matter of linear algebraâ€”in fact, you already know all the math you
    need for this chapter; itâ€™s just a matter of putting the pieces together and learning
    the statistics terminology.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ¶å®šç»Ÿè®¡æ¨¡å‹å¯èƒ½å¾ˆå›°éš¾ï¼Œéœ€è¦åˆ›é€ åŠ›ã€ç»éªŒå’Œä¸“ä¸šçŸ¥è¯†ã€‚ä½†æ ¹æ®å°†æ¨¡å‹æ‹Ÿåˆåˆ°æ•°æ®çš„è‡ªç”±å‚æ•°æ˜¯ä¸€ä»¶ç®€å•çš„çº¿æ€§ä»£æ•°é—®é¢˜â€”â€”å®é™…ä¸Šï¼Œä½ å·²ç»æŒæ¡äº†æœ¬ç« æ‰€éœ€çš„æ‰€æœ‰æ•°å­¦ï¼Œåªæ˜¯éœ€è¦å°†å„éƒ¨åˆ†ç»„åˆèµ·æ¥ï¼Œå¹¶å­¦ä¹ ç»Ÿè®¡æœ¯è¯­ã€‚
- en: General Linear Models
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å¹¿ä¹‰çº¿æ€§æ¨¡å‹
- en: A statistical model is a set of equations that relates predictors (called *independent
    variables*) to observations (called the *dependent variable*). In the model of
    the stock market, the independent variable is *time* and the dependent variable
    is *stock market price* (e.g., quantified as the S&P 500 index).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: ç»Ÿè®¡æ¨¡å‹æ˜¯ä¸€ç»„æ–¹ç¨‹ï¼Œå°†é¢„æµ‹å˜é‡ï¼ˆç§°ä¸º *ç‹¬ç«‹å˜é‡*ï¼‰ä¸è§‚å¯Ÿç»“æœï¼ˆç§°ä¸º *ä¾èµ–å˜é‡*ï¼‰ç›¸å…³è”ã€‚åœ¨è‚¡å¸‚æ¨¡å‹ä¸­ï¼Œç‹¬ç«‹å˜é‡æ˜¯ *æ—¶é—´*ï¼Œä¾èµ–å˜é‡æ˜¯ *è‚¡å¸‚ä»·æ ¼*ï¼ˆä¾‹å¦‚ï¼Œä»¥æ ‡å‡†æ™®å°”500æŒ‡æ•°é‡åŒ–ï¼‰ã€‚
- en: In this book I will focus on general linear models, which are abbreviated as
    GLM. Regression is a type of GLM, for example.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ¬ä¹¦ä¸­ï¼Œæˆ‘å°†é‡ç‚¹ä»‹ç»å¹¿ä¹‰çº¿æ€§æ¨¡å‹ï¼ˆGLMï¼‰ï¼Œå…¶ç®€ç§°ä¸ºGLMã€‚ä¾‹å¦‚ï¼Œå›å½’æ˜¯GLMçš„ä¸€ç§ç±»å‹ã€‚
- en: Terminology
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: æœ¯è¯­
- en: Statisticians use slightly different terminology than do linear algebraticians.
    [TableÂ 11-1](#table_11_1) shows the key letters and descriptions for vectors and
    matrices used in the GLM.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ç»Ÿè®¡å­¦å®¶ä½¿ç”¨çš„æœ¯è¯­ä¸çº¿æ€§ä»£æ•°å­¦å®¶ç•¥æœ‰ä¸åŒã€‚[è¡¨Â 11-1](#table_11_1) å±•ç¤ºäº†GLMä¸­ç”¨äºå‘é‡å’ŒçŸ©é˜µçš„å…³é”®å­—æ¯å’Œæè¿°ã€‚
- en: Table 11-1\. Table of terms in GLMs
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: è¡¨ 11-1\. å¹¿ä¹‰çº¿æ€§æ¨¡å‹æœ¯è¯­è¡¨
- en: '| LinAlg | Stats | Description |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| LinAlg | Stats | æè¿° |'
- en: '| --- | --- | --- |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Ax = b | <math alttext="upper X beta equals y"><mrow><mi>X</mi><mi>Î²</mi><mo>=</mo><mi>y</mi></mrow></math>
    | General linear model (GLM) |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| Ax = b | <math alttext="upper X beta equals y"><mrow><mi>X</mi><mi>Î²</mi><mo>=</mo><mi>y</mi></mrow></math>
    | å¹¿ä¹‰çº¿æ€§æ¨¡å‹ï¼ˆGLMï¼‰ |'
- en: '| A | X | Design matrix (columns = independent variables, predictors, regressors)
    |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| A | X | è®¾è®¡çŸ©é˜µï¼ˆåˆ— = ç‹¬ç«‹å˜é‡ï¼Œé¢„æµ‹å˜é‡ï¼Œå›å½’å™¨ï¼‰ |'
- en: '| x | <math alttext="beta"><mi>Î²</mi></math> | Regression coefficients or beta
    parameters |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| x | <math alttext="beta"><mi>Î²</mi></math> | å›å½’ç³»æ•°æˆ–è´å¡”å‚æ•° |'
- en: '| b | y | Dependent variable, outcome measure, data |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| b | y | å› å˜é‡ï¼Œç»“æœæµ‹é‡ï¼Œæ•°æ® |'
- en: Setting Up a General Linear Model
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è®¾ç½®å¹¿ä¹‰çº¿æ€§æ¨¡å‹
- en: Setting up a GLM involves (1) defining an equation that relates the predictor
    variables to the dependent variable, (2) mapping the observed data onto the equations,
    (3) transforming the series of equations into a matrix equation, and (4) solving
    that equation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: è®¾ç½®ä¸€ä¸ªGLMåŒ…æ‹¬ï¼ˆ1ï¼‰å®šä¹‰ä¸€ä¸ªå°†é¢„æµ‹å˜é‡ä¸å› å˜é‡è”ç³»èµ·æ¥çš„æ–¹ç¨‹ï¼Œï¼ˆ2ï¼‰å°†è§‚å¯Ÿæ•°æ®æ˜ å°„åˆ°è¿™äº›æ–¹ç¨‹ä¸­ï¼Œï¼ˆ3ï¼‰å°†ä¸€ç³»åˆ—æ–¹ç¨‹è½¬æ¢ä¸ºçŸ©é˜µæ–¹ç¨‹ï¼Œå¹¶ï¼ˆ4ï¼‰è§£å†³è¯¥æ–¹ç¨‹ã€‚
- en: 'Iâ€™ll use a simple example to make the procedure concrete. I have a model that
    predicts adult height based on weight and on parentsâ€™ height. The equation looks
    like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘å°†ç”¨ä¸€ä¸ªç®€å•çš„ä¾‹å­æ¥å…·ä½“è¯´æ˜è¿™ä¸ªè¿‡ç¨‹ã€‚æˆ‘æœ‰ä¸€ä¸ªæ¨¡å‹ï¼Œæ ¹æ®ä½“é‡å’Œçˆ¶æ¯çš„èº«é«˜é¢„æµ‹æˆå¹´äººçš„èº«é«˜ã€‚æ–¹ç¨‹å¦‚ä¸‹æ‰€ç¤ºï¼š
- en: <math alttext="y equals beta 0 plus beta 1 w plus beta 2 h plus epsilon" display="block"><mrow><mi>y</mi>
    <mo>=</mo> <msub><mi>Î²</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>Î²</mi> <mn>1</mn></msub>
    <mi>w</mi> <mo>+</mo> <msub><mi>Î²</mi> <mn>2</mn></msub> <mi>h</mi> <mo>+</mo>
    <mi>Ïµ</mi></mrow></math>
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="y equals beta 0 plus beta 1 w plus beta 2 h plus epsilon" display="block"><mrow><mi>y</mi>
    <mo>=</mo> <msub><mi>Î²</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>Î²</mi> <mn>1</mn></msub>
    <mi>w</mi> <mo>+</mo> <msub><mi>Î²</mi> <mn>2</mn></msub> <mi>h</mi> <mo>+</mo>
    <mi>Ïµ</mi></mrow></math>
- en: '*y* is the height of an individual, *w* is their weight, and *h* is their parentsâ€™
    height (the average of mother and father). <math alttext="epsilon"><mi>Ïµ</mi></math>
    is an error term (also called a *residual*), because we cannot reasonably expect
    that weight and parentsâ€™ height *perfectly determines* an individualâ€™s height;
    there are myriad factors that our model does not account for, and the variance
    not attributable to weight and parentsâ€™ height will be absorbed by the residual.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*y* æ˜¯ä¸ªä½“çš„èº«é«˜ï¼Œ*w* æ˜¯ä»–ä»¬çš„ä½“é‡ï¼Œ*h* æ˜¯ä»–ä»¬çˆ¶æ¯çš„èº«é«˜ï¼ˆæ¯äº²å’Œçˆ¶äº²çš„å¹³å‡å€¼ï¼‰ã€‚ <math alttext="epsilon"><mi>Ïµ</mi></math>
    æ˜¯ä¸€ä¸ªè¯¯å·®é¡¹ï¼ˆä¹Ÿç§°ä¸º *æ®‹å·®*ï¼‰ï¼Œå› ä¸ºæˆ‘ä»¬ä¸èƒ½åˆç†åœ°æœŸæœ›ä½“é‡å’Œçˆ¶æ¯çš„èº«é«˜å®Œå…¨å†³å®šä¸€ä¸ªäººçš„èº«é«˜ï¼›æˆ‘ä»¬çš„æ¨¡å‹æ²¡æœ‰è€ƒè™‘åˆ°çš„å„ç§å› ç´ ï¼Œè€Œä¸èƒ½å½’å› äºä½“é‡å’Œçˆ¶æ¯çš„èº«é«˜çš„æ–¹å·®å°†è¢«æ®‹å·®å¸æ”¶ã€‚'
- en: 'My hypothesis is that weight and parentsâ€™ height are important for an individualâ€™s
    height, but I donâ€™t know *how* important each variable is. Enter the <math alttext="beta"><mi>Î²</mi></math>
    terms: they are the coefficients, or weights, that tell me how to combine weight
    and parentsâ€™ height to predict an individualâ€™s height. In other words, a linear
    weighted combination, where the <math alttext="beta"><mi>Î²</mi></math> s are the
    weights.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘çš„å‡è®¾æ˜¯ï¼Œä½“é‡å’Œçˆ¶æ¯çš„èº«é«˜å¯¹ä¸ªä½“çš„èº«é«˜å¾ˆé‡è¦ï¼Œä½†æˆ‘ä¸çŸ¥é“æ¯ä¸ªå˜é‡æœ‰å¤šé‡è¦ã€‚è¾“å…¥ <math alttext="beta"><mi>Î²</mi></math>
    é¡¹ï¼šå®ƒä»¬æ˜¯ç³»æ•°æˆ–æƒé‡ï¼Œå‘Šè¯‰æˆ‘å¦‚ä½•ç»“åˆä½“é‡å’Œçˆ¶æ¯çš„èº«é«˜æ¥é¢„æµ‹ä¸ªä½“çš„èº«é«˜ã€‚æ¢å¥è¯è¯´ï¼Œè¿™æ˜¯ä¸€ä¸ªçº¿æ€§åŠ æƒç»„åˆï¼Œå…¶ä¸­ <math alttext="beta"><mi>Î²</mi></math>
    æ˜¯æƒé‡ã€‚
- en: <math alttext="beta 0"><msub><mi>Î²</mi> <mn>0</mn></msub></math> is called an
    *intercept* (sometimes called a *constant*). The intercept term is a vector of
    all 1s. Without an intercept term, the best-fit line is forced to pass through
    the origin. Iâ€™ll explain why, and show a demonstration, toward the end of the
    chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="beta 0"><msub><mi>Î²</mi> <mn>0</mn></msub></math> è¢«ç§°ä¸º *æˆªè·*ï¼ˆæœ‰æ—¶ç§°ä¸º
    *å¸¸æ•°*ï¼‰ã€‚æˆªè·é¡¹æ˜¯ä¸€ä¸ªå…¨ä¸º1çš„å‘é‡ã€‚å¦‚æœæ²¡æœ‰æˆªè·é¡¹ï¼Œæœ€ä½³æ‹Ÿåˆçº¿å°†è¢«è¿«é€šè¿‡åŸç‚¹ã€‚æˆ‘å°†åœ¨æœ¬ç« æœ«å°¾è§£é‡Šä¸ºä»€ä¹ˆï¼Œå¹¶å±•ç¤ºä¸€ä¸ªæ¼”ç¤ºã€‚
- en: Now we have our equation, our model of the universe (well, one tiny part of
    it). Next, we need to map the observed data onto the equations. For simplicity,
    Iâ€™m going to make up some data in [TableÂ 11-2](#table_11_2) (you may imagine that
    *y* and *h* have units of centimeters and *w* has units of kilograms).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æœ‰äº†æˆ‘ä»¬çš„æ–¹ç¨‹ï¼Œæˆ‘ä»¬çš„å®‡å®™æ¨¡å‹ï¼ˆå—¯ï¼Œå®ƒçš„ä¸€ä¸ªå¾®å°éƒ¨åˆ†ï¼‰ã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬éœ€è¦å°†è§‚å¯Ÿæ•°æ®æ˜ å°„åˆ°è¿™äº›æ–¹ç¨‹ä¸­ã€‚ä¸ºäº†ç®€å•èµ·è§ï¼Œæˆ‘ä¼šåœ¨ [è¡¨11-2](#table_11_2)
    ä¸­è™šæ„ä¸€äº›æ•°æ®ï¼ˆä½ å¯ä»¥æƒ³è±¡ *y* å’Œ *h* å•ä½æ˜¯å˜ç±³ï¼Œ*w* å•ä½æ˜¯å…¬æ–¤ï¼‰ã€‚
- en: Table 11-2\. Made-up data for our statistical model of height
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: è¡¨11-2ã€‚æˆ‘ä»¬èº«é«˜ç»Ÿè®¡æ¨¡å‹çš„è™šæ„æ•°æ®
- en: '| *y* | *w* | *h* |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| *y* | *w* | *h* |'
- en: '| --- | --- | --- |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 175 | 70 | 177 |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 175 | 70 | 177 |'
- en: '| 181 | 86 | 190 |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 181 | 86 | 190 |'
- en: '| 159 | 63 | 180 |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 159 | 63 | 180 |'
- en: '| 165 | 62 | 172 |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 165 | 62 | 172 |'
- en: 'Mapping the observed data onto our statistical model involves replicating the
    equation four times (corresponding to four observations in our dataset), each
    time replacing the variables *y*, *w*, and *h* with the measured data:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: å°†è§‚å¯Ÿæ•°æ®æ˜ å°„åˆ°æˆ‘ä»¬çš„ç»Ÿè®¡æ¨¡å‹ä¸­æ¶‰åŠå°†æ–¹ç¨‹å¤åˆ¶å››æ¬¡ï¼ˆå¯¹åº”æˆ‘ä»¬æ•°æ®é›†ä¸­çš„å››ä¸ªè§‚å¯Ÿï¼‰ï¼Œæ¯æ¬¡ç”¨å®é™…æ•°æ®æ›¿æ¢å˜é‡ *y*ã€*w* å’Œ *h*ï¼š
- en: <math alttext="StartLayout 1st Row 1st Column 175 2nd Column equals beta 0 plus
    70 beta 1 plus 177 beta 2 2nd Row 1st Column 181 2nd Column equals beta 0 plus
    86 beta 1 plus 190 beta 2 3rd Row 1st Column 159 2nd Column equals beta 0 plus
    63 beta 1 plus 180 beta 2 4th Row 1st Column 165 2nd Column equals beta 0 plus
    62 beta 1 plus 172 beta 2 EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mn>175</mn></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <msub><mi>Î²</mi> <mn>0</mn></msub> <mo>+</mo> <mn>70</mn> <msub><mi>Î²</mi> <mn>1</mn></msub>
    <mo>+</mo> <mn>177</mn> <msub><mi>Î²</mi> <mn>2</mn></msub></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mn>181</mn></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <msub><mi>Î²</mi> <mn>0</mn></msub> <mo>+</mo> <mn>86</mn> <msub><mi>Î²</mi> <mn>1</mn></msub>
    <mo>+</mo> <mn>190</mn> <msub><mi>Î²</mi> <mn>2</mn></msub></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mn>159</mn></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <msub><mi>Î²</mi> <mn>0</mn></msub> <mo>+</mo> <mn>63</mn> <msub><mi>Î²</mi> <mn>1</mn></msub>
    <mo>+</mo> <mn>180</mn> <msub><mi>Î²</mi> <mn>2</mn></msub></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mn>165</mn></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <msub><mi>Î²</mi> <mn>0</mn></msub> <mo>+</mo> <mn>62</mn> <msub><mi>Î²</mi> <mn>1</mn></msub>
    <mo>+</mo> <mn>172</mn> <msub><mi>Î²</mi> <mn>2</mn></msub></mrow></mtd></mtr></mtable></math>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column 175 2nd Column equals beta 0 plus
    70 beta 1 plus 177 beta 2 2nd Row 1st Column 181 2nd Column equals beta 0 plus
    86 beta 1 plus 190 beta 2 3rd Row 1st Column 159 2nd Column equals beta 0 plus
    63 beta 1 plus 180 beta 2 4th Row 1st Column 165 2nd Column equals beta 0 plus
    62 beta 1 plus 172 beta 2 EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mn>175</mn></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <msub><mi>Î²</mi> <mn>0</mn></msub> <mo>+</mo> <mn>70</mn> <msub><mi>Î²</mi> <mn>1</mn></msub>
    <mo>+</mo> <mn>177</mn> <msub><mi>Î²</mi> <mn>2</mn></msub></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mn>181</mn></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <msub><mi>Î²</mi> <mn>0</mn></msub> <mo>+</mo> <mn>86</mn> <msub><mi>Î²</mi> <mn>1</mn></msub>
    <mo>+</mo> <mn>190</mn> <msub><mi>Î²</mi> <mn>2</mn></msub></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mn>159</mn></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <msub><mi>Î²</mi> <mn>0</mn></msub> <mo>+</mo> <mn>63</mn> <msub><mi>Î²</mi> <mn>1</mn></msub>
    <mo>+</mo> <mn>180</mn> <msub><mi>Î²</mi> <mn>2</mn></msub></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mn>165</mn></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <msub><mi>Î²</mi> <mn>0</mn></msub> <mo>+</mo> <mn>62</mn> <msub><mi>Î²</mi> <mn>1</mn></msub>
    <mo>+</mo> <mn>172</mn> <msub><mi>Î²</mi> <mn>2</mn></msub></mrow></mtd></mtr></mtable></math>
- en: 'Iâ€™m omitting the <math alttext="epsilon"><mi>Ïµ</mi></math> term for now; Iâ€™ll
    have more to say about the residuals later. We now need to translate this system
    of equations into a matrix equation. I know that you know how to do that, so Iâ€™ll
    print out the equation here only so you can confirm what you already know from
    [ChapterÂ 10](ch10.xhtml#Chapter_10):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å‰æˆ‘ä¼šçœç•¥ <math alttext="epsilon"><mi>Ïµ</mi></math> é¡¹ï¼›ç¨åæˆ‘ä¼šè¯¦ç»†è®¨è®ºæ®‹å·®ã€‚ç°åœ¨æˆ‘ä»¬éœ€è¦å°†è¿™äº›æ–¹ç¨‹ç¿»è¯‘æˆçŸ©é˜µæ–¹ç¨‹ã€‚æˆ‘çŸ¥é“ä½ çŸ¥é“å¦‚ä½•åšï¼Œæ‰€ä»¥æˆ‘åœ¨è¿™é‡Œåªæ‰“å°æ–¹ç¨‹ï¼Œä»¥ä¾¿ä½ ä»
    [ç¬¬10ç« ](ch10.xhtml#Chapter_10) ç¡®è®¤ï¼š
- en: <math alttext="Start 4 By 3 Matrix 1st Row 1st Column 1 2nd Column 70 3rd Column
    177 2nd Row 1st Column 1 2nd Column 86 3rd Column 190 3rd Row 1st Column 1 2nd
    Column 63 3rd Column 180 4th Row 1st Column 1 2nd Column 62 3rd Column 172 EndMatrix
    Start 3 By 1 Matrix 1st Row  beta 0 2nd Row  beta 1 3rd Row  beta 2 EndMatrix
    equals Start 4 By 1 Matrix 1st Row  175 2nd Row  181 3rd Row  159 4th Row  165
    EndMatrix" display="block"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>70</mn></mtd> <mtd><mn>177</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>86</mn></mtd> <mtd><mn>190</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>63</mn></mtd> <mtd><mn>180</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>62</mn></mtd> <mtd><mn>172</mn></mtd></mtr></mtable></mfenced> <mfenced
    close="]" open="["><mtable><mtr><mtd><msub><mi>Î²</mi> <mn>0</mn></msub></mtd></mtr>
    <mtr><mtd><msub><mi>Î²</mi> <mn>1</mn></msub></mtd></mtr> <mtr><mtd><msub><mi>Î²</mi>
    <mn>2</mn></msub></mtd></mtr></mtable></mfenced> <mo>=</mo> <mfenced close="]"
    open="["><mtable><mtr><mtd><mn>175</mn></mtd></mtr> <mtr><mtd><mn>181</mn></mtd></mtr>
    <mtr><mtd><mn>159</mn></mtd></mtr> <mtr><mtd><mn>165</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 4 By 3 Matrix 1st Row 1st Column 1 2nd Column 70 3rd Column
    177 2nd Row 1st Column 1 2nd Column 86 3rd Column 190 3rd Row 1st Column 1 2nd
    Column 63 3rd Column 180 4th Row 1st Column 1 2nd Column 62 3rd Column 172 EndMatrix
    Start 3 By 1 Matrix 1st Row  beta 0 2nd Row  beta 1 3rd Row  beta 2 EndMatrix
    equals Start 4 By 1 Matrix 1st Row  175 2nd Row  181 3rd Row  159 4th Row  165
    EndMatrix" display="block"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>70</mn></mtd> <mtd><mn>177</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>86</mn></mtd> <mtd><mn>190</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>63</mn></mtd> <mtd><mn>180</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>62</mn></mtd> <mtd><mn>172</mn></mtd></mtr></mtable></mfenced> <mfenced
    close="]" open="["><mtable><mtr><mtd><msub><mi>Î²</mi> <mn>0</mn></msub></mtd></mtr>
    <mtr><mtd><msub><mi>Î²</mi> <mn>1</mn></msub></mtd></mtr> <mtr><mtd><msub><mi>Î²</mi>
    <mn>2</mn></msub></mtd></mtr></mtable></mfenced> <mo>=</mo> <mfenced close="]"
    open="["><mtable><mtr><mtd><mn>175</mn></mtd></mtr> <mtr><mtd><mn>181</mn></mtd></mtr>
    <mtr><mtd><mn>159</mn></mtd></mtr> <mtr><mtd><mn>165</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: And, of course, we can express this equation succinctly as <math alttext="bold
    upper X beta equals bold y"><mrow><mi mathvariant="bold">X</mi><mi mathvariant="bold">Î²</mi><mo>=</mo><mi
    mathvariant="bold">y</mi></mrow></math>.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œæˆ‘ä»¬å¯ä»¥ç®€æ´åœ°è¡¨ç¤ºè¿™ä¸ªæ–¹ç¨‹ä¸º <math alttext="bold upper X beta equals bold y"><mrow><mi
    mathvariant="bold">X</mi><mi mathvariant="bold">Î²</mi><mo>=</mo><mi mathvariant="bold">y</mi></mrow></math>ã€‚
- en: Solving GLMs
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: è§£å†³å¹¿ä¹‰çº¿æ€§æ¨¡å‹ï¼ˆGLMsï¼‰
- en: 'Iâ€™m sure you already know the main idea of this section: to solve for the vector
    of unknown coefficients <math alttext="beta"><mi mathvariant="bold">Î²</mi></math>,
    simply left-multiply both sides of the equation by the left-inverse of <math alttext="bold
    upper X"><mi>ğ—</mi></math> , the design matrix. The solution looks like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ç›¸ä¿¡ä½ å·²ç»äº†è§£æœ¬èŠ‚çš„ä¸»è¦æ€æƒ³ï¼šä¸ºäº†æ±‚è§£æœªçŸ¥ç³»æ•°å‘é‡ <math alttext="beta"><mi mathvariant="bold">Î²</mi></math>ï¼Œåªéœ€å°†æ–¹ç¨‹å¼çš„ä¸¤è¾¹å·¦ä¹˜è®¾è®¡çŸ©é˜µ
    <math alttext="bold upper X"><mi>ğ—</mi></math> çš„å·¦é€†å³å¯ã€‚è§£å†³æ–¹æ¡ˆå¦‚ä¸‹ï¼š
- en: <math alttext="StartLayout 1st Row 1st Column bold upper X beta 2nd Column equals
    bold y 2nd Row 1st Column left-parenthesis bold upper X Superscript upper T Baseline
    bold upper X right-parenthesis Superscript negative 1 Baseline bold upper X Superscript
    upper T Baseline bold upper X beta 2nd Column equals left-parenthesis bold upper
    X Superscript upper T Baseline bold upper X right-parenthesis Superscript negative
    1 Baseline bold upper X Superscript upper T Baseline bold y 3rd Row 1st Column
    beta 2nd Column equals left-parenthesis bold upper X Superscript upper T Baseline
    bold upper X right-parenthesis Superscript negative 1 Baseline bold upper X Superscript
    upper T Baseline bold y EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mrow><mi mathvariant="bold">X</mi> <mi mathvariant="bold">Î²</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi mathvariant="bold">y</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mrow><msup><mrow><mo>(</mo><msup><mi mathvariant="bold">X</mi>
    <mtext>T</mtext></msup> <mi mathvariant="bold">X</mi><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msup><mi mathvariant="bold">X</mi> <mtext>T</mtext></msup> <mi mathvariant="bold">X</mi>
    <mi mathvariant="bold">Î²</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <msup><mrow><mo>(</mo><msup><mi mathvariant="bold">X</mi> <mtext>T</mtext></msup>
    <mi mathvariant="bold">X</mi><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msup><mi mathvariant="bold">X</mi> <mtext>T</mtext></msup> <mi mathvariant="bold">y</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mi mathvariant="bold">Î²</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <msup><mrow><mo>(</mo><msup><mi mathvariant="bold">X</mi> <mtext>T</mtext></msup>
    <mi mathvariant="bold">X</mi><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msup><mi mathvariant="bold">X</mi> <mtext>T</mtext></msup> <mi mathvariant="bold">y</mi></mrow></mtd></mtr></mtable></math>
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column bold upper X beta 2nd Column equals
    bold y 2nd Row 1st Column left-parenthesis bold upper X Superscript upper T Baseline
    bold upper X right-parenthesis Superscript negative 1 Baseline bold upper X Superscript
    upper T Baseline bold upper X beta 2nd Column equals left-parenthesis bold upper
    X Superscript upper T Baseline bold upper X right-parenthesis Superscript negative
    1 Baseline bold upper X Superscript upper T Baseline bold y 3rd Row 1st Column
    beta 2nd Column equals left-parenthesis bold upper X Superscript upper T Baseline
    bold upper X right-parenthesis Superscript negative 1 Baseline bold upper X Superscript
    upper T Baseline bold y EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mrow><mi mathvariant="bold">X</mi> <mi mathvariant="bold">Î²</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi mathvariant="bold">y</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mrow><msup><mrow><mo>(</mo><msup><mi mathvariant="bold">X</mi>
    <mtext>T</mtext></msup> <mi mathvariant="bold">X</mi><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msup><mi mathvariant="bold">X</mi> <mtext>T</mtext></msup> <mi mathvariant="bold">X</mi>
    <mi mathvariant="bold">Î²</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <msup><mrow><mo>(</mo><msup><mi mathvariant="bold">X</mi> <mtext>T</mtext></msup>
    <mi mathvariant="bold">X</mi><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msup><mi mathvariant="bold">X</mi> <mtext>T</mtext></msup> <mi mathvariant="bold">y</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mi mathvariant="bold">Î²</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <msup><mrow><mo>(</mo><msup><mi mathvariant="bold">X</mi> <mtext>T</mtext></msup>
    <mi mathvariant="bold">X</mi><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msup><mi mathvariant="bold">X</mi> <mtext>T</mtext></msup> <mi mathvariant="bold">y</mi></mrow></mtd></mtr></mtable></math>
- en: 'Please stare at that final equation until it is permanently tattooed into your
    brain. It is called the *least squares solution* and is one of the most important
    mathematical equations in applied linear algebra. Youâ€™ll see it in research publications,
    textbooks, blogs, lectures, docstrings in Python functions, billboards in Tajikistan,^([1](ch11.xhtml#idm45733295548016))
    and many other places. You might see different letters, or possibly some additions,
    like the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·ç›¯ç€é‚£ä¸ªæœ€åçš„æ–¹ç¨‹å¼ç›´åˆ°å®ƒæ°¸è¿œåˆ»åœ¨ä½ çš„è„‘æµ·ä¸­ã€‚å®ƒè¢«ç§°ä¸º*æœ€å°äºŒä¹˜è§£*ï¼Œæ˜¯åº”ç”¨çº¿æ€§ä»£æ•°ä¸­æœ€é‡è¦çš„æ•°å­¦æ–¹ç¨‹ä¹‹ä¸€ã€‚ä½ ä¼šåœ¨ç ”ç©¶å‡ºç‰ˆç‰©ã€æ•™ç§‘ä¹¦ã€åšå®¢ã€è®²åº§ã€Python
    å‡½æ•°çš„æ–‡æ¡£å­—ç¬¦ä¸²ã€å¡”å‰å…‹æ–¯å¦çš„å¹¿å‘Šç‰Œ^([1](ch11.xhtml#idm45733295548016))ç­‰åœ°æ–¹çœ‹åˆ°å®ƒã€‚ä½ å¯èƒ½ä¼šçœ‹åˆ°ä¸åŒçš„å­—æ¯ï¼Œæˆ–è€…å¯èƒ½ä¼šæœ‰ä¸€äº›é™„åŠ å†…å®¹ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: <math alttext="bold b equals left-parenthesis bold upper H Superscript upper
    T Baseline bold upper W bold upper H plus lamda bold upper L Superscript upper
    T Baseline bold upper L right-parenthesis Superscript negative 1 Baseline bold
    upper H Superscript upper T Baseline bold x" display="block"><mrow><mi>ğ›</mi>
    <mo>=</mo> <msup><mrow><mo>(</mo><msup><mi>ğ‡</mi> <mtext>T</mtext></msup> <mi>ğ–</mi><mi>ğ‡</mi><mo>+</mo><mi>Î»</mi><msup><mi>ğ‹</mi>
    <mtext>T</mtext></msup> <mi>ğ‹</mi><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msup><mi>ğ‡</mi> <mtext>T</mtext></msup> <mi>ğ±</mi></mrow></math>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="bold b equals left-parenthesis bold upper H Superscript upper
    T Baseline bold upper W bold upper H plus lamda bold upper L Superscript upper
    T Baseline bold upper L right-parenthesis Superscript negative 1 Baseline bold
    upper H Superscript upper T Baseline bold x" display="block"><mrow><mi>ğ›</mi>
    <mo>=</mo> <msup><mrow><mo>(</mo><msup><mi>ğ‡</mi> <mtext>T</mtext></msup> <mi>ğ–</mi><mi>ğ‡</mi><mo>+</mo><mi>Î»</mi><msup><mi>ğ‹</mi>
    <mtext>T</mtext></msup> <mi>ğ‹</mi><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msup><mi>ğ‡</mi> <mtext>T</mtext></msup> <mi>ğ±</mi></mrow></math>
- en: The meaning of that equation and the interpretation of the additional matrices
    are not important (they are various ways of regularizing the model fitting); what
    is important is that you are able to see the least squares formula embedded in
    that complicated-looking equation (for example, imagine setting <math alttext="bold
    upper W equals bold upper I"><mrow><mi>ğ–</mi> <mo>=</mo> <mi>ğˆ</mi></mrow></math>
    and <math alttext="lamda equals 0"><mrow><mi>Î»</mi> <mo>=</mo> <mn>0</mn></mrow></math>
    ).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: æ–¹ç¨‹å¼çš„å«ä¹‰åŠé™„åŠ çŸ©é˜µçš„è§£é‡Šå¹¶ä¸é‡è¦ï¼ˆå®ƒä»¬æ˜¯æ­£åˆ™åŒ–æ¨¡å‹æ‹Ÿåˆçš„å„ç§æ–¹æ³•ï¼‰ï¼›é‡è¦çš„æ˜¯ï¼Œä½ èƒ½å¤Ÿçœ‹åˆ°æœ€å°äºŒä¹˜å…¬å¼åµŒå…¥åˆ°é‚£ä¸ªçœ‹ä¼¼å¤æ‚çš„æ–¹ç¨‹å¼ä¸­ï¼ˆä¾‹å¦‚ï¼Œè®¾å®š <math
    alttext="bold upper W equals bold upper I"><mrow><mi>ğ–</mi> <mo>=</mo> <mi>ğˆ</mi></mrow></math>
    å’Œ <math alttext="lamda equals 0"><mrow><mi>Î»</mi> <mo>=</mo> <mn>0</mn></mrow></math>
    ï¼‰ã€‚
- en: 'The least squares solution via the left-inverse can be translated directly
    into Python code (variable `X` is the design matrix and variable `y` is the data
    vector):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡å·¦é€†çš„æœ€å°äºŒä¹˜è§£å¯ä»¥ç›´æ¥ç¿»è¯‘æˆ Python ä»£ç ï¼ˆå˜é‡ `X` æ˜¯è®¾è®¡çŸ©é˜µï¼Œå˜é‡ `y` æ˜¯æ•°æ®å‘é‡ï¼‰ï¼š
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: I will show results from these modelsâ€”and how to interpret themâ€”later in this
    chapter; for now Iâ€™d like you to focus on how the math formulas are translated
    into Python code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘å°†åœ¨æœ¬ç« åé¢å±•ç¤ºè¿™äº›æ¨¡å‹çš„ç»“æœâ€”â€”ä»¥åŠå¦‚ä½•è§£é‡Šå®ƒä»¬ï¼›ç°åœ¨è¯·ä½ ä¸“æ³¨äºæ•°å­¦å…¬å¼å¦‚ä½•è½¬æ¢ä¸º Python ä»£ç ã€‚
- en: Left-Inverse Versus NumPyâ€™s Least Squares Solver
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å·¦é€†ä¸ NumPy çš„æœ€å°äºŒä¹˜è§£ç®—å™¨
- en: The code in this chapter is a direct translation of the math into Python code.
    Explicitly computing the left-inverse is not the most numerically stable way to
    solve the GLM (although it is accurate for the simple problems in this chapter),
    but I want you to see that the seemingly abstract linear algebra really works.
    There are more numerically stable ways to solve the GLM, including QR decomposition
    (which you will see later in this chapter) and Pythonâ€™s more numerically stable
    methods (which you will see in the next chapter).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬ç« çš„ä»£ç ç›´æ¥å°†æ•°å­¦å…¬å¼è½¬æ¢ä¸º Python ä»£ç ã€‚æ˜¾å¼è®¡ç®—å·¦é€†ä¸æ˜¯è§£å†³å¹¿ä¹‰çº¿æ€§æ¨¡å‹ï¼ˆGLMï¼‰æœ€ç¨³å®šçš„æ–¹å¼ï¼ˆå°½ç®¡å¯¹æœ¬ç« ä¸­çš„ç®€å•é—®é¢˜æ¥è¯´æ˜¯å‡†ç¡®çš„ï¼‰ï¼Œä½†æˆ‘å¸Œæœ›ä½ èƒ½çœ‹åˆ°è¿™äº›çœ‹ä¼¼æŠ½è±¡çš„çº¿æ€§ä»£æ•°ç¡®å®æœ‰æ•ˆã€‚è§£å†³
    GLM çš„æ›´ç¨³å®šçš„æ–¹å¼åŒ…æ‹¬ QR åˆ†è§£ï¼ˆä½ å°†åœ¨æœ¬ç« åé¢çœ‹åˆ°ï¼‰å’Œ Python çš„æ›´ç¨³å®šçš„æ–¹æ³•ï¼ˆä½ å°†åœ¨ä¸‹ä¸€ç« çœ‹åˆ°ï¼‰ã€‚
- en: Is the Solution Exact?
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è§£æ˜¯å¦ç¡®åˆ‡ï¼Ÿ
- en: The equation <math alttext="bold upper X beta equals bold y"><mrow><mi mathvariant="bold">X</mi><mi
    mathvariant="bold">Î²</mi><mo>=</mo><mi mathvariant="bold">y</mi></mrow></math>
    is exactly solvable when <math alttext="bold y"><mi>ğ²</mi></math> is in the column
    space of the design matrix <math alttext="bold upper X"><mi>ğ—</mi></math> . So
    the question is whether the data vector is guaranteed to be in the column space
    of the statistical model. The answer is no, there is no such guarantee. In fact,
    the data vector <math alttext="bold y"><mi>ğ²</mi></math> is almost never in the
    column space of <math alttext="bold upper X"><mi>ğ—</mi></math> .
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æ•°æ®å‘é‡ <math alttext="bold y"><mi>ğ²</mi></math> åœ¨è®¾è®¡çŸ©é˜µ <math alttext="bold upper
    X"><mi>ğ—</mi></math> çš„åˆ—ç©ºé—´ä¸­æ—¶ï¼Œæ–¹ç¨‹å¼ <math alttext="bold upper X beta equals bold y"><mrow><mi
    mathvariant="bold">X</mi><mi mathvariant="bold">Î²</mi><mo>=</mo><mi mathvariant="bold">y</mi></mrow></math>
    æ˜¯ç¡®åˆ‡å¯è§£çš„ã€‚å› æ­¤é—®é¢˜æ˜¯æ•°æ®å‘é‡æ˜¯å¦ç¡®ä¿åœ¨ç»Ÿè®¡æ¨¡å‹çš„åˆ—ç©ºé—´ä¸­ã€‚ç­”æ¡ˆæ˜¯å¦å®šçš„ï¼Œäº‹å®ä¸Šï¼Œæ•°æ®å‘é‡ <math alttext="bold y"><mi>ğ²</mi></math>
    å‡ ä¹æ°¸è¿œä¸åœ¨ <math alttext="bold upper X"><mi>ğ—</mi></math> çš„åˆ—ç©ºé—´ä¸­ã€‚
- en: To understand why not, letâ€™s imagine a survey of university students in which
    the researchers are trying to predict average GPA (grade point average) based
    on drinking behavior. The survey may contain data from two thousand students yet
    have only three questions (e.g., how much alcohol do you consume; how often do
    you black out; what is your GPA). The data is contained in a 2000 Ã— 3 table. The
    column space of the design matrix is a 2D subspace inside that 2000D ambient dimensionality,
    and the data vector is a 1D subspace inside that same ambient dimensionality.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: è¦ç†è§£ä¸ºä»€ä¹ˆä¸è¿™æ ·åšï¼Œè®©æˆ‘ä»¬æƒ³è±¡ä¸€é¡¹é’ˆå¯¹å¤§å­¦ç”Ÿçš„è°ƒæŸ¥ï¼Œç ”ç©¶äººå‘˜è¯•å›¾æ ¹æ®é¥®é…’è¡Œä¸ºé¢„æµ‹å¹³å‡GPAï¼ˆå¹³å‡ç»©ç‚¹ï¼‰ã€‚è°ƒæŸ¥å¯èƒ½åŒ…å«æ¥è‡ªä¸¤åƒåå­¦ç”Ÿçš„æ•°æ®ï¼Œä½†åªæœ‰ä¸‰ä¸ªé—®é¢˜ï¼ˆä¾‹å¦‚ï¼Œæ‚¨æ¶ˆè´¹å¤šå°‘é…’ç²¾ï¼›æ‚¨ç»å¸¸å¤±å¿†å—ï¼›æ‚¨çš„GPAæ˜¯å¤šå°‘ï¼‰ã€‚æ•°æ®åŒ…å«åœ¨ä¸€ä¸ª2000Ã—3çš„è¡¨æ ¼ä¸­ã€‚è®¾è®¡çŸ©é˜µçš„åˆ—ç©ºé—´æ˜¯è¯¥2000Dç¯å¢ƒç»´åº¦å†…çš„ä¸€ä¸ª2Då­ç©ºé—´ï¼Œè€Œæ•°æ®å‘é‡æ˜¯åŒä¸€ç¯å¢ƒç»´åº¦å†…çš„ä¸€ä¸ª1Då­ç©ºé—´ã€‚
- en: 'If the data is in the column space of the design matrix, it means that the
    model accounts for 100% of the variance in the data. But this almost never happens:
    real-world data contains noise and sampling variability, and the models are simplifications
    that do not account for all of the variability (e.g., GPA is determined by myriad
    factors that our model ignores).'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæ•°æ®åœ¨è®¾è®¡çŸ©é˜µçš„åˆ—ç©ºé—´å†…ï¼Œæ„å‘³ç€æ¨¡å‹å¯ä»¥è§£é‡Šæ•°æ®æ–¹å·®çš„100%ã€‚ä½†è¿™å‡ ä¹ä»ä¸ä¼šå‘ç”Ÿï¼šç°å®ä¸–ç•Œçš„æ•°æ®åŒ…å«å™ªå£°å’ŒæŠ½æ ·å˜å¼‚æ€§ï¼Œè€Œæ¨¡å‹åªæ˜¯ç®€åŒ–ï¼Œæœªèƒ½è§£é‡Šæ‰€æœ‰å˜å¼‚æ€§ï¼ˆä¾‹å¦‚ï¼ŒGPAç”±æˆ‘ä»¬æ¨¡å‹å¿½ç•¥çš„å¤šç§å› ç´ å†³å®šï¼‰ã€‚
- en: 'The solution to this conundrum is that we modify the GLM equation to allow
    for a discrepancy between the model-predicted data and the observed data. It can
    be expressed in several equivalent (up to a sign) ways:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: è§£å†³è¿™ä¸€éš¾é¢˜çš„æ–¹æ³•æ˜¯ä¿®æ”¹GLMæ–¹ç¨‹ï¼Œå…è®¸æ¨¡å‹é¢„æµ‹æ•°æ®ä¸è§‚å¯Ÿæ•°æ®ä¹‹é—´å­˜åœ¨å·®å¼‚ã€‚å®ƒå¯ä»¥ç”¨å‡ ç§ç­‰æ•ˆï¼ˆè‡³å°‘åœ¨ç¬¦å·ä¸Šï¼‰çš„æ–¹å¼è¡¨ç¤ºï¼š
- en: <math alttext="StartLayout 1st Row 1st Column bold upper X beta 2nd Column equals
    bold y plus epsilon 2nd Row 1st Column bold upper X beta plus epsilon 2nd Column
    equals bold y 3rd Row 1st Column epsilon 2nd Column equals bold upper X beta minus
    bold y EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi
    mathvariant="bold">X</mi> <mi mathvariant="bold">Î²</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mi mathvariant="bold">y</mi> <mo>+</mo> <mi mathvariant="bold">Ïµ</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mrow><mi mathvariant="bold">X</mi> <mi mathvariant="bold">Î²</mi>
    <mo>+</mo> <mi mathvariant="bold">Ïµ</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mi mathvariant="bold">y</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi
    mathvariant="bold">Ïµ</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo> <mi mathvariant="bold">X</mi>
    <mi mathvariant="bold">Î²</mi> <mo>-</mo> <mi mathvariant="bold">y</mi></mrow></mtd></mtr></mtable></math>
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column bold upper X beta 2nd Column equals
    bold y plus epsilon 2nd Row 1st Column bold upper X beta plus epsilon 2nd Column
    equals bold y 3rd Row 1st Column epsilon 2nd Column equals bold upper X beta minus
    bold y EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi
    mathvariant="bold">X</mi> <mi mathvariant="bold">Î²</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mi mathvariant="bold">y</mi> <mo>+</mo> <mi mathvariant="bold">Ïµ</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mrow><mi mathvariant="bold">X</mi> <mi mathvariant="bold">Î²</mi>
    <mo>+</mo> <mi mathvariant="bold">Ïµ</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mi mathvariant="bold">y</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi
    mathvariant="bold">Ïµ</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo> <mi mathvariant="bold">X</mi>
    <mi mathvariant="bold">Î²</mi> <mo>-</mo> <mi mathvariant="bold">y</mi></mrow></mtd></mtr></mtable></math>
- en: The interpretation of the first equation is that <math alttext="epsilon"><mi
    mathvariant="bold">Ïµ</mi></math> is a residual, or an error term, that you add
    to the data vector so that it fits inside the column space of the design matrix.
    The interpretation of the second equation is that the residual term is an adjustment
    to the design matrix so that it fits the data perfectly. Finally, the interpretation
    of the third equation is that the residual is defined as the difference between
    the model-predicted data and the observed data.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬ä¸€ä¸ªæ–¹ç¨‹çš„è§£é‡Šæ˜¯<math alttext="epsilon"><mi mathvariant="bold">Ïµ</mi></math>æ˜¯ä¸€ä¸ªæ®‹å·®ï¼Œæˆ–è€…è¯´æ˜¯ä¸€ä¸ªè¯¯å·®é¡¹ï¼Œä½ éœ€è¦å°†å®ƒåŠ åˆ°æ•°æ®å‘é‡ä¸­ï¼Œä½¿å…¶ç¬¦åˆè®¾è®¡çŸ©é˜µçš„åˆ—ç©ºé—´ã€‚ç¬¬äºŒä¸ªæ–¹ç¨‹çš„è§£é‡Šæ˜¯æ®‹å·®é¡¹æ˜¯å¯¹è®¾è®¡çŸ©é˜µçš„è°ƒæ•´ï¼Œä»¥ä¾¿å®Œç¾æ‹Ÿåˆæ•°æ®ã€‚æœ€åï¼Œç¬¬ä¸‰ä¸ªæ–¹ç¨‹çš„è§£é‡Šæ˜¯æ®‹å·®è¢«å®šä¹‰ä¸ºæ¨¡å‹é¢„æµ‹æ•°æ®ä¸è§‚å¯Ÿæ•°æ®ä¹‹é—´çš„å·®å¼‚ã€‚
- en: There is another, very insightful, interpretation, which approaches GLMs and
    least squares from a geometric perspective. Iâ€™ll get back to this in the next
    section.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: è¿˜æœ‰å¦ä¸€ç§éå¸¸æœ‰è§åœ°çš„è§£é‡Šï¼Œä»å‡ ä½•è§’åº¦æ¥è¿‘GLMå’Œæœ€å°äºŒä¹˜æ³•ã€‚æˆ‘å°†åœ¨ä¸‹ä¸€èŠ‚è¯¦ç»†ä»‹ç»è¿™ä¸€ç‚¹ã€‚
- en: The point of this section is that the observed data is almost never inside the
    subspace spanned by the regressors. For this reason, it is also common to see
    the GLM expressed as <math alttext="bold upper X equals beta ModifyingAbove bold
    y With bold caret"><mrow><mi mathvariant="bold">X</mi><mo>=</mo><mi mathvariant="bold">Î²</mi><mover
    accent="true"><mi mathvariant="bold">y</mi> <mo>^</mo></mover></mrow></math> where
    <math alttext="ModifyingAbove bold y With bold caret equals bold y plus epsilon"><mrow><mover
    accent="true"><mi mathvariant="bold">y</mi> <mo>^</mo></mover><mo>=</mo><mi mathvariant="bold">y</mi><mo>+</mo><mi
    mathvariant="bold">Ïµ</mi></mrow></math>.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸€éƒ¨åˆ†çš„è¦ç‚¹æ˜¯è§‚å¯Ÿåˆ°çš„æ•°æ®å‡ ä¹ä»ä¸åœ¨å›å½’å‘é‡ç”Ÿæˆçš„å­ç©ºé—´å†…ã€‚å› æ­¤ï¼Œé€šå¸¸å°†GLMè¡¨ç¤ºä¸º<math alttext="bold upper X equals
    beta ModifyingAbove bold y With bold caret"><mrow><mi mathvariant="bold">X</mi><mo>=</mo><mi
    mathvariant="bold">Î²</mi><mover accent="true"><mi mathvariant="bold">y</mi> <mo>^</mo></mover></mrow></math>ï¼Œå…¶ä¸­<math
    alttext="ModifyingAbove bold y With bold caret equals bold y plus epsilon"><mrow><mover
    accent="true"><mi mathvariant="bold">y</mi> <mo>^</mo></mover><mo>=</mo><mi mathvariant="bold">y</mi><mo>+</mo><mi
    mathvariant="bold">Ïµ</mi></mrow></math>ã€‚
- en: Therefore, the goal of the GLM is to find the linear combination of the regressors
    that gets as close as possible to the observed data. More on this point later;
    I now want to introduce you to the geometric perspective of least squares.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼ŒGLMçš„ç›®æ ‡æ˜¯æ‰¾åˆ°å›å½’å˜é‡çš„çº¿æ€§ç»„åˆï¼Œä½¿å…¶å°½å¯èƒ½æ¥è¿‘è§‚å¯Ÿæ•°æ®ã€‚å…³äºè¿™ä¸€ç‚¹çš„æ›´å¤šå†…å®¹å°†åœ¨åé¢è¯¦ç»†è¯´æ˜ï¼›ç°åœ¨æˆ‘æƒ³å‘ä½ ä»‹ç»æœ€å°äºŒä¹˜æ³•çš„å‡ ä½•è§†è§’ã€‚
- en: A Geometric Perspective on Least Squares
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: æœ€å°äºŒä¹˜æ³•çš„å‡ ä½•è§†è§’
- en: So far Iâ€™ve introduced the solution to the GLM from the algebraic perspective
    of solving a matrix equation. There is also a geometric perspective to the GLM,
    which provides an alternative perspective and helps reveal several important features
    of the least squares solution.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»‹ç»äº†ä»è§£çŸ©é˜µæ–¹ç¨‹çš„ä»£æ•°è§’åº¦è§£å†³GLMçš„æ–¹æ³•ã€‚GLMè¿˜æœ‰ä¸€ç§å‡ ä½•è§†è§’ï¼Œæä¾›äº†ä¸€ç§æ›¿ä»£è§†è§’ï¼Œå¹¶å¸®åŠ©æ­ç¤ºæœ€å°äºŒä¹˜è§£å†³æ–¹æ¡ˆçš„å‡ ä¸ªé‡è¦ç‰¹å¾ã€‚
- en: Letâ€™s consider that the column space of the design matrix <math alttext="upper
    C left-parenthesis bold upper X right-parenthesis"><mrow><mi>C</mi> <mo>(</mo>
    <mi>ğ—</mi> <mo>)</mo></mrow></math> is a subspace of <math alttext="double-struck
    upper R Superscript upper M"><msup><mi>â„</mi> <mi>M</mi></msup></math> . Itâ€™s
    typically a very low-dimensional subspace (that is, *N* << *M*), because statistical
    models tend to have many more observations (rows) than predictors (columns). The
    dependent variable is a vector <math alttext="bold y element-of double-struck
    upper R Superscript upper M"><mrow><mi>ğ²</mi> <mo>âˆˆ</mo> <msup><mi>â„</mi> <mi>M</mi></msup></mrow></math>
    . The questions at hand are, is the vector <math alttext="bold y"><mi>ğ²</mi></math>
    in the column space of the design matrix, and if not, what coordinate inside the
    column space of the design matrix is as close as possible to the data vector?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬è€ƒè™‘è®¾è®¡çŸ©é˜µçš„åˆ—ç©ºé—´<math alttext="upper C left-parenthesis bold upper X right-parenthesis"><mrow><mi>C</mi>
    <mo>(</mo> <mi>ğ—</mi> <mo>)</mo></mrow></math>æ˜¯<math alttext="double-struck upper
    R Superscript upper M"><msup><mi>â„</mi> <mi>M</mi></msup></math>çš„å­ç©ºé—´ã€‚é€šå¸¸æ˜¯ä¸€ä¸ªéå¸¸ä½ç»´çš„å­ç©ºé—´ï¼ˆå³ï¼Œ*N*
    << *M*ï¼‰ï¼Œå› ä¸ºç»Ÿè®¡æ¨¡å‹é€šå¸¸æœ‰æ¯”é¢„æµ‹å˜é‡ï¼ˆåˆ—ï¼‰æ›´å¤šçš„è§‚å¯Ÿï¼ˆè¡Œï¼‰ã€‚å› å˜é‡æ˜¯å‘é‡<math alttext="bold y element-of double-struck
    upper R Superscript upper M"><mrow><mi>ğ²</mi> <mo>âˆˆ</mo> <msup><mi>â„</mi> <mi>M</mi></msup></mrow></math>ã€‚æ‰€æ¶‰åŠçš„é—®é¢˜æ˜¯ï¼Œå‘é‡<math
    alttext="bold y"><mi>ğ²</mi></math>æ˜¯å¦åœ¨è®¾è®¡çŸ©é˜µçš„åˆ—ç©ºé—´ä¸­ï¼Œå¦‚æœä¸æ˜¯ï¼Œé‚£ä¹ˆè®¾è®¡çŸ©é˜µçš„åˆ—ç©ºé—´å†…çš„åæ ‡æœ€æ¥è¿‘æ•°æ®å‘é‡æ˜¯ä»€ä¹ˆï¼Ÿ
- en: The answer to the first question is no, as I discussed in the previous section.
    The second question is profound, because you already learned the answer in [ChapterÂ 2](ch02.xhtml#Chapter_2).
    Consider [FigureÂ 11-1](#fig_11_1) while thinking about the solution.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬ä¸€ä¸ªé—®é¢˜çš„ç­”æ¡ˆæ˜¯å¦å®šçš„ï¼Œæ­£å¦‚æˆ‘åœ¨å‰ä¸€èŠ‚ä¸­è®¨è®ºçš„é‚£æ ·ã€‚ç¬¬äºŒä¸ªé—®é¢˜å¾ˆæ·±åˆ»ï¼Œå› ä¸ºä½ å·²ç»åœ¨[ç¬¬äºŒç« ](ch02.xhtml#Chapter_2)ä¸­å­¦ä¹ äº†ç­”æ¡ˆã€‚åœ¨è€ƒè™‘è§£å†³æ–¹æ¡ˆæ—¶ï¼Œè¯·å‚è€ƒ[å›¾Â 11-1](#fig_11_1)ã€‚
- en: '![geo of glm](assets/plad_1101.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![glm çš„å‡ ä½•](assets/plad_1101.png)'
- en: 'Figure 11-1\. The abstracted geometric view of GLM: find the point in the column
    space of the design matrix that is as close as possible to the data vector'
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾ 11-1. GLM çš„æŠ½è±¡å‡ ä½•è§†è§’ï¼šæ‰¾åˆ°è®¾è®¡çŸ©é˜µåˆ—ç©ºé—´ä¸­è·ç¦»æ•°æ®å‘é‡æœ€æ¥è¿‘çš„ç‚¹
- en: 'So, our goal is to find the set of coefficients <math alttext="beta"><mi mathvariant="bold">Î²</mi></math>
    such that the weighted combination of columns in <math alttext="bold upper X"><mi>ğ—</mi></math>
    minimizes the distance to data vector <math alttext="bold y"><mi>ğ²</mi></math>
    . We can call that projection vector <math alttext="epsilon"><mi mathvariant="bold">Ïµ</mi></math>.
    How do we find the vector <math alttext="epsilon"><mi mathvariant="bold">Ïµ</mi></math>
    and the coefficients <math alttext="beta"><mi mathvariant="bold">Î²</mi></math>?
    We use orthogonal vector projection, just like what you learned in [ChapterÂ 2](ch02.xhtml#Chapter_2).
    This means we can apply the same approach as in [ChapterÂ 2](ch02.xhtml#Chapter_2),
    but using matrices instead of vectors. The key insight is that the shortest distance
    between <math alttext="bold y"><mi>ğ²</mi></math> and <math alttext="bold upper
    X"><mi>ğ—</mi></math> is given by the projection vector <math alttext="bold y minus
    bold upper X beta"><mrow><mi mathvariant="bold">y</mi><mo>-</mo><mi mathvariant="bold">X</mi><mi
    mathvariant="bold">Î²</mi></mrow></math> that meets <math alttext="bold upper X"><mi>ğ—</mi></math>
    at a right angle:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬çš„ç›®æ ‡æ˜¯æ‰¾åˆ°ç³»æ•°é›†åˆ<math alttext="beta"><mi mathvariant="bold">Î²</mi></math>ï¼Œä½¿å¾—<math
    alttext="bold upper X"><mi>ğ—</mi></math>ä¸­åˆ—çš„åŠ æƒç»„åˆæœ€å°åŒ–åˆ°æ•°æ®å‘é‡<math alttext="bold y"><mi>ğ²</mi></math>çš„è·ç¦»ã€‚æˆ‘ä»¬å¯ä»¥ç§°è¯¥æŠ•å½±å‘é‡ä¸º<math
    alttext="epsilon"><mi mathvariant="bold">Ïµ</mi></math>ã€‚æˆ‘ä»¬å¦‚ä½•æ‰¾åˆ°å‘é‡<math alttext="epsilon"><mi
    mathvariant="bold">Ïµ</mi></math>å’Œç³»æ•°<math alttext="beta"><mi mathvariant="bold">Î²</mi></math>ï¼Ÿæˆ‘ä»¬ä½¿ç”¨æ­£äº¤å‘é‡æŠ•å½±ï¼Œå°±åƒä½ åœ¨[ç¬¬äºŒç« ](ch02.xhtml#Chapter_2)ä¸­å­¦åˆ°çš„é‚£æ ·ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥åº”ç”¨ä¸å‘é‡ä¸åŒçš„çŸ©é˜µç›¸åŒçš„æ–¹æ³•ã€‚å…³é”®çš„è§è§£æ˜¯ï¼Œ<math
    alttext="bold y"><mi>ğ²</mi></math>å’Œ<math alttext="bold upper X"><mi>ğ—</mi></math>ä¹‹é—´çš„æœ€çŸ­è·ç¦»ç”±æŠ•å½±å‘é‡<math
    alttext="bold y minus bold upper X beta"><mrow><mi mathvariant="bold">y</mi><mo>-</mo><mi
    mathvariant="bold">X</mi><mi mathvariant="bold">Î²</mi></mrow></math>ç»™å‡ºï¼Œè¯¥å‘é‡åœ¨<math
    alttext="bold upper X"><mi>ğ—</mi></math>ä¸Šå‘ˆç›´è§’ï¼š
- en: <math alttext="StartLayout 1st Row 1st Column bold upper X Superscript upper
    T Baseline epsilon 2nd Column equals bold 0 2nd Row 1st Column bold upper X Superscript
    upper T Baseline left-parenthesis bold y minus bold upper X beta right-parenthesis
    2nd Column equals bold 0 3rd Row 1st Column bold upper X Superscript upper T Baseline
    bold y minus bold upper X Superscript upper T Baseline bold upper X beta 2nd Column
    equals bold 0 4th Row 1st Column bold upper X Superscript upper T Baseline bold
    upper X beta 2nd Column equals bold upper X Superscript upper T Baseline bold
    y 5th Row 1st Column beta 2nd Column equals left-parenthesis bold upper X Superscript
    upper T Baseline bold upper X right-parenthesis Superscript negative 1 Baseline
    bold upper X Superscript upper T Baseline bold y EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><msup><mi mathvariant="bold">X</mi>
    <mtext>T</mtext></msup> <mi mathvariant="bold">Ïµ</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mn mathvariant="bold">0</mn></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mrow><msup><mi
    mathvariant="bold">X</mi> <mtext>T</mtext></msup> <mrow><mo>(</mo> <mi mathvariant="bold">y</mi>
    <mo>-</mo> <mi mathvariant="bold">X</mi> <mi mathvariant="bold">Î²</mi> <mo>)</mo></mrow></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mn mathvariant="bold">0</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mrow><msup><mi mathvariant="bold">X</mi> <mtext>T</mtext></msup>
    <mi mathvariant="bold">y</mi> <mo>-</mo> <msup><mi mathvariant="bold">X</mi> <mtext>T</mtext></msup>
    <mi mathvariant="bold">X</mi> <mi mathvariant="bold">Î²</mi></mrow></mtd> <mtd
    columnalign="left"><mrow><mo>=</mo> <mn mathvariant="bold">0</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mrow><msup><mi mathvariant="bold">X</mi> <mtext>T</mtext></msup>
    <mi mathvariant="bold">X</mi> <mi mathvariant="bold">Î²</mi></mrow></mtd> <mtd
    columnalign="left"><mrow><mo>=</mo> <msup><mi mathvariant="bold">X</mi> <mtext>T</mtext></msup>
    <mi mathvariant="bold">y</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi
    mathvariant="bold">Î²</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo> <msup><mrow><mo>(</mo><msup><mi
    mathvariant="bold">X</mi> <mtext>T</mtext></msup> <mi mathvariant="bold">X</mi><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <msup><mi mathvariant="bold">X</mi> <mtext>T</mtext></msup>
    <mi mathvariant="bold">y</mi></mrow></mtd></mtr></mtable></math>
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column bold upper X Superscript upper
    T Baseline epsilon 2nd Column equals bold 0 2nd Row 1st Column bold upper X Superscript
    upper T Baseline left-parenthesis bold y minus bold upper X beta right-parenthesis
    2nd Column equals bold 0 3rd Row 1st Column bold upper X Superscript upper T Baseline
    bold y minus bold upper X Superscript upper T Baseline bold upper X beta 2nd Column
    equals bold 0 4th Row 1st Column bold upper X Superscript upper T Baseline bold
    upper X beta 2nd Column equals bold upper X Superscript upper T Baseline bold
    y 5th Row 1st Column beta 2nd Column equals left-parenthesis bold upper X Superscript
    upper T Baseline bold upper X right-parenthesis Superscript negative 1 Baseline
    bold upper X Superscript upper T Baseline bold y EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><msup><mi mathvariant="bold">X</mi>
    <mtext>T</mtext></msup> <mi mathvariant="bold">Ïµ</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mn mathvariant="bold">0</mn></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mrow><msup><mi
    mathvariant="bold">X</mi> <mtext>T</mtext></msup> <mrow><mo>(</mo> <mi mathvariant="bold">y</mi>
    <mo>-</mo> <mi mathvariant="bold">X</mi> <mi mathvariant="bold">Î²</mi> <mo>)</mo></mrow></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mn mathvariant="bold">0</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mrow><msup><mi mathvariant="bold">X</mi> <mtext>T</mtext></msup>
    <mi mathvariant="bold">y</mi> <mo>-</mo> <msup><mi mathvariant="bold">X</mi> <mtext>T</mtext></msup>
    <mi mathvariant="bold">X</mi> <mi mathvariant="bold">Î²</mi></mrow></mtd> <mtd
    columnalign="left"><mrow><mo>=</mo> <mn mathvariant="bold">0</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mrow><msup><mi mathvariant="bold">X</mi> <mtext>T</mtext></msup>
    <mi mathvariant="bold">X</mi> <mi mathvariant="bold">Î²</mi></mrow></mtd> <mtd
    columnalign="left"><mrow><mo>=</mo> <msup><mi mathvariant="bold">X</mi> <mtext>T</mtext></msup>
    <mi mathvariant="bold">y</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi
    mathvariant="bold">Î²</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo> <msup><mrow><mo>(</mo><msup><mi
    mathvariant="bold">X</mi> <mtext>T</mtext></msup> <mi mathvariant="bold">X</mi><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <msup><mi mathvariant="bold">X</mi> <mtext>T</mtext></msup>
    <mi mathvariant="bold">y</mi></mrow></mtd></mtr></mtable></math>
- en: 'That progression of equations is remarkable: we started from thinking about
    the GLM as a geometric projection of a data vector onto the column space of a
    design matrix, applied the principle of orthogonal vector projection that you
    learned about early on in the book, and voilÃ ! We have rederived the same left-inverse
    solution that we got from the algebraic approach.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸€ç³»åˆ—æ–¹ç¨‹çš„è¿›å±•éå¸¸å¼•äººæ³¨ç›®ï¼šæˆ‘ä»¬ä»æŠŠå¹¿ä¹‰çº¿æ€§æ¨¡å‹ï¼ˆGLMï¼‰çœ‹ä½œæ˜¯æ•°æ®å‘é‡åœ¨è®¾è®¡çŸ©é˜µçš„åˆ—ç©ºé—´ä¸Šçš„å‡ ä½•æŠ•å½±å¼€å§‹ï¼Œåº”ç”¨äº†æ‚¨åœ¨æœ¬ä¹¦æ—©æœŸå­¦åˆ°çš„æ­£äº¤å‘é‡æŠ•å½±åŸç†ï¼Œç„¶åï¼æˆ‘ä»¬é‡æ–°å¯¼å‡ºäº†ä»ä»£æ•°æ–¹æ³•ä¸­å¾—åˆ°çš„ç›¸åŒå·¦é€†è§£ã€‚
- en: Why Does Least Squares Work?
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆæœ€å°äºŒä¹˜æ³•æœ‰æ•ˆï¼Ÿ
- en: Why is it called â€œleast squaresâ€? What are these so-called squares, and why
    does this method give us the least of them?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆç§°ä¹‹ä¸ºâ€œæœ€å°äºŒä¹˜æ³•â€ï¼Ÿè¿™äº›æ‰€è°“çš„å¹³æ–¹æ˜¯ä»€ä¹ˆï¼Œä¸ºä»€ä¹ˆè¿™ç§æ–¹æ³•èƒ½ä½¿å®ƒä»¬æœ€å°åŒ–ï¼Ÿ
- en: 'The â€œsquaresâ€ here refers to squared errors between the predicted data and
    the observed data. There is an error term for each *i*th predicted data point,
    which is defined as <math alttext="epsilon Subscript i Baseline equals bold upper
    X Subscript i Baseline beta minus bold y Subscript i"><mrow><msub><mi>Ïµ</mi> <mi>i</mi></msub>
    <mo>=</mo><msub><mi mathvariant="bold">X</mi> <mi>i</mi></msub> <mi mathvariant="bold">Î²</mi><mo>-</mo><msub><mi
    mathvariant="bold">y</mi> <mi>i</mi></msub></mrow></math> . Note that each data
    point is predicted using the same set of coefficients (that is, the same weights
    for combining the predictors in the design matrix). We can capture all errors
    in one vector:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œçš„â€œå¹³æ–¹â€æŒ‡çš„æ˜¯é¢„æµ‹æ•°æ®ä¸è§‚æµ‹æ•°æ®ä¹‹é—´çš„å¹³æ–¹è¯¯å·®ã€‚æ¯ä¸ªç¬¬*i*ä¸ªé¢„æµ‹æ•°æ®ç‚¹éƒ½æœ‰ä¸€ä¸ªè¯¯å·®é¡¹ï¼Œå®šä¹‰ä¸º<math alttext="epsilon Subscript
    i Baseline equals bold upper X Subscript i Baseline beta minus bold y Subscript
    i"><mrow><msub><mi>Ïµ</mi> <mi>i</mi></msub> <mo>=</mo><msub><mi mathvariant="bold">X</mi>
    <mi>i</mi></msub> <mi mathvariant="bold">Î²</mi><mo>-</mo><msub><mi mathvariant="bold">y</mi>
    <mi>i</mi></msub></mrow></math> ã€‚è¯·æ³¨æ„ï¼Œæ¯ä¸ªæ•°æ®ç‚¹éƒ½ä½¿ç”¨ç›¸åŒçš„ç³»æ•°ï¼ˆå³è®¾è®¡çŸ©é˜µä¸­é¢„æµ‹å™¨çš„ç›¸åŒæƒé‡ç»„åˆï¼‰ã€‚æˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ªå‘é‡æ¥è¡¨ç¤ºæ‰€æœ‰çš„è¯¯å·®ï¼š
- en: <math alttext="epsilon equals bold upper X beta minus bold y" display="block"><mrow><mi
    mathvariant="bold">Ïµ</mi> <mo>=</mo> <mi mathvariant="bold">X</mi> <mi mathvariant="bold">Î²</mi>
    <mo>-</mo> <mi mathvariant="bold">y</mi></mrow></math>
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="epsilon equals bold upper X beta minus bold y" display="block"><mrow><mi
    mathvariant="bold">Ïµ</mi> <mo>=</mo> <mi mathvariant="bold">X</mi> <mi mathvariant="bold">Î²</mi>
    <mo>-</mo> <mi mathvariant="bold">y</mi></mrow></math>
- en: 'If the model is a good fit to the data, then the errors should be small. Therefore,
    we can say that the objective of model fitting is to choose the elements in <math
    alttext="beta"><mi mathvariant="bold">Î²</mi></math> that minimize the elements
    in <math alttext="epsilon"><mi mathvariant="bold">Ïµ</mi></math>. But just *minimizing*
    the errors would cause the model to predict values toward negative infinity. Thus,
    instead we minimize the *squared* errors, which correspond to their geometric
    squared distance to the observed data <math alttext="bold y"><mi>ğ²</mi></math>
    , regardless of whether the prediction error itself is positive or negative.^([2](ch11.xhtml#idm45733295319056))
    This is the same thing as minimizing the squared norm of the errors. Hence the
    name â€œleast squares.â€ That leads to the following modification:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæ¨¡å‹å¾ˆå¥½åœ°æ‹Ÿåˆäº†æ•°æ®ï¼Œé‚£ä¹ˆè¯¯å·®åº”è¯¥å¾ˆå°ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥è¯´æ¨¡å‹æ‹Ÿåˆçš„ç›®æ ‡æ˜¯é€‰æ‹©æœ€å°åŒ–<math alttext="beta"><mi mathvariant="bold">Î²</mi></math>
    ä¸­çš„å…ƒç´ ï¼Œè¿™äº›å…ƒç´ æœ€å°åŒ–äº†<math alttext="epsilon"><mi mathvariant="bold">Ïµ</mi></math> ä¸­çš„å…ƒç´ ã€‚ä½†æ˜¯ä»…ä»…*æœ€å°åŒ–*è¯¯å·®ä¼šå¯¼è‡´æ¨¡å‹é¢„æµ‹å€¼å‘è´Ÿæ— ç©·é¢„æµ‹ã€‚å› æ­¤ï¼Œæˆ‘ä»¬æœ€å°åŒ–*å¹³æ–¹*è¯¯å·®ï¼Œè¿™å¯¹åº”äºå®ƒä»¬åˆ°è§‚æµ‹æ•°æ®<math
    alttext="bold y"><mi>ğ²</mi></math> çš„å‡ ä½•å¹³æ–¹è·ç¦»ï¼Œè€Œä¸ç®¡é¢„æµ‹è¯¯å·®æœ¬èº«æ˜¯æ­£è¿˜æ˜¯è´Ÿã€‚^([2](ch11.xhtml#idm45733295319056))
    è¿™ä¸æœ€å°åŒ–è¯¯å·®èŒƒæ•°çš„æ€æƒ³æ˜¯ç›¸åŒçš„ã€‚å› æ­¤å¾—åâ€œæœ€å°äºŒä¹˜æ³•â€ã€‚è¿™å¯¼è‡´äº†ä»¥ä¸‹ä¿®æ”¹ï¼š
- en: <math alttext="parallel-to epsilon parallel-to equals parallel-to bold upper
    X beta minus bold y parallel-to" display="block"><mrow><msup><mrow><mo>âˆ¥</mo><mi
    mathvariant="bold">Ïµ</mi><mo>âˆ¥</mo></mrow> <mn>2</mn></msup> <mo>=</mo> <msup><mrow><mo>âˆ¥</mo><mi
    mathvariant="bold">X</mi><mi mathvariant="bold">Î²</mi><mo>-</mo><mi mathvariant="bold">y</mi><mo>âˆ¥</mo></mrow>
    <mn>2</mn></msup></mrow></math>
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="parallel-to epsilon parallel-to equals parallel-to bold upper
    X beta minus bold y parallel-to" display="block"><mrow><msup><mrow><mo>âˆ¥</mo><mi
    mathvariant="bold">Ïµ</mi><mo>âˆ¥</mo></mrow> <mn>2</mn></msup> <mo>=</mo> <msup><mrow><mo>âˆ¥</mo><mi
    mathvariant="bold">X</mi><mi mathvariant="bold">Î²</mi><mo>-</mo><mi mathvariant="bold">y</mi><mo>âˆ¥</mo></mrow>
    <mn>2</mn></msup></mrow></math>
- en: 'We can now view this as an optimization problem. In particular, we want to
    find the set of coefficients that minimizes the squared errors. That minimization
    can be expressed as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å¯ä»¥æŠŠå®ƒçœ‹ä½œæ˜¯ä¸€ä¸ªä¼˜åŒ–é—®é¢˜ã€‚ç‰¹åˆ«åœ°ï¼Œæˆ‘ä»¬æƒ³æ‰¾åˆ°ä¸€ç»„ç³»æ•°ï¼Œè¿™äº›ç³»æ•°æœ€å°åŒ–äº†å¹³æ–¹è¯¯å·®ã€‚è¿™ç§æœ€å°åŒ–å¯ä»¥è¡¨è¾¾å¦‚ä¸‹ï¼š
- en: <math alttext="min Underscript beta Endscripts parallel-to bold upper X beta
    minus bold y parallel-to" display="block"><mrow><munder><mo form="prefix" movablelimits="true">min</mo>
    <mi mathvariant="bold">Î²</mi></munder> <msup><mrow><mo>âˆ¥</mo><mi mathvariant="bold">X</mi><mi
    mathvariant="bold">Î²</mi><mo>-</mo><mi mathvariant="bold">y</mi><mo>âˆ¥</mo></mrow>
    <mn>2</mn></msup></mrow></math>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="min Underscript beta Endscripts parallel-to bold upper X beta
    minus bold y parallel-to" display="block"><mrow><munder><mo form="prefix" movablelimits="true">min</mo>
    <mi mathvariant="bold">Î²</mi></munder> <msup><mrow><mo>âˆ¥</mo><mi mathvariant="bold">X</mi><mi
    mathvariant="bold">Î²</mi><mo>-</mo><mi mathvariant="bold">y</mi><mo>âˆ¥</mo></mrow>
    <mn>2</mn></msup></mrow></math>
- en: 'The solution to this optimization can be found by setting the derivative of
    the objective to zero and applying a bit of differential calculus^([3](ch11.xhtml#idm45733295298448))
    and a bit of algebra:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: è§£å†³è¿™ä¸ªä¼˜åŒ–é—®é¢˜å¯ä»¥é€šè¿‡å°†ç›®æ ‡çš„å¯¼æ•°è®¾ä¸ºé›¶å¹¶åº”ç”¨ä¸€ç‚¹å¾®åˆ†è®¡ç®—^([3](ch11.xhtml#idm45733295298448)) å’Œä¸€ç‚¹ä»£æ•°æ¥æ‰¾åˆ°ã€‚
- en: <math alttext="StartLayout 1st Row 1st Column 0 equals StartFraction d Over
    d beta EndFraction parallel-to bold upper X beta minus bold y parallel-to 2nd
    Column equals 2 bold upper X Superscript upper T Baseline left-parenthesis bold
    upper X beta minus bold y right-parenthesis 2nd Row 1st Column 0 2nd Column equals
    bold upper X Superscript upper T Baseline bold upper X beta minus bold upper X
    Superscript upper T Baseline bold y 3rd Row 1st Column bold upper X Superscript
    upper T Baseline bold upper X beta 2nd Column equals bold upper X Superscript
    upper T Baseline bold y 4th Row 1st Column beta 2nd Column equals left-parenthesis
    bold upper X Superscript upper T Baseline bold upper X right-parenthesis Superscript
    negative 1 Baseline bold upper X Superscript upper T Baseline bold y EndLayout"
    display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mn>0</mn>
    <mo>=</mo> <mfrac><mi>d</mi> <mrow><mi>d</mi><mi mathvariant="bold">Î²</mi></mrow></mfrac>
    <msup><mrow><mo>âˆ¥</mo><mi mathvariant="bold">X</mi><mi mathvariant="bold">Î²</mi><mo>-</mo><mi
    mathvariant="bold">y</mi><mo>âˆ¥</mo></mrow> <mn>2</mn></msup></mrow></mtd> <mtd
    columnalign="left"><mrow><mo>=</mo> <mn>2</mn> <msup><mi mathvariant="bold">X</mi>
    <mtext>T</mtext></msup> <mrow><mo>(</mo> <mi mathvariant="bold">X</mi> <mi mathvariant="bold">Î²</mi>
    <mo>-</mo> <mi mathvariant="bold">y</mi> <mo>)</mo></mrow></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mn>0</mn></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <msup><mi mathvariant="bold">X</mi> <mtext>T</mtext></msup> <mi mathvariant="bold">X</mi>
    <mi mathvariant="bold">Î²</mi> <mo>-</mo> <msup><mi mathvariant="bold">X</mi> <mtext>T</mtext></msup>
    <mi mathvariant="bold">y</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mrow><msup><mi
    mathvariant="bold">X</mi> <mtext>T</mtext></msup> <mi mathvariant="bold">X</mi>
    <mi mathvariant="bold">Î²</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <msup><mi mathvariant="bold">X</mi> <mtext>T</mtext></msup> <mi mathvariant="bold">y</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mi mathvariant="bold">Î²</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <msup><mrow><mo>(</mo><msup><mi mathvariant="bold">X</mi> <mtext>T</mtext></msup>
    <mi mathvariant="bold">X</mi><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msup><mi mathvariant="bold">X</mi> <mtext>T</mtext></msup> <mi mathvariant="bold">y</mi></mrow></mtd></mtr></mtable></math>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column 0 equals StartFraction d Over
    d beta EndFraction parallel-to bold upper X beta minus bold y parallel-to 2nd
    Column equals 2 bold upper X Superscript upper T Baseline left-parenthesis bold
    upper X beta minus bold y right-parenthesis 2nd Row 1st Column 0 2nd Column equals
    bold upper X Superscript upper T Baseline bold upper X beta minus bold upper X
    Superscript upper T Baseline bold y 3rd Row 1st Column bold upper X Superscript
    upper T Baseline bold upper X beta 2nd Column equals bold upper X Superscript
    upper T Baseline bold y 4th Row 1st Column beta 2nd Column equals left-parenthesis
    bold upper X Superscript upper T Baseline bold upper X right-parenthesis Superscript
    negative 1 Baseline bold upper X Superscript upper T Baseline bold y EndLayout"
    display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mn>0</mn>
    <mo>=</mo> <mfrac><mi>d</mi> <mrow><mi>d</mi><mi mathvariant="bold">Î²</mi></mrow></mfrac>
    <msup><mrow><mo>âˆ¥</mo><mi mathvariant="bold">X</mi><mi mathvariant="bold">Î²</mi><mo>-</mo><mi
    mathvariant="bold">y</mi><mo>âˆ¥</mo></mrow> <mn>2</mn></msup></mrow></mtd> <mtd
    columnalign="left"><mrow><mo>=</mo> <mn>2</mn> <msup><mi mathvariant="bold">X</mi>
    <mtext>T</mtext></msup> <mrow><mo>(</mo> <mi mathvariant="bold">X</mi> <mi mathvariant="bold">Î²</mi>
    <mo>-</mo> <mi mathvariant="bold">y</mi> <mo>)</mo></mrow></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mn>0</mn></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <msup><mi mathvariant="bold">X</mi> <mtext>T</mtext></msup> <mi mathvariant="bold">X</mi>
    <mi mathvariant="bold">Î²</mi> <mo>-</mo> <msup><mi mathvariant="bold">X</mi> <mtext>T</mtext></msup>
    <mi mathvariant="bold">y</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mrow><msup><mi
    mathvariant="bold">X</mi> <mtext>T</mtext></msup> <mi mathvariant="bold">X</mi>
    <mi mathvariant="bold">Î²</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <msup><mi mathvariant="bold">X</mi> <mtext>T</mtext></msup> <mi mathvariant="bold">y</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mi mathvariant="bold">Î²</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <msup><mrow><mo>(</mo><msup><mi mathvariant="bold">X</mi> <mtext>T</mtext></msup>
    <mi mathvariant="bold">X</mi><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msup><mi mathvariant="bold">X</mi> <mtext>T</mtext></msup> <mi mathvariant="bold">y</mi></mrow></mtd></mtr></mtable></math>
- en: Amazingly enough, we started from a different perspectiveâ€”minimize the squared
    distance between the model-predicted values and the observed valuesâ€”and again
    we rediscovered the same solution to least squares that we reached simply by using
    our linear algebra intuition.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ç¥å¥‡çš„æ˜¯ï¼Œæˆ‘ä»¬ä»ä¸åŒçš„è§’åº¦å‡ºå‘â€”â€”æœ€å°åŒ–æ¨¡å‹é¢„æµ‹å€¼ä¸è§‚æµ‹å€¼ä¹‹é—´çš„å¹³æ–¹è·ç¦»â€”â€”æˆ‘ä»¬å†æ¬¡é€šè¿‡çº¿æ€§ä»£æ•°çš„ç›´è§‰é‡æ–°å‘ç°äº†æœ€å°äºŒä¹˜æ³•çš„ç›¸åŒè§£å†³æ–¹æ¡ˆã€‚
- en: '[FigureÂ 11-2](#fig_11_2) shows some observed data (black squares), their model-predicted
    values (gray dots), and the distances between them (gray dashed lines). All model-predicted
    values lie on a line; the goal of least squares is to find the slope and intercept
    of that line that minimizes the distances from predicted to observed data.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[å›¾Â 11-2](#fig_11_2)å±•ç¤ºäº†ä¸€äº›è§‚å¯Ÿåˆ°çš„æ•°æ®ï¼ˆé»‘è‰²æ–¹å—ï¼‰ï¼Œå®ƒä»¬çš„æ¨¡å‹é¢„æµ‹å€¼ï¼ˆç°è‰²ç‚¹ï¼‰ä»¥åŠå®ƒä»¬ä¹‹é—´çš„è·ç¦»ï¼ˆç°è‰²è™šçº¿ï¼‰ã€‚æ‰€æœ‰æ¨¡å‹é¢„æµ‹å€¼å‡ä½äºä¸€æ¡ç›´çº¿ä¸Šï¼›æœ€å°äºŒä¹˜æ³•çš„ç›®æ ‡æ˜¯æ‰¾åˆ°è¯¥ç›´çº¿çš„æ–œç‡å’Œæˆªè·ï¼Œä½¿å¾—ä»é¢„æµ‹åˆ°è§‚æµ‹æ•°æ®çš„è·ç¦»æœ€å°åŒ–ã€‚'
- en: '![pic of glm](assets/plad_1102.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![glmå›¾ç‰‡](assets/plad_1102.png)'
- en: Figure 11-2\. Visual intuition for least squares
  id: totrans-80
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾Â 11-2\. æœ€å°äºŒä¹˜æ³•çš„ç›´è§‚ç†è§£
- en: GLM in a Simple Example
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç®€å•ç¤ºä¾‹ä¸­çš„å¹¿ä¹‰çº¿æ€§æ¨¡å‹ï¼ˆGLMï¼‰
- en: You will see several examples with real data in the next chapter; here I want
    to focus on a simple example with fake data. The fake data comes from a fake experiment
    in which I surveyed a random set of 20 of my fake students and asked them to report
    the number of my online courses they have taken and their general satisfaction
    with life.^([4](ch11.xhtml#idm45733295240096))
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸‹ä¸€ç« èŠ‚ä¸­ï¼Œä½ å°†çœ‹åˆ°å‡ ä¸ªå®é™…æ•°æ®çš„ç¤ºä¾‹ï¼›åœ¨è¿™é‡Œï¼Œæˆ‘æƒ³é›†ä¸­è®¨è®ºä¸€ä¸ªä½¿ç”¨è™šå‡æ•°æ®çš„ç®€å•ç¤ºä¾‹ã€‚è¿™äº›è™šå‡æ•°æ®æ¥è‡ªä¸€ä¸ªè™šæ„çš„å®éªŒï¼Œæˆ‘åœ¨å…¶ä¸­éšæœºè°ƒæŸ¥äº†20ä½è™šæ„çš„å­¦ç”Ÿï¼Œå¹¶è¯¢é—®äº†ä»–ä»¬å‚åŠ è¿‡çš„åœ¨çº¿è¯¾ç¨‹æ•°é‡ä»¥åŠä»–ä»¬å¯¹ç”Ÿæ´»çš„æ•´ä½“æ»¡æ„åº¦ã€‚^([4](ch11.xhtml#idm45733295240096))
- en: '[TableÂ 11-3](#table_11_3) shows the first 4 (out of 20) rows of the data matrix.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[è¡¨Â 11-3](#table_11_3)å±•ç¤ºäº†æ•°æ®çŸ©é˜µçš„å‰4è¡Œï¼ˆå…±20è¡Œï¼‰ã€‚'
- en: Table 11-3\. Data table
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: è¡¨Â 11-3\. æ•°æ®è¡¨
- en: '| Number of courses | Life happiness |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| Number of courses | Life happiness |'
- en: '| --- | --- |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 4 | 25 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 25 |'
- en: '| 12 | 54 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 54 |'
- en: '| 3 | 21 |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 21 |'
- en: '| 14 | 80 |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 14 | 80 |'
- en: The data is easier to visualize in a scatterplot, which you see in [FigureÂ 11-3](#fig_11_3).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡æ•£ç‚¹å›¾æ›´å®¹æ˜“å°†æ•°æ®å¯è§†åŒ–ï¼Œä½ å¯ä»¥åœ¨[å›¾Â 11-3](#fig_11_3)ä¸­çœ‹åˆ°å®ƒã€‚
- en: '![The data](assets/plad_1103.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![æ•°æ®](assets/plad_1103.png)'
- en: Figure 11-3\. Fake data from a fake survey
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾Â 11-3\. æ¥è‡ªè™šæ„è°ƒæŸ¥çš„è™šå‡æ•°æ®
- en: Notice that the independent variable is plotted on the *x*-axis while the dependent
    variable is plotted on the *y*-axis. That is common convention in statistics.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œç‹¬ç«‹å˜é‡åœ¨*x*è½´ä¸Šç»˜åˆ¶ï¼Œè€Œå› å˜é‡åœ¨*y*è½´ä¸Šç»˜åˆ¶ï¼Œè¿™æ˜¯ç»Ÿè®¡å­¦ä¸­çš„å¸¸è§æƒ¯ä¾‹ã€‚
- en: 'We need to create the design matrix. Because this is a simple model with only
    one predictor, our design matrix is actually only one column vector. Our matrix
    equation <math alttext="bold upper X beta equals bold y"><mrow><mi mathvariant="bold">X</mi><mi
    mathvariant="bold">Î²</mi><mo>=</mo><mi mathvariant="bold">y</mi></mrow></math>
    looks like this (again, only the first four data values):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬éœ€è¦åˆ›å»ºè®¾è®¡çŸ©é˜µã€‚å› ä¸ºè¿™æ˜¯ä¸€ä¸ªç®€å•çš„æ¨¡å‹ï¼Œåªæœ‰ä¸€ä¸ªé¢„æµ‹å˜é‡ï¼Œæ‰€ä»¥æˆ‘ä»¬çš„è®¾è®¡çŸ©é˜µå®é™…ä¸Šåªæ˜¯ä¸€ä¸ªåˆ—å‘é‡ã€‚æˆ‘ä»¬çš„çŸ©é˜µæ–¹ç¨‹<math alttext="bold
    upper X beta equals bold y"><mrow><mi mathvariant="bold">X</mi><mi mathvariant="bold">Î²</mi><mo>=</mo><mi
    mathvariant="bold">y</mi></mrow></math>çœ‹èµ·æ¥åƒè¿™æ ·ï¼ˆå†æ¬¡å¼ºè°ƒï¼Œä»…å±•ç¤ºå‰å››ä¸ªæ•°æ®å€¼ï¼‰ï¼š
- en: <math alttext="Start 4 By 1 Matrix 1st Row  25 2nd Row  54 3rd Row  21 4th Row  80
    EndMatrix Start 1 By 1 Matrix 1st Row  beta EndMatrix equals Start 4 By 1 Matrix
    1st Row  4 2nd Row  12 3rd Row  3 4th Row  14 EndMatrix" display="block"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>25</mn></mtd></mtr> <mtr><mtd><mn>54</mn></mtd></mtr>
    <mtr><mtd><mn>21</mn></mtd></mtr> <mtr><mtd><mn>80</mn></mtd></mtr></mtable></mfenced>
    <mfenced close="]" open="["><mtable><mtr><mtd><mi>Î²</mi></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>12</mn></mtd></mtr> <mtr><mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mn>14</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 4 By 1 Matrix 1st Row  25 2nd Row  54 3rd Row  21 4th Row  80
    EndMatrix Start 1 By 1 Matrix 1st Row  beta EndMatrix equals Start 4 By 1 Matrix
    1st Row  4 2nd Row  12 3rd Row  3 4th Row  14 EndMatrix" display="block"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>25</mn></mtd></mtr> <mtr><mtd><mn>54</mn></mtd></mtr>
    <mtr><mtd><mn>21</mn></mtd></mtr> <mtr><mtd><mn>80</mn></mtd></mtr></mtable></mfenced>
    <mfenced close="]" open="["><mtable><mtr><mtd><mi>Î²</mi></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>12</mn></mtd></mtr> <mtr><mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mn>14</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'The following Python code shows the solution. Variables `numcourses` and `happiness`
    contain the data; they are both lists and therefore must be converted into multidimensional
    NumPy arrays:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹Pythonä»£ç å±•ç¤ºäº†è§£å†³æ–¹æ¡ˆã€‚å˜é‡`numcourses`å’Œ`happiness`åŒ…å«æ•°æ®ï¼›å®ƒä»¬éƒ½æ˜¯åˆ—è¡¨ï¼Œå› æ­¤å¿…é¡»è½¬æ¢ä¸ºå¤šç»´NumPyæ•°ç»„ï¼š
- en: '[PRE1]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The least squares formula tells us that <math alttext="beta equals 5.95"><mrow><mi
    mathvariant="bold">Î²</mi><mo>=</mo><mn>5.95</mn></mrow></math>. What does this
    number mean? It is the slope in our formula. In other words, for each additional
    course that someone takes, their self-reported life happiness increases by 5.95
    points. Letâ€™s see how that result looks in a plot. [FigureÂ 11-4](#fig_11_4) shows
    the data (black squares), the predicted happiness values (gray dots connected
    by a line), and the residuals (dashed line connecting each observed value to the
    predicted value).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€å°äºŒä¹˜å…¬å¼å‘Šè¯‰æˆ‘ä»¬<math alttext="beta equals 5.95"><mrow><mi mathvariant="bold">Î²</mi><mo>=</mo><mn>5.95</mn></mrow></math>ã€‚è¿™ä¸ªæ•°å­—çš„å«ä¹‰æ˜¯ä»€ä¹ˆï¼Ÿå®ƒæ˜¯æˆ‘ä»¬å…¬å¼ä¸­çš„æ–œç‡ã€‚æ¢å¥è¯è¯´ï¼Œæ¯å¢åŠ ä¸€é—¨è¯¾ç¨‹ï¼Œä¸€ä¸ªäººçš„è‡ªæŠ¥ç”Ÿæ´»å¹¸ç¦æ„Ÿå°±å¢åŠ 5.95ä¸ªç‚¹ã€‚è®©æˆ‘ä»¬çœ‹çœ‹è¿™ä¸ªç»“æœåœ¨å›¾ä¸­çš„è¡¨ç°ã€‚[å›¾Â 11-4](#fig_11_4)å±•ç¤ºäº†æ•°æ®ï¼ˆé»‘è‰²æ–¹å—ï¼‰ã€é¢„æµ‹çš„å¹¸ç¦å€¼ï¼ˆç”±ç°è‰²ç‚¹è¿æ¥çš„çº¿ï¼‰ä»¥åŠæ®‹å·®ï¼ˆè¿æ¥æ¯ä¸ªè§‚æµ‹å€¼ä¸é¢„æµ‹å€¼çš„è™šçº¿ï¼‰ã€‚
- en: '![The data, part deux](assets/plad_1104.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![æ•°æ®ç»­é›†](assets/plad_1104.png)'
- en: Figure 11-4\. Observed and predicted data (SSE = sum of squared errors)
  id: totrans-101
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾Â 11-4\. è§‚å¯Ÿæ•°æ®å’Œé¢„æµ‹æ•°æ®ï¼ˆSSE = å¹³æ–¹è¯¯å·®å’Œï¼‰
- en: If you experience a feeling of unease while looking at [FigureÂ 11-4](#fig_11_4),
    then thatâ€™s goodâ€”it means you are thinking critically and noticed that the model
    doesnâ€™t do a great job at minimizing the errors. You can easily imagine pushing
    the left side of the best-fit line up to get a better fit. Whatâ€™s the problem
    here?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ åœ¨è§‚çœ‹[å›¾Â 11-4](#fig_11_4)æ—¶æ„Ÿåˆ°ä¸å®‰ï¼Œé‚£æ˜¯å¥½äº‹â€”â€”è¿™æ„å‘³ç€ä½ åœ¨è¿›è¡Œæ‰¹åˆ¤æ€§æ€è€ƒï¼Œå¹¶æ³¨æ„åˆ°æ¨¡å‹åœ¨æœ€å°åŒ–è¯¯å·®æ–¹é¢è¡¨ç°ä¸ä½³ã€‚ä½ å¯ä»¥è½»æ¾æƒ³è±¡å°†æœ€ä½³æ‹Ÿåˆçº¿çš„å·¦ä¾§å‘ä¸Šæ¨ä»¥è·å¾—æ›´å¥½çš„æ‹Ÿåˆã€‚è¿™é‡Œçš„é—®é¢˜æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿ
- en: The problem is that the design matrix contains no intercept. The equation of
    the best-fit line is *y* = *mx*, which means that when *x* = 0, *y* = 0\. That
    constraint doesnâ€™t make sense for this problemâ€”it would be a sad world if anyone
    who doesnâ€™t take my courses is completely devoid of life satisfaction. Instead,
    we want our line to have the form *y* = *mx* + *b*, where *b* is the intercept
    term that allows the best-fit line to cross the *y*-axis at any value. The statistical
    interpretation of the intercept is the expected numerical value of the observations
    when the predictors are set to zero.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: é—®é¢˜åœ¨äºè®¾è®¡çŸ©é˜µä¸åŒ…å«æˆªè·é¡¹ã€‚æœ€ä½³æ‹Ÿåˆçº¿çš„æ–¹ç¨‹æ˜¯*y* = *mx*ï¼Œè¿™æ„å‘³ç€å½“*x* = 0æ—¶ï¼Œ*y* = 0ã€‚è¿™ä¸ªçº¦æŸå¯¹è¿™ä¸ªé—®é¢˜æ¥è¯´æ˜¯æ²¡æœ‰æ„ä¹‰çš„â€”â€”å¦‚æœä»»ä½•æ²¡æœ‰å‚åŠ æˆ‘çš„è¯¾ç¨‹çš„äººå®Œå…¨ç¼ºä¹ç”Ÿæ´»æ»¡æ„åº¦ï¼Œé‚£å°†æ˜¯ä¸€ä¸ªæ‚²å“€çš„ä¸–ç•Œã€‚ç›¸åï¼Œæˆ‘ä»¬å¸Œæœ›æˆ‘ä»¬çš„çº¿æ¡å…·æœ‰*y*
    = *mx* + *b*çš„å½¢å¼ï¼Œå…¶ä¸­*b*æ˜¯æˆªè·é¡¹ï¼Œå…è®¸æœ€ä½³æ‹Ÿåˆçº¿åœ¨*y*è½´ä¸Šäº¤å‰ä»»æ„å€¼ã€‚æˆªè·çš„ç»Ÿè®¡è§£é‡Šæ˜¯è§‚å¯Ÿæ•°å€¼çš„æœŸæœ›å€¼ï¼Œå½“é¢„æµ‹å˜é‡è®¾ä¸ºé›¶æ—¶ã€‚
- en: 'Adding an intercept term to our design matrix gives the following modified
    equations (again only showing the first four rows):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: å‘æˆ‘ä»¬çš„è®¾è®¡çŸ©é˜µæ·»åŠ ä¸€ä¸ªæˆªè·é¡¹ä¼šå¾—åˆ°ä»¥ä¸‹ä¿®æ”¹çš„æ–¹ç¨‹ï¼ˆå†æ¬¡ä»…æ˜¾ç¤ºå‰å››è¡Œï¼‰ï¼š
- en: <math alttext="Start 4 By 2 Matrix 1st Row 1st Column 1 2nd Column 25 2nd Row
    1st Column 1 2nd Column 54 3rd Row 1st Column 1 2nd Column 21 4th Row 1st Column
    1 2nd Column 80 EndMatrix StartBinomialOrMatrix beta 1 Choose beta 2 EndBinomialOrMatrix
    equals Start 4 By 1 Matrix 1st Row  4 2nd Row  12 3rd Row  3 4th Row  14 EndMatrix"
    display="block"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>25</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>54</mn></mtd></mtr>
    <mtr><mtd><mn>1</mn></mtd> <mtd><mn>21</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>80</mn></mtd></mtr></mtable></mfenced> <mfenced close="]" open="["><mtable><mtr><mtd><msub><mi>Î²</mi>
    <mn>1</mn></msub></mtd></mtr> <mtr><mtd><msub><mi>Î²</mi> <mn>2</mn></msub></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>12</mn></mtd></mtr> <mtr><mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mn>14</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 4 By 2 Matrix 1st Row 1st Column 1 2nd Column 25 2nd Row
    1st Column 1 2nd Column 54 3rd Row 1st Column 1 2nd Column 21 4th Row 1st Column
    1 2nd Column 80 EndMatrix StartBinomialOrMatrix beta 1 Choose beta 2 EndBinomialOrMatrix
    equals Start 4 By 1 Matrix 1st Row  4 2nd Row  12 3rd Row  3 4th Row  14 EndMatrix"
    display="block"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>25</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>54</mn></mtd></mtr>
    <mtr><mtd><mn>1</mn></mtd> <mtd><mn>21</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>80</mn></mtd></mtr></mtable></mfenced> <mfenced close="]" open="["><mtable><mtr><mtd><msub><mi>Î²</mi>
    <mn>1</mn></msub></mtd></mtr> <mtr><mtd><msub><mi>Î²</mi> <mn>2</mn></msub></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>12</mn></mtd></mtr> <mtr><mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mn>14</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'The code doesnâ€™t change, with one exception of creating the design matrix:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ä»£ç ä¸å˜ï¼Œå”¯ä¸€çš„ä¾‹å¤–æ˜¯åˆ›å»ºè®¾è®¡çŸ©é˜µï¼š
- en: '[PRE2]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now we find that <math alttext="beta"><mi mathvariant="bold">Î²</mi></math> is
    the two-element vector [22.9,3.7]. The expected level of happiness for someone
    who has taken zero courses is 22.9, and for each additional course someone takes,
    their happiness increases by 3.7 points. Iâ€™m sure you will agree that [FigureÂ 11-5](#fig_11_5)
    looks much better. And the SSE is around half of what it was when we excluded
    the intercept.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å‘ç°**Î²**æ˜¯ä¸¤å…ƒå‘é‡[22.9, 3.7]ã€‚å¯¹äºä¸€ä¸ªé›¶è¯¾ç¨‹çš„äººæ¥è¯´ï¼Œå¹¸ç¦æ„Ÿçš„æœŸæœ›æ°´å¹³æ˜¯22.9ï¼Œè€Œæ¯å¢åŠ ä¸€é—¨è¯¾ç¨‹ï¼Œä»–ä»¬çš„å¹¸ç¦æ„Ÿå°†å¢åŠ 3.7ç‚¹ã€‚æˆ‘ç›¸ä¿¡ä½ ä¼šåŒæ„[å›¾11-5](#fig_11_5)çœ‹èµ·æ¥å¥½å¤šäº†ã€‚SSEå¤§çº¦æ˜¯æˆ‘ä»¬æ’é™¤æˆªè·æ—¶çš„ä¸€åŠã€‚
- en: '![The data, part troi](assets/plad_1105.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![æ•°æ®ï¼Œç¬¬ä¸‰éƒ¨åˆ†](assets/plad_1105.png)'
- en: Figure 11-5\. Observed and predicted data, now with an intercept term
  id: totrans-110
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾11-5ã€‚è§‚å¯Ÿå’Œé¢„æµ‹æ•°æ®ï¼Œç°åœ¨åŒ…å«æˆªè·é¡¹
- en: I will let you draw your own conclusions about the fake results from this fake
    study based on fake data; the point is to see a numerical example of how to solve
    a system of equations by building an appropriate design matrix and solving for
    the unknown regressors using the left-inverse.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä¼šè®©ä½ è‡ªå·±å¯¹è¿™ä¸ªåŸºäºè™šå‡æ•°æ®çš„è™šå‡ç ”ç©¶ç»“æœåšå‡ºç»“è®ºï¼›é‡ç‚¹æ˜¯çœ‹åˆ°å¦‚ä½•é€šè¿‡æ„å»ºé€‚å½“çš„è®¾è®¡çŸ©é˜µå¹¶è§£æœªçŸ¥å›å½’å™¨æ¥è§£å†³æ–¹ç¨‹ç»„çš„æ•°å€¼ç¤ºä¾‹ã€‚
- en: Least Squares via QR
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: é€šè¿‡QRè¿›è¡Œæœ€å°äºŒä¹˜æ³•
- en: The left-inverse method is theoretically sound, but risks numerical instability.
    This is partly because it requires computing the matrix inverse, which you already
    know can be numerically unstable. But it turns out that the matrix <math alttext="bold
    upper X Superscript upper T Baseline bold upper X"><mrow><msup><mi>ğ—</mi> <mtext>T</mtext></msup>
    <mi>ğ—</mi></mrow></math> itself can introduce difficulties. Multiplying a matrix
    by its transpose has implications for properties such as the norm and the condition
    number. You will learn more about the condition number in [ChapterÂ 14](ch14.xhtml#Chapter_14),
    but Iâ€™ve already mentioned that matrices with a high condition number can be numerically
    unstable, and thus a design matrix with a high condition number will become even
    less numerically stable when squared.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: å·¦é€†æ–¹æ³•åœ¨ç†è®ºä¸Šæ˜¯åˆç†çš„ï¼Œä½†å­˜åœ¨æ•°å€¼ä¸ç¨³å®šçš„é£é™©ã€‚éƒ¨åˆ†åŸå› æ˜¯å®ƒéœ€è¦è®¡ç®—çŸ©é˜µçš„é€†ï¼Œä½ å·²ç»çŸ¥é“è¿™å¯èƒ½å¯¼è‡´æ•°å€¼ä¸ç¨³å®šã€‚ä½†äº‹å®è¯æ˜ï¼ŒçŸ©é˜µ**ğ—<sup>T</sup>ğ—**æœ¬èº«å¯èƒ½ä¼šå¸¦æ¥å›°éš¾ã€‚å°†ä¸€ä¸ªçŸ©é˜µä¹˜ä»¥å®ƒçš„è½¬ç½®å¯¹è¯¸å¦‚èŒƒæ•°å’Œæ¡ä»¶æ•°ç­‰æ€§è´¨æœ‰å½±å“ã€‚ä½ å°†åœ¨[ç¬¬14ç« ](ch14.xhtml#Chapter_14)è¿›ä¸€æ­¥äº†è§£æ¡ä»¶æ•°ï¼Œä½†æˆ‘å·²ç»æåˆ°ï¼Œæ¡ä»¶æ•°é«˜çš„çŸ©é˜µå¯èƒ½æ•°å€¼ä¸ç¨³å®šï¼Œå› æ­¤æ¡ä»¶æ•°é«˜çš„è®¾è®¡çŸ©é˜µåœ¨å¹³æ–¹åä¼šå˜å¾—æ›´ä¸ç¨³å®šã€‚
- en: 'QR decomposition provides a more stable way to solve the least squares problem.
    Observe the following sequence of equations:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: QRåˆ†è§£æä¾›äº†è§£å†³æœ€å°äºŒä¹˜é—®é¢˜æ›´ç¨³å®šçš„æ–¹æ³•ã€‚è§‚å¯Ÿä»¥ä¸‹æ–¹ç¨‹çš„åºåˆ—ï¼š
- en: <math alttext="StartLayout 1st Row 1st Column bold upper X beta 2nd Column equals
    bold y 2nd Row 1st Column bold upper Q bold upper R beta 2nd Column equals bold
    y 3rd Row 1st Column bold upper R beta 2nd Column equals bold upper Q Superscript
    upper T Baseline bold y 4th Row 1st Column beta 2nd Column equals bold upper R
    Superscript negative 1 Baseline bold upper Q Superscript upper T Baseline bold
    y EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi
    mathvariant="bold">X</mi> <mi mathvariant="bold">Î²</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mi mathvariant="bold">y</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mrow><mi
    mathvariant="bold">Q</mi> <mi mathvariant="bold">R</mi> <mi mathvariant="bold">Î²</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi mathvariant="bold">y</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mrow><mi mathvariant="bold">R</mi> <mi mathvariant="bold">Î²</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <msup><mi mathvariant="bold">Q</mi> <mtext>T</mtext></msup>
    <mi mathvariant="bold">y</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi
    mathvariant="bold">Î²</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo> <msup><mi
    mathvariant="bold">R</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <msup><mi mathvariant="bold">Q</mi>
    <mtext>T</mtext></msup> <mi mathvariant="bold">y</mi></mrow></mtd></mtr></mtable></math>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column bold upper X beta 2nd Column equals
    bold y 2nd Row 1st Column bold upper Q bold upper R beta 2nd Column equals bold
    y 3rd Row 1st Column bold upper R beta 2nd Column equals bold upper Q Superscript
    upper T Baseline bold y 4th Row 1st Column beta 2nd Column equals bold upper R
    Superscript negative 1 Baseline bold upper Q Superscript upper T Baseline bold
    y EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi
    mathvariant="bold">X</mi> <mi mathvariant="bold">Î²</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mi mathvariant="bold">y</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mrow><mi
    mathvariant="bold">Q</mi> <mi mathvariant="bold">R</mi> <mi mathvariant="bold">Î²</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi mathvariant="bold">y</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mrow><mi mathvariant="bold">R</mi> <mi mathvariant="bold">Î²</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <msup><mi mathvariant="bold">Q</mi> <mtext>T</mtext></msup>
    <mi mathvariant="bold">y</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi
    mathvariant="bold">Î²</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo> <msup><mi
    mathvariant="bold">R</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <msup><mi mathvariant="bold">Q</mi>
    <mtext>T</mtext></msup> <mi mathvariant="bold">y</mi></mrow></mtd></mtr></mtable></math>
- en: These equations are slightly simplified from the actual low-level numerical
    implementations. For example, <math alttext="bold upper R"><mi>ğ‘</mi></math> is
    the same shape as <math alttext="bold upper X"><mi>ğ—</mi></math> , i.e., tall
    (and therefore noninvertible), although only the first *N* rows are nonzero (as
    you discovered in [Exercise 9-7](ch09.xhtml#exercise_9_7)), which means that rows
    *N* + 1 through *M* do not contribute to the solution (in matrix multiplication,
    rows of zeros produce results of zeros). Those rows can be removed from <math
    alttext="bold upper R"><mi>ğ‘</mi></math> and from <math alttext="bold upper Q
    Superscript upper T Baseline bold y"><mrow><msup><mi>ğ</mi> <mtext>T</mtext></msup>
    <mi>ğ²</mi></mrow></math> . Secondly, row swaps (implemented via permutation matrices)
    might be used to increase numerical stability.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›æ–¹ç¨‹ç•¥å¾®ç®€åŒ–äº†å®é™…ä½çº§æ•°å€¼å®ç°ã€‚ä¾‹å¦‚ï¼Œ<math alttext="bold upper R"><mi>ğ‘</mi></math>ä¸<math alttext="bold
    upper X"><mi>ğ—</mi></math>çš„å½¢çŠ¶ç›¸åŒï¼Œå³é«˜è€Œéå¯é€†ï¼Œå°½ç®¡ä»…å‰*N*è¡Œæ˜¯éé›¶çš„ï¼ˆå¦‚æ‚¨åœ¨[ä¹ é¢˜ 9-7](ch09.xhtml#exercise_9_7)ä¸­å‘ç°çš„ï¼‰ï¼Œè¿™æ„å‘³ç€ç¬¬*N*
    + 1åˆ°*M*è¡Œä¸ä¼šå¯¹è§£äº§ç”Ÿè´¡çŒ®ï¼ˆåœ¨çŸ©é˜µä¹˜æ³•ä¸­ï¼Œé›¶è¡Œäº§ç”Ÿé›¶ç»“æœï¼‰ã€‚è¿™äº›è¡Œå¯ä»¥ä»<math alttext="bold upper R"><mi>ğ‘</mi></math>å’Œ<math
    alttext="bold upper Q Superscript upper T Baseline bold y"><mrow><msup><mi>ğ</mi>
    <mtext>T</mtext></msup> <mi>ğ²</mi></mrow></math>ä¸­ç§»é™¤ã€‚å…¶æ¬¡ï¼Œè¡Œäº¤æ¢ï¼ˆé€šè¿‡ç½®æ¢çŸ©é˜µå®ç°ï¼‰å¯èƒ½ç”¨äºå¢åŠ æ•°å€¼ç¨³å®šæ€§ã€‚
- en: 'But hereâ€™s the best part: itâ€™s not even necessary to invert <math alttext="bold
    upper R"><mi>ğ‘</mi></math> â€”that matrix is upper-triangular and therefore the
    solution can be obtained via back substitution. Itâ€™s the same as solving a system
    of equations via the Gauss-Jordan method: augment the coefficients matrix by the
    constants, row reduce to obtain the RREF, and extract the solution from the final
    column of the augmented matrix.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†è¿™é‡Œæœ€é‡è¦çš„éƒ¨åˆ†æ˜¯ï¼šä¸éœ€è¦è½¬ç½®çŸ©é˜µ<math alttext="bold upper R"><mi>ğ‘</mi></math> â€”â€”è¯¥çŸ©é˜µæ˜¯ä¸Šä¸‰è§’çš„ï¼Œå› æ­¤å¯ä»¥é€šè¿‡å›ä»£æ³•è·å¾—è§£ã€‚è¿™ä¸é€šè¿‡é«˜æ–¯-çº¦å½“æ–¹æ³•è§£æ–¹ç¨‹ç»„æ˜¯ç›¸åŒçš„ï¼šå°†ç³»æ•°çŸ©é˜µä¸å¸¸æ•°å¢å¹¿ï¼Œè¡Œçº¦ç®€ä»¥è·å¾—æœ€ç®€è¡Œé˜¶æ¢¯å½¢å¼çŸ©é˜µï¼Œå¹¶ä»å¢å¹¿çŸ©é˜µçš„æœ€åä¸€åˆ—æå–è§£ã€‚
- en: The conclusion here is that QR decomposition solves the least squares problem
    without squaring <math alttext="bold upper X Superscript upper T Baseline bold
    upper X"><mrow><msup><mi>ğ—</mi> <mtext>T</mtext></msup> <mi>ğ—</mi></mrow></math>
    and without explicitly inverting a matrix. The main risk of numerical instability
    comes from computing <math alttext="bold upper Q"><mi>ğ</mi></math> , although
    this is fairly numerically stable when implemented via Householder reflections.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ç»“è®ºæ˜¯QRåˆ†è§£è§£å†³äº†æœ€å°äºŒä¹˜é—®é¢˜ï¼Œæ— éœ€å¯¹<math alttext="bold upper X Superscript upper T Baseline
    bold upper X"><mrow><msup><mi>ğ—</mi> <mtext>T</mtext></msup> <mi>ğ—</mi></mrow></math>è¿›è¡Œå¹³æ–¹ï¼Œä¹Ÿæ— éœ€æ˜¾å¼æ±‚é€†çŸ©é˜µã€‚æ•°å€¼ä¸ç¨³å®šçš„ä¸»è¦é£é™©æ¥è‡ªè®¡ç®—<math
    alttext="bold upper Q"><mi>ğ</mi></math>ï¼Œå°½ç®¡é€šè¿‡Householderåå°„å®ç°æ—¶ï¼Œè¿™æ˜¯ç›¸å½“ç¨³å®šçš„ã€‚
- en: '[Exercise 11-3](#exercise_11_3) will walk you through this implementation.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[ä¹ é¢˜ 11-3](#exercise_11_3) å°†å¼•å¯¼æ‚¨å®Œæˆè¿™ä¸ªå®ç°ã€‚'
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ€»ç»“
- en: Many people think that statistics is hard because the underlying mathematics
    is hard. To be sure, there are advanced statistical methods involving advanced
    mathematics. But many of the commonly used statistical methods are built on linear
    algebra principles that you now understand. That means you no longer have any
    excuses not to master the statistical analyses used in data science!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: è®¸å¤šäººè®¤ä¸ºç»Ÿè®¡å­¦å¾ˆéš¾æ˜¯å› ä¸ºå…¶åŸºç¡€æ•°å­¦éš¾åº¦å¾ˆå¤§ã€‚ç¡®å®ï¼Œæ¶‰åŠé«˜çº§æ•°å­¦çš„é«˜çº§ç»Ÿè®¡æ–¹æ³•å­˜åœ¨ã€‚ä½†è®¸å¤šå¸¸ç”¨çš„ç»Ÿè®¡æ–¹æ³•æ˜¯å»ºç«‹åœ¨æ‚¨ç°åœ¨ç†è§£çš„çº¿æ€§ä»£æ•°åŸç†ä¸Šçš„ã€‚è¿™æ„å‘³ç€æ‚¨ä¸å†æœ‰ä»»ä½•ç†ç”±ä¸ç²¾é€šæ•°æ®ç§‘å­¦ä¸­ä½¿ç”¨çš„ç»Ÿè®¡åˆ†ææ–¹æ³•äº†ï¼
- en: The goal of this chapter was to introduce you to the terminology and math underlying
    the general linear model, the geometric interpretation, and the implications of
    the math for minimizing the difference between model-predicated data and observed
    data. I also showed an application of a regression in a simple toy example. In
    the next chapter, youâ€™ll see least squares implemented with real data, and youâ€™ll
    see extensions of least squares in regression, such as polynomial regression and
    regularization.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬ç« çš„ç›®æ ‡æ˜¯ä»‹ç»é€šç”¨çº¿æ€§æ¨¡å‹çš„æœ¯è¯­å’Œæ•°å­¦åŸºç¡€ï¼Œå‡ ä½•è§£é‡Šï¼Œä»¥åŠæ•°å­¦å¯¹æ¨¡å‹é¢„æµ‹æ•°æ®ä¸è§‚å¯Ÿæ•°æ®å·®å¼‚æœ€å°åŒ–çš„å½±å“ã€‚æˆ‘è¿˜å±•ç¤ºäº†ä¸€ä¸ªç®€å•ç©å…·ç¤ºä¾‹ä¸­å›å½’çš„åº”ç”¨ã€‚åœ¨ä¸‹ä¸€ç« ä¸­ï¼Œæ‚¨å°†çœ‹åˆ°åœ¨çœŸå®æ•°æ®ä¸­å®ç°æœ€å°äºŒä¹˜æ³•ï¼Œå¹¶çœ‹åˆ°æœ€å°äºŒä¹˜æ³•åœ¨å›å½’ä¸­çš„æ‰©å±•ï¼Œå¦‚å¤šé¡¹å¼å›å½’å’Œæ­£åˆ™åŒ–ã€‚
- en: 'Here are the key take-home messages from this chapter:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹æ˜¯æœ¬ç« çš„ä¸»è¦è¦ç‚¹ï¼š
- en: The GLM is a statistical framework for understanding our rich and beautiful
    universe. It works by setting up a system of equations, just like the systems
    of equations you learned about in the previous chapter.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¹¿ä¹‰çº¿æ€§æ¨¡å‹ï¼ˆGLMï¼‰æ˜¯ç†è§£æˆ‘ä»¬ä¸°å¯Œå’Œç¾ä¸½å®‡å®™çš„ç»Ÿè®¡æ¡†æ¶ã€‚å®ƒé€šè¿‡å»ºç«‹ä¸€ç»„æ–¹ç¨‹æ¥å·¥ä½œï¼Œå°±åƒä½ åœ¨ä¸Šä¸€ç« ä¸­å­¦åˆ°çš„æ–¹ç¨‹ç»„ä¸€æ ·ã€‚
- en: The terms are somewhat different between linear algebra and statistics; once
    you learn the terminological mappings, statistics becomes easier because you already
    know the math.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: çº¿æ€§ä»£æ•°å’Œç»Ÿè®¡å­¦æœ¯è¯­æœ‰æ‰€ä¸åŒï¼›ä¸€æ—¦ä½ äº†è§£äº†æœ¯è¯­æ˜ å°„ï¼Œç»Ÿè®¡å­¦ä¼šå˜å¾—æ›´å®¹æ˜“ï¼Œå› ä¸ºä½ å·²ç»äº†è§£äº†æ•°å­¦ã€‚
- en: The least squares method of solving equations via the left-inverse is the foundation
    of many statistical analyses, and you will often see the least squares solution
    â€œhiddenâ€ inside seemingly complicated formulas.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æœ€å°äºŒä¹˜æ–¹æ³•é€šè¿‡å·¦é€†æ¥è§£æ–¹ç¨‹ï¼Œæ˜¯è®¸å¤šç»Ÿè®¡åˆ†æçš„åŸºç¡€ï¼Œä½ ç»å¸¸ä¼šåœ¨çœ‹ä¼¼å¤æ‚çš„å…¬å¼ä¸­â€œéšè—â€æœ€å°äºŒä¹˜è§£æ³•ã€‚
- en: The least squares formula can be derived via algebra, geometry, or calculus.
    This provides multiple ways of understanding and interpreting least squares.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æœ€å°äºŒä¹˜å…¬å¼å¯ä»¥é€šè¿‡ä»£æ•°ã€å‡ ä½•æˆ–å¾®ç§¯åˆ†æ¨å¯¼å‡ºæ¥ã€‚è¿™æä¾›äº†ç†è§£å’Œè§£é‡Šæœ€å°äºŒä¹˜çš„å¤šç§æ–¹å¼ã€‚
- en: Multiplying the observed data vector by the left-inverse is conceptually the
    right way to think about least squares. In practice, other methods such as LU
    and QR decomposition are more numerically stable. Fortunately, you donâ€™t need
    to worry about this because Python calls low-level libraries (mostly LAPACK) that
    implement the most numerically stable algorithms.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å°†è§‚æµ‹æ•°æ®å‘é‡ä¹˜ä»¥å·¦é€†çš„æ¦‚å¿µä¸Šæ˜¯è€ƒè™‘æœ€å°äºŒä¹˜çš„æ­£ç¡®æ–¹æ³•ã€‚åœ¨å®è·µä¸­ï¼Œå…¶ä»–æ–¹æ³•å¦‚LUå’ŒQRåˆ†è§£æ›´åŠ æ•°å€¼ç¨³å®šã€‚å¹¸è¿çš„æ˜¯ï¼Œä½ ä¸éœ€è¦æ‹…å¿ƒè¿™ä¸ªï¼Œå› ä¸ºPythonè°ƒç”¨ä½çº§åˆ«åº“ï¼ˆä¸»è¦æ˜¯LAPACKï¼‰ï¼Œè¿™äº›åº“å®ç°äº†æœ€æ•°å€¼ç¨³å®šçš„ç®—æ³•ã€‚
- en: Code Exercises
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ä»£ç ç»ƒä¹ 
- en: Exercise 11-1\.
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '-   ç»ƒä¹  11-1ã€‚'
- en: I explained that the residuals are orthogonal to the predicted data (in other
    words, <math alttext="epsilon Superscript upper T Baseline ModifyingAbove bold
    y With bold caret equals 0"><mrow><msup><mi>Ïµ</mi> <mtext>T</mtext></msup> <mover
    accent="true"><mi>ğ²</mi> <mo>^</mo></mover> <mo>=</mo> <mn>0</mn></mrow></math>
    ). Illustrate this in the toy dataset from this chapter. In particular, make a
    scatterplot of the predicted data by the errors (as in [FigureÂ 11-6](#fig_11_6)).
    Then compute the dot product and the correlation coefficient between the residuals
    and the model-predicted data. In theory, both should be exactly zero, although
    there are some rounding errors. Which of those two analyses (dot product or correlation)
    is smaller, and why is that?
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘è§£é‡Šäº†æ®‹å·®ä¸é¢„æµ‹æ•°æ®æ­£äº¤ï¼ˆæ¢å¥è¯è¯´ï¼Œ<math alttext="epsilon Superscript upper T Baseline ModifyingAbove
    bold y With bold caret equals 0"><mrow><msup><mi>Ïµ</mi> <mtext>T</mtext></msup>
    <mover accent="true"><mi>ğ²</mi> <mo>^</mo></mover> <mo>=</mo> <mn>0</mn></mrow></math>
    ï¼‰ã€‚åœ¨æœ¬ç« ä¸­çš„ç©å…·æ•°æ®é›†ä¸­è¯´æ˜è¿™ä¸€ç‚¹ã€‚ç‰¹åˆ«æ˜¯ï¼Œç”¨é¢„æµ‹æ•°æ®å’Œè¯¯å·®åˆ¶ä½œæ•£ç‚¹å›¾ï¼ˆå¦‚[å›¾Â 11-6](#fig_11_6)ï¼‰ã€‚ç„¶åè®¡ç®—æ®‹å·®ä¸æ¨¡å‹é¢„æµ‹æ•°æ®ä¹‹é—´çš„ç‚¹ç§¯å’Œç›¸å…³ç³»æ•°ã€‚ç†è®ºä¸Šï¼Œä¸¤è€…åº”å®Œå…¨ä¸ºé›¶ï¼Œå°½ç®¡å­˜åœ¨ä¸€äº›èˆå…¥è¯¯å·®ã€‚è¿™ä¸¤ç§åˆ†æï¼ˆç‚¹ç§¯æˆ–ç›¸å…³æ€§ï¼‰ä¸­å“ªä¸€ç§æ›´å°ï¼Œä¸ºä»€ä¹ˆï¼Ÿ
- en: '![Ex0](assets/plad_1106.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![Ex0](assets/plad_1106.png)'
- en: Figure 11-6\. Solution to Exercise 11-1
  id: totrans-133
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾ 11-6\. ç»ƒä¹  11-1 çš„è§£ç­”
- en: Exercise 11-2\.
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '-   ç»ƒä¹  11-2ã€‚'
- en: 'The model-predicted happiness is merely one way of linearly combining the columns
    of the design matrix. But the residuals vector isnâ€™t only orthogonal to that one
    linear weighted combination; instead, the residuals vector is orthogonal to the
    *entire subspace* spanned by the design matrix. Demonstrate this in Python (hint:
    think of the left-null space and rank).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: æ¨¡å‹é¢„æµ‹çš„å¹¸ç¦æ„Ÿä»…ä»…æ˜¯çº¿æ€§ç»„åˆè®¾è®¡çŸ©é˜µåˆ—çš„ä¸€ç§æ–¹å¼ã€‚ä½†æ˜¯æ®‹å·®å‘é‡ä¸ä»…ä»…æ˜¯ä¸è¯¥çº¿æ€§åŠ æƒç»„åˆæ­£äº¤ï¼›ç›¸åï¼Œæ®‹å·®å‘é‡æ­£äº¤äºè®¾è®¡çŸ©é˜µå¼ æˆçš„*æ•´ä¸ªå­ç©ºé—´*ã€‚åœ¨Pythonä¸­æ¼”ç¤ºè¿™ä¸€ç‚¹ï¼ˆæç¤ºï¼šè€ƒè™‘å·¦é›¶ç©ºé—´å’Œç§©ï¼‰ã€‚
- en: Exercise 11-3\.
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '-   ç»ƒä¹  11-3ã€‚'
- en: 'You are now going to compute least squares via QR decomposition, as I explained
    in [â€œLeast Squares via QRâ€](#least_squares_via_qr). In particular, compute and
    compare the following solution methods: (1) the left-inverse <math alttext="left-parenthesis
    bold upper X Superscript upper T Baseline bold upper X right-parenthesis Superscript
    negative 1 Baseline bold upper X Superscript upper T Baseline bold y"><mrow><msup><mrow><mo>(</mo><msup><mi>ğ—</mi>
    <mtext>T</mtext></msup> <mi>ğ—</mi><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msup><mi>ğ—</mi> <mtext>T</mtext></msup> <mi>ğ²</mi></mrow></math> , (2) QR with
    the inverse as <math alttext="bold upper R Superscript negative 1 Baseline bold
    upper Q Superscript upper T Baseline bold y"><mrow><msup><mi>ğ‘</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msup><mi>ğ</mi> <mtext>T</mtext></msup> <mi>ğ²</mi></mrow></math> , and (3) Gauss-Jordan
    elimination on the matrix <math alttext="bold upper R"><mi>ğ‘</mi></math> augmented
    with <math alttext="bold upper Q Superscript upper T Baseline bold y"><mrow><msup><mi>ğ</mi>
    <mtext>T</mtext></msup> <mi>ğ²</mi></mrow></math> .'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œä½ å°†é€šè¿‡ QR åˆ†è§£è®¡ç®—æœ€å°äºŒä¹˜æ³•ï¼Œæ­£å¦‚æˆ‘åœ¨ [â€œæœ€å°äºŒä¹˜æ³• via QRâ€](#least_squares_via_qr) ä¸­æ‰€è§£é‡Šçš„é‚£æ ·ã€‚ç‰¹åˆ«æ˜¯ï¼Œè®¡ç®—å¹¶æ¯”è¾ƒä»¥ä¸‹è§£æ³•ï¼š(1)
    å·¦é€† <math alttext="left-parenthesis bold upper X Superscript upper T Baseline bold
    upper X right-parenthesis Superscript negative 1 Baseline bold upper X Superscript
    upper T Baseline bold y"><mrow><msup><mrow><mo>(</mo><msup><mi>ğ—</mi> <mtext>T</mtext></msup>
    <mi>ğ—</mi><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <msup><mi>ğ—</mi>
    <mtext>T</mtext></msup> <mi>ğ²</mi></mrow></math> ï¼Œ(2) QR åˆ†è§£çš„é€†ä½œä¸º <math alttext="bold
    upper R Superscript negative 1 Baseline bold upper Q Superscript upper T Baseline
    bold y"><mrow><msup><mi>ğ‘</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <msup><mi>ğ</mi>
    <mtext>T</mtext></msup> <mi>ğ²</mi></mrow></math> ï¼Œä»¥åŠ (3) å¯¹çŸ©é˜µ <math alttext="bold
    upper R"><mi>ğ‘</mi></math> å’Œå¢å¹¿çŸ©é˜µ <math alttext="bold upper Q Superscript upper
    T Baseline bold y"><mrow><msup><mi>ğ</mi> <mtext>T</mtext></msup> <mi>ğ²</mi></mrow></math>
    è¿›è¡Œçš„é«˜æ–¯-çº¦å½“æ¶ˆå…ƒæ³•ã€‚
- en: Print out the beta parameters from the three methods as follows. (Rounding to
    three digits after the decimal point is an optional extra coding challenge.)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: æŒ‰ä»¥ä¸‹æ–¹å¼æ‰“å°å‡ºä¸‰ç§æ–¹æ³•çš„ beta å‚æ•°ã€‚ ï¼ˆå°†å°æ•°ç‚¹åçš„ç»“æœå››èˆäº”å…¥åˆ°ä¸‰ä½æ•°æ˜¯ä¸€ä¸ªé¢å¤–çš„ç¼–ç æŒ‘æˆ˜ã€‚ï¼‰
- en: '[PRE3]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, print out the resulting matrices from the QR method as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼ŒæŒ‰ä»¥ä¸‹æ–¹å¼æ‰“å° QR æ–¹æ³•ç”Ÿæˆçš„ç»“æœçŸ©é˜µï¼š
- en: '[PRE4]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Exercise 11-4\.
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ç»ƒä¹  11-4\.
- en: '*Outliers* are data values that are unusual or nonrepresentative. Outliers
    can cause significant problems in statistical models, and therefore can cause
    significant headaches for data scientists. In this exercise, we will create outliers
    in the happiness data to observe the effects on the resulting least squares solution.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*å¼‚å¸¸å€¼* æ˜¯ä¸å¯»å¸¸æˆ–ä¸å…¸å‹çš„æ•°æ®å€¼ã€‚å¼‚å¸¸å€¼å¯èƒ½ä¼šå¯¼è‡´ç»Ÿè®¡æ¨¡å‹ä¸­çš„æ˜¾è‘—é—®é¢˜ï¼Œå› æ­¤å®ƒä»¬å¯èƒ½ä¼šç»™æ•°æ®ç§‘å­¦å®¶å¸¦æ¥å¤´ç—›ã€‚åœ¨è¿™ä¸ªç»ƒä¹ ä¸­ï¼Œæˆ‘ä»¬å°†åœ¨å¹¸ç¦æ•°æ®ä¸­åˆ›å»ºå¼‚å¸¸å€¼ï¼Œä»¥è§‚å¯Ÿå¯¹æœ€å°äºŒä¹˜è§£çš„å½±å“ã€‚'
- en: In the data vector, change the first observed data point from `70` to `170`
    (simulating a data-entry typo). Then recompute the least squares fit and plot
    the data. Repeat this outlier simulation but change the final data point from
    `70` to `170` (and set the first data point back to its original `70`). Compare
    with the original data by creating a visualization like [FigureÂ 11-7](#fig_11_7).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ•°æ®å‘é‡ä¸­ï¼Œå°†ç¬¬ä¸€ä¸ªè§‚å¯Ÿæ•°æ®ç‚¹ä» `70` æ”¹ä¸º `170` ï¼ˆæ¨¡æ‹Ÿæ•°æ®è¾“å…¥é”™è¯¯ï¼‰ã€‚ç„¶åé‡æ–°è®¡ç®—æœ€å°äºŒä¹˜æ‹Ÿåˆå¹¶ç»˜åˆ¶æ•°æ®ã€‚é‡å¤è¿™ç§å¼‚å¸¸å€¼æ¨¡æ‹Ÿï¼Œä½†å°†æœ€åä¸€ä¸ªæ•°æ®ç‚¹ä»
    `70` æ”¹ä¸º `170` ï¼ˆå¹¶å°†ç¬¬ä¸€ä¸ªæ•°æ®ç‚¹æ¢å¤ä¸ºå…¶åŸå§‹å€¼ `70`ï¼‰ã€‚é€šè¿‡åˆ›å»ºç±»ä¼¼äº [å›¾ 11-7](#fig_11_7) çš„å¯è§†åŒ–æ¥ä¸åŸå§‹æ•°æ®è¿›è¡Œæ¯”è¾ƒã€‚
- en: '![Ex3](assets/plad_1107.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![Ex3](assets/plad_1107.png)'
- en: Figure 11-7\. Solution to Exercise 11-4
  id: totrans-146
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾ 11-7\. ç»ƒä¹  11-4 çš„è§£ç­”
- en: Interestingly, the outlier was identical in the outcome variable (in both cases,
    the `70` turned into `170`), but the effect on the fit of the model to the data
    was quite different because of the corresponding *x*-axis value. This differential
    impact of outliers is called *leverage* and is something you would learn about
    in a deeper discussion of statistics and model fitting.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰è¶£çš„æ˜¯ï¼Œå¼‚å¸¸å€¼åœ¨ç»“æœå˜é‡ä¸­æ˜¯ç›¸åŒçš„ï¼ˆåœ¨ä¸¤ç§æƒ…å†µä¸‹ï¼Œ`70` å˜æˆäº† `170`ï¼‰ï¼Œä½†ç”±äºç›¸åº”çš„ *x* è½´æ•°å€¼ï¼Œå®ƒä»¬å¯¹æ¨¡å‹æ‹Ÿåˆæ•°æ®çš„å½±å“å´æœ‰å¾ˆå¤§å·®å¼‚ã€‚è¿™ç§å¼‚å¸¸å€¼å¯¹æ¨¡å‹æ‹Ÿåˆçš„ä¸åŒå½±å“è¢«ç§°ä¸º
    *æ æ†æ•ˆåº”*ï¼Œéœ€è¦åœ¨æ›´æ·±å…¥è®¨è®ºç»Ÿè®¡å­¦å’Œæ¨¡å‹æ‹Ÿåˆæ—¶å­¦ä¹ ã€‚
- en: Exercise 11-5\.
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ç»ƒä¹  11-5\.
- en: In this exercise, you will compute the matrix inverse using least squares, following
    the interpetation I introduced in the previous chapter. We will consider the equation
    <math alttext="bold upper X bold upper B equals bold upper Y"><mrow><mi>ğ—</mi>
    <mi>ğ</mi> <mo>=</mo> <mi>ğ˜</mi></mrow></math> , where <math alttext="bold upper
    X"><mi>ğ—</mi></math> is the square full-rank matrix to invert, <math alttext="bold
    upper B"><mi>ğ</mi></math> is the matrix of unknown coefficients (which will be
    the matrix inverse), and <math alttext="bold upper Y"><mi>ğ˜</mi></math> is the
    â€œobserved dataâ€ (the identity matrix).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªç»ƒä¹ ä¸­ï¼Œæ‚¨å°†ä½¿ç”¨æœ€å°äºŒä¹˜æ³•è®¡ç®—çŸ©é˜µçš„é€†ï¼ŒæŒ‰ç…§æˆ‘åœ¨å‰ä¸€ç« èŠ‚ä¸­ä»‹ç»çš„è§£é‡Šè¿›è¡Œã€‚æˆ‘ä»¬å°†è€ƒè™‘æ–¹ç¨‹å¼<math alttext="bold upper X
    bold upper B equals bold upper Y"><mrow><mi>ğ—</mi> <mi>ğ</mi> <mo>=</mo> <mi>ğ˜</mi></mrow></math>ï¼Œå…¶ä¸­<math
    alttext="bold upper X"><mi>ğ—</mi></math>æ˜¯è¦æ±‚é€†çš„æ–¹é˜µæ»¡ç§©çŸ©é˜µï¼Œ<math alttext="bold upper
    B"><mi>ğ</mi></math>æ˜¯æœªçŸ¥ç³»æ•°çš„çŸ©é˜µï¼ˆå°†æ˜¯çŸ©é˜µé€†ï¼‰ï¼Œè€Œ<math alttext="bold upper Y"><mi>ğ˜</mi></math>æ˜¯â€œè§‚å¯Ÿåˆ°çš„æ•°æ®â€ï¼ˆå•ä½çŸ©é˜µï¼‰ã€‚
- en: You will compute <math alttext="bold upper B"><mi>ğ</mi></math> in three ways.
    First, use the left-inverse least squares method to compute the matrix one column
    at a time. This is done by computing the least squares fit between the matrix
    <math alttext="bold upper X"><mi>ğ—</mi></math> and each column of <math alttext="bold
    upper Y"><mi>ğ˜</mi></math> in a `for` loop. Second, use the left-inverse method
    to compute the entire <math alttext="bold upper B"><mi>ğ</mi></math> matrix in
    one line of code. Finally, compute <math alttext="bold upper X Superscript negative
    1"><msup><mi>ğ—</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math> using the
    function `np.linalg.inv()`. Mutliply each of those <math alttext="bold upper B"><mi>ğ</mi></math>
    matrices by <math alttext="bold upper X"><mi>ğ—</mi></math> and show in a figure
    like [FigureÂ 11-8](#fig_11_8). Finally, test whether these three â€œdifferentâ€ ways
    of computing the inverse are equivalent (they should be, because the matrix inverse
    is unique).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: æ‚¨å°†é€šè¿‡ä¸‰ç§æ–¹å¼è®¡ç®—<math alttext="bold upper B"><mi>ğ</mi></math>ã€‚é¦–å…ˆï¼Œä½¿ç”¨å·¦é€†æœ€å°äºŒä¹˜æ³•é€åˆ—è®¡ç®—çŸ©é˜µ<math
    alttext="bold upper X"><mi>ğ—</mi></math>å’Œ<math alttext="bold upper Y"><mi>ğ˜</mi></math>çš„æœ€å°äºŒä¹˜æ‹Ÿåˆï¼Œåœ¨`for`å¾ªç¯ä¸­æ‰§è¡Œã€‚å…¶æ¬¡ï¼Œä½¿ç”¨å·¦é€†æ–¹æ³•åœ¨ä¸€è¡Œä»£ç ä¸­è®¡ç®—æ•´ä¸ª<math
    alttext="bold upper B"><mi>ğ</mi></math>çŸ©é˜µã€‚æœ€åï¼Œä½¿ç”¨å‡½æ•°`np.linalg.inv()`è®¡ç®—<math alttext="bold
    upper X Superscript negative 1"><msup><mi>ğ—</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>ã€‚å°†æ¯ä¸ª<math
    alttext="bold upper B"><mi>ğ</mi></math>çŸ©é˜µä¹˜ä»¥<math alttext="bold upper X"><mi>ğ—</mi></math>ï¼Œå¹¶å±•ç¤ºç±»ä¼¼äº[FigureÂ 11-8](#fig_11_8)çš„å›¾è¡¨ã€‚æœ€åï¼Œæµ‹è¯•è¿™ä¸‰ç§â€œä¸åŒâ€çš„é€†è®¡ç®—æ–¹æ³•æ˜¯å¦ç­‰æ•ˆï¼ˆå®ƒä»¬åº”è¯¥æ˜¯çš„ï¼Œå› ä¸ºçŸ©é˜µé€†æ˜¯å”¯ä¸€çš„ï¼‰ã€‚
- en: 'Observation: it is rather strange (not to mention circular) to use the inverse
    of <math alttext="bold upper X Superscript upper T Baseline bold upper X"><mrow><msup><mi>ğ—</mi>
    <mtext>T</mtext></msup> <mi>ğ—</mi></mrow></math> to compute the inverse of <math
    alttext="bold upper X"><mi>ğ—</mi></math> . (Indeed, you should confirm with paper
    and pencil that the left-inverse reduces to the full inverse for square full-rank
    <math alttext="bold upper X"><mi>ğ—</mi></math> !) Needless to say, this is not
    a computational method that would be implemented in practice. However, this exercise
    reinforces the interpretation of the matrix inverse as the transformation that
    projects a matrix onto the identity matrix, and that that projection matrix can
    be obtained via least squares. Comparing the least squares solution to `np.linalg.inv`
    also illustrates the numerical inaccuracies that can arise when computing the
    left-inverse.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: è§‚å¯Ÿï¼šä½¿ç”¨<math alttext="bold upper X Superscript upper T Baseline bold upper X"><mrow><msup><mi>ğ—</mi>
    <mtext>T</mtext></msup> <mi>ğ—</mi></mrow></math>çš„é€†æ¥è®¡ç®—<math alttext="bold upper
    X"><mi>ğ—</mi></math>çš„é€†æ˜¾å¾—éå¸¸å¥‡æ€ªï¼ˆæ›´ä¸ç”¨è¯´æ˜¯å¾ªç¯çš„äº†ï¼‰ã€‚ï¼ˆç¡®å®ï¼Œæ‚¨åº”è¯¥é€šè¿‡çº¸å’Œç¬”æ¥ç¡®è®¤ï¼Œå·¦é€†å¯¹äºæ–¹é˜µæ»¡ç§©<math alttext="bold
    upper X"><mi>ğ—</mi></math>ä¼šç®€åŒ–ä¸ºå®Œå…¨é€†ï¼ï¼‰ä¸ç”¨è¯´ï¼Œè¿™ä¸æ˜¯ä¸€ä¸ªå®é™…å®æ–½çš„è®¡ç®—æ–¹æ³•ã€‚ç„¶è€Œï¼Œè¿™ä¸ªç»ƒä¹ åŠ å¼ºäº†çŸ©é˜µé€†çš„è§£é‡Šï¼Œå³å°†çŸ©é˜µæŠ•å½±åˆ°å•ä½çŸ©é˜µçš„å˜æ¢ï¼Œå¹¶ä¸”è¯¥æŠ•å½±çŸ©é˜µå¯ä»¥é€šè¿‡æœ€å°äºŒä¹˜æ³•å¾—åˆ°ã€‚å°†æœ€å°äºŒä¹˜è§£ä¸`np.linalg.inv`è¿›è¡Œæ¯”è¾ƒï¼Œè¿˜å¯ä»¥è¯´æ˜è®¡ç®—å·¦é€†æ—¶å¯èƒ½å‡ºç°çš„æ•°å€¼ä¸å‡†ç¡®æ€§ã€‚
- en: '![Exercise 11-5](assets/plad_1108.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![ç»ƒä¹  11-5](assets/plad_1108.png)'
- en: Figure 11-8\. Solution to Exercise 11-5
  id: totrans-153
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾ 11-8\. ç»ƒä¹  11-5 çš„è§£ç­”
- en: ^([1](ch11.xhtml#idm45733295548016-marker)) Admittedly, Iâ€™ve never seen this
    equation on a Tajikistani billboard, but the point is to keep an open mind.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch11.xhtml#idm45733295548016-marker)) è¯šç„¶ï¼Œæˆ‘ä»æœªåœ¨å¡”å‰å…‹æ–¯å¦å¹¿å‘Šç‰Œä¸Šçœ‹åˆ°è¿™ä¸ªæ–¹ç¨‹å¼ï¼Œä½†é‡ç‚¹æ˜¯è¦ä¿æŒå¼€æ”¾çš„å¿ƒæ€ã€‚
- en: ^([2](ch11.xhtml#idm45733295319056-marker)) In case you were wondering, it is
    also possible to minimize the *absolute* distances instead of the *squared* distances.
    Those two objectives can lead to different results; one advantage of squared distance
    is the convenient derivative, which leads to the least squares solution.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch11.xhtml#idm45733295319056-marker)) å¦‚æœä½ åœ¨æƒ³ï¼Œä¹Ÿå¯ä»¥å°†*ç»å¯¹*è·ç¦»æœ€å°åŒ–ï¼Œè€Œä¸æ˜¯*å¹³æ–¹*è·ç¦»ã€‚è¿™ä¸¤ä¸ªç›®æ ‡å¯èƒ½å¯¼è‡´ä¸åŒçš„ç»“æœï¼›å¹³æ–¹è·ç¦»çš„ä¸€ä¸ªä¼˜ç‚¹æ˜¯æ–¹ä¾¿çš„å¯¼æ•°è®¡ç®—ï¼Œè¿™å¯¼è‡´äº†æœ€å°äºŒä¹˜è§£ã€‚
- en: ^([3](ch11.xhtml#idm45733295298448-marker)) If you are not comfortable with
    matrix calculus, then donâ€™t worry about the equations; the point is that we took
    the derivative with respect to **Î²** using the chain rule.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch11.xhtml#idm45733295298448-marker)) å¦‚æœä½ å¯¹çŸ©é˜µå¾®ç§¯åˆ†æ„Ÿåˆ°ä¸é€‚åº”ï¼Œé‚£å°±ä¸ç”¨æ‹…å¿ƒæ–¹ç¨‹å¼ï¼›é‡ç‚¹æ˜¯æˆ‘ä»¬åˆ©ç”¨é“¾å¼æ³•åˆ™å¯¹**Î²**è¿›è¡Œäº†å¯¼æ•°ã€‚
- en: '^([4](ch11.xhtml#idm45733295240096-marker)) In case itâ€™s not already clear
    enough: this is completely made-up data for this example; any resemblance to the
    real world is coincidental.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch11.xhtml#idm45733295240096-marker)) å¦‚æœè¿˜ä¸å¤Ÿæ¸…æ¥šï¼šè¿™äº›æ•°æ®å®Œå…¨æ˜¯ä¸ºè¿™ä¸ªä¾‹å­è€Œè™šæ„çš„ï¼›ä»»ä½•ä¸ç°å®ä¸–ç•Œçš„ç›¸ä¼¼æ€§éƒ½æ˜¯å·§åˆã€‚
