- en: Chapter 13\. Visualizing data
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 13 章. 数据可视化
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Making quick plots of vector data using matplotlib
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 matplotlib 快速绘制矢量数据
- en: Plotting raster data with matplotlib
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 matplotlib 绘制栅格数据
- en: Creating maps with Mapnik
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Mapnik 创建地图
- en: As you no doubt have noticed, the ability to view your data is essential. While
    you can use desktop GIS software, such as QGIS, sometimes it’s nice to see your
    data as you work, without needing to open it up in other software. This is the
    idea behind the `VectorPlotter` class in the `ospybook` module. Other times you
    might need to create a picture of your data, such as a quick-and-dirty plot to
    show a colleague, or perhaps a much nicer map to post online or give to a client.
    This isn’t a book on cartography (which is good, because I’m cartographically
    challenged), so this chapter will show you the basics of displaying data in a
    few different ways, but won’t focus on techniques for making the data look pretty.
    You’ll see how to use both the matplotlib and Mapnik modules to plot your data.
    If you want something pretty, you’ll want to go with Mapnik, but matplotlib is
    great for quick visualizations.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，查看数据的能力是至关重要的。虽然你可以使用桌面 GIS 软件，如 QGIS，但有时在不需要在其他软件中打开的情况下看到你的数据会更好。这就是
    `ospybook` 模块中 `VectorPlotter` 类背后的想法。其他时候你可能需要创建你数据的图像，比如快速且简单的图表来展示给同事，或者可能是一张更漂亮的地图，用于在线发布或提供给客户。这不是一本关于制图学的书（这很好，因为我在这方面有挑战），所以本章将展示以几种不同的方式显示数据的基本方法，但不会专注于使数据看起来漂亮的技术。你将了解如何使用
    matplotlib 和 Mapnik 模块来绘制你的数据。如果你想得到一些漂亮的东西，你可能会选择 Mapnik，但 matplotlib 对于快速可视化来说非常出色。
- en: 13.1\. Matplotlib
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1. Matplotlib
- en: Matplotlib is a general-purpose plotting library for Python and can be used
    for any kind of graphic you can think up. This module is extensive, and like NumPy
    and SciPy, entire books have been written on it. If you’re interested in seeing
    an overview of what can be done, check out the examples in the matplotlib gallery
    at [http://matplotlib.org/gallery.html](http://matplotlib.org/gallery.html). The
    gallery contains many impressive examples for making charts and graphs, but we’re
    more interested in spatial data, so this section will concentrate on quick-and-crude
    plots of geographical datasets. In fact, the `VectorPlotter` class uses matplotlib,
    and you’ll learn the basics of how that class plots vector data.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib 是一个用于 Python 的一般用途绘图库，可以用于任何你能想到的图形。这个模块非常广泛，就像 NumPy 和 SciPy 一样，关于它已经写了很多本书。如果你对了解可以做什么有一个概述感兴趣，请查看
    matplotlib 画廊中的示例，网址为 [http://matplotlib.org/gallery.html](http://matplotlib.org/gallery.html)。该画廊包含许多令人印象深刻的图表和图形示例，但我们更感兴趣的是空间数据，所以本节将专注于地理数据集的快速且粗略的绘图。实际上，`VectorPlotter`
    类使用 matplotlib，你将学习该类如何绘制矢量数据的基本知识。
- en: 'Matplotlib has several parts, but the one that you interact with the most to
    plot data is `pyplot`, and that’s what we’ll use here. It’s convention to rename
    this as `plt` when importing it:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib 有几个部分，但你与它交互最多以绘制数据的是 `pyplot`，这就是我们在这里要使用的。在导入时将其重命名为 `plt` 是一种惯例：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can use `pyplot` in interactive or non-interactive mode. Back in [chapters
    3](kindle_split_011.html#ch03) through [7](kindle_split_015.html#ch07), you used
    a `VectorPlotter` from an interactive console and saw the changes to your plots
    immediately. This was matplotlib at work in interactive mode. This mode is extremely
    handy for playing with matplotlib and learning how it works. It’s also useful
    for interactively exploring data.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在交互式或非交互式模式下使用 `pyplot`。在 [第 3 章](kindle_split_011.html#ch03) 到 [第 7 章](kindle_split_015.html#ch07)
    中，你从一个交互式控制台使用了一个 `VectorPlotter` 并立即看到了你图表的变化。这就是 matplotlib 在交互式模式下的工作方式。这种模式对于玩
    matplotlib 和学习它是如何工作的来说非常方便。它也适用于交互式地探索数据。
- en: Plotting isn’t interactive by default, however. This makes sense, because interactivity
    wouldn’t be helpful for a script that creates a graphic and saves it to disk with
    no input from the user. Exceptions exist to every rule, though, and you may find
    that if you’re using IPython in `pylab` mode or an IDE such as Spyder, then interactive
    mode will be on by default. When in interactive mode, the plot is automatically
    shown to the user, but if you want to show the plot when using non-interactive
    mode, then you must call the `plt.show()` method after adding all of the graphics
    to your plot. This will stop the script’s execution until the user closes the
    plot window. You might be tempted to use interactive mode so that the user can
    see the plot as it’s created, but you’ll probably have bad luck with that because
    the plot window disappears when the script ends. The user might see parts of the
    plot as it’s created, but if the script ends as soon as the plot is finished,
    then the user may never get a chance to see the final product.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，绘图不是交互式的。这很有道理，因为对于没有用户输入就创建图形并保存到磁盘的脚本来说，交互性并不有帮助。然而，每条规则都有例外，你可能发现如果你在使用
    `pylab` 模式下的 IPython 或是像 Spyder 这样的 IDE，那么交互模式默认是开启的。在交互模式下，图形会自动显示给用户，但如果你想在非交互模式下显示图形，那么你必须在将所有图形添加到你的图形中之后调用
    `plt.show()` 方法。这将停止脚本的执行，直到用户关闭图形窗口。你可能想使用交互模式，以便用户可以看到图形的创建过程，但你可能不会有什么好运，因为当脚本结束时，图形窗口会消失。用户可能会在图形创建过程中看到部分图形，但如果脚本在图形完成时立即结束，那么用户可能永远没有机会看到最终产品。
- en: 'If you want to turn interactive mode on, either from a script or the console,
    use this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要开启交互模式，无论是从脚本还是控制台，请使用以下命令：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can turn interactive mode back off with `plt.ioff()`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `plt.ioff()` 将交互模式关闭。
- en: 13.1.1\. Plotting vector data
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.1\. 绘制矢量数据
- en: 'You might be surprised to learn that plotting vector data isn’t that difficult.
    The data’s made up of x and y coordinates, after all. First you’ll see how to
    use the `plot` function to draw points, lines, and polygons in general, and then
    you’ll graduate to plotting shapefiles. Once you can do that, you’ll learn how
    to create holes in the special case of donut polygons, so that other data can
    show through if needed. The `plot` function has many options, most of which will
    be ignored here, but you can read about them all in the online documentation found
    at [http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.plot](http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.plot).
    This function wants, at the minimum, lists of x and y coordinates. If that’s all
    you provide, then a line is plotted using those coordinates and a color from the
    matplotlib color cycle. For example, the following code plots the line y = x²,
    shown in [figure 13.1](#ch13fig01):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会惊讶地发现绘制矢量数据并不那么困难。毕竟，数据由 x 和 y 坐标组成。首先，你将看到如何使用 `plot` 函数绘制点、线和多边形，然后你将学习如何绘制形状文件。一旦你能做到这一点，你将学习如何在甜甜圈多边形这种特殊情况下创建孔洞，以便在需要时其他数据可以显示出来。`plot`
    函数有很多选项，其中大多数在这里将被忽略，但你可以在[http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.plot](http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.plot)找到的在线文档中了解它们。这个函数至少需要
    x 和 y 坐标的列表。如果你只提供这些，那么将使用这些坐标和 matplotlib 颜色周期中的一个颜色绘制一条线。例如，以下代码绘制了 y = x² 的线，如图
    13.1 所示：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Figure 13.1\. A simple line plot
  id: totrans-18
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.1\. 一个简单的线图
- en: '![](13fig01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](13fig01.jpg)'
- en: You can specify a color and change this from a line to a series of points simply
    by providing a marker specification, as in the following example. In this case,
    `'ro'` means that it should draw red circles instead of the default line. The
    `markersize` parameter makes the points a bit larger than they would have been
    by default. (Don’t forget to call `plt.show()` to draw each of these plots.)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过提供标记说明来指定颜色并将线条转换为一系列点，如下面的示例所示。在这种情况下，`'ro'` 表示应该绘制红色圆圈而不是默认的线条。`markersize`
    参数使得点比默认情况下更大。（不要忘记调用 `plt.show()` 来绘制每个这些图形。）
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The result of this code is shown in [figure 13.2](#ch13fig02). You can also
    plot a single point by passing in an x and a y value instead of lists of values.
    You might think that the coordinates would be enough, but you have to provide
    a marker symbol such as `'ro'` or else it still tries to draw a line. Because
    one point isn’t enough information to draw a line, you end up with a blank plot.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的结果显示在[图 13.2](#ch13fig02)中。你也可以通过传递 x 和 y 值而不是值列表来绘制单个点。你可能认为坐标就足够了，但你必须提供一个标记符号，如
    `'ro'`，否则它仍然试图画线。因为一个点不足以提供画线的足够信息，你最终会得到一个空白的图。
- en: Figure 13.2\. A simple point plot
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.2\. 一个简单的点图
- en: '![](13fig02.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](13fig02.jpg)'
- en: Because polygons are closed lines, you can draw a hollow polygon exactly the
    same way as a line. Make sure that the first and last sets of coordinates are
    the same so that the polygon is closed. For example, the following code snippet
    adds a 0 to the end of each list so that a line from [figure 13.1](#ch13fig01)
    is drawn back to the origin. In addition, the `lw` named parameter is used to
    change the line thickness (`lw` is short for `linewidth`, which you could also
    use). The results are shown in [figure 13.3](#ch13fig03).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因为多边形是闭合的线条，你可以用与画线相同的方式画一个空心多边形。确保第一组和最后一组坐标相同，这样多边形才是闭合的。例如，以下代码片段在每个列表的末尾添加一个
    0，以便从[图 13.1](#ch13fig01) 绘制一条线回到原点。此外，使用名为 `lw` 的命名参数来改变线宽（`lw` 是 `linewidth`
    的缩写，你也可以使用）。结果在[图 13.3](#ch13fig03) 中显示。
- en: Figure 13.3\. A simple closed line plot
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.3\. 一个简单的闭合线条图
- en: '![](13fig03.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](13fig03.jpg)'
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Believe it or not, you now know pretty much everything you need to know to make
    simple plots of vector data, assuming you remember what you learned in earlier
    chapters. To draw the features in a layer, open it and, for each feature, get
    the geometry coordinates and plot them as you did here. Let’s try it out with
    the global landmass shapefile. This particular dataset is convenient because all
    of the geometries are simple polygons, and you don’t need to worry about multipolygons.
    You have one donut polygon in the mix, but you can ignore that for now and plot
    the outer ring. For each feature, get the first ring from its geometry, and then
    get the coordinates from that. Remember that the coordinates come in a list of
    pairs, so the `zip` function comes in handy because you can use it to create two
    separate lists of x and y coordinates. The following listing demonstrates this
    pattern and results in a plot like [figure 13.4](#ch13fig04)A.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，你现在几乎已经知道了制作简单矢量数据图所需的所有知识，前提是你记得在前面章节中学到的知识。要绘制图层中的特征，打开它，然后对于每个特征，获取几何坐标并像这里一样绘制它们。让我们用全球陆地形状文件来试一试。这个特定数据集很方便，因为所有的几何形状都是简单多边形，你不需要担心多边形。混合中有一个甜甜圈多边形，但现在你可以忽略它，并绘制外环。对于每个特征，从其几何形状中获取第一个环，然后从那里获取坐标。记住，坐标以一对列表的形式出现，所以
    `zip` 函数很有用，因为你可以用它来创建两个单独的 x 和 y 坐标列表。以下列表演示了这种模式，并导致了一个类似于[图 13.4](#ch13fig04)A
    的图。
- en: Figure 13.4\. Two plots of the continents using closed lines for polygons. Plot
    A sets the axes equal to each other and the proportions are correct, unlike plot
    B in which the default axis limits are used.
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.4\. 使用闭合线条绘制大陆的两种图。图 A 将轴设置为相等，比例正确，与使用默认轴限制的图 B 不同。
- en: '![](13fig04_alt.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](13fig04_alt.jpg)'
- en: Listing 13.1\. Plotting simple polygons
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.1\. 绘制简单多边形
- en: '![](290fig01_alt.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](290fig01_alt.jpg)'
- en: One little detail that the listing takes care of has not been mentioned yet.
    For your spatial plots to look right, you need to set the axis units equal to
    each other. If you comment this line out, you’ll end up with a plot more like
    [figure 13.4](#ch13fig04)B. By default the data are fitted into the available
    space so that the data fill it all up. The distance covered by a single unit might
    be different on each axis. If you look closely at part B of the figure, you’ll
    see that the horizontal axis ranges from -200 to 200 but the vertical one from
    -100 to 100, and yet they both use up the same amount of space on paper. Setting
    the axes units equal fixes this distortion.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中注意到的细节尚未提及。为了使你的空间图看起来正确，你需要将轴单位设置为相等。如果你取消注释这一行，你最终会得到一个更类似于[图 13.4](#ch13fig04)B
    的图。默认情况下，数据会被拟合到可用空间中，以便数据填满整个空间。单个单位覆盖的距离在每个轴上可能不同。如果你仔细观察图的部分 B，你会看到水平轴的范围从
    -200 到 200，但垂直轴的范围从 -100 到 100，尽管它们在纸上占用的空间相同。设置轴单位相等可以解决这个问题。
- en: As you’ve seen, drawing simple polygons isn’t difficult. Dealing with multipolygons
    and donut polygons adds a little more complexity to the code, but it’s still the
    exact same process. In the case of a multipolygon, you need to loop through each
    polygon in the multipolygon, and then for each polygon (whether from a multipolygon
    or not), loop through the rings and plot each one. The following listing shows
    this process for the countries shapefile, which gives you a plot like [figure
    13.5](#ch13fig05).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，绘制简单的多边形并不困难。处理多边形和多边形环增加了代码的复杂性，但仍然是完全相同的过程。在多边形的情况下，您需要遍历多边形中的每个多边形，然后对于每个多边形（无论是否来自多边形），遍历环并绘制每一个。以下列表展示了为
    countries 形状文件显示此过程，它为您提供了类似于图 13.5 的图表。
- en: Figure 13.5\. A plot of countries using closed lines but accounting for multipolygons
    and holes
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.5\. 使用封闭线绘制国家，但考虑到多边形和孔
- en: '![](13fig05.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](13fig05.jpg)'
- en: Listing 13.2\. Plotting polygons
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.2\. 绘制多边形
- en: '![](ch13ex02-0.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](ch13ex02-0.jpg)'
- en: '![](ch13ex02-1.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](ch13ex02-1.jpg)'
- en: This example breaks things up into a few functions to make things easier. The
    `plot_polygon` function loops through the rings in a polygon and plots each one.
    The other function, `plot_layer`, opens a data source, gets the layer indicated
    by the optional `layer_index` parameter, and loops through all of the features
    and plots their geometries. If the geometry is a polygon, it passes it along to
    `plot_polygon`, but if it’s a multipolygon, it passes each polygon part to `plot_polygon`
    separately. Both of these functions allow you to use `**kwargs` to pass optional
    parameters that are used by the matplotlib `plot` function (see the sidebar).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将事物分解成几个函数，以便更容易处理。`plot_polygon` 函数遍历多边形的环，并绘制每一个环。另一个函数 `plot_layer` 打开数据源，获取由可选的
    `layer_index` 参数指定的层，并遍历所有要素，绘制它们的几何形状。如果几何形状是多边形，它将其传递给 `plot_polygon`，但如果它是多边形，它将每个多边形部分单独传递给
    `plot_polygon`。这两个函数都允许您使用 `**kwargs` 传递由 matplotlib `plot` 函数使用的可选参数（见侧边栏）。
- en: These functions make it easy to plot a shapefile, because all you have to do
    is pass the filename and symbol to `plot_layer`, set your axes to be equal, and
    then show the plot. This listing also shows you how to turn tick marks off if
    you don’t want them drawing alongside the axes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数使绘制形状文件变得容易，因为您只需传递文件名和符号给 `plot_layer`，设置您的坐标轴为相等，然后显示图表。此列表还展示了如何关闭不需要的刻度标记，如果您不想它们与坐标轴一起绘制。
- en: '|  |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Using **kwargs in functions**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**在函数中使用 **kwargs**'
- en: The same way you’ve used a single asterisk to explode a list into individual
    values that can be passed as ordered arguments to a function, you can use double
    asterisks to explode a dictionary for use as named arguments. For example, if
    a function can accept a variety of optional parameters, you could create a dictionary
    containing the ones you want to use, with the parameter names as the keys, and
    then pass that to the function instead of each argument individually. This behavior
    is useful for passing arguments through your function to another one.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 与您使用单个星号将列表分解成单独的值，以便作为有序参数传递给函数的方式相同，您可以使用双星号将字典分解为命名参数。例如，如果函数可以接受各种可选参数，您可以创建一个包含您想要使用的参数的字典，其中参数名称作为键，然后将该字典传递给函数，而不是逐个传递每个参数。这种行为对于通过您的函数将参数传递给另一个函数非常有用。
- en: For example, the matplotlib `plot` function accepts a large number of optional
    parameters that control the output. It would be nice to use these with the `plot_polygon`
    and `plot_layer` functions in [listing 13.2](#ch13ex02), but those functions have
    no reason to worry about the optional parameters. They only need to pass them
    along to `plot` when the time comes. To do this, add a variable prefixed with
    `**` as the last parameter to your function. This variable is called `kwargs`
    by convention, but you can call it whatever you want. It does have to be the last
    parameter, however. Then you can pass it along to other functions, and the parameters
    that the user provided eventually arrive in the intended function.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，matplotlib 的 `plot` 函数接受大量可选参数，用于控制输出。使用列表 13.2 中的 `plot_polygon` 和 `plot_layer`
    函数时，使用这些参数会很方便，但那些函数没有必要担心可选参数。它们只需要在需要时将它们传递给 `plot`。为此，将一个以 `**` 前缀开始的变量作为函数的最后一个参数添加。按照惯例，这个变量被称为
    `kwargs`，但您可以称其为任何您想要的名称。然而，它必须是最后一个参数。然后您可以将其传递给其他函数，最终用户提供的参数会到达预期的函数。
- en: '|  |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You probably want to plot lines and points in addition to polygons, so create
    two more simple functions to plot those geometry types and add a few more conditional
    statements to `plot_layer`. This additional code is shown in the following listing,
    and an example of the output is shown in [figure 13.6](#ch13fig06).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还想绘制除了多边形之外的线条和点，所以创建两个额外的简单函数来绘制这些几何类型，并在`plot_layer`中添加一些额外的条件语句。以下列表显示了额外的代码，以及[图13.6](#ch13fig06)的输出示例。
- en: Figure 13.6\. A plot of countries, rivers, and cities using basic lines and
    points
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.6\. 使用基本线条和点绘制的国家、河流和城市
- en: '![](13fig06.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](13fig06.jpg)'
- en: Listing 13.3\. Plotting lines and points
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表13.3\. 绘制线条和点
- en: '![](ch13ex03-0.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](ch13ex03-0.jpg)'
- en: '![](ch13ex03-1.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](ch13ex03-1.jpg)'
- en: This listing doesn’t contain new concepts, only new code. You extend the `plot_layer`
    function so it calls the correct functions for lines, multilines, points, and
    multipoints. Then at the end of the listing, you use the updated function to plot
    country outlines again, but you also add major rivers and large cities. You also
    take advantage of `**kwargs` to pass a marker size for the city points so that
    they don’t draw so big as to hide other features in the plot.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表中没有新的概念，只有新的代码。你扩展了`plot_layer`函数，使其调用正确的线条、多线条、点和多点的函数。然后在列表的末尾，你使用更新的函数再次绘制国家轮廓，但你还添加了主要河流和大型城市。你还利用`**kwargs`传递城市点的标记大小，这样它们就不会绘制得太大以至于隐藏图中的其他特征。
- en: 'Until now you’ve treated polygons as closed lines when plotting them. What
    if you want to fill them with a color? You can do this by changing your `plot_polygon`
    function to use the matplotlib `fill` function instead of `plot`, like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你在绘图时将多边形当作闭合线条处理。如果你想用颜色填充它们怎么办？你可以通过将你的`plot_polygon`函数更改为使用matplotlib的`fill`函数而不是`plot`来实现这一点，如下所示：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now the `symbol` parameter should be a color to use for the fill, so using `y`
    for yellow would result in [figure 13.7](#ch13fig07) with the continents filled
    in.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的`symbol`参数应该是一个用于填充的颜色，所以使用`y`代表黄色会导致[图13.7](#ch13fig07)中的大陆被填充。
- en: Figure 13.7\. A repeat of [figure 13.6](#ch13fig06), but the closed lines are
    filled with a color
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.7\. [图13.6](#ch13fig06)的重复，但闭合线条被填充了颜色
- en: '![](13fig07.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](13fig07.jpg)'
- en: 'The only problem with this method is that polygons with holes in them will
    be plotted incorrectly, because the holes will be plotted using the same fill
    color. You could fix this by only plotting the first ring with the fill color
    and using white for the later rings, but that wouldn’t create a hole because nothing
    underneath would show through. If you need real holes, you can use matplotlib
    `PathPatch`es, but it’s a little more complicated than what you’ve done so far.
    To draw a polygon, you not only need the vertex coordinates, but also a set of
    codes denoting whether to draw a line or move the pen to that location. You use
    this information to create a `Path`, and then create a `PathPatch` from that.
    The `PathPatch` is the object that you add a fill color to. Once you have that,
    then you need to add it to the plot. For example, this bit of code draws the solid
    red triangle shown in [figure 13.8](#ch13fig08):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的唯一问题是，如果多边形内部有孔，它们将被错误地绘制，因为孔将被使用相同的填充颜色绘制。你可以通过只使用填充颜色绘制第一个环，而使用白色绘制后续的环来修复这个问题，但这不会创建一个孔，因为下面的东西不会显示出来。如果你需要真正的孔，你可以使用matplotlib的`PathPatch`，但这比你之前所做的工作要复杂一些。要绘制一个多边形，你不仅需要顶点坐标，还需要一组代码来表示是否绘制线条或将笔移动到该位置。你使用这些信息来创建一个`Path`，然后从该`Path`创建一个`PathPatch`。`PathPatch`是你要添加填充颜色的对象。一旦有了这个，你还需要将其添加到图中。例如，以下代码绘制了[图13.8](#ch13fig08)中显示的实心红色三角形：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Figure 13.8\. Simple patch polygons
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.8\. 简单的补丁多边形
- en: '![](13fig08.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](13fig08.jpg)'
- en: The first code is `MOVETO`, meaning that the pen should move to the first set
    of coordinates without drawing anything. This makes sense if you’ve already drawn
    something else and don’t want a line connecting the last point in the previous
    path to the first point in this path. The `LINETO` code corresponds to the rest
    of your coordinates, meaning that the points will be connected. Once you’ve created
    the path, then you can use it to create a patch, which can be filled. You need
    to add the patch to the drawing area of the plot, which is called the *axes* (which
    in turn contains the x and y axis).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第一段代码是`MOVETO`，意味着笔应该移动到第一组坐标而不绘制任何东西。如果你已经绘制了其他东西，并且不想将前一个路径的最后一个点与当前路径的第一个点连接起来，这很有意义。`LINETO`代码对应于你的其余坐标，意味着点将被连接。一旦创建了路径，就可以使用它来创建补丁，补丁可以被填充。需要将补丁添加到图的绘制区域，这被称为*坐标轴*（它反过来包含x轴和y轴）。
- en: 'To put a hole in a patch, create a path as before, but use a `MOVETO` code
    to move to the first set of coordinates for the hole, and then add the vertices
    in the opposite direction as the outer set in order to indicate that this should
    create a hole. If the coordinates for the outer ring are in clockwise order, then
    the coordinates for the holes must be in counterclockwise order. For example,
    you can put a hole in your earlier triangle like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在补丁上打孔时，创建路径与之前相同，但使用`MOVETO`代码移动到孔的第一组坐标，然后以与外环相反的方向添加顶点，以指示应创建一个孔。如果外环的坐标是顺时针顺序，则孔的坐标必须是逆时针顺序。例如，你可以这样在你的早期三角形中打孔：
- en: '![](295fig01_alt.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](295fig01_alt.jpg)'
- en: Once you have all of your coordinates and codes in two lists or NumPy arrays,
    then you can use them as before to create the patch with a hole that is shown
    in [figure 13.8](#ch13fig08). The following listing applies this process to spatial
    data to make a plot of world countries like that in [figure 13.9](#ch13fig09).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了两个列表或NumPy数组中的所有坐标和代码，你就可以像之前一样使用它们来创建一个带有孔的补丁，如图13.8中所示。以下列表将此过程应用于空间数据，以绘制如图13.9所示的世界国家图。
- en: Figure 13.9\. Countries drawn with patches instead of lines
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.9：用补丁而不是线条绘制的国家
- en: '![](13fig09.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](13fig09.jpg)'
- en: Listing 13.4\. Draw world countries as patches
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表13.4：将世界国家绘制为补丁
- en: '![](ch13ex04-0.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch13ex04-0.jpg)'
- en: '![](ch13ex04-1.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch13ex04-1.jpg)'
- en: This listing contains a couple of useful functions. The first, `order_coords`,
    checks if coordinates are in the order requested and reorders them if not. Most
    of the code in the function implements an algorithm for determining order. Once
    the order is determined, it’s compared to the requested order, and if they differ,
    the coordinates are reversed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表包含一些有用的函数。第一个函数`order_coords`检查坐标是否按请求的顺序排列，如果不按顺序则重新排列它们。函数中的大部分代码实现了一个确定顺序的算法。一旦确定了顺序，它就会与请求的顺序进行比较，如果它们不同，则反转坐标。
- en: Also, a simple function called `make_codes` creates a list of `LINETO` codes
    of the appropriate length, with the first one changed to `MOVETO` so a new path
    can be started.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一个名为`make_codes`的简单函数创建了一个适当长度的`LINETO`代码列表，第一个被更改为`MOVETO`，以便可以开始新的路径。
- en: The last function plots polygons as patches. The first thing this function does
    is create a list of the outer ring coordinates in clockwise order, along with
    a corresponding code list. Then it loops through any inner rings that might exist,
    and for each one creates a list of coordinates in counterclockwise order and a
    list of codes. Then it appends the coordinates and codes for the inner ring to
    the end of the master lists. Once all rings have been processed, it creates a
    patch and adds it to the plot.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个函数将多边形作为补丁绘制。此函数首先创建一个顺时针顺序的外环坐标列表，以及相应的代码列表。然后它遍历可能存在的任何内环，并为每个内环创建一个逆时针顺序的坐标列表和代码列表。然后它将内环的坐标和代码追加到主列表的末尾。一旦处理完所有环，它就创建一个补丁并将其添加到图中。
- en: The main part of the code simply loops through the features in a shapefile and
    calls the `plot_polygon_patch` function on each polygon, including those inside
    multipolygons. Don’t forget to set the axis to `equal` before drawing the plot,
    because otherwise the x and y axis will probably only range from 0 to 1, and you’ll
    end up staring at a blank plot.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的主体部分简单地遍历形状文件中的特征，并对每个多边形调用`plot_polygon_patch`函数，包括多边形内的多边形。在绘制图之前，不要忘记将坐标轴设置为`equal`，否则x轴和y轴可能只会从0到1，你最终会看到一个空白的图。
- en: Animation
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 动画
- en: 'You can have even more fun by animating your plots. To see how it’s done, you’ll
    animate the movements of one of the albatrosses from [chapter 7](kindle_split_015.html#ch07).
    Let’s start by configuring the plot’s extent based on the GPS data:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过动画化你的图表来获得更多的乐趣。要了解如何实现，你将动画化第7章中[章节7](kindle_split_015.html#ch07)中一只信天翁的移动。让我们首先根据GPS数据配置图表的范围：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You get the extent of the GPS data layer and then use it to set the x and y
    limits for the plot, except that you add 1,000 meters in every direction to add
    a little buffer around the data you want to show. You also turn the tick marks
    off. You probably want to add the landmasses to your plot because the GPS locations
    aren’t too interesting without context. You can use your `plot_polygon` function
    to do this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你获取GPS数据层的范围，然后使用它来设置图表的x和y限制，除了在每个方向上添加1,000米以在你要显示的数据周围添加一些缓冲区。你还关闭了刻度标记。你可能想在图表中添加陆地，因为GPS位置没有上下文的话并不太有趣。你可以使用你的`plot_polygon`函数来做这件事：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now you’re ready to add the animated data, but you need to store it somewhere
    so it’s accessible to the animation routines. You have many ways you could set
    this up, but for this example you’ll store the x,y coordinate pairs in a list,
    with the corresponding timestamps in another list:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经准备好添加动画数据了，但你需要将其存储在某个地方，以便动画例程可以访问它。你有多种方法可以设置它，但在这个例子中，你将把x,y坐标对存储在一个列表中，相应的时间戳存储在另一个列表中：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You iterate through all of the features for the animal with tag `''2131-2131''`
    and add the timestamp to one list and a tuple containing the coordinates to another
    list. You’ll use the coordinates to animate a point and the timestamps to show
    the current time. You need to initialize both the point and the timestamp annotation,
    so let’s do that:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你遍历带有标签`'2131-2131'`的动物的所有特征，将时间戳添加到一个列表中，并将包含坐标的元组添加到另一个列表中。你将使用坐标来动画化一个点，并使用时间戳来显示当前时间。你需要初始化点和时间戳注释，让我们来做这件事：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here you initialize the point by plotting it with no coordinates. The `plot`
    function returns a list of objects, but in this case you have only one item in
    the list because you only plotted one point. You grab that point graphic out of
    the list and store it in your `point` variable. Then you create an empty annotation
    object on the current axes (`gca` is short for “get current axes”). Setting the
    optional `xycoords` parameter to `'axes fraction'` lets you specify the annotation’s
    location using percentages rather than pixels or map coordinates. The annotation
    will be a quarter of the way across the axes (0.25) and close to the top (0.95).
    You also tell the annotation that it’s going to be animated, which will make the
    text change much more smoothly.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你通过没有坐标的绘图来初始化点。`plot`函数返回一个对象列表，但在这个例子中，列表中只有一个项目，因为你只绘制了一个点。你从列表中获取那个点图形并将其存储在`point`变量中。然后你在当前轴上创建一个空的注释对象（`gca`是“get
    current axes”的缩写）。将可选的`xycoords`参数设置为`'axes fraction'`允许你使用百分比而不是像素或地图坐标来指定注释的位置。注释将位于轴的四分之一处（0.25）并且靠近顶部（0.95）。你还告诉注释它将被动画化，这将使文本变化更加平滑。
- en: Now you need to write a simple function that tells the animation what items
    are going to change, namely, your point and label. If you don’t set the point
    coordinates to `None` in this function, then there is always a point at the first
    location in the animation, even while another point is moving around.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要编写一个简单的函数，告诉动画将要改变哪些项目，即你的点和标签。如果你在这个函数中不将点坐标设置为`None`，那么在动画中始终有一个点位于第一个位置，即使另一个点正在移动。
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: One last function you need to write is the one that moves the point and changes
    the label. The first parameter to this function is a counter that gets passed
    to it automatically, specifying which iteration of the animation is currently
    being processed. The rest of the parameters are up to you. It needs to accept
    the objects that will change and any data needed to change them. Like the `init`
    function, this function must return the objects that change.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要编写最后一个函数，该函数用于移动点并更改标签。这个函数的第一个参数是一个计数器，它自动传递给它，指定当前正在处理的动画迭代次数。其余的参数由你决定。它需要接受将要改变的对象以及任何需要改变它们的数据。就像`init`函数一样，这个函数必须返回改变的对象。
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The function uses the counter variable, `i`, to pull the correct timestamps
    and coordinates out of the lists. It changes the label’s text to the timestamp,
    and sets the point’s coordinates to the values you saved from the shapefile. Then
    it returns the point and the label because they’ve changed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数使用计数变量`i`从列表中提取正确的时间戳和坐标。它将标签的文本更改为时间戳，并将点的坐标设置为从shapefile中保存的值。然后它返回点和标签，因为它们已经改变。
- en: Now let’s run the animation using the `FuncAnimation` function in matplotlib.
    The two required parameters are the matplotlib figure object that the animation
    will run on and your function that tells things how to animate. The `frames` parameter
    is the counter variable, which can be a list of values, or as in this case, the
    number of times you want the animation to run. The `init_func` parameter is the
    initialization function that you wrote. If you don’t provide this, then the first
    result from the animation will be used for initialization, and it will stay there
    throughout the animation. If your animation function requires parameters other
    than the counter, you need to provide them using the `fargs` argument to `FuncAnimation`.
    If `blit` is `True,` then only the parts of the plot that have changed will be
    redrawn, which will speed things up. The `interval` parameter is the number of
    milliseconds between frames, and `repeat` tells it whether to repeat the animation
    or stop after one time.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用matplotlib中的`FuncAnimation`函数运行动画。该函数需要两个参数：动画将运行的matplotlib图形对象以及告诉动画如何进行的函数。`frames`参数是计数变量，它可以是值列表，或者在本例中，是您希望动画运行次数的数量。`init_func`参数是您编写的初始化函数。如果您不提供此参数，则动画的第一个结果将被用于初始化，并且在整个动画过程中保持不变。如果您的动画函数需要除计数器之外的其他参数，您需要使用`FuncAnimation`的`fargs`参数提供它们。如果`blit`为`True`，则只重新绘制图表中已更改的部分，这将加快速度。`interval`参数是帧之间的毫秒数，而`repeat`参数告诉它是否重复动画或运行一次后停止。
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It would be nice if the animation could be embedded in paper, but it can’t,
    so you’ll have to run the code yourself to see it in action. One thing you should
    notice is that nothing in this code will force the elapsed time to stay at a constant
    speed. If two consecutive GPS fixes are three days apart, they’ll be treated the
    same as two that are only an hour apart. One way to fix that is to round the timestamps
    to the nearest hour and make sure entries are in the `timestamps` and `coordinates`
    lists for every hour. If there aren’t coordinates corresponding to a specific
    time, then put a bogus value in the list. When you update the animation, only
    update the point location if the coordinates are valid. Here’s a function that
    rounds timestamps:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果动画可以嵌入到论文中那就太好了，但这是不可能的，所以您需要自己运行代码来看到它的实际效果。您应该注意，在这段代码中没有任何东西会强制使经过的时间保持恒定速度。如果两个连续的GPS定位点相隔三天，它们将被视为相隔仅一小时的两个点。解决这个问题的一种方法是将时间戳四舍五入到最近的整点，并确保`timestamps`和`coordinates`列表中每小时都有条目。如果没有对应特定时间的坐标，则在列表中放入一个无效值。当您更新动画时，只有当坐标有效时才更新点的位置。下面是一个四舍五入时间戳的函数：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you use the default value of 60 for the `minutes` parameter, the function
    rounds to the nearest hour. In this case it adds 30 minutes to the timestamp,
    so if the original was 11:27:14.01, the new time is 11:57:14.01\. Then it calculates
    the remainder of dividing the timestamp’s minutes value by the number of minutes
    you want to round to. In this case, that value is 57 because 57 goes into 60 zero
    times and the entire value is the remainder. Then the numbers of seconds and microseconds
    from the timestamp are added to this value, so you have 57:14.01, and the result
    is subtracted from the timestamp. Now the timestamp is 11:00 even, which is the
    closest hour to 11:27:14.01.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您为`minutes`参数使用默认值60，函数将四舍五入到最近的整点。在这种情况下，它将30分钟加到时间戳上，所以如果原始时间是11:27:14.01，新时间是11:57:14.01。然后它计算时间戳分钟值除以您想要四舍五入的分钟数的余数。在这种情况下，这个值是57，因为57不能整除60，整个值就是余数。然后，将时间戳的秒数和微秒数加到这个值上，所以您有57:14.01，然后从这个值中减去结果。现在时间戳是11:00整，这是最接近11:27:14.01的整点。
- en: 'Now that you can round timestamps, let’s initialize the `timestamps` and `coordinates`
    lists with the first values from the dataset:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以使用四舍五入时间戳了，让我们用数据集的第一组值初始化`timestamps`和`coordinates`列表：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now you can loop through the rest of the features and fill in your lists. Get
    the timestamp for each row and compare it to the last one in the `timestamps`
    list. Keep adding new timestamps to the list until the last one is equal to the
    one from the feature, and while you’re at it, append a bogus set of coordinates
    to that list, too. The loop will stop when the last timestamp in the list is equal
    to the row’s timestamp, so you can overwrite the last set of bogus coordinates
    with the feature’s coordinates and they’ll match up with the correct timestamp.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以遍历其余的功能并填写你的列表。获取每一行的戳记并与其在 `timestamps` 列表中的最后一个进行比较。继续向列表中添加新的戳记，直到最后一个等于特征中的戳记，同时，你也可以将一个虚假的坐标集添加到该列表中。当列表中的最后一个戳记等于行的戳记时，循环将停止，这样你就可以用特征的坐标覆盖最后一个虚假坐标集，它们将与正确的戳记匹配。
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The only other thing you need to do is change your `update` function so that
    it only moves the point if there are valid coordinates. If you don’t do this,
    the point will disappear when there aren’t coordinates for a specific time because
    they’ll be set to `None`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你唯一需要做的另一件事就是修改你的 `update` 函数，使其只有在存在有效坐标时才移动点。如果你不这样做，当没有特定时间的坐标时，点将会消失，因为它们会被设置为
    `None`。
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now you can run the animation as before, but the time increments will be constant,
    which makes much more sense.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以像以前一样运行动画，但时间增量将是恒定的，这更有意义。
- en: 'If you have appropriate software installed, you can also save the animation
    as a video file. For example, I have FFmpeg ([www.ffmpeg.org](http://www.ffmpeg.org))
    installed, so as long as `ffmpeg` is in my PATH environment variable, I can save
    the animation like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你安装了适当的软件，你还可以将动画保存为视频文件。例如，我安装了 FFmpeg ([www.ffmpeg.org](http://www.ffmpeg.org))，所以只要
    `ffmpeg` 在我的 PATH 环境变量中，我就可以像这样保存动画：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you don’t have the software to save it yourself but would still like to see
    the results, there’s a saved version in the Galapagos data folder.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有保存软件但仍然想查看结果，Galapagos 数据文件夹中有一个保存的版本。
- en: 13.1.2\. Plotting raster data
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.2\. 绘制栅格数据
- en: You can also use matplotlib to draw raster data. Making a simple raster plot
    is extremely easy because you have no coordinates to worry about, and there happens
    to be a function for displaying data contained in a NumPy array. Let’s start with
    a small image and draw it using the default color ramp, as shown in [figure 13.10](#ch13fig10)A.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 matplotlib 来绘制栅格数据。制作一个简单的栅格图非常容易，因为你不需要担心坐标，而且恰好有一个用于显示包含在 NumPy 数组中的数据的函数。让我们从一个小的图像开始，使用默认的颜色渐变来绘制它，如图
    [图 13.10](#ch13fig10)A 所示。
- en: Figure 13.10\. Two plots of the same digital elevation model of Mount St. Helens.
    Plot A uses the default color ramp (which morphs from blue to red), and plot B
    uses a grayscale color ramp.
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.10\. 圣海伦斯山的同一数字高程模型的两个图。图 A 使用默认的颜色渐变（从蓝色渐变到红色），而图 B 使用灰度颜色渐变。
- en: '![](13fig10_alt.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](13fig10_alt.jpg)'
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see, all you have to do is read the raster data into a NumPy array
    as you’ve done many times before, and then pass that array to the `imshow` function,
    and you have yourself a plot. You might not like the default color ramp, but you
    can probably find a built-in one that you like. If not, you can create your own,
    although you won’t learn how to do that here. To use a colormap, pass its name
    to `imshow` as the `cmap` parameter, like this ([figure 13.10](#ch13fig10)B):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你所要做的就是像以前一样读取栅格数据到一个 NumPy 数组中，然后将该数组传递给 `imshow` 函数，你就有了一个图表。你可能不喜欢默认的颜色渐变，但你可能找到一个你喜欢的内置渐变。如果没有，你可以创建自己的渐变，尽管你在这里不会学习如何做到这一点。要使用颜色图，将颜色图名称传递给
    `imshow` 作为 `cmap` 参数，就像这样 ([图 13.10](#ch13fig10)B)：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|  |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: As of this writing, you can see a list of matplotlib colormaps at [http://wiki.scipy.org/Cookbook/Matplotlib/Show_colormaps](http://wiki.scipy.org/Cookbook/Matplotlib/Show_colormaps).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可以看到 matplotlib 颜色图列表在 [http://wiki.scipy.org/Cookbook/Matplotlib/Show_colormaps](http://wiki.scipy.org/Cookbook/Matplotlib/Show_colormaps)。
- en: '|  |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If you want to plot a large image, you shouldn’t read the entire band in and
    try to plot it. You’re much better off using one of the pyramid layers because
    they take up much less memory and will plot considerably faster. You need to choose
    the appropriate overview level so that you have the resolution that you need without
    degrading performance. Here’s a function that retrieves overview data from an
    image, although it doesn’t check to make sure that the user requests a valid overview
    level.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想绘制一个大图像，你不应该读取整个波段并尝试绘制它。使用金字塔层之一会更好，因为它们占用的内存更少，绘制速度也更快。您需要选择适当的概述级别，以便在不降低性能的情况下获得所需的分辨率。以下是一个从图像中检索概述数据的函数，尽管它没有检查用户是否请求了有效的概述级别。
- en: Listing 13.5\. Function to retrieve overview data
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表13.5\. 获取概述数据的函数
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The function requires that the user provide the path to a raster file, and
    optionally, a band number and overview level. If the optional parameters aren’t
    provided, it will return the coarsest overview for the first band. Try using this
    function to plot the lowest resolution overview for a Landsat band:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数要求用户提供栅格文件的路径，以及可选的波段号和概述级别。如果未提供可选参数，它将返回第一波段的最低级概述。尝试使用此函数绘制Landsat波段的最低分辨率概述：
- en: '![](302fig01_alt.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](302fig01_alt.jpg)'
- en: As you can see from [figure 13.11](#ch13fig11)A, this results in an extremely
    dark image and in this case, at least, it’s difficult if not impossible to differentiate
    much at all. It might even seem worse if you hadn’t masked out the pixels that
    were equal to 0\. Without that step, you’d see a rectangle with all of the outside
    pixels that weren’t part of the satellite imagery drawn as black.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图13.11](#ch13fig11)A所示，这导致图像非常暗，在这种情况下，至少很难区分任何东西。如果你没有屏蔽掉等于0的像素，它甚至可能看起来更糟。如果没有这一步，你会看到一个矩形，其中所有不属于卫星图像的外围像素都被绘制为黑色。
- en: Figure 13.11\. Two plots of the same Landsat band. Plot A uses default settings,
    but plot B uses stretched data for much better contrast.
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.11\. 同一Landsat波段的两个绘图。绘图A使用默认设置，但绘图B使用拉伸数据以获得更好的对比度。
- en: '![](13fig11_alt.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](13fig11_alt.jpg)'
- en: Because of the lack of contrast in [figure 13.11](#ch13fig11)A, this is a perfect
    time to stretch the data to make it look better. A *standard deviation stretch*,
    which is a common method, keeps pixel values that are within one or more standard
    deviations (usually two) from the mean, and sets everything outside that range
    to the minimum or maximum included values, as shown in [figure 13.12](#ch13fig12).
    The values are then stretched between 0 and 1 for drawing, because that’s what
    matplotlib wants.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于[图13.11](#ch13fig11)A中的对比度不足，现在是拉伸数据以使其看起来更好的完美时机。一种常见的*标准差拉伸*方法，它保留均值一个或多个标准差（通常为两个）内的像素值，并将该范围之外的所有值设置为包含的最小或最大值，如图[图13.12](#ch13fig12)所示。然后，为了绘图，将值拉伸到0和1之间，因为这是matplotlib所希望的。
- en: Figure 13.12\. An illustration of how the data extremes are clipped, and then
    all data values are stretched between 0 and 1
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.12\. 数据极端值裁剪的说明，然后所有数据值都在0和1之间拉伸
- en: '![](13fig12_alt.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](13fig12_alt.jpg)'
- en: 'To implement this, figure out the minimum and maximum cutoffs that are the
    desired number of standard deviations from the mean and then pass them as the
    `vmin` and `vmax` parameters to `imshow`, respectively. The data will automatically
    be stretched for you, but you need to provide these clip values, like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，找出所需的均值所需的标准差的最小和最大截断值，然后将它们分别作为`vmin`和`vmax`参数传递给`imshow`。数据将自动为您拉伸，但您需要提供这些裁剪值，如下所示：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[Figure 13.11](#ch13fig11)B is stretched in this way, and it’s obviously a
    better visualization of the data than the nonstretched version.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[图13.11](#ch13fig11)B以这种方式拉伸，显然比未拉伸版本的数据可视化更好。'
- en: 'You can also plot three bands as red, green, and blue, with an optional fourth
    alpha band. In this case you need to stack the bands into a three-dimensional
    array and pass that to `imshow`. Unlike with single bands, using masked arrays
    to filter out the zeros around the edges doesn’t work in this case, so you’re
    stuck with the black edges for the moment. The following code snippet uses three
    bands to create a figure like 13.13A:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将三个波段作为红色、绿色和蓝色绘制，并可选地添加第四个alpha波段。在这种情况下，您需要将波段堆叠成一个三维数组，并将其传递给`imshow`。与单个波段不同，在这种情况下，使用掩码数组过滤掉边缘的零不起作用，所以目前你只能忍受黑色边缘。以下代码片段使用三个波段创建类似于13.13A的图像：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Again, that image is too dark to be useful. Unfortunately, stretching the data
    is a bit more complicated if you’re plotting multiple bands because the automatic
    scaling with `vmin` and `vmax` only works for single bands. You’ll need to normalize
    the data yourself. The following function performs a standard deviation stretch
    on the data contained in a NumPy array and then scales the results between 0 and
    1.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，那张图片太暗，无法使用。不幸的是，如果你在绘制多个波段，扩展数据会稍微复杂一些，因为使用 `vmin` 和 `vmax` 的自动缩放只适用于单个波段。你需要自己规范化数据。以下函数对包含在
    NumPy 数组中的数据进行标准差扩展，然后将在 0 到 1 之间缩放结果。
- en: Listing 13.6\. Function to stretch and scale data
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.6\. 扩展和缩放数据的功能
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Instead of finding the appropriate distance from the mean, based on the desired
    number of standard deviations, this function makes sure that the values used aren’t
    less than the minimum or greater than the maximum data values. For example, if
    you have 8-bit data that ranges from 0 to 255, the mean value is 43, and the standard
    deviation is 24, then the lower bound would be -5 if you subtracted two standard
    deviations from the mean. The minimum possible value is 0, however, and you don’t
    want to normalize your data using impossible values, so that’s why the function
    checks to make sure that the bounds don’t fall out of the range of potential values.
    After determining the bounds, they’re used with the `np.clip` function, which
    replaces all values that are less than `new_min` with `new_min`, and replaces
    all values that are greater than `new_max` with `new_max`, like what was illustrated
    back in [figure 13.12](#ch13fig12). Then the resulting data are scaled from 0
    to 1\. Now you can use this function to scale each of the three bands appropriately.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于所需标准差数量的均值找到适当的距离不同，这个函数确保使用的值不小于最小值或大于最大数据值。例如，如果你有从 0 到 255 范围的 8 位数据，平均值是
    43，标准差是 24，那么从均值减去两个标准差后，下限将是 -5。然而，可能的最小值是 0，你不想使用不可能的值来规范化你的数据，这就是为什么函数会检查以确保边界不会超出潜在值的范围。确定边界后，它们将与
    `np.clip` 函数一起使用，该函数将所有小于 `new_min` 的值替换为 `new_min`，并将所有大于 `new_max` 的值替换为 `new_max`，就像在[图
    13.12](#ch13fig12)中展示的那样。然后，结果数据从 0 到 1 缩放。现在你可以使用这个函数适当地缩放每个波段。
- en: Because you’re scaling these data yourself, you can take advantage of the alpha
    channel to get rid of the black around the edges. For this particular image, you
    can assume that if all three bands contain 0, then the pixel is an outside edge.
    The alpha band should also contain 0 for these pixels, meaning it’s fully transparent.
    Other pixels should have a 1 in the alpha band so that they’ll be drawn at full
    opacity. Add this alpha band to your three-dimensional stack, as shown in the
    following snippet, and when you plot it the results will be similar to [figure
    13.13](#ch13fig13)B.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你自己在缩放这些数据，你可以利用 alpha 通道来去除边缘的黑色。对于这张特定的图像，你可以假设如果所有三个波段都包含 0，那么像素是边缘。alpha
    波段也应该包含 0，这意味着它是完全透明的。其他像素在 alpha 波段中应该有 1，这样它们将以全不透明度绘制。将这个 alpha 波段添加到你的三维堆栈中，如下面的代码片段所示，当你绘制它时，结果将类似于[图
    13.13](#ch13fig13)B。
- en: Figure 13.13\. Two plots of the same three-band Landsat image. Plot A uses default
    settings, but plot B uses stretched data for considerably better contrast.
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.13\. 同一张三波段 Landsat 图像的两个绘图。绘图 A 使用默认设置，但绘图 B 使用扩展数据，对比度明显更好。
- en: '![](13fig13_alt.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](13fig13_alt.jpg)'
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 13.1.3\. Plotting 3D data
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.3\. 绘制 3D 数据
- en: 'You can even plot three-dimensional data, such as a digital elevation model.
    To do this, you need the array containing elevation data, and two other arrays
    of the same size containing x and y coordinates for each pixel. These latter two
    arrays can be created by passing arrays containing the possible x and y values
    to `np.meshgrid`, which results in data like that shown in [figure 13.14](#ch13fig14).
    Each pixel in the x array contains a value indicating which row it’s in, and each
    pixel in the y array indicates the column. If your pixels are square and you don’t
    need georeferencing information in your plot, you can use `arange` to get the
    input lists for `meshgrid`, so getting your two-dimensional x and y arrays is
    as easy as this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以绘制三维数据，例如数字高程模型。为此，您需要一个包含高程数据的数组，以及两个相同大小的数组，包含每个像素的x和y坐标。后两个数组可以通过将包含可能x和y值的数组传递给`np.meshgrid`来创建，这会产生类似于[图13.14](#ch13fig14)中所示的数据。x数组中的每个像素包含一个值，指示它在哪一行，而y数组中的每个像素指示列。如果您的像素是正方形且您不需要在图表中包含地理参考信息，您可以使用`arange`获取传递给`meshgrid`的输入列表，因此获取二维x和y数组就像这样：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Figure 13.14\. An illustration of meshgrid output. Part A shows the x,y coordinate
    pair for each cell in the array. The output is two arrays, one of which contains
    x coordinates (part B) and the other contains y coordinates (part C).
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.14. meshgrid输出的说明。部分A显示了数组中每个单元格的x,y坐标对。输出是两个数组，其中一个包含x坐标（部分B）和另一个包含y坐标（部分C）。
- en: '![](13fig14_alt.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](13fig14_alt.jpg)'
- en: In other cases, you can use the geotransform to compute the required information
    so that the x and y arrays contain real-world coordinates instead of pixel coordinates
    like those in [figure 13.14](#ch13fig14). The following listing shows the steps
    to do this using a DEM of Mount St. Helens, and then it plots the data in 3D to
    get [figure 13.15](#ch13fig15)A.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，您可以使用地理变换来计算所需信息，以便x和y数组包含真实世界的坐标而不是[图13.14](#ch13fig14)中那样的像素坐标。以下列表显示了使用圣海伦斯山的DEM执行此操作的步骤，然后它以3D形式绘制数据以获得[图13.15](#ch13fig15)A。
- en: Figure 13.15\. 3D plots of Mount St. Helens. Plot A uses default settings, while
    the elevation and azimuth have been changed for plot B, as well as the axis removed.
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.15. 圣海伦斯山的3D图。图A使用默认设置，而图B则改变了高程和方位角，以及移除了坐标轴。
- en: '![](13fig15_alt.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](13fig15_alt.jpg)'
- en: Listing 13.7\. Using `meshgrid` to get map coordinates
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表13.7. 使用`meshgrid`获取地图坐标
- en: '![](306fig01_alt.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](306fig01_alt.jpg)'
- en: The first part of this listing reads overview data into memory and uses the
    geotransform to calculate the bounding coordinates for the DEM. These coordinates
    are then used in conjunction with `meshgrid` to create the x and y arrays needed
    for the plot.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的第一个部分将概述数据读入内存，并使用地理变换来计算DEM的边界坐标。然后，这些坐标与`meshgrid`结合使用，以创建绘图所需的x和y数组。
- en: To create the plot, you first create a matplotlib figure object and then grab
    its axes object. You tell the axes to use 3D, and then you call its `plot_surface`
    method in order to make the plot. This function requires the x and y arrays and
    the array containing elevations. You use the colormap named gist_earth instead
    of the default, and you used `lw=0` to set the line width to 0\. If you don’t
    change the line width, then each cell will have an outline around it, which doesn’t
    look good in this case. By the way, a figure and axes were created automatically
    for your earlier plots, but you didn’t need to worry about them. Here you do,
    because you need a handle to the axes to specify 3D and plot the surface.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建此图，您首先创建一个matplotlib图对象，然后获取其坐标轴对象。您告诉坐标轴使用3D，然后调用其`plot_surface`方法以创建图表。此函数需要x和y数组以及包含高程的数组。您使用名为gist_earth的调色板而不是默认调色板，并使用`lw=0`将线宽设置为0。如果您不更改线宽，则每个单元格周围都会有轮廓，这在这种情况下看起来不好。顺便说一下，对于您之前的图表，已经自动创建了图和坐标轴，但您不必担心它们。在这里，您需要，因为您需要一个坐标轴句柄来指定3D并绘制表面。
- en: 'What if you want to change the vantage point that you’re viewing the 3D image
    from? Well, you can set an elevation between 0 and 90, where 0 is ground level
    and 90 is looking straight down, and you can also rotate the plot from 0 to 360
    degrees. The image in [figure 13.15](#ch13fig15)B was obtained by setting the
    elevation to 55, rotating the figure 60 degrees, and turning the axis off. To
    do this, add these two lines before calling `plt.show()`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想改变观察 3D 图像的视角呢？嗯，您可以将高度设置为 0 到 90 之间，其中 0 是地面水平，90 是直视下方，您还可以将图表旋转 0 到 360
    度。图 [图 13.15](#ch13fig15)B 是通过将高度设置为 55，旋转图表 60 度，并关闭轴来获得的。为此，在调用 `plt.show()`
    之前添加这两行代码：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can make this even more fun by creating an animation. This is simpler than
    the Albatross animation from earlier because all you have to do is change the
    rotation factor for each iteration. Try adding this to your code before calling
    `plt.show`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过创建动画使这个过程更加有趣。这比之前的 Albatross 动画简单，因为您只需为每次迭代更改旋转因子。尝试在调用 `plt.show` 之前添加此代码：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `animate` function changes the vantage point that the plot is being viewed
    from. The call to `FuncAnimation` sets things up so that the `animate` function
    is called 36 times, once for each value in `frames`. This will cause the plot
    to rotate 10 degrees each time. Although the interval parameter specifies that
    there will be 100 milliseconds in between each frame, it will be slower if your
    computer can’t draw it that fast. A saved version of this is in the Nepal data
    folder.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`animate` 函数改变了观察点，即从哪个角度观察图表。调用 `FuncAnimation` 设置了 `animate` 函数被调用 36 次，每次对应
    `frames` 中的一个值。这将导致图表每次旋转 10 度。尽管间隔参数指定了每帧之间有 100 毫秒，但如果您的计算机无法这么快地绘制它，速度会慢一些。这个保存的版本在尼泊尔数据文件夹中。'
- en: 13.2\. Mapnik
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2\. Mapnik
- en: The plots you’ve been making so far work well for visualizing data, but a good
    chance exists that you’ll need to make something that looks a little nicer, or
    more like a real map, at some point. One good way to do this using Python is with
    Mapnik, a popular cartographic library. In fact, you might have seen maps created
    with Mapnik without knowing it. Mapnik was designed for making tiled maps for
    web applications, and as far as I know it’s not easy to put cartographic symbols
    such as North arrows on Mapnik images. You can do it with other graphics modules
    such as Cairo, but that’s beyond the scope of this introduction. This section
    will walk you through the basics of drawing vector and raster data using this
    module, but you should visit mapnik.org if you want to learn more.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您迄今为止制作的图表非常适合可视化数据，但您可能会需要制作看起来更美观或更像真实地图的东西。使用 Python，一个很好的方法是使用 Mapnik，这是一个流行的制图库。实际上，您可能已经看到了使用
    Mapnik 创建的地图，却不知道。Mapnik 是为制作网络应用程序的瓦片地图而设计的，据我所知，在 Mapnik 图像上放置如北箭头这样的制图符号并不容易。您可以使用其他图形模块如
    Cairo 来实现，但这超出了本介绍的范畴。本节将带您了解使用此模块绘制矢量和栅格数据的基本方法，但如果您想了解更多信息，请访问 mapnik.org。
- en: Before we start drawing anything, though, let’s take a quick look at the minimum
    requirements for a Mapnik map, as seen in [figure 13.16](#ch13fig16). A map has
    one or more layers, as well as one or more styles. The styles are what specify
    how the data are to be drawn. Each style needs at least one rule, and each rule
    needs at least one symbol. Rules can also have filters so that they only apply
    to a subset of the data. Each layer needs a data source and at least one style.
    Layer styles aren’t new style objects; they reference one of the styles that belongs
    to the map. You’ll see how this all works in the next few examples.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始绘制任何东西之前，让我们快速看一下 Mapnik 地图的最小要求，如图 [图 13.16](#ch13fig16) 所示。地图有一个或多个图层，以及一个或多个样式。样式指定了数据应该如何绘制。每个样式至少需要一个规则，每个规则至少需要一个符号。规则还可以有过滤器，以便它们只应用于数据的一个子集。每个图层需要一个数据源和至少一个样式。图层样式不是新的样式对象；它们引用属于地图的某个样式。您将在接下来的几个示例中看到这一切是如何工作的。
- en: Figure 13.16\. A basic organization chart of a Mapnik map. Each map has at least
    one layer and one style. Each layer needs to reference at least one of the styles.
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.16\. Mapnik 地图的基本组织结构图。每个地图至少包含一个图层和一个样式。每个图层需要引用至少一种样式。
- en: '![](13fig16_alt.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![13fig16_alt.jpg](13fig16_alt.jpg)'
- en: 13.2.1\. Drawing vector data
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.1\. 绘制矢量数据
- en: Do you remember the New Orleans data from an earlier chapter? If not, you’re
    about to be reminded, because you’ll use it in the next few examples. The following
    listing starts by drawing the TIGER water layer from the US Census Bureau.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您还记得前面章节中的新奥尔良数据吗？如果不记得，您很快就会想起，因为您将在接下来的几个示例中使用它。下面的列表首先从美国人口普查局的 TIGER 水层开始绘制。
- en: Listing 13.8\. Creating a simple Mapnik map
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.8\. 创建一个简单的 Mapnik 地图
- en: '![](308fig01_alt.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](308fig01_alt.jpg)'
- en: The first step is to create a Mapnik map object, but you call it `m` instead
    of `map` because `map` is a reserved word in Python. You need to provide a size
    for the map when you create it, so this map will be 800 pixels wide and 600 tall.
    You can optionally provide a spatial reference in the form of a Proj.4 string
    or EPSG code; if you don’t provide this, then it will default to WGS84 lat/lon.
    Because most of the New Orleans data uses NAD83 lat/lon, that’s what you decide
    to use here. You also set a bounding box in the form of `(min_x, min_y, max_x,
    max_y)`. If you don’t set the bounding box, you’ll end up with an empty map.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个 Mapnik 地图对象，但您将其命名为 `m` 而不是 `map`，因为 `map` 是 Python 中的一个保留字。在创建地图时，您需要提供一个大小，因此这个地图将宽度为
    800 像素，高度为 600 像素。您可以可选地提供一个空间参考，形式为 Proj.4 字符串或 EPSG 代码；如果您不提供此信息，则默认为 WGS84
    纬度/经度。由于新奥尔良的大部分数据使用 NAD83 纬度/经度，因此您决定在这里使用它。您还设置了一个边界框，形式为 `(min_x, min_y, max_x,
    max_y)`。如果您不设置边界框，最终将得到一个空地图。
- en: To add a layer to a map, you need to create a layer object and give it a data
    source. Several types of data sources exist for different data formats, such as
    shapefiles, Geo-JSON, and PostGIS. Here you create a shapefile data source and
    add it to a layer that you name `'Tiger'`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要向地图中添加一个图层，您需要创建一个图层对象并为其提供一个数据源。存在多种数据源类型，用于不同的数据格式，例如 shapefiles、Geo-JSON
    和 PostGIS。在这里，您创建一个 shapefile 数据源并将其添加到您命名为 `'Tiger'` 的图层中。
- en: Adding a layer to a map isn’t enough, however. If you want the layer to be drawn,
    you also need to provide information about how to symbolize it. You start this
    off by creating a Mapnik color object (`water_color`) from RGB values that specify
    a light blue, and then used that to create a polygon symbolizer for drawing water
    layers. Polygons drawn with this symbolizer will be filled with the blue color
    defined by the RGB values.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 向地图中添加一个图层还不够。如果您想绘制图层，您还需要提供有关如何符号化的信息。您首先通过从指定浅蓝色的 RGB 值创建一个 Mapnik 颜色对象 (`water_color`)
    来开始这个过程，然后使用它来创建一个用于绘制水层的多边形符号化器。使用此符号化器绘制的多边形将被填充为 RGB 值定义的蓝色。
- en: Once you have a symbolizer, you create a symbology style. A style needs at least
    one rule that defines how to draw something. This particular style is simple and
    only contains one rule, which in turn only contains your polygon symbolizer. Then
    you add the style to the map so that layers could use it. Notice that you provide
    a name for the style at the same time you add it to the map; this is important
    later.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了符号化器，您就创建一个符号化样式。一个样式至少需要一个规则来定义如何绘制某个东西。这个特定的样式很简单，只包含一个规则，而这个规则又只包含您的多边形符号化器。然后您将样式添加到地图中，以便图层可以使用它。请注意，在将样式添加到地图的同时，您还提供了样式的名称；这在以后很重要。
- en: You want the Tiger layer to use the style you create, so then you add the style
    to the layer as well, making sure to use the same name for the style that you
    used when adding it to the map. The style must be added to both the layer and
    the map or it won’t work. In addition, the style must be added to the layer before
    the layer is added to the map, which is what you do next.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望 Tiger 图层使用您创建的样式，因此您将样式也添加到图层中，确保使用与添加到地图时相同的样式名称。样式必须同时添加到图层和地图中，否则它将不起作用。此外，样式必须在将图层添加到地图之前添加到图层中，这就是您接下来要做的。
- en: Finally, after everything is added in the appropriate places, you save the map
    to a file. If all goes well, you’ll have an image like [figure 13.17](#ch13fig17).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在所有内容都添加到适当的位置后，您需要将地图保存到文件中。如果一切顺利，您将得到一个如图 13.17 所示的图像 [图 13.17](#ch13fig17)。
- en: Figure 13.17\. A simple plot of hydrographic data using a single layer and style
    rule
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.17\. 使用单个图层和样式规则绘制水文数据的简单图表
- en: '![](13fig17.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](13fig17.jpg)'
- en: As pretty as that figure is, you want more than water bodies, so now try adding
    marshland, too. These data come from a national hydrography dataset that includes
    open water, glaciers, marshes, dry lakes, canals, and other features. In fact,
    including the canals and lakes from this dataset will make your map look a little
    better, so you’ll include them as well. This next listing shows how to add this
    new layer with more-complicated styling to the map. This code would be added in
    before saving the map to an image file.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管那个图很漂亮，但你想要的不仅仅是水体，所以现在也尝试添加沼泽地。这些数据来自一个包含开放水域、冰川、沼泽、干湖、运河和其他特征的国家级水文数据集。实际上，包括这个数据集中的运河和湖泊会使你的地图看起来更好一些，所以你也会包括它们。接下来的列表显示了如何添加这个新的图层，并使用更复杂的样式添加到地图上。这段代码会在保存地图为图像文件之前添加。
- en: Listing 13.9\. Using multiple rules in a style
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.9\. 在样式中使用多个规则
- en: '![](310fig01_alt.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](310fig01_alt.jpg)'
- en: The methods for creating this layer and adding it and its style to the map are
    the same as before, but this time the style is more complicated. For starters,
    you add two rules to this style instead of one. Let’s look at the first of these,
    called `water_rule`. You use a filter to apply this rule to only those features
    where the `"Feature"` attribute column is equal to either `'Canal'` or `'Lake'`.
    Filter expressions in Mapnik are similar to the OGR filter expressions that you’ve
    already used, but attribute names must be surrounded by brackets. You use the
    same water polygon symbolizer for this rule that you used for the `tiger` data.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这个图层并将其及其样式添加到地图上的方法与之前相同，但这次样式更复杂。首先，你为这个样式添加两个规则而不是一个。让我们看看第一个，称为 `water_rule`。你使用一个过滤器将这个规则应用于那些“Feature”属性列等于
    `'Canal'` 或 `'Lake'` 的要素。Mapnik 中的过滤器表达式与你已经使用的 OGR 过滤器表达式类似，但属性名必须用方括号括起来。你为这个规则使用了与
    `tiger` 数据相同的用水体多边形符号化器。
- en: Before creating the second rule, you construct new symbolizers that use a green
    color. This time you define the color using hex notation to prove that you can,
    but you could use RGB again if you want. The color is then used to create another
    polygon fill symbol and also a line symbol that’s 2 pixels wide. This line symbolizer
    will be used to outline the polygons with the same color that they’re filled with.
    The reason you use the outline here is because the datasets have slight gaps between
    shapes that are obvious without an outline filling them up.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建第二个规则之前，你构建了新的符号化器，使用绿色颜色。这次你使用十六进制表示法定义颜色以证明你可以这样做，但如果你想的话也可以再次使用 RGB。然后使用这个颜色创建另一个多边形填充符号，以及一个宽度为
    2 像素的线符号。这个线符号化器将用于用与填充相同颜色的线条勾勒多边形。你在这里使用轮廓的原因是因为数据集在形状之间有细微的间隙，没有轮廓填充的话这些间隙是明显的。
- en: Now that you have your symbolizers, you create the marsh rule for this layer.
    First, you use a filter to make this rule apply only to features where the `"Feature"`
    attribute column is equal to the string `'Swamp or Marsh'`. Then you add the green
    fill and outline symbols that you created previously.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了你的符号化器，你为这个图层创建 marsh 规则。首先，你使用一个过滤器使这个规则仅适用于那些“Feature”属性列等于字符串 `'Swamp
    or Marsh'` 的要素。然后你添加了之前创建的绿色填充和轮廓符号。
- en: After creating the rules, you create a new style and add both rules to it. Then
    you add the style to the map and the layer, and add the layer to the map. After
    rendering this map to a file, you end up with a graphic like [figure 13.18](#ch13fig18).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建规则之后，你创建一个新的样式并将两个规则都添加到其中。然后你将样式添加到地图和图层中，并将图层添加到地图中。渲染这个地图到文件后，你最终得到一个如图
    [图 13.18](#ch13fig18) 所示的图形。
- en: Figure 13.18\. Another layer added, this time using two rules to specify that
    marshes and open water in the same dataset are drawn differently
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.18\. 添加了另一个图层，这次使用两个规则来指定同一数据集中的沼泽和开放水域以不同的方式绘制
- en: '![](13fig18.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](13fig18.jpg)'
- en: 'If you compare [figures 13.17](#ch13fig17) and [13.18](#ch13fig18), you might
    wonder where all of the little water bodies disappeared to. The layers are drawn
    in the same order that you add them to the map, so the marshes were drawn on top
    of those little water bodies. For this reason, you need to think about which of
    your layers should not be covered up and plan accordingly. To get a graphic like
    [figure 13.19](#ch13fig19) instead, move the code that appends the layers to the
    map down to the end of the script and then reverse the order that the layers are
    added, like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你比较[图13.17](#ch13fig17)和[13.18](#ch13fig18)，你可能会想知道所有的小水体都到哪里去了。层是按照你添加到地图中的顺序绘制的，所以湿地是在那些小水体之上绘制的。因此，你需要考虑哪些层不应该被覆盖，并据此进行规划。要得到像[图13.19](#ch13fig19)这样的图形，请将添加层的代码移至脚本末尾，然后反转层的添加顺序，如下所示：
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Figure 13.19\. The same data as [figure 13.18](#ch13fig18), but the order of
    the layers reversed
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.19。与[图13.18](#ch13fig18)相同的数据，但层的顺序已反转
- en: '![](13fig19.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](13fig19.jpg)'
- en: Your map is still not complete, however, because you want some roads and the
    New Orleans city boundary. The following listing shows the code to add these.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你的地图仍然不完整，因为你还想添加一些道路和纽奥良的城市边界。下面的列表显示了添加这些内容的代码。
- en: Listing 13.10\. Adding the roads and city outline
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表13.10。添加道路和城市轮廓
- en: '![](ch13ex10-0.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](ch13ex10-0.jpg)'
- en: '![](ch13ex10-1.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](ch13ex10-1.jpg)'
- en: Only a few new things were added in this example. This first is that you specify
    the spatial reference when creating the roads layer. This is necessary because
    this particular shapefile uses WGS84 instead of NAD83\. You could use a Proj.4
    string, as you did with the map spatial reference information, but you opt for
    an EPSG code instead. Notice that you use two rules for the roads style so that
    you can draw primary roads a little fatter than secondary and tertiary roads.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中只添加了几个新内容。第一个是，在创建道路层时指定空间参考。这是必要的，因为这个特定的shapefile使用WGS84而不是NAD83。你可以使用Proj.4字符串，就像你使用地图空间参考信息那样，但你选择使用EPSG代码。注意，你为道路样式使用了两个规则，这样你可以绘制比次要和三级道路稍粗的主干道路。
- en: The second new concept is that you can create color objects using HTML named
    colors, as well. This is the technique you use to create the black line for the
    city outline. But you also want the city outline to be dashed instead of solid,
    so you edit the line’s stroke property to make it dashed. The first parameter
    to `add_dash` is the length of the dash in pixels, and the second is the length
    of the gap between the dashes.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个新概念是，你也可以使用HTML命名颜色创建颜色对象。这是你用来创建城市轮廓黑色线条的技术。但你还希望城市轮廓是虚线而不是实线，因此你编辑线条的描边属性使其变为虚线。`add_dash`的第一个参数是虚线的像素长度，第二个参数是虚线之间的间隙长度。
- en: The result of adding all of this code to your script is shown in [figure 13.20](#ch13fig20).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些代码添加到脚本中的结果是[图13.20](#ch13fig20)所示。
- en: Figure 13.20\. Line styles added in order to draw roads and the city outline
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.20。为了绘制道路和城市轮廓而添加的线条样式
- en: '![](13fig20.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](13fig20.jpg)'
- en: 13.2.2\. Storing information as XML
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.2. 将信息存储为XML
- en: 'If you use certain styles or layers often, you can store the relevant information
    in XML files that can be loaded from your script. You can also store entire maps
    this way, meaning that you can create a map using XML and then render it with
    Mapnik. If you’d like to see what one of these files looks like, add this line
    of code to the end of your script:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你经常使用某些样式或层，你可以将相关信息存储在可以从你的脚本中加载的XML文件中。你也可以这样存储整个地图，这意味着你可以使用XML创建地图，然后使用Mapnik渲染它。如果你想看看这些文件的样子，请将此行代码添加到脚本末尾：
- en: '[PRE30]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To render the map described in this XML file to an image, write a script that
    imports Mapnik and then loads the XML and saves the output like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此XML文件描述的地图渲染为图像，请编写一个导入Mapnik的脚本，然后加载XML并保存输出如下：
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: That is pretty much the entire script. You do still have to create a map object
    with the desired size and bounding box, but the layers and styles are pulled from
    the XML file.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是整个脚本。你仍然需要创建一个具有所需大小和边界框的地图对象，但层和样式是从XML文件中提取的。
- en: You aren’t stuck using only the information contained in the XML, however, so
    you can use this technique to store commonly used layers or styles. For example,
    if you use the hydrography dataset from the National Atlas often, you can store
    its information in an XML file and load it in your scripts. Pull the code pertaining
    to the atlas layer out of your earlier script and use it to create a new script
    that saves the necessary XML. The following listing shows what you need.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你不必仅使用 XML 中包含的信息，因此你可以使用这种技术来存储常用的层或样式。例如，如果你经常使用国家地图的水文数据集，你可以将其信息存储在一个
    XML 文件中，并在你的脚本中加载它。将有关地图层的代码从早期的脚本中提取出来，并使用它来创建一个新的脚本，该脚本保存必要的 XML。以下列表显示了你需要的内容。
- en: Listing 13.11\. Create XML to describe the National Atlas hydrography layer
  id: totrans-205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.11\. 创建 XML 描述国家地图水文层
- en: '[PRE32]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This script creates the styles used by the National Atlas layer, including the
    filters that are specific to that layer’s attribute table. It also creates the
    layer and appends the style to it. The SRS is added to the layer, too, because
    your scripts that load this file may not use the same SRS as this particular layer.
    The style and layer are both added to a dummy map object that’s used to save the
    information. The size of the map doesn’t matter because that will be determined
    by the script that loads the XML.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本创建用于国家地图层的样式，包括特定于该层属性表的过滤器。它还创建了层并将样式附加到它上。SRS 也添加到层中，因为加载此文件的脚本可能不会使用与该特定层相同的
    SRS。样式和层都添加到一个虚拟地图对象中，用于保存信息。地图的大小无关紧要，因为这将由加载 XML 的脚本确定。
- en: The resulting XML looks like the following listing.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 XML 看起来如下列表。
- en: Listing 13.12\. XML describing the National Atlas hydrography layer
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.12\. 描述国家地图水文层的 XML
- en: '[PRE33]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, the XML is straightforward, so you might even want to define
    your layers this way from the beginning instead of writing code. Either way, once
    you have this file, you can delete all of the code from [listing 13.9](#ch13ex09)
    that creates the atlas layer and style (that’s more than 20 lines) and then replace
    this
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，XML 很简单，所以你可能甚至想从一开始就使用这种方式定义你的层，而不是编写代码。无论如何，一旦你有了这个文件，你可以删除 [列表 13.9](#ch13ex09)
    中创建地图层和样式的所有代码（那超过 20 行），然后替换为
- en: '[PRE34]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'with this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下内容：
- en: '[PRE35]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Obviously, this technique will simplify your life if you use the same layers
    in multiple maps and is worth looking into.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果你在多个地图中使用相同的层，这种技术将简化你的生活，值得研究。
- en: 13.2.3\. Drawing raster data
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.3\. 绘制栅格数据
- en: Now that you know the basics of drawing vector data with Mapnik, it’s time to
    create a simple graphic using raster data. The following listing creates an image
    that displays a topo map for Mount St. Helens.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了使用 Mapnik 绘制矢量数据的基础，是时候创建一个使用栅格数据的简单图形了。以下列表创建了一个显示圣海伦斯山地形图的图像。
- en: Listing 13.13\. Drawing a raster
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.13\. 绘制栅格
- en: '![](316fig01_alt.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](316fig01_alt.jpg)'
- en: Much of this example should look familiar, because it’s similar to the vector
    example. The main differences are that you use a GDAL data source instead of a
    shapefile and you use a simple raster symbolizer with no options. Unlike the shapefile
    examples, though, you do have to specify an SRS for the raster data source even
    if it matches the map’s SRS. Other than that, the process of creating rules, styles,
    and layers is still the same. The output graphic looks like [figure 13.21](#ch13fig21).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这个例子应该看起来很熟悉，因为它与矢量示例类似。主要区别在于你使用 GDAL 数据源而不是 shapefile，并且使用了一个没有选项的简单栅格符号化器。然而，与
    shapefile 示例不同的是，即使它与地图的 SRS 匹配，你也必须指定栅格数据源的 SRS。除此之外，创建规则、样式和层的流程仍然是相同的。输出图形看起来像[图
    13.21](#ch13fig21)。
- en: Figure 13.21\. A raster plot of a topo map
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.21\. 地形图的栅格图
- en: '![](13fig21.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](13fig21.jpg)'
- en: This image could use a little help, though. One common technique for making
    something like this more aesthetically pleasing is to overlay it on a *hillshade*
    dataset to give it depth. A hillshade is created by assuming a height and angle
    for a light source, and determining where the shadows would fall based on a digital
    elevation model ([figure 13.22](#ch13fig22)). The next listing shows how to put
    a hillshade derived from the Mount St. Helens DEM underneath this topo map to
    get a figure like 13.23.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，这张图片可能需要一点帮助。使类似这样的东西更具美学吸引力的一种常见技术是将它叠加在 *高程阴影* 数据集上，以赋予它深度。高程阴影是通过假设光源的高度和角度，并根据数字高程模型确定阴影落在哪里来创建的（[图
    13.22](#ch13fig22)）。下一个列表显示了如何将来自圣海伦斯山 DEM 的高程阴影放在这个拓扑图下面，以得到类似 13.23 的图像。
- en: Figure 13.22\. A digital elevation model of Mount St. Helens on the left, and
    a hillshade derived from the DEM on the right
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.22\. 左侧为圣海伦斯山的数字高程模型，右侧为由 DEM 衍生的高程阴影
- en: '![](13fig22.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](13fig22.jpg)'
- en: Listing 13.14\. Using a hillshade
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.14\. 使用高程阴影
- en: '![](ch13ex14-0.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch13ex14-0.jpg)'
- en: '![](ch13ex14-1.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch13ex14-1.jpg)'
- en: In this example, the hillshade layer is added exactly the same way as the topo
    layer was added previously, but this time you make one change to the topo layer’s
    symbolizer. Because you want the topo layer to be semitransparent to let the hillshade
    layer show through, you change the opacity property to a value of 0.6\. A value
    of 1.0 (the default) makes the layer fully opaque, so the hillshade layer might
    as well not even be there. A value of 0 is fully transparent, so you’d only see
    the hillshade. You can play with this value to see what level of transparency
    you like best, but [figure 13.23](#ch13fig23) shows what effect a value of 0.6
    has.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，高程层是按照之前添加拓扑层的方式添加的，但这次您对拓扑层的符号化器进行了一项更改。因为您希望拓扑层半透明，以便让高程层显示出来，所以您将不透明度属性更改为
    0.6。值为 1.0（默认值）使图层完全不透明，因此高程层几乎可以忽略不计。值为 0 完全透明，因此您只能看到高程层。您可以调整这个值，看看您最喜欢哪种透明度级别，但[图
    13.23](#ch13fig23) 展示了 0.6 值的效果。
- en: Figure 13.23\. A topo raster drawn partly transparent so that an underlying
    hillshade layer provides shadows
  id: totrans-230
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.23\. 部分透明的拓扑栅格图，其下方的阴影层提供阴影
- en: '![](13fig23.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图片](13fig23.jpg)'
- en: 13.3\. Summary
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3\. 概述
- en: The matplotlib module is a general-purpose plotting module for Python and works
    well for quickly visualizing data.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: matplotlib 模块是 Python 的一个通用绘图模块，适用于快速可视化数据。
- en: You can use the matplotlib interactive mode to see immediately what effect something
    has.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 matplotlib 交互模式立即看到某个效果。
- en: Use the Mapnik module if you want prettier maps and images than what you can
    easily get with matplotlib.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想要比使用 matplotlib 更容易获得的更漂亮的地图和图像，请使用 Mapnik 模块。
- en: You can store Mapnik styles and layers in XML files to make them easily reusable.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将 Mapnik 样式和图层存储在 XML 文件中，以便它们易于重复使用。
