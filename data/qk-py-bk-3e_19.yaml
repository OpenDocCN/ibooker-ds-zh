- en: Chapter 17\. Data types as objects
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第17章\. 数据类型作为对象
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Treating types as objects
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将类型视为对象
- en: Using types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类型
- en: Creating user-defined classes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用户定义的类
- en: Understanding duck typing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解鸭子类型
- en: Using special method attributes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特殊方法属性
- en: Subclassing built-in types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类化内置类型
- en: By now, you’ve learned the basic Python types as well as how to create your
    own data types using classes. For many languages, that would be pretty much it
    as far as data types are concerned. But Python is dynamically typed, meaning that
    types are determined at runtime, not at compile time. This fact is one of the
    reasons Python is so easy to use. It also makes it possible, and sometimes necessary,
    to compute with the types of objects (not just the objects themselves).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学习了基本的Python类型以及如何使用类创建自己的数据类型。对于许多语言来说，这基本上就是数据类型了。但Python是动态类型的，这意味着类型是在运行时确定的，而不是在编译时。这是Python易于使用的原因之一。它还使得计算对象的类型（而不仅仅是对象本身）成为可能，有时甚至是必要的。
- en: 17.1\. Types are objects, too
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.1\. 类型也是对象
- en: 'Fire up a Python session, and try out the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个Python会话，尝试以下操作：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This example is the first time you’ve seen the built-in `type` function in Python.
    It can be applied to any Python object and returns the type of that object. In
    this example, the function tells you that `5` is an `int` (integer) and that `['hello',
    'goodbye']` is a `list`—things that you probably already knew.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你第一次在Python中看到内置的`type`函数。它可以应用于任何Python对象，并返回该对象的类型。在这个例子中，该函数告诉你`5`是`int`（整数），而`['hello',
    'goodbye']`是`list`——这些你可能已经知道了。
- en: 'Of greater interest is the fact that Python returns objects in response to
    the calls to type; `<class ''int''>` and `<class ''list''>` are the screen representations
    of the returned objects. What sort of object is returned by a call of `type(5)`?
    You have an easy way of finding out. Just use `type` on that result:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的是，Python在调用类型时返回对象；`<class 'int'>`和`<class 'list'>`是返回对象的屏幕表示。`type(5)`的调用返回什么类型的对象？你有一个简单的方法可以找到答案。只需使用`type`在该结果上：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The object returned by `type` is an object whose type happens to be `<class
    'type'>`; you can call it a *type object*. A type object is another kind of Python
    object whose only outstanding feature is the confusion that its name sometime
    causes. Saying a type object is of type `<class 'type'>` has about the same degree
    of clarity as the old Abbott and Costello “Who’s on First?” comedy routine.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`type`函数返回的对象的类型恰好是`<class ''type''>`；你可以称之为*类型对象*。类型对象是另一种Python对象，它唯一的突出特点是它有时会引起的困惑。说类型对象是类型`<class
    ''type''>`与老艾博特和科斯特洛的“谁是第一？”喜剧节目有相同的清晰度。'
- en: 17.2\. Using types
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.2\. 使用类型
- en: 'Now that you know that data types can be represented as Python type objects,
    what can you do with them? You can compare them, because any two Python objects
    can be compared:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道数据类型可以表示为Python类型对象，你能用它们做什么呢？你可以比较它们，因为任何两个Python对象都可以进行比较：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The types of `"Hello"` and `"Goodbye"` are the same (they’re both strings),
    but the types of `"Hello"` and `5` are different. Among other things, you can
    use this technique to provide type checking in your function and method definitions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`"Hello"`和`"Goodbye"`的类型相同（它们都是字符串），但`"Hello"`和`5`的类型不同。除此之外，你还可以使用这种技术在你的函数和方法定义中提供类型检查。'
- en: 17.3\. Types and user-defined classes
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.3\. 类型与用户定义的类
- en: 'The most common reason to be interested in the types of objects, particularly
    instances of user-defined classes, is to find out whether a particular object
    is an instance of a class. After determining that an object is of a particular
    type, the code can treat it appropriately. An example makes things much clearer.
    To start, define a couple of empty classes so as to set up a simple inheritance
    hierarchy:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对象类型的兴趣最常见的原因是找出特定对象是否是用户定义类的实例。在确定对象是特定类型之后，代码可以适当地处理它。一个例子可以使事情更加清晰。首先，定义几个空类，以便设置一个简单的继承层次结构：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now create an instance of class `B`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个`B`类的实例：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As expected, applying the `type` function to `b` tells you that `b` is an instance
    of the class `B` that’s defined in your current `__main__` namespace:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，将`type`函数应用于`b`会告诉你`b`是当前`__main__`命名空间中定义的`B`类的实例：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can also obtain exactly the same information by accessing the instance’s
    special `__class__` attribute:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过访问实例的特殊`__class__`属性来获得完全相同的信息：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You’ll be working with that class quite a bit to extract further information,
    so store it somewhere:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你将相当频繁地使用该类来提取更多信息，所以请将其存储在某个地方：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, to emphasize that everything in Python is an object, prove that the class
    you obtained from `b` is the class you defined under the name `B`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了强调 Python 中的一切都是对象，证明从 `b` 获取的类是你用 `B` 的名称定义的类：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, you didn’t need to store the class of `b`—you already had it—but
    I want to make clear that a class is just another Python object and can be stored
    or passed around like any Python object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你不需要存储 `b` 的类——你已经有它了，但我想要明确指出，一个类只是另一个 Python 对象，可以像任何 Python 对象一样存储或传递。
- en: 'Given the class of `b`, you can find the name of that class by using its `__name___`
    attribute:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 给定 `b` 的类，你可以通过使用其 `__name__` 属性来找到该类的名称：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And you can find out what classes a class inherits from by accessing its `__bases__`
    attribute, which contains a tuple of all of its base classes:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问其 `__bases__` 属性来找出一个类继承自哪些类，该属性包含一个包含所有基类的元组：
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Used together, `__class__`, `__bases__`, and `__name__` allow a full analysis
    of the class inheritance structure associated with any instance.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 结合使用 `__class__`、`__bases__` 和 `__name__` 属性，可以对任何实例关联的类继承结构进行全面分析。
- en: 'But two built-in functions provide a more user-friendly way of obtaining most
    of the information you usually need: `isinstance` and `issubclass`. The `isinstance`
    function is what you should use to determine whether, for example, a class passed
    into a function or method is of the expected type:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 但有两个内置函数提供了更用户友好的方式来获取你通常需要的大部分信息：`isinstance` 和 `issubclass`。`isinstance` 函数是你应该用来确定，例如，传递给函数或方法的类是否为预期类型：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `issubclass` function is only for class types.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`issubclass` 函数仅适用于类类型。'
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For class instances, check against the class ***1***. `e` is an instance of
    class `D` because `E` inherits from `D` ***2***. But `d` isn’t an instance of
    class `E` ***3***. For other types, you can use an example ***4***. A class is
    considered to be a subclass of itself ***5***.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类实例，检查是否与类 ***1*** 相同。`e` 是类 `D` 的实例，因为 `E` 继承自 `D` ***2***。但 `d` 不是类 `E`
    的实例 ***3***。对于其他类型，你可以使用一个例子 ***4***。一个类被认为是其自身的子类 ***5***。
- en: '|  |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: Types'
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：类型
- en: Suppose that you want to make sure that object `x` is a list before you try
    appending to it. What code would you use? What would be the difference between
    using `type()` and `isinstance()`? Would this be the look before you leap (LBYL)
    or easier to ask forgiveness than permission (EAFP) of programming? What other
    options might you have besides checking the type explicitly?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想在尝试向对象 `x` 添加内容之前确保 `x` 是一个列表。你会使用什么代码？使用 `type()` 和 `isinstance()` 之间的区别是什么？这会是“跳之前先看”（LBYL）还是编程中更容易请求宽恕而不是许可（EAFP）？除了显式检查类型之外，你还有哪些其他选择？
- en: '|  |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 17.4\. Duck typing
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.4. 鸭式类型
- en: 'Using `type`, `isinstance`, and `issubclass` makes it fairly easy to make code
    correctly determine an object’s or class’s inheritance hierarchy. Although this
    process is easy, Python also has a feature that makes using objects even easier:
    duck typing. *Duck typing* (as in “If it walks like a duck and quacks like a duck,
    it probably *is* a duck”) refers to Python’s way of determining whether an object
    is the required type for an operation, focusing on an object’s interface rather
    than its type. If an operation needs an iterator, for example, the object used
    doesn’t need to be a subclass of any particular iterator or of any iterator at
    all. All that matters is that the object used as an iterator is able to yield
    a series of objects in the expected way.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `type`、`isinstance` 和 `issubclass` 使得代码能够正确地确定对象或类的继承层次结构变得相当容易。尽管这个过程很简单，Python
    还有一个使使用对象更加容易的功能：鸭式类型。*鸭式类型*（正如“如果它像鸭子走路，像鸭子嘎嘎叫，它可能就是一只鸭子”）指的是 Python 确定对象是否为操作所需类型的做法，它关注的是对象的接口而不是其类型。例如，如果操作需要一个迭代器，所使用的对象不需要是任何特定迭代器的子类，也不需要是任何迭代器的子类。唯一重要的是，用作迭代器的对象能够以预期的方式产生一系列对象。
- en: By contrast, in a language like Java, stricter rules of inheritance are enforced.
    In short, duck typing means that in Python, you don’t need to (and probably shouldn’t)
    worry about type-checking function or method arguments and the like. Instead,
    you should rely on readable and documented code combined with thorough testing
    to make sure that an object “quacks like a duck” as needed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，在像Java这样的语言中，会强制执行更严格的继承规则。简而言之，鸭子类型意味着在Python中，你不需要（并且可能不应该）担心类型检查函数或方法参数等。相反，你应该依靠可读性和文档化的代码，以及彻底的测试，以确保对象“像鸭子一样叫”。
- en: Duck typing can increase the flexibility of well-written code and, combined
    with the more advanced object-oriented features, gives you the ability to create
    classes and objects to cover almost any situation.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 鸭子类型可以增加代码的灵活性，并结合更高级的面向对象特性，使你能够创建类和对象来覆盖几乎所有情况。
- en: 17.5\. What is a special method attribute?
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.5. 什么是特殊方法属性？
- en: A *special method attribute* is an attribute of a Python class with a special
    meaning to Python. It’s defined as a method but isn’t intended to be used directly
    as such. Special methods aren’t usually directly invoked; instead, they’re called
    automatically by Python in response to a demand made on an object of that class.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*特殊方法属性* 是Python类的一个属性，它对Python有特殊的意义。它被定义为一个方法，但不打算直接这样使用。特殊方法通常不是直接调用的；相反，它们是在对那个类的对象提出要求时由Python自动调用的。'
- en: Perhaps the simplest example is the `__str__` special method attribute. If it’s
    defined in a class, any time an instance of that class is used where Python requires
    a user-readable string representation of that instance, the `__str__` method attribute
    is invoked, and the value it returns is used as the required string. To see this
    attribute in action, define a class representing red, green, and blue (RGB) colors
    as a triplet of numbers, one each for red, green, and blue intensities. As well
    as defining the standard `__init__` method to initialize instances of the class,
    define a `__str__` method to return strings representing instances in a reasonably
    human-friendly format. Your definition should look something like this.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最简单的例子是 `__str__` 特殊方法属性。如果它在类中定义，那么每次在Python需要用户可读的实例字符串表示时，都会调用该类的 `__str__`
    方法属性，并使用它返回的值作为所需的字符串。为了看到这个属性的作用，定义一个表示红色、绿色和蓝色（RGB）颜色的类，它是一个包含三个数字的三元组，分别代表红色、绿色和蓝色的强度。除了定义标准的
    `__init__` 方法来初始化类的实例外，还定义一个 `__str__` 方法来返回以合理的人性化格式表示实例的字符串。你的定义应该看起来像这样。
- en: Listing 17.1\. File color_module.py
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 17.1. 文件 color_module.py
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you put this definition into a file called color_module.py, you can load
    it and use it in the normal manner:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这个定义放入一个名为 color_module.py 的文件中，你可以加载它并以正常方式使用它：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can see the presence of the `__str__` special method attribute if you use
    `print` to print out `c`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `print` 打印 `c`，你可以看到 `__str__` 特殊方法属性的存在：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Even though your `__str__` special method attribute hasn’t been explicitly invoked
    by any of your code, it has nonetheless been used by Python, which knows that
    the `__str__` attribute (if present) defines a method to convert objects into
    user-readable strings. This characteristic is the defining one of special method
    attributes; it allows you to define functionality that hooks into Python in special
    ways. Among other things, special method attributes can be used to define classes
    whose objects behave in a fashion that’s syntactically and semantically equivalent
    to lists or dictionaries. You could, for example, use this ability to define objects
    that are used in exactly the same manner as Python lists but that use balanced
    trees rather than arrays to store data. To a programmer, such objects would appear
    to be lists, but with faster inserts, slower iterations, and certain other performance
    differences that presumably would be advantageous in the problem at hand.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你的 `__str__` 特殊方法属性没有被你的代码明确调用，Python仍然使用了它，因为Python知道 `__str__` 属性（如果存在）定义了一个将对象转换为用户可读字符串的方法。这是特殊方法属性的定义性特征；它允许你以特殊的方式定义功能，使其与Python挂钩。在其他方面，特殊方法属性可以用来定义对象，这些对象的行为在语法和语义上与列表或字典相当。例如，你可以使用这种能力来定义对象，这些对象的使用方式与Python列表完全相同，但使用平衡树而不是数组来存储数据。对于程序员来说，这样的对象看起来像是列表，但具有更快的插入、更慢的迭代和某些其他性能差异，这些差异可能有利于手头的任务。
- en: The rest of this chapter covers longer examples using special method attributes.
    The chapter doesn’t discuss all of Python’s available special method attributes,
    but it does expose you to the concept in enough detail that you can easily use
    the other special attribute methods, all of which are defined in the standard
    library documentation for built-in types.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分将涵盖使用特殊方法属性的更长的例子。本章并没有讨论Python所有可用的特殊方法属性，但它确实详细介绍了这个概念，使你可以轻松地使用其他特殊属性方法，所有这些方法都在内置类型的标准库文档中定义。
- en: 17.6\. Making an object behave like a list
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.6\. 使对象表现得像列表
- en: 'This sample problem involves a large text file containing records of people;
    each record consists of a single line containing the person’s name, age, and place
    of residence, with a double semicolon (`::`) between the fields. A few lines from
    such a file might look like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例问题涉及一个包含人们记录的大文本文件；每个记录由包含个人姓名、年龄和居住地的单行组成，字段之间用双分号（`::`）分隔。这样一个文件的一些行可能看起来像这样：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Suppose that you need to collect information about the distribution of ages
    of people in the file. There are many ways the lines in this file could be processed.
    Here’s one way:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要收集关于文件中人们年龄分布的信息。处理这个文件中的行有好多方法。这里有一种方法：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: That technique would work in theory, but it reads the entire file into memory
    at once. If the file were too large to be held in memory (and these files potentially
    are that large), the program wouldn’t work.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在理论上可行，但它会一次性将整个文件读入内存。如果文件太大而无法放入内存（这些文件可能就是那么大），程序将无法工作。
- en: 'Another way to attack the problem is this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的另一种方法是：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This code would get around the problem of having too little memory by reading
    in only one line at a time. It would work fine, but suppose that you wanted to
    make opening the file even simpler and that you wanted to get only the first two
    fields (name and age) of the lines in the file. You’d need something that could,
    at least for the purposes of a `for` loop, treat a text file as a list of lines
    but without reading the entire text file in at once.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码通过一次只读取一行来绕过内存不足的问题。它将正常工作，但假设你想要使打开文件更加简单，并且只想获取文件中的行的前两个字段（姓名和年龄）。你需要某种东西，至少在`for`循环的目的上，可以将文本文件当作行列表来处理，但不必一次性读取整个文本文件。
- en: 17.7\. The __getitem__ special method attribute
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.7\. `__getitem__` 特殊方法属性
- en: A solution is to use the `__getitem__` special method attribute, which you can
    define in any user-defined class, to enable instances of that class to respond
    to list access syntax and semantics. If `AClass` is a Python class that defines
    `__getitem__`, and `obj` is an instance of that class, things like `x = obj[n]`
    and `for x in obj:` are meaningful; `obj` may be used in much the same way as
    a list.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一个解决方案是使用`__getitem__`特殊方法属性，你可以在任何用户定义的类中定义它，以使该类的实例能够响应列表访问语法和语义。如果`AClass`是一个定义了`__getitem__`的Python类，并且`obj`是该类的一个实例，那么像`x
    = obj[n]`和`for x in obj:`这样的操作是有意义的；`obj`可以像列表一样使用。
- en: 'Here’s the resulting code (explanations follow):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是生成的代码（解释随后）：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* Opens file for reading**'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打开文件进行读取**'
- en: '***2* Tries to read line**'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 尝试读取行**'
- en: '***3* If no more data ...**'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果没有更多数据 ...**'
- en: '***4* ... closes fileobject ...**'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* ... 关闭文件对象 ...**'
- en: '***5* ... and raises IndexError**'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* ... 并引发`IndexError`**'
- en: '***6* Otherwise, splits line, returns first two fields**'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 否则，分割行，返回前两个字段**'
- en: At first glance, this example may look worse than the previous solution because
    there’s more code, and it’s difficult to understand. But most of that code is
    in a class, which can be put into its own module, such as the `myutils` module.
    Then the program becomes
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，这个例子可能看起来比之前的解决方案更糟糕，因为代码更多，难以理解。但大部分代码都在一个类中，可以被放入它自己的模块中，例如`myutils`模块。然后程序就变成了
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `LineReader` class handles all the details of opening the file, reading
    in lines one at a time, and closing the file. At the cost of somewhat more initial
    development time, it provides a tool that makes working with one-record-per-line
    large text files easier and less error-prone. Note that Python already has several
    powerful ways to read files, but this example has the advantage that it’s fairly
    easy to understand. When you get the idea, you can apply the same principle in
    many situations.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`LineReader`类处理打开文件、逐行读取和关闭文件的全部细节。虽然需要稍微多一点初始开发时间，但它提供了一个工具，使得处理每行一个记录的大文本文件变得更加容易且错误率更低。请注意，Python已经提供了几种强大的读取文件的方法，但这个例子有一个优点，那就是它相当容易理解。当你理解了这个概念后，你可以在许多情况下应用相同的原理。'
- en: 17.7.1\. How it works
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 17.7.1. 它是如何工作的
- en: '`LineReader` is a class, and the `__init__` method opens the named file for
    reading and stores the opened `fileobject` for later access. To understand the
    use of the `__getitem__` method, you need to know the following three points:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`LineReader`是一个类，`__init__`方法打开指定的文件以供读取，并将打开的`fileobject`存储起来以供后续访问。要理解`__getitem__`方法的使用，你需要知道以下三个要点：'
- en: 'Any object that defines `__getitem__` as an instance method can return elements
    as though it were a list: all accesses of the form `object[i]` are transformed
    by Python into a method invocation of the form `object.__getitem__(i)`, which
    is handled as a normal method invocation. It’s ultimately executed as `__getitem__(object,
    i)`, using the version of `__getitem__` defined in the class. The first argument
    of each call of `__getitem__` is the object from which data is being extracted,
    and the second argument is the index of that data.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何定义了`__getitem__`作为实例方法的对象都可以像列表一样返回元素：所有形式为`object[i]`的访问都被Python转换为形式为`object.__getitem__(i)`的方法调用，这被当作正常方法调用处理。它最终执行为`__getitem__(object,
    i)`，使用类中定义的`__getitem__`版本。`__getitem__`每次调用的第一个参数是从中提取数据的对象，第二个参数是数据的索引。
- en: Because `for` loops access each piece of data in a list, one at a time, a loop
    of the form `for arg in sequence:` works by calling `__getitem__` over and over
    again, with sequentially increasing indexes. The `for` loop first sets `arg` to
    `sequence.__getitem__(0)`, then to `sequence.__getitem__(1)`, and so on.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为`for`循环逐个访问列表中的每条数据，所以形式为`for arg in sequence:`的循环通过反复调用`__getitem__`并使用递增的索引来实现。`for`循环首先将`arg`设置为`sequence.__getitem__(0)`，然后设置为`sequence.__getitem__(1)`，依此类推。
- en: A `for` loop catches `IndexError` exceptions and handles them by exiting the
    loop. This process is how `for` loops are terminated when used with normal lists
    or sequences.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`循环捕获`IndexError`异常并通过退出循环来处理它们。这就是在正常列表或序列中使用时`for`循环终止的过程。'
- en: 'The `LineReader` class is intended for use only with and inside a `for` loop,
    and the `for` loop always generates calls with a uniformly increasing index: `__getitem__(self,
    0)`, `__getitem__(self, 1)`, `__getitem__(self, 2)`, and so on. The previous code
    takes advantage of this knowledge and returns lines one after the other, ignoring
    the `index` argument.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`LineReader`类仅用于`for`循环中，并且`for`循环始终生成具有均匀递增索引的调用：`__getitem__(self, 0)`、`__getitem__(self,
    1)`、`__getitem__(self, 2)`等等。前面的代码利用了这一知识，逐行返回行，忽略`index`参数。'
- en: With this knowledge, understanding how a `LineReader` object emulates a sequence
    in a `for` loop is easy. Each iteration of the loop causes the special Python
    attribute method `__getitem__` to be invoked on the object; as a result, the object
    reads in the next line from its stored `fileobject` and examines that line. If
    the line is nonempty, it’s returned. An empty line means that the end of the file
    has been reached; the object closes the `fileobject` and raises the `IndexError`
    exception. `IndexError` is caught by the enclosing `for` loop, which then terminates.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些知识，理解`LineReader`对象如何在`for`循环中模拟序列是很容易的。循环的每次迭代都会在对象上调用特殊的Python属性方法`__getitem__`；结果，对象从其存储的`fileobject`中读取下一行并检查该行。如果该行非空，则返回。空行意味着已到达文件末尾；对象关闭`fileobject`并引发`IndexError`异常。`IndexError`被外层的`for`循环捕获，然后循环终止。
- en: Remember that this example is here for illustrative purposes only. Usually,
    iterating over the lines of a file by using the `for line in fileobject:` type
    of loop is sufficient, but this example does show how easy it is in Python to
    create objects that behave like lists or other types.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这个例子只是为了说明目的。通常，通过使用`for line in fileobject:`类型的循环遍历文件的行是足够的，但这个例子确实展示了在Python中创建类似列表或其他类型的对象是多么容易。
- en: '|  |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: __getitem__'
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：__getitem__
- en: The example use of `__getitem__` is very limited and won’t work correctly in
    many situations. What are some cases in which the implementation above will fail
    or work incorrectly?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`__getitem__` 的示例使用非常有限，在许多情况下无法正确工作。在哪些情况下上述实现将失败或工作不正确？'
- en: '|  |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 17.7.2\. Implementing full list functionality
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 17.7.2. 实现完整的列表功能
- en: In the previous example, an object of the `LineReader` class behaves like a
    list object only to the extent that it correctly responds to sequential accesses
    of the lines in the file it’s reading from. You may wonder how this functionality
    can be expanded to make `LineReader` (or other) objects behave more like a list.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`LineReader` 类的对象仅在其正确响应从其读取的文件中的行顺序访问的范围内表现得像列表对象。你可能想知道如何扩展这种功能，使
    `LineReader`（或其他）对象表现得更像列表。
- en: First, the `__getitem__` method should handle its index argument in some way.
    Because the whole point of the `LineReader` class is to avoid reading a large
    file into memory, it wouldn’t make sense to have the entire file in memory and
    return the appropriate line. Probably the smartest thing to do would be to check
    that each index in a `__getitem__` call is one greater than the index from the
    previous `__getitem__` call (or is 0, for the first call of `__getitem__` on a
    `LineReader` instance) and to raise an error if this isn’t the case. This practice
    would ensure that `LineReader` instances are used only in `for` loops as was intended.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`__getitem__` 方法应以某种方式处理其索引参数。因为 `LineReader` 类的全部目的是避免将大文件读入内存，所以将整个文件保留在内存中并返回适当的行是没有意义的。最明智的做法可能是检查
    `__getitem__` 调用中的每个索引都比前一个 `__getitem__` 调用中的索引大一个（或者对于 `LineReader` 实例上的 `__getitem__`
    的第一次调用是 0）并且如果情况不是这样则引发错误。这种做法将确保 `LineReader` 实例仅按预期在 `for` 循环中使用。
- en: More generally, Python provides several special method attributes relating to
    list behavior. `__setitem__` provides a way of defining what should be done when
    an object is used in the syntactic context of a list assignment, `obj[n] = val`.
    Some other special method attributes provide less-obvious list functionality,
    such as the `__add__` attribute, which enables objects to respond to the `+` operator
    and hence to perform their version of list concatenation. Several other special
    methods also need to be defined before a class fully emulates a list, but you
    can achieve complete list emulation by defining the appropriate Python special
    method attributes. The next section gives an example that goes farther toward
    implementing a full list emulation class.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 更普遍地，Python 提供了几个与列表行为相关的特殊方法属性。`__setitem__` 提供了一种定义当对象在列表赋值语法上下文中使用时应该执行什么操作的方法，即
    `obj[n] = val`。一些其他特殊方法属性提供了不那么明显的列表功能，例如 `__add__` 属性，它使对象能够响应 `+` 操作符，从而执行其列表连接版本。在类完全模拟列表之前，还需要定义几个其他特殊方法，但通过定义适当的
    Python 特殊方法属性，你可以实现完整的列表模拟。下一节提供了一个示例，展示了如何实现一个完整的列表模拟类。
- en: 17.8\. Giving an object full list capability
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.8. 给对象赋予完整的列表能力
- en: '`__getitem__` is one of many Python special function attributes that may be
    defined in a class to permit instances of that class to display special behavior.
    To see how special method attributes can be carried farther, effectively integrating
    new abilities into Python in a seamless manner, look at another, more comprehensive
    example.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`__getitem__` 是许多 Python 特殊函数属性之一，可以在类中定义，以允许该类的实例显示特殊行为。要了解特殊方法属性如何进一步扩展，有效地以无缝的方式将新能力集成到
    Python 中，请查看另一个更全面的示例。'
- en: When lists are used, it’s common for any particular list to contain elements
    of only one type, such as a list of strings or a list of numbers. Some languages,
    such as C++, have the ability to enforce this restriction. In large programs,
    the ability to declare a list as containing a certain type of element can help
    you track down errors. An attempt to add an element of the wrong type to a typed
    list results in an error message, potentially identifying a problem at an earlier
    stage of program development than would otherwise be the case.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用列表时，通常任何特定的列表只包含一种类型的元素，例如字符串列表或数字列表。一些语言，如 C++，具有强制执行这种限制的能力。在大型程序中，声明列表包含特定类型的元素可以帮助你追踪错误。尝试将错误类型的元素添加到类型列表中会导致错误消息，这可能会在程序开发的早期阶段识别出问题，否则可能不会发生。
- en: 'Python doesn’t have typed lists built in, and most Python coders don’t miss
    them. But if you’re concerned about enforcing the homogeneity of a list, special
    method attributes make it easy to create a class that behaves like a typed list.
    Here’s the beginning of such a class (which makes extensive use of the Python
    built-in `type` and `isinstance` functions to check the type of objects):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Python 内置没有类型列表，大多数 Python 开发者并不觉得缺少它们。但是，如果你关心强制列表的同质性，特殊方法属性可以让你轻松创建一个表现得像类型列表的类。以下是这样的一个类的开头（它广泛使用了
    Python 内置的 `type` 和 `isinstance` 函数来检查对象类型）：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `example_element` argument defines the type that this list can contain by
    providing an example of the type of element ***1***.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`example_element` 参数通过提供一个元素类型的示例来定义这个列表可以包含的类型 ***1***。'
- en: The `TypedList` class, as defined here, gives you the ability to make a call
    of the form
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里定义的 `TypedList` 类，让你能够进行如下形式的调用
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first argument, `'Hello'`, isn’t incorporated into the resulting data structure
    at all. It’s used as an example of the type of element the list must contain (strings,
    in this case). The second argument is an optional list that can be used to give
    an initial list of values. The `__init__` function for the `TypedList` class checks
    that any list elements, passed in when a `TypedList` instance is created, are
    of the same type as the example value given. If there are any type mismatches,
    an exception is raised.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数，`'Hello'`，根本没有被包含到结果的数据结构中。它被用作一个例子，说明列表必须包含的元素类型（在这种情况下是字符串）。第二个参数是一个可选的列表，可以用来提供一个初始值列表。`TypedList`
    类的 `__init__` 函数会检查在创建 `TypedList` 实例时传入的任何列表元素是否与提供的示例值类型相同。如果有任何类型不匹配，则会引发异常。
- en: 'This version of the `TypedList` class can’t be used as a list, because it doesn’t
    respond to the standard methods for setting or accessing list elements. To fix
    this problem, you need to define the `__setitem__` and `__getitem__` special method
    attributes. The `__setitem__` method is called automatically by Python any time
    a statement of the form `TypedListInstance[i] = value` is executed, and the `__getitem__`
    method is called any time the expression `TypedListInstance[i]` is evaluated to
    return the value in the *i*th slot of `TypedListInstance`. Here’s the next version
    of the `TypedList` class. Because you’ll be type-checking a lot of new elements,
    this function is abstracted out into the new private method `__check`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的 `TypedList` 类不能用作列表，因为它不响应设置或访问列表元素的常规方法。要解决这个问题，你需要定义 `__setitem__` 和
    `__getitem__` 特殊方法属性。`__setitem__` 方法在执行形式为 `TypedListInstance[i] = value` 的语句时由
    Python 自动调用，而 `__getitem__` 方法在任何表达式 `TypedListInstance[i]` 被评估以返回 `TypedListInstance`
    中第 *i* 个槽位的值时被调用。以下是 `TypedList` 类的下一个版本。因为你将要对许多新元素进行类型检查，所以这个函数被抽象成新的私有方法 `__check`：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now instances of the `TypedList` class look more like lists. The following
    code is valid, for example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `TypedList` 类的实例看起来更像列表了。例如，以下代码是有效的：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The accesses of elements of `x` in the `print` statement are handled by `__getitem__`,
    which passes them down to the list instance stored in the `TypedList` object.
    The assignments to `x[2]` and `x[3]` are handled by `__setitem__`, which checks
    that the element being assigned into the list is of the appropriate type and then
    performs the assignment on the list contained in `self.elements`. The last line
    uses `__getitem__` to unpack the first five items in `x` and then pack them into
    the variables `a`, `b`, `c`, `d`, and e, respectively. The calls to `__getitem__`
    and `__setitem__` are made automatically by Python.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `print` 语句中对 `x` 的元素访问由 `__getitem__` 处理，它将这些元素传递到存储在 `TypedList` 对象中的列表实例。对
    `x[2]` 和 `x[3]` 的赋值由 `__setitem__` 处理，它会检查被赋值的元素是否为适当的类型，然后对 `self.elements` 中包含的列表执行赋值操作。最后一行使用
    `__getitem__` 来解包 `x` 的前五个元素，然后将它们分别打包到变量 `a`、`b`、`c`、`d` 和 `e` 中。`__getitem__`
    和 `__setitem__` 的调用是由 Python 自动进行的。
- en: Completion of the `TypedList` class, so that `TypedList` objects behave in all
    respects like list objects, requires more code. The special method attributes
    `__setitem__` and `__getitem__` should be defined so that `TypedList` instances
    can handle slice notation as well as single item access. `__add__` should be defined
    so that list addition (concatenation) can be performed, and `__mul__` should be
    defined so that list multiplication can be performed. `__len__` should be defined
    so that calls of `len(TypedListInstance)` are evaluated correctly. `__delitem__`
    should be defined so that the `TypedList` class can handle `del` statements correctly.
    Also, an `append` method should be defined so that elements can be appended to
    `TypedList` instances by means of the standard list-style `append`, as well as
    `insert` and `extend` methods.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 完成 `TypedList` 类，以便 `TypedList` 对象在所有方面都像列表对象一样表现，需要更多的代码。特殊方法属性 `__setitem__`
    和 `__getitem__` 应该被定义，以便 `TypedList` 实例可以处理切片表示法以及单个项访问。`__add__` 应该被定义，以便可以进行列表添加（连接）。`__mul__`
    应该被定义，以便可以进行列表乘法。`__len__` 应该被定义，以便 `len(TypedListInstance)` 的调用可以正确评估。`__delitem__`
    应该被定义，以便 `TypedList` 类可以正确处理 `del` 语句。此外，还应该定义一个 `append` 方法，以便可以通过标准的列表样式 `append`、`insert`
    和 `extend` 方法将元素附加到 `TypedList` 实例上。
- en: '|  |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Implementing list special methods'
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这样做：实现列表特殊方法
- en: Try implementing the `__len__` and `__delitem__` special methods, as well as
    an `append` method.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试实现特殊方法 `__len__` 和 `__delitem__`，以及一个 `append` 方法。
- en: '|  |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 17.9\. Subclassing from built-in types
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.9\. 从内置类型子类化
- en: The previous example makes for a good exercise in understanding how to implement
    a listlike class from scratch, but it’s also a lot of work. In practice, if you
    were planning to implement your own listlike structure along the lines demonstrated
    here, you might instead consider subclassing the list type or the `UserList` type.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例是理解如何从头实现一个类似列表的类的良好练习，但这也是一项大量工作。在实践中，如果你打算按照这里展示的方式实现自己的类似列表的结构，你可能会考虑子类化列表类型或
    `UserList` 类型。
- en: 17.9.1\. Subclassing list
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 17.9.1\. 子类化列表
- en: 'Instead of creating a class for a typed list from scratch, as you did in the
    previous examples, you can subclass the list type and override all the methods
    that need to be aware of the allowed type. One big advantage of this approach
    is that your class has default versions of all list operations because it’s a
    list already. The main thing to keep in mind is that every type in Python is a
    class, and if you need a variation on the behavior of a built-in type, you may
    want to consider subclassing that type:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前示例中从头开始创建一个类型列表的类不同，你可以通过子类化列表类型并覆盖所有需要知道允许类型的方来做到这一点。这种方法的一个主要优点是，由于它已经是一个列表，因此你的类具有所有列表操作的默认版本。需要记住的主要事情是，Python
    中的每个类型都是一个类，如果你需要内置类型的某种行为变化，你可能需要考虑子类化该类型：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note that all that you need to do in this case is implement a method to check
    the type of items being added and then tweak `__setitem__` to make that check
    before calling `list`’s regular `__setitem__` method. Other methods, such as `sort`
    and `del`, work without any further coding. Overloading a built-in type can save
    a fair amount of time if you need only a few variations in its behavior, because
    the bulk of the class can be used unchanged.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，你需要做的只是实现一个方法来检查要添加的项目类型，然后调整 `__setitem__` 在调用列表的常规 `__setitem__`
    方法之前进行该检查。其他方法，如 `sort` 和 `del`，无需进一步编码即可工作。如果你只需要在行为上做少量变化，重载内置类型可以节省相当多的时间，因为类的大部分内容可以保持不变。
- en: 17.9.2\. Subclassing UserList
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 17.9.2\. 子类化 UserList
- en: 'If you need a variation on a list (as in the previous examples), there’s a
    third alternative: You can subclass the `UserList` class, a list wrapper class
    found in the `collections` module. `UserList` was created for earlier versions
    of Python when subclassing the list type wasn’t possible, but it’s still useful,
    particularly for the current situation, because the underlying list is available
    as the `data` attribute:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个与列表不同的变体（如前例所示），还有一个第三种选择：你可以子类化 `UserList` 类，这是一个在 `collections` 模块中找到的列表包装类。`UserList`
    是为 Python 的早期版本创建的，当时无法子类化列表类型，但它仍然很有用，尤其是在当前情况下，因为底层列表作为 `data` 属性可用：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This example is much the same as subclassing `list`, except that in the implementation
    of the class, the list of items is available internally as the `data` member.
    In some situations, having direct access to the underlying data structure can
    be useful. Also, in addition to `UserList`, there are `UserDict` and `UserString`
    wrapper classes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子与子类化 `list` 非常相似，只是在类的实现中，项目列表作为 `data` 成员内部可用。在某些情况下，直接访问底层数据结构可能很有用。此外，除了
    `UserList`，还有 `UserDict` 和 `UserString` 包装类。
- en: 17.10\. When to use special method attributes
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.10. 何时使用特殊方法属性
- en: As a rule, it’s a good idea to be somewhat cautious with the use of special
    method attributes. Other programmers who need to work with your code may wonder
    why one sequence-type object responds correctly to standard indexing notation,
    whereas another doesn’t.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在使用特殊方法属性时要谨慎。其他需要与你代码一起工作的程序员可能会想知道为什么一个序列类型对象能够正确响应标准索引符号，而另一个则不能。
- en: 'My general guidelines are to use special method attributes in either of two
    situations:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我的一般指导原则是在以下两种情况下使用特殊方法属性：
- en: If I have a frequently used class in my own code that behaves in some respects
    like a Python built-in type, I’ll define such special method attributes as useful.
    This situation occurs most often with objects that behave like sequences in one
    way or another.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我在自己的代码中有一个经常使用的类，它在某些方面类似于 Python 内置类型，我会定义这样的特殊方法属性作为有用的。这种情况最常见于以某种方式表现像序列的对象。
- en: If I have a class that behaves identically or almost identically to a built-in
    class, I may choose to define all of the appropriate special function attributes
    or subclass the built-in Python type and distribute the class. An example of the
    latter solution might be lists implemented as balanced trees so that access is
    slower but insertion is faster than with standard lists.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我有一个与内置类行为相同或几乎相同的类，我可能会选择定义所有适当特殊函数属性或子类化内置 Python 类型并将类分发出去。后者解决方案的一个例子可能是将列表实现为平衡树，这样访问速度较慢但插入速度比标准列表快。
- en: These rules aren’t hard-and-fast rules. It’s often a good idea to define the
    `__str__` special method attribute for a class, for example, so that you can say
    `print(instance)` in debugging code and get an informative, nice-looking representation
    of your object printed to the screen.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则并不是一成不变的。例如，定义类的 `__str__` 特殊方法属性通常是一个好主意，这样你就可以在调试代码中使用 `print(instance)`
    并在屏幕上打印出有信息量和良好外观的对象表示。
- en: '|  |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: Special method attributes and subclassing existing types'
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：特殊方法属性和现有类型的子类化
- en: Suppose that you want a dictionary-like type that allows only strings as keys
    (maybe to make it work like a `shelf` object, as described in [chapter 13](kindle_split_024.html#ch13)).
    What options would you have for creating such a class? What would be the advantages
    and disadvantages of each option?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要一个类似字典的类型，只允许字符串作为键（可能为了使其像第 13 章中描述的 `shelf` 对象那样工作）。你有哪些创建此类类的选项？每种选项的优点和缺点是什么？
- en: '|  |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Python has the tools to do type checking as needed in your code, but by taking
    advantage of duck typing, you can write more flexible code that doesn’t need to
    be as concerned with type checking.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 有工具可以在你的代码中进行类型检查，但通过利用鸭子类型，你可以编写更灵活的代码，无需过于关注类型检查。
- en: Special method attributes and subclassing built-in classes can be used to add
    listlike behavior to user-created classes.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特殊方法属性和内置类的子类化可以用于向用户创建的类添加类似列表的行为。
- en: Python’s use of duck typing, special method attributes, and subclassing makes
    it possible to construct and combine classes in a variety of ways.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 使用鸭子类型、特殊方法属性和子类化，使得以多种方式构建和组合类成为可能。
