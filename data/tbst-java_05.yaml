- en: 4 Debugging apps remotely
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 远程调试应用程序
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Debugging an app installed in a remote environment
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试远程环境中的应用程序
- en: Upskilling debugging techniques with a hands-on example
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过实际示例提升调试技术
- en: One of my friends recently had a problem where a particular part of the software
    he was implementing was very slow. Generally, when we have these types of performance
    issues, we suspect that an I/O interface is the cause (e.g., a connection to a
    database or reading or writing in a file). Remember from chapter 1 that such interfaces
    often slow down apps, so they are a likely suspect. But in my friend’s case, interfaces
    were not the issue.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我的一个朋友最近遇到了一个问题，他在实施软件时，某个特定部分运行得非常慢。通常，当我们遇到这类性能问题时，我们会怀疑是I/O接口的原因（例如，数据库连接或读写文件）。记得在第一章中提到，这类接口往往会减慢应用程序的速度，因此它们很可能是罪魁祸首。但在我的朋友的情况下，接口并不是问题所在。
- en: The performance issue was caused by the simple generation of a random value
    (a universally unique identifier [UUID] stored in the database). The operating
    system uses hardware sources (e.g., mouse movements, the keyboard, etc.) to collect
    randomness, referred to as *entropy*. The app uses this randomness to generate
    random values. But when we deploy the app in a virtualized environment such as
    a virtual machine or a container (which is pretty common for app deployments today),
    the operating system has fewer sources to create its entropy. Thus, sometimes
    there’s not enough entropy for the app to create the random values it needs. This
    situation causes performance problems and, in some cases, can have a negative
    impact on the app’s security.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 性能问题是由简单地生成一个随机值（存储在数据库中的通用唯一标识符[UUID]）引起的。操作系统使用硬件来源（例如，鼠标移动、键盘等）来收集随机性，这被称为*熵*。应用程序使用这种随机性来生成随机值。但是，当我们在一个虚拟化环境中部署应用程序，如虚拟机或容器（这在今天的应用程序部署中相当常见）时，操作系统用于创建熵的来源就减少了。因此，有时应用程序创建所需随机值的熵可能不足。这种情况会导致性能问题，在某些情况下，可能会对应用程序的安全性产生负面影响。
- en: This type of problem can be really challenging to investigate without connecting
    directly to the environment in which the problem occurs. For such scenarios, remote
    debugging can be the solution. You can only examine certain cases in particular
    environments. Suppose your client observes an issue, but the problem doesn’t occur
    when you run the app on your computer. You definitely cannot solve it by simply
    telling your client, “It works on my machine.”
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 没有直接连接到问题发生的环境，这种问题很难调查。对于这类场景，远程调试可能是解决方案。你只能在特定环境中检查某些情况。假设你的客户观察到问题，但你在自己的电脑上运行应用程序时问题并没有发生。你绝对不能仅仅通过告诉你的客户“在我的机器上它运行正常”来解决这个问题。
- en: You need to connect to the environment in which the problem occurs when you
    cannot reproduce the issue on your computer. Although sometimes you don’t have
    any other options, and you have to take the challenging path of trying to fix
    a problem you can’t re-create, at other times, the environment is open for remote
    debugging. *Remote debugging*, or debugging an app installed in an external environment,
    is the subject of this chapter (see figure 4.1).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在电脑上无法重现问题时，你需要连接到问题发生的环境。虽然有时你没有任何其他选择，不得不尝试修复你无法重现的问题，但在其他时候，环境是开放的，可以进行远程调试。*远程调试*，或调试外部环境中的应用程序，是本章的主题（见图4.1）。
- en: '![](../../OEBPS/Images/CH04_F01_Spilca3.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH04_F01_Spilca3.png)'
- en: Figure 4.1 Remotely debugging an app. The developer can run the debugger tool
    locally but connect it to an app instance running in a different environment.
    This approach allows the developer to investigate problems that only occur in
    specific environments.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 远程调试应用程序。开发者可以在本地运行调试工具，但将其连接到在另一个环境中运行的应用程序实例。这种方法允许开发者调查仅在特定环境中出现的问题。
- en: We’ll start the chapter by discussing what remote debugging is and when you
    can expect to use it, as well as when you should not use this method. Then, to
    apply this technique, we’ll look at an issue to investigate. You’ll learn how
    an app needs to be configured to remotely debug it and how to connect and use
    the debugger for a remote environment.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将本章从讨论远程调试是什么以及你何时可以期望使用它开始，以及何时不应使用这种方法。然后，为了应用这项技术，我们将研究一个需要调查的问题。你将了解应用程序需要如何配置才能进行远程调试，以及如何连接和使用远程环境的调试器。
- en: 4.1 What is remote debugging?
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 什么是远程调试？
- en: In this section, we discuss what remote debugging is, when to use it, and when
    to avoid it. Remote debugging is nothing more than applying the debugging techniques
    you learned in chapters 2 and 3 on an app that doesn’t run locally on your system
    but instead runs in an outside environment. Why would you need to use such techniques
    in a remote environment? To answer this question, let’s briefly review a typical
    software development process.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论远程调试是什么，何时使用它，以及何时避免使用它。远程调试不过是将你在第2章和第3章中学到的调试技术应用于一个不在你系统本地运行而是在外部环境中运行的应用程序。为什么你需要在一个远程环境中使用这些技术呢？为了回答这个问题，让我们简要回顾一下典型的软件开发过程。
- en: When developers implement an app, they don’t write it for their local systems.
    The final purpose of an app is to deploy it in a production environment where
    it helps users solve various business problems. Moreover, when implementing the
    software, we often don’t deploy the app directly in users’ environments, or *production
    environments*. Instead, we use similar environments to roughly test the capabilities
    and fixes we need to implement before installing them in an environment where
    they are officially used with real data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者实现一个应用程序时，他们并不是为他们的本地系统编写的。应用程序的最终目的是将其部署到生产环境中，在那里它可以帮助用户解决各种业务问题。此外，在实现软件时，我们通常不会直接在用户的或生产环境中部署应用程序，而是使用类似的环境来大致测试我们需要实现的功能和修复，然后再将它们安装到官方使用真实数据的正式环境中。
- en: '![](../../OEBPS/Images/CH04_F02_Spilca3.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2](../../OEBPS/Images/CH04_F02_Spilca3.png)'
- en: Figure 4.2 When building a real-world app, developers often use multiple environments.
    First, they build the app in development (dev) environments. Then, once a feature
    or a solution is ready, they present it to users (or stakeholders of the app)
    using a user acceptance test (UAT) environment. Finally, after the stakeholders
    confirm that the implementation works, they install it in a production (prod)
    environment.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 当构建现实世界的应用程序时，开发者通常会使用多个环境。首先，他们在开发（dev）环境中构建应用程序。然后，一旦某个功能或解决方案准备就绪，他们就会使用用户验收测试（UAT）环境向用户（或应用程序的利益相关者）展示。最后，在利益相关者确认实现可行之后，他们将应用程序安装到生产（prod）环境中。
- en: 'As described in figure 4.2, a development team uses at least three environments
    when developing an app:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如图4.2所示，开发团队在开发应用程序时至少使用三个环境：
- en: '*The development environment (dev**)*—An environment similar to where the app
    will be deployed. Developers mainly use this environment to test new capabilities
    and fixes they implement after developing them on their local system.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开发环境（dev）*——一个类似于应用程序将部署的环境。开发者主要使用这个环境来测试他们在本地系统上开发后实现的新功能和修复。'
- en: '*The user acceptance test environment (UAT**)*—Once successfully tested in
    the development environment, the app is installed in the user acceptance test
    environment. Users can test the new implementations and fixes and confirm they
    work before the app is delivered to an environment with real data.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用户验收测试环境（UAT）*——一旦在开发环境中成功测试，应用程序就被安装到用户验收测试环境中。用户可以测试新的实现和修复，并在应用程序交付到包含真实数据的真实环境中之前确认它们是否可行。'
- en: '*The production environment (prod**)*—After users confirm a new implementation
    works as expected and they feel comfortable using it, the app is installed in
    the production environment.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*生产环境（prod）*——在用户确认新的实现按预期工作并且他们感到舒适使用之后，应用程序被安装到生产环境中。'
- en: 'But what if an implementation works on your local computer but behaves differently
    in another environment? You might wonder how an app can work differently. Even
    when using the same compiled app, we can observe differences in the app’s behavior
    between two different environments. Some reasons for these differences include
    the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果某个实现在你本地计算机上运行正常，但在另一个环境中表现不同，你会怎么想呢？你可能想知道为什么一个应用程序可以以不同的方式工作。即使使用相同的编译应用程序，我们也可以观察到两个不同环境中应用程序行为的差异。这些差异的原因可能包括以下几方面：
- en: The data available in the app’s environments is different. Different environments
    use different database instances, different configuration files, and so on.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序环境中可用的数据不同。不同的环境使用不同的数据库实例、不同的配置文件等等。
- en: The operating systems in which the app is installed are not the same.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序安装的操作系统可能不同。
- en: The way the deployment is orchestrated may be different. For example, one environment
    may use virtual machines for the deployment, while another uses a containerized
    solution.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署的编排方式可能不同。例如，一个环境可能使用虚拟机进行部署，而另一个则使用容器化解决方案。
- en: Permission setup may be different in each environment.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个环境中的权限设置可能不同。
- en: The environments may have different resources (allocated memory or CPU).
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境可能具有不同的资源（分配的内存或CPU）。
- en: These are just some of the many things that can make a given output or behavior
    different. The last time I had such a problem (not long ago), the app produced
    a different output due to a request that was being sent to a web service the app
    used in the implemented use case. Because of security issues, we couldn’t use
    the same endpoint in the dev environment, and we couldn’t connect to the one the
    app used in the environment with the problem. These conditions made the investigation
    challenging (honestly, we didn’t even consider that an endpoint was the cause
    of our issue until we started debugging).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是众多可能导致特定输出或行为不同的因素中的一部分。上一次我遇到这样的问题（不久前），应用程序由于在实现的使用案例中向使用的网络服务发送的请求不同，产生了不同的输出。由于安全问题，我们无法在开发环境中使用相同的端点，也无法连接到应用程序在出现问题的环境中使用的端点。这些条件使得调查变得具有挑战性（老实说，直到我们开始调试，我们甚至都没有考虑过端点是问题的原因）。
- en: 'Remote debugging can really help you to understand the software behavior faster
    in these types of cases. However, keep one crucial piece of advice in mind: never
    use remote debugging in the production environment (figure 4.3). Also, make sure
    you always understand the main differences between the environments you use.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，远程调试真的可以帮助你更快地理解软件行为。然而，请记住一条重要的建议：永远不要在生产环境中使用远程调试（图4.3）。同时，确保你始终了解你使用的环境之间的主要差异。
- en: TIP Paying attention to how the environments differ from one another gives you
    clues as to what could go wrong. It can even spare you the time of investigating
    an issue in which simply knowing these details will empirically give you the answer
    to a problem.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 注意不同环境之间的差异，这会给你提供可能出错线索。这甚至可以节省你调查问题的宝贵时间，仅凭这些细节就可以经验性地给出问题的答案。
- en: '![](../../OEBPS/Images/icon_guy.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/icon_guy.png)'
- en: '![](../../OEBPS/Images/CH04_F03_Spilca3.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH04_F03_Spilca3.png)'
- en: Figure 4.3 Developers implement the app using the dev and UAT environments.
    It’s OK to debug apps in these environments. But remember, never debug apps in
    the prod environment, as this can affect the app’s execution, interfere with users’
    actions, and even expose sensitive data, creating a security vulnerability.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 开发者使用开发和UAT环境实现应用程序。在这些环境中调试应用程序是可以的。但请记住，永远不要在生产环境中调试应用程序，因为这可能会影响应用程序的执行，干扰用户的操作，甚至暴露敏感数据，从而创建安全漏洞。
- en: 'As you’ll learn, you need to attach a piece of software we name *agent* to
    the app execution to enable remote debugging. Some of the consequences of attaching
    the debugging agent (and why you shouldn’t do this in a production environment)
    include these:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将学到的，你需要将我们称之为*代理*的软件附加到应用程序执行中，以启用远程调试。附加调试代理的一些后果（以及为什么你不应该在生产环境中这样做）包括以下内容：
- en: The agent can slow the app’s execution; this slowness can cause performance
    problems.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理可以减慢应用程序的执行；这种缓慢可能会导致性能问题。
- en: The agent needs to communicate with the debugger tool through the network. To
    enable this, you need to make specific ports available, which can cause vulnerability
    issues.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理需要通过网络与调试工具进行通信。为了启用这一点，你需要打开特定的端口，这可能会引起安全漏洞问题。
- en: Debugging a specific piece of code can interfere with functionality if the same
    part of the app is being used elsewhere simultaneously.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试特定的代码片段可能会干扰功能，如果应用程序的同一部分同时被其他地方使用。
- en: Sometimes debugging can block the app indefinitely and force you to restart
    the process.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时调试可能会无限期地阻止应用程序，并迫使你重新启动进程。
- en: 4.2 Investigating in remote environments
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 在远程环境中进行调查
- en: In this section, we consider debugging an app that runs in a remote environment.
    I’ll start by describing the scenario in section 4.2.1\. Then, in section 4.2.2,
    using an app provided with this book (project da-ch4-ex1), we will discuss how
    to start an app for remote debugging and how to attach a debugger to the remotely
    running app using the techniques you learned in chapters 2 and 3.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们考虑调试在远程环境中运行的应用程序。我将首先在第4.2.1节中描述场景。然后，在第4.2.2节中，我们将使用本书提供的应用程序（项目da-ch4-ex1），讨论如何启动应用程序以进行远程调试，以及如何使用你在第2章和第3章中学到的技术将调试器附加到远程运行的应用程序上。
- en: 4.2.1 The scenario
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 情景
- en: Suppose you work on a team that implements and maintains a large application
    many clients use to manage their product inventory. Recently, your team implemented
    a new capability that helps your clients easily manage their costs. The team successfully
    tested the behavior in the dev environment and installed the app in the UAT environment
    to allow users to validate the feature before moving it to production. However,
    the person responsible for testing the new capability informs you that the web
    interface where the new data should be displayed shows nothing.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在一个团队中工作，该团队实施并维护了一个大型应用，许多客户使用该应用来管理他们的产品库存。最近，你的团队实施了一个新的功能，帮助客户轻松管理他们的成本。团队在开发环境中成功测试了行为，并在UAT环境中安装了应用，以便在将其移至生产之前允许用户验证该功能。然而，负责测试新功能的人告诉你，应该显示新数据的Web界面没有任何显示。
- en: Concerned, you take a look and quickly see that the problem is not the frontend.
    But an endpoint on the backend seems to behave weirdly. When the endpoint is called
    in the UAT environment, the HTTP response status code is 200 OK, but the app doesn’t
    return the data in the HTTP response (figure 4.4). You check the logs, but nothing
    shows there either. Since you can’t observe the problem locally or in the dev
    environment, you decide to remotely connect your debugger in the UAT environment
    to find the cause of this issue.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 感到担忧，你查看了一下，很快发现问题不在于前端。但后端的某个端点似乎表现异常。当在UAT环境中调用该端点时，HTTP响应状态码为200 OK，但应用没有在HTTP响应中返回数据（图4.4）。你检查了日志，但那里也没有任何显示。由于你无法在本地或开发环境中观察到这个问题，你决定在UAT环境中远程连接你的调试器以找到这个问题的原因。
- en: Note Even if we discuss debugging an app running in a remote environment, to
    make the example simpler, we use the local system to run the app, to which we
    connect remotely. For this reason, you’ll see in the figures that I use “localhost”
    to access the environment running the app. In a real-world scenario, the app would
    run on a different system, which would be identified with an IP address or DNS
    name.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：即使我们讨论的是在远程环境中运行的应用的调试，为了使示例更简单，我们使用本地系统来运行应用，然后远程连接到它。因此，你会在图中看到我使用“localhost”来访问运行应用的环境。在现实世界的场景中，应用将运行在不同的系统上，该系统将使用IP地址或DNS名称来标识。
- en: '![](../../OEBPS/Images/CH04_F04_Spilca3.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH04_F04_Spilca3.png)'
- en: Figure 4.4 The scenario you have to investigate. The `/api/product/total/costs`
    endpoint should return the total costs from the database. Instead, when a request
    is sent to the endpoint, the app behaves oddly. The HTTP status is 200 OK, but
    the total costs, which you expected to be a list of values, comes back null.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 你需要调查的场景。`/api/product/total/costs`端点应该从数据库返回总成本。相反，当向端点发送请求时，应用表现异常。HTTP状态是200
    OK，但你预期的总成本，一个值列表，返回为null。
- en: 4.2.2 Finding issues in remote environments
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 在远程环境中查找问题
- en: In this section, we use remote debugging to investigate the case study described
    in section 4.2.1\. We start by configuring and running the app to connect to a
    remote debugger and then attach the debugger to start our investigation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用远程调试来调查4.2.1节中描述的案例研究。我们首先配置并运行应用以连接到远程调试器，然后将调试器附加到应用以开始调查。
- en: The app would already be running in a real-world case and most likely wouldn’t
    be already configured to allow remote debugging. Therefore, we begin with starting
    the app so that you are aware of the full picture of remote debugging and know
    the prerequisites of such an approach.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的案例中，应用已经运行，并且很可能还没有配置为允许远程调试。因此，我们首先启动应用，这样你就能了解远程调试的全貌，并知道这种方法的先决条件。
- en: When starting the app that you want to remotely debug, you need to make sure
    you attach a debugger agent to the execution. To attach a debugger agent to a
    Java app execution, you add the `-agentlib:jdwp` parameter to the `java` command
    line, as in figure 4.5\. You must specify the port number to which you’ll attach
    the debugger tool. Basically, the debug agent acts as a server, listening for
    a debugger tool to connect on the configured port and allowing the tool to run
    the debug operations (pausing the execution on a breakpoint, stepping over, stepping
    into, etc.).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当启动你想要远程调试的应用时，你需要确保将调试代理附加到执行中。要将调试代理附加到Java应用执行，你需要在`java`命令行中添加`-agentlib:jdwp`参数，如图4.5所示。你必须指定你将附加调试工具的端口号。基本上，调试代理充当服务器，监听在配置的端口上连接的调试工具，并允许工具运行调试操作（在断点处暂停执行、单步执行、进入等）。
- en: '![](../../OEBPS/Images/CH04_F05_Spilca3.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH04_F05_Spilca3.png)'
- en: Figure 4.5 When debugging an app locally, the IDE attaches the debugger. But
    when running an app in a remote environment, you must attach a debugger agent
    at the app start yourself.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 当在本地调试应用程序时，IDE 会附加调试器。但当你在一个远程环境中运行应用程序时，你必须自己在一个应用程序启动时附加调试器代理。
- en: 'You can copy this command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以复制此命令：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Notice the few configurations specified in the command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意命令中指定的少量配置：
- en: '`transport=dt_socket` configures the way the debugger tool communicates with
    the debugger agent. The `dt_socket` configuration means we use TCP/IP to establish
    the communication over a network. This is always how you establish the communication
    between the agent and the tool.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transport=dt_socket` 配置了调试工具与调试器代理之间的通信方式。`dt_socket` 配置意味着我们使用 TCP/IP 在网络上建立通信。这始终是建立代理和工具之间通信的方式。'
- en: '`server=y` means the agent acts as a server after attaching to the app execution.
    The agent waits for a debugger tool to connect to it and control the app execution
    through it. You would use the `server=n` configuration to connect to a debugger
    agent rather than starting one.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`server=y` 表示代理在附加到应用程序执行后充当服务器。代理等待调试工具连接到它，并通过它控制应用程序的执行。你可以使用 `server=n`
    配置来连接到调试器代理而不是启动一个。'
- en: '`suspend=n` tells the app to start without waiting for a debugger tool to connect.
    If you want to prevent the app from starting until you connect a debugger, you
    need to use `suspend=y`. In our case, we have a web app, and the problem appears
    when calling one of its endpoints, so we need the app to start before it can call
    the endpoint. If we were investigating a problem with the server boot process,
    we would most likely need to use `suspend=y` to allow the app to start only after
    we have the debugger tool connected.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`suspend=n` 告诉应用程序在没有等待调试工具连接的情况下启动。如果你想防止应用程序在你连接调试器之前启动，你需要使用 `suspend=y`。在我们的例子中，我们有一个网络应用程序，问题出现在调用其端点时，因此我们需要在应用程序能够调用端点之前启动应用程序。如果我们正在调查服务器启动过程的问题，我们很可能需要使用
    `suspend=y` 来允许应用程序在调试工具连接后才能启动。'
- en: '`address=*:5005` tells the agent to open port 5005 on the system, the port
    to which the debugger tool will connect to communicate with the agent. The port
    value must not already be in use on the system, and the network needs to permit
    the communication between the debugger tool and the agent (the port needs to be
    opened in the network).'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`address=*:5005` 告诉代理在系统上打开端口 5005，这是调试工具将连接以与代理通信的端口。端口号必须在系统上未被使用，并且网络需要允许调试工具和代理之间的通信（端口需要在网络中打开）。'
- en: Figure 4.6 shows the app, starting with the debugger agent attached. Notice
    the message printed in the console right after the command tells us the agent
    is listening on the configured port 5005.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 显示了应用程序，从附加了调试器代理开始。注意命令执行后立即在控制台打印的消息告诉我们代理正在监听配置的端口 5005。
- en: '![](../../OEBPS/Images/CH04_F06_Spilca3.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH04_F06_Spilca3.png)'
- en: Figure 4.6 When you run the command to start the app, you can see that the app
    begins executing. At the same time, you can see that the debugging agent printed
    a line showing that it is listening for a debugger to attach on the configured
    port 5005.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 当你运行启动应用程序的命令时，你可以看到应用程序开始执行。同时，你可以看到调试代理打印了一条消息，表明它正在配置的端口 5005 上监听调试器的附加。
- en: Once your remote app has a debugger agent attached, you can connect the debugger
    to start investigating the issue. Remember, we assume that the network is configured
    to allow communication between the two apps (the debugger tool and the debugger
    agent). We run both on the localhost for our example, so for our demonstration,
    such networking configurations are not an issue.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的远程应用程序附加了调试器代理，你就可以连接调试器以开始调查问题。记住，我们假设网络已配置为允许两个应用程序（调试工具和调试器代理）之间的通信。在我们的例子中，我们都在本地主机上运行，所以对于我们的演示，这样的网络配置不是问题。
- en: But in a real-world scenario, you should always make sure you can establish
    the communication before you start to debug. In most cases, you’ll likely need
    someone on the infrastructure team to help you open the needed port if communication
    is not allowed. Remember that, usually, ports are, by default, closed for communication
    for security reasons.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但在实际场景中，你应该在开始调试之前始终确保可以建立通信。在大多数情况下，你可能需要基础设施团队的人帮助你打开所需的端口，如果通信不被允许的话。记住，通常出于安全原因，端口默认是关闭以供通信的。
- en: 'Next, we’ll examine how to attach the debugger to a remote app using IntelliJ
    IDEA Community. The steps to run the debugger on the app running in a remote environment
    are as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将检查如何使用IntelliJ IDEA Community将调试器附加到远程应用。在远程环境中运行的应用程序上运行调试器的步骤如下：
- en: Add a new running configuration.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的运行配置。
- en: Configure the remote address (IP address and port) of the debugger agent.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置调试代理的远程地址（IP地址和端口）。
- en: Start debugging the app.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始调试应用。
- en: '![](../../OEBPS/Images/CH04_F07_Spilca3.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH04_F07_Spilca3.png)'
- en: Figure 4.7 You can use an IDE to configure the debugger to attach to an already
    running app in a particular environment, as long as the app has a debugger agent
    attached to it. In IntelliJ IDEA Community, you need to create a new running configuration
    to tell the debugger to attach to an already running app. You can add a new run
    configuration by selecting Edit Configurations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 您可以使用IDE配置调试器以附加到特定环境中的已运行应用，只要应用已附加调试代理。在IntelliJ IDEA Community中，您需要创建一个新的运行配置来告诉调试器附加到已运行的应用。您可以通过选择“编辑配置”来添加新的运行配置。
- en: Figure 4.7 shows you how to open the Edit Configurations section to add a new
    running configuration.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7展示了如何打开“编辑配置”部分以添加新的运行配置。
- en: '![](../../OEBPS/Images/CH04_F08_Spilca3.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH04_F08_Spilca3.png)'
- en: Figure 4.8 Once you’ve selected Edit Configurations, you can add a new configuration.
    First, click the plus icon, and then Add New Configuration.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 一旦您选择了“编辑配置”，您就可以添加新的配置。首先，点击加号图标，然后选择“添加新配置”。
- en: Figure 4.8 shows you how to add a new running configuration.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8展示了如何添加新的运行配置。
- en: '![](../../OEBPS/Images/CH04_F09_Spilca3.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH04_F09_Spilca3.png)'
- en: Figure 4.9 Since we want to attach the debugger to an app running in a remote
    environment, select the Remote JVM Debug configuration type.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9 由于我们想要将调试器附加到在远程环境中运行的应用，请选择“远程JVM调试”配置类型。
- en: Since we want to connect to a remote debugger agent, we need to add a new remote
    debugging configuration, as presented in figure 4.9.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要连接到远程调试代理，因此需要添加一个新的远程调试配置，如图4.9所示。
- en: '![](../../OEBPS/Images/CH04_F10_Spilca3.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH04_F10_Spilca3.png)'
- en: Figure 4.10 Give a name to the new configuration you add and specify the address
    of the environment and port you configured the debugger agent to listen on (here,
    port 5005 when starting the app).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10 给您添加的新配置起一个名字，并指定调试代理配置的地址和端口（在此处，启动应用时为端口5005）。
- en: Configure the address of the debugger agent, as shown in figure 4.10\. In our
    case, we are running the app on the same system as the debugger, so we use localhost.
    In a real-world setting, if the app runs on a different system, you’d have to
    use the IP address of that system. We use port 5005 for the agent to listen and
    connect with a debugger tool.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 配置调试代理的地址，如图4.10所示。在我们的情况下，我们在与调试器相同的系统上运行应用，因此我们使用localhost。在实际环境中，如果应用运行在不同的系统上，您将不得不使用该系统的IP地址。我们使用端口5005让代理监听并与调试工具连接。
- en: '![](../../OEBPS/Images/CH04_F11_Spilca3.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH04_F11_Spilca3.png)'
- en: Figure 4.11 The debugger tool that runs on the developer’s computer connects
    to the debugger agent on port 5005\. The debugger agent allows the debugger tool
    to control the app. The app also opens a port, but this port is for its clients
    (the browser, in the case of a web app).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11 在开发者计算机上运行的调试工具连接到端口5005上的调试代理。调试代理允许调试工具控制应用。应用也会打开一个端口，但这个端口是为其客户端（在Web应用的情况下是浏览器）准备的。
- en: Remember that we connect the debugger tool to the debugger agent, which opens
    port 5005 (figure 4.11). Don’t confuse the port opened by the debugger agent (5005)
    with our web app’s port (8080).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们将调试工具连接到调试代理，该代理打开端口5005（图4.11）。不要将调试代理打开的端口（5005）与我们的Web应用端口（8080）混淆。
- en: '![](../../OEBPS/Images/CH04_F12_Spilca3.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH04_F12_Spilca3.png)'
- en: Figure 4.12 You can now run the debugger using the newly added configuration.
    Click the small bug icon to start the debugger.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12 您现在可以使用新添加的配置运行调试器。点击小虫图标以启动调试器。
- en: Once you have a configuration in place, start the debugger (figure 4.12). The
    debugger will start “talking” with the debugger agent attached to the app and
    allow you to control the execution.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置就绪，开始调试器（图4.12）。调试器将与附加到应用的调试代理“对话”，并允许您控制执行。
- en: '![](../../OEBPS/Images/CH04_F13_Spilca3.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH04_F13_Spilca3.png)'
- en: Figure 4.13 The developer needs to make sure they have the same version of source
    code as the one used to generate the app’s executable run in the remote environment.
    Otherwise, the debugger's actions could become inconsistent with the code the
    developer investigates, which would create more confusion than it would help the
    developer understand the app’s behavior.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 开发者需要确保他们拥有的源代码版本与用于在远程环境中生成应用程序可执行文件的版本相同。否则，调试器的操作可能与开发者调查的代码不一致，这可能会比帮助开发者理解应用程序的行为造成更多的困惑。
- en: Now you can use the debugger the same way you learned in chapters 2 and 3\.
    It is important to be careful with the version of the code you use (figure 4.13).
    When locally debugging an application, you know that the IDE compiles the app
    and then attaches the debugger to the freshly compiled code. However, when you
    connect to a remote app, you can no longer be sure that the source code you have
    corresponds to the compiled code of the remote app to which you attach the debugger.
    If the team started on new tasks, code that you need to investigate may have potentially
    been changed, added, or removed in the same classes involved. Using a different
    source code version can lead to strange and confusing debugger behavior. For example,
    the debugger may show that you are navigating empty lines, even lines outside
    the methods or classes. The execution stack trace can also become inconsistent
    with the expected execution.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用调试器的方式与您在第 2 章和第 3 章中学到的方式相同。注意你使用的代码版本很重要（如图 4.13 所示）。当在本地调试应用程序时，您知道
    IDE 编译应用程序，然后将调试器附加到新编译的代码上。然而，当您连接到远程应用程序时，您不能再确定您拥有的源代码是否与您附加调试器的远程应用程序的编译代码相对应。如果团队开始新的任务，您需要调查的代码可能已经在涉及的相同类中进行了更改、添加或删除。使用不同的源代码版本可能导致调试器出现奇怪和令人困惑的行为。例如，调试器可能会显示您正在导航空行，甚至是方法或类之外的行。执行堆栈跟踪也可能与预期的执行不一致。
- en: Fortunately, today we use source code versioning software such as Git or SVN,
    so we can always figure out which version of the source code created the app we
    deployed. Before debugging, you need to make sure you have the same source code
    as the one compiled into the app you want to investigate remotely. Use your source
    code versioning tool to find the exact source code version.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，今天我们使用源代码版本控制软件，如 Git 或 SVN，因此我们可以始终确定创建我们部署的应用程序的源代码版本。在调试之前，您需要确保您拥有的源代码与您想要远程调查的应用程序编译成的源代码相同。使用您的源代码版本控制工具来找到确切的源代码版本。
- en: '![](../../OEBPS/Images/CH04_UN02_Spilca3.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH04_UN02_Spilca3.png)'
- en: 'Let’s add a breakpoint on the first line that raises concerns: line 23 in the
    `ProductService` class, as presented in figure 4.14\. Here, the app should select
    the data from the database to return in the HTTP response. First, I want to determine
    whether the data is correctly retrieved from the database, so I pause the execution
    on this line and step over to see the result.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在引起担忧的第一行设置一个断点：如图 4.14 所示的 `ProductService` 类中的第 23 行。在这里，应用程序应该从数据库中选择要返回到
    HTTP 响应中的数据。首先，我想确定数据是否正确地从数据库中检索出来，所以我在这行暂停执行并单步跳过以查看结果。
- en: '![](../../OEBPS/Images/CH04_F14_Spilca3.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH04_F14_Spilca3.png)'
- en: Figure 4.14 Just as when debugging an app locally, you can add breakpoints and
    use navigation operations. Add a new breakpoint on line 23 in the `ProductService`
    class.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 就像在本地调试应用程序一样，您可以添加断点并使用导航操作。在 `ProductService` 类的第 23 行添加一个新的断点。
- en: After adding the breakpoint, use Postman (or a similar tool) to send the HTTP
    request with the unexpected behavior (figure 4.15). Postman (which you can download
    from [https://www.postman.com/downloads/](https://www.postman.com/downloads/))
    is a simple tool you can use to call a given endpoint, and lately it has become
    one of developers’ favorite tools for this purpose. Postman has a user-friendly
    GUI, but if you prefer the command line, you can choose another tool such as cURL.
    To make the example simple, I use Postman.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加断点后，使用 Postman（或类似工具）发送具有意外行为的 HTTP 请求（如图 4.15 所示）。Postman（您可以从 [https://www.postman.com/downloads/](https://www.postman.com/downloads/)
    下载）是一个简单的工具，您可以使用它来调用给定的端点，并且最近它已经成为开发者们为此目的最喜欢的工具之一。Postman 拥有用户友好的 GUI，但如果您更喜欢命令行，您可以选择其他工具，例如
    cURL。为了使示例简单，我使用 Postman。
- en: '![](../../OEBPS/Images/CH04_F15_Spilca3.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH04_F15_Spilca3.png)'
- en: Figure 4.15 When using Postman to send the request, the response doesn’t come
    back immediately. Instead, Postman waits indefinitely for the response because
    the app paused the execution on the line you marked with a breakpoint.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15 当使用 Postman 发送请求时，响应不会立即返回。相反，Postman 无限期地等待响应，因为应用程序在您设置的断点所在的行上暂停了执行。
- en: Note that Postman doesn’t immediately show the HTTP response. Instead, you see
    that the request remains pending because the debugger paused the app on the line
    you marked with a breakpoint, as shown in figure 4.16\. You can now start using
    the navigation operations to investigate the problem.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Postman 不会立即显示 HTTP 响应。相反，您会看到请求仍然挂起，因为调试器在您标记断点的行上暂停了应用程序，如图 4.16 所示。现在您可以使用导航操作来调查问题。
- en: '![](../../OEBPS/Images/CH04_F16_Spilca3.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH04_F16_Spilca3.png)'
- en: Figure 4.16 The IDE shows that the debugger did indeed pause the execution on
    the line you marked with a breakpoint. Thus, you can use navigation operations
    to continue your investigation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16 IDE 显示调试器确实在您设置的断点所在的行上暂停了执行。因此，您可以使用导航操作继续调查。
- en: 'Using a step over operation, you see that instead of returning the data from
    the database, the app throws an exception (figure 4.17). Now you can start to
    discern the problem:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单步跳过操作，您可以看到应用程序没有从数据库返回数据，而是抛出了异常（图 4.17）。现在您可以开始分析问题：
- en: The developer who implemented this functionality used a primitive type to represent
    a column that could take null values in a database. Since a primitive in Java
    is not an object type and cannot hold the value null, the app throws an exception.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现此功能的开发者使用原始类型来表示数据库中可能包含 null 值的列。由于 Java 中的原始类型不是对象类型，不能持有 null 值，因此应用程序会抛出异常。
- en: The developer used the `printStackTrace()` method to print the exception message,
    which is not helpful because you can’t easily configure the output for various
    environments. This is likely the reason you couldn’t see anything in the logs
    in the first place (to be discussed further in chapter 5).
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发者使用了 `printStackTrace()` 方法来打印异常信息，这并不 helpful，因为您无法轻松地为各种环境配置输出。这可能是您最初在日志中看不到任何内容的原因（将在第
    5 章中进一步讨论）。
- en: The problem did not happen locally or in the dev environment because there were
    no null values for that field in the database.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于数据库中该字段没有 null 值，因此问题没有在本地或开发环境中发生。
- en: '![](../../OEBPS/Images/CH04_F17_Spilca3.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH04_F17_Spilca3.png)'
- en: Figure 4.17 The step over operation shows that the app throws an exception.
    Now you have an idea of what the problem is and can decide how to solve it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17 单步跳过操作显示应用程序抛出了异常。现在您对问题有了了解，可以决定如何解决它。
- en: Clearly, the code needs to be refactored, and maybe an enhancement of the code
    review process should be discussed with the team in the next retrospective meeting.
    Nonetheless, you are happy that you found the cause of the issue and know how
    to solve it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，代码需要重构，也许在下一次回顾会议中应该与团队讨论代码审查过程的增强。尽管如此，您很高兴找到了问题的原因，并知道如何解决它。
- en: Creating a remote configuration in Eclipse IDE
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Eclipse IDE 中创建远程配置
- en: I use IntelliJ IDEA as the primary IDE for the examples of the book. But, as
    I stated in earlier chapters, this book isn’t about using a certain IDE. You can
    apply the techniques we discuss with a variety of tools of your choosing. For
    example, you can do remote debugging with other IDEs, such as Eclipse.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用 IntelliJ IDEA 作为本书示例的主要 IDE。但正如我在前面的章节中所述，这本书并不是关于使用某个特定的 IDE。您可以使用您选择的任何工具应用我们讨论的技术。例如，您可以使用其他
    IDE 进行远程调试，如 Eclipse。
- en: The following figure shows you how to add a new debugging configuration in Eclipse
    IDE.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了如何在 Eclipse IDE 中添加新的调试配置。
- en: '![](../../OEBPS/Images/CH04_UN03_Spilca3.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH04_UN03_Spilca3.png)'
- en: Adding a new debug configuration in Eclipse.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Eclipse 中添加新的调试配置。
- en: To add a new debug configuration in Eclipse IDE, choose Run > Debug Configurations.
    You can configure the debug configuration to attach it to the debugging agent
    controlling the remote app.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Eclipse IDE 中添加新的调试配置，请选择 Run > Debug Configurations。您可以将调试配置配置为附加到控制远程应用程序的调试代理。
- en: Just as in IntelliJ IDEA, you need to configure the debugging agent’s address
    (IP address and port) to which the debugger tool connects.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在 IntelliJ IDEA 中一样，您需要配置调试代理的地址（IP 地址和端口），调试工具将连接到该地址。
- en: '![](../../OEBPS/Images/CH04_UN04_Spilca3.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH04_UN04_Spilca3.png)'
- en: Add a new Remote Java Application debug configuration and set the address of
    the debugger agent. You can then save the configuration and use the debugging
    feature to connect to the app remotely for debugging.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个新的远程 Java 应用程序调试配置，并设置调试代理的地址。然后你可以保存配置并使用调试功能远程连接到应用程序进行调试。
- en: Once you’ve added the configuration, start the debugger and add the breakpoints
    to pause the execution where you want to start investigating your code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了配置，启动调试器并将断点添加到你想开始调查代码的地方以暂停执行。
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Sometimes the specific unexpected behavior of a running app happens only in
    certain environments in which the app executes. When this happens, debugging becomes
    more challenging.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，运行中的应用程序的具体意外行为仅在应用程序执行的环境中出现。当这种情况发生时，调试变得更加具有挑战性。
- en: 'You can use a debugger with a Java app that executes in a remote environment
    with some conditions:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用调试器来调试在远程环境中执行带有某些条件的 Java 应用程序：
- en: The app should be started with a debugger agent attached.
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序应该以附加调试代理的方式启动。
- en: The network configuration should allow communication between the debugger tool
    and the debugger agent attached to the app in the remote environment.
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络配置应允许调试工具与远程环境中附加到应用程序的调试代理之间的通信。
- en: Remote debugging allows you to use the same debugging techniques as local debugging
    by attaching to a process that runs in a remote environment.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程调试允许你通过连接到在远程环境中运行的进程，使用与本地调试相同的调试技术。
- en: Before debugging an app running in a remote environment, make sure the debugger
    uses a copy of the same source code that created the app you are investigating.
    If you don’t have the exact source code and changes are made in the parts of the
    app involved in your investigation, the debugger may behave oddly, and your remote
    investigation will become more challenging than helpful.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调试远程环境中的应用程序之前，请确保调试器使用的是创建你要调查的应用程序相同的源代码副本。如果你没有确切的源代码，并且应用程序中涉及调查的部分进行了更改，调试器可能会出现异常行为，你的远程调查将变得比有帮助更具有挑战性。
