- en: Unit 6\. Building an API
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6单元\. 构建一个API
- en: In [unit 5](../Text/kindle_split_037.html#part05), you added some new features
    to allow users to log in to your application securely. This addition allows you
    to start distinguishing content that you’d like to show only to logged-in users,
    not the general public. After all, you probably want users to be able to delete
    only their own content, not that of others. These improvements increase the possibilities
    of browser interaction by your users. Internet browsers, however, are only one
    of many types of clients that may want to interact with your data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5单元](../Text/kindle_split_037.html#part05)中，你添加了一些新功能，以允许用户安全地登录到你的应用程序。这一添加使你能够开始区分你只想向已登录用户显示的内容，而不是向公众显示。毕竟，你可能希望用户只能删除他们自己的内容，而不是他人的。这些改进增加了用户与浏览器交互的可能性。然而，互联网浏览器只是可能想要与你的数据交互的许多客户端类型之一。
- en: In this lesson, I discuss how to make better use of your application programming
    interfaces (APIs). An *API* is the method through which clients can interact with
    your application data. Currently, that interaction is through rendered HTML pages,
    available to only web clients, though you may want to modify your controller actions
    to respond to different types of requests with various formats of the same data.
    You can use other data formats through XML or JSON. You may want to access the
    course listings from within a user’s edit page without switching views, for example.
    Maybe you have unsaved content in the edit form, and you’d like to look quickly
    at the list of courses without having to update your user data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，我将讨论如何更好地利用你的应用程序编程接口（API）。*API* 是客户端与你的应用程序数据交互的方法。目前，这种交互是通过渲染的HTML页面进行的，仅限于网络客户端，尽管你可能希望修改你的控制器操作以响应不同类型的请求，并使用相同数据的不同格式。你可以通过XML或JSON使用其他数据格式。你可能希望在用户编辑页面内访问课程列表，而无需切换视图，例如。也许你在编辑表单中有未保存的内容，你希望快速查看课程列表，而无需更新你的用户数据。
- en: In the first lesson, you set up a basic API with RESTful routes to respond with
    course listings in JSON format. Then you use client-side JavaScript to display
    the data on the screen. At the end of the unit, you’ll apply some security barriers
    to your API to prevent unwanted requests from getting access to your database.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一课中，你设置了一个基本的API，使用RESTful路由以JSON格式响应课程列表。然后你使用客户端JavaScript在屏幕上显示数据。在本单元结束时，你将对API应用一些安全屏障，以防止不想要的请求访问你的数据库。
- en: 'This unit covers the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本单元涵盖了以下主题：
- en: '[Lesson 26](../Text/kindle_split_043.html#ch26) introduces you to the way APIs
    are used in the tech industry and ways of responding with different data formats.
    In this lesson, you organize your routes for a more maintainable API and use query
    params to determine the type of data with which you respond.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第26课](../Text/kindle_split_043.html#ch26)介绍了在技术行业中API的使用方式以及响应不同数据格式的方法。在本课中，你为更易于维护的API组织路由，并使用查询参数来确定响应的数据类型。'
- en: '[Lesson 27](../Text/kindle_split_044.html#ch27) shows how to use AJAX through
    the client-side JavaScript to load data in a view without refreshing the page.
    In this lesson, you create a new route and handle incoming requests to a `/api`
    namespace.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第27课](../Text/kindle_split_044.html#ch27)展示了如何通过客户端JavaScript使用AJAX在无需刷新页面的情况下加载数据。在本课中，你创建了一个新的路由，并处理对`/api`命名空间的传入请求。'
- en: '[Lesson 28](../Text/kindle_split_045.html#ch28) guides you through basic approaches
    you can take to secure your API when there’s no way to sign in users visually.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第28课](../Text/kindle_split_045.html#ch28)指导你了解在没有视觉登录方式的情况下如何保护你的API的基本方法。'
- en: '[Lesson 29](../Text/kindle_split_046.html#ch29) wraps up the unit by providing
    the steps you need to make AJAX requests to load Confetti Cuisine course data
    from the user’s profile page. Then you can enroll a user without leaving the profile
    page.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[第29课](../Text/kindle_split_046.html#ch29)通过提供你需要执行的步骤来总结本单元，这些步骤用于从用户个人资料页面发送AJAX请求以加载Confetti
    Cuisine课程数据。然后你可以在不离开个人资料页面的情况下让用户注册。'
- en: Lesson 26\. Adding an API to Your Application
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第26课\. 向你的应用程序添加API
- en: In this lesson, you take a first look at reorganizing your routing structure
    and responding with data. First, you create new folders to house the routes you’ve
    built in main.js. The new structure follows some of the application programming
    interface (API) conventions you set up in earlier lessons. Next, you modify some
    controller actions to respond with Embedded JavaScript (EJS) and JSON, depending
    on the query parameters. Last, you test your new API connection by creating an
    Ajax `GET` request from your client-side JavaScript.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节课中，你首先查看重新组织你的路由结构并响应数据。首先，你创建新的文件夹来存放 main.js 中构建的路由。新的结构遵循你在之前课程中设置的一些应用程序编程接口（API）约定。接下来，你修改一些控制器操作以根据查询参数响应嵌入式
    JavaScript（EJS）和 JSON。最后，你通过从客户端 JavaScript 创建 Ajax `GET` 请求来测试你的新 API 连接。
- en: This lesson covers
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本节课涵盖
- en: Organizing your routes with namespacing
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命名空间组织路由
- en: Creating API endpoints to respond with JSON
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建响应 JSON 的 API 端点
- en: Making Ajax requests from your views
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从视图中发送 Ajax 请求
- en: '|  |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: Your recipe application renders many pages and offers specific functionality
    on each page. To make the user experience less complicated, you’d like to allow
    users to view available programs from their profile pages. To do so, you decide
    to conditionally serve data in JSON format and display that data through JavaScript
    and HTML on the client. When you modify your controller actions, your application
    can offer an API that goes beyond serving web pages.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你的食谱应用程序渲染许多页面，并在每个页面上提供特定的功能。为了使用户体验不那么复杂，你希望允许用户从他们的个人资料页面查看可用的程序。为此，你决定有条件地以
    JSON 格式提供数据，并通过 JavaScript 和 HTML 在客户端显示这些数据。当你修改控制器操作时，你的应用程序可以提供超出服务网页的 API。
- en: '|  |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)26.1\. Organizing your routes'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)26.1. 组织你的路由'
- en: As your application grows, the routes in your main.js file start to overwhelm
    other middleware and configurations. Routes are important parts of your application,
    and keeping your routes organized in a way that multiple developers can manage
    and understand is arguably as important.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的应用程序的增长，main.js 文件中的路由开始压倒其他中间件和配置。路由是应用程序的重要组成部分，以一种多开发者可以管理和理解的方式组织你的路由同样重要。
- en: To start this lesson, you break down the routing structure you’ve set up in
    an easy-to-follow directory structure. In [units 4](../Text/kindle_split_031.html#part04)
    and [5](../Text/kindle_split_037.html#part05), you created routes to reflect CRUD
    functionality in what’s called a REST architecture. *Representational state transfer*
    (REST) is a way of programming your application to represent the involvement of
    its resources across the web. Your application’s resources are the users, subscribers,
    and courses stored in the database and displayed in the views. You implemented
    a RESTful structure by constructing your routes to contain the model name, HTTP
    method, action being performed, and model ID if necessary. `router.get("users/:id/edit",
    usersController .edit)` tells you that an HTTP `GET` request was made to the `u``s``ers/:id/edit`
    path, for example.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始本节课，你将你设置的易于遵循的目录结构中的路由结构分解。在[第 4 单元](../Text/kindle_split_031.html#part04)和[第
    5 单元](../Text/kindle_split_037.html#part05)中，你创建了路由以反映 REST 架构中的 CRUD 功能。*表示性状态转移*（REST）是一种编程方式，用于表示应用程序资源在互联网上的参与。你的应用程序的资源是存储在数据库中并在视图中显示的用户、订阅者和课程。你通过构建包含模型名称、HTTP
    方法、执行的操作以及必要时模型 ID 的路由来实现 RESTful 结构。`router.get("users/:id/edit", usersController
    .edit)`告诉你，例如，有一个 HTTP `GET` 请求发送到了 `u``s``ers/:id/edit` 路径。
- en: These routes make it easy for users to know exactly what information is needed
    to get the data they want to see—in this case, an edit form for an existing user.
    From the path alone, you know that you’re trying to edit a specific user record.
    From there, you can connect to the appropriate action and redirect to another
    RESTful route.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些路由使用户能够确切地知道需要哪些信息才能获取他们想要看到的数据——在这种情况下，是现有用户的编辑表单。仅从路径本身，你就知道你正在尝试编辑特定的用户记录。从那里，你可以连接到相应的操作并重定向到另一个
    RESTful 路由。
- en: '|  |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Redirecting is often a secondary action when you’re creating or updating information
    in the database. After arriving at the initial controller action to modify data,
    you redirect to another route to send the user to another page to view.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 重定向通常是在数据库中创建或更新信息时的次要操作。在到达修改数据的初始控制器操作后，你将重定向到另一个路由，将用户发送到另一个页面以查看。
- en: '|  |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In this section, you reorganize your routes into individual modules to reflect
    the models that they use. This structure will be useful when you decide to expand
    the types of routes and response data you use in the application.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将您的路由重新组织成单独的模块，以反映它们所使用的模型。当您决定扩展应用程序中使用的路由和响应数据类型时，这种结构将非常有用。
- en: 'Start by creating a new folder called routes at the root level of your project
    and create the following new modules within that folder:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先在项目根目录下创建一个名为routes的新文件夹，并在该文件夹中创建以下新模块：
- en: userRoutes.js
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: userRoutes.js
- en: courseRoutes.js
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: courseRoutes.js
- en: subscriberRoutes.js
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: subscriberRoutes.js
- en: errorRoutes.js
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: errorRoutes.js
- en: homeRoutes.js
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: homeRoutes.js
- en: index.js
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: index.js
- en: These six modules will divide the routes that are currently in main.js. For
    now, focus on the user routes.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这六个模块将划分main.js中当前的路由。目前，请专注于用户路由。
- en: Start by requiring the Express.js `Router` and the `usersController` at the
    top of the module. Then import the login routes and CRUD routes, and add them
    to the local `router` object. Doing so allows these routes to be handled by the
    same router. With all the working routes attached to the `router`, you can export
    the router object. Notice in this example that you’re leaving `users` out of the
    path. You’ll define that part of the path in index.js later.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先在模块顶部导入Express.js的`Router`和`usersController`。然后导入登录路由和CRUD路由，并将它们添加到本地的`router`对象中。这样做允许这些路由由同一个路由器处理。将所有工作路由附加到`router`后，您可以导出路由对象。注意在这个例子中，您省略了`users`路径。您将在index.js中稍后定义路径的这一部分。
- en: Copy all the routes in main.js that pertain to the user (CRUD operations, login,
    and authentication), and move them into userRoutes.js, as shown in the next listing.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 将main.js中与用户相关的所有路由（CRUD操作、登录和认证）复制到userRoutes.js中，具体内容见下文。
- en: Listing 26.1\. Moving user routes to userRoutes.js
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表26.1\. 将用户路由移动到userRoutes.js
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1*** **Require Express.js Router and users controller.**'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **导入Express.js Router和users控制器。**'
- en: '***2*** **Add CRUD routes.**'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **添加CRUD路由。**'
- en: '***3*** **Add login and authentication routes.**'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **添加登录和认证路由。**'
- en: '***4*** **Export the module router.**'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **导出模块路由。**'
- en: '|  |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Namespaces**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名空间**'
- en: '*Namespacing* is a way of defining routes, paths, and other application items
    under the umbrella of a specific string or path. Instead of defining dozens of
    routes with the same path prefix, `/users`, you can make that prefix a namespace
    for those routes.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*命名空间*是一种在特定字符串或路径的伞状下定义路由、路径和其他应用程序项的方法。您不必定义具有相同路径前缀（`/users`）的数十个路由，而是可以将该前缀作为这些路由的命名空间。'
- en: Namespacing is particularly helpful in separating routes in your API based on
    the format of the content returned. If an iOS application wants to access the
    data in your recipe application, for example, you might create specific routes
    with the namespace `/ios`. Then you could define paths such as `/ios/courses`
    and `/ios/subscribers`. Through the routes defined under this namespace, the iOS
    application can access data.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间特别有助于根据返回内容格式在您的API中分离路由。例如，如果iOS应用程序想要访问您的食谱应用程序中的数据，您可能会创建具有命名空间`/ios`的特定路由。然后您可以定义路径，如`/ios/courses`和`/ios/subscribers`。通过此命名空间下定义的路由，iOS应用程序可以访问数据。
- en: '|  |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Follow the same strategy for the other route files. Subscriber routes go in
    subscriberRoutes.js, and error routes go in errorRoutes.js.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他路由文件，遵循相同的策略。订阅者路由放在subscriberRoutes.js中，错误路由放在errorRoutes.js中。
- en: The index.js module requires all route modules to be in one place. This convention
    makes it easier to identify all the route types in one file and requires only
    a single file into main.js. As with the route modules, you require the Express.js
    `Router` in index.js. Next, require each relative route module. With those modules
    added, tell the local `router` object to use those routes with specific namespaces.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: index.js模块要求所有路由模块都在一个地方。这种约定使得在一个文件中识别所有路由类型变得更容易，并且只需要一个文件导入到main.js中。与路由模块一样，您在index.js中也需要导入Express.js的`Router`。接下来，导入每个相对路由模块。添加了这些模块后，告诉本地的`router`对象使用这些路由和特定的命名空间。
- en: For the home and error routes, no namespace is necessary. By adding the `/users`
    namespace for the user routes defined in [listing 26.1](#ch26ex01), you return
    to the original functionality of your routes. The last step is requiring this
    index.js module in main.js. Add `const router = require("./routes/index")` to
    the top of main.js and `app.use("/", router)` after your middleware functions.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于主页和错误路由，不需要命名空间。通过为 [26.1 列表](#ch26ex01) 中定义的用户路由添加 `/users` 命名空间，你将返回到路由的原有功能。最后一步是在
    main.js 中引入此 index.js 模块。在 main.js 的顶部添加 `const router = require("./routes/index")`，并在你的中间件函数之后添加
    `app.use("/", router)`。
- en: To tie all these routes to the same router used by your application, add the
    code in the next listing to index.js.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这些路由与你的应用程序使用的相同路由器绑定，请将下一列表中的代码添加到 index.js 中。
- en: Listing 26.2\. Importing all routes into index.js
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.2. 将所有路由导入 index.js
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1*** **Require the Express.js Router.**'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 需要Express.js 路由器。'
- en: '***2*** **Require all the route modules within the same directory.**'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 需要同一目录内的所有路由模块。'
- en: '***3*** **Use the routes from the relative route modules with namespaces.**'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 使用带有命名空间的相对路由模块中的路由。'
- en: '***4*** **Export the router from index.js.**'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 从 index.js 导出路由器。'
- en: '|  |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Order matters. Make sure to have the more-detailed routes closer to the top
    of `index.js`. Otherwise, the error routes will handle all incoming requests before
    they can reach the routes you intended.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序很重要。确保将更详细的路由放在 `index.js` 的顶部附近。否则，错误路由将在它们能够到达你打算到达的路由之前处理所有传入的请求。
- en: '|  |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The Express.js `router` object operates through middleware. Within it, you can
    define specific tasks that you want to perform on incoming requests. In this case,
    you’re using `router` to load routes under different namespaces. As with other
    middleware, if you want the router middleware to be part of the main application’s
    middleware flow, you need to add it with `app.use`. In main.js, remove all the
    controllers’ require statements, as well as the require statement for `express.Router()`.
    The rest of the middleware in main.js is used by the `app` object.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Express.js 的 `router` 对象通过中间件操作。在其内部，你可以定义你希望在传入请求上执行的具体任务。在这种情况下，你正在使用 `router`
    在不同的命名空间下加载路由。与其他中间件一样，如果你想将路由器中间件添加到主应用程序的中间件流程中，你需要使用 `app.use` 添加它。在 main.js
    中，删除所有控制器的 require 语句，以及 `express.Router()` 的 require 语句。main.js 中的其余中间件用于 `app`
    对象。
- en: '|  |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: It’s important to change all remaining middleware in main.js to be used by `app`
    instead of `router` because you’ll want the `app` to parse requests and use your
    templating engine before the request reaches your router at the bottom of the
    file. Order of middleware matters!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要将 main.js 中剩余的所有中间件更改为由 `app` 使用而不是 `router`，因为你在请求到达文件底部的路由之前，希望 `app`
    解析请求并使用你的模板引擎。中间件的顺序很重要！
- en: '|  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Restart your application, and confirm the original functionality of your application
    is intact. If you get any errors or if some routes aren’t found, make sure that
    all the route namespaces are defined correctly and that the resource name prefixes
    are stripped from the original paths. Under the new namespace, your user index
    route, for example, should read `router.get("/", usersController.index, usersController.indexView)`
    instead of `router.get("/users", usersController.index, usersController.indexView)`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动你的应用程序，并确认应用程序的原有功能保持完好。如果你遇到任何错误，或者某些路由找不到，请确保所有路由命名空间都已正确定义，并且已从原始路径中删除资源名称前缀。在新命名空间下，例如，你的用户索引路由应读取
    `router.get("/", usersController.index, usersController.indexView)` 而不是 `router.get("/users",
    usersController.index, usersController.indexView)`。
- en: In the next section, you learn how to use your existing routes to return two
    types of data formats.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学习如何使用现有的路由来返回两种数据格式。
- en: '|  |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 26.1**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 26.1**'
- en: '**[Q1:](#ch26qa2q0a1)**'
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch26qa2q0a1)**'
- en: ''
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why do you add `app.use("/", router)` in main.js?
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你为什么在 main.js 中添加 `app.use("/", router)`？
- en: '|  |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 26.1 answer**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 26.1 答案**'
- en: '**[1:](#ch26qa1q1)**'
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch26qa1q1)**'
- en: ''
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When the router is defined in main.js, you need to tell the Express.js application
    to use it as middleware.
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当路由在 main.js 中定义时，你需要告诉 Express.js 应用程序将其用作中间件。
- en: '|  |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)26.2\. Creating an API'
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![创建 API 的截图](../Images/sectionFig.png)26.2. 创建 API'
- en: 'An API is a structure set up within your application to allow external sources
    to access your application data. In effect, you’ve already built an API by creating
    your Express.js web server. By serving HTML and EJS, you’ve provided an avenue
    through which users of your application can access your data: the web browser.
    Not every user, however, will want to see your application data exclusively through
    the browser on a web page with the styling and formatting you’ve applied.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: API 是在你的应用程序内设置的结构，允许外部来源访问你的应用程序数据。实际上，通过创建 Express.js 网络服务器，你已经构建了一个 API。通过提供
    HTML 和 EJS，你已经提供了一条途径，让应用程序的用户可以通过网络浏览器访问你的数据：网页浏览器。然而，并非每个用户都希望通过你应用的网页浏览器以特定的样式和格式查看应用程序数据。
- en: Think of your current Express.js application as being like a restaurant menu.
    It’s likely that most people will refer to the printed menu to find out what food
    items a restaurant offers. Getting access to the hard-copy menu requires traveling
    to the restaurant itself. By providing a phone number to call to inquire about
    menu items and a website to display the restaurant’s menu, you give customers
    more options to get the information they need. Similarly, a robust API provides
    application data in different formats that you access in different ways.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 将你当前的 Express.js 应用程序想象成一家餐厅的菜单。大多数人可能会参考打印的菜单来了解餐厅提供的食物项目。获取硬拷贝菜单需要亲自前往餐厅。通过提供电话号码以查询菜单项目以及显示餐厅菜单的网站，你为顾客提供了更多获取所需信息的选择。同样，一个强大的
    API 提供了不同格式的应用程序数据，你可以通过不同的方式访问这些数据。
- en: In this section, you reconstruct some of your application routes and actions
    to respond with data in JSON format in addition to rendered EJS views. Responding
    with JSON is simple in Express.js. Change the `res.render("courses/index")` line
    in the `i``n``dexView` action of coursesController.js to `res.json(res.locals.courses)`.
    When you restart your application and visit http://locatlhost:3000/courses, your
    browser should display all the courses in your database in JSON format ([figure
    26.1](#ch26fig01)).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将重构一些应用程序的路由和动作，以便除了渲染 EJS 视图外，还能以 JSON 格式响应数据。在 Express.js 中，以 JSON 格式响应数据很简单。将
    `coursesController.js` 中 `indexView` 动作的 `res.render("courses/index")` 行更改为 `res.json(res.locals.courses)`。当你重新启动应用程序并访问
    http://localhost:3000/courses 时，你的浏览器应该以 JSON 格式显示数据库中的所有课程（[图 26.1](#ch26fig01)）。
- en: Figure 26.1\. Display of JSON course results in browser
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 26.1\. 浏览器中 JSON 课程结果的显示
- en: '![](../Images/26fig01_alt.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/26fig01_alt.jpg)'
- en: 'This output should resemble the output from your MongoDB server when you run
    `mongo` in a new terminal window: `use rec``i``pe_db` and `db.courses.find({})`,
    as shown in [figure 26.2](#ch26fig02). Running these commands starts your MongoDB
    environment and lists all the courses in your recipe database. In the application,
    you’re essentially showing the full database documents in the browser.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出应类似于你在新终端窗口中运行 `mongo` 命令时的 MongoDB 服务器输出：`use recipe_db` 和 `db.courses.find({})`，如图
    26.2 所示。运行这些命令启动 MongoDB 环境，并列出你的食谱数据库中的所有课程。在应用程序中，你实际上是在浏览器中显示完整的数据库文档。
- en: Figure 26.2\. Display of courses in MongoDB
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 26.2\. MongoDB 中的课程显示
- en: '![](../Images/26fig02_alt.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/26fig02_alt.jpg)'
- en: You can further improve the index action by responding with JSON only when requested.
    You can accomplish this task in many ways. One way is to use query params. In
    this code, you perform a check for the `format` query param. If it exists and
    equals `json`, respond with the course data in JSON format. Otherwise, respond
    with a rendered EJS view as usual. Change the `courses` `i``n``dexView` action
    to the code in the next listing.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过仅响应 JSON 格式来进一步改进索引动作。你可以用多种方式完成这项任务。一种方式是使用查询参数。在这段代码中，你检查了 `format` 查询参数。如果它存在且等于
    `json`，则以 JSON 格式响应课程数据。否则，像往常一样响应渲染的 EJS 视图。将 `courses` `indexView` 动作更改为下一列表中的代码。
- en: Listing 26.3\. Responding with JSON when query param exists in usersController.js
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.3\. 在 usersController.js 中存在查询参数时响应 JSON
- en: '[PRE2]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1*** **Respond with JSON if the format query param equals json.**'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **如果格式查询参数等于 json，则响应 JSON 格式。**'
- en: '***2*** **Respond with an EJS view if the format query param doesn’t equal
    json.**'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **如果格式查询参数不等于 json，则响应 EJS 视图。**'
- en: 'Restart your application, and visit http://localhost:3000/courses to ensure
    that your original EJS index view is still rendering. To display JSON data instead
    of the normal view, append `?format=json` to the end of your URL: visit `http://localhost:3000/courses?
    format=json`. This additional query parameter tells your courses controller to
    render data in JSON format instead of EJS.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动你的应用程序，并访问 http://localhost:3000/courses 以确保你的原始 EJS index 视图仍然在渲染。要显示 JSON
    数据而不是正常视图，请将 `?format=json` 追加到 URL 的末尾：访问 `http://localhost:3000/courses?format=json`。这个额外的查询参数告诉你的课程控制器以
    JSON 格式而不是 EJS 渲染数据。
- en: With this change in place, if an external application wants to access the list
    of courses, it can make a request to the URL with the query parameter. External
    applications are only one group of consumers that can benefit from this implementation,
    though. You can use this data endpoint from within your own application in many
    ways. (An API *endpoint* is a reference to one or more application paths whose
    routes accept web requests.)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 实施这一变化后，如果外部应用程序想要访问课程列表，它可以向带有查询参数的 URL 发送请求。尽管如此，外部应用程序只是可以从这一实现中受益的一组消费者之一。你可以在自己的应用程序中以多种方式使用此数据端点。（API
    *端点* 是对接受网络请求的一个或多个应用程序路径的引用。）
- en: '|  |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 26.2**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 26.2**'
- en: '**[Q1:](#ch26qa4q0a1)**'
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch26qa4q0a1)**'
- en: ''
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What method do you use on the response to send data as JSON back to the client?
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你在响应上使用什么方法来以 JSON 格式将数据发送回客户端？
- en: '|  |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 26.2 answer**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 26.2 答案**'
- en: '**[1:](#ch26qa3q1)**'
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch26qa3q1)**'
- en: ''
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In Express.js, you can use `res.json` followed by the parameters you’d like
    to send in JSON format.
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 Express.js 中，你可以使用 `res.json` 后跟你想要以 JSON 格式发送的参数。
- en: '|  |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)26.3\. Calling your API from the client'
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)26.3\. 从客户端调用你的 API'
- en: 'In the restaurant analogy, a menu’s items could be made available through different
    media: print, phone, or web. This variety makes it easier for customers to learn
    more about the food served in the restaurant and also could make it easier for
    restaurant staff to access the menu items more quickly. After all, pulling up
    a web page is a convenient alternative to finding a menu on a busy night.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在餐厅的类比中，菜单项可以通过不同的媒体提供：印刷、电话或网络。这种多样性使得顾客更容易了解餐厅提供的食物，同时也可能使餐厅工作人员更快地访问菜单项。毕竟，在繁忙的夜晚打开网页是找到菜单的一个方便的替代方案。
- en: In many places within your application, you could benefit from application routes
    that return JSON data. Primarily, you could benefit by making Ajax requests from
    the client to access data from pages you don’t want to refresh. What if you want
    users to be able to view the course listings without having to change their current
    page, for example?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序的许多地方，你可以从返回 JSON 数据的应用程序路由中受益。主要的好处是，你可以通过客户端向不希望刷新的页面发送 Ajax 请求来受益。例如，如果你想让用户能够在不改变他们当前页面的情况下查看课程列表，那会怎么样？
- en: Implement a solution by populating a *modal* (a window that overlays the main
    browser screen with some instruction or content) with course data via an Ajax
    request. To start, create a partial view called _coursesModal.ejs in the views/courses
    folder. Use a simple bootstrap modal, as shown in the next listing.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Ajax 请求用课程数据填充一个 *模态*（一个覆盖主浏览器屏幕的带有某些说明或内容的窗口）来实现解决方案。首先，在 views/courses
    文件夹中创建一个名为 _coursesModal.ejs 的部分视图。使用如以下列表所示的一个简单的 Bootstrap 模态。
- en: In this modal, you have a button that triggers a modal to appear. The modal
    has a tag with the `modal-body` class. Target this class to populate course data.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模态中，你有一个触发模态出现的按钮。该模态有一个带有 `modal-body` 类的标签。针对此类填充课程数据。
- en: Listing 26.4\. Simple bootstrap modal in _coursesModel.ejs
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.4\. 在 _coursesModel.ejs 中的简单 Bootstrap 模态
- en: '[PRE3]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1*** **Add a modal where you’ll populate modal-body.**'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **添加一个你将填充 modal-body 的模态。**'
- en: Include this partial view in your layout.ejs file so that you can access it
    from anywhere in your application by adding `<li><%- include courses/_coursesModal
    %></li>` as an item in your layout’s navigation. To get this modal to work, you
    also need to have the bootstrap client-side JavaScript as well as jQuery. You
    can get the minified code for jQuery.min.js at [https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js](https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js)
    and bootstrap.min.js at [https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js](https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 layout.ejs 文件中包含这个部分视图，这样你就可以通过添加 `<li><%- include courses/_coursesModal
    %></li>` 作为布局导航中的一个项目，在任何应用位置访问它。为了使这个模态框正常工作，你还需要有 bootstrap 客户端 JavaScript 以及
    jQuery。你可以在 [https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js](https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js)
    获取 jQuery.min.js 的压缩代码，并在 [https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js](https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js)
    获取 bootstrap.min.js。
- en: '|  |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: I recommend copying the code from this content delivery network and saving the
    code locally to files with the same name in public/js.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议复制这个内容交付网络中的代码，并将其保存为与 public/js 中相同名称的本地文件。
- en: '|  |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Then, in layout.ejs, link to these JavaScript files, as shown in the following
    listing.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 layout.ejs 中，链接到以下列表中的 JavaScript 文件。
- en: Listing 26.5\. Import jquery and bootstrap into layout.ejs
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.5\. 将 jquery 和 bootstrap 导入 layout.ejs
- en: '[PRE4]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1*** **Add local JavaScript files from public/js.**'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **添加来自 public/js 的本地 JavaScript 文件。**'
- en: With a few styling changes, you can restart your application. You should see
    a button in your top navigation bar that opens a modal, as shown in [figure 26.3](#ch26fig03).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一些样式更改，你可以重新启动你的应用程序。你应该在你的顶部导航栏中看到一个按钮，点击它将打开一个模态框，如图 [图 26.3](#ch26fig03)
    所示。
- en: Figure 26.3\. Simple modal button in navigation bar
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 26.3\. 导航栏中的简单模态按钮
- en: '![](../Images/26fig03_alt.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/26fig03_alt.jpg)'
- en: To give this modal some data, create recipeApp.js in your public folder’s js
    folder. This JavaScript file will run on the client side. Make sure that this
    file is linked in your layout .ejs file below bootstrap and jQuery by adding `<script
    type="text/javascript" src="/js/recipeApp.js"></script>`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给这个模态框提供一些数据，在你的 public 文件夹的 js 文件夹中创建 recipeApp.js。这个 JavaScript 文件将在客户端运行。确保在
    layout .ejs 文件中将此文件链接到 bootstrap 和 jQuery 下方，通过添加 `<script type="text/javascript"
    src="/js/recipeApp.js"></script>`。
- en: Within recipeApp.js, add the code in [listing 26.6](#ch26ex06). You wrap the
    code block in `$(document) .ready` to ensure that no JavaScript is run until the
    DOM is loaded and ready. Then you add a click listener on the `modal-button` ID.
    When that button is clicked in the navigation bar, perform an Ajax `GET` request,
    using `$.get` to the `/courses?format=json` path. With the added query param,
    you expect the response to include data as an array in JSON. Then you loop through
    that array to access individual course records and use `$(".modal-body").append`
    to add some HTML with each course’s title and description.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 recipeApp.js 中，添加 [列表 26.6](#ch26ex06) 中的代码。你将代码块包裹在 `$(document) .ready`
    中，以确保在 DOM 加载并准备好之前不执行任何 JavaScript。然后你添加一个点击监听器到 `modal-button` ID。当在导航栏中点击该按钮时，执行一个到
    `/courses?format=json` 路径的 Ajax `GET` 请求。通过添加查询参数，你期望响应包含作为 JSON 数组的数据。然后你遍历该数组以访问单个课程记录，并使用
    `$(".modal-body").append` 为每个课程的标题和描述添加一些 HTML。
- en: Listing 26.6\. Ajax function to load data in modal in recipeApp.js
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.6\. recipeApp.js 中的 Ajax 函数用于在模态框中加载数据
- en: '[PRE5]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1*** **Wait for DOM to load.**'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **等待 DOM 加载。**'
- en: '***2*** **Listen for a click event on the modal button.**'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **监听模态按钮的点击事件。**'
- en: '***3*** **Clear the modal from any previous content.**'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **清除模态框中的任何先前内容。**'
- en: '***4*** **Request data from /courses?format=json asynchronously.**'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **异步从 /courses?format=json 请求数据。**'
- en: '***5*** **Loop through array of data in the response.**'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **遍历响应中的数据数组。**'
- en: '***6*** **Append each course to the modal.**'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **将每个课程添加到模态框中。**'
- en: With this Ajax request in place, restart the application and load course data
    into the modal. Clicking the modal button fetches new data from the server, as
    shown in [figure 26.4](#ch26fig04).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在此 Ajax 请求设置完成后，重新启动应用程序并将课程数据加载到模态框中。点击模态按钮从服务器获取新数据，如图 [图 26.4](#ch26fig04)
    所示。
- en: Figure 26.4\. Populating course data within modal
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 26.4\. 在模态框中填充课程数据
- en: '![](../Images/26fig04_alt.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/26fig04_alt.jpg)'
- en: Now users can view the list of courses from any page. Even if new courses are
    added to the database, clicking the modal button fetches that new list.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，用户可以从任何页面查看课程列表。即使数据库中添加了新的课程，点击模态按钮也会获取新的列表。
- en: '|  |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Ajax**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ajax**'
- en: '*Asynchronous JavaScript and XML* (Ajax) is a technology that allows client-side
    requests to be made asynchronously without interfering with any behavior or display
    of the application page. Ajax uses JSON and XML to format data and requests to
    be sent to a server. By managing only the data layer of an application on your
    browser, Ajax allows you to make a request asynchronously and handle data in the
    resulting response through a callback function.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*异步JavaScript和XML* (Ajax)是一种允许客户端异步请求而不干扰应用程序页面任何行为或显示的技术。Ajax使用JSON和XML来格式化数据和要求发送到服务器。通过仅管理浏览器中应用程序的数据层，Ajax允许你异步发送请求并通过回调函数处理结果响应中的数据。'
- en: Because of the way that Ajax interacts with a backend server without the need
    to reload your web page, it’s widely used to update content dynamically in real
    time. Through multiple Ajax requests, a web page theoretically might never have
    to reload.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Ajax与后端服务器交互的方式无需重新加载你的网页，它被广泛用于实时动态更新内容。通过多个Ajax请求，理论上网页可能永远不需要重新加载。
- en: '|  |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 26.3**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查26.3**'
- en: '**[Q1:](#ch26qa6q0a1)**'
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch26qa6q0a1)**'
- en: ''
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you expect will happen if there are no courses in the database when
    you make an Ajax request?
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你进行Ajax请求时，如果数据库中没有课程，你期望会发生什么？
- en: '|  |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 26.3 answer**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 26.3 答案**'
- en: '**[1:](#ch26qa5q1)**'
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch26qa5q1)**'
- en: ''
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Ajax request returns an array of items from the database. If there are no
    records, the response contains an empty array.
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Ajax请求从数据库返回一个项目数组。如果没有记录，响应将包含一个空数组。
- en: '|  |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)Summary'
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)总结'
- en: In this lesson, you learned about modifying your application route structure
    to make room for an extensive API. First, you reorganized your routes into individual
    modules. Next, you added a way to respond with JSON data from your controller
    action. Last, you added client-side JavaScript to make asynchronous requests to
    your server from within a view. In [lesson 27](../Text/kindle_split_044.html#ch27),
    you explore namespacing further and see ways in which you can enroll users in
    courses from the modal itself.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了如何修改你的应用程序路由结构以腾出空间用于广泛的API。首先，你将路由重新组织成单独的模块。接下来，你添加了一种从控制器操作中响应JSON数据的方式。最后，你添加了客户端JavaScript，以便在视图中从服务器进行异步请求。在[第27课](../Text/kindle_split_044.html#ch27)中，你将进一步探索命名空间，并了解如何从模态本身注册用户到课程中。
- en: '|  |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Try this**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试这个**'
- en: With one action modified to respond with JSON data, try applying the same technique
    to other actions. Start by adding the query param condition to the other model
    index actions; then implement it for the show actions.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过修改一个响应JSON数据的操作，尝试将相同的技巧应用到其他操作上。首先，将查询参数条件添加到其他模型索引操作中；然后实现它用于显示操作。
- en: Keep in mind that the `show` actions return individual records, not arrays.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`show`操作返回单个记录，而不是数组。
- en: '|  |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Lesson 27\. Accessing Your API from Your Application
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第27课\. 从你的应用程序访问你的API
- en: In this lesson, you change the way that you access JSON-formatted data by adding
    an API namespace. Then you modify your AJAX function to allow users to join courses
    directly from a modal. Last, you create the action to link users and courses through
    a new route.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你通过添加API命名空间来改变访问JSON格式化数据的方式。然后你修改AJAX函数，允许用户直接从模态中注册课程。最后，你创建了一个通过新路由链接用户和课程的操作。
- en: This lesson covers
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 本课涵盖
- en: Creating an API namespace
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建API命名空间
- en: Building a UI modal to fetch data asynchronously
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建用于异步获取数据的UI模态
- en: Connecting models with MongoDB methods
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MongoDB方法连接模型
- en: '|  |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这个**'
- en: Users can now view course listings from any page on your application, but they
    want to do more than view that list. With AJAX requests, you can not only pull
    data asynchronously into the page, but also perform other actions, such as creating
    new records and editing existing records.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 用户现在可以从应用程序的任何页面查看课程列表，但他们想做的不仅仅是查看这个列表。通过Ajax请求，你不仅可以异步将数据拉入页面，还可以执行其他操作，例如创建新记录和编辑现有记录。
- en: In this lesson, you explore ways in which you can make better use of your API
    and how AJAX can help.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你将探索如何更好地使用你的API以及AJAX如何能帮助你。
- en: '|  |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)27.1\. Applying an API namespace'
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)27.1\. 应用API命名空间'
- en: I discussed namespacing in [lesson 26](../Text/kindle_split_043.html#ch26).
    Now you’re going to implement a namespace for API endpoints that return JSON data
    or perform actions asynchronously. To get started, create a new route module called
    apiRoutes.js in your routes folder. This module will contain all the API routes
    with JSON response bodies. Require this new module in index.js by adding `const
    apiRoutes = require("./apiRoutes")`. Then tell your router to use this module
    under the `api` namespace with `router.use("/api", apiRoutes)`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 [第 26 课](../Text/kindle_split_043.html#ch26) 中讨论了命名空间。现在你将实现一个用于返回 JSON 数据或异步执行操作的
    API 端点的命名空间。要开始，在你的 routes 文件夹中创建一个新的路由模块，名为 apiRoutes.js。此模块将包含所有具有 JSON 响应体的
    API 路由。通过添加 `const apiRoutes = require("./apiRoutes")` 在 index.js 中引入此新模块。然后告诉你的路由器在
    `api` 命名空间下使用此模块，使用 `router.use("/api", apiRoutes)`。
- en: '|  |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You must add this new route above the home and error routes. Those routes are
    namespaced for `/`, meaning that any URL entered that doesn’t match a route name
    before reaching the error or home routes defaults to an error page.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须将此新路由添加到主页和错误路由之上。这些路由针对 `/` 命名空间，这意味着任何在到达错误或主页路由之前不匹配路由名称的 URL 都默认为错误页面。
- en: '|  |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Create your first route, and have it point to your coursesController.js. Add
    the code in [listing 27.1](#ch27ex01) to apiRoutes.js. Require the Express.js
    router along with your courses controller at `../controllers/coursesController`.
    Then point `GET` requests to the `/courses` path to the index action of coursesController.js
    and export the router, followed by `respondJSON`. As with your other error-handling
    middleware, tell this router to use `errorJSON` in case actions run earlier don’t
    return a response.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 创建你的第一个路由，并将其指向 coursesController.js。将 [列表 27.1](#ch27ex01) 中的代码添加到 apiRoutes.js
    中。在 `../controllers/coursesController` 中引入 Express.js 路由器以及你的课程控制器。然后将 `GET` 请求指向
    `/courses` 路径到 coursesController.js 的 index 动作，并导出路由器，然后是 `respondJSON`。与其他错误处理中间件一样，告诉此路由器如果早期动作没有返回响应，则使用
    `errorJSON`。
- en: '|  |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If an action doesn’t explicitly respond to the client, the connection is still
    open, and the request continues to flow through the chain of middleware functions.
    Typically, this situation means that an error has occurred, and that error will
    propagate through until error-handling middleware catches it.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个动作没有明确响应客户端，连接仍然打开，请求会继续通过中间件函数链流动。通常，这种情况意味着发生了错误，并且该错误会传播，直到错误处理中间件捕获它。
- en: '|  |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 27.1\. Adding a route to show all courses in apiRoutes.js
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 27.1\. 在 apiRoutes.js 中添加一个路由以显示所有课程
- en: '[PRE6]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1*** **Require courses controller.**'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **引入课程控制器。**'
- en: '***2*** **Add the API route to the Express.js Router.**'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将 API 路由添加到 Express.js 路由器。**'
- en: '***3*** **Add API error-handling middleware.**'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **添加 API 错误处理中间件。**'
- en: To get this code to work, create the `respondJSON` and `errorJSON` actions in
    courses-Controller.js. Add the code in [listing 27.2](#ch27ex02) to the courses
    controller for this action.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要使此代码生效，请在 courses-Controller.js 中创建 `respondJSON` 和 `errorJSON` 动作。将 [列表 27.2](#ch27ex02)
    中的代码添加到该动作的课程控制器中。
- en: The `index` action in coursesController.js already attaches `courses` to the
    response’s `locals` object. Take that `locals` object and display it in JSON format
    instead of rendering the data in EJS. If an error occurs in the courses query,
    pass the error to your `e``r``rorJSON` action. Your normal errors controller actions
    respond only with browser views. If an error occurs, instead of redirecting to
    another page, respond with a status code of `500`, indicating that an internal
    error has occurred.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: coursesController.js 中的 `index` 动作已经将 `courses` 添加到响应的 `locals` 对象中。取这个 `locals`
    对象并以 JSON 格式显示，而不是在 EJS 中渲染数据。如果在课程查询中发生错误，将错误传递给您的 `e``r``rorJSON` 动作。您正常的错误控制器动作只响应浏览器视图。如果发生错误，而不是重定向到另一个页面，以
    `500` 状态码响应，表示发生了内部错误。
- en: Listing 27.2\. Adding JSON responses for courses in coursesController.js
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 27.2\. 在 coursesController.js 中添加课程 JSON 响应
- en: '[PRE7]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1*** **Handle the request from previous middleware, and submit response.**'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **处理来自先前中间件的请求并提交响应。**'
- en: '***2*** **Respond with the response’s local data in JSON format.**'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **以 JSON 格式响应响应的本地数据。**'
- en: '***3*** **Respond with a 500 status code and error message in JSON format.**'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **以 JSON 格式响应 500 状态码和错误消息。**'
- en: '|  |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You will also need to add `const httpStatus = require("http-status-codes")`
    to the top of coursesController.js.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要在 coursesController.js 的顶部添加 `const httpStatus = require("http-status-codes")`。
- en: '|  |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Restart your application, and visit http://localhost:3000/api/courses in your
    browser to see course data in JSON. Having these routes and controllers separate
    from your web application routes and controllers prevents you from making mistakes
    in the future. As things stand now, you always want to render EJS or redirect
    if you visit `/courses`, and you always expect a JSON response from`/api/courses`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动你的应用程序，并在浏览器中访问 http://localhost:3000/api/courses 以查看 JSON 格式的课程数据。将这些路由和控制器与你的
    web 应用程序的路由和控制器分开，可以防止你将来犯错误。就现状而言，你总是希望在访问 `/courses` 时渲染 EJS 或重定向，并且你总是期望从 `/api/courses`
    获取 JSON 响应。
- en: With this new API namespace, route, and controller action in place, change the
    AJAX `GET` request in recipeApp.js to call `/api/courses` instead of `/courses?format=json`.
    Then remove the conditional block checking for the `format` query param in your
    courses `indexView` action. Restart your application, and check whether you can
    still load the course data in the modal.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在此新的 API 命名空间、路由和控制器动作就绪后，将 recipeApp.js 中的 AJAX `GET` 请求更改为调用 `/api/courses`
    而不是 `/courses?format=json`。然后从你的课程 `indexView` 动作中删除检查 `format` 查询参数的条件块。重新启动你的应用程序，并检查你是否仍然可以在模态框中加载课程数据。
- en: Also, because you’re now returning your data wrapped in another JavaScript object
    containing your status code, you need to modify your AJAX call to handle returned
    data properly. Change the AJAX call in recipeApp.js as shown in the next listing.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，因为你现在返回的数据被包含在另一个包含你的状态码的 JavaScript 对象中，你需要修改你的 AJAX 调用来正确处理返回的数据。如下一列表所示，更改
    recipeApp.js 中的 AJAX 调用。
- en: Listing 27.3\. Modifying AJAX call in recipeApp.js
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 27.3\. 修改 recipeApp.js 中的 AJAX 调用
- en: '[PRE8]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1*** **Set up a local variable to represent data.**'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **设置一个局部变量来表示数据。**'
- en: '***2*** **Check that the data object contains course information.**'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **检查数据对象是否包含课程信息。**'
- en: '***3*** **Loop through course data, and add elements to modal.**'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **遍历课程数据，并将元素添加到模态框中。**'
- en: Restart your application, and click the modal button to see that functionality
    hasn’t changed from the last section.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动你的应用程序，并点击模态框按钮以查看功能是否与上一节相同。
- en: In the next section, you add more functionality to the modal to allow users
    to join courses.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将添加更多功能到模态框，允许用户加入课程。
- en: '|  |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 27.1**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 27.1**'
- en: '**[Q1:](#ch27qa2q0a1)**'
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch27qa2q0a1)**'
- en: ''
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why do you create a new folder for API controllers?
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你为什么为 API 控制器创建一个新的文件夹？
- en: '|  |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 27.1 answer**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 27.1 答案**'
- en: '**[1:](#ch27qa1q1)**'
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch27qa1q1)**'
- en: ''
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Having a separate folder for API controllers and actions makes it easier to
    split the application in two. One part of the application serves data with a visual
    aspect, and the other serves data to sources looking for the raw data.
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为 API 控制器和动作设置一个单独的文件夹可以使将应用程序分成两部分变得更加容易。应用程序的一部分提供具有视觉方面的数据，另一部分提供寻找原始数据的数据源。
- en: '|  |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)27.2\. Joining courses via modal'
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)27.2\. 通过模态框加入课程'
- en: Listing the courses in a modal is a great accomplishment. In this section, you
    improve the modal even more by allowing users to join a course asynchronously
    through the modal. Add a button that allows users to join the course. Through
    AJAX, you submit a request to an API endpoint where a controller action attempts
    to add the user to the course and responds with a success or failure message in
    JSON.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在模态框中列出课程是一项伟大的成就。在本节中，你通过允许用户通过模态框异步加入课程来进一步改进模态框。添加一个允许用户加入课程的按钮。通过 AJAX，你向一个
    API 端点提交请求，控制器动作尝试将用户添加到课程中，并返回 JSON 格式的成功或失败消息。
- en: First, add the link to join the course by adding the HTML code in [listing 27.4](#ch27ex04)
    to the bottom of the HTML rendered from the original AJAX call in recipeApp.js.
    This button needs a custom class `join-button` and can be placed next to the course
    title in the modal. It also needs the `data-id` set to `${course._id}`, which
    allows you to know which course listing you selected.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过将 [列表 27.4](#ch27ex04) 中的 HTML 代码添加到 recipeApp.js 中原始 AJAX 调用生成的 HTML 的底部来添加加入课程的链接。这个按钮需要一个自定义类
    `join-button`，并且可以放在模态框中的课程标题旁边。它还需要将 `data-id` 设置为 `${course._id}`，这样你就可以知道你选择了哪个课程列表。
- en: '|  |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The data attribute in HTML is helpful in situations like these. You can mark
    each button with a `data-id` attribute so that each button’s unique ID matches
    some corresponding course ID.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，HTML 中的数据属性很有帮助。你可以给每个按钮标记一个 `data-id` 属性，以便每个按钮的唯一 ID 与某个相应的课程 ID 匹配。
- en: '|  |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Listing 27.4\. Adding a button to join a course in recipeApp.js
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 27.4\. 在 recipeApp.js 中添加加入课程的按钮
- en: '[PRE9]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1*** **Add a button with target-class join-button to join a course.**'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **添加一个带有 target-class join-button 的按钮以加入课程。**'
- en: If you restart the application now, you should see a button next to each course
    item, as shown in [figure 27.1](#ch27fig01). These buttons don’t have any functionality
    yet, though.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在重新启动应用程序，您应该在每个课程项旁边看到一个按钮，如图 27.1 所示。尽管这些按钮目前还没有任何功能。
- en: Figure 27.1\. Adding a join button
  id: totrans-239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 27.1\. 添加加入按钮
- en: '![](../Images/27fig01_alt.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图 27.1](../Images/27fig01_alt.jpg)'
- en: To get these buttons to work, change the code in recipeApp.js to use the code
    in [listing 27.5](#ch27ex05). In this example, you create a function called `addJoinButtonListener`
    that sets up a click-event listener for each button with the class `join-button`.
    You need to call this function right after the AJAX request completes because
    you want to attach the listener to the buttons after they’re created on the page.
    To do this, append a `then` block to the AJAX request.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这些按钮生效，请将 recipeApp.js 中的代码更改为使用 [列表 27.5](#ch27ex05) 中的代码。在这个例子中，您创建了一个名为
    `addJoinButtonListener` 的函数，该函数为具有类 `join-button` 的每个按钮设置点击事件监听器。您需要在 AJAX 请求完成后立即调用此函数，因为您想在按钮在页面上创建后附加监听器。为此，将一个
    `then` 块附加到 AJAX 请求上。
- en: '|  |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: AJAX functions use promises, so you can chain `then` and `catch` blocks to the
    end of requests to run code after you get a response. The `success` block behaves
    the same way.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: AJAX 函数使用承诺（promises），因此你可以在请求的末尾链式调用 `then` 和 `catch` 块来在获取响应后运行代码。`success`
    块的行为方式相同。
- en: '|  |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In `addJoinButtonListener`, you grab the target of the click—the button—and
    then pull the data ID you set earlier with the course’s ID. With this information,
    you can make a new AJAX `GET` request to the `/api/courses/:id/join` endpoint.
    For this request to work, you need to make sure that the user is logged in. This
    route allows you to target specific courses to join by using the course ID.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `addJoinButtonListener` 中，您获取点击的目标——按钮——然后提取您之前使用课程 ID 设置的数据 ID。有了这些信息，您可以对
    `/api/courses/:id/join` 端点发起一个新的 AJAX `GET` 请求。为了使此请求生效，您需要确保用户已登录。此路由允许您通过使用课程
    ID 来针对特定的课程进行加入。
- en: 'The route and action that handle that request return the JSON value `success:
    true` if you’re able to add the user to the course. If you’re successful, change
    the text and color of the button to indicate that the user has joined by adding
    a new `joined-button` class and removing the old `join-button` class. This swapping
    of classes allows you to style each button with different style rules in recipe_app.css
    and also prevents the click event from triggering another request. If you don’t
    see the color of the button change, make sure that you’re targeting the correct
    button class. If joining the course results in an error, change the button’s text
    to tell the user to try again.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '处理该请求的路由和操作返回 JSON 值 `success: true`，如果您能够将用户添加到课程中。如果您成功了，通过添加新的 `joined-button`
    类并移除旧的 `join-button` 类来更改按钮的文本和颜色，以指示用户已加入。这种类的交换允许您在 recipe_app.css 中使用不同的样式规则来样式化每个按钮，同时也防止点击事件触发另一个请求。如果您没有看到按钮颜色的变化，请确保您正在针对正确的按钮类。如果加入课程导致错误，请更改按钮的文本，告诉用户重试。'
- en: '|  |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The variable `$button` has only the `$` in front to indicate that it represents
    a jQuery object. This syntax is stylistic and conventional but not required to
    get your code to work.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `$button` 前面只有 `$` 来表示它代表一个 jQuery 对象。这种语法是风格和传统的，但不是必须的，以使您的代码生效。
- en: '|  |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 27.5\. Adding an event listener to each button in recipeApp.js
  id: totrans-252
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 27.5\. 在 recipeApp.js 中为每个按钮添加事件监听器
- en: '[PRE10]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1*** **Call addJoinButtonListener to add an event listener on your buttons
    after the AJAX request completes.**'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在 AJAX 请求完成后，调用 addJoinButtonListener 方法为你的按钮添加事件监听器。**'
- en: '***2*** **Create the event listener for the modal button.**'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **为模态按钮创建事件监听器。**'
- en: '***3*** **Grab the button and button ID data.**'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **获取按钮和按钮 ID 数据。**'
- en: '***4*** **Make an AJAX request with the course’s ID to join.**'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **使用课程的 ID 发起一个 AJAX 请求以加入课程。**'
- en: '***5*** **Check whether the join action was successful, and modify the button.**'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **检查加入操作是否成功，并修改按钮。**'
- en: Now your application is prepared to send an AJAX request and handle its response
    when the join button is clicked. In the next section, you create the API endpoint
    to handle this request.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的应用程序已准备好在点击加入按钮时发送 AJAX 请求并处理其响应。在下一节中，您将创建处理此请求的 API 端点。
- en: '|  |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 27.2**'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 27.2**'
- en: '**[Q1:](#ch27qa4q0a1)**'
  id: totrans-262
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch27qa4q0a1)**'
- en: ''
  id: totrans-263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why do you need to call the `addJoinButtonListener` function after the modal
    contents are created?
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么需要在模态内容创建后调用 `addJoinButtonListener` 函数？
- en: '|  |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 27.2 answer**'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 27.2 答案**'
- en: '**[1:](#ch27qa3q1)**'
  id: totrans-268
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch27qa3q1)**'
- en: ''
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`addJoinButtonListener` sets an event listener for a specific class within
    the modal contents. To set the listener, you must first create the content in
    the modal.'
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`addJoinButtonListener` 在模态内容中为特定类设置事件监听器。要设置监听器，您必须首先在模态中创建内容。'
- en: '|  |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)27.3\. Creating an API endpoint to connect models'
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)27.3\. 创建一个 API 端点以连接模型'
- en: To complete the course modal, you need to create a route to handle requests
    made for the current user to join a course. To do so, add `router.get("/courses/:id/join",
    courses-Controller.join, coursesController.respondJSON)` to apiRoutes.js. This
    route allows `get` requests to go through a `join` action and feed results to
    your `respondJSON` action, which returns to the client. At the top of coursesController.js,
    require the User model with `const User = require("../models/user")`. Then, in
    coursesController.js, add the `join` action in [listing 27.6](#ch27ex06).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成课程模态，您需要创建一个路由来处理对当前用户加入课程的请求。为此，将 `router.get("/courses/:id/join", courses-Controller.join,
    coursesController.respondJSON)` 添加到 apiRoutes.js 中。此路由允许 `get` 请求通过 `join` 动作，并将结果传递给您的
    `respondJSON` 动作，该动作返回给客户端。在 coursesController.js 的顶部，使用 `const User = require("../models/user")`
    引入 User 模型。然后，在 coursesController.js 中，在 [列表 27.6](#ch27ex06) 中添加 `join` 动作。
- en: In this `join` action, you get the current logged-in user and the course’s ID
    from the URL params. If a `currentUser` exists, use the Mongoose `findByIdAndUpdate`
    to locate the `user` object and update its courses array to contain the target
    course ID. Here, you use the MongoDB `$addToSet` method, which ensures that the
    array has no duplicate IDs. If you’re successful, add a `success` property to
    the response’s `locals` object, which in turn is passed to `respondJSON` and passed
    back to the client. In case the user isn’t logged in or an error occurs while
    updating the user’s association, pass an `error` to be handled by your error-handling
    middleware.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `join` 动作中，您从 URL 参数中获取当前登录用户和课程的 ID。如果存在 `currentUser`，使用 Mongoose 的 `findByIdAndUpdate`
    方法定位 `user` 对象，并更新其课程数组以包含目标课程 ID。在这里，您使用 MongoDB 的 `$addToSet` 方法，确保数组中没有重复的
    ID。如果操作成功，向响应的 `locals` 对象中添加一个 `success` 属性，该对象随后传递给 `respondJSON`，再传递回客户端。如果用户未登录或在更新用户关联时发生错误，传递一个
    `error` 给错误处理中间件进行处理。
- en: Listing 27.6\. Creating an action to join a course in coursesController.js
  id: totrans-275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 27.6\. 在 coursesController.js 中创建加入课程的动作
- en: '[PRE11]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1*** **Add the join action to let users join a course.**'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **添加加入动作以允许用户加入课程。**'
- en: '***2*** **Get the course id and current user from the request.**'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **从请求中获取课程 ID 和当前用户。**'
- en: '***3*** **Check whether a current user is logged in.**'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **检查当前用户是否已登录。**'
- en: '***4*** **Update the user’s courses field to contain the targeted course.**'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **更新用户的课程字段以包含目标课程。**'
- en: '***5*** **Respond with a JSON object with a success indicator.**'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **响应一个包含成功指示器的 JSON 对象。**'
- en: '***6*** **Respond with a JSON object with an error indicator.**'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **响应一个包含错误指示器的 JSON 对象。**'
- en: '***7*** **Pass an error through to the next middleware function.**'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **将错误传递给下一个中间件函数。**'
- en: With this action in place, restart your application, and try joining courses
    in the modal. If you’re not signed in, you may see the `Try Again` text appear
    over the button. Otherwise, depending on your custom styling, your button should
    turn green and change text for every button you click, as shown in [figure 27.2](#ch27fig02).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在此动作就绪后，重新启动您的应用程序，并在模态中尝试加入课程。如果您未登录，您可能会在按钮上看到“重试”文本。否则，根据您的自定义样式，您的按钮应该在每个按钮点击时变为绿色并更改文本，如图
    27.2 所示。
- en: Figure 27.2\. Example modal after a course has been joined
  id: totrans-285
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 27.2\. 加入课程后的示例模态
- en: '![](../Images/27fig02_alt.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/27fig02_alt.jpg)'
- en: You can improve the user experience by letting users know whether they’re already
    part of one or more courses in the modal.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过让用户知道他们是否已经加入了一个或多个课程来改善用户体验。
- en: Given your application structure and model schemas, you can filter your results
    by adding the middleware function `filterU``s``erCourses` to coursesController.js,
    as shown in [listing 27.7](#ch27ex07). In this code, you’re checking whether a
    user is logged in before you continue. If a user is logged in, use the `map` function
    on your array of courses. Within this function, look at each course and check
    whether its `_id` is found in your logged-in user’s array of courses. The `some`
    function returns a Boolean value to let you know if a match occurs. If a user
    has joined a course with ID `5a98eee50e424815f0517ad1`, for example, that ID should
    exist in `curre``n``tUser.courses`, and the `userJoined` value for that course
    is `true`. Last, convert the `courses` Mongoose document object to JSON so that
    you can append an additional property by using `Object.assign`. This property,
    `joined`, lets you know in the user interface whether the user previously joined
    the course. If no user is logged in, call `next` to pass along the unmodified
    course results.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的应用程序结构和模型模式，你可以通过将中间件函数 `filterUserCourses` 添加到 coursesController.js 中来过滤你的结果，如
    [列表 27.7](#ch27ex07) 所示。在这段代码中，你在继续之前检查用户是否已登录。如果用户已登录，使用数组中的 `map` 函数。在此函数中，查看每个课程并检查其
    `_id` 是否在登录用户的课程数组中。`some` 函数返回一个布尔值，让你知道是否发生匹配。例如，如果用户已加入 ID 为 `5a98eee50e424815f0517ad1`
    的课程，则该 ID 应该存在于 `currentUser.courses` 中，并且该课程的 `userJoined` 值为 `true`。最后，将 `courses`
    Mongoose 文档对象转换为 JSON，以便使用 `Object.assign` 添加一个附加属性。这个属性 `joined` 让你在用户界面中知道用户是否以前加入过该课程。如果没有用户登录，调用
    `next` 以传递未修改的课程结果。
- en: Listing 27.7\. Adding an action to filter courses in coursesController.js
  id: totrans-289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 27.7\. 在 coursesController.js 中添加过滤课程的动作
- en: '[PRE12]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1*** **Check whether a user is logged in.**'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **检查用户是否已登录。**'
- en: '***2*** **Modify course data to add a flag indicating user association.**'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **修改课程数据以添加表示用户关联的标志。**'
- en: '***3*** **Check whether the course exists in the user’s courses array.**'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **检查课程是否存在于用户的课程数组中。**'
- en: To use this middleware function, you need to add it to your API route for `/courses`
    before you return the JSON response. The route will look like `router.get("/courses",
    coursesController.index, coursesController.filterUserCourses, coursesController
    .respondJSON)`, where `coursesController.filterUserCourses` sits after your query
    for courses in `coursesController.index`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此中间件函数，你需要在返回 JSON 响应之前将其添加到 `/courses` API 路由中。该路由看起来像 `router.get("/courses",
    coursesController.index, coursesController.filterUserCourses, coursesController.respondJSON)`，其中
    `coursesController.filterUserCourses` 位于 `coursesController.index` 中查询课程之后。
- en: The last step is changing the client-side JavaScript in recipeApp.js to check
    whether the current user has already joined the course and modifying the button
    in the course listing modal. In [listing 27.8](#ch27ex08), you use a ternary operator
    in the button’s class attribute and main text content. These operators check whether
    the course data’s `joined` property is `true` or `false`. If the property is `true`,
    create the button to indicate that the user has already joined. Otherwise, display
    a button inviting users to join.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将 recipeApp.js 中的客户端 JavaScript 修改为检查当前用户是否已经加入课程，并修改课程列表模态中的按钮。在 [列表 27.8](#ch27ex08)
    中，你在按钮的类属性和主要文本内容中使用三元运算符。这些运算符检查课程数据的 `joined` 属性是 `true` 还是 `false`。如果是 `true`，则创建按钮以指示用户已经加入。否则，显示一个邀请用户加入的按钮。
- en: Listing 27.8\. Adding dynamic button styling in recipeApp.js
  id: totrans-296
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 27.8\. 在 recipeApp.js 中添加动态按钮样式
- en: '[PRE13]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1*** **Add the appropriate class to reflect join status.**'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **添加适当的类以反映加入状态。**'
- en: '***2*** **Add the button’s text to reflect join status.**'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **添加按钮文本以反映加入状态。**'
- en: After applying these changes, relaunch your application and log in. The color
    and text of your course-listing buttons will correctly reflect the status of your
    associations in the database.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 应用这些更改后，重新启动你的应用程序并登录。你的课程列表按钮的颜色和文本将正确反映数据库中关联的状态。
- en: '|  |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: If you experience problems maintaining a logged-in account, make sure to use
    sessions and cookies prior to initializing `passport` and your custom middleware.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在维护登录账户时遇到问题，确保在初始化 `passport` 和自定义中间件之前使用会话和 cookies。
- en: '|  |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 27.3**'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 27.3**'
- en: '**[Q1:](#ch27qa6q0a1)**'
  id: totrans-307
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch27qa6q0a1)**'
- en: ''
  id: totrans-308
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why do you need to use the `findByIdAndUpdate` method?
  id: totrans-309
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你为什么需要使用 `findByIdAndUpdate` 方法？
- en: '|  |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 27.3 answer**'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 27.3 答案**'
- en: '**[1:](#ch27qa5q1)**'
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch27qa5q1)**'
- en: ''
  id: totrans-314
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `findByIdAndUpdate` Mongoose method combines the `find` and `update` methods,
    so you can conveniently perform a single step to update a user document.
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`findByIdAndUpdate` Mongoose 方法结合了 `find` 和 `update` 方法，因此您可以方便地执行单个步骤来更新用户文档。'
- en: '|  |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)Summary'
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)摘要'
- en: In this lesson, you learned how to modify your namespacing structure to accommodate
    an API for JSON data responses. You also improved your courses modal by allowing
    users to join specific courses without needing to change pages. Through the AJAX
    requests and API endpoints you created, more of your application’s functionality
    can move to a single page and away from individual views for each action. In [lesson
    28](../Text/kindle_split_045.html#ch28), I discuss some ways in which you can
    secure your API.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，您学习了如何修改命名空间结构以适应 JSON 数据响应的 API。您还通过允许用户在不更改页面的情况下加入特定课程来改进了您的课程模式。通过您创建的
    AJAX 请求和 API 端点，您应用程序的功能可以更多地移动到单个页面，并远离每个动作的独立视图。在 [第 28 课](../Text/kindle_split_045.html#ch28)
    中，我讨论了您可以用来保护您的 API 的一些方法。
- en: '|  |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Try this**'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试以下操作**'
- en: With this new API in place, you’ll want to create endpoints for every route
    that might return data. You may want to add every `index` and `show` action to
    the controllers in the `api` directory, for example.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新 API 就位后，您可能希望为每个可能返回数据的路由创建端点。例如，您可能希望将 `api` 目录中的每个 `index` 和 `show` 动作添加到控制器中。
- en: Create those actions and one additional action to create a user, and return
    JSON with a confirmation of success or failure instead of a rendered view.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这些动作以及一个额外的创建用户的动作，并返回包含成功或失败确认的 JSON，而不是渲染视图。
- en: '|  |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Lesson 28\. Adding API Security
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 28 课\. 添加 API 安全性
- en: In this lesson, you apply a few security strategies to your API routes. Without
    a browser to store cookies, some external applications may find it difficult to
    use your API without a way to verify the user’s identity. First, you implement
    some basic security by providing an API token that must be appended to each request.
    Then you improve that strategy by generating a unique API key for each user upon
    account creation. Last, you explore JSON Web Tokens (JWT), a system of hashing
    user data and exchanging tokens to authenticate user accounts without a browser.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，您将一些安全策略应用到您的 API 路由上。由于没有浏览器来存储 cookies，一些外部应用程序可能在没有验证用户身份的方式下难以使用您的
    API。首先，您通过提供必须附加到每个请求的 API 令牌来实现一些基本安全措施。然后，您通过在账户创建时为每个用户生成唯一的 API 密钥来改进这一策略。最后，您探讨了
    JSON Web Tokens (JWT)，这是一种通过散列用户数据和交换令牌来验证用户账户的系统，而不需要浏览器。
- en: This lesson covers
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 本课涵盖
- en: Adding security-token-verification middleware
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加安全令牌验证中间件
- en: Creating a `pre("save")` hook to generate API keys
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `pre("save")` 钩子以生成 API 密钥
- en: Implementing JWT header authentication
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现JWT头部认证
- en: '|  |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑以下内容**'
- en: You built a robust API for the recipe application. Your endpoints include routes
    to create new users and update existing users. Because an API endpoint can be
    accessed from any device that can make an HTTP request, there’s no telling who
    might make a request to your API without first creating an account and storing
    session data on the server.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 您为食谱应用程序构建了一个强大的 API。您的端点包括创建新用户和更新现有用户的路由。由于 API 端点可以从任何可以发出 HTTP 请求的设备访问，因此无法预测谁可能会在没有首先创建账户并在服务器上存储会话数据的情况下向您的
    API 发出请求。
- en: Having some form of security on your API routes ensures that your data doesn’t
    fall into the wrong hands.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 API 路由上实施某种形式的安全措施可以确保您的数据不会落入错误的手中。
- en: '|  |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)28.1\. Implementing simple security'
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)28.1\. 实现简单安全'
- en: '[Unit 5](../Text/kindle_split_037.html#part05) guided you through user-account
    creation and authentication. With the help of a few packages, you created a thorough
    process of validating and encrypting user data and of ensuring that those users
    were authenticated before getting access to certain pages.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '[单元 5](../Text/kindle_split_037.html#part05) 指导您完成了用户账户创建和身份验证的过程。借助几个包的帮助，您创建了一个全面的过程，用于验证和加密用户数据，并确保这些用户在访问某些页面之前已经通过身份验证。'
- en: Even without the help of external packages, you can take some simple steps to
    protect your API. The first method you’ll use in this lesson is generating an
    API token that must be used by users accessing your API. Users need to have a
    token because they may not be using a browser to access the API, so your current
    implementation with Passport.js, cookies, and sessions may not work with the client.
    An additional token reduces this risk, ensuring that only users who make requests
    with a valid token can see data. You could add `app.set("token", process.env.TOKEN
    || "recipeT0k3n")` to main.js, for example. Then this application variable would
    be set to whatever you use as the `TOKEN` environment variable or default to `recipeT0k3n`.
    The token could be retrieved by using `app.get("token")`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有外部包的帮助，你也可以采取一些简单的步骤来保护你的API。在本课中，你将使用的第一种方法是生成一个API令牌，该令牌必须由访问你的API的用户使用。用户需要令牌，因为他们可能不是使用浏览器来访问API，所以你当前的Passport.js、cookies和session实现可能无法与客户端一起工作。额外的令牌可以降低这种风险，确保只有使用有效令牌发起请求的用户才能看到数据。例如，你可以在main.js中添加`app.set("token",
    process.env.TOKEN || "recipeT0k3n")`。然后这个应用程序变量就会设置为你在`TOKEN`环境变量中使用的值，或者默认为`recipeT0k3n`。令牌可以通过使用`app.get("token")`来检索。
- en: Because you want to monitor incoming requests to the API in the `apiRoutes`
    module, set the token as a constant in usersController.js in the api folder, using
    `const token = process.env.TOKEN || "recipeT0k3n"`. This token will be used by
    middleware within usersController.js to verify incoming API requests. Create that
    middleware function by adding the code in [listing 28.1](#ch28ex01) to usersController.js.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你想在`apiRoutes`模块中监控对API的传入请求，所以在api文件夹中的usersController.js中设置令牌为一个常量，使用`const
    token = process.env.TOKEN || "recipeT0k3n"`。这个令牌将由usersController.js中的中间件用于验证传入的API请求。通过在usersController.js中添加[列表28.1](#ch28ex01)中的代码来创建这个中间件函数。
- en: This middleware function, `verifyToken`, checks for a query param called `apiToken`
    that matches the token you set earlier. If the tokens match, call `next` to continue
    the middleware chain; otherwise, pass an error with a custom message. This error
    reaches your error-handling middleware and displays the message as JSON.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这个中间件函数`verifyToken`检查一个名为`apiToken`的查询参数，该参数与之前设置的令牌匹配。如果令牌匹配，调用`next`以继续中间件链；否则，传递一个带有自定义消息的错误。这个错误会到达你的错误处理中间件，并以JSON格式显示消息。
- en: Listing 28.1\. Adding middleware function to verify API token in usersController.js
  id: totrans-340
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表28.1\. 在usersController.js中添加验证API令牌的中间件函数
- en: '[PRE14]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1*** **Create the verifyToken middleware function with the next parameter.**'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **创建带有next参数的verifyToken中间件函数。**'
- en: '***2*** **Call the next middleware function if tokens match.**'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **如果令牌匹配，调用下一个中间件函数。**'
- en: '***3*** **Respond with error message if tokens don’t match.**'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **如果令牌不匹配，则返回错误消息。**'
- en: To add the `usersController.verifyToken` middleware so that it runs before every
    API request is handled, you can add `rou``t``er.use(usersController.verifyToken)`,
    as the first function in apiRoutes.js. You also need to require the users controller
    by adding `const usersController = require("../controllers/usersController")`
    to apiRoutes.js.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加`usersController.verifyToken`中间件，以便在处理每个API请求之前运行，你可以在apiRoutes.js中将`router.use(usersController.verifyToken)`作为第一个函数添加。你还需要通过在apiRoutes.js中添加`const
    usersController = require("../controllers/usersController")`来引入用户控制器。
- en: 'Restart your application, and when you visit http://localhost:3000/api/courses,
    notice the following error message: `{"st``a``tus":500, "message":"Invalid API
    token."}`. This message is a good sign. It means that your API validation is working
    because you didn’t make a request by using a valid API token.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动你的应用程序，当你访问http://localhost:3000/api/courses时，请注意以下错误消息：`{"status":500,
    "message":"Invalid API token."}`。这是一个好兆头。这意味着你的API验证正在工作，因为你没有使用有效的API令牌发起请求。
- en: 'To bypass this message, add the `apiToken` query parameter. Visiting http://localhost:
    3000/api/courses?apiToken=recipeT0k3n should result in a display of the original
    course data in JSON format. If you choose to implement your API security this
    way, you need to share this token with your trusted users. To get your AJAX requests
    to work, add the `?apiToken=recipeT0k3n` query parameter to those URLs as well
    in recipeApp.js.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 要绕过此消息，请添加`apiToken`查询参数。访问http://localhost:3000/api/courses?apiToken=recipeT0k3n应该会以JSON格式显示原始课程数据。如果你选择以这种方式实现你的API安全，你需要将此令牌与你的信任用户共享。为了使你的AJAX请求正常工作，你还需要在recipeApp.js中将`?apiToken=recipeT0k3n`查询参数添加到那些URL中。
- en: This simple security barrier is definitely a start, but you can imagine that
    it quickly becomes an unreliable system as more users require the token to access
    your API. The more users who have access to the same token, the more likely it
    is for that token to fall into the hands of nonusers. When you’re quickly building
    an application that requires a thin layer of security, this approach may be sufficient.
    When the application is live online, however, you’ll want to modify the API security
    to treat each user request uniquely.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的安全屏障无疑是开始，但随着更多用户需要令牌来访问您的 API，它很快就会成为一个不可靠的系统。拥有相同令牌的访问用户越多，该令牌落入非用户手中的可能性就越大。当您快速构建需要薄层安全的应用程序时，这种方法可能足够用。然而，当应用程序上线时，您将希望修改
    API 安全性，以独特的方式处理每个用户请求。
- en: In the next section, you explore ways to keep the token unique for each user.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将探索保持每个用户令牌唯一性的方法。
- en: '|  |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 28.1**'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 28.1**'
- en: '**[Q1:](#ch28qa2q0a1)**'
  id: totrans-352
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch28qa2q0a1)**'
- en: ''
  id: totrans-353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why might you store a secret token in `process.env.TOKEN`?
  id: totrans-354
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么您可能会在 `process.env.TOKEN` 中存储一个秘密令牌？
- en: '|  |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 28.1 answer**'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 28.1 答案**'
- en: '**[1:](#ch28qa1q1)**'
  id: totrans-358
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch28qa1q1)**'
- en: ''
  id: totrans-359
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You can store sensitive or secret data in `process.env` as environmental variables.
    These variables are normally stored on the server but don’t need to appear in
    the code. This practice makes it easier to change the token directly on the server
    (you don’t have to change the code each time), and it’s a more-secure convention.
  id: totrans-360
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您可以将敏感或秘密数据存储在 `process.env` 中作为环境变量。这些变量通常存储在服务器上，但不需要出现在代码中。这种做法使得直接在服务器上更改令牌变得更加容易（您不必每次都更改代码），并且这是一种更安全的约定。
- en: '|  |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)28.2\. Adding API tokens'
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)28.2\. 添加 API 令牌'
- en: You just constructed a middleware function to verify API tokens passed as query
    parameters in the URL. This method is effective at securing your API, but it doesn’t
    prevent nonusers from getting their hands on the one and only token.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚构建了一个中间件函数来验证 URL 中作为查询参数传递的 API 令牌。这种方法在保护您的 API 方面非常有效，但它不能阻止非用户获取唯一的令牌。
- en: To improve this system, add a custom token to each user account. Do this by
    adding a new `apiToken` field to the user schema that’s of type String. Next,
    build a `pre("save")` hook on the `User` model to generate an API token that’s
    unique to that user upon account creation. Before you get to the code, use a Node.js
    package to help with the token generation.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进这个系统，为每个用户账户添加一个自定义令牌。通过在用户模式中添加一个新的 `apiToken` 字段（类型为 String）来实现。接下来，在
    `User` 模型上构建一个 `pre("save")` 钩子，在账户创建时为该用户生成一个唯一的 API 令牌。在您看到代码之前，使用 Node.js 包来帮助生成令牌。
- en: The `rand-token` package provides some simple tools for creating new alphanumeric
    tokens of your desired length. Run `npm install rand-token -S` to install the
    `rand-token` package in this project, and require it in user.js by adding `const
    randToken = require ("rand-token")`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`rand-token` 包提供了一些创建所需长度的新字母数字令牌的简单工具。运行 `npm install rand-token -S` 在此项目中安装
    `rand-token` 包，并在 user.js 中通过添加 `const randToken = require ("rand-token")` 来引入它。'
- en: Add the code in the next listing to user.js. This code first checks whether
    the user’s -`apiToken` field is set. If it isn’t, generate a new unique 16-character
    token with `rand-Token.generate`.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到 user.js 中。此代码首先检查用户的 `-apiToken` 字段是否已设置。如果没有，则使用 `rand-Token.generate`
    生成一个新的唯一 16 位字符令牌。
- en: Listing 28.2\. Creating a `pre(`“`save`”`)` hook to generate an API token in
    user.js
  id: totrans-367
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 28.2\. 在 user.js 中创建一个 `pre("save")` 钩子以生成 API 令牌
- en: '[PRE15]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1*** **Check for an existing API token and generate a new one with randToken.generate.**'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **检查现有的 API 令牌，并使用 randToken.generate 生成一个新的。**'
- en: '|  |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-371
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You can improve the functionality here by comparing the generated token with
    other users’ tokens to ensure that no duplicity occurs.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过比较生成的令牌与其他用户的令牌来改进这里的函数，以确保不会发生重复。
- en: '|  |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Next, add the `apiToken` field as an item in the table on the user’s `show`
    page. This way, when a new user visits their profile page, they’ll have access
    to their API token. In [figure 28.1](#ch28fig01), for example, my user account
    has the token `2plMh5yZMFULOzpx`.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将 `apiToken` 字段添加到用户 `show` 页面表格中的项目。这样，当新用户访问他们的个人资料页面时，他们将能够访问他们的 API
    令牌。例如，在 [图 28.1](#ch28fig01) 中，我的用户账户的令牌是 `2plMh5yZMFULOzpx`。
- en: Figure 28.1\. Displaying the API token on the user’s show page
  id: totrans-375
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 28.1\. 在用户的显示页面上显示 API 令牌
- en: '![](../Images/28fig01_alt.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/28fig01_alt.jpg)'
- en: To use this token, you need to modify the `verifyToken` middleware to check
    the `apiToken` query param against the tokens in your database. Change `verifyToken`
    in /api/users-Controller.js to use the code in [listing 28.3](#ch28ex03).
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此令牌，您需要修改`verifyToken`中间件以将`apiToken`查询参数与数据库中的令牌进行比较。将/api/users-Controller.js中的`verifyToken`更改为使用[列表28.3](#ch28ex03)中的代码。
- en: In this modified middleware function, you grab the token as the query parameter.
    If a token appears in the URL, search the user database for a single user who
    has that API token. If such a user exists, continue to the next middleware function.
    If no user with that token exists, if an error occurs in the query, or if no query
    parameter was used, pass an error.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在此修改后的中间件函数中，您将令牌作为查询参数获取。如果URL中出现了令牌，则在用户数据库中搜索具有该API令牌的单个用户。如果存在这样的用户，则继续到下一个中间件函数。如果没有用户具有该令牌，如果查询中发生错误，或者没有使用查询参数，则传递错误。
- en: Listing 28.3\. Improving the token verification action in usersController.js
  id: totrans-379
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表28.3\. 在usersController.js中改进令牌验证动作
- en: '[PRE16]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1*** **Check whether a token exists as the query parameter.**'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **检查是否存在作为查询参数的令牌。**'
- en: '***2*** **Search for a user with the provided API token.**'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **搜索具有提供的API令牌的用户。**'
- en: '***3*** **Call next if a user with the API token exists.**'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **如果存在具有API令牌的用户，则调用next。**'
- en: '***4*** **Pass an error to error handler.**'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **将错误传递给错误处理器。**'
- en: 'Restart your application, and create a new user account. Visit that new user’s
    show page, and locate the `apiToken` value. Then visit http://localhost:3000/api/courses?
    api-Token= followed by the API token for that user. The `jon@jonwexler.com` user,
    for example, would use the following URL: http://localhost:3000/api/courses?apiToken=
    2plMh5yZMFULOzpx. You should see the list of courses in JSON as before.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动您的应用程序，并创建一个新的用户账户。访问该新用户的展示页面，并找到`apiToken`值。然后访问http://localhost:3000/api/courses?
    api-Token=后跟该用户的API令牌。例如，`jon@jonwexler.com`用户将使用以下URL：http://localhost:3000/api/courses?apiToken=
    2plMh5yZMFULOzpx。您应该会看到与之前相同的课程列表。
- en: 'This new system reduces the vulnerability of having a single API token for
    all users. With the API token connected to a user account, you could also verify
    the user’s information in your database and keep metrics on the number or quality
    of that user’s API requests. To get your client-side JavaScript to use this token
    in your API calls, you can add a hidden element to layout.ejs with the current
    user’s token. You could add `<div id="apiToken" data-token="<%= currentUser.apiToken
    %>" style="display: none;">` within the block to check whether a user is logged
    in, for example. Then, when the document is ready in recipeApp.js, you can locate
    the token, use it with `let apiToken = $(``"``#apiToken``"``).data (``"``token``"``)`,
    and call your Ajax request on `/api/courses?apiToken=${apiToken}`.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '这个新系统降低了所有用户使用单个API令牌的脆弱性。与用户账户关联的API令牌，您还可以验证数据库中的用户信息，并跟踪该用户API请求的数量或质量。要使客户端JavaScript在API调用中使用此令牌，您可以在layout.ejs中添加一个隐藏元素，包含当前用户的令牌。例如，您可以在块内添加`<div
    id="apiToken" data-token="<%= currentUser.apiToken %>" style="display: none;">`来检查用户是否已登录。然后，当recipeApp.js中的文档准备好时，您可以找到令牌，使用`let
    apiToken = $(``"``#apiToken``"``).data (``"``token``"``)`，并在`/api/courses?apiToken=${apiToken}`上调用您的Ajax请求。'
- en: Still, you can take a more-secure approach to building API authentication in
    which a web browser isn’t necessarily involved. That method uses JSON web tokens
    (JWT).
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，您还可以采取更安全的构建API认证的方法，其中不一定涉及网络浏览器。该方法使用JSON Web令牌（JWT）。
- en: '|  |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 28.2**'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查28.2**'
- en: '**[Q1:](#ch28qa4q0a1)**'
  id: totrans-390
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch28qa4q0a1)**'
- en: ''
  id: totrans-391
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What does `randToken.generate(16)` do?
  id: totrans-392
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`randToken.generate(16)`做什么？'
- en: '|  |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 28.2 answer**'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 28.2 答案**'
- en: '**[1:](#ch28qa3q1)**'
  id: totrans-396
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch28qa3q1)**'
- en: ''
  id: totrans-397
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This method generates a random 16-character alphanumeric token.
  id: totrans-398
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此方法生成一个随机的16位字母数字令牌。
- en: '|  |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)28.3\. Using JSON web tokens'
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)28.3\. 使用JSON Web令牌'
- en: You can build a secure API by using cookies, but the API’s functionality still
    depends on its clients to support and store those cookies. Consider someone who
    writes a script to run requests against your API solely from their terminal window,
    for example. In this case, if you want to apply user authentication on incoming
    requests, you need some way to keep track of which users are requesting and whether
    they’ve recently logged in. Without a visual login page, that task can be difficult.
    You can try some alternative solutions, one of which is using JSON web tokens.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 cookies 来构建一个安全的 API，但 API 的功能仍然依赖于其客户端支持并存储这些 cookies。考虑一下，例如，有人编写了一个脚本，仅从他们的终端窗口向你的
    API 发送请求。在这种情况下，如果你想在传入的请求上应用用户认证，你需要某种方式来跟踪哪些用户正在请求以及他们是否最近登录。没有可视化的登录页面，这项任务可能会很困难。你可以尝试一些替代解决方案，其中之一就是使用
    JSON web tokens。
- en: '*JSON web tokens* (JWT) are signed or encrypted data passed between the server
    and client as a means of representing an authenticated user request. Ultimately,
    JWTs are like sessions in a different format and used differently in web communication.
    You can think of JWTs as being like API tokens that are regenerated on every login.
    JWTs contain three parts, as defined in [table 28.1](#ch28table01).'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '*JSON web tokens* (JWT) 是作为表示已认证用户请求的手段，在服务器和客户端之间传递的签名或加密数据。最终，JWTs 就像不同格式的会话，在
    Web 通信中用法不同。你可以将 JWTs 视为在每次登录时重新生成的 API 令牌。JWTs 包含三个部分，如 [表 28.1](#ch28table01)
    中定义的。'
- en: Table 28.1\. Parts of JWTs
  id: totrans-403
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 28.1\. JWT 的组成部分
- en: '| JWT part | Description |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| JWT 部分 | 描述 |'
- en: '| --- | --- |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| --- | ---'
- en: '| Header | A JSON object detailing how the data in the JWT is prepared and
    hashed. |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| 头部 | 一个 JSON 对象，详细说明了 JWT 中数据的准备和哈希方式。 |'
- en: '| Payload | The data stored in the JWT, used to verify the user who previously
    authenticated. The payload normally includes the user’s ID. |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| 有效载荷 | 存储在 JWT 中的数据，用于验证之前已认证的用户。有效载荷通常包括用户的 ID。 |'
- en: '| Signature | A hashed code using the header and payload values. |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| 签名 | 使用头部和有效载荷值生成的哈希码。 |'
- en: '|  |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-410
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: The smaller the payload, the smaller the JWT and the faster it’s sent with each
    response.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 有效载荷越小，JWT 越小，每次响应发送的速度就越快。
- en: '|  |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: These three values together offer a unique arrangement of data indicating the
    recent login status for a specific user. First, the user makes a request and passes
    their email and password. The server responds with an encoded JWT verifying the
    user’s correct login information. For each subsequent user request, that same
    JWT must be sent back to the server. Then the server verifies the JWT by decoding
    its values and locating the user specified in the payload. Unlike in password
    encryption with Passport.js and `bcrypt`, JWTs aren’t encrypted through hashing
    and salting. JWTs are encoded, which means that the server can decode the JWT
    to reveal its contents without needing to know some secret value set by the user.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个值共同提供了一个特定用户最近登录状态的独特数据排列。首先，用户发起请求并传递他们的电子邮件和密码。服务器响应一个编码的 JWT，以验证用户的正确登录信息。对于每个后续的用户请求，必须将相同的
    JWT 发送回服务器。然后服务器通过解码其值并定位有效载荷中指定的用户来验证 JWT。与 Passport.js 和 `bcrypt` 中的密码加密不同，JWTs
    不是通过哈希和加盐来加密的。JWTs 是编码的，这意味着服务器可以解码 JWT 来揭示其内容，而无需知道用户设置的某些秘密值。
- en: In this section, you apply JWT API security with the help of the `jsonwebtoken`
    package. Install the `jsonwebtoken` package by running `npm i jsonwebtoken -S`
    in terminal. Because you’re going to use JWTs for user verification in the API,
    require `jsonwebtoken` in users-Controller.js with `const jsonWebToken = require("jsonwebtoken")`.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将在 `jsonwebtoken` 包的帮助下应用 JWT API 安全性。通过在终端中运行 `npm i jsonwebtoken -S`
    来安装 `jsonwebtoken` 包。由于你打算在 API 中使用 JWT 进行用户验证，请在 users-Controller.js 中使用 `const
    jsonWebToken = require("jsonwebtoken")` 引入 `jsonwebtoken`。
- en: To use JWTs, you need to allow the user to log in without a browser. Create
    a new API login action by adding the code in [listing 28.4](#ch28ex04) to usersController.js.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 JWTs，你需要允许用户在没有浏览器的情况下登录。通过将 [清单 28.4](#ch28ex04) 中的代码添加到 usersController.js
    中来创建一个新的 API 登录操作。
- en: '|  |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-417
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You can find more information on the jsonwebtoken package at [https://github.com/auth0/node-jsonwebtoken](https://github.com/auth0/node-jsonwebtoken).
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/auth0/node-jsonwebtoken](https://github.com/auth0/node-jsonwebtoken)
    上找到有关 jsonwebtoken 包的更多信息。
- en: '|  |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: This action uses the Passport.js `local` strategy that you set up in [lesson
    24](../Text/kindle_split_040.html#ch24). Through the authenticate method, verify
    that the user email address and password match that of a user in the database.
    Then, through a callback function, if a user is found with the matching email
    and password, use `jsonWebToken.sign` to create a token with the user’s ID and
    an expiration date set to one day from the time of signing. Finally, respond with
    a JSON object with a success tag and the signed token; otherwise, respond with
    the error message.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作使用你在[第24课](../Text/kindle_split_040.html#ch24)中设置的Passport.js `local`策略。通过authenticate方法，验证用户电子邮件地址和密码是否与数据库中用户的匹配。然后，通过回调函数，如果找到具有匹配电子邮件和密码的用户，使用`jsonWebToken.sign`创建一个包含用户ID和设置为一日签发时间的过期日期的令牌。最后，返回一个包含成功标签和已签名的令牌的JSON对象；否则，返回错误消息。
- en: Listing 28.4\. Creating a login action for the API in usersController.js
  id: totrans-421
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表28.4\. 在usersController.js中为API创建登录操作
- en: '[PRE17]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1*** **Authenticate with the passport.authenticate method.**'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **使用passport.authenticate方法进行身份验证。**'
- en: '***2*** **Sign the JWT if a user exists with matching email and password.**'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **如果存在与匹配的电子邮件和密码匹配的用户，则对JWT进行签名。**'
- en: '***3*** **Respond with the JWT.**'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **返回JWT。**'
- en: '***4*** **Respond with an error message.**'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **返回错误消息。**'
- en: Now this token can be used for 24 hours to make requests to secured API endpoints.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，此令牌可以用于24小时，以对受保护的API端点进行请求。
- en: 'Next, add the following `POST` route to `apiRoutes.js`: `router.post(`“`/login`”,
    `usersController.apiAuthenticate)`. You can generate the token without a browser
    by making a `POST` request to the `/api/login` route with your email and password
    in the body. To do so, run a curl command in terminal, such as `curl -d "email=jon@jonwexler.com&password=12345"
    http://localhost:3000/api/login`. In this example, the `-d` flag indicates that
    the user is posting their email and password as data to the provided URL. After
    running this command, you should expect a response similar to the response in
    the next listing.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将以下`POST`路由添加到`apiRoutes.js`：`router.post("'/login'", usersController.apiAuthenticate)`。您可以通过向`/api/login`路由发送带有电子邮件和密码的`POST`请求来生成令牌，而无需浏览器。为此，在终端中运行curl命令，例如`curl
    -d "email=jon@jonwexler.com&password=12345" http://localhost:3000/api/login`。在此示例中，`-d`标志表示用户正在将他们的电子邮件和密码作为数据发送到提供的URL。运行此命令后，您应该期望收到类似于下一个列表中响应的响应。
- en: Listing 28.5\. Example response for a successful JWT authentication in terminal
  id: totrans-429
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表28.5\. 成功JWT身份验证的终端示例响应
- en: '[PRE18]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1*** **Display of a successful response with a JWT after authentication.**'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在身份验证后显示带有JWT的成功响应。**'
- en: To secure all the API endpoints, add an action to verify incoming JWTs and add
    that middleware for every API route. Add the code in [listing 28.6](#ch28ex06)
    to usersController.js.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 要保护所有API端点，添加一个验证传入JWT的操作，并将该中间件添加到每个API路由。将代码添加到[列表28.6](#ch28ex06)中的usersController.js。
- en: First, pull the incoming token from the request header. Then, if a token exists,
    use `jsonWebToken.verify` along with the token and secret passphrase to decode
    the token and verify its authenticity. The following callback provides any errors
    that may have occurred, as well as the decoded payload. You can check whether
    the payload has a value. If so, pull the user’s ID from `pa``y``load.data`, and
    query the database for a user with that ID. If no such user exists, that user’s
    account may have been deleted, or the JWT may have been tampered with, so return
    an error message. If the user ID matches, call `next` and move on to the API endpoint.
    This method of communication continues until the token expires and the user creates
    a new JWT.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从请求头中提取传入的令牌。然后，如果存在令牌，使用`jsonWebToken.verify`以及令牌和密钥短语来解码令牌并验证其真实性。以下回调提供了可能发生的任何错误，以及解码后的有效载荷。你可以检查有效载荷是否有值。如果有，从`payload.data`中提取用户的ID，并查询具有该ID的用户。如果不存在这样的用户，该用户的账户可能已被删除，或者JWT可能已被篡改，因此返回错误消息。如果用户ID匹配，调用`next`并继续到API端点。这种通信方式会持续到令牌过期，用户创建新的JWT。
- en: Listing 28.6\. Creating a verification action for the API in usersController.js
  id: totrans-434
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表28.6\. 在usersController.js中为API创建验证操作
- en: '[PRE19]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1*** **Retrieve the JWT from request headers.**'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **从请求头中检索JWT。**'
- en: '***2*** **Verify the JWT, and decode its payload.**'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **验证JWT并解码其有效载荷。**'
- en: '***3*** **Check for a user with the decoded user ID from the JWT payload.**'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **检查JWT有效载荷中解码的用户ID是否存在用户。**'
- en: '***4*** **Call the next middleware function if a user is found with the JWT
    ID.**'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **如果找到具有JWT ID的用户，则调用下一个中间件函数。**'
- en: '***5*** **Respond with an error message if the token can’t be verified.**'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **如果无法验证令牌，则返回错误信息。**'
- en: '***6*** **Respond with an error message if no token is found in the request
    headers.**'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **如果请求头中没有找到令牌，则返回错误信息。**'
- en: The final step is placing this `verifyJWT` middleware function before any API
    request is processed. Add `rou``t``er.use(usersController.verifyJWT)` to apiRoute.js
    below the `login` route and above all other routes. This step ensures that every
    route needs to use the `verifyJWT` middleware except for the `login` route, which
    is used to generate your JWT.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将此`verifyJWT`中间件函数放置在处理任何API请求之前。在`apiRoute.js`中在`login`路由下方和所有其他路由上方添加`router.use(usersController.verifyJWT)`。这一步骤确保除了用于生成JWT的`login`路由外，每个路由都需要使用`verifyJWT`中间件。
- en: '|  |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-444
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: At this point, you no longer need your token generator hook on the User model
    or any remnants of the past two API security techniques to use JWTs. You may want
    to keep these recently implemented API security techniques in place, however,
    as a fallback to access your API. More work is needed to get these security approaches
    to work together.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你不再需要在用户模型上的令牌生成钩子或过去两种API安全技术的任何残留部分来使用JWT。然而，你可能希望保留这些最近实施的API安全技术作为访问你的API的备用方案。要使这些安全方法协同工作，还需要做更多的工作。
- en: '|  |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You can test your JWT by running another curl command in terminal and identifying
    the token in the request headers. With the token from [listing 28.5](#ch28ex05),
    that command looks like [listing 28.7](#ch28ex07).
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在终端中运行另一个curl命令并识别请求头中的令牌来测试你的JWT。使用[列表28.5](#ch28ex05)中的令牌，该命令看起来像[列表28.7](#ch28ex07)。
- en: In this command, you use the `-H` flag to indicate a header key-value pair for
    your JWT in quotation marks. By making a request and passing a valid JWT, you
    should gain access to the application’s data.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在此命令中，你使用`-H`标志来指示JWT的引号内的header键值对。通过发送请求并传递有效的JWT，你应该能够访问应用程序的数据。
- en: '|  |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-450
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: You need to remove the `usersController.verifyToken` action to make this new
    approach work. Otherwise, your application will look for both a JWT header and
    an `apiToken`.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要移除`usersController.verifyToken`操作以使这种新方法生效。否则，你的应用程序将同时寻找JWT头和`apiToken`。
- en: '|  |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 28.7\. Creating a verification action for the API in usersController.js
  id: totrans-453
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表28.7\. 在usersController.js中为API创建验证操作
- en: '[PRE20]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1*** **Make a request with JWT in the headers.**'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在头部发送JWT请求。**'
- en: '|  |'
  id: totrans-456
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-457
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: The way you’re building your API to use JWTs will interfere with the work you’ve
    already done in your client-side Ajax request. Consider this section to be an
    introduction to using JWTs, not necessarily a replacement for the security you’ve
    implemented in the recipe application so far.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 你构建API以使用JWT的方式将干扰你已经在客户端Ajax请求中完成的工作。请将本节视为使用JWT的介绍，而不是替换迄今为止在食谱应用中实现的安全的必要替代品。
- en: '|  |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If your request is successful, you should expect to see the same list of courses
    as the JSON from the first section of this lesson. If you plan to use JWTs for
    securing your API, you need to specify to the users of your API exactly how you
    expect them to authenticate and verify their tokens. One way is to create a view
    with an additional login form where a user can post their email and password to
    get an API token in response. That token can be stored temporarily on the User
    model like the random token in the preceding section.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的请求成功，你应该会看到与本课程第一部分的JSON相同的课程列表。如果你计划使用JWT来保护你的API，你需要明确告诉你的API用户你期望他们如何进行身份验证和验证他们的令牌。一种方法是为用户提供一个额外的登录表单，用户可以在其中提交他们的电子邮件和密码以获取API令牌作为响应。该令牌可以像上一节中的随机令牌一样临时存储在用户模型中。
- en: '|  |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-462
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: Using JWTs requires the client to store the token in some way. Not being able
    to store the JWT temporarily makes it impossible to create future requests after
    the token is created on login.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JWT需要客户端以某种方式存储令牌。如果不能临时存储JWT，则在登录时创建令牌后，将无法创建未来的请求。
- en: '|  |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: JWTs can help prevent attacks on your application’s data and secure access through
    your API, but this requires more steps to implement. Ultimately, you may find
    that it makes more sense to start with a simpler approach, such as generating
    random tokens for each user.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: JWT可以帮助防止对应用程序数据的攻击并确保通过API的安全访问，但这需要更多步骤来实现。最终，你可能发现从更简单的方法开始更有意义，例如为每个用户生成随机令牌。
- en: '|  |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 28.3**'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查28.3**'
- en: '**[Q1:](#ch28qa6q0a1)**'
  id: totrans-468
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch28qa6q0a1)**'
- en: ''
  id: totrans-469
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why do you pass the JWT in the header of the request?
  id: totrans-470
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么你在请求头中传递JWT？
- en: '|  |'
  id: totrans-471
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 28.3 answer**'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 28.3 答案**'
- en: '**[1:](#ch28qa5q1)**'
  id: totrans-474
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch28qa5q1)**'
- en: ''
  id: totrans-475
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You could pass the JWT in the body of the request, but because not all requests
    will be `POST`, the headers offer a more convenient place.
  id: totrans-476
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以在请求体中传递JWT，但由于并非所有请求都是`POST`，因此头部提供了一个更方便的位置。
- en: '|  |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)Summary'
  id: totrans-478
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![章节图](../Images/sectionFig.png)摘要'
- en: In this lesson, you learned how to implement three security tokens on your API.
    The first strategy is a simple security token that can be used by all clients.
    The second strategy requires generating a new random token for each user upon
    creation. In the third approach, you use JWTs to provide the most-secure option
    for authenticating users to access your API. In [lesson 29](../Text/kindle_split_046.html#ch29)
    (this unit’s capstone exercise), you have an opportunity to build an API with
    some of the functionality introduced in this unit.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了如何在你的API上实现三个安全令牌。第一种策略是一个简单的安全令牌，可以被所有客户端使用。第二种策略要求在创建用户时为每个用户生成一个新的随机令牌。在第三种方法中，你使用JWT提供最安全的选项来验证用户访问你的API。在[第29课](../Text/kindle_split_046.html#ch29)（本单元的总结练习）中，你有机会构建一个具有本单元中介绍的一些功能的API。
- en: '|  |'
  id: totrans-480
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Try this**'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试这个**'
- en: Now that you have some basic security options to choose among, try creating
    more API routes that require JWTs. You can also exclude certain routes from requiring
    a token, such as the `login` route. Pick two routes to exclude from your API security.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一些基本的安全选项可以选择，尝试创建更多需要JWT的API路由。你也可以排除某些路由，例如`login`路由，不需要令牌。从你的API安全中排除两个路由。
- en: '|  |'
  id: totrans-483
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Lesson 29\. Capstone: Implementing an API'
  id: totrans-484
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第29课。总结：实现API
- en: Confetti Cuisine raves about the user interaction with the application. To encourage
    more users to enroll in their courses, however, they’d like me to add more data
    on individual pages. More specifically, they want me to include a modal on every
    page that lists the offered courses and a link to enroll in each one.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: Confetti Cuisine对用户与应用程序的互动赞不绝口。然而，为了鼓励更多用户报名他们的课程，他们希望我能在每个页面上添加更多数据。更具体地说，他们希望我在每个页面上包含一个列出提供的课程并链接到每个课程的模态。
- en: To accomplish this task, I’m going to make requests to my application server
    by using Ajax on the client side. By making an asynchronous call to my server
    behind the scenes, I won’t need to load the course data until the user clicks
    a button to enroll. This change to use Ajax should help with the initial page-load
    time and ensure that course data is up to date when the user views it.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个任务，我将在客户端使用Ajax向我的应用服务器发送请求。通过在幕后对服务器进行异步调用，我无需在用户点击按钮报名之前加载课程数据。使用Ajax的这种改变应该有助于初始页面加载时间，并确保用户查看时课程数据是最新的。
- en: First, I’m going to need to modify my application layout view to include a partial
    containing the Embedded JavaScript (EJS) for my modal. Next, I’m going to create
    the client-side JavaScript code to request for course data. To get this data to
    appear, I need to create an API endpoint to respond with course data as JSON.
    When I have that endpoint working, I’ll add an action to handle enrolling users
    in courses and respond with JSON upon completion. This endpoint will allow users
    to enroll in classes from any page without needing to leave or refresh the page
    they’re on.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我需要修改我的应用布局视图，以包含包含我的模态的嵌入式JavaScript (EJS)。接下来，我将创建客户端JavaScript代码以请求课程数据。为了使这些数据显示出来，我需要创建一个API端点以JSON格式响应课程数据。当这个端点工作后，我将添加一个动作来处理用户报名课程，并在完成后返回JSON。这个端点将允许用户从任何页面报名课程，而无需离开或刷新他们所在的页面。
- en: Before I begin, I’m going to restructure my routes to pave the way for my new
    API endpoints.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在我开始之前，我将重构我的路由，为我的新API端点铺平道路。
- en: '![](../Images/sectionFig.png)29.1\. Restructuring routes'
  id: totrans-489
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![章节图](../Images/sectionFig.png)29.1. 重构路由'
- en: To start with the application’s improvements, I’ll move my routes into their
    own modules to clean up my main application file. As this application grows, the
    routes will increase as well. I’d like future developers on this project to be
    able to locate the routes they need easily. Because my routes for each model resource
    are already RESTful—meaning that the route paths take my application’s models
    and CRUD functions into consideration—the restructuring process is much simpler.
    My new application structure will separate my routes based on controller name,
    as shown in [figure 29.1](#ch29fig01).
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始改进应用程序，我将我的路由移动到它们自己的模块中，以清理我的主应用程序文件。随着应用程序的增长，路由也会增加。我希望这个项目的未来开发者能够轻松地找到他们需要的路由。因为我的每个模型资源的路由已经符合RESTful——这意味着路由路径考虑了我的应用程序的模型和CRUD函数——所以重构过程要简单得多。我的新应用程序结构将根据控制器名称来分离我的路由，如图29.1所示。
- en: Figure 29.1\. Application structure with routes folder
  id: totrans-491
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图29.1\. 带有路由文件夹的应用程序结构
- en: '![](../Images/29fig01_alt.jpg)'
  id: totrans-492
  prefs: []
  type: TYPE_IMG
  zh: '![图29.1](../Images/29fig01_alt.jpg)'
- en: 'First, I create a new routes folder at the root level of my application directory.
    Within that folder, I create three modules to hold my models’ respective routes:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我在应用程序目录的根级别创建一个新的路由文件夹。在这个文件夹内，我创建了三个模块来存放我模型各自的路由：
- en: userRoutes.js
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: userRoutes.js
- en: courseRoutes.js
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: courseRoutes.js
- en: subscriberRoutes.js
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: subscriberRoutes.js
- en: Next, I move all the user routes out of main.js and into userRoutes.js. This
    new routes file resembles the code in [listing 29.1](#ch29ex01).
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将所有用户路由从`main.js`移动到`userRoutes.js`。这个新的路由文件类似于[列表29.1](#ch29ex01)中的代码。
- en: '|  |'
  id: totrans-498
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-499
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'I’ll also move my home and error routes into their own home: Routes.js and
    errorRoutes.js, respectively.'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 我还将我的主页和错误路由移动到它们自己的主页：Routes.js和errorRoutes.js，分别。
- en: '|  |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: At the top of this file, I require the Express.js Router and usersController.js.
    These two modules allow me to attach my routes to the same object across my application
    and link those routes to actions in the users controller. Then I apply the `get`,
    `post`, `put`, and `delete` routes for users, which include the routes for CRUD
    actions as well as the routes to sign in and log in. Before I continue, I remove
    all occurrences of the text `users` in the route path. Instead, I’ll apply these
    routes under the `users` namespace later. These routes are bound to the `router`
    object, which I export with this module to make it available to other modules
    in the project.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件的顶部，我导入了Express.js路由器和usersController.js。这两个模块允许我在整个应用程序中将路由附加到同一个对象上，并将这些路由链接到用户控制器的操作。然后，我为用户应用了`get`、`post`、`put`和`delete`路由，包括CRUD操作的路线以及登录和登出的路由。在我继续之前，我将路由路径中的所有`users`文本删除。相反，我将在稍后应用这些路由到`users`命名空间下。这些路由绑定到`router`对象上，我通过这个模块导出它，使其在项目中的其他模块可用。
- en: Listing 29.1\. User routes in userRoutes.js
  id: totrans-503
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表29.1\. 用户路由在userRoutes.js中
- en: '[PRE21]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***1*** **Require the Express.js Router and usersController.**'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **需要Express.js路由器和usersController。**'
- en: '***2*** **Define user routes on the router object.**'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **在路由器对象上定义用户路由。**'
- en: '***3*** **Export the router object from the module.**'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **从模块中导出路由器对象。**'
- en: Then I apply the same strategy to the other model routes and export the `router`
    object in each module. Exporting the `router` object allows any other module to
    require these routes. My routes are better organized, with each module requiring
    only the controllers it needs to use. To get these routes accessible in main.js,
    I create a new file called index.js in the routes folder. This file requires all
    relevant routes so that they can be accessed in one place. Then I’ll require index.js
    in main.js.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我将相同的策略应用到其他模型路由上，并在每个模块中导出`router`对象。导出`router`对象允许任何其他模块导入这些路由。我的路由组织得更好，每个模块只需要使用它需要的控制器。为了在`main.js`中访问这些路由，我在路由文件夹中创建了一个名为`index.js`的新文件。这个文件导入了所有相关的路由，以便它们可以在一个地方访问。然后，我将在`main.js`中导入`index.js`。
- en: '|  |'
  id: totrans-509
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-510
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: All remaining middleware in main.js should be applied to `app.use` and should
    no longer use `router`.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.js`中剩余的所有中间件都应该应用到`app.use`，并且不再使用`router`。'
- en: '|  |'
  id: totrans-512
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: I start by requiring the Express.js Router along with all my route modules.
    In this example, I include model routes and routes for errors and my home controller.
    `router.use` tells my router to use the first parameter as the namespace and the
    second parameter as the routes module specific to that namespace. At the end of
    the file, I export my `router` object, which now contains all the previously defined
    routes. The code in index.js is shown in the next listing.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先引入Express.js路由以及所有我的路由模块。在这个例子中，我包括模型路由和错误路由以及我的主页控制器路由。`router.use`告诉我的路由器使用第一个参数作为命名空间，第二个参数作为特定于该命名空间的路由模块。在文件末尾，我导出我的`router`对象，它现在包含所有之前定义的路由。index.js中的代码在下一个列表中显示。
- en: Listing 29.2\. All routes in index.js
  id: totrans-514
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表29.2\. index.js中的所有路由
- en: '[PRE22]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***1*** **Require the Express.js Router and route modules.**'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **引入Express.js路由和路由模块。**'
- en: '***2*** **Define namespaces for each route module.**'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **为每个路由模块定义命名空间。**'
- en: '***3*** **Export the complete router object.**'
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **导出完整的路由对象。**'
- en: With these routes reorganized, I’ll still be able to access my index of courses
    and individual courses at the `/courses` and `/courses/:id` paths, respectively.
    Because my routes are more organized, I have room to introduce new route modules
    without complicating my code structure. To import these routes into the application,
    I need to require index.js at the top of main.js by using `const router = require("./routes/index")`.
    This `router` object replaces the one I had before. Then I tell my Express.js
    app to use this router in the same way that I told the router to use previously
    defined routes by making sure that `app.use("/", router)` is in main.js.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新组织这些路由后，我仍然可以通过`/courses`和`/courses/:id`路径分别访问我的课程索引和单个课程。因为我的路由更加有序，我有空间引入新的路由模块而不会使我的代码结构复杂化。为了将这些路由导入到应用程序中，我需要在main.js的顶部使用`const
    router = require("./routes/index")`来引入index.js。这个`router`对象替换了之前的那个。然后我告诉Express.js应用程序以与我之前告诉路由器使用先前定义的路由相同的方式使用这个路由器，确保`app.use("/",
    router)`在main.js中。
- en: '|  |'
  id: totrans-520
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-521
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: I also need to remove my require lines for all controllers in main.js, as they’re
    no longer referenced in that module.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 我还需要从main.js中删除所有控制器的require行，因为它们在该模块中不再被引用。
- en: '|  |'
  id: totrans-523
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: With this new routing structure in place, my application continues to function
    as before. I can start implementing my API modifications by creating the modal
    that will display courses.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 在此新的路由结构下，我的应用程序继续按原样运行。我可以开始通过创建显示课程的模态框来实施API修改。
- en: '![](../Images/sectionFig.png)29.2\. Adding the courses partial'
  id: totrans-525
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)29.2\. 添加课程部分'
- en: To create a modal, I use the default bootstrap modal HTML, which provides the
    code for a button that displays a simple modal in the center of the screen. I
    add that code to a new file called _coursesModal.ejs in my courses folder. The
    underscore distinguishes the names of partials from regular views.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个模态框，我使用默认的Bootstrap模态HTML，它提供了一个按钮代码，该按钮在屏幕中央显示一个简单的模态框。我将此代码添加到我的课程文件夹中名为_coursesModal.ejs的新文件中。下划线区分了部分名称和常规视图名称。
- en: This partial, which contains only the modal code shown in the next listing,
    needs to be included in my layout.ejs file. I include the partial as a list item
    in my navigation bar, with `<%- include courses/_coursesModal %>`.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 这个只包含下一个列表中显示的模态框代码的部分，需要包含在我的layout.ejs文件中。我将部分作为列表项包含在我的导航栏中，使用`<%- include
    courses/_coursesModal %>`。
- en: Listing 29.3\. Code for modal in _coursesModal.ejs
  id: totrans-528
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表29.3\. _coursesModal.ejs中的模态框代码
- en: '[PRE23]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1*** **Add the button to open modal.**'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **添加打开模态框的按钮。**'
- en: '***2*** **Add code for the modal window.**'
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **添加模态窗口的代码。**'
- en: '|  |'
  id: totrans-532
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-533
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: I also need to make sure that the JavaScript files for bootstrap and jQuery
    are added to my public/js folder and imported into my layout.ejs through script
    tags. Otherwise, my modal won’t animate on the screen. I can download the latest
    jQuery code from [https://code.jquery.com](https://code.jquery.com) and bootstrap
    code from [https://www.bootstrapcdn.com](https://www.bootstrapcdn.com).
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 我还需要确保将Bootstrap和jQuery的JavaScript文件添加到我的public/js文件夹中，并通过script标签导入到我的layout.ejs中。否则，我的模态框在屏幕上不会动画显示。我可以从[https://code.jquery.com](https://code.jquery.com)下载最新的jQuery代码，从[https://www.bootstrapcdn.com](https://www.bootstrapcdn.com)下载Bootstrap代码。
- en: '|  |'
  id: totrans-535
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: When I restart my application, I see a button in my navigation bar, which opens
    an empty modal when clicked ([figure 29.2](#ch29fig02)).
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 当我重新启动我的应用程序时，我在导航栏中看到一个按钮，点击时会打开一个空白的模态框（[图29.2](#ch29fig02)）。
- en: Figure 29.2\. Modal button in layout navigation
  id: totrans-537
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图29.2\. 布局导航中的模式按钮
- en: '![](../Images/29fig02_alt.jpg)'
  id: totrans-538
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/29fig02_alt.jpg)'
- en: The next step is populating this modal by using course data with AJAX and a
    new API endpoint.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用 AJAX 和新的 API 端点填充这个模态，使用课程数据。
- en: '![](../Images/sectionFig.png)29.3\. Creating the AJAX function'
  id: totrans-540
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![创建 AJAX 函数](../Images/sectionFig.png)29.3\. 创建 AJAX 函数'
- en: One way to access application data without needing to refresh my web page is
    to make an asynchronous Ajax request to my server. This request occurs behind
    the scenes on the browser used by the application’s clients and originates from
    the client’s JavaScript file in the public folder.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 一种在不刷新我的网页的情况下访问应用程序数据的方法是向我的服务器发送异步的 Ajax 请求。这个请求在应用程序客户端使用的浏览器中幕后发生，并源自公共文件夹中客户端的
    JavaScript 文件。
- en: 'To get this Ajax function to work, I need to ensure that jQuery is added to
    my project and linked from the layout file, because I’ll use some of its methods
    to populate my modal. Then, through my custom confettiCuisine.js file in my public/js
    folder, I can add the code in [listing 29.4](#ch29ex04). I can reference this
    file in `layout.ejs` using the following script tag: `<script type="text/javascript"
    src="js/confettiCuisine.js"></script>`.'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这个 Ajax 函数工作，我需要确保 jQuery 已添加到我的项目中，并从布局文件中链接，因为我将使用它的一些方法来填充我的模态。然后，通过我的公共/js
    文件夹中的自定义 confettiCuisine.js 文件，我可以添加 [列表 29.4](#ch29ex04) 中的代码。我可以在 `layout.ejs`
    中使用以下脚本标签引用此文件：`<script type="text/javascript" src="js/confettiCuisine.js"></script>`。
- en: This Ajax function runs only when the Document Object Model (DOM) is loaded
    and the modal button is clicked. I handle the click event by making a `GET` request
    to my API endpoint at `/api/courses`. This request is equivalent to making a `GET`
    request to http://localhost:3000/api/courses in my web browser and receiving a
    page of JSON data. I’ll create this route soon.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Ajax 函数仅在文档对象模型 (DOM) 加载且模态按钮被点击时运行。我通过向我的 API 端点 `/api/courses` 发送 `GET`
    请求来处理点击事件。这个请求等同于在我的网络浏览器中发送一个 `GET` 请求到 http://localhost:3000/api/courses 并接收一页
    JSON 数据。我很快就会创建这个路由。
- en: Next, I handle the results in the response through the `results` object. Within
    this object, I expect to see a `data` object. If there’s no `data` or `course`
    object, I `return` to exit the function. I parse the `data` object for JSON and
    loop through its array of contents to populate my modal. For each item in my `data`
    object, I display the title, cost, and description within HTML tags.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我通过 `results` 对象处理响应中的结果。在这个对象中，我期望看到一个 `data` 对象。如果没有 `data` 或 `course`
    对象，我 `return` 以退出函数。我解析 `data` 对象以获取 JSON，并遍历其内容数组以填充我的模态。对于 `data` 对象中的每个条目，我在
    HTML 标签内显示标题、费用和描述。
- en: 'To the side of each course listing, I link a button to an enrollment route
    for that course. I create a function called `addJoinButtonListener` to add an
    event listener on each course listing after its elements are added to the DOM.
    That function listens for a click event on the join button, marked with the `.join-button`
    class. When that button is clicked, I make another AJAX request through my API
    namespace to `/api/courses/${courseId}/join` for the specific course listing I
    selected. If my server returns a response saying that I was successfully added
    to the course, I change the color and text of the button. Using the ternary operator
    `${course.joined ? "joined-button" : "join-button" }`, I determine the class of
    the button’s styling, depending on the value of `course.joined`. I’ll create this
    property on each course object to let my user interface know whether the currently
    logged-in user has already joined the course.'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '在每个课程列表旁边，我链接一个按钮到该课程的注册路由。我创建一个名为 `addJoinButtonListener` 的函数，在元素被添加到 DOM
    之后为每个课程列表添加一个事件监听器。该函数监听带有 `.join-button` 类的加入按钮的点击事件。当该按钮被点击时，我通过我的 API 命名空间向
    `/api/courses/${courseId}/join` 发送另一个 AJAX 请求，针对我选择的特定课程列表。如果我的服务器返回一个表示我成功加入课程的响应，我改变按钮的颜色和文本。使用三元运算符
    `${course.joined ? "joined-button" : "join-button" }`，我确定按钮样式的类，取决于 `course.joined`
    的值。我将在每个课程对象上创建这个属性，以便我的用户界面知道当前登录的用户是否已经加入了课程。'
- en: Listing 29.4\. Creating an Ajax function to retrieve course data in confettiCuisine.js
  id: totrans-546
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 29.4\. 在 confettiCuisine.js 中创建一个用于检索课程数据的 Ajax 函数
- en: '[PRE24]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1*** **Wait for the DOM to load.**'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **等待 DOM 加载。**'
- en: '***2*** **Handle a click event on the modal button.**'
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **处理模态按钮上的点击事件。**'
- en: '***3*** **Reset the modal body’s contents to an empty string.**'
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **将模态体的内容重置为空字符串。**'
- en: '***4*** **Fetch course data via an AJAX GET request.**'
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **通过 AJAX GET 请求获取课程数据。**'
- en: '***5*** **Loop through each course, and append to the modal body.**'
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **遍历每个课程，并将其追加到模态体中。**'
- en: '***6*** **Link to enroll the current user.**'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **链接以注册当前用户。**'
- en: '***7*** **Call addJoinButtonListener to add an event listener on the course
    listing.**'
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **调用`addJoinButtonListener`以在课程列表上添加事件监听器。**'
- en: '***8*** **Make an API call to join the selected course.**'
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8*** **调用API接口加入所选课程。**'
- en: To get this code to work, I need to create two new API endpoints. One endpoint
    retrieves course data as JSON; the other handles my requests to enroll users at
    `/api/course/${courseId}/join`. I’ll add these endpoints in the next section.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 要使此代码正常工作，我需要创建两个新的API端点。一个端点用于检索课程数据作为JSON格式；另一个端点处理我在`/api/course/${courseId}/join`上的用户注册请求。我将在下一节中添加这些端点。
- en: '![](../Images/sectionFig.png)29.4\. Adding an API endpoint'
  id: totrans-557
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)29.4\. 添加API端点'
- en: Now that my Confetti Cuisine application is configured to communicate with two
    new API endpoints, I need to create the routes to handle these requests. The first
    step is adding the routes to my index.js file in the routes folder. For the AJAX
    request, I need a specific route under an `api` namespace because I want requests
    to go to `/api/courses`, not only `/courses`. To accomplish this task, I create
    apiRoutes.js within the routes folder with the code in [listing 29.5](#ch29ex05).
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我的Confetti Cuisine应用程序已配置为与两个新的API端点通信，我需要创建处理这些请求的路由。第一步是将路由添加到位于`routes`文件夹中的`index.js`文件。对于AJAX请求，我需要在`api`命名空间下创建一个特定的路由，因为我希望请求发送到`/api/courses`，而不仅仅是`/courses`。为了完成这个任务，我在`routes`文件夹中创建了`apiRoutes.js`，其中包含[列表29.5](#ch29ex05)中的代码。
- en: This file requires the Express.js Router and my `coursesController`. Then I
    have that router object handle `GET` requests made to the `/courses` path. This
    route gets the course listing from the index action in the courses controller.
    Then the course listing goes through a `filterUserCourses` middleware function
    to mark the courses that the current user has already joined, and results are
    sent back through the `respondJSON` function. Under the `api` namespace, this
    path is `/api/courses`. The second route handles `GET` requests to a new action
    called `join`. I have one more piece of middleware for this API. I make reference
    to the `errorJSON` action, which handles all errors resulting from any of the
    routes in this API. Last, I export the router.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件需要Express.js路由器和我的`coursesController`。然后我让该路由器对象处理对`/courses`路径的`GET`请求。此路由从课程控制器中的`index`操作获取课程列表。然后课程列表通过`filterUserCourses`中间件函数标记当前用户已加入的课程，并通过`respondJSON`函数发送回结果。在`api`命名空间下，此路径是`/api/courses`。第二个路由处理对名为`join`的新操作的`GET`请求。我为这个API添加了一个额外的中间件。我引用了`errorJSON`操作，该操作处理由此API中任何路由引起的所有错误。最后，我导出路由器。
- en: Listing 29.5\. Creating an API route in `apiRoutes`
  id: totrans-560
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表29.5\. 在`apiRoutes`中创建一个API路由
- en: '[PRE25]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '***1*** **Require the Express.js Router and coursesController.**'
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **引入Express.js路由器和coursesController。**'
- en: '***2*** **Create a route for the courses data endpoint.**'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **为课程数据端点创建一个路由。**'
- en: '***3*** **Create a route to join a course by ID.**'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **通过ID创建一个加入课程的路由。**'
- en: '***4*** **Handle all API errors.**'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **处理所有API错误。**'
- en: Next, I need to add this router to the router defined in index.js. I require
    apiRoutes.js into index.js by adding `const apiRoutes = require("./apiRoutes")`.
    I add `router.use ("/api", apiRoutes)` to index.js to use the routes defined in
    apiRoutes.js under the `/api` namespace. I’ve already created the `index` action
    to fetch the courses from my database. Now I need to create the `filterUserCourses`,
    `respondJSON`, and `errorJSON` actions in my courses controller so that I can
    return my data in JSON format. To do so, I add the code in the following listing
    to coursesController.js.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我需要将此路由器添加到在`index.js`中定义的路由器。我在`index.js`中通过添加`const apiRoutes = require("./apiRoutes")`来引入`apiRoutes.js`。我向`index.js`添加`router.use
    ("/api", apiRoutes)`以使用在`apiRoutes.js`中定义的、位于`/api`命名空间下的路由。我已经创建了`index`操作来从我的数据库中获取课程。现在我需要在课程控制器中创建`filterUserCourses`、`respondJSON`和`errorJSON`操作，以便我可以以JSON格式返回我的数据。为此，我在以下列表中添加了代码到`coursesController.js`。
- en: Listing 29.6\. Creating an action to enroll users in courses in coursesController.js
  id: totrans-567
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表29.6\. 在`coursesController.js`中创建一个将用户注册到课程中的操作
- en: '[PRE26]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '***1*** **Return a courses array through the data property.**'
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **通过数据属性返回课程数组。**'
- en: '***2*** **Return an error message and status code of 500 if an error occurs.**'
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **如果发生错误，返回错误消息和状态码500。**'
- en: '***3*** **Check whether the user is logged in and return an array of courses
    with joined property reflecting user association.**'
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **检查用户是否已登录，并返回一个包含已加入属性反映用户关联的课程数组。**'
- en: With these new endpoints in place, I can restart my application and see the
    course listings populate my modal when the navigation button is clicked ([figure
    29.3](#ch29fig03)).
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好这些新端点后，我可以重新启动我的应用程序，并在点击导航按钮时看到课程列表填充到模态中（[图 29.3](#ch29fig03)）。
- en: Figure 29.3\. Showing course listing through modal in browser
  id: totrans-573
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 29.3\. 通过浏览器中的模态显示课程列表
- en: '![](../Images/29fig03_alt.jpg)'
  id: totrans-574
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/29fig03_alt.jpg)'
- en: '|  |'
  id: totrans-575
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-576
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: While testing that this API endpoint works, I need to comment out my route to
    `join` until the action is added to my courses controller. Otherwise, my application
    will complain that it’s looking for a callback that doesn’t exist.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试这个 API 端点是否正常工作之前，我需要注释掉指向 `join` 的路由，直到我将动作添加到我的课程控制器中。否则，我的应用程序将抱怨它在寻找一个不存在的回调。
- en: '|  |'
  id: totrans-578
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The last phase is creating a route and action to handle users who are looking
    to enroll in a class and filter the course listing to reflect those users who
    have already joined.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的阶段是创建一个路由和动作来处理想要注册课程的用户，并过滤课程列表以反映那些已经加入的用户。
- en: '![](../Images/sectionFig.png)29.5\. Creating an action to enroll users'
  id: totrans-580
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)29.5\. 创建一个将用户注册到课程中的动作'
- en: To enroll a user in a cooking class, I need the current user’s ID and the selected
    course’s ID. I can get the user’s ID from the user object on the request, provided
    by `passport`. I need to use `req.user._id` or the `currentUser` variable I created
    the last time I worked on this project ([lesson 25](../Text/kindle_split_041.html#ch25)).
    I also have easy access to the course ID through the RESTful route. The course
    ID is the second element in the route’s path. My second route, `'/courses/:id/join'`
    in apiRoutes.js, points to the `join` action in my courses controller.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 要将用户注册到烹饪课程中，我需要当前用户的 ID 和所选课程的 ID。我可以从由 `passport` 提供的请求中的用户对象中获取用户 ID，即 `req.user._id`
    或我在上次工作在这个项目时创建的 `currentUser` 变量（[课程 25](../Text/kindle_split_041.html#ch25)）。我也可以通过
    RESTful 路由轻松访问课程 ID。课程 ID 是路由路径中的第二个元素。我的第二个路由 `'/courses/:id/join'` 在 apiRoutes.js
    中指向我的课程控制器中的 `join` 动作。
- en: The last step is adding a controller action to enroll the user in the selected
    course. I start by creating a new action called `join` and defining local variables
    for the course and user IDs. Because I’m referencing the User model in this controller,
    I need to require that model in coursesController.js by adding `const User = require("../models/user")`.
    Then I check whether a user is signed in. If not, I return an error message in
    JSON format.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是添加一个控制器动作以将用户注册到所选课程中。我开始创建一个名为 `join` 的新动作，并为课程和用户 ID 定义局部变量。因为我在这个控制器中引用了用户模型，所以我需要在
    coursesController.js 中添加 `const User = require("../models/user")`。然后我检查用户是否已登录。如果没有，我以
    JSON 格式返回错误消息。
- en: '|  |'
  id: totrans-583
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-584
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You will also need to add `const httpStatus = require("http-status-codes")`
    and `const User = require("../models/user")` to the top of coursesController.js.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要在 coursesController.js 的顶部添加 `const httpStatus = require("http-status-codes")`
    和 `const User = require("../models/user")`。
- en: '|  |'
  id: totrans-586
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If the user is logged in, I use the Mongoose `findByIdAndUpdate` query method
    to search for the user by the user object, the `currentUser`, and the MongoDB
    array update operator `$addToSet` to insert the selected course into the user’s
    `courses` list. This association signifies an enrollment. I accomplish all these
    tasks by using the code in [listing 29.7](#ch29ex07).
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户已登录，我使用 Mongoose 的 `findByIdAndUpdate` 查询方法通过用户对象、`currentUser` 和 MongoDB
    数组更新运算符 `$addToSet` 将所选课程插入到用户的 `courses` 列表中。这种关联表示注册。我通过 [列表 29.7](#ch29ex07)
    中的代码完成所有这些任务。
- en: '|  |'
  id: totrans-588
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-589
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '`$addToSet` ensures that no duplicate values appear in the `courses` array.
    I could have used the MongoDB `$push` operator to add the course ID to the user’s
    `courses` array, but this operator may have allowed users to enroll in the same
    course multiple times by accident.'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '`$addToSet` 确保在 `courses` 数组中不会出现重复值。我本可以使用 MongoDB 的 `$push` 运算符将课程 ID 添加到用户的
    `courses` 数组中，但这个运算符可能会意外地允许用户多次注册同一课程。'
- en: '|  |'
  id: totrans-591
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 29.7\. Creating an action to enroll users in courses in coursesController.js
  id: totrans-592
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 29.7\. 在 coursesController.js 中创建一个将用户注册到课程中的动作
- en: '[PRE27]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1*** **Define local variables for course and user IDs.**'
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **为课程和用户 ID 定义局部变量。**'
- en: '***2*** **Check whether the user is logged in.**'
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **检查用户是否已登录。**'
- en: '***3*** **Find and update the user to connect the selected course.**'
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **查找并更新用户以连接所选课程。**'
- en: '***4*** **Continue to next middleware.**'
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **继续到下一个中间件。**'
- en: '***5*** **Continue to error middleware with an error message if the user failed
    to enroll.**'
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** 继续到错误中间件，如果用户未能注册，则显示错误信息。'
- en: With this action in place, I can restart the application. When I try to enroll
    in a course before logging in, I see the message in [figure 29.4](#ch29fig04).
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个操作到位后，我可以重新启动应用程序。当我尝试在登录前注册课程时，我看到了[图29.4](#ch29fig04)中的消息。
- en: Figure 29.4\. Trying to enroll before logging in
  id: totrans-600
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图29.4. 在登录前尝试注册
- en: '![](../Images/29fig04_alt.jpg)'
  id: totrans-601
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/29fig04_alt.jpg)'
- en: After I successfully log in and click the button to join a course, the screen
    resembles [figure 29.5](#ch29fig05). Also, after joining a course, I can refresh
    my window and still see my `joined` status preserved in the modal.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 在我成功登录并点击加入课程的按钮后，屏幕类似于[图29.5](#ch29fig05)。此外，在加入课程后，我刷新窗口仍然可以在模态窗口中看到我的`joined`状态被保留。
- en: Figure 29.5\. Successfully enrolling in a course
  id: totrans-603
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图29.5. 成功注册课程
- en: '![](../Images/29fig05_alt.jpg)'
  id: totrans-604
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/29fig05_alt.jpg)'
- en: With a new API namespace, I can open this application to more Ajax requests
    and other applications that want to access Confetti Cuisine’s raw JSON data. I
    could secure the API, but doing so isn’t required for this small change.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个新的API命名空间，我可以打开这个应用程序，使其能够接受更多的Ajax请求以及其他想要访问Confetti Cuisine原始JSON数据的应用程序。我可以保护API，但在这个小改动中这样做不是必需的。
- en: Now that I’ve implemented a new feature to allow users to enroll in courses,
    I’ll work on improving other parts of the application that may benefit from single-page
    asynchronous calls to my API.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经实现了一个新功能，允许用户注册课程，接下来我将致力于改进应用程序的其他部分，这些部分可能将从对我的API的单页异步调用中受益。
- en: '![](../Images/sectionFig.png)Summary'
  id: totrans-607
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![图片](../Images/sectionFig.png)摘要'
- en: In this capstone exercise, I improved the Confetti Cuisine application experience
    by introducing an Ajax request to a new API endpoint. I started by reorganizing
    my application’s routes and separating the web routes from the API routes. Then
    I created an Ajax function on the client-side JavaScript to populate a modal with
    course-listing results from a custom API endpoint. Last, I created a route and
    action to allow users to enroll in courses from any page in the application. With
    this new improvement in place, Confetti Cuisine’s marketing team feels better
    about informing users and encouraging them to join their classes.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个综合练习中，我通过引入一个Ajax请求到新的API端点，改善了Confetti Cuisine应用程序的体验。我开始通过重新组织应用程序的路由，将Web路由与API路由分开。然后，我在客户端JavaScript中创建了一个Ajax函数，用于从自定义API端点填充模态窗口中的课程列表结果。最后，我创建了一个路由和操作，允许用户从应用程序的任何页面注册课程。随着这一新改进的实施，Confetti
    Cuisine的市场营销团队对向用户传达信息和鼓励他们参加课程感到更加自信。
