- en: 7 The React testing ecosystem
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 React测试生态系统
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Setting up an environment for testing React applications
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为React应用设置测试环境
- en: An overview of different React testing tools
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同React测试工具概述
- en: Writing your first tests for a React application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为React应用编写第一个测试
- en: When you’ve got a top-notch mixer, instead of wasting time whisking eggs and
    sugar, you can focus on improving other aspects of your craft, like refining your
    recipes or decorating your cakes.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当你拥有一个顶级的搅拌器时，你不必浪费时间搅拌鸡蛋和糖，你可以专注于提高你工艺的其他方面，比如完善你的食谱或装饰你的蛋糕。
- en: Similar to how superb equipment enables pastry chefs to focus on more significant
    aspects of their craft, frontend frameworks and libraries, like React, allow you
    to focus on more significant aspects of writing web applications. Instead of focusing
    on manipulating the DOM—removing, inserting, and updating elements yourself—you
    can focus on your application’s usability, accessibility, and business logic.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于优秀设备使糕点师能够专注于他们工艺的更重要的方面，如React这样的前端框架和库，让你能够专注于编写网络应用的更重要的方面。你不必专注于操作DOM——自己删除、插入和更新元素——你可以专注于你应用的可用性、可访问性和业务逻辑。
- en: In this chapter, you’ll learn how to test React applications and how it relates
    to what you’ve learned about testing frontend applications. You’ll learn how tools
    like JSDOM can still be useful in different contexts, and you’ll learn concepts
    that will help test any other frontend frameworks you may use.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个章节中，你将学习如何测试React应用，以及它与你在测试前端应用中学到的知识如何相关。你将了解像JSDOM这样的工具在不同环境中仍然有用，你将学习有助于测试你可能使用的任何其他前端框架的概念。
- en: I’ve chosen to write these examples using React mainly because of its popularity.
    I believe it’s the tool with which most of you will already be familiar.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择用React编写这些示例主要是因为它的流行。我相信它是最多人已经熟悉的工具。
- en: If you don’t already know React, going through its “getting started” guide should
    be enough for you to understand the examples I’ll use. My main goal with this
    chapter is *not* to teach you React but, instead, to demonstrate principles that
    will be useful, regardless of the tools you’ll use.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还不了解React，通过它的“入门”指南应该足以让你理解我将使用的示例。我写这一章的主要目标**不是**教你React，而是展示一些无论你使用什么工具都会有用的原则。
- en: I’ll begin this chapter by explaining how React applications run in a browser
    and then teach you how to simulate those conditions in a test environment so that
    you can have reliable quality guarantees.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从这个章节开始解释React应用如何在浏览器中运行，然后教你如何在测试环境中模拟这些条件，这样你就可以有可靠的质量保证。
- en: During the process of setting up a testing environment, I’ll cover multiple
    tools. I’ll explain their roles and how they work so that you can more easily
    fix issues in your tests and testing infrastructure.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置测试环境的过程中，我会介绍多个工具。我会解释它们的作用以及它们是如何工作的，这样你可以更容易地修复测试和测试基础设施中的问题。
- en: Once your React testing environment is operational, you’ll see firsthand how
    many of the concepts you’ve learned when testing pure JavaScript applications
    still apply.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的React测试环境运行起来，你将亲身体验到你在测试纯JavaScript应用时学到的许多概念仍然适用。
- en: Then, I’ll give you an overview of the tools available in React’s testing ecosystem,
    focusing on my library of choice, `react-testing-library`, which I’ll use to show
    you how to write your first tests for React applications.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我将为你概述React测试生态系统中的工具，重点关注我选择的库`react-testing-library`，我将用它来展示如何为React应用编写第一个测试。
- en: Even though I’ll focus on a single library, I’ll explain how many other libraries
    work, their pros and cons, and what to consider when choosing tools so that you
    can make your own decisions, depending on the project on which you’re working.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我会专注于一个库，但我将解释许多其他库是如何工作的，它们的优缺点，以及选择工具时需要考虑的因素，这样你可以根据自己的项目做出自己的决定。
- en: 7.1 Setting up a test environment for React
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 为React设置测试环境
- en: One of the most important things to learn about a kitchen is where everything
    is. In Louis’s kitchen, he labels every drawer and has rigorous rules about where
    to store ingredients and equipment. His staff may think he’s too methodical, but
    Louis would rather call himself a utilitarian. He knows that one can’t bake a
    cake if they can’t find a pan.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 关于厨房，最重要的学习之一是了解一切的位置。在路易的厨房里，他给每个抽屉都贴上了标签，并制定了严格的规则来存储原料和设备。他的员工可能认为他太有条理了，但路易更愿意称自己为实用主义者。他知道，如果找不到烤盘，就无法烘焙蛋糕。
- en: In this section, you’ll set up a React application and its testing environment.
    During this process, you’ll understand how React works and how to reproduce that
    in your testing environment.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将设置一个 React 应用程序及其测试环境。在这个过程中，你将了解 React 的工作原理以及如何在测试环境中重现它。
- en: The application you’ll write in this chapter will be just like the one you’ve
    built in the previous chapter. The difference is that this time you’ll use React
    instead of manipulating the DOM yourself.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中你将要编写的应用程序将与上一章中你构建的应用程序类似。不同之处在于这次你将使用 React 而不是自己操作 DOM。
- en: Because I can’t describe how Jest will interface with your application without
    explaining how browsers run React applications, I’ve divided this section into
    two parts. In the first part, you’ll understand which tools are involved in making
    a React application run in the browser. In the second part, you’ll set up the
    test environment for your application and understand how the tools you’ve used
    to make your application run in the browser impact the setup of your test environment.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我无法描述 Jest 如何与你的应用程序接口，而不解释浏览器如何运行 React 应用程序，所以我将本节分为两部分。在第一部分，你将了解使 React
    应用程序在浏览器中运行的工具。在第二部分，你将设置你的应用程序的测试环境，并了解你用来使应用程序在浏览器中运行的工具如何影响测试环境的设置。
- en: 7.1.1 Setting up a React application
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.1 设置 React 应用程序
- en: To understand how to test a React application, you must learn what’s necessary
    to make it run in a browser. Only then will you be able to replicate the browser’s
    environment within your tests accurately.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何测试一个 React 应用程序，你必须学习使其在浏览器中运行所必需的内容。只有在你准确复制浏览器环境之后，你才能在测试中准确复制。
- en: In this subsection, you’ll learn how to configure a React application for it
    to run in a browser. During the process, I’ll explain what tools you’ll need and
    what each one of them does.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，你将学习如何配置一个 React 应用程序，使其能够在浏览器中运行。在这个过程中，我会解释你需要哪些工具以及每个工具的作用。
- en: Start by creating an `index.html` containing a node into which you’ll render
    your application. This file should also load a script called `bundle.js`, which
    will include your application’s JavaScript code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个包含一个节点（你将在其中渲染你的应用程序）的 `index.html` 文件。此文件还应加载一个名为 `bundle.js` 的脚本，该脚本将包含你的应用程序的
    JavaScript 代码。
- en: Listing 7.1 index.html
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.1 index.html
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Loads the bundle.js file, which will include the whole bundled application
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 加载包含整个捆绑应用程序的 `bundle.js` 文件
- en: Before you start using any JavaScript packages, create a `package.json` file
    with `npm init -y`. You’ll use this to keep track of your dependencies and write
    NPM scripts.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用任何 JavaScript 包之前，使用 `npm init -y` 创建一个 `package.json` 文件。你将使用这个文件来跟踪你的依赖项并编写
    NPM 脚本。
- en: 'Once you’ve created a `package.json` file, install the two main dependencies
    you’ll need for writing React applications that can run in a browser: `react`
    and `react-dom`. React is the library that deals with the components themselves,
    and `react-dom` allows you to render those components to the DOM. Remember to
    install these packages as *dependencies*, with `npm install --save react react-dom`.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了 `package.json` 文件，安装你编写可以在浏览器中运行的 React 应用程序所需的两个主要依赖项：`react` 和 `react-dom`。`react`
    是处理组件本身的库，而 `react-dom` 允许你将这些组件渲染到 DOM 中。请记住，使用 `npm install --save react react-dom`
    将这些包作为依赖项安装。
- en: As the entry point for your application, create a `bundle.js` file. In it, you
    will use React to define an `App` component and `react-dom` to render an instance
    of that component to the `app` node in `index.html`, as shown next.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 作为你应用程序的入口点，创建一个 `bundle.js` 文件。在其中，你将使用 React 定义一个 `App` 组件，并使用 `react-dom`
    将该组件的一个实例渲染到 `index.html` 中的 `app` 节点，如下所示。
- en: Listing 7.2 index.js
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.2 index.js
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Creates an h1 element to use as the page’s header
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个 h1 元素作为页面的标题
- en: ❷ Creates a div element whose only child is the header element
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个 div 元素，其唯一子元素是标题元素
- en: ❸ Renders the App element to the node whose id is app
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将 App 元素渲染到 id 为 app 的节点
- en: As you might remember from the previous chapter, because we’re importing other
    libraries, we must bundle them into the `bundle.js` file that our `index.html`
    will load. To perform bundling, install `browserify` as a dev dependency with
    `npm` `install --save-dev` `browserify`. Then, add the following script to your
    `package.json` file so that you can generate a bundle with `npm run build`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如你从上一章所记得，因为我们正在导入其他库，我们必须将它们捆绑到 `index.html` 将要加载的 `bundle.js` 文件中。为了执行捆绑，使用
    `npm` 将 `browserify` 作为开发依赖项安装，命令为 `install --save-dev browserify`。然后，将以下脚本添加到你的
    `package.json` 文件中，以便你可以使用 `npm run build` 生成捆绑包。
- en: Listing 7.3 package.json
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.3 package.json
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ A script that will bundle your application into a single bundle.js file when
    you run npm run build
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个脚本，当运行 npm run build 时将你的应用程序打包成一个单独的 bundle.js 文件
- en: Generate a `bundle.js` file, and serve your application at `localhost:8080`
    with `npx http-server ./`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一个 `bundle.js` 文件，并使用 `npx http-server ./` 在 `localhost:8080` 上提供你的应用程序。
- en: If you’re already familiar with React, by now you’re probably thinking, “But,
    hey, that’s not how I write React applications!” and you’re absolutely right.
    The immense majority of people writing React applications are using markup in
    their JavaScript code. They’re using what’s called `JSX`, a format that mixes
    JavaScript and HTML. The React code you’re used to seeing probably looks more
    like this.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经熟悉 React，到现在你可能已经在想，“但是，嘿，这并不是我写 React 应用程序的方式！”你完全正确。编写 React 应用程序的大多数人都在他们的
    JavaScript 代码中使用标记。他们使用的是所谓的 `JSX`，这是一种混合了 JavaScript 和 HTML 的格式。你习惯看到的 React
    代码可能看起来更像是这样。
- en: Listing 7.4 index.jsx
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.4 index.jsx
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ An App component that will render a div, including a header
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个将渲染一个包含标题的 div 的 App 组件
- en: ❷ Renders the App component to the DOM node whose id is app
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将 App 组件渲染到 id 为 app 的 DOM 节点
- en: Being able to embed markup in your JavaScript code makes components more readable
    and less convoluted, but it’s worth noticing that browsers do *not* know how to
    run `JSX`. Therefore, for these files to run in a browser, you’ll have to use
    tools to convert `JSX` to plain JavaScript.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在 JavaScript 代码中嵌入标记可以使组件更易于阅读且更简洁，但值得注意的是，浏览器并不知道如何运行 `JSX`。因此，为了使这些文件能在浏览器中运行，你必须使用工具将
    `JSX` 转换为纯 JavaScript。
- en: JSX is a more *convenient* way to write components, but it’s *not* part of React.
    It extends JavaScript’s syntax and, when transforming JSX into plain JavaScript,
    it is converted to function calls. In the case of React, those function calls
    happen to be `React.createElement` calls—the same function calls we had in the
    previous `index.js` file.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 是编写组件的一种更 *方便* 的方式，但它 *不是* React 的一部分。它扩展了 JavaScript 的语法，并且在将 JSX 转换为纯
    JavaScript 时，它会被转换为函数调用。在 React 的情况下，这些函数调用恰好是 `React.createElement` 调用——与我们在之前的
    `index.js` 文件中使用的相同函数调用。
- en: JSX is not unique to React. Other libraries, like Preact, for example, can also
    take advantage of JSX. The difference is that the JSX you write for a Preact application
    needs to be converted into different function calls, not `React.createElement`,
    which is specific to React.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 并非仅限于 React。例如，像 Preact 这样的其他库也可以利用 JSX。区别在于，为 Preact 应用程序编写的 JSX 需要转换为不同的函数调用，而不是
    React 特有的 `React.createElement`。
- en: Once the `index.jsx` file I’ve written above is converted to a plain JavaScript
    file, its output should be similar to the output produced by the version of `index.js`
    that used `React.createElement` directly.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我将上面的 `index.jsx` 文件转换为纯 JavaScript 文件，其输出应该与直接使用 `React.createElement` 的
    `index.js` 版本的输出相似。
- en: It’s crucial to understand how JSX and React work because that will help you
    set up your test environment. This knowledge will enable you to grasp what Jest
    is doing when dealing with JSX files.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 JSX 和 React 的工作原理至关重要，因为这将帮助你设置测试环境。这种知识将使你能够理解 Jest 在处理 JSX 文件时正在做什么。
- en: Important JSX is simply a more convenient way to write components. Browsers
    *can’t* run JSX files. To be able to run applications written using JSX, you need
    to transform JSX into plain JavaScript.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 重要 JSX 只是一种更方便的编写组件的方式。浏览器 *不能* 运行 JSX 文件。要能够运行使用 JSX 编写的应用程序，你需要将 JSX 转换为纯
    JavaScript。
- en: JSX isn’t an exclusive feature of React; it’s an extension to JavaScript’s syntax,
    which, in the case of React, is converted to `React.createElement` calls.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 不是 React 的专属特性；它是 JavaScript 语法的扩展，在 React 的情况下，它会被转换为 `React.createElement`
    调用。
- en: Remember that when your application gets to the browser, it becomes “just JavaScript.”
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当你的应用程序到达浏览器时，它就变成了“仅仅是 JavaScript。”
- en: Now that you understand how JSX works, it’s time to see it in action. Rename
    your `index.js` file to `index.jsx`, and update its code so that it uses JSX instead
    of `React .createElement`, like I’ve done earlier.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 JSX 的工作原理，是时候看到它在实际中的应用了。将你的 `index.js` 文件重命名为 `index.jsx`，并更新其代码，使其使用
    JSX 而不是我之前使用的 `React.createElement`。
- en: To transform your code so that it can run in a browser, you’ll use `babelify`
    and Babel. The `babelify` package enables Browserify to use Babel, a JavaScript
    compiler, to compile your code. You can then use packages like `preset-react`
    to transform JSX to plain JavaScript. Given that you’ll need those packages only
    in your development environment, install them as dev dependencies with `npm` `install`
    `--save-dev` `babelify` `@babel/core` `@babel/preset-react`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要将你的代码转换为能在浏览器中运行的代码，你将使用 `babelify` 和 Babel。`babelify` 包使 Browserify 能够使用 Babel，一个
    JavaScript 编译器，来编译你的代码。然后，你可以使用像 `preset-react` 这样的包将 JSX 转换为纯 JavaScript。鉴于你只需要在开发环境中使用这些包，请使用
    `npm install --save-dev babelify @babel/core @babel/preset-react` 命令将它们作为开发依赖项安装。
- en: NOTE I’ve chosen to use Browserify for these examples because it makes them
    more concise. Currently, many readers are probably using Webpack instead.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我选择使用 Browserify 来演示这些示例，因为它使它们更加简洁。目前，许多读者可能正在使用 Webpack。
- en: If you’re using Webpack, the same fundamentals apply. With Webpack, you will
    still use Babel and its presets to transform your JSX code into plain JavaScript,
    which can run in a browser.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Webpack，同样的原则适用。使用 Webpack 时，你仍然会使用 Babel 及其预设来将你的 JSX 代码转换为纯 JavaScript，使其能在浏览器中运行。
- en: To help you understand how these tools relate to each other, think of Webpack
    as being equivalent to Browserify, and of `babel-loader` as being equivalent to
    `babelify`. These comparisons are, of course, a simplification, but, in the context
    of this chapter, they will help you understand how the examples work.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你理解这些工具之间的关系，可以将 Webpack 视为与 Browserify 等效，将 `babel-loader` 视为与 `babelify`
    等效。当然，这些比较是简化的，但在本章的上下文中，它们将帮助你理解示例的工作原理。
- en: Update your `package.json` so that your `build` command uses `index.jsx` instead
    of `index.js` as your application’s entry point, and add configurations for Browserify
    so that it uses `babelify` and `@babel/preset-react` when building your application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 更新你的 `package.json`，使你的 `build` 命令使用 `index.jsx` 而不是 `index.js` 作为应用程序的入口点，并添加
    Browserify 的配置，以便在构建应用程序时使用 `babelify` 和 `@babel/preset-react`。
- en: Listing 7.5 package.json
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.5 package.json
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Configures Browserify’s babelify plugin to transform JSX into plain JavaScript
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 配置 Browserify 的 babelify 插件以将 JSX 转换为纯 JavaScript
- en: After this change, your application will be ready to run in a browser. When
    you run `npm run build`, Browserify will bundle your application into a single
    pure JavaScript file. During the bundling process, it will interface with Babel
    through `babelify` to transform JSX into pure JavaScript, as shown in figure 7.1.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在此更改之后，你的应用程序将准备好在浏览器中运行。当你运行 `npm run build` 命令时，Browserify 将将你的应用程序打包成一个单一的纯
    JavaScript 文件。在打包过程中，它将通过 `babelify` 与 Babel 交互，将 JSX 转换为纯 JavaScript，如图 7.1 所示。
- en: Finally, when you serve your application with `npx http-server ./`, `index.html`
    will load the `bundle.js` file, which will mount the `App` component to the page.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当你使用 `npx http-server ./` 命令提供应用程序服务时，`index.html` 将加载 `bundle.js` 文件，并将
    `App` 组件挂载到页面上。
- en: '![](../Images/CH07_F01_DaCosta.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 DaCosta 的配置](../Images/CH07_F01_DaCosta.png)'
- en: Figure 7.1 Your application’s build process, from bundling and transforming
    your code, to executing it in a browser
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 你的应用程序的构建过程，从打包和转换代码到在浏览器中执行
- en: To see your application working, build it with `npm run build`, and serve it
    with `npx http-server ./` to be able to access it at `localhost:8080`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到你的应用程序运行效果，请使用 `npm run build` 命令构建它，然后使用 `npx http-server ./` 命令来提供服务，以便在
    `localhost:8080` 上访问它。
- en: Another detail you might have noticed is that, up to now, I’ve been using Node.js’s
    `require` to import JavaScript modules in this book’s examples. This function,
    however, is not the standard way to import modules in JavaScript. In this chapter,
    instead of using `require`, I will use ES imports.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还注意到的一个细节是，到目前为止，我在本书的示例中一直使用 Node.js 的 `require` 来导入 JavaScript 模块。然而，这并不是在
    JavaScript 中导入模块的标准方式。在本章中，我将不使用 `require`，而是使用 ES 导入。
- en: Listing 7.6 index.jsx
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.6 index.jsx
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To be able to use ES imports, you must use Babel’s `preset-env` to transform
    ES imports into `require` calls—also known as CommonJS imports.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 ES 导入，你必须使用 Babel 的 `preset-env` 将 ES 导入转换为 `require` 调用——也称为 CommonJS 导入。
- en: NOTE At the time of this writing, Node.js’s latest version already supports
    ES imports. I’ve chosen to demonstrate how to do this using Babel so that readers
    using previous versions of Node.js can also follow along. You can read more about
    Node.js’s support for ES modules at [https://nodejs.org/api/esm.html](https://nodejs.org/api/esm.html).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在撰写本文时，Node.js 的最新版本已经支持 ES 导入。我选择使用 Babel 来演示如何做这件事，以便使用先前版本的 Node.js 的读者也可以跟随。你可以在
    [https://nodejs.org/api/esm.html](https://nodejs.org/api/esm.html) 上了解更多关于 Node.js
    对 ES 模块的支持。
- en: Install Babel’s `preset-env` as a dev dependency with `npm install --save-dev
    @babel/preset-env`, and update your `package.json` so that it uses this package
    when building your application.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `npm install --save-dev @babel/preset-env` 将 Babel 的 `preset-env` 作为开发依赖项安装，并更新你的
    `package.json` 以便在构建应用程序时使用此包。
- en: Listing 7.7 package.json
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.7 package.json
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Configures Browserify’s babelify plugin to transform your code in such a way
    that you can target specific environments without having to micronomanage environment-specific
    changes
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 配置 Browserify 的 babelify 插件，以便以这种方式转换你的代码，这样你就可以针对特定环境进行操作，而无需对特定环境的更改进行微管理
- en: Now that you’ve finished setting up `babelify`, you can build and access your
    application just like before. First, run `npm` `run` `build`, and then serve it
    at `localhost:8080` with `npx` `http-server ./`
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了 `babelify` 的设置，你可以像以前一样构建和访问你的应用程序。首先，运行 `npm run build`，然后使用 `npx
    http-server ./` 在 `localhost:8080` 上提供服务。
- en: 7.1.2 Setting up a testing environment
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.2 设置测试环境
- en: Now that you’ve learned what’s involved in making a React application run in
    a browser, it’s time to learn what’s involved in making it run in Node.js, so
    that you can use Jest to test it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了使 React 应用程序在浏览器中运行所涉及的内容，现在是时候了解使其在 Node.js 中运行所涉及的内容了，这样你就可以使用 Jest
    来测试它。
- en: Start setting up a testing environment by installing Jest as a dev dependency
    with `npm` `install` `--save-dev jest`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `npm install --save-dev jest` 将 Jest 作为开发依赖项安装，开始设置测试环境。
- en: Because you’ll start testing your `App` component, separate it into its own
    `App.jsx` file and update `index.jsx` so that it imports `App` from `App.jsx`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你要开始测试你的 `App` 组件，所以将其单独分离到自己的 `App.jsx` 文件中，并更新 `index.jsx` 以便从 `App.jsx`
    中导入 `App`。
- en: Listing 7.8 App.jsx
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.8 App.jsx
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Creates an App component, and exports it
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个 App 组件，并导出它
- en: Listing 7.9 index.jsx
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.9 index.jsx
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Imports the App component from App.jsx
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从 App.jsx 导入 App 组件
- en: ❷ Renders an instance of App to the DOM node whose ID is app
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将 App 的实例渲染到 ID 为 app 的 DOM 节点中
- en: Now, before you can even try to render `App` and test it—as we’ll do in the
    next section—you must be able to execute the code in its `App.jsx` file.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你甚至尝试渲染 `App` 并测试它——我们将在下一节中这样做——之前，你必须能够执行其 `App.jsx` 文件中的代码。
- en: Create your first test file, and call it `App.test.js`. For now, just try to
    import `App` using the ES Modules syntax.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 创建你的第一个测试文件，并将其命名为 `App.test.js`。目前，只需尝试使用 ES 模块语法导入 `App`。
- en: Listing 7.10 App.test.js
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.10 App.test.js
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When trying to run this test file with Jest, you’ll get a syntax error.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试使用 Jest 运行此测试文件时，你会得到一个语法错误。
- en: TIP To run your tests, update your `package.json`, and add an NPM script called
    `test` that invokes `jest`, just like we’ve done before. This NPM script will
    allow you to run your tests with `npm test`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：为了运行你的测试，更新你的 `package.json`，并添加一个名为 `test` 的 NPM 脚本，该脚本调用 `jest`，就像我们以前做的那样。这个
    NPM 脚本将允许你使用 `npm test` 运行你的测试。
- en: At the moment of this writing, I’m using Node.js v12\. In this version, even
    just importing `App` using the ES modules syntax in a file with a `.js` extension
    will cause your tests to fail.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，我正在使用 Node.js v12。在这个版本中，即使只是使用具有 `.js` 扩展名的文件中的 ES 模块语法导入 `App`，也会导致你的测试失败。
- en: To solve this problem, you must transform `App.test.js` using Babel and the
    `preset-env` package, just like you’ve done before when using Browserify to bundle
    your code. The difference is that this time you won’t need Browserify as an intermediate.
    Instead, you’ll instruct Jest itself to use Babel.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你必须使用 Babel 和 `preset-env` 包转换 `App.test.js`，就像你以前使用 Browserify 打包代码时做的那样。不同之处在于这次你不需要
    Browserify 作为中间件。相反，你将指示 Jest 本身使用 Babel。
- en: To tell Jest to transform your files so that you can run them in Node.js, you
    can move Babel’s configuration into its own `babel.config.js` file. In the version
    of Jest I’m using at the time of this writing, just having this configuration
    file will be enough for Jest to know that it should transform files before running
    them.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要告诉 Jest 转换您的文件以便您可以在 Node.js 中运行它们，您可以将 Babel 的配置移动到它自己的 `babel.config.js`
    文件中。在我撰写此内容时，Jest 的版本中，仅此配置文件就足以让 Jest 知道它应该在运行文件之前进行转换。
- en: Go ahead and create a `babel.config.js` file that uses `preset-env` to transform
    your sources so that they can run in Node.js.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 继续创建一个使用 `preset-env` 转换源代码以便它们可以在 Node.js 中运行的 `babel.config.js` 文件。
- en: Listing 7.11 babel.config.js
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.11 babel.config.js
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Configures Babel to transform your files so that they’re compatible with Node.js
    and, therefore, can be executed by Jest, which runs within Node.js
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 配置 Babel 将您的文件转换为与 Node.js 兼容，因此可以由在 Node.js 中运行的 Jest 执行
- en: This change makes the import itself succeed, but it still won’t cause Jest to
    exit without errors. If you try rerunning Jest, you’ll see that it now complains
    about finding an unexpected token in your `App.jsx` file.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更改使得导入本身成功，但它仍然不会导致 Jest 无错误退出。如果您尝试重新运行 Jest，您会看到它现在抱怨在您的 `App.jsx` 文件中找到了意外的标记。
- en: This error happens because, just like the browser, Node doesn’t know how to
    execute JSX. Therefore, you must transform JSX to plain JavaScript before you
    can run it in Node.js with Jest.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误发生是因为，就像浏览器一样，Node 也不知道如何执行 JSX。因此，在您可以使用 Jest 在 Node.js 中运行它之前，您必须将 JSX
    转换为纯 JavaScript。
- en: Update your `babel.config.js` file so that it uses `preset-react` to transform
    JSX into `React.createElement` calls, just like you’ve done before.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 更新您的 `babel.config.js` 文件，使其使用 `preset-react` 将 JSX 转换为 `React.createElement`
    调用，就像您之前所做的那样。
- en: Listing 7.12 babel.config.js
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.12 babel.config.js
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Configures Babel to transform JSX into plain JavaScript, so that you can execute
    them using Node.js
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 配置 Babel 将 JSX 转换为纯 JavaScript，以便您可以使用 Node.js 执行它们
- en: Now that you have created a `.babel.config.js` configuration File, Jest will
    use Babel to transform the files before running them, as shown in figure 7.2\.
    Jest needs to do this because it runs within Node.js, which doesn’t know about
    JSX and whose current version can’t yet handle ES modules. To transform JSX into
    pure JavaScript, it uses `preset-react`, and to turn ES imports into CommonJS
    imports (`require` calls), it uses `preset-env`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经创建了一个 `.babel.config.js` 配置文件，Jest 将在运行文件之前使用 Babel 进行转换，如图 7.2 所示。Jest
    需要这样做，因为它在 Node.js 中运行，Node.js 不了解 JSX，并且其当前版本还无法处理 ES 模块。为了将 JSX 转换为纯 JavaScript，它使用
    `preset-react`，并将 ES 导入转换为 CommonJS 导入（`require` 调用），它使用 `preset-env`。
- en: '![](../Images/CH07_F02_DaCosta.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F02_DaCosta.png)'
- en: Figure 7.2 How Jest transforms your files before running tests
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 Jest 在运行测试之前如何转换您的文件
- en: 'Finally, after using `preset-react`, Jest will be able to run `App.test.js`.
    It still terminates with an error, but now it’s one that’s a lot easier to solve:
    you haven’t yet written any tests.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在使用了 `preset-react` 之后，Jest 将能够运行 `App.test.js`。它仍然以错误结束，但现在它是一个更容易解决的错误：您还没有编写任何测试。
- en: Important It’s crucial to understand the role of each tool you’re using. In
    the first part of this chapter, you used Browserify to *bundle* your application
    into a single JavaScript file. The `babelify` package enabled you to use Babel,
    which is the compiler itself, to *transform* your files. The `preset-env` and
    `preset-react` packages were responsible for telling Babel *how* to perform the
    transformation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：理解您所使用的每个工具的作用至关重要。在本章的第一部分，您使用 Browserify 将您的应用程序打包成一个单一的 JavaScript 文件。`babelify`
    包使您能够使用 Babel，即编译器本身，来 *转换* 您的文件。`preset-env` 和 `preset-react` 包负责告诉 Babel *如何*
    执行转换。
- en: 'In this last part, you configured Jest to use Babel to *transform* your files
    before running them. The role of `preset-env` and `preset-react` remains the same:
    they tell Babel *how* to transform the code.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一部分，您已配置 Jest 使用 Babel 在运行文件之前将它们进行 *转换*。`preset-env` 和 `preset-react` 的作用保持不变：它们告诉
    Babel *如何* 进行转换。
- en: Testing React applications is not very different from testing vanilla frontend
    applications. In both situations, you want to replicate a browser’s environment
    in Node.js as accurately as possible. To do that, you can use tools like JSDOM,
    which simulates a browser’s APIs, and Babel, which transforms your code so that
    it can run in a browser.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 React 应用程序与测试纯前端应用程序并没有很大区别。在这两种情况下，你都想尽可能精确地在 Node.js 中复制浏览器的环境。为此，你可以使用像
    JSDOM 这样的工具，它模拟浏览器的 API，以及 Babel，它将你的代码转换成可以在浏览器中运行的格式。
- en: If you’re using a library or framework other than React, to understand how to
    test it, I’d recommend you to follow the same thought process I’ve exposed in
    this section. First, check what you need to do to get your application to run
    in a browser. Understand each tool’s role and how it works. Then, when you have
    a good understanding of how your application works in a browser, modify those
    steps in such way that you can to get the code to run in Node.js so that you can
    use Jest.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 React 之外的库或框架，为了了解如何测试它，我建议你遵循我在本节中展示的相同思维过程。首先，检查你需要做什么才能让你的应用程序在浏览器中运行。理解每个工具的作用及其工作原理。然后，当你对应用程序在浏览器中的工作方式有了很好的理解后，以这种方式修改这些步骤，以便你可以将代码运行在
    Node.js 中，从而可以使用 Jest。
- en: 7.2 An overview of React testing libraries
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 React 测试库概述
- en: A first-class oven, some premium French cookware, and a brand-new mixer won’t
    bake a cake for you, but picking the right tools for the job gets you halfway
    there.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一台一流的烤箱，一些高端的法国厨具，以及一个全新的搅拌器不会为你烘焙蛋糕，但选择适合工作的工具会让你成功一半。
- en: In this section, I’ll give you a brief overview of the tools available in the
    React testing ecosystem. I’ll explain how they work, and their pros and cons,
    so that you can pick the tools that you judge to be adequate for your project.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将简要概述 React 测试生态系统中的工具。我会解释它们的工作原理，以及它们的优缺点，以便你可以选择你认为适合你项目的工具。
- en: Through numerous examples, I’ll teach you how to use React’s own utilities.
    I’ll explain how these utilities interact with your testing environment and fundamental
    concepts related to testing React applications.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过众多示例，我将教你如何使用 React 自带的工具。我会解释这些工具如何与你的测试环境交互，以及与测试 React 应用程序相关的根本概念。
- en: Because most React testing libraries are convenient wrappers for functionality
    that is already available in React’s own testing tools, a solid understanding
    of them will make it a lot easier for you to grasp what’s happening behind the
    scenes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数 React 测试库都是对 React 自带测试工具中已存在的功能的便捷包装，因此对这些工具有一个扎实的理解将使你更容易理解幕后发生的事情。
- en: Once you have a good understanding of React’s own testing utilities and how
    React works within your test environment, you’ll see which libraries you can use
    to reduce the amount of code you have to write in your tests.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你对 React 自带的测试工具和 React 在你的测试环境中的工作方式有了很好的理解，你就会看到哪些库你可以使用来减少你在测试中需要编写的代码量。
- en: Even though I’ll explain the pros and cons of multiple libraries, the library
    on which I’ll focus in this section is `react-testing-library`. It’s my testing
    library of choice for most projects, and, in this section, you’ll learn how to
    use it and understand why I recommend it for most cases.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我会解释多个库的优缺点，但本节中我将重点关注的库是 `react-testing-library`。它是我在大多数项目中的首选测试库，在本节中，你将学习如何使用它，并理解为什么我推荐它在大多数情况下使用。
- en: 7.2.1 Rendering components and the DOM
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.1 渲染组件和 DOM
- en: 'Your first task in this section will be to write a test for the `App` component.
    The test you’ll write will follow the three As pattern: arrange, act, assert.
    Because Jest has already set up a JSDOM instance for you, you can jump straight
    to acting and asserting. You’ll render `App` to the JSDOM instance and check whether
    it displays the correct header.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你的第一个任务将是编写 `App` 组件的测试。你将要编写的测试将遵循三个 A 的模式：arrange（准备）、act（执行）、assert（断言）。因为
    Jest 已经为你设置了一个 JSDOM 实例，所以你可以直接跳到执行和断言。你将在 JSDOM 实例中渲染 `App` 并检查它是否显示了正确的标题。
- en: To be able to write this test for the `App` component, you must solve two issues.
    First, you must be able to render `App` itself. Then, you must be able to check
    whether the correct header is present in the DOM.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够为 `App` 组件编写这个测试，你必须解决两个问题。首先，你必须能够渲染 `App` 本身。然后，你必须能够检查 DOM 中是否存在正确的标题。
- en: Start by attaching a `div` to the JSDOM instance’s `document`. Later, you’ll
    render the `App` component to this `div`, like what you’ve done in your application
    code when rendering `App` to the `div` in `index.html`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将一个 `div` 添加到 JSDOM 实例的 `document` 中。稍后，你将在这个 `div` 中渲染 `App` 组件，就像你在应用程序代码中将
    `App` 渲染到 `index.html` 中的 `div` 时所做的那样。
- en: Listing 7.13 App.test.js
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.13 App.test.js
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Creates a div element
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个 div 元素
- en: ❷ Attaches the div to the document’s body
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将 div 附加到文档体
- en: Now, go ahead and write a test that renders `App` to the `root` node you’ve
    just created. To render `App`, you’ll use `react-dom`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，继续编写一个测试，将 `App` 渲染到你刚刚创建的 `root` 节点。要渲染 `App`，你将使用 `react-dom`。
- en: Unlike what you’ve done in your application, in your tests you must wrap each
    of your interactions with a component into a React testing utility called `act`,
    which is part of the `react-dom` package. The `act` function ensures that the
    updates associated to your interactions have been processed and applied to the
    DOM, which, in this case, is implemented by JSDOM.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与你在应用程序中所做的不一样，在你的测试中，你必须将每个交互用 React 测试工具包中的 `act` 组件包裹起来，`act` 是 `react-dom`
    包的一部分。`act` 函数确保与你的交互相关的更新已经被处理并应用到 DOM 上，在这种情况下，DOM 是由 JSDOM 实现的。
- en: Listing 7.14 App.test.jsx
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.14 App.test.jsx
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Attaches a div to the document’s body
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 div 附加到文档体
- en: ❷ Renders an instance of App to the div you’ve attached to the document’s body
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将 App 实例渲染到你附加到文档体中的 div
- en: NOTE Because your test file now uses JSX to create `App`, I’d recommend you
    to change its extension to `.jsx` to indicate the type of code it contains.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：由于你的测试文件现在使用 JSX 创建 `App`，我建议你将其扩展名更改为 `.jsx`，以指示它包含的代码类型。
- en: In the test you’ve just written, you’re accurately simulating how the `App`
    component gets rendered by a browser. Instead of replacing any parts of React
    with test doubles, you’re leveraging JSDOM’s DOM implementation to render the
    component, just like a browser would do.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在你刚刚编写的测试中，你准确地模拟了 `App` 组件是如何由浏览器渲染的。你并没有用测试替身替换 React 的任何部分，而是利用 JSDOM 的 DOM
    实现来渲染组件，就像浏览器会做的那样。
- en: Besides making tests more reliable, rendering components to the DOM enables
    you to use any testing tools and techniques that work with vanilla JavaScript
    applications. As long as you are rendering HTML elements to the DOM, you can interact
    with these elements just like you would in any other situation.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使测试更加可靠外，将组件渲染到 DOM 中还使你能够使用任何与纯 JavaScript 应用程序一起工作的测试工具和技术。只要你在 DOM 中渲染
    HTML 元素，你就可以像在其他任何情况下一样与这些元素交互。
- en: Try, for example, using the document’s `querySelector` function to find the
    rendered header, and assert on its `textContent` property, just like you would
    do for any other DOM node.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，尝试使用文档的 `querySelector` 函数来查找渲染的标题，并断言其 `textContent` 属性，就像你为任何其他 DOM 节点所做的那样。
- en: Listing 7.15 App.test.jsx
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.15 App.test.jsx
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Renders an instance of App to the div within the document’s body
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 App 实例渲染到文档体内的 div
- en: ❷ Finds an h1 element within the document
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在文档中找到一个 h1 元素
- en: ❸ Asserts that the header’s contents are “Inventory Contents”
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 断言标题的内容是“库存内容”
- en: The test you’ve just written uses `react-dom/test-utils` to render `App` to
    a JSDOM instance and then uses web APIs to find and inspect an `h1` element so
    that you can assert on it. These test’s steps are illustrated in figure 7.3.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚编写的测试使用 `react-dom/test-utils` 将 `App` 渲染到 JSDOM 实例，然后使用 Web API 来查找和检查一个
    `h1` 元素，以便你可以对其断言。这些测试步骤在图 7.3 中展示。
- en: '![](../Images/CH07_F03_DaCosta.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F03_DaCosta.png)'
- en: Figure 7.3 Testing components by using `react-dom/test-utils` to render components
    to the DOM and Web APIs to find and inspect the rendered elements
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 使用 `react-dom/test-utils` 将组件渲染到 DOM 并使用 Web API 查找和检查渲染元素来测试组件
- en: The fact that you’re using `react` or `react-dom` is entirely transparent to
    the `document.querySelector` function that you’ve just used. This function operates
    on the document’s elements, no matter how they were rendered.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用 `react` 或 `react-dom` 的实际情况对刚刚使用的 `document.querySelector` 函数来说是完全透明的。这个函数在文档的元素上操作，无论它们是如何渲染的。
- en: The same principle is valid for other testing utilities. Given that you’re rendering
    the `App` component to the DOM, you can use DOM testing utilities like `dom-testing-library`
    to make your tests more readable and robust.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的原则也适用于其他测试工具。鉴于你将 `App` 组件渲染到 DOM 中，你可以使用像 `dom-testing-library` 这样的 DOM
    测试工具，使你的测试更加可读和健壮。
- en: NOTE In general, when dealing with React, because of how thin the integration
    layer is, I consider my components to be atomic “units.” Therefore, I classify
    tests for isolated components as “unit tests.” When a test involves more than
    one component, I prefer to call it an “integration test.”
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 备注：一般来说，在处理 React 时，由于集成层很薄，我认为我的组件是原子的“单元”。因此，我将针对隔离组件的测试归类为“单元测试”。当一个测试涉及多个组件时，我更喜欢将其称为“集成测试”。
- en: Even though I’d classify the last test you wrote as a unit test, one could also
    argue that it should be labeled as an integration test because you’re testing
    not only your code but also whether it interfaces properly with React.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我会将你刚刚编写的最后一个测试归类为单元测试，但也有人可能会争论它应该被标记为集成测试，因为你不仅测试了你的代码，还测试了它是否与 React 正确接口。
- en: Especially in this case, it’s interesting to think of the testing pyramid as
    a continuous spectrum, rather than a discrete set of categories. Even though I’d
    put this test in the bottom part of the pyramid, it would still be higher than
    a test that calls a function and checks the returned value, for example.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是在这个案例中，将测试金字塔视为一个连续的谱系，而不是一组离散的分类，是很有趣的。尽管我会把这个测试放在金字塔的底部，但它仍然高于调用函数并检查返回值的测试，例如。
- en: '**Use React when testing your components**. Do *not* isolate your components
    from React just so that you can label tests as “unit tests.”'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**在测试组件时使用 React**。**不要**将你的组件从 React 中隔离出来，只是为了将测试标记为“单元测试”。'
- en: Testing your components in isolation would make your tests almost useless because
    React’s logic for rendering and updating components is an integral part of what
    makes your application work.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在隔离的情况下测试你的组件会使你的测试几乎无用，因为 React 的渲染和更新组件的逻辑是使你的应用程序工作的一个重要部分。
- en: Remember that your goal is *not* to label tests. Your goal is to write the right
    quantity of tests at each different level of integration.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 记住你的目标**不是**标记测试。你的目标是编写每个不同集成级别所需数量的测试。
- en: Go ahead and install `dom-testing-library` as a dev dependency with `npm install
    --save-dev @testing-library/dom`. Then, try finding the page’s header using this
    library’s `screen` object’s `getByText` method instead of the document’s `querySelector`
    function.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请使用 `npm install --save-dev @testing-library/dom` 将 `dom-testing-library` 作为开发依赖项安装。然后，尝试使用这个库的
    `screen` 对象的 `getByText` 方法来查找页面的标题，而不是使用文档的 `querySelector` 函数。
- en: Listing 7.16 App.test.jsx
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.16 App.test.jsx
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Renders App to the div you’ve attached to the document’s body
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 App 渲染到你附加到文档体的 div 中
- en: ❷ Uses the getByText function from @testing-library/dom to find an element whose
    contents are “Inventory Contents,” and then asserts that the element was found
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 @testing-library/dom 的 `getByText` 函数查找内容为“Inventory Contents”的元素，然后断言该元素已被找到
- en: Now that you have installed `dom-testing-library`, you can also use its `fireEvent`
    APIs. As far as `fireEvent` is concerned, it’s dealing with DOM nodes like any
    others, and, therefore, it can click buttons, fill inputs, and submit forms, just
    like it would in any other situation.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经安装了 `dom-testing-library`，你还可以使用它的 `fireEvent` API。就 `fireEvent` 而言，它像处理其他
    DOM 节点一样处理 DOM 节点，因此它可以点击按钮、填充输入框和提交表单，就像在任何其他情况下一样。
- en: In the same way that `dom-testing-library` doesn’t care about React, React and
    `react-dom` don’t care about whether they’re rendered in a browser or JSDOM. As
    long as the JSDOM APIs match the browser’s, React will respond to events in the
    same way.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `dom-testing-library` 不关心 React 一样，React 和 `react-dom` 也不关心它们是在浏览器中渲染还是在 JSDOM
    中渲染。只要 JSDOM API 与浏览器匹配，React 就会以相同的方式响应用件。
- en: To see how you could interact with your components using `dom-testing-library`,
    first, add to your `App` component a button that increments the number of cheesecakes
    available.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用 `dom-testing-library` 与你的组件交互，首先，在你的 `App` 组件中添加一个按钮，该按钮会增加可用的芝士蛋糕数量。
- en: Listing 7.17 App.jsx.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.17 App.jsx。
- en: '[PRE16]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Creates a piece of state that represents the inventory’s cheesecakes
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个表示库存芝士蛋糕的状态
- en: ❷ Increments the number of cheesecakes when users click the button
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当用户点击按钮时增加芝士蛋糕的数量
- en: When testing this feature, remember that you must wrap interactions with your
    components into the `act` function provided by `react-dom`. This function ensures
    that the interactions have been processed and that the necessary updates have
    been applied to the DOM.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试此功能时，请记住你必须将你的组件交互包裹在 `react-dom` 提供的 `act` 函数中。这个函数确保交互已经被处理，并且必要的更新已经应用到
    DOM 上。
- en: Listing 7.18 App.test.jsx
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.18 App.test.jsx
- en: '[PRE17]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Renders an instance of App
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 渲染 App 实例
- en: ❷ Uses the getByText method from @testing-library/dom to find an element indicating
    that the inventory contains zero cheesecakes, and then asserts that it exists
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用来自 @testing-library/dom 的 `getByText` 方法来查找表示库存中没有奶酪蛋糕的元素，然后断言它存在
- en: ❸ Finds the button to add cheesecakes by its text
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 通过文本找到添加奶酪蛋糕的按钮
- en: ❹ Uses fireEvent from @testing-library/dom to click the button that adds a cheesecake
    to the inventory, and makes sure that updates are processed and applied to the
    DOM
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用来自 @testing-library/dom 的 `fireEvent` 来点击添加奶酪蛋糕到库存的按钮，并确保更新被处理并应用到 DOM 上
- en: ❺ Uses getByText to find an element indicating that the inventory contains one
    cheesecake, and then asserts that it exists
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用 `getByText` 来查找表示库存中有一个奶酪蛋糕的元素，然后断言它存在
- en: In the previous example, also shown in figure 7.4, you’ve used the render method
    from `react-dom/utils` to render the `App` component to your JSDOM instance and
    the `getByText` query from `dom-testing-library` to find elements in the page
    and interact with them.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的示例中，如图 7.4 所示，你使用了来自 `react-dom/utils` 的 `render` 方法将 `App` 组件渲染到你的 JSDOM
    实例中，并使用来自 `dom-testing-library` 的 `getByText` 查询来查找页面中的元素并与它们交互。
- en: '![](../Images/CH07_F04_DaCosta.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH07_F04_DaCosta.png)'
- en: Figure 7.4 What happens when using `react-dom/test-utils` to render components
    but using `dom-testing-library` to find rendered elements and interact with them
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 使用 `react-dom/test-utils` 渲染组件但使用 `dom-testing-library` 来查找渲染的元素并与它们交互时会发生什么
- en: Now that you’ve seen `dom-testing-library` interacting appropriately with your
    React application, try using `jest-dom` exactly like you would when testing a
    pure JavaScript project. Because `jest-dom` operates on top of the DOM, it will
    work seamlessly with the React components you’re rendering, just like `dom-testing-library`
    did.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到 `dom-testing-library` 正确地与你的 React 应用程序交互，尝试像测试纯 JavaScript 项目一样使用 `jest-dom`。因为
    `jest-dom` 在 DOM 之上运行，它将与你渲染的 React 组件无缝工作，就像 `dom-testing-library` 一样。
- en: To use `jest-dom`, install it with `npm install --save-dev @testing-library/jest-dom`,
    create a script to extend Jest with the assertions provided by `jest-dom`, and
    update `jest.config.js` so that it executes that script before running a test
    file.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `jest-dom`，使用 `npm install --save-dev @testing-library/jest-dom` 安装它，创建一个脚本以扩展
    Jest 以使用 `jest-dom` 提供的断言，并更新 `jest.config.js` 以在运行测试文件之前执行该脚本。
- en: Listing 7.19 jest.config.js
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.19 jest.config.js
- en: '[PRE18]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Before each test, Jest executes the script that extends Jest with the assertions
    from jest-dom.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在每个测试之前，Jest 执行扩展 Jest 以使用 jest-dom 断言的脚本。
- en: Listing 7.20 setupJestDom.js
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.20 setupJestDom.js
- en: '[PRE19]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Extends Jest with the assertions from jest-dom
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 扩展 Jest 以使用 jest-dom 的断言
- en: Once you’ve set up this library, use it to assert that the header is currently
    in the document.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了此库，使用它来断言标题当前在文档中。
- en: Listing 7.21 App.test.jsx
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.21 App.test.jsx
- en: '[PRE20]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Uses an assertion from jest-dom to assert that a certain element is in the
    document
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 jest-dom 的断言来断言某个元素在文档中
- en: These are just two of many tools that you can use both when testing vanilla
    JavaScript applications and when testing React applications.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是你可以用于测试纯 JavaScript 应用程序和 React 应用程序的许多工具中的两个。
- en: Important As long as you’re rendering components to the DOM and accurately reproducing
    a browser’s behavior, any tools that work for pure JavaScript applications will
    work for React applications.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：只要你在 DOM 上渲染组件并准确复制浏览器的行为，任何适用于纯 JavaScript 应用程序的工具都将适用于 React 应用程序。
- en: As a general piece of advice, when researching how to test applications that
    use a particular library or framework, I’d recommend you first to understand how
    that library or framework itself works in a browser. No matter what library or
    framework you’re using, by rendering your application like a browser would, you
    can make your tests more reliable and widen the range of tools you can use.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般建议，当研究如何测试使用特定库或框架的应用程序时，我建议你首先了解该库或框架本身在浏览器中的工作方式。无论你使用什么库或框架，通过像浏览器一样渲染你的应用程序，你可以使你的测试更加可靠，并扩大你可以使用的工具范围。
- en: Except for the compilation and rendering steps, testing React applications is
    similar to testing vanilla JavaScript applications. When testing your React applications,
    remember that you’re primarily dealing with DOM nodes, and that the same principles
    for writing effective tests still apply. You should, for example, write tight
    and precise assertions and find elements using properties that constitute an integral
    part of what it should be.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 除了编译和渲染步骤之外，测试React应用程序与测试纯JavaScript应用程序类似。在测试你的React应用程序时，请记住你主要处理的是DOM节点，并且编写有效测试的原则仍然适用。例如，你应该编写紧凑且精确的断言，并使用构成其本质部分的属性来查找元素。
- en: 7.2.2 React Testing Library
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.2 React 测试库
- en: Up to now, because you’re dealing with React, your tests involve plenty of React-specific
    concerns. Because you need to render components to the DOM, you are manually attaching
    a `div` to a JSDOM instance and rendering components yourself by using `react-dom`.
    Besides this extra work, when your tests finish, you *do not* have a teardown
    hook to remove the rendered nodes from the DOM. This lack of a cleanup routine
    could cause one test to interfere with another, and, if you were to implement
    it, you’d have to do it manually.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，因为你正在处理React，你的测试涉及大量的React特定问题。由于你需要将组件渲染到DOM中，你手动将一个`div`附加到JSDOM实例上，并使用`react-dom`自行渲染组件。除了这项额外的工作之外，当你的测试完成后，你*没有*一个拆解钩子来从DOM中移除渲染的节点。这种缺乏清理例程可能会导致一个测试干扰另一个测试，如果你要实现它，你必须手动完成。
- en: Additionally, to ensure that updates will be processed and applied to the DOM,
    you’re wrapping the interactions with your components into the `act` function
    provided by `react-dom`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了确保更新将被处理并应用到DOM中，你将你的组件交互包裹在`react-dom`提供的`act`函数中。
- en: To solve these problems efficiently, you could replace `dom-testing-library`
    with `react-testing-library`. Unlike the methods from `dom-testing-library`, those
    from `react-testing-library` already take into account React-specific concerns,
    such as wrapping interactions into `act` or automatically unmounting components
    after a test finishes.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地解决这些问题，你可以用`react-testing-library`替换`dom-testing-library`。与`dom-testing-library`的方法不同，`react-testing-library`的方法已经考虑了React特定的关注点，例如将交互包裹到`act`中或在测试完成后自动卸载组件。
- en: In this section, you’ll learn how to use `react-testing-library` to test your
    components. You’ll write a component that includes a form to add new items to
    the inventory and another that contains a list with the server’s inventory’s contents.
    Then, you’ll learn how to test these components using `react-testing-library`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何使用`react-testing-library`来测试你的组件。你将编写一个包含用于向库存中添加新项目的表单的组件，另一个包含服务器库存内容的列表。然后，你将学习如何使用`react-testing-library`测试这些组件。
- en: By using `react-testing-library` and its methods, you’ll understand how it can
    make your tests more concise and understandable by hiding the complexities and
    specificities of testing React applications that you’ve previously seen.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`react-testing-library`及其方法，你将了解它如何使你的测试更加简洁和易于理解，通过隐藏你之前看到的测试React应用程序的复杂性和特定性。
- en: NOTE The `react-testing-library` package is built on top of `dom-testing-library`,
    and both are part of the same “family” of tools. Therefore their APIs are, intentionally,
    almost identical.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`react-testing-library`包建立在`dom-testing-library`之上，两者都属于同一个“家族”的工具。因此，它们的API故意几乎相同。
- en: Rendering components and finding elements
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染组件和查找元素
- en: Your first task with `react-testing-library` will be using it to render components
    to the DOM. Throughout the process, I’ll explain the differences between using
    `react-testing-library` and `react-dom`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`react-testing-library`的第一个任务将是使用它将组件渲染到DOM中。在整个过程中，我将解释使用`react-testing-library`与`react-dom`之间的区别。
- en: Install `react-testing-library` as a dev dependency with `npm install` `--save-dev`
    `@testing-library/react` so that you can start using its functions instead of
    the ones in `dom-testing-library`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`npm install` `--save-dev` `@testing-library/react`安装`react-testing-library`作为开发依赖项，这样你就可以开始使用它的函数而不是`dom-testing-library`中的函数。
- en: Once you’ve installed `react-testing-library`, start using its `render` method
    instead of the one in `react-dom` to render your components.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你安装了`react-testing-library`，就开始使用它的`render`方法而不是`react-dom`中的方法来渲染你的组件。
- en: Because `react-testing-library` appends to the DOM a container of its own within
    which it will render elements, you don’t need to create any nodes yourself.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `react-testing-library` 在 DOM 中添加了一个自己的容器，并在其中渲染元素，所以你不需要自己创建任何节点。
- en: Listing 7.22 App.test.jsx
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.22 App.test.jsx
- en: '[PRE21]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Uses the render function from react-testing-library to render an instance
    of App to the document
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用来自 react-testing-library 的 render 函数将 App 实例渲染到文档中
- en: ❷ Uses the render function from react-testing-library to render an instance
    of App to the document
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用来自 react-testing-library 的 render 函数将 App 实例渲染到文档中
- en: In the previous example, you used the `render` method from `react-testing-library`
    to replace the `render` method from `react-dom/test-utils`. Unlike `react-dom/test-utils`,
    `react-testing-library` will automatically configure a hook to clean up your JSDOM
    instance after each test.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，你使用了 `react-testing-library` 的 `render` 方法来替换 `react-dom/test-utils`
    的 `render` 方法。与 `react-dom/test-utils` 不同，`react-testing-library` 会自动配置一个钩子，在每个测试之后清理你的
    JSDOM 实例。
- en: Besides not requiring setup or cleanup routines for your JSDOM instance, `react-testing-library`’s
    `render` function returns an object containing the same queries as the ones that
    `dom-testing-library` includes. The difference between them is that the queries
    from `react-testing-library`’s `render` method are automatically bound to run
    within the rendered component, not within the whole JSDOM instance. Because these
    queries’ scope is limited, you don’t have to use `screen` or pass a container
    as an argument.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 除了不需要为你的 JSDOM 实例设置或清理例程之外，`react-testing-library` 的 `render` 函数返回一个包含与 `dom-testing-library`
    包含的相同查询的对象。它们之间的区别在于，`react-testing-library` 的 `render` 方法的查询会自动绑定在渲染组件内部运行，而不是在整个
    JSDOM 实例内部。因为这些查询的范围有限，你不需要使用 `screen` 或传递容器作为参数。
- en: Listing 7.23 App.test.jsx
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.23 App.test.jsx
- en: '[PRE22]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Uses the render function from react-testing-library to render an instance
    of App to the document, and obtains a getByText query that is scoped to the render’s
    results
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用来自 react-testing-library 的 render 函数将 App 实例渲染到文档中，并获取一个限定在 render 结果的 getByText
    查询
- en: ❷ Uses the scoped getByText function to find a element by its text, and then
    asserts that it’s in the document
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 scoped getByText 函数通过文本查找元素，然后断言该元素在文档中
- en: ❸ Again uses the render function from react-testing-library to render an instance
    of App, and obtains a getByText query that is scoped to the render’s results
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 再次使用来自 react-testing-library 的 render 函数渲染 App 实例，并获取一个限定在 render 结果的 getByText
    查询
- en: ❹ Uses the scoped getByText function to find an element indicating that there
    are no cheesecakes in the inventory, and then asserts that it’s in the document
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用 scoped getByText 函数查找表示库存中没有芝士蛋糕的元素，然后断言该元素在文档中
- en: ❺ Uses the scoped getByText function to find the button that adds cheesecakes
    to the inventory
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用 scoped getByText 函数查找添加芝士蛋糕到库存的按钮
- en: ❻ Uses fireEvent from dom-testing-library to click the button that adds a cheesecake
    to the inventory
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 使用 dom-testing-library 的 fireEvent 函数点击添加芝士蛋糕到库存的按钮
- en: ❼ Uses the scoped getByText one last time to find an element indicating that
    the inventory now contains one cheesecake, and then asserts that this element
    is in the document
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 再次使用 scoped getByText 函数查找表示库存现在包含一个芝士蛋糕的元素，然后断言该元素在文档中
- en: Thanks to `react-testing-library`, rendering components became much terser.
    Because `react-testing-library` handles both mounting and unmounting your components,
    you don’t need to create special nodes manually nor set up any cleanup hooks.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了 `react-testing-library`，渲染组件变得更加简洁。因为 `react-testing-library` 处理了组件的挂载和卸载，你不需要手动创建特殊节点，也不需要设置任何清理钩子。
- en: Additionally, your queries became much safer because the `render` method from
    `react-testing-library` scopes your queries to the rendered component’s root container.
    Therefore, when executing assertions, you’re guaranteed to assert on elements
    within the component under test.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你的查询变得更加安全，因为 `react-testing-library` 的 `render` 方法将你的查询范围限定在渲染组件的根容器内。因此，在执行断言时，你可以确保断言的是测试组件内的元素。
- en: Interacting with components
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 与组件交互
- en: Previously, to interact with your application, you’ve used the `fireEvent` utility
    from `dom-testing-library` combined with calls to React’s `act` function. Even
    though these two tools enable you to perform rich interactions with your components
    programmatically, `react-testing-library` provides you with a shorter way to do
    so.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，为了与您的应用程序交互，您已经使用了来自 `dom-testing-library` 的 `fireEvent` 工具以及 React 的 `act`
    函数的调用。尽管这两个工具使您能够以编程方式执行丰富的交互，但 `react-testing-library` 提供了一种更简单的方法来实现这一点。
- en: In this subsection, you’ll create a component that contains a form for Louis’s
    staff to add new items to the bakery’s inventory. Then, you’ll learn how to interact
    with this form using `react-testing-library` so that you can write concise, reliable,
    and readable tests.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，您将创建一个包含 Louis 员工添加新项目到面包店库存的表单的组件。然后，您将学习如何使用 `react-testing-library`
    与此表单交互，以便您可以编写简洁、可靠且易于阅读的测试。
- en: To interact with components using `react-testing-library`, you will use its
    `fireEvent` utility instead of the one from `dom-testing-library`. The difference
    between the two is that the `fireEvent` utility within `react-testing-library`
    already wraps interactions into `act` calls. Because `react-testing-library` takes
    care of using `act`, you don’t have to worry about that yourself.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `react-testing-library` 与组件交互时，您将使用其 `fireEvent` 工具而不是来自 `dom-testing-library`
    的工具。这两个工具之间的区别在于，`react-testing-library` 中的 `fireEvent` 工具已经将交互封装到 `act` 调用中。因为
    `react-testing-library` 负责使用 `act`，所以您不必自己担心这一点。
- en: Go ahead and replace the `fireEvent` function from `dom-testing-library` with
    the `fireEvent` function from `react-testing-library` so that you can stop using
    `act` yourself.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `dom-testing-library` 的 `fireEvent` 函数替换为 `react-testing-library` 的 `fireEvent`
    函数，这样您就可以停止自己使用 `act`。
- en: Listing 7.24 App.test.jsx
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.24 App.test.jsx
- en: '[PRE23]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Imports both render and fireEvent from react-testing-library
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从 `react-testing-library` 导入 `render` 和 `fireEvent`
- en: ❷ Renders an instance of App to the document, and obtains a getByText function
    scoped to the render’s results
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将 App 实例渲染到文档中，并获取一个作用域为渲染结果的 `getByText` 函数
- en: ❸ Uses the scoped getByText function to find elements in the DOM, and asserts
    and interacts with them
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用作用域内的 `getByText` 函数在 DOM 中查找元素，并断言和与之交互
- en: ❹ Uses the fireEvent utility from react-testing-library to click the button
    that adds a cheesecake to the inventory, so that you don’t have to wrap your interaction
    into an act call
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用来自 `react-testing-library` 的 `fireEvent` 工具点击添加奶酪蛋糕到库存的按钮，这样您就不必将您的交互封装到
    `act` 调用中
- en: By using the `queries` and the `render` and `fireEvent` methods from `react-testing-library`,
    you have entirely eliminated the necessity to use `dom-testing-library`. After
    this change, `react-testing-library` is the only library with which you have to
    interface to render components, find elements, and interact with them, as you
    can see in figure 7.5.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用来自 `react-testing-library` 的 `queries`、`render` 和 `fireEvent` 方法，您已经完全消除了使用
    `dom-testing-library` 的必要性。在此更改之后，`react-testing-library` 是您唯一需要与之交互的库，用于渲染组件、查找元素以及与之交互，如图
    7.5 所示。
- en: '![](../Images/CH07_F05_DaCosta.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH07_F05_DaCosta.png)'
- en: Figure 7.5 How your tests interact with your components when you use *only*`react-testing-library`.
    This library is capable of rendering components, finding elements, and interacting
    with them.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 当您仅使用 `react-testing-library` 时，您的测试如何与组件交互。这个库能够渲染组件、查找元素以及与之交互。
- en: TIP To uninstall `dom-testing-library` and remove it from your dependency list,
    use `npm uninstall dom-testing library`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：要卸载 `dom-testing-library` 并从依赖列表中移除它，请使用 `npm uninstall dom-testing library`。
- en: Now that you know how the `fireEvent` method from `react-testing-library` works,
    you’ll create a more complex component and learn how to test it. This new component
    will be called `ItemForm`, and it will replace the current button that increments
    the number of cheesecakes.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了 `react-testing-library` 的 `fireEvent` 方法是如何工作的，您将创建一个更复杂的组件，并学习如何测试它。这个新组件将被命名为
    `ItemForm`，它将替换当前增加奶酪蛋糕数量的按钮。
- en: Similar to the form in the previous chapter’s application, when submitted, it
    will send a request to the server. Because it will contain two fields—one for
    the item’s name and another for the quantity to add—the form will allow stock
    managers to add any amounts of any products.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章应用程序中的表单类似，当提交时，它将向服务器发送请求。因为它将包含两个字段——一个用于物品的名称，另一个用于要添加的数量——表单将允许库存经理添加任何数量的任何产品。
- en: NOTE Because this chapter focuses on testing React applications, not backends,
    I will build the next examples on top of the same server you used in chapter 6.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：由于本章重点介绍测试React应用程序，而不是后端，因此我将基于您在第六章中使用的相同服务器构建下一个示例。
- en: You can find the code for the server as well as this chapter’s examples in this
    book’s repository on GitHub, at [https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书GitHub仓库中找到服务器的代码以及本章的示例，网址为[https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications)。
- en: Within the folder for chapter 7, you’ll find a directory named `server`, which
    contains an HTTP server capable of handling the requests your React application
    will make.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7章的文件夹中，您将找到一个名为`server`的目录，其中包含一个能够处理您的React应用程序将发出的请求的HTTP服务器。
- en: To run that server, navigate into its folder, install its dependencies with
    `npm install`, ensure that your database schema is up-to-date with `npm` `run
    migrate:dev`, and spin up the server with `npm` `start`. Your HTTP server will
    be bound to port `3000` by default.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行该服务器，导航到其文件夹，使用`npm install`安装其依赖项，使用`npm run migrate:dev`确保您的数据库模式是最新的，然后使用`npm
    start`启动服务器。默认情况下，您的HTTP服务器将绑定到端口`3000`。
- en: Start the work on this form by creating an `ItemForm` component that can manage
    only its own state. Don’t worry about sending requests to the server for now.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个只能管理自身状态的`ItemForm`组件来开始此表单的工作。现在不必担心向服务器发送请求。
- en: Listing 7.25 ItemForm.jsx
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.25 ItemForm.jsx
- en: '[PRE24]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Creates a piece of state that will store the form’s itemName
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个状态片段，用于存储表单的`itemName`
- en: ❷ Creates a piece of state that will store the form’s quantity
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个状态片段，用于存储表单的`quantity`
- en: ❸ Creates a form with two fields and a submit button. This form will call the
    onSubmit function when submitted.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建一个包含两个字段和提交按钮的表单。此表单在提交时会调用`onSubmit`函数。
- en: As an exercise, to practice what you’ve previously learned about `react-testing-library`
    queries, create a file called `ItemForm.test.jsx`, and write a unit test that
    validates whether this component renders the correct elements. This test should
    render `ItemForm` and use the queries returned by the `render` function to find
    the elements you want. Then you should assert that these elements are present
    in the DOM, just like you have done previously to find the header within `App`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，为了练习您之前关于`react-testing-library`查询学到的知识，创建一个名为`ItemForm.test.jsx`的文件，并编写一个单元测试来验证此组件是否渲染了正确的元素。此测试应渲染`ItemForm`并使用`render`函数返回的查询来查找您想要的元素。然后您应该断言这些元素存在于DOM中，就像您之前在`App`中查找标题时做的那样。
- en: NOTE You can find a complete example of how to write this test in the `chapter7/2_an_overview_of_react_testing_libraries/2_react_testing_library`
    folder in this book’s GitHub repository, at [https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可以在本书GitHub仓库的`chapter7/2_an_overview_of_react_testing_libraries/2_react_testing_library`文件夹中找到一个如何编写此测试的完整示例，网址为[https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications)。
- en: Now that `ItemForm` renders a `form` with two fields and a submit button, you’ll
    make it send requests to the server whenever users submit new items.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于`ItemForm`渲染了一个包含两个字段和提交按钮的`form`，您将使其在用户提交新项目时向服务器发送请求。
- en: To make sure that the server’s address will be consistent across your project,
    create a `constants.js` file in which you’ll create a constant containing the
    server’s address and export it.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保服务器地址在您的项目中保持一致，创建一个`constants.js`文件，在其中创建一个包含服务器地址的常量并将其导出。
- en: Listing 7.26 constants.js
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.26 constants.js
- en: '[PRE25]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Finally, update `ItemForm.js` so that it sends a request to the server when
    users submit the form.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新`ItemForm.js`，以便在用户提交表单时向服务器发送请求。
- en: Listing 7.27 ItemForm.jsx
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.27 ItemForm.jsx
- en: '[PRE26]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ A function that sends a request to the server’s route, which handles adding
    new items to the inventory
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个向服务器路由发送请求的函数，该路由处理向库存中添加新项目
- en: ❷ An onSubmit function that prevents the page from reloading and sends a request
    to the server when the form is submitted
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一个`onSubmit`函数，该函数在表单提交时防止页面重新加载并向服务器发送请求
- en: ❸ A form element that calls onSubmit when submitted
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 一个在提交时调用`onSubmit`的表单元素
- en: Before you can interact with your component and check whether it sends the appropriate
    requests to the server, you must remember to replace the global `fetch` with `isomorphic-fetch`,
    as you did in the previous chapter. Otherwise, you’ll run into errors because
    Node.js, which runs Jest, does *not* have a global `fetch` function.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在你能够与你的组件交互并检查它是否向服务器发送适当的请求之前，你必须记住将全局的 `fetch` 替换为 `isomorphic-fetch`，就像你在上一章中所做的那样。否则，由于运行
    Jest 的 Node.js 没有全局的 `fetch` 函数，你将遇到错误。
- en: To replace the global `fetch` when running tests, install `isomorphic-fetch`
    as a dev dependency with `npm` `install` `--save-dev` `isomorphic-fetch`. Then,
    create a file called `setupGlobalFetch.js`, which will assign the `fetch` function
    from `isomorphic-fetch` to the `fetch` property in the JSDOM’s window.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在运行测试时替换全局的 `fetch`，使用 `npm install --save-dev isomorphic-fetch` 将 `isomorphic-fetch`
    安装为开发依赖项。然后，创建一个名为 `setupGlobalFetch.js` 的文件，该文件将 `isomorphic-fetch` 的 `fetch`
    函数分配给 JSDOM 的 window 中的 `fetch` 属性。
- en: Listing 7.28 setupGlobalFetch.js
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.28 setupGlobalFetch.js
- en: '[PRE27]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Assigns the fetch function from isomorphic-fetch to the global window’s fetch
    property
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 isomorphic-fetch 的 fetch 函数分配给全局 window 的 fetch 属性
- en: Once you have created this file, tell Jest to run it before each of your test
    files by updating the `setupFilesAfterEnv` option in `jest.config.js`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了此文件，通过更新 `jest.config.js` 中的 `setupFilesAfterEnv` 选项，告诉 Jest 在每个测试文件之前运行它。
- en: Listing 7.29 setupGlobalFetch.js
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.29 setupGlobalFetch.js
- en: '[PRE28]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ Before executing each test file, Jest will run the script that assigns the
    fetch function from isomorphic-fetch the global window’s fetch property.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在执行每个测试文件之前，Jest 将运行一个脚本，将来自 isomorphic-fetch 的 fetch 函数分配给全局 window 的 fetch
    属性。
- en: Now that your components have access to `fetch` during tests, you’ll test whether
    the form sends the appropriate requests to your backend. In this test, you will
    use the `fireEvent` function from `react-testing-library` to fill and submit the
    form, and `nock` to intercept requests and respond to them. Because you’re dealing
    with DOM nodes within JSDOM, and `fireEvent` already performs interactions within
    the `act` function, this test will resemble a test for a vanilla JavaScript application.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在由于你的组件在测试期间可以访问 `fetch`，你将测试表单是否向你的后端发送适当的请求。在这个测试中，你将使用来自 `react-testing-library`
    的 `fireEvent` 函数填写和提交表单，并使用 `nock` 拦截请求并对其做出响应。由于你正在处理 JSDOM 中的 DOM 节点，并且 `fireEvent`
    已经在 `act` 函数内执行交互，这个测试将类似于一个纯 JavaScript 应用程序的测试。
- en: Listing 7.30 ItemForm.test.jsx
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.30 ItemForm.test.jsx
- en: '[PRE29]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ Creates an interceptor that responds with a 200 status to a POST request sent
    to /inventory/cheesecake, whose body’s quantity property is 2
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个响应状态为 200 的拦截器，对发送到 /inventory/cheesecake 的 POST 请求做出响应，其 body 的数量属性为
    2
- en: ❷ Updates with “cheesecake,” the form field for the item name
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 更新为“芝士蛋糕”，项目名称的表单字段
- en: ❸ Updates with “2,” the form field for the item’s quantity
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 更新为“2”，项目数量的表单字段
- en: ❹ Clicks the button that submits the form
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 点击提交表单的按钮
- en: ❺ Expects all the interceptors to have been reached
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 期望所有拦截器都已到达
- en: Once you’ve finished implementing `ItemForm`, you’ll use it within the `App`
    component. After this change, users will be able to add any number of any items
    to the inventory—not only cheesecake.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了 `ItemForm` 的实现，你将在 `App` 组件中使用它。在此更改之后，用户将能够将任何数量的任何项目添加到库存中——而不仅仅是芝士蛋糕。
- en: Listing 7.31 App.jsx
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.31 App.jsx
- en: '[PRE30]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ Renders an instance of ItemForm within App
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在 App 中渲染 ItemForm 的实例
- en: To make sure that all tests are still passing, remember to remove from `App.test.jsx`
    the test that validates the button responsible for adding cheesecake to the inventory.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保所有测试仍然通过，请记住从 `App.test.jsx` 中移除验证负责将芝士蛋糕添加到库存的按钮的测试。
- en: For you to see the form working, build your application with `npm run build`,
    and serve it at `localhost:8080` by serving it with `npx http-server ./`. With
    your developer tools’ Network tab open, fill the form and submit new items so
    that you can see the requests sent to the server.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你看到表单的工作情况，使用 `npm run build` 构建你的应用程序，并通过 `npx http-server ./` 在 `localhost:8080`
    上提供服务。在你的开发者工具的网络标签页打开的情况下，填写表单并提交新项目，以便你可以看到发送到服务器的请求。
- en: Waiting for events
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 等待事件
- en: As you write React applications, you’ll eventually find situations in which
    you rely on an external source that causes your components to update. You could,
    for example, have a component that depends on a timer generating random values
    or a server responding to requests.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写 React 应用程序时，你最终会发现你依赖于外部源，这会导致你的组件更新。例如，你可能有一个依赖于生成随机值或响应请求的服务器的计时器的组件。
- en: In those cases, you’ll need to wait for those events to happen and for React
    to process the updates and render up-to-date components to the DOM.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在那些情况下，您需要等待这些事件发生，并让 React 处理更新并将最新的组件渲染到 DOM 中。
- en: In this section, you’ll implement and test an `ItemList` component that fetches
    a list of items from the server and updates itself to display what’s in stock.
    Without this list, it would be impossible for the staff to manage the bakery’s
    inventory.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将实现并测试一个 `ItemList` 组件，该组件从服务器获取项目列表并更新自身以显示库存情况。没有这个列表，员工将无法管理面包店的库存。
- en: Start implementing this feature by creating a file named `ItemList.jsx` and
    writing the component that will list what’s in stock. The `ItemList` component
    should receive an `itemsprop` and use it to render a list of items.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个名为 `ItemList.jsx` 的文件并编写将列出库存的组件来开始实现此功能。`ItemList` 组件应接收一个 `itemsprop`
    并使用它来渲染项目列表。
- en: Listing 7.32 ItemList.jsx
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.32 ItemList.jsx
- en: '[PRE31]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ Creates an ItemList component that can receive an items prop
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个可以接收 `items` 属性的 `ItemList` 组件
- en: ❷ Iterates through each property in items, and renders a li element for each
    with their names and quantities
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 遍历 `items` 中的每个属性，并为每个属性渲染一个带有其名称和数量的 li 元素
- en: To validate whether this component adequately renders the item list passed to
    it, you’ll write a test in `ItemList.test.jsx`. This test should pass to `ItemList`
    an object with a few items, render the component to DOM using the `render` function
    from `react-testing-library`, and check whether the list contains the correct
    content.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证此组件是否充分渲染传递给它的项目列表，您将在 `ItemList.test.jsx` 中编写一个测试。此测试应将包含几个项目的对象传递给 `ItemList`，使用来自
    `react-testing-library` 的 `render` 函数将组件渲染到 DOM 中，并检查列表是否包含正确的内容。
- en: Listing 7.33 ItemList.spec.jsx
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.33 ItemList.spec.jsx
- en: '[PRE32]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ Creates a static list of items
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个静态项目列表
- en: ❷ Renders an ItemList element with the static list of items
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用静态项目列表渲染 `ItemList` 元素
- en: ❸ Expects the rendered ul element to have three children
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 期望渲染的 ul 元素有三个子元素
- en: ❹ Finds an element indicating that the inventory contains 2 cheesecakes
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 查找表示库存中有 2 个芝士蛋糕的元素
- en: ❺ Finds an element indicating that the inventory contains 5 croissants
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 查找表示库存中有 5 个可颂的元素
- en: ❻ Finds an element indicating that the inventory contains 96 macaroons
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 查找表示库存中有 96 个马卡龙的元素
- en: Now that you know that `ItemList` can render the inventory’s items adequately,
    you’ll populate it with the contents given to you by the server.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道 `ItemList` 可以充分渲染库存的项目，您将使用服务器提供的内容填充它。
- en: To populate `ItemList` for the first time, make `App` fetch the inventory’s
    contents by sending a request to `GET /inventory` as it renders. Once the client
    receives the response, it should update its state and pass the list of items to
    `ItemList`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 要首次填充 `ItemList`，让 `App` 在渲染时通过向 `GET /inventory` 发送请求来获取库存的内容。一旦客户端收到响应，它应更新其状态并将项目列表传递给
    `ItemList`。
- en: Listing 7.34 App.jsx
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.34 App.jsx
- en: '[PRE33]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ Makes the App component send a request to the server to fetch a list of items
    when it renders
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当 `App` 组件渲染时，使其向服务器发送请求以获取项目列表
- en: ❷ Updates the state within App when it receives an item list from the server
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当 `App` 接收到来自服务器的项目列表时，更新其状态
- en: ❸ Renders the ItemList with the item list obtained from the server
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用从服务器获取的项目列表渲染 `ItemList`
- en: NOTE When packaging your application, due to the usage of `async/await` within
    your `useEffect` hook, you will have to configure Babel’s `preset-env` to use
    polyfills from a package called `core-js`. Otherwise, your application won’t work
    in the browser, even after it’s built.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在打包应用程序时，由于在 `useEffect` 钩子中使用了 `async/await`，您必须配置 Babel 的 `preset-env`
    以使用名为 `core-js` 的包中的 polyfills。否则，即使构建后，您的应用程序在浏览器中也无法工作。
- en: To do so, install `core-js` with `npm install --save-dev core-js@2`, and update
    the `transform` settings for Browserify within `package.json`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，使用 `npm install --save-dev core-js@2` 安装 `core-js`，并在 `package.json` 中更新
    Browserify 的 `transform` 设置。
- en: The `core-js` package includes polyfills for more recent ECMAScript versions,
    which will be included in your bundle so that you have access to modern features,
    such as `async/await`.{
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`core-js` 包包含对更近期的 ECMAScript 版本的 polyfills，这些 polyfills 将包含在您的包中，以便您可以使用现代功能，如
    `async/await`。'
- en: Listing 7.35 package.json
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.35 package.json
- en: '[PRE34]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Making your component update itself after the call to `fetch` resolves will
    cause the test in `App.test.js` to fail. It will fail because it doesn’t wait
    for the call to `fetch` to resolve before the test finishes.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`fetch`解决后使你的组件更新自身将导致`App.test.js`中的测试失败。它会失败，因为它在测试完成之前没有等待`fetch`调用解决。
- en: Because `react-testing-library` unmounts components after a test finishes, by
    the time `fetch` resolves, the component will not be mounted anymore but will
    still try to set its state. This attempt to set the state of an unmounted component
    is what causes React to raise an error.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`react-testing-library`在测试完成后卸载组件，所以在`fetch`解决之前，组件将不再挂载，但仍会尝试设置其状态。这就是React引发错误的原因。
- en: Fix that test by making `App.jsx` avoid updating its state if the component
    is not mounted.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使`App.jsx`在组件未挂载时避免更新其状态来修复该测试。
- en: Listing 7.36 App.jsx
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.36 App.jsx
- en: '[PRE35]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ Creates a reference whose value will indicate whether App is mounted
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个引用，其值将指示App是否已挂载
- en: ❷ Sets isMounted to true when the App mounts
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当App挂载时将isMounted设置为true
- en: ❸ Avoids updating the state within App if it’s not mounted anymore
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 避免在App未挂载时更新其状态
- en: ❹ A function that will be called when App unmounts and will set isMounted to
    false
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 当App卸载时将被调用的函数，并将isMounted设置为false
- en: With this test passing, you must now test whether your application would display
    the inventory contents once the server responds to the request sent by the `App`
    component. Otherwise, the list of items would always be empty.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个测试通过后，你现在必须测试你的应用程序是否会在服务器响应由`App`组件发送的请求后显示库存内容。否则，物品列表将始终为空。
- en: To test whether `App` populates `ItemList` appropriately, you should write a
    test that’s capable of making `fetch` resolve to a static list of items, rendering
    `App`, waiting for `App` to update with the request’s response, and checking each
    of the list items.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试`App`是否适当地填充`ItemList`，你应该编写一个能够使`fetch`解决到一个静态物品列表的测试，渲染`App`，等待`App`使用请求的响应更新，并检查列表中的每个项目。
- en: For the `App` component to get a list of items from the server, add to your
    `App.test.jsx` a `beforeEach` hook that will use `nock` to intercept `GET` requests
    to `/inventory`. Then, make sure there are no unused interceptors after each test
    by adding an `afterEach` hook that clears all interceptors. Additionally, this
    hook should throw an error if the `nock.isDone` method returns `false`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让`App`组件从服务器获取一个物品列表，请向`App.test.jsx`添加一个`beforeEach`钩子，该钩子将使用`nock`拦截对`/inventory`的`GET`请求。然后，通过添加一个清除所有拦截器的`afterEach`钩子，确保每个测试后没有未使用的拦截器。此外，如果`nock.isDone`方法返回`false`，此钩子应抛出错误。
- en: Listing 7.37 App.test.jsx
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.37 App.test.jsx
- en: '[PRE36]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ❶ Before each test, creates an interceptor that will respond to GET requests
    to /inventory with a list of items
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在每个测试之前，创建一个拦截器，该拦截器将对`/inventory`的GET请求响应一个物品列表
- en: ❷ After each test, checks if all interceptors have been reached, and, if they
    haven’t, clears unused intereceptors and throws an error
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在每个测试之后，检查是否所有拦截器都已到达，如果没有，则清除未使用的拦截器并抛出错误
- en: After creating these hooks, write a test that renders `App`, waits for the list
    to have three children, and checks whether the expected list items are present.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建这些钩子之后，编写一个测试，该测试渲染`App`组件，等待列表有三个子项，并检查是否出现了预期的列表项。
- en: To wait for the list to be populated, you can use the `waitFor` method from
    `react-testing-library`. This method will rerun the function passed to it until
    that function doesn’t throw any errors. Because your assertions will throw an
    `AssertionError` when they fail, you can use `waitFor` as a retry mechanism for
    them.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 要等待列表被填充，你可以使用来自`react-testing-library`的`waitFor`方法。这个方法将重新运行传递给它的函数，直到该函数不抛出任何错误。因为当你的断言失败时，它们将抛出`AssertionError`，所以你可以将`waitFor`用作它们的重试机制。
- en: Listing 7.38 App.test.jsx
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.38 App.test.jsx
- en: '[PRE37]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ❶ Renders an instance of App
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 渲染App的一个实例
- en: ❷ Waits for the rendered ul element to have three children
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 等待渲染的ul元素有三个子项
- en: ❸ Finds an element indicating that the inventory contains 2 cheesecakes
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 找到一个表示库存包含2个芝士蛋糕的元素
- en: ❹ Finds an element indicating that the inventory contains 5 croissants
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 找到一个表示库存包含5个羊角面包的元素
- en: ❺ Finds an element indicating that the inventory contains 96 macaroons
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 找到一个表示库存包含96个马卡龙的元素
- en: In this case, because you just want to wait until the list has items, the only
    assertion you’ll wrap into `waitFor` is one that checks the number of elements
    in the list.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，因为你只想等待列表中有项目，所以你将包装进 `waitFor` 的唯一断言是检查列表中元素数量的断言。
- en: If you also wrap other assertions into `waitFor`, these assertions could fail
    because the list’s content is incorrect, but `react-testing-library` keeps retrying
    them until the test times out.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将其他断言也包装进 `waitFor`，这些断言可能会因为列表的内容不正确而失败，但 `react-testing-library` 会不断重试，直到测试超时。
- en: TIP To avoid having to use `waitFor` every time you need to wait for an element,
    you can also use `findBy*` instead of `getBy*` queries.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：为了避免每次需要等待元素时都必须使用 `waitFor`，你也可以使用 `findBy*` 而不是 `getBy*` 查询。
- en: A `findBy*` query runs asynchronously. The promise returned by this kind of
    query either resolves with the found element or rejects after one second if it
    didn’t find anything matching the passed criteria.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`findBy*` 查询是异步执行的。此类查询返回的承诺要么在找到匹配的元素时解决，要么在1秒后拒绝，如果没有找到匹配的元素。'
- en: You could use it, for example, to replace the `waitFor`, which causes your test
    to wait for the list to have three children.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用它来替换 `waitFor`，这会导致你的测试等待列表有三个子元素。
- en: Instead of using the `waitFor` function to wait for the list to contain three
    children before running assertions, you can do the opposite. You can use `findByText`
    to wait for the elements with the expected text to be visible first and only then
    assert on the list’s size.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用 `waitFor` 函数在运行断言之前等待列表包含三个子元素，你可以做相反的事情。你可以使用 `findByText` 等待具有预期文本的元素首先变得可见，然后才对列表的大小进行断言。
- en: Listing 7.39 App.test.jsx
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.39 App.test.jsx
- en: '[PRE38]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ❶ Renders an instance of App
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 渲染 App 实例
- en: ❷ Waits for an element indicating that the inventory contains 2 cheesecakes
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 等待一个元素指示库存中有2个芝士蛋糕
- en: ❸ Waits for an element indicating that the inventory contains 5 croissants
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 等待一个元素指示库存中有5个可颂
- en: ❹ Waits for an element indicating that the inventory contains 96 macaroons
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 等待一个元素指示库存中有96个马卡龙
- en: ❺ Asserts that the rendered ul element has three children
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 断言渲染的 ul 元素有三个子元素
- en: Always try to keep your `waitFor` callbacks as lean as possible. Otherwise,
    it could cause your tests to take longer to run. As you’ve done in this test,
    write the minimum number of assertions you can to verify that a particular event
    happened.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 总是尽量使你的 `waitFor` 回调尽可能简洁。否则，它可能会导致你的测试运行时间更长。就像你在这次测试中所做的那样，写下尽可能少的断言来验证特定事件是否发生。
- en: NOTE When testing React applications, I consider components to be atomic units.
    Therefore, unlike the previous tests, I’d classify this one as an integration
    test because it involves multiple components.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在测试 React 应用程序时，我认为组件是原子单元。因此，与之前的测试不同，我会将这个测试归类为集成测试，因为它涉及多个组件。
- en: 7.2.3 Enzyme
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.3 酶
- en: Enzyme is a React testing tool that is analogous to `react-testing-library`.
    It has methods to render components to the DOM, to find elements, and to interact
    with them.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 酶是一个与 `react-testing-library` 相似的 React 测试工具。它具有将组件渲染到 DOM、查找元素以及与之交互的方法。
- en: 'The most significant difference between Enzyme and `react-testing-library`
    is their approaches to instrumentation. Enzyme gives you very fine-grained control
    over a component’s internals. It allows you to programmatically set its state,
    update its props, and access what’s passed to each of the component’s children.
    On the other hand, `react-testing-library` focuses on testing components with
    as little introspection as possible. It allows you to interact with components
    only as users would: by finding nodes in the DOM and dispatching events through
    them.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 酶与 `react-testing-library` 之间最显著的区别在于它们对工具化的方法。酶让你对组件的内部有非常细粒度的控制。它允许你以编程方式设置其状态、更新其属性，并访问传递给每个组件子元素的值。另一方面，`react-testing-library`
    专注于尽可能少地进行内省来测试组件。它允许你像用户一样与组件交互：通过在 DOM 中查找节点并通过它们分发事件。
- en: Additionally, Enzyme includes utilities for you to perform `shallow` *rendering*,
    which renders *exclusively* the top-level component passed to it. In other words,
    Enzyme’s `shallow` rendering does *not* render any of the target’s child components.
    In comparison, the only way to do that in `react-testing-library` would be to
    manually replace a component with one of Jest’s test doubles.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Enzyme还包含了一些实用工具，可以帮助你执行`shallow`渲染，这仅渲染传递给它的顶级组件。换句话说，Enzyme的`shallow`渲染不会渲染目标组件的任何子组件。相比之下，在`react-testing-library`中实现这一点的唯一方法是通过Jest的测试替身手动替换组件。
- en: Considering its extensive and flexible API, Enzyme can be an attractive tool
    for separating writing small tests and obtaining quick and granular feedback as
    you write code. With Enzyme, it’s easy to isolate components from one another,
    or even isolate different parts of your components in various tests. However,
    this flexibility comes at the cost of reliability and can make your test suite
    difficult and expensive to maintain.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到其广泛且灵活的API，Enzyme可以是一个在编写小型测试和获取代码编写过程中的快速且细粒度反馈的有吸引力的工具。使用Enzyme，你可以轻松地将组件彼此隔离，甚至在各种测试中隔离组件的不同部分。然而，这种灵活性是以可靠性为代价的，可能会使你的测试套件难以维护且成本高昂。
- en: Because Enzyme makes it too easy to test implementation details of your components,
    it can easily tightly couple your tests to a component’s implementation. This
    tight coupling causes you to have to update your tests more often, thus generating
    more costs. Additionally, when `shallow`-rendering components, you’re essentially
    replacing child components with test doubles, which causes your tests to be not
    representative of what happens at run time and, therefore, makes them less reliable.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Enzyme使得测试组件的实现细节变得过于容易，它很容易将测试紧密耦合到组件的实现上。这种紧密耦合导致你必须更频繁地更新测试，从而产生更多成本。此外，在`shallow`渲染组件时，你实际上是用测试替身替换了子组件，这使得你的测试无法代表运行时发生的情况，因此可靠性降低。
- en: Personally, `react-testing-library` is my preferred tool for React testing.
    I agree with this approach because using fewer test doubles does make tests more
    reliable, even though sometimes I think the library could make it easier to create
    test doubles. Furthermore, its methods allow me to quickly and accurately simulate
    what happens at run time, which gives me stronger reliability guarantees.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 个人而言，`react-testing-library`是我首选的React测试工具。我同意这种做法，因为使用更少的测试替身确实可以使测试更加可靠，尽管有时我认为该库可以更容易地创建测试替身。此外，它的方法允许我快速准确地模拟运行时发生的情况，这为我提供了更强的可靠性保证。
- en: NOTE In this chapter’s next section I’ll explain in more detail how to use test
    doubles, when to do it, and the pros and cons of doing it.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 备注：在本章的下一段中，我将更详细地解释如何使用测试替身、何时使用以及使用测试替身的优缺点。
- en: For the sake of brevity, I won’t get into details of how to use Enzyme, because,
    in the vast majority of cases, I’d recommend `react-testing-library` instead.
    In addition to `react-testing-library`’s API being more concise and encouraging
    patterns that generate more reliable guarantees, at the moment of this writing,
    Enzyme’s `shallow` rendering also can’t handle many different kinds of React hooks
    properly. Therefore, if you’d like to adopt React hooks, you won’t be able to
    use `shallow`, which is one of the main reasons to use Enzyme.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我不会详细介绍如何使用Enzyme，因为在绝大多数情况下，我更推荐使用`react-testing-library`。除了`react-testing-library`的API更加简洁，鼓励产生更可靠保证的模式之外，在撰写本文时，Enzyme的`shallow`渲染也无法正确处理许多不同类型的React钩子。因此，如果你想采用React钩子，你将无法使用`shallow`，这是使用Enzyme的主要原因之一。
- en: Given that it’s still a popular tool, and that you might find it in existing
    projects, I thought it was worth a mention.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它仍然是一个流行的工具，并且你可能在现有的项目中找到它，我认为提一下它是值得的。
- en: If you do proceed to use Enzyme, keep in mind that the same principles related
    to rendering components to the DOM and the overarching structure to translating
    JSX still apply. Therefore, it will be reasonably straightforward to learn how
    to use it.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实决定使用Enzyme，请记住，与将组件渲染到DOM以及将JSX转换为DOM的整体结构相关的相同原则仍然适用。因此，学习如何使用它将相对直接。
- en: NOTE If you’re interested, you can find the documentation for Enzyme at [https://enzymejs.github.io/enzyme/](https://enzymejs.github.io/enzyme/).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 备注：如果你感兴趣，可以在[https://enzymejs.github.io/enzyme/](https://enzymejs.github.io/enzyme/)找到Enzyme的文档。
- en: 7.2.4 The React test renderer
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.4 React测试渲染器
- en: React’s own test renderer is yet another tool to render React components. Unlike
    Enzyme or `react-testing-library`, it renders components to plain JavaScript objects
    instead of rendering them to the DOM, as shown in figure 7.6.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: React自己的测试渲染器是另一个渲染React组件的工具。与Enzyme或`react-testing-library`不同，它将组件渲染为简单的JavaScript对象，而不是将它们渲染到DOM中，如图7.6所示。
- en: It can be useful if, for example, you’re not using JSDOM, or if you *can’t*
    use it. Because React’s test renderer will not transform your components into
    fully fledged DOM nodes, you don’t need any DOM implementation to render components
    and inspect their contents.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您不使用JSDOM，或者无法使用它，这可能是有用的。因为React的测试渲染器不会将您的组件转换为完整的DOM节点，所以您不需要任何DOM实现来渲染组件并检查其内容。
- en: '![](../Images/CH07_F06_DaCosta.png)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH07_F06_DaCosta.png)'
- en: Figure 7.6 React’s test renderer doesn’t render components to a JSDOM instance.
    Instead, it creates a plain JavaScript object that contains a few methods that
    you can use to find and inspect rendered elements.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 React的测试渲染器不会将组件渲染到JSDOM实例中。相反，它创建了一个包含一些您可以使用以查找和检查渲染元素的简单JavaScript对象。
- en: If you’re testing a web application, I don’t see the benefit of using React’s
    test renderer, and, therefore, I’d advocate against it. Setting up JSDOM is reasonably
    quick, and it makes your tests much more reliable because it makes your code run
    just like it would in a browser, replicating your run-time environment conditions
    much more accurately.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在测试一个Web应用程序，我认为使用React的测试渲染器没有好处，因此我反对使用它。设置JSDOM相对较快，并且它使您的测试更加可靠，因为它使您的代码像在浏览器中运行一样，更准确地复制运行时环境条件。
- en: The main use case for `react-test-renderer` is when you are *not* rendering
    components to a DOM but would still like to inspect their contents.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-test-renderer`的主要用例是当您不将组件渲染到DOM中，但仍想检查其内容时。'
- en: If you have a `react-native` application, for example, its components depend
    on a mobile’s run-time environment. Therefore, you wouldn’t be able to render
    them in a JSDOM environment.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您有一个`react-native`应用程序，其组件依赖于移动设备的运行时环境。因此，您无法在JSDOM环境中渲染它们。
- en: Keep in mind that React allows you to define components and how those components
    behave. The task of actually rendering those components in different platforms
    is the responsibility of other tools, which you’ll choose depending on the environment
    you’re targeting. The `react-dom` package, for example, is responsible for rendering
    components to the DOM, differently from `react-native`, which handles components
    in a mobile environment.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，React允许您定义组件及其行为。实际上在不同平台上渲染这些组件的任务是其他工具的责任，您将根据目标环境选择这些工具。例如，`react-dom`包负责将组件渲染到DOM中，而与`react-native`不同，后者在移动环境中处理组件。
- en: NOTE You can find the complete documentation for React’s test renderer at [https://reactjs.org/docs/test-renderer.html](https://reactjs.org/docs/test-renderer.html).
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可以在[https://reactjs.org/docs/test-renderer.html](https://reactjs.org/docs/test-renderer.html)找到React测试渲染器的完整文档。
- en: Summary
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: To test your React components within Node.js in such a way that resembles how
    they work in a browser, you can use JSDOM. Similar to when testing vanilla JavaScript
    clients, when testing React applications, you can render components to a JSDOM
    instance and then use queries to find elements so that you assert on them.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在Node.js中测试您的React组件，使其类似于在浏览器中的工作方式，您可以使用JSDOM。类似于测试纯JavaScript客户端，当测试React应用程序时，您可以将组件渲染到JSDOM实例中，然后使用查询来查找元素，以便对它们进行断言。
- en: JSX extends JavaScript syntax, but it can’t be understood by browsers, or by
    Node.js. In the same way that you have to compile your JSX code to plain JavaScript
    before you can run it in a browser, you need to configure `Jest` to transform
    JSX into plain JavaScript before you can run your tests.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX扩展了JavaScript语法，但浏览器或Node.js无法理解它。与您必须将JSX代码编译为纯JavaScript才能在浏览器中运行一样，您需要配置`Jest`在运行测试之前将JSX转换为纯JavaScript。
- en: Whenever using code that can’t run within the Node.js version you’re using,
    you need to compile it to plain supported JavaScript before you can run tests
    using Jest. You may need to transform your files if, for example, you’re using
    ES imports.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用无法在您使用的Node.js版本中运行的代码时，您需要在运行Jest测试之前将其编译为纯支持的JavaScript。例如，如果您使用ES导入，您可能需要转换您的文件。
- en: To test your React applications, you can use `react-testing-library`, whose
    API is similar to the `dom-testing-library` package you’ve seen in the previous
    chapter. The difference between these two libraries is that `react-testing-library`
    addresses React-specific concerns straight out of the box. These concerns include
    automatically unmounting components, returning queries scoped to the component’s
    wrapper, and wrapping interactions into `act` to make sure that updates were processed
    and applied to the DOM.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要测试你的React应用程序，你可以使用`react-testing-library`，其API与你在上一章中看到的`dom-testing-library`包类似。这两个库之间的区别在于`react-testing-library`直接解决了React特定的关注点。这些关注点包括自动卸载组件、返回针对组件包装器的查询，以及将交互包装到`act`中以确保更新被处理并应用到DOM上。
- en: To deal with HTTP requests within the tests for your React application, you
    can use `nock` in the same way you did when testing vanilla JavaScript applications.
    If you need to wait for a component to update when a request resolves, or when
    an external data source provides it with data, you can use the `waitFor` function
    from `react-testing-library`. With `waitFor`, you can retry an assertion until
    it succeeds and only then proceed to perform other actions or verifications.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了处理你的React应用程序测试中的HTTP请求，你可以像测试纯JavaScript应用程序时那样使用`nock`。如果你需要在请求解决或外部数据源提供数据时等待组件更新，你可以使用`react-testing-library`中的`waitFor`函数。使用`waitFor`，你可以重试断言直到成功，然后才继续执行其他操作或验证。
- en: Enzyme is a popular alternative to `react-testing-library`. Unlike `react-testing-library`,
    Enzyme allows you to interface directly with internal aspects of your components,
    like their `props` and `state`. Additionally, its `shallow` rendering feature
    makes it easier to isolate tests. Because these features make your tests differ
    from what happens in run time, they come at the cost of reliability.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Enzyme是`react-testing-library`的一个流行替代品。与`react-testing-library`不同，Enzyme允许你直接与组件的内部方面进行交互，如它们的`props`和`state`。此外，它的`shallow`渲染功能使得隔离测试更加容易。由于这些特性使得你的测试与运行时发生的情况不同，它们是以可靠性为代价的。
- en: If your React application renders components to a target other than the DOM,
    as React Native does, you can use React’s test renderer to render components to
    plain JavaScript objects.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的React应用程序将组件渲染到除了DOM之外的目标，就像React Native那样，你可以使用React的测试渲染器将组件渲染到普通的JavaScript对象上。
- en: Especially when testing React applications, it’s interesting to think of the
    testing pyramid as a continuous spectrum, rather than a discrete set of categories.
    Because of how thin the integration layer between React and your tests is, I’d
    put tests that involve a single component into the bottom part of the pyramid,
    even though they don’t stub React itself. The more components and different pieces
    of code a test involves, the higher it goes in the pyramid.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尤其是在测试React应用程序时，将测试金字塔视为一个连续的谱系，而不是一组离散的分类，是非常有趣的。由于React与你的测试之间的集成层非常薄，我会把只涉及单个组件的测试放入金字塔的底部，即使它们并没有模拟React本身。测试涉及的组件和不同代码片段越多，它在金字塔中的位置就越高。
