- en: Appendix A. Types of web APIs and protocols
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 A. 网络API和协议类型
- en: 'In this appendix, we study the API protocols we can use to implement application
    interfaces. Each of these protocols evolved to address specific problems in the
    integration between API consumers and producers. We discuss the benefits and the
    limitations of each protocol so that we can make the best choice when designing
    and building our own APIs. We will discuss the following protocols:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录中，我们研究我们可以用来实现应用程序接口的 API 协议。每个协议都是为了解决 API 消费者和生产者之间集成中的特定问题而演化的。我们讨论每个协议的优缺点，以便我们在设计和构建自己的
    API 时做出最佳选择。我们将讨论以下协议：
- en: RPC and its variants, JSON-RPC and XML-RPC
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RPC 及其变体，JSON-RPC 和 XML-RPC
- en: SOAP
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOAP
- en: gRPC
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gRPC
- en: REST
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST
- en: GraphQL
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL
- en: 'Choosing the right type of API is fundamental for the performance and integration
    strategy of our microservices. The factors that will condition our choice of API
    protocol include these:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 选择正确的 API 类型对于我们的微服务性能和集成策略至关重要。将影响我们选择 API 协议的因素包括：
- en: Whether the API is public or private
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 是否为公开或私有
- en: 'Type of API consumer: small devices, mobile applications, browsers, or other
    microservices'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 消费者类型：小型设备、移动应用、浏览器或其他微服务
- en: The capabilities and resources we wish to expose; for example, whether it is
    a hierarchical data model that can be organized around endpoints or a highly interconnected
    net of resources with cross-references among them
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望公开的能力和资源；例如，是否是一个可以围绕端点组织的数据模型，或者是一个高度互联的资源网络，其中资源之间存在交叉引用
- en: We take these factors into consideration when discussing the benefits and constraints
    of each protocol in the following sections to assess their suitability for different
    scenarios.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下各节中，我们讨论每个协议的优缺点时，会考虑这些因素，以评估它们在不同场景中的适用性。
- en: 'A.1 The dawn of APIs: RPC, XML-RPC, and JSON-RPC'
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.1 API 的黎明：RPC、XML-RPC 和 JSON-RPC
- en: Let’s begin by explaining a remote procedure call and its two most common implementations,
    namely, XML-RPC and JSON-RPC. As you can see in figure A.1, a *remote procedure
    call* (RPC) is a protocol that allows a client to invoke a procedure or subroutine
    in a different machine. The origins of this form of communication go back to the
    1980s, with the emergence of distributed computing systems, and over time it has
    evolved into standard implementations.[¹](#pgfId-1086899) Two popular implementations
    are XML-RPC and JSON-RPC.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先解释远程过程调用及其两种最常见实现，即 XML-RPC 和 JSON-RPC。如图 A.1 所示，*远程过程调用*（RPC）是一种允许客户端在另一台机器上调用过程或子程序的协议。这种通信形式的起源可以追溯到
    20 世纪 80 年代，随着分布式计算系统的出现，随着时间的推移，它已经发展成为标准实现。[¹](#pgfId-1086899) 两种流行的实现是 XML-RPC
    和 JSON-RPC。
- en: '![](../Images/A-1.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片 A-1](../Images/A-1.png)'
- en: Figure A.1 Using RPC, a program invokes a function or subroutine from the API
    server.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.1 使用 RPC，程序从 API 服务器调用函数或子程序。
- en: XML-RPC is an RPC protocol that uses Extensible Markup Language (XML) over HTTP
    to exchange data between a client and a server. It was created by Dave Winer in
    1998, and it eventually grew into what later came to be known as SOAP (see section
    A.2).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: XML-RPC 是一种 RPC 协议，它使用可扩展标记语言 (XML) 通过 HTTP 在客户端和服务器之间交换数据。它由 Dave Winer 在 1998
    年创建，并最终发展成为后来被称为 SOAP 的东西（见附录 A.2）。
- en: 'With the increasing popularity of JavaScript Object Notation (JSON) as a data
    serialization format, an alternative implementation of RPC came in the form of
    JSON-RPC. It was introduced in 2005 and offers a simplified way for exchanging
    data between an API client and the server. As you can see in figure A.2, JSON-RPC
    payloads usually include three properties:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 随着JavaScript对象表示法（JSON）作为数据序列化格式的日益流行，RPC 的另一种实现形式是 JSON-RPC。它于 2005 年推出，为 API
    客户端和服务器之间交换数据提供了一种简化的方式。如图 A.2 所示，JSON-RPC 有效载荷通常包括三个属性：
- en: '`method`—The method or function that the client wishes to invoke in the remote
    server'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method`—客户端希望在远程服务器上调用的方法或函数'
- en: '`params`—The parameters that must be passed to the method or function on invocation'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`params`—在调用方法或函数时必须传递的参数'
- en: '`id`—A value to identify the request'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`—用于标识请求的值'
- en: '![](../Images/A-2.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片 A-2](../Images/A-2.png)'
- en: 'Figure A.2 Using JSON-RPC, an API client sends a request to an API server invoking
    the `calculate_price()` function to get the price of a medium cup of cappuccino.
    The server responds with the result of the invocation: $10.70.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.2 使用 JSON-RPC，API 客户端向 API 服务器发送请求，调用 `calculate_price()` 函数以获取中杯卡布奇诺的价格。服务器响应调用结果：$10.70。
- en: 'In turn, JSON-RPC response payloads include the following parameters:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 相应地，JSON-RPC 响应负载包括以下参数：
- en: '`result`—The value returned by the invoked method or function'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`result`—被调用的方法或函数返回的值'
- en: '`error`—An error code raised during the invocation, if any'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error`—在调用过程中引发的错误代码（如果有）'
- en: '`id`—The ID of the request which is being handled'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`—正在处理请求的 ID'
- en: RPC is a lightweight protocol that allows you to drive API integrations without
    having to implement complex interfaces. An RPC client only needs to know the name
    of the function it needs to invoke in the remote server, with its signature. It
    doesn’t need to look for different endpoints and comply with their schemas as
    in REST. However, the lack of a proper interface layer between the API consumer
    and the producer inevitably tends to create tight coupling between the client
    and the implementation details of the server. As a consequence, a small change
    in implementation details risks breaking the integration. For this reason, RPC
    is recommended mostly for internal API integrations, where you’re in full control
    of both the client and the server.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: RPC 是一种轻量级协议，允许您在不实现复杂接口的情况下驱动 API 集成。RPC 客户端只需要知道它需要在远程服务器上调用的函数的名称及其签名。它不需要像
    REST 那样寻找不同的端点并遵守它们的模式。然而，API 消费者和生产者之间缺乏适当的接口层不可避免地倾向于在客户端和服务器实现细节之间创建紧密耦合。因此，实现细节的微小变化可能会破坏集成。因此，RPC
    主要推荐用于内部 API 集成，在这种情况下，您可以完全控制客户端和服务器。
- en: A.2 SOAP and the emergence of API standards
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.2 SOAP 和 API 标准的出现
- en: This section discusses the Simple Object Access Protocol (SOAP). SOAP enables
    communication with web services through the exchange of XML payloads. It was introduced
    in 1998 by Dave Winer, Don Box, Bob Atkisnon, and Mohsen Al-Ghosein for Microsoft,
    and after a number of iterations, it became a standard protocol for web applications
    in 2003\. SOAP was conceived as a messaging protocol, and it runs on top of a
    data transport layer, such as HTTP.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论简单对象访问协议（SOAP）。SOAP 通过交换 XML 负载来实现与 Web 服务的通信。它于 1998 年由 Dave Winer、Don
    Box、Bob Atkisnon 和 Mohsen Al-Ghosein 为微软公司引入，经过多次迭代，于 2003 年成为 Web 应用程序的标准协议。SOAP
    被构想为一个消息协议，它运行在数据传输层之上，例如 HTTP。
- en: 'SOAP was designed to meet three major goals:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: SOAP 被设计来满足三个主要目标：
- en: '*Extensibility*—SOAP can be extended with capabilities found in other messaging
    systems.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可扩展性*—SOAP 可以通过其他消息系统中找到的功能进行扩展。'
- en: '*Neutrality*—It can operate over any data transfer protocol of choice, including
    HTTP, or directly over TCP or UDP, among others.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*中立性*—它可以操作任何选择的数据传输协议，包括 HTTP，或者直接通过 TCP 或 UDP 等其他协议。'
- en: '*Independence*—It enables communication between web applications regardless
    of their programming models.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*独立性*—它使得无论 Web 应用程序的编程模型如何，都可以进行通信。'
- en: 'The payloads exchanged with a SOAP endpoint are represented in XML, and as
    illustrated in figure A.3, they include the following properties:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 与 SOAP 端点交换的负载以 XML 表示，如图 A.3 所示，它们包括以下属性：
- en: '`Envelope` *(required)*—Identifies the XML document as a SOAP payload'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Envelope` *(必需)*—标识 XML 文档为 SOAP 负载'
- en: '`Header` *(optional)*—Includes additional information about the data contained
    in the message, for example, the type of encoding'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Header` *(可选)*—包含关于消息中包含的数据的附加信息，例如编码类型'
- en: '`Body` *(required)*—Contains the payload (actual message being exchanged) of
    the request/response'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Body` *(必需)*—包含请求/响应的负载（实际交换的消息）'
- en: '`Fault` *(optional)*—Contains errors that occurred while processing the request'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fault` *(可选)*—包含在处理请求时发生的错误'
- en: '![](../Images/A-3.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/A-3.png)'
- en: 'Figure A.3 At the top of a SOAP message, we find a section called `Envelope`
    that tells us that this is a SOAP payload. An optional `Header` section includes
    metadata about the message, such as the type of encoding. The `Body` section includes
    the actual payload of the message: the data being exchanged between the client
    and the server. Finally, a section called `Fault` includes details of any errors
    raised while processing the payload.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.3 在 SOAP 消息的顶部，我们找到一个名为 `Envelope` 的部分，它告诉我们这是一个 SOAP 负载。一个可选的 `Header`
    部分包含了关于消息的元数据，例如编码类型。`Body` 部分包含了消息的实际负载：客户端和服务器之间交换的数据。最后，一个名为 `Fault` 的部分包括了在处理负载时出现的任何错误详情。
- en: SOAP was a major contribution to the field of APIs. The availability of a standard
    protocol for communication across web applications led to the emergence of vendor
    APIs. Suddenly, it was possible to sell digital services by simply exposing an
    API that everybody could understand and consume.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: SOAP对API领域做出了重大贡献。跨Web应用程序通信的标准协议的可用性导致了供应商API的出现。突然之间，通过简单地公开一个每个人都能理解和消费的API，就可以销售数字服务。
- en: 'In recent years, SOAP has been superseded by newer protocols and architectures.
    The factors that contributed to the decline of SOAP include these:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，SOAP已被新的协议和架构所取代。导致SOAP衰落的因素包括这些：
- en: The payloads exchanged through SOAP contain large XML documents, which consume
    a large amount of bandwidth.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过SOAP交换的有效负载包含大型XML文档，这消耗了大量的带宽。
- en: XML is difficult to read and maintain, and it requires careful parsing, which
    makes exchanging messages structured in XML less convenient.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML难以阅读和维护，它需要仔细解析，这使得交换以XML结构化的消息不太方便。
- en: SOAP does not provide a clear framework for organizing the data and capabilities
    that we want to expose through an API. It provides a way of exchanging messages,
    and it is up to the agents involved on both sides of the API to decide how to
    make sense of such messages.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOAP没有提供一个清晰的框架来组织我们希望通过API公开的数据和能力。它提供了一种交换消息的方式，并且API两边的代理必须决定如何理解这些消息。
- en: 'A.3 RPC strikes again: Fast exchanges over gRPC'
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.3 RPC再次出击：在gRPC上快速交换
- en: This section discusses a specific implementation of the RPC protocol called
    gRPC,[²](#pgfId-1086964) which was developed by Google in 2015\. This protocol
    uses HTTP/2 as a transport layer and exchanges payloads encoded with Protocol
    Buffers (Protobuf)—a method for serializing structured data. As we explained in
    chapter 2, serialization is the process of translating data into a format that
    can be stored or transferred over a network. Another process must be able to pick
    up the saved data and restore it to its original format. The process of restoring
    serialized data is also known as *unmarshalling*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了RPC协议的一个特定实现，称为gRPC，[²](#pgfId-1086964)，该协议由谷歌在2015年开发。该协议使用HTTP/2作为传输层，并交换使用Protocol
    Buffers（Protobuf）编码的有效负载——一种序列化结构化数据的方法。正如我们在第2章中解释的，序列化是将数据转换为可以存储或通过网络传输的格式的过程。另一个过程必须能够拾取保存的数据并将其恢复到原始格式。恢复序列化数据的过程也被称为*反序列化*。
- en: Some serialization methods are language specific, such as `pickle` for Python.
    Some others, like the popular JavaScript Object Notation (JSON) format, are language
    agnostic and can be translated into the native data structures of other languages.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一些序列化方法是语言特定的，例如Python的`pickle`。其他一些，如流行的JavaScript对象表示法（JSON）格式，是语言无关的，并且可以转换为其他语言的本地数据结构。
- en: An obvious shortcoming of JSON is that it only allows for the serialization
    of simple data representations consisting of strings, Booleans, arrays, associative
    arrays, and `null` values. Because JSON is language agnostic and must be strictly
    transferable across languages and environments, it cannot allow for the serialization
    of language-specific features, like `NaN` (not a number) in JavaScript, tuples
    or sets in Python, or classes in object-oriented languages.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: JSON的一个明显缺点是它只允许序列化由字符串、布尔值、数组、关联数组以及`null`值组成的简单数据表示。由于JSON是语言无关的，并且必须在语言和环境之间严格可传输，因此它不能允许序列化语言特定的功能，如JavaScript中的`NaN`（不是一个数字）、Python中的元组或集合，或在面向对象语言中的类。
- en: Python’s `pickle` format allows you to serialize any type of data structure
    running in your Python programs, including custom objects. The shortcoming, though,
    is that the serialized data is highly specific to the version of Python that you
    were running at the time of dumping the data. Due to slight changes in the internal
    implementation of Python between different releases, you cannot expect a different
    process to be able to reliably parse a pickled file.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`pickle`格式允许您序列化在您的Python程序中运行的任何类型的数据结构，包括自定义对象。然而，缺点是序列化数据高度特定于您在导出数据时运行的Python版本。由于Python在不同版本之间内部实现的细微变化，您不能期望不同的过程能够可靠地解析一个pickle文件。
- en: 'Protobuf comes somewhere in between: it allows you to define more complex data
    structures than JSON, including enumerations, and it is able to generate native
    classes from the serialized data, which you can extend to add custom functionality.
    As you can see in figure A.4, in gRPC you must first define the schema for the
    data structures that you want to exchange over the API using the Protobuf specification
    format, and then use the Protubuf CLI to automatically generate code for both
    the client and the API server.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Protobuf 处于中间位置：它允许你定义比 JSON 更复杂的数据结构，包括枚举，并且能够从序列化数据生成原生类，你可以扩展这些类以添加自定义功能。如图
    A.4 所示，在 gRPC 中，你必须首先使用 Protobuf 规范格式定义你想要通过 API 交换的数据结构的模式，然后使用 Protobuf 命令行工具自动生成客户端和
    API 服务器的代码。
- en: '![](../Images/A-4.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片 A-4](../Images/A-4.png)'
- en: Figure A.4 gRPC uses Protobuf to encode the data exchanged through the API.
    Using the `protoc` CLI, we can generate code (stubs) for both the client and the
    server from a Protobuf specification.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.4 gRPC 使用 Protobuf 对 API 交换的数据进行编码。使用 `protoc` 命令行工具，我们可以从 Protobuf 规范生成客户端和服务器端的代码（存根）。
- en: The data structures generated from the Protobuf specifications are called *stubs*.
    The stubs are implemented in code native to the language we use to build the API
    client and the server. As you can see in figure A.5, the stubs take care of parsing
    and validating the data exchanged between client and server.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Protobuf 规范生成的数据结构称为 *存根*。存根是用我们构建 API 客户端和服务器所使用的语言本地编写的代码实现的。如图 A.5 所示，存根负责解析和验证客户端和服务器之间交换的数据。
- en: '![](../Images/A-5.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片 A-5](../Images/A-5.png)'
- en: Figure A.5 The stubs generated with Protobuf take care of parsing the payloads
    exchanged between the API client and the API server and translating them into
    native code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.5 使用 Protobuf 生成的存根负责解析 API 客户端和 API 服务器之间交换的有效载荷，并将它们转换为本地代码。
- en: gRPC offers a more reliable approach for API integrations than plain RPC. The
    use of Protobuf serves as an enforcement mechanism that ensures the data exchanged
    between the client and the server comes in the expected format. It also helps
    to make sure that communication over the API is highly optimized, since the data
    is exchanged directly in binary format. For this reason, gRPC is an ideal candidate
    for the implementation of internal API integrations where performance is a relevant
    factor.[³](#pgfId-1086996)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 提供了一种比普通 RPC 更可靠的 API 集成方法。使用 Protobuf 作为强制机制，确保客户端和服务器之间交换的数据符合预期的格式。它还有助于确保
    API 通信高度优化，因为数据是以二进制格式直接交换的。因此，gRPC 是实现内部 API 集成的一个理想选择，其中性能是一个相关因素。[³](#pgfId-1086996)
- en: A.4 HTTP-native APIs with REST
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.4 基于 HTTP 的 REST API
- en: This section explains Representational State Transfer (REST) and its main features.
    REST is an architectural style for the design of web services and their interfaces.
    As we saw in chapter 4, REST APIs are structured around resources. We distinguish
    two types of resources, collections and singletons, and we use different URL paths
    to represent them. For example, in figure A.6, `/orders` represents a collection
    of orders, while `/orders/{order_id}` represents the URI of a single order. We
    use `/orders` to retrieve a list of orders and to place new orders, and we use
    `/orders/{order_id}` to perform actions on a single order.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了表示状态转移（REST）及其主要特性。REST 是一种用于设计网络服务和其接口的架构风格。正如我们在第 4 章中看到的，REST API 是围绕资源构建的。我们区分两种资源类型，集合和单例，并使用不同的
    URL 路径来表示它们。例如，在图 A.6 中，`/orders` 代表订单集合，而 `/orders/{order_id}` 代表单个订单的 URI。我们使用
    `/orders` 来检索订单列表和创建新订单，并使用 `/orders/{order_id}` 来对单个订单执行操作。
- en: '![](../Images/A-6.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片 A-6](../Images/A-6.png)'
- en: Figure A.6 REST APIs are structured around endpoints. We distinguish between
    singleton endpoints, such as GET `/orders/8`, and collection endpoints, such as
    GET `/orders`. Leveraging the semantics of HTTP methods, REST API responses include
    HTTP status codes that signal the result of processing the request.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.6 REST API 的结构围绕端点构建。我们区分单例端点，例如 GET `/orders/8`，和集合端点，例如 GET `/orders`。利用
    HTTP 方法的语义，REST API 响应包括 HTTP 状态码，用以指示请求处理的结果。
- en: Good REST API design leverages features from the HTTP protocol to deliver highly
    expressive APIs. For example, as you can see in figure A.7, we use HTTP methods
    to define API endpoints and express their intent (POST to create resources and
    GET to retrieve resources); we use HTTP status codes to signal the result of processing
    a request; and we use HTTP payloads to carry exchange data between the client
    and the server.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的 REST API 设计利用 HTTP 协议的功能来提供高度表达的 API。例如，如图 A.7 所示，我们使用 HTTP 方法来定义 API 端点并表达它们的意图（POST
    用于创建资源，GET 用于检索资源）；我们使用 HTTP 状态码来表示请求处理的结果；我们使用 HTTP 有效载荷在客户端和服务器之间传输交换数据。
- en: We document REST APIs using the OpenAPI standard, which was originally created
    in 2010 by Tony Tam under the name Swagger API. The project gained in popularity,
    and in 2015 the OpenAPI Initiative was launched to maintain the specification.
    In 2016, the specification was officially released under the name OpenAPI Specification
    (OAS).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 OpenAPI 标准来记录 REST API，该标准最初于 2010 年由 Tony Tam 创建，当时名为 Swagger API。随着项目的流行，2015
    年启动了 OpenAPI 创新计划以维护该规范。2016 年，该规范正式以 OpenAPI 规范（OAS）的名义发布。
- en: The data exchanged through a REST API goes in the body of an HTTP request/response.
    This data can be encoded in any type of format the producer of the API wishes
    to enforce, but it is common practice to use JSON.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 REST API 交换的数据位于 HTTP 请求/响应的主体中。API 生产者可以将其编码为任何他们希望实施的格式，但通常的做法是使用 JSON。
- en: Thanks to the possibility of creating API documentation with a high level of
    detail in a standard specification format, REST is an ideal candidate for enterprise
    API integrations and for building public APIs with a large and diverse range of
    consumers.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可以在标准规范格式中创建具有高度详细信息的 API 文档，因此 REST 是企业 API 集成和构建面向大量且多样化的消费者的公共 API 的理想选择。
- en: A.5 Granular queries with GraphQL
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.5 使用 GraphQL 进行细粒度查询
- en: This section explains GraphQL and how it compares to REST. GraphQL is a query
    language based on graphs and nodes. As of the time of this writing, it is one
    of the most popular choices for the implementation of web APIs.[⁴](#pgfId-1087026)
    It was developed by Facebook in 2012 and publicly released in 2015.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了 GraphQL 以及它与 REST 的比较。GraphQL 是一种基于图和节点的查询语言。截至本文撰写时，它是实现 Web API 最受欢迎的选择之一。[⁴](#pgfId-1087026)
    它由 Facebook 于 2012 年开发并于 2015 年公开发布。
- en: GraphQL is designed to address some of the limitations of REST APIs, such as
    the difficulty of representing certain operations through HTTP endpoints. For
    example, let’s say you ordered a cup of coffee through the CoffeeMesh website,
    and later you change your mind and decide to cancel the order. Which HTTP method
    is most appropriate to represent this action? You can argue that cancelling an
    order is akin to deleting it, so you could use the DELETE method. But, is cancelling
    really the same as deleting? Are you going to delete the order from your records
    after cancellation? Probably not. You could argue that it should be a PUT or a
    PATCH request since you are changing the state of the order to `cancelled`. Or
    you could say it should be a POST request since the user is triggering an operation
    that involves more than simply updating a record. However you look at it, HTTP
    does present some limitations when it comes to modeling user actions, and GraphQL
    gets around this problem by not constraining itself to using elements of the HTTP
    protocol exclusively.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 被设计用来解决 REST API 的一些局限性，例如通过 HTTP 端点表示某些操作的困难。例如，假设您通过 CoffeeMesh 网站订购了一杯咖啡，后来您改变了主意并决定取消订单。哪种
    HTTP 方法最适合表示这个动作？您可以争论说取消订单类似于删除，因此可以使用 DELETE 方法。但是，取消真的等同于删除吗？您在取消后是否会从您的记录中删除订单？可能不会。您可以争论说它应该是一个
    PUT 或 PATCH 请求，因为您正在将订单的状态更改为“已取消”。或者您可以说它应该是一个 POST 请求，因为用户正在触发一个涉及更多不仅仅是更新记录的操作。无论如何看待这个问题，HTTP
    在建模用户动作时确实存在一些局限性，而 GraphQL 通过不将自己限制在仅使用 HTTP 协议的元素来解决这个问题。
- en: 'Another limitation of REST is the inability for clients to make granular requests
    of data, technically known as *overfetching*. For example, imagine that an API
    exposes `/products` and `/ingredients` resources. As you can see in figure A.7,
    with `/products` we can get a list of products, including the IDs of their ingredients.
    However, if we want to get the name of each ingredient, we must request the details
    of each ingredient to the `/ingredients` API. The result is the API client needs
    to send various requests to the API to obtain a simple representation of a product.
    The API client also receives more information than it needs: in each request against
    the `/ingredients` API, the client receives a full description of each ingredient,
    when it only needs the name. Overfetching is a challenge for small devices such
    as mobile phones, which may not be able to handle and store large amounts of data
    and may have more limited network access.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: REST的另一个限制是客户端无法对数据进行细粒度请求，这在技术上被称为*过度获取*。例如，想象一个API公开了`/products`和`/ingredients`资源。如图A.7所示，使用`/products`我们可以获取产品列表，包括其成分的ID。然而，如果我们想获取每个成分的名称，我们必须向`/ingredients`
    API请求每个成分的详细信息。结果是API客户端需要向API发送各种请求以获取产品的简单表示。API客户端还接收了比所需更多的信息：在针对`/ingredients`
    API的每个请求中，客户端接收了每个成分的完整描述，而它只需要名称。过度获取对于如手机等小型设备来说是一个挑战，这些设备可能无法处理和存储大量数据，并且可能具有更有限的网络访问。
- en: '![](../Images/A-7.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图A-7](../Images/A-7.png)'
- en: Figure A.7 A limitation of REST APIs is the inability of API clients to make
    granular requests of data, otherwise known as overfetching. In the figure, the
    `/products` endpoint returns a list of products with the IDs of their ingredients.
    To obtain the ingredients’ names, the client must request the details of each
    ingredient from the `/ingredients` endpoint. As a result, the API client ends
    up making too many requests to the server and receiving more data than it needs.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.7 REST API的一个限制是API客户端无法对数据进行细粒度请求，这被称为过度获取。在图中，`/products`端点返回包含其成分ID的产品列表。为了获取成分的名称，客户端必须从`/ingredients`端点请求每个成分的详细信息。结果，API客户端最终向服务器发送过多的请求，并接收比所需更多的数据。
- en: GraphQL avoids these problems by allowing clients to make granular queries on
    the server. With GraphQL, we can create relationships between different data models,
    allowing API clients to fetch data from related entities. For example, in figure
    A.8, an API client can request a list of products and the names of their ingredients
    in a single request. By allowing clients to retrieve the data they need from the
    server in a single request, GraphQL is an ideal candidate for APIs, which are
    consumed by clients with limited network access or limited storage capabilities,
    such as mobile devices. GraphQL is also a good choice for APIs with highly interconnected
    resources, in which users are likely to fetch data from related entities, such
    as products and ingredients in figure A.8.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL通过允许客户端在服务器上执行细粒度查询来避免这些问题。使用GraphQL，我们可以创建不同数据模型之间的关系，允许API客户端从相关实体中获取数据。例如，在图A.8中，API客户端可以请求产品列表及其成分名称的单个请求。通过允许客户端在单个请求中从服务器检索所需数据，GraphQL是API的理想选择，这些API由具有有限网络访问或有限存储能力的客户端消费，如移动设备。GraphQL也是高度互联资源API的良好选择，其中用户很可能从相关实体中获取数据，如图A.8中的产品和成分。
- en: '![](../Images/A-8.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图A-8](../Images/A-8.png)'
- en: Figure A.8 Using a GraphQL API, we can query data from related entities, such
    as products and ingredients. In this figure, an API client requests a list of
    products with the names of their ingredients.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.8 使用GraphQL API，我们可以查询相关实体中的数据，例如产品和成分。在此图中，API客户端请求带有其成分名称的产品列表。
- en: Despite its benefits, GraphQL also comes with constraints. A major limitation
    of GraphQL is that it doesn’t provide great support for custom scalar types. GraphQL
    ships with a basic set of built-in scalars, such as integer (`Int`) and string
    (`String`). GraphQL allows you to declare your own custom scalars, but you can’t
    document their shape or how they’re validated using the SDL. In the words of GraphQL’s
    official documentation, “It’s up to our implementation to define how that type
    should be serialized, deserialized, and validated” ([https://graphql.org/learn/schema/](https://graphql.org/learn/schema/)).
    Since one of the cornerstones of robust API integrations is great documentation,
    GraphQL is a challenging choice for public APIs that must be reliably consumed
    by external clients.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管GraphQL有其优点，但它也伴随着一些限制。GraphQL的一个主要限制是它对自定义标量类型的支持并不充分。GraphQL自带一组基本的内置标量，例如整数（`Int`）和字符串（`String`）。GraphQL允许你声明自己的自定义标量，但你无法使用SDL文档化它们的形状或验证方式。正如GraphQL官方文档所说，“定义该类型如何序列化、反序列化和验证取决于我们的实现”
    ([https://graphql.org/learn/schema/](https://graphql.org/learn/schema/))。由于稳健的API集成的一个基石是优秀的文档，因此GraphQL对于必须被外部客户端可靠消费的公共API来说是一个具有挑战性的选择。
- en: Another limitation of GraphQL is that all the queries are typically done with
    POST requests, which makes it more difficult to cache the responses. In my experience,
    most developers also find it more difficult to interact with a GraphQL API. In
    fact, Postman’s 2022 State of the API Report found that only 28% of the surveyed
    developers use GraphQL, and up to 14% of them hadn’t heard of it. While interacting
    with a REST API may be as simple as hitting a GET endpoint, with GraphQL you must
    know how to build query documents and how to send them to the server. Since developers
    are less familiar with GraphQL, choosing this technology may make your APIs less
    likely to be consumed.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL的另一个限制是所有查询通常都使用POST请求来完成，这使得缓存响应变得更加困难。根据我的经验，大多数开发者也发现与GraphQL API交互更加困难。实际上，Postman的2022年API状态报告发现，只有28%的调查开发者使用GraphQL，其中高达14%的人甚至没有听说过它。虽然与REST
    API交互可能只需简单地调用GET端点，但使用GraphQL你必须知道如何构建查询文档以及如何将它们发送到服务器。由于开发者对GraphQL不太熟悉，选择这项技术可能会使你的API不太可能被消费。
- en: '* * *'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ¹ Bruce Jay Nelson is credited with the introduction of the term *remote procedure
    call* in his doctoral dissertation (Technical Report CSL-81-9, Xero Palo Alto
    Research Center, Palo Alto CA, 1981). For a more formal description of the implementation
    requirements of RPC, see Andrew B. Birrell and Bruce Jay Nelson, “Implementing
    Remote Procedure Calls,” *ACM Transactions on Computer Systems*, vol. 2, no. 1,
    1984, pp. 39–59.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ 布鲁斯·杰·尼尔森在他的博士论文（技术报告CSL-81-9，Xero帕洛阿尔托研究中心，帕洛阿尔托CA，1981年）中引入了术语*远程过程调用*。关于RPC实现要求的更正式描述，请参阅Andrew
    B. Birrell和Bruce Jay Nelson的“Implementing Remote Procedure Calls”，*ACM Transactions
    on Computer Systems*，第2卷，第1期，1984年，第39-59页。
- en: ² You’re surely wondering what the “g” in gRPC stands for. According to the
    official documentation, it stands for a different word in every release. For example,
    in version 1.1 it stands for “good,” while in version 1.2 it stands for “green,”
    and so on ([https://grpc.github.io/grpc/core/md_doc_g_stands_for.html](https://grpc.github.io/grpc/core/md_doc_g_stands_for.html)).
    Some people believe that the “g” stands for Google, as this protocol was invented
    by Google (see “Is gRPC the Future of Client-Server Communication?” by Bleeding
    Edge Press, *Medium*, July 19, 2018, [https://medium.com/@EdgePress/is-grpc-the-future-of-client-server-communication-b112acf9f365](https://medium.com/@EdgePress/is-grpc-the-future-of-client-server-communication-b112acf9f365)).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ² 你肯定想知道gRPC中的“g”代表什么。根据官方文档，每个版本中“g”代表不同的单词。例如，在版本1.1中它代表“good”，而在版本1.2中它代表“green”，以此类推
    ([https://grpc.github.io/grpc/core/md_doc_g_stands_for.html](https://grpc.github.io/grpc/core/md_doc_g_stands_for.html))。有些人认为“g”代表Google，因为该协议是由Google发明的（参见Bleeding
    Edge Press的“Is gRPC the Future of Client-Server Communication?”，*Medium*，2018年7月19日，[https://medium.com/@EdgePress/is-grpc-the-future-of-client-server-communication-b112acf9f365](https://medium.com/@EdgePress/is-grpc-the-future-of-client-server-communication-b112acf9f365))。
- en: ³ According to Postman’s 2022 State of the API Report, 11% of the surveyed developers
    use gRPC ([https://www.postman.com/state-of-api/api-technologies/#api-technologies](https://www.postman.com/state-of-api/api-technologies/#api-technologies)).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ³ 根据Postman的2022年API状态报告，11%的调查开发者使用gRPC ([https://www.postman.com/state-of-api/api-technologies/#api-technologies](https://www.postman.com/state-of-api/api-technologies/#api-technologies))。
- en: ⁴ According to Postman’s 2022 State of the API Report, 28% of the surveyed developers
    use GraphQL ([https://www.postman.com/state-of-api/api-technologies/#api-technologies](https://www.postman.com/state-of-api/api-technologies/#api-technologies)).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Postman 的 2022 年 API 状态报告，28% 的受访开发者使用 GraphQL ([https://www.postman.com/state-of-api/api-technologies/#api-technologies](https://www.postman.com/state-of-api/api-technologies/#api-technologies)).
