- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: 'Angular: a modern web platform'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Angular：一个现代 Web 平台
- en: '**This chapter covers**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Angular as a platform for modern applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 作为现代应用程序的平台
- en: Key reasons for choosing Angular
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择 Angular 的关键原因
- en: Angular’s architecture and how components form the basis of it
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 的架构以及组件如何构成其基础
- en: How AngularJS differs from Angular
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AngularJS 与 Angular 的区别
- en: ES2015 and TypeScript and how Angular uses them
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ES2015 和 TypeScript 以及 Angular 如何使用它们
- en: Angular is a modern web application platform that promises to provide developers
    with a comprehensive set of tools and capabilities to build large, robust applications.
    The core value proposition of Angular is to make it possible to build applications
    that work for nearly any platform—whether mobile, web, or desktop. The Angular
    team has focused on building much more than a robust application framework; they’ve
    also built an entire ecosystem.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 是一个现代 Web 应用程序平台，承诺为开发者提供一套全面的工具和能力，以构建大型、健壮的应用程序。Angular 的核心价值主张是使构建适用于几乎所有平台的应用程序成为可能——无论是移动、Web
    还是桌面。Angular 团队不仅专注于构建一个健壮的应用程序框架，还构建了一个完整的生态系统。
- en: All that’s a bit of a mouthful, which is partly what makes Angular such an exciting
    technology to work with. Let’s start by taking a closer look at why you would
    choose Angular for your next project.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些内容有点多，这也是 Angular 成为如此令人兴奋的技术之一的原因。让我们先仔细看看为什么你会选择 Angular 作为下一个项目的开发工具。
- en: 1.1 Why choose Angular?
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 为什么选择 Angular？
- en: Building web applications that can meet the needs of users is not a trivial
    task. The quality and complexity of applications is ever increasing, and so are
    users’ expectations for quality and capabilities. Angular exists to help developers
    deliver applications to meet these demands.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 构建能够满足用户需求的应用程序并非易事。应用程序的质量和复杂性不断增长，用户对质量和功能的需求也在增加。Angular 的存在是为了帮助开发者交付满足这些需求的应用程序。
- en: 'If you haven’t settled on Angular as a tool of choice yet, let’s quickly cover
    some of the top reasons that you should seriously consider Angular. Some items
    are covered more in section 1.3, but here are the top highlights in my experience:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有确定 Angular 作为首选工具，让我们快速概述一些你应该认真考虑 Angular 的主要原因。一些内容在 1.3 节中有更详细的介绍，但以下是我经验中的主要亮点：
- en: '*Inspired by web standards, enhanced by modern capabilities —*Anyone building
    web applications today knows there are many different ways and ideas about how
    to design applications. Angular tries to design its framework and the development
    process around common standards (like leveraging the latest JavaScript language
    features), using modern capabilities (such as embracing TypeScript for type enforcement).'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*受网络标准启发，由现代功能增强* — 任何今天构建 Web 应用程序的人都知道，有无数不同的方式和想法来设计应用程序。Angular 尝试围绕常见标准（如利用最新的
    JavaScript 语言功能）设计和开发其框架及开发过程，使用现代功能（如采用 TypeScript 进行类型强制）。'
- en: '*Development tooling included, customizations available —*Angular provides
    a common developer experience through its CLI tooling (for generating, building,
    testing, and deploying apps), while making those same tools available to be easily
    integrated into custom solutions (such as a custom build toolchain) and third-party
    tools (like different editors or IDEs).'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*包含开发工具，提供定制选项* — Angular 通过其 CLI 工具（用于生成、构建、测试和部署应用程序）提供了一个共同的开发者体验，同时使这些相同的工具易于集成到定制解决方案（如定制构建工具链）和第三方工具（如不同的编辑器或
    IDE）中。'
- en: '*Powerful ecosystem with a large community —*There is an ever-growing number
    of third-party libraries, UI libraries, blog posts, and events. Angular’s large
    and active community provides a great foundation on which to learn and should
    instill confidence that it will remain a valuable technology.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*强大的生态系统和庞大的社区* — 存在着越来越多的第三方库、UI 库、博客文章和活动。Angular 的庞大和活跃社区提供了一个很好的学习基础，并应增强人们对它将继续保持有价值技术的信心。'
- en: '*Sponsored by Google, open source community driven —*Google has a team of engineers,
    managers, and evangelists solely dedicated to bringing Angular to the rest of
    Google and the entire web community. With thousands of “internal customers” who
    rely on Angular inside Google, the Angular team uses those experiences to inform
    future development and receives large volumes of external contributions that together
    shape Angular’s future (you can join in too!).'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*由Google赞助，开源社区驱动*—Google有一支工程师、经理和传教士团队，他们专门致力于将Angular带给Google的其余部分和整个网络社区。在Google内部，有成千上万的“内部客户”依赖Angular，Angular团队利用这些经验来指导未来的开发，并收到了大量的外部贡献，这些贡献共同塑造了Angular的未来（你也可以加入其中！）。'
- en: Angular is much more than just a JavaScript library that powers some of the
    top websites in the world. I’m passionate about open source communities, and I’m
    an advocate for people to get engaged in a project as part of their regular routine.
    Projects in the Angular community are where I put a lot of my energy and contributions,
    and I invite you to join me. Although I do engage with the Angular project itself,
    I primarily contribute to projects in the Angular ecosystem, such as Clarity,
    a UI component library and design language.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Angular不仅仅是一个为世界上一些顶级网站提供动力的JavaScript库。我对开源社区充满热情，并倡导人们将其作为日常例行公事的一部分参与项目。Angular社区中的项目是我投入大量精力和贡献的地方，我也邀请你加入我。虽然我确实参与了Angular项目本身，但我主要贡献于Angular生态系统中的项目，例如Clarity，一个UI组件库和设计语言。
- en: You may be a developer trying to figure out whether Angular will meet your needs,
    or you may be a manager trying to understand the role of the technology, or trying
    to figure out how to improve your current applications. Regardless of where you’re
    starting from, the Angular ecosystem has a lot to offer.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能是一位试图弄清楚Angular是否满足你需求的开发者，或者你可能是一位试图理解这项技术角色、或试图弄清楚如何改进你当前应用程序的经理。无论你从哪里开始，Angular生态系统都有很多可以提供的。
- en: 1.2 What you’ll learn
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 你将学到什么
- en: This book is designed to be a comprehensive walk through Angular, but it’s also
    meant to get you informed about various aspects of the ecosystem. The approach
    is always experiential, where you’ll learn about a topic and build it yourself
    to see the concepts come to life. At the end of this book you should be able to
    make high-quality Angular applications and have the foundational knowledge and
    experience on which to build a career and applications.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本书旨在全面地介绍Angular，但它也旨在让你了解生态系统的各个方面。方法始终是经验性的，你将学习一个主题，并通过自己构建它来观察概念如何变得生动。本书结束时，你应该能够制作高质量的Angular应用程序，并拥有构建职业和应用程序的基础知识和经验。
- en: 'The key takeaways in this book include the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的关键要点包括以下内容：
- en: '*How Angular works* —We’ll look at some of the key internal concepts that make
    it such a compelling platform for building your applications. You’ll learn the
    concepts and build examples to illustrate them as part of a functional application.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Angular的工作原理*—我们将探讨一些关键内部概念，这些概念使得它成为构建应用程序的一个非常有吸引力的平台。你将学习这些概念，并通过构建示例来展示它们作为功能应用程序的一部分。'
- en: '*How to build applications —*In most chapters, we’ll walk step-by-step through
    a number of real-life examples. The code examples are comprehensive and focus
    on a certain set of goals for each chapter.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如何构建应用程序*—在大多数章节中，我们将一步步地通过一些真实世界的例子进行讲解。代码示例全面，并针对每一章设定了特定的目标。'
- en: '*Learn about the ecosystem —*Each example uses some third-party libraries and
    capabilities. This helps you see more of a realistic development experience and
    gain a foundation for building your own applications.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*了解生态系统*—每个例子都使用了一些第三方库和功能。这有助于你看到更真实的发展体验，并为构建你自己的应用程序打下基础。'
- en: '*Get practical insights from my experiences —*In many of the examples and notes
    about them, I share practical advice from my experience, including suggestions
    on things to avoid (even if it''s perfectly legitimate code) and how to choose
    between different approaches when they’re provided.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从我的经验中获得实用见解*—在许多例子及其说明中，我分享了我从经验中得到的实用建议，包括避免某些事情的建议（即使这些代码是合法的）以及当有多种方法可供选择时如何进行选择。'
- en: You should be equipped to design and build web applications with Angular by
    the end of the book. If you’re not as interested in the technical aspects (perhaps
    as a manager), you’ll still glean a lot of the same lessons to get a solid frame
    of reference for how Angular works and what it provides for your project.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 到本书结束时，你应该能够使用Angular设计和构建网络应用。如果你对技术方面不太感兴趣（也许是一个管理者），你仍然可以从中获得很多相同的教训，以获得Angular的工作方式和它为你的项目提供的内容的稳固参考框架。
- en: 'There are a few things I won’t be able to cover in this book, but just because
    these items aren’t specifically discussed, it doesn’t mean you can’t learn many
    things related to them. The following are *not* core topics covered in this book:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，有一些内容我无法涵盖，但这并不意味着你不能从它们相关的许多事物中学习。以下*不是*本书涵盖的核心主题：
- en: '*How to write libraries* —This book focuses on how to build applications with
    Angular, and in many ways building a library has different guidelines and recommendations.
    That would be another book. But building a library is also difficult if you don’t
    know how to build an application first.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如何编写库* — 这本书侧重于如何使用Angular构建应用，从许多方面来看，构建库有不同的指南和建议。那将是另一本书的内容。但如果你不知道如何构建应用，构建库也会很困难。'
- en: '*Every available API and features* —Many APIs and features aren’t covered in
    this book, mostly because they’re rarely used. I believe this book will empower
    you to build your skills to the level that you can quickly learn these additional
    features as your project needs require.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*每个可用的API和功能* — 本书没有涵盖许多API和功能，主要是因为它们很少被使用。我相信这本书将使你能够提升自己的技能，以便在项目需要时快速学习这些附加功能。'
- en: '*How to design your app and* *UX principles* —This is such a large topic that
    I can’t cover it fully. I’ve tried to show several different ideas and patterns
    in the chapter examples to give you some ideas, but it’s often opinion-based.
    I hope you’ll take time to compare the design of each and know that there can
    be limitations as well due to these being examples and not actual projects.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如何设计你的应用和* *用户体验原则* — 这是一个非常大的主题，我无法全面涵盖。我已经在章节示例中尝试展示了几种不同的想法和模式，以给你一些启发，但这些都往往是基于个人观点的。我希望你能花时间比较每种设计，并知道由于这些是示例而非实际项目，因此可能会有局限性。'
- en: Angular is an evolving project, with new features and sometimes deprecation
    of existing ones. I’ve taken great care to ensure that the concepts taught are
    the core ideas that are unlikely to change (though they may be enhanced). If there
    are any changes that break some of the example code or concepts, please check
    the GitHub project for each chapter or the book’s forums, which should have a
    list of known changes and errata.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Angular是一个不断发展的项目，具有新的功能和有时是现有功能的弃用。我已经非常小心地确保所教授的概念是核心思想，这些思想不太可能改变（尽管它们可能会得到增强）。如果有任何更改破坏了一些示例代码或概念，请检查每个章节或本书的GitHub项目，或者论坛，其中应该有一个已知更改和错误列表。
- en: To better understand the impact of Angular in today’s web, let’s go back a few
    years to look at the history that brought us here.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解Angular在当今网络中的影响，让我们回顾几年前的历史，看看是什么带我们来到这里。
- en: 1.3 The journey from AngularJS to Angular
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 从AngularJS到Angular的旅程
- en: Web applications came of age around 2009–2010, when the Web 2.0 fad finally
    gave way to better application approaches and frameworks. The term *web application*
    also became refined, due perhaps in large part to the standardization of HTML5
    and EcmaScript 5 (the basis of JavaScript), and focused primarily on the ability
    to build robust applications that run almost entirely in the browser.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用在2009-2010年左右成熟，当时Web 2.0的潮流最终让位于更好的应用方法和框架。术语*网络应用*也因此变得更加精确，这或许在很大程度上得益于HTML5和EcmaScript
    5（JavaScript的基础）的标准化，它主要关注构建几乎完全在浏览器中运行的稳健应用的能力。
- en: In 2009, Miško Hevery announced AngularJS, which became one of the most popular
    frameworks (if not *the* most) for building web applications. The AngularJS project
    was brought into Google, and version 1.0 was officially launched in October 2010\.
    There were many other viable frameworks, but AngularJS struck a chord with a wide
    audience of developers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 2009年，Miško Hevery宣布了AngularJS，这成为构建网络应用最受欢迎的框架（如果不是*最*受欢迎的），AngularJS项目被引入谷歌，并于2010年10月正式发布了1.0版本。当时还有许多其他可行的框架，但AngularJS与广泛的开发者群体产生了共鸣。
- en: Angular version 2, officially announced in September 2014, was developed over
    the course of two years (plus some time prior to its announcement). It was released
    as Angular version 2 in September 2016, with Angular 4 being released in March
    2017\. The Angular team will continue to provide major releases on a six-month
    schedule, with a focus on easy upgrades. Depending on when you read this, Angular
    6, or even 10, could be the most current release.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2版本于2014年9月正式宣布，历时两年（加上宣布之前的一些时间）开发。它于2016年9月以Angular 2版本发布，Angular
    4于2017年3月发布。Angular团队将继续按照每六个月一次的节奏提供主要版本，重点关注易于升级。根据你阅读的时间，Angular 6或甚至10可能是最新的版本。
- en: But you aren’t looking at this book to learn about the past—you’re interested
    in building modern web applications. Perhaps you’ve built Angular 1 applications,
    or even started with some of the Angular 2 guides. The focus of this book is on
    building modern web applications, and Angular provides the platform to elegantly
    accomplish that.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 但你阅读这本书不是为了了解过去——你对构建现代Web应用程序感兴趣。也许你已经构建了Angular 1应用程序，或者甚至从Angular 2的一些指南开始。本书的重点是构建现代Web应用程序，Angular提供了优雅地完成这一目标的平台。
- en: Throughout the book, I’ll mention AngularJS occasionally to draw connections
    for readers who have experience with it, but when I use *Angular* without a number,
    I’m always referring to Angular version 2 or greater. Check out [https://angular.io](https://angular.io)
    ([figure 1.1](#figure1.1)) for more info.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我会偶尔提到AngularJS，以帮助有经验的读者建立联系，但当我使用没有数字的*Angular*时，我始终指的是Angular 2或更高版本。查看[https://angular.io](https://angular.io)
    ([图1.1](#figure1.1))获取更多信息。
- en: '![c01-1.png](image_fi/293313c01/c01-1.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![c01-1.png](image_fi/293313c01/c01-1.png)'
- en: '[**Figure 1.1**](#figureanchor1.1) The Angular website is a great resource
    for documentation, events, and everything about Angular.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图1.1**](#figureanchor1.1) Angular网站是关于文档、活动和Angular的一切的绝佳资源。'
- en: '1.4 Angular: a platform, not a framework'
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4 Angular：一个平台，而不是一个框架
- en: There are a few important distinctions between a framework and a platform. A
    *framework* is usually just the code library used to build an application, whereas
    a *platform* is more holistic and includes tooling and support beyond a framework.
    AngularJS was focused solely on building web applications in the browser and was
    clearly a framework. It had a large ecosystem of third-party modules that could
    be easily used to add features to your application, but at the heart of it all,
    it simply built web applications in the browser.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 框架和平台之间有一些重要的区别。通常，*框架*只是用于构建应用程序的代码库，而*平台*则更加全面，包括框架之外的工具和支持。AngularJS专注于在浏览器中构建Web应用程序，显然是一个框架。它有一个庞大的第三方模块生态系统，可以轻松地用于向应用程序添加功能，但核心只是构建浏览器中的Web应用程序。
- en: 'Angular comes with a leaner core library and makes additional features available
    as separate packages that can be used as needed. It also has many tools that push
    it beyond a simple framework, including the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Angular附带了一个更精简的核心库，并且将附加功能作为单独的包提供，可以根据需要使用。它还拥有许多工具，这些工具使其超越了简单的框架，包括以下内容：
- en: Dedicated CLI for application development, testing, and deployment
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专门用于应用程序开发、测试和部署的CLI
- en: Offline rendering capabilities on many back-end server platforms
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在许多后端服务器平台上提供离线渲染功能
- en: Desktop-, mobile-, and browser-based application execution environments
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于桌面、移动和浏览器的应用程序执行环境
- en: Comprehensive UI component libraries, such as Material Design
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完备的UI组件库，例如Material Design
- en: Some of these things existed in some shape with AngularJS, but most were community
    solutions and were bolted into AngularJS after the fact. In contrast, Angular
    was developed with these platform features in mind.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些功能在AngularJS中以某种形式存在，但大多数是社区解决方案，并在AngularJS之后添加。相比之下，Angular是考虑到这些平台功能而开发的。
- en: These parts are still in refinement and will continue to evolve into more robust
    options.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些部分仍在完善中，并将继续发展成为更稳健的选项。
- en: 1.4.1 Angular CLI
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.1 Angular CLI
- en: Modern development typically requires setting up many tools in order to start
    a project, which has given rise to *more* tools to help manage *those* tools.
    A typical project needs to manage handling a build process (asset optimization),
    testing (unit and end-to-end testing), and local development support (local server).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现代开发通常需要设置许多工具才能开始一个项目，这导致了更多工具的诞生，以帮助管理这些工具。一个典型的项目需要管理构建过程（资产优化）、测试（单元测试和端到端测试）以及本地开发支持（本地服务器）。
- en: The Angular CLI (often just referred to as the CLI) is the official toolchain
    for building Angular applications that provide these features and more. This book
    uses the CLI for all examples, and you’re encouraged to use it for your projects
    as well. You could roll your own build tooling, but that’s suggested only if the
    CLI doesn’t meet your needs.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI（通常简称为 CLI）是构建提供这些功能以及更多功能的 Angular 应用的官方工具链。本书使用 CLI 进行所有示例，并鼓励你在自己的项目中使用它。你可以自己构建构建工具，但这仅在
    CLI 无法满足你的需求时才建议。
- en: 'You can install the CLI using npm. It does require that you have a recent version
    of NodeJS installed to run properly:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 npm 安装 CLI。它确实需要你安装一个较新的 NodeJS 版本才能正常运行：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The CLI has a number of features that aid in the development of Angular apps.
    Here are the primary features:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: CLI 有许多有助于 Angular 应用程序开发的特性。以下是主要特性：
- en: '*Generates new project scaffolding —*Instead of having to create a new project
    from an existing project or creating all the files yourself, the CLI will generate
    a full project with a basic app already started for you.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*生成新的项目骨架—*你不必从现有项目创建新项目或自己创建所有文件，CLI 会为你生成一个包含基本应用程序的完整项目。'
- en: '*Generates new application pieces —*Need a new component? Easy; it can generate
    the files for you. It can generate components, services, routes, and pipes, and
    it also will automatically ensure they are fully wired up in the build process.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*生成新的应用程序组件—*需要一个新的组件？很简单；它可以为你生成文件。它可以生成组件、服务、路由和管道，并且它还会在构建过程中自动确保它们完全连接。'
- en: '*Manages the entire build toolchain —*Because files need to be processed before
    being served to the client (such as TypeScript compilation), the CLI will process
    your source files and build them into an optimized version for development or
    production.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*管理整个构建工具链—*因为文件在提供给客户端（如 TypeScript 编译）之前需要被处理，所以 CLI 会处理你的源文件并将它们构建成用于开发或生产的优化版本。'
- en: '*Serves a localhost development server —*The CLI handles the build flow and
    then starts a server listening on localhost so you can see the results, with a
    live reload feature.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提供本地主机开发服务器—*CLI 处理构建流程，然后启动一个监听 localhost 的服务器，以便你可以查看结果，并具有实时重新加载功能。'
- en: '*Incorporates code linting and formatting code —*Helps enforce quality code
    by using the CLI to lint your code for style and semantic errors, and it can also
    help format your code automatically to the style rules.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*集成代码检查和格式化代码—*通过使用 CLI 对你的代码进行风格和语义错误检查，CLI 可以帮助强制执行代码质量，并且它还可以自动将你的代码格式化为特定的风格规则。'
- en: '*Supports running unit and* *e2e tests —*Tests are vital, so the CLI sets up
    Karma for running your unit tests and works with Protractor to execute your e2e
    tests. It will automatically pick up and execute new tests as they’re generated.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*支持运行单元测试和端到端测试—*测试至关重要，因此 CLI 为运行单元测试设置了 Karma，并与 Protractor 合作执行端到端测试。它将自动捕获并执行新生成的测试。'
- en: You can add other features and capabilities to the CLI. To see the full list
    of features, you can run `ng help` to output the current help documentation. You
    can also read more about the CLI at [https://cli.angular.io](https://cli.angular.io).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为 CLI 添加其他功能和能力。要查看完整的功能列表，你可以运行 `ng help` 来输出当前的帮助文档。你还可以在 [https://cli.angular.io](https://cli.angular.io)
    上了解更多关于 CLI 的信息。
- en: 1.4.2 Server rendering and the compiler
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.2 服务器渲染和编译器
- en: Compiling output in Angular is decoupled from the browser in a way that allows
    Angular applications to be rendered in different environments, such as a server
    or desktop app. There are many great side effects of this design pattern, because
    Angular is much more versatile by being able to render on the client and server,
    and it opens many different opportunities.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 中，编译输出与浏览器解耦，这使得 Angular 应用可以在不同的环境中渲染，例如服务器或桌面应用程序。这种设计模式有许多很好的副作用，因为
    Angular 能够在客户端和服务器上渲染，这使得它更加灵活，并开辟了许多不同的机会。
- en: There are two things in play here—first, the decoupled compiler of Angular,
    and then optional support for universal rendering. It takes a decoupled compiler
    to enable the universal rendering, because you can implement different rendering
    patterns depending on the environment.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个因素在起作用——首先，Angular 的解耦编译器，然后是可选的通用渲染支持。要启用通用渲染，需要一个解耦的编译器，因为你可以根据环境实现不同的渲染模式。
- en: The compiler in Angular is a very important piece of the puzzle. It’s responsible
    for resolving data bindings, registering event handlers, and rendering out the
    resulting HTML for components.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Angular中的编译器是整个解决方案中非常重要的一部分。它负责解析数据绑定、注册事件处理程序，并为组件渲染出结果HTML。
- en: The term *server rendering* is about the notion that it shouldn’t matter where
    you run the JavaScript engine that executes Angular code. It should be possible
    to run Angular universally, such as with browser JavaScript engines, NodeJS, or
    even less common engines like Java’s Nashorn engine. This greatly increases the
    ways in which Angular can be used.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: “服务器端渲染”这个术语涉及到这样一个观点：运行执行Angular代码的JavaScript引擎的位置不应该很重要。应该能够以浏览器JavaScript引擎、NodeJS或甚至更不常见的引擎（如Java的Nashorn引擎）的方式，在通用环境中运行Angular。这极大地增加了Angular的使用方式。
- en: 'Why does this matter? Let’s explore a few primary use cases:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这为什么很重要？让我们探索一些主要的使用案例：
- en: '*Server rendering for faster loading —*Mobile devices are the primary way to
    access the internet these days, and mobile connections are frequently slow and
    unreliable. A server-side rendering option allows you to resolve data bindings
    and render components on the server so the initial payload sent to the user is
    pre-initialized. It can also optimize and send the necessary bytes for a quick
    initial load time and lazy load the other assets as needed.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*服务器端渲染以实现更快的加载速度*——如今，移动设备是访问互联网的主要方式，而移动连接通常速度慢且不可靠。服务器端渲染选项允许您在服务器上解析数据绑定和渲染组件，这样发送给用户的初始负载就可以预先初始化。它还可以优化并发送必要的字节以实现快速初始加载时间，并在需要时懒加载其他资源。'
- en: '*Performance in the browser —*One of the major pain points of JavaScript is
    that it’s single threaded, which means that JavaScript can only handle one instruction
    at a time. In modern browsers, a newer technology known as web workers allows
    Angular to push some of the execution of the compiler into another process. This
    means that a lot more processing can occur, and it allows things like animations
    and user interactions to be smoother.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*浏览器中的性能*——JavaScript的一个主要痛点是它是单线程的，这意味着JavaScript一次只能处理一条指令。在现代浏览器中，一种称为Web
    Workers的新技术允许Angular将编译器的一些执行推送到另一个进程。这意味着可以发生更多的处理，并且它使得动画和用户交互更加平滑。'
- en: '*SEO —*There’s a major concern about how heavy JavaScript applications are
    crawled by search engines. Universal rendering means we can detect crawlers and
    render the site for them so that content is ready without having to worry if the
    crawler executes JavaScript (some do, some don’t). This will certainly enhance
    SEO efforts for Angular applications.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*搜索引擎优化（SEO）*——人们非常关注搜索引擎如何爬取重量级的JavaScript应用程序。通用渲染意味着我们可以检测爬虫并为它们渲染网站，这样内容就可以准备好了，无需担心爬虫是否执行JavaScript（有些会，有些不会）。这无疑将增强Angular应用程序的SEO努力。'
- en: '*Multiple platforms —*Many developers want to use other platforms for their
    back ends, such as .NET or PHP. Angular can be compiled in the platform of choice,
    assuming there’s a supported renderer. Angular will provide support for NodeJS,
    but the community is actively building and maintaining rendering support for other
    platforms such as Java and Go.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*多平台支持*——许多开发者希望使用其他平台作为他们的后端，例如.NET或PHP。如果有一个支持的渲染器，Angular可以在所选平台上编译。Angular将提供对NodeJS的支持，但社区正在积极构建和维护对其他平台（如Java和Go）的渲染支持。'
- en: All of these have been issues for years in building web applications, and Angular
    provides a comprehensive solution. The great thing is you don’t have to do a lot
    of work to enable these features in your application.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些在构建Web应用程序中已经存在了多年，Angular提供了一个全面的解决方案。好处是您不需要做很多工作就能在您的应用程序中启用这些功能。
- en: This is an area of evolution at the time of writing, and setting it up correctly
    is an advanced topic that I can’t cover in depth. But the Angular documentation
    and CLI are being constantly improved to show you how to incorporate these types
    of benefits easily.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在撰写本文时的一个发展领域，正确设置它是一个高级话题，我无法深入探讨。但Angular文档和CLI正在不断改进，以向您展示如何轻松地整合这些类型的优势。
- en: 1.4.3 Mobile and desktop capabilities
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.3 移动和桌面功能
- en: The rendering capabilities enable Angular to work with native mobile and desktop
    applications. Tools like Cordova have been around for a while; they let you create
    *hybrid* applications—web applications wrapped up inside some type of native shell.
    But Angular’s rendering design makes it possible to support rendering out to different
    native platforms entirely.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染能力使Angular能够与原生移动和桌面应用程序协同工作。像Cordova这样的工具已经存在了一段时间；它们允许你创建*混合*应用程序——Web应用程序被包裹在某种类型的原生壳中。但Angular的渲染设计使得支持渲染到不同的原生平台成为可能。
- en: The major value is that you can share a lot of code between your Angular applications,
    even if some are designed to build mobile apps and others are web applications.
    This is particularly valuable in large teams.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的价值在于你可以在你的Angular应用程序之间共享大量代码，即使有些是为构建移动应用程序而设计的，而有些则是Web应用程序。这在大型团队中尤其有价值。
- en: 'The mobile and desktop capabilities of Angular are extensions of the design
    of the compiler. The following tools are all outside of Angular’s core but use
    the design of Angular to power some powerful design patterns:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的移动和桌面功能是编译器设计的扩展。以下工具都在Angular的核心之外，但使用Angular的设计来驱动一些强大的设计模式：
- en: '*Ionic (mobile) —*This fantastic and popular hybrid app framework ([figure
    1.2](#figure1.2)) for Angular JS has been updated to work with Angular. Millions
    of mobile apps have been created with Ionic, and it’s primarily focused on building
    hybrid apps. The UI components are all created to run in the browser, but look
    and feel like native UI components.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ionic（移动）—*这个出色且流行的混合应用程序框架（[图1.2](#figure1.2)）已更新以与Angular兼容。数百万个移动应用程序都是使用Ionic创建的，它主要专注于构建混合应用程序。UI组件都是为在浏览器中运行而设计的，但看起来和感觉像原生UI组件。'
- en: '*NativeScript (mobile) —*This is another popular mobile framework that creates
    native mobile apps. NativeScript implements the native UI components but allows
    you to write Angular components to describe your application.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*原生脚本（移动）—*这是另一个流行的移动框架，可以创建原生移动应用程序。原生脚本实现了原生UI组件，但允许你编写Angular组件来描述你的应用程序。'
- en: '*React Native (mobile, desktop) —*By the name, you’d be correct to assume that
    React Native is really part of the React framework ecosystem. But with a custom
    render, it’s possible to use the React Native tool to generate native mobile apps.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*React Native（移动、桌面）—*从名字上看，你会正确地假设React Native实际上是React框架生态系统的一部分。但通过自定义渲染，可以使用React
    Native工具生成原生移动应用程序。'
- en: '![c01-2.png](image_fi/293313c01/c01-2.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![c01-2.png](image_fi/293313c01/c01-2.png)'
- en: '[**Figure 1.2**](#figureanchor1.2) Ionic is a popular and powerful mobile framework
    for Angular.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图1.2**](#figureanchor1.2)  Ionic是一个流行的强大移动框架，适用于Angular。'
- en: '*Windows Universal (desktop) —*Windows has support for building native Windows
    applications using JavaScript. It’s possible to use Angular as your application
    layer but still have to build out a native Windows application.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Windows通用（桌面）—*Windows支持使用JavaScript构建原生Windows应用程序。你可以使用Angular作为应用程序层，但仍需构建原生Windows应用程序。'
- en: '*Electron (desktop) —*Based on NodeJS, Electron is a very popular cross-platform
    application framework. It implements a set of APIs to hook into the native OS,
    and you can leverage Angular to power the internal logic of your app.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*电子（桌面）—*基于NodeJS的Electron是一个非常流行的跨平台应用程序框架。它实现了一套API来钩入原生操作系统，并允许你利用Angular来驱动应用程序的内部逻辑。'
- en: '*Progressive Web Apps (mobile, desktop) —*The capabilities of Progressive Web
    Apps (PWAs) aren’t limited to Angular. They’re fundamentally about blurring the
    line between the web and native. As of this writing, they’re in experimental support.
    This is an exciting potential avenue for building applications of tomorrow.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*渐进式Web应用程序（移动、桌面）—*渐进式Web应用程序（PWA）的功能并不仅限于Angular。它们本质上是关于模糊Web和原生之间的界限。截至本文撰写时，它们处于实验性支持状态。这是构建未来应用程序的一个令人兴奋的潜在途径。'
- en: These different options support the power of the decoupled compiler in Angular.
    It also means that there will likely be many, many more examples and use cases
    that allow you to build Angular applications that can run nearly anywhere.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不同的选项支持了Angular中解耦编译器的强大功能。这也意味着可能会出现许多、许多更多的示例和用例，允许你构建几乎在任何地方都能运行的Angular应用程序。
- en: 1.4.4 UI libraries
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.4 UI库
- en: There’s an ever-growing catalog of UI libraries built for Angular. They bring
    different sets of UI components to developers for easy consumption. Rather than
    having to build your own charts or tabs components, you can use one of the many
    prebuilt options.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为 Angular 构建的 UI 库目录正在不断增长。它们为开发者提供了易于消费的 UI 组件集合。你无需自己构建图表或标签组件，可以使用众多预构建选项之一。
- en: Depending on your team’s size and skill sets, implementing your own UI components
    may be challenging. Making truly reusable and hardened UI components is difficult.
    These components are rarely what make your application really unique, so it’s
    hard to spend the time (and money) to build them.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你团队的大小和技能组合，实现自己的 UI 组件可能会很具挑战性。制作真正可重用和加固的 UI 组件是困难的。这些组件很少是使你的应用程序真正独特的东西，因此很难花费时间和金钱来构建它们。
- en: 'These libraries are plentiful. There are so many that I can’t cover all the
    options. You’ll notice there’s a lot of overlap in the functionalities that each
    of them provides, so comparing them can be difficult. We’ll take a look at some
    of the most popular options, but I recommend doing additional research before
    selecting an option:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这些库非常丰富。数量众多，以至于我无法涵盖所有选项。你会注意到它们提供的功能有很多重叠，因此比较它们可能会很困难。我们将探讨一些最受欢迎的选项，但我建议在选择选项之前进行额外的调查：
- en: '*Angular Material ([https://github.com/angular/material2](https://github.com/angular/material2)) —*Material
    Design is the official design specification created by Google. It has strong roots
    in concepts of real-world objects, hence Material in the name. Angular Material
    is the official UI component library provided by the Angular team and it implements
    a number of UI components according to the design specification. It has an open
    source license.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Angular Material ([https://github.com/angular/material2](https://github.com/angular/material2))
    —* Material Design 是由 Google 创建的官方设计规范。它在现实世界对象的概念中有着深厚的根基，因此得名 Material。Angular
    Material 是 Angular 团队提供的官方 UI 组件库，并根据设计规范实现了多个 UI 组件。它拥有开源许可。'
- en: '*Covalent ([https://teradata.github.io/covalent](https://teradata.github.io/covalent)) —*This
    library extends the Angular Material project with a number of additional components
    and capabilities, but still retains the principles of Material Design. It’s a
    result of work done at Teradata. It has an open source license.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Covalent ([https://teradata.github.io/covalent](https://teradata.github.io/covalent))
    —* 这个库通过添加许多额外的组件和能力扩展了 Angular Material 项目，但仍保留了 Material Design 的原则。它是 Teradata
    的工作成果。它拥有开源许可。'
- en: '*Clarity ([https://vmware.github.io/clarity](https://vmware.github.io/clarity)) —*This
    library, shown in [figure 1.3](#figure1.3), comes from VMware. It’s designed as
    both a library and a design specification for web applications. It contains many
    components that are specific to Angular but also has some icons and a general
    CSS framework. It has an open source license.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Clarity ([https://vmware.github.io/clarity](https://vmware.github.io/clarity))
    —* 如 [图 1.3](#figure1.3) 所示，这个库来自 VMware。它被设计为一个库和 Web 应用程序的设计规范。它包含许多特定于 Angular
    的组件，还有一些图标和一个通用的 CSS 框架。它拥有开源许可。'
- en: '*ng-bootstrap ([https://ng-bootstrap.github.io](https://ng-bootstrap.github.io)) —*Based
    on the very popular Bootstrap CSS framework, ng-bootstrap implements the components
    based on the design of Bootstrap. It’s built by the same team that created the
    very popular AngularJS UI Bootstrap project. It has an open source license.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ng-bootstrap ([https://ng-bootstrap.github.io](https://ng-bootstrap.github.io))
    —* 基于 Bootstrap CSS 框架，ng-bootstrap 根据 Bootstrap 的设计实现了组件。它是由创建 AngularJS UI Bootstrap
    项目的同一团队构建的。它拥有开源许可。'
- en: '*Kendo UI ([https://www.telerik.com/kendo-angular-ui/](https://www.telerik.com/kendo-angular-ui/)) —*From
    the same company as NativeScript, Kendo UI is a UI library that’s been integrated
    into many different frameworks, but the company is building a set of native Angular
    UI components that are custom for Angular. It has a commercial license.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Kendo UI ([https://www.telerik.com/kendo-angular-ui/](https://www.telerik.com/kendo-angular-ui/))
    —* 来自 NativeScript 的同一公司，Kendo UI 是一个集成到许多不同框架中的 UI 库。该公司正在构建一套专为 Angular 定制的原生
    UI 组件。它拥有商业许可。'
- en: '*PrimeNG ([www.primefaces.org/primeng/](http://www.primefaces.org/primeng/)) —*A
    rich collection of UI components, PrimeNG is developed by PrimeTek and has more
    than 60 components. It comes with many themes and is designed for mobile and desktops.
    It has an open source license.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PrimeNG ([www.primefaces.org/primeng/](http://www.primefaces.org/primeng/))
    —* PrimeNG 是由 PrimeTek 开发的 UI 组件丰富集合，拥有超过 60 个组件。它提供了许多主题，并专为移动设备和桌面设计。它拥有开源许可。'
- en: '*Wijmo ([http://wijmo.com/angular2/](http://wijmo.com/angular2/)) —*Containing
    some very complex data grid components, Wijmo implements this set of Angular components
    without support from other libraries like jQuery. The UI library has a commercial
    license.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Wijmo ([http://wijmo.com/angular2/](http://wijmo.com/angular2/)) — 包含一些非常复杂的数据网格组件，Wijmo实现了这一系列Angular组件，而不需要像jQuery这样的其他库的支持。该UI库具有商业许可证。'
- en: '![c01-3.png](image_fi/293313c01/c01-3.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![c01-3.png](image_fi/293313c01/c01-3.png)'
- en: '[**Figure 1.3**](#figureanchor1.3) Clarity Design System is one of the most
    popular Angular UI libraries.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图1.3**](#figureanchor1.3) 清晰度设计系统是Angular UI库中最受欢迎的之一。'
- en: '*Ionic ([http://ionic.io](http://ionic.io)) —*Primarily for mobile, Ionic is
    a comprehensive library of components with easy theming, native device integrations,
    practical services, and its own CLI for app development workflows. The company
    also provides commercial services for mobile app development. It has an open source
    license.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ionic ([http://ionic.io](http://ionic.io)) — 主要针对移动端，Ionic是一个包含易于主题化、原生设备集成、实用服务和自身CLI（应用程序开发工作流程）的组件库。该公司还提供移动应用程序开发的商业服务。它具有开源许可证。'
- en: '*Fuel-UI ([http://fuelinteractive.github.io/fuel-ui/](http://fuelinteractive.github.io/fuel-ui/)) —*Another
    Bootstrap CSS framework­based set of components, directives, and pipes by Fuel
    Travel. It has an open source license.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Fuel-UI ([http://fuelinteractive.github.io/fuel-ui/](http://fuelinteractive.github.io/fuel-ui/))
    — 由Fuel Travel提供的另一个基于Bootstrap CSS框架的组件、指令和管道集。它具有开源许可证。'
- en: You’re certainly not required to use a UI library, but most developers will
    find them to be useful. Any reasonable UI library should be fairly well tested,
    allowing you to focus more on what makes your application unique.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然不需要使用UI库，但大多数开发者会发现它们很有用。任何合理的UI库都应该经过相当充分的测试，让你能更多地关注使你的应用程序独特的地方。
- en: 1.5 Component architecture
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.5 组件架构
- en: Many modern applications have adopted a component-based approach to developing
    applications. The intention is to design each piece of your application in a standalone
    manner that limits the amount of coupling and duplication across various parts
    of the program. In many ways, a *component* is a way to create custom HTML elements
    in your application.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代应用程序都采用了基于组件的方法来开发应用程序。目的是以独立的方式设计你应用程序的每一部分，以限制程序各个部分之间的耦合和重复。在许多方面，*组件*是在你的应用程序中创建自定义HTML元素的一种方式。
- en: The easiest way to think about a component architecture is to look at an example
    of a page with a large number of discrete parts and inspect how the various parts
    relate to one another. Figure 1.4 shows an example from a future chapter and visually
    breaks down the various component parts.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 思考组件架构的最简单方法之一是查看一个包含大量离散部分的页面示例，并检查各个部分是如何相互关联的。图1.4展示了未来章节的一个示例，并直观地分解了各种组件部分。
- en: '![c01-4.png](image_fi/293313c01/c01-4.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![c01-4.png](image_fi/293313c01/c01-4.png)'
- en: '**Figure 1.4** Component architecture illustrated by showing how components
    are nested and combined to create more complex layouts'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**图1.4** 通过展示组件如何嵌套和组合以创建更复杂的布局来展示组件架构'
- en: The figure shows an isolated section from one of the book chapter examples,
    illustrating that several components combine to create this display. You can see
    that various parts are independent from the others, but they also work together
    to create the list of items. There’s clearly a hierarchy between them. The list
    of components on the right shows the parent-to-child relationship each of the
    components has with the others, and this is essentially how HTML elements work
    together on the page.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图表显示了本书章节示例中的一个独立部分，说明了几个组件如何组合在一起创建这个显示。你可以看到各个部分相互独立，但它们也共同工作以创建项目列表。它们之间显然存在层次关系。右侧的组件列表显示了每个组件与其他组件之间的父子关系，这正是HTML元素在页面上协同工作的基本方式。
- en: HTML itself is a language of components. Each element has a certain role and
    functionality, and they’re all easily nested to create more complex functionality.
    They’re isolated but still easily manipulated to do whatever is needed at the
    moment. Some elements work in tandem. For example, `INPUT`s are used inside of
    a `FORM` to describe a set of input controls. Many elements can also emit events
    when things happen; a `FORM` can emit an event when the form is submitted, for
    example. This allows you to wire up additional logic to manipulate HTML elements
    based on the events that fire—the fundamentals of front-end application development.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: HTML本身是一种组件语言。每个元素都有一定的角色和功能，并且它们可以轻松嵌套以创建更复杂的功能。它们是隔离的，但仍然可以轻松地操作以完成当前所需的任何任务。一些元素协同工作。例如，`INPUT`元素在`FORM`内部使用，以描述一组输入控件。许多元素在发生某些事情时也可以发出事件；例如，`FORM`在表单提交时可以发出事件。这允许你根据触发的事件将额外的逻辑连接到HTML元素，这是前端应用程序开发的基础。
- en: Hopefully a component architecture seems fairly approachable and consistent
    with your current understanding of the web. The intention is to focus on breaking
    down individual parts of the application (particularly the visual UI elements)
    into discrete, modular components.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 希望组件架构看起来相当容易接近，并且与你对网络的当前理解保持一致。目的是将应用程序的各个部分（尤其是视觉UI元素）分解成离散的、模块化的组件。
- en: There are many ways to implement a component architecture, as evidenced by the
    many web application libraries such as React and Ember. Angular has a very obvious
    component-based architecture (all Angular applications are components). React
    and Ember also have first-class support for components in their applications.
    Those with jQuery experience can also imagine that jQuery plugins can be conceptually
    similar to components, though they’re not as consistent or regulated. Even the
    basic concepts of the Web 2.0 days (think widgets!) are based around building
    components.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 实现组件架构有许多方法，正如许多网络应用程序库（如React和Ember）所证明的那样。Angular有一个非常明显的基于组件的架构（所有Angular应用程序都是组件）。React和Ember也为其应用程序提供了对组件的一级支持。那些有jQuery经验的人也可以想象jQuery插件在概念上可以类似于组件，尽管它们并不那么一致或规范。甚至Web
    2.0时代的基礎概念（想想小工具！）也是围绕构建组件来展开的。
- en: 1.5.1 Components’ key characteristics
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5.1 组件的关键特性
- en: 'Components have some concepts that drive their design and architecture. This
    section will explore these concepts in more detail, but also keep an eye open
    for how Angular applies these concepts to practice throughout the book:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 组件有一些概念驱动着它们的设计和架构。本节将更详细地探讨这些概念，但也要关注Angular如何在整本书的实践中应用这些概念：
- en: '*Encapsulation —*Keeping component logic in a single place'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*封装* — 将组件逻辑保持在单一位置'
- en: '*Isolation —*Keeping component internals hidden from external actors'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*隔离* — 将组件内部隐藏对外部行为者'
- en: '*Reusability —*Allowing component reuse with minimal effort'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可复用性* — 允许以最小的努力进行组件复用'
- en: '*Evented —*Emitting events during the lifecycle of the component'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*事件驱动* — 在组件的生命周期中发出事件'
- en: '*Customizable —*Making it possible to style and extend the component'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可定制* — 使其可能对组件进行样式化和扩展'
- en: '*Declarative —*Using a component with simple declarative markup'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*声明式* — 使用具有简单声明性标记的组件'
- en: When we build components, the preceding are the tenets we should consider when
    designing the best components possible. These concepts have existed in various
    forms before, but rarely have they all been clearly implemented and standardized
    into the web platform.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建组件时，上述原则是我们设计最佳组件时应该考虑的。这些概念以前以各种形式存在，但很少全部被明确实现并标准化为网络平台。
- en: 'The World Wide Web Consortium (W3C), the primary standards body for the web,
    is developing an official Web Component specification. Several standards are required
    in order to implement the full vision of web components:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网标准组织（W3C），作为网络的主要标准机构，正在制定官方的Web组件规范。为了实现网络组件的完整愿景，需要几个标准：
- en: Custom elements (encapsulation, declarative, reusability, evented)
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义元素（封装、声明式、可复用性、事件驱动）
- en: Shadow DOM (isolation, encapsulation, customizable)
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阴影DOM（隔离、封装、可定制）
- en: Templates (encapsulation, isolation)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板（封装、隔离）
- en: JavaScript modules (encapsulation, isolation, reusability)
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript模块（封装、隔离、可复用性）
- en: As of this writing, the specification isn’t fully adopted in all browsers and
    possibly never will be. Standards are also subject to change, but it’s not crucial
    that we dive into the specifics of the specification here. The important thing
    is that these four concepts are central to the idea of components. Let’s explore
    them a little more in detail and see how they enable a component architecture.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，该规范并未在所有浏览器中得到完全采用，并且可能永远不会得到完全采用。标准也可能发生变化，但在这里深入探讨规范的细节并不至关重要。重要的是，这四个概念是组件理念的核心。让我们更详细地探讨它们，看看它们如何使组件架构成为可能。
- en: Custom Elements
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自定义元素
- en: HTML is the language of the web because it describes the content of a page in
    a fairly concise set of elements. As a markup language, it’s a declarative way
    to describe your content. *Custom elements* mean being able to extend HTML with
    our own additional elements, adding to the vocabulary of what is possible. You
    can read about the official specification at [www.w3.org/TR/custom-elements/](http://www.w3.org/TR/custom-elements/).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: HTML是网络的通用语言，因为它以相当简洁的元素集描述了页面内容。作为一种标记语言，它是一种描述内容的声明性方式。*自定义元素*意味着能够通过我们自己的附加元素扩展HTML，增加可能性的词汇表。你可以在[www.w3.org/TR/custom-elements/](http://www.w3.org/TR/custom-elements/)上阅读关于官方规范的更多信息。
- en: 'The official specification for custom elements is intended to allow developers
    to create new HTML elements that essentially blend naturally and natively into
    the DOM. In other words, using a custom element should be no different from using
    any other HTML element. For example, imagine you want to create a custom element
    that implements a tabbing interface. You would likely want to create custom elements
    like the following code and in [figure 1.5](#figure1.5):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义元素的官方规范旨在允许开发者创建新的HTML元素，这些元素本质上可以自然地、本地地融合到DOM中。换句话说，使用自定义元素应该与其他任何HTML元素的使用没有区别。例如，想象你想创建一个实现标签页界面的自定义元素。你可能会想创建如下代码所示的自定义元素，并在[图1.5](#figure1.5)中：
- en: '[PRE1]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This looks and feels like natural HTML because these would be two custom elements:
    `tab`s and `tab` elements. The real value here is how easy it is to implement
    tabs. Using jQuery, you would end up creating a lot of `div` elements, applying
    a number of custom IDs or classes, and sprinkling some JavaScript on top.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来和感觉就像自然的HTML，因为这些将会有两个自定义元素：`tab`s和`tab`元素。这里的真正价值在于实现标签页的简便性。使用jQuery，你最终会创建大量的`div`元素，应用多个自定义ID或类，并在其上添加一些JavaScript。
- en: These tabs could also emit events. For example, anytime the active tab changes
    there could be a `tabChange` event. Anything in your application could then listen
    for this event and act accordingly. Each custom element could implement any number
    of events that seem practical to the lifecycle of the component.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标签页也可以发出事件。例如，每当活动标签更改时，可能会有一个`tabChange`事件。你的应用程序中的任何内容都可以监听此事件并相应地采取行动。每个自定义元素都可以实现任何看似对组件生命周期实用的数量的事件。
- en: A custom element can also implement its own styling, so the tabs can come by
    default with a particular look and feel. Anyone using the tabs could write their
    own CSS to modify it to their particular use case, but custom elements can have
    a default appearance much like many HTML elements.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义元素也可以实现自己的样式，因此标签页可以默认具有特定的外观和感觉。任何使用标签页的人都可以编写自己的CSS来修改它以适应特定的使用场景，但自定义元素可以有一个默认的外观，就像许多HTML元素一样。
- en: Custom elements have a lot of the stuff necessary for building components. In
    fact, we could stop with custom elements and be fairly happy. It gives us a *declarative*
    way to create a *reusable* component, which *encapsulates* the internal mechanics
    of the component away from the rest of the application, but can emit *events*
    to enable other components to hook into the lifecycle. Angular uses these concepts
    in its implementation of components.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义元素拥有构建组件所需的大量功能。实际上，我们可以在自定义元素上停止，并且相当满意。它为我们提供了一种*声明性*的方式来创建*可重用*的组件，该组件*封装*了组件的内部机制，使其与应用程序的其他部分隔离开来，但可以发出*事件*以使其他组件能够钩入组件的生命周期。Angular在其组件实现中使用了这些概念。
- en: '![c01-5.png](image_fi/293313c01/c01-5.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![c01-5.png](image_fi/293313c01/c01-5.png)'
- en: '[**Figure 1.5**](#figureanchor1.5) Custom elements fit into a normal HTML hierarchy
    but can implement new behaviors.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图1.5**](#figureanchor1.5) 自定义元素适合于正常的HTML层次结构，但可以实现新的行为。'
- en: Angular provides its own mechanics to create a custom element, which is just
    an Angular component. Every Angular component is a custom element and fulfills
    the four tenets (and more) that we expect to get from a custom element.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供自己的机制来创建自定义元素，这实际上就是一个Angular组件。每个Angular组件都是一个自定义元素，并满足我们期望从自定义元素获得的四个原则（以及更多）。
- en: 1.5.2 Shadow DOM
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5.2 Shadow DOM
- en: Despite the rather ominous-sounding name, the *Shadow DOM* is really your best
    friend when it comes to trying to isolate styling behaviors inside of a component.
    The Shadow DOM is an isolated Document Object Model (DOM) tree that’s detached
    from the typical CSS inheritance, allowing you to create a barrier between markup
    inside and outside of the Shadow DOM. For example, if you have a button inside
    of a Shadow DOM and a button outside, any CSS for the button written outside the
    Shadow DOM won’t affect the button inside it. This is important for Angular because
    it allows us to have better control over how CSS affects the way the components
    display.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管名字听起来有些不吉利，但当你试图在组件内部隔离样式行为时，*Shadow DOM*实际上是你的最佳朋友。Shadow DOM是一个独立的文档对象模型（DOM）树，与典型的CSS继承分离，允许你在Shadow
    DOM内部和外部之间创建一个屏障。例如，如果你在Shadow DOM内部有一个按钮，而在外部也有一个按钮，那么在Shadow DOM外部编写的按钮CSS不会影响其内部的按钮。这对于Angular来说很重要，因为它允许我们更好地控制CSS如何影响组件的显示方式。
- en: CSS is a powerful language, but most web developers have run into issues where
    CSS styles have accidentally modified elements other than the intended ones, particularly
    when adding CSS from external sources. Shadow DOM provides a way to truly encapsulate
    your component HTML and CSS from other parts of the page, which is known as Light
    DOM. You can read about the official specification at [www.w3.org/TR/shadow-dom](http://www.w3.org/TR/shadow-dom).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: CSS是一种强大的语言，但大多数Web开发者都遇到过CSS样式意外修改了除目标元素之外的其他元素的问题，尤其是在添加外部CSS源时。Shadow DOM提供了一种真正封装组件HTML和CSS的方法，使其与其他页面部分分离，这被称为Light
    DOM。你可以在[www.w3.org/TR/shadow-dom](http://www.w3.org/TR/shadow-dom)上阅读官方规范。
- en: Developers should be familiar with the standard Light DOM, defining the standard
    DOM behaviors with regard to element styling and visibility. When you write a
    CSS rule, the CSS selector is the only way to limit which elements receive that
    particular styling. Outside of some fairly small, hand-crafted web pages, most
    CSS is written with some kind of systematic approach to set clear rules about
    how CSS styles get applied. This gave rise to many of the great CSS grid and component
    frameworks, such as Bootstrap and Foundation. It also gave us a selection of CSS
    selector nomenclatures, such as Scalable Modular Architecture for CSS (SMACSS)
    and Block Element Modifier (BEM). Although we’ve found ways to manage the Light
    DOM with these systems, it doesn’t change the underlying behavior that someone
    could still manage to break your whole application by adding a single rule that
    doesn’t adhere to the guidelines.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者应该熟悉标准的Light DOM，它定义了与元素样式和可见性相关的标准DOM行为。当你编写一个CSS规则时，CSS选择器是唯一限制哪些元素接收特定样式的途径。在大多数情况下，CSS都是通过某种系统方法编写的，以明确CSS样式如何应用。这导致了众多优秀的CSS网格和组件框架的出现，如Bootstrap和Foundation。它还为我们提供了一系列CSS选择器命名法，如CSS的可伸缩模块化架构（SMACSS）和块元素修饰符（BEM）。尽管我们已经找到了管理Light
    DOM的方法，但这并没有改变根本的行为，即有人仍然可能通过添加一个不遵循指南的规则来破坏整个应用程序。
- en: There’s always been pain associated with scaling page styling with CSS due to
    the greedy nature of CSS selectors always trying to match as many things as possible.
    In contrast with the Light DOM, the Shadow DOM gives us the ability to denote
    that a fragment of the DOM be shifted into a new realm that doesn’t play with
    the Light DOM styles.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于CSS选择器的贪婪特性，总是试图匹配尽可能多的元素，因此在用CSS进行页面样式缩放时一直伴随着痛苦。与Light DOM相比，Shadow DOM赋予我们能力将DOM的一部分移入一个新领域，这个新领域不会与Light
    DOM样式交互。
- en: In many science fiction stories, characters may get caught somehow in a new
    dimension of reality that is separated from normal reality, and they’re usually
    unable to interact between these realities except through some “bridge” between
    the realities. Similarly, I like to think of using Shadow DOM as like shifting
    the current context to a new dimension that has very limited connection to the
    Light DOM and therefore allows us to write CSS and HTML that gets rendered without
    having the ability to modify other styles.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多科幻故事中，人物可能会以某种方式被困在现实的一个新维度中，这个维度与正常现实分离，他们通常无法通过现实之间的某种“桥梁”进行交互。同样，我喜欢将使用
    Shadow DOM 视为将当前上下文转移到与 Light DOM 非常有限连接的新维度，因此允许我们编写在无法修改其他样式的条件下渲染的 CSS 和 HTML。
- en: Developers can create a new Shadow DOM (known as a *shadow root*) that will
    carve out an isolated DOM tree that has limited interaction with the Light DOM.
    You still attach this root inside the DOM tree as a node. The *shadow boundary*
    is the line between the Light and Shadow DOMs. There are many nuances and features
    that enable certain forms of styles to target inside or outside of the boundary,
    but I’ll leave those details for you to dive into if they become needed.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以创建一个新的 Shadow DOM（称为 *阴影根*），这将切割出一个与 Light DOM 有限交互的独立 DOM 树。您仍然需要将此根作为节点附加到
    DOM 树中。*阴影边界* 是 Light DOM 和 Shadow DOM 之间的线。有许多细微差别和功能使得某些形式的样式可以针对边界内或边界外，但我会将这些细节留给你，如果需要的话再深入研究。
- en: In [figure 1.6](#figure1.6), you can see a simple example where the first line
    of text output in the middle of the image has the black background and white text,
    whereas the second line of text (which is inside the shadow root) doesn’t.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 1.6](#figure1.6) 中，您可以看到一个简单的示例，其中图像中间输出的第一行文本具有黑色背景和白色文字，而第二行文本（位于阴影根内）没有。
- en: '![c01-6.png](image_fi/293313c01/c01-6.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![c01-6.png](image_fi/293313c01/c01-6.png)'
- en: '[**Figure 1.6**](#figureanchor1.6) Shadow DOM example where the styles from
    outside the shadow root don’t cross the boundary and apply to inner elements'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图 1.6**](#figureanchor1.6)  Shadow DOM 示例，其中来自阴影根之外的风格不会跨越边界并应用于内部元素'
- en: Shadow DOM enables the best form of encapsulation available in the browser for
    styles and templates. It’s able to isolate the internals of a component in such
    a way that outside styles and scripts won’t accidentally attach and modify it.
    It does provide some customization features that allow you to communicate across
    the shadow boundary. These are particularly important features when we want to
    build out complex and reusable components that can be entirely self-contained
    with styling.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Shadow DOM 为浏览器中样式和模板提供了最佳封装形式。它能够以某种方式隔离组件的内部，使得外部样式和脚本不会意外地附加并修改它。它确实提供了一些定制功能，允许您跨越阴影边界进行通信。这些功能在我们想要构建复杂且可重用的组件时尤为重要，这些组件可以完全自包含样式。
- en: Unfortunately, Shadow DOM support may not be available in all browsers and may
    require a polyfill. Chapter 4 explores this in more detail, but Angular lets us
    write components that use either the Shadow DOM, an emulated version of the Shadow
    DOM, or just the Light DOM.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Shadow DOM 的支持可能不是所有浏览器都提供，可能需要 polyfill。第 4 章将更详细地探讨这个问题，但 Angular 允许我们编写使用
    Shadow DOM、Shadow DOM 的模拟版本或仅 Light DOM 的组件。
- en: 1.5.3 Templates
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5.3 模板
- en: '*Templates* are a powerful feature that allow us to create isolated fragments
    of the DOM to use in our components. Our custom elements need to have some kind
    of internal structure, and often we’ll need to be able to reuse this markup. Ideally
    this shouldn’t clutter the main document, and HTML5 introduces a new `template`
    tag to help us out. You can read the spec at [https://www.w3.org/TR/html5/semantics-scripting.html#the-template-element](https://www.w3.org/TR/html5/semantics-scripting.html#the-template-element).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*模板* 是一个强大的功能，它允许我们创建用于组件中的独立 DOM 片段。我们的自定义元素需要某种内部结构，并且我们通常需要能够重用这种标记。理想情况下，这不应该使主文档杂乱无章，HTML5
    引入了一个新的 `template` 标签来帮助我们。您可以在 [https://www.w3.org/TR/html5/semantics-scripting.html#the-template-element](https://www.w3.org/TR/html5/semantics-scripting.html#the-template-element)
    阅读规范。'
- en: Any markup written inside a template is just a fragment that’s not part of the
    current page unless it’s explicitly initialized. In other words, if you were to
    look at the DOM tree, the content in templates doesn’t appear. If your markup
    has CSS, inline scripts, image elements, or other elements that typically trigger
    a browser action, those actions won’t run until the template is used.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板内部编写的任何标记都只是一个不属于当前页面的片段，除非它被显式初始化。换句话说，如果你查看DOM树，模板中的内容不会出现。如果你的标记包含CSS、内联脚本、图像元素或其他通常触发浏览器操作的元素，这些操作将不会在模板使用之前运行。
- en: Templates are often used with the Shadow DOM because it allows you to define
    the template and then inject it into the shadow root. Without templates, the Shadow
    DOM APIs would require us to inject content node by node. They’re also used by
    Angular as part of the lifecycle of components and the compilation process, allowing
    Angular to keep isolated, inert copies of the template as data changes and needs
    to be recompiled.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 模板通常与Shadow DOM一起使用，因为它允许你定义模板，然后将其注入到shadow root中。没有模板，Shadow DOM API将需要我们逐个节点地注入内容。它们也被Angular作为组件生命周期和编译过程的一部分使用，允许Angular在数据变化和需要重新编译时保持模板的隔离、惰性副本作为数据。
- en: The role of templates folds in nicely with the overall component architecture
    and works in tandem with the Shadow DOM and custom elements. They provide a layer
    of encapsulation that lets you define a template that remains inactive until it’s
    needed and therefore isolates the template from the rest of the application.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 模板的作用与整体组件架构很好地融合，并与Shadow DOM和自定义元素协同工作。它们提供了一层封装，允许你定义一个在需要时才激活的模板，从而将模板与应用程序的其他部分隔离开来。
- en: 1.5.3 JavaScript modules
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5.3 JavaScript模块
- en: Neither HTML nor JavaScript has traditionally had a native means to load additional
    files or assets during the lifecycle of the application. You had to ensure that
    all the needed files were loaded on page load, or use some workaround that usually
    relied on making an XHR request or adding a new script tag to the page. Though
    these approaches worked, they weren’t particularly elegant or always easy to use.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是HTML还是JavaScript，传统上都没有在应用程序生命周期中加载额外文件或资产的原生方法。你必须确保所有需要的文件在页面加载时都已加载，或者使用一些通常依赖于发起XHR请求或向页面添加新脚本标签的解决方案。尽管这些方法有效，但它们并不特别优雅，也不总是容易使用。
- en: Today we have modules and module loaders in JavaScript, which give a native
    way to load and execute code throughout the entire lifecycle of the app, not just
    on page load. Previously, developers had to build a bundle of all the assets for
    the web application ahead of time and deliver the whole package to the user. Modules
    ([figure 1.7](#figure1.7)) give us a lot of interesting capabilities, many of
    which are familiar to developers who have worked with other languages with package
    or module capabilities, like Java, Python, or Go.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我们在JavaScript中有模块和模块加载器，这为在整个应用程序生命周期中加载和执行代码提供了原生方法，而不仅仅是页面加载时。以前，开发者必须提前构建包含所有资产的Web应用程序包，并将整个包交付给用户。模块（[图 1.7](#figure1.7)）为我们提供了许多有趣的功能，其中许多对使用过具有包或模块功能的其他语言的开发者来说都很熟悉，比如Java、Python或Go。
- en: '![c01-7.png](image_fi/293313c01/c01-7.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![c01-7.png](image_fi/293313c01/c01-7.png)'
- en: '[**Figure 1.7**](#figureanchor1.7) Angular provides modules (like animation)
    that contain all the services and objects you’ll need to build your applications,
    but first you’ll have to import them.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图 1.7**](#figureanchor1.7) Angular提供了包含所有你需要构建应用程序的服务和对象的模块（如动画），但首先你必须导入它们。'
- en: Inherently, modules aren’t strictly a component technology. Modules are an isolated
    piece of JavaScript that can be used to generate a component, create a reusable
    service, or do anything else JavaScript can do. They’re fundamentally a way to
    encapsulate application code and choose what’s available for the other parts of
    the application to use.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，模块并不是严格意义上的组件技术。模块是可以用来生成组件、创建可重用服务或执行JavaScript能做的任何其他事情的独立JavaScript代码块。它们本质上是封装应用程序代码并选择应用程序其他部分可以使用的内容的一种方式。
- en: '![c01-8.png](image_fi/293313c01/c01-8.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![c01-8.png](image_fi/293313c01/c01-8.png)'
- en: '[**Figure 1.8**](#figureanchor1.8) Loading objects into a file from different
    modules using imports'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图 1.8**](#figureanchor1.8) 从不同模块使用导入将对象加载到文件中'
- en: In JavaScript, a module is any file of JavaScript code that contains the `export`
    keyword. Modules export values that they want to expose to the application and
    can keep other parts of the internal logic private. Then, in order to use an exported
    value, you have to first import it from another module ([figure 1.8](#figure1.8)).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，一个模块是任何包含 `export` 关键字的 JavaScript 代码文件。模块导出它们想要暴露给应用程序的值，并且可以保持内部逻辑的其他部分私有。然后，为了使用导出的值，你必须首先从另一个模块中导入它（[图
    1.8](#figure1.8)）。
- en: In [figure 1.8](#figure1.8) (a snippet from a later chapter), we're first importing
    some things from external modules that the rest of the code in this file depends
    on. The `Component` and `DoCheck` objects are being imported from the @angular/core
    package (which is part of our node modules directory), and `AccountService` is
    being imported based on the file path provided.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 1.8](#figure1.8)（来自后续章节的片段）中，我们首先从外部模块导入一些东西，这些模块是本文件中其余代码所依赖的。`Component`
    和 `DoCheck` 对象是从 @angular/core 包（它是我们的 node 模块目录的一部分）导入的，而 `AccountService` 是基于提供的文件路径导入的。
- en: These modules are powerful because they *encapsulate* the contents of a single
    Java­Script file into a single coherent whole. They *isolate* the code and allow
    the developer to conditionally export values to share. They also support *reusability*
    by defining common mechanics for sharing values in a JavaScript application that
    previously could only be done by putting values directly on the global scope or
    by crafting some non-standard service to manage dependency injection, as Angular
    1 did.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模块之所以强大，是因为它们 *封装* 了单个 JavaScript 文件的全部内容，形成一个单一的整体。它们 *隔离* 代码，并允许开发者有条件地导出值以共享。它们还通过定义在
    JavaScript 应用程序中共享值的通用机制来支持 *可重用性*，这在之前只能通过直接在全局作用域上放置值或通过创建一些非标准的服务来管理依赖注入来实现，就像
    Angular 1 所做的那样。
- en: HTML imports are a similar concept that has been proposed as part of the HTML
    spec, which would provide similar capabilities. But it’s likely that HTML imports
    won’t be adopted, and instead JavaScript modules are used. There are libraries
    that use HTML imports, such as Polymer, by using a polyfill library.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 导入是一个类似的概念，它作为 HTML 规范的一部分被提出，将提供类似的功能。但很可能会采用 JavaScript 模块而不是 HTML 导入。有一些库使用
    HTML 导入，例如 Polymer，通过使用 polyfill 库来实现。
- en: Angular itself is built entirely around the notion of modules. The source code
    uses them extensively. When you write your own applications, it’s recommended
    that you also use them. Executing an Angular application is fundamentally loading
    a module that contains the application bootstrapping logic, which in turn starts
    to load and trigger additional modules. It’s possible to write your Angular applications
    without modules using ES5 syntax, which is not recommended but discussed next.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 本身完全围绕模块的概念构建。源代码广泛使用它们。当你编写自己的应用程序时，建议你也使用它们。执行 Angular 应用程序本质上是在加载一个包含应用程序引导逻辑的模块，然后它开始加载和触发其他模块。虽然不推荐，但可以使用
    ES5 语法编写不使用模块的 Angular 应用程序，这将在下文中讨论。
- en: 1.6 Modern JavaScript and Angular
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.6 现代JavaScript和Angular
- en: Angular is designed to take advantage of many features that are fairly recent
    to the web platform. Most of these became part of the JavaScript specification
    in 2015 with the release of ES2015 (also known as ES6, but I’ll refer to its official
    name ES2015); other features are still in development as of this writing but are
    likely to be adopted in a future version.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 被设计用来利用许多相对较新的网络平台特性。其中大部分在 2015 年随着 ES2015（也称为 ES6，但我会使用其官方名称 ES2015）的发布成为
    JavaScript 规范的一部分；其他特性在撰写本文时仍在开发中，但很可能在未来版本中得到采用。
- en: 'These features are well covered in many places, so I won’t go into detail.
    Though they could be used with AngularJS, Angular was designed to work using these
    capabilities. I’ll cover some of the most important aspects quickly, namely the
    following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性在许多地方都有很好的介绍，所以我就不详细说明了。尽管它们可以与 AngularJS 一起使用，但 Angular 是设计用来利用这些功能的。我将快速介绍一些最重要的方面，即以下内容：
- en: Classes
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: Decorators
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器
- en: Modules
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块
- en: Template literals
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板字符串
- en: Let’s look at an example with all these features working together and then review
    how they’re put together. The following listing is a functional but simple Angular
    component, and you’ll get to see many more examples that use the same concepts
    in more complex ways in this book.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个所有这些特性共同作用时的例子，然后回顾一下它们是如何组合在一起的。以下列表是一个功能性强但简单的 Angular 组件，你将在本书中看到更多使用相同概念但更复杂方式的例子。
- en: '**Listing 1.1** Modern JavaScript Syntax'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 1.1** 现代JavaScript语法'
- en: '[PRE2]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let’s start from the bottom and go from there. In ES2015, classes were introduced
    as a new way to define an object, which is in fact a function. Classes are used
    to create components, directives, pipes, and services, though they can be used
    in other ways as well. Using the `class` keyword, the class `MyComponent` is created
    and is an object that has a property called `title`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从底部开始，然后逐步进行。在 ES2015 中，类被引入作为一种定义对象的新方法，实际上它是一个函数。类用于创建组件、指令、管道和服务，尽管它们也可以以其他方式使用。使用
    `class` 关键字创建 `MyComponent` 类，它是一个具有名为 `title` 的属性的对象。
- en: Classes are syntactic sugar for creating objects in JavaScript. They don’t introduce
    a new type of inheritance to JavaScript, which is important to remember. Developers
    familiar with class objects in other languages may accidentally carry over concepts
    into JavaScript, but in this case the concept of a class doesn’t change the way
    prototypical inheritance works with JavaScript.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 类是 JavaScript 中创建对象的语法糖。它们没有为 JavaScript 引入新的继承类型，这一点很重要要记住。熟悉其他语言中类对象的开发者可能会意外地将概念带入
    JavaScript，但在这个情况下，类的概念并没有改变 JavaScript 中原型继承的工作方式。
- en: Inside of the class there’s a special method called `constructor()`. It’s executed
    immediately when a new copy of the object is created. As long as you name a method
    `constructor()`, it will be used during creation.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在类内部有一个特殊的方法叫做 `constructor()`。当创建对象的新副本时，它会立即执行。只要你的方法命名为 `constructor()`，它就会在创建过程中被使用。
- en: Classes are also useful because they help ensure that the keyword `this` references
    the object itself. The keyword `this` is a common barrier in JavaScript, and classes
    help ensure that it behaves more consistently.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 类也很有用，因为它们有助于确保关键字 `this` 引用对象本身。关键字 `this` 是 JavaScript 中常见的障碍，类有助于确保其行为更加一致。
- en: The `export` keyword denotes the file as a module. Any module is isolated into
    a private space, and unless a value is exported, it won’t be available for another
    file or module to use. This breaks away from the global scope that JavaScript
    has for values and provides a proper separation between modules. Because the `MyComponent`
    class is exported, it can be imported into another module (not shown here).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`export` 关键字表示文件是一个模块。任何模块都被隔离到一个私有空间中，除非值被导出，否则它将不可用于其他文件或模块。这打破了 JavaScript
    中值的全局作用域，并在模块之间提供了适当的分离。因为 `MyComponent` 类被导出，所以它可以被导入到另一个模块中（此处未显示）。'
- en: At the top of the file, the `import` statement imports the `Component` value
    from the `angular/core` module, which allows it to be used in this module.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件顶部，`import` 语句从 `angular/core` 模块中导入 `Component` 值，这使得它可以在本模块中使用。
- en: Then in the middle we use the `@Component` decorator, which is a way to add
    metadata to the class. Decorators always start with the @ symbol, and Angular
    uses these decorators to understand what type of class has been declared. In this
    case, it’s a component, and Angular will know how to render a component based
    on this decorator. There are several other ones, such as `Injectable` and `Pipe`,
    and we’ll see those in action later.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在中间，我们使用 `@Component` 装饰器，这是一种向类添加元数据的方式。装饰器总是以 @ 符号开头，Angular 使用这些装饰器来理解声明的类的类型。在这种情况下，它是一个组件，Angular
    将根据这个装饰器知道如何渲染组件。还有其他几个装饰器，例如 `Injectable` 和 `Pipe`，我们将在稍后看到它们的作用。
- en: Finally, the decorator accepts an object that contains the metadata associated
    with the component itself. In this example, it has two properties for the selector
    and an inline HTML template. The decorators define what properties can be passed
    here, but they allow you to customize the way the class is handled by Angular.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，装饰器接受一个包含与组件本身相关的元数据的对象。在这个例子中，它有两个属性用于选择器和内联 HTML 模板。装饰器定义了可以传递给这里的属性，但它们允许你自定义
    Angular 处理类的方式。
- en: 1.6.1 Observables
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.6.1 可观察对象
- en: In addition to new syntax, *observables* are a newer pattern for JavaScript
    applications to manage asynchronous activities. They’re also a draft for a feature
    to be natively implemented in the JavaScript language so it has weight behind
    the pattern. RxJS is the library we’ll use to help us implement observables in
    our applications.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 除了新的语法之外，*可观察对象* 是 JavaScript 应用程序管理异步活动的新模式。它们也是 JavaScript 语言中要原生实现的功能的草案，因此这个模式有了一定的分量。RxJS
    是我们将用来帮助我们实现应用程序中可观察对象的库。
- en: '*Promises* are another construct to help deal with asynchronous calls, which
    are useful for making API requests, for example. Promises have a major limitation
    in that they’re only useful for one call cycle. For example, if you wanted to
    have a promise return a value on an event like a user click, that promise would
    resolve on the first click. But you might be interested in handling *every* user
    click action. Normally, you’d use an event listener for this, and that allows
    you to handle events over time. This is an important distinction: Observables
    are like event handlers in that they continue to process data over time and allow
    you to continuously handle that stream of data.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*Promise*是另一种帮助处理异步调用的结构，例如，用于进行API请求很有用。Promise的一个主要限制是它们只对一次调用周期有用。例如，如果你想在用户点击事件上让Promise返回一个值，那么这个Promise将在第一次点击时解决。但你可能对处理*每个*用户点击动作感兴趣。通常，你会使用事件监听器来处理这种情况，这允许你在一段时间内处理事件。这是一个重要的区别：可观察对象就像事件处理器一样，它们会随着时间的推移持续处理数据，并允许你连续处理那个数据流。'
- en: Reactive programming is the higher-level name for what observables provide,
    which is a pattern for dealing with asynchronous data streams. Many things in
    a web application are asynchronous data streams, if you think about it. A user
    typing keystrokes into a form input is really a stream of individual characters.
    Timers and intervals generate a stream of activity over time. Websockets pass
    data as a stream over time. It’s that simple, but the challenge can be wrapping
    your mind around it all.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程是可观察对象提供的更高层次的名字，它是一种处理异步数据流的模式。如果你这么想，一个Web应用中的许多事物实际上都是异步数据流。用户在表单输入中输入按键实际上是一系列单个字符的流。计时器和间隔生成随时间推移的活动流。WebSockets随时间流过数据。这很简单，但挑战在于如何理解这一切。
- en: Angular uses observable patterns often, and having a grasp of the fundamentals
    is useful. During the course of this book, you’ll see observables in a number
    of places, and they all work in the same basic way. We’re not going to worry about
    constructing observables here. Instead we’ll just focus on how to use them when
    they’re given to you.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Angular经常使用可观察对象模式，掌握基础知识是有用的。在本书的整个过程中，你会在多个地方看到可观察对象，它们都以相同的基本方式工作。我们不会在这里担心构造可观察对象。相反，我们将专注于当它们被提供给你时如何使用它们。
- en: 'To use observables, you subscribe to the stream of data and pass a function
    that will run every time there’s a new piece of data. We’ll see this in action
    in chapter 2 when we make an HTTP request, but let’s look at a quick sample just
    to see some syntax:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用可观察对象，你需要订阅数据流，并传递一个函数，该函数会在有新数据时运行。我们将在第2章中看到这个操作的示例，当我们发起HTTP请求时，但让我们先快速看一下一些语法：
- en: '[PRE7]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This snippet is using the HTTP library to make a `get` request, which returns
    an observable. Then we subscribe to that observable, and our callback function
    fires when the data is returned or the error is handled. It’s not very different
    from a promise, except that an observable could continue to send data. Let’s take
    a different example:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段正在使用HTTP库来发起一个`get`请求，该请求返回一个可观察对象。然后我们订阅这个可观察对象，当数据返回或错误被处理时，我们的回调函数就会被触发。它与Promise没有太大区别，只不过可观察对象可以继续发送数据。让我们看一个不同的例子：
- en: '[PRE8]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, imagine `keyboardService.keypress()` returns an observable,
    and it emits details about what key was pressed. This is like an event listener,
    except that it comes in a stream.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，假设`keyboardService.keypress()`返回一个可观察对象，并发出有关按下哪个键的详细信息。这就像一个事件监听器，只不过它以流的形式出现。
- en: Another interesting capability of observables is that they are composable into
    many combinations. Observables can be combined, flattened into one, filtered,
    and more. We’ll see one example in chapter 9, where we’ll combine two observable
    streams and handle the data they emit in one place. We’ll not use many of the
    more complex features in this book, but you’ll likely be interested in how they
    work, so I recommend the book *RxJS in* *Action* (www.manning.com/books/rxjs-in-action).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察对象的另一个有趣的能力是它们可以组合成多种组合。可观察对象可以组合、扁平化成一个，过滤，等等。我们将在第9章中看到一个示例，我们将合并两个可观察对象流，并在一个地方处理它们发出的数据。在这本书中，我们不会使用许多更复杂的功能，但你可能对它们是如何工作的感兴趣，所以我推荐阅读《RxJS
    in Action》（www.manning.com/books/rxjs-in-action）这本书。
- en: 1.7 TypeScript and Angular
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.7 TypeScript和Angular
- en: Angular itself it written with TypeScript, which is a superset of JavaScript
    that introduces the ability to enforce typing information. It can be used with
    any version of JavaScript, so you can use it with anything ES3 (that’s not a typo)
    or newer.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 本身是用 TypeScript 编写的，它是 JavaScript 的超集，引入了强制类型信息的能力。它可以与任何版本的 JavaScript
    一起使用，因此你可以用它与任何 ES3（这不是一个打字错误）或更新的版本一起使用。
- en: The basic value proposition of TypeScript is it can force restrictions on what
    types of values variables hold. For example, a variable may only hold a number
    or it may hold an array of strings. JavaScript has types (don’t let anyone tell
    you otherwise!), but variables aren’t typed, so you can store any type of value
    in any variable. This also gave birth to the many types of comparison operators,
    such as `==` for loose equality or `===` for strict equality.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的基本价值主张是它可以对变量持有的值类型施加限制。例如，一个变量可能只能持有数字，或者它可能持有字符串数组。JavaScript
    有类型（不要让任何人告诉你不是这样！），但变量没有类型，所以你可以将任何类型的值存储在任何变量中。这也催生了各种比较运算符，如 `==` 用于松散相等或 `===`
    用于严格相等。
- en: 'TypeScript can help catch many simple syntax errors before they affect your
    application. Sometimes you can write valid JavaScript, but the real world shows
    that valid syntax doesn’t always mean valid behavior. Take this example:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 可以帮助在它们影响应用程序之前捕获许多简单的语法错误。有时你可以编写有效的 JavaScript，但现实世界表明，有效的语法并不总是意味着有效的行为。以下是一个例子：
- en: '[PRE9]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This snippet shows a simple tip calculator example where you take the value
    from an input element and add it to the bill to get the total payment amount.
    The problem here is that the `tip` variable is actually a string (because it’s
    text input). Adding a number and a string together is perhaps one of the most
    common pitfalls for new JavaScript developers, though it can happen to anyone.
    If you used TypeScript to enforce types, this code could be written to alert about
    this common error:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段展示了简单的小费计算器示例，其中你从输入元素中获取值并将其添加到账单中，以获取总付款金额。这里的问题是 `tip` 变量实际上是一个字符串（因为它是一个文本输入）。将数字和字符串相加可能是新
    JavaScript 开发者最常见的陷阱之一，尽管这可能会发生在任何人身上。如果你使用 TypeScript 来强制类型，这段代码可以编写为警告这种常见的错误：
- en: '[PRE10]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here we’re using TypeScript to declare that all these variables must each hold
    a number value by using `:number`. This is a simple syntax that sits inside of
    JavaScript to tell TypeScript what type of value the variable should hold. The
    `tip` value will error because it’s being assigned a string, and then the total
    value will error because it attempts to add a number and a string type, which
    results in a string.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 TypeScript 声明所有这些变量必须各自持有数字值，通过使用 `:number`。这是一个简单的语法，位于 JavaScript
    内部，告诉 TypeScript 变量应该持有哪种类型的值。`tip` 值将报错，因为它被分配了一个字符串，然后总值将报错，因为它尝试将数字和字符串类型相加，结果是一个字符串。
- en: This may seem like an obvious error to a seasoned JavaScript developer, but
    how often do you have new developers work on your code base? How often do you
    refactor your code? Can you still ensure that your application is passing around
    the same value types as you continue to maintain the application? Without TypeScript,
    you’re responsible for doing a strict comparator check of every value before it’s
    used.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于经验丰富的 JavaScript 开发者来说，这可能是明显的错误，但你有多少次让新开发者参与你的代码库？你有多少次重构你的代码？你能确保在维护应用程序的过程中，你的应用程序仍在传递相同的值类型吗？没有
    TypeScript，你在使用每个值之前必须进行严格的比较检查。
- en: 'Many developers wonder why they should bother learning and using TypeScript.
    Here are the primary reasons to use TypeScript, in my humble opinion:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者都在 wonder 为什么他们应该费心学习和使用 TypeScript。在我看来，以下是使用 TypeScript 的主要理由：
- en: '*Adds clarity to your code —*Variables that have types are easier to understand,
    because other developers (or yourself in six months) don’t have to think very
    hard about what the variable should be.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使你的代码更清晰 —* 具有类型的变量更容易理解，因为其他开发者（或六个月后的你自己）不必太费脑筋就能想清楚变量应该是什么。'
- en: '*Enables a smarter editor —*When you use TypeScript with a supported editor,
    you’ll get automatic IntelliSense support for your code. As you write, the editor
    can suggest known variables or functions and tell you what type of value it expects.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*启用更智能的编辑器 —* 当你使用 TypeScript 与支持编辑器时，你将获得代码的自动 IntelliSense 支持。当你编写代码时，编辑器可以建议已知的变量或函数，并告诉你它期望的类型值。'
- en: '*Catches errors before you run code —*TypeScript will catch syntax errors before
    you run the code in the browser, helping to reduce the feedback loop when you
    write invalid code.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在运行代码前捕获错误—*TypeScript 会在你运行浏览器中的代码之前捕获语法错误，帮助你减少编写无效代码时的反馈循环。'
- en: '*Entirely optional —*You can use types when you want, and optionally leave
    them out where it doesn’t matter.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*完全可选—*当你需要时可以使用类型，也可以选择在不重要的地方省略它们。'
- en: I hope you’re sold on the value of TypeScript. If not, I hope you’ll give it
    a closer look during the course of the book. This book uses it in examples to
    help provide more clarity and to help further demonstrate the power of TypeScript.
    I’ll try to provide additional insight into TypeScript features and functionality
    as we use features in the examples, but you can always learn all there is to know
    at [www.typescriptlang.org/docs/tutorial.html](http://www.typescriptlang.org/docs/tutorial.html).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你已经认可了 TypeScript 的价值。如果没有，我希望你在阅读本书的过程中能更仔细地审视它。本书在示例中使用 TypeScript，以提供更多的清晰度并进一步展示
    TypeScript 的强大功能。随着我们在示例中使用功能，我会尝试提供关于 TypeScript 特性和功能的额外见解，但你始终可以在 [www.typescriptlang.org/docs/tutorial.html](http://www.typescriptlang.org/docs/tutorial.html)
    上学习所有你需要知道的内容。
- en: Even if you choose not to use TypeScript for type enforcement in your application,
    you can use TypeScript to compile your application. Because the Angular CLI already
    uses TypeScript internally, you may be using it without even knowing. If you decide
    to build your own build tooling, TypeScript is still a worthwhile compiler option.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你选择不在你的应用程序中使用 TypeScript 进行类型检查，你仍然可以使用 TypeScript 来编译你的应用程序。因为 Angular CLI
    已经内部使用了 TypeScript，你可能在使用它而自己却不知道。如果你决定构建自己的构建工具，TypeScript 仍然是一个值得考虑的编译器选项。
- en: If you’re wondering whether using TypeScript in your Angular application is
    required, the answer is technically no. There are ways to write your application
    in vanilla JavaScript and avoid TypeScript, to a certain degree. But it’s intentionally
    not documented because there are simply too many features of Angular that don’t
    work unless you use TypeScript. If you’re afraid it will be hard to learn, don’t
    be. It’s straightforward, and in several places throughout the book I’ll explain
    some nuances of TypeScript that you may not have seen before.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道是否在 Angular 应用程序中使用 TypeScript 是必需的，技术上答案是无需。有方法可以编写不使用 TypeScript 的应用程序，并在一定程度上避免使用
    TypeScript。但出于故意，这部分内容并未被文档化，因为 Angular 有许多功能在没有使用 TypeScript 的情况下无法正常工作。如果你担心它难以学习，请不要担心。它很简单，本书中我会在几个地方解释一些你可能之前未曾见过的
    TypeScript 的细微差别。
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter introduced you to Angular as a development platform, not just
    an application framework. There are so many features and capabilities with Angular.
    Here’s a quick summary:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 Angular 作为开发平台，而不仅仅是应用框架。Angular 有许多特性和功能。以下是一个简要总结：
- en: Angular is a platform, with many key elements such as tooling, UI libraries,
    and testing built in or easily incorporated into your application projects.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 是一个平台，内置了许多关键元素，如工具、UI 库和测试，这些都可以轻松集成到你的应用程序项目中。
- en: Applications are essentially combinations of components. These components build
    upon the core principles of encapsulation, isolation, and reusability, which should
    have events, be customizable, and be declarative.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序本质上是由组件组合而成的。这些组件建立在封装、隔离和可重用性的核心原则之上，应该具有事件、可定制性和声明性。
- en: ES6 and TypeScript provide a lot of the underpinnings for Angular’s architecture
    and syntax, making it a powerful framework without having to build a lot of custom
    language capabilities.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ES6 和 TypeScript 为 Angular 的架构和语法提供了很多基础，使其成为一个无需构建大量自定义语言功能的强大框架。
