- en: Unit 5\. State and behavior
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5单元。状态和行为
- en: In Go, values represent *state*, such as whether a door is opened or closed.
    Functions and methods define *behavior*—actions on state, such as opening a door.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，值代表*状态*，例如门是打开还是关闭。函数和方法定义*行为*——对状态的操作，例如打开门。
- en: As programs grow larger, they become more difficult to manage and maintain,
    unless you have the right tools.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着程序的增大，它们变得越来越难以管理和维护，除非你有合适的工具。
- en: If there are several doors that can independently be opened or closed, it’s
    helpful to bundle the state and behavior together. Programming languages also
    allow you to express abstract ideas, such as *things that can be opened*. Then
    on a hot summer day, you can open everything that can be opened, whether door
    or window.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有几个门可以独立打开或关闭，将状态和行为捆绑在一起是有帮助的。编程语言还允许你表达抽象的概念，例如*可以打开的东西*。然后在炎热的夏日，你可以打开所有可以打开的东西，无论是门还是窗户。
- en: 'There are a lot of big words to describe these ideas: object-orientation, encapsulation,
    polymorphism, and composition. The lessons in this unit aim to demystify the concepts
    and demonstrate Go’s rather unique approach to object-oriented design.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多大词来描述这些概念：面向对象、封装、多态和组合。本单元的课程旨在阐明这些概念，并展示Go在面向对象设计方面相当独特的方法。
- en: Lesson 21\. A little structure
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第21课。一点结构体
- en: After reading [lesson 21](#ch21), you’ll be able to
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完[第21课](#ch21)后，你将能够
- en: Give coordinates on Mars a little structure
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给火星上的坐标一点结构体
- en: Encode structures to the popular JSON data format
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将结构体编码为流行的JSON数据格式
- en: A vehicle is made up of many parts, and those parts may have associated values
    (or state). The engine is on, the wheels are turning, the battery is fully charged.
    Using a separate variable for each value is akin to the vehicle sitting in the
    shop disassembled. Likewise, a building may have windows that are open and a door
    that is unlocked. To assemble the parts or construct a structure, Go provides
    a *structure* type.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一个车辆由许多部分组成，这些部分可能具有相关的值（或状态）。发动机正在运行，车轮在转动，电池完全充电。为每个值使用单独的变量就像车辆在商店中拆解一样。同样，一栋建筑可能有打开的窗户和未锁的门。为了组装部件或构建结构，Go提供了*结构体*类型。
- en: '|  |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: Whereas collections are of the same type, *structures* allow you to group disparate
    things together. Take a look around. What do you see that could be represented
    with a structure?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 而集合是同一类型，*结构体*允许你将不同的事物组合在一起。环顾四周。你看到了什么可以用结构体来表示？
- en: '|  |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 21.1\. Declaring a structure
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.1. 声明一个结构体
- en: 'A pair of coordinates are good candidates for adopting a little structure.
    Latitude and longitude go everywhere together. In a world without structures,
    a function to calculate the distance between two locations would need two pairs
    of coordinates:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一对坐标是采用一点结构的良好候选。纬度和经度总是一起出现。在一个没有结构体的世界中，计算两个位置之间距离的函数需要两对坐标：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Though this does work, passing independent coordinates around is prone to errors
    and just plain tedious. Latitude and longitude are a single unit, and structures
    let you treat them as such.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这确实可行，但传递独立的坐标容易出错，而且非常繁琐。纬度和经度是一个单一的单位，结构体允许你将它们视为这样的单位。
- en: The `curiosity` structure in the next listing is declared with floating-point
    fields for latitude and longitude. To assign a value to a field or access the
    value of a field, use *dot notation* with variable name *dot* field name, as shown.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表中的`curiosity`结构体使用浮点字段声明纬度和经度。要为字段赋值或访问字段的值，使用带有变量名*点*字段名的*点表示法*，如下所示。
- en: 'Listing 21.1\. Introducing a little structure: struct.go'
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表21.1.介绍一点结构体：struct.go
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* Assigns values to fields of the structure**'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将值赋给结构体的字段**'
- en: '***2* Prints -4.5895 137.4417**'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 -4.5895 137.4417**'
- en: '***3* Prints {-4.5895 137.4417}**'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 打印 {-4.5895 137.4417}**'
- en: '|  |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The `Print` family of functions will display the contents of structures for
    you.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`Print`函数族将显示结构体的内容。'
- en: '|  |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The Mars Curiosity rover began its journey at Bradbury Landing, located at 4°35’22.2”
    S, 137°26’30.1” E. In [listing 21.1](#ch21ex01) the latitude and longitude for
    Bradbury Landing are expressed in *decimal degrees*, with positive latitudes to
    the north and positive longitudes to the east, as illustrated in [figure 21.1](#ch21fig01).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 火星好奇号探测器从布拉德伯里着陆点开始其旅程，位于南纬4°35’22.2”，东经137°26’30.1”。在第[21.1节](#ch21ex01)中，布拉德伯里着陆点的纬度和经度以*十进制度数*表示，北纬为正值，东经为正值，如图[21.1节](#ch21fig01)所示。
- en: Figure 21.1\. Latitude and longitude in decimal degrees
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 21.1\. 十进制度数的纬度和经度
- en: '![](21fig01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](21fig01.jpg)'
- en: '|  |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 21.1**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 21.1**'
- en: '**[1](#ch21qa2q0a1)**'
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch21qa2q0a1)**'
- en: ''
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What advantage do structures have over individual variables?
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 结构体相较于单个变量有什么优势？
- en: '**[2](#ch21qa2q0a2)**'
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch21qa2q0a2)**'
- en: ''
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Bradbury Landing is about 4,400 meters below Martian “sea level.” If `curiosity`
    had an altitude field, how would you assign it the value of –4400?
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Bradbury Landing 大约在火星“海平面”下方 4,400 米。如果 `curiosity` 有一个海拔字段，你会如何将其值设置为 -4400？
- en: '|  |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 21.1 answer**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 21.1 答案**'
- en: '**[1](#ch21qa1q1)**'
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch21qa1q1)**'
- en: ''
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Structures group related values together, making it simpler and less error-prone
    to pass them around.
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 结构体将相关值组合在一起，使得传递它们变得更加简单且错误率更低。
- en: '**[2](#ch21qa1q2)**'
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch21qa1q2)**'
- en: ''
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|  |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 21.2\. Reusing structures with types
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.2\. 使用类型重复使用结构体
- en: If you need multiple structures with the same fields, you can define a type,
    much like the `celsius` type in [lesson 13](kindle_split_024.html#ch13). The `location`
    type declared in the following listing is used to place the Spirit rover at Columbia
    Memorial Station and the Opportunity rover at Challenger Memorial Station.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要具有相同字段的多余结构体，你可以定义一个类型，就像[第 13 课](kindle_split_024.html#ch13)中的 `celsius`
    类型一样。以下列表中声明的 `location` 类型用于将 Spirit 探索车放置在 Columbia Memorial Station，并将 Opportunity
    探索车放置在 Challenger Memorial Station。
- en: 'Listing 21.2\. Location type: location.go'
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 21.2\. 位置类型：location.go
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* Reuses the location type**'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 重复使用位置类型**'
- en: '***2* Prints {-14.5684 175.472636} {-1.9462 354.4734}**'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 {-14.5684 175.472636} {-1.9462 354.4734}**'
- en: '|  |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 21.2**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 21.2**'
- en: '**[Q1:](#ch21qa4q0a1)**'
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch21qa4q0a1)**'
- en: ''
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How would you adapt the code from [listing 21.1](#ch21ex01) to use the `location`
    type for the Curiosity rover at Bradbury Landing?
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你会如何修改[列表 21.1](#ch21ex01)中的代码以使用 Curiosity 探索车在 Bradbury Landing 的 `location`
    类型？
- en: '|  |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 21.2 answer**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 21.2 答案**'
- en: '**[1:](#ch21qa3q1)**'
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch21qa3q1)**'
- en: ''
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '|  |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 21.3\. Initialize structures with composite literals
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.3\. 使用复合字面量初始化结构体
- en: Composite literals for initializing structures come in two different forms.
    In [listing 21.3](#ch21ex03), the `opportunity` and `insight` variables are initialized
    using field-value pairs. Fields may be in any order, and fields that aren’t listed
    will retain the zero value for their type. This form tolerates change and will
    continue to work correctly even if fields are added to the structure or if fields
    are reordered. If `location` gained an altitude field, both `opportunity` and
    `insight` would default to an altitude of zero.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化结构体的复合字面量有两种不同的形式。在[列表 21.3](#ch21ex03)中，`opportunity` 和 `insight` 变量使用字段值对进行初始化。字段可以以任何顺序排列，未列出的字段将保留其类型的零值。这种形式可以容忍变化，即使在结构体中添加字段或重新排序字段，它也能继续正确工作。如果
    `location` 类型增加了一个海拔字段，`opportunity` 和 `insight` 将默认为海拔零。
- en: 'Listing 21.3\. Composite literal with field-value pairs: struct-literal.go'
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 21.3\. 带字段值对的复合字面量：struct-literal.go
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* Prints {-1.9462 354.4734}**'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 {-1.9462 354.4734}**'
- en: '***2* Prints {4.5 135.9}**'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 {4.5 135.9}**'
- en: The composite literal in [listing 21.4](#ch21ex04) doesn’t specify field names.
    Instead, a value must be provided for each field in the same order in which they’re
    listed in the structure definition. This form works best for types that are stable
    and only have a few fields. If the `location` type gains an altitude field, `spirit`
    must specify a value for altitude for the program to compile. Mixing up the order
    of `lat` and `long` won’t cause a compiler error, but the program won’t produce
    correct results.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 21.4](#ch21ex04)中的复合字面量没有指定字段名称。相反，必须为结构体定义中列出的每个字段提供值，顺序与结构体定义中的顺序相同。这种形式最适合稳定且只有少量字段的类型。如果
    `location` 类型增加了一个海拔字段，`spirit` 必须为海拔指定一个值，以便程序能够编译。混淆 `lat` 和 `long` 的顺序不会导致编译器错误，但程序将不会产生正确的结果。'
- en: 'Listing 21.4\. Composite literal with values only: struct-literal.go'
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 21.4\. 仅带值的复合字面量：struct-literal.go
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* Prints {-14.5684 175.472636}**'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 {-14.5684 175.472636}**'
- en: No matter how you initialize a structure, you can modify the `%v` format verb
    with a plus sign `+` to print out the field names, as shown in the next listing.
    This is especially useful for inspecting large structures.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你如何初始化结构体，你都可以通过在 `%v` 格式动词前加上加号 `+` 来修改它，以打印出字段名称，如下一列表所示。这对于检查大型结构体特别有用。
- en: 'Listing 21.5\. Printing keys of structures: struct-literal.go'
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 21.5\. 打印结构体的键：struct-literal.go
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* Prints {-4.5895 137.4417}**'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 {-4.5895 137.4417}**'
- en: '***2* Prints {lat:-4.5895 long:137.4417}**'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 {lat:-4.5895 long:137.4417}**'
- en: '|  |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 21.3**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 21.3**'
- en: '**[Q1:](#ch21qa6q0a1)**'
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch21qa6q0a1)**'
- en: ''
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In what ways is the field-value composite literal syntax preferable to the values-only
    form?
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在哪些方面，字段值复合字面量语法比仅值的形式更可取？
- en: '|  |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 21.3 answer**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 21.3 答案**'
- en: '**[1:](#ch21qa5q1)**'
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch21qa5q1)**'
- en: ''
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fields may be listed in any order.
  id: totrans-92
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字段可以按任何顺序列出。
- en: Fields are optional, taking on the zero value if not listed.
  id: totrans-93
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字段是可选的，如果没有列出，则采用零值。
- en: No changes are required when reordering or adding fields to the structure declaration.
  id: totrans-94
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在重新排序或添加字段到结构声明时，不需要进行任何更改。
- en: '|  |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 21.4\. Structures are copied
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.4\. 结构被复制
- en: When the Curiosity rover heads east from Bradbury Landing to Yellowknife Bay,
    the location of Bradbury Landing doesn’t change in real life, nor in the next
    listing. The `curiosity` variable is initialized with a copy of the values contained
    in `bradbury`, so the values change independently.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当好奇号探测器从布拉德伯里着陆点向东前往耶洛奈夫湾时，布拉德伯里着陆点的位置在现实生活中，以及在下一条列表中都没有改变。`curiosity` 变量使用
    `bradbury` 中包含的值的副本进行初始化，因此这些值独立变化。
- en: 'Listing 21.6\. Assignment makes a copy: struct-value.go'
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 21.6\. 赋值会创建一个副本：struct-value.go
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* Heads east to Yellowknife Bay**'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 向东前往耶洛奈夫湾**'
- en: '***2* Prints {-4.5895 137.4417} {-4.5895 137.4523}**'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 {-4.5895 137.4417} {-4.5895 137.4523}**'
- en: '|  |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 21.4**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 21.4**'
- en: '**[Q1:](#ch21qa8q0a1)**'
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch21qa8q0a1)**'
- en: ''
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If `curiosity` were passed to a function that manipulated `lat` or `long`, would
    the caller see those changes?
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果将 `curiosity` 传递给一个操作 `lat` 或 `long` 的函数，调用者会看到这些更改吗？
- en: '|  |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 21.4 answer**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 21.4 答案**'
- en: '**[1:](#ch21qa7q1)**'
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch21qa7q1)**'
- en: ''
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: No, the function would receive a copy of `curiosity`, as is the case with arrays.
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不，函数将接收 `curiosity` 的一个副本，就像数组一样。
- en: '|  |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 21.5\. A slice of structures
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.5\. 结构切片
- en: A slice of structures, `[]struct` is a collection of zero or more values (a
    slice) where each value is based on a structure instead of a primitive type like
    `float64`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 结构切片 `[]struct` 是一个包含零个或多个值（一个切片）的集合，其中每个值基于一个结构，而不是像 `float64` 这样的原始类型。
- en: If a program needed a collection of landing sites for Mars rovers, the way *not*
    to do it would be two separate slices for latitudes and longitudes, as shown in
    the following listing.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个程序需要一个火星探测车的着陆点集合，那么以下列表所示的两个单独的纬度和经度切片的方式是不正确的。
- en: 'Listing 21.7\. Two slices of floats: slice-struct.go'
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 21.7\. 两个浮点数切片：slice-struct.go
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This already looks bad, especially in light of the location structure introduced
    earlier in this lesson. Now imagine more slices being added for altitude and so
    on. A mistake when editing the previous listing could easily result in data misaligned
    across slices or even slices of different lengths.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经看起来很糟糕了，尤其是在本课程早期引入的位置结构的基础上。现在想象一下，添加更多用于海拔等的切片。编辑前一个列表时的错误很容易导致切片之间的数据错位，甚至不同长度的切片。
- en: A better solution is to create a single slice where each value is a structure.
    Then each location is a single unit, which you can extend with the name of the
    landing site or other fields as needed, as shown in the next listing.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是创建一个包含每个值都是一个结构的单个切片。然后每个位置都是一个单独的单元，可以根据需要扩展着陆点的名称或其他字段，如下一个列表所示。
- en: 'Listing 21.8\. A slice of locations: slice-struct.go'
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 21.8\. 位置的一个切片：slice-struct.go
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|  |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 21.5**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 21.5**'
- en: '**[Q1:](#ch21qa10q0a1)**'
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch21qa10q0a1)**'
- en: ''
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the danger of using multiple interrelated slices?
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用多个相互关联的切片有什么危险？
- en: '|  |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 21.5 answer**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 21.5 答案**'
- en: '**[1:](#ch21qa9q1)**'
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch21qa9q1)**'
- en: ''
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It’s easy to end up with data misaligned across slices.
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 很容易导致数据在切片之间错位。
- en: '|  |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 21.6\. Encoding structures to JSON
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.6\. 将结构编码为 JSON
- en: JavaScript Object Notation, or JSON (json.org), is a standard data format popularized
    by Douglas Crockford. It’s based on a subset of the JavaScript language but it’s
    widely supported in other programming languages. JSON is commonly used for web
    APIs (Application Programming Interfaces), including the MAAS API ([github.com/ingenology/mars_weather_api](http://github.com/ingenology/mars_weather_api))
    that provides weather data from the Curiosity rover.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 对象表示法，或 JSON (json.org)，是一种由 Douglas Crockford 推广的标准数据格式。它基于 JavaScript
    语言的子集，但在其他编程语言中得到广泛支持。JSON 通常用于 Web API（应用程序编程接口），包括提供好奇号探测器天气数据的 MAAS API ([github.com/ingenology/mars_weather_api](http://github.com/ingenology/mars_weather_api))。
- en: The `Marshal` function from the `json` package is used in [listing 21.9](#ch21ex09)
    to encode the data in `location` into JSON format. `Marshal` returns the JSON
    data as bytes, which can be sent over the wire or converted to a string for display.
    It may also return an error, a topic that’s covered in [lesson 28](kindle_split_042.html#ch28).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`json`包中的`Marshal`函数在[列表 21.9](#ch21ex09)中用于将`location`中的数据编码成 JSON 格式。`Marshal`返回
    JSON 数据作为字节，这些字节可以通过网络发送或转换为字符串以供显示。它也可能返回一个错误，这是一个在[课程 28](kindle_split_042.html#ch28)中讨论的主题。'
- en: 'Listing 21.9\. Marshalling location: json.go'
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 21.9. 编码位置：json.go
- en: '[PRE11]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1* Fields must begin with an uppercase letter.**'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 字段必须以大写字母开头。**'
- en: '***2* Prints {“Lat”:-4.5895,“Long”:137.4417}**'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 {“Lat”:-4.5895,“Long”:137.4417}**'
- en: Notice that the JSON keys match the field names of the `location` structure.
    For this to work, the `json` package requires fields to be exported. If `Lat`
    and `Long` began with a lowercase letter, the output would be `{}`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，JSON 键与`location`结构体的字段名相匹配。为了使这生效，`json`包要求字段必须导出。如果`Lat`和`Long`以小写字母开头，输出将是`{}`。
- en: '|  |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 21.6**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 21.6**'
- en: '**[Q1:](#ch21qa12q0a1)**'
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch21qa12q0a1)**'
- en: ''
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What does the abbreviation JSON stand for?
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JSON 的缩写是什么？
- en: '|  |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 21.6 answer**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 21.6 答案**'
- en: '**[1:](#ch21qa11q1)**'
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch21qa11q1)**'
- en: ''
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: JSON stands for JavaScript Object Notation.
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JSON 代表 JavaScript 对象表示法。
- en: '|  |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 21.7\. Customizing JSON with struct tags
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.7. 使用 struct 标签自定义 JSON
- en: Go’s `json` package requires that fields have an initial uppercase letter and
    multiword field names use *CamelCase* by convention. You may want JSON keys in
    *snake*_*case*, particularly when interoperating with Python or Ruby. The fields
    of a structure can be tagged with the field names you want the `json` package
    to use.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的 `json` 包要求字段以大写字母开头，并且多词字段名按照惯例使用 *CamelCase*。你可能希望 JSON 键使用 *snake*_*case*，尤其是在与
    Python 或 Ruby 交互时。结构体的字段可以用你希望 `json` 包使用的字段名进行标记。
- en: The only change from [listing 21.9](#ch21ex09) to [listing 21.10](#ch21ex10)
    is the inclusion of *struct tags* that alter the output of the `Marshal` function.
    Notice that the `Lat` and `Long` fields must still be exported for the `json`
    package to see them.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 从[列表 21.9](#ch21ex09)到[列表 21.10](#ch21ex10)的唯一变化是包含了改变`Marshal`函数输出的*struct
    标签*。注意，`Lat`和`Long`字段仍然必须导出，以便`json`包能够看到它们。
- en: 'Listing 21.10\. Customizing location fields: json-tags.go'
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 21.10. 自定义位置字段：json-tags.go
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* Struct tags alter the output.**'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Struct 标签改变了输出。**'
- en: '***2* Prints {“latitude”:-4.5895,“longitude”:137.4417}**'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 {“latitude”:-4.5895,“longitude”:137.4417}**'
- en: Struct tags are ordinary strings associated with the fields of a structure.
    Raw string literals (``) are preferable, because quotation marks don’t need to
    be escaped with a backslash, as in the less readable `"json:\"latitude\""`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Struct 标签是与结构体字段相关联的普通字符串。原始字符串字面量（``）更可取，因为引号不需要用反斜杠转义，就像在不太易读的`"json:"latitude\""`中那样。
- en: The struct tags are formatted as `key:"value"`, where the key tends to be the
    name of a package. To customize the `Lat` field for both JSON and XML, the struct
    tag would be ``json:"latitude" xml:"latitude"``.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Struct 标签的格式为`key:"value"`，其中键通常是包的名称。为了同时自定义 JSON 和 XML 中的`Lat`字段，struct 标签将是`json:"latitude"
    xml:"latitude"`。
- en: As the name implies, struct tags are only for the fields of structures, though
    `json.Marshal` will encode other types.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，struct 标签仅用于结构体的字段，尽管 `json.Marshal` 也会编码其他类型。
- en: '|  |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 21.7**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 21.7**'
- en: '**[Q1:](#ch21qa14q0a1)**'
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch21qa14q0a1)**'
- en: ''
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why must the `Lat` and `Long` fields begin with an uppercase letter when encoding
    JSON?
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么在编码 JSON 时`Lat`和`Long`字段必须以大写字母开头？
- en: '|  |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 21.7 answer**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 21.7 答案**'
- en: '**[1:](#ch21qa13q1)**'
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch21qa13q1)**'
- en: ''
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fields must be exported for the `json` package to see them.
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 字段必须导出，以便 `json` 包能够看到它们。
- en: '|  |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Structures group values together into one unit.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构将值组合成一个单元。
- en: Structures are values that are copied when assigned or passed to functions.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体是当分配或传递给函数时复制的值。
- en: Composite literals provide a convenient means to initialize structures.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复合字面量提供了一种方便的方式来初始化结构体。
- en: Struct tags decorate exported fields with additional information that packages
    can use.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Struct 标签用额外的信息装饰导出字段，这些信息可以被包使用。
- en: The `json` package utilizes struct tags to control the output of field names.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`json`包使用 struct 标签来控制字段名的输出。'
- en: Let’s see if you got this...
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否理解了...
- en: 'Experiment: landing.go'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实验：landing.go
- en: Write a program that displays the JSON encoding of the three rover landing sites
    in [listing 21.8](#ch21ex08). The JSON should include the name of each landing
    site and use struct tags as shown in [listing 21.10](#ch21ex10).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，显示 [列表 21.8](#ch21ex08) 中三个火星着陆点的 JSON 编码。JSON 应包括每个着陆点的名称，并使用如 [列表 21.10](#ch21ex10)
    所示的结构标签。
- en: To make the output friendlier, make use of the `MarshalIndent` function from
    the `json` package.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使输出更友好，请使用 `json` 包中的 `MarshalIndent` 函数。
- en: Lesson 22\. Go’s got no class
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 22 课\. Go 没有类
- en: After reading [lesson 22](#ch22), you’ll be able to
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读 [第 22 课](#ch22) 后，你将能够
- en: Write methods that provide behavior to structured data
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写提供结构化数据行为的方法
- en: Apply principles of object-oriented design
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用面向对象设计原则
- en: Go isn’t like classical languages. It has no classes and no objects, and it
    omits features like inheritance. Yet Go still provides what you need to apply
    ideas from object-oriented design. This lesson explores the combination of structures
    with methods.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语言与经典语言不同。它没有类和对象，并且省略了继承等特性。然而，Go 语言仍然提供了应用面向对象设计思想所需的功能。本节课探讨了结构与方法的结合。
- en: '|  |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: '*Synergy* is a buzzword commonly heard in entrepreneurial circles. It means
    “greater than the sum of its parts.” The Go language has types, methods on types,
    and structures. Together, these provide much of the functionality that classes
    do for other languages, without needing to introduce a new concept into the language.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*协同效应* 是在创业圈中经常听到的术语。它的意思是“大于其各部分的总和”。Go 语言有类型、类型上的方法和结构。三者结合，提供了类在其他语言中提供的许多功能，而不需要将新概念引入语言中。'
- en: What other aspects of Go exhibit this property of combining to create something
    greater?
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 有哪些其他方面的 Go 语言表现出这种结合以创造更伟大事物的特性？
- en: '|  |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 22.1\. Attaching methods to structures
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 22.1\. 将方法附加到结构体
- en: In [lesson 13](kindle_split_024.html#ch13), you attached `celsius` and `fahrenheit`
    methods to the `kelvin` type to convert temperatures. In the same way, methods
    can be attached to other types you declare. It works the same whether the underlying
    type is a `float64` or a `struct`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 13 课](kindle_split_024.html#ch13) 中，你将 `celsius` 和 `fahrenheit` 方法附加到 `kelvin`
    类型上以转换温度。同样，方法可以附加到你声明的其他类型上。无论底层类型是 `float64` 还是 `struct`，效果都是一样的。
- en: To start, you need to declare a type, such as the `coordinate` structure in
    the following listing.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要声明一个类型，例如以下列表中的 `coordinate` 结构体。
- en: 'Listing 22.1\. The `coordinate` type: coordinate.go'
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 22.1\. `coordinate` 类型：coordinate.go
- en: '[PRE13]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Bradbury Landing is located at 4°35’22.2” S, 137°26’30.1” E in DMS format (degrees,
    minutes, seconds). There are 60 seconds (`"`) in one minute, and 60 minutes (`'`)
    in one degree, but these minutes and seconds represent a location, not a time.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 布拉德利着陆点位于 DMS 格式（度、分、秒）中的 4°35’22.2” S，137°26’30.1” E。一分钟有 60 秒 (`"`)，一度有 60
    分钟 (`'`)，但这些分钟和秒代表的是一个位置，而不是时间。
- en: The decimal method in the following listing will convert a DMS coordinate to
    decimal degrees.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表中的十进制方法将把 DMS 坐标转换为十进制度。
- en: 'Listing 22.2\. The decimal method: coordinate.go'
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 22.2\. 十进制方法：coordinate.go
- en: '[PRE14]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now you can provide coordinates in the friendly DMS format and convert them
    to decimal degrees to perform calculations:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用友好的 DMS 格式提供坐标，并将它们转换为十进制度以进行计算：
- en: '[PRE15]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* Prints -4.5895 137.4417**'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 -4.5895 137.4417**'
- en: '|  |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 22.1**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 22.1**'
- en: '**[Q1:](#ch22qa2q0a1)**'
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch22qa2q0a1)**'
- en: ''
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the receiver for the decimal method in [listing 22.2](#ch22ex02)?
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[十进制方法中的接收器是什么？](#ch22ex02)'
- en: '|  |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 22.1 answer**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 22.1 答案**'
- en: '**[1:](#ch22qa1q1)**'
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch22qa1q1)**'
- en: ''
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The receiver is `c` of type `coordinate`.
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 接收器是 `c`，类型为 `coordinate`。
- en: '|  |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 22.2\. Constructor functions
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 22.2\. 构造函数
- en: 'To construct a decimal degrees location from degrees, minutes, and seconds,
    you can use the decimal method from [listing 22.2](#ch22ex02) with a composite
    literal:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要从度、分、秒构建十进制度数的位置，可以使用 [列表 22.2](#ch22ex02) 中的十进制方法与复合字面量：
- en: '[PRE16]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you need a composite literal that’s anything more than a list of values,
    consider writing a constructor function. The following listing declares a constructor
    function named `newLocation`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要一个比值列表更复杂的复合字面量，请考虑编写一个构造函数。以下列表声明了一个名为 `newLocation` 的构造函数。
- en: 'Listing 22.3\. Construct a new location: construct.go'
  id: totrans-225
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 22.3\. 构建新位置：construct.go
- en: '[PRE17]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Classical languages provide constructors as a special language feature to construct
    objects. Python has `_init_`, Ruby has `initialize`, and PHP has `__construct()`.
    Go doesn’t have a language feature for constructors. Instead `newLocation` is
    an ordinary function with a name that follows a convention.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 古典语言提供构造器作为特殊语言特性来构建对象。Python有`_init_`，Ruby有`initialize`，PHP有`__construct()`。Go没有构造器的语言特性。相反，`newLocation`是一个遵循约定的普通函数。
- en: '![](f0173-01.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](f0173-01.jpg)'
- en: 'Functions in the form `newType` or `NewType` are used to construct a value
    of said type. Whether you name it `newLocation` or `NewLocation` depends on whether
    the function is exported for other packages to use, as covered in [lesson 12](kindle_split_023.html#ch12).
    You use `newLocation` like any other function:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 形式为`newType`或`NewType`的函数用于构建该类型的值。你将其命名为`newLocation`还是`NewLocation`取决于该函数是否导出以供其他包使用，如第12课所述。你像使用任何其他函数一样使用`newLocation`：
- en: '[PRE18]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* Prints {-4.5895 137.4417}**'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 {-4.5895 137.4417}**'
- en: If you want to construct locations from a variety of inputs, just declare multiple
    functions with suitable names—perhaps `newLocationDMS` and `newLocationDD` for
    degrees, minutes, and seconds and decimal degrees, respectively.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要从各种输入中构建位置，只需声明多个具有合适名称的函数——例如，对于度、分、秒和十进制度，可以分别命名为`newLocationDMS`和`newLocationDD`。
- en: '|  |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Sometimes constructor functions are named `New`, as is the case with the `New`
    function in the `errors` package. Because function calls are prefixed with the
    package they belong to, naming the function `NewError` would be read as `errors.NewError`
    rather than the more concise and preferable `errors.New`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 有时构造函数命名为`New`，例如`errors`包中的`New`函数。因为函数调用以所属包为前缀，所以将函数命名为`NewError`会被读作`errors.NewError`，而不是更简洁、更可取的`errors.New`。
- en: '|  |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 22.2**'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 22.2**'
- en: '**[Q1:](#ch22qa4q0a1)**'
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch22qa4q0a1)**'
- en: ''
  id: totrans-240
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What would you name a function that constructs a variable of type `Universe`?
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你会给一个构建类型为`Universe`的变量的函数起什么名字？
- en: '|  |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 22.2 answer**'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 22.2 答案**'
- en: '**[1:](#ch22qa3q1)**'
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch22qa3q1)**'
- en: ''
  id: totrans-246
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: By convention the function would be named `NewUniverse`, or `newUniverse` if
    not exported.
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 按照惯例，函数会被命名为`NewUniverse`，或者如果不导出，则为`newUniverse`。
- en: '|  |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 22.3\. The class alternative
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 22.3. 类的替代方案
- en: Go doesn’t have the `class` of classical languages like Python, Ruby, and Java.
    Yet a structure with a few methods fulfills much of the same purpose. If you squint,
    they aren’t that different.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Go没有像Python、Ruby和Java这样的经典语言的`class`。然而，具有少量方法的结构可以完成许多相同的目的。如果你眯着眼睛看，它们并没有那么不同。
- en: To drive the point home, build a whole new `world` type from the ground up.
    It will have a field for the radius of the planet, which you’ll use to calculate
    the distance between two locations, as shown in the following listing.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强调这一点，从头开始构建一个新的`world`类型。它将有一个表示行星半径的字段，你将使用它来计算两个位置之间的距离，如下所示。
- en: 'Listing 22.4\. A whole new `world`: world.go'
  id: totrans-252
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 22.4. 一个全新的`world`：world.go
- en: '[PRE19]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Mars has a volumetric mean radius of 3,389.5 kilometers. Rather than declare
    3389.5 as a constant, use the `world` type to declare Mars as one of many possible
    worlds:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 火星的平均半径为3,389.5千米。与其将3389.5声明为一个常量，不如使用`world`类型将火星声明为许多可能的世界之一：
- en: '[PRE20]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then a `distance` method is attached to the `world` type, giving it access
    to the `radius` field. It accepts two parameters, both of type `location`, and
    will return a distance in kilometers:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将一个`distance`方法附加到`world`类型上，使其能够访问`radius`字段。它接受两个参数，都是`location`类型，并将返回千米距离：
- en: '[PRE21]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***1* To-do: some math using w.radius**'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 待办事项：使用w.radius进行一些数学运算**'
- en: 'This is going to involve some math, so be sure to import the `math` package,
    as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这将涉及一些数学运算，所以请确保导入`math`包，如下所示：
- en: '[PRE22]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The location type uses degrees for latitude and longitude, but the math functions
    in the standard library use radians. Given that a circle has 360° or 2π radians,
    the following function performs the necessary conversion:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 位置类型使用度来表示纬度和经度，但标准库中的数学函数使用弧度。鉴于一个圆有360°或2π弧度，以下函数执行必要的转换：
- en: '[PRE23]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now for the distance calculation. It uses a number of trigonometric functions
    including sine, cosine, and arccosine. If you’re a math geek, you can look up
    the formulas ([www.movable-type.co.uk/scripts/latlong.html](http://www.movable-type.co.uk/scripts/latlong.html))
    and research the Spherical Law of Cosines to understand how this works. Mars isn’t
    a perfect sphere, but this formula achieves a “good enough” approximation for
    our purposes:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进行距离计算。它使用包括正弦、余弦和反余弦在内的多个三角函数。如果你是数学爱好者，可以查找公式 ([www.movable-type.co.uk/scripts/latlong.html](http://www.movable-type.co.uk/scripts/latlong.html))
    并研究余弦定理来了解它是如何工作的。火星不是一个完美的球体，但这个公式在我们的目的上已经足够接近了：
- en: '[PRE24]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1* Uses the world’s radius field**'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用世界的半径字段**'
- en: If your eyes just glazed over, don’t worry. The math is needed in a program
    that calculates distance, but as long as `distance` returns the correct results,
    fully understanding how all the math works is optional (though a good idea).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感到困惑，不要担心。计算距离的程序需要数学，但只要 `distance` 返回正确的结果，完全理解所有数学工作是如何进行的就不是必须的（尽管这是一个好主意）。
- en: 'Speaking of results, to see `distance` in action, declare some locations and
    use the `mars` variable declared earlier:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 说到结果，要看到 `distance` 的实际应用，声明一些位置并使用之前声明的 `mars` 变量：
- en: '[PRE25]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '***1* Uses the distance method on mars**'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在火星上使用距离方法**'
- en: '***2* Prints 9669.71 km**'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 9669.71 公里**'
- en: If you get a different result, go back to ensure the code is typed exactly as
    shown. One missing `rad` will result in incorrect calculations. If all else fails,
    download the code from [github.com/nathany/get-programming-with-go](http://github.com/nathany/get-programming-with-go)
    and resign yourself to copy and paste.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你得到不同的结果，请返回并确保代码的输入与显示的完全一致。缺少一个 `rad` 将导致计算错误。如果所有其他方法都失败了，请从 [github.com/nathany/get-programming-with-go](http://github.com/nathany/get-programming-with-go)
    下载代码，并接受复制粘贴。
- en: The `distance` method was adopted from formulas for Earth, but using the radius
    of Mars. By declaring `distance` as a method on the `world` type, you can calculate
    distance for other worlds, such as Earth. The radius for each planet is found
    in [table 22.2](#ch22table02), as provided by the Planetary Fact Sheet ([nssdc.gsfc.nasa.gov/planetary/factsheet/](http://nssdc.gsfc.nasa.gov/planetary/factsheet/))
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`distance` 方法是从地球的公式中采用的，但使用的是火星的半径。通过在 `world` 类型上声明 `distance` 为一个方法，你可以计算其他世界的距离，例如地球。每个行星的半径可以在
    [表22.2](#ch22table02) 中找到，如行星事实表([nssdc.gsfc.nasa.gov/planetary/factsheet/](http://nssdc.gsfc.nasa.gov/planetary/factsheet/))所提供。'
- en: '|  |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 22.3**'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查22.3**'
- en: '**[Q1:](#ch22qa6q0a1)**'
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch22qa6q0a1)**'
- en: ''
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How is it beneficial to declare a distance method on the `world` type compared
    to a less object-oriented approach?
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与更面向对象的方法相比，在 `world` 类型上声明距离方法有什么好处？
- en: '|  |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 22.3 answer**'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 22.3 答案**'
- en: '**[1:](#ch22qa5q1)**'
  id: totrans-281
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch22qa5q1)**'
- en: ''
  id: totrans-282
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It provides a clean way to calculate distance for different worlds, and there’s
    no need to pass the volumetric mean radius into the distance method, because it
    already has access to `w.radius`.
  id: totrans-283
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它提供了一种干净的方式来计算不同世界的距离，并且不需要将体积平均半径传递给距离方法，因为它已经可以访问 `w.radius`。
- en: '|  |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Combining methods and structures provides much of what classical languages provide
    without introducing a new language feature.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合方法和结构提供了经典语言提供的大部分功能，而不引入新的语言特性。
- en: Constructor functions are ordinary functions.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数是普通函数。
- en: Let’s see if you got this...
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否掌握了这个...
- en: 'Experiment: landing.go'
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实验：landing.go
- en: Use the code from [listings 22.1](#ch22ex01), [22.2](#ch22ex02), and [22.3](#ch22ex03)
    to write a program that declares a `location` for each location in [table 22.1](#ch22table01).
    Print out each of the locations in decimal degrees.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [列表22.1](#ch22ex01)，[22.2](#ch22ex02)，和 [22.3](#ch22ex03) 中的代码编写一个程序，为 [表22.1](#ch22table01)
    中的每个位置声明一个 `location`。以十进制度数打印出每个位置。
- en: 'Experiment: distance.go'
  id: totrans-291
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实验：distance.go
- en: Use the `distance` method from [listing 22.4](#ch22ex04) to write a program
    that determines the distance between each pair of landing sites in [table 22.1](#ch22table01).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [列表22.4](#ch22ex04) 中的 `distance` 方法编写一个程序，确定 [表22.1](#ch22table01) 中每对着陆点之间的距离。
- en: Which two landing sites are the closest?
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 哪两个着陆点是最近的？
- en: Which two are farthest apart?
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 哪两个位置相距最远？
- en: 'To determine the distance between the following locations, you’ll need to declare
    other worlds based on [table 22.2](#ch22table02):'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定以下位置之间的距离，你需要根据 [表22.2](#ch22table02) 声明其他世界：
- en: Find the distance from London, England (51°30’N 0°08’W) to Paris, France (48°51’N
    2°21’E).
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找出从英国伦敦（51°30’N 0°08’W）到法国巴黎（48°51’N 2°21’E）的距离。
- en: Find the distance from your city to the capital of your country.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找您所在城市到您国家首都的距离。
- en: Find the distance between Mount Sharp (5°4’ 48”S, 137°51’E) and Olympus Mons
    (18°39’N, 226°12’E) on Mars.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找火星上夏普山（5°4’ 48”S, 137°51’E）和奥林匹斯山（18°39’N, 226°12’E）之间的距离。
- en: Table 22.1\. Landing sites on Mars
  id: totrans-299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表22.1. 火星着陆点
- en: '| Rover or lander | Landing site | Latitude | Longitude |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| 探测器或着陆器 | 着陆点 | 纬度 | 经度 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Spirit | Columbia Memorial Station | 14°34’6.2” S | 175°28’21.5” E |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| 精神号 | 哥伦比亚纪念站 | 14°34’6.2” S | 175°28’21.5” E |'
- en: '| Opportunity | Challenger Memorial Station | 1°56’46.3” S | 354°28’24.2” E
    |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| 机遇号 | 挑战者纪念站 | 1°56’46.3” S | 354°28’24.2” E |'
- en: '| Curiosity | Bradbury Landing | 4°35’22.2” S | 137°26’30.1” E |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| 好奇号 | 布拉德利着陆点 | 4°35’22.2” S | 137°26’30.1” E |'
- en: '| InSight | Elysium Planitia | 4°30’0.0” N | 135°54’0” E |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| 印象号 | 爱丽斯平原 | 4°30’0.0” N | 135°54’0” E |'
- en: Table 22.2\. The volumetric mean radius of various planets
  id: totrans-306
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表22.2. 各种行星的体积平均半径
- en: '| Planet | Radius (km) |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| 行星 | 半径（km） |'
- en: '| --- | --- |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Mercury | 2439.7 |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| 水星 | 2439.7 |'
- en: '| Venus | 6051.8 |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| 金星 | 6051.8 |'
- en: '| Earth | 6371.0 |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| 地球 | 6371.0 |'
- en: '| Mars | 3389.5 |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| 火星 | 3389.5 |'
- en: '| Jupiter | 69911 |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| 木星 | 69911 |'
- en: '| Saturn | 58232 |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| 土星 | 58232 |'
- en: '| Uranus | 25362 |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| 天王星 | 25362 |'
- en: '| Neptune | 24622 |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| 海王星 | 24622 |'
- en: Lesson 23\. Composition and forwarding
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第23课。组合和转发
- en: After reading [lesson 23](#ch23), you’ll be able to
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读第23课[后](#ch23)，您将能够
- en: Compose structures with composition
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用组合组合结构
- en: Forward methods to other methods
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将方法转发到其他方法
- en: Forget about classical inheritance
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忘记经典继承
- en: When you look around the world, everything you see is made up of smaller parts.
    People tend to have bodies with limbs, which in turn have fingers or toes. Flowers
    have petals and stems. Mars Rovers have wheels and treads and entire subsystems,
    like the Rover Environmental Monitoring Station (REMS). Each part plays its role.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 当你环顾四周的世界时，你所看到的一切都是由更小的部分组成的。人们倾向于有带有四肢的身体，四肢又依次有手指或脚趾。花朵有花瓣和花茎。火星探测器有轮子和履带，以及整个子系统，如火星探测器环境监测站（REMS）。每个部分都扮演着它的角色。
- en: In the world of object-oriented programming, objects are *composed of* smaller
    objects in the same way. Computer scientists call this *object composition* or
    simply *composition*.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的编程世界中，对象以相同的方式由更小的对象组成。计算机科学家称之为 *对象组合* 或简单地称为 *组合*。
- en: Gophers use composition with structures, and Go provides a special language
    feature called *embedding* to forward methods. This lesson demonstrates composition
    and embedding with a fictional weather report from REMS.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 仓鼠使用结构组合，Go 提供了一种称为 *嵌入* 的特殊语言特性来转发方法。本课通过 REMS 的虚构天气报告演示了组合和嵌入。
- en: '![](f0178-01_alt.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](f0178-01_alt.jpg)'
- en: '|  |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: Designing hierarchies can be difficult. A hierarchy of the animal kingdom would
    attempt to group animals with the same behaviors. Some mammals walk on land while
    others swim, yet blue whales also nurse their young. How would you organize them?
    It can be difficult to change hierarchies too, as even a small change can have
    a wide impact.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 设计层次结构可能很困难。动物王国的层次结构试图将具有相同行为的动物分组。一些哺乳动物在陆地上行走，而另一些则游泳，但蓝鲸也会哺乳幼崽。如何组织它们？改变层次结构也可能很困难，因为即使是微小的变化也可能产生广泛的影响。
- en: 'Composition is a far simpler and more flexible approach: implement walking,
    swimming, nursing, and other behaviors and associate the appropriate ones with
    each animal.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 组合是一种更简单、更灵活的方法：实现行走、游泳、哺乳和其他行为，并将适当的与每种动物关联。
- en: As a bonus, if you design a robot, the walking behavior can be reused.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外奖励，如果您设计一个机器人，行走行为可以被重用。
- en: '|  |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 23.1\. Composing structures
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.1. 组合结构
- en: A weather report includes a variety of data, such as the high and low temperatures,
    current day (sol), and location. A naive solution is to define all the necessary
    fields in a single `report` structure like the following listing.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 天气报告包括各种数据，例如最高和最低温度、当前日（日），以及位置。一个简单的解决方案是在单个 `report` 结构中定义所有必要的字段，如下面的列表所示。
- en: 'Listing 23.1\. Without composition: unorganized.go'
  id: totrans-334
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表23.1. 没有组合：unorganized.go
- en: '[PRE26]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Looking at [listing 23.1](#ch23ex01), `report` is a mix of disparate data. It
    gets unwieldy when the report grows to include even more data, such as wind speed
    and direction, pressure, humidity, season, sunrise, and sunset.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 查看第23.1节中的[列表23.1](#ch23ex01)，`report` 是由不同数据混合而成的。当报告增长到包括更多数据，例如风速和风向、气压、湿度、季节、日出和日落时，它就会变得难以操控。
- en: Fortunately you can group related fields together with structures and composition.
    The following listing defines a `report` structure composed of structures for
    temperature and location.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你可以通过结构体和组合将相关字段分组在一起。以下列表定义了一个由温度和位置结构体组成的 `report` 结构体。
- en: 'Listing 23.2\. Structs inside of structs: compose.go'
  id: totrans-338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 23.2\. 结构体内部的结构：compose.go
- en: '[PRE27]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1* The temperature field is a structure of type temperature.**'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 温度字段是温度类型的结构体。**'
- en: 'With these types defined, a weather report is built up from location and temperature
    data as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了这些类型后，天气报告是通过以下方式构建的，即从位置和温度数据中构建：
- en: '[PRE28]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '***1* Prints {sol:15 temperature:{high:-1 low:-78} location:{lat:-4.5895 long:137.4417}}**'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 {sol:15 temperature:{high:-1 low:-78} location:{lat:-4.5895 long:137.4417}}**'
- en: '***2* Prints a balmy -1° C**'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印温暖 -1° C**'
- en: Take another look at [listing 23.2](#ch23ex02). Notice that `high` and `low`
    clearly refer to temperatures, whereas the same fields in [listing 23.1](#ch23ex01)
    are ambiguous.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 再看看 [列表 23.2](#ch23ex02)。注意，`high` 和 `low` 明确指的是温度，而 [列表 23.1](#ch23ex01) 中的相同字段则是不明确的。
- en: By building a weather report out of smaller types, you can further organize
    your code by hanging methods from each type. For example, to calculate the average
    temperature, you can write a method like the one shown in the next listing.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将天气报告构建为较小类型，你可以通过在每个类型上挂载方法来进一步组织你的代码。例如，为了计算平均温度，你可以编写如下列表中所示的方法。
- en: 'Listing 23.3\. An average method: average.go'
  id: totrans-347
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 23.3\. 一种平均方法：average.go
- en: '[PRE29]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The temperature type and average method can be used independently of the weather
    report as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 温度类型和平均方法可以独立于天气报告使用，如下所示：
- en: '[PRE30]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '***1* Prints average -39.5° C**'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印平均 -39.5° C**'
- en: 'When you create a weather report, the average method is accessible by chaining
    off the temperature field:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个天气报告时，平均方法可以通过链式调用温度字段来访问：
- en: '[PRE31]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '***1* Prints average -39.5° C**'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印平均 -39.5° C**'
- en: 'If you want to expose the average temperature directly through the `report`
    type, there’s no need to duplicate the logic in [listing 23.3](#ch23ex03). Write
    a method that forwards to the real implementation instead:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要通过 `report` 类型直接暴露平均温度，就没有必要在 [列表 23.3](#ch23ex03) 中重复逻辑。写一个将前向到实际实现的方法：
- en: '[PRE32]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With a method to forward from report to temperature, you gain convenient access
    to `report.average()` while still structuring your code around smaller types.
    The remainder of this lesson examines a Go feature that promises to make method
    forwarding effortless.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 使用从报告到温度的前向方法，你可以在围绕较小类型结构代码的同时方便地访问 `report.average()`。本节课的剩余部分将探讨一个承诺使方法前向无懈可击的
    Go 特性。
- en: '|  |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 23.1**'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 23.1**'
- en: '**[Q1:](#ch23qa2q0a1)**'
  id: totrans-360
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch23qa2q0a1)**'
- en: ''
  id: totrans-361
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Compare [listings 23.1](#ch23ex01) to [23.2](#ch23ex02). Which code do you prefer
    and why?
  id: totrans-362
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将 [列表 23.1](#ch23ex01) 与 [23.2](#ch23ex02) 进行比较。你更喜欢哪种代码，为什么？
- en: '|  |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 23.1 answer**'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 23.1 答案**'
- en: '**[1:](#ch23qa1q1)**'
  id: totrans-366
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch23qa1q1)**'
- en: ''
  id: totrans-367
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The structures in [listing 23.2](#ch23ex02) are more organized, by splitting
    out temperatures and locations into separate reusable structures.
  id: totrans-368
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[列表 23.2](#ch23ex02) 中的结构体组织得更好，通过将温度和位置拆分到单独的可重用结构体中。'
- en: '|  |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 23.2\. Forwarding methods
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.2\. 前向方法
- en: Method forwarding can make it more convenient to use the methods. Imagine asking
    Curiosity the weather on Mars. It could *forward* your request to the REMS system,
    which in turn would forward your request to a thermometer to determine the air
    temperature. With forwarding, you don’t need to know the path to the method—you
    just ask Curiosity.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 方法前向可以使使用方法更加方便。想象一下询问好奇号火星上的天气。它可以将你的请求 *前向* 到 REMS 系统，然后该系统再将你的请求前向到温度计以确定空气温度。有了前向，你不需要知道方法的路径——你只需询问好奇号。
- en: What isn’t so convenient is manually writing methods to forward from one type
    to another like in [listing 23.3](#ch23ex03). Such repetitive code, called *boilerplate*,
    adds nothing but clutter.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 不太方便的是手动编写像 [列表 23.3](#ch23ex03) 中的从一种类型到另一种类型的前向方法。这种重复的代码，称为 *样板代码*，除了增加混乱之外，没有任何帮助。
- en: Fortunately, Go will do method forwarding for you with *struct embedding*. To
    embed a type in a structure, specify the type without a field name, as shown in
    the following listing.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Go 会为你使用 *结构体嵌入* 进行方法前向。要在结构体中嵌入一个类型，指定类型而不指定字段名，如下面的列表所示。
- en: 'Listing 23.4\. Struct embedding: embed.go'
  id: totrans-374
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 23.4\. 结构体嵌入：embed.go
- en: '[PRE33]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1* A temperature type embedded into report**'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 报告中嵌入的温度类型**'
- en: 'All the methods on the `temperature` type are automatically made accessible
    through the `report` type:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 所有在 `temperature` 类型上的方法都会自动通过 `report` 类型变得可访问：
- en: '[PRE34]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '***1* Prints average -39.5° C**'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印平均 -39.5° C**'
- en: 'Though no field name was specified, a field still exists with the same name
    as the embedded type. You can access the `temperature` field as follows:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有指定字段名，但仍然存在一个与嵌入类型同名字段。你可以如下访问 `temperature` 字段：
- en: '[PRE35]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '***1* Prints average -39.5° C**'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印平均 -39.5° C**'
- en: 'Embedding doesn’t only forward methods. Fields of an inner structure are accessible
    from the outer structure. In addition to `report.temperature.high`, you can access
    the high temperature with `report.high` as follows:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入不仅转发方法。内部结构的字段可以从外部结构体访问。除了 `report.temperature.high`，你还可以如下使用 `report.high`
    访问高温：
- en: '[PRE36]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '***1* Prints -1° C**'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 -1° C**'
- en: '***2* Prints 32° C**'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 32° C**'
- en: As you can see, changes to the `report.high` field are reflected in `report.temperature.high`.
    It’s just another way to access the same data.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`report.high` 字段的更改反映在 `report.temperature.high` 上。这只是访问相同数据的另一种方式。
- en: You can embed any type in a structure, not just structures. In the following
    listing, the `sol` type has an underlying type of `int`, yet it’s embedded just
    like the `location` and `temperature` structures.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在结构体中嵌入任何类型，而不仅仅是结构体。在下面的列表中，`sol` 类型有一个基础类型为 `int`，但它就像 `location` 和 `temperature`
    结构体一样被嵌入。
- en: 'Listing 23.5\. Embedding other types: sol.go'
  id: totrans-389
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 23.5\. 嵌入其他类型：sol.go
- en: '[PRE37]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Any methods declared on the `sol` type can be accessed through the `sol` field
    or through the `report` type:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 声明在 `sol` 类型上的任何方法都可以通过 `sol` 字段或通过 `report` 类型访问：
- en: '[PRE38]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '***1* Prints 1431**'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 1431**'
- en: '|  |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 23.2**'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 23.2**'
- en: '**[1](#ch23qa4q0a1)**'
  id: totrans-396
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch23qa4q0a1)**'
- en: ''
  id: totrans-397
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which types can be embedded into a structure?
  id: totrans-398
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 哪些类型可以被嵌入到结构体中？
- en: '**[2](#ch23qa4q0a2)**'
  id: totrans-399
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch23qa4q0a2)**'
- en: ''
  id: totrans-400
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Is `report.lat` valid? If so, which field does it refer to in [listing 23.4](#ch23ex04)?
  id: totrans-401
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`report.lat` 是否有效？如果是，它在 [列表 23.4](#ch23ex04) 中引用的是哪个字段？'
- en: '|  |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 23.2 answer**'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 23.2 答案**'
- en: '**[1](#ch23qa3q1)**'
  id: totrans-405
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch23qa3q1)**'
- en: ''
  id: totrans-406
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Any type can be embedded into a structure.
  id: totrans-407
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 任何类型都可以被嵌入到结构体中。
- en: '**[2](#ch23qa3q2)**'
  id: totrans-408
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch23qa3q2)**'
- en: ''
  id: totrans-409
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Yes, `report.lat` is equivalent to `report.location.lat`.
  id: totrans-410
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 是的，`report.lat` 等同于 `report.location.lat`。
- en: '|  |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 23.3\. Name collisions
  id: totrans-412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.3\. 名称冲突
- en: The weather report works fine. Then someone wants to know the number of days
    it takes for a rover to travel between two locations. The Curiosity rover drives
    approximately 200 meters per day, so you add a `days` method to the location type
    to do the math, as shown in the next listing.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 天气报告工作正常。然后有人想知道一辆漫游车在两个位置之间旅行需要多少天。好奇号漫游车每天大约行驶200米，所以你向位置类型添加一个 `days` 方法来进行计算，如下面的列表所示。
- en: 'Listing 23.6\. Another method with the same name: collision.go'
  id: totrans-414
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 23.6\. 同名方法：collision.go
- en: '[PRE39]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '***1* See [lesson 22](kindle_split_035.html#ch22).**'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 见 [课程 22](kindle_split_035.html#ch22)。**'
- en: The `report` structure embeds both `sol` and `location`, two types with a method
    named `days`.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`report` 结构体嵌入 `sol` 和 `location`，这两个类型都有一个名为 `days` 的方法。'
- en: The good news is that if none of your code is using the `days` method on a `report`,
    everything continues to work fine. The Go compiler is smart enough to only point
    out a name collision if it’s a problem.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，如果你的代码中没有使用 `report` 上的 `days` 方法，一切都会继续正常工作。Go 编译器足够智能，只有在有问题时才会指出名称冲突。
- en: 'If the `days` method on the `report` type is being used, the Go compiler doesn’t
    know if it should forward the call to the method on `sol` or the method on `location`,
    so it reports an error:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正在使用 `report` 类型上的 `days` 方法，Go 编译器不知道是否应该将调用转发到 `sol` 上的方法还是 `location` 上的方法，因此它会报告一个错误：
- en: '[PRE40]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '***1* Ambiguous selector report.days**'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 模糊选择器 report.days**'
- en: 'Resolving an *ambiguous selector* error is straightforward. If you implement
    the `days` method on the `report` type, it will take precedence over the `days`
    methods from the embedded types. You can manually forward to the embedded type
    of your choosing or perform some other behavior:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 解决一个 *模糊选择器* 错误很简单。如果你在 `report` 类型上实现了 `days` 方法，它将优先于嵌入类型的 `days` 方法。你可以手动转发到你选择的嵌入类型，或者执行其他行为：
- en: '[PRE41]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '|  |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**This isn’t the inheritance you were looking for**'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '**这不是你想要的继承**'
- en: Classical languages like C++, Java, PHP, Python, Ruby, and Swift can use composition,
    but they also supply a language feature called inheritance.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 C++、Java、PHP、Python、Ruby 和 Swift 这样的经典语言可以使用组合，但它们也提供了一种称为继承的语言特性。
- en: Inheritance is a different way of thinking about designing software. With *inheritance*,
    a rover is a type of vehicle and thereby *inherits* the functionality that all
    vehicles share. With composition, a rover has an engine and wheels and various
    other parts that provide the functionality a rover needs. A truck may reuse several
    of those parts, but there is no vehicle type or hierarchy descending from it.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是思考软件设计的一种不同方式。使用 *继承*，漫游车是一种车辆类型，因此 *继承* 了所有车辆共享的功能。使用组合，漫游车有一个引擎和轮子以及各种其他部件，这些部件提供了漫游车所需的功能。卡车可以重用其中的一些部件，但没有任何车辆类型或层次结构从它派生出来。
- en: 'Composition is generally considered more flexible, allowing greater reuse and
    easier changes than software built with inheritance. This isn’t a new revelation,
    either—this wisdom was published in 1994:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 组合通常被认为比使用继承构建的软件更灵活，允许更大的重用和更易于更改。这也不是一个新发现——这种智慧在 1994 年就已经发表了：
- en: '*Favor object composition over class inheritance.*'
  id: totrans-429
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*优先使用对象组合而不是类继承。*'
- en: ''
  id: totrans-430
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Gang of Four, *Design Patterns: Elements of Reusable Object-Oriented Software**'
  id: totrans-431
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*四人帮*，《设计模式：可重用面向对象软件元素》'
- en: When people first see embedding, some initially think that it’s the same as
    inheritance, but it’s not. Not only is it a different way of thinking about software
    design, there’s a subtle technical difference.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们第一次看到嵌入时，有些人最初认为它与继承相同，但实际上并非如此。这不仅是一种不同的思考软件设计的方式，还存在一个微妙的技术差异。
- en: 'The receiver of `average()` in [listing 23.3](#ch23ex03) is always of type
    `temperature`, even when forwarded through `report`. With *delegation* or inheritance,
    the receiver could be of type `report`, but Go has neither delegation nor inheritance.
    That’s okay, though, because inheritance isn’t needed:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 23.3](#ch23ex03) 中的 `average()` 的接收者始终是 `temperature` 类型，即使通过 `report`
    转发也是如此。使用 *委托* 或继承，接收者可以是 `report` 类型，但 Go 既没有委托也没有继承。不过，这没关系，因为继承不是必需的：
- en: '*Use of classical inheritance is always optional; every problem that it solves
    can be solved another way.*'
  id: totrans-434
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*使用经典继承始终是可选的；它解决的问题都可以用其他方式解决。*'
- en: ''
  id: totrans-435
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Sandi Metz, *Practical Object-Oriented Design in Ruby**'
  id: totrans-436
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Sandi Metz*，《Ruby 实用面向对象设计》'
- en: Go is an independent new language that’s able to shed the weight of antiquated
    paradigms, and so it does.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: Go 是一种独立的新语言，能够摆脱过时的范式，因此它做到了。
- en: '|  |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 23.3**'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 23.3**'
- en: '**[Q1:](#ch23qa6q0a1)**'
  id: totrans-441
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch23qa6q0a1)**'
- en: ''
  id: totrans-442
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If multiple embedded types implement a method of the same name, does the Go
    compiler report an error?
  id: totrans-443
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果多个嵌入类型实现了同名方法，Go 编译器是否会报告错误？
- en: '|  |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 23.3 answer**'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 23.3 答案**'
- en: '**[1:](#ch23qa5q1)**'
  id: totrans-447
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch23qa5q1)**'
- en: ''
  id: totrans-448
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Go compiler only reports an error if the method is being used.
  id: totrans-449
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Go 编译器只有在方法被使用时才会报告错误。
- en: '|  |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-451
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Composition is a technique of breaking large structures down into small structures
    and putting them together.
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合是将大型结构分解成小型结构并将它们组合起来的技术。
- en: Embedding gives access to the fields of inner structures in the outer structure.
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入允许外部结构访问内部结构的字段。
- en: Methods are automatically forwarded when you embed types in a structure.
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你在结构中嵌入类型时，方法会自动转发。
- en: Go will inform you of name collisions caused by embedding, but only if those
    methods are being used.
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 会通知你由嵌入引起的名称冲突，但只有当这些方法被使用时。
- en: Let’s see if you got this...
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否明白了……
- en: 'Experiment: gps.go'
  id: totrans-457
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实验：gps.go
- en: Write a program with a `gps` structure for a Global Positioning System (GPS).
    This `struct` should be composed of a current location, destination location,
    and a world.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个用于全球定位系统（GPS）的 `gps` 结构的程序。这个 `struct` 应该由当前位置、目的地位置和世界组成。
- en: Implement a `description` method for the `location` type that returns a string
    containing the name, latitude, and longitude. The `world` type should implement
    a distance method using the math from [lesson 22](kindle_split_035.html#ch22).
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 为 `location` 类型实现一个 `description` 方法，该方法返回一个包含名称、纬度和经度的字符串。`world` 类型应使用来自 [第
    22 课](kindle_split_035.html#ch22) 的数学实现距离方法。
- en: Attach two methods to the `gps` type. First, attach a `distance` method that
    finds the distance between the current and destination locations. Then implement
    a `message` method that returns a string describing how many kilometers remain
    to the destination.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个方法附加到 `gps` 类型。首先，附加一个 `distance` 方法，用于查找当前位置和目的地位置之间的距离。然后实现一个 `message`
    方法，返回一个字符串，描述剩余多少公里到达目的地。
- en: As a final step, create a `rover` structure that embeds the `gps` and write
    a `main` function to test everything out. Initialize a GPS for Mars with a current
    location of Bradbury Landing (-4.5895, 137.4417) and a destination of Elysium
    Planitia (4.5, 135.9). Then create a `curiosity` rover and print out its `message`
    (which forwards to the `gps`).
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，创建一个嵌入 `gps` 的 `rover` 结构体，并编写一个 `main` 函数来测试一切。初始化一个火星上的 GPS，当前位置为布拉德伯里着陆点
    (-4.5895, 137.4417)，目的地为伊里斯平原 (4.5, 135.9)。然后创建一个 `curiosity` 探索车，并打印出它的 `message`（这会转发到
    `gps`）。
- en: Lesson 24\. Interfaces
  id: totrans-462
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第24课\. 接口
- en: After reading [lesson 24](#ch24), you’ll be able to
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读了[第24课](#ch24)之后，你将能够
- en: Get your types talking
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让你的类型说话
- en: Discover interfaces as you go
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实践中发现接口
- en: Explore interfaces in the standard library
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在标准库中探索接口
- en: Save humanity from a Martian invasion
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从火星入侵中拯救人类
- en: Pen and paper aren’t the only tools you could use to jot down your latest insight.
    A nearby crayon and napkin can serve the purpose. Crayons, permanent markers,
    and mechanical pencils can all satisfy your need to write a reminder in a notepad,
    a slogan on construction paper, or an entry in a journal. Writing is very flexible.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 笔和纸并不是你用来记录最新洞察的唯一工具。附近的蜡笔和餐巾纸也可以起到作用。蜡笔、永久性记号笔和机械铅笔都可以满足你在便签本上写提醒、在建设纸上写标语或在日记中写条目的需求。写作非常灵活。
- en: The Go standard library has an *interface* for writing. It goes by the name
    of `Writer`, and with it you can write text, images, comma-separated values (CSV),
    compressed archives, and more. You can write to the screen, a file on disk, or
    a response to a web request. With the help of a single interface, Go can write
    any number of things to any number of places. `Writer` is very flexible.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: Go 标准库有一个用于书写的*接口*，名为 `Writer`。有了它，你可以写入文本、图像、逗号分隔值（CSV）、压缩存档等等。你可以将内容写入屏幕、磁盘上的文件或对网络请求的响应。借助单个接口，Go
    可以将任何数量的内容写入任何数量的地方。`Writer` 非常灵活。
- en: A 0.5 mm ballpoint pen with blue ink is a *concrete* thing, whereas a writing
    instrument is a fuzzier idea. With interfaces, code can express *abstract* concepts
    such as *a thing that writes*. Think of what something can do, rather than what
    it is. This way of thinking, as expressed through interfaces, will help your code
    to adapt to change.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 一支0.5毫米的蓝色墨水圆珠笔是一个*具体*的东西，而一支书写工具是一个更模糊的概念。使用接口，代码可以表达*抽象*概念，例如*一个会写字的东西*。想想它能做什么，而不是它是什么。这种思维方式，通过接口表达，将有助于你的代码适应变化。
- en: '|  |'
  id: totrans-471
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: What are some *concrete* things around you? What can you do with them? Can you
    do the same thing with something else? What is the common behavior or interface
    that they have?
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 你周围有哪些*具体*的东西？你能用它们做什么？你能用其他东西做同样的事情吗？它们有什么共同的行为或接口？
- en: '|  |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 24.1\. The interface type
  id: totrans-475
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 24.1\. 接口类型
- en: 'The majority of types focus on the values they store: integers for whole numbers,
    strings for text, and so on. The interface type is different. Interfaces are concerned
    with what a type can do, not the value it holds.'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数类型都关注它们存储的值：整数用于整数，字符串用于文本，等等。接口类型不同。接口关注的是类型能做什么，而不是它持有的值。
- en: Methods express the behavior a type provides, so interfaces are declared with
    a set of methods that a type must satisfy. The following listing declares a variable
    with an interface type.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 方法表达了类型提供的行为，因此接口是用一组类型必须满足的方法声明的。以下列表声明了一个接口类型的变量。
- en: 'Listing 24.1\. A set of methods: talk.go'
  id: totrans-478
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 24.1\. 一组方法：talk.go
- en: '[PRE42]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The variable `t` can hold any value of any type that *satisfies* the interface.
    More specifically, a type will satisfy the interface if it declares a method named
    `talk` that accepts no arguments and returns a string.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `t` 可以持有任何满足接口的任何类型的任何值。更具体地说，如果类型声明了一个名为 `talk` 的方法，该方法不接受任何参数并返回一个字符串，则该类型将满足接口。
- en: The following listing declares two types that meet these requirements.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表声明了两个满足这些要求的类型。
- en: 'Listing 24.2\. Satisfying an interface: talk.go'
  id: totrans-482
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 24.2\. 满足接口：talk.go
- en: '[PRE43]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Though `martian` is a structure with no fields and `laser` is an integer, both
    types provide a `talk` method and therefore can be assigned to `t`, as in the
    following listing.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `martian` 是一个没有字段的结构体，而 `laser` 是一个整数，但两种类型都提供了一个 `talk` 方法，因此可以将它们分配给 `t`，如下所示。
- en: 'Listing 24.3\. Polymorphism: talk.go'
  id: totrans-485
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 24.3\. 多态：talk.go
- en: '[PRE44]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '***1* Prints nack nack**'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 nack nack**'
- en: '***2* Prints pew pew pew**'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 pew pew pew**'
- en: The shape-shifting variable `t` is able to take the form of a `martian` or `laser`.
    Computer scientists say that interfaces provide *polymorphism*, which means “many
    shapes.”
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 变形变量 `t` 能够变成 `martian` 或 `laser` 的形式。计算机科学家说，接口提供了 *多态性*，这意味着“多种形状”。
- en: '![](f0188-01.jpg)'
  id: totrans-490
  prefs: []
  type: TYPE_IMG
  zh: '![](f0188-01.jpg)'
- en: '|  |'
  id: totrans-491
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-492
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Unlike Java, in Go `martian` and `laser` don’t explicitly declare that they
    implement an interface. The benefit of this is covered later in the lesson.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Java 不同，在 Go 中 `martian` 和 `laser` 并没有明确声明它们实现了接口。这种做法的好处将在本课的后面部分介绍。
- en: '|  |'
  id: totrans-494
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Typically interfaces are declared as named types that can be reused. There’s
    a convention of naming interface types with an *-er* suffix: a *talker* is anything
    that talks, as shown in the following listing.'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，接口被声明为可重用的命名类型。有一个命名接口类型的命名约定：以 *-er* 后缀命名：*talker* 是任何会说话的东西，如以下列表所示。
- en: 'Listing 24.4\. A `talker` type: shout.go'
  id: totrans-496
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 24.4\. `talker` 类型：shout.go
- en: '[PRE45]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: An interface type can be used anywhere other types are used. For example, the
    following `shout` function has a parameter of type `talker`.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 接口类型可以在其他类型可以使用的任何地方使用。例如，以下 `shout` 函数有一个类型为 `talker` 的参数。
- en: 'Listing 24.5\. Shout what was spoken: shout.go'
  id: totrans-499
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 24.5\. 大声说出所说的话：shout.go
- en: '[PRE46]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You can use the `shout` function with any value that satisfies the `talker`
    interface, whether martians or lasers, as shown in the next listing.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用满足 `talker` 接口的任何值与 `shout` 函数一起使用，无论是火星人还是激光，如以下列表所示。
- en: 'Listing 24.6\. Shouting: shout.go'
  id: totrans-502
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 24.6\. 大声喊叫：shout.go
- en: '[PRE47]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '***1* Prints NACK NACK**'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 NACK NACK**'
- en: '***2* Prints PEW PEW**'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 PEW PEW**'
- en: 'The argument you pass to the `shout` function must satisfy the `talker` interface.
    For example, the `crater` type doesn’t satisfy the `talker` interface, so if you
    expect a crater to shout, Go refuses to compile your program:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 你传递给 `shout` 函数的参数必须满足 `talker` 接口。例如，`crater` 类型不满足 `talker` 接口，所以如果你期望碎石大声喊叫，Go
    将拒绝编译你的程序：
- en: '[PRE48]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '***1* crater does not implement talker (missing talk method)**'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 碎石没有实现 talker 接口（缺少 talk 方法）**'
- en: Interfaces exhibit their flexibility when you need to change or extend code.
    When you declare a new type with a `talk` method, the `shout` function will work
    with it. Any code that only depends on the interface can remain the same, even
    as implementations are added and modified.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要更改或扩展代码时，接口会展现出其灵活性。当你声明一个新的具有 `talk` 方法的类型时，`shout` 函数将与之配合工作。任何只依赖于接口的代码都可以保持不变，即使实现被添加和修改。
- en: It’s worth noting that interfaces can be used with struct embedding, the language
    feature covered in [lesson 23](kindle_split_036.html#ch23). For example, the following
    listing embeds `laser` in a `starship`.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，接口可以与结构体嵌入一起使用，这是第 23 课中介绍的语言特性。例如，以下列表在 `starship` 中嵌入 `laser`。
- en: 'Listing 24.7\. Embedding satisfies interfaces: starship.go'
  id: totrans-511
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 24.7\. 嵌入满足接口：starship.go
- en: '[PRE49]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '***1* Prints pew pew pew**'
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 pew pew pew**'
- en: '***2* Prints PEW PEW PEW**'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 PEW PEW PEW**'
- en: When a starship talks, the laser does the talking. Embedding `laser` gives the
    `starship` a `talk` method that forwards to the `laser`. Now the starship also
    satisfies the `talker` interface, allowing it to be used with `shout`.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 当一艘星际飞船说话时，激光负责说话。嵌入 `laser` 给 `starship` 一个将转发到 `laser` 的 `talk` 方法。现在星际飞船也满足
    `talker` 接口，允许它与 `shout` 一起使用。
- en: '*Used together, composition and interfaces make a very powerful design tool.*'
  id: totrans-516
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*组合和接口结合使用是一种非常强大的设计工具。*'
- en: ''
  id: totrans-517
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Bill Venners, *JavaWorld* (see [mng.bz/B5eg](http://mng.bz/B5eg))*'
  id: totrans-518
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*比尔·文纳，*JavaWorld*（见 [mng.bz/B5eg](http://mng.bz/B5eg)）*'
- en: '|  |'
  id: totrans-519
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 24.1**'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 24.1**'
- en: '**[1](#ch24qa2q0a1)**'
  id: totrans-521
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch24qa2q0a1)**'
- en: ''
  id: totrans-522
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Modify the laser’s `talk` method in [listing 24.4](#ch24ex04) to prevent the
    Martian guns from firing, thus saving humanity from the invasion.
  id: totrans-523
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 修改 [列表 24.4](#ch24ex04) 中的激光的 `talk` 方法，以防止火星人的枪支发射，从而拯救人类免受入侵。
- en: '**[2](#ch24qa2q0a2)**'
  id: totrans-524
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch24qa2q0a2)**'
- en: ''
  id: totrans-525
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Expand [listing 24.4](#ch24ex04) by declaring a new `rover` type with a `talk`
    method that returns “whir whir”. Use the `shout` function with your new type.
  id: totrans-526
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过声明一个新的具有 `talk` 方法并返回“whir whir”的 `rover` 类型来扩展 [列表 24.4](#ch24ex04)。使用您的新的类型与
    `shout` 函数一起使用。
- en: '|  |'
  id: totrans-527
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-528
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 24.1 answer**'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 24.1 答案**'
- en: '**[1](#ch24qa1q1)**'
  id: totrans-530
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch24qa1q1)**'
- en: ''
  id: totrans-531
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-532
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '**[2](#ch24qa1q2)**'
  id: totrans-533
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch24qa1q2)**'
- en: ''
  id: totrans-534
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-535
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE51]'
- en: ''
  id: totrans-536
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '***1* Prints WHIR WHIR**'
  id: totrans-537
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 WHIR WHIR**'
- en: '|  |'
  id: totrans-538
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 24.2\. Discovering the interface
  id: totrans-539
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 24.2\. 发现接口
- en: With Go you can begin implementing your code and discover the interfaces as
    you go. Any code can implement an interface, even code that already exists. This
    section walks you through an example.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Go 语言，你可以开始编写代码，并在编写过程中发现接口。任何代码都可以实现接口，即使是已经存在的代码。本节将带您通过一个示例进行说明。
- en: The following listing derives a fictional stardate from the day of the year
    and hour of the day.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表从年份和小时数推导出一个虚构的 `stardate`。
- en: 'Listing 24.8\. Stardate calculation: stardate.go'
  id: totrans-542
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 24.8\. `Stardate` 计算：stardate.go
- en: '[PRE52]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '***1* Prints 1219.2 Curiosity has landed**'
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 1219.2 Curiosity 已着陆**'
- en: The `stardate` function in [listing 24.8](#ch24ex08) is limited to Earth dates.
    To remedy this, the following listing declares an interface for `stardate` to
    use.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 24.8](#ch24ex08) 中的 `stardate` 函数仅限于地球日期。为了解决这个问题，下一列表声明了一个 `stardate`
    接口。'
- en: 'Listing 24.9\. Stardate interface: stardater.go'
  id: totrans-546
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 24.9\. `Stardate` 接口：stardater.go
- en: '[PRE53]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The new `stardate` function in [listing 24.9](#ch24ex09) continues to operate
    on Earth dates because the `time.Time` type in the standard library satisfies
    the `stardater` interface. Interfaces in Go are satisfied implicitly, which is
    especially helpful when working with code you didn’t write.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `stardate` 函数在 [列表 24.9](#ch24ex09) 中继续使用地球日期，因为标准库中的 `time.Time` 类型满足 `stardater`
    接口。Go 中的接口是隐式满足的，这在处理你未编写的代码时特别有帮助。
- en: '|  |'
  id: totrans-549
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-550
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This wouldn’t be possible in a language like Java because `java.time` would
    need to explicitly say that it `implements stardater`.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 Java 这样的语言中，这是不可能的，因为 `java.time` 需要明确声明它 `implements stardater`。
- en: '|  |'
  id: totrans-552
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: With the `stardater` interface in place, [listing 24.9](#ch24ex09) can be expanded
    with a `sol` type that satisfies the interface with methods for `YearDay` and
    `Hour`, as shown in the following listing.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `stardater` 接口就位的情况下，[列表 24.9](#ch24ex09) 可以通过添加一个满足接口的 `sol` 类型来扩展，该类型具有
    `YearDay` 和 `Hour` 方法，如以下列表所示。
- en: 'Listing 24.10\. Sol implementation: stardater.go'
  id: totrans-554
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 24.10\. `Sol` 实现：stardater.go
- en: '[PRE54]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '***1* There are 668 sols in a Martian year.**'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 火星年中有 668 个火星日。**'
- en: '***2* The hour is unknown.**'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 小时未知。**'
- en: Now the `stardate` function operates on both Earth dates and Martian sols, as
    shown in the next listing.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`stardate` 函数同时操作地球日期和火星日，如下一列表所示。
- en: 'Listing 24.11\. In use: stardater.go'
  id: totrans-559
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 24.11\. 使用中：stardater.go
- en: '[PRE55]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '***1* Prints 1219.2 Curiosity has landed**'
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 1219.2 Curiosity 已着陆**'
- en: '***2* Prints 1086.0 Happy birthday**'
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 1086.0 生日快乐**'
- en: '|  |'
  id: totrans-563
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 24.2**'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 24.2**'
- en: '**[Q1:](#ch24qa4q0a1)**'
  id: totrans-565
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch24qa4q0a1)**'
- en: ''
  id: totrans-566
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How is implicitly satisfying interfaces advantageous?
  id: totrans-567
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 隐式满足的接口有哪些优势？
- en: '|  |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-569
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 24.2 answer**'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 24.2 答案**'
- en: '**[1:](#ch24qa3q1)**'
  id: totrans-571
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch24qa3q1)**'
- en: ''
  id: totrans-572
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You can declare an interface that’s satisfied by code you didn’t write, providing
    more flexibility.
  id: totrans-573
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以声明一个由你未编写的代码满足的接口，这提供了更多的灵活性。
- en: '|  |'
  id: totrans-574
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 24.3\. Satisfying interfaces
  id: totrans-575
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 24.3\. 满足接口
- en: The standard library exports a number of single-method interfaces that you can
    implement in your code.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库导出了一些单方法接口，你可以在自己的代码中实现它们。
- en: '*Go encourages composition over inheritance, using simple, often one-method
    interfaces ... that serve as clean, comprehensible boundaries between components.*'
  id: totrans-577
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Go 鼓励使用组合而非继承，使用简单、通常只有一个方法的接口...这些接口作为组件之间干净、可理解的边界。*'
- en: ''
  id: totrans-578
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Rob Pike, “Go at Google: Language Design in the Service of Software Engineering”
    (see [talks.golang.org/2012/splash.article](http://talks.golang.org/2012/splash.article))*'
  id: totrans-579
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Rob Pike, “Go at Google: Language Design in the Service of Software Engineering”
    (see [talks.golang.org/2012/splash.article](http://talks.golang.org/2012/splash.article))*'
- en: 'As an example, the `fmt` package declares a `Stringer` interface as follows:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`fmt` 包声明了一个 `Stringer` 接口如下：
- en: '[PRE56]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If a type provides a `String` method, `Println`, `Sprintf`, and friends will
    use it. The following listing provides a `String` method to control how the `fmt`
    package displays a location.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类型提供了一个 `String` 方法，`Println`、`Sprintf` 和其他方法将使用它。以下列表提供了一个 `String` 方法来控制
    `fmt` 包如何显示位置。
- en: 'Listing 24.12\. Satisfying stringer: stringer.go'
  id: totrans-583
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 24.12\. 满足 `Stringer`：stringer.go
- en: '[PRE57]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '***1* Prints -4.5895, 137.4417**'
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 -4.5895, 137.4417**'
- en: In addition to `fmt.Stringer`, popular interfaces in the standard library include
    `io.Reader`, `io.Writer`, and `json.Marshaler`.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `fmt.Stringer`，标准库中流行的接口还包括 `io.Reader`、`io.Writer` 和 `json.Marshaler`。
- en: '|  |'
  id: totrans-587
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-588
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `io.ReadWriter` interface provides an example of interface embedding that
    looks similar to struct embedding from [lesson 23](kindle_split_036.html#ch23).
    Unlike structures, interfaces don’t have fields or attached methods, so interface
    embedding saves some typing and little else.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.ReadWriter` 接口提供了一个类似于 [第 23 课](kindle_split_036.html#ch23) 中的结构嵌入的接口嵌入示例。与结构不同，接口没有字段或附加方法，因此接口嵌入节省了一些打字，但几乎没有其他好处。'
- en: '|  |'
  id: totrans-590
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-591
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 24.3**'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 24.3**'
- en: '**[Q1:](#ch24qa6q0a1)**'
  id: totrans-593
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch24qa6q0a1)**'
- en: ''
  id: totrans-594
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a `String` method on the `coordinate` type and use it to display coordinates
    in a more readable format.
  id: totrans-595
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在`coordinate`类型上编写一个`String`方法，并使用它以更可读的格式显示坐标。
- en: ''
  id: totrans-596
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-597
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE58]'
- en: ''
  id: totrans-598
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Your program should output: `Elysium Planitia is at 4°30''0.0" N, 135°54''0.0"
    E`'
  id: totrans-599
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你的程序应该输出：`Elysium Planitia位于北纬4°30'0.0"，东经135°54'0.0"处`
- en: '|  |'
  id: totrans-600
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-601
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 24.3 answer**'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 24.3 答案**'
- en: '**[1:](#ch24qa5q1)**'
  id: totrans-603
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch24qa5q1)**'
- en: ''
  id: totrans-604
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-605
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE59]'
- en: ''
  id: totrans-606
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '***1* Prints Elysium Planitia is at 4°30’0.0” N, 135°54’0.0” E**'
  id: totrans-607
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印Elysium Planitia位于北纬4°30’0.0” N，东经135°54’0.0” E**'
- en: '|  |'
  id: totrans-608
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 24.4\. Summary
  id: totrans-609
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 24.4. 概述
- en: Interface types specify required behaviors with a set of methods.
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口类型通过一组方法指定所需的行为。
- en: Interfaces are satisfied implicitly by new or existing code in any package.
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何包中的新或现有代码都会隐式满足接口。
- en: A structure will satisfy the interfaces that embedded types satisfy.
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构将满足嵌入类型满足的接口。
- en: Follow the example set by the standard library and strive to keep interfaces
    small.
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照标准库的示例，努力保持接口小巧。
- en: Let’s see if you got this...
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否掌握了这个...
- en: 'Experiment: marshal.go'
  id: totrans-615
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实验：marshal.go
- en: 'Write a program that outputs coordinates in JSON format, expanding on work
    done for the preceding quick check. The JSON output should provide each coordinate
    in decimal degrees (DD) as well as the degrees, minutes, seconds format:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，以JSON格式输出坐标，扩展先前的快速检查工作。JSON输出应提供每个坐标的十进制度数（DD）以及度、分、秒格式：
- en: '[PRE60]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This can be achieved without modifying the coordinate structure by satisfying
    the `json.Marshaler` interface to customize the JSON. The `MarshalJSON` method
    you write may make use of `json.Marshal`.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过满足`json.Marshaler`接口来自定义JSON，而不需要修改坐标结构。你编写的`MarshalJSON`方法可以使用`json.Marshal`。
- en: '|  |'
  id: totrans-619
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-620
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: To calculate decimal degrees, you’ll need the `decimal` method introduced in
    [lesson 22](kindle_split_035.html#ch22).
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算十进制度数，你需要使用第22课中引入的`decimal`方法。
- en: '|  |'
  id: totrans-622
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Lesson 25\. Capstone: Martian animal sanctuary'
  id: totrans-623
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第25课：火星动物庇护所
- en: In the distant future, humankind may be able to comfortably live on what is
    currently a dusty red planet. Mars is farther from the Sun and therefore much
    colder. Warming up the planet could be the first step in *terraforming* the climate
    and surface of Mars. Once water begins to flow and plants begin to grow, organisms
    can be introduced.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 在遥远的未来，人类可能能够在目前这个尘土飞扬的红星球上舒适地生活。火星距离太阳更远，因此温度更低。加热这个星球可能是改造火星气候和表面的第一步。一旦水流开始流动，植物开始生长，就可以引入生物。
- en: '*Tropical trees can be planted; insects and some small animals can be introduced.
    Humans will still need gas masks to provide oxygen and prevent high levels of
    carbon dioxide in the lungs.*'
  id: totrans-625
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*可以在热带种植树木；可以引入昆虫和一些小型动物。人类仍然需要气罩来提供氧气并防止肺部二氧化碳含量过高。*'
- en: ''
  id: totrans-626
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Leonard David, *Mars: Our Future on the Red Planet**'
  id: totrans-627
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*莱纳德·大卫，《火星：我们在红色星球上的未来》*'
- en: Right now the Martian atmosphere is approximately 96% carbon dioxide (see [en.wikipedia.org/wiki/Atmosphere_of_Mars](http://en.wikipedia.org/wiki/Atmosphere_of_Mars)).
    It could take a very, very long time to change that. Mars will remain a different
    world.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 目前火星大气中大约有96%的二氧化碳（参见[en.wikipedia.org/wiki/Atmosphere_of_Mars](http://en.wikipedia.org/wiki/Atmosphere_of_Mars)）。改变这一点可能需要非常非常长的时间。火星将仍然是一个不同的世界。
- en: Now it’s time to use your imagination. What do you think would happen if an
    ark full of Earth animals were introduced to a terraformed Mars? What lifeforms
    might spring forth as the climate adjusts to support life?
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候发挥你的想象力了。你认为如果一艘装满地球动物的方舟被引入到经过改造的火星上会发生什么？随着气候适应以支持生命，可能会出现哪些生命形式？
- en: '![](f0197-01_alt.jpg)'
  id: totrans-630
  prefs: []
  type: TYPE_IMG
  zh: '![](f0197-01_alt.jpg)'
- en: Your task is to create a simulation of the first animal sanctuary on Mars. Make
    a few types of animals. Each animal should have a name and adhere to the `Stringer`
    interface to return their name.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 你的任务是创建火星上第一个动物庇护所的模拟。制作几种动物类型。每种动物都应该有一个名字，并遵循`Stringer`接口以返回它们的名称。
- en: Every animal should have methods to move and eat. The move method should return
    a description of the movement. The eat method should return the name of a random
    food that the animal likes.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 每种动物都应该有移动和进食的方法。移动方法应返回移动的描述。进食方法应返回动物喜欢的随机食物名称。
- en: Implement a day/night cycle and run the simulation for three 24-hour sols (72
    hours). All the animals should sleep from sunset until sunrise. For every hour
    of the day, pick an animal at random to perform a random action (move or eat).
    For every action, print out a description of what the animal did.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 实现昼夜循环，并运行模拟三个24小时日（72小时）。所有动物应从日落睡到日出。对于每天中的每一小时，随机选择一个动物执行一个随机动作（移动或进食）。对于每个动作，打印出动物所执行动作的描述。
- en: Your implementation should make use of structures and interfaces.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 你的实现应该使用结构和接口。
