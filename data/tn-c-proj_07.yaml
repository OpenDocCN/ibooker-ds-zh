- en: 7 String utilities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 字符串工具
- en: It’s often said, and rightly so, that the C programming language lacks a string
    data type. Such a thing would be nice. It would be easier to guarantee that every
    string in a program is bona fide and that all string functions work cleanly without
    flaw. But such claims are untrue. A string in C is a character array, weakly typed,
    and easy for any C programmer to screw up.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 人们常说，而且有充分的理由，C 编程语言缺少字符串数据类型。这样的功能会很不错。这将更容易保证程序中的每个字符串都是真实的，并且所有字符串函数都能干净利落且无缺陷地工作。但这样的说法是不真实的。在
    C 语言中，字符串是一个字符数组，弱类型，任何 C 程序员都容易出错。
- en: 'Yes, handy string functions exist in C. A crafty coder can easily cobble together
    any string function, imitating what’s available in some other, loftier programming
    language but lacking in C. Still, any creative approach to handling an absent
    string function in C still must deal with the language’s myopic perception of
    the string concept. Therefore, some extra training is required, which includes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，C 语言中存在实用的字符串函数。一个巧妙的程序员可以轻松地拼凑出任何字符串函数，模仿在其他一些更高层次的编程语言中可用的功能，但在 C 语言中却缺乏。然而，任何处理
    C 语言中缺失字符串函数的创造性方法都必须处理语言对字符串概念的狭隘认识。因此，需要一些额外的训练，包括：
- en: Reviewing what’s so terrible about strings in C
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审视 C 语言中字符串的糟糕之处
- en: Understanding how string length is measured
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解字符串长度是如何测量的
- en: Creating interesting and useful string functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建有趣且有用的字符串函数
- en: Building your own string function library
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建自己的字符串函数库
- en: Exploring make-believe object-oriented programming
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索虚构的面向对象编程
- en: Despite what you can do with strings in C, the grousing and disdain remains—and
    it’s legitimate. C strings are squishy things. It’s easy to mess up when you create
    or manipulate a string, even for experienced programmers. Still, strings exist
    as a valid form of data and are necessary for communications. So, prepare to bolster
    your string knowledge and build up your programming arsenal.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您可以在 C 语言中使用字符串，但抱怨和轻蔑仍然存在——这是合理的。C 字符串是柔软的东西。在创建或操作字符串时，即使是经验丰富的程序员也容易出错。然而，字符串作为有效的数据形式存在，并且对于通信是必要的。因此，准备好增强您的字符串知识并建立您的编程武器库。
- en: 7.1 Strings in C
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 C 语言中的字符串
- en: That which you call a string doesn’t exist in C as its own data type, like an
    *int* or a *double*. No programmer worries about malforming an integer or incorrectly
    encoding the binary format of a real number. These data types—*int*, *double*,
    and even *char*—are atoms. A string is a molecule. It must be constructed specifically.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您所称之为字符串的东西在 C 语言中并不存在，就像 *int* 或 *double* 这样的数据类型一样。没有程序员会担心整数变形或不正确地编码实数的二进制格式。这些数据类型——*int*、*double*，甚至
    *char*——是原子。字符串是一个分子。它必须专门构建。
- en: Technically, a string is a special type of character array. It has a beginning
    character, located at some address in memory. Every following character in memory
    is part of the string, up until the null character, \0, is encountered. This ad
    hoc structure is used as a string in C—though it remains squishy. If you require
    further understanding of the squishy concept, table 7.1 provides a comparative
    review.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，字符串是一种特殊的字符数组类型。它有一个起始字符，位于内存中的某个地址。内存中的每个后续字符都是字符串的一部分，直到遇到空字符 \0 为止。这种临时结构在
    C 语言中被用作字符串——尽管它仍然很柔软。如果您需要进一步了解柔软的概念，表 7.1 提供了比较性综述。
- en: Table 7.1 Squishy things
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.1 柔软的东西
- en: '| Thing | Why it’s squishy |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 事物 | 为什么它会变得柔软 |'
- en: '| Street intersection limit line | Because few cars stop at the limit line.
    Most just roll through. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 街道交叉口限制线 | 因为很少有汽车停在限制线上。大多数只是滚过去。 |'
- en: '| Grandpa saying “No” | Just give it time. Making a cute face helps. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 爷爷说“不” | 给它点时间。做个可爱的表情有帮助。 |'
- en: '| Building permits | Different wait times apply, depending on how friendly
    you are with the mayor. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 建筑许可证 | 根据您与市长的关系友好程度，等待时间不同。 |'
- en: '| Food | Doesn’t mean the same thing on an airplane. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 食物 | 在飞机上并不意味着同一件事。 |'
- en: '| Personality | Good to have yourself; bad for a blind date. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 性格 | 对自己来说很好；对相亲来说却不好。 |'
- en: '| Obese | Actuarial tables haven’t been updated since the 1940s. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 肥胖 | 自 1940 年以来，精算表尚未更新。 |'
- en: '| Fame on social media | Wait a few hours. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 社交媒体上的名声 | 等待几个小时。 |'
- en: '| Sponge cake | By design. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 海绵蛋糕 | 设计使然。 |'
- en: 7.1.1 Understanding the string
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.1 理解字符串
- en: 'It’s important to separate what you believe to be a string from a character
    array. Though all strings are character arrays, not all character arrays are strings.
    For example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 将您认为的字符串与字符数组区分开来很重要。尽管所有字符串都是字符数组，但并非所有字符数组都是字符串。例如：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This statement creates a *char* array a[]. It contains three characters: c-a-t.
    This array is not a string. The following *char* array, however, is a string:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句创建了一个 *char* 数组 a[]。它包含三个字符：c-a-t。这个数组不是字符串。然而，下面的 *char* 数组是一个字符串：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Array b[] contains four characters: c-a-t plus the null character. This terminating
    null character makes the array a string. It can be processed by any C language
    string function or output as a string.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 数组 b[] 包含四个字符：c-a-t 加上空字符。这个终止的空字符使数组成为字符串。它可以由任何 C 语言字符串函数处理或作为字符串输出。
- en: 'To save you time, and to keep the keyboard’s apostrophe key from wearing out,
    the C compiler lets you craft strings by enclosing characters in double quotes:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省你的时间，并且让键盘的单引号键不会磨损，C 编译器允许你通过将字符放在双引号中来构建字符串：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Array c[] is a string. It consists of four characters, c-a-t, plus the null
    character added automatically by the compiler. Though this character doesn’t appear
    in the statement, you must account for it when allocating storage for the string—always!
    If you declare a string like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 数组 c[] 是一个字符串。它由四个字符组成，c-a-t，加上编译器自动添加的空字符。尽管这个字符没有出现在声明中，但你必须在为字符串分配存储空间时考虑到它——总是！如果你这样声明字符串：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: the compiler allocates three characters for c-a-t, but none for the null character.
    This declaration might be flagged by the compiler—or it might not. Either way,
    the string is malformed, and, minus the terminating null character, manipulating
    or outputting the string yields unpredictable and potentially wacky results.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器为 c-a-t 分配了三个字符，但没有为空字符分配。这个声明可能会被编译器标记——或者可能不会。无论如何，字符串是不规则的，并且，如果没有终止的空字符，操作或输出字符串会产生不可预测的甚至可能荒谬的结果。
- en: 'Because the compiler automatically allocates storage for a string, the following
    declaration format is used most often:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因为编译器会自动为字符串分配存储空间，所以以下声明格式最常使用：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With empty brackets, the compiler calculates the string’s storage and assigns
    the proper number of elements to the array, including the null character.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用空括号时，编译器会计算字符串的存储空间，并为数组分配适当数量的元素，包括空字符。
- en: 'Especially when building your own strings, you must take care to account for
    the terminating null character: storage must be allocated for it, and your code
    must ensure that the final character in the string is the \0.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是在构建自己的字符串时，你必须注意考虑到终止的空字符：必须为它分配存储空间，并且你的代码必须确保字符串中的最后一个字符是 \0。
- en: 'Here are some string considerations:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些字符串注意事项：
- en: When allocating string storage, always add one for the null character. Strings
    are allocated directly as a *char* array declaration or via a memory-allocation
    function such as *malloc()*.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在分配字符串存储空间时，始终为空字符添加一个。字符串可以直接作为 *char* 数组声明分配，或者通过如 *malloc()* 这样的内存分配函数。
- en: When using string storage, remember that the final character in storage must
    be the null character, whether or not the buffer is full.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用字符串存储时，请记住，存储空间中的最后一个字符必须是空字符，无论缓冲区是否已满。
- en: The *fgets()* function, often used to read string input, automatically accounts
    for the null character in its second argument, size. So, if you use the value
    32 as the size argument in an *fgets()* statement, the function stores up to 31
    characters before it automatically adds the null character to terminate the input
    string.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*fgets()* 函数通常用于读取字符串输入，它在其第二个参数大小中自动考虑了空字符。因此，如果你在 *fgets()* 语句中将值 32 作为大小参数使用，该函数在自动添加空字符以终止输入字符串之前存储最多
    31 个字符。'
- en: Without the terminating null character, string functions continuing processing
    bytes until the next random null character is encountered. The effect could be
    garbage output or—worse—a segmentation fault.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有终止的空字符，字符串函数会继续处理字节，直到遇到下一个随机的空字符。结果可能是垃圾输出——更糟糕的是，可能会引发段错误。
- en: One problem with forgetting the null is that often memory is already packed
    with null characters. A buffer can overflow, but the random null characters already
    in memory prevent output from looking bad—and from your mistake being detected.
    Never rely upon null characters sitting in memory.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忘记空字符的一个问题是，通常内存中已经充满了空字符。缓冲区可能会溢出，但内存中已经存在的随机空字符可以防止输出看起来糟糕——以及你的错误被检测到。永远不要依赖于内存中静止的空字符。
- en: The null character is necessary to terminate a string but not required. The
    compiler doesn’t check for it—how could it? This lack of confirmation, of string
    containment, is what makes strings squishy in C.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空字符是终止字符串所必需的，但不是必须检查的。编译器不会检查它——它怎么能呢？这种缺乏确认、字符串包含的缺失，使得C语言中的字符串变得灵活。
- en: 7.1.2 Measuring a string
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.2 测量字符串
- en: The title of this section has a completely different definition for my grandmother.
    No, she doesn’t code, but she crochets. The strings are longer in crocheting,
    but in programming you don’t use the word skein. Instead, you fuss over character
    count.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部分的标题对我奶奶来说有完全不同的定义。不，她不编程，但她编织。在编织中，字符串更长，但在编程中，你不会使用skein这个词。相反，你会在字符计数上纠结。
- en: As stored in memory, a string is one character longer than its text, this extra
    character being the null character terminating the string. It’s part of the string
    but not “in” the string.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存中存储的字符串比其文本多一个字符，这个额外的字符是终止字符串的空字符。它是字符串的一部分，但不在字符串“内部”。
- en: According to the *strlen()* function, the string is only as long as its number
    of characters, minus one for the nonprinting null character.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 根据strlen()函数，字符串的长度仅为其字符数减去一个非打印的空字符。
- en: So, how long is the string?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，字符串有多长？
- en: 'The *man* page for the *strlen()* describes its purpose:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: strlen()的man页面描述了其目的：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The *strlen()* counts the number of characters in the string, with escaped characters
    counted as a single character. For example, the newline \n is a single character,
    though it occupies two character positions. The tab \t is also a single character,
    though the terminal may translate it into multiple spaces when output.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: strlen()计算字符串中的字符数，转义字符被计为一个字符。例如，换行符\n是一个字符，尽管它占据了两个字符位置。制表符\t也是一个字符，尽管终端在输出时可能将其转换为多个空格。
- en: Regardless of the nits I pick, the value returned by *strlen()* can be used
    elsewhere in the code to manipulate all characters in the string without violating
    the terminating null character or double-counting escaped characters. If you want
    to include the null character in the string’s size, you can use the sizeof operator,
    but be aware that this trick works only on statically allocated strings (otherwise,
    the pointer size is returned).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 不论我挑剔什么，strlen()返回的值可以在代码的其他地方使用，以操作字符串中的所有字符，而不会违反终止空字符或重复计算转义字符。如果你想将空字符包含在字符串的大小中，可以使用sizeof运算符，但请注意，这个技巧只适用于静态分配的字符串（否则，返回指针大小）。
- en: In the following listing, a comparison is made between values returned by *strlen()*
    and *sizeof*. A string s[] is declared at line 6, which contains 10 characters.
    The *printf()* statement at line 8 outputs the string’s *strlen()* value. The
    *printf()* statement at line 9 outputs the string’s *sizeof* value.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中，我们比较了strlen()和sizeof返回的值。在代码的第6行声明了一个字符串s[]，它包含10个字符。第8行的printf()语句输出字符串的strlen()值。第9行的printf()语句输出字符串的sizeof值。
- en: Listing 7.1 Source code for string_size.c
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.1 string_size.c的源代码
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ 10 characters
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 10个字符
- en: 'Here’s the output:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The *strlen()* function returns the number of characters in the string; *sizeof*
    returns the amount of storage the string occupies—essentially strlen()+1, though,
    if the string is smaller than its allocated buffer size, *sizeof* returns the
    buffer size and not strlen()+1. If you make this change to line 6 in the code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: strlen()函数返回字符串中的字符数；sizeof返回字符串占用的存储量——本质上相当于strlen()+1，但如果字符串小于其分配的缓冲区大小，sizeof返回缓冲区大小而不是strlen()+1。如果你将此更改应用到代码的第6行：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Now 20 characters of storage
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 现在20个字符的存储
- en: 'Here is the updated output:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是更新后的输出：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Despite the larger buffer size, the null character still sits at element 10
    (the 11th character) in the s[] array. The remainder of the buffer is considered
    garbage but is still reported as the string’s “size” by the *sizeof* operator.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管缓冲区的大小增加了，但空字符仍然位于s[]数组中的第10个元素（第11个字符）。缓冲区的其余部分被认为是垃圾，但仍然被sizeof运算符报告为字符串的“大小”。
- en: 'Measuring a string also comes into play with the grand philosophical debate
    over what is a null string and what is an empty string. The difference is relevant
    in other programming languages, where a string can be explicitly defined as being
    either null or empty. In C, with its weak data types and squishy strings, the
    difference is less obvious. Consider the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 测量字符串也与关于空字符串和空字符串是什么的伟大哲学辩论有关。这种差异在其他编程语言中也很相关，在这些语言中，字符串可以明确地定义为null或空。在C中，由于其弱数据类型和松散的字符串，这种差异不太明显。考虑以下情况：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Of the two arrays, a[] and b[], which is the null string and which is the empty
    string?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个数组a[]和b[]中，哪个是空字符串，哪个是空字符串？
- en: You may think that C doesn’t care about which string is which. Obviously, array
    a[] is initialized and b[] is not. The rest of the discussion is semantics, but
    according to computer science, a[] is the empty string and b[] is the null string.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为C不关心哪个字符串是哪个。显然，数组a[]已初始化，而b[]未初始化。其余的讨论是语义问题，但根据计算机科学，a[]是空字符串，b[]是空字符串。
- en: In the next listing, I perform a test comparing the two strings, empty a[] and
    null b[], to see whether the compiler notices the difference between a null string
    or an empty string. The *strcmp()* function is used, which returns zero when both
    strings are identical.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个列表中，我执行了一个测试，比较了两个字符串，空数组a[]和空数组b[]，以查看编译器是否注意到空字符串或空字符串之间的差异。使用*strcmp()*函数，当两个字符串相同时会返回零。
- en: Listing 7.2 Source code for empty-null.c
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.2 empty-null.c的源代码
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ The empty string
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 空字符串
- en: ❷ The null string (uninitialized)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 空字符串（未初始化）
- en: ❸ If both strings are identical
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果两个字符串相同
- en: ❹ Size according to *strlen()*
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 根据strlen()的大小
- en: ❺ Size according to *sizeof*
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 根据sizeof的大小
- en: 'The program’s output describes how the strings are seen internally:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出描述了字符串在内部是如何被看到的：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Of course, there’s always a random chance that the garbage in memory for string
    b[] may match up with the contents of string a[]. Therefore, even this output
    can’t truly be trusted. I mean, why does strlen(b) return the value 4?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，总有可能字符串b[]在内存中的垃圾数据与字符串a[]的内容匹配。因此，即使这个输出也不能真正被信任。我的意思是，为什么strlen(b)返回值是4？
- en: 'As far as strings in C are concerned, I prefer to think of a null string as
    uninitialized. An empty string is an easier concept to understand. After all,
    it’s completely legitimate in C to have a string that contains only the terminating
    null character: such a string’s length is zero. It can be manipulated by all string
    functions. Beyond these curiosities, however, you can leave the debate over “empty
    string” and “null string” to the grand viziers of other, trendier programming
    languages.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 就C语言中的字符串而言，我更喜欢将空字符串视为未初始化的。空字符串是一个更容易理解的概念。毕竟，在C中，有一个只包含终止空字符的字符串是完全合法的：这样的字符串长度为零。它可以被所有字符串函数操作。然而，除了这些好奇之处，你可以将“空字符串”和“空字符串”的争论留给其他更时尚编程语言的伟大维齐尔。
- en: 7.1.3 Reviewing C string functions
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.3 C字符串函数回顾
- en: Many C language functions understand and process strings. The assumption is
    that the string is a *char* array that properly terminates. This format is how
    functions such as *printf()*, *puts()*, *fgets()*, and others deal with strings.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 许多C语言函数理解和处理字符串。假设字符串是一个*char*数组，并且正确终止。这种格式是诸如*printf()*, *puts()*, *fgets()*,
    等函数处理字符串的方式。
- en: String functions are prototyped in the string.h header file. Standard C library
    string manipulation functions are listed in table 7.2.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串函数在string.h头文件中声明。标准C库字符串操作函数列在表7.2中。
- en: Table 7.2 Common C library string functions
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.2 常见C库字符串函数
- en: '| Function | Description |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| *strcat**()* | Appends one string to another, sticking both together |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| *strcat**()* | 将一个字符串附加到另一个字符串上，将两者连接起来 |'
- en: '| *strncat**()* | Sticks two strings together, but limited to a certain number
    of characters |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| *strncat**()* | 将两个字符串连接起来，但限于一定数量的字符 |'
- en: '| *strchr**()* | Returns a pointer to the location of a specific character
    within a string |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| *strchr**()* | 返回指向字符串中特定字符位置的指针 |'
- en: '| *strcmp**()* | Compares two strings, returning zero for a match |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| *strcmp**()* | 比较两个字符串，匹配时返回零 |'
- en: '| *strncmp**()* | Compares two strings up to a given length |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| *strncmp**()* | 比较两个字符串，直到给定长度 |'
- en: '| *strcoll**()* | Compares two strings using locale information |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| *strcoll**()* | 使用区域信息比较两个字符串 |'
- en: '| *strcpy**()* | Copies characters from one string into another or into a buffer
    |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| *strcpy**()* | 将一个字符串中的字符复制到另一个字符串或缓冲区中 |'
- en: '| *strncpy**()* | Copies a given number of characters from one string to another
    |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| *strncpy**()* | 从一个字符串复制指定数量的字符到另一个字符串 |'
- en: '| *strlen**()* | Returns the number of characters in a string |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| *strlen**()* | 返回字符串中的字符数 |'
- en: '| *strpbrk()* | Locates the first instance of a character from one string found
    in another |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| *strpbrk()* | 定位一个字符串中在另一个字符串中找到的第一个字符实例 |'
- en: '| *strrchr()* | Returns a pointer to character within a string, measured from
    the end of the string |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| *strrchr()* | 返回指向字符串中字符的指针，从字符串的末尾开始测量 |'
- en: '| *strspn()* | Returns the position of specified characters in one string found
    in another |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| *strspn()* | 返回指定字符在字符串中的位置，这些字符在另一个字符串中找到 |'
- en: '| *strcspn()* | Returns the position of specified characters in one string
    not found in another |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| *strcspn()* | 返回指定字符在字符串中的位置，这些字符在另一个字符串中未找到 |'
- en: '| *strstr()* | Returns the position of one string found within another |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| *strstr()* | 返回一个字符串在另一个字符串中的位置 |'
- en: '| *strtok()* | Parses a string based on separator characters (called repeatedly)
    |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| *strtok()* | 根据分隔符字符解析字符串（反复调用） |'
- en: '| *strxfrm()* | Transforms one string into another based on locale information
    |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| *strxfrm()* | 根据区域信息将一个字符串转换为另一个字符串 |'
- en: Many string functions feature an “n” companion, such as *strcat()* and *strncat()*.
    The n indicates that the function counts characters or otherwise tries to avoid
    an overflow by setting a string size value.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 许多字符串函数都有一个“n”伴随函数，例如 *strcat()* 和 *strncat()*。n 表示函数计算字符或通过设置字符串大小值来尝试避免溢出。
- en: Though table 7.2 lists only common C library string functions, your compiler’s
    library may feature more. For example, the *strcasecmp()* function works like
    *strcmp()*, but it ignores letter case when making the comparison. (See chapter
    11.) Also, the *strfry()* function is available specifically with GNU C libraries.
    It randomly swaps characters in a string, similar to the *scramble()* function
    discussed in chapter 6.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管表7.2只列出了常见的C库字符串函数，但你的编译器的库可能还有更多。例如，*strcasecmp()* 函数与 *strcmp()* 函数类似，但在比较时忽略字母的大小写。（见第11章。）此外，*strfry()*
    函数专门在GNU C库中可用。它随机交换字符串中的字符，类似于第6章中讨论的 *scramble()* 函数。
- en: Just to ensure that you’re always alarmed or confused, some compilers may also
    feature a strings.h header file. This header defines a few additional string functions,
    such as strcasecmp(), with some C libraries. I don’t cover these functions in
    this chapter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你总是感到警觉或困惑，一些编译器可能还会提供 strings.h 头文件。此头文件定义了一些额外的字符串函数，例如 strcasecmp()，与某些C库一起使用。我在本章中不涵盖这些函数。
- en: 7.1.4 Returning versus modifying directly
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.4 返回与直接修改
- en: Functions that manipulate strings in C have two ways they can make their changes.
    The first is to return a modified version of the string. The second is to manipulate
    the passed string directly. Choosing an approach really depends on the function’s
    purpose.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在C中操作字符串的函数有两种方式可以使其更改。第一种是返回字符串的修改版本。第二种是直接操作传递的字符串。选择方法实际上取决于函数的目的。
- en: 'For example, the *strcat()* function appends one string to another. Here is
    the man page format:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*strcat()* 函数将一个字符串追加到另一个字符串。以下是手册页格式：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: String src (source) is appended to the end of string dest (destination). The
    function assumes enough room is available in the dest buffer to successfully append
    the string. Upon success, string dest contains both dest plus src. The function
    returns a pointer to dest. The *strcat()* function is an example of manipulating
    a passed string directly.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串 src（源）被追加到字符串 dest（目标）的末尾。该函数假定 dest 缓冲区有足够的空间来成功追加字符串。成功后，字符串 dest 包含 dest
    和 src。该函数返回对 dest 的指针。*strcat()* 函数是直接操作传递的字符串的示例。
- en: In the next listing, two strings are present in the *main()* function, s1[]
    and s2[]. It’s the job of the *strappend()* function to stick both strings together,
    returning a pointer to the new, longer string. The secret is that within the *strappend()*
    function is the *strcat()* function, and its value (the address of dest) is returned.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个列表中，*main()* 函数中有两个字符串，s1[] 和 s2[]。*strappend()* 函数的任务是将这两个字符串粘合在一起，并返回对新、更长字符串的指针。秘密在于
    *strappend()* 函数内部有 *strcat()* 函数，并且返回值（dest 的地址）。
- en: Listing 7.3 Source code for strcat.c
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.3 strcat.c的源代码
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ The *strcat()* function returns pointer dest, the newly combined string.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ *strcat()* 函数返回指针 dest，即新组合的字符串。
- en: ❷ Array s1[] contains enough storage for both strings.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 数组 s1[] 包含足够的空间来存储两个字符串。
- en: 'The program’s output shows the concatenated string:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出显示了连接后的字符串：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this example, the function doesn’t really create a new string. It merely
    returns a pointer to the first string passed, which now contains both strings.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，函数并没有真正创建一个新的字符串。它只是返回指向第一个传入的字符串的指针，现在它包含了两个字符串。
- en: Exercise 7.1
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 7.1
- en: Modify the source code for strcat.c. Remove the *strcat()* function from the
    code, replacing it with your own code that sticks the contents of argument src
    to the end of argument dest. Do not use the *strcat()* function to accomplish
    this task! Instead, determine the size of the resulting string and allocate storage
    for it. The *strappend()* function returns the address of the created string.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 strcat.c 的源代码。从代码中移除 *strcat()* 函数，用你自己的代码替换它，将参数 src 的内容粘接到参数 dest 的末尾。不要使用
    *strcat()* 函数来完成这个任务！相反，确定结果字符串的大小，并为它分配存储空间。*strappend()* 函数返回创建的字符串的地址。
- en: You can further modify the code so that string s1[] holds only the text shown;
    it doesn’t need to allocate storage for the new string. Proper allocation is instead
    made within the *strappend()* function.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以进一步修改代码，使得字符串 s1[] 只包含显示的文本；它不需要为新字符串分配存储空间。正确的分配是在 *strappend()* 函数中完成的。
- en: My solution to this exercise is available in the online repository as strappend.c.
    Comments in the code explain my approach. Remember, this code demonstrates how
    a string function can create a new string as opposed to modifying a string passed
    as an argument.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我对这个练习的解决方案可以在在线存储库中找到，名为 strappend.c。代码中的注释解释了我的方法。记住，这段代码演示了字符串函数如何创建一个新的字符串，而不是修改作为参数传递的字符串。
- en: 7.2 String functions galore
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 字符串函数众多
- en: C has plenty of string functions, but apparently not enough for the grand poohbahs
    of those other programming languages. They disparage C as being weak on string
    manipulation. Of course, any function you feel is missing from the C library—one
    that happily dwells in some other, trendier programming language—can easily be
    coded. All you must do is remember to include the all-important terminating null
    character, and anything string-related is possible in C.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: C 语言有大量的字符串函数，但显然对于那些其他编程语言的“大人物”来说还不够。他们贬低 C 语言在字符串操作方面的能力。当然，任何你觉得 C 库中缺失的函数——那些在其他一些更时髦的编程语言中快乐地居住的函数——都可以轻松编写。你只需要记住包含那个至关重要的终止空字符，然后在
    C 语言中就可以实现任何与字符串相关的事情。
- en: In this section, I present a smattering of string functions, some of which exist
    in other programming languages, others of which I felt compelled to create because
    of some personal brain defect. Regardless, these functions prove that anything
    you can do with a string in those Johnny-come-lately programming languages is
    just as doable in C.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我介绍了一些字符串函数，其中一些在其他编程语言中存在，而另一些则是由于一些个人脑部缺陷而不得不创建的。无论如何，这些函数证明了在那些新出现的编程语言中你可以用字符串做的任何事情，在
    C 语言中同样可以做到。
- en: 'Oh! One point to make: the functions found in other languages are sometimes
    called *methods* because they pertain to object-oriented programming. Well, *la-di-da*.
    I can call my car the Batmobile, but it’s still a Hyundai.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 哦！有一点需要说明：在其他语言中找到的函数有时被称为 *方法*，因为它们与面向对象编程相关。嗯，*la-di-da*。我可以把我的车叫做蝙蝠车，但它仍然是一辆现代汽车。
- en: 7.2.1 Changing case
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.1 改变大小写
- en: Functions that change text case in a string are common in other languages. In
    C, the ctype functions *toupper()* and *tolower()* convert single characters,
    letters of the alphabet to upper- or lowercase, respectively. These functions
    can easily be applied to an entire string. All you need to do is write a function
    that handles the task.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言中，字符串中的文本大小写转换函数很常见。在 C 语言中，ctype 函数 *toupper()* 和 *tolower()* 分别将单个字符、字母转换为大写或小写。这些函数可以轻松地应用于整个字符串。你所需要做的就是编写一个处理这个任务的函数。
- en: The following listing shows the source code for strupper.c, which converts a
    string’s lowercase letters to uppercase. The string is modified within the function,
    where a *while* loop processes each character. If the character is in the range
    of 'a' to 'z', its sixth bit is reset (changed to zero), which converts it to
    lowercase. (This bitwise manipulation is discussed in chapter 5.) The *strupper()*
    function avoids using any ctype functions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了 strupper.c 的源代码，该代码将字符串的小写字母转换为大写。字符串在函数内部被修改，其中 *while* 循环处理每个字符。如果字符在
    'a' 到 'z' 的范围内，其第六位被重置（变为零），从而将其转换为小写。（这种位操作在第 5 章中有讨论。）*strupper()* 函数避免使用任何
    ctype 函数。
- en: Listing 7.4 Source code for strupper.c
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.4 strupper.c 的源代码
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Loops until *s references the null character (end of the string)
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 循环直到 *s 指向空字符（字符串的结尾）
- en: ❷ Changes only lowercase letters
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 仅更改小写字母
- en: ❸ Resets the sixth bit to convert to uppercase
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将第六位重置以转换为大写
- en: 'Here is the program’s output:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序的输出：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The *strupper()* function could also convert characters to uppercase by performing
    basic math. Due to the layout of the ASCII table, the following statement also
    works:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`*strupper()*`函数也可以通过执行基本数学运算将字符转换为大写。由于ASCII表的布局，以下语句也有效：'
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Subtracting 32 from each character’s ASCII value also converts it to lowercase.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 从每个字符的ASCII值中减去32也将它转换为小写。
- en: 'It’s easy to modify the *strupper()* function to create a function that converts
    characters to lowercase. Here is how a *strlower()* function may look:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`*strupper()*`函数以创建一个将字符转换为小写的函数很容易。以下是一个`*strlower()*`函数可能的样子：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Converts only uppercase letters
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 仅转换大写字母
- en: ❷ Adds 32 to make the conversion
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 加32以进行转换
- en: The complete source code showing the *strlower()* function is found in this
    book’s online repository as strlower.c.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 显示`*strlower()*`函数完整源代码的在线仓库位于本书的在线资源库中，名为`strlower.c`。
- en: Exercise 7.2
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 练习7.2
- en: Write a function, *strcaps()*, that capitalizes the first letter of every word
    in a string. Process the text “This is a sample string” or a similar string that
    contains several words written in lowercase, including at least one one-letter
    word. The function modifies the string directly as opposed to generating a new
    string.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为`*strcaps()*`的函数，该函数将字符串中每个单词的首字母大写。处理文本“这是一个示例字符串”或类似的字符串，其中包含多个用小写写的单词，包括至少一个单字母单词。该函数直接修改字符串，而不是生成一个新的字符串。
- en: My solution is found in the online repository as strcaps.c. It contains comments
    that explain my approach.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我的解决方案可以在在线仓库中找到，名为`strcaps.c`。它包含解释我的方法的注释。
- en: 7.2.2 Reversing a string
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.2 反转字符串
- en: The key to changing the order of characters in a string is knowing the string’s
    length—where it starts and where it ends.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 改变字符串中字符顺序的关键是知道字符串的长度——它的起始位置和结束位置。
- en: For the string’s start, the string’s variable name is used, which holds the
    base address. The string’s ending address isn’t stored anywhere; the code must
    find the string’s terminating null character and then use math to calculate the
    string’s size. This math isn’t required in other programming languages, where
    every aspect of the string is fully known. Further, in C the string can be malformed,
    which would make the process impossible.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字符串的起始位置，使用字符串的变量名，它持有基本地址。字符串的结束地址没有存储在任何地方；代码必须找到字符串的终止空字符，然后使用数学方法计算字符串的大小。在其他编程语言中不需要这种数学计算，因为字符串的每个方面都是完全已知的。此外，在C语言中，字符串可能是不规则的，这会使这个过程变得不可能。
- en: Figure 7.1 illustrates a string lounging in memory, with both array and pointer
    notation calling out some of its parts. The terminating null character marks the
    end of the string, wherever its location may be, measured as offset n from the
    string’s start.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1说明了字符串在内存中的样子，数组表示法和指针表示法指出了它的一些部分。终止的空字符标志着字符串的结束，无论其位置如何，都从字符串的起始位置测量为偏移量n。
- en: '![07-01](Images/07-01.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![07-01](Images/07-01.png)'
- en: Figure 7.1 Measuring a string in memory
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 内存中字符串的测量
- en: The easiest way to locate the end of a string is to use the *strlen()* function.
    Add the function’s return value to the string’s starting location in memory to
    find the string’s end.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 定位字符串的末尾最简单的方法是使用`*strlen()*`函数。将函数的返回值加到字符串在内存中的起始位置，以找到字符串的末尾。
- en: 'For the do-it-yourself crowd, you can craft your own string-end function or
    loop to locate the string’s caboose. Assume that char pointer s references the
    string’s start and that *int* variable len is initialized to zero. If so, this
    *while* loop locates the string’s end, where the null character dwells:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于DIY爱好者，你可以自己编写字符串结束函数或循环来定位字符串的末尾。假设字符指针`s`引用字符串的起始位置，而`*int`变量`len`被初始化为零。如果是这样，这个`*while*`循环将定位字符串的末尾，即空字符所在的位置：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After this loop is complete, pointer *s references the string’s terminating
    null character, and the value of len is equal to the string’s length (minus the
    null character). Here is a more readable version of the loop:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个循环完成后，指针`s`引用字符串的终止空字符，而`len`的值等于字符串的长度（减去空字符）。以下是循环的更易读版本：
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The stupidest way to find the end of a string is to use the *sizeof* operator.
    The operator isn’t dumb, but when used on a *char* pointer argument, *sizeof*
    returns the number of bytes the pointer (memory address variable) occupies, not
    the size of the buffer the pointer references. For example, on my computer, a
    pointer is 4 bytes wide, so no matter what size buffer *s refers to, sizeof(s)
    always returns 4.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 找到字符串末尾最愚蠢的方法是使用 *sizeof* 操作符。操作符并不愚蠢，但当它用于 *char* 指针参数时，*sizeof* 返回指针（内存地址变量）占用的字节数，而不是指针引用的缓冲区的大小。例如，在我的计算机上，指针宽度为
    4 字节，因此无论 *s* 指向的缓冲区大小如何，sizeof(s) 总是返回 4。
- en: After obtaining the string’s length, the reversing process works backgrounds
    through the string, copying each character into another buffer, front to back.
    The result is a new string containing the reverse character order of the original.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在获得字符串长度后，反转过程在字符串的背景中工作，将每个字符复制到另一个缓冲区中，从前往后。结果是包含原始字符串反向字符顺序的新字符串。
- en: The *strrev()* function shown in the next listing creates a new string, reversed.
    First, a *while* loop calculates the string’s size (argument *s). Second, storage
    is allocated for the new string based on the original string’s size. I don’t need
    to +1 in the *malloc()* statement to make room for the null character, because
    variable len already references the null character’s offset. Finally, a *while*
    loop processes string s backward as it fills string reversed with characters.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表中所示的 *strrev()* 函数创建了一个新的反转字符串。首先，一个 *while* 循环计算字符串的大小（参数 *s*）。其次，根据原始字符串的大小分配新字符串的存储空间。我不需要在
    *malloc()* 语句中 +1 来为空字符腾出空间，因为变量 len 已经引用了空字符的偏移量。最后，一个 *while* 循环在填充字符串 reversed
    时以反向顺序处理字符串 s。
- en: Listing 7.5 The *strrev()* function
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.5 *strrev()* 函数
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Variable len contains the offset of the null character and also the string’s
    length.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 变量 len 包含了空字符的偏移量以及字符串的长度。
- en: ❷ Loops until *s references the null character terminating the passed string
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 循环直到 *s 指向传递的字符串终止的空字符
- en: ❸ Allocates storage for the reversed string; same length as the passed string
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为反转字符串分配存储空间；与传递的字符串长度相同
- en: ❹ Backs up s over the terminating null character; it now points to the last
    character in the passed string
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将 s 回退到终止的空字符；现在它指向传递的字符串中的最后一个字符
- en: ❺ Indexes into the new string, reversed
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在新字符串中索引，并反转
- en: ❻ Copies the number of characters in the original string
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 复制原始字符串中的字符数
- en: ❼ Copies the characters
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 复制字符
- en: ❽ Increments the offset for the reversed string
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 增加反转字符串的偏移量
- en: ❾ Decrements the offset for the original string
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 减少原始字符串的偏移量
- en: ❿ Backs up the pointer
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 回退指针
- en: ⓫ Always cap a newly constructed string with the null character!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 总是使用空字符为新构造的字符串加顶！
- en: ⓬ Don’t free the pointer here! Its data must be retained.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ⓬ 在这里不要释放指针！其数据必须保留。
- en: 'This function is included with the source code for strrev.c, found in the book’s
    online repository. In the *main()* function a sample string is output, and then
    the reversed string is output for comparison. Here’s a sample run:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数包含在 strrev.c 的源代码中，可在本书的在线仓库中找到。在 *main()* 函数中，输出一个示例字符串，然后输出反转后的字符串以进行比较。以下是一个示例运行：
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This code shows only one way to create a string reversal function, though the
    general approach is the same for all variations: work the original string backward
    to create the new string.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码仅展示了创建字符串反转函数的一种方法，尽管对于所有变体，通用方法都是相同的：反向处理原始字符串以创建新字符串。
- en: 7.2.3 Trimming a string
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.3 字符串修剪
- en: String-truncating functions are popular in other programming languages. For
    example, I remember the LEFT$, RIGHT$, and MID$ commands from my days of programming
    in BASIC. These commands lack similar functions in C, but they’re easy enough
    to craft. Figure 7.2 gives you an idea of what each one does.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串截断函数在其他编程语言中很受欢迎。例如，我记得我在 BASIC 编程时代使用的 LEFT$、RIGHT$ 和 MID$ 命令。C 语言中没有类似的功能，但它们很容易创建。图
    7.2 展示了每个命令的作用。
- en: '![07-02](Images/07-02.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![07-02](Images/07-02.png)'
- en: 'Figure 7.2 Extracting portions of a string: left, middle, and right'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 提取字符串的部分：左、中、右
- en: 'Each function requires at least two arguments: a string to slice and a character
    count. The middle extraction function also requires an offset. For my approach,
    I decided to return a new string containing the desired chunk, which leaves the
    original string intact.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数至少需要两个参数：要切片的字符串和字符计数。中间提取函数还需要一个偏移量。对于我的方法，我决定返回一个包含所需块的新字符串，这样就不会破坏原始字符串。
- en: The next listing shows my concoction of a *left(* function, which extracts len
    characters from the passed string s. As with each of these trimming functions,
    storage is allocated for a new string. The *left()* function is the easiest to
    code because it copies the first len characters of the passed string s into the
    target string buf. The address of buf is returned.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表展示了我对 *left()* 函数的创造，它从传入的字符串 s 中提取 len 个字符。与每个修剪函数一样，为新字符串分配了存储空间。*left()*
    函数是最容易编码的，因为它将传入字符串 s 的前 len 个字符复制到目标字符串 buf 中。buf 的地址被返回。
- en: Listing 7.6 The *left()* function
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.6 *left()* 函数
- en: '[PRE24]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Storage for the new string
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 用于新字符串的存储空间
- en: ❷ Allocates storage for the new string, plus one for the null character
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为新字符串分配存储空间，加上一个空字符
- en: ❸ Copies the len characters
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 复制 len 个字符
- en: ❹ Checks for an unexpected null character and terminates the loop if found
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 检查是否存在意外的空字符，并在找到时终止循环
- en: ❺ Copies characters
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 复制字符
- en: ❻ Caps the newly created string
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 为新创建的字符串添加结束符
- en: Figure 7.3 illustrates the guts of the left() function.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 展示了 left() 函数的内部结构。
- en: '![07-03](Images/07-03.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![07-03](Images/07-03.png)'
- en: Figure 7.3 The way the *left()* function slices a string
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 *left()* 函数切割字符串的方式
- en: Unlike the *left()* function, chopping off the right side of a string requires
    that the program knows where the string ends. From the preceding section, you
    recall that C doesn’t track a string’s tail. Your code must hunt down that terminating
    null character. For the *right()* function, I count backward from the null character
    to lop off the right side of the string.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 与 *left()* 函数不同，切割字符串的右侧需要程序知道字符串的结束位置。从前面章节中，你可能会记得 C 语言不跟踪字符串的尾部。你的代码必须找到那个终止的空字符。对于
    *right()* 函数，我从一个空字符开始向后计数，以截断字符串的右侧。
- en: My *right()* function is shown in the following listing. It borrows its allocation
    routine from the *left()* function shown in listing 7.6\. After the buffer is
    created, the code hunts for the end of the string, moving the pointer start to
    this location. Then the value of len is subtracted from start to reposition the
    pointer to the beginning of the right-end string chunk desired. Then len number
    of characters are copied into the new string.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我的 *right()* 函数如下所示。它从列表 7.6 中显示的 *left()* 函数借用了其分配例程。在创建缓冲区之后，代码寻找字符串的末尾，将指针起始位置移动到该位置。然后从
    start 减去 len 的值，将指针重新定位到所需的右端字符串块的开头。然后，将 len 个字符复制到新字符串中。
- en: Listing 7.7 The *right()* function
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.7 *right()* 函数
- en: '[PRE25]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ Uses the pointer start as the offset to retain for later the address in variable
    s
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用指针 start 作为偏移量，保留变量 s 中的地址以供以后使用
- en: ❷ Searches for the end of the string
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 搜索字符串的末尾
- en: ❸ Adjusts the pointer start to reference where the right end of the string starts
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 调整指针起始位置以引用字符串右端开始的位置
- en: ❹ Checks for underflow and exits if true
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 检查下溢并退出，如果为真
- en: ❺ Copies the rightmost portion of the string into the new buffer
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将字符串的最右侧部分复制到新缓冲区中
- en: ❻ Caps the newly created string
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 为新创建的字符串添加结束符
- en: The *right()* function’s operation is illustrated in figure 7.4.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*right()* 函数的操作在图 7.4 中展示。'
- en: '![07-04](Images/07-04.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![07-04](Images/07-04.png)'
- en: Figure 7.4 The calculations made to extract the right side of a string
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 展示了提取字符串右侧的计算
- en: 'The final string-trimming function is really the only one you need: when given
    the proper arguments, the mid() function can easily substitute for the *left()*
    or *right()* functions. In fact, these two functions could be macros based on
    *mid()*. I blab more on this topic in a few paragraphs.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个字符串修剪函数实际上是唯一需要的：当给定适当的参数时，mid() 函数可以轻松地替代 *left()* 或 *right()* 函数。实际上，这两个函数可以基于
    *mid()* 定义为宏。我将在接下来的几段中详细讨论这个话题。
- en: 'My *mid()* function has three arguments:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我的 *mid()* 函数有三个参数：
- en: '[PRE26]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Pointer s references the string to slice. Integer offset is the character position
    to start extraction. And integer len is the number of characters to extract.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 指针 s 引用要切割的字符串。整数偏移量是提取开始的字符位置。整数 len 是要提取的字符数。
- en: 'The full *mid()* function is shown in listing 7.8\. It performs a straight
    character-by-character copy from the passed string s into the new string buffer
    buf. The key, however, is adding the offset value when passing the characters:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 *mid()* 函数在列表 7.8 中展示。它从传入的字符串 s 直接逐字符复制到新的字符串缓冲区 buf。然而，关键在于在传递字符时添加偏移量值：
- en: '[PRE27]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The offset value must be reduced by 1 to account for the fact that characters
    in the string start at offset 0, not offset 1\. If I were to write documentation
    for the function, I’d need to explain that valid values for argument offset are
    in the range of 1 through the string’s length. Unlike in C coding, you don’t want
    to start with zero—though you could. Again, state so in the function’s documentation.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 偏移值必须减 1，以考虑到字符串中的字符从偏移 0 开始，而不是偏移 1。如果我要为该函数编写文档，我需要解释有效偏移量参数的范围是 1 到字符串长度。与
    C 编码不同，你不想从零开始——尽管你可以。再次强调，在函数的文档中说明这一点。
- en: Listing 7.8 The *mid()* function
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.8 *mid()* 函数
- en: '[PRE28]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ Copies len number of characters
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 复制 len 个字符
- en: ❷ The offset value is decreased by 1 because the first character is offset 0,
    not offset 1.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 偏移量值减 1，因为第一个字符的偏移是 0，而不是偏移 1。
- en: ❸ Catches any overflow and stops
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 捕获任何溢出并停止
- en: ❹ Always cap a string you’ve created yourself.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 总是给你自己创建的字符串加上标题。
- en: Figure 7.5 illustrates how the *mid()* function operates.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 展示了 *mid()* 函数的工作方式。
- en: '![07-05](Images/07-05.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![07-05](Images/07-05.png)'
- en: Figure 7.5 The operations of the *mid()* function
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 *mid()* 函数的操作
- en: 'As I wrote earlier, the *left()* and *right()* functions are easily reproduced
    by using specific formats for the *mid()* function. If you were to write a macro
    for the *left()* function, you could use this format:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所写，通过使用 *mid()* 函数的特定格式，可以轻松地复制 *left()* 和 *right()* 函数。如果你要为 *left()* 函数编写宏，可以使用此格式：
- en: '[PRE29]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With an offset of 1, this mid() function returns the leftmost len characters
    of string s. (Remember, the offset value is reduced by 1 in the *mid()* function.)
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当偏移量为 1 时，此 mid() 函数返回字符串 s 的最左侧 len 个字符。（记住，在 *mid()* 函数中，偏移值会减 1。）
- en: 'Crafting the *right()* function equivalent of *mid()* requires that the string’s
    length be obtained in the call:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建与 *mid()* 等效的 *right()* 函数，需要在调用中获取字符串的长度：
- en: '[PRE30]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The second argument is the string’s length (obtained by the *strlen()* function),
    minus the number of characters desired. It bothers me to call the *strlen()* function
    in a macro, but my point is more to show that the true power function for string
    slicing is the *mid()* function.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是字符串的长度（由 *strlen()* 函数获得），减去所需的字符数。我在宏中调用 *strlen()* 函数让我感到烦恼，但我的观点更多的是要展示字符串切片的真正强大函数是
    *mid()* 函数。
- en: You can find all these string-trimming functions—*left()*, *right()*, and *mid()*—in
    the source code file trimming.c, found in this book’s online repository.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书在线仓库中找到所有这些字符串修剪函数——*left()*, *right()*, 和 *mid()*——位于 trimming.c 源代码文件中。
- en: 7.2.4 Splitting a string
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.4 分割字符串
- en: I wrote my string-splitting function out of spite. Another programmer, a disciple
    of one of those fancy new languages, scoffed, “You can’t even split a string in
    C with fewer than 20 lines of code.”
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我编写我的字符串分割函数是出于愤怒。另一位程序员，一位那些花哨新语言的信徒嘲笑说：“你甚至不能用少于 20 行代码在 C 中分割字符串。”
- en: Challenge accepted.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 接受挑战。
- en: 'Though I can easily code a string-splitting function in C with fewer than 20
    lines of code, one point I must concede is that such a function requires at least
    four arguments:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我可以轻松地用少于 20 行代码在 C 中编写字符串分割函数，但我必须承认的一个观点是，这样的函数至少需要四个参数：
- en: '[PRE31]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Pointer org references the string to split. Integer offset is the location of
    the split. And the last two pointers, s1 and s2, contain the two sides of the
    split. These pointers are passed by reference, which allows the function to access
    and modify their contents.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 指针 org 引用要分割的字符串。整数偏移量是分割的位置。最后两个指针，s1 和 s2，包含分割的两部分。这些指针通过引用传递，允许函数访问和修改其内容。
- en: The next listing shows my *strsplit()* function, with its cozy 15 lines of code—and
    no obfuscation. I used white space and indents as I normally do. The size of the
    original string is obtained and used to allocate storage for s1 and s2. Then the
    *strncpy()* function copies the separate portions of the original string into
    the separate strings. The function returns 1 upon success, and 0 when things foul
    up.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了 my *strsplit()* 函数，它有 15 行简洁的代码——没有任何混淆。我使用了通常使用的空白和缩进。获取原始字符串的大小并用于为
    s1 和 s2 分配存储空间。然后，*strncpy()* 函数将原始字符串的各个部分复制到单独的字符串中。函数在成功时返回 1，在出错时返回 0。
- en: Listing 7.9 The *strsplit()* function
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.9 *strsplit()* 函数
- en: '[PRE32]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ Obtains the original string’s length
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取原始字符串的长度
- en: ❷ If the offset argument is out of range, return zero—error.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果偏移量参数超出范围，则返回零——错误。
- en: ❸ Allocates storage for split string 1, argument s1 dereferenced
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为拆分字符串 1 分配存储空间，参数 s1 取反
- en: ❹ Allocates storage for split string 2, calculating the proper size
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 为拆分字符串 2 分配存储空间，计算适当的大小
- en: ❺ Returns an error if either allocation fails
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果任一分配失败，则返回错误
- en: ❻ Copies the proper number of characters into the new strings
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将适当数量的字符复制到新字符串中
- en: The *strsplit()* function you see in listing 7.9 is my first version, where
    my goal was to see how few lines of code I could use. It calls C library string
    functions to perform some of the basic operations, which means this version of
    the *strsplit()* function relies upon the string.h header file. I wrote another
    version that avoids using the string library functions, though its code is obviously
    much longer.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.9 中所示的 *strsplit()* 函数是我的第一个版本，我的目标是看看我能用多少行代码实现。它调用 C 库字符串函数执行一些基本操作，这意味着这个版本的
    *strsplit()* 函数依赖于 string.h 头文件。我编写了另一个版本，避免了使用字符串库函数，尽管其代码显然更长。
- en: The *strsplit()* function shown in listing 7.9 is found in the online repository
    in the strsplit.c source code file.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.9 中所示的 *strsplit()* 函数可以在在线存储库中的 strsplit.c 源代码文件中找到。
- en: 7.2.5 Inserting one string into another
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.5 在另一个字符串中插入一个字符串
- en: 'When I originally thought of writing a string insertion function, I figured
    I’d use two C library string functions to accomplish the task: *strcpy()* and
    *strcat()*. These functions can build the string one step at a time: the *strcpy()*
    function copies one string to another, duplicating a string in another array or
    chunk of memory. The *strcat()* function sticks one string onto the end of another,
    creating a larger string. The inserted string is pieced together: original string,
    plus insert, plus the rest of the original string.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当我最初考虑编写字符串插入函数时，我想我会使用两个 C 库字符串函数来完成这项任务：*strcpy()* 和 *strcat()*. 这些函数可以一步一步地构建字符串：*strcpy()*
    函数将一个字符串复制到另一个，在另一个数组或内存块中复制一个字符串。*strcat()* 函数将一个字符串附加到另一个字符串的末尾，创建一个更大的字符串。插入的字符串被拼接起来：原始字符串，加上插入的文本，再加上原始字符串的其余部分。
- en: 'The function would have this declaration:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 函数将具有以下声明：
- en: '[PRE33]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Pointer org is the original string, which must be large enough to accommodate
    the inserted text. Pointer ins is the string to insert; integer offset is the
    location (starting with 1) at which string ins is inserted into string org.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 指针 org 是原始字符串，它必须足够大以容纳要插入的文本。指针 ins 是要插入的字符串；整数偏移量是字符串 ins 插入到字符串 org 中的位置（从
    1 开始）。
- en: My *strinsert()* function returns 1 upon success, 0 on error.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我的 *strinsert()* 函数在成功时返回 1，在错误时返回 0。
- en: It didn’t work.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这没有奏效。
- en: The problem with using *strcpy()* and *strcat()* is that I must split the original
    string, save the remainder, and then build final string. This step requires a
    temporary buffer for the remainder of string org at position offset, as illustrated
    in figure 7.6\. Then string ins is concatenated to the new end of string org,
    then the original end of string org is concatenated to the result. Messy.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *strcpy()* 和 *strcat()* 的问题是我必须拆分原始字符串，保存剩余部分，然后构建最终字符串。这一步需要一个临时缓冲区来存储字符串
    org 在偏移量位置上的剩余部分，如图 7.6 所示。然后，将字符串 ins 连接到字符串 org 的新末尾，然后将原始字符串 org 的末尾连接到结果。很混乱。
- en: '![07-06](Images/07-06.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![07-06](Images/07-06.png)'
- en: Figure 7.6 The process of using string library functions makes inserting a string
    overly complex.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 使用字符串库函数的过程使得插入字符串过于复杂。
- en: 'Further, as shown in figure 7.6, the hope is that the user has allocated enough
    storage for the original string org to accommodate the inserted text. To me, this
    hope is too risky, so I changed my approach. Here is the function’s updated declaration:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如图 7.6 所示，希望用户已经为原始字符串 org 分配了足够的存储空间以容纳要插入的文本。对我来说，这个希望太冒险了，所以我改变了我的方法。以下是函数更新的声明：
- en: '[PRE34]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The function’s return value is a newly created string, which avoids the necessity
    that string org be large enough to also accommodate inserting string ins. Returning
    the string, that is, creating it within the function, also avoids having to temporarily
    store the remainder of string org for concatenation later.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的返回值是一个新创建的字符串，这避免了字符串 org 需要足够大以容纳插入字符串 ins 的必要性。返回字符串，即在函数内创建它，也避免了需要临时存储字符串
    org 的剩余部分以供稍后连接。
- en: In this new approach, I build the new string character by character, inserting
    string ins at offset characters as the new string is built. Figure 7.7 illustrates
    how the improved version of the function operates.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种新的方法中，我逐个字符地构建新的字符串，在构建新字符串时在偏移量字符处插入字符串 ins。图 7.7 阐述了函数改进版本的运行方式。
- en: '![07-07](Images/07-07.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![07-07](Images/07-07.png)'
- en: Figure 7.7 The improved technique for inserting one string into another
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 将一个字符串插入另一个字符串的改进技术
- en: Rather than use the *strcat*() and *strcpy()* functions, my improved version
    of the *strinsert()* function copies characters sequentially from string org into
    a newly created buffer, new. Once the character count is equal to offset, characters
    are copied from string ins into the newly created buffer. After that, the count
    continues from string org.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用 *strcat*() 和 *strcpy()* 函数，我改进的 *strinsert()* 函数将字符顺序地从字符串 org 复制到一个新创建的缓冲区
    new 中。一旦字符计数等于偏移量，就从字符串 ins 复制字符到新创建的缓冲区。之后，计数从字符串 org 继续进行。
- en: You find the full *strinsert()* function in the following listing. It builds
    the string new character by character from arguments org and ins. The C library’s
    *strlen()* function is used; otherwise, the string is built using statements within
    the function.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书在线仓库中找到完整的 *strinsert()* 函数，它从参数 org 和 ins 构建字符串 new，使用 C 库的 *strlen()*
    函数；否则，字符串使用函数内的语句构建。
- en: Listing 7.10 The *strinsert()* function
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.10 *strinsert()* 函数
- en: '[PRE35]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ Obtains the size of the new string
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取新字符串的大小
- en: ❷ Returns an empty string if the offset is a silly value
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果偏移量是一个愚蠢的值，则返回空字符串
- en: ❸ Allocates storage for the new string
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为新字符串分配存储空间
- en: ❹ Reduces the offset value to account for strings starting at 0, not 1
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 减少偏移量值以考虑字符串从 0 开始而不是 1
- en: ❺ Indexes to track progress through new string
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 跟踪通过新字符串的进度
- en: ❻ Status variable to track whether ins string has been inserted
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 状态变量用于跟踪 ins 字符串是否已被插入
- en: ❼ Loops through the original string
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 遍历原始字符串
- en: ❽ Immediately checks for the offset value to account for offset = 0
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 立即检查偏移量值以处理 offset = 0 的情况
- en: ❾ Inserts ins string, adding it to string new
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 插入 ins 字符串，将其添加到字符串 new 中
- en: ❿ Marks that the string has been inserted
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 标记字符串已被插入
- en: ⓫ Continues building the new string from the original string
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 从原始字符串继续构建新字符串
- en: ⓬ Confirms that a string was inserted; if not, string ins is appended
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ⓬ 确认已插入字符串；如果没有，则将字符串 ins 追加
- en: ⓭ Always cap a string you create yourself!
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ⓭ 总是首字母大写你自己创建的字符串！
- en: 'In the function, I tried to handle a condition when the offset argument is
    larger than the length of string org. I couldn’t quite get it to work, so I decided
    to use the out-of-range value as a feature: if the value of offset is longer than
    string org, string ins is appended to string org regardless of the offset value.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数中，我尝试处理偏移量参数大于字符串 org 长度的情况。我无法让它正常工作，所以我决定将超出范围的值作为一个特性：如果偏移量的值大于字符串 org，则无论偏移量值如何，都将字符串
    ins 追加到字符串 org。
- en: 'You can find the *strinsert()* function inside the source code file strinsert.c
    in this book’s online repository. Here is the program’s output, where the string
    “fine” (plus a space) is inserted into the string “Well, this is another mess!”
    at offset 23:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书在线仓库的源代码文件 strinsert.c 中找到 *strinsert()* 函数。以下是程序的输出，其中字符串“fine”（加上一个空格）被插入到字符串“Well,
    this is another mess!”的偏移量 23 处：
- en: '[PRE36]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 7.2.6 Counting words in a string
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.6 在字符串中计数单词
- en: To solve the puzzle of counting words in a string, you must write code that
    recognizes when a word starts. You’ve already written such code if you completed
    exercise 7.2, which capitalizes the first character of words in a string. The
    *strcaps()* function can be modified to count words rather than convert characters
    to uppercase.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决在字符串中计数单词的难题，你必须编写能够识别单词开始位置的代码。如果你完成了练习 7.2，你已经编写了这样的代码，它将字符串中单词的第一个字符转换为大写。可以将
    *strcaps()* 函数修改为计数单词而不是将字符转换为大写。
- en: The next listing shows an update to my solution for exercise 7.2 (do you regret
    reading this chapter front-to-back?), where the *strwords()* function consumes
    a string’s characters in sequence, one after the other. The variable inword determines
    whether the current character is inside a word. Each time a new word starts, variable
    count is incremented.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表展示了针对练习 7.2 的解决方案的更新（你后悔按顺序阅读这一章了吗？），其中 *strwords()* 函数按顺序逐个消费字符串的字符。变量
    inword 决定当前字符是否在单词内部。每次新单词开始时，变量 count 就会增加。
- en: Listing 7.11 The *strwords()* function inside source code strwords.c
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.11 源代码文件 strwords.c 中的 *strwords()* 函数
- en: '[PRE37]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ❶ Creates the constants FALSE=0 and TRUE=1
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建常量 FALSE=0 和 TRUE=1
- en: ❷ Starts out assuming the code isn’t reading inside of a word
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 假设代码没有在单词内部读取
- en: ❸ Word count initialized
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 初始化单词计数
- en: ❹ Loops through string s
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 遍历字符串 s
- en: ❺ Is the current letter alphabetic?
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 当前字母是否为字母？
- en: ❻ Confirms that a word isn’t being processed
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 确认正在处理的不是一个单词
- en: ❼ Inside the word, increments the count
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 在单词内部增加计数
- en: ❽ Resets the inword variable
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 重置 inword 变量
- en: ❾ For nonalpha characters, inword is FALSE
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 对于非字母字符，inword 是 FALSE
- en: 'Here is a sample run of the strwords.c program:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 strwords.c 程序的一个示例运行：
- en: '[PRE38]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If you change the word is to isn’t in the string, here is the modified output:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将字符串中的 word 改为 isn’t，这里是将修改后的输出：
- en: '[PRE39]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Hmmm.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯嗯。
- en: Exercise 7.3
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 7.3
- en: Modify the *strwords()* function shown in listing 7.11 so that it accounts for
    contractions. This task has a simple solution, one that’s presented in the first
    C language programming book, *The C Programming Language*, by Brian Kernighan
    and Dennis Ritchie (Pearson, 1988). Without cheating, see if you can accomplish
    the same task.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 修改列表 7.11 中所示的 *strwords()* 函数，使其能够处理缩写。这个任务有一个简单的解决方案，它是在第一本 C 语言编程书籍《C 程序设计语言》中提出的，由
    Brian Kernighan 和 Dennis Ritchie 编写（Pearson，1988年）。不作弊，看看你是否能完成同样的任务。
- en: My solution is titled strwords2.c, and it’s available in this book’s online
    repository.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我的解决方案名为 strwords2.c，并且可以在本书的在线仓库中找到。
- en: 7.2.7 Converting tabs to spaces
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.7 将制表符转换为空格
- en: 'The terminal you use in Linux is smart enough to output tab characters to the
    next virtual tab stop on the display. These tab stops are set at 8 characters
    by default. Some shells, such as *bash* and *zsh*, feature the *tabs* command,
    which can set the tab stops to a different character interval: for example, tabs
    4 sets a terminal tab stop that is 4 characters wide.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中使用的终端足够智能，能够输出制表符到显示器的下一个虚拟制表位。这些制表位默认设置为8个字符。一些shell，如 *bash* 和 *zsh*，具有
    *tabs* 命令，可以将制表位设置为不同的字符间隔：例如，tabs 4 设置一个宽度为4个字符的终端制表位。
- en: 'The following *printf()* statement outputs a string with two tab characters:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 *printf()* 语句输出包含两个制表符的字符串：
- en: '[PRE40]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here is the output:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE41]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The tab character didn’t expand to a constant number of characters. Instead,
    it’s interpreted by the shell and expanded to the next virtual tab stop at 8-character
    intervals across the display. This effect ensures that columns line up perfectly
    as you use tabs to line up text or create tables.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 制表符没有扩展为固定数量的字符。相反，它被shell解释，并在显示器的8个字符间隔的下一个虚拟制表位处扩展。这种效果确保了使用制表符对齐文本或创建表格时，列能够完美对齐。
- en: Obviously, you don’t need to convert tabs into spaces for output on the terminal.
    But one function you can write is one that sets variable-width tab stops in a
    program’s output. The width for these tab stops is created by outputting spaces;
    this book doesn’t go into terminal hardware programming.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你不需要将制表符转换为空格来在终端上输出。但你可以编写一个函数，该函数可以在程序输出中设置可变宽度的制表位。这些制表位的宽度是通过输出空格来创建的；本书不涉及终端硬件编程。
- en: 'To set a tab stop, you must know where text output is going across the screen—the
    current column value. This value is compared with the tab stop width desired,
    using the following equation:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置制表位，你必须知道文本输出在屏幕上的位置——当前列值。这个值与所需的制表位宽度进行比较，使用以下公式：
- en: '[PRE42]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here is how this statement works out:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这个语句是如何工作的：
- en: '![07-07_UN01](Images/07-07_UN01.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![07-07_UN01](Images/07-07_UN01.png)'
- en: The (column % tab) expression returns the number of spaces since the last tab
    stop interval (tab) based on the cursor’s current column offset (column). To obtain
    the number of spaces until the next tab stop, this value is subtracted from the
    tab stop width. The result is the number of spaces required to line up the next
    character output with a tab stop.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: (column % tab) 表达式返回自上次制表位间隔（tab）以来基于光标当前列偏移量（column）的空格数。为了获得到下一个制表位的空格数，从这个值中减去制表位宽度。结果是输出下一个字符与制表位对齐所需的空格数。
- en: The tab calculation equation exists as a statement in the *strtabs()* function,
    shown in the next listing. The function outputs a string, carefully checking each
    character for the tab, \t. When encountered, the next tab stop offset is calculated,
    and the given number of spaces are output.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 制表位计算公式作为 *strtabs()* 函数中的一个语句存在，该函数在下一列表中显示。该函数输出一个字符串，仔细检查每个字符是否有制表符，\t。当遇到时，计算下一个制表位偏移量，并输出给定数量的空格。
- en: Listing 7.12 The *strtabs()* function inside source code file strtabs.c
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.12 源代码文件 strtabs.c 中的 *strtabs()* 函数
- en: '[PRE43]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ❶ The column variable tracks the current column position.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 列变量跟踪当前列位置。
- en: ❷ Loops through the string
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 遍历字符串
- en: ❸ Catches the tab character
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 捕获制表符
- en: ❹ Calculates the number of spaces to output to line up at the next tab stop
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 计算输出到下一个制表位所需的空格数
- en: ❺ Outputs the required spaces
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 输出所需空格
- en: ❻ Updates the column offset
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 更新列偏移量
- en: ❼ Handles other characters here
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 在此处处理其他字符
- en: ❽ If a newline is output, resets the column value
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 如果输出换行符，则重置列值
- en: '❾ Nested loop to output the three sample strings at three different tab stops:
    4, 8, and 16 spaces'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 嵌套循环以在三个不同的制表符位置输出三个示例字符串：4、8和16个空格
- en: 'The program’s output generates three strings, with different tab patterns using
    three different tab stop settings. Here’s the output:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出生成三个字符串，使用三个不同的制表符设置的不同制表符模式。以下是输出：
- en: '[PRE44]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: When the terminal window encounters a tab, it doesn’t convert the tab into multiple
    spaces like the strtabs.c program does. For the terminal window, the cursor itself
    moves the required number of character positions across the screen; spaces aren’t
    output. To prove so, take the standard output of some program that generates tabs
    and look at the raw data. You see tab characters (ASCII 9) instead of a series
    of spaces.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 当终端窗口遇到制表符时，它不会像strtabs.c程序那样将制表符转换为多个空格。对于终端窗口，光标本身在屏幕上移动所需的字符位置；不会输出空格。为了证明这一点，可以查看生成制表符的某些程序的输出，并查看原始数据。你会看到制表符字符（ASCII
    9），而不是一系列空格。
- en: 7.3 A string library
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 字符串库
- en: One of the best ways to put all string-manipulation functions to work, or to
    deal with any targeted collection of functions, is to create your own custom library.
    It’s a way to share the functions with others or have them ready for yourself
    in a practical way.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有字符串操作函数投入使用或处理任何特定的函数集合的最好方法之一是创建自己的自定义库。这是一种与他人共享函数或以实用方式为自己准备函数的方法。
- en: 'You know about other libraries and have probably used them, such as the math
    library. Creating these tools isn’t that difficult, nor is knowing how to create
    them a secret: if you know how to compile code, you can create a library.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经了解其他库并可能使用过它们，例如数学库。创建这些工具并不困难，了解如何创建它们也不是秘密：如果你知道如何编译代码，你就可以创建一个库。
- en: All C libraries are created by someone—some clever coder who cobbles together
    functions and other elements required to let you share in their genius. Even the
    C standard library is written and maintained by C coders, the high lords of the
    programming realm.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的C库都是由某人创建的——一些聪明的程序员将函数和其他必需元素拼凑在一起，以便让你分享他们的天才。即使是C标准库也是由C程序员编写的，他们是编程领域的最高统治者。
- en: Using your string library is as easy as using another library; your string library
    is linked into the object code file at build time. The functions are prototyped
    and supported by a custom header file. Everything works for your library just
    as it does for other libraries.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的字符串库就像使用其他库一样简单；你的字符串库在构建时被链接到目标代码文件中。函数由自定义头文件原型化和支持。对于你的库，一切工作方式与其他库相同。
- en: For the string library, I’ll include many of the functions demonstrated in this
    chapter. If you have additional, favorite string functions, feel free to add them
    as well. Directions throughout this section explain the details and offer tips
    for creating your own custom library.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字符串库，我将包括本章中展示的许多函数。如果你有额外的、喜欢的字符串函数，也请随意添加。本节中的说明解释了细节，并提供了创建你自己的自定义库的技巧。
- en: 7.3.1 Writing the library source and header file
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.1 编写库源文件和头文件
- en: 'Creating a library starts with a source code editor. Your goal is to create
    two files at minimum:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 创建库从源代码编辑器开始。你的目标是至少创建两个文件：
- en: A source code file
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码文件
- en: A header file containing the functions’ prototypes
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含函数原型的头文件
- en: The source code is one or more files (depending on how you work) containing
    all the functions for the library—just the functions. You don’t need a *main()*
    function, because you’re building a library, not a program. This file is compiled
    just like any other source code file, but it’s not linked. You need only the object
    code file, .o, to create the library.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码是一个或多个文件（取决于你的工作方式），包含库中所有函数——仅仅是函数。你不需要`main()`函数，因为你正在构建一个库，而不是一个程序。这个文件就像任何其他源代码文件一样编译，但它不会被链接。你只需要目标代码文件（.o），就可以创建库。
- en: The library also requires a header file, which contains the function prototypes’s
    defined constants, necessary includes, and other goodies that assist the functions.
    For example, if a function uses a structure, it must be declared in the source
    code file as well as in the header file. Programmers who use your library need
    the structure definition to make the function work. The header file is where you
    put these things, and it’s where they’re referenced when programmers use your
    library.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 库还需要一个头文件，该头文件包含函数原型的定义常量、必要的包含文件以及其他有助于函数的元素。例如，如果一个函数使用一个结构体，那么它必须在源代码文件和头文件中声明。使用你的库的程序员需要结构定义来使函数工作。头文件是放置这些元素的地方，也是程序员使用你的库时引用这些元素的地方。
- en: 'In listing 7.13, you see the first part of the mystring.c source code file,
    which contains many of the string functions demonstrated in this chapter. The
    file has descriptive comments, which can be expanded to show version history,
    offer tips, and provide examples. The #include directives in the source code file
    are required for the functions, just as they would be in any source code file.
    Further, see how I’ve feebly attempted to document each function, showing the
    arguments and return value? Yes, this information can be expanded upon; documentation
    is good.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在图7.13中，你可以看到mystring.c源代码文件的第一部分，其中包含了许多在本章中演示的字符串函数。该文件包含描述性注释，这些注释可以扩展以显示版本历史、提供提示和示例。源代码文件中的#include指令对于函数是必需的，就像在任何源代码文件中一样。此外，看看我如何无力地尝试为每个函数编写文档，显示参数和返回值？是的，这些信息可以进一步扩展；文档是好的。
- en: Listing 7.13 The first part of the mystring.c library source code file
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.13 mystring.c库源代码文件的第一部分
- en: '[PRE45]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ❶ Comments introducing the library file
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 介绍库文件的注释
- en: ❷ Headers required for the functions in this file
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 本文件中函数所需的头文件
- en: ❸ Comments introducing and describing each function
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 介绍和描述每个函数的注释
- en: ❹ The function itself (continues)
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 函数本身（继续）
- en: The order of the functions inside the source code file doesn’t matter—unless
    one function references another. In such a situation, ensure that the referenced
    function appears before (above) the function it’s referenced in.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码文件中函数的顺序并不重要——除非一个函数引用了另一个函数。在这种情况下，确保被引用的函数出现在引用它的函数之前（上方）。
- en: The companion header file for your library isn’t listed in the library’s source
    code file (refer to listing 7.13). The header file is necessary to provide support
    for programmers who use your library; only if items in the header file are referenced
    in the code (defined constants, for example) do you need to include the library’s
    header file in the source code file. Key to the header file are the function prototypes,
    structures, global/external variable definitions, macros, and defined constants.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 你的库的伴随头文件没有在库的源代码文件中列出（参见图7.13）。头文件对于为使用你的库的程序员提供支持是必要的；只有当头文件中的项目（例如定义的常量）在代码中被引用时，你才需要在源代码文件中包含库的头文件。头文件的关键是函数原型、结构体、全局/外部变量定义、宏和定义的常量。
- en: As with the library’s source code file, I recommend commenting the header file
    to document its parts. Be helpful to your programmer pals. Further, I add version
    number defined constants to my header files, as shown here.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 就像库的源代码文件一样，我建议注释头文件以记录其各个部分。这对你的程序员朋友们会有帮助。此外，我在头文件中添加了定义的版本号常量，如下所示。
- en: Listing 7.14 The mystring.h header file to support the mystring library
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.14 支持mystring库的mystring.h头文件
- en: '[PRE46]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ❶ Details about your library header file in the comments
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在注释中介绍你的库头文件
- en: ❷ Version number defined constants
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 版本号定义的常量
- en: ❸ Function prototypes
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 函数原型
- en: Both files, the source code and header file, are necessary to use the library.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码文件和头文件都是使用库所必需的。
- en: 7.3.2 Creating a library
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.2 创建库
- en: Libraries are created from object code files. The *ar* (archive) utility is
    what transforms the object code file into a library. Therefore, the first step
    to creating a library is to compile—but not link—your library’s source code file.
    Once you have the compiled object code, you use the *ar* utility to create the
    library.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 库是从目标代码文件创建的。*ar*（归档）实用程序是将目标代码文件转换为库的工具。因此，创建库的第一步是编译——但不链接——你的库的源代码文件。一旦你有编译后的目标代码，你使用*ar*实用程序来创建库。
- en: 'For this example, I’m using the mystring.c source code file, which is available
    from this book’s online code repository. To compile the source code into object
    code, the -c switch is specified. This switch is available to all C compilers.
    Here is the command format for *clang*:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我使用的是 mystring.c 源代码文件，该文件可以从本书的在线代码仓库中获取。要将源代码编译成对象代码，指定 -c 开关。此开关对所有
    C 编译器都可用。以下是 *clang* 的命令格式：
- en: '[PRE47]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The -c switch directs *clang* to “compile only.” The source code file is compiled
    into object code, mystring.o, but it’s not linked to create a program. This step
    is repeated for all source code files, though you can specify the lot in a single
    command:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: -c 开关指示 *clang* “仅编译”。源代码文件被编译成对象代码 mystring.o，但不会链接以创建程序。这一步骤会为所有源代码文件重复进行，尽管你可以在一个命令中指定所有这些：
- en: '[PRE48]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'For this command, three object code files are created: first.o, second.o, and
    third.o.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个命令，创建了三个对象代码文件：first.o、second.o 和 third.o。
- en: 'The next step is to use the archive utility *ar* to build the library. This
    command is followed by three arguments: command switches, the name of the library
    file, and finally the object code files required to build the library. For example:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用归档工具 *ar* 来构建库。此命令后跟三个参数：命令开关、库文件名，以及最后构建库所需的对象代码文件。例如：
- en: '[PRE49]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here are what the switches do:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是开关的功能：
- en: -c—Creates the archive
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -c——创建归档
- en: -s—Indexes the archive
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -s——索引归档
- en: -r—Inserts file(s) into the archive
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -r——将文件（们）插入到归档中
- en: You can specify them as *-rcs* or *-r* *-c* *-s*—either way.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以指定它们为 *-rcs* 或 *-r* *-c* *-s*——两种方式都可以。
- en: The name of the library file will be libmystring.a. The *ar* utility uses the
    object code file mystring.o to create the library. If multiple object code files
    were required, specify them after mystring.o.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 库文件名将是 libmystring.a。*ar* 工具使用对象代码文件 mystring.o 来创建库。如果需要多个对象代码文件，请在 mystring.o
    之后指定它们。
- en: 'Upon success, the *ar* utility creates the library named libmystring.a. This
    naming format follows the convention used in Linux: libname.a. The library starts
    with lib, and then name, which is the library name. The filename extension is
    dot-a.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 成功后，*ar* 工具会创建名为 libmystring.a 的库。这种命名格式遵循 Linux 中的约定：libname.a。库以 lib 开头，然后是
    name，即库的名称。文件扩展名是点-a。
- en: The .a extension, as well as the process outlined in this section for creating
    a library, is designed for static library, as opposed to a dynamic library. The
    static model works best for this type of library, which is used only by command-line
    programs and doesn’t require the capabilities of a dynamic library. I do not cover
    dynamic libraries in this book.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: .a 扩展名以及本节中概述的创建库的过程是为静态库设计的，而不是动态库。静态模型最适合此类库，此类库仅由命令行程序使用，并且不需要动态库的功能。我在本书中不涉及动态库。
- en: 7.3.3 Using the string library
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.3 使用字符串库
- en: To use a library other than the standard C library, its name must be specified
    at build time. The -l (little L) switch is immediately followed by the library
    name. The name is the only part of the library filename used, not the first three
    letters (lib) or the .a extension.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用除标准 C 库之外的库，必须在构建时指定其名称。-l（小写的L）开关紧随库名称之后。名称是库文件名中使用的唯一部分，不是前三个字母（lib）或 .a
    扩展名。
- en: 'If you’ve copied the library into the /usr/local/lib folder, the linker searches
    for it there. Otherwise, the -L (big L) switch directs the linker to look in a
    specific directory for library files. For a library you create in the same folder
    as your program, such as when working the examples in this book, specify the -L.
    (dash-big L-period) switch to direct the linker to look in the current directory.
    For example:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经将库复制到了 /usr/local/lib 文件夹中，链接器会在这里搜索它。否则，-L（大写的L）开关会指示链接器在特定目录中查找库文件。对于与你的程序在同一文件夹中创建的库，例如在本书的示例中工作，指定
    -L（破折号-大写的L-点）开关以指示链接器在当前目录中查找。例如：
- en: '[PRE50]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: When *clang* builds the source code from libsample.c into a program, it directs
    the linker to look in the current directory (-L.) for the library file libmystring.h
    (-lmystring). The format for this command is important; the -l switch must be
    specified last or else you see linker errors. (Some compilers may be smart enough
    to discover the library switch as any command-line argument, though my experience
    leads me to recommend putting the -l switch last.)
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 当*clang*将libsample.c源代码构建成程序时，它将链接器指向当前目录（-L.）以查找库文件libmystring.h（-lmystring）。此命令的格式很重要；必须指定-l开关最后，否则你会看到链接器错误。（一些编译器可能足够智能，能够将库开关识别为任何命令行参数，尽管我的经验让我建议将-l开关放在最后。）
- en: The next listing shows the source code found in libsample.c, available in this
    book’s online repository. The *strcaps()* function at line 8 is part of the mystring
    library. Its prototype is found in the mystring.h header file (also included in
    the repository), though it’s the library that contains the function’s code. Line
    2 shows the header file in double quotes, which directs the compiler to locate
    it in the current directory.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了在本书的在线仓库中可找到的libsample.c源代码。第8行的*strcaps()*函数是mystring库的一部分。其原型可以在mystring.h头文件中找到（也包含在仓库中），尽管包含该函数代码的是库。第2行显示了双引号中的头文件，这指示编译器在当前目录中查找它。
- en: Listing 7.15 Source code for libsample.c
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.15 libsample.c的源代码
- en: '[PRE51]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: ❶ Looks in the current directory for this header file, which contains the prototype
    for the *strcaps()* function
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在当前目录中查找包含*strcaps()*函数原型的这个头文件
- en: ❷ This function is found in the libmystring.a library, linked in at build time.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 此函数位于libmystring.a库中，在构建时链接。
- en: 'Here is the program’s output when built and linked using the command shown
    earlier:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用前面显示的命令构建和链接程序时的输出：
- en: '[PRE52]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Just as you can place a copy of your personal library in the /usr/local/lib
    folder, you can place a copy of the library’s header file into the /usr/local/include
    folder. This step avoids having to use the double quotes to set the header file’s
    location; as with /usr/local/lib, the compiler scans the /usr/local/include folder
    for header files.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你可以将个人库的副本放在/usr/local/lib文件夹中一样，你可以在/usr/local/include文件夹中放置库的头文件副本。这一步避免了使用双引号来设置头文件的位置；与/usr/local/lib一样，编译器会扫描/usr/local/include文件夹以查找头文件。
- en: 7.4 A kinda OOP approach
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 一种类似OOP的方法
- en: C is a procedural programming language. Inelegantly put, this description means
    that C code runs from top to bottom, with one thing happening after another. Older
    programming languages like C are also procedural. The list includes BASIC, Fortran,
    COBOL, and other relics. But don’t let the antiquity fool you! COBOL programmers
    made bank during the Y2K crisis.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: C是一种过程式编程语言。不优雅地说，这个描述意味着C代码从上到下运行，一件事情接着另一件事情发生。像C这样的旧编程语言也是过程式的。这个列表包括BASIC、Fortran、COBOL和其他遗迹。但不要让它们的古老性欺骗了你！在Y2K危机期间，COBOL程序员赚了大钱。
- en: Newer programming languages are object-oriented. They approach the programming
    task differently, something you can read about in wonderful books about these
    popular and trendy digital dialects. Without getting too far into the weeds, and
    keeping this discussion vague to avoid the nitpickers, object-oriented programming
    (OOP) involves methods instead of functions. *Methods* work like functions, though
    they’re often a part of the data type they manipulate.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 较新的编程语言是面向对象的。它们以不同的方式处理编程任务，你可以在关于这些流行和趋势的数字方言的精彩书籍中了解到这一点。不要深入细节，保持这个讨论模糊以避免吹毛求疵，面向对象编程（OOP）涉及方法而不是函数。"方法"像函数一样工作，尽管它们通常是它们所操作的数据类型的一部分。
- en: 'For example, if you want to obtain the length of a string in the Java programming
    language, you use this construction:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想在Java编程语言中获取字符串的长度，你使用这个构造：
- en: '[PRE53]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The string variable is named Str. The dot operator accesses the *length()*
    method, which is attached to all string objects. (Get it?) The result returned
    is the number of characters in string Str. The equivalent C language statement
    is:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串变量命名为Str。点操作符访问附加到所有字符串对象上的*length()*方法。（明白了吗？）返回的结果是字符串Str中的字符数。等效的C语言语句是：
- en: '[PRE54]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The dot operator is also used in C, specifically in a structure. And one of
    the members of a string can be . . . a function. Surprise.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 点操作符也在C中使用，特别是在结构体中。字符串的一个成员可以是……一个函数。惊喜。
- en: 7.4.1 Adding a function to a structure
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.1 向结构体添加函数
- en: 'A structure contains members of specific data types: *int*, *float*, *char*,
    and so on. As it turns out, a function is also a data type, and it can serve as
    a member of a structure.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体包含特定数据类型的成员：*int*，*float*，*char*，等等。结果证明，函数也是一种数据类型，它可以作为结构体的成员。
- en: 'For comparison, if you’ve been around the C language a while, you know that
    many functions can accept another function as an argument; the *qsort()* function
    uses another function (its name as an address) as one of its arguments. As with
    functions as arguments, specifying a function as a structure member involves using
    a specific format:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 作为比较，如果你在 C 语言中已经有一段时间了，你知道许多函数可以接受另一个函数作为参数；*qsort()* 函数使用另一个函数（其名称作为地址）作为其参数之一。与作为参数的函数一样，指定函数作为结构体成员需要使用特定的格式：
- en: '[PRE55]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The type is a data type, the value returned from the function or *void* for
    nothing returned.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 类型是一个数据类型，函数返回的值或 *void* 表示没有返回值。
- en: The name is the function’s name, which is secretly a pointer. In this format,
    the function’s name isn’t followed by parentheses. Instead, the arguments item
    lists any arguments passed to the function.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 名称是函数的名称，这实际上是一个指针。在这个格式中，函数的名称后面不跟括号。相反，参数项列表出了传递给函数的任何参数。
- en: 'To form a clear picture, here is a structure definition that has a function
    as one of its members:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 为了形成一个清晰的画面，这里是一个结构定义，其中包含一个函数作为其成员之一：
- en: '[PRE56]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The str structure’s function member is referenced as the length. It takes a
    *const char* pointer—a string—as its argument. And it returns an *unsigned long*
    value. This declaration merely creates a function as a member of the str structure,
    which also contains a string member. To make the function member work, it must
    be assigned to a specific function. In this case, the function I have in mind
    is *strlen()*, which takes a *const char* pointer as an argument and returns an
    *unsigned long* value.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: str 结构体的函数成员被引用为 length。它接受一个 *const char* 指针——一个字符串——作为其参数。它返回一个 *unsigned
    long* 值。这个声明仅仅创建了一个作为 str 结构体成员的函数，该结构体还包含一个字符串成员。为了使函数成员工作，它必须被分配给一个特定的函数。在这种情况下，我心中的函数是
    *strlen()*，它接受一个 *const char* 指针作为参数并返回一个 *unsigned long* 值。
- en: 'Creating a structure merely defines its members. To use the structure, a variable
    of the structure type is created. Here, structure str variable str1 is created:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个结构体仅仅定义了其成员。要使用结构体，必须创建一个该结构体类型的变量。在这里，创建了结构体 str 变量 str1：
- en: '[PRE57]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'And its members must be assigned values. Here is how the length member is assigned:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 并且其成员必须被赋予值。以下是长度成员的赋值方式：
- en: '[PRE58]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The length member’s function is *strlen()*. It’s specified without the parentheses,
    prefixed by the ampersand to obtain its address. Once assigned, the function member
    can be called like any function. For example:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 长度成员的函数是 *strlen()*。它指定时没有括号，前缀是和符号以获得其地址。一旦分配，函数成员就可以像任何函数一样被调用。例如：
- en: '[PRE59]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Member str1.length is a function (secretly *strlen()*). It operates on the string
    member of the same structure, str1.string. The value returned, the length of the
    string, is stored in variable len.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 成员 str1.length 是一个函数（秘密中是 *strlen()*）。它操作的是同一结构体中的字符串成员，str1.string。返回的值，即字符串的长度，存储在变量
    len 中。
- en: The following listing demonstrates all these crazy steps in the source code
    for struct_funct.c. This file is available in this book’s online repository.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了 struct_funct.c 源代码中所有这些疯狂的步骤。此文件可在本书的在线仓库中找到。
- en: Listing 7.16 Source code for struct_funct.c
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.16 struct_funct.c 的源代码
- en: '[PRE60]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: ❶ Must include the string.h header for the definition of the strlen() function
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 必须包含 string.h 头文件以定义 strlen() 函数
- en: ❷ The function member of structure str
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 结构体 str 的函数成员
- en: ❸ Variable str1 is created of the str structure type.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建了一个 str 结构体类型的变量 str1。
- en: ❹ The string member is assigned.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 字符串成员被分配。
- en: ❺ The function is assigned, no parentheses, and prefixed by the address-of operator.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 函数被分配，没有括号，并且前缀是地址运算符。
- en: ❻ The function is called in the *printf()* statement.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 函数在 *printf()* 语句中被调用。
- en: 'Here is the program’s output:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序的输出：
- en: '[PRE61]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: I confess that the expression str1.length(str1.string) doesn’t magically transform
    C into an object-oriented programming language. Yet for those intrepid coders
    who strive to make C more OOP-like, this is the approach they take. They may even
    cobble together macros to make the contraption look cleaner, such as str.length(),
    which is what I’d be pleased with. Still, C wasn’t created to offer such constructions.
    Most coders who want to use OOP drift to languages such as C++, C#, and Python.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须承认，表达式 str1.length(str1.string) 并不能神奇地将 C 语言转变为面向对象编程语言。然而，对于那些努力使 C 语言更接近
    OOP 的勇敢程序员来说，这是他们采取的方法。他们甚至可能拼凑宏来使这个装置看起来更整洁，例如 str.length()，这正是我所期望的。尽管如此，C 语言并不是为了提供这样的结构而创建的。大多数想要使用
    OOP 的程序员会转向 C++、C# 和 Python 等语言。
- en: 7.4.2 Creating a string “object”
  id: totrans-428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.2 创建字符串“对象”
- en: I’m risking certain heresy charges and banishment from the C programming world,
    but it’s possible to further expand upon the idea of making C more OOP-like. Consider
    that you could create a string structure “object.” The problem with C is that
    the implementation must be done through functions.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 我冒着在 C 编程世界中受到异端指控并被放逐的风险，但可以进一步扩展使 C 语言更接近 OOP 的想法。考虑一下，你可以创建一个字符串结构“对象”。C
    语言的问题是实现必须通过函数来完成。
- en: 'For example, you could write a function to create the pseudo string object.
    The function would require a string structure to be passed. Such a structure might
    look like this:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以编写一个函数来创建伪字符串对象。这个函数需要一个字符串结构作为参数。这样的结构可能看起来像这样：
- en: '[PRE62]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This example is brief. You could add other string descriptors as structure members
    and perhaps a smattering of functions as well. But, for a pseudo string object
    demonstration, this construction is sufficient.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子很简单。你可以添加其他字符串描述符作为结构成员，也许还可以添加一些函数。但是，对于一个伪字符串对象的演示，这个结构已经足够了。
- en: 'To create the phony string object, a *string_create()* function is needed.
    This function is passed a pointer to a string structure along with the string’s
    contents (text):'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这个假字符串对象，需要一个 *string_create()* 函数。这个函数接收一个指向字符串结构的指针以及字符串的内容（文本）：
- en: '[PRE63]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The pointer is necessary to allow the function to modify the structure directly.
    Without the pointer, any changes made to the passed structure within the function
    are discarded. The string passed, v, is eventually incorporated into the structure
    along with other informative goodies.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 指针是必要的，以便函数可以直接修改结构。如果没有指针，函数中对传递的结构所做的任何更改都将被丢弃。传递的字符串 v 最终将与其他信息一起纳入结构中。
- en: 'The next listing illustrates the *string_create()* function. It returns TRUE
    or FALSE values depending on whether the object is successfully created: the string’s
    length is obtained and stored in the structure’s length member. This value is
    used to allocate storage for the string. I feel that allocating storage specifically
    for the string is better than duplicating the passed string’s pointer, which could
    change in the future.'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表展示了 *string_create()* 函数。它根据对象是否成功创建返回 TRUE 或 FALSE 值：获取并存储字符串的长度在结构的长度成员中。这个值用于为字符串分配存储空间。我认为为字符串分配特定的存储空间比复制传递的字符串指针更好，因为指针可能会在未来发生变化。
- en: Listing 7.17 The *string_create()* function
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.17 *string_create()* 函数
- en: '[PRE64]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: ❶ Confirms that a string is available; if not, returns FALSE
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 确认字符串可用；如果不可用，则返回 FALSE
- en: ❷ Assigns the string’s length
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 赋予字符串的长度
- en: ❸ Allocates storage for the string
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为字符串分配存储空间
- en: ❹ Copies the original string to newly allocated storage
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将原始字符串复制到新分配的存储空间
- en: ❺ Returns TRUE upon success
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 成功时返回 TRUE
- en: Just as an object is created, a companion *string_destroy()* function must exist.
    This function removes the object, which means deallocating the string’s storage
    and zeroing out any other structure members.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 正如创建对象一样，必须存在一个伴随的 *string_destroy()* 函数。这个函数移除对象，这意味着释放字符串的存储空间，并将任何其他结构成员设置为
    0。
- en: 'The next listing shows the *string_destroy()* function, called with the sole
    argument as the string structure to clear. The function does three things: frees
    the allocated memory, assigns the value pointer to NULL (which confirms that the
    memory is deallocated), and sets the string’s length to zero. This function doesn’t
    obliterate the structure variable, unlike OOP languages that may also remove the
    variable that’s created.'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表展示了 *string_destroy()* 函数，它使用唯一的参数作为要清除的字符串结构。该函数执行三项操作：释放分配的内存，将值指针赋值为
    NULL（这确认了内存已被释放），并将字符串的长度设置为 0。这个函数不会像面向对象的语言那样销毁结构变量。
- en: Listing 7.18 The *string_destroy()* function
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.18 *string_destroy()* 函数
- en: '[PRE65]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: ❶ Free string storage memory
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 释放字符串存储内存
- en: ❷ Assigns the pointer to NULL, which can be used later to test for a valid string
    structure
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将指针赋值为 NULL，这可以在以后用来测试字符串结构的有效性
- en: ❸ Resets the string length to zero
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将字符串长度重置为零
- en: Of course, after destroying a string structure variable, it can be reused or
    reassigned. The point is to have both a create function and a destroy function
    for the “object,” which mimics how some object-oriented programming languages
    work with objects.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在销毁字符串结构变量之后，它可以被重新使用或重新分配。关键是对于“对象”，要有创建函数和销毁函数，这模仿了一些面向对象编程语言处理对象的方式。
- en: The source code file string_object.c, available on this book’s online repository,
    showcases both functions. In the code, you see that the string structure is declared
    externally, which allows all functions to access its definition.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 该书在线仓库中可用的源代码文件 string_object.c 展示了这两个函数。在代码中，你可以看到字符串结构是在外部声明的，这使得所有函数都可以访问其定义。
- en: It’s possible to expand upon the string structure, adding more members that
    describe the string—including function members. I leave this topic to you for
    further exploration, though keep in mind that object-oriented programming languages
    are available for you to learn and play. Forcing C into this mold is a consideration,
    but I would recommend focusing on the language’s strengths as opposed to pretending
    it’s something else.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能扩展字符串结构，添加更多描述字符串的成员——包括函数成员。我将这个话题留给你进一步探索，但请记住，面向对象编程语言可供你学习和玩耍。强迫 C 语言适应这种模式是一个考虑因素，但我更建议关注语言的优势，而不是假装它是其他东西。
