- en: Unit 6\. Down the gopher hole
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6单元。向下进入地鼠洞
- en: It’s time to get your hands dirty, delving deeper into programming with Go.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候动手实践，更深入地学习 Go 编程了。
- en: You’ll need to consider how memory is organized and shared, bringing new levels
    of control and responsibility. You’ll learn how `nil` can be beneficial, while
    avoiding the dreaded *nil pointer dereference*. And you’ll see how exercising
    diligence in error handing can make your programs more reliable.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要考虑内存的组织和共享方式，这将带来新的控制层次和责任。你会了解到 `nil` 可以是有益的，同时避免可怕的 *nil 指针解引用*。你还会看到在错误处理中表现出勤奋如何使你的程序更加可靠。
- en: Lesson 26\. A few pointers
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第26课。几个指针
- en: After reading [lesson 26](#ch26), you’ll be able to
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完 [第26课](#ch26) 后，你将能够
- en: Declare and use pointers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明和使用指针
- en: Understand the relationship between pointers and random access memory (RAM)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解指针和随机访问内存（RAM）之间的关系
- en: Know when to use—and not use—pointers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道何时使用——以及何时不使用——指针
- en: 'Walk around any neighborhood and you’ll likely encounter homes with individual
    addresses and street signs to guide you on your way. You may happen upon a closed-down
    shop with an apologetic sign: “Sorry, we’ve moved!” Pointers are a bit like the
    sign in the store window that directs you to a different address.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何街区走一走，你很可能会遇到带有单独地址和街道标志的房屋，这些标志会指引你的方向。你可能会遇到一个关闭的商店，上面挂着道歉的标志：“抱歉，我们搬家了！”指针有点像商店橱窗里的标志，指示你前往不同的地址。
- en: '![](f0201-01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](f0201-01.jpg)'
- en: A *pointer* is a variable that points to the address of another variable. In
    computer science, pointers are a form of *indirection*, and indirection can be
    a powerful tool.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*指针* 是一个指向另一个变量地址的变量。在计算机科学中，指针是一种 *间接引用*，间接引用可以是一个强大的工具。'
- en: '*All problems in computer science can be solved by another level of indirection...*'
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*计算机科学中的所有问题都可以通过另一层间接引用来解决...*'
- en: ''
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*David Wheeler*'
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*大卫·惠勒*'
- en: Pointers are quite useful, but over the years they’ve been associated with a
    great deal of angst. Languages in the past—C in particular—had little emphasis
    on safety. Many crashes and security vulnerabilities can be tied back to the misuse
    of pointers. This gave rise to several languages that don’t expose pointers to
    programmers.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 指针非常有用，但多年来它们与大量的焦虑相关联。过去的语言——特别是 C 语言——对安全性的强调很少。许多崩溃和安全漏洞都可以追溯到指针的误用。这导致了几个不向程序员暴露指针的语言的产生。
- en: Go does have pointers, but with an emphasis on memory safety. Go isn’t plagued
    with issues like *dangling pointers*. This would be like heading to the address
    for your favorite shop, only to find it was accidentally replaced with the parking
    lot for a new casino.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Go 确实有指针，但强调内存安全。Go 没有像 *悬垂指针* 这样的问题。这就像去你最喜欢的商店的地址，却发现它意外地被一个新赌场的停车场取代了。
- en: If you’ve encountered pointers before, take a deep breath. This isn’t going
    to be so bad. If this is your first encounter, relax. Go is a safe place to learn
    pointers.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前遇到过指针，深呼吸。这不会那么糟糕。如果你是第一次遇到，放松。Go 是一个学习指针的安全场所。
- en: '|  |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: Like the shop sign directing visitors to a new address, pointers direct a computer
    where to look for a value. What’s another situation where you’re directed to look
    somewhere else?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 就像指示访客前往新地址的商店招牌一样，指针指示计算机在哪里查找值。还有什么其他情况你会被指示去别处寻找？
- en: '|  |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 26.1\. The ampersand and the asterisk
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.1\. 和号和星号
- en: Pointers in Go adopt the well-established syntax used by C. There are two symbols
    to be aware of, the ampersand (`&`) and the asterisk (`*`), though the asterisk
    serves a dual purpose, as you’ll soon see.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的指针采用了 C 语言中广泛使用的语法。有两个符号需要注意，即和号（`&`）和星号（`*`），尽管星号具有双重作用，你很快就会看到。
- en: The *address operator*, represented by an ampersand, determines the address
    of a variable in memory. Variables store their values in a computer’s RAM, and
    the location where a value is stored is known as its *memory address*. The following
    listing prints a memory address as a hexadecimal number, though the address on
    your computer will differ.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*地址运算符*，由和号表示，确定变量在内存中的地址。变量将它们的值存储在计算机的 RAM 中，而存储值的地点被称为其 *内存地址*。以下列表以十六进制数字打印内存地址，尽管你的计算机上的地址会有所不同。'
- en: 'Listing 26.1\. Address operator: memory.go'
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.1\. 地址运算符：memory.go
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* Prints 0x1040c108**'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 0x1040c108**'
- en: This is the location in memory where the computer stored 42\. Thankfully, you
    can use the variable name `answer` to retrieve the value, rather than the memory
    address your computer uses.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是计算机存储 42 的内存位置。幸运的是，你可以使用变量名 `answer` 来检索值，而不是使用计算机使用的内存地址。
- en: '|  |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You can’t take the address of a literal string, number, or Boolean. The Go compiler
    will report an error for `&42` or `&"another level of indirection"`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能取一个字面量字符串、数字或布尔值的地址。Go 编译器会对 `&42` 或 `&"another level of indirection"` 报错。
- en: '|  |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The address operator (`&`) provides the memory address of a value. The reverse
    operation is known as *dereferencing*, which provides the value that a memory
    address refers to. The following listing dereferences the `address` variable by
    prefixing it with an asterisk (`*`).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 地址运算符 (`&`) 提供了一个值的内存地址。相反的操作称为 *解引用*，它提供了内存地址所引用的值。以下列表通过在 `address` 变量前加一个星号
    (`*`) 来解引用 `address` 变量。
- en: 'Listing 26.2\. Dereference operator: memory.go'
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.2\. 解引用运算符：memory.go
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* Prints 0x1040c108**'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 0x1040c108**'
- en: '***2* Prints 42**'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 42**'
- en: In the preceding listing and in [figure 26.1](#ch26fig01), the `address` variable
    holds the memory address of `answer`. It doesn’t hold the answer (42), but it
    knows where to find it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表和 [图 26.1](#ch26fig01) 中，`address` 变量持有 `answer` 的内存地址。它不持有答案（42），但它知道在哪里可以找到它。
- en: '|  |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Memory addresses in C can be manipulated with pointer arithmetic (for example
    `address++`), but Go disallows unsafe operations.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: C 中的内存地址可以通过指针算术（例如 `address++`）进行操作，但 Go 禁止不安全操作。
- en: '|  |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Figure 26.1\. `address` points to `answer`
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 26.1\. `address` 指向 `answer`
- en: '![](26fig01.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](26fig01.jpg)'
- en: '|  |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 26.1**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 26.1**'
- en: '**[1](#ch26qa2q0a1)**'
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch26qa2q0a1)**'
- en: ''
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What does `fmt.Println(*&answer)` display for [listing 26.2](#ch26ex02)?
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`fmt.Println(*&answer)` 对于 [列表 26.2](#ch26ex02) 显示了什么？'
- en: '**[2](#ch26qa2q0a2)**'
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch26qa2q0a2)**'
- en: ''
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How might the Go compiler know the difference between dereferencing and multiplication?
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Go 编译器如何知道解引用和乘法的区别？
- en: '|  |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 26.1 answer**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 26.1 答案**'
- en: '**[1](#ch26qa1q1)**'
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch26qa1q1)**'
- en: ''
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It prints 42 because the memory address (`&`) is dereferenced (`*`) back to
    the value.
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它打印 42，因为内存地址 (`&`) 被解引用 (`*`) 回到值。
- en: '**[2](#ch26qa1q2)**'
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch26qa1q2)**'
- en: ''
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Multiplication is an *infix* operator requiring two values, whereas dereferencing
    prefixes a single variable.
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 乘法是一个 *中缀* 运算符，需要两个值，而解引用则前缀一个单个变量。
- en: '|  |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 26.1.1\. Pointer types
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 26.1.1\. 指针类型
- en: Pointers store memory addresses.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 指针存储内存地址。
- en: The `address` variable in [listing 26.2](#ch26ex02) is a pointer of type `*int`,
    as the `%T` format verb reveals in the following listing.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 26.2](#ch26ex02) 中的 `address` 变量是一个类型为 `*int` 的指针，如以下列表中的 `%T` 格式动词所揭示。
- en: 'Listing 26.3\. A pointer type: type.go'
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.3\. 指针类型：type.go
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* Prints address is a *int**'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印地址是 *int**'
- en: The asterisk in `*int` denotes that the type is a pointer. In this case, it
    can point to other variables of type `int`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`*int` 中的星号表示该类型是一个指针。在这种情况下，它可以指向其他类型为 `int` 的变量。'
- en: Pointer types can appear anywhere types are used, including in variable declarations,
    function parameters, return types, structure field types, and so on. In the following
    listing, the asterisk (`*`) in the declaration of `home` indicates that it’s a
    pointer type.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 指针类型可以出现在任何使用类型的地方，包括变量声明、函数参数、返回类型、结构字段类型等。在以下列表中，声明 `home` 中的星号 (`*`) 表示它是一个指针类型。
- en: 'Listing 26.4\. Declaring a pointer: home.go'
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.4\. 声明指针：home.go
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* Prints home is a *string**'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 home 是 *string**'
- en: '***2* Prints Canada**'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 Canada**'
- en: '|  |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**提示**'
- en: An asterisk prefixing a type denotes a pointer type, whereas an asterisk prefixing
    a variable name is used to dereference the value that variable points to.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型前加一个星号表示指针类型，而在变量名前加一个星号用于解引用变量所指向的值。
- en: '|  |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The `home` variable in the previous listing can point at any variable of type
    `string`. However, the Go compiler won’t allow `home` to point to a variable of
    any other type, such as `int`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个列表中的 `home` 变量可以指向任何类型为 `string` 的变量。然而，Go 编译器不允许 `home` 指向任何其他类型的变量，例如 `int`。
- en: '|  |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The C type system is easily convinced that a memory address holds a different
    type. That can be useful at times but, once again, Go avoids potentially unsafe
    operations.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: C 的类型系统很容易相信一个内存地址持有不同的类型。这在某些时候可能很有用，但 Go 再次避免了潜在的不安全操作。
- en: '|  |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 26.2**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 26.2**'
- en: '**[1](#ch26qa4q0a1)**'
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch26qa4q0a1)**'
- en: ''
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What code would you use to declare a variable named `address` that can point
    to integers?
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你将使用什么代码来声明一个名为 `address` 的变量，该变量可以指向整数？
- en: '**[2](#ch26qa4q0a2)**'
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch26qa4q0a2)**'
- en: ''
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How can you distinguish between the declaration of a pointer type and dereferencing
    a pointer in [listing 26.4](#ch26ex04)?
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你如何在[代码列表 26.4](#ch26ex04)中区分指针类型的声明和指针解引用？
- en: '|  |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 26.2 answer**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 26.2 答案**'
- en: '**[1](#ch26qa3q1)**'
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch26qa3q1)**'
- en: ''
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`var address *int`'
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`var address *int`'
- en: '**[2](#ch26qa3q2)**'
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch26qa3q2)**'
- en: ''
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An asterisk prefixing a type denotes a pointer type, whereas an asterisk prefixing
    a variable name is used to dereference the value that variable points to.
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在类型前加一个星号表示指针类型，而将星号加在变量名前用于解引用变量指向的值。
- en: '|  |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 26.2\. Pointers are for pointing
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.2\. 指针用于指向
- en: Charles Bolden became the administrator of NASA on July 17, 2009\. He was preceded
    by Christopher Scolese. By representing the administrator role with a pointer,
    the following listing can point `administrator` at whoever fills the role (see
    [figure 26.2](#ch26fig02)).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Charles Bolden 于 2009 年 7 月 17 日成为美国国家航空航天局的管理员。他的前任是 Christopher Scolese。通过用指针表示管理员角色，以下列表可以将
    `administrator` 指向任何担任该角色的人（参见[图 26.2](#ch26fig02)）。
- en: 'Listing 26.5\. Administrator for NASA: nasa.go'
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.5\. 美国国家航空航天局管理员：nasa.go
- en: '[PRE4]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* Prints Christopher J. Scolese**'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 Christopher J. Scolese**'
- en: '***2* Prints Charles F. Bolden**'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 Charles F. Bolden**'
- en: Figure 26.2\. `administrator` points to `bolden`
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 26.2\. `administrator` 指向 `bolden`
- en: '![](26fig02.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](26fig02.jpg)'
- en: 'Changes to the value of `bolden` can be made in one place, because the administrator
    variable points to `bolden` rather than storing a copy:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于管理员变量指向 `bolden` 而不是存储副本，因此可以在一个地方修改 `bolden` 的值：
- en: '[PRE5]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* Prints Charles Frank Bolden Jr.**'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 Charles Frank Bolden Jr.**'
- en: 'It’s also possible to dereference `administrator` to change the value of `bolden`
    indirectly:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过解引用 `administrator` 来间接更改 `bolden` 的值：
- en: '[PRE6]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* Prints Maj. Gen. Charles Frank Bolden Jr.**'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 Maj. Gen. Charles Frank Bolden Jr.**'
- en: 'Assigning `major` to `administrator` results in a new pointer that’s also pointing
    at the `bolden` string (see [figure 26.3](#ch26fig03)):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `major` 分配给 `administrator` 将导致一个新的指针，它也指向 `bolden` 字符串（参见[图 26.3](#ch26fig03)）：
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* Prints Major General Charles Frank Bolden Jr.**'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 Major General Charles Frank Bolden Jr.**'
- en: Figure 26.3\. `administrator` and `major` point to `bolden`
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 26.3\. `administrator` 和 `major` 指向 `bolden`
- en: '![](26fig03.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](26fig03.jpg)'
- en: 'The `major` and `administrator` pointers both hold the same memory address
    and therefore are equal:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`major` 和 `administrator` 指针都持有相同的内存地址，因此它们是相等的：'
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* Prints true**'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 true**'
- en: 'Charles Bolden was succeeded by Robert M. Lightfoot Jr. on January 20, 2017\.
    After this change, `administrator` and `major` no longer point to the same memory
    address (see [figure 26.4](#ch26fig04)):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Charles Bolden 于 2017 年 1 月 20 日被 Robert M. Lightfoot Jr. 接替。在此更改之后，`administrator`
    和 `major` 不再指向相同的内存地址（参见[图 26.4](#ch26fig04)）：
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* Prints false**'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 false**'
- en: Figure 26.4\. `administrator` now points to `lightfoot`
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 26.4\. `administrator` 现在指向 `lightfoot`
- en: '![](26fig04.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](26fig04.jpg)'
- en: 'Assigning the dereferenced value of `major` to another variable makes a copy
    of the string. After the clone is made, direct and indirect modifications to `bolden`
    have no effect on the value of `charles`, or vice versa:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `major` 的解引用值分配给另一个变量会创建一个字符串的副本。在创建副本后，对 `bolden` 的直接和间接修改都不会影响 `charles`
    的值，反之亦然：
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* Prints Major General Charles Frank Bolden Jr.**'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 Major General Charles Frank Bolden Jr.**'
- en: '***2* Prints Charles Bolden**'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 Charles Bolden**'
- en: 'If two variables contain the same string, they’re considered equal, as with
    `charles` and `bolden` in the following code. This is the case even though they
    have different memory addresses:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个变量包含相同的字符串，它们被认为是相等的，就像以下代码中的 `charles` 和 `bolden` 一样。即使它们有不同的内存地址，这也是这种情况：
- en: '[PRE11]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1* Prints true**'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 true**'
- en: '***2* Prints false**'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 false**'
- en: In this section, the value of `bolden` was modified indirectly by dereferencing
    the `administrator` and `major` pointers. This demonstrates what pointers can
    do, though it would be straightforward to assign values directly to `bolden` in
    this instance.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，通过解引用 `administrator` 和 `major` 指针间接修改了 `bolden` 的值。这展示了指针可以做什么，尽管在这种情况下直接将值分配给
    `bolden` 会更简单。
- en: '|  |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 26.3**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 26.3**'
- en: '**[1](#ch26qa6q0a1)**'
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch26qa6q0a1)**'
- en: ''
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What’s the benefit of using a pointer in [listing 26.5](#ch26ex05)?
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在[代码列表 26.5](#ch26ex05)中使用指针有什么好处？
- en: '**[2](#ch26qa6q0a2)**'
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch26qa6q0a2)**'
- en: ''
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Describe what the statements `major := administrator` and `charles := *major`
    do.
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 描述语句 `major := administrator` 和 `charles := *major` 的作用。
- en: '|  |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 26.3 answer**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 26.3 答案**'
- en: '**[1](#ch26qa5q1)**'
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch26qa5q1)**'
- en: ''
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Changes can be made in one place, as the `administrator` variable points to
    a person rather than storing a copy.
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 变更可以在一个地方进行，因为`administrator`变量指向一个人而不是存储一个副本。
- en: '**[2](#ch26qa5q2)**'
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch26qa5q2)**'
- en: ''
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The variable `major` is a new `*string` pointer that holds the same memory address
    as `administrator`, whereas `charles` is a string containing a copy of the value
    that `major` was pointing to.
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 变量`major`是一个新的`*string`指针，它持有与`administrator`相同的内存地址，而`charles`是一个包含`major`所指向的值的副本的字符串。
- en: '|  |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 26.2.1\. Pointing to structures
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 26.2.1\. 指向结构体
- en: Pointers are frequently used with structures. As such, the Go language designers
    chose to provide a few ergonomic amenities for pointers to structures.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 指针经常与结构体一起使用。因此，Go 语言的设计者选择为结构体的指针提供一些人体工程学上的便利。
- en: Unlike strings and numbers, composite literals can be prefixed with an address
    operator. In the following listing, the `timmy` variable holds a memory address
    pointing to a `person` structure.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 与字符串和数字不同，复合字面量可以前缀地址运算符。在以下列表中，`timmy`变量持有指向`person`结构的内存地址。
- en: 'Listing 26.6\. Person structure: struct.go'
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.6\. 人员结构：struct.go
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Furthermore, it isn’t necessary to dereference structures to access their fields.
    The following listing is preferable to writing `(*timmy).superpower`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，访问结构体的字段时不需要解引用结构体。以下列表比编写`(*timmy).superpower`更可取。
- en: 'Listing 26.7\. Composite literals: struct.go'
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.7\. 复合字面量：struct.go
- en: '[PRE13]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1* Prints &{name:Timothy superpower:flying age:10}**'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 &{name:Timothy superpower:flying age:10}**'
- en: '|  |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 26.4**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 26.4**'
- en: '**[1](#ch26qa8q0a1)**'
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch26qa8q0a1)**'
- en: ''
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are valid uses of the address operator?
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 地址运算符的有效用途是什么？
- en: ''
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Literal strings: `&"Timothy"`'
  id: totrans-170
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文字字符串：`&"Timothy"`
- en: 'Literal integers: `&10`'
  id: totrans-171
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文字整数：`&10`
- en: 'Composite literals: `&person{name: "Timothy"}`'
  id: totrans-172
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '复合字面量：`&person{name: "Timothy"}`'
- en: All of the above
  id: totrans-173
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有上述内容
- en: '**[2](#ch26qa8q0a2)**'
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch26qa8q0a2)**'
- en: ''
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What’s the difference between `timmy.superpower` and `(*timmy).superpower`?
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`timmy.superpower`和`(*timmy).superpower`之间有什么区别？'
- en: '|  |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 26.4 answer**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 26.4 答案**'
- en: '**[1](#ch26qa7q1)**'
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch26qa7q1)**'
- en: ''
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The address operator is valid with variable names and composite literals, but
    not literal strings or numbers.
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 地址运算符对变量名和复合字面量有效，但对文字字符串或数字无效。
- en: '**[2](#ch26qa7q2)**'
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch26qa7q2)**'
- en: ''
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There’s no functional difference because Go automatically dereferences pointers
    for fields, but `timmy.superpower` is easier to read and is therefore preferable.
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于 Go 自动解引用字段，因此没有功能上的差异，但`timmy.superpower`更容易阅读，因此更可取。
- en: '|  |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 26.2.2\. Pointing to arrays
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 26.2.2\. 指向数组
- en: As with structures, composite literals for arrays can be prefixed with the address
    operator (`&`) to create a new pointer to an array. Arrays also provide automatic
    dereferencing, as shown in the following listing.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 与结构体一样，数组的复合字面量可以前缀地址运算符（`&`）以创建指向数组的新的指针。数组也提供自动解引用，如下所示。
- en: 'Listing 26.8\. Pointer to an array: superpowers.go'
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.8\. 指向数组的指针：superpowers.go
- en: '[PRE14]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1* Prints flight**'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 flight**'
- en: '***2* Prints [invisibility]**'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 [invisibility]**'
- en: The array in the previous listing is dereferenced automatically when indexing
    or slicing it. There’s no need to write the more cumbersome `(*superpowers)[0]`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个列表中，数组在索引或切片时自动解引用。无需编写更繁琐的`(*superpowers)[0]`。
- en: '|  |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Unlike the C language, arrays and pointers in Go are completely independent
    types.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 与 C 语言不同，Go 中的数组和指针是完全独立的类型。
- en: '|  |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Composite literals for slices and maps can also be prefixed with the address
    operator (`&`), but there’s no automatic dereferencing.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 切片和映射的复合字面量也可以前缀地址运算符（`&`），但没有自动解引用。
- en: '|  |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 26.5**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 26.5**'
- en: '**[Q1:](#ch26qa10q0a1)**'
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch26qa10q0a1)**'
- en: ''
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What’s another way to write `(*superpowers)[2:]` where `superpowers` is a pointer
    to an array?
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除了`superpowers`是数组的指针之外，还有其他写法可以写`(*superpowers)[2:]`吗？
- en: '|  |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 26.5 answer**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 26.5 答案**'
- en: '**[1:](#ch26qa9q1)**'
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch26qa9q1)**'
- en: ''
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Writing `superpowers[2:]` is the same, thanks to automatic dereferencing for
    arrays.
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于数组自动解引用，`superpowers[2:]`的写法相同。
- en: '|  |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 26.3\. Enabling mutation
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.3\. 启用修改
- en: Pointers are used to enable mutation across function and method boundaries.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 指针用于在函数和方法边界之间启用修改。
- en: 26.3.1\. Pointers as parameters
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 26.3.1\. 指针作为参数
- en: Function and method parameters are passed by value in Go. That means functions
    always operate on a copy of passed arguments. When a pointer is passed to a function,
    the function receives a copy of the memory address. By dereferencing the memory
    address, a function can mutate the value a pointer points to.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，函数和方法参数是通过值传递的。这意味着函数始终操作传递参数的副本。当传递指针到函数时，函数接收传递参数的内存地址的副本。通过取消引用内存地址，函数可以修改指针指向的值。
- en: In [listing 26.9](#ch26ex09) a `birthday` function is declared with one parameter
    of type `*person`. This allows the function body to dereference the pointer and
    modify the value it points to. As with [listing 26.7](#ch26ex07), it isn’t necessary
    to explicitly dereference the `p` variable to access the `age` field. The syntax
    in the following listing is preferable to `(*p).age++`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 26.9](#ch26ex09) 中，声明了一个参数类型为 `*person` 的 `birthday` 函数。这允许函数体取消引用指针并修改它指向的值。与
    [列表 26.7](#ch26ex07) 一样，不需要显式取消引用 `p` 变量来访问 `age` 字段。下面列表中的语法比 `(*p).age++` 更可取。
- en: 'Listing 26.9\. Function parameters: birthday.go'
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.9\. 函数参数：birthday.go
- en: '[PRE15]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `birthday` function requires the caller to pass a pointer to a person, as
    shown in the following listing.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`birthday` 函数要求调用者传递一个人的指针，如下面的列表所示。'
- en: 'Listing 26.10\. Function arguments: birthday.go'
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.10\. 函数参数：birthday.go
- en: '[PRE16]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1* Prints {name:Rebecca superpower:imagination age:15}**'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 {name:Rebecca superpower:imagination age:15}**'
- en: '|  |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 26.6**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 26.6**'
- en: '**[1](#ch26qa12q0a1)**'
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch26qa12q0a1)**'
- en: ''
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What code would return Timothy 11? Refer to [listing 26.6](#ch26ex06).
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 什么代码会返回 Timothy 11？请参阅 [列表 26.6](#ch26ex06)。
- en: ''
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`birthday(&timmy)`'
  id: totrans-228
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`birthday(&timmy)`'
- en: '`birthday(timmy)`'
  id: totrans-229
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`birthday(timmy)`'
- en: '`birthday(*timmy)`'
  id: totrans-230
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`birthday(*timmy)`'
- en: '**[2](#ch26qa12q0a2)**'
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch26qa12q0a2)**'
- en: ''
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What age would Rebecca be if the `birthday(p person)` function didn’t use a
    pointer?
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果 `birthday(p person)` 函数不使用指针，Rebecca 会是什么年龄？
- en: '|  |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 26.6 answer**'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 26.6 答案**'
- en: '**[1](#ch26qa11q1)**'
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch26qa11q1)**'
- en: ''
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `timmy` variable is a pointer already, so the correct answer is b. `birthday(timmy)`.
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`timmy` 变量已经是指针，所以正确答案是 b. `birthday(timmy)`。'
- en: '**[2](#ch26qa11q2)**'
  id: totrans-240
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch26qa11q2)**'
- en: ''
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Rebecca would forever remain 14 if `birthday` didn’t utilize a pointer.
  id: totrans-242
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果 `birthday` 不使用指针，Rebecca 将永远保持 14 岁。
- en: '|  |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 26.3.2\. Pointer receivers
  id: totrans-244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 26.3.2\. 指针接收者
- en: Method receivers are similar to parameters. The `birthday` method in the next
    listing uses a pointer for the receiver, which allows the method to mutate a person’s
    attributes. This behavior is just like the `birthday` function in [listing 26.9](#ch26ex09).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 方法接收者类似于参数。在下一个列表中，`birthday` 方法使用指针作为接收者，这使得方法可以修改一个人的属性。这种行为就像 [列表 26.9](#ch26ex09)
    中的 `birthday` 函数。
- en: 'Listing 26.11\. Pointer receiver: method.go'
  id: totrans-246
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.11\. 指针接收者：method.go
- en: '[PRE17]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the following listing, declaring a pointer and calling the `birthday` method
    increments Terry’s age.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的列表中，声明一个指针并调用 `birthday` 方法会增加 Terry 的年龄。
- en: 'Listing 26.12\. Method call with a pointer: method.go'
  id: totrans-249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.12\. 使用指针的方法调用：method.go
- en: '[PRE18]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* Prints &{name:Terry age:16}**'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 &{name:Terry age:16}**'
- en: Alternatively, the method call in the next listing doesn’t use a pointer, yet
    it still works. Go will automatically determine the address of (`&`) a variable
    when calling methods with dot notation, so you don’t need to write `(&nathan).birthday()`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，下一个列表中的方法调用没有使用指针，但它仍然有效。Go 在使用点符号调用方法时，会自动确定变量的地址（`&`），因此不需要编写 `(&nathan).birthday()`。
- en: 'Listing 26.13\. Method call without a pointer: method.go'
  id: totrans-253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.13\. 无指针的方法调用：method.go
- en: '[PRE19]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* Prints {name:Nathan age:18}**'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 {name:Nathan age:18}**'
- en: Whether called with a pointer or not, the `birthday` method declared in [listing
    26.11](#ch26ex11) must specify a pointer receiver—otherwise, `age` wouldn’t increment.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是否使用指针调用，[列表 26.11](#ch26ex11) 中声明的 `birthday` 方法都必须指定指针接收者——否则，`age` 不会增加。
- en: Structures are frequently passed around with pointers. It makes sense for the
    `birthday` method to mutate a person’s attributes rather than create a whole new
    person. That said, not every structure should be mutated. The standard library
    provides a great example in the `time` package. The methods of the `time.Time`
    type never use a pointer receiver, preferring to return a new time instead, as
    shown in the next listing. After all, tomorrow is a new day.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体通常以指针的形式传递。对于 `birthday` 方法来说，修改一个人的属性而不是创建一个全新的个人是有意义的。然而，并非每个结构体都应该被修改。标准库在
    `time` 包中提供了一个很好的例子。`time.Time` 类型的方法从不使用指针接收者，而是更喜欢返回一个新的时间，如下一个列表所示。毕竟，明天是新的日子。
- en: 'Listing 26.14\. Tomorrow is a new day: day.go'
  id: totrans-258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.14\. 新的一天：day.go
- en: '[PRE20]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1* Prints Tue, Nov 10, 2009**'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 Tue, Nov 10, 2009**'
- en: '***2* Prints Wed, Nov 11, 2009**'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 Wed, Nov 11, 2009**'
- en: '|  |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: You should use pointer receivers consistently. If some methods need pointer
    receivers, use pointer receivers for all methods of the type (see [golang.org/doc/faq#methods_on_values_or_pointers](http://golang.org/doc/faq#methods_on_values_or_pointers)).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该始终如一地使用指针接收器。如果某些方法需要指针接收器，则使用该类型的所有方法的指针接收器（参见 [golang.org/doc/faq#methods_on_values_or_pointers](http://golang.org/doc/faq#methods_on_values_or_pointers)）。
- en: '|  |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 26.7**'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 26.7**'
- en: '**[Q1:](#ch26qa14q0a1)**'
  id: totrans-268
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch26qa14q0a1)**'
- en: ''
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How do you know that `time.Time` never uses a pointer receiver?
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你如何知道 `time.Time` 从不使用指针接收器？
- en: '|  |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 26.7 answer**'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 26.7 答案**'
- en: '**[1:](#ch26qa13q1)**'
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch26qa13q1)**'
- en: ''
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The code in [listing 26.14](#ch26ex14) doesn’t reveal whether or not the `Add`
    method uses a pointer receiver because dot notation is the same either way. It’s
    best to look at the documentation for the methods of `time.Time` (see [golang.org/pkg/time/#Time](http://golang.org/pkg/time/#Time)).
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[列表 26.14](#ch26ex14) 中的代码没有揭示 `Add` 方法是否使用指针接收器，因为点符号在这两种情况下都是相同的。最好查看 `time.Time`
    方法的文档（参见 [golang.org/pkg/time/#Time](http://golang.org/pkg/time/#Time)）。'
- en: '|  |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 26.3.3\. Interior pointers
  id: totrans-278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 26.3.3\. 内部指针
- en: Go provides a handy feature called *interior pointers*, used to determine the
    memory address of a field inside of a structure. The `levelUp` function in the
    following listing mutates a `stats` structure and therefore requires a pointer.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Go 提供了一个方便的功能，称为 *内部指针*，用于确定结构体内部字段的内存地址。以下列表中的 `levelUp` 函数修改了一个 `stats` 结构体，因此需要使用指针。
- en: 'Listing 26.15\. The `levelUp` function: interior.go'
  id: totrans-280
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.15\. `levelUp` 函数：interior.go
- en: '[PRE21]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The address operator in Go can be used to point to a field within a structure,
    as shown in the next listing.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的地址操作符可以用来指向结构体中的一个字段，如下面的列表所示。
- en: 'Listing 26.16\. Interior pointers: interior.go'
  id: totrans-283
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.16\. 内部指针：interior.go
- en: '[PRE22]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***1* Prints {level:1 endurance:56 health:280}**'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 {level:1 endurance:56 health:280}**'
- en: The `character` type doesn’t have any pointers in the structure definition,
    yet you can take the memory address of any field when the need arises. The code
    `&player.stats` provides a pointer to the interior of the structure.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`character` 类型在结构定义中没有任何指针，但在需要时可以获取任何字段的内存地址。代码 `&player.stats` 提供了指向结构体内部的指针。'
- en: '|  |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 26.8**'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 26.8**'
- en: '**[Q1:](#ch26qa16q0a1)**'
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch26qa16q0a1)**'
- en: ''
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What’s an interior pointer?
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 什么是内部指针？
- en: '|  |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 26.8 answer**'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 26.8 答案**'
- en: '**[1:](#ch26qa15q1)**'
  id: totrans-295
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch26qa15q1)**'
- en: ''
  id: totrans-296
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A pointer that points at a field inside a structure. This is achieved by using
    the address operator on a field of a structure, such as `&player.stats`.
  id: totrans-297
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 指向结构体内部字段的指针。这是通过在结构体的字段上使用地址操作符来实现的，例如 `&player.stats`。
- en: '|  |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 26.3.4\. Mutating arrays
  id: totrans-299
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 26.3.4\. 修改数组
- en: Though slices tend to be preferred over arrays, using arrays can be appropriate
    when there’s no need to change their length. The chessboard from [lesson 16](kindle_split_028.html#ch16)
    is such an example. The following listing demonstrates how pointers allow functions
    to mutate elements of the array.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管切片通常比数组更受欢迎，但在不需要更改其长度的情况下，使用数组可能是合适的。[第 16 课](kindle_split_028.html#ch16)
    中的棋盘就是这样的一个例子。以下列表演示了指针如何允许函数修改数组的元素。
- en: 'Listing 26.17\. Resetting the chessboard: array.go'
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.17\. 重置棋盘：array.go
- en: '[PRE23]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1* Prints r**'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 r**'
- en: In [lesson 20](kindle_split_032.html#ch20), the suggested implementation for
    Conway’s Game of Life makes use of slices even though the world is a fixed size.
    Armed with pointers, you could rewrite the Game of Life to use arrays.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 20 课](kindle_split_032.html#ch20) 中，对康威生命游戏的建议实现使用了切片，尽管世界的大小是固定的。有了指针，你可以重写生命游戏以使用数组。
- en: '|  |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 26.9**'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 26.9**'
- en: '**[Q1:](#ch26qa18q0a1)**'
  id: totrans-307
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch26qa18q0a1)**'
- en: ''
  id: totrans-308
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When is it appropriate to use a pointer to an array?
  id: totrans-309
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在什么情况下使用数组的指针是合适的？
- en: '|  |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 26.9 answer**'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 26.9 答案**'
- en: '**[1:](#ch26qa17q1)**'
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch26qa17q1)**'
- en: ''
  id: totrans-314
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Arrays are appropriate for data with fixed dimensions, such as a chess-board.
    Arrays are copied when passed to functions or methods unless a pointer is used,
    which enables mutation.
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 数组适用于具有固定维度的数据，例如棋盘。除非使用指针，否则在传递给函数或方法时数组会被复制，这允许修改。
- en: '|  |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 26.4\. Pointers in disguise
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.4\. 掩饰的指针
- en: Not all mutations require explicit use of a pointer. Go uses pointers behind
    the scenes for some of the built-in collections.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的修改都需要显式使用指针。Go 在一些内置集合的内部使用指针。
- en: 26.4.1\. Maps are pointers
  id: totrans-319
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 26.4.1\. 地图是指针
- en: '[Lesson 19](kindle_split_031.html#ch19) states that maps aren’t copied when
    assigned or passed as arguments. Maps are pointers in disguise, so pointing to
    a map is redundant. Don’t do this:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '[课程 19](kindle_split_031.html#ch19) 指出，在赋值或作为参数传递时，地图不会被复制。地图是伪装成指针的，所以指向地图是多余的。不要这样做：'
- en: '[PRE24]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1* Unnecessary pointer**'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 不必要的指针**'
- en: It’s perfectly fine for the key or value of a map to be a pointer type, but
    there’s rarely a reason to point to a map.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 地图的键或值可以是指针类型，但很少有必要指向地图。
- en: '|  |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 26.10**'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 26.10**'
- en: '**[Q1:](#ch26qa20q0a1)**'
  id: totrans-326
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch26qa20q0a1)**'
- en: ''
  id: totrans-327
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Is a map a pointer?
  id: totrans-328
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 地图是指针吗？
- en: '|  |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 26.10 answer**'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 26.10 答案**'
- en: '**[1:](#ch26qa19q1)**'
  id: totrans-332
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch26qa19q1)**'
- en: ''
  id: totrans-333
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Yes, even though maps don’t resemble pointers syntactically, they are in fact
    pointers. There’s no way to use a map that isn’t a pointer.
  id: totrans-334
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 是的，尽管从语法上看地图不像指针，但它们实际上是指针。无法使用非指针类型的地图。
- en: '|  |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 26.4.2\. Slices point at arrays
  id: totrans-336
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 26.4.2\. 切片指向数组
- en: '[Lesson 17](kindle_split_029.html#ch17) describes a slice as a window into
    an array. To point at an element of the array, slices use a pointer.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '[课程 17](kindle_split_029.html#ch17) 将切片描述为数组的窗口。为了指向数组中的一个元素，切片使用指针。'
- en: 'A slice is represented internally as a structure with three elements: a pointer
    to an array, the capacity of the slice, and the length. The internal pointer allows
    the underlying data to be mutated when a slice is passed directly to a function
    or method.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 切片在内部表示为一个包含三个元素的结构的指针：一个指向数组的指针、切片的容量和长度。内部指针允许在将切片直接传递给函数或方法时修改底层数据。
- en: 'An explicit pointer to a slice is only useful when modifying the slice itself:
    the length, capacity, or starting offset. In the following listing, the `reclassify`
    function modifies the length of the `planets` slice. The calling function (`main`)
    wouldn’t see this change if `reclassify` didn’t utilize a pointer.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在修改切片本身时（长度、容量或起始偏移量）显式指针才有用。在以下列表中，`reclassify`函数修改了`planets`切片的长度。如果`reclassify`没有利用指针，调用函数（`main`）将看不到这种变化。
- en: 'Listing 26.18\. Modifying a slice: slice.go'
  id: totrans-340
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.18\. 修改切片：slice.go
- en: '[PRE25]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '***1* Prints [Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune]**'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 [水星 金星 地球 火星 木星 土星 天王星 海王星]**'
- en: Instead of mutating the passed slice as in [listing 26.18](#ch26ex18), an arguably
    cleaner approach is to write the `reclassify` function to return a new slice.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 与在[列表 26.18](#ch26ex18)中修改传递的切片不同，一个更干净的方法是编写`reclassify`函数以返回一个新的切片。
- en: '|  |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 26.11**'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 26.11**'
- en: '**[Q1:](#ch26qa22q0a1)**'
  id: totrans-346
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch26qa22q0a1)**'
- en: ''
  id: totrans-347
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Functions and methods wanting to mutate the data they receive will require a
    pointer for which two data types?
  id: totrans-348
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 想要修改接收到的数据的函数和方法需要哪种数据类型的指针？
- en: '|  |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 26.11 answer**'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 26.11 答案**'
- en: '**[1:](#ch26qa21q1)**'
  id: totrans-352
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch26qa21q1)**'
- en: ''
  id: totrans-353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Structures and arrays.
  id: totrans-354
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 结构体和数组。
- en: '|  |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 26.5\. Pointers and interfaces
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.5\. 指针和接口
- en: The following listing demonstrates that both `martian` and a pointer to `martian`
    satisfy the `talker` interface.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表演示了`martian`和指向`martian`的指针都满足`talker`接口。
- en: 'Listing 26.19\. Pointers and interfaces: martian.go'
  id: totrans-358
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.19\. 指针和接口：martian.go
- en: '[PRE26]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '***1* Prints NACK NACK**'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 NACK NACK**'
- en: It’s different when methods use pointer receivers, as shown in the following
    listing.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 当方法使用指针接收者时，情况就不同了，如下面的列表所示。
- en: 'Listing 26.20\. Pointers and interfaces: interface.go'
  id: totrans-362
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.20\. 指针和接口：interface.go
- en: '[PRE27]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1* Prints PEW PEW**'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 PEW PEW**'
- en: In the preceding listing, `&pew` is of type `*laser`, which satisfies the `talker`
    interface that `shout` requires. But `shout(pew)` doesn’t work because `laser`
    doesn’t satisfy the interface in this case.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，`&pew`是`*laser`类型，它满足`shout`所需的`talker`接口。但`shout(pew)`不工作，因为在这种情况下`laser`不满足接口。
- en: '|  |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 26.12**'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 26.12**'
- en: '**[Q1:](#ch26qa24q0a1)**'
  id: totrans-368
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch26qa24q0a1)**'
- en: ''
  id: totrans-369
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When does a pointer satisfy an interface?
  id: totrans-370
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 指针何时满足接口？
- en: '|  |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 26.12 answer**'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 26.12 答案**'
- en: '**[1:](#ch26qa23q1)**'
  id: totrans-374
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch26qa23q1)**'
- en: ''
  id: totrans-375
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A pointer to a value satisfies all the interfaces that the non-pointer version
    of the type satisfies.
  id: totrans-376
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 值的指针满足该类型的非指针版本满足的所有接口。
- en: '|  |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 26.6\. Use pointers wisely
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.6\. 聪明地使用指针
- en: Pointers can be useful, but they also add complexity. It can be more difficult
    to follow code when values could be changed from multiple places.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 指针可能很有用，但它们也增加了复杂性。当值可能从多个地方更改时，代码可能更难跟踪。
- en: Use pointers when it makes sense, but don’t overuse them. Programming languages
    that don’t expose pointers often use them behind the scenes, such as when composing
    a class of several objects. With Go you decide when to use pointers and when to
    *not* use them.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 当有需要时使用指针，但不要过度使用。那些不暴露指针的编程语言通常在幕后使用它们，例如在组合几个对象的一个类时。使用Go语言，你可以决定何时使用指针，何时**不**使用它们。
- en: '|  |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 26.13**'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 26.13**'
- en: '**[Q1:](#ch26qa26q0a1)**'
  id: totrans-383
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch26qa26q0a1)**'
- en: ''
  id: totrans-384
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why shouldn’t pointers be overused?
  id: totrans-385
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么不应该过度使用指针？
- en: '|  |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 26.13 answer**'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 26.13 答案**'
- en: '**[1:](#ch26qa25q1)**'
  id: totrans-389
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch26qa25q1)**'
- en: ''
  id: totrans-390
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Code that doesn’t use pointers may be simpler to understand.
  id: totrans-391
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不使用指针的代码可能更容易理解。
- en: '|  |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: Pointers store memory addresses.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针存储内存地址。
- en: The address operator (`&`) provides the memory address of a variable.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地址运算符（`&`）提供了变量的内存地址。
- en: A pointer can be dereferenced (`*`) to access or modify the value it points
    to.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指针可以通过解引用（`*`）来访问或修改它所指向的值。
- en: Pointers are types declared with a preceding asterisk, such as `*int`.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针是用前缀星号声明的类型，例如`*int`。
- en: Use pointers to mutate values across function and method boundaries.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用指针在函数和方法边界之间修改值。
- en: Pointers are most useful with structures and arrays.
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针在结构和数组中最有用。
- en: Maps and slices use pointers behind the scenes.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射和切片在幕后使用指针。
- en: Interior pointers can point at fields inside structures without declaring those
    fields as pointers.
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部指针可以指向结构体内部的字段，而无需将这些字段声明为指针。
- en: Use pointers when it makes sense but don’t overuse them.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当有需要时使用指针，但不要过度使用它们。
- en: Let’s see if you got this...
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否理解了...
- en: 'Experiment: turtle.go'
  id: totrans-404
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实验：turtle.go
- en: Write a program with a turtle that can move up, down, left, or right. The turtle
    should store an (x, y) location where positive values go down and to the right.
    Use methods to increment/decrement the appropriate variable. A `main` function
    should exercise the methods you’ve written and print the final location.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，使用海龟可以向上、向下、向左或向右移动。海龟应该存储一个(x, y)位置，其中正值向下和向右。使用方法来增加/减少适当的变量。一个`main`函数应该练习你编写的方法，并打印最终位置。
- en: '|  |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-407
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Method receivers will need to use pointers in order to manipulate the x and
    y values.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 方法接收者将需要使用指针来操作x和y值。
- en: '|  |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Lesson 27\. Much ado about nil
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 27课.关于nil的诸多讨论
- en: After reading [lesson 27](#ch27), you’ll be able to
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读[第27课](#ch27)之后，你将能够
- en: Do something with nothing
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用无物做些事情
- en: Understand the trouble with nil
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解nil带来的麻烦
- en: See how Go improves on nil’s story
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看Go如何改进nil的故事
- en: The word *nil* is a noun that means nothing or zero. In the Go programming language,
    `nil` is a zero value. Recall from [unit 2](kindle_split_015.html#part03) that
    an integer declared without a value will default to 0\. An empty string is the
    zero value for strings, and so on. A pointer with nowhere to point has the value
    `nil`. And the `nil` identifier is the zero value for slices, maps, and interfaces
    too.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 词语*nil*是一个名词，意思是“无”或“零”。在Go编程语言中，`nil`是一个零值。回想一下[单元2](kindle_split_015.html#part03)，一个未赋值的整数将默认为0。空字符串是字符串的零值，依此类推。一个没有指向任何地方的指针具有`nil`值。而且，`nil`标识符也是切片、映射和接口的零值。
- en: 'Many programming languages incorporate the concept of nil, though they may
    call it NULL, null, or None. In 2009, prior to the release of Go, language designer
    Tony Hoare gave a presentation titled “Null References: The Billion Dollar Mistake.”
    In his talk (see [mng.bz/dNzX](http://mng.bz/dNzX)), Hoare claims responsibility
    for inventing the null reference in 1965 and suggests that pointers to nowhere
    weren’t one of his brightest ideas.'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '许多编程语言都包含了nil的概念，尽管它们可能称之为NULL、null或None。在2009年Go语言发布之前，语言设计者Tony Hoare做了一次题为“Null
    References: The Billion Dollar Mistake”的演讲。在他的演讲中（见[mng.bz/dNzX](http://mng.bz/dNzX)），Hoare声称自己在1965年发明了null
    reference，并建议指向无意义的指针并不是他最聪明的想法之一。'
- en: '|  |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-418
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Tony Hoare went on to invent communicating sequential processes (CSP) in 1978\.
    His ideas are the basis for concurrency in Go, the topic of [unit 7](kindle_split_044.html#part08).
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: Tony Hoare在1978年继续发明了通信顺序进程（CSP）。他的想法是Go语言并发的基础，也是[单元7](kindle_split_044.html#part08)的主题。
- en: '|  |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Nil is somewhat friendlier in Go, and less prevalent than in past languages,
    but there are still caveats to be aware of. Nil has some unexpected uses too,
    which Francesc Campoy talked about in his presentation at GopherCon 2016 (see
    [www.youtube.com/watch?v=ynoY2xz-F8s](http://www.youtube.com/watch?v=ynoY2xz-F8s)),
    providing inspiration for this lesson.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，nil相对友好，并且比过去的一些语言中要少见，但仍然有一些需要注意的注意事项。nil也有一些意外的用途，这在弗朗西斯克·坎波伊在2016年GopherCon的演讲中提到过（见[www.youtube.com/watch?v=ynoY2xz-F8s](http://www.youtube.com/watch?v=ynoY2xz-F8s)），为这个课程提供了灵感。
- en: '|  |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: Consider representing a constellation, where each star contains a pointer to
    its nearest neighboring star. After the math is done, every star will point somewhere,
    and finding the nearest star becomes a quick pointer dereference away.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑表示一个星座，其中每颗星星都包含指向其最近邻星星的指针。数学计算完成后，每颗星星都会指向某个地方，找到最近星星只需通过快速指针解引用即可。
- en: But until all the calculations are done, where should the pointers point? This
    is one situation where nil comes in handy. Nil can stand in for the nearest star
    until it’s known.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 但在所有计算完成之前，指针应该指向哪里呢？这就是nil派上用场的一个情况。nil可以暂时替代最近的星星，直到情况明了。
- en: What is another situation where a pointer to nowhere could be useful?
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 还有什么情况中，一个指向空处的指针可能是有用的？
- en: '|  |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 27.1\. Nil leads to panic
  id: totrans-428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.1. 空指针导致恐慌
- en: If a pointer isn’t pointing anywhere, attempting to dereference the pointer
    won’t work, as [listing 27.1](#ch27ex01) demonstrates. Dereference a nil pointer,
    and the program will crash. As a rule, people tend to dislike apps that crash.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个指针没有指向任何地方，尝试解引用该指针将不会起作用，正如[列表 27.1](#ch27ex01) 所演示的那样。解引用空指针，程序将会崩溃。一般来说，人们都不喜欢崩溃的应用程序。
- en: '*I call it my billion-dollar mistake.*'
  id: totrans-430
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*我称之为我的十亿美元的错误。*'
- en: ''
  id: totrans-431
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Tony Hoare*'
  id: totrans-432
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*托尼·霍尔*'
- en: 'Listing 27.1\. Nil leads to panic: panic.go'
  id: totrans-433
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 27.1. 空指针导致恐慌：panic.go
- en: '[PRE28]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '***1* Prints <nil>**'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 <nil>**'
- en: '***2* Panic: nil pointer dereference**'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 潜在恐慌：空指针解引用**'
- en: Avoiding panic is fairly straightforward. It’s a matter of guarding against
    a nil pointer dereference with an `if` statement, as shown in the following listing.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 避免恐慌相当直接。这是一个通过`if`语句防止空指针解引用的问题，如下面的列表所示。
- en: 'Listing 27.2\. Guard against panic: nopanic.go'
  id: totrans-438
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 27.2. 防止恐慌：nopanic.go
- en: '[PRE29]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To be fair, programs can crash for many reasons, not only because of nil pointer
    dereferences. For example, divide by zero also causes a panic, and the remedy
    is similar. Even so, considering all the software written in the past 50 years,
    the number of accidental nil pointer dereferences could be fairly costly for users
    and programmers alike. The existence of nil does burden the programmer with more
    decisions. Should the code check for nil, and if so, where should the check be?
    What should the code do if a value is nil? Does all this make *nil* a bad word?
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，程序可能因为许多原因而崩溃，而不仅仅是空指针解引用。例如，除以零也会导致恐慌，补救措施是相似的。尽管如此，考虑到过去50年编写过的所有软件，意外的空指针解引用可能对用户和程序员来说都是相当昂贵的。nil的存在确实给程序员带来了更多的决策。代码是否应该检查nil，如果是的话，检查应该在何处进行？如果值是nil，代码应该做什么？这一切是否使*nil*成为一个坏词？
- en: '![](f0222-01_alt.jpg)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
  zh: '![](f0222-01_alt.jpg)'
- en: There’s no need to cover your ears or avoid nil altogether. In truth, nil can
    be quite useful, as the remainder of this lesson demonstrates. Additionally, nil
    pointers in Go are less prevalent than null pointers are in some other languages,
    and there are ways to avoid their use when appropriate.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要捂住耳朵或完全避开nil。实际上，nil可以相当有用，本节课的剩余部分将证明这一点。此外，Go中的nil指针比某些其他语言中的null指针要少见，而且有方法可以在适当的时候避免使用它们。
- en: '|  |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 27.1**'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 27.1**'
- en: '**[Q1:](#ch27qa2q0a1)**'
  id: totrans-445
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch27qa2q0a1)**'
- en: ''
  id: totrans-446
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What’s the zero value for the type `*string`?
  id: totrans-447
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`*string`类型的零值是什么？'
- en: '|  |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 27.1 answer**'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 27.1 答案**'
- en: '**[1:](#ch27qa1q1)**'
  id: totrans-451
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch27qa1q1)**'
- en: ''
  id: totrans-452
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The zero value for a pointer is `nil`.
  id: totrans-453
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 指针的零值是`nil`。
- en: '|  |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 27.2\. Guarding your methods
  id: totrans-455
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.2. 保护你的方法
- en: Methods frequently receive a pointer to a structure, which means the receiver
    could be nil, as shown in the following listing. Whether a pointer is dereferenced
    explicitly (`*p`) or implicitly by accessing a field of the struct (`p.age`),
    a nil value will panic.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 方法经常接收一个指向结构的指针，这意味着接收者可能是nil，如下面的列表所示。无论是显式解引用指针（`*p`）还是通过访问结构体的字段（`p.age`）隐式解引用，nil值都会导致恐慌。
- en: 'Listing 27.3\. Nil receivers: method.go'
  id: totrans-457
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 27.3. 空接收者：method.go
- en: '[PRE30]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '***1* nil pointer dereference**'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 空指针解引用**'
- en: '***2* Prints <nil>**'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 <nil>**'
- en: A key observation is that the panic is caused when the `p.age++` line executes.
    Remove that line, and the program will run.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关键的观察结果是，当执行 `p.age++` 行时，会引发 panic。删除该行，程序将运行。
- en: '|  |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-463
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Contrast this to the equivalent program in Java, where a null receiver will
    crash the program immediately when a method is called.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 与在调用方法时会导致程序立即崩溃的 Java 中等效程序相比。
- en: '|  |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Go will happily call methods even when the receiver has a nil value. A nil receiver
    behaves no differently than a nil parameter. This means methods can guard against
    nil values, as shown in the following listing.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 即使接收器具有 `nil` 值，Go 也会愉快地调用方法。`nil` 接收器的行为与 `nil` 参数没有区别。这意味着方法可以防止 `nil` 值，如下面的列表所示。
- en: 'Listing 27.4\. Guard clause: guard.go'
  id: totrans-467
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 27.4\. 保护子句：guard.go
- en: '[PRE31]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Rather than check for `nil` before every call to the `birthday` method, the
    preceding listing guards against nil receivers inside the method.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前列表中在 `birthday` 方法中检查 `nil` 接收器相比。
- en: '|  |'
  id: totrans-470
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-471
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In Objective-C, invoking a method on nil doesn’t crash, but rather than call
    the method, it returns a zero value.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Objective-C 中，在 `nil` 上调用方法不会崩溃，但不会调用该方法，而是返回零值。
- en: '|  |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You decide how to handle `nil` in Go. Your methods can return zero values, or
    return an error, or let it crash.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 您决定如何在 Go 中处理 `nil`。您的方法可以返回零值，或返回一个错误，或者让它崩溃。
- en: '|  |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 27.2**'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 27.2**'
- en: '**[Q1:](#ch27qa4q0a1)**'
  id: totrans-477
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch27qa4q0a1)**'
- en: ''
  id: totrans-478
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What does accessing a field (`p.age`) do if `p` is nil?
  id: totrans-479
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果 `p` 是 `nil`，访问字段（`p.age`）会做什么？
- en: '|  |'
  id: totrans-480
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-481
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 27.2 answer**'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 27.2 答案**'
- en: '**[1:](#ch27qa3q1)**'
  id: totrans-483
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch27qa3q1)**'
- en: ''
  id: totrans-484
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It panics, crashing the program, unless the code checks for `nil` before the
    field access.
  id: totrans-485
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果在字段访问之前没有检查 `nil`，则会引发 panic，导致程序崩溃。
- en: '|  |'
  id: totrans-486
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 27.3\. Nil function values
  id: totrans-487
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.3\. `nil` 函数值
- en: When a variable is declared as a function type, its value is `nil` by default.
    In the following listing, `fn` has the type of a function, but it isn’t assigned
    to any specific function.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个变量被声明为函数类型时，其默认值为 `nil`。在下面的列表中，`fn` 具有函数类型，但没有分配给任何特定的函数。
- en: 'Listing 27.5\. Function types that are nil: fn.go'
  id: totrans-489
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 27.5\. `nil` 的函数类型：fn.go
- en: '[PRE32]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '***1* Prints true**'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 true**'
- en: If the preceding listing were to call `fn(1, 2)`, the program would panic with
    a nil pointer dereference, because there’s no function assigned to `fn`.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的列表调用 `fn(1, 2)`，程序会因为 `fn` 没有分配给任何函数而引发 panic，即空指针解引用。
- en: It’s possible to check whether a function value is `nil` and provide default
    behavior. In the next listing, `sort.Slice` is used to sort a slice of strings
    with a first-class `less` function. If `nil` is passed for the `less` argument,
    it defaults to a function that sorts alphabetically.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能检查函数值是否为 `nil` 并提供默认行为。在下一个列表中，`sort.Slice` 用于对字符串切片进行排序，其中包含一等 `less` 函数。如果为
    `less` 参数传递 `nil`，则默认为按字母顺序排序的函数。
- en: 'Listing 27.6\. A default function: sort.go'
  id: totrans-494
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 27.6\. 默认函数：sort.go
- en: '[PRE33]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1* Prints [carrot celery onion]**'
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 [胡萝卜 青葱 洋葱]**'
- en: '|  |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 27.3**'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 27.3**'
- en: '**[Q1:](#ch27qa6q0a1)**'
  id: totrans-499
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch27qa6q0a1)**'
- en: ''
  id: totrans-500
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a line of code to sort `food` from the shortest to longest string in [listing
    27.6](#ch27ex06).
  id: totrans-501
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 [列表 27.6](#ch27ex06) 中编写一行代码以按从短到长的字符串对 `food` 进行排序。
- en: '|  |'
  id: totrans-502
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-503
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 27.3 answer**'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 27.3 答案**'
- en: '**[1:](#ch27qa5q1)**'
  id: totrans-505
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch27qa5q1)**'
- en: ''
  id: totrans-506
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-507
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '|  |'
  id: totrans-508
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 27.4\. Nil slices
  id: totrans-509
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.4\. `nil` 切片
- en: A slice that’s declared without a composite literal or the `make` built-in will
    have a value of `nil`. Fortunately, the `range` keyword, `len` built-in, and `append`
    built-in all work with nil slices, as shown in the following listing.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用复合字面量或 `make` 内置函数声明的切片将具有 `nil` 值。幸运的是，`range` 关键字、`len` 内置函数和 `append`
    内置函数都可以与 `nil` 切片一起使用，如下面的列表所示。
- en: 'Listing 27.7\. Growing a slice: slice.go'
  id: totrans-511
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 27.7\. 增长一个切片：slice.go
- en: '[PRE35]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '***1* Prints true**'
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 true**'
- en: '***2* Prints 0**'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 0**'
- en: '***3* Prints [onion carrot celery]**'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 打印 [洋葱 胡萝卜 青葱]**'
- en: An empty slice and a nil slice aren’t equivalent, but they can often be used
    interchangeably. The following listing passes `nil` to a function that accepts
    a slice, skipping the step of making an empty slice.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 空切片和 `nil` 切片不等价，但它们通常可以互换使用。下面的列表将 `nil` 传递给接受切片的函数，跳过了创建空切片的步骤。
- en: 'Listing 27.8\. Start with nil: mirepoix.go'
  id: totrans-517
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 27.8\. 从 `nil` 开始：mirepoix.go
- en: '[PRE36]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '***1* Prints [onion carrot celery]**'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 [洋葱 胡萝卜 青葱]**'
- en: Whenever you write a function that accepts a slice, ensure that a nil slice
    has the same behavior as an empty slice.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 每次您编写接受切片的函数时，请确保 `nil` 切片具有与空切片相同的操作。
- en: '|  |'
  id: totrans-521
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 27.4**'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 27.4**'
- en: '**[Q1:](#ch27qa8q0a1)**'
  id: totrans-523
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch27qa8q0a1)**'
- en: ''
  id: totrans-524
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which actions are safe to perform on a nil slice?
  id: totrans-525
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在空切片上执行哪些操作是安全的？
- en: '|  |'
  id: totrans-526
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-527
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 27.4 answer**'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 27.4 答案**'
- en: '**[1:](#ch27qa7q1)**'
  id: totrans-529
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch27qa7q1)**'
- en: ''
  id: totrans-530
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The built-ins `len`, `cap`, and `append` are safe to use with a nil slice, as
    is the `range` key-word. As with an empty slice, directly accessing an element
    of a nil slice (`soup[0]`) will panic with index out of range.
  id: totrans-531
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 内置函数 `len`、`cap` 和 `append` 可以安全地与空切片一起使用，`range` 关键字也是如此。与空切片一样，直接访问空切片的元素（`soup[0]`）将导致索引越界恐慌。
- en: '|  |'
  id: totrans-532
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 27.5\. Nil maps
  id: totrans-533
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.5. 空映射
- en: As with slices, a map declared without a composite literal or the `make` built-in
    has a value of `nil`. Maps can be read even when nil, as shown in the following
    listing, though writing to a nil map will panic.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 与切片类似，未使用复合字面量或 `make` 内置函数声明的映射具有 `nil` 的值。映射可以在为空时读取，如以下列表所示，尽管向空映射写入将导致恐慌。
- en: 'Listing 27.9\. Reading a map: map.go'
  id: totrans-535
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 27.9. 读取映射：map.go
- en: '[PRE37]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '***1* Prints true**'
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 true**'
- en: If a function only reads from a map, it’s fine to pass the function `nil` instead
    of making an empty map.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数只从映射中读取，则可以传递 `nil` 而不是创建一个空映射。
- en: '|  |'
  id: totrans-539
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 27.5**'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 27.5**'
- en: '**[Q1:](#ch27qa10q0a1)**'
  id: totrans-541
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch27qa10q0a1)**'
- en: ''
  id: totrans-542
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What action on a nil map will cause a panic?
  id: totrans-543
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对空映射执行什么操作会导致恐慌？
- en: '|  |'
  id: totrans-544
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-545
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 27.5 answer**'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 27.5 答案**'
- en: '**[1:](#ch27qa9q1)**'
  id: totrans-547
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch27qa9q1)**'
- en: ''
  id: totrans-548
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Writing to a nil map (`soup["onion"] = 1`) will panic with: assignment to entry
    in nil map.'
  id: totrans-549
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 向空映射写入 (`soup["onion"] = 1`) 将导致恐慌：向空映射的条目赋值。
- en: '|  |'
  id: totrans-550
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 27.6\. Nil interfaces
  id: totrans-551
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.6. 空接口
- en: When a variable is declared to be an interface type without an assignment, the
    zero value is `nil`. The following listing demonstrates that the interface type
    and value are both `nil`, and the variable compares as equal to `nil`.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 当变量声明为接口类型但没有赋值时，其零值是 `nil`。以下列表演示了接口类型和值都是 `nil`，并且变量与 `nil` 进行比较时相等。
- en: 'Listing 27.10\. Interfaces can be nil: interface.go'
  id: totrans-553
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 27.10. 空映射：interface.go
- en: '[PRE38]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '***1* Prints <nil> <nil> true**'
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 <nil> <nil> true**'
- en: When a variable with an interface type is assigned a value, the interface internally
    points to the type and value of that variable. This leads to the rather surprising
    behavior of a nil value that doesn’t compare as equal to `nil`. Both the interface
    type and value need to be `nil` for the variable to equal `nil`, as shown in the
    following listing.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个具有接口类型的变量被赋予一个值时，接口内部指向该变量的类型和值。这导致了一个令人惊讶的行为，即空值不与 `nil` 相等。接口类型和值都需要是 `nil`，变量才等于
    `nil`，如以下列表所示。
- en: 'Listing 27.11\. Wat?: interface.go'
  id: totrans-557
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 27.11. Wat?：interface.go
- en: '[PRE39]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '***1* Prints *int <nil> false**'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 *int <nil> false**'
- en: The `%#v` format verb is shorthand to see both type and value, also revealing
    that the variable contains `(*int)(nil)` rather than just `<nil>`, as shown in
    [listing 27.12](#ch27ex12).
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '`%#v` 格式动词是查看类型和值的简写，同时也揭示了变量包含 `(*int)(nil)` 而不是仅仅 `<nil>`，如 [列表 27.12](#ch27ex12)
    所示。'
- en: 'Listing 27.12\. Inspecting the Go representation: interface.go'
  id: totrans-561
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 27.12. 检查 Go 表示：interface.go
- en: '[PRE40]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '***1* Prints (*int)(nil)**'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 (*int)(nil)**'
- en: To avoid surprises when comparing interfaces to nil, it’s best to use the `nil`
    identifier explicitly, rather than pointing to a variable that contains a nil.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在比较接口和空值时出现意外，最好显式使用 `nil` 标识符，而不是指向包含空值的变量。
- en: '|  |'
  id: totrans-565
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 27.6**'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 27.6**'
- en: '**[Q1:](#ch27qa12q0a1)**'
  id: totrans-567
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch27qa12q0a1)**'
- en: ''
  id: totrans-568
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What’s the value of `s` when declared as `var s fmt.Stringer`?
  id: totrans-569
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当声明 `var s fmt.Stringer` 时，`s` 的值是什么？
- en: '|  |'
  id: totrans-570
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-571
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 27.6 answer**'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 27.6 答案**'
- en: '**[1:](#ch27qa11q1)**'
  id: totrans-573
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch27qa11q1)**'
- en: ''
  id: totrans-574
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The value is `nil` because `fmt.Stringer` is an interface and the zero value
    for interfaces is `nil`.
  id: totrans-575
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 值是 `nil`，因为 `fmt.Stringer` 是一个接口，接口的零值是 `nil`。
- en: '|  |'
  id: totrans-576
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 27.7\. An alternative to nil
  id: totrans-577
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.7. 空值的替代方案
- en: It can be tempting to adopt nil whenever a value can be nothing. For example,
    a pointer to an integer (`*int`) can represent both zero and nil. Pointers are
    intended for pointing, so using a pointer just to provide a `nil` value isn’t
    necessarily the best option.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个值可以是空值时，可能会倾向于使用空值。例如，整数指针 (`*int`) 可以表示零和空值。指针旨在指向，所以仅仅为了提供一个空值而使用指针不一定是最优选择。
- en: Instead of using a pointer, one alternative is to declare a small structure
    with a few methods. It requires a little more code, but it doesn’t require a pointer
    or nil, as shown in the following listing.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用指针外，另一种选择是声明一个包含几个方法的简单结构。这需要更多的代码，但不需要指针或空值，如以下列表所示。
- en: 'Listing 27.13\. Number is set: valid.go'
  id: totrans-580
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 27.13. 数字已设置：valid.go
- en: '[PRE41]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '***1* Prints 42**'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 42**'
- en: '***2* Prints not set**'
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 not set**'
- en: '|  |'
  id: totrans-584
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 27.7**'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查27.7**'
- en: '**[Q1:](#ch27qa14q0a1)**'
  id: totrans-586
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch27qa14q0a1)**'
- en: ''
  id: totrans-587
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are some advantages to the approach taken in [listing 27.13](#ch27ex13)?
  id: totrans-588
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 采用[列表27.13](#ch27ex13)中方法的一些优点是什么？
- en: '|  |'
  id: totrans-589
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-590
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 27.7 answer**'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 27.7 答案**'
- en: '**[1:](#ch27qa13q1)**'
  id: totrans-592
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch27qa13q1)**'
- en: ''
  id: totrans-593
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It completely avoids nil pointer dereferences by not having pointers or `nil`
    values. The `valid` Boolean has a clear intention, whereas the meaning of `nil`
    is less clear.
  id: totrans-594
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它通过没有指针或 `nil` 值完全避免了空指针解引用。`valid` 布尔值有明确的目的，而 `nil` 的含义则不太明确。
- en: '|  |'
  id: totrans-595
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-596
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Nil pointer dereferences will crash your program.
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空指针解引用会导致你的程序崩溃。
- en: Methods can guard against receiving `nil` values.
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法可以防止接收 `nil` 值。
- en: Default behavior can be provided for functions passed as arguments.
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为传递给函数的参数提供默认行为。
- en: A nil slice is often interchangeable with an empty slice.
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `nil` 切片通常可以与空切片互换。
- en: A nil map can be read from but not written to.
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `nil` 映射可以从中读取但不能写入。
- en: If an interface looks like it’s nil, be sure both the type and value are `nil`.
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个接口看起来是 `nil`，确保类型和值都是 `nil`。
- en: Nil isn’t the only way to represent nothing.
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nil` 不是表示“无”的唯一方式。'
- en: Let’s see if you got this...
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否明白了...
- en: 'Experiment: knights.go'
  id: totrans-605
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实验：knights.go
- en: A knight blocks Arthur’s path. Our hero is empty-handed, represented by a `nil`
    value for `leftHand *item`. Implement a `character` struct with methods such as
    `pickup(i *item)` and `give(to *character)`. Then use what you’ve learned in this
    lesson to write a script that has Arthur pick up an item and give it to the knight,
    displaying an appropriate description for each action.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 一位骑士阻挡了亚瑟的道路。我们的英雄空手而归，用 `nil` 值表示 `leftHand *item`。实现一个 `character` 结构体，具有
    `pickup(i *item)` 和 `give(to *character)` 等方法。然后使用你在本课程中学到的知识编写一个脚本，让亚瑟拿起一个物品并将其交给骑士，显示每个动作的适当描述。
- en: Lesson 28\. To err is human
  id: totrans-607
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 课程28。犯错误是人类的天性
- en: After reading [lesson 28](#ch28), you’ll be able to
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完[课程28](#ch28)后，你将能够
- en: Write files and handle failure
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写文件和处理失败
- en: Handle errors with a flair of creativity
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用创意处理错误
- en: Make and identify specific errors
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建并识别特定错误
- en: Keep calm and carry on
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持冷静，继续前进
- en: The sirens sound. Students and teachers shuffle out of classrooms to the nearest
    exit and congregate at the muster point. There’s no danger in sight and nothing
    is on fire. It’s another routine fire drill. Everyone is better prepared in the
    event of a real emergency.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 喊声响起。学生和老师从教室里出来，走向最近的出口，在集合点聚集。眼前没有危险，也没有东西着火。这是另一个例行的消防演习。每个人都为真正的紧急情况做好了更好的准备。
- en: File not found, invalid format, the server is unreachable. What does software
    do when something goes wrong? Maybe the problem can be extinguished, allowing
    operations to carry on as usual. Perhaps the best course of action is to exit
    safely, closing doors on the way out—or crash through a fourth story window as
    a last resort.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 文件未找到，格式无效，服务器不可达。当出现问题时，软件会做什么？也许问题可以被解决，让操作像往常一样继续。也许最好的行动方案是安全退出，关闭门，或者作为最后的手段从四楼窗户冲出去。
- en: It’s important to have a plan. Consider the errors that could occur, how to
    communicate those errors, and the steps to handle them. Go keeps error handling
    front and center, encouraging you to think about failure and how to handle it.
    Like the tenth fire drill, error handling can feel mundane at times, but it ultimately
    leads to reliable software.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 制定计划很重要。考虑可能发生的错误，如何传达这些错误以及处理它们的步骤。Go将错误处理放在首位，鼓励你思考失败以及如何处理它。就像第十次消防演习一样，错误处理有时可能感觉平淡无奇，但最终会导致可靠的软件。
- en: This lesson explores a few ways to handle errors and delves into how errors
    are made. It closes by contrasting Go’s style of error handling with that of other
    programming languages.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 本课程探讨了处理错误的一些方法，并深入探讨了错误是如何产生的。最后，它通过对比Go的错误处理风格与其他编程语言的风格来结束。
- en: '|  |'
  id: totrans-617
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: 'In the early 18th century, Alexander Pope penned a poem containing a now well-known
    phrase: *to err is human*. Take a moment to consider this phrase and how it might
    relate to computer programming.'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 在18世纪初，亚历山大·蒲柏创作了一首包含现在广为人知的短语的诗：“犯错误是人类的天性”。花点时间考虑这个短语以及它可能如何与计算机编程相关。
- en: '*To err is human; to forgive, divine.*'
  id: totrans-620
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*犯错误是人类的天性；宽恕是神圣的。*'
- en: ''
  id: totrans-621
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Alexander Pope, “An Essay on Criticism: Part 2”*'
  id: totrans-622
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*亚历山大·蒲柏，《批评论文：第二部分》*'
- en: 'Here’s our take: everyone makes mistakes. Systems fail. Errors happen all the
    time. Errors aren’t exceptional, so you should expect that things could go wrong.
    What’s important is how you choose to respond. Acknowledge errors, don’t ignore
    them. Work to resolve issues and move on.'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的观点是：每个人都会犯错误。系统会失败。错误总是会发生。错误不是异常的，因此你应该预期事情可能会出错。重要的是你选择如何响应。承认错误，不要忽视它们。努力解决问题并继续前进。
- en: '|  |'
  id: totrans-624
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 28.1\. Handling errors
  id: totrans-625
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.1. 处理错误
- en: In programming languages of the past, the limitation of a single return value
    made error handling somewhat obscure. Functions would overload the same return
    value to indicate both an error or a successful value, or require a side channel
    to communicate the error, such as a global `errno` variable. Worse still, the
    mechanism to communicate errors was inconsistent from function to function.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的编程语言中，单一返回值的限制使得错误处理变得有些晦涩。函数会重载相同的返回值来指示错误或成功的值，或者需要一个侧通道来传递错误，例如全局的 `errno`
    变量。更糟糕的是，从函数到函数传递错误的机制不一致。
- en: Go has multiple return values, as mentioned in [lesson 12](kindle_split_023.html#ch12).
    Though not specific to error handling, multiple return values provide a simple
    and consistent mechanism to return errors to calling functions. If a function
    can return an error, the convention is to use the last return value for errors.
    The caller should check if an error occurred *immediately* after calling a function.
    If no errors occurred, the error value will be `nil`.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在 [第 12 课](kindle_split_023.html#ch12) 中提到的，Go 有多个返回值。虽然这不是专门针对错误处理的，但多个返回值提供了一个简单且一致的机制来将错误返回给调用函数。如果一个函数可以返回错误，惯例是使用最后一个返回值来表示错误。调用者应在调用函数后立即检查是否发生了错误。如果没有错误发生，错误值将是
    `nil`。
- en: To demonstrate error handling, [listing 28.1](#ch28ex01) calls the `ReadDir`
    function. If an error occurs, the `err` variable won’t be `nil`, causing the program
    to print the error and exit immediately. The nonzero value passed to `os.Exit`
    informs the operating system that an error occurred.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示错误处理，[代码示例 28.1](#ch28ex01) 调用了 `ReadDir` 函数。如果发生错误，`err` 变量不会是 `nil`，导致程序打印错误并立即退出。传递给
    `os.Exit` 的非零值通知操作系统发生了错误。
- en: If `ReadDir` is successful, `files` will be assigned to a slice of `os.FileInfo`,
    providing information on the files and directories at the specified path. In this
    case, a dot is specified for the path, indicating the current directory.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `ReadDir` 成功，`files` 将被分配给一个 `os.FileInfo` 切片，提供指定路径上文件和目录的信息。在这种情况下，指定了一个点，表示当前目录。
- en: 'Listing 28.1\. Files: files.go'
  id: totrans-630
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 28.1. 文件：files.go
- en: '[PRE42]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '|  |'
  id: totrans-632
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-633
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: When an error occurs, the other return values generally shouldn’t be relied
    on. They may be set to the zero values for their type, but some functions may
    return partial data or something else entirely.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生错误时，通常不应依赖其他返回值。它们可能被设置为它们类型的零值，但某些函数可能返回部分数据或完全不同的内容。
- en: '|  |'
  id: totrans-635
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'If you run [listing 28.1](#ch28ex01) in the Go Playground, it will output a
    list of directories:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将 [代码示例 28.1](#ch28ex01) 在 Go Playground 中运行，它将输出目录列表：
- en: '[PRE43]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: To list the contents of a different directory, replace the current directory
    (`"."`) in [listing 28.1](#ch28ex01) with the name of another directory, such
    as `"etc"`. The list may contain both files and directories. You can use `file.IsDir()`
    to distinguish between the two.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出不同目录的内容，可以将 [代码示例 28.1](#ch28ex01) 中的当前目录（`"."`）替换为另一个目录的名称，例如 `"etc"`。列表可能包含文件和目录。你可以使用
    `file.IsDir()` 来区分两者。
- en: '|  |'
  id: totrans-639
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 28.1**'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 28.1**'
- en: '**[1](#ch28qa2q0a1)**'
  id: totrans-641
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch28qa2q0a1)**'
- en: ''
  id: totrans-642
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Revise [listing 28.1](#ch28ex01) to read a make-believe directory, such as `"unicorns"`.
    What error message is displayed?
  id: totrans-643
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 修改 [代码示例 28.1](#ch28ex01) 以读取一个虚构的目录，例如 `"unicorns"`。会显示什么错误信息？
- en: '**[2](#ch28qa2q0a2)**'
  id: totrans-644
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch28qa2q0a2)**'
- en: ''
  id: totrans-645
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What error message is displayed if you use `ReadDir` on a file, such as `"/etc/hosts"`,
    rather than a directory?
  id: totrans-646
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你使用 `ReadDir` 在一个文件上，例如 `"/etc/hosts"`，而不是一个目录，会显示什么错误信息？
- en: '|  |'
  id: totrans-647
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-648
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 28.1 answer**'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 28.1 答案**'
- en: '**[1](#ch28qa1q1)**'
  id: totrans-650
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch28qa1q1)**'
- en: ''
  id: totrans-651
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'open unicorns: No such file or directory'
  id: totrans-652
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'open unicorns: 没有该文件或目录'
- en: '**[2](#ch28qa1q2)**'
  id: totrans-653
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch28qa1q2)**'
- en: ''
  id: totrans-654
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'readdirent: Invalid argument'
  id: totrans-655
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'readdirent: 无效参数'
- en: '|  |'
  id: totrans-656
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 28.2\. Elegant error handling
  id: totrans-657
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.2. 精美的错误处理
- en: Gophers are encouraged to consider and handle any errors that functions return.
    The amount of code dedicated to handling errors can quickly add up. Fortunately,
    there are several ways to reduce the amount of error-handling code without sacrificing
    reliability.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励 Gophers 考虑并处理函数返回的任何错误。用于处理错误的代码量可能会迅速增加。幸运的是，有几种方法可以减少错误处理代码的数量，而不会牺牲可靠性。
- en: Some functions perform equations, data transformations, and other logic without
    ever needing to return an error. Then there are functions that communicate with
    files, databases, and servers. Communication is messy and can fail. One strategy
    to reduce error-handling code is to isolate an error-free subset of a program
    from the inherently error-prone code.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 一些函数执行方程、数据转换和其他逻辑，而无需返回错误。然后有一些函数与文件、数据库和服务器进行通信。通信可能很混乱，可能会失败。减少错误处理代码的一种策略是将程序中无错误的子集与固有的错误易发代码隔离开。
- en: But what about code that does return errors? We can’t remove the errors, but
    we can work to simplify the error-handling code. To demonstrate, we’ll make a
    small program that writes the following Go Proverbs to a file and then improve
    the error handling until the code becomes palatable.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于返回错误的代码呢？我们无法移除错误，但我们可以努力简化错误处理代码。为了演示，我们将编写一个小程序，将以下Go谚语写入文件，并改进错误处理，直到代码变得可接受。
- en: Errors are values.
  id: totrans-661
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 错误是值。
- en: ''
  id: totrans-662
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Don’t just check errors, handle them gracefully.
  id: totrans-663
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不要只是检查错误，要优雅地处理它们。
- en: ''
  id: totrans-664
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Don’t panic.
  id: totrans-665
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不要恐慌。
- en: ''
  id: totrans-666
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Make the zero value useful.
  id: totrans-667
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使零值有用。
- en: ''
  id: totrans-668
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The bigger the interface, the weaker the abstraction.
  id: totrans-669
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 接口越大，抽象越弱。
- en: ''
  id: totrans-670
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`interface{}` says nothing.'
  id: totrans-671
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`interface{}` 没有说任何事情。'
- en: ''
  id: totrans-672
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Gofmt’s style is no one’s favorite, yet `gofmt` is everyone’s favorite.
  id: totrans-673
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Gofmt 的风格不是每个人的最爱，但 `gofmt` 是每个人的最爱。
- en: ''
  id: totrans-674
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Documentation is for users.
  id: totrans-675
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 文档是为用户准备的。
- en: ''
  id: totrans-676
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A little copying is better than a little dependency.
  id: totrans-677
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一点复制比一点依赖更好。
- en: ''
  id: totrans-678
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Clear is better than clever.
  id: totrans-679
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 清晰比聪明好。
- en: ''
  id: totrans-680
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Concurrency is not parallelism.
  id: totrans-681
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 并发不是并行。
- en: ''
  id: totrans-682
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Don’t communicate by sharing memory, share memory by communicating.
  id: totrans-683
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不要通过共享内存进行通信，而要通过通信共享内存。
- en: ''
  id: totrans-684
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Channels orchestrate; mutexes serialize.
  id: totrans-685
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通道进行编排；互斥锁进行序列化。
- en: ''
  id: totrans-686
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Rob Pike, Go Proverbs (see go-proverbs.github.io)*'
  id: totrans-687
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*罗布·派克，Go谚语（见go-proverbs.github.io）*'
- en: 28.2.1\. Writing a file
  id: totrans-688
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.2.1\. 写入文件
- en: Any number of things can go wrong when writing a file. If the path is invalid
    or there’s an issue with permissions, creating the file may fail before we even
    start writing. Once writing, the device could run out of disk space or be unplugged.
    In addition, a file must be closed when done, both to ensure it is successfully
    flushed to disk, and to avoid *leaking* resources.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 在写入文件时可能会出现许多问题。如果路径无效或存在权限问题，在开始写入之前创建文件可能会失败。一旦开始写入，设备可能会耗尽磁盘空间或被拔掉。此外，完成时必须关闭文件，以确保它成功刷新到磁盘，并避免*资源泄漏*。
- en: '|  |'
  id: totrans-690
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-691
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Operating systems can only have so many files open at once, so every open file
    cuts into that limit. When a file is unintentionally left open, the waste of that
    resource is an example of a leak.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统一次只能打开有限数量的文件，因此每个打开的文件都会减少这个限制。当文件意外地被留下打开时，这种资源的浪费是泄漏的一个例子。
- en: '|  |'
  id: totrans-693
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The main function in [listing 28.2](#ch28ex02) calls `proverbs` to create a
    file and handles any error by displaying it and exiting. A different implementation
    could handle errors differently, perhaps prompting the user for a different path
    and filename. Though the `proverbs` function could have been written to exit on
    errors, it’s useful to let the caller decide how to handle errors.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 28.2](#ch28ex02) 中的主函数调用 `proverbs` 创建文件，并通过显示错误并退出处理任何错误。不同的实现可以以不同的方式处理错误，例如提示用户输入不同的路径和文件名。尽管
    `proverbs` 函数可以编写为在错误时退出，但让调用者决定如何处理错误是有用的。'
- en: 'Listing 28.2\. Calling `proverbs`: proverbs.go'
  id: totrans-695
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 28.2\. 调用 `proverbs`：proverbs.go
- en: '[PRE44]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `proverbs` function may return an `error`, which is a special built-in type
    for errors. The function attempts to create a file. If an error occurs at this
    point, there’s no need to close the file, so it aborts immediately. The remainder
    of the function writes lines out to the file and ensures that the file is closed
    whether it succeeds or fails, as shown in the following listing.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '`proverbs` 函数可能会返回一个错误，这是一个用于错误的特殊内置类型。该函数尝试创建一个文件。如果在这一点上发生错误，就没有必要关闭文件，因此它立即中止。函数的其余部分将行写入文件，并确保无论成功与否，文件都会被关闭，如下面的列表所示。'
- en: 'Listing 28.3\. Writing Go Proverbs: proverbs.go'
  id: totrans-698
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 28.3\. 编写Go谚语：proverbs.go
- en: '[PRE45]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: There’s a fair amount of error-handling code in the previous listing—so much
    so, that writing out all the Go Proverbs could become quite tedious.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的列表中有相当多的错误处理代码——如此之多，以至于写出所有的 Go Proverbs 可能会变得相当乏味。
- en: On the positive side, the code that handles errors is consistently indented,
    which makes it easier to scan through the code without reading all the repetitive
    error handling. Indenting errors in this way is a common pattern in the Go community,
    but we can improve on this implementation.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 从积极的一面来看，处理错误的代码始终是缩进的，这使得在不需要阅读所有重复的错误处理的情况下扫描代码变得更容易。以这种方式缩进错误是 Go 社区中的一种常见模式，但我们可以在这种实现上做得更好。
- en: '|  |'
  id: totrans-702
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 28.2**'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 28.2**'
- en: '**[Q1:](#ch28qa4q0a1)**'
  id: totrans-704
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch28qa4q0a1)**'
- en: ''
  id: totrans-705
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why should functions return an error instead of exiting the program?
  id: totrans-706
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么函数应该返回错误而不是退出程序？
- en: '|  |'
  id: totrans-707
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-708
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 28.2 answer**'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 28.2 答案**'
- en: '**[1:](#ch28qa3q1)**'
  id: totrans-710
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch28qa3q1)**'
- en: ''
  id: totrans-711
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Returning an error gives the caller a chance to decide how to handle the error.
    For example, the program may decide to retry rather than exit.
  id: totrans-712
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回错误给调用者一个决定如何处理错误的机会。例如，程序可能决定重试而不是退出。
- en: '|  |'
  id: totrans-713
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 28.2.2\. The defer keyword
  id: totrans-714
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.2.2\. `defer` 关键字
- en: To ensure that that the file is closed correctly, you can make use of the `defer`
    keyword. Go ensures that all deferred actions take place before the containing
    function returns. In the following listing, every return statement that follows
    `defer` will result in the `f.Close()` method being called.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保文件正确关闭，您可以使用 `defer` 关键字。Go 确保所有延迟操作都在包含函数返回之前执行。在下面的列表中，每个跟随 `defer` 的返回语句都将导致调用
    `f.Close()` 方法。
- en: 'Listing 28.4\. `defer` cleanup: defer.go'
  id: totrans-716
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 28.4\. `defer` 清理：defer.go
- en: '[PRE46]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '|  |'
  id: totrans-718
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-719
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The behavior of the preceding listing is identical to that of [listing 28.3](#ch28ex03).
    Changing the code without changing its behavior is called *refactoring*. Much
    like polishing the first draft of an essay, refactoring is an important skill
    for writing better code.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 之前列表的行为与[列表 28.3](#ch28ex03)的行为相同。在不改变行为的情况下更改代码称为 *重构*。就像润色论文的第一稿一样，重构是编写更好代码的重要技能。
- en: '|  |'
  id: totrans-721
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You can defer any function or method, and like multiple return values, defer
    isn’t specifically for error handling. It does improve error handling by removing
    the burden of always having to remember to clean up. Thanks to `defer`, the code
    that handles errors can focus on the error at hand, and nothing more.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以推迟任何函数或方法，就像多重返回值一样，`defer` 并非专门用于错误处理。但它通过减少总是需要记住清理的负担来改进错误处理。多亏了 `defer`，处理错误的代码可以专注于当前错误，而无需关注其他任何事情。
- en: The `defer` keyword has made things a little better, but checking for errors
    after writing each line is still a pain. It’s time to get creative!
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: '`defer` 关键字使事情变得更好一些，但在每行写入后检查错误仍然很痛苦。是时候发挥创意了！'
- en: '|  |'
  id: totrans-724
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 28.3**'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 28.3**'
- en: '**[Q1:](#ch28qa6q0a1)**'
  id: totrans-726
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch28qa6q0a1)**'
- en: ''
  id: totrans-727
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When will the deferred action be called?
  id: totrans-728
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 延迟操作将在何时被调用？
- en: '|  |'
  id: totrans-729
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-730
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 28.3 answer**'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 28.3 答案**'
- en: '**[1:](#ch28qa5q1)**'
  id: totrans-732
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch28qa5q1)**'
- en: ''
  id: totrans-733
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Defer will be called when returning from the function.
  id: totrans-734
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当从函数返回时将调用`Defer`。
- en: '|  |'
  id: totrans-735
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 28.2.3\. Creative error handling
  id: totrans-736
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.2.3\. 创造性的错误处理
- en: In January 2015, a marvelous article on error handling was published on the
    Go blog ([blog.golang.org/errors-are-values](http://blog.golang.org/errors-are-values)).
    The article describes a simple way to write to a file without repeating the same
    error-handling code after every line.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年1月，一篇关于错误处理的精彩文章在 Go 博客上发布([blog.golang.org/errors-are-values](http://blog.golang.org/errors-are-values))。文章描述了一种简单的方法，可以在不重复每行后的相同错误处理代码的情况下写入文件。
- en: To apply this technique, you need to declare a new type, which we call `safeWriter`
    in [listing 28.5](#ch28ex05). If an error occurs while `safeWriter` is writing
    to a file, it stores the error instead of returning it. Subsequent attempts to
    write to the same file will be skipped if `writeln` sees that an error occurred
    previously.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用此技术，您需要声明一个新的类型，我们在[列表 28.5](#ch28ex05)中将其称为 `safeWriter`。如果 `safeWriter`
    在写入文件时发生错误，它将存储错误而不是返回它。如果 `writeln` 发现之前已发生错误，后续尝试写入同一文件将被跳过。
- en: 'Listing 28.5\. Storing error values: writer.go'
  id: totrans-739
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 28.5\. 存储错误值：writer.go
- en: '[PRE47]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '***1* A place to store the first error**'
  id: totrans-741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 存储第一个错误的地方**'
- en: '***2* Skips the write if an error occurred previously**'
  id: totrans-742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 如果之前发生错误，则跳过写入**'
- en: '***3* Writes a line and store any error**'
  id: totrans-743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 写入一行并存储任何错误**'
- en: Using `safeWriter`, the following listing writes several lines without repetitive
    error handling, yet still returns any errors that occur.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `safeWriter`，以下列表在不重复错误处理的情况下写入多行，但仍会返回发生的任何错误。
- en: 'Listing 28.6\. The road to proverbs: writer.go'
  id: totrans-745
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 28.6\. 通往谚语的途径：writer.go
- en: '[PRE48]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '***1* Returns an error, if one occurred**'
  id: totrans-747
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 如果发生错误则返回错误**'
- en: 'This is a far cleaner way to write a text file, but that isn’t the point. The
    same technique can be applied to creating zip files or to completely different
    tasks, and the big idea is even greater than a single technique:'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种更干净地写入文本文件的方法，但这不是重点。相同的技巧可以应用于创建 zip 文件或执行完全不同的任务，而大思想甚至比单一技巧还要重要：
- en: '*...errors are values, and the full power of the Go programming language is
    available for processing them.*'
  id: totrans-749
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*...错误是值，Go 编程语言的全部力量都可以用于处理它们。*'
- en: ''
  id: totrans-750
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Rob Pike, “Errors are values” (see [blog.golang.org/errors-are-values](http://blog.golang.org/errors-are-values))*'
  id: totrans-751
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Rob Pike, “Errors are values” (see [blog.golang.org/errors-are-values](http://blog.golang.org/errors-are-values))*'
- en: Elegant error handling is within your grasp.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 精美的错误处理尽在你的掌握之中。
- en: '|  |'
  id: totrans-753
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 28.4**'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 28.4**'
- en: '**[Q1:](#ch28qa8q0a1)**'
  id: totrans-755
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch28qa8q0a1)**'
- en: ''
  id: totrans-756
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If an error occurred while [listing 28.6](#ch28ex06) was writing “Clear is better
    than clever.” to a file, what sequence of events would follow?
  id: totrans-757
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果在 [列表 28.6](#ch28ex06) 写入“清晰胜过聪明”到文件时发生错误，接下来会有一系列什么事件发生？
- en: '|  |'
  id: totrans-758
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-759
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 28.4 answer**'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 28.4 答案**'
- en: '**[1:](#ch28qa7q1)**'
  id: totrans-761
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch28qa7q1)**'
- en: ''
  id: totrans-762
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The error is stored in the `sw` structure.
  id: totrans-763
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误存储在 `sw` 结构中。
- en: The `writeln` function will be called three more times, but it will see the
    stored error and not attempt to write to the file.
  id: totrans-764
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`writeln` 函数将被调用三次，但它将看到存储的错误，而不会尝试写入文件。'
- en: The stored error will be returned, and `defer` will try to close the file.
  id: totrans-765
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储的错误将被返回，并且 `defer` 将尝试关闭文件。
- en: '|  |'
  id: totrans-766
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 28.3\. New errors
  id: totrans-767
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.3\. 新的错误
- en: If a function receives parameters that are incorrect, or if something else goes
    wrong, you can create and return new error values to inform the caller of the
    problem.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数接收到的参数不正确，或者发生其他错误，你可以创建并返回新的错误值来通知调用者问题。
- en: To demonstrate new errors, [listing 28.7](#ch28ex07) builds the foundation for
    a Sudoku logic puzzle, which takes place on a 9 × 9 grid. Each square on the grid
    may contain a digit from 1 to 9\. This implementation will use a fixed-size array,
    and the number zero will indicate an empty square.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示新的错误，[列表 28.7](#ch28ex07) 为 Sudoku 逻辑谜题的构建奠定了基础，该谜题在一个 9 × 9 的网格上进行。网格上的每个方格可能包含从
    1 到 9 的数字。此实现将使用固定大小的数组，数字零将表示空方格。
- en: 'Listing 28.7\. Sudoku grid: sudoku1.go'
  id: totrans-770
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 28.7\. Sudoku 网格：sudoku1.go
- en: '[PRE49]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `errors` package (see [golang.org/pkg/errors/](http://golang.org/pkg/errors/))
    contains a constructor function that accepts a string for an error message. Using
    it, the `Set` method in [listing 28.8](#ch28ex08) may create and return an “out
    of bounds” error.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 包含错误构造函数的 `errors` 包（见 [golang.org/pkg/errors/](http://golang.org/pkg/errors/））可以接受一个字符串作为错误消息。使用它，[列表
    28.8](#ch28ex08) 中的 `Set` 方法可以创建并返回一个“越界”错误。
- en: '|  |'
  id: totrans-773
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-774
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Validating parameters at the beginning of a method guards the remainder of the
    method from worrying about bad input.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法开始时验证参数可以保护方法的其他部分免受坏输入的担忧。
- en: '|  |'
  id: totrans-776
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Listing 28.8\. Validate parameters: sudoku1.go'
  id: totrans-777
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 28.8\. 验证参数：sudoku1.go
- en: '[PRE50]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `inBounds` function in the next listing ensures that `row` and `column`
    are inside the grid boundaries. It keeps the `Set` method from becoming weighed
    down in details.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表中的 `inBounds` 函数确保 `row` 和 `column` 在网格边界内。它防止 `Set` 方法被细节拖累。
- en: 'Listing 28.9\. Helper function: sudoku1.go'
  id: totrans-780
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 28.9\. 辅助函数：sudoku1.go
- en: '[PRE51]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Finally, the `main` function in the next listing creates a grid and displays
    any error resulting from an invalid placement.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，下一个列表中的 `main` 函数创建一个网格并显示任何由于无效放置而产生的错误。
- en: 'Listing 28.10\. Set a digit: sudoku1.go'
  id: totrans-783
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 28.10\. 设置数字：sudoku1.go
- en: '[PRE52]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '|  |'
  id: totrans-785
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-786
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: It’s common to use partial sentences for error messages so that the message
    can be augmented with additional text before it’s displayed.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 在错误消息中使用部分句子是常见的，这样在显示之前可以添加额外的文本来增强消息。
- en: '|  |'
  id: totrans-788
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Always take the time to write informative error messages. Think of error messages
    as part of the user interface for your program, whether for end users or other
    software developers. The phrase “out of bounds” is okay, but “outside of grid
    boundaries” may be better. A message like “error 37” isn’t very helpful at all.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 总是花时间编写有信息量的错误消息。将错误消息视为您程序的用户界面的一部分，无论是面向最终用户还是其他软件开发人员。短语“越界”是可以的，但“超出网格边界”可能更好。像“错误
    37”这样的消息几乎没有任何帮助。
- en: '|  |'
  id: totrans-790
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 28.5**'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 28.5**'
- en: '**[Q1:](#ch28qa10q0a1)**'
  id: totrans-792
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch28qa10q0a1)**'
- en: ''
  id: totrans-793
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How is it beneficial to guard against bad input at the beginning of a function?
  id: totrans-794
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在函数开始时防止不良输入有什么好处？
- en: '|  |'
  id: totrans-795
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-796
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 28.5 answer**'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 28.5 答案**'
- en: '**[1:](#ch28qa9q1)**'
  id: totrans-798
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch28qa9q1)**'
- en: ''
  id: totrans-799
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The remainder of the function doesn’t need to consider bad input because it
    has already been checked. Instead of letting it fail (for example, “runtime error:
    index out of range”) a friendly message can be returned.'
  id: totrans-800
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 函数的其余部分不需要考虑不良输入，因为它已经进行了检查。与其让它失败（例如，“运行时错误：索引越界”）不如返回一个友好的消息。
- en: '|  |'
  id: totrans-801
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 28.3.1\. Which error is which
  id: totrans-802
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.3.1\. 哪个错误是哪个
- en: Many Go packages declare and export variables for the errors that they could
    return. To apply this to the Sudoku grid, the next listing declares the two error
    variables at the package level.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Go 包声明并导出它们可能返回的错误变量。要将此应用于数独网格，下面的列表在包级别声明了两个错误变量。
- en: 'Listing 28.11\. Declare error variables: sudoku2.go'
  id: totrans-804
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 28.11\. 声明错误变量：sudoku2.go
- en: '[PRE53]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '|  |'
  id: totrans-806
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-807
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: By convention, error messages are assigned to variables that begin with the
    word `Err`.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，错误消息被分配给以单词 `Err` 开头的变量。
- en: '|  |'
  id: totrans-809
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: With `ErrBounds` declared, you can revise the `Set` method to return it instead
    of creating a new error, as shown in the following listing.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 声明 `ErrBounds` 后，你可以修改 `Set` 方法，使其返回它而不是创建一个新的错误，如下面的列表所示。
- en: 'Listing 28.12\. Return the error: sudoku2.go'
  id: totrans-811
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 28.12\. 返回错误：sudoku2.go
- en: '[PRE54]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If the `Set` method returns an error, the caller can distinguish between possible
    errors and handle specific errors differently, as shown in the following listing.
    You can compare the error returned with error variables using `==` or a `switch`
    statement.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `Set` 方法返回错误，调用者可以区分可能的错误，并针对特定错误进行不同的处理，如下面的列表所示。您可以使用 `==` 或 `switch` 语句将返回的错误与错误变量进行比较。
- en: 'Listing 28.13\. Which error in main: sudoku2.go'
  id: totrans-814
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 28.13\. 主函数中的哪个错误：sudoku2.go
- en: '[PRE55]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '|  |'
  id: totrans-816
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-817
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The `errors.New` constructor is implemented using a pointer, so the `switch`
    statement in preceding listing is comparing memory addresses, not the text contained
    in the error message.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: '`errors.New` 构造函数使用指针实现，所以前面列表中的 `switch` 语句是在比较内存地址，而不是错误消息中的文本。'
- en: '|  |'
  id: totrans-819
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-820
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 28.6**'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 28.6**'
- en: '**[Q1:](#ch28qa12q0a1)**'
  id: totrans-822
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch28qa12q0a1)**'
- en: ''
  id: totrans-823
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a `validDigit` function and use it to ensure that the `Set` method only
    accepts digits between 1 and 9.
  id: totrans-824
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写一个 `validDigit` 函数，并使用它来确保 `Set` 方法只接受 1 到 9 之间的数字。
- en: '|  |'
  id: totrans-825
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-826
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 28.6 answer**'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 28.6 答案**'
- en: '**[1:](#ch28qa11q1)**'
  id: totrans-828
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch28qa11q1)**'
- en: ''
  id: totrans-829
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-830
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE56]'
- en: ''
  id: totrans-831
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `Set` method should contain this additional check:'
  id: totrans-832
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Set` 方法应包含此附加检查：'
- en: ''
  id: totrans-833
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-834
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '|  |'
  id: totrans-835
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 28.3.2\. Custom error types
  id: totrans-836
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.3.2\. 自定义错误类型
- en: As helpful as `errors.New` is, there are times when it’s desirable to represent
    errors with more than a simple message. Go gives you the freedom to do this.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `errors.New` 很有帮助，但有时我们希望用比简单消息更复杂的内容来表示错误。Go 给你这样的自由。
- en: The `error` type is a built-in interface, as shown in the following listing.
    Any type that implements an `Error()` method that returns a string will implicitly
    satisfy the error interface. As an interface, it’s possible to create new error
    types.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: '`error` 类型是一个内置接口，如下面的列表所示。任何实现了返回字符串的 `Error()` 方法的类型都将隐式满足错误接口。作为接口，您可以创建新的错误类型。'
- en: Listing 28.14\. The `error` interface
  id: totrans-839
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 28.14\. `error` 接口
- en: '[PRE58]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Multiple errors
  id: totrans-841
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 多个错误
- en: 'There could be several reasons why a digit can’t be placed at a particular
    location in Sudoku. The preceding section established two rules: that the row
    and column are within the grid, and that the digit is between 1 and 9\. What if
    the caller passes multiple invalid arguments?'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 在数独中，一个数字不能放置在特定位置可能有几个原因。前面的部分确立了两个规则：行和列必须在网格内，数字必须在 1 到 9 之间。如果调用者传递多个无效参数怎么办？
- en: Rather than return one error at a time, the `Set` method could perform multiple
    validations and return all the errors at once. The `SudokuError` type in [listing
    28.15](#ch28ex15) is a slice of `error`. It satisfies the `error` interface with
    a method that joins multiple errors together into one string.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是一次返回一个错误，`Set` 方法可以执行多个验证，并一次性返回所有错误。在 [列表 28.15](#ch28ex15) 中的 `SudokuError`
    类型是一个 `error` 切片。它通过一个将多个错误连接成一个字符串的方法满足 `error` 接口。
- en: '|  |'
  id: totrans-844
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-845
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: By convention, custom error types like `SudokuError` end with the word `Error`.
    Sometimes they’re just the word `Error`, such as `url.Error` from the `url` package.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，像 `SudokuError` 这样的自定义错误类型以单词 `Error` 结尾。有时它们只是单词 `Error`，例如 `url` 包中的
    `url.Error`。
- en: '|  |'
  id: totrans-847
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Listing 28.15\. Custom `error` type: sudoku3.go'
  id: totrans-848
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 28.15\. 自定义 `error` 类型：sudoku3.go
- en: '[PRE59]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '***1* Converts the errors to strings**'
  id: totrans-850
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将错误转换为字符串**'
- en: To make use of `SudokuError`, the `Set` method can be modified to validate both
    the boundaries and digit, returning both errors at once, as shown in the following
    listing.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 `SudokuError`，`Set` 方法可以被修改以验证边界和数字，同时返回两个错误，如下面的列表所示。
- en: 'Listing 28.16\. Appending errors: sudoku3.go'
  id: totrans-852
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 28.16\. 添加错误：sudoku3.go
- en: '[PRE60]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '***1* Returns type is error**'
  id: totrans-854
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 返回类型是 error**'
- en: '***2* Returns nil**'
  id: totrans-855
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 返回 nil**'
- en: If no errors occur, the `Set` method returns `nil`. This hasn’t changed from
    [listing 28.8](#ch28ex08), but it’s important to highlight that it doesn’t return
    an empty `errs` slice. Review nil interfaces in the preceding lesson if you’re
    not sure why.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误发生，`Set` 方法返回 `nil`。这并没有从 [列表 28.8](#ch28ex08) 中改变，但重要的是要强调它不会返回一个空的 `errs`
    切片。如果你不确定为什么，请回顾前一个课程中的 nil 接口。
- en: The method signature for `Set` also hasn’t changed from [listing 28.8](#ch28ex08).
    Always use the `error` interface type when returning errors, not concrete types
    like `SudokuError`.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set` 方法的签名也没有从 [列表 28.8](#ch28ex08) 中改变。在返回错误时，始终使用 `error` 接口类型，而不是像 `SudokuError`
    这样的具体类型。'
- en: '|  |'
  id: totrans-858
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 28.7**'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 28.7**'
- en: '**[Q1:](#ch28qa14q0a1)**'
  id: totrans-860
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch28qa14q0a1)**'
- en: ''
  id: totrans-861
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if the `Set` method returns an empty `errs` slice on success?
  id: totrans-862
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果 `Set` 方法在成功时返回一个空的 `errs` 切片会发生什么？
- en: '|  |'
  id: totrans-863
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-864
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 28.7 answer**'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 28.7 答案**'
- en: '**[1:](#ch28qa13q1)**'
  id: totrans-866
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch28qa13q1)**'
- en: ''
  id: totrans-867
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `error` interface that’s returned won’t be `nil`. Even though the slice
    of errors is empty, the caller will think there was an error.
  id: totrans-868
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回的 `error` 接口不会是 `nil`。即使错误切片为空，调用者也会认为发生了错误。
- en: '|  |'
  id: totrans-869
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Type assertions
  id: totrans-870
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 类型断言
- en: Because [listing 28.16](#ch28ex16) converts `SudokuError` to an `error` interface
    type before it’s returned, you may wonder how to access the individual errors.
    The answer is with *type assertions*. Using a type assertion, you can convert
    an interface to the underlying concrete type.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 [列表 28.16](#ch28ex16) 在返回之前将 `SudokuError` 转换为 `error` 接口类型，你可能想知道如何访问单个错误。答案是使用
    *类型断言*。使用类型断言，你可以将接口转换为底层具体类型。
- en: The type assertion in [listing 28.17](#ch28ex17) asserts that `err` is of type
    `SudokuError` with the code `err.(SudokuError)`. If it is, `ok` will be true,
    and `errs` will be a `SudokuError`, giving access to the slice of errors in this
    case. Remember that the individual errors appended to `SudokuError` are the variables
    `ErrBounds` and `ErrDigit`, which allow comparisons if desired.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 28.17](#ch28ex17) 中的类型断言断言 `err` 是 `SudokuError` 类型，代码为 `err.(SudokuError)`。如果是，`ok`
    将为真，`errs` 将是 `SudokuError`，从而可以访问此情况下的错误切片。记住，附加到 `SudokuError` 的单个错误是 `ErrBounds`
    和 `ErrDigit` 变量，如果需要，可以进行比较。
- en: 'Listing 28.17\. Type assertion: sudoku3.go'
  id: totrans-873
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 28.17\. 类型断言：sudoku3.go
- en: '[PRE61]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The preceding listing will output the following errors:'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的列表将输出以下错误：
- en: '[PRE62]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '|  |'
  id: totrans-877
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-878
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If a type satisfies multiple interfaces, type assertions can also convert from
    one interface to another.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类型满足多个接口，类型断言也可以从一个接口转换为另一个接口。
- en: '|  |'
  id: totrans-880
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-881
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 28.8**'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 28.8**'
- en: '**[Q1:](#ch28qa16q0a1)**'
  id: totrans-883
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch28qa16q0a1)**'
- en: ''
  id: totrans-884
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What does the type assertion `err.(SudokuError)` do?
  id: totrans-885
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 类型断言 `err.(SudokuError)` 做什么？
- en: '|  |'
  id: totrans-886
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-887
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 28.8 answer**'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 28.8 答案**'
- en: '**[1:](#ch28qa15q1)**'
  id: totrans-889
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch28qa15q1)**'
- en: ''
  id: totrans-890
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It attempts to convert the `err` value from the `error` interface type to the
    concrete `SudokuError` type.
  id: totrans-891
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它尝试将 `err` 值从 `error` 接口类型转换为具体的 `SudokuError` 类型。
- en: '|  |'
  id: totrans-892
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 28.4\. Don’t panic
  id: totrans-893
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.4\. 不要恐慌
- en: Several languages rely heavily on *exceptions* for communicating and handling
    errors. Go doesn’t have exceptions, but it does have a similar mechanism called
    `panic`. When a *panic* occurs, the program will crash, as is the case with unhandled
    exceptions in other languages.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 几种语言严重依赖*异常*来传递和处理错误。Go没有异常，但它确实有一个类似的机制，称为`panic`。当发生*panic*时，程序将崩溃，就像其他语言中未处理的异常一样。
- en: '![](f0245-01.jpg)'
  id: totrans-895
  prefs: []
  type: TYPE_IMG
  zh: '![](f0245-01.jpg)'
- en: 28.4.1\. Exceptions in other languages
  id: totrans-896
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.4.1\. 其他语言中的异常
- en: Exceptions differ significantly from Go’s error values in both behavior and
    implementation.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 异常在行为和实现上都与Go的错误值有显著差异。
- en: If a function throws an exception and no one is around to catch it, the exception
    will bubble up to the calling function, and the caller of that function, and so
    on, until it reaches the top of the *call stack* (for example, the `main` function).
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数抛出异常而没有人来捕获它，异常将向上冒泡到调用函数，然后是那个函数的调用者，依此类推，直到达到*调用栈*的顶部（例如，`main`函数）。
- en: Exceptions are a style of error handling that can be considered opt-in. It often
    takes no code to opt out of handling exceptions, whereas opting in to exception
    handling may involve a fair amount of specialized code. This is because instead
    of using existing language features, exceptions tend to have special keywords,
    such as `try`, `catch`, `throw`, `finally`, `raise`, `rescue`, `except`, and so
    on.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是一种可以被认为是可选的错误处理方式。通常，不处理异常不需要任何代码，而选择异常处理可能需要相当多的专用代码。这是因为异常通常使用特殊的关键字，如`try`、`catch`、`throw`、`finally`、`raise`、`rescue`、`except`等，而不是使用现有的语言特性。
- en: Error values in Go provide a simple, flexible alternative to exceptions that
    can help you build reliable software. Ignoring error values in Go is a conscious
    decision that is plainly evident to anyone reading the resulting code.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的错误值提供了一个简单、灵活的替代方案，可以用来构建可靠的软件。在Go中忽略错误值是一个有意识的决策，对阅读代码的人来说是显而易见的。
- en: '|  |'
  id: totrans-901
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 28.9**'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查28.9**'
- en: '**[Q1:](#ch28qa18q0a1)**'
  id: totrans-903
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch28qa18q0a1)**'
- en: ''
  id: totrans-904
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are two benefits of Go’s error values as compared to exceptions?
  id: totrans-905
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与异常相比，Go的错误值有哪些两个优点？
- en: '|  |'
  id: totrans-906
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-907
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 28.9 answer**'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 28.9 答案**'
- en: '**[1:](#ch28qa17q1)**'
  id: totrans-909
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch28qa17q1)**'
- en: ''
  id: totrans-910
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Go pushes developers to consider errors, which can result in more reliable software,
    whereas exceptions tend to be ignored by default. Error values don’t require specialized
    keywords, making them simpler, while also being more flexible.
  id: totrans-911
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Go鼓励开发者考虑错误，这可以导致更可靠的软件，而异常通常默认被忽略。错误值不需要特定的关键字，这使得它们更简单，同时也更灵活。
- en: '|  |'
  id: totrans-912
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 28.4.2\. How to panic
  id: totrans-913
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.4.2\. 如何使用panic
- en: 'As mentioned, Go does have a mechanism similar to exceptions: `panic`. Whereas
    an invalid digit in Sudoku may be cause for an exception in another language,
    `panic` in Go is rare.'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Go确实有一个类似于异常的机制：`panic`。在其他语言中，数独中的无效数字可能引起异常，但在Go中，`panic`是罕见的。
- en: 'If the world is about to end, and you forgot your trusty towel back on Earth,
    then perhaps panic is warranted. The argument passed to `panic` can be any type,
    not only strings as shown here:'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 如果世界即将结束，而你又忘记了在地球上信任的毛巾，那么或许`panic`是合理的。传递给`panic`的参数可以是任何类型，而不仅仅是像这里显示的字符串：
- en: '[PRE63]'
  id: totrans-916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '|  |'
  id: totrans-917
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-918
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Though error values are generally preferable to `panic`, `panic` is often better
    than `os.Exit` in that `panic` will run any deferred functions, whereas `os.Exit`
    does not.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管错误值通常比`panic`更可取，但`panic`通常比`os.Exit`更好，因为`panic`会运行任何延迟执行的函数，而`os.Exit`则不会。
- en: '|  |'
  id: totrans-920
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'There are some situations where Go will panic instead of providing an error
    value, such as when dividing by zero:'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，Go会抛出`panic`而不是提供错误值，例如在除以零时：
- en: '[PRE64]'
  id: totrans-922
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '***1* Runtime error: integer divide by zero**'
  id: totrans-923
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 运行时错误：整数除以零**'
- en: '|  |'
  id: totrans-924
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 28.10**'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查28.10**'
- en: '**[Q1:](#ch28qa20q0a1)**'
  id: totrans-926
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch28qa20q0a1)**'
- en: ''
  id: totrans-927
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When should your program panic?
  id: totrans-928
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你的程序应该在什么情况下panic？
- en: '|  |'
  id: totrans-929
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-930
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 28.10 answer**'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 28.10 答案**'
- en: '**[1:](#ch28qa19q1)**'
  id: totrans-932
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch28qa19q1)**'
- en: ''
  id: totrans-933
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Panic should be rare.
  id: totrans-934
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: panic应该很少发生。
- en: '|  |'
  id: totrans-935
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 28.4.3\. Keep calm and carry on
  id: totrans-936
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.4.3\. 保持冷静，继续前进
- en: To keep `panic` from crashing your program, Go provides a `recover` function,
    shown in [listing 28.18](#ch28ex18).
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止`panic`导致程序崩溃，Go提供了`recover`函数，如[代码列表28.18](#ch28ex18)所示。
- en: Deferred functions are executed before a function returns, even in the case
    of panic. If a deferred function calls `recover`, the panic will stop, and the
    program will continue running. As such, recover serves a similar purpose to `catch`,
    `except`, and `rescue` in other languages.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟函数在函数返回之前执行，即使在panic的情况下也是如此。如果一个延迟函数调用了`recover`，panic将会停止，程序将继续运行。因此，`recover`在其他语言中的`catch`、`except`和`rescue`具有类似的作用。
- en: 'Listing 28.18\. Keep calm and carry on: panic.go'
  id: totrans-939
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 28.18\. 保持冷静，继续前进：panic.go
- en: '[PRE65]'
  id: totrans-940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '***1* Recovers from panic**'
  id: totrans-941
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从panic中恢复**'
- en: '***2* Prints I forgot my towel**'
  id: totrans-942
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 我忘了我的毛巾**'
- en: '***3* Causes panic**'
  id: totrans-943
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 引起panic**'
- en: '|  |'
  id: totrans-944
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-945
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding listing uses an anonymous function, a topic covered in [lesson
    14](kindle_split_025.html#ch14).
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的列表使用了一个匿名函数，这是在第14课中介绍的主题。
- en: '|  |'
  id: totrans-947
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-948
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 28.11**'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 28.11**'
- en: '**[Q1:](#ch28qa22q0a1)**'
  id: totrans-950
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch28qa22q0a1)**'
- en: ''
  id: totrans-951
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Where can the `recover` built-in function be used?
  id: totrans-952
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`recover`内置函数在哪里可以使用？'
- en: '|  |'
  id: totrans-953
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-954
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 28.11 answer**'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 28.11 答案**'
- en: '**[1:](#ch28qa21q1)**'
  id: totrans-956
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch28qa21q1)**'
- en: ''
  id: totrans-957
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Only deferred functions can make use of `recover`.
  id: totrans-958
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 只有延迟函数才能使用`recover`。
- en: '|  |'
  id: totrans-959
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-960
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Errors are values that interoperate with multiple return values and the rest
    of the Go language.
  id: totrans-961
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误是与多个返回值和Go语言的其他部分交互的值。
- en: There is a great deal of flexibility in handling errors if you’re willing to
    get creative.
  id: totrans-962
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你愿意发挥创意，处理错误有很大的灵活性。
- en: Custom error types are possible by satisfying the `error` interface.
  id: totrans-963
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过满足`error`接口，可以实现自定义错误类型。
- en: The `defer` keyword helps clean up before a function returns.
  id: totrans-964
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defer`关键字有助于在函数返回之前进行清理。'
- en: Type assertions can convert an interface to a concrete type or another interface.
  id: totrans-965
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型断言可以将接口转换为具体类型或另一个接口。
- en: Don’t panic—return an error instead.
  id: totrans-966
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要panic——返回一个错误代替。
- en: Let’s see if you got this...
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否掌握了这个...
- en: 'Experiment: url.go'
  id: totrans-968
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实验：url.go
- en: 'In the Go standard library, there’s a function to parse web addresses (see
    [golang.org/pkg/net/url/#Parse](http://golang.org/pkg/net/url/#Parse)). Display
    the error that occurs when `url.Parse` is used with an invalid web address, such
    as one containing a space: `https://a b.com/`.'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go标准库中，有一个用于解析网络地址的函数（见[golang.org/pkg/net/url/#Parse](http://golang.org/pkg/net/url/#Parse)）。当使用无效的网络地址（例如包含空格的地址）时，显示`url.Parse`发生的错误：`https://a
    b.com/`。
- en: Use the `%#v` format verb with `Printf` to learn more about the error. Then
    perform a `*url.Error` type assertion to access and print the fields of the underlying
    structure.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Printf`的`%#v`格式说明符来了解更多关于错误的信息。然后执行一个`*url.Error`类型断言来访问并打印底层结构的字段。
- en: '|  |'
  id: totrans-971
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-972
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: A URL, or Uniform Resource Locator, is the address of a page on the World Wide
    Web.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 一个URL，或统一资源定位符，是万维网上一个页面的地址。
- en: '|  |'
  id: totrans-974
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Lesson 29\. Capstone: Sudoku rules'
  id: totrans-975
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 课 29\. 顶峰：数独规则
- en: Sudoku is a logic puzzle that takes place on a 9 × 9 grid (see [en.wikipedia.org/wiki/Sudoku](http://en.wikipedia.org/wiki/Sudoku)).
    Each square can contain a digit from 1 through 9\. The number zero indicates an
    empty square.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 数独是一种逻辑谜题，发生在9 × 9的网格上（见[en.wikipedia.org/wiki/Sudoku](http://en.wikipedia.org/wiki/Sudoku)）。每个方格可以包含从1到9的数字。数字零表示空方格。
- en: 'The grid is divided into nine subregions that are 3 × 3 each. When placing
    a digit, it must adhere to certain constraints. The digit being placed may not
    already appear in any of the following:'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 网格被分成九个3 × 3的子区域。放置数字时，必须遵守某些约束。放置的数字不能出现在以下任何一种情况中：
- en: The horizontal row it’s placed in
  id: totrans-978
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它放置的水平行
- en: The vertical column it’s placed in
  id: totrans-979
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它放置的垂直列
- en: The 3 × 3 subregion it’s placed in
  id: totrans-980
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它放置的3 × 3子区域
- en: '![](f0248-01.jpg)'
  id: totrans-981
  prefs: []
  type: TYPE_IMG
  zh: '![](f0248-01.jpg)'
- en: Use a fixed-size (9 × 9) array to hold the Sudoku grid. If a function or method
    needs to modify the array, remember that you need to pass the array with a pointer.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 使用固定大小（9 × 9）的数组来存储数独网格。如果一个函数或方法需要修改数组，请记住你需要传递一个指向数组的指针。
- en: Implement a method to set a digit at a specific location. This method should
    return an error if placing the digit breaks one of the rules.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个方法来在特定位置设置数字。如果放置数字违反了规则之一，该方法应返回一个错误。
- en: Also implement a method to clear a digit from a square. This method need not
    adhere to these constraints, as several squares may be empty (zero).
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 还实现一个方法来清除一个方格中的数字。这个方法不需要遵守这些约束，因为可能有多个方格是空的（零）。
- en: 'Sudoku puzzles begin with some digits already set. Write a constructor function
    to prepare the Sudoku puzzle, and use a composite literal to specify the initial
    values. Here’s an example:'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 数独谜题开始时已经有一些数字被设置好了。编写一个构造函数来准备数独谜题，并使用复合字面量来指定初始值。以下是一个示例：
- en: '[PRE66]'
  id: totrans-986
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The starting digits are fixed in place and may not be overwritten or cleared.
    Modify your program so that it can identify which digits are fixed and which are
    penciled in. Add a validation that causes set and clear to return an error for
    any of the fixed digits. The digits that are initially zero may be set, overwritten,
    and cleared.
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 起始数字固定在位置上，不能被覆盖或清除。修改你的程序，使其能够识别哪些数字是固定的，哪些是铅笔标记的。添加一个验证，使得对于任何固定的数字，设置和清除操作都会返回错误。初始为零的数字可以被设置、覆盖和清除。
- en: You don’t need to write a Sudoku solver for this exercise, but be sure to test
    that all the rules are implemented correctly.
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要为这个练习编写数独求解器，但一定要确保所有规则都正确实现。
