- en: 9 Creating custom plugins
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 创建自定义插件
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Developing custom Fluentd plugins for Redis
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Redis开发自定义Fluentd插件
- en: Using Fluentd utilities to speed up development
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Fluentd实用工具加速开发
- en: Implementing the Fluentd plugin life cycle methods
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现Fluentd插件的生命周期方法
- en: Testing and packaging custom Fluentd plugins
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试和打包自定义Fluentd插件
- en: Creating documentation for the custom plugins
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为自定义插件创建文档
- en: At various points in the book, we have referred to Fluentd’s support for the
    development of plugins beyond those from the core product. The extensibility of
    Fluentd has led to a robust ecosystem of third-party plugins to make it easy to
    capture, filter, manipulate, and send them to many different systems and data
    stores. We have also discussed how custom plugins could connect to and monitor
    esoteric and legacy solutions when things cannot easily or efficiently be achieved
    with the existing plugins.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的各个部分，我们提到了Fluentd对插件开发的支持，这些插件不仅限于核心产品提供的那些。Fluentd的可扩展性导致了强大的第三方插件生态系统，这使得捕获、过滤、操作并将它们发送到许多不同的系统和数据存储变得容易。我们还讨论了当现有插件无法轻松或高效地完成任务时，自定义插件如何连接和监控一些特殊和遗留解决方案。
- en: In this chapter, we will walk through the process of creating an input and output
    plugin that makes use of Redis’s list capability. We will take a closer look at
    Redis and the rationale behind its use.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细介绍创建一个利用Redis列表功能的输入和输出插件的过程。我们将更深入地了解Redis及其使用理由。
- en: Developing Ruby
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 开发Ruby
- en: This chapter does call for some development experience. Still, you do not need
    to be a hardcore Ruby developer to take the information shown here and put it
    into action. Like most languages, once you have had some development experience
    with one language, you can use that understanding to start coming to grips with
    others. I count myself in this category given that I’ve come through a career
    of programming with Ada, C, C++, and then Java for the last 15 or more years.
    We are not going to write another Ruby book; others have done an exceptional job
    of this already, such as David A. Black and Joseph Leo III with *The Well-Grounded
    Rubyist*, 3rd edition (Manning, 2017). I have tried to provide just enough detail
    for you to understand what we are doing with Ruby and the code without first learning
    the language. After all, it is our goal to help you understand what is happening
    with Fluentd. In appendix E, we have included links to resources to help you learn
    the basics of Ruby and to better understand the tools used, or you might want
    to make use of them if you take on the exercises.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章确实需要一些开发经验。尽管如此，您不需要成为核心Ruby开发者就能将这里展示的信息付诸实践。像大多数语言一样，一旦您在一种语言上有所开发经验，您就可以利用这种理解来开始掌握其他语言。我把自己归入这一类，因为我已经通过Ada、C、C++编程生涯，然后在过去的15年或更长时间里使用Java。我们不会再写另一本Ruby书；其他人已经在这方面做得非常出色，例如David
    A. Black和Joseph Leo III的《The Well-Grounded Rubyist》，第3版（Manning，2017）。我试图提供足够的细节，让您在没有先学习语言的情况下就能理解我们用Ruby和代码所做的工作。毕竟，我们的目标是帮助您理解Fluentd中发生的事情。在附录E中，我们包括了链接到资源，以帮助您学习Ruby的基础知识，并更好地理解使用的工具，或者如果您接受练习，您可能想要使用它们。
- en: 9.1 Plugin source code
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 插件源代码
- en: Code for the plugin developed here is included with the download of the book
    or retrievable from our GitHub repository ([http://mng.bz/M20W](http://mng.bz/M20W)).
    If you want to build upon what is provided, we encourage you to fork the GitHub
    repository and develop it as you wish; enhancement opportunities you might like
    to consider include
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这里开发的插件代码包含在本书的下载中，或可从我们的GitHub仓库中获取（[http://mng.bz/M20W](http://mng.bz/M20W)）。如果您想在此基础上进行开发，我们鼓励您fork
    GitHub仓库，并按您的意愿进行开发；您可能想要考虑的增强机会包括
- en: Moving to use the RedisTimeSeries feature (more on this in a moment)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转向使用RedisTimeSeries功能（稍后将有更多介绍）
- en: Developing support for Fluentd’s block size-based buffering
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发支持Fluentd基于块大小的缓冲
- en: Increasing security on the connection to Redis (e.g., using SSL/TLS connections
    and credentials, such as username and password)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强与Redis连接的安全性（例如，使用SSL/TLS连接和凭证，如用户名和密码）
- en: Whatever approach you take, all we ask is for you to acknowledge this book as
    the starting point in the code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您采取何种方法，我们唯一的要求是您承认这本书是代码的起点。
- en: 9.2 What is Redis, and why build a plugin with the Redis list capability?
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 什么是Redis，为什么需要使用具有Redis列表功能的插件？
- en: Redis is an open source, scalable, in-memory storage solution built around name-value
    pairs. The ability to define details such as time to live (TTL; this means that
    the time to hold the data is defined, after which it is automatically deleted)
    on data elements held, making for an exceptional caching tool. (In appendix E,
    we have provided plenty of supporting references for Redis in addition to those
    for Ruby.)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 是一个围绕名称-值对构建的开源、可扩展的内存存储解决方案。它能够定义数据元素上诸如生存时间（TTL；这意味着定义了保留数据的时间，之后它将自动删除）等详细信息，使其成为一款卓越的缓存工具。（在附录
    E 中，我们提供了关于 Redis 的许多支持性参考，除了 Ruby 的之外。）
- en: 'Aside from using Redis to help demonstrate plugin development, there are some
    potential real-world benefits of developing such a plugin:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用 Redis 来帮助展示插件开发之外，开发此类插件还有一些潜在的实际好处：
- en: Rather than using a small, embedded, in-memory cache, we can use a highly resilient
    open source option that can be far more effective in scaling and replicating the
    cached data across multiple servers (for more insight into the use of caches,
    check out [https://techterms.com/definition/cache](https://techterms.com/definition/cache)).
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用一个高度弹性的开源选项，而不是使用小型嵌入式内存缓存，这可以在扩展和跨多个服务器复制缓存数据方面更加有效（有关缓存使用的更多信息，请参阅 [https://techterms.com/definition/cache](https://techterms.com/definition/cache)）。
- en: It provides an additional option for enabling Fluentd nodes to collaborate efficiently.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为启用 Fluentd 节点高效协作提供了额外的选项。
- en: It creates integrations with Redis lists, such as the Ruby Resque (Ruby queuing
    implementation; [https://github.com/resque](https://github.com/resque)), providing
    opportunities to support or use additional services.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与 Redis 列表创建集成，例如 Ruby Resque（Ruby 队列实现；[https://github.com/resque](https://github.com/resque)），提供了支持或使用额外服务的机会。
- en: It provides a means to keep events held in order, as Redis lists support the
    first in, first out (FIFO) pattern; this allows us to keep log events in sequence
    (i.e., in time series).
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了一种保持事件顺序的方法，因为 Redis 列表支持先进先出（FIFO）模式；这允许我们按顺序（即按时间序列）保持日志事件。
- en: Caching solutions such as Redis operate by storing the data within memory data
    structures rather than long-term storage like a conventional database. The structures
    handle the data as key-value pairs. The internal structures can be very sophisticated
    to allow the cache to quickly locate the correct bit of memory. In addition to
    this, the data can be handled as a time series of events. The data held can also
    have a TTL before being automatically removed from the store.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如 Redis 这样的缓存解决方案通过在内存数据结构中存储数据而不是像传统数据库那样的长期存储来运行。这些结构将数据作为键值对处理。内部结构可以非常复杂，以便缓存能够快速定位正确的内存块。此外，数据还可以作为事件的时间序列来处理。存储的数据也可以在自动从存储中删除之前有一个
    TTL（生存时间）。
- en: 9.2.1 Redis list over RedisTimeSeries
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.1 Redis 列表与 RedisTimeSeries
- en: 'At the time of this writing, Redis Labs has developed the high-performance
    RedisTimeSeries, which handles data in a time-series format made of two 64-bit
    structures representing the time and a value (more at [https://oss.redislabs.com/redistimeseries](https://oss.redislabs.com/redistimeseries)).
    Using it presents some challenges:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Redis Labs 开发了高性能的 RedisTimeSeries，它以由两个 64 位结构组成的时间序列格式处理数据，分别代表时间和值（更多信息请参阅
    [https://oss.redislabs.com/redistimeseries](https://oss.redislabs.com/redistimeseries)）。使用它带来了一些挑战：
- en: There is no support for a Windows native option, and we want to keep things
    as simple as possible without needing to work through the different approaches
    to Linux virtualization.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有支持 Windows 原生选项，我们希望尽可能保持简单，无需通过不同的 Linux 虚拟化方法进行操作。
- en: The data structure used by RedisTimeSeries cannot hold the log events in 128
    bits, which means that to use this structure, the value part must act as a “foreign
    key” to another data structure. Taking the example solution to an enterprise-class
    capability may make this worthwhile, but it adds complexity related to Redis,
    not Fluentd, and therefore won’t be beneficial to this book.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RedisTimeSeries 使用的数据库结构无法在 128 位中存储日志事件，这意味着为了使用此结构，值部分必须充当另一个数据结构的“外键”。将示例解决方案扩展到企业级能力可能是有价值的，但这会增加与
    Redis 相关的复杂性，而不是 Fluentd 的，因此不会对本书有益。
- en: Given these points, we will stick with the vanilla Redis features.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些点，我们将坚持使用纯 Redis 功能。
- en: 9.3 Illustrating our objective using Redis CLI
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 使用 Redis CLI 展示我们的目标
- en: Before we start looking at any development activities, let’s simulate the behavior
    we want to achieve with the plugins. Simulating the behavior will make it easier
    to relate the development activities back to the solution. To do this, we first
    need to install Redis, using the details provided in appendix A. Once Redis is
    installed, we will use its command-line interface (CLI) to simulate the effect
    of the plugins we will build.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始查看任何开发活动之前，让我们模拟我们想要通过插件实现的行为。模拟行为将使我们将开发活动与解决方案联系起来变得更容易。为此，我们首先需要安装Redis，使用附录A中提供的信息。一旦Redis安装完成，我们将使用其命令行界面（CLI）来模拟我们将要构建的插件的效果。
- en: The Redis server needs to be started in its own shell. This can be done with
    the command
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Redis服务器需要在它自己的shell中启动。这可以通过以下命令完成
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once we see evidence of that process running (Redis reporting to the console),
    the next step is to start the Redis CLI with the command `redis-cli` in a new
    console window. We can recognize when the command has worked, as the command prompt
    will look like
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们看到该过程运行的证据（Redis向控制台报告），下一步就是在新的控制台窗口中使用命令`redis-cli`启动Redis CLI。我们可以通过命令提示符的变化来识别命令是否成功执行，命令提示符将看起来像
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can confirm that we have a proper Redis server connection by entering the
    command info. This will result in a lot of settings information, including the
    Redis version displayed in the console. With one `redis-cli` running, we need
    to repeat the process in a separate shell to simulate the effect of two different
    processes interacting with the cache. For the rest of this section, we will refer
    to these as CLI 1 and CLI 2\. As we go through the simulation, imagine CLI 1 is
    acting as a Fluentd output plugin and CLI 2 as a Fluentd input plugin. In CLI
    1, we want to run the following list push (`lpush`) commands:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过输入命令info来确认我们有一个合适的Redis服务器连接。这将导致显示大量的设置信息，包括在控制台中显示的Redis版本。当有一个`redis-cli`运行时，我们需要在另一个shell中重复此过程来模拟两个不同进程与缓存交互的效果。在本节的其余部分，我们将将其称为CLI
    1和CLI 2。随着我们进行模拟，想象CLI 1作为Fluentd输出插件，CLI 2作为Fluentd输入插件。在CLI 1中，我们想要运行以下列表推送（`lpush`）命令：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Each time the command is issued, you will get a response looking like (integer)
    1\. To start with, we will see this response changing as the list depth changes.
    We can use the list length (`llen`) command
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 每次发出命令时，你将得到一个看起来像（integer）1的响应。一开始，我们将看到这个响应随着列表深度的变化而变化。我们可以使用列表长度（`llen`）命令
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'to find out how many entries in the list exist. The reference to `fluentd`
    in these commands is the name of the list we are using. Notice how we need to
    use single quotes at the beginning and end of the record so that we can use double
    quotes in the JSON. Now, in CLI 2, issue the list pop (`lpop`) command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以找出列表中有多少条目。这些命令中对`fluentd`的引用是我们正在使用的列表的名称。注意我们如何在记录的开始和结束处使用单引号，这样我们就可以在JSON中使用双引号。现在，在CLI
    2中，发出列表弹出（`lpop`）命令：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As a result, you will see the first entry provided in CLI 1 displayed on the
    CLI 2 console. Repeat the command `lpop fluentd`, and the response will include
    the second record added. Add more entries on CLI 1 and continue popping on CLI
    2 until you see a nil response. This means the list has been emptied.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你将看到CLI 1中提供的第一个条目在CLI 2控制台上显示。重复命令`lpop fluentd`，响应将包括添加的第二个记录。在CLI 1上添加更多条目，并在CLI
    2上继续弹出，直到你看到nil响应。这意味着列表已被清空。
- en: CLI 1 is effectively our output plugin behavior in our simulation, and CLI 2
    is our source plugin behavior. This can help our Fluentd setup by smoothing out
    the spikes in the activity. Fluentd input and output nodes are transient in nature
    (as may be the case of a containerized environment). In that case, we have efficient
    in-memory storage of log events (holding events in memory will not suffer the
    same I/O performance impacts of storage to disk).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: CLI 1实际上是我们在模拟中的输出插件行为，CLI 2是我们的源插件行为。这可以帮助我们的Fluentd设置，通过平滑活动中的峰值。Fluentd输入和输出节点本质上是瞬时的（在容器化环境中可能也是如此）。在这种情况下，我们有高效的内存存储日志事件（在内存中保留事件不会遭受存储到磁盘的相同I/O性能影响）。
- en: 9.4 Preparing for development
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 开发准备
- en: Before we can start any development, some basic preparation is needed. You need
    to have
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始任何开发之前，需要进行一些基本的准备。你需要有
- en: Prepared an installation of Fluentd and Ruby, or continue using the existing
    installation that has been used with the previous chapters (if you would rather
    start fresh, then all the necessary steps are detailed in appendix A).
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备了Fluentd和Ruby的安装，或者继续使用与前面章节一起使用的现有安装（如果您想从头开始，所有必要的步骤都详细说明在附录A中）。
- en: Prepared a simple installation of Redis, if you have not already done this (details
    for this are in appendix A).
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，请准备一个简单的Redis安装（有关此信息的详细信息请参阅附录A）。
- en: Chosen an IDE (integrated development environment) that can support Ruby and
    installed the IDE and any relevant extensions needed (we will be using Visual
    Studio Code). As this tends to be a personal choice, we will leave the choice
    and installation up to you.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择了一个可以支持Ruby的IDE（集成开发环境），并安装了IDE和任何相关的扩展（我们将使用Visual Studio Code）。由于这通常是个人选择，我们将选择和安装的决定权留给你。
- en: Installed the Redis Gem to write Ruby code to talk with Redis (detailed in appendix
    A).
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了Redis Gem以用Ruby代码与Redis通信（详细信息请参阅附录A）。
- en: Established a folder for implementing our plugin; this may align with the folder
    structure created when you retrieved all the book’s support files.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为实现我们的插件建立了一个文件夹；这可能与你检索本书所有支持文件时创建的文件夹结构相一致。
- en: We do not want to accidentally pollute the use of Ruby and the catalog of gems
    with our development efforts. One way to achieve this is to allow our development
    code to be picked up by Fluentd when we start it rather than require it to be
    packaged as a gem and deployed to test code. There are also ways to comingle development
    code with the gems file system, which we would not recommend.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们不希望我们的开发工作无意中污染Ruby的使用和gem的目录。实现这一目标的一种方法是在启动时允许我们的开发代码被Fluentd获取，而不是要求它被打包成gem并部署到测试代码中。也有方法将开发代码与gem文件系统混合，但我们不推荐这样做。
- en: For the rest of this chapter, we will assume that path starts as `c:\myDev\GitHub|LoggingInAction\Chapter9`.
    Once these components are in place, then we are ready to start.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将假设路径以`c:\myDev\GitHub|LoggingInAction\Chapter9`开始。一旦这些组件就位，我们就可以开始工作了。
- en: 9.5 Plugin frameworks
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5 插件框架
- en: As you have seen throughout the book, Fluentd works with a strong foundation
    of plugins of different types—input, output, filter, parser, and formatter. Fluentd
    needs to impose some common mechanisms, including naming conventions and folder
    structure, to make plugins work and tell the core of Fluentd about the different
    plugins installed. To help with this, Fluentd includes some tools to help make
    sure plugin development complies with the required conventions. Plugins have a
    class hierarchy with classes to build upon for each plugin type. Figure 9.1 illustrates
    this class hierarchy.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在整本书中看到的，Fluentd与不同类型的插件（输入、输出、过滤器、解析器和格式化器）的强大基础一起工作。Fluentd需要强制实施一些通用机制，包括命名约定和文件夹结构，以便插件能够工作，并告诉Fluentd核心已安装的不同插件。为了帮助实现这一点，Fluentd包括一些工具来确保插件开发符合所需的约定。插件有一个类层次结构，每个插件类型都有一个可以构建的类。图9.1展示了这个类层次结构。
- en: '![](../Images/CH09_F01_Wilkins.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 Wilkins](../Images/CH09_F01_Wilkins.png)'
- en: Figure 9.1 The foundation classes on which we can build our plugin, all of which
    are located within the lib/fluent/plugin folder of the source tree
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 我们可以构建插件的基础类，所有这些类都位于源树的lib/fluent/plugin文件夹中
- en: 9.5.1 Creating the skeleton plugin
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.1 创建骨架插件
- en: 'Fluentd provides a tool for building the skeleton framework for our plugin.
    Before this is executed, you need to be in the correct location that you want
    to use for Fluentd development (e.g., the root folder for your own GitHub project),
    as it will use that folder as the starting point for all the artifacts. Once in
    the correct location, we can use the command `fluent-plugin-generate <plugin type>
    <plugin name>`. The plugin type represents the type of plugin (input, output,
    etc.) and the plugin’s name. We are going to start with the output plugin. In
    our case, this makes the complete call:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Fluentd提供了一个用于构建我们插件骨架框架的工具。在执行此操作之前，您需要位于您想要用于Fluentd开发的正确位置（例如，您自己的GitHub项目的根文件夹），因为它将使用该文件夹作为所有工件的开端。一旦到达正确的位置，我们就可以使用命令`fluent-plugin-generate
    <plugin type> <plugin name>`。插件类型表示插件类型（输入、输出等），以及插件名称。我们将从输出插件开始。在我们的情况下，这使完整的调用：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We have opted for the name `redislist`, as the plugin works specifically with
    Redis’s lists capability. As with most data stores, there is already a general-purpose
    Redis plugin in existence ([http://mng.bz/aDP7](http://mng.bz/aDP7)); you might
    want to build a plugin to monitor its health as well.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择了名称`redislist`，因为该插件专门与Redis的列表功能一起工作。与大多数数据存储一样，已经存在一个通用目的的Redis插件（[http://mng.bz/aDP7](http://mng.bz/aDP7)）；你可能还想构建一个插件来监控其健康状态。
- en: As a result of using the utility, we get a directory structure as illustrated
    in figure 9.2, which includes some skeleton configuration and code files. As we
    progress through this chapter, we will address each of the files.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该实用程序的结果，我们得到了如图9.2所示的目录结构，其中包含一些骨架配置和代码文件。随着我们进入本章，我们将逐一处理每个文件。
- en: '![](../Images/CH09_F02_Wilkins.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH09_F02_Wilkins.png)'
- en: Figure 9.2 The directory structure and files generated when we run the fluent-plugin-generate
    utility. Colors indicate what needs to be modified to complete a plugin, as shown
    in the key.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 当我们运行fluent-plugin-generate实用程序时生成的目录结构和文件。颜色表示需要修改以完成插件的内容，如键所示。
- en: The code we will develop for the plugin is shown in the `/lib/fluent/plugin`
    folder, as illustrated in figure 9.2, with the Ruby file based on the plugin name
    (e.g., `out_ redislist.rb`). The code we develop in the following few sections
    will go into this file.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在插件代码中展示的代码位于`/lib/fluent/plugin`文件夹中，如图9.2所示，Ruby文件基于插件名称（例如，`out_redislist.rb`）。我们将在接下来的几节中开发的代码将放入此文件。
- en: 9.5.2 Plugin life cycle
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.2 插件生命周期
- en: Plugins are taken through a life cycle, with each stage having a method that
    can be overridden if you need to implement the logic for that specific stage of
    a life cycle. As we will see during the development of our input and output plugins,
    we do not have to use every stage, but some are essential in nearly every case—for
    example, configure, start, and shut down. Each of these states also has a query
    function to determine whether that is the current state—for example, `after_shutdown?`
    Figure 9.3 illustrates the full life cycle that a plugin supports along with the
    goal of each stage.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 插件会经历一个生命周期，每个阶段都有一个方法，如果需要实现生命周期特定阶段逻辑，则可以覆盖该方法。正如我们在开发输入和输出插件时将看到的，我们不必使用每个阶段，但几乎所有情况下某些阶段是必不可少的——例如，配置、启动和关闭。每个状态还有一个查询函数，用于确定当前状态是否为该状态——例如，`after_shutdown?`
    图9.3展示了插件支持的完整生命周期以及每个阶段的目标。
- en: '![](../Images/CH09_F03_Wilkins.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH09_F03_Wilkins.png)'
- en: Figure 9.3 Plugins go through this life cycle with methods provided in the skeleton
    to be overloaded and implement specific logic needed at each life cycle stage.
    Not all states have to be overloaded.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 插件通过这个生命周期，使用骨架中提供的方法进行覆盖，并在每个生命周期阶段实现所需的特定逻辑。并非所有状态都需要覆盖。
- en: 9.6 Implementing the plugin core
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.6 实现插件核心
- en: We’ve generated the skeleton and taken a moment to look at the life cycle stages;
    now the plugin can inject any specific behavior required. We can now get down
    to writing the plugin code that processes the configuration and executes the handling
    of log events, and we’ll cover connecting and disconnecting with Redis.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经生成了骨架，并花了一点时间查看生命周期阶段；现在插件可以注入任何所需的具体行为。我们现在可以着手编写处理配置和执行日志事件处理的插件代码，我们还将涵盖与Redis的连接和断开连接。
- en: 9.6.1 How configuration attributes work
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.6.1 配置属性如何工作
- en: With the plugin structured, the first step is to define the configuration attributes
    the it will use. This is achieved by using the `config_param` object, which takes
    the values for
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 插件结构化后，第一步是定义它将使用的配置属性。这是通过使用`config_param`对象来实现的，它接受以下值：
- en: The attribute name as it would be used in the configuration file.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在配置文件中使用的属性名称。
- en: The attribute’s data type, which could be any of string, integer.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性的数据类型，可以是字符串、整数等。
- en: The default value, if one can be specified.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可以指定，则默认值。
- en: Whether the value should be kept secret when Fluentd performs a dry run or the
    startup output of its configuration. By default, this is false and therefore not
    needed. But to illustrate the behavior, we have included its use.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当Fluentd执行干运行或其配置的启动输出时，值是否应该保密。默认情况下，这是false，因此不需要。但为了说明行为，我们已包含其使用。
- en: The ability to define an alias for the attribute name. Aliasing can be helpful
    when a plugin changes over time.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义属性名称别名的功能。别名在插件随时间变化时可能很有帮助。
- en: We need to capture a port number, host address (a DNS name or IP), and the list’s
    name held by Redis. To do this, we need to define several configuration attributes
    to be specified in the configuration file. The code is a sequence of `desc` and
    `config_param` statements, with the `desc` providing the description of the following
    `config_param` appearing in the code. We know the data types and potential default
    values mean we should exploit the available attributes to simplify data validation.
    This will also make the user’s experience as simple as possible. As a result,
    we should end up with code as illustrated in the following listing.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要捕获端口号、主机地址（一个DNS名称或IP地址），以及Redis持有的列表名称。为此，我们需要在配置文件中定义几个配置属性。代码是一系列`desc`和`config_param`语句的序列，其中`desc`提供了代码中出现的后续`config_param`的描述。我们知道数据类型和潜在的默认值意味着我们应该利用可用的属性来简化数据验证。这将使用户体验尽可能简单。因此，我们最终应该得到如下所示的代码。
- en: Listing 9.1 Chapter9/fluent-plugin-out-redislist/lib/fluent/out_redislist.rb
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.1 第9章/fluent-plugin-out-redislist/lib/fluent/out_redislist.rb
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Providing the desc entry before each config_param means that tools can be
    used to generate the documentation for the plugin configuration, as well as provide
    documentation internally.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在每个config_param之前提供desc条目意味着可以使用工具生成插件配置的文档，并提供内部文档。
- en: ❷ This is an example of setting an integer configuration value and defaulting
    the value. We can also indicate to Fluentd when it generates the summary of the
    configuration at startup and outputs it; we can tell Fluentd with the secret parameter
    whether the value should be included. We have also told Fluentd that if it receives
    portNo as a configuration value, then use it as the port number source.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这是一个设置整型配置值并设置默认值的示例。我们还可以指示Fluentd在启动时生成配置摘要并输出它；我们可以通过秘密参数告诉Fluentd是否应包含该值。我们还告诉Fluentd，如果它接收到portNo作为配置值，则将其用作端口号源。
- en: ❸ As with the previous example, we are setting a default value. This time we
    are providing a string.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 与前面的示例一样，我们正在设置一个默认值。这次我们提供一个字符串。
- en: Once defined, we can refer to the values as class-level elements and use the
    Ruby `@` notation (e.g., `@port`) within the rest of the code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义，我们就可以将值作为类级别元素进行引用，并在代码的其余部分使用Ruby的`@`符号（例如，`@port`）。
- en: We should also hold the Redis connection as a class member, so we do not need
    to re-create the connection every time we interact with Redis. With the configuration
    details, we could also try to create the Redis connection now. Still, by the life
    cycle definitions, that would be incorrect, and if another plugin configuration
    failed, Fluentd might choose not to start our plugin. As a result, we would be
    consuming unnecessary resources, such as the network connection. But we need the
    Redis dependency incorporated into the code with `require "redis"` declaration
    at the top of the file.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该将Redis连接作为类成员持有，这样我们就不需要在每次与Redis交互时重新创建连接。有了配置细节，我们也可以尝试现在创建Redis连接。然而，根据生命周期定义，这样做是不正确的，如果另一个插件配置失败，Fluentd可能选择不启动我们的插件。因此，我们会消耗不必要的资源，例如网络连接。但是，我们需要通过在文件顶部使用`require
    "redis"`声明将Redis依赖项合并到代码中。
- en: Note When it comes to coding style, I create the steps needed in the plugin
    as small functions. This may appear inefficient, but the optimizers in compilers,
    interpreters, and language virtual machines can usually optimize out these overheads.
    This approach does make for easier testing, and each step is easier to examine
    in isolation.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在编码风格方面，我在插件中创建必要的步骤作为小函数。这可能会显得效率低下，但编译器、解释器和语言虚拟机中的优化器通常可以优化掉这些开销。这种方法确实使得测试更容易，并且可以单独检查每个步骤。
- en: The framework provides a `configure` function, as seen in the life cycle (see
    figure 9.3). This gives us the chance to implement any additional custom validation
    needed. We can also use this method to define our own class-level variables. To
    illustrate this capability, we will implement code to check if the network port
    defined is the default Redis port. If it isn’t the default port, log a warning
    message to remind developers that they need to ensure ports are deconflicted.
    This code is in the following listing, with both our check function and the implementation
    of the configure function, which uses any inherited behavior.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 框架提供了一个 `configure` 函数，如生命周期中所示（见图 9.3）。这给了我们实现任何额外自定义验证的机会。我们还可以使用此方法来定义我们自己的类级别变量。为了说明这种能力，我们将实现代码来检查定义的网络端口是否是默认的
    Redis 端口。如果不是默认端口，记录一条警告信息提醒开发者他们需要确保端口不会冲突。此代码如下所示，包括我们的检查函数和配置函数的实现，该函数使用了任何继承的行为。
- en: Listing 9.2 Chapter9/fluent-plugin-out-redislist/lib/fluent/out_redislist.rb
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.2 Chapter9/fluent-plugin-out-redislist/lib/fluent/out_redislist.rb
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Retrieves the configuration value from the list of configuration attributes
    using the defined name
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用定义的名称从配置属性列表中检索配置值
- en: ❷ We defined a constant in the class for the default port.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们在类中定义了一个用于默认端口的常量。
- en: ❸ This is the method that is invoked as part of the plugin life cycle and triggers
    our check_port method.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 这是作为插件生命周期的一部分被调用，并触发我们的 check_port 方法的方法。
- en: ❹ Makes sure any inherited logic is executed first
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 确保首先执行任何继承的逻辑
- en: ❺ Invokes our method, passing all the configuration data over
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 调用我们的方法，将所有配置数据传递过去
- en: 9.6.2 Starting up and shutting down
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.6.2 启动和关闭
- en: After the configuration, the most critical functions in the life cycle will
    be the start and shutdown functions for most plugins. These are the ideal moments
    to create or close connections, such as those to Redis. Since establishing connections
    to storage solutions is often relatively slow, we want to perform the task before
    actively communicating with the remote solution. Redis allows us to define time-outs
    on the connections and how many reconnection attempts we can have. We’ll set these
    up as configuration values, but for now, let’s hardwire them. If the connection
    fails to be established, we should make it easy to recognize during the plugin
    life cycle. We can do this by setting the connector to `nil` and logging the issue.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置之后，生命周期中最关键的功能将是大多数插件的启动和关闭函数。这些是创建或关闭连接的理想时刻，例如与 Redis 的连接。由于建立到存储解决方案的连接通常相对较慢，我们希望在积极与远程解决方案通信之前执行此任务。Redis
    允许我们定义连接的超时时间和我们可以尝试重新连接的次数。我们将把这些设置为配置值，但现在让我们将它们硬编码。如果连接建立失败，我们应该在插件生命周期中使其易于识别。我们可以通过将连接器设置为
    `nil` 并记录问题来实现这一点。
- en: We need to incorporate the start and shutdown functions shown in the following
    listing into our plugin and our supporting functions to ensure that the required
    behavior is achieved.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将以下列表中的启动和关闭函数整合到我们的插件和辅助函数中，以确保实现所需的行为。
- en: Listing 9.3 Chapter9/fluent-plugin-out-redislist/lib/fluent/plugin/out_redislist.rb
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.3 Chapter9/fluent-plugin-out-redislist/lib/fluent/plugin/out_redislist.rb
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Establishing the Redis connection, informing the connection parameters from
    values retrieved from the configuration properties and defined constants
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 建立Redis连接，从配置属性和定义的常量中检索连接参数
- en: ❷ Handles Redis connection errors separately from the general catchall, as we
    can guide the user more effectively for these kinds of issues
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将 Redis 连接错误单独处理，不同于一般的通用捕获，因为我们可以更有效地引导用户处理这类问题
- en: ❸ Establishes a connection to Redis as part of the startup once all the inherited
    activities are completed
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在所有继承的活动完成后，作为启动过程的一部分建立与 Redis 的连接
- en: ❹ Ensures any inherited tasks are completed
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 确保任何继承的任务都已完成
- en: ❺ If we still have a Redis connection, then start the disconnection process.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果我们仍然有 Redis 连接，那么开始断开连接的过程。
- en: 9.6.3 Getting the plugin to work with our Fluentd installation
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.6.3 使插件与我们的Fluentd安装一起工作
- en: With enough code to prove we can get our plugin to at least start and stop,
    we can run a simple test with the full Fluentd. The Fluentd tooling includes extensions
    to help with unit testing, but it is always rewarding to see code firing up as
    part of something bigger, particularly when the startup is quick. To do this,
    we need to ensure Fluentd can pick up our plugin code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有足够的代码来证明我们可以让我们的插件至少启动和停止，我们就可以运行一个简单的测试，使用完整的Fluentd。Fluentd工具包括扩展，可以帮助进行单元测试，但看到代码作为更大系统的一部分运行总是令人欣慰的，尤其是当启动速度快的时候。为了做到这一点，我们需要确保Fluentd能够识别我们的插件代码。
- en: We need a test configuration to be able to run Fluentd. We have prepared one
    for this job, and it can be retrieved from `Chapter9/Fluentd/dummy-plugin.conf`.
    Of course, you might like to choose to develop your own configuration, given everything
    you’ve learned in the book.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个测试配置来运行Fluentd。我们已经为这项工作准备了一个，可以从`Chapter9/Fluentd/dummy-plugin.conf`获取。当然，你可能希望根据你在书中所学的一切选择开发自己的配置。
- en: We have repeated using the dummy source Fluentd plugin to generate log events,
    as the content is not essential. The crucial element is the match configuration,
    as illustrated in the following listing.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经重复使用模拟源Fluentd插件来生成日志事件，因为内容并不重要。关键元素是匹配配置，如下面的列表所示。
- en: Listing 9.4 Chapter9/Fluentd/dummy_plugin.conf
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.4 Chapter9/Fluentd/dummy_plugin.conf
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ This is the declaration to use our plugin.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这是使用我们的插件的声明。
- en: ❷ As we build upon the base class provided, the in-memory helper plugin is available
    if the use of the buffer attribute is defined. For now, we have the buffer configuration
    commented out.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 由于我们基于基类进行构建，如果定义了使用缓冲区属性，则内存辅助插件可用。目前，我们已将缓冲区配置注释掉。
- en: Before starting Fluentd, we need to start the Redis server as we did earlier
    in the chapter. Eventually, we will want to package and deploy our plugin just
    like any other Fluentd plugin using the gem tools. But to start with, we do not
    want to go through the additional effort of deploying and undeploying a gem every
    time we make a change. To avoid the gem deployment issue, we can add parameters
    to the command line telling Fluentd to pick up the source code of our plugin from
    a Ruby file. For example, my copy of the plugin directory structure starts at
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动Fluentd之前，我们需要像本章前面所做的那样启动Redis服务器。最终，我们希望像其他任何Fluentd插件一样使用gem工具打包和部署我们的插件。但一开始，我们不希望每次我们做出更改时都额外努力部署和卸载gem。为了避免gem部署问题，我们可以在命令行中添加参数，告诉Fluentd从Ruby文件中获取我们插件的源代码。例如，我的插件目录结构从以下位置开始：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then the extended Fluentd command will look as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，扩展的Fluentd命令将如下所示：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Going forward, we will show the path as `<plugin absolute path>\Chapter9\ fluent-plugin-out-redislist\lib\fluent\plugin`,
    where you need to substitute `<plugin absolute path>` accordingly.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 今后，我们将显示路径为`<plugin absolute path>\Chapter9\ fluent-plugin-out-redislist\lib\fluent\plugin`，其中你需要相应地替换`<plugin
    absolute path>`。
- en: Combining the configuration file and extending the path to collect our plugin
    mean our command to start Fluentd will result in Fluentd displaying the configuration
    as it starts up. With the Redis server running at the command line, it will be
    possible to see Redis logging the number of connections it has as we start and
    stop Fluentd.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 将配置文件和扩展路径以收集我们的插件结合起来，意味着我们启动Fluentd的命令将导致Fluentd在启动时显示配置。当Redis服务器在命令行上运行时，我们将能够看到Redis在启动和停止Fluentd时记录其连接数。
- en: 9.6.4 Putting additional configuration validation into action
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.6.4 将额外的配置验证付诸实践
- en: Your objective is to restart the Redis server on a different port and create
    an alternative Fluentd configuration to connect to Redis on a different port.
    You need to confirm that our configuration check is performing correctly. To restart
    Redis on a different port, add `--port nnnn`, where `nnnn` represents the port
    number to use with the startup command.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你的目标是重启Redis服务器到不同的端口，并创建一个替代的Fluentd配置来连接到不同端口的Redis。你需要确认我们的配置检查是否正确执行。要重启Redis到不同的端口，请添加`--port
    nnnn`，其中`nnnn`代表启动命令中使用的端口号。
- en: Answer
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 答案
- en: The modified configuration file solution can be found at `Chapter9\ExerciseResults\dummy-plugin-Answer.conf`,
    where we have changed the port from `6379` to `16379`. We also modified the log
    message generated by the dummy output plugin, although we will not see that yet.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的配置文件解决方案可以在`Chapter9\ExerciseResults\dummy-plugin-Answer.conf`中找到，我们将端口从`6379`更改为`16379`。我们还修改了模拟输出插件生成的日志消息，尽管我们目前还看不到。
- en: When the Redis server is started, we need to add `--port 16379` to override
    the default. Our Fluentd startup command now becomes
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当Redis服务器启动时，我们需要添加`--port 16379`来覆盖默认值。我们的Fluentd启动命令现在变为
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When Fluentd starts up, we should see the warning in the log output from Fluentd
    about using a nonstandard port. But the Redis server should report the connection.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当Fluentd启动时，我们应该在Fluentd的日志输出中看到关于使用非标准端口的警告。但Redis服务器应该报告连接。
- en: 9.6.5 Implementing the Redis output logic
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.6.5 实现Redis输出逻辑
- en: 'Having proven we can configure, start up, and shut down the plugin, we can
    move to the next step of implementing the logic of sending the events to Redis.
    There are several ways the logic can be executed:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在证明我们可以配置、启动和关闭插件之后，我们可以进入实现将事件发送到Redis的逻辑的下一步。逻辑可以以几种方式执行：
- en: '*Synchronous*—Process each event by implementing the method `def process (tag,
    es)`. This is the most straightforward approach and the least performant for execution,
    as it does not use any buffering.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*同步*—通过实现`def process (tag, es)`方法处理每个事件。这是最直接的方法，但执行效率最低，因为它没有使用任何缓冲。'
- en: '*Synchronous buffered*—Output is implemented by the method `def write (chunk)`.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*同步缓冲*—输出通过`def write (chunk)`方法实现。'
- en: '*Asynchronous buffered*—Output is implemented by the method `def try_write
    (chunk)`.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*异步缓冲*—输出通过`def try_write (chunk)`方法实现。'
- en: Which implementation method is used is dictated by whether the configuration
    includes a `<buffer>` section or not, unless we configure some override to the
    standard behavior. For the first implementation, we will keep it nice and straightforward
    with the synchronous model.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的实现方法取决于配置是否包含`<buffer>`部分，除非我们配置了一些覆盖标准行为。对于第一个实现，我们将保持同步模型简单直接。
- en: 'Our implementation process needs to tag the event stream passed as `(es)` and
    iterate through the events. As the stream could contain multiple events, we can
    make the process a little more efficient by telling Redis to batch up executing
    the insertion of the events. This is done by telling Redis it will receive multiple
    transaction calls using the command `redis.multi`. Once we have iterated through
    the events, tell Redis it can execute the transactions using the call `redis.exec`.
    As we iterate through the log events, we need to perform the following actions:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现过程需要标记传递给`(es)`的事件流，并遍历事件。由于流可能包含多个事件，我们可以通过告诉Redis批量执行事件的插入来使这个过程更高效。这是通过使用`redis.multi`命令告诉Redis它将接收多个事务调用来完成的。一旦我们遍历了事件，我们就可以通过调用`redis.exec`告诉Redis它可以执行事务。当我们遍历日志事件时，我们需要执行以下操作：
- en: Build a JSON representation of the log event(s). If you have reviewed the output
    interface, you will note that there is a predefined formatter function. We have
    chosen not to override or use this, as we do not want to impact other applications
    of this method within the plugin’s base classes; we can therefore format the presentation
    in any desired manner—for example, using msgpack.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建日志事件（的）JSON表示。如果您已经审查了输出接口，您会注意到有一个预定义的格式化函数。我们选择不覆盖或使用它，因为我们不希望影响插件基类中此方法的其它应用；因此，我们可以以任何期望的方式格式化表示，例如使用msgpack。
- en: Perform a Redis list push function.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行Redis列表推送功能。
- en: We should be defensive in our code to handle the scenario of losing the Redis
    connection before all the events have been committed to Redis.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在代码中采取防御性措施来处理在所有事件都提交到Redis之前丢失Redis连接的场景。
- en: We need to transform the log event to JSON for potentially three different functions;
    we should write the logic once and invoke it from the different plugin methods
    involved. The result of this is two methods, as shown in the following listing.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将日志事件转换为JSON，可能用于三个不同的功能；我们应该只编写一次逻辑，并从涉及的不同插件方法中调用它。结果是以下列表中的两个方法。
- en: Listing 9.5 Chapter9/fluent-plugin-out-redislist/lib/fluent/pluginout_redislist.rb
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.5 第9章/fluent-plugin-out-redislist/lib/fluent/pluginout_redislist.rb
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ This is our function that translates the log event into a JSON representation.
    We need to build our own JSON representation, as we need to capture all the log
    event attributes.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这是一个将日志事件转换为JSON表示的函数。我们需要构建自己的JSON表示，因为我们需要捕获所有日志事件属性。
- en: ❷ By using predefined constants, these could be shared with the input plugin.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 通过使用预定义的常量，这些可以与输入插件共享。
- en: ❸ As the record, event time, and tag represent a flat structure, we can build
    a simple hash structure and then exploit the prebuilt operations to convert it
    to JSON. Note we don’t use the formatter method, as this is used by other parts
    of Fluentd, such as the buffer, and we don’t wish to confuse that logic with a
    variant representation.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 由于记录、事件时间和标签代表一个平面结构，我们可以构建一个简单的哈希结构，然后利用预构建的操作将其转换为JSON。请注意，我们不使用格式化方法，因为这在Fluentd的其他部分中使用，例如缓冲区，我们不希望用这种变体表示混淆逻辑。
- en: ❹ This is one of the standard functions used by an output plugin.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 这是由输出插件使用的一个标准功能之一。
- en: ❺ This tells Redis to accept multiple statements that should be executed in
    a single operation.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 这告诉Redis接受多个应该在一个操作中执行的状态语句。
- en: ❻ This releases the Redis library to send all the statements to the Redis server
    as a single block.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 这将释放Redis库将所有语句作为一个单独的块发送到Redis服务器。
- en: 9.6.6 Putting the testing of synchronous output into action
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.6.6 将同步输出测试付诸实践
- en: We have reached a state where we can confirm that we can write to Redis. Using
    the previously illustrated approach, restart Fluentd and use the illustrated Redis
    commands to review the list in Redis and pop entries in the list.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经达到了可以确认我们可以写入Redis的状态。使用之前展示的方法，重新启动Fluentd并使用展示的Redis命令来检查Redis中的列表并弹出列表中的条目。
- en: Answer
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 答案
- en: 'In repeating the Fluentd test, with the write method now in place, you should
    expect the Redis commands to show the list structure to grow with JSON content,
    looking something like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在重复Fluentd测试时，现在写入方法已经就位，你应该期望Redis命令显示列表结构随着JSON内容增长，看起来像这样：
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The log events as they are generated will increment the counter value due to
    the source configuration. This will mean there should be a correlation between
    the counter attribute values and the Redis list length. This can be confirmed
    with the `llen` command in the Redis CLI. You will also be able to pop the entries
    from the list using the command `lpop fluentd`, as the configuration will allow
    the default list name to be used.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于日志事件是按生成顺序增加计数器值的，这意味着计数器属性值和Redis列表长度之间应该存在关联。这可以通过Redis CLI中的`llen`命令来确认。你还可以使用`lpop
    fluentd`命令从列表中弹出条目，因为配置允许使用默认的列表名称。
- en: 9.7 Implementing the Redis input plugin
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.7 实现Redis输入插件
- en: Before implementing one of the other write methods, let’s complete the circuit
    with the input plugin. We can use the same utilities that generated the output
    plugin to generate the skeleton folders and files for the input side. Everything
    is the same as before rerunning the utility, except that we specify the plugin
    as input, not output. This will result in the generated code extending a different
    base class (as we saw in figure 9.2); thus, we need to implement some different
    functions.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现其他写入方法之前，让我们先完成输入插件的部分电路。我们可以使用生成输出插件的相同工具来生成输入侧的骨架文件夹和文件。一切与之前重新运行工具时相同，只是我们指定插件为输入，而不是输出。这将导致生成的代码扩展不同的基类（如图9.2所示）；因此，我们需要实现一些不同的函数。
- en: For Redis, the input plugin is effectively a polling activity, as most solutions
    don’t support callbacks or webhooks (it is worth noting that Redis does have a
    webhook concept). This means we will need a configuration value as to how quickly
    the plugin needs to poll Redis. As with the output plugin, we will need the information
    necessary to connect to Redis. For this latter task, we can copy the code written
    for the output plugin. While this does not support the excellent coding principles
    of DRY (don’t repeat yourself), there are plenty of opportunities to improve our
    code later.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Redis来说，输入插件实际上是一种轮询活动，因为大多数解决方案都不支持回调或webhooks（值得注意的是，Redis确实有webhook的概念）。这意味着我们需要一个配置值来指定插件需要多快轮询Redis。与输出插件一样，我们需要连接到Redis所需的信息。对于这个后者的任务，我们可以复制为输出插件编写的代码。虽然这并不支持DRY（不要重复自己）的优秀编码原则，但以后有很多机会改进我们的代码。
- en: Although we have some additional values to consider, the input plugin processes
    the configuration attributes just as the output plugin does. The two key functions
    that need to be implemented on the input plugin are to handle the `run` command
    and the `emit` function (as shown in listing 9.6). The run method will be responsible
    for starting our scheduling thread. The emit function handles calling Redis and
    emitting the log events to the next process in Fluentd defined by the configuration
    file.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们有一些额外的值需要考虑，但输入插件处理配置属性的方式与输出插件相同。在输入插件上需要实现的两个关键功能是处理`run`命令和`emit`函数（如列表
    9.6 所示）。`run`方法将负责启动我们的调度线程。`emit`函数处理调用Redis并将日志事件输出到Fluentd配置文件定义的下一个流程。
- en: As a source plugin, the framework will set the tag and timestamp values on the
    event to reflect the current time and the tag default behavior. Do these values
    make sense, as they do not truly reflect when the original event occurred? To
    address this, we are providing the means to determine whether the original tag
    and time are added to the event record or should be used in the core log event.
    It is probably best if we allow the person configuring the plugin to determine
    what should be replaced. If the values should be inserted into the log event,
    we must determine what attribute names to use. We can address this using the same
    mechanism for capturing plugin configuration attributes already used.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 作为源插件，框架将在事件上设置标签和时间戳值，以反映当前时间和标签默认行为。这些值有意义吗？因为它们并不真正反映原始事件发生的时间。为了解决这个问题，我们提供了确定原始标签和时间是否添加到事件记录或应在核心日志事件中使用的手段。最好允许配置插件的人决定应该替换什么。如果这些值应该插入到日志事件中，我们必须确定要使用的属性名称。我们可以使用捕获插件配置属性已使用的相同机制来解决这个问题。
- en: Listing 9.6 Chapter9/fluent-plugin-redislist/lib/fluent/plugin/in_redislist.rb
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.6 第9章/fluent-plugin-redislist/lib/fluent/plugin/in_redislist.rb
- en: '[PRE15]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Determines whether a new connection is required
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 确定是否需要新的连接
- en: ❷ Sets the loop controller up so we keep calling Fluentd until a shutdown process
    changes the status of this flag
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 设置循环控制器，以便我们持续调用Fluentd，直到关闭流程改变此标志的状态
- en: ❸ Redis allows us to treat a list as first in, first out (FIFO) or last in,
    first out (LIFO). So we can use this configuration to control whether we want
    to operate the list in a FIFO or LIFO manner.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ Redis允许我们将列表视为先进先出（FIFO）或后进先出（LIFO）。因此，我们可以使用此配置来控制我们是否希望以FIFO或LIFO方式操作列表。
- en: ❹ Determine whether the tag and date-time values should replace the new log
    event or simply be incorporated in their log event record.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 确定标签和日期时间值是否应该替换新的日志事件，或者只是简单地纳入其日志事件记录中。
- en: ❺ This is when we tell Fluentd to pass the log event onto the next step of the
    process based on the configuration definition.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 这时，我们告诉Fluentd根据配置定义将日志事件传递到处理流程的下一步。
- en: ❻ The thread handling for the run method, and for as long as the thread is allowed
    to run
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 运行方法的线程处理，以及线程允许运行的时间
- en: ❼ Once we’ve decided the thread has legitimately been woken since the last cycle,
    we can use emit to send all the log events.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 一旦我们决定线程自上次循环以来确实被唤醒，我们就可以使用`emit`发送所有日志事件。
- en: 9.7.1 Testing input and output plugin execution
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7.1 测试输入和输出插件执行
- en: 'With our input plugin implemented, we can perform a simple test. We could easily
    incorporate both the input and output plugins into our single configuration (see
    `Chapter9/fluentd/dummy-plugin.conf`); the problem would be that the log information
    for input and output would intermingle. We would need to extend the plugin path
    parameter to include both plugins, like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现我们的输入插件后，我们可以进行简单的测试。我们可以轻松地将输入和输出插件合并到单个配置中（参见`Chapter9/fluentd/dummy-plugin.conf`）；问题在于输入和输出的日志信息会混合。我们需要扩展插件路径参数以包括这两个插件，如下所示：
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Alternatively, we can start two instances of Fluentd with each using their
    own configuration, so each process has one input. This will make seeing what is
    happening a lot easier. To do this, repeat the steps previously used to see the
    output plugin at work. Then, in another console window, we can adapt the command
    to reference our input plugin path and the `Chapter9\Fluentd\dummy-plugin-in.conf`
    that we have prepared already. The result should look like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以启动两个 Fluentd 实例，每个实例使用自己的配置，这样每个进程就有一个输入。这将使观察发生的事情变得容易得多。为此，重复之前用于查看输出插件工作的步骤。然后，在另一个控制台窗口中，我们可以调整命令以引用我们的输入插件路径和已经准备好的
    `Chapter9\Fluentd\dummy-plugin-in.conf`。结果应该看起来像这样：
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With everything running, you should see in one console messages showing the
    log events being added. Another shows them being removed and the Redis console
    displaying the two interactions of adding and removing from the list.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当一切运行正常时，你应该在一个控制台中看到显示正在添加的日志事件的日志消息。另一个控制台显示它们正在被移除，Redis 控制台则显示了添加和从列表中移除的两个交互。
- en: With the ability to write and consume log events with a Redis list now in place,
    let us go back to the write logic and extend the implementation with alternate
    ways of the output logic working, such as by using the buffer.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有了使用 Redis 列表写入和消费日志事件的能力，让我们回到写入逻辑，并通过使用缓冲等不同的输出逻辑工作方式扩展实现。
- en: 9.8 Extending output with buffering
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.8 使用缓冲扩展输出
- en: As we saw in chapter 4, if the plugin supports a buffer, the I/O process can
    be optimized. We have already done some performance optimization by configuring
    the synchronous process to bunch the Redis push operations together, so the Redis
    connector executes them all at once if we receive more than one log event. But
    we can further accelerate the process by using the buffer to process larger groups
    into a single transaction in Redis.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第 4 章中看到的，如果插件支持缓冲，I/O 过程可以被优化。我们已经通过配置同步过程将 Redis 推送操作组合在一起进行了一些性能优化，因此如果收到多个日志事件，Redis
    连接器会一次性执行它们。但我们可以通过使用缓冲将更大的组处理成一个单独的 Redis 事务来进一步加速这个过程。
- en: As we saw in chapter 4, out of the box, there are two types of buffers for Fluentd
    using either a temporary file or memory. Supporting a file implementation does
    not make sense when our target is an in-memory solution that provides better performance
    than using physical storage such as disks. This means our solution should only
    allow the use of the memory buffer.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第 4 章中看到的，对于 Fluentd 来说，默认情况下有两种类型的缓冲，可以使用临时文件或内存。当我们的目标是提供比使用物理存储（如磁盘）更好的性能的内存解决方案时，支持文件实现是没有意义的。这意味着我们的解决方案应该只允许使用内存缓冲。
- en: In figure 9.4, we can see how the log event passes through the different paths
    of the base Fluentd output class and the functions that need to be implemented,
    depending on whether buffering is used and whether buffering is synchronous or
    asynchronous in nature.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 9.4 中，我们可以看到日志事件如何通过基础 Fluentd 输出类的不同路径以及需要实现的功能，这取决于是否使用缓冲以及缓冲是同步的还是异步的。
- en: '![](../Images/CH09_F04_Wilkins.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4](../Images/CH09_F04_Wilkins.png)'
- en: Figure 9.4 The different methods involved in outputting log events from an output
    plugin depending on the use and type of buffering
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 根据缓冲的使用和类型，从输出插件输出日志事件的不同方法
- en: As shown in figure 9.4, to keep things simple, we will implement the synchronous
    buffered path to start with once we have plugins for input and output; then we
    will revisit to extend the plugin for the buffered use case.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 9.4 所示，为了保持简单，一旦我们有了输入和输出插件，我们将首先实现同步缓冲路径；然后我们将重新访问以扩展插件的缓冲使用案例。
- en: 'The asynchronous path is largely the same as the synchronous path regarding
    how we interact with Fluentd. But we have to manage the additional logic that
    makes the behavior asynchronous and uses the buffer chunk data structures. With
    the buffering, we could offer either or both approaches to handling the buffer
    chunks. The options include the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 异步路径在如何与 Fluentd 交互方面与同步路径大致相同。但我们必须管理额外的逻辑，这些逻辑使得行为异步并使用缓冲块数据结构。有了缓冲，我们可以提供处理缓冲块的方法，包括以下选项：
- en: '*Each chunk is controlled by the number of log events it can contain.* This
    is a simple mechanism and very efficient and predictable when log events are consistent
    in size. But if log events are variable in size, you can exhaust the available
    memory before filling a chunk.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*每个数据块通过它可以包含的日志事件数量来控制。* 这是一个简单的机制，当日志事件大小一致时，非常高效且可预测。但如果日志事件大小可变，在填满数据块之前，您可能会耗尽可用内存。'
- en: '*Each chunk is controlled by allocating the same amount of memory.* With the
    size model, we have the responsibility to implement the logic around calculating
    the size of the log event, determining if the log event can fit into the current
    chunk or needs to be put into another chunk. Also, we must decide what to do if
    the log event is larger than the chunk size limit.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*每个数据块通过分配相同数量的内存来控制。* 在大小模型中，我们有责任实现围绕计算日志事件大小的逻辑，确定日志事件是否可以放入当前数据块或需要放入另一个数据块。此外，我们必须决定如果日志事件的大小超过数据块大小限制时应该做什么。'
- en: The benefit of this model is that if log events are variable in size, we don’t
    risk memory exhaustion scenarios, as we’ve capped the number of resources that
    will be used. The additional code complexity here is not about how Fluentd plugins
    are written and more about understanding Ruby and how it works with data structures.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种模型的好处是，如果日志事件的大小是可变的，我们不会面临内存耗尽的情况，因为我们已经限制了将要使用的资源数量。这里的额外代码复杂性并不在于 Fluentd
    插件的编写方式，而更多在于理解 Ruby 以及它是如何与数据结构协同工作的。
- en: 'In the spirit of “keep it simple stupid” (KISS) and focusing on Fluentd, we
    will illustrate the number of log events per chunk model. The responsibility of
    understanding the log events and avoiding the risk of memory exhaustion is on
    the user. With our approach worked out, we should make it easy for the user by
    defaulting some of the buffer settings as we would like to have them. As a result,
    we can incorporate with the configurations the following code fragment:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在“保持简单愚蠢”（KISS）的精神和专注于 Fluentd 的基础上，我们将说明每个数据块中日志事件的数目模型。理解日志事件并避免内存耗尽风险的责任在于用户。通过我们的方法，我们应该默认一些缓冲设置，以便用户使用起来更加方便。因此，我们可以将以下代码片段纳入配置中：
- en: '[PRE18]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, we have defined a chunk size configuration attribute, which
    has itself defaulted. As a result, we will default to the buffering approach without
    any configuration values unless explicitly overridden. We should also extend the
    `configure` function to consider the possibility of being supplied with configuration
    values that we do not recommend or are not supporting, as they are intended for
    the chunk size model of buffering.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们定义了一个数据块大小配置属性，它本身已经默认设置。因此，除非明确覆盖，否则我们将默认使用缓冲方法而不需要任何配置值。我们还应该扩展 `configure`
    函数，以考虑提供我们不推荐或不支持配置值的可能性，因为它们是为缓冲的数据块大小模型设计的。
- en: The next step is implementing the write function, which takes a buffer chunk
    once complete and passes the chunk building up the Redis push calls. We can leverage
    the previous logic to generate the representation we want to use in Redis. Just
    as with the synchronous bufferless path, we want to brace the looping through
    the chunk with the instruction to the Redis connector to batch up all the Redis
    commands to execute in one go using the `redis.multi` and `redis.exec` functions.
    The new write method is shown in the following listing.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是实现写入函数，它接受一个完整的缓冲数据块，并将构建 Redis 推送调用的数据块传递出去。我们可以利用之前的逻辑来生成我们希望在 Redis 中使用的表示。就像在同步无缓冲路径中一样，我们希望用
    Redis 连接器的指令来包围数据块循环，以便一次性使用 `redis.multi` 和 `redis.exec` 函数执行所有 Redis 命令。新的写入方法如下所示。
- en: Listing 9.7 Chapter9/fluent-plugin-out-redislist/lib/fluent/out_redislist.rb
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.7 第 9 章/fluent-plugin-out-redislist/lib/fluent/out_redislist.rb
- en: '[PRE19]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ The function is called from the base class logic. We have implemented our
    own version. Unlike functions like configure, calling super would trigger a not-implemented
    exception.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 函数是从基类逻辑中调用的。我们已经实现了自己的版本。与 configure 等函数不同，调用 super 会触发未实现异常。
- en: ❷ Instructs the Redis connector to group all the Redis statements that follow
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 指示 Redis 连接器将随后的所有 Redis 语句分组
- en: ❸ The chunk has a different structure to the stream structure provided in the
    unbatched path, so we need a different loop. This will iterate over each chunk
    entry
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 数据块的结构与未分批路径中提供的流结构不同，因此我们需要不同的循环。这将遍历每个数据块条目
- en: ❹ As before, we need to take the log event, time, and tag to build a representation
    to be used in Redis.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如前所述，我们需要获取日志事件、时间和标签来构建用于Redis的表示。
- en: ❺ Handles Redis connection errors separately from the general catchall, as we
    can guide the user more effectively for these kinds of issues
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将Redis连接错误与一般的捕获所有错误分开处理，因为我们可以更有效地引导用户解决这类问题
- en: 'We can rerun our test with a slightly different configuration to ensure we
    use the buffering behavior with this method introduced. This can be done with
    the following command:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用略微不同的配置重新运行我们的测试，以确保我们使用这种方法引入的缓冲行为。这可以通过以下命令完成：
- en: '[PRE20]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With the test configuration provided, we should see the write method trace statements
    occurring periodically. The internal tracing writes log events to `stdout` in
    short bursts as the write function logs the details as it calls the Redis connector.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用提供的测试配置，我们应该看到写入方法跟踪语句定期发生。内部跟踪以短促的爆发将日志事件写入`stdout`，因为写入函数在调用Redis连接器时记录详细信息。
- en: 9.8.1 Improving our scenario by putting maintainability into action
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.8.1 通过实施可维护性来改进我们的场景
- en: Our proof-of-concept level implementation of the Redis list plugin has shown
    how we can deliver a new plugin. In the process of development, there is some
    commonality between the input and output code. As a result, we have received the
    go-ahead to make some improvements. Therefore, the first goal is to refactor the
    input and output to use a common base class.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对Redis列表插件的初步实现展示了我们如何交付一个新的插件。在开发过程中，输入和输出代码之间存在一些共性。因此，我们得到了改进的批准。因此，第一个目标是重构输入和输出以使用一个共同的基类。
- en: 9.9 Unit testing
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.9 单元测试
- en: The testing we have done so far is a manual process that we all know is not
    the best. In the real world, we would lead with unit testing and build up from
    there. Ideally, changes in the code should trigger a continuous integration and
    continuous delivery process, automatically running the unit tests and end-to-end
    testing.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止所进行的测试是一个手动过程，我们都知道这不是最好的。在现实世界中，我们会从单元测试开始，并在此基础上构建。理想情况下，代码的更改应触发持续集成和持续交付过程，自动运行单元测试和端到端测试。
- en: We will not go into depth here, as unit testing is primarily an aspect of Ruby
    development, rather than Fluentd. The Fluentd team has built some support libraries
    that can be used with any major unit test frameworks, including *test-unit* ([https://test
    -unit.github.io/](https://test-unit.github.io/)), *RSpec* ([https://rspec.info/](https://rspec.info/)),
    and *minitest*. Our example utilizes test-unit, as it is a well-adopted framework
    and feels like many other major unit test frameworks, such as *NUnit*, *JUnit*,
    and so on.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会深入探讨，因为单元测试主要是Ruby开发的一个方面，而不是Fluentd。Fluentd团队构建了一些支持库，可以与任何主要的单元测试框架一起使用，包括
    *test-unit* ([https://test-unit.github.io/](https://test-unit.github.io/))、*RSpec*
    ([https://rspec.info/](https://rspec.info/)) 和 *minitest*。我们的示例使用test-unit，因为它是一个广泛采用的框架，感觉像许多其他主要的单元测试框架，如
    *NUnit*、*JUnit* 等等。
- en: When we used the utility for generating the plugin skeleton and generated the
    main Ruby code, the tool also generated a folder structure test in the base plugin
    folder. This includes providing a skeleton class to help us get started. The test
    class has the same name as the plugin but with a prefix of `test_`. This is a
    small piece of helper code (`helper.rb`) in the base of the test path. This loads
    the framework’s helper code into the test-unit tool.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用生成插件骨架的实用程序并生成主Ruby代码时，该工具还在基本插件文件夹中生成了一个测试文件夹结构。这包括提供一个骨架类来帮助我们开始。测试类与插件同名，但前面有一个`test_`前缀。这是测试路径基础目录中的一小段辅助代码（`helper.rb`），它将框架的辅助代码加载到测试单元工具中。
- en: To illustrate the possibilities, we have built a couple of tests for the output
    plugin, as illustrated in listing 9.8\. These tests focus on validating the configuration-related
    logic that drives the behavior of our plugins. This is achieved using part of
    the Fluentd test framework that implements different types of drivers. The type
    of driver needed is dictated by the plugin type and mimics the core of Fluentd.
    We can trigger the necessary operations using the driver, including feeding in
    log events to the plugin. The driver also provides the means to retrieve and evaluate
    the results, such as how many times events have been through specific stages (e.g.,
    emit, write). The evaluation can be done using the driver to access and examine
    the processed events, such as the output of the synchronous and asynchronous write
    operations, and to simply know how many events have been handled.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明可能性，我们为输出插件构建了一些测试，如列表9.8所示。这些测试侧重于验证驱动我们插件行为的配置相关逻辑。这是通过Fluentd测试框架的一部分实现的，该框架实现了不同类型的驱动程序。所需的驱动程序类型由插件类型决定，并模仿Fluentd的核心。我们可以使用驱动程序触发必要的操作，包括向插件提供日志事件。驱动程序还提供了检索和评估结果的方法，例如事件通过特定阶段（例如，emit、write）的次数。评估可以通过驱动程序访问和检查处理的事件来完成，例如同步和异步写入操作的输出，以及简单地知道处理了多少事件。
- en: The driver capability can be extended to handle the impact of scheduled activities,
    such as events accumulating in a buffer. The test utilities can also capture standard
    out and process the text. Capturing such output allows you to verify that the
    processing of log events is being generated as expected. In our test for advanced
    config, we apply this technique. If log events are not going to `stdout`, but
    to a log file for Fluentd, it can also be interrogated, looking for how much log
    information is generated and whether specific log events have occurred.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动能力可以扩展以处理计划活动的影响，例如事件在缓冲区中积累。测试实用程序也可以捕获标准输出并处理文本。捕获此类输出允许您验证日志事件的处理是否按预期生成。在我们的高级配置测试中，我们应用了这项技术。如果日志事件不会输出到`stdout`，而是输出到Fluentd的日志文件，也可以进行查询，查看生成了多少日志信息以及是否发生了特定的日志事件。
- en: Listing 9.8 Chapter9/fluent-plugin-out-redislist/test/plugin/test_out_redislist.rb
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.8 Chapter9/fluent-plugin-out-redislist/test/plugin/test_out_redislist.rb
- en: '[PRE21]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Declares the unit test
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 声明单元测试
- en: ❷ Creates a set of configuration values to be passed
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建要传递的一组配置值
- en: ❸ Defines a variable to capture any stdout generated within the following statement
    block
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 定义一个变量以捕获以下语句块中生成的任何标准输出
- en: ❹ Creates the driver using the test config provided
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用提供的测试配置创建驱动程序
- en: ❺ Tests the values set in the plugin for the port
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 测试插件中设置的端口号值
- en: ❻ Evaluates whether the warning about no standard port has been produced
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 评估是否生成了关于没有标准端口的警告
- en: ❼ Shuts down everything cleanly
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 清洁地关闭一切
- en: 'To execute the unit tests, we simply need to follow the unit test framework’s
    guidance. In the case of test-unit, that comes down to using Ruby to execute the
    unit test file. For example:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行单元测试，我们只需遵循单元测试框架的指导。在test-unit的情况下，这归结为使用Ruby执行单元测试文件。例如：
- en: '[PRE22]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 9.10 Putting the development of unit tests into action
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.10 将单元测试的开发付诸实践
- en: Previously, we identified the need to test different configurations through
    running Fluentd with alternative configuration files. These should be replaced
    with unit tests. As the output plugin has restricted how we can use buffering,
    we need to further test configuration handling. This is best done with unit tests
    for the `configure` and `write` functions.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们确定了通过运行Fluentd使用不同的配置文件来测试不同配置的需求。这些应该被单元测试所取代。由于输出插件限制了我们可以使用的缓冲方式，我们需要进一步测试配置处理。这最好通过为`configure`和`write`函数进行单元测试来完成。
- en: 9.10.1 Answer
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.10.1 答案
- en: Within the `Chapter9/ExerciseResults` directory, we have included two child
    directories called `test-out` and `test-in`. These contain the directory structures
    and files with additional unit tests covering the configure and other operations
    that you can compare against.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Chapter9/ExerciseResults`目录中，我们包含了两个子目录，分别称为`test-out`和`test-in`。这些包含目录结构和文件，其中包含额外的单元测试，覆盖了配置和其他操作，您可以进行比较。
- en: 9.11 Package and deployment
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.11 打包和部署
- en: Having completed testing, we can think about packaging and deploying our plugins.
    This includes preparing the metadata files and documentation.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 完成测试后，我们可以考虑打包和部署我们的插件。这包括准备元数据文件和文档。
- en: 9.11.1 Documentation
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.11.1 文档
- en: Part of packaging up a solution includes providing the licensing information
    and documentation for the plugin. The template utility will have provided a standard
    license document and a basic README. The most important thing here is to ensure
    that the readme is clear and complete. Like any good product, the plugin’s ability
    to be successfully used is predicated on people understanding how to use it, so
    good documentation will make a meaningful difference. In the download pack (and
    GitHub repository), we have provided a separate completed readme, so the initial
    generated state (`readme.md`) and final state (`readme-final.md`) can be compared.
    You may notice in the readme content some instructions for helping to complete
    the Gemfile, which we will come to in a moment.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 打包解决方案的一部分包括提供插件的许可信息和文档。模板工具将提供标准的许可文档和基本的 README。这里最重要的是确保 README 清晰完整。像任何好的产品一样，插件能否成功使用取决于人们是否了解如何使用它，因此良好的文档将产生重大影响。在下载包（和
    GitHub 仓库）中，我们提供了一个单独的完成后的 README，以便可以比较初始生成的状态（`readme.md`）和最终状态（`readme-final.md`）。您可能会在
    README 内容中注意到一些帮助完成 Gemfile 的说明，我们将在稍后讨论。
- en: 'The task of generating the documentation for the plugins is greatly simplified
    using another Fluentd-provided utility. The `fluent-plugin-config-format` utility
    takes the plugin type (in the same way that the utility that created the skeleton
    for us) and names the plugin’s parameters. We can then tell the utility how we
    would like the documentation to be generated. In the following example, we have
    used `markdown` (it makes it easy for GitHub and other Git-like repositories to
    render nicely, but other options include pure text and JSON). As we want to generate
    the documentation from the source, we need to provide the path to the Ruby plugin
    code. Using this utility with the following parameters will produce the documentation
    about the plugin configuration information:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用另一个 Fluentd 提供的工具，生成插件的文档任务得到了极大的简化。`fluent-plugin-config-format` 工具接受插件类型（与为我们创建骨架的工具相同的方式）并为插件的参数命名。然后我们可以告诉工具我们希望如何生成文档。在下面的示例中，我们使用了
    `markdown`（它使得 GitHub 和其他 Git 类型的仓库能够很好地渲染，但其他选项包括纯文本和 JSON）。由于我们希望从源代码生成文档，我们需要提供
    Ruby 插件代码的路径。使用此工具并以下列参数将生成关于插件配置信息的文档：
- en: '[PRE23]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The result of the utility is sent to the console rather than to a file, so we
    do need to cut and paste the output into our `readme.md` file (or use some shell/console
    tricks to pipe the output into the file). We have incorporated the output into
    the `readme - final.md` file.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 工具的结果被发送到控制台而不是文件中，因此我们需要将输出剪切并粘贴到我们的 `readme.md` 文件中（或者使用一些 shell/console 技巧将输出管道到文件中）。我们已经将输出整合到了
    `readme - final.md` 文件中。
- en: USING RDOC OR YARD
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 RDOC 或 YARD
- en: In the directory structure shown in figure 9.2, we had a doc folder that was
    not generated by the Fluentd utility. This comes from running *RDoc* or *YARD*
    on the code, resulting in developer-level documentation being generated. In this
    case, we have opted to use YARD, as it provides some additional neat features
    over standard RDoc. To find out more about YARD and install it, see appendix E.
    Note that if you prefer to stick with RDoc, the metadata tags YARD uses will appear
    in the generated output.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 9.2 所示的目录结构中，我们有一个 doc 文件夹，它不是由 Fluentd 工具生成的。这是通过在代码上运行 *RDoc* 或 *YARD*
    得到的，从而生成了开发者级别的文档。在这种情况下，我们选择使用 YARD，因为它在标准 RDoc 之上提供了一些额外的便捷功能。要了解更多关于 YARD 的信息以及如何安装它，请参阅附录
    E。请注意，如果您更喜欢坚持使用 RDoc，YARD 使用的元数据标签将出现在生成的输出中。
- en: 'With YARD installed, maintaining this document comes down to looking after
    the code, commenting, and running the commands from the root folder of the plugin:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 YARD 后，维护此文档的工作就归结为关注代码、注释以及在插件的根目录中运行命令：
- en: '[PRE24]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will update the documentation for you, but it focuses on general Ruby code
    and comments, not the specifics relating to Fluentd, such as the configuration
    values and their parameters.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为您更新文档，但它主要关注通用 Ruby 代码和注释，而不是与 Fluentd 相关的特定内容，例如配置值及其参数。
- en: 9.11.2 Complete metadata aka manifest
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.11.2 完整元数据即清单
- en: The Gemfile needs to be updated as directed by the README in its defaulted content.
    Therefore, we need to add to the `gemspec` file the name of the gem we want to
    create. It takes the form of `gem <name of the gem>`—for example, `gem "fluent-plugin-out-redislist"`—for
    our input plugin.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 需要根据 README 中默认内容中的指示更新 Gemfile。因此，我们需要将我们要创建的 gem 的名称添加到 `gemspec` 文件中。它采用
    `gem <gem 名称>` 的形式——例如，`gem "fluent-plugin-out-redislist"`——用于我们的输入插件。
- en: 'The gemspec file will also need to be completed with additional information,
    including the summary, description, home page, license, contact details, and versioning
    (Semantic Versioning format is expected; [https://semver.org](https://semver.org)).
    This also needs to include details of any dependencies. When set up, we installed
    several additional gems, such as the Redis connector. This means we need to add
    the dependencies into the `gemspec` file so they are retrieved when this plugin
    is installed:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: gemspec 文件还需要补充额外的信息，包括摘要、描述、主页、许可证、联系详情和版本信息（预期使用语义版本控制格式；[https://semver.org](https://semver.org)）。这还需要包括任何依赖项的详细信息。当设置好时，我们安装了几个额外的
    gem，例如 Redis 连接器。这意味着我们需要将依赖项添加到 `gemspec` 文件中，以便在安装此插件时检索它们：
- en: '[PRE25]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This indicates that the Redis gem is needed at a version of 4.0 or later. The
    gemspec standard does allow for complex rules to be defined for what versions
    can be used.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明需要 Redis gem 的版本为 4.0 或更高版本。gemspec 标准确实允许定义复杂的规则，以确定可以使用哪些版本。
- en: 9.11.3 Building the gem package
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.11.3 构建 gem 包
- en: 'Once complete, we can do this using the RubyGem tooling that we previously
    installed. This means we can use the gemspec tools to create the final package.
    But be careful where you execute the command from, as the gemspec file includes
    scripting, which uses relative paths to locate all the files that need to be included.
    We can switch on the verbose mode using the `-V` parameter to the command to make
    it easy to see what is going on. To complete the task, we use the command to create
    the gem file:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，我们可以使用之前安装的 RubyGem 工具来完成此操作。这意味着我们可以使用 gemspec 工具创建最终的包。但请注意执行命令的位置，因为
    gemspec 文件包含脚本，它使用相对路径来定位所有需要包含的文件。我们可以使用命令的 `-V` 参数来开启详细模式，以便更容易地看到正在发生的事情。为了完成任务，我们使用以下命令创建
    gem 文件：
- en: '[PRE26]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With the gem file is created, we need to install it into our local library of
    gems. Once complete, we can then use the gem without providing the path to the
    actual Ruby code. This can be done with the command
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当 gem 文件创建完成后，我们需要将其安装到我们的本地 gem 库中。一旦完成，我们就可以使用该 gem，而无需提供实际 Ruby 代码的路径。这可以通过以下命令完成：
- en: '[PRE27]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We can confirm that the gem is in place by executing the command
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行以下命令来确认 gem 已安装：
- en: '[PRE28]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This should yield a list including our gem.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会生成一个包括我们的 gem 的列表。
- en: 9.11.4 Rerun without the plugin paths
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.11.4 无插件路径重新运行
- en: With the plugins built and the gems created and installed, we can rerun our
    test scenario. This time the test can be run without referencing the Ruby code
    directly, as we have made the code available via the gems we created to ensure
    we don’t accidentally run using the `-p` parameter in the Fluentd command line.
    As a result, we can see our plugin working, but the execution commands reflect
    the conventional way of working that we would see in production.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建了插件并创建了安装了 gem 之后，我们可以重新运行我们的测试场景。这次测试可以在不直接引用 Ruby 代码的情况下运行，因为我们已经通过我们创建的
    gem 提供了代码，以确保我们不会意外地在 Fluentd 命令行中使用 `-p` 参数。因此，我们可以看到我们的插件正在工作，但执行命令反映了在生产中会看到的传统工作方式。
- en: 9.12 Extending to be an enterprise-class solution
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.12 扩展为成为企业级解决方案
- en: 'The plugin development has been successful and has met all our requirements.
    But it doesn’t yet reach the level at which we could call the solution suitable
    for enterprise-class use cases. To bring things up to a suitable standard, we
    recommend some changes:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 插件开发已成功，并满足了我们所有的要求。但它还没有达到我们可以称之为适合企业级用例的水平的程度。为了达到合适的标准，我们建议进行一些更改：
- en: Credentials used on the Redis connection—configure the plugin to optionally
    use an authenticated connection with Redis. This should be done to allow the credentials
    to be injected from a secure source, such as Vault.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Redis 连接上使用的凭证——配置插件以可选地使用带有 Redis 的认证连接。这样做是为了允许凭证从安全源注入，例如 Vault。
- en: Using an authenticated connection to Redis means passing credentials. We do
    not really want to be doing that with an HTTP connection with the credentials
    in cleartext. So, the connection to Redis should be implemented securely with
    SSL/TLS certificates.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用经过身份验证的 Redis 连接意味着传递凭证。我们真的不希望在明文凭证的 HTTP 连接中这样做。因此，Redis 连接应该通过 SSL/TLS
    证书安全实现。
- en: One of the features within Redis, and what makes it such a good cache solution,
    is the inclusion of TTL. By incorporating TTL, we can control the size of the
    Redis buffer, and if we cannot keep up, then events will simply expire.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redis 中的一个特性，也是使其成为优秀缓存解决方案的原因之一，是包含 TTL（生存时间）。通过包含 TTL，我们可以控制 Redis 缓冲区的大小，如果我们无法跟上，那么事件将简单地过期。
- en: As events are handled, some basic stats could be generated that could potentially
    be consumed by Prometheus.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在处理事件时，可以生成一些基本统计信息，这些信息可能会被 Prometheus 消费。
- en: Extend and enhance the unit testing to achieve a target of greater than 60%
    coverage.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展和增强单元测试，以达到超过 60% 的覆盖率目标。
- en: Develop the prebuilt *Rakefile* to include and execute all the unit tests. Also,
    incorporate activities such as
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发预构建的 *Rakefile* 以包含并执行所有单元测试。同时，结合以下活动：
- en: Lint code analysis.
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码分析。
- en: Maintaining the additional documentation using of *RDoc* or YARD. Currently,
    the doc folder is generated using YARD.
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *RDoc* 或 YARD 维护额外的文档。目前，doc 文件夹是使用 YARD 生成的。
- en: Generating `fluent-plugin-config-format` output and determining if there have
    been any changes since the last build.
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成 `fluent-plugin-config-format` 输出，并确定自上次构建以来是否有任何更改。
- en: Incorporate the process into a continuous integration tool suite.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将该流程集成到持续集成工具套件中。
- en: Consolidate the `readme.md` documentation rather than using the `readme` `-
    final.md`
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `readme.md` 文档合并，而不是使用 `readme` `- final.md`。
- en: If you wish to develop your plugin development skills or use this as a practical
    opportunity to develop your Ruby development skills, we would encourage you to
    try implementing these suggested improvements. As you won’t be following our steps
    when implementing these features, we would recommend that you adopt your preferred
    development tool(s). We do not have a reference solution to this, but running
    the test scenarios as you implement your solution to this exercise will confirm
    a successful outcome functionally.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想提高你的插件开发技能或将其作为实际机会来提高你的 Ruby 开发技能，我们鼓励你尝试实现这些建议的改进。由于你在实现这些功能时不会遵循我们的步骤，我们建议你采用你喜欢的开发工具（们）。我们没有参考解决方案，但运行测试场景以确认你实现此练习的解决方案的功能性成功。
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Fluentd plugin tooling provides the means to create the skeleton code to develop
    both input and output plugins.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fluentd 插件工具提供了创建输入和输出插件骨架代码的手段。
- en: Fluentd’s skeleton supports asynchronous and synchronous buffering output plugin
    functions.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fluentd 的框架支持异步和同步缓冲输出插件功能。
- en: Fluentd input plugins need to be able to set the time and tag details. The input
    plugin implements this logic.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fluentd 输入插件需要能够设置时间和标签细节。输入插件实现了这一逻辑。
- en: The plugin framework includes defining, creating, and defaulting the configuration
    properties for the plugin loaded from the configuration file.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件框架包括定义、创建和默认配置从配置文件加载的插件的配置属性。
- en: Fluentd plugins are typically made available as RubyGems. The utilities provided
    by Ruby and Fluentd make this easy to achieve.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fluentd 插件通常作为 RubyGems 提供。Ruby 和 Fluentd 提供的实用工具使得实现这一点变得简单。
