- en: Part 3\. Adding a dynamic front end with Angular
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三部分. 使用Angular添加动态前端
- en: Angular is one of the most exciting technologies of our time and is a core part
    of the MEAN stack with proven stability and longevity. You’ve done a lot of work
    so far with Express, which is the server-side framework. Angular is the client-side
    framework that enables you to build entire applications that run in the browser.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Angular是我们这个时代最激动人心的技术之一，是MEAN堆栈的核心部分，具有经过验证的稳定性和持久性。到目前为止，你已经与Express做了很多工作，它是服务器端框架。Angular是客户端框架，它使你能够构建在浏览器中运行的应用程序。
- en: You’ll get to know Angular and TypeScript (like JavaScript, a bit different
    but *good* different) in [chapter 8](kindle_split_020.xhtml#ch08), seeing what
    all the fuss is about and getting into the particular syntax semantics and jargon
    associated with it. Angular can have a steep learning curve, but it doesn’t have
    to. As you get started with Angular and TypeScript in [chapter 8](kindle_split_020.xhtml#ch08),
    you’ll see how to use them to build a component for an existing web page, including
    calling your REST API to get data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](kindle_split_020.xhtml#ch08)中，你将了解Angular和TypeScript（就像JavaScript，有点不同但*很好*的不同），了解所有这些喧嚣的原因，并了解与之相关的特定语法语义和术语。Angular的学习曲线可能很陡峭，但不必如此。在[第8章](kindle_split_020.xhtml#ch08)中开始使用Angular和TypeScript时，你将看到如何使用它们来构建一个现有网页的组件，包括调用你的REST
    API来获取数据。
- en: '[Chapters 9](kindle_split_021.xhtml#ch09) and [10](kindle_split_022.xhtml#ch10)
    focus on how to use Angular to build a single-page application (SPA). Building
    on what you learned in [chapter 8](kindle_split_020.xhtml#ch08), you re-create
    Loc8r as an SPA. You’ll focus on best practices throughout, learning how to build
    a modular application that’s easily maintainable with components that can easily
    be reused. By the end of [part 3](#part03), you’ll have a fully functioning SPA
    interacting with your REST API to create and read data.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[第9章](kindle_split_021.xhtml#ch09) 和 [第10章](kindle_split_022.xhtml#ch10) 专注于如何使用Angular构建单页应用程序（SPA）。在[第8章](kindle_split_020.xhtml#ch08)所学的基础上，你将重新创建Loc8r作为SPA。你将关注最佳实践，学习如何构建一个模块化应用程序，它具有易于维护的组件，这些组件可以轻松重用。到[第三部分](#part03)结束时，你将拥有一个完全功能化的SPA，它可以与你的REST
    API交互以创建和读取数据。'
- en: Chapter 8\. Creating an Angular application with TypeScript
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8章. 使用TypeScript创建Angular应用程序
- en: '*This chapter covers*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Using the Angular CLI and creating an Angular application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular CLI创建Angular应用程序
- en: Understanding the basics of TypeScript
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解TypeScript的基本知识
- en: Creating and using Angular components
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用Angular组件
- en: Getting data from an API and binding data to HTML templates
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从API获取数据并将数据绑定到HTML模板中
- en: Building an Angular application for production
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建用于生产的Angular应用程序
- en: 'Here it comes. It’s time to take a look at the final part of the MEAN stack:
    Angular! When you’re getting started with Angular and TypeScript, it can feel
    like a different language at times, but TypeScript is a superset of JavaScript,
    so it’s JavaScript with some additional bits and pieces. TypeScript is the preferred
    language for creating Angular applications. We’ll cover what we need to as we
    go, and you’ll be fairly comfortable with it by the end of this chapter.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止。是时候看看MEAN堆栈的最后一部分了：Angular！当你开始使用Angular和TypeScript时，有时会感觉像是一门不同的语言，但TypeScript是JavaScript的超集，所以它是带有一些额外部分的JavaScript。TypeScript是创建Angular应用程序的首选语言。我们将随着进展逐步介绍所需的内容，到本章结束时，你将相当熟悉它。
- en: 'To get into it all, you’ll rebuild the list of locations shown in the homepage
    as an Angular application. You’ll embed this little application in the Express-driven
    homepage, replacing the list delivered by Express, to serve two purposes:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要全面了解，你需要重建主页上显示的位置列表，作为一个Angular应用程序。你将在这个由Express驱动的主页中嵌入这个小应用程序，替换Express提供的列表，以实现两个目的：
- en: You’ll work with some of the building blocks of Angular without getting overwhelmed.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将处理Angular的一些构建块，而不会感到不知所措。
- en: You’ll see how to use Angular to create a single component within an existing
    page or application.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将看到如何使用Angular在现有页面或应用程序中创建一个单组件。
- en: '[Figure 8.1](#ch08fig01) shows where you are in the overall plan, adding Angular
    to the front end of the existing Express application.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8.1](#ch08fig01) 展示了你在整体计划中的位置，即将Angular添加到现有Express应用程序的前端。'
- en: Figure 8.1\. This chapter focuses on adding Angular to the front end of the
    existing Express application
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.1. 本章重点介绍如何将Angular添加到现有的Express应用程序的前端
- en: '![](Images/08fig01_alt.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig01_alt.jpg)'
- en: The approach taken in this chapter is what you’d do if you wanted to enhance
    a page, project, or application with a bit of Angular. Building a full application
    entirely in Angular is coming up in [chapters 9](kindle_split_021.xhtml#ch09)
    and [10](kindle_split_022.xhtml#ch10) and adds to what you’ll learn in this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章采用的方法是如果您想用一点 Angular 来增强页面、项目或应用程序时您会做的事情。完全在 Angular 中构建完整应用程序的内容将在第 9 章（kindle_split_021.xhtml#ch09）和第
    10 章（kindle_split_022.xhtml#ch10）中介绍，并将补充您在本章中学到的内容。
- en: 8.1\. Getting up and running with Angular
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1\. 使用 Angular 运行起来
- en: In this section, you’ll create a skeleton Angular application, look at how it’s
    put together, and explore some of the tools that come with it to help development.
    If you haven’t done so yet, you’ll need to install the Angular command-line interface
    (CLI) as described in [appendix A](kindle_split_026.xhtml#app01).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将创建一个 Angular 应用程序的骨架，查看它是如何组成的，并探索一些附带工具以帮助开发。如果您还没有这样做，您需要按照附录 A（kindle_split_026.xhtml#app01）中所述安装
    Angular 命令行界面（CLI）。
- en: You’ll start by using the CLI to create a new application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您将首先使用 CLI 创建一个新应用程序。
- en: 8.1.1\. Using the command line to create a boilerplate Angular app
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.1\. 使用命令行创建 Angular 应用程序的模板
- en: The easiest way to create a new Angular application is to use the Angular CLI,
    which creates a fully functional small application and generates a good folder
    structure.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的 Angular 应用程序最简单的方法是使用 Angular CLI，它创建一个功能齐全的小型应用程序并生成良好的文件夹结构。
- en: 'The base command is simple:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 基本命令很简单：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Before you run the command to create your Angular app for Loc8r—which would
    create a new application called your-app-name with default settings in the current
    folder—you’ll want to look at some options.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在您运行命令以创建 Loc8r 的 Angular 应用程序之前——这将创建一个名为 your-app-name 的新应用程序，并在当前文件夹中使用默认设置——您可能想要查看一些选项。
- en: 'You can apply many options to this command, and you can see them by running
    `ng help` in the command line. The options you’re interested in are the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以向这个命令应用许多选项，您可以通过在命令行中运行 `ng help` 来查看它们。您感兴趣的选项如下：
- en: '`--skipGit`, to skip the default Git initialization and first commit. By default,
    `ng new` initializes the folder as a new Git repository, but you don’t need to
    do that, because you’re going to create it inside an existing Git repo.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--skipGit`，跳过默认的 Git 初始化和第一次提交。默认情况下，`ng new` 将文件夹初始化为新的 Git 仓库，但您不需要这样做，因为您将在现有的
    Git 仓库内创建它。'
- en: '`--skipTests`, to skip installation of some testing files. We don’t cover unit
    tests in this book, so you don’t need these extra files. See the sidebar “[Testing
    Angular applications](#ch08sb01)” as to why we don’t cover this topic.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--skipTests`，跳过安装一些测试文件。本书没有涵盖单元测试，因此您不需要这些额外的文件。有关为什么我们不涵盖这个主题的更多信息，请参阅侧边栏“[测试
    Angular 应用程序](#ch08sb01)”。'
- en: '`--directory`, to specify the folder where you want the application to be generated.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--directory`，指定您希望应用程序生成的文件夹。'
- en: '`--defaults` forces default Angular settings to be used.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--defaults` 强制使用默认的 Angular 设置。'
- en: '|  |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Testing Angular applications**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试 Angular 应用程序**'
- en: Testing is an important, but really large, topic—so large, in fact, that there
    are many books written on the topic. (Several really good ones are published by
    Manning Publications.)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是一个重要但非常大的主题——实际上，关于这个主题已经写了很多本书。（Manning 出版公司出版了一些非常好的书籍。）
- en: We don’t cover testing in this book due to space constraints. If you’re interested
    in finding out more about testing Angular applications, then your first stop should
    be [https://www.manning.com/books/testing-angular-applications](https://www.manning.com/books/testing-angular-applications).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于篇幅限制，本书没有涵盖测试内容。如果您想了解更多关于测试 Angular 应用程序的信息，那么您应该首先访问[https://www.manning.com/books/testing-angular-applications](https://www.manning.com/books/testing-angular-applications)。
- en: '|  |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Putting all this together, you’ll use a command to create a boilerplate Angular
    application inside a new folder called app_public. This command installs a lot
    of stuff, so it’ll take a little while to run, and you’ll need to be online for
    it to work. Make sure that in terminal, you’re in the root folder of your Loc8r
    application before running the following command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些组合起来，您将使用一个命令在名为 app_public 的新文件夹内创建一个 Angular 应用程序的模板。这个命令会安装很多东西，所以运行起来会花费一些时间，并且您需要保持在线状态才能使其工作。确保在终端中，您在
    Loc8r 应用程序的根目录下运行以下命令之前：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|  |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Improvement
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 改进
- en: To those who are familiar with AngularJS (Angular 1.x), this is quite a change
    from the days of being able to download a single library file to start coding!
    The good news is that this new approach encourages better application architecture
    out of the box.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于熟悉AngularJS（Angular 1.x）的人来说，这与能够下载单个库文件开始编码的日子有很大的不同！好消息是，这种新的方法从一开始就鼓励了更好的应用程序架构。
- en: '|  |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: When everything is installed, the contents of your app_public folder should
    look like [figure 8.2](#ch08fig02).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当一切安装完毕后，你的app_public文件夹的内容应该看起来像[图8.2](#ch08fig02)。
- en: Figure 8.2\. Default contents of a freshly generated Angular project
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.2\. 新生成的Angular项目的默认内容
- en: '![](Images/08fig02.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/08fig02.jpg)'
- en: You may notice that this project has its own package.json file and node_modules
    folder, so it looks a lot like a Node application. The src folder is where you’ll
    do most of your work.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到这个项目有自己的package.json文件和node_modules文件夹，所以它看起来很像一个Node应用。src文件夹是你要做大部分工作的地方。
- en: 8.1.2\. Running the Angular app
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.2\. 运行Angular应用
- en: 'This is a fully functional Angular app, albeit a rather minimal one. Now run
    it, see what you’ve got, and take a look under the hood. To run the app, head
    to your app_public folder in terminal, and run the following command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个完全功能性的Angular应用，尽管相当简约。现在运行它，看看你得到了什么，并查看其内部结构。要运行应用，请在终端中转到你的app_public文件夹，并运行以下命令：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When you run this command, you’ll see some notifications in terminal as Angular
    builds the application, ending with `?wdm?: Compiled successfully.` When you see
    this message, your app is ready to view on port 4200\. To check it out, open your
    browser, and go to http://localhost:4200. Not much is going on here, admittedly,
    but if you view the source or inspect element, you should see something like [figure
    8.3](#ch08fig03).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '当你运行这个命令时，你会在终端中看到一些通知，Angular正在构建应用程序，最后以`?wdm?: 编译成功`结束。当你看到这条消息时，你的应用已经准备好在4200端口上查看。要查看它，请打开你的浏览器，并转到http://localhost:4200。诚然，这里没有什么特别的事情发生，但如果你查看源代码或检查元素，你应该会看到像[图8.3](#ch08fig03)那样的内容。'
- en: Figure 8.3\. The autogenerated Angular app working in the browser alongside
    the generated HTML
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.3\. 在浏览器中与生成的HTML一起工作的自动生成的Angular应用
- en: '![](Images/08fig03_alt.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/08fig03_alt.jpg)'
- en: You’ll see some minimal HTML and a bunch of JavaScript files being referenced.
    Take note of the `app-root` HTML tag, however; that’s unusual and important. Remember
    this tag, because you’ll come back to it when you look at the source files.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到一些基本的HTML和一些引用的JavaScript文件。但是请注意`app-root` HTML标签；这是不寻常的，但很重要。记住这个标签，因为当你查看源文件时，你会回到它。
- en: 8.1.3\. The source code behind the application
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.3\. 应用程序背后的源代码
- en: Angular applications are built with components, which are compiled into modules.
    *Component* and *module* are terms that are often used loosely to label the building
    blocks of an application, but in Angular, they have specific meanings. A component
    handles a specific piece of functionality, and a module contains one or more components
    working together. This default example is a simple module with one component.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Angular应用是用组件构建的，这些组件被编译成模块。"组件"和"模块"是常用来标记应用程序构建块的术语，但在Angular中，它们有特定的含义。组件处理特定的功能，而模块包含一个或多个一起工作的组件。这个默认示例是一个简单的模块，包含一个组件。
- en: Open the src folder in your editor, and you’ll see several files and folders.
    Start at the beginning by looking at the index.html file in the src folder; it
    should look something like [listing 8.1](#ch08ex01).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的编辑器中打开src文件夹，你会看到几个文件和文件夹。从src文件夹中的index.html文件开始，它应该看起来像[列表8.1](#ch08ex01)。
- en: Listing 8.1\. The default contents of the src/index.html file
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.1\. src/index.html文件的默认内容
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* The title has been created from the application name.**'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 标题是从应用程序名称创建的。**'
- en: '***2* The only tag in the body is the app-root.**'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 主体中唯一的标签是app-root。**'
- en: There’s not a huge amount here aside from some basic HTML scaffolding. You can
    see that Angular has populated the `title` tag for you ***1***, taking the application
    name you specified in the terminal command (`loc8r-public`) and turning it into
    camelCase. Also, you see the `app-root` tag ***2*** that you noticed in the source
    of the running application, but this time, no `<h1>` tag is inside it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里除了一些基本的HTML框架之外，没有太多内容。你可以看到Angular已经为你填充了`title`标签 ***1***，它将你在终端命令中指定的应用程序名称（`loc8r-public`）转换成了驼峰式。你还看到了`app-root`标签
    ***2***，这是你在运行的应用程序源中注意到的，但这次里面没有`<h1>`标签。
- en: Dig a bit deeper and look inside the app folder (inside the src folder).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 深入挖掘并查看 src 文件夹中的 app 文件夹（在 src 文件夹内）。
- en: The main module
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 主模块
- en: Remember that we said *Angular applications are built with components, which
    are compiled into modules*? A good place to start investigating is in the module
    definition.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们说过“Angular 应用程序是用组件构建的，这些组件被编译成模块”吗？一个开始调查的好地方是模块定义。
- en: In src/app, you’ll find a file called app.module.ts. This file is the central
    point of your Angular module, and it’s where all of the components are brought
    together. At the moment, this file looks like [listing 8.2](#ch08ex02).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 src/app 中，你会找到一个名为 app.module.ts 的文件。这个文件是 Angular 模块的中心点，所有组件都汇集在这里。目前，这个文件看起来像列表
    8.2（#ch08ex02）。
- en: 'We won’t go deeply into the semantics of each part right now; we’ll only give
    you a high-level view of what each section does. In essence, this file does the
    following things:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不会深入探讨每个部分的语义；我们只会给你一个每个部分功能的概述。本质上，这个文件执行以下操作：
- en: Imports various pieces of Angular functionality that the app will use
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入应用将使用的各种 Angular 功能模块
- en: Imports the components that the app will use
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入应用将使用的组件
- en: Describes the module by using a decorator
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用装饰器描述模块
- en: Exports the module
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出模块
- en: '|  |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Decorators and dependency injection**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**装饰器和依赖注入**'
- en: A *decorator* is a way that ES2015 and TypeScript provide metadata and annotations
    to functions, modules and classes. A common use case in Angular is to handle dependency
    injection, which is a way of saying, “This module or class depends on this piece
    of functionality to run.”
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*装饰器*是 ES2015 和 TypeScript 提供的一种方式，用于向函数、模块和类提供元数据和注释。在 Angular 中，一个常见的用例是处理依赖注入，这是一种说“这个模块或类依赖于这个功能来运行”的方式。'
- en: You can see in [listing 8.2](#ch08ex02) that you import the module `BrowserModule`
    into your module. In this case, the decorator also declares the components it
    contains and which component should be used as the start point (`bootstrap`).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在列表 8.2（#ch08ex02）中看到，你将模块 `BrowserModule` 导入到你的模块中。在这种情况下，装饰器还声明了它包含的组件以及哪个组件应该用作起点（`bootstrap`）。
- en: '|  |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In this file, follow the journey of `AppComponent`, highlighted in bold in [listing
    8.2](#ch08ex02). First, it’s imported from the file system (you may recognize
    the `./` syntax from `require` and Node.js) before being both declared and bootstrapped
    inside the module decorator. For more information on decorators, check out the
    sidebar “[Decorators and dependency injection](#ch08sb02).”
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，跟随 `AppComponent` 的旅程，如列表 8.2（#ch08ex02）中用粗体突出显示的。首先，它从文件系统中导入（你可能从 `require`
    和 Node.js 中的 `./` 语法中认出了它），然后在模块装饰器内部声明和启动。有关装饰器的更多信息，请参阅侧边栏“[装饰器和依赖注入](#ch08sb02)。”
- en: Listing 8.2\. The default contents of the src/app/app.module.ts file
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.2\. src/app/app.module.ts 文件默认内容
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* Imports various Angular modules that the application will use**'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入应用将使用的各种 Angular 模块**'
- en: '***2* Imports a component from the file system**'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从文件系统中导入一个组件**'
- en: '***3* Describes the module by using a decorator . . .**'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用装饰器描述模块 . . .**'
- en: '***4* . . . including the entry point into the application**'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* . . . 包括应用程序的入口点**'
- en: '***5* Exports the module**'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 导出模块**'
- en: This is the main module, and you can see from the `bootstrap` line in the decorator
    that the entry point into the application itself is `AppComponent`. You can also
    see from the `import` statement where this component lives in the file system—in
    this case, in the same folder as this module definition. Check it out.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是主模块，你可以从装饰器中的 `bootstrap` 行看到，应用程序本身的入口点是 `AppComponent`。你还可以从 `import` 语句中看到这个组件在文件系统中的位置——在这个例子中，它与模块定义在同一文件夹中。查看一下。
- en: The default bootstrapped component
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 默认启动组件
- en: 'In the app_public/src/app folder, alongside the module file, you can see three
    app.component files:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 app_public/src/app 文件夹中，与模块文件并列，你可以看到三个 app.component 文件：
- en: app.component.css
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: app.component.css
- en: app.component.html
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: app.component.html
- en: app.component.ts
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: app.component.ts
- en: These files are typical for any component. The CSS and HTML files define the
    styles and markup for the component, and the TS file defines the behavior in TypeScript.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件对于任何组件都是典型的。CSS 和 HTML 文件定义了组件的样式和标记，而 TS 文件定义了 TypeScript 中的行为。
- en: 'The CSS file is empty, but the HTML file contains the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 文件为空，但 HTML 文件包含以下代码：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code makes some sense, as you think back to when you inspected the elements
    within the browser and saw some minimal HTML content. In Angular, double curly
    brackets are used to denote a binding between the data and the view. Here, the
    variable `title` is being bound, as are the contents of the `<h1>` tag. To see
    where this `title` variable is being defined, you need to look inside the component
    definition file, app.component.ts, which is shown in full in [listing 8.3](#ch08ex03).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有些道理，因为你回想起在浏览器中检查元素时看到的一些最小HTML内容。在Angular中，双大括号用于表示数据与视图之间的绑定。在这里，变量`title`正在被绑定，以及`<h1>`标签的内容。要看到这个`title`变量在哪里被定义，你需要查看组件定义文件app.component.ts，该文件在[列表8.3](#ch08ex03)中完整展示。
- en: 'This component file does three main things:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件文件主要做三件事：
- en: Imports what it needs from Angular
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Angular导入所需的内容
- en: Decorates the component, giving it the information that the app needs to run
    it
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰组件，为应用程序提供运行所需的信息
- en: Exports the component as a class
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将组件作为类导出
- en: Listing 8.3\. The default contents of app.component.ts
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.3\. app.component.ts的默认内容
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* Imports the Component from the Angular core**'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从Angular核心导入组件**'
- en: '***2* Decorates the component**'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 装饰组件**'
- en: '***3* Exports the component as a class**'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将组件作为类导出**'
- en: This file is simple, but the syntax is a bit alien if you’re used to plain JavaScript.
    If you look inside it, though, you can see some interesting information, and you
    can see the pieces coming together.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件很简单，但如果习惯了纯JavaScript，其语法可能有点陌生。不过，如果你查看它的内部，你可以看到一些有趣的信息，并且可以看到各个部分是如何组合在一起的。
- en: Starting with the decorator, you can see the HTML and CSS files being referenced,
    but you can also see `selector:` ‘`app-root`’. Ah-ha! That’s the name of the tag
    you found in the index.html file! And when you inspected the elements, you saw
    that tag with an `<h1>` tag and some content inside, which matches your app.component.html
    file. Okay, it’s coming together.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 从装饰器开始，你可以看到引用的HTML和CSS文件，但你也可以看到`selector:` ‘`app-root`’。啊哈！这就是你在index.html文件中找到的标签名！当你检查元素时，你看到了这个带有`<h1>`标签和一些内容的标签，这与你的app.component.html文件相匹配。好吧，一切都在逐渐明朗。
- en: Next, you see the `AppComponent` class being exported, which you’ve already
    seen imported and bootstrapped in the module definition. Finally, you see the
    definition of `title` (you saw the binding in the HTML file for the component)
    and the value of `loc8r-public` (which you saw when running it in the browser).
    Note that no `var`, `const`, or `let` is associated with `title` because inside
    a class definition, you define *class members* as opposed to variables.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你看到`AppComponent`类被导出，这你已经在模块定义中看到过导入和引导。最后，你看到`title`的定义（你在HTML文件中看到了组件的绑定）以及`loc8r-public`的值（你在浏览器中运行时看到过）。请注意，与`title`相关联的没有`var`、`const`或`let`，因为在类定义内部，你定义的是*类成员*而不是变量。
- en: Tying it all together
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将一切整合在一起
- en: 'Okay, you’ve seen a lot here, so we’ll quickly recap how everything ties together:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，你在这里看到了很多，所以我们将快速回顾一下所有这些是如何联系在一起的：
- en: 'The component `AppComponent` comprises three files: TypeScript, HTML, and CSS.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件`AppComponent`由三个文件组成：TypeScript、HTML和CSS。
- en: The TypeScript file is the key part of the component, defining the functionality
    referencing the other files and declaring which selector (HTML tag) it will bind
    to.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript文件是组件的关键部分，定义了功能，引用了其他文件，并声明了它将绑定到的选择器（HTML标签）。
- en: The component TypeScript file exports the `AppComponent` class.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件TypeScript文件导出`AppComponent`类。
- en: The module file imports the `AppComponent` class from the component TypeScript
    file and declares it as the entry point into the application.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块文件从组件TypeScript文件中导入了`AppComponent`类，并将其声明为应用程序的入口点。
- en: The module file also imports various pieces of native Angular functionality.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块文件还导入了各种原生Angular功能。
- en: '[Figure 8.4](#ch08fig04) illustrates all this.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8.4](#ch08fig04)展示了所有这些内容。'
- en: Figure 8.4\. How the pieces of the simple Angular app fit together
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.4\. 简单Angular应用程序的各个部分是如何组合在一起的
- en: '![](Images/08fig04_alt.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig04_alt.jpg)'
- en: This information gives you a good understanding of how this simple app is constructed.
    But when you viewed the source in the browser earlier, none of the files you looked
    at were referenced, and you saw a few JavaScript files. What’s going on? How did
    the TypeScript files become JavaScript in the browser?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息让你对如何构建这个简单的应用程序有了很好的理解。但是，当你之前在浏览器中查看源代码时，你查看的所有文件都没有被引用，你看到了一些JavaScript文件。发生了什么？TypeScript文件是如何在浏览器中变成JavaScript的？
- en: The Angular build process
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Angular 构建过程
- en: Currently, browsers don’t support TypeScript—only JavaScript—and some don’t
    fully support even ES2015 yet. But writing in TypeScript gives you more-robust
    code. And although this sample application is small, you can look into the future
    a little bit and see that if you have an application with several components,
    you have a lot of separate files to deal with. You don’t want to have to specify
    all these files in your HTML source.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，浏览器不支持 TypeScript——只支持 JavaScript——而且一些浏览器甚至还没有完全支持 ES2015。但是使用 TypeScript
    可以编写更健壮的代码。尽管这个示例应用程序很小，但您可以展望未来，看看如果您有一个包含多个组件的应用程序，您将有很多单独的文件需要处理。您不希望在您的 HTML
    源代码中指定所有这些文件。
- en: Angular deals with these issues by using a *build* process to take all the separate
    TypeScript files, convert them to vanilla JavaScript, and put them in one file
    called main.bundle.js. If you look at the sources in the browser, you’ll be able
    to find `title = 'loc8r-public'` there, as shown in [figure 8.5](#ch08fig05).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 通过使用 *构建* 过程来处理这些问题，将所有单独的 TypeScript 文件合并，将它们转换为纯 JavaScript，并将它们放入一个名为
    main.bundle.js 的文件中。如果您查看浏览器中的源代码，您将能够找到 `title = 'loc8r-public'`，如图 8.5 所示。
- en: Figure 8.5\. Finding the component definition inside the built JavaScript code
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.5\. 在构建的 JavaScript 代码中找到组件定义
- en: '![](Images/08fig05_alt.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/08fig05_alt.jpg)'
- en: At the moment, you’re using the `ng serve` command to compile, build, and deliver
    the Angular application to the browser on port 4200\. This command runs in memory;
    you won’t find these built files inside the application code anywhere. When it
    comes to building a final version, you’ll use a different command, `ng build`.
    More on that later.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，您正在使用 `ng serve` 命令来编译、构建并将 Angular 应用程序交付到浏览器上的 4200 端口。此命令在内存中运行；您不会在应用程序代码的任何地方找到这些构建文件。当涉及到构建最终版本时，您将使用不同的命令，`ng
    build`。关于这一点，稍后会有更多介绍。
- en: For development, `ng serve` is perfect. It not only gives you this browser environment,
    but also watches the source code for changes and rebuilds and refreshes the application
    when it changes. You can see this in action by changing `'loc8r-app'` in src/app/app.component.ts
    to `'I am Getting MEAN!'` Head back to the application in the browser, and you’ll
    see that the content has changed, as shown in [figure 8.6](#ch08fig06).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发，`ng serve` 是完美的。它不仅为您提供了这个浏览器环境，而且还监视源代码的变化，并在变化时重新构建和刷新应用程序。您可以通过将 src/app/app.component.ts
    中的 `'loc8r-app'` 更改为 `'I am Getting MEAN!'` 来看到这一功能的效果。回到浏览器中的应用程序，您会看到内容已经改变，如图
    8.6 所示。
- en: Figure 8.6\. `ng serve` rebuilds and reloads the application when the source
    code changes.
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.6\. 当源代码发生变化时，`ng serve` 会重新构建和重新加载应用程序。
- en: '![](Images/08fig06.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/08fig06.jpg)'
- en: '`ng serve` helps in the development process by eliminating the need to build
    and refresh manually with every change.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`ng serve` 通过消除每次更改时手动构建和刷新的需求，帮助开发过程。'
- en: Now that you know enough about Angular to be dangerous, you’ll make the move
    into building something for Loc8r. You’ll uncover more about Angular and TypeScript
    as you go, and everything will start to become more familiar.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对 Angular 的了解已经足够深入，可以开始为 Loc8r 构建一些内容了。随着您的深入，您将了解更多关于 Angular 和 TypeScript
    的知识，并且一切都将变得更加熟悉。
- en: 8.2\. Working with Angular components
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2\. 使用 Angular 组件
- en: You’ll start by building the listing section of the homepage, which you’ll embed
    in the Express application. It’s an example of how you can add some Angular functionality
    to an existing site, which is a common requirement on large enterprise sites where
    you’re not likely to have complete control of everything. In the following chapters,
    you’ll build on this foundational knowledge and see how to build a standalone
    single-page application (SPA) in Angular.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您将从构建主页的列表部分开始，您将将其嵌入到 Express 应用程序中。这是一个示例，说明您如何向现有网站添加一些 Angular 功能，这在大型企业网站上是一个常见的需求，在这些网站上您可能无法完全控制所有内容。在接下来的章节中，您将在此基础上构建知识，并了解如何在
    Angular 中构建独立的单页应用程序（SPA）。
- en: Begin by creating a new component.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个新的组件。
- en: 8.2.1\. Creating a new home-list component
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.1\. 创建一个新的 home-list 组件
- en: 'You can create all the files manually, or you can use the Angular CLI. You’ll
    take advantage of the CLI to create a skeleton component. In terminal, from within
    the app_public folder, run the following command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以手动创建所有文件，或者可以使用 Angular CLI。您将利用 CLI 来创建一个组件骨架。在终端中，在 app_public 文件夹内，运行以下命令：
- en: '[PRE7]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This command creates a new folder called home-list within the src folder. Create
    the TypeScript, HTML, and CSS files inside it, and also update the app.module.ts
    file to tell the module about the new component. You’ll also see a spec.ts file
    in the new component folder. This file is a template for unit testing, but we’re
    not covering it here, so you can ignore it for now. Angular CLI outputs into terminal
    confirmations of all these actions.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令在 src 文件夹内创建一个名为 home-list 的新文件夹。在其内部创建 TypeScript、HTML 和 CSS 文件，并更新 app.module.ts
    文件以通知模块关于新组件的信息。你还会在新的组件文件夹中看到一个 spec.ts 文件。此文件是单元测试的模板，但我们在这里不涉及它，所以你现在可以忽略它。Angular
    CLI 将所有这些操作的确认输出到终端。
- en: Making it the default component
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设置为默认组件
- en: The new `home-list` component will be the basis for this Angular module, so
    you need to make it the default component. You do this inside the app.module.ts
    file by changing the bootstrap value inside the module decorator from `AppComponent`
    to `HomeListComponent`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `home-list` 组件将是此 Angular 模块的基础，所以你需要将其设置为默认组件。你可以在 app.module.ts 文件中通过更改模块装饰器中的
    bootstrap 值从 `AppComponent` 更改为 `HomeListComponent` 来完成此操作。
- en: '`AppComponent` is no longer needed, so you can remove the import statement,
    remove it from the declarations, and even delete the files. The changes to app.module.ts
    are shown in the following listing.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppComponent` 不再需要，所以你可以删除导入语句，从声明中删除它，甚至删除文件。app.module.ts 的更改如下所示。'
- en: Listing 8.4\. Changing to the new component in app.module.ts
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.4\. 在 app.module.ts 中更改到新组件
- en: '[PRE8]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* This line was added by the Angular CLI; delete the AppComponent import,
    as it’s no longer needed.**'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这一行是由 Angular CLI 添加的；删除 AppComponent 导入，因为它不再需要。**'
- en: '***2* Deletes AppComponent from the declarations array**'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从声明数组中删除 AppComponent**'
- en: '***3* Changes AppComponent to HomeListComponent for the bootstrap value**'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将 bootstrap 值的 AppComponent 更改为 HomeListComponent**'
- en: 'If you run `ng serve` or still have it running, you’ll see a blank page displayed
    in the browser window and several errors in the JavaScript console. These errors
    are a lot of red text that can seem intimidating, but the first line is helpful:
    it says, “The selector “app-home-list” did not match any elements.”'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行 `ng serve` 或者它仍在运行，你将在浏览器窗口中看到一个空白页面，并在 JavaScript 控制台中看到几个错误。这些错误是大量的红色文本，可能会显得令人畏惧，但第一行是有帮助的：它说，“选择器“app-home-list”没有匹配任何元素。”
- en: If you think back to the original component, you’ll remember that `selector`
    defines the tag on the page that the component will bind to. You’ve changed the
    component but not the tag on the page!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾一下原始组件，你会记得 `selector` 定义了组件将绑定到的页面上的标签。你已经更改了组件，但没有更改页面上的标签！
- en: Setting the HTML tag for the component
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设置组件的 HTML 标签
- en: 'To ensure that you use the right tag, open the home-list.component.ts file,
    and check out the component decorator, which should look something like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你使用正确的标签，打开 home-list.component.ts 文件，查看组件装饰器，它应该看起来像这样：
- en: '[PRE9]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here, you can see that the selector is `app-home-list`, so that’s what you
    need to use. You could change it if you want to have a different naming convention,
    but this will work. Open the index.html file in the src folder, and change the
    app-root tag to app-home-list so that it looks like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到选择器是 `app-home-list`，所以这就是你需要使用的。如果你想有不同的命名约定，你可以更改它，但这会工作。打开 src 文件夹中的
    index.html 文件，将 app-root 标签更改为 app-home-list，使其看起来像这样：
- en: '[PRE10]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now check the browser—from now on, we’ll assume you have `ng serve` running
    whenever you check out the browser—and see that the page has changed to say `home-list
    works!`, as shown in [figure 8.7](#ch08fig07).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在检查浏览器——从现在开始，我们将假设你在检查浏览器时总是运行着 `ng serve` ——你会看到页面已经改变，显示 `home-list works!`，如图
    8.7 所示。
- en: Figure 8.7\. Confirmation that the new `home-list` component is working as the
    default in the application
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.7\. 确认新的 `home-list` 组件作为默认组件在应用程序中工作
- en: '![](Images/08fig07.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig07.jpg)'
- en: Now that your component is there, you can start working on making it look like
    it should.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的组件已经准备好了，你可以开始工作，使其看起来应该的样子。
- en: 8.2.2\. Creating the HTML template
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.2\. 创建 HTML 模板
- en: Using an approach similar to how you built the Express application, you’ll start
    by creating some static HTML with hardcoded data. This way, you make sure that
    everything is working properly before you try to get the data from the API.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与构建 Express 应用程序类似的方法，你将首先创建一些静态 HTML，并使用硬编码的数据。这样，你就可以确保在尝试从 API 获取数据之前，一切都在正常工作。
- en: Fortunately, you’ve already created the markup and the styles for this component;
    now, you need to transfer them to Angular.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你已经为这个组件创建了标记和样式；现在，你需要将它们转移到 Angular 上。
- en: Getting the HTML markup
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 获取 HTML 标记
- en: You can’t copy and paste the HTML directly from the Express source code, because
    it’s in Pug format and also is templated to use data bindings. For now, you want
    the full HTML, including data.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能直接从 Express 源代码复制粘贴 HTML，因为它是以 Pug 格式编写的，并且也是模板化的，以使用数据绑定。目前，你想要完整的 HTML，包括数据。
- en: 'The easiest way to get the HTML is to run the Express app and go to the homepage
    in a browser. Different browsers have slightly different ways of getting the HTML
    but are similar to the following procedure in Chrome:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 获取 HTML 的最简单方法是运行 Express 应用程序，并在浏览器中转到主页。不同的浏览器获取 HTML 的方法略有不同，但与以下 Chrome
    中的步骤相似：
- en: Right-click in the HTML area, and choose Inspect Element from the contextual
    menu.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 HTML 区域右键单击，并在上下文菜单中选择检查元素。
- en: Highlight the `<div class="card">` element.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 高亮显示 `<div class="card">` 元素。
- en: Select Copy, and then Copy Outer HTML.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择复制，然后复制外部 HTML。
- en: Paste this into home-list.component.html, replacing the existing contents, and
    you should see something like the following.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 将此内容粘贴到 home-list.component.html 中，替换现有内容，你应该会看到以下内容。
- en: Listing 8.5\. Some static HTML for home-list.component.html to get started
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.5\. 用于 home-list.component.html 的某些静态 HTML 以开始
- en: '[PRE11]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you take a look in the browser when this is saved, you’ll be able to see
    the contents, but it won’t look nice. You need to add the styles.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在浏览器中查看保存后的内容，你将能够看到内容，但看起来不会很好。你需要添加样式。
- en: Bringing in the styles
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 引入样式
- en: Like the HTML, the CSS styles already exist in the Express application; you
    only need to access them. You could update the index.html file to access them
    directly from localhost:3000, but certain browsers give you a CORS warning if
    you try, because the Angular development app and the Express app are running on
    different ports. See the sidebar “[What is CORS?](#ch08sb03)” if this term is
    new to you.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 与 HTML 一样，CSS 样式已经存在于 Express 应用程序中；你只需要访问它们。你可以更新 index.html 文件，直接从 localhost:3000
    访问它们，但某些浏览器在尝试时可能会给出 CORS 警告，因为 Angular 开发应用程序和 Express 应用程序在不同的端口上运行。如果你对这个术语不熟悉，请参阅侧边栏“[什么是
    CORS？](#ch08sb03)”。
- en: '|  |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**What is CORS?**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是 CORS？**'
- en: Browsers aren’t allowed to access or request certain resources from a different
    domain, including requesting font files and making AJAX calls. This policy is
    known as the *same-origin policy*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器不允许从不同域名访问或请求某些资源，包括请求字体文件和进行 AJAX 调用。这项政策被称为*同源策略*。
- en: '*CORS* (cross-origin resource sharing) is a mechanism that allows this to happen
    but can be set only from the server that hosts the resources. If the server denies
    you, there’s nothing you can do from the browser side to change it.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*CORS*（跨源资源共享）是一种允许这种情况发生的机制，但只能从托管资源的服务器设置。如果服务器拒绝，从浏览器端无法做任何事情来改变它。'
- en: '|  |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: To allow access to the resources, the server must be set to respond with a new
    HTTP header called `Access-Control-Allow-Origin`, with a value that matches the
    requesting domain.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要允许访问资源，服务器必须设置为响应一个名为 `Access-Control-Allow-Origin` 的新 HTTP 标头，其值与请求域名匹配。
- en: Not all browsers give a CORS warning for a different port, but to avoid the
    problem altogether, grab all the styles and fonts, and drop them into the Angular
    app. Copy the webfonts, stylesheets, and js folders from /public folder, and paste
    them into the src/assets folder in app_public.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有浏览器都会为不同端口提供 CORS 警告，但为了避免这个问题，获取所有样式和字体，并将它们放入 Angular 应用程序中。从 /public
    文件夹复制 webfonts、stylesheets 和 js 文件夹，并将它们粘贴到 app_public 中的 src/assets 文件夹。
- en: Next, reference these CSS and JS files in the index.html file (in app_public),
    as shown in the following listing. Notice that you’re also adding the references
    for the bootstrap dependencies.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 index.html 文件（在 app_public 中）中引用这些 CSS 和 JS 文件，如下所示。注意，你还在添加对 bootstrap
    依赖项的引用。
- en: Listing 8.6\. Adding the CSS files to index.html for the Angular app
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.6\. 将 CSS 文件添加到 index.html 以供 Angular 应用程序使用
- en: '[PRE12]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With the styles in place, you can look at the browser and see something like
    [figure 8.8](#ch08fig08).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 添加样式后，你可以在浏览器中看到类似[图 8.8](#ch08fig08)的东西。
- en: Figure 8.8\. The Angular app displaying static content and using the styles
    and fonts
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.8\. 显示静态内容并使用样式和字体的 Angular 应用程序
- en: '![](Images/08fig08.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/08fig08.jpg)'
- en: '|  |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: When you’re building an application to sit inside another page, as you are here,
    the application uses the CSS of that containing page. The copies of the stylesheets
    you have here are for development use only, so your module looks right as you
    build it. When you’re building an SPA, however, the final application uses the
    stylesheets inside the Angular app.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建一个要嵌入另一个页面中的应用程序时，就像你现在这样，该应用程序使用包含页面的CSS。你这里拥有的样式表副本仅用于开发，所以你的模块在构建时看起来是正确的。然而，当你构建一个SPA时，最终的应用程序使用Angular应用程序内部的样式表。
- en: '|  |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Now that you’ve got your homepage component looking about right, you’re ready
    to move on to making the HTML smarter by moving the hardcoded data out.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经让你的主页组件看起来大致正确，你就可以继续通过将硬编码的数据移出，使HTML更智能。
- en: 8.2.3\. Moving data out of the template into the code
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.3\. 将数据从模板移到代码中
- en: 'As you saw earlier in this chapter, with Angular, you can define a class member
    inside the component code and bind it to the HTML by using curly braces. You could
    add this to home-list.component.ts to define the name of a location:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本章前面看到的，使用Angular，你可以在组件代码中定义一个类成员，并通过使用花括号将其绑定到HTML。你可以在home-list.component.ts中添加此内容来定义位置名称：
- en: '[PRE13]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then you could have this display in the HTML by replacing the location name
    with the binding, as shown in bold here:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以通过将位置名称替换为绑定，在HTML中显示此内容，如粗体所示：
- en: '[PRE14]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The result would be that the browser displays the same way as before, but now
    part of the data is coming from the code and being bound to the template; it’s
    no longer hardcoded HTML.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是浏览器以相同的方式显示，但现在数据的一部分来自代码，并被绑定到模板中；它不再是硬编码的HTML。
- en: This example is good and shows you the way forward, but you need a lot more
    data for a location and a better way to manage it. For this purpose, you need
    to use a class.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子很好，展示了前进的方向，但你需要更多关于位置的数据以及更好的管理方式。为此，你需要使用一个类。
- en: Defining a class to give structure to data
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义一个类以给数据结构化
- en: In Angular, a *class* is used to define the structure of a data object. In terms
    of what you’ve already learned, you could think of it as being similar to a simple
    Mongoose schema—essentially, a list of the pieces of data you expect an object
    to hold and the type of value.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，*类*用于定义数据对象的结构。从你已学到的内容来看，你可以将其视为类似于简单的Mongoose模式——本质上，是一个列表，列出了你期望对象持有的数据片段及其类型。
- en: The type is important. One thing that JavaScript doesn’t have is the ability
    to state what type of value can be assigned to a given variable. It’s easy to
    change the value from a string to a number to a Boolean; JavaScript doesn’t care!
    But TypeScript does care, and it can help your code be more robust by making sure
    that you’re always using the correct type of data for each variable. TypeScript
    is called *TypeScript* for a reason. See the sidebar “[Types in TypeScript](#ch08sb04)”
    for a list of available types.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 类型很重要。JavaScript没有的一项能力是声明可以分配给给定变量的值的类型。从字符串更改为数字或布尔值很容易；JavaScript不在乎！但TypeScript在乎，并且它可以通过确保你始终为每个变量使用正确的数据类型来帮助你的代码更加健壮。TypeScript之所以被称为*TypeScript*，是有原因的。请参阅侧边栏“[TypeScript中的类型](#ch08sb04)”以获取可用类型的列表。
- en: '|  |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Types in TypeScript**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**TypeScript中的类型**'
- en: 'The different data types that TypeScript accepts are as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript接受的不同的数据类型如下：
- en: '**`String`—** Text values.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`String`—** 文本值。'
- en: '**`number`—** Any numerical value; integers and decimals are treated the same
    way.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`number`—** 任何数值；整数和小数被同等对待。'
- en: '**`boolean`—** True or false.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`boolean`—** 真或假。'
- en: '**`Array`—** An array of a given type of data.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`Array`—** 指定类型数据的数组。'
- en: '**`enum`—** A way of giving friendly names to a set of numeric values.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`enum`—** 给一组数值命名友好名称的方式。'
- en: '**`Any`—** This data type can be anything, like how JavaScript is by default.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`Any`—** 此数据类型可以是任何东西，就像JavaScript默认那样。'
- en: '**`Void`—** The absence of a type, typically used for functions that don’t
    return anything.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`Void`—** 没有类型，通常用于不返回任何内容的函数。'
- en: '|  |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Defining a class is a simple task, and you’ll do it at the top of the home-list.component.ts
    file, after the initial `import` statement but before the component decorator.
    To define a class and make it accessible, export it; give it a name; and then
    list the names of the data items along with their expected data types.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个类是一个简单的任务，你将在home-list.component.ts文件的顶部执行此操作，在初始`import`语句之后但在组件装饰器之前。为了定义一个类并使其可访问，导出它；给它一个名字；然后列出数据项的名称及其预期的数据类型。
- en: Listing 8.7\. Defining the `Location` class in home-list.component.ts
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.7\. 在home-list.component.ts中定义`Location`类
- en: '[PRE15]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* Creates and exports a class called Location**'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建并导出一个名为Location的类**'
- en: '***2* Defines the class members and their types . . .**'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 定义类成员及其类型 . . .**'
- en: '***3* . . . including an array of strings**'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* . . . 包括字符串数组**'
- en: With this done, you’ve defined the data you expect to see in your location objects.
    In fact—and this is important—each object defined with the class `Location` *must*
    have a value for each item specified.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，你已定义了你期望在位置对象中看到的数据。事实上——这很重要——使用`Location`类定义的每个对象*必须*为每个指定项提供一个值。
- en: Now that you’ve defined a class, you’re ready to use it.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了一个类，你就可以使用它了。
- en: Creating an instance of the location class
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建位置类的实例
- en: 'When declaring variables and class members in TypeScript, you should state
    the type of data as well as the name, as you did when defining the properties
    of the `Location` class. Use the format `variableName: variableType = variableValue`.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '在TypeScript中声明变量和类成员时，你应该声明数据类型以及名称，就像你在定义`Location`类的属性时做的那样。使用格式`variableName:
    variableType = variableValue`。'
- en: 'When you added `name = ''Costy''` to the `home-list` component to try it out,
    for example, you should have added `name: string = ''Costy''` instead. This code
    would have told TypeScript that `name` should only ever be a string value.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，当你向`home-list`组件添加`name = ''Costy''`来尝试它时，你应该添加`name: string = ''Costy''`而不是。这段代码会告诉TypeScript，`name`应该始终是字符串值。'
- en: You do the same when creating a variable or class member that’s an instance
    of a class, but in this case stating that the type is the name of the class. [Listing
    8.8](#ch08ex08) shows how to add a `location` class member with the type `Location`
    to the `home-list` component, giving it all the values it needs. The common way
    to describe this is to say that *`location` is an instance of type `Location`*.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个类的实例或类成员变量时，你也会这样做，但在这个情况下，你需要声明类型是类的名称。[列表8.8](#ch08ex08)展示了如何向`home-list`组件添加一个类型为`Location`的`location`类成员，给它所有需要的值。通常我们会说，*`location`是类型`Location`的实例*。
- en: Listing 8.8\. Defining a `location` with the `Location` class in home-list.component.ts
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.8\. 在home-list.component.ts中使用`Location`类定义`location`
- en: '[PRE16]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A little later, you’ll look at `constructor` and `ngOnInit`, seeing why they’re
    there and what they can be used for. For now, you can ignore them and focus on
    the new class member you’ve created. That’s got all the data you need for one
    of the homepage listings, so next, you’ll use this data in the HTML.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，你将查看`constructor`和`ngOnInit`，了解它们为什么存在以及它们可以用来做什么。现在，你可以忽略它们，专注于你创建的新类成员。这个类成员包含了你需要用于主页列表的所有数据，所以接下来，你将在HTML中使用这些数据。
- en: 8.2.4\. Using class member data in the HTML template
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.4\. 在HTML模板中使用类成员数据
- en: As a quick recap, you’ve already seen how to bind data exposed from the component
    class in the HTML template by using curly braces—as in `{{title}}`. Now your data
    is a little more complex, and you need to access the properties of the class member,
    which you can do by using the standard JavaScript dot syntax. `location.name`,
    for example, gives you the value of the `name` property.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 快速回顾一下，你已经看到了如何通过使用花括号在HTML模板中绑定从组件类暴露的数据——就像`{{title}}`这样。现在你的数据稍微复杂一些，你需要访问类成员的属性，这可以通过使用标准的JavaScript点语法来实现。例如，`location.name`会给你`name`属性的值。
- en: The next listing highlights some of the quick and easy changes to make to the
    HTML template to bring the data in.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表突出了对HTML模板进行的一些快速简单的更改，以便引入数据。
- en: Listing 8.9\. Binding the first pieces of data in home-list.component.html
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.9\. 在home-list.component.html中绑定第一份数据
- en: '[PRE17]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, you have four single pieces of data being bound into the HTML template.
    The facilities and the star rating are going to take a bit more work. Start with
    the facilities, and loop through an array of data.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你有四条单独的数据被绑定到HTML模板中。设施和星级评分需要更多的工作。从设施开始，遍历数据数组。
- en: 'Facilities: Looping through an array of items in an HTML template'
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设施：在HTML模板中遍历项目数组
- en: 'In the TypeScript file, you defined facilities as an array of strings, like
    this: `[''hot drinks'', ''food'', ''power'']`. Now you’ll see how Angular can
    help you loop through these strings and create a `span` tag for each facility
    in the array.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript文件中，你将设施定义为字符串数组，如下所示：`['hot drinks', 'food', 'power']`。现在你将看到Angular如何帮助你遍历这些字符串，并为数组中的每个设施创建一个`span`标签。
- en: The secret is to use an Angular directive called `*ngFor`. When applied to a
    HTML tag and given an array of data, it loops through the array, creating an element
    for each entry. To access the value or properties of each item, you need to define
    a variable that Angular can use as it goes through the loop.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 秘诀是使用一个名为 `*ngFor` 的 Angular 指令。当应用于 HTML 标签并给定一个数据数组时，它会遍历数组，为每个条目创建一个元素。要访问每个项的值或属性，你需要定义一个
    Angular 在遍历过程中可以使用的变量。
- en: The following listing shows how to use the `*ngFor` directive to loop through
    the l`ocation.facilities` array, assigning and using the variable `facility` to
    access the value.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了如何使用 `*ngFor` 指令遍历 `location.facilities` 数组，分配并使用变量 `facility` 来访问值。
- en: Listing 8.10\. Using `*ngFor` to loop through an array in home-list.component.html
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.10\. 在 home-list.component.html 中使用 `*ngFor` 遍历数组
- en: '[PRE18]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `*` is important, because without it, Angular won’t perform the loop. With
    the `*`, it repeats the `<span>` and everything in it. Given the data facilities
    `['hot drinks', 'food', 'power']`, the output is
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`*` 符号很重要，因为没有它，Angular 不会执行循环。有了 `*`，它会重复 `<span>` 以及其中的所有内容。给定数据设施 `[''hot
    drinks'', ''food'', ''power'']`，输出如下'
- en: '[PRE19]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that Angular creates some additional comments and tag attributes, which
    you can see in [figure 8.9](#ch08fig09), along with the output in the browser.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Angular 创建了一些额外的注释和标签属性，你可以在 [图 8.9](#ch08fig09) 中看到，以及浏览器中的输出。
- en: Figure 8.9\. The output of Angular looping through the array of facilities
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.9\. Angular 遍历设施数组的输出
- en: '![](Images/08fig09_alt.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig09_alt.jpg)'
- en: Now that the facilities are done, you can move on to the rating stars.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在设施已经完成，你可以继续处理评分星号。
- en: 'Rating stars: Using Angular expressions to set CSS classes'
  id: totrans-241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 评分星号：使用 Angular 表达式设置 CSS 类
- en: 'So far, the data bindings you’ve used have been simple: one variable name or
    property within the double curly braces. With Angular, you can also use simple
    expressions inside a binding. You could join two strings by using `{{ ''Getting
    '' + ''MEAN'' }}` or perform a simple math operation with `{{ Math.floor(14.65)
    }}`.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你使用的数据绑定都很简单：双大括号内的一个变量名或属性。使用 Angular，你还可以在绑定中使用简单的表达式。你可以使用 `{{ 'Getting
    ' + 'MEAN' }}` 来连接两个字符串，或者使用 `{{ Math.floor(14.65) }}` 来执行简单的数学运算。
- en: 'For the rating stars, each star is defined with a Font Awesome class: `.fas.fa-star`
    for a solid star and `.far.fa-star` for an outline. You want to set the classes
    by using Angular, making sure that you have the correct number of solid and hollow
    stars to convey the rating.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 对于评分星号，每个星号都使用 Font Awesome 类定义：`.fas.fa-star` 用于实心星号，`.far.fa-star` 用于轮廓。你想要使用
    Angular 设置这些类，确保你有正确数量的实心和空心星号来传达评分。
- en: 'To achieve this task, you’ll use a JavaScript ternary operator, which is shorthand
    for a simple `if` / `else` expression. Using the first star as an example, you
    want to say, “If the rating is less than 1, make the star hollow; otherwise, make
    it solid.” Example code:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个任务，你需要使用 JavaScript 三元运算符，它是简单 `if` / `else` 表达式的简写。以第一个星号为例，你想要表达的是：“如果评分小于
    1，则使星号空心；否则，使它实心。” 示例代码：
- en: '[PRE20]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Translated into a ternary operator, the same expression looks like this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为三元运算符，相同的表达式看起来是这样的：
- en: '[PRE21]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Flowing this logic through into the `<i>` tags that make up the rating stars
    and putting the expressions into Angular bindings results in something that looks
    like the next listing. Note that each expression has a different number to show
    the correct stars and that you’re always outputting `fa-star`, so you’ve taken
    it out of the expression.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 将此逻辑应用到构成评分星号的 `<i>` 标签中，并将表达式放入 Angular 绑定中，结果如下所示。注意，每个表达式都有一个不同的数字来显示正确的星号，而且你总是输出
    `fa-star`，所以你将其从表达式中移除了。
- en: Listing 8.11\. Binding the ternary expressions to generate ratings-stars classes
  id: totrans-249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.11\. 绑定三元表达式以生成 ratings-stars 类
- en: '[PRE22]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can validate that this code is working correctly in the browser, and you’ll
    see something like [figure 8.10](#ch08fig10).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在浏览器中验证此代码是否正确运行，你将看到类似 [图 8.10](#ch08fig10) 的内容。
- en: Figure 8.10\. Showing the rating stars correctly, using Angular expression bindings
    to generate the correct class
  id: totrans-252
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.10\. 正确显示评分星号，使用 Angular 表达式绑定生成正确的类
- en: '![](Images/08fig10_alt.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig10_alt.jpg)'
- en: 'Looking good! You have one more piece of data to deal with: the distance.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错！你还有另一份数据要处理：距离。
- en: Formatting data using pipes
  id: totrans-255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用管道格式化数据
- en: Angular gives you a way to format data within the binding, using what are known
    as *pipes*. For those familiar with AngularJS, pipes used to be called *filters*.
    Angular has several built-in pipes, including date and currency formatting, as
    well as uppercase, lowercase, and title-case string transformations.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 提供了一种在绑定中格式化数据的方法，使用的是所谓的 *管道*。对于那些熟悉 AngularJS 的人来说，管道过去被称为 *过滤器*。Angular
    有几个内置的管道，包括日期和货币格式化，以及大写、小写和标题化字符串转换。
- en: 'You apply pipes inside a binding by adding the pipe character (`|)` after the
    variable or expression to be bound, followed by the name of the pipe. If you want
    to display the address of a location in uppercase, for example, you could add
    the uppercase binding like this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在绑定内部应用管道是通过在要绑定的变量或表达式后添加管道字符（`|`），然后跟管道名称来实现的。如果你想以大写形式显示一个位置的地址，例如，你可以添加大写绑定如下：
- en: '[PRE23]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You don’t want to do that, but you could if you wanted to!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不想这样做，但如果你愿意的话可以！
- en: A pipe that can be useful for debugging is the JSON pipe, which turns a JSON
    object into a string so that it can be displayed in the browser. If you aren’t
    sure what data is coming through in the `location` object, you could temporarily
    bind to it somewhere in the HTML and add the JSON pipe.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对调试有用的管道是 JSON 管道，它将一个 JSON 对象转换为字符串，以便在浏览器中显示。如果你不确定 `location` 对象中通过的数据是什么，你可以在
    HTML 中的某个地方临时绑定到它并添加 JSON 管道。
- en: 'Some pipes can take options to define how they work. Take the currency pipe,
    for example. You can apply the currency pipe without any options, like this:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 一些管道可以接受选项来定义它们的工作方式。以货币管道为例。你可以不带任何选项地应用货币管道，如下所示：
- en: '[PRE24]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This pipe assumes a default currency of US dollars and rounds the digit up to
    the nearest cent. In this example, the output would be `USD12.35`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这个管道假设默认货币为美元，并将数字四舍五入到最接近的美分。在这个例子中，输出将是 `USD12.35`。
- en: You can apply options to this pipe to change the currency and display the symbol
    instead of the currency code. Pipe options are specified directly after the pipe
    name, separated by colons. The order of the options is important. The first option
    for the currency pipe is the currency code itself, to change the currency; the
    second option is a Boolean to state whether to display the symbol.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向这个管道应用选项来更改货币并显示符号而不是货币代码。管道选项直接跟在管道名称后面，由冒号分隔。选项的顺序很重要。货币管道的第一个选项是货币代码本身，用于更改货币；第二个选项是一个布尔值，用于表示是否显示符号。
- en: 'If you wanted to display the currency as Euros, for example, and show the symbol
    instead of the code, you could use the pipe like this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要以欧元的形式显示货币，例如，并显示符号而不是代码，你可以像这样使用管道：
- en: '[PRE25]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This pipe would output `€12.35`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这个管道将输出 `€12.35`。
- en: That’s how pipes work, and you’ll work with some other default pipes as you
    build the Loc8r application. Now you need to format the distance into meters or
    kilometers, and for that purpose, you need to create a custom pipe.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是管道的工作方式，在你构建 Loc8r 应用程序的过程中，你将使用一些其他默认的管道。现在你需要将距离格式化为米或千米，为此，你需要创建一个自定义管道。
- en: 'Distances: Creating a custom pipe'
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 距离：创建一个自定义管道
- en: Before you create a new pipe to format the distance, make sure the data you’re
    passing it reflects what you’ll get from the API. In your current mocked-up data,
    you’ve got `14.0` so that the distance number displays nicely. But the API returns
    the distance in meters, so update the distance in home-list.component.ts to reflect
    this fact—`14000.1234`, for example.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在你创建一个新的管道来格式化距离之前，确保传递给它的数据反映了你将从 API 获得的数据。在你的当前模拟数据中，你有 `14.0` 以确保距离数字显示得很好。但是
    API 返回的是米，所以更新 home-list.component.ts 中的距离以反映这一事实——例如 `14000.1234`。
- en: 'To create the boilerplate files for a custom pipe, you can use the Angular
    CLI. In terminal, from the app_public folder, run the following command:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要为自定义管道创建模板文件，你可以使用 Angular CLI。在终端中，从 app_public 文件夹运行以下命令：
- en: '[PRE26]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This command generates two new files—distance.pipe.ts and distance.pipe.spec.ts—in
    the src/app folder. The CLI adds the import to the app.module.ts file. If you
    want to move your pipe files somewhere else, such as into a subfolder, you’d have
    to update app.module.ts to say where they were moved. Leave them where they are
    for now.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令在 src/app 文件夹中生成两个新文件——distance.pipe.ts 和 distance.pipe.spec.ts。CLI 将导入添加到
    app.module.ts 文件中。如果你想要将管道文件移动到其他地方，例如子文件夹中，你必须更新 app.module.ts 来指定它们的新位置。现在先让他们留在原地。
- en: 'The boilerplate pipe file, distance.pipe.ts, looks like this:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 模板管道文件，distance.pipe.ts，看起来是这样的：
- en: '[PRE27]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This structure should be starting to look familiar. You’ve got the imports at
    the top, followed by the decorator, with the export class at the end. It’s the
    contents of the class that you’re interested in here—in particular, that `transform`
    function.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构应该开始看起来熟悉了。你顶部有导入，然后是装饰器，最后是导出类。你在这里感兴趣的是类的内容——特别是那个`transform`函数。
- en: 'At first glance, this code looks a bit odd and somewhat complicated, with all
    the colons and `any` all over the place. But this code is TypeScript doing what
    it does: defining the types for variables. The contents of the parentheses (`value:
    any, args?: any)` is saying that the function *accepts* a parameter `value` of
    any type and other arguments of any type. The third `: any`, after the parentheses,
    is defining the type of the *return* value of the function.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '初看，这段代码看起来有点奇怪，有些复杂，到处都是冒号和`any`。但这是TypeScript在执行它的工作：为变量定义类型。括号内的内容（`value:
    any, args?: any`）表示该函数*接受*任何类型的参数`value`和其他任何类型的参数。括号后面的第三个`: any`定义了函数的*返回*值的类型。'
- en: 'You want to change these, as your distance function will accept a number and
    return a string. To do so, update the `transform` function like this:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要更改这些，因为你的距离函数将接受一个数字并返回一个字符串。为此，更新`transform`函数如下：
- en: '[PRE28]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that you’ve changed the name of the parameter to `distance`. You’ve already
    written the code to format the distance in Node, so you can copy it from /app_server/controllers/locations.js
    and paste it here. You want the `isNumeric` helper along with the contents of
    the `formatDistance` function. When that’s done, the `transform` function looks
    like the following.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你已经将参数的名称更改为`distance`。你已经在Node中编写了格式化距离的代码，所以你可以从`/app_server/controllers/locations.js`复制它并粘贴到这里。你需要`isNumeric`辅助函数以及`formatDistance`函数的内容。完成这些后，`transform`函数看起来如下。
- en: Listing 8.12\. Creating the distance format pipe in distance.pipe.ts
  id: totrans-281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.12\. 在distance.pipe.ts中创建距离格式化管道
- en: '[PRE29]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Note that all the code, including the helper function, is inside the `transform`
    function. All that’s left now is to update the binding to use your new pipe and
    remove the `km` from the template. The following snippet shows the updated binding
    from home-list.component.html:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有代码，包括辅助函数，都在`transform`函数内部。现在剩下的只是更新绑定以使用你的新管道，并从模板中删除`km`。以下是从home-list.component.html中更新的绑定片段：
- en: '[PRE30]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can also check this out in the browser (see [figure 8.11](#ch08fig11)).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在浏览器中查看这个（见[图8.11](#ch08fig11)）。
- en: Figure 8.11\. Using the Angular pipe to format the distance supplied in meters
  id: totrans-286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.11\. 使用Angular管道格式化以米为单位的距离
- en: '![](Images/08fig11_alt.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig11_alt.jpg)'
- en: Play around with the data in the component definition, and test that it displays
    as you think it should. This looks good, and you’ve got all the data bindings
    set with all the data being supplied by the component definition. This is a single
    item, however, and your API will return an array of multiple items; it is a list,
    after all! In the next section, you’ll update it to work as a list.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件定义中玩转数据，并测试它是否按你想象的方式显示。看起来不错，你已经设置了所有数据绑定，所有数据都是由组件定义提供的。然而，这是一个单独的项目，你的API将返回多个项目的数组；毕竟，它是一个列表！在下一节中，你将更新它以作为列表工作。
- en: Working with multiple instances of a class
  id: totrans-289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 与类的多个实例一起工作
- en: 'The data for your single location is defined as `location` of type `Location`.
    Don’t read that out loud! The construct, without data, looks like this:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你单个位置的数据定义为`location`类型`Location`。不要大声读出来！没有数据时，结构看起来像这样：
- en: '[PRE31]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When you get the data from the API, however, this will be an array, so you
    need to define an array of objects of type `Location`. The way to do this is to
    add square brackets after the class name so that it looks like this construct:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从API获取数据时，这将会是一个数组，因此你需要定义一个类型为`Location`的对象数组。这样做的方法是在类名后面添加方括号，使其看起来像这样的结构：
- en: '[PRE32]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If you take this approach (note that you change the member name to the plural
    `locations`, as you’re dealing with an array) and update your `home-list` component
    to contain two locations, the result looks like the following.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你采取这种方法（注意你将成员名称更改为复数`locations`，因为你正在处理一个数组）并更新你的`home-list`组件以包含两个位置，结果看起来如下。
- en: Listing 8.13\. Changing the locations instantiation to an array in home-list.component.ts
  id: totrans-295
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.13\. 在home-list.component.ts中将位置实例化改为数组
- en: '[PRE33]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Having renamed `location` to `locations` and changed the type to an array,
    you’ll need to update the HTML template. You’ve already seen how to loop through
    an array by using `*ngFor`, and this process is no different. In fact, all you
    need to do is add an `*ngFor` attribute to the outermost div of a single location—the
    one with the class of `card`. It looks like this:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`location`重命名为`locations`并更改类型为数组后，你需要更新HTML模板。你已经看到如何通过使用`*ngFor`来遍历数组，这个过程没有不同。实际上，你只需要在单个位置的最外层div（具有`card`类）上添加一个`*ngFor`属性。它看起来像这样：
- en: '[PRE34]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: By defining the instance name `location,` you don’t need to change any of the
    data bindings inside the template, because that’s what you were already using.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义实例名称`location`，你不需要更改模板内部的数据绑定，因为那正是你之前使用的。
- en: Now you have multiple items in your list, as shown in [figure 8.12](#ch08fig12).
    This is looking good and working well. The next step is removing the hardcoded
    data entirely and calling the API instead.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的列表中有多个项目，如图8.12所示。看起来不错，工作得很好。下一步是完全删除硬编码的数据，并调用API。
- en: Figure 8.12\. Updating the component to display multiple locations in a list
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.12\. 更新组件以在列表中显示多个位置
- en: '![](Images/08fig12_alt.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig12_alt.jpg)'
- en: 8.3\. Getting data from an API
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3\. 从API获取数据
- en: In this section, you’ll see how to call an API from an Angular application to
    get data. When you’ve got the data, you’ll display it instead of the hardcoded
    data you currently have.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解如何从Angular应用程序中调用API以获取数据。当你得到数据时，你将显示它而不是你目前拥有的硬编码数据。
- en: 'To interact with an API, you need to use another building block of Angular
    applications: a *service*. A service works in the background and isn’t directly
    connected to the user interface, like everything you’ve seen so far.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 要与API交互，你需要使用Angular应用程序的另一个构建块：一个*服务*。服务在后台工作，并不直接连接到用户界面，就像你迄今为止看到的一切。
- en: 8.3.1\. Creating a data service
  id: totrans-306
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.1\. 创建数据服务
- en: 'You create a service in the same way that you’ve created components and pipes
    so far: by using the Angular CLI. You use the same `ng generate` command as before,
    this time followed by the options `service` and `service name`. In the app_public
    folder, run the following command in terminal:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建服务的方式与你迄今为止创建组件和管道的方式相同：使用Angular CLI。你使用与之前相同的`ng generate`命令，这次后面跟着`service`和`service
    name`选项。在`app_public`文件夹中，在终端中运行以下命令：
- en: '[PRE35]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This command generates the files for a new service called `loc8r-data` in the
    app/src folder. Terminal confirms the creation of the files.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令在`app/src`文件夹中生成一个名为`loc8r-data`的新服务文件。终端确认文件已创建。
- en: Services are generated with a `providedIn` value passed to the `Injectable`
    decorator, which defaults to `'root'`. It takes the place of explicitly listing
    services in the providers array in your application root module, and is suitable
    for your purposes, so leave the default value as is.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 服务通过传递给`Injectable`装饰器的`providedIn`值生成，默认为`'root'`。它取代了在应用程序根模块中显式列出服务在提供者数组中的做法，适合你的目的，所以保留默认值不变。
- en: 'Before you worry about including it, look at the boilerplate code and build
    it out. The code layout should look familiar by now: imports followed by a decorator
    followed by the exported class:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在你担心包含它之前，看看模板代码并构建它。现在代码布局应该很熟悉了：导入后跟一个装饰器，然后是导出的类：
- en: '[PRE36]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This boilerplate is sparse, which isn’t surprising, because services can be
    used for many things besides requesting data from APIs. Get started by giving
    the service some of the things it needs.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板文件很简洁，这并不奇怪，因为服务除了从API请求数据之外，还可以用于许多其他事情。开始使用服务之前，给它一些它需要的东西。
- en: Enabling HTTP requests and promise handling in a service
  id: totrans-314
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在服务中启用HTTP请求和承诺处理
- en: In Angular, HTTP requests run asynchronously and return Observables, but you
    want to wait until the data is complete before working with it, so you’ll convert
    them to Promises. For a quick explanation, see the sidebar “[Observables and Promises](#ch08sb05).”
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，HTTP请求是异步运行的，并返回可观察对象，但你在处理数据之前想等待数据完成，所以你会将它们转换为承诺。为了快速解释，请参阅侧边栏“[可观察对象和承诺](#ch08sb05)。”
- en: '|  |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Observables and Promises**'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**可观察对象和承诺**'
- en: Observables and Promises are great ways of handling asynchronous requests. Observables
    return chunks of data in a stream, whereas Promises return complete sets of data.
    Angular includes the RxJS library for working with observables, including converting
    them into Promises.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: Observables和Promises是处理异步请求的绝佳方式。Observables以流的形式返回数据块，而Promises返回完整的数据集。Angular包括RxJS库来处理Observables，包括将它们转换为Promises。
- en: There’s much more to RxJS and Observables than we can cover here—enough for
    a whole book, in fact. Check out *RxJS in Action,* by Luis Atencio and Paul P.
    Daniels, to learn more ([https://www.manning.com/books/rxjs-in-action](https://www.manning.com/books/rxjs-in-action)).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 关于RxJS和Observables，我们在这里无法涵盖的内容还有很多——实际上足够写一本书。查看Luis Atencio和Paul P. Daniels所著的《RxJS
    in Action》以了解更多信息（[https://www.manning.com/books/rxjs-in-action](https://www.manning.com/books/rxjs-in-action)）。
- en: '|  |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This doesn’t mean that you can’t, or shouldn’t, use Observables—only that you
    aren’t in the sample application. If you want to see how to use Observables within
    the Loc8r application, check out [appendix C](kindle_split_038.xhtml#app03).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着你不能，或者不应该使用Observables——只是你不在示例应用程序中。如果你想了解如何在Loc8r应用程序中使用Observables，请查看[附录C](kindle_split_038.xhtml#app03)。
- en: 'To set up the service to make HTTP requests and return Promises, you need to
    inject the HTTP service into your service. You import the HTTP service by updating
    the top of the loc8r-data.service.ts file like this:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置服务以发起HTTP请求并返回Promises，你需要将HTTP服务注入到你的服务中。你通过更新`loc8r-data.service.ts`文件顶部的导入来导入HTTP服务，如下所示：
- en: '[PRE37]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The second step is injecting the `HTTPClient` service into your service so you
    can use it and call the HTTP service methods. To do this, you use the constructor
    part of the boilerplate code. A class constructor defines the parameters that
    are provided when the class is instantiated. Angular uses this to manage dependency
    injection, telling the class which other services or components it needs to run.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是将`HTTPClient`服务注入到你的服务中，这样你就可以使用它并调用HTTP服务的方法。为此，你使用样板代码的构造函数部分。类构造函数定义了在类实例化时提供的参数。Angular使用它来管理依赖注入，告诉类它需要哪些其他服务或组件来运行。
- en: 'Injecting the service is simple: you define the parameter name and its type.
    You can also state whether the service is public or private—that is, whether it
    will be accessible from outside the class or kept within it. Private is the most
    common option.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注入服务很简单：你定义参数名称和其类型。你也可以声明服务是公共的还是私有的——也就是说，它是否可以从类外部访问或保持在其内部。私有是最常见的选项。
- en: 'You inject `http` of type `HttpClient`, and keep it private by updating the
    constructor in loc8r-data.service.ts to look like this:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 你注入了类型为`HttpClient`的`http`，并通过更新`loc8r-data.service.ts`中的构造函数将其保持为私有，如下所示：
- en: '[PRE38]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, you need to ensure that the `HttpClientModule` is imported and available
    to your application. Do this by adding the following import to your app.module.ts
    file:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要确保`HttpClientModule`被导入并可供你的应用程序使用。通过在你的`app.module.ts`文件中添加以下导入来实现这一点：
- en: '[PRE39]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the same file, add the module’s name to the `imports` array in the `@NgModule`
    decorator, like so:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一文件中，将模块的名称添加到`@NgModule`装饰器中的`imports`数组中，如下所示：
- en: '[PRE40]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: With those small updates, your data service can make HTTP requests and return
    Promises.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些小的更新，你的数据服务可以发起HTTP请求并返回Promise。
- en: Creating the method to get data
  id: totrans-333
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建获取数据的方法
- en: Your service needs a public method exposed so the component can call it. At
    this point, the method doesn’t need to accept any parameters but returns a Promise
    containing an array of locations.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 你的服务需要一个公开的方法供组件调用。在这个阶段，该方法不需要接受任何参数，但返回一个包含位置数组的Promise。
- en: 'Inside the `Loc8rDataService` class, you want to define a method like this:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Loc8rDataService`类内部，你想要定义一个类似这样的方法：
- en: '[PRE41]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This is good except that your service doesn’t know what `Location` is. You
    defined and exported the `Location` class in your `home-list` component, so you
    can import that into the service by adding this line along with the other imports:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，除了你的服务不知道`Location`是什么。你在`home-list`组件中定义并导出了`Location`类，所以你可以通过添加以下行将这个类导入到服务中，与其他导入一起：
- en: '[PRE42]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now you’re ready to code the meat of your service.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好编写服务的核心代码了。
- en: Making HTTP requests
  id: totrans-340
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 发起HTTP请求
- en: 'Making the HTTP request to the API is straightforward, involving only a few
    steps:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 向API发起HTTP请求很简单，只需要几个步骤：
- en: Build the URL to call.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建要调用的URL。
- en: Tell the HTTP service to make a request for the URL.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉HTTP服务对URL发起请求。
- en: Convert the Observable response to a Promise.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Observable响应转换为Promise。
- en: Convert the response to JSON.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将响应转换为JSON。
- en: Return the response.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回响应。
- en: Catch, handle, and return errors.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕获、处理并返回错误。
- en: Putting these steps into code looks like the following listing, all of which
    is inside the `Loc8rDataService` class in loc8r-data.service.ts.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些步骤放入代码中看起来如下所示，所有这些都是位于 loc8r-data.service.ts 中的 `Loc8rDataService` 类内部。
- en: Listing 8.14\. Making and returning the HTTP request to your API in loc8r-data.service.ts
  id: totrans-349
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.14\. 在 loc8r-data.service.ts 中创建并返回 HTTP 请求
- en: '[PRE43]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '***1* Builds the URL to the API, using parameters for future enhancements**'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用参数构建 API 的 URL，以供未来增强使用**'
- en: '***2* Returns the Promise**'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 返回 Promise**'
- en: '***3* Makes the HTTP GET call to the URL you built**'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 对你构建的 URL 进行 HTTP GET 调用**'
- en: '***4* Converts the Observable response to a Promise**'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将 Observable 响应转换为 Promise**'
- en: '***5* Converts the response to a JSON object of type Location**'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将响应转换为类型为 Location 的 JSON 对象**'
- en: '***6* Handles and returns any errors**'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 处理并返回任何错误**'
- en: Note that only the method you need to call from somewhere else, `getLocations,`
    is public; everything else is defined as private so it can’t be accessed externally.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，只有你需要从其他地方调用的方法 `getLocations` 是公开的；其他所有内容都被定义为私有，因此不能从外部访问。
- en: That’s not a lot of code, but it’s doing a lot. As you’ll see is quite common
    with Angular, after you get your head around the setting up of components, classes,
    and services, a lot of the actual code can be simple, because many of the common
    tasks have had the complexities abstracted away.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是很多代码，但它做了很多事情。正如你将看到的，在 Angular 中相当常见，在你掌握了组件、类和服务的设置之后，实际的代码可以很简单，因为许多常见任务已经将复杂性抽象掉了。
- en: Now that your data service is created, it’s time to use it from your `home-list`
    component.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数据服务已经创建，是时候从 `home-list` 组件中使用它了。
- en: 8.3.2\. Using a data service
  id: totrans-360
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.2\. 使用数据服务
- en: You’re at a point where you have an Angular component that can display an array
    of locations (which are currently hardcoded), an API that can return an array
    of locations, and a service to call that API and expose the response. The missing
    link is between the component and the service.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在处于一个可以显示位置数组（目前是硬编码的）的 Angular 组件、可以返回位置数组的 API 以及调用该 API 并公开响应的服务都有的位置。缺失的环节是组件和服务之间的连接。
- en: Importing the service into the component
  id: totrans-362
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将服务导入到组件中
- en: Three steps are required to include the service in the component, all of which
    take place inside the home-list.component.ts file. You need to import the service,
    inject the service, and then provide the service.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 将服务包含到组件中需要三个步骤，所有这些步骤都在 home-list.component.ts 文件内部进行。你需要导入服务，注入服务，然后提供服务。
- en: 'First, import the service from the TypeScript file, which you do at the top
    of the component file directly below the existing import line, like this:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从 TypeScript 文件中导入服务，你需要在组件文件顶部直接在现有导入行下方进行，如下所示：
- en: '[PRE44]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note that you define a relative path to the service file with `../`, which means
    “Go up a level in the folder structure.” If you move the service files to a different
    place, you need to remember to update the references in code.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你使用 `../` 定义了服务文件的相对路径，这意味着“在文件夹结构中向上提升一级。”如果你将服务文件移动到不同的位置，你需要记住更新代码中的引用。
- en: 'The second step is injecting the service into the component, using the constructor
    as you did inside the data service itself. This time, though, you update the constructor
    in home-list.component.ts by injecting `loc8rDataService` of type `Loc8rDataService`
    and keeping it private, like this:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是将服务注入到组件中，使用与在数据服务内部相同的方式。不过，这次你通过注入 `loc8rDataService` 类型为 `Loc8rDataService`
    并将其保持为私有来更新 home-list.component.ts 中的构造函数，如下所示：
- en: '[PRE45]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: By the end, the top of the home-list.component.ts file should look like the
    following.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 到最后，home-list.component.ts 文件顶部应该看起来如下所示。
- en: Listing 8.15\. Making your service available to the component in home-list.component.ts
  id: totrans-370
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.15\. 在 home-list.component.ts 中使服务对组件可用
- en: '[PRE46]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '***1* Imports the service from the source code file**'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从源代码文件导入服务**'
- en: '***2* Injects the service into the component using the constructor**'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用构造函数将服务注入到组件中**'
- en: Now that the service is created and brought into the component, you can use
    it.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在服务已经创建并引入到组件中，你可以使用它了。
- en: Using the service to get the data
  id: totrans-375
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用服务获取数据
- en: Inside the class, create a private method to call your data service method and
    handle the Promise response. When it has the Promise response, this method can
    set the value of the locations array, which automatically updated in the HTML.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在类内部，创建一个私有方法来调用您的数据服务方法并处理Promise响应。当它有Promise响应时，此方法可以设置位置数组的值，这将在HTML中自动更新。
- en: To show that this is working, remove all the hardcoded data from the component
    and declare `locations` to be of type `Location`, with no value assigned. Pop
    the code from the next listing into the `HomeListComponent` class definition in
    home-list.component.ts.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明这是有效的，从组件中删除所有硬编码的数据，并将`locations`声明为`Location`类型，不分配任何值。将下一列表中的代码放入home-list.component.ts中的`HomeListComponent`类定义中。
- en: Listing 8.16\. Creating a function to call the data service from home-list.component.ts
  id: totrans-378
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.16\. 在home-list.component.ts中创建一个调用数据服务的函数
- en: '[PRE47]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '***1* Changes the locations declaration to have no default value**'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将位置声明更改为其没有默认值**'
- en: '***2* Defines a getLocations method that accepts no parameters and returns
    nothing**'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 定义一个不接受任何参数也不返回任何内容的getLocations方法**'
- en: '***3* Calls your data service method**'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 调用您的数据服务方法**'
- en: '***4* Updates the locations array with the contents of the response**'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用响应内容更新位置数组**'
- en: Great stuff. This code still won’t work, though, because you’re not calling
    the private `getLocations` method in the component. That step is the next and
    final step, but you need to make sure that you do it at the right time.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。尽管如此，这段代码仍然无法工作，因为您没有在组件中调用私有的`getLocations`方法。这一步是下一个也是最后一步，但您需要确保在正确的时间这样做。
- en: As you’ve seen, an Angular application is composed of many files. But you have
    no control of the order in which the files are put together and, therefore, no
    direct control of the execution order. You need to make sure that the service
    is called only after it’s available, which is where that little empty `ngOnInit()`
    block comes into play.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，Angular应用程序由许多文件组成。但您无法控制文件组合的顺序，因此无法直接控制执行顺序。您需要确保在服务可用之后才调用它，这就是那个小小的空`ngOnInit()`块发挥作用的地方。
- en: '`ngOnInit` is one of several Angular lifecycle hooks. While an Angular application
    is starting and running, things happen in a specific order to make sure that the
    application maintains integrity and always does things the same way. The lifecycle
    hooks allow you to listen to the process and take action at certain times.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngOnInit`是几个Angular生命周期钩子之一。当Angular应用程序启动和运行时，事情按照特定的顺序发生，以确保应用程序保持完整性并且始终以相同的方式进行操作。生命周期钩子允许您在特定时间监听过程并采取行动。'
- en: 'The `ngOnInit` hook allows you to hook into when the component is initialized
    and ready. This is a good time to make that data call, because you know that it’s
    safe to do so and that the component is ready to run. Make a call to the `local
    getLocations` method in home-list.component.ts, like so:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngOnInit`钩子允许您在组件初始化并准备好时进行挂钩。这是一个进行数据调用的好时机，因为您知道这样做是安全的，并且组件已经准备好运行。在home-list.component.ts中调用`local
    getLocations`方法，如下所示：'
- en: '[PRE48]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now the application will compile properly, run, and make the call to the API.
    Great! But if you try it on certain browsers (most notably Chrome), no data comes
    through. If you open the browser developer tools or JavaScript console, you’ll
    see a CORS warning, because the Angular app and Express API are running on different
    ports.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，应用程序将正确编译、运行并调用API。太好了！但如果您在某些浏览器（尤其是Chrome）上尝试，则不会通过任何数据。如果您打开浏览器开发者工具或JavaScript控制台，您会看到一个CORS警告，因为Angular应用程序和Express
    API正在不同的端口上运行。
- en: Allowing CORS requests in Express
  id: totrans-390
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在Express中允许CORS请求
- en: The CORS issue can’t be fixed from the browser side; it has to be done on the
    server side. You need to change gears for a moment and drop back into Express.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: CORS问题不能从浏览器端修复；它必须在服务器端完成。您需要暂时改变方向，回到Express。
- en: 'Allowing cross-origin requests is simple, fortunately. For every request made
    to the API, you need to add two HTTP headers: `Access-Control-Allow-Origin` and
    `Access-Control-Allow-Headers`. The first of these headers can contain a specific
    URL from which you’ll allow requests or a `*` as a wildcard to accept requests
    from any domain. You’ll limit requests to your Angular development application
    by specifying the URL and port.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 允许跨源请求很简单，幸运的是。对于发送到API的每个请求，您需要添加两个HTTP头：`Access-Control-Allow-Origin`和`Access-Control-Allow-Headers`。这些头中的第一个可以包含一个特定的URL，您将从该URL允许请求，或者使用`*`作为通配符以接受来自任何域的请求。您将通过指定URL和端口来限制对Angular开发应用程序的请求。
- en: 'Head back to app.js in the root of the application, and add the following bold
    font lines before the routes are used:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到应用程序根目录下的 app.js 文件，在路由使用之前添加以下加粗字体行：
- en: '[PRE49]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This code adds the two headers and their values to the responses for all requests
    made to the API routes. If you’ve still got your Express application running on
    port 3000 and your Angular application running on port 4200, you should see your
    data coming through into the browser, as in [figure 8.13](#ch08fig13).
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将两个头和它们的值添加到所有请求 API 路由的响应中。如果你仍然在端口 3000 上运行你的 Express 应用程序，在端口 4200 上运行你的
    Angular 应用程序，你应该会看到你的数据通过浏览器进入，如图 8.13 所示。
- en: Figure 8.13\. Your Angular component is now displaying data brought in from
    the API.
  id: totrans-396
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.13\. 你的 Angular 组件现在正在显示从 API 中获取的数据。
- en: '![](Images/08fig13_alt.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![图片 8.13 替代文本](Images/08fig13_alt.jpg)'
- en: This is great! You’ve built a nice little self-contained Angular application
    without too much trouble. This isn’t a bad start, especially considering that
    you’ve also been coming to grips with TypeScript throughout this chapter. In the
    next section, you’ll finish this application and embed it in your Express application.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这太棒了！你轻松地构建了一个小巧的、自包含的 Angular 应用程序。这并不是一个糟糕的开始，特别是考虑到你还在本章中掌握了 TypeScript。在下一节中，你将完成这个应用程序并将其嵌入到你的
    Express 应用程序中。
- en: 8.4\. Putting an Angular application into production
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4\. 将 Angular 应用程序投入生产
- en: So far, you’ve been working with Angular in development mode while building
    your little application. But as soon as you stop `ng serve` from running, all
    you’re left with is a bunch of source files, nothing you could include in a website.
    What you need to do now is build your application for production and add it to
    your homepage.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你一直在开发模式下使用 Angular 构建你的小应用程序。但当你停止 `ng serve` 运行后，你只剩下一些源文件，没有任何可以包含在网站中的内容。现在你需要为生产环境构建你的应用程序并将其添加到你的主页上。
- en: 8.4.1\. Building an Angular application for production
  id: totrans-401
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.1\. 构建用于生产的 Angular 应用程序
- en: You’ve been using the `ng serve` command throughout this chapter to rebuild
    your application automatically and serve the compiled files from memory. Now you’ll
    use the `ng build` command to compile the files once and save them to disk.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你一直在使用 `ng serve` 命令来自动重建你的应用程序并从内存中提供编译后的文件。现在你将使用 `ng build` 命令一次性编译文件并将它们保存到磁盘上。
- en: The `ng build` command generates all the application files and puts them in
    a folder called dist. This folder is at the same level as the src folder which
    would be great, but if you run `ng serve` again afterward, it deletes the dist
    folder, which isn’t helpful, as you can imagine. But you can change this destination
    folder by using the option `--output-path` when running the command. If you do,
    your destination folder won’t unexpectedly be deleted the next time you decide
    to run `ng serve`.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '`ng build` 命令生成所有应用程序文件并将它们放入一个名为 dist 的文件夹中。这个文件夹与 src 文件夹处于同一级别，这将是很好的，但如果你之后再次运行
    `ng serve`，它将删除 dist 文件夹，这并不 helpful，正如你可以想象的那样。但你可以通过在运行命令时使用 `--output-path`
    选项来更改目标文件夹。如果你这样做，你的目标文件夹在下次你决定运行 `ng serve` 时不会意外地被删除。'
- en: There are far too many build options for us to go through here (you can check
    them out by running `ng help` in terminal), and the only other one you need to
    know right now is the one to specify that you want a production build (as opposed
    to a development build). You specify that by adding the `--prod` flag to the command.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 构建选项太多，我们在这里无法一一介绍（你可以在终端中运行 `ng help` 来查看它们），你现在唯一需要知道的是指定你想要生产构建（而不是开发构建）的选项。你可以通过在命令中添加
    `--prod` 标志来指定这一点。
- en: 'To create a production build of your application in the folder app_public/build,
    run the following command in terminal from the app_public folder:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 app_public 文件夹中创建应用程序的生产构建版本，在终端中运行以下命令：
- en: '[PRE50]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This command kicks off the build process. If you get an error about not being
    able to find where `AppComponent` goes, that’s probably because the references
    were taken out of app.module.ts, but the files weren’t deleted. The fix is to
    delete the old app.component files, because you’re not using them anymore.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令启动构建过程。如果你收到一个关于找不到 `AppComponent` 的错误，那可能是因为引用被从 app.module.ts 中移除，但文件没有被删除。修复方法是删除旧的
    app.component 文件，因为你不再使用它们了。
- en: 'That’s it: the application is built for production! Now you need to include
    it in the Express application.'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样：应用程序已经为生产环境准备好了！现在你需要将其包含到 Express 应用程序中。
- en: 8.4.2\. Using the Angular application from the Express site
  id: totrans-409
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.2\. 从 Express 网站使用 Angular 应用程序
- en: To use the Angular application in your homepage, you need to do a few small
    things in Express. First, you’ll set the app_public folder to be a static path,
    meaning that you can easily reference the files in the build folder from the browser.
    To do the second part, update the Pug templates to include the JavaScript files
    in the build folder.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 要在主页中使用 Angular 应用，你需要在 Express 中做一些小事情。首先，你将 app_public 文件夹设置为静态路径，这意味着你可以轻松地从浏览器中引用构建文件夹中的文件。为了完成第二部分，更新
    Pug 模板以包含构建文件夹中的 JavaScript 文件。
- en: Easy, right? Now do it!
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 简单，对吧？现在就来做吧！
- en: Defining a static path for the Angular application
  id: totrans-412
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 为 Angular 应用定义静态路径
- en: 'You’ve already seen how Express defines folders to use for static resources,
    because the generator automatically defined the public folder to be static. You
    can do the same for the app_public folder by duplicating the line in app.js in
    the root of the application and setting the name to be app_public:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到 Express 如何定义用于静态资源的文件夹，因为生成器自动将 public 文件夹定义为静态。你可以通过在应用程序根目录中的 app.js
    中复制该行来为 app_public 文件夹做同样的事情，并将名称设置为 app_public：
- en: '[PRE51]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now Express will serve static resources from either the public or the app_public
    folder. Why define the whole app_public folder and not only the build subfolder
    to be a static resource? Well, the build folder also contains an index.html file.
    If this file is included as a static resource, it shows up as the homepage, as
    the static resources are checked before the other Express routes. This feature
    will be useful in the following chapters, when you create the full Angular application,
    but it’s not what you want right now. Right now, you want to use the Angular application
    *inside* your existing site, because you’re replacing part of the homepage.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Express 将从 public 或 app_public 文件夹中提供静态资源。为什么定义整个 app_public 文件夹而不是只定义 build
    子文件夹为静态资源？嗯，build 文件夹还包含一个 index.html 文件。如果这个文件被包含为静态资源，它将作为主页出现，因为静态资源在检查其他 Express
    路由之前被检查。这个特性将在接下来的章节中很有用，当你创建完整的 Angular 应用时，但这不是你现在想要的。现在，你想要在现有的网站上使用 Angular
    应用 *内部*，因为你正在替换主页的部分。
- en: Referencing the compiled Angular JavaScript files from the HTML
  id: totrans-416
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从 HTML 中引用编译后的 Angular JavaScript 文件
- en: You want to reference the Angular files on only the homepage, not on the other
    pages. The problem at the moment is that you can include script files only in
    the layout.pug template; all the other templates extend a small nested HTML part
    of this. There’s nowhere to put new script tags.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 你只想在主页上引用 Angular 文件，而不是在其他页面上。目前的问题是，你只能在 layout.pug 模板中包含脚本文件；所有其他模板都扩展了这个小的嵌套
    HTML 部分。没有地方可以放置新的脚本标签。
- en: A simple way to address this problem is to create a new `block` in the layout.pug
    template. Then any other page that extends this layout will have an option for
    including page-specific scripts.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的简单方法是在 layout.pug 模板中创建一个新的 `block`。然后任何扩展此布局的其他页面都将有包含页面特定脚本的选择。
- en: 'In layout.pug, include this line at the bottom to define a new `block` called
    `scripts`:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在 layout.pug 中，在底部添加以下行以定义一个新的 `block`，称为 `scripts`：
- en: '[PRE52]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Make sure that the indentation matches that of the final `script` tag in the
    file; the desired outcome is that any page-specific scripts will be added at the
    bottom of the HTML `body`.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 确保缩进与文件中最后的 `script` 标签相同；期望的结果是任何特定页面的脚本都将添加到 HTML 的 `body` 底部。
- en: 'Next, use this new `block` from within locations-list.pug, and reference all
    three JavaScript files from the app_public/build folder. The code should look
    a bit like this, but you’ll have different filenames:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 locations-list.pug 文件中使用这个新的 `block`，并从 app_public/build 文件夹中引用所有三个 JavaScript
    文件。代码看起来可能像这样，但文件名会有所不同：
- en: '[PRE53]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: You’re almost there! You only need to add a tag in the HTML for the application
    to bind to.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎完成了！你只需要在 HTML 中添加一个标签来绑定应用。
- en: Adding the HTML tag to bind the Angular app
  id: totrans-425
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将 HTML 标签添加到绑定 Angular 应用
- en: If you cast your mind back to earlier in the chapter or check the source code,
    you’ll remember that your app was bootstrapped into an HTML tag called `app-home-list`.
    All you want to do now is replace the list part of the homepage with your new
    holding tag.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回想起本章前面的内容或检查源代码，你会记得你的应用被引导到一个名为 `app-home-list` 的 HTML 标签中。你现在只想用你的新持有标签替换主页的部分列表。
- en: 'In locations-list.pug, find the `each location in locations` section, and either
    delete it or comment it out for reference. In its place, add `app-home-list`,
    ensuring that the indentation is correct. This part of the template should look
    something like this:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在`locations-list.pug`文件中，找到`each location in locations`部分，要么删除它，要么将其注释掉以供参考。在其位置添加`app-home-list`，确保缩进正确。这部分模板看起来应该像这样：
- en: '[PRE54]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now you’re done! Head to the browser; go back on localhost:3000; and check out
    the homepage, now including your Angular application, which is getting data from
    your API.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了！前往浏览器；回到localhost:3000；检查主页，现在包括你的Angular应用程序，它正在从你的API获取数据。
- en: If you’ve done everything properly, the page should look the same as before.
    To prove that the homepage is using the Angular application, inspect an element
    of the list; you’ll see the app-home-list tag and all the Angular stuff inside
    (see [figure 8.14](#ch08fig14)).
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一切操作正确，页面应该看起来和之前一样。为了证明主页正在使用Angular应用程序，检查列表中的一个元素；你会看到app-home-list标签以及所有Angular相关的内容（见[图8.14](#ch08fig14)）。
- en: Figure 8.14\. Validating that the homepage list is using the Angular module
  id: totrans-431
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.14\. 验证主页列表是否使用Angular模块
- en: '![](Images/08fig14_alt.jpg)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig14_alt.jpg)'
- en: We love this stuff! It’s great how all the pieces fit together and work together.
    Now you’re Getting MEAN. In [chapter 9](kindle_split_021.xhtml#ch09), you’ll start
    work on building Loc8r as a full Angular SPA.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 我们非常喜欢这些内容！所有部件如何相互配合并协同工作真是太棒了。现在你正在迈向MEAN。在第[9章](kindle_split_021.xhtml#ch09)中，你将开始构建Loc8r作为完整的Angular
    SPA。
- en: Summary
  id: totrans-434
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you learned
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了
- en: How the Angular CLI is used to generate application boilerplate, components,
    and more
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Angular CLI生成应用程序模板、组件等
- en: How to work with TypeScript classes, importing and exporting, and using them
    to define types for variables
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用TypeScript类、导入和导出，以及如何使用它们为变量定义类型
- en: How to control the code execution flow using Angular lifecycle hooks
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Angular生命周期钩子控制代码执行流程
- en: How to create and use some of the Angular building blocks to put an application
    together, covering modules, components, pipes, and services
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建和使用一些Angular构建块来组装应用程序，包括模块、组件、管道和服务
- en: How to use the Angular CLI to target for production
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Angular CLI针对生产环境进行目标定位
- en: 'Chapter 9\. Building a single-page application with Angular: Foundations'
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9章\. 使用Angular构建单页应用程序：基础
- en: '*This chapter covers*'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Working with the Angular router and navigating between pages
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular路由在页面之间导航
- en: Architectural best practices for an SPA
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SPA的架构最佳实践
- en: Building up views through multiple components
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过多个组件构建视图
- en: Injecting HTML into bindings
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将HTML注入到绑定中
- en: Working with browsers’ native geolocation capabilities
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用浏览器本地的地理位置功能
- en: You saw in [chapter 8](kindle_split_020.xhtml#ch08) how to use Angular to add
    functionality to an existing page. In this chapter and [chapter 10](kindle_split_022.xhtml#ch10),
    you’ll take Angular to the next level by using it to create a single-page application
    (SPA). Instead of running the entire application logic on the server using Express,
    you’ll run it all in the browser using Angular. For some benefits and considerations
    when using an SPA instead of a traditional approach, flick through [chapter 2](kindle_split_012.xhtml#ch02).
    By the end of this chapter, you’ll have the framework for an SPA in place with
    the first part up and running by using Angular to route to the homepage and display
    the content.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第8章](kindle_split_020.xhtml#ch08)中看到了如何使用Angular为现有页面添加功能。在本章和[第10章](kindle_split_022.xhtml#ch10)中，你将通过使用Angular创建单页应用程序（SPA）将Angular提升到下一个层次。你将不再在服务器上使用Express运行整个应用程序逻辑，而是将在浏览器中使用Angular运行它。关于使用SPA而不是传统方法的一些好处和考虑因素，请参阅[第2章](kindle_split_012.xhtml#ch02)。到本章结束时，你将拥有SPA的框架，通过使用Angular路由到主页并显示内容，第一部分将运行起来。
- en: '[Figure 9.1](#ch09fig01) shows where you are in the overall plan, recreating
    the main application as an Angular SPA.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.1](#ch09fig01)显示了你在整体计划中的位置，将主应用程序作为Angular SPA重新创建。'
- en: Figure 9.1\. This chapter recreates the Loc8r application as an Angular SPA,
    moving the application logic from the back end to the front end.
  id: totrans-450
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.1\. 本章将Loc8r应用程序重新创建为Angular SPA，将应用程序逻辑从后端移动到前端。
- en: '![](Images/09fig01_alt.jpg)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig01_alt.jpg)'
- en: In a normal development process, you probably wouldn’t create an entire application
    on the server and recreate it as an SPA. Ideally, your early planning phases defined
    whether you wanted an SPA, enabling you to start in the appropriate technology.
    For the learning process you’re going through now, it’s a good approach; you’re
    already familiar with the functionality of the site, and the layouts have already
    been created. This approach lets you focus on the more exciting prospect of seeing
    how to build a full Angular application.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常的开发过程中，你可能不会在服务器上创建整个应用程序，并将其重新创建为 SPA。理想情况下，你的早期规划阶段就定义了你是否想要一个 SPA，这样你就可以从适当的技术开始。对于你现在正在经历的学习过程，这是一个很好的方法；你已经熟悉了网站的功能，布局也已经创建。这种方法让你可以专注于更令人兴奋的展望，即了解如何构建完整的
    Angular 应用程序。
- en: In this chapter, you’ll start by adding the Angular router to navigate between
    pages; then, you’ll create the homepage and the About page and add geolocation
    functionality. As you add more components and functionality, you’ll explore various
    best practices, such as making reusable components and building up a modular application.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将首先添加 Angular 路由以在页面之间导航；然后，你将创建主页和关于页面，并添加地理位置功能。随着你添加更多组件和功能，你将探索各种最佳实践，例如创建可重用组件和构建模块化应用程序。
- en: 9.1\. Adding navigation in an Angular SPA
  id: totrans-454
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1\. 在 Angular SPA 中添加导航
- en: In this section, you’ll add the outline of the About page and enable navigation
    between this new page and the homepage. The main focus of this section is the
    navigation; you’ll complete the About page in section [9.4](#ch09lev1sec4).
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将添加关于页面的轮廓并启用此新页面与主页之间的导航。本节的主要重点是导航；你将在第 [9.4](#ch09lev1sec4) 节完成关于页面。
- en: You may remember that when you configured the Express application, you defined
    URL paths (routes) and used the Express router to map the routes to specific pieces
    of functionality. In Angular, you’ll do the same thing but use the Angular router
    instead.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，当你配置 Express 应用程序时，你定义了 URL 路径（路由）并使用 Express 路由将路由映射到特定的功能。在 Angular
    中，你将做同样的事情，但使用 Angular 路由。
- en: One big difference in using the Angular router is that the full application
    is already loaded in the browser, so when you navigate between pages, the browser
    doesn’t fully download all the HTML, CSS, and JavaScript each time. Navigating
    becomes a much quicker experience for the user; the only things they normally
    have to wait for are data from API calls and any new images.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Angular 路由的一个重大区别是，整个应用程序已经加载到浏览器中，因此当你导航到不同页面时，浏览器不需要每次都完全下载所有 HTML、CSS
    和 JavaScript。导航对用户来说变得更快；他们通常只需要等待的是 API 调用的数据以及任何新的图片。
- en: The first step is importing the Angular router into the application.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将 Angular 路由导入到应用程序中。
- en: 9.1.1\. Importing the Angular router and defining the first route
  id: totrans-459
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.1\. 导入 Angular 路由并定义第一个路由
- en: The Angular router needs to be imported into app.module.ts, which is also where
    you’ll define the routes. The router is imported from `@angular/router` as `RouterModule`,
    which should be placed with the other Angular imports at the top of app.module.ts.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 路由需要导入到 app.module.ts 中，这也是你将定义路由的地方。路由是从 `@angular/router` 导入的，作为 `RouterModule`，它应该放在
    app.module.ts 顶部的其他 Angular 导入中。
- en: Listing 9.1\. Adding the `RouterModule` to the list of imports in app.module.ts
  id: totrans-461
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.1\. 在 app.module.ts 中将 `RouterModule` 添加到导入列表中
- en: '[PRE55]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '***1* Imports the Angular RouterModule**'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入 Angular RouterModule**'
- en: In the same file, in the `@NgModule` decorator, all these modules are listed
    in the imports section. You need to do the same with `RouterModule`, but in this
    case, you also need to pass it the routing configuration you want.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一文件中，在 `@NgModule` 装饰器中，所有这些模块都在导入部分列出。你需要用 `RouterModule` 做同样的事情，但在这个情况下，你还需要传递你想要的路由配置。
- en: 9.1.2\. Routing configuration
  id: totrans-465
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.2\. 路由配置
- en: The routing configuration is an array of objects, each object specifying one
    route. The properties for each route are
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 路由配置是一个对象数组，每个对象指定一个路由。每个路由的属性包括
- en: '**`path`—** The URL path to match'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`path`—** 匹配的 URL 路径'
- en: '**`component`—** The name of the Angular component to use'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`component`—** 要使用的 Angular 组件名称'
- en: The `path` property shouldn’t contain any leading or trailing slashes, so instead
    of `/about/`, you’d have `about`, for example. It can also be an empty string
    to denote the homepage. Remember that the `base href` is set in the index.html
    file? You set yours to be `"/",` as you want everything running at the top level,
    but even if you set it to have a value, that value wouldn’t make any difference
    to the routing configuration. In your routing configuration, you should leave
    out anything set in the `base href` html tag.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '`path` 属性不应该包含任何前导或尾随斜杠，所以例如，你会有 `about` 而不是 `/about/`。它也可以是一个空字符串，表示主页。记住，`base
    href` 是在 index.html 文件中设置的？你将其设置为 `"/"`，因为你希望所有内容都在顶级运行，即使你设置了值，这个值也不会对路由配置产生影响。在你的路由配置中，你应该省略在
    `base href` html 标签中设置的任何内容。'
- en: 'You start by adding the configuration for the homepage, so `path` is an empty
    string, and `component` is the name of your existing component: `HomeListComponent`.
    The configuration is passed to a `forRoot` method on the `RouterModule`.'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先添加主页的配置，所以 `path` 是一个空字符串，`component` 是你现有的组件名称：`HomeListComponent`。配置被传递给
    `RouterModule` 的 `forRoot` 方法。
- en: Listing 9.2\. Adding the routing configuration to the decorator in app.module.ts
  id: totrans-471
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.2\. 在 app.module.ts 的装饰器中添加路由配置
- en: '[PRE56]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '***1* Adds the RouterModule to the imports, calling the forRoot method**'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 RouterModule 添加到 imports 中，并调用 forRoot 方法**'
- en: '***2* Defines the homepage route as an empty string**'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将主页路由定义为空字符串**'
- en: '***3* Specifies the HomeListComponent as the one to use for this route**'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 指定 HomeListComponent 作为此路由的组件**'
- en: 'You’ve imported the Angular `RouterModule` into your application and told it
    which component to use for the homepage. You can’t test it, however, because you’re
    also specifying the same component as the default component. Note the line `bootstrap:
    [HomeListComponent]` in [listing 9.2](#ch09ex02). What you need to do is create
    a new default component, which you’ll use to hold the navigation.'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '你已经将 Angular 的 `RouterModule` 导入到你的应用程序中，并告诉它使用哪个组件作为主页。然而，你无法测试它，因为你还在指定相同的组件作为默认组件。注意
    [列表 9.2](#ch09ex02) 中的行 `bootstrap: [HomeListComponent]`。你需要做的是创建一个新的默认组件，你将使用它来包含导航。'
- en: 9.1.3\. Creating a component for the framework and navigation
  id: totrans-477
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.3\. 创建框架和导航的组件
- en: 'To hold the navigation elements, you need to create a new component and make
    that the default component for the application. You’ll also use this component
    to hold all the framework HTML, much as you did in layout.pug in Express. In reality,
    the framework HTML is three things: navigation, content container, and footer.'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 为了包含导航元素，你需要创建一个新的组件并将其作为应用程序的默认组件。你还将使用此组件来包含所有框架 HTML，就像你在 Express 中的 layout.pug
    所做的那样。实际上，框架 HTML 是三件事：导航、内容容器和页脚。
- en: 'First, create a new component called `framework` by running the following in
    terminal from the app_public directory:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过在 app_public 目录的终端中运行以下命令创建一个名为 `framework` 的新组件：
- en: '[PRE57]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This command creates a new framework folder inside app_public/src/app/ and also
    generates all the files you need. Find the framework.component.html file, and
    add all the HTML shown in the following listing, which is pretty much what the
    HTML content of layout.pug would look like if converted to HTML
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令在 app_public/src/app/ 内部创建一个新的框架文件夹，并生成你需要的所有文件。找到 framework.component.html
    文件，并添加以下列表中显示的所有 HTML，这基本上就是 layout.pug 转换为 HTML 的内容。
- en: Listing 9.3\. Adding the HTML for the framework in framework.component.html
  id: totrans-482
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.3\. 在 framework.component.html 中添加框架的 HTML
- en: '[PRE58]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '***1* Sets up the navigation section**'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 设置导航部分**'
- en: '***2* Creates the main container**'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建主容器**'
- en: '***3* Nests the footer inside the main container**'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将页脚嵌套在主容器内**'
- en: Now that you’ve got the component set up, you need to tell the application to
    use it as the default component, and tell it where to put it in the HTML.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经设置了组件，你需要告诉应用程序使用它作为默认组件，并告诉它在 HTML 中的位置。
- en: 'To set the new `framework` component as the default component, update the bootstrap
    value in app.module.ts like so, replacing `HomeListComponent` with `FrameworkComponent`:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 要将新的 `framework` 组件设置为默认组件，更新 app.module.ts 中的 bootstrap 值如下，将 `HomeListComponent`
    替换为 `FrameworkComponent`：
- en: '[PRE59]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally, you need to update index.html to have the correct tag for this component
    rather than `home-list`. Open framework.component.ts, and find the selector in
    the decorator, which gives you the name of the HTML tag you should use:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要更新 index.html 以使用此组件的正确标签而不是 `home-list`。打开 framework.component.ts，并在装饰器中找到选择器，它给你提供了应该使用的
    HTML 标签的名称：
- en: '[PRE60]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: So `app-framework` is the tag you need to have in index.html so Angular knows
    where to put the `framework` component. Update index.html to look like the following.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`app-framework`是你需要在`index.html`中拥有的标签，这样Angular就知道在哪里放置`框架`组件。更新`index.html`以看起来如下。
- en: Listing 9.4\. Updating index.html file to use the new `framework` component
  id: totrans-493
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.4\. 更新`index.html`文件以使用新的`framework`组件
- en: '[PRE61]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '***1* Replaces the home-list component for the app-framework**'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 替换app-framework的home-list组件**'
- en: Now that your `framework` component is created and linked to the HTML, you can
    check it out in the browser, as shown in [figure 9.2](#ch09fig02). If you haven’t
    done so already, remember to run `nodemon` from the root folder of the application
    to get the API running, and also run `ng serve` from the app_public folder to
    get the development version of the Angular app running.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的`框架`组件已创建并链接到HTML，您可以在浏览器中查看它，如图 [图9.2](#ch09fig02) 所示。如果您还没有这样做，请记住从应用程序的根目录运行`nodemon`以启动API，并从`app_public`文件夹运行`ng
    serve`以启动Angular应用程序的开发版本。
- en: Figure 9.2\. Showing the `framework` component by default instead of the listing
  id: totrans-497
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.2\. 默认显示`框架`组件而不是列表
- en: '![](Images/09fig02_alt.jpg)'
  id: totrans-498
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig02_alt.jpg)'
- en: 'You can see the page header displaying, so you have success of sorts. Your
    new component works! But you don’t see any content, even though you’re on the
    homepage route. If you open the JavaScript console in the browser, you see an
    error: `Cannot find primary outlet to load ''HomeListComponent''`.'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到页头正在显示，所以你某种程度上是成功的。你的新组件工作！但你没有看到任何内容，即使你处于主页路由。如果你在浏览器中打开JavaScript控制台，你会看到一个错误：`Cannot
    find primary outlet to load 'HomeListComponent'`。
- en: You’ve told the application to load `HomeListComponent` for the homepage route,
    but haven’t specified where it should be positioned in the HTML.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经告诉应用程序为主页路由加载`HomeListComponent`，但没有指定它应该在HTML中的位置。
- en: 9.1.4\. Defining where to display the content using router-outlet
  id: totrans-501
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.4\. 使用`router-outlet`定义显示内容的位置
- en: Specifying the destination for a routed component is as simple as adding an
    empty tag pair in the HTML where you want it to go. This special tag is `<router-outlet>`.
    Angular adds the routed component *after* this tag, not inside it, as you might
    expect if you’re familiar with AngularJS.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 指定路由组件的目标就像在HTML中添加一个空标签对一样简单，你希望它去的位置。这个特殊标签是`<router-outlet>`。Angular将路由组件添加到这个标签之后，而不是像你熟悉AngularJS时预期的那样放在里面。
- en: Adding this empty tag pair to the correct place in the framework HTML—where
    you had block content in layout.pug—looks like the following.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个空标签对添加到框架HTML的正确位置——即你在layout.pug中放置块内容的位置——看起来如下。
- en: Listing 9.5\. Adding `router-outlet` to framework.component.html
  id: totrans-504
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.5\. 将`router-outlet`添加到`framework.component.html`
- en: '[PRE62]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '***1* Outlet for the router; Angular uses the URL to find the component and
    injects it here.**'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 路由器出口；Angular使用URL来查找组件并将其注入此处。**'
- en: If you check out the browser now, you see the listing information as well as
    the framework. Inspecting the elements, as shown in [figure 9.3](#ch09fig03),
    demonstrates that `<router-outlet>` remains empty, and that `<app-home-list>`
    was injected afterward.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在查看浏览器，你会看到列表信息和框架。如图 [图9.3](#ch09fig03) 所示，检查元素显示 `<router-outlet>` 保持为空，并且
    `<app-home-list>` 在之后被注入。
- en: Figure 9.3\. The routed component—the listing information—is now being displayed
    on the homepage route, with the HTML being injected after the `<router-outlet>`
    tag.
  id: totrans-508
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.3\. 路由组件——列表信息——现在正在主页路由上显示，HTML被注入到`<router-outlet>`标签之后。
- en: '![](Images/09fig03_alt.jpg)'
  id: totrans-509
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig03_alt.jpg)'
- en: You can see the framework and the listing for the homepage, but it’s not the
    homepage you know and love. It’s missing a header and sidebar. You’ll come back
    to this page in section [9.2](#ch09lev1sec2). First, you need to see how the navigation
    works.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到主页的框架和列表，但这并不是你熟悉和喜爱的主页。它缺少了页眉和侧边栏。你将在[9.2](#ch09lev1sec2)节中回到这个页面。首先，你需要了解导航是如何工作的。
- en: 9.1.5\. Navigating between pages
  id: totrans-511
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.5\. 在页面间导航
- en: To see the navigation in action, update the Angular application so that you
    can flip between the homepage and the About page. If you click the links right
    now, they won’t work. To get the navigation working, you need to create an `about`
    component, define the `about` route, and change the links in the navigation to
    something Angular can use.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到导航的实际效果，更新Angular应用程序，以便可以在主页和关于页面之间切换。如果你现在点击链接，它们将不会工作。为了使导航工作，你需要创建一个`about`组件，定义`about`路由，并将导航中的链接更改为Angular可以使用的内容。
- en: 'Creating the `about` component with Angular CLI should be familiar by now.
    In terminal, in the app_public folder, run the following `generate` command:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Angular CLI创建`about`组件现在应该很熟悉了。在终端中，在app_public文件夹中，运行以下`generate`命令：
- en: '[PRE63]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This command creates the new component inside app_public/src/app/about. You’ll
    leave it as it is for now, so you can focus on the navigation. In section [9.4](#ch09lev1sec4),
    you’ll return to the About page and build it out fully.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令在app_public/src/app/about中创建新的组件。现在您可以保持它不变，以便专注于导航。在第[9.4](#ch09lev1sec4)节中，您将返回到About页面并完全构建它。
- en: Defining a new route
  id: totrans-516
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义新的路由
- en: As with the homepage route, you need to configure the route for the About page
    in app.module.ts. You need to specify the path for the route as well as the name
    of the component. The path is `'about'`. Remember that you don’t need any leading
    or trailing slashes.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 与主页路由一样，您需要在app.module.ts中配置About页面的路由。您需要指定路由的路径以及组件的名称。路径是`'about'`。请记住，您不需要任何前导或尾随斜杠。
- en: 'To make sure you get the name of the component correct, you can open about.component.ts
    to find it in the export line: `export class AboutComponent implements OnInit`.'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保您正确地得到了组件的名称，您可以打开about.component.ts以在导出行中找到它：`export class AboutComponent
    implements OnInit`。
- en: Knowing the path and component name, you can add the new route in app.module.ts.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 知道路径和组件名称后，您可以在app.module.ts中添加新的路由。
- en: Listing 9.6\. Defining the new `about` route in app.module.ts
  id: totrans-520
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.6\. 在app.module.ts中定义新的`about`路由
- en: '[PRE64]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: If you open the browser directly to localhost:4200/about, you get the About
    page, but the navigation links don’t work properly yet. You’ll fix them in the
    next section.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您直接在浏览器中打开localhost:4200/about，您会得到About页面，但导航链接目前还不能正常工作。您将在下一节中修复它们。
- en: Setting Angular navigation links
  id: totrans-523
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设置Angular导航链接
- en: When you’re using links defined in the router, Angular doesn’t want to see `href`
    attributes in the `<a>` tags; instead, it looks for a directive called `routerLink`.
    Angular takes the value you give to `routerLink` to create the `href` property.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用路由中定义的链接时，Angular不希望在`<a>`标签中看到`href`属性；相反，它寻找一个名为`routerLink`的指令。Angular使用您提供给`routerLink`的值来创建`href`属性。
- en: The rules that apply to defining a path in the router also apply to setting
    the value for a `routerLink`. You don’t need to include leading or trailing slashes,
    and bear in mind that you don’t need to duplicate anything set in the `base href`.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 定义路由路径的规则也适用于设置`routerLink`的值。您不需要包含前导或尾随斜杠，并且请记住，您不需要重复在`base href`中设置的任何内容。
- en: Following these rules, updating the navigation links in framework.component.html
    looks like the next listing. Replace `href` attributes with `routerLink` directives,
    ensuring that the values match what you have in the router definition in app.module.ts.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些规则，更新framework.component.html中的导航链接看起来像下面的列表。将`href`属性替换为`routerLink`指令，确保值与在app.module.ts中的路由定义匹配。
- en: Listing 9.7\. Defining the navigation router links in framework.component.html
  id: totrans-527
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.7\. 在framework.component.html中定义导航router链接
- en: '[PRE65]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '***1* Empty routerLink path pointing to the default component**'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 空的routerLink路径指向默认组件**'
- en: '***2* about path to cause navigation to the about component**'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* about路径用于导航到about组件**'
- en: With this code in place and saved, you can click between the two links, as shown
    in [figure 9.4](#ch09fig04).
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码放置并保存后，您可以在两个链接之间点击，如图[图9.4](#ch09fig04)所示。
- en: Figure 9.4\. Using the navigation buttons to switch between the homepage and
    the About page—an Angular SPA!
  id: totrans-532
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.4\. 使用导航按钮在主页和About页面之间切换——一个Angular单页应用！
- en: '![](Images/09fig04_alt.jpg)'
  id: totrans-533
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/09fig04_alt.jpg)'
- en: Notice that the URL in the browser changes as normal, but the page doesn’t reload
    or flicker when moving between the pages. If you check the network traffic when
    switching between these two pages, you’ll see only calls to the API being made.
    You can also use the back and forward buttons in your browser, and the site will
    work like a traditional website. Congratulations—you’ve built a single-page application!
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，浏览器中的URL会像往常一样改变，但在页面之间切换时页面不会重新加载或闪烁。如果您在切换这两个页面时检查网络流量，您将只会看到对API的调用。您还可以使用浏览器中的后退和前进按钮，网站将像传统网站一样工作。恭喜您——您已经构建了一个单页应用！
- en: Before you move on, quickly improve the navigation by adding active styles.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，快速通过添加活动样式来改进导航。
- en: 9.1.6\. Adding active navigation styles
  id: totrans-536
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.6\. 添加活动导航样式
- en: It’s standard practice in web design to have an `active` class on navigation
    items so that the link for the current page looks a bit different—a simple visual
    cue to tells users where they are. You’ve got only one link in your navigation,
    but the process is still worthwhile.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 在网页设计中，将`active`类应用于导航项是标准做法，这样当前页面的链接看起来会略有不同——一个简单的视觉提示，告诉用户他们所在的位置。你的导航中只有一个链接，但这个过程仍然值得。
- en: 'Twitter Bootstrap has helper classes defined to create an active navigation
    state; you set the class `active` on the active link. As it’s such a common requirement,
    Angular also has a helper for this class: a directive called `routerLinkActive`.'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter Bootstrap定义了辅助类来创建活动导航状态；你在活动链接上设置`active`类。由于这是一个常见的需求，Angular也有一个辅助工具：一个名为`routerLinkActive`的指令。
- en: 'On an `<a>` tag containing a router link, you can add the `routerLinkActive`
    directive and specify the name of the class you want to use for active links.
    You’ll use the class `active` in framework.component.html:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含路由链接的`<a>`标签上，你可以添加`routerLinkActive`指令并指定你想要用于活动链接的类名。你将在`framework.component.html`中使用`active`类：
- en: '[PRE66]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The positioning of the `routerLinkActive` attribute is important. If it doesn’t
    seem to be working, make sure that you included it before the `class` attribute.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '`routerLinkActive`属性的位置很重要。如果它似乎不起作用，请确保你在`class`属性之前包含了它。'
- en: Now, when you visit the About page, the `<a>` tag has an extra class of `active`
    added to it, which Bootstrap displays as a stronger white color, as you can see
    in [figure 9.5](#ch09fig05).
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你访问关于页面时，`<a>`标签被添加了一个额外的`active`类，Bootstrap将其显示为更强烈的白色，正如你在[图9.5](#ch09fig05)中可以看到的那样。
- en: Figure 9.5\. Seeing the `active` class in action; Angular adds and removes it
    from the link as navigation changes are made.
  id: totrans-543
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.5. 查看`active`类的实际应用；Angular在导航更改时向链接添加和移除它。
- en: '![](Images/09fig05_alt.jpg)'
  id: totrans-544
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](Images/09fig05_alt.jpg)'
- en: And with that, you’ve covered the basics of the Angular router, creating working
    navigation for your SPA. You can see that the views clearly need some work, so
    that’s what you’ll focus on in the next two sections.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，你已经涵盖了Angular路由的基础知识，为你的SPA创建了工作导航。你可以看到视图显然需要一些工作，所以你将在下一两个部分中关注这一点。
- en: 9.2\. Building a modular app using multiple nested components
  id: totrans-546
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2. 使用多个嵌套组件构建模块化应用
- en: In this section, you’ll focus on building out the familiar homepage in Angular.
    To set yourself up for success—and to follow Angular architectural best practices—you’ll
    do this by creating several new components and nesting them as you need to. This
    process gives you a modular application, so you can reuse pieces in different
    places in the application.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将专注于在Angular中构建熟悉的主页。为了设定成功的基础——并遵循Angular架构最佳实践——你将通过创建几个新组件并根据需要嵌套它们来实现这一点。这个过程为你提供了一个模块化应用程序，因此你可以在应用程序的不同地方重用这些部分。
- en: 'The homepage has three main sections:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 主页有三个主要部分：
- en: Page header
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面标题
- en: List of locations
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置列表
- en: Sidebar
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 侧边栏
- en: You already have the list of locations built as a component; that’s your `home-list`
    component. You’ll need to create the header and the sidebar as two new components.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经将位置列表构建为一个组件；那就是你的`home-list`组件。你需要创建标题和侧边栏作为两个新的组件。
- en: You’ll also need to wrap all three of these components inside a main homepage
    component to ensure that everything works together, has the correct layout, and
    can be navigated to via the Angular router. [Figure 9.6](#ch09fig06) shows an
    overlay of how these components fit together on top of the homepage design. You
    have the `framework` component on the outside, holding everything. Nested inside
    this component is the `homepage` component to control the content area, with the
    page header, listing, and sidebar components nested inside it.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要将这三个组件都包裹在主主页组件中，以确保它们可以一起工作，具有正确的布局，并且可以通过Angular路由进行导航。[图9.6](#ch09fig06)显示了这些组件如何在主页设计之上叠加。你有一个外部的`framework`组件，它包含了一切。在这个组件内部嵌套的是`homepage`组件，用于控制内容区域，其中包含页面标题、列表和侧边栏组件。
- en: Figure 9.6\. Breaking the homepage layout into components, using two levels
    of nesting
  id: totrans-554
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.6. 将主页布局分解为组件，使用两层嵌套
- en: '![](Images/09fig06_alt.jpg)'
  id: totrans-555
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](Images/09fig06_alt.jpg)'
- en: This is what you’re going to build. You’ll start with the `homepage` component.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你要构建的内容。你将从`homepage`组件开始。
- en: 9.2.1\. Creating the main homepage component
  id: totrans-557
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.1. 创建主主页组件
- en: The `homepage` component contains all the HTML and information for the homepage—everything
    between the header and the footer. This component is what you’ll reference in
    the router for Angular to use whenever anybody requests the homepage.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '`homepage` 组件包含主页的所有 HTML 和信息——从标题到页脚之间的所有内容。这个组件是你将在 Angular 的路由器中引用的，以便在任何人请求主页时使用。'
- en: 'Start by using the Angular CLI to generate the component in the now-familiar
    way (in terminal from the app_public folder):'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用 Angular CLI 以熟悉的方式生成组件（从 app_public 文件夹的终端中）：
- en: '[PRE67]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Next, tell the router to use this component for the default home route by updating
    app.module.ts like so:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过更新 app.module.ts 来告诉路由器使用此组件作为默认主页路由，如下所示：
- en: '[PRE68]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In homepage.component.html, put the selector for the `home-list` component
    for a moment before checking it in the browser:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 在 homepage.component.html 中，在浏览器中检查它之前，暂时放置 `home-list` 组件的选择器：
- en: '[PRE69]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: If you look at the application in the browser, it looks the way it did before,
    with the navigation bar, footer, and listing section in between.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过浏览器查看应用程序，它看起来和之前一样，有导航栏、页脚和中间的列表部分。
- en: But you want to see all the content for the homepage now; that’s the page header,
    main content, and sidebar. Taking the framework code from the Pug templates and
    turning it into HTML looks like the following listing. Note that you’re putting
    the `app-home-list` component here to display the listing section.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 但你现在想看到主页的所有内容；这就是页面标题、主要内容以及侧边栏。将 Pug 模板中的框架代码转换为 HTML 的样子如下所示。请注意，你在这里放置了
    `app-home-list` 组件以显示列表部分。
- en: Listing 9.8\. Putting the HTML for homepage content in homepage.component.html
  id: totrans-567
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.8\. 将主页内容的 HTML 放入 homepage.component.html
- en: '[PRE70]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '***1* The page header**'
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 页面标题**'
- en: '***2* Container for the homepage listing component**'
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 主页列表组件的容器**'
- en: '***3* The sidebar**'
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 侧边栏**'
- en: Now, when you view the page in the browser, you get something like [figure 9.7](#ch09fig07)—your
    good old familiar homepage!
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你通过浏览器查看页面时，你会得到类似[图9.7](#ch09fig07)的东西——你熟悉的老主页！
- en: Figure 9.7\. The homepage in Angular with the page header and sidebar hardcoded
    in the `homepage` component
  id: totrans-573
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.7\. 在 Angular 中，主页组件中硬编码了页面标题和侧边栏
- en: '![](Images/09fig07_alt.jpg)'
  id: totrans-574
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig07_alt.jpg)'
- en: Everything is there and working correctly, including the `home-list` component
    nested inside the `homepage` component. But you can do better. The page header
    and sidebar are repeated on other pages, albeit with different text content. You
    can follow some architectural best practices here and try to avoid repeating code
    by creating reusable components.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的东西都在那里并且工作正常，包括嵌套在 `homepage` 组件内的 `home-list` 组件。但你可以做得更好。页面标题和侧边栏在其他页面上重复出现，尽管文本内容不同。你可以遵循一些架构最佳实践，并尝试通过创建可重用组件来避免代码重复。
- en: 9.2.2\. Creating and using reusable subcomponents
  id: totrans-576
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.2\. 创建和使用可重用子组件
- en: You’re going to create the page header and sidebar as new components so that
    you never need to copy the HTML into multiple views. If the site grows to have
    dozens or hundreds of pages, you wouldn’t want to have to repeat the same HTML
    in each layout. This situation gets even worse if you need to update the HTML
    in the future. It’s much easier to update the HTML in one place, and is also much
    less prone to errors or omissions.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 你将创建页面标题和侧边栏作为新组件，这样你就不需要将 HTML 复制到多个视图中。如果网站增长到有数十或数百个页面，你就不想在每个布局中重复相同的 HTML。如果你需要在未来更新
    HTML，这种情况会更糟。在一个地方更新 HTML 要容易得多，而且也更不容易出错或遗漏。
- en: You’ll make the components “smart” so that you can pass them different content
    to display. In your case, the reusable components are all about the HTML rather
    than the content. Start with the page header.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使组件“智能”，以便你可以传递不同的内容来显示。在你的情况下，可重用组件都是关于 HTML 而不是内容。从页面标题开始。
- en: Creating the page-header component
  id: totrans-579
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建页面标题组件
- en: 'The first step is issuing the familiar component generation command in terminal:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是发出熟悉的组件生成命令（在终端中）：
- en: '[PRE71]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Following that command, copy the header content from the homepage HTML and
    paste it into page-header.component.html:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行上述命令后，从主页 HTML 中复制标题内容并将其粘贴到 page-header.component.html：
- en: '[PRE72]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Then you need to reference this content in the homepage.component.html instead
    of the full HTML currently there. To do so, you need the correct tag, which you
    can find by looking for the selector in the page-header.component.ts file. In
    this case, the selector is app-page-header, so that’s what you’ll use in the `homepage`
    component HTML.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要在家页面的 .component.html 中引用此内容，而不是目前存在的完整 HTML。为此，你需要正确的标签，你可以通过查找 page-header.component.ts
    文件中的选择器来找到它。在这种情况下，选择器是 app-page-header，所以你将在 `homepage` 组件 HTML 中使用它。
- en: Listing 9.9\. Replacing the page header HTML in homepage.component.html
  id: totrans-585
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.9\. 替换 homepage.component.html 中的页面头部 HTML
- en: '[PRE73]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Good start. You’ve created the new `page-header` component, but it still has
    hardcoded content. Next, you’ll pass data to the page header from the `homepage`
    component.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 很好的开始。你已经创建了新的 `page-header` 组件，但它仍然有硬编码的内容。接下来，你将从 `homepage` 组件传递数据到页面头部。
- en: Defining the data for the page-header component on the homepage
  id: totrans-588
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在主页上定义页面头部组件的数据
- en: You want to set the data for the `homepage` instance of the `page-header` component
    from within the `homepage` component so you can pass it through.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 你想在 `homepage` 组件内部设置 `page-header` 组件的 `homepage` 实例的数据，以便你可以传递它。
- en: Defining the data is simple. In the `homepage` component class definition, you
    create a new member to hold the data. You’ll create a member called `pageContent`
    and nest the header inside it, as shown in the next listing. The class member
    is a simple JavaScript object with text data. Note that the `strapline` content
    is shortened in this snippet to save trees.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 定义数据很简单。在 `homepage` 组件类定义中，你创建一个新的成员来保存数据。你将创建一个名为 `pageContent` 的成员，并将头部嵌套在其中，如下一列表所示。类成员是一个简单的
    JavaScript 对象，包含文本数据。请注意，在这个片段中，`strapline` 内容被缩短以节省树木。
- en: Listing 9.10\. Defining the homepage page header content in homepage.component.ts
  id: totrans-591
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.10\. 在 homepage.component.ts 中定义主页页面头部内容
- en: '[PRE74]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '***1* Creates a new class member to hold the page header content**'
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个新的类成员来保存页面头部内容**'
- en: The `header` is nested inside `pageContent` because, soon, you’ll add the sidebar
    content too, and having them both within the same member will keep the code neater.
    Next, you pass this data to the `page-header` component.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '`header` 被嵌套在 `pageContent` 中，因为不久你还将添加侧边栏内容，将它们都放在同一个成员中会使代码更整洁。接下来，你将此数据传递给
    `page-header` 组件。'
- en: Passing data into the page-header component
  id: totrans-595
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将数据传递到页面头部组件
- en: The homepage class member `pageContent` is now available to the homepage HTML,
    but rather than use the data directly, you want to pass it through to the `page-header`
    component. Data is passed through to the nested component via a special binding
    in the HTML. The name of the binding is a property you define in the nested component,
    so it can be anything you want.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 主页类的成员 `pageContent` 现在可供主页 HTML 使用，但你不想直接使用这些数据，而是想通过 `page-header` 组件传递它。数据通过
    HTML 中的特殊绑定传递给嵌套组件。绑定的名称是在嵌套组件中定义的一个属性，所以可以是任何你想要的。
- en: 'You’ll bind the page header content to a property called `content`. (This property
    doesn’t exist yet; you’ll define it in the next step.) In homepage.component.html,
    update `<app-page-header>` to include the binding:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 你将绑定页面头部内容到名为 `content` 的属性。（这个属性目前还不存在；你将在下一步中定义它。）在 homepage.component.html
    中，更新 `<app-page-header>` 以包括绑定：
- en: '[PRE75]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Note that although the square brackets may not be valid HTML, that’s okay here,
    because Angular removes them before serving the HTML to the browser. The actual
    HTML that the browser will receive is something like `<app-page-header_ngcontent-c6=""
    _nghost-c2="">`, which is valid HTML.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管方括号可能不是有效的 HTML，但在这里没关系，因为 Angular 在将 HTML 传递给浏览器之前会移除它们。浏览器实际接收到的 HTML
    可能类似于 `<app-page-header_ngcontent-c6="" _nghost-c2="">`，这是有效的 HTML。
- en: You’re now passing data from the `homepage` component to the nested `page-header`
    component; you need to update the page header to accept and use this data.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在正在从 `homepage` 组件传递数据到嵌套的 `page-header` 组件；你需要更新页面头部以接受和使用这些数据。
- en: Accepting and displaying incoming data in a component
  id: totrans-601
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在组件中接受和显示传入的数据
- en: You need to tell the `pageHeader` component that `content` should exist as a
    property and to get the value from the outside. Technically, `content` is an *input*
    to the component.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要告诉 `pageHeader` 组件 `content` 应该作为一个属性存在，并从外部获取值。技术上讲，`content` 是组件的一个 *输入*。
- en: Any property of a class needs to be defined, and this one is no different. Where
    it differs from what you’ve seen before is that it needs to be defined as an input
    property. To do that, you need to import `Input` into the component from the Angular
    core and use it as a decorator when you define the `content` member.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 类的任何属性都需要定义，这个属性也不例外。它与之前你所看到的不同之处在于，它需要被定义为输入属性。为了做到这一点，你需要从Angular核心导入`Input`，并在定义`content`成员时将其用作装饰器。
- en: Listing 9.11\. Telling page-header.component.ts to accept content as an `Input`
  id: totrans-604
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.11\. 告诉`page-header.component.ts`接受内容作为`Input`
- en: '[PRE76]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '***1* Imports Input from the Angular core**'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从Angular核心导入Input**'
- en: '***2* Defines content as a class member that accepts an input of any type**'
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将内容定义为类成员，该成员接受任何类型的数据输入**'
- en: When that’s done, the component will understand the data being sent to it from
    the `homepage` component, and you’ll be able to display it. Replace the hardcoded
    text in page-header.component.html with the relevant Angular data bindings.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 当完成这些操作后，组件将理解从`homepage`组件发送给它的数据，你将能够显示它。将`page-header.component.html`中的硬编码文本替换为相关的Angular数据绑定。
- en: Listing 9.12\. Putting the data bindings in page-header.component.html
  id: totrans-609
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.12\. 在`page-header.component.html`中放置数据绑定
- en: '[PRE77]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Now you have a fully reusable component for the page header, which can display
    the data sent to it from a parent component. This component is an important building
    block of Angular application architecture. You’ll cement the process by doing
    the same for the sidebar so that you can complete the homepage, but you’ll run
    into a little hiccup along the way.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个完全可重用的页眉组件，它可以显示从父组件发送给它的数据。这个组件是Angular应用程序架构的重要构建块。你将通过为侧边栏做同样的事情来巩固这个过程，以便你可以完成主页，但在过程中你会遇到一点小麻烦。
- en: Creating the sidebar component
  id: totrans-612
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建侧边栏组件
- en: We won’t dwell too long on the steps for setting up the sidebar component, as
    you completed them for the page header earlier in this chapter.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会过多地讨论设置侧边栏组件的步骤，因为你已经在本章早期完成了页眉的设置。
- en: 'First, generate the component:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，生成组件：
- en: '[PRE78]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Second, grab the sidebar HTML from homepage.component.html, and paste it into
    sidebar.component.html. When you do, replace the text content with a binding to
    `content`:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，从`homepage.component.html`中获取侧边栏HTML，并将其粘贴到`sidebar.component.html`中。当你这样做时，将文本内容替换为对`content`的绑定：
- en: '[PRE79]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Third, allow the sidebar component to receive data by importing `Input` from
    Angular core and defining the `content` property—of type `string`—with the `@Input`
    decorator:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，通过从Angular核心导入`Input`并定义类型为`string`的`content`属性，使用`@Input`装饰器允许侧边栏组件接收数据：
- en: '[PRE80]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Fourth, update the `pageContent` member in homepage.component.ts to contain
    the sidebar data:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 第四，更新`homepage.component.ts`中的`pageContent`成员以包含侧边栏数据：
- en: '[PRE81]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Fifth, update the homepage.component.html to use the new sidebar component,
    and pass the data through as `content`:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 第五，更新`homepage.component.html`以使用新的侧边栏组件，并通过`content`传递数据：
- en: '[PRE82]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: All done! But is it? If you view this page in the browser, you’ll notice that
    no matter how wide you make your browser window, the sidebar is always below the
    content (see [figure 9.8](#ch09fig08)).
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 所有工作都完成了！但是，它真的完成了吗？如果你在浏览器中查看这个页面，你会注意到无论你如何调整浏览器窗口的宽度，侧边栏总是位于内容下方（见[图 9.8](#ch09fig08)）。
- en: Figure 9.8\. The new sidebar component is in and working, but it’s below the
    main content instead of where it should be.
  id: totrans-625
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.8\. 新的侧边栏组件已经添加并正在工作，但它位于主内容下方，而不是它应该所在的位置。
- en: '![](Images/09fig08_alt.jpg)'
  id: totrans-626
  prefs: []
  type: TYPE_IMG
  zh: '![图片 9.8](Images/09fig08_alt.jpg)'
- en: The position of the sidebar is defined by the classes in the `<div class="col-12
    col-md-4">` element. But by putting this content inside a component, you wrapped
    it in a new tag, `<app-sidebar>`, so Bootstrap is throwing the sidebar below as
    a new row.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 侧边栏的位置由`<div class="col-12 col-md-4">`元素中的类定义。但通过将此内容放入组件中，你将其包裹在一个新的标签`<app-sidebar>`中，因此Bootstrap将侧边栏作为新的一行抛到下方。
- en: This problem is something to look out for, especially when you’re nesting components.
    But it’s easy to fix.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题是需要注意的，尤其是在你嵌套组件时。但它是很容易修复的。
- en: Working with Angular elements and Bootstrap layout classes
  id: totrans-629
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用Angular元素和Bootstrap布局类进行工作
- en: 'The problem you have is that the browser now sees this following HTML markup
    generated:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 你遇到的问题是浏览器现在看到以下HTML标记生成：
- en: '[PRE83]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The Bootstrap `col` classes for the sidebar are in the wrong level in the hierarchy,
    so `<app-sidebar>` is being treated as a full-width column regardless of browser
    size. All you need to do is move the classes from the `<div>` in sidebar.component.html
    to `<app-sidebar>` in homepage.component.html, so that homepage.component.html
    looks like the following.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 侧边栏的 Bootstrap `col` 类在层次结构中的级别错误，因此 `<app-sidebar>` 不论浏览器大小都被视为全宽列。你需要做的就是将
    sidebar.component.html 中的 `<div>` 类移动到 homepage.component.html 中的 `<app-sidebar>`，这样
    homepage.component.html 就会看起来像以下这样。
- en: Listing 9.13\. Moving the sidebar classes into homepage.component.html
  id: totrans-633
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.13。将侧边栏类移动到 homepage.component.html
- en: '[PRE84]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'With that done, you no longer need the `<div>` in the sidebar markup; you can
    keep the `<p>` and the content. Now sidebar.component.html looks like this:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，你不再需要侧边栏标记中的 `<div>`；你可以保留 `<p>` 和内容。现在 sidebar.component.html 看起来是这样的：
- en: '[PRE85]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: With that fix, everything should look right with the homepage, as shown in [figure
    9.9](#ch09fig09). The homepage is looking good! Something has been missing so
    far, though. Wouldn’t it be great if Loc8r could tell where you are and find places
    nearby? You’ll add geolocation to the homepage in the next section.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个修复，主页应该看起来一切正常，如图9.9所示。主页看起来不错！不过到目前为止，还有一些东西缺失。如果 Loc8r 能够告诉你在哪里，并找到附近的地方，那不是很好吗？你将在下一节中将地理位置添加到主页中。
- en: Figure 9.9\. The completed homepage rendering correctly, constructed of multiple
    nested components
  id: totrans-638
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.9。完成的主页渲染正确，由多个嵌套组件构成
- en: '![](Images/09fig09_alt.jpg)'
  id: totrans-639
  prefs: []
  type: TYPE_IMG
  zh: '![图片9.9的替代文本](Images/09fig09_alt.jpg)'
- en: 9.3\. Adding geolocation to find places near you
  id: totrans-640
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3。添加地理位置以查找附近的地方
- en: The main premise of Loc8r is that it’s location aware and able to find places
    that are near the user. So far, you’ve been faking it by hardcoding geographic
    coordinates into the API requests. You’re going to change that right now by adding
    HTML5 geolocation.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: Loc8r 的主要前提是它具有位置感知能力，能够找到靠近用户的地方。到目前为止，你通过将地理坐标硬编码到API请求中来进行欺骗。你现在将通过添加HTML5地理位置来改变这一点。
- en: 'To get geolocation working, you’ll need to do the following things:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 要使地理位置正常工作，你需要做以下几件事：
- en: Add a call to the HTML5 location API to your Angular application.
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将对HTML5位置API的调用添加到你的Angular应用程序中。
- en: Query the Express API if location details are available.
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询 Express API 以确定是否提供位置详情。
- en: Pass the coordinates to your Angular data service, removing the hardcoded location.
  id: totrans-645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将坐标传递给你的Angular数据服务，移除硬编码的位置。
- en: Output messages along the way so the user knows what’s going on.
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出消息，让用户知道发生了什么。
- en: Starting at the top, you’ll add the geolocation JavaScript function by creating
    a new service.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部开始，你将通过创建一个新的服务来添加地理位置 JavaScript 函数。
- en: 9.3.1\. Creating an Angular geolocation service
  id: totrans-648
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.1。创建Angular地理位置服务
- en: The ability to find the location of the user feels like something that would
    be reusable, in this and other projects. To snap it off as a piece of standalone
    functionality, you’ll create another service to hold it. As a rule, any code that’s
    interacting with APIs, running logic, or performing operations should be externalized
    into services. Leave the component to control the services rather than perform
    the functions.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 能够找到用户的位置感觉像是一种可重用的功能，在这个和其他项目中。为了将其作为独立的功能分离出来，你将创建另一个服务来持有它。一般来说，任何与API交互、运行逻辑或执行操作的代码都应该外部化到服务中。让组件控制服务而不是执行功能。
- en: 'To create the skeleton of the geolocation service, run the following in terminal
    from app_public:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建地理位置服务的框架，请在终端中从 app_public 运行以下命令：
- en: '[PRE86]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We won’t distract you right now by diving into the details of how the HTML5/JavaScript
    geolocation API works. Modern browsers have a method on the `navigator` object
    that you can call to find the coordinates of the user. The user has to give permission
    for this to happen. The method accepts two parameters (a success callback and
    an error callback) and looks like the following:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不会深入探讨 HTML5/JavaScript 地理位置API的工作细节。现代浏览器在 `navigator` 对象上有一个你可以调用的方法来找到用户的坐标。用户必须为此操作提供权限。该方法接受两个参数（一个成功回调和一个错误回调），如下所示：
- en: '[PRE87]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: You’ll need to expose the standard geolocation script in a public method so
    that you can use it as a service. While you’re here, you’ll also error-trap against
    the possibility that the current browser doesn’t support this feature. The following
    listing shows the full code for geolocation.service.ts, providing a public `getPosition`
    method that other components can call.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在一个公开的方法中公开标准的地理位置脚本，以便您可以使用它作为服务。当您在这里时，您还将错误处理针对当前浏览器可能不支持此功能的可能性。以下列表显示了
    geolocation.service.ts 的完整代码，提供了一个公开的 `getPosition` 方法，其他组件可以调用。
- en: Listing 9.14\. Creating a `geolocation` service using a callback to get current
    position
  id: totrans-655
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.14\. 使用回调获取当前位置创建 `geolocation` 服务
- en: '[PRE88]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '***1* Defines a public member called getPosition that accepts three callback
    functions for success, error, and not supported**'
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义一个名为 getPosition 的公共成员，该成员接受三个回调函数，用于成功、错误和不支持**'
- en: '***2* If geolocation is supported, calls the native method, passing through
    success and error callbacks**'
  id: totrans-658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 如果支持地理位置，则调用本地方法，传递成功和错误回调**'
- en: '***3* If geolocation isn’t supported, invokes the not supported callback**'
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果不支持地理位置，则调用不支持回调**'
- en: That code gives you a geolocation service, with a public method, `getPosition`,
    to which you can pass three callback functions. This service checks to see whether
    the browser supports geolocation and then attempts to get the coordinates. Then
    the service calls one of the three different callbacks, depending on whether geolocation
    is supported and whether it was able to obtain the coordinates.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 那段代码为您提供了一个地理位置服务，其中有一个公开的方法 `getPosition`，您可以传递三个回调函数。此服务检查浏览器是否支持地理位置，然后尝试获取坐标。然后，根据地理位置是否受支持以及是否能够获取坐标，服务会调用三个不同的回调之一。
- en: The next step is adding the service to the application.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将服务添加到应用程序中。
- en: 9.3.2\. Adding the geolocation service to the application
  id: totrans-662
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.2\. 将地理位置服务添加到应用程序
- en: 'To use your new geolocation service, you need to import it into the `home-list`
    component, as you did for your data service. You need to do the following:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用您的新地理位置服务，您需要将其导入 `home-list` 组件中，就像您导入数据服务时做的那样。您需要执行以下操作：
- en: Import the service into the component.
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将服务导入组件中。
- en: Add the service to the providers in the decorator.
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将服务添加到装饰器中的提供者。
- en: Add the service to the class constructor.
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将服务添加到类构造函数中。
- en: The following listing highlights in bold the additions you need to make to the
    `home-list` component definition to import and register the geolocation service.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表以粗体突出显示您需要添加到 `home-list` 组件定义中以便导入和注册地理位置服务的修改。
- en: Listing 9.15\. Updating home-list.component.ts to bring in the geolocation service
  id: totrans-668
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.15\. 更新 home-list.component.ts 以引入地理位置服务
- en: '[PRE89]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '***1* Imports the geolocation service**'
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入地理位置服务**'
- en: '***2* Passes the service into the class constructor**'
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将服务传递到类构造函数**'
- en: When you’ve done this, you’ll be able to use the geolocation service from within
    your `home-list` component.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，您将能够在 `home-list` 组件内部使用地理位置服务。
- en: 9.3.3\. Using the geolocation service from the home-list component
  id: totrans-673
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.3\. 从 home-list 组件使用地理位置服务
- en: The `home-list` component now has access to the geolocation service, so use
    it! Remember, your `getPosition` method in the service accepts three callback
    functions, so you’ll need to create those functions before you can call the method.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '`home-list` 组件现在可以访问地理位置服务，所以请使用它！记住，服务中的 `getPosition` 方法接受三个回调函数，因此您在调用该方法之前需要创建这些函数。'
- en: As the geolocation process can take a few seconds before you even start searching
    the database for locations, you’ll also want to provide some useful messages to
    users so that they know what’s going on.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 由于地理位置过程可能需要几秒钟才能开始搜索数据库中的位置，因此您还希望向用户提供一些有用的消息，以便他们知道正在发生什么。
- en: 'You already have an element for messages in your HTML, but it’s currently in
    homepage.component.html, and you need it in home-list.component.html. Find the
    `<div class="error"></div>` in the homepage HTML and remove it. Then, paste it
    into the top of home-list.component.html, adding a binding so that you can display
    messages like so:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经在 HTML 中有一个用于消息的元素，但它目前位于 homepage.component.html 中，您需要将其放在 home-list.component.html
    中。在 homepage HTML 中找到 `<div class="error"></div>` 并将其删除。然后，将其粘贴到 home-list.component.html
    的顶部，添加一个绑定，以便您可以显示如下消息：
- en: '[PRE90]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: With this code, you’ll be able to use the message binding to keep the user up
    to date on what’s happening. Now you’re ready to create the callback functions.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码，您将能够使用消息绑定来让用户了解正在发生的事情。现在您已经准备好创建回调函数。
- en: Creating the geolocation callback functions
  id: totrans-679
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建地理位置回调函数
- en: 'Inside the component, create three new private members, one for each of the
    possible geolocation outcomes:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件内部创建三个新的私有成员，每个成员对应可能的地理位置结果：
- en: Successful geolocation attempt
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地理位置尝试成功
- en: Unsuccessful geolocation attempt
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地理位置尝试失败
- en: Geolocation not supported
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地理位置不受支持
- en: You’ll also update the messages being displayed to users, letting them know
    that the system is doing something. This message is particularly important, because
    geolocation can take a second or two.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 您还将更新显示给用户的消息，让他们知道系统正在做什么。这条消息尤其重要，因为地理位置可能需要一秒钟或两秒钟。
- en: 'The success callback is the existing `getLocations` method, with some additional
    message-setting thrown in: the other two set error messages, as shown in the following
    listing. As you’ll be using the message binding from within these new functions,
    you’ll also need to define it as a property of the class with type `string`.'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 成功回调是现有的`getLocations`方法，其中添加了一些额外的消息设置：其他两个设置错误消息，如下所示列表。由于您将在这些新函数内部使用消息绑定，您还需要将其定义为类的字符串类型属性。
- en: Listing 9.16\. Setting up the geolocation callback functions in home-list.component.ts
  id: totrans-686
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.16\. 在home-list.component.ts中设置地理位置回调函数
- en: '[PRE91]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '***1* Defines the message property of type string**'
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义了类型为字符串的消息属性**'
- en: '***2* Sets some messages inside the existing getLocations member**'
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在现有的getLocations成员内部设置一些消息**'
- en: '***3* The function to run if geolocation is supported but not successful**'
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果地理位置受支持但未成功时运行的函数**'
- en: '***4* The function to run if geolocation isn’t supported by browser**'
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 浏览器不支持地理位置时的运行函数**'
- en: You’ve got your three callback functions there for success, failure, and error.
    Now you need to use your geolocation service rather than call `getLocations()`
    on the `ngOnInit()` of the component.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经有了三个回调函数，用于成功、失败和错误。现在您需要使用您的地理位置服务，而不是在组件的`ngOnInit()`上调用`getLocations()`。
- en: Calling the geolocation service
  id: totrans-693
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 调用地理位置服务
- en: To call the `getPosition` method of your geolocation service, you’ll need to
    create a new member in the `home-list` component and call it on `init` instead
    of calling the `getLocations` method directly.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用您的地理位置服务的`getPosition`方法，您需要在`home-list`组件中创建一个新成员，并在`init`时调用它，而不是直接调用`getLocations`方法。
- en: 'Your geolocation service accepts three callback parameters—success, error,
    and unsupported—so you can add a new member to home-list.component.ts called `getPosition`
    that calls your service, passing through your callback functions. That member
    should look like this:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 您的地理位置服务接受三个回调参数——成功、错误和不受支持——因此您可以在home-list.component.ts中添加一个名为`getPosition`的新成员，该成员调用您的服务，并通过您的回调函数传递。该成员应如下所示：
- en: '[PRE92]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Then, you need to call this member when the component is initialized, instead
    of the `getLocations` method, so replace the call in `ngOnInit` to be this new
    member:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要在组件初始化时调用此成员，而不是`getLocations`方法，因此将`ngOnInit`中的调用替换为这个新成员：
- en: '[PRE93]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Save this code, and head to the browser. You should see something like [figure
    9.10](#ch09fig10), where the browser asks you for permission to access your location.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 保存此代码，然后转到浏览器。您应该会看到类似[图9.10](#ch09fig10)的内容，其中浏览器要求您允许访问您的位置。
- en: Figure 9.10\. A successful call to your geolocation service is marked by a browser
    request to know your location.
  id: totrans-700
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.10\. 成功调用您的地理位置服务是通过浏览器请求了解您的位置来标记的。
- en: '![](Images/09fig10_alt.jpg)'
  id: totrans-701
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig10_alt.jpg)'
- en: Great news—until you click Allow and the screen hangs on the `Getting your location`
    message, quietly throwing a JavaScript error in the background. The error you’re
    getting says `Cannot set property 'message' of null` and looks like [figure 9.11](#ch09fig11).
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息——直到您点击允许，屏幕在“获取您的位置”信息上挂起，在后台悄悄抛出一个JavaScript错误。您得到的错误说“无法设置null的属性'message'”，看起来像[图9.11](#ch09fig11)。
- en: Figure 9.11\. Error message shown when you’re trying to set messages in the
    geolocation callback
  id: totrans-703
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.11\. 尝试在地理位置回调中设置消息时显示的错误信息
- en: '![](Images/09fig11_alt.jpg)'
  id: totrans-704
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig11_alt.jpg)'
- en: This message tells you what the problem is and where it occurs, which helps
    you fix it.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 这条消息告诉您问题是什么以及它发生在哪里，这有助于您修复它。
- en: Working with this in callbacks across components and services
  id: totrans-706
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在组件和服务之间使用回调中的this
- en: You can see from the error in [figure 9.11](#ch09fig11) that it can’t set `this.message`
    inside the `getLocations` callback, because `this` is null. When passing the class
    member through as a callback, you lose the context of `this`, which is the instance
    of the class itself.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从图9.11中的错误中看到，它不能在`getLocations`回调中设置`this.message`，因为`this`是null。当通过回调函数传递类成员时，你失去了`this`的上下文，它是类的实例本身。
- en: Luckily, the fix is easy. You can send the context through by binding `this`
    to each callback as you send it. Where each callback function is passed, add `.bind(this)`
    to the end.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，修复很简单。你可以通过绑定`this`到每个回调函数来发送上下文。在每个回调函数被传递的地方，添加`.bind(this)`到末尾。
- en: Listing 9.17\. Binding `this` to geolocation callback functions in home-list.component.ts
  id: totrans-709
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.17\. 在home-list.component.ts中将`this`绑定到地理位置回调函数
- en: '[PRE94]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Now you’re binding the context of `this` to the callback function so that it
    exists when you need it. When you visit the browser again, you have success! After
    displaying a few messages and getting your location, the browser displays `home-list`
    again.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你正在将`this`的上下文绑定到回调函数，以便在需要时存在。当你再次访问浏览器时，你成功了！在显示了一些消息并获取了你的位置后，浏览器再次显示了`home-list`。
- en: But you’re not using the location yet. You’re getting it but doing nothing with
    it. You’ll change that situation next.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 但你还没有使用这个位置。你获取了它，但没有做什么。你将在下一部分改变这种情况。
- en: Using the geolocation coordinates to query the API
  id: totrans-713
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用地理位置坐标查询API
- en: In home-list.component.ts, the `getPosition` method calls your geolocation service
    to get the coordinates. When it’s successful, it calls the `getLocations` method—again
    in home-list.component.ts—as a callback, passing the position as a parameter.
    You need to update this callback to receive the position. Then this callback calls
    your data service to search for locations. You need to pass the coordinates to
    the service, and then update the service to use these values when calling the
    API.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 在`home-list.component.ts`中，`getPosition`方法调用你的地理位置服务以获取坐标。当它成功时，它调用`getLocations`方法——再次在`home-list.component.ts`中——作为一个回调，传递位置作为参数。你需要更新这个回调以接收位置。然后这个回调调用你的数据服务以搜索位置。你需要将坐标传递给服务，然后更新服务以在调用API时使用这些值。
- en: You have two things to update. Starting with `getLocations()` in home-list.component.ts,
    you need to update it to accept a position parameter, extract the coordinates
    from it, and pass them through to the data service, as highlighted in the following
    listing.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 你有两件事要更新。从`home-list.component.ts`中的`getLocations()`开始，你需要更新它以接受位置参数，从中提取坐标，并将它们传递到数据服务，如下面的列表所示。
- en: Listing 9.18\. Updating home-list.component.ts to use the geolocation position
  id: totrans-716
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.18\. 更新home-list.component.ts以使用地理位置位置
- en: '[PRE95]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '***1* Accepts the position as a parameter**'
  id: totrans-718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 接受位置作为参数**'
- en: '***2* Extracts the latitude and longitude coordinates from the position**'
  id: totrans-719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从位置中提取纬度和经度坐标**'
- en: '***3* Passes the coordinates to the data service call**'
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将坐标传递给数据服务调用**'
- en: You’re now getting the position from the geolocation service, extracting the
    latitude and longitude coordinates, and passing them to the data service. To get
    the last piece in place, you need to update the data service to accept the coordinate
    parameters and use them instead of the hardcoded values.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在正在从地理位置服务获取位置，提取纬度和经度坐标，并将它们传递给数据服务。为了使最后一部分到位，你需要更新数据服务以接受坐标参数并使用它们而不是硬编码的值。
- en: Listing 9.19\. Updating loc8r-data.service.ts to use the geolocation coordinates
  id: totrans-722
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.19\. 更新loc8r-data.service.ts以使用地理位置坐标
- en: '[PRE96]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '***1* Accepts lat and lng parameters of type number**'
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 接受lat和lng参数，类型为数字**'
- en: '***2* Deletes the hardcoded values you had for lat and lng before**'
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 删除之前为lat和lng设置的硬编码值**'
- en: Now the coordinates are finding their way from the geolocation service to the
    API call, so you’re now using Loc8r to find places near you! If you check it out
    in the browser—if you’ve added some places within 20 km of where you are—you should
    see them listed, as shown in [figure 9.12](#ch09fig12). You’ll probably notice
    a slight change in the distance coordinates, depending on how accurate your test
    data was.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，坐标正在从地理位置服务找到其路径到API调用，所以你现在正在使用Loc8r来查找你附近的地点！如果你在浏览器中查看——如果你添加了你所在位置20公里范围内的地点——你应该能看到它们被列出，如图9.12所示。你可能注意到距离坐标有轻微的变化，这取决于你的测试数据有多准确。
- en: Figure 9.12\. The Loc8r homepage as an Angular app, using geolocation to find
    places nearby from your own API
  id: totrans-727
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.12\. 作为 Angular 应用的 Loc8r 主页，使用地理位置从你的 API 中查找附近的地点
- en: '![](Images/09fig12_alt.jpg)'
  id: totrans-728
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig12_alt.jpg)'
- en: That’s the last piece of the puzzle for the homepage. Loc8r now finds your current
    location and lists the places near you, which was the whole idea from the start.
    The last thing you’ll do in this chapter is sort out the About page, during which
    you’ll explore the challenges of injecting HTML through Angular bindings.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是主页的最后一块拼图。Loc8r 现在可以找到你的当前位置，并列出附近的地点，这正是从开始时的整个想法。在本章的最后，你将整理关于页面，在这个过程中，你将探索通过
    Angular 绑定注入 HTML 的挑战。
- en: 9.4\. Safely binding HTML content
  id: totrans-730
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4\. 安全地绑定 HTML 内容
- en: The current status of the About page in the Angular SPA is that it exists only
    as a default skeleton page, as you created it to demonstrate navigation and routing
    in Angular. In this section, you’ll complete the page.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular SPA 中，关于页面的当前状态是它仅作为一个默认骨架页面存在，正如你创建它来演示 Angular 中的导航和路由。在本节中，你将完成这个页面。
- en: 9.4.1\. Adding the About page content to the app
  id: totrans-732
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.4.1\. 将关于页面内容添加到应用中
- en: The About page should be fairly straightforward. You add the content to the
    component definition and create the simple markup with the bindings to display
    it. Easy, right?
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 关于页面应该是相当直接的。你将内容添加到组件定义中，并创建简单的标记，通过绑定来显示它。简单，对吧？
- en: Start by adding the content to the component definition. In the following listing,
    you can see the class definition in about.component.ts. You’re defining a `pageContent`
    member to hold all the text information, as you’ve done before. We’ve trimmed
    the text in the main content area to save ink and trees.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 首先向组件定义中添加内容。在下面的列表中，你可以看到 about.component.ts 中的类定义。你正在定义一个 `pageContent` 成员来保存所有文本信息，就像你之前做的那样。我们已经裁剪了主要内容区域中的文本，以节省墨水和树木。
- en: Listing 9.20\. Creating the Angular controller for the About page
  id: totrans-735
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.20\. 为关于页面创建 Angular 控制器
- en: '[PRE97]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: As components go, this one is simple. No magic is going on here. Note, though,
    that you’ve still got the `\n` characters to denote line breaks.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 就组件而言，这个很简单。这里没有发生任何魔法。注意，尽管如此，你仍然有 `\n` 字符来表示换行。
- en: 'Next, you need to create the HTML layout. From your original Pug templates,
    you know what the markup needs to be; you need a page header and then a couple
    of `<div>`s to hold the content. For the page header, you can reuse the `pageHeader`
    component that you created earlier and pass the data through as you did for the
    homepage. There’s not much to the rest of the markup. The entire contents of about.component.html
    are shown in the following snippet:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要创建 HTML 布局。从你的原始 Pug 模板中，你知道标记需要是什么；你需要一个页面标题和几个 `<div>` 来存放内容。对于页面标题，你可以重用你之前创建的
    `pageHeader` 组件，并像为主页那样传递数据。其余的标记并不多。about.component.html 的全部内容如下所示：
- en: '[PRE98]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Again, nothing unusual here—only the page header, some HTML, and a standard
    Angular binding. If you look at this page in the browser, you’ll see that the
    content is coming through, but the line breaks aren’t displaying, as illustrated
    in [figure 9.13](#ch09fig13).
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这里没有什么不同寻常的——只有页面标题、一些 HTML 和标准的 Angular 绑定。如果你在浏览器中查看这个页面，你会看到内容正在通过，但换行符没有显示，如图
    [图 9.13](#ch09fig13) 所示。
- en: Figure 9.13\. The content for the About page is coming through from the controller,
    but the line breaks are being ignored.
  id: totrans-741
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.13\. 关于页面的内容是从控制器传来的，但换行符被忽略了。
- en: '![](Images/09fig13_alt.jpg)'
  id: totrans-742
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig13_alt.jpg)'
- en: This situation isn’t ideal. You want your text to be readable and shown as originally
    intended. If you can change the way that the distances appear on the homepage
    by using a pipe, why not do the same thing to fix the line breaks? Give it a shot,
    and create a new pipe.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况并不理想。你希望文本可读，并按原意显示。如果你可以通过使用管道更改主页上显示的距离，为什么不做同样的事情来修复换行符？试一试，创建一个新的管道。
- en: 9.4.2\. Creating a pipe to transform the line breaks
  id: totrans-744
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.4.2\. 创建一个管道来转换换行符
- en: 'You want to create a pipe that takes the provided text and replaces each instance
    of `\n` with a `<br/>` tag. You’ve already solved this problem in Pug by using
    a JavaScript `replace` command, as shown in the following code snippet:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 你想创建一个管道，它接受提供的文本，并将每个 `\n` 实例替换为 `<br/>` 标签。你已经在 Pug 中通过使用 JavaScript `replace`
    命令解决了这个问题，如下面的代码片段所示：
- en: '[PRE99]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: With Angular, you can’t do this inline. Instead, you need to create a pipe and
    apply it to the binding.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Angular，你不能这样做内联。相反，你需要创建一个管道并将其应用于绑定。
- en: Creating an htmlLineBreaks pipe
  id: totrans-748
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建 htmlLineBreaks 管道
- en: 'As you’ve already seen, pipes are best created by the Angular CLI, so run the
    following command in terminal to generate the files and register the pipe with
    the application:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，最佳创建管道的方式是通过 Angular CLI，因此请在终端中运行以下命令以生成文件并将管道注册到应用程序中：
- en: '[PRE100]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The pipe itself is fairly straightforward. It needs to accept incoming text
    as a string value. Replace each `\n` with a `<br/>`, and then return a string
    value. Update the main content of html-line-breaks.html to look like the following
    snippet:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 管道本身相当简单。它需要接受作为字符串值的传入文本。将每个 `\n` 替换为 `<br/>`，然后返回一个字符串值。将 html-line-breaks.html
    的主要内容更新如下所示：
- en: '[PRE101]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: When you’ve done that, try using it.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 您完成之后，尝试使用它。
- en: Applying the pipe to the binding
  id: totrans-754
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将管道应用于绑定
- en: 'Applying a pipe to a binding is simple; you’ve already done it a few times.
    In the HTML, add the pipe character (`|`) after the data object being bound, and
    follow it with the name of the filter like this:'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 将管道应用于绑定很简单；您已经做过几次了。在 HTML 中，在绑定的数据对象之后添加管道字符（`|`），然后跟随着过滤器的名称，如下所示：
- en: '[PRE102]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Simple, right? But if you try it in the browser, all isn’t quite as you’d hoped.
    As you can see in [figure 9.14](#ch09fig14), the line breaks are being replaced
    by `<br/>`, but they’re being displayed as text instead of rendering as HTML.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 简单吗？但如果您在浏览器中尝试，结果可能并不如您所愿。如图 9.14[图 9.14](#ch09fig14) 所示，换行符被 `<br/>` 替换，但它们被显示为文本而不是作为
    HTML 渲染。
- en: Figure 9.14\. The `<br/>` tags being inserted with your filter are being rendered
    as text rather than HTML tags.
  id: totrans-758
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.14\. 您使用过滤器插入的 `<br/>` 标签被渲染为文本而不是 HTML 标签。
- en: '![](Images/09fig14.jpg)'
  id: totrans-759
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig14.jpg)'
- en: 'Hmmmm, this isn’t quite what you wanted, but at least the pipe seems to be
    working. There’s a good reason for this output: security. Angular protects you
    and your application from malicious attacks by preventing HTML from being injected
    into a data binding. Think about when you let visitors write reviews for locations,
    for example. If they could add any HTML they wanted to, someone could easily insert
    a `<script>` tag and run some JavaScript, hijacking the page.'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯嗯，这并不是您想要的，但至少管道似乎在正常工作。这种输出的原因很好：安全性。Angular 通过防止 HTML 注入数据绑定来保护您和您的应用程序免受恶意攻击。例如，当您允许访客为地点撰写评论时，请考虑这一点。如果他们可以添加任何他们想要的
    HTML，有人可以轻松地插入一个 `<script>` 标签并运行一些 JavaScript，从而劫持页面。
- en: But there’s a way to let a subset of HTML tags through into a binding, which
    you’ll look at next.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 但有一种方法可以让 HTML 标签的子集通过绑定，您将在下一节中看到。
- en: 9.4.3\. Safely binding HTML by using a property binding
  id: totrans-762
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.4.3\. 使用属性绑定安全地绑定 HTML
- en: Angular lets you pass through some HTML tags if you use a property binding instead
    of the default bindings you normally use for content. This technique works only
    for a subset of HTML tags to prevent XSS hacks, attacks, and weaknesses. Think
    of property binding as being “one-way” binding. The component can’t read the data
    back out and use it, but it can update it and change the data in the binding.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用属性绑定而不是通常用于内容的默认绑定，Angular 允许您传递一些 HTML 标签。此技术仅适用于 HTML 标签的子集，以防止 XSS 漏洞、攻击和弱点。将属性绑定视为“单向”绑定。组件不能读取数据并将其用于其他地方，但它可以更新它并更改绑定中的数据。
- en: You used property bindings when you passed data into nested components. Remember
    building the About page? There, you were binding data to a property you defined
    in the nested component, which you called `content`. Here, you’re binding to a
    native property of a tag—in this case, `innerHTML`.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将数据传递到嵌套组件时，您已经使用了属性绑定。记得您构建关于页面吗？在那里，您将数据绑定到嵌套组件中定义的属性，您称之为 `content`。在这里，您绑定到一个标签的本地属性——在这种情况下，`innerHTML`。
- en: 'Property bindings are denoted by wrapping square brackets around them and then
    passing the value. You can remove the content binding in about.component.html
    and use a property binding:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 属性绑定通过将它们括在方括号中来表示，然后传递值。您可以在 about.component.html 中删除内容绑定并使用属性绑定：
- en: '[PRE103]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Note that you can apply pipes to this type of binding too, so you’re still using
    your `htmlLineBreaks` pipe. Finally, when you view the About page in the browser,
    you’ll see the line breaks in place, looking like [figure 9.15](#ch09fig15).
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您也可以将管道应用于此类绑定，因此您仍在使用您的 `htmlLineBreaks` 管道。最后，当您在浏览器中查看关于页面时，您将看到换行符正确显示，就像
    [图 9.15](#ch09fig15) 所示。
- en: Figure 9.15\. Using the `htmlLineBreaks` pipe in conjunction with the property
    binding, you now see the line breaks rendering as intended.
  id: totrans-768
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.15\. 使用 `htmlLineBreaks` 管道与属性绑定结合，您现在可以看到换行符按预期渲染。
- en: '![](Images/09fig15_alt.jpg)'
  id: totrans-769
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig15_alt.jpg)'
- en: Success! You’ve made a great start toward building Loc8r as an Angular SPA.
    You’ve got a couple of pages, some routing and navigation, geolocation, and a
    great modular application architecture. Keep on moving!
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！你已经在构建Loc8r作为Angular SPA方面取得了良好的开端。你已经有了几个页面，一些路由和导航，地理位置，以及一个优秀的模块化应用程序架构。继续前进吧！
- en: 9.5\. Challenge
  id: totrans-771
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5\. 挑战
- en: Use what you’ve learned about Angular so far and create a new component called
    `rating-stars`. This component will be used in the homepage listing section and
    in the other places where you display rating stars, which you’ll be building out
    in the next section.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你到目前为止学到的Angular知识，创建一个新的组件名为`rating-stars`。这个组件将在主页列表部分以及其他显示评分星号的地方使用，你将在下一节构建这些部分。
- en: This new component should
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新组件应该
- en: Accept an incoming number value (the rating)
  id: totrans-774
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受传入的数字值（评分）
- en: Display the correct number of solid stars based on the rating
  id: totrans-775
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据评分显示正确的实心星号数量
- en: Be reusable many times on a single page
  id: totrans-776
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单个页面上多次可重用
- en: 'As a clue, your elements should look something like this:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提示，你的元素应该看起来像这样：
- en: '[PRE104]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Good luck! The code (should you need it) is available in GitHub, on the chapter-09
    branch.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 祝你好运！如果你需要，代码（如果需要）可在GitHub上找到，位于chapter-09分支。
- en: In [chapter 10](kindle_split_022.xhtml#ch10), you’ll continue building out the
    Angular SPA, encountering more-complex page layouts and modal popups, and accepting
    user input via forms.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](kindle_split_022.xhtml#ch10)中，你将继续构建Angular SPA，遇到更复杂的页面布局和模态弹出窗口，并通过表单接受用户输入。
- en: Summary
  id: totrans-781
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了
- en: That Angular has a Router and how it works
  id: totrans-783
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular有一个路由器以及它是如何工作的
- en: How to build a functional website and use site navigation
  id: totrans-784
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建一个功能网站并使用网站导航
- en: That using nested components to create a modular and scalable application is
    best practice
  id: totrans-785
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用嵌套组件创建模块化和可扩展的应用程序是最佳实践
- en: How to work with external interfaces like the browser’s geolocation capabilities
  id: totrans-786
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何与外部接口如浏览器的地理位置功能一起工作
- en: 'Chapter 10\. Building a single-page application with Angular: The next level'
  id: totrans-787
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10章\. 使用Angular构建单页应用程序：下一个层次
- en: '*This chapter covers*'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Routing with URL parameters in Angular
  id: totrans-789
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Angular中使用URL参数进行路由
- en: Querying the API with URL parameter data
  id: totrans-790
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用URL参数数据查询API
- en: Building more-complex layouts and handling form submissions
  id: totrans-791
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建更复杂的布局和处理表单提交
- en: Creating a separate router configuration file
  id: totrans-792
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个单独的路由器配置文件
- en: Replacing the Express UI with the Angular app
  id: totrans-793
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用Angular应用替换Express UI
- en: In this chapter, you’ll follow on from the work you started in [chapter 9](kindle_split_021.xhtml#ch09)
    with building a single-page application (SPA). By the end of this chapter, the
    Loc8r application will be a single Angular application that uses your API to get
    the data.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将继续在[第9章](kindle_split_021.xhtml#ch09)中开始的工作，构建一个单页应用程序（SPA）。到本章结束时，Loc8r应用程序将是一个使用你的API获取数据的单个Angular应用程序。
- en: '[Figure 10.1](#ch10fig01) shows where you are in the overall plan, still recreating
    the main application as an Angular SPA.'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10.1](#ch10fig01)显示了你在整体计划中的位置，仍然在重建主要应用程序作为Angular SPA。'
- en: 'Figure 10.1\. This chapter continues the work you started in [chapter 9](kindle_split_021.xhtml#ch09):
    recreating the Loc8r application as an Angular SPA, moving the application logic
    from the back end to the front end.'
  id: totrans-796
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.1\. 本章继续你在[第9章](kindle_split_021.xhtml#ch09)中开始的工作：将Loc8r应用程序作为Angular SPA重建，将应用程序逻辑从后端移到前端。
- en: '![](Images/10fig01_alt.jpg)'
  id: totrans-797
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10fig01_alt.jpg)'
- en: You’ll start by creating the missing pages and functionality, and see how to
    use URL parameters in routes, including using them when querying the API. When
    you’ve got most of the functionality in place, you’ll build the form to add new
    reviews, but rather than have a separate page as you had in Express, you’ll include
    the form inline and be able to add reviews without leaving the Details page. This
    technique is an SPA way of doing things and eliminates extra round trips to the
    server. When everything’s running, you’ll look at a couple of ways to improve
    the architecture to follow some Angular and TypeScript best practices.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从创建缺失的页面和功能开始，了解如何在路由中使用URL参数，包括在查询API时使用它们。当你已经实现了大部分功能后，你将构建一个表单来添加新的评论，但与Express中的单独页面不同，你将内联包含该表单，并能够在不离开详情页的情况下添加评论。这种技术是一种SPA方式，可以消除额外的服务器往返。当一切运行正常时，你将查看几种改进架构的方法，以遵循一些Angular和TypeScript的最佳实践。
- en: To finish, you’ll use your Angular application as the front end for Loc8r, eliminating
    the need for the public-facing part of the Express application.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将使用你的Angular应用程序作为Loc8r的前端，消除Express应用程序公共部分的需求。
- en: 10.1\. Working with more-complex views and routing parameters
  id: totrans-800
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1\. 使用更复杂的视图和路由参数
- en: In this section, you’ll add the Details page to the Angular SPA. One crucial
    aspect is retrieving the location ID from the URL parameter to ensure that you
    get the correct data. Using URL parameters in this way is common practice and
    is a useful technique to know in any framework. You’ll also have to update the
    data service to ask the API for specific location details. As you translate the
    Pug view into an Angular template, you’ll also discover some additional functionality
    that Angular provides to help you create the various layouts required.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将向Angular SPA添加详情页面。一个关键方面是从URL参数中检索位置ID，以确保你得到正确的数据。以这种方式使用URL参数是常见的做法，并且是任何框架中都知道的有用技术。你还将不得不更新数据服务，以请求API的具体位置详情。当你将Pug视图转换为Angular模板时，你还将发现Angular提供的一些额外功能，以帮助你创建所需的多种布局。
- en: You’ve got a lot to do, so before you get into the fun stuff, you’d better plan
    it.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 你有很多事情要做，所以在你开始有趣的部分之前，你最好先规划一下。
- en: 10.1.1\. Planning the layout
  id: totrans-803
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.1\. 规划布局
- en: The Details page has quite a bit more to it than the others you’ve made in Angular
    so far, but as you know what it looks like, you can start to plan it from a high
    level. When that’s done, it’ll be easier to add the details.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 与你在Angular中迄今为止制作的页面相比，详情页面有更多内容，但正如你所知它看起来是什么样子，你可以从高层次开始规划。完成这个之后，添加细节会更容易。
- en: By looking at the layout and what you’ve done already, you can begin to see
    the different components you’ll need and how to nest them. You’ll keep the existing
    framework component on the outside, of course, containing the navigation and footer.
    In the routable area, you’ll have a new details-page component containing the
    page header, sidebar, and main content. [Figure 10.2](#ch10fig02) shows a sketch
    of this layout plan over-laid on a screenshot of the Details page itself.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看布局和已经完成的工作，你可以开始看到你需要的不同组件以及如何嵌套它们。当然，你将保留现有的框架组件在外部，包含导航和页脚。在可路由区域，你将有一个新的详情页面组件，包含页面标题、侧边栏和主要内容。[图10.2](#ch10fig02)显示了在详情页面截图上叠加的这种布局规划草图。
- en: Figure 10.2\. Planning the components and nesting needed for building the Details
    page in Angular
  id: totrans-806
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.2\. 规划在Angular中构建详情页面所需的组件和嵌套
- en: '![](Images/10fig02_alt.jpg)'
  id: totrans-807
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/10fig02_alt.jpg)'
- en: 'This plan gives you a good idea of what you need to build and what you can
    reuse. We hope that you’re starting to see why creating reusable components is
    a good idea! At this point, note that you need some of the location data in three
    components: the page header, the location details component, and the sidebar.
    You’ll need to take this fact into consideration when coding the page.'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规划让你对需要构建的内容和可以重用的内容有了很好的了解。我们希望你现在开始明白为什么创建可重用组件是个好主意！在此阶段，请注意，你需要在三个组件中使用一些位置数据：页面标题、位置详情组件和侧边栏。在编写页面代码时，你需要考虑这个事实。
- en: 'Of the five components in the plan, you need to create two: the Details page
    component to organize all the others and the location details component to display
    the actual details. You’ll create basic versions of these components next so that
    you have a page to route to.'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 在计划中的五个组件中，你需要创建两个：用于组织其他所有组件的详情页面组件，以及用于显示实际详情的位置详情组件。你将接下来创建这些组件的基本版本，以便有一个可以路由到的页面。
- en: 10.1.2\. Creating the required components
  id: totrans-810
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.2\. 创建所需的组件
- en: You know that you want a Details page component containing the location details
    along with the sidebar and header. The location details component is missing,
    so you’ll create a skeleton of that first. Then you can create the framework component
    ready for routing.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道你想要一个包含位置详情、侧边栏和标题的详情页面组件。位置详情组件缺失，所以你将首先创建它的骨架。然后你可以创建准备路由的框架组件。
- en: 'Use the Angular CLI to create the location details component; run the following
    command in terminal in the app_public folder:'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Angular CLI创建位置详情组件；在app_public文件夹的终端中运行以下命令：
- en: '[PRE105]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'You can leave the default content in this new component for the time being,
    as you’ll build it out properly soon. Next, create the Details page component,
    and add the skeleton layout to it. In terminal, use the Angular CLI again with
    the following command:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以先在这个新组件中保留默认内容，因为你很快就会正确地构建它。接下来，创建详情页面组件，并向其中添加骨架布局。在终端中，再次使用Angular CLI，使用以下命令：
- en: '[PRE106]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'You’ll add some content to this component, as it’s going to hold the other
    components for the page: the page header, location details, and sidebar. [Listing
    10.1](#ch10ex01) shows how you want to lay these components out in details-page.component.html.
    You’ll also add the `content` bindings for the page header and sidebar so that
    you can pass in information from this component.'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 你将向这个组件添加一些内容，因为它将包含页面的其他组件：页面标题、位置详情和侧边栏。[列表10.1](#ch10ex01)显示了你在details-page.component.html中想要如何详细布局这些组件。你还将添加页面标题和侧边栏的`content`绑定，以便你可以从这个组件传递信息。
- en: Listing 10.1\. The basic layout for details-page.component.html
  id: totrans-817
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.1\. details-page.component.html的基本布局
- en: '[PRE107]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '***1* Page header component, including a property binding**'
  id: totrans-819
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 页面标题组件，包括属性绑定**'
- en: '***2* Location details component**'
  id: totrans-820
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 位置详情组件**'
- en: '***3* Sidebar component, including a property binding**'
  id: totrans-821
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 侧边栏组件，包括属性绑定**'
- en: So that you’ll be able to see the content in the header and sidebar, you’ll
    create some default content. In the HTML for the Details page component, you’ll
    use the bindings `pageContent.header` and `pageContent.sidebar`, so in the component
    class, you’ll create a corresponding `pageContent` member containing `header`
    and `sidebar` properties. The following listing shows what this looks like in
    details-page.component.ts, also giving the content properties some default text.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你能够看到标题和侧边栏中的内容，你将创建一些默认内容。在详情页面组件的HTML中，你将使用绑定`pageContent.header`和`pageContent.sidebar`，因此，在组件类中，你将创建一个相应的`pageContent`成员，包含`header`和`sidebar`属性。以下列表显示了在details-page.component.ts中的样子，同时也为内容属性提供了一些默认文本。
- en: Listing 10.2\. The starting content for the Details page in details-page.component.ts
  id: totrans-823
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.2\. 在details-page.component.ts中详情页面的起始内容
- en: '[PRE108]'
  id: totrans-824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '***1* The new pageContent member containing . . .**'
  id: totrans-825
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 包含 . . . 的新pageContent成员**'
- en: '***2* header details and . . .**'
  id: totrans-826
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 标题详情和 . . .**'
- en: '***3* . . . sidebar content**'
  id: totrans-827
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* . . . 侧边栏内容**'
- en: Now you’ve got your Details page component, containing the three nested components
    you need to lay out the page. You’ve even got some starting data being passed
    into two of the nested components.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了你的详情页面组件，其中包含你需要来布局页面的三个嵌套组件。你甚至已经将一些起始数据传递给了两个嵌套组件。
- en: You’re ready to set up the routing so that you can see the page.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经准备好设置路由，以便你可以看到页面。
- en: 10.1.3\. Setting up and defining routes with URL parameters
  id: totrans-830
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.3\. 使用URL参数设置和定义路由
- en: Defining routes with URL parameters is as easy in Angular as it is in Express.
    Even the syntax is the same—not something you hear often in the programming world!
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中使用URL参数定义路由与在Express中一样简单。甚至语法也是相同的——这在编程世界中并不常见！
- en: 'Your routes for the app are defined in app.module.ts, so that’s where you’ll
    add the new one. As you want to accept a URL parameter, you’ll define the route
    the same way you did in Express: by putting a `locationId` variable at the end
    of the path, preceded by a colon.'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用路由在app.module.ts中定义，所以你将在那里添加新的路由。因为你想要接受一个URL参数，所以你将以与在Express中相同的方式定义路由：在路径末尾放置一个`locationId`变量，前面加冒号。
- en: Listing 10.3\. Adding the Details page route to app.module.ts
  id: totrans-833
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.3\. 在app.module.ts中添加详情页面路由
- en: '[PRE109]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '***1* Defines a ‘locationId’ URL parameter in the route by prefixing it with
    a colon**'
  id: totrans-835
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 通过在前面加冒号来在路由中定义一个‘locationId’ URL参数**'
- en: With that in place, you can go to location/*something* in the browser, and Angular
    will route you to the Details page component. At the moment, this component looks
    like [figure 10.3](#ch10fig03).
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一来，你就可以在浏览器中访问location/*something*，Angular会路由你到详情页面组件。目前，这个组件看起来像[图10.3](#ch10fig03)。
- en: Figure 10.3\. Testing the new location details route and seeing the default
    content you added to the components
  id: totrans-837
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.3\. 测试新的位置详情路由并查看你添加到组件中的默认内容
- en: '![](Images/10fig03_alt.jpg)'
  id: totrans-838
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10fig03_alt.jpg)'
- en: 'If you remember from your original layouts, the sidebar content in this page
    should be in two paragraphs, so your line breaks aren’t coming through. Fortunately,
    you’ve already created a pipe for that purpose. You need to update the sidebar
    component to use it. In sidebar.component.html, change the Angular binding to
    an `innerHTML` property binding, passing in the content and the `htmlLineBreaks`
    pipe like this:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得您原始布局，这个页面侧边栏的内容应该分为两段，所以您的换行符不会显示出来。幸运的是，您已经为这个目的创建了一个管道。您需要更新侧边栏组件以使用它。在sidebar.component.html中，将Angular绑定更改为`innerHTML`属性绑定，传递内容和`htmlLineBreaks`管道，如下所示：
- en: '[PRE110]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Now the `\n` parts of the sidebar content are converted to `<br/>` tags and
    rendered as HTML, looking like [figure 10.4](#ch10fig04).
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 现在侧边栏内容的`\n`部分被转换为`<br/>`标签并作为HTML渲染，看起来像[图10.4](#ch10fig04)。
- en: Figure 10.4\. Enabling line breaks in the sidebar by using your custom pipe
  id: totrans-842
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.4. 通过使用您自定义的管道启用侧边栏中的换行
- en: '![](Images/10fig04.jpg)'
  id: totrans-843
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10fig04.jpg)'
- en: The general page layout looks good, and you can see that it’s working. Before
    you build it out, it would be useful to navigate to this page with real location
    IDs in the URL. To do so, you need to update the links in the homepage listings.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 通用页面布局看起来不错，您可以看到它在工作。在构建它之前，使用URL中的真实位置ID导航到这个页面会有所帮助。为此，您需要更新主页列表中的链接。
- en: Creating Angular links to the Details page
  id: totrans-845
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建指向详情页面的Angular链接
- en: The homepage listing currently displays links to this page, and if you try them,
    they take you there. But you may well notice that when you do, the page flickers.
    This happens because the links are standard `href` attributes in an `<a>` tag,
    so the browser follows them like normal links. The result is that the page has
    a full reload and reloads the Angular application—not what you want in an SPA!
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 首页列表当前显示指向此页面的链接，如果您尝试它们，它们会带您去那里。但您可能会注意到，当您这样做时，页面会闪烁。这是因为链接是标准`href`属性，在`<a>`标签中，所以浏览器像正常链接一样跟随它们。结果是页面完全重新加载并重新加载Angular应用程序——这不是您在SPA中想要的！
- en: 'You want Angular to capture clicks of these links and to handle the navigation
    and routing. When you created the navigation, you used `routerLink` instead of
    `href` in the `<a>` tags, and you need to do the same here. In home-list.component.html,
    find the link to the location, and swap out the `href` attribute:'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望Angular捕获这些链接的点击并处理导航和路由。当您创建导航时，您在`<a>`标签中使用了`routerLink`而不是`href`，您需要在这里做同样的事情。在home-list.component.html中找到位置链接，并替换`href`属性：
- en: '[PRE111]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The rest of the code can stay the same. With that simple change, you’ve made
    your app even more like a proper SPA. Now you’re ready to start using the URL
    parameter in the page.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的代码可以保持不变。通过这个简单的更改，您已经使您的应用更像一个真正的SPA。现在您可以使用页面中的URL参数了。
- en: 10.1.4\. Using URL parameters in components and services
  id: totrans-850
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.4. 在组件和服务中使用URL参数
- en: The plan is to get the location ID URL parameter and use it in a call to the
    API to get the details for a specific location. When the data comes back, you
    want to display it on the page.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 计划获取位置ID URL参数并在调用API以获取特定位置详情时使用它。当数据返回时，您想在页面上显示它。
- en: Where’s the best place to put this logic? Any of the components in the routable
    area could be configured to get the URL parameter and call the API, but you want
    to display data in all three nested components. So you’ll go for the approach
    of using the “parent” Details page component to get the data and then pass it
    through to the three child components. First, you’ll add a method to your data
    service to call the API to get a single location by ID.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 这个逻辑的最佳位置在哪里？任何可路由区域的组件都可以配置为获取URL参数并调用API，但您希望显示所有三个嵌套组件中的数据。所以您将采用使用“父”详情页面组件获取数据然后传递给三个子组件的方法。首先，您需要向数据服务添加一个方法来通过ID获取单个位置。
- en: Creating the data service to call the API
  id: totrans-853
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建调用API的数据服务
- en: 'The data service that you created in [chapter 8](kindle_split_020.xhtml#ch08)
    currently has a single method: `getLocations`. This method retrieves a list of
    locations when given a pair of coordinates. The new method you need has a similar
    construct, so make a copy of this method in loc8r-data.service.ts and call it
    `getLocationById`.'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 您在[第8章](kindle_split_020.xhtml#ch08)中创建的数据服务目前只有一个方法：`getLocations`。这个方法在给定一对坐标时检索位置列表。您需要的新方法具有类似的构造，所以请在loc8r-data.service.ts中复制此方法并命名为`getLocationById`。
- en: 'You need to make a few small adjustments to get this method working:'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要做一些小的调整才能使此方法正常工作：
- en: Change the expected input parameters to a single `locationId` of type `string`.
  id: totrans-856
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将期望的输入参数更改为单个 `locationId` 类型为 `string`。
- en: Change the return type to a single `Location` instance instead of an array.
  id: totrans-857
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将返回类型更改为单个 `Location` 实例而不是数组。
- en: Change the API URL to call, using `locationId` as a URL parameter.
  id: totrans-858
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 API URL 更改为使用 `locationId` 作为 URL 参数进行调用。
- en: Set the JSON response to a single `Location` instance.
  id: totrans-859
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 JSON 响应设置为单个 `Location` 实例。
- en: The following listing shows how this method looks in code, in loc8r-data.service.ts.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了在 loc8r-data.service.ts 中的代码中这个方法的样子。
- en: Listing 10.4\. Adding a method to get a location by ID in loc8r-data.service.ts
  id: totrans-861
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.4\. 在 loc8r-data.service.ts 中添加一个通过 ID 获取位置的方法
- en: '[PRE112]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '***1* Sets the correct input parameters and expected return type, both single
    items**'
  id: totrans-863
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 设置正确的输入参数和期望的返回类型，都是单个项目**'
- en: '***2* Changes the API URL to use the location ID as a URL parameter**'
  id: totrans-864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将 API URL 更改为使用位置 ID 作为 URL 参数**'
- en: '***3* Sets the JSON response to be a single Location instance**'
  id: totrans-865
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将 JSON 响应设置为单个 Location 实例**'
- en: With the data service method ready, you can import the service into the Details
    page component, ready to use.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 数据服务方法准备好后，你可以将其导入到详情页面组件中，准备使用。
- en: Importing the data service into the component
  id: totrans-867
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将数据服务导入到组件中
- en: You’ve imported a service into a component before—the data service into the
    `home-list` component—so we won’t dwell on the process too much here. You’ll need
    to import the data service into the Details page component, add it to the providers,
    and then make it available by declaring it in the class constructor.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前已经将一个服务导入到组件中过——将数据服务导入到 `home-list` 组件中——所以我们在这里不会过多地讨论这个过程。你需要将数据服务导入到详情页面组件中，将其添加到提供者中，然后在类构造函数中声明它以使其可用。
- en: While you’re here, you’ll also import the `Location` class from the `home-list`
    component and empty the default page content. All these updates to details-page.component
    are shown in the following listing.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在这里时，你还将从 `home-list` 组件中导入 `Location` 类并清空默认页面内容。以下列表显示了 details-page.component
    的所有这些更新。
- en: Listing 10.5\. Importing your data service in details-page.component.ts
  id: totrans-870
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.5\. 在 details-page.component.ts 中详细导入数据服务
- en: '[PRE113]'
  id: totrans-871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '***1* Imports your data service**'
  id: totrans-872
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入你的数据服务**'
- en: '***2* Imports the Location class definition**'
  id: totrans-873
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 导入 Location 类定义**'
- en: '***3* Creates a private local instance of the data service**'
  id: totrans-874
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 创建数据服务的私有本地实例**'
- en: '***4* Clears the default page content**'
  id: totrans-875
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 清除默认页面内容**'
- en: 'The only real thing to be careful with here is the case of `loc8rDataService`
    in the constructor: the class type definition has an uppercase `L`, and the local
    instance is defined with a lowercase `l`.'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一需要小心的是构造函数中的 `loc8rDataService` 的情况：类的类型定义有一个大写的 `L`，而本地实例是用小写的 `l` 定义的。
- en: Now you’re ready to get the URL parameter into the component.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以将 URL 参数获取到组件中。
- en: Using URL parameters in a component
  id: totrans-878
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在组件中使用 URL 参数
- en: 'Given that using URL parameters in an app is a common requirement, the process
    is surprisingly complicated. You need three new pieces of functionality:'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在应用程序中使用 URL 参数是一个常见的需求，这个过程出人意料地复杂。你需要三个新的功能组件：
- en: '`ActivatedRoute` from the Angular router to get you the value of the current
    route from inside the component'
  id: totrans-880
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Angular 路由器中导入 `ActivatedRoute` 以从组件内部获取当前路由的值
- en: '`ParamMap` from the Angular router to get you the URL parameters of the active
    route as an Observable'
  id: totrans-881
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Angular 路由器中导入 `ParamMap` 以获取活动路由的 URL 参数作为可观察对象
- en: '`switchMap` from RxJS to get the values from the `ParamMap` Observable and
    use them to call your API, creating a second Observable'
  id: totrans-882
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 RxJS 中导入 `switchMap` 以从 `ParamMap` 可观察对象中获取值，并使用它们来调用你的 API，创建第二个可观察对象
- en: 'The following snippet shows in bold the additions needed in details-page.component.ts
    to import these pieces of functionality:'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段以粗体显示了在 details-page.component.ts 中需要导入这些功能组件的添加内容：
- en: '[PRE114]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'You also need to make the activated route available to the component by defining
    a private member `route` of type `ActivatedRoute` in the constructor:'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要通过在构造函数中定义一个类型为 `ActivatedRoute` 的私有成员 `route` 来使激活的路由对组件可用：
- en: '[PRE115]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Now comes the complicated bit. Complete these steps to get a location ID from
    the URL parameter and turn it into location data from the API:'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是复杂的部分。完成以下步骤以从 URL 参数中获取位置 ID 并将其转换为 API 中的位置数据：
- en: When the component initializes, use `switchMap` to subscribe to the `paramMap`
    Observable of the activated route.
  id: totrans-888
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当组件初始化时，使用 `switchMap` 订阅到激活路由的 `paramMap` 可观察对象。
- en: When the `paramMap` Observable returns a `ParamMap` object, get the value of
    the `locationId` URL parameter.
  id: totrans-889
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 `paramMap` `Observable` 返回一个 `ParamMap` 对象时，获取 `locationId` URL 参数的值。
- en: Call the `getLocationsById` method of your data service, passing it the ID.
  id: totrans-890
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用你的数据服务的 `getLocationsById` 方法，并传入 ID。
- en: Return the API call so that it returns an Observable.
  id: totrans-891
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 API 调用，使其返回一个 `Observable`。
- en: Subscribe to listen for when the Observable returns the data from your API.
    The result should be a single object of type `Location`.
  id: totrans-892
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订阅以监听当 `Observable` 从你的 API 返回数据时。结果应该是一个类型为 `Location` 的单个对象。
- en: Set the content for the page header and sidebar, using the location name returned
    from the API.
  id: totrans-893
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用从 API 返回的位置名称设置页眉和侧边栏的内容。
- en: Phew! That’s a lot of steps for a seemingly simple process. All this takes place
    in the `ngOnInit` lifecycle hook in details-page.component.ts. The next listing
    shows what the code looks like.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！对于一个看似简单的流程来说，这些步骤真是太多了。所有这些都在 `details-page.component.ts` 中的 `ngOnInit` 生命周期钩子中完成。接下来的列表显示了代码的样子。
- en: Listing 10.6\. Getting and using the URL parameter in details-page.component.ts
  id: totrans-895
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.6\. 在 `details-page.component.ts` 中获取和使用 URL 参数
- en: '[PRE116]'
  id: totrans-896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '***1* Gets the paramMap Observable of the activated route**'
  id: totrans-897
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** 获取激活路由的 `paramMap` `Observable`。'
- en: '***2* Uses the pipe operator to compose a sequence of operations that will
    act on the Observable**'
  id: totrans-898
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** 使用管道操作符组合一系列将作用于 `Observable` 的操作。'
- en: '***3* Uses switchMap to extract the required elements from the ParamMap and
    return an Observable**'
  id: totrans-899
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3** 使用 `switchMap` 从 `ParamMap` 中提取所需元素，并返回一个 `Observable`。'
- en: '***4* Uses the .get method to get the value of the locationId URL parameter
    from the ParamMap**'
  id: totrans-900
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**4** 使用 `.get` 方法从 `ParamMap` 中获取 `locationId` URL 参数的值。'
- en: '***5* Makes the call to your new data service method, returning it as an Observable**'
  id: totrans-901
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**5** 调用你的新数据服务方法，将其作为 `Observable` 返回。'
- en: '***6* Subscribes to the API call Observable, expecting a Location back**'
  id: totrans-902
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**6** 订阅 API 调用 `Observable`，期望返回一个 `Location`。'
- en: '***7* Sends the location name to the page header and sidebar**'
  id: totrans-903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**7** 将位置名称发送到页眉和侧边栏。'
- en: 'That’s some fairly dense code; a lot is happening in a few lines and commands.
    We recommend reading the plan and the annotated code a few times to piece everything
    together. It’s powerful, a little different from what you’ve seen so far, and
    about as complex as you’ll see in this book. In particular, note the two chained
    Observables: first, the route `paramMap` being subscribed to by the `switchMap`,
    which returns the second.'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码相当密集；在几行和命令中发生了很多事情。我们建议多次阅读计划和注释代码，以拼凑出所有内容。它很强大，与之前看到的不同，并且在这本书中你将看到的复杂度相当。特别是注意两个链式
    `Observable`：首先，`paramMap` 被订阅，由 `switchMap` 返回第二个。
- en: The good news is that when you’re done, your Details page shows the location
    name in the page header and the sidebar, as shown in [figure 10.5](#ch10fig05).
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，当你完成时，你的 Details 页面会在页眉和侧边栏中显示位置名称，如图 [图 10.5](#ch10fig05) 所示。
- en: Figure 10.5\. Displaying the location name in the header and sidebar after getting
    the location ID from the URL and sending it to the API
  id: totrans-906
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.5\. 在从 URL 获取位置 ID 并将其发送到 API 后，在页眉和侧边栏中显示位置名称
- en: '![](Images/10fig05_alt.jpg)'
  id: totrans-907
  prefs: []
  type: TYPE_IMG
  zh: '![图片 10.5](Images/10fig05_alt.jpg)'
- en: You’re now using the location ID in the URL to query the database and passing
    a bit of the returned data to two of the components on the page. Before you build
    out the main part of the Details page, make sure that the final component is getting
    the data it needs.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你正在使用 URL 中的位置 ID 来查询数据库，并将返回的数据的一部分传递给页面上的两个组件。在构建 Details 页面的主要部分之前，确保最终组件正在获取它所需的数据。
- en: 10.1.5\. Passing data to the Details page component
  id: totrans-909
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.5\. 将数据传递给 Details 页面组件
- en: 'To pass the location data from the Details page component to the nested location
    details component, you need to do three things:'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 要将位置数据从 Details 页面组件传递到嵌套的位置详情组件，你需要做三件事：
- en: Add a class member to the Details page component to hold the location data when
    you get it back from the data service.
  id: totrans-911
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在从数据服务获取位置数据后，将一个类成员添加到 Details 页面组件中，用于保存位置数据。
- en: Pass the data into the child component, using a property binding in the HTML.
  id: totrans-912
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 HTML 中的属性绑定将数据传递给子组件。
- en: Update the location details component to accept this incoming data.
  id: totrans-913
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新位置详情组件以接受传入的数据。
- en: First, as shown in [listing 10.7](#ch10ex07), define a new member `newLocation`
    of type `Location` in details-page.component.ts, and give it a value when you
    get a location back from the API call.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如 [列表 10.7](#ch10ex07) 所示，在 `details-page.component.ts` 中定义一个新的 `Location`
    类成员 `newLocation`，并在从 API 调用获取位置后为其赋值。
- en: Listing 10.7\. Exposing the found location details in details-page.component.ts
  id: totrans-915
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.7\. 在 details-page.component.ts 中公开找到的位置详情
- en: '[PRE117]'
  id: totrans-916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '***1* Updating the local newLocation with that received from the Observable**'
  id: totrans-917
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 更新本地 newLocation 以接收来自 Observable 的数据**'
- en: 'With the location details being exposed through this `newLocation` class member,
    you can pass this through to the nested component by adding a property binding
    to the element in details-page.component.html:'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个 `newLocation` 类成员公开位置详情，你可以通过在 details-page.component.html 中的元素上添加属性绑定将其传递给嵌套组件：
- en: '[PRE118]'
  id: totrans-919
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: You’ve seen this type of setup before. The property binding will pass the contents
    of `newLocation` in the Details page component to the `location` member of the
    location details component.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前已经见过这种设置。属性绑定将把 Details 页面组件中的 `newLocation` 内容传递给位置详情组件的 `location` 成员。
- en: Your location details component doesn’t have a location member yet, so you’ll
    need to add it to the component definition and set it up to be an input member
    of type `Location`. You’ve performed these actions before, so the following listing
    serves as a handy reminder, showing everything in place in location-details.component.ts.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 你的位置详情组件还没有位置成员，所以你需要将其添加到组件定义中，并设置它为类型为 `Location` 的输入成员。你之前已经执行过这些操作，所以下面的列表作为方便的提醒，展示了在
    location-details.component.ts 中的所有内容。
- en: Listing 10.8\. Accepting incoming location data in location-details.component.ts
  id: totrans-922
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.8\. 在 location-details.component.ts 中接受传入的位置数据
- en: '[PRE119]'
  id: totrans-923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '***1* Imports ‘Input’ from the Angular core**'
  id: totrans-924
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从 Angular 核心导入 ‘Input’**'
- en: '***2* Imports your ‘Location’ class definition**'
  id: totrans-925
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 导入你的 ‘Location’ 类定义**'
- en: '***3* Defines ‘location’ as an input member of type ‘Location’**'
  id: totrans-926
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将 ‘location’ 定义为类型为 ‘Location’ 的输入成员**'
- en: '***4* Don’t forget the Google API key. (You got one in [chapter 2](kindle_split_012.xhtml#ch02),
    didn’t you?)**'
  id: totrans-927
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 不要忘记 Google API 密钥。（你在第 2 章中得到了一个，不是吗？）**'
- en: The page is still working and looks as it did before, but now the Details page
    component is getting the data from the database and passing it to all three of
    the nested components. It’s time to build out the nested view.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 页面仍然在正常工作，看起来和之前一样，但现在详情页面组件正在从数据库获取数据并将其传递给所有三个嵌套组件。是时候构建嵌套视图了。
- en: 10.1.6\. Building the Details page view
  id: totrans-929
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.6\. 构建 Details 页面视图
- en: For the location details, you’ve already got a Pug template with Pug data bindings,
    and you need to transform this template into HTML with Angular bindings. You have
    quite a few bindings to put in place, as well as some loops, utilizing Angular’s
    `*ngFor` construct. You’ll use the `rating-stars` component that you created for
    the challenge at the end of [chapter 9](kindle_split_021.xhtml#ch09) to show the
    overall rating and the rating for each review. If you haven’t created this component,
    refer to the book’s code repository on GitHub. You’ll also need to allow line
    breaks in the review text by using the `htmlLineBreaks` pipe.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 对于位置详情，你已经有一个带有 Pug 数据绑定的 Pug 模板，你需要将这个模板转换为带有 Angular 绑定的 HTML。你需要放置相当多的绑定，以及一些使用
    Angular 的 `*ngFor` 构造的循环。你将使用你在第 9 章末尾挑战中创建的 `rating-stars` 组件来显示总体评分和每个评论的评分。如果你还没有创建这个组件，请参考
    GitHub 上的书籍代码仓库。你还需要通过使用 `htmlLineBreaks` 管道来允许评论文本中的换行。
- en: Getting the main template in place
  id: totrans-931
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 放置主要模板
- en: '[Listing 10.9](#ch10ex09) shows everything in place, with the bindings in bold.
    This code should make up the entire contents of location-details.component.html.
    We’ve left out some pieces, such as the opening times, which you’ll fill in when
    you’ve got this code in place and tested.'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 10.9](#ch10ex09) 展示了所有内容，其中绑定以粗体显示。这段代码应该构成 location-details.component.html
    的全部内容。我们省略了一些部分，例如营业时间，你将在代码就位并测试后填写这些内容。'
- en: Listing 10.9\. Angular template for location details in location-details.component.html
  id: totrans-933
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.9\. location-details.component.html 中的位置详情的 Angular 模板
- en: '[PRE120]'
  id: totrans-934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '***1* Use rating-stars component to show average rating for location.**'
  id: totrans-935
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用 rating-stars 组件来显示位置的平均评分。**'
- en: '***2* Loop through facilities.**'
  id: totrans-936
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 遍历设施。**'
- en: '***3* Don’t forget the Google Maps API key.**'
  id: totrans-937
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 不要忘记 Google Maps API 密钥。**'
- en: '***4* Loop through reviews.**'
  id: totrans-938
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 遍历评论循环。**'
- en: '***5* Use rating-stars component to show rating for each review.**'
  id: totrans-939
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 使用 rating-stars 组件来显示每个评论的评分。**'
- en: '***6* Apply htmlLineBreaks pipe to review text and bind as HTML.**'
  id: totrans-940
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 将 htmlLineBreaks 管道应用于评论文本并将其绑定为 HTML。**'
- en: That code listing is long, but that’s to be expected, as quite a lot is going
    on in the Details page. If you look at the page in the browser now, it looks about
    right. You have a few things to fix, but you know about them.
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 那段代码列表很长，但这是可以预料的，因为详情页面有很多事情在进行。如果你现在在浏览器中查看页面，看起来是正确的。你有一些事情要修复，但你已经知道了。
- en: Although the page looks good, if you open the JavaScript console, you’ll see
    that the page has thrown a lot of errors along the lines of `Cannot read property
    'rating' of undefined`. These errors are binding errors, happening because the
    nested location details component is trying to bind to data as soon as the page
    loads, but you don’t have any data until after the API call has completed.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然页面看起来不错，但如果你打开 JavaScript 控制台，你会看到页面抛出了很多类似`Cannot read property 'rating'
    of undefined'`的错误。这些错误是绑定错误，发生的原因是嵌套的位置详情组件在页面加载时试图绑定数据，但你还没有数据直到 API 调用完成。
- en: Hiding components to stop premature-binding errors
  id: totrans-943
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 隐藏组件以防止过早绑定错误
- en: The binding errors are occurring because the component is trying to bind to
    data before the data has been provided. How do you stop this from happening? A
    good way is to hide the component in the HTML until the data has been received
    from the API and you have the location details ready to display.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定错误发生是因为组件试图在数据提供之前绑定数据。你该如何阻止这种情况发生？一个不错的方法是在 HTML 中隐藏组件，直到从 API 接收数据并且你有准备好的位置详情可以显示。
- en: Angular includes a helpful native directive called `*ngIf`, which you can add
    to an element in the HTML. `*ngIf` is given an expression. If the expression resolves
    to `true`, the element is shown; otherwise, it’s hidden.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 包含一个有用的原生指令`*ngIf`，你可以将其添加到 HTML 中的元素。`*ngIf`接受一个表达式。如果表达式解析为`true`，则显示该元素；否则，它会被隐藏。
- en: 'For your situation, you want to show the location details component only when
    the location data exists. So you can add an `*ngIf` directive to the location
    details element in details-page.component.html like so:'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的情况，你只想在存在位置数据时显示位置详情组件。因此，你可以在details-page.component.html中的位置详情元素上添加一个`*ngIf`指令，如下所示：
- en: '[PRE121]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: With that small change, you have no more binding errors!
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个小小的改动，你不再会有绑定错误了！
- en: Now it’s on to fixing the remaining page template issues. Because you’re not
    showing opening times yet, the reviews are coming through oldest first, and the
    data of the reviews needs formatting.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 现在转向修复剩余的页面模板问题。因为你还没有显示营业时间，所以评论是按时间顺序显示的，评论的数据需要格式化。
- en: Adding if-else style logic with ngSwitchCase to show the opening times
  id: totrans-950
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用`ngSwitchCase`添加if-else样式逻辑以显示营业时间
- en: 'It’s not unusual to want some type of `if-else` logic in a template to show
    different chunks of HTML depending on a certain parameter. For each opening time,
    you want to display the days in the range and either a closed message or the opening
    and closing times. In your Pug template, you had a bit of logic, a simple `if`
    statement checking whether `closed` was `true`:'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中想要某种类型的`if-else`逻辑以根据某个参数显示不同的HTML块并不罕见。对于每个营业时间，你想要显示日期范围以及一个关闭消息或营业和关闭时间。在你的
    Pug 模板中，你有一点点逻辑，一个简单的`if`语句检查`closed`是否为`true`：
- en: '[PRE122]'
  id: totrans-952
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: You want to do something similar in your Angular template. You’ve seen how `*ngIf`
    can work for a one-off case, but for `if-else` logic, Angular works along the
    lines of JavaScript’s `switch` method. With this method, you define which condition
    you want to check at the top, and then provide different options depending on
    the value of the condition.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 你想在你的 Angular 模板中做类似的事情。你已经看到了`*ngIf`如何适用于一次性情况，但对于`if-else`逻辑，Angular 按照JavaScript的`switch`方法工作。使用这种方法，你可以在顶部定义你想要检查的条件，然后根据条件的值提供不同的选项。
- en: The key parts here are an `[ngSwitch]` binding for defining the condition to
    switch on, an `*ngSwitchCase` directive for providing a specific value, and an
    `*ngSwitchDefault` directive for providing a backup option if none of the specific
    values matches. You can see all these parts in action in the following listing,
    where you add the opening times to location-details.component.html.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 这里关键的部分是一个用于定义切换条件的`[ngSwitch]`绑定，一个用于提供特定值的`*ngSwitchCase`指令，以及一个用于提供备份选项的`*ngSwitchDefault`指令。你可以在以下列表中看到所有这些部分的实际应用，其中你将营业时间添加到location-details.component.html中。
- en: Listing 10.10\. Using `ngSwitch` in location-details.component.html
  id: totrans-955
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.10\. 在location-details.component.html中使用`ngSwitch`
- en: '[PRE123]'
  id: totrans-956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '***1* Runs switch based on the value of time.closed**'
  id: totrans-957
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 根据 time.closed 的值运行 switch***'
- en: '***2* When time.closed is true, outputs closed**'
  id: totrans-958
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 当 time.closed 为 true 时，输出 closed***'
- en: '***3* Otherwise, default action is to output opening and closing times**'
  id: totrans-959
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 否则，默认操作是输出开放和关闭时间**'
- en: Now you have a bit of logic in the template. Note that as all the `ngSwitch`
    commands are property bindings and directives, they need to be added to HTML tags.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 现在模板中有一点点逻辑。注意，由于所有的`ngSwitch`命令都是属性绑定和指令，它们需要添加到HTML标签中。
- en: Okay, it’s time to get the reviews showing most recent first.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在是时候让评论以最新的顺序显示了。
- en: Changing the display order of a list by using a custom pipe
  id: totrans-962
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 通过使用自定义管道更改列表的显示顺序
- en: 'If you have experience with AngularJS, you may be expecting an update of the
    old `orderBy` filter, which could be used to magically reorder a repeated list
    in almost any way imaginable. It was flexible and powerful, but it came with a
    downside: with large datasets, this flexible filter became slow. For this reason,
    the Angular team decided not to include it in the new versions.'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉AngularJS，你可能期望更新旧的`orderBy`过滤器，它可以用来神奇地以几乎任何可想象的方式重新排列重复的列表。它是灵活且强大的，但有一个缺点：对于大型数据集，这种灵活的过滤器变得很慢。因此，Angular团队决定不在新版本中包含它。
- en: Without a native way to change the order of a list, the options are to write
    some code in the component or to create a new pipe. A pipe is often best—especially
    if you think you may want to reuse the functionality somewhere else—and you also
    know that a pipe will always be applied if the data changes.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有本地方式可以更改列表的顺序，选项是编写组件中的代码或创建一个新的管道。管道通常是最好的选择——特别是如果你认为你可能想在其他地方重用该功能——而且你也知道如果数据发生变化，管道总是会应用。
- en: 'Create a new pipe specifically to order the reviews by date, most recent first.
    You’ll create the new pipe the normal way by running the following command in
    terminal, in the app_public folder:'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的管道，专门按日期顺序排列评论，最新的排在前面。你将按照正常方式创建新的管道，在终端中运行以下命令，在app_public文件夹中：
- en: '[PRE124]'
  id: totrans-966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'When the pipe is generated, add it to the `*ngFor` directive looping the reviews
    in location-details.component.html, like so:'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 当管道生成后，将其添加到在location-details.component.html中循环评论的`*ngFor`指令中，如下所示：
- en: '[PRE125]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Next, you’ll code the pipe itself. Remember that it comes with a `transform`
    hook that accepts a value and returns a value. For your purposes, you want to
    accept and return an array, as reviews are returned from the database as an array.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将编写管道本身。记住，它包含一个接受值并返回值的`transform`钩子。就你的目的而言，你想要接受并返回一个数组，因为评论是从数据库作为数组返回的。
- en: As you’re working with arrays, you can use JavaScript’s native array `sort`
    method, which accepts a function as a parameter. This function takes two items
    at a time from the array and can compare them however you code. The return value
    of the function should be a positive or negative number. A negative number means
    that the order stays the same; positive means that the order changes.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你正在处理数组，你可以使用JavaScript的本地数组`sort`方法，它接受一个函数作为参数。这个函数一次从数组中取两个项目，并可以按你编写的方式比较它们。函数的返回值应该是正数或负数。负数表示顺序保持不变；正数表示顺序改变。
- en: You’re comparing dates and want the most recent first. In terms of comparison
    operators, a more recent date is “greater than” an older date. So if the date
    of the first parameter is greater than (more recent than) the date of the second,
    you return a negative number to keep the order the same. Otherwise, return a positive
    number to swap them round. That’s more complicated to explain than it is to code!
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在比较日期，并希望最新的日期排在前面。在比较运算符方面，较新的日期是“大于”较旧的日期。所以如果第一个参数的日期大于（比第二个参数的日期更近），你返回一个负数以保持顺序不变。否则，返回一个正数以交换它们的位置。这比写代码要复杂得多！
- en: The next listing shows what the pipe code looks like, creating a comparison
    function called `compare` and using it to sort the array of reviews before returning
    the updated array.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了管道代码的样子，创建了一个名为`compare`的比较函数，并使用它来对评论数组进行排序，然后返回更新后的数组。
- en: Listing 10.11\. Creating most-recent-first.pipe.ts to change display order of
    reviews
  id: totrans-973
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.11\. 创建most-recent-first.pipe.ts以更改评论的显示顺序
- en: '[PRE126]'
  id: totrans-974
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '***1* Your comparing function, taking two values from the array**'
  id: totrans-975
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 你的比较函数，从数组中取两个值**'
- en: '***2* Gets the creation date of each review**'
  id: totrans-976
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 获取每个评论的创建日期**'
- en: '***3* If a is more recent than b, returns -1; otherwise, returns 1**'
  id: totrans-977
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果a比b更近，则返回-1；否则，返回1**'
- en: '***4* The transform method, accepting and returning arrays of reviews**'
  id: totrans-978
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* transform方法，接受并返回评论数组**'
- en: '***5* Uses your compare function to sort the array, returning the reordered
    version**'
  id: totrans-979
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 使用你的比较函数来排序数组，返回重新排序的版本**'
- en: 'If you reload the page, you should see your reviews showing in the correct
    order: most recent first. It’s a little hard to tell, though, as the date format
    isn’t exactly user friendly. You’ll fix this problem in the next section.'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重新加载页面，你应该看到你的审查按照正确的顺序显示：最新的首先显示。然而，由于日期格式并不完全符合用户友好性，所以这有点难以判断。你将在下一节中解决这个问题。
- en: Fixing the date format by using the date pipe
  id: totrans-981
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 通过使用日期管道修复日期格式
- en: 'Fortunately, formatting dates is much simpler than ordering by them. One of
    Angular’s default pipes is the `date` pipe, which formats a given date in the
    style you want. This pipe takes one argument: the format for your date.'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，格式化日期比按日期排序要简单得多。Angular 的默认管道之一是 `date` 管道，它可以按照你想要的方式格式化给定的日期。这个管道接受一个参数：你日期的格式。
- en: To apply your formatting, you send a string describing the output you want.
    Too many options are available to be listed here, but the format is easy to get
    the hang of. For the format *1 September 2017*, for example, send the string `'d
    MMMM yyyy'`, as shown in the following listing.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用你的格式，你需要发送一个描述你想要输出的字符串。这里有很多选项，无法在此列出，但格式很容易掌握。例如，对于格式 *1 September 2017*，发送的字符串是
    `'d MMMM yyyy'`，如下面的列表所示。
- en: Listing 10.12\. Formatting with a `date` pipe in location-details.component.html
  id: totrans-984
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.12\. 在 location-details.component.html 中使用 `date` 管道进行格式化
- en: '[PRE127]'
  id: totrans-985
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: With that, you’re done with the layout and formatting of the Details page, which
    should look like [figure 10.6](#ch10fig06).
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你已经完成了详情页面的布局和格式化，它应该看起来像[图 10.6](#ch10fig06)。
- en: Figure 10.6\. All the location details are now being shown on the Angular page.
  id: totrans-987
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.6\. 所有位置详情现在都在 Angular 页面上显示。
- en: '![](Images/10fig06_alt.jpg)'
  id: totrans-988
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10fig06_alt.jpg)'
- en: The next and final step is enabling reviews to be added, but you’re going to
    drop the concept of an extra page to do this, which is how you did it in Express.
    Instead, you’ll do it inline on the page to provide a slicker experience.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个也是最后的步骤是启用添加审查功能，但你将放弃使用额外页面的概念来完成这个任务，这是你在 Express 中所做的方式。相反，你将在页面上直接进行操作，以提供更流畅的体验。
- en: 10.2\. Working with forms and handling submitted data
  id: totrans-990
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2\. 处理表单和处理提交的数据
- en: In this section, you’ll create the Add Review page in Angular, and have it submit
    data to the API. Rather than navigate to a separate form page when the Add Review
    button is clicked, it’ll display a form inline in the page. When the form is submitted,
    you’ll have Angular handle the data, submit it to the API, and display the new
    review at the top of the list. You’ll start by seeing what’s involved with creating
    the form in Angular.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将在 Angular 中创建添加审查页面，并将其数据提交到 API。当点击添加审查按钮时，你不会导航到单独的表单页面，而是在页面上直接显示表单。当表单提交时，Angular
    将处理数据，将其提交到 API，并在列表顶部显示新的审查。你将从查看在 Angular 中创建表单所涉及的内容开始。
- en: 10.2.1\. Creating the review form in Angular
  id: totrans-992
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.1\. 在 Angular 中创建审查表单
- en: To create the review form, you’ll get the HTML in place, add data bindings to
    the input fields, make sure that they all work as expected, and, finally, ensure
    that the form is initially hidden and is displayed only if the button is clicked.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建审查表单，你需要将 HTML 放置到位，添加数据绑定到输入字段，确保它们都按预期工作，最后确保表单最初是隐藏的，并且只有当按钮被点击时才显示。
- en: Putting the form HTML in place
  id: totrans-994
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将表单 HTML 放置到位
- en: Add the inline form to the page just after the `Customer reviews<h2>` tag, as
    shown in the following listing. Much of the layout is taken from the form you
    used in Express, including the form input names and IDs.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 将内联表单添加到页面中，紧接在 `Customer reviews<h2>` 标签之后，如下面的列表所示。大部分布局都来自你在 Express 中使用的表单，包括表单输入名称和
    ID。
- en: Listing 10.13\. Adding the review form to location-details.component.html
  id: totrans-996
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.13\. 将审查表添加到 location-details.component.html
- en: '[PRE128]'
  id: totrans-997
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '***1* Adds the new div and the form HTML directly after the Customer reviews
    header**'
  id: totrans-998
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在客户审查标题之后直接添加新的 div 和表单 HTML**'
- en: Right now, you’re not doing anything clever or asking Angular to do anything.
    You’ve put raw HTML with some Bootstrap classes in the template. In the browser,
    this looks like [figure 10.7](#ch10fig07).
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你并没有做任何聪明的事情或要求 Angular 做任何事情。你已经在模板中放置了一些带有 Bootstrap 类的原始 HTML。在浏览器中，这看起来像[图
    10.7](#ch10fig07)。
- en: Figure 10.7\. The review form displays inline in the Details page, between the
    Add Review button and the list of reviews.
  id: totrans-1000
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.7\. 审查表单在详情页面中直接显示，位于添加审查按钮和审查列表之间。
- en: '![](Images/10fig07_alt.jpg)'
  id: totrans-1001
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10fig07_alt.jpg)'
- en: That’s the basic form in place. Next, add the data bindings.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 基本表单已经到位。接下来，添加数据绑定。
- en: Adding data bindings to form inputs
  id: totrans-1003
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 向表单输入添加数据绑定
- en: In Express, you posted the form to another URL and handled the submitted data
    there, but with Angular, you don’t want to change the page at all. With Angular,
    the approach is to add data bindings to all the fields in a form so the component
    can access the values.
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Express 中，你将表单发布到另一个 URL 并在那里处理提交的数据，但使用 Angular，你不想改变页面。使用 Angular，方法是将数据绑定添加到表单中的所有字段，以便组件可以访问这些值。
- en: 'To add a data binding to a form field, use a directive with a special syntax
    like this: `[(ngModel)]="bindingName"`. (Remembering the order of the brackets
    can be difficult, so this has become known as “banana in a boat” to help you remember!)'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据绑定添加到表单字段，使用具有特殊语法的指令，例如：`[(ngModel)]="bindingName"`。（记住括号的顺序可能很难，因此这被称为“香蕉船”，以帮助你记住！）
- en: To use `ngModel` in your HTML, you need to have `FormsModule` and `ReactiveFormsModule`
    imported into the application in app.module.ts. Add the line `import { FormsModule,
    ReactiveFormsModule } from '@angular/forms';` to app.module.ts, and add both of
    those module names to the `imports` array in the same file.
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 HTML 中使用 `ngModel`，你需要将 `FormsModule` 和 `ReactiveFormsModule` 导入到应用中 app.module.ts。将
    `import { FormsModule, ReactiveFormsModule } from '@angular/forms';` 行添加到 app.module.ts，并将这两个模块名称添加到同一文件中的
    `imports` 数组中。
- en: 'In your component, you’ll want to keep all the submitted form data inside a
    single object so you can pass it around easily. Define a new public member, `newReview`,
    in location-details.component.html, giving it properties for the author name,
    rating, and review content. Each property needs to have a default value, so the
    definition should look like this:'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的组件中，你希望将所有提交的表单数据保存在一个单独的对象中，这样你就可以轻松地传递它。在 location-details.component.html
    中定义一个新的公共成员 `newReview`，给它作者名称、评分和评论内容属性。每个属性都需要一个默认值，所以定义应该看起来像这样：
- en: '[PRE129]'
  id: totrans-1008
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Now that this `newReview` object and its properties are defined in the component,
    you can use them in the HTML. The following listing shows how to add the bindings
    to the form in location-details.component.html.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于 `newReview` 对象及其属性已经在组件中定义，你可以在 HTML 中使用它们。以下列表显示了如何在 location-details.component.html
    中添加到表单的绑定。
- en: Listing 10.14\. Adding data bindings to review form in location-details.component.html
  id: totrans-1010
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.14\. 在 location-details.component.html 中添加评论表单的数据绑定
- en: '[PRE130]'
  id: totrans-1011
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '***1* Adds the “banana in a boat” model bindings to the form inputs**'
  id: totrans-1012
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将“香蕉船”模型绑定添加到表单输入**'
- en: This looks good and, on the face of it, seems to work. But you want the rating
    to be a number, and in a select option, `value="5"` is a string containing the
    character 5.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来不错，表面上似乎也工作得很好。但你希望评分是一个数字，而在选择选项中，`value="5"` 是包含字符 5 的字符串。
- en: Working with select values that are not strings
  id: totrans-1014
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 处理非字符串的 select 值
- en: A select option `value` is by default a string, but your database requires a
    number for the rating. Angular has a way to help you get different types of data
    from a select field.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 选择选项的 `value` 默认是一个字符串，但你的数据库需要评分是一个数字。Angular 有一种方法可以帮助你从选择字段获取不同类型的数据。
- en: Instead of using `value="STRING VALUE"` inside each `<option>`, use `[ngValue]=
    "ANGULAR EXPRESSION"`. When written out, the value of `[ngValue]` looks like a
    string, but it’s an Angular expression. This could be an object or a true Boolean,
    but you want a number.
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在每个 `<option>` 中使用 `value="STRING VALUE"`，使用 `[ngValue]= "ANGULAR EXPRESSION"`。当写出来时，`[ngValue]`
    的值看起来像是一个字符串，但它是一个 Angular 表达式。这可以是一个对象或一个真正的布尔值，但你想要一个数字。
- en: 'In location-details.component.html, update each of the `<option>` tags to use
    `[ngValue]` instead of value:'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 在 location-details.component.html 中，更新每个 `<option>` 标签以使用 `[ngValue]` 而不是 `value`：
- en: '[PRE131]'
  id: totrans-1018
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Now Angular gets the value of the `<select>` as a number, not a string. This
    technique will be useful when you submit the data to the API. Next, you hide the
    form by default, as you don’t want it showing all the time.
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Angular 将 `<select>` 的值作为一个数字而不是字符串来获取。当将数据提交到 API 时，这项技术将非常有用。接下来，你默认隐藏表单，因为你不想让它一直显示。
- en: Setting the visibility of the form
  id: totrans-1020
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设置表单的可见性
- en: You don’t want the Add Review section of the page to be visible when the page
    loads; you want the Add Review button to show it, and when the form is displayed,
    you want the Cancel button to hide it again.
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 你不希望在页面加载时显示“添加评论”部分；你希望“添加评论”按钮显示它，当表单显示时，你希望“取消”按钮再次隐藏它。
- en: To show and hide the form, you can use your old friend `*ngIf`. `*ngIf` needs
    a Boolean value to decide whether to show the element it’s applied to, so you’ll
    need to define one in the component.
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示和隐藏表单，你可以使用你的老朋友 `*ngIf`。`*ngIf` 需要一个布尔值来决定是否显示它所应用的元素，因此你需要在组件中定义一个。
- en: 'In location-details.component.ts, define a new public member `formVisible`
    of type `boolean` with a default value of `false`:'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 在 location-details.component.ts 中，定义一个新的公共成员 `formVisible`，其类型为 `boolean`，默认值为
    `false`：
- en: '[PRE132]'
  id: totrans-1024
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'You’ve set the default value to `false`, as you want the form to be hidden
    by default. To use this Boolean to set the visibility of the form, locate the
    `<div>` surrounding the `<form>` in location-details.component.html, and add the
    `*ngIf` directive to it like this:'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经将默认值设置为 `false`，因为你希望表单默认隐藏。要使用这个布尔值来设置表单的可见性，在 location-details.component.html
    中找到包围 `<form>` 的 `<div>`，并像这样添加 `*ngIf` 指令：
- en: '[PRE133]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Now the form is hidden by default when the page loads.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当页面加载时，表单默认是隐藏的。
- en: Toggling the visibility of the form
  id: totrans-1028
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 切换表单的可见性
- en: To change the visibility of the form, you need a way to change the value of
    `formVisible` when the Add Review and Cancel buttons are clicked. Not surprisingly,
    Angular has an on-click handler you can use to track clicks of elements and then
    do something.
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改表单的可见性，你需要一种方法，在点击添加评论和取消按钮时更改 `formVisible` 的值。不出所料，Angular 有一个你可以用来跟踪元素点击并执行某些操作的点击处理程序。
- en: Angular’s click handler is accessed by adding `(click)` to the element and giving
    it an Angular expression. This expression could be one that calls a public member
    in the component class or any other kind of valid expression. You want to set
    `formVisible` to `true` when the Add Review button is clicked and `false` when
    the Cancel button is clicked.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 的点击处理程序通过在元素上添加 `(click)` 并提供一个 Angular 表达式来访问。这个表达式可以是调用组件类中的公共成员或任何其他类型的有效表达式。当点击添加评论按钮时，你想将
    `formVisible` 设置为 `true`，当点击取消按钮时设置为 `false`。
- en: 'In location-details.component.html, change the Add Review button from an `<a>`
    tag to a `<button>`, removing the `href` attribute and replacing it with a `(click)`
    setting `formVisible` to be `true`:'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 在 location-details.component.html 中，将添加评论按钮从 `<a>` 标签更改为 `<button>`，移除 `href`
    属性，并用设置 `formVisible` 为 `true` 的 `(click)` 事件替换它：
- en: '[PRE134]'
  id: totrans-1032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'In a similar way, add a `(click)` to the Cancel button, setting `formVisible`
    to be `false`:'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，给取消按钮添加 `(click)` 事件，将 `formVisible` 设置为 `false`：
- en: '[PRE135]'
  id: totrans-1034
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: With those click handlers in place, you can use the two buttons to show and
    hide the review form, using the `formVisible` property of the component to keep
    track of the status. The final thing you need to do is hook up the form so that
    when it’s submitted, a review is added.
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些点击处理程序就位后，你可以使用这两个按钮来显示和隐藏评论表单，使用组件的 `formVisible` 属性来跟踪状态。你需要做的最后一件事是将表单连接起来，以便在提交时添加评论。
- en: 10.2.2\. Sending submitted form data to an API
  id: totrans-1036
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.2\. 将提交的表单数据发送到 API
- en: 'Now is the time to make your review form work and add a review to the database
    when it’s submitted. To get to this point, you have to complete a few steps:'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候让你的评论表单工作，并在提交时将评论添加到数据库中。为了达到这个目的，你必须完成几个步骤：
- en: Add a new member to your data service to `POST` new reviews to the API.
  id: totrans-1038
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的数据服务中添加一个新成员来 `POST` 新评论到 API。
- en: Have Angular handle the form when it’s submitted.
  id: totrans-1039
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当表单提交时，让 Angular 处理。
- en: Validate the form so that only complete data is accepted.
  id: totrans-1040
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证表单，以确保只接受完整的数据。
- en: Send the review data to your service.
  id: totrans-1041
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将评论数据发送到你的服务。
- en: Push the review into the list in the Details page.
  id: totrans-1042
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将评论推送到详情页面的列表中。
- en: You’ll start with step 1.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从第一步开始。
- en: 'Step 1: Updating the data service to accept new reviews'
  id: totrans-1044
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第一步：更新数据服务以接受新的评论
- en: 'To use the form to post review data, you need to add a method to your data
    service that talks to the correct API endpoint and can post the data. You’ll call
    this new method `addReviewByLocationId` and have it accept two parameters: a location
    ID and the review data.'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用表单发布评论数据，你需要在数据服务中添加一个方法，该方法与正确的 API 端点通信并可以发布数据。你将调用这个新方法 `addReviewByLocationId`，并让它接受两个参数：位置
    ID 和评论数据。
- en: The contents of the method are the same as the others, except you’ll use `post`
    instead of `get` to call the API. The following listing shows the new method to
    be added to loc8r-data.service.ts.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的内容与其他方法相同，但你将使用 `post` 而不是 `get` 来调用 API。以下列表显示了要添加到 loc8r-data.service.ts
    中的新方法。
- en: Listing 10.15\. New public member for adding reviews in loc8r-data.service.ts
  id: totrans-1047
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.15\. 在 loc8r-data.service.ts 中添加用于添加评论的新公共成员
- en: '[PRE136]'
  id: totrans-1048
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Brilliant; now you’ll be able to use this method from your component when you’ve
    got the form handling sorted. Now move on to step 2.
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了；现在当你处理完表单处理时，你将能够从组件中使用这种方法。现在继续到第二步。
- en: 'Step 2: Adding the on Submit form handler'
  id: totrans-1050
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第二步：添加表单提交处理程序
- en: When working with a form in HTML, you typically have an action to tell the browser
    where to send the data and a method describing which HTTP verb to use. You may
    also have an `onSubmit` event handler if you want to do anything with the form
    data by using JavaScript before it’s sent.
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 当在HTML中使用表单时，你通常有一个动作来告诉浏览器将数据发送到何处，以及一个方法来描述使用哪个HTTP动词。如果你想在数据发送之前使用JavaScript对表单数据进行一些操作，你可能还会有一个`onSubmit`事件处理器。
- en: 'In an Angular SPA, you don’t want the form to submit to a different URL, taking
    you to a new page. You want Angular to handle everything, so you’ll remove the
    form element’s `action=""` attribute and replace it with Angular’s `ngSubmit`
    event handler to call a public member in the component. The following code snippet
    shows how the event handler is used, adding it to the form definition, calling
    a function in the component that you’ll write in a moment:'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular SPA中，你不想让表单提交到不同的URL，从而跳转到新页面。你希望Angular处理一切，所以你会移除表单元素的`action=""`属性，并用Angular的`ngSubmit`事件处理器来调用组件中的公共成员。以下代码片段显示了如何使用事件处理器，将其添加到表单定义中，调用你即将编写的组件中的函数：
- en: '[PRE137]'
  id: totrans-1053
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'This line calls a public method on the component called `onReviewSubmit` when
    the form is submitted. You need to create this method, so you’ll add a simple
    method to location-details.component.ts to create a console log when the form
    is submitted:'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码在表单提交时调用组件上的一个公共方法`onReviewSubmit`。你需要创建这个方法，所以你将在location-details.component.ts中添加一个简单的方法，当表单提交时创建一个控制台日志：
- en: '[PRE138]'
  id: totrans-1055
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Because you bound all the form fields to properties of `newReview`, this console
    log outputs all the data submitted. Now that you can capture the form data, you’ll
    add some validation in step 3 so that only complete data is accepted.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你将所有表单字段绑定到了`newReview`的属性上，这个控制台日志输出了所有提交的数据。现在你可以捕获表单数据了，你将在第3步添加一些验证，以确保只接受完整的数据。
- en: 'Step 3: Validating the submitted form data'
  id: totrans-1057
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第3步：验证提交的表单数据
- en: Before you blindly send every form submission to the API to save to the database,
    you want to do some quick validation to ensure that all the fields are filled
    in. If any of them aren’t filled in, you’ll display an error message. Your browser
    may prevent forms from being submitted with empty required fields; if this is
    the case for you, temporarily remove the `required` attribute from the form fields
    to test the Angular validation.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 在你盲目地将每个表单提交发送到API以保存到数据库之前，你想要进行一些快速验证，以确保所有字段都已填写。如果有任何字段未填写，你将显示一个错误消息。你的浏览器可能阻止带有空必填字段的表单提交；如果你遇到这种情况，暂时从表单字段中移除`required`属性以测试Angular验证。
- en: When a form is submitted, you’ll start by removing any existing error messages
    before checking whether each data item in the form is truthy (that is, any form
    of `true` value). If any of the checks returns `false`—that is, a field has no
    data—you’ll set a form error message in the component. If all the data exists,
    you’ll continue to log it to the console as before.
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 当表单提交时，你将首先删除任何现有的错误消息，然后检查表单中的每个数据项是否为真值（即任何形式的`true`值）。如果任何检查返回`false`——即字段没有数据——你将在组件中设置一个表单错误消息。如果所有数据都存在，你将继续像以前一样将其记录到控制台。
- en: The following listing shows the new validation member you need to add to location-details.component.ts
    and how you need to change the `onReviewSubmit` function to use it.
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了你需要添加到location-details.component.ts中的新验证成员以及你需要如何更改`onReviewSubmit`函数以使用它。
- en: Listing 10.16\. Adding validation to the review form in location-details.component.ts
  id: totrans-1061
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.16\. 在location-details.component.ts中添加对评论表单的验证
- en: '[PRE139]'
  id: totrans-1062
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '***1* Declares the formError variable**'
  id: totrans-1063
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明formError变量**'
- en: '***2* Private member to check that all form fields have content**'
  id: totrans-1064
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 私有成员以检查所有表单字段是否有内容**'
- en: '***3* Resets any existing error messages**'
  id: totrans-1065
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 重置任何现有的错误消息**'
- en: '***4* If form validation passes, log submits data to console**'
  id: totrans-1066
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 如果表单验证通过，将数据记录到控制台**'
- en: '***5* Otherwise, sets an error message**'
  id: totrans-1067
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 否则，设置错误消息**'
- en: Now that you’re creating an error message, you want to show it to users when
    it’s generated. For this task, you’ll add in a new Bootstrap alert `div` to the
    form template and bind the message as the content. You want to show the `div`
    only when there’s an error message to display, so use the familiar `*ngIf` directive
    to handle this task, checking whether `formError` has a value.
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你正在创建一个错误消息，你希望在它生成时将其显示给用户。对于这个任务，你将在表单模板中添加一个新的Bootstrap alert `div`并将消息绑定为其内容。你只想在需要显示错误消息时显示`div`，所以使用熟悉的`*ngIf`指令来处理这个任务，检查`formError`是否有值。
- en: 'The addition you need to make to the review form template, adding the alert
    near the top of the form, looks like this:'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 需要添加到评论表单模板中的内容，在表单顶部附近添加警报，看起来像这样：
- en: '[PRE140]'
  id: totrans-1070
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Now, if you click the Submit button without adding details to the form, you’ll
    get an alert, something like [figure 10.8](#ch10fig08).
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您在表单中没有添加详细信息就点击提交按钮，您将收到一个警报，类似于[图10.8](#ch10fig08)。
- en: Figure 10.8\. When a user tries to submit an incomplete form, an error message
    is displayed.
  id: totrans-1072
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.8\. 当用户尝试提交不完整的表单时，会显示错误消息。
- en: '![](Images/10fig08_alt.jpg)'
  id: totrans-1073
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/10fig08_alt.jpg)'
- en: So you’ve got invalid data covered. Next, you’ll deal with valid data, and send
    it to the API.
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您已经覆盖了无效数据。接下来，您将处理有效数据，并将其发送到API。
- en: 'Step 4: Sending the form data to the data service'
  id: totrans-1075
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第4步：将表单数据发送到数据服务
- en: Your form data is being posted, and you’ve got a data service ready to post
    it to the API. Now hook these two tasks up. You’ll use the data service as you’ve
    done before; using this new method is no different.
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 您的表单数据正在提交，并且您已经准备好将数据发送到API的数据服务。现在将这两个任务连接起来。您将像之前一样使用数据服务；使用这个新方法没有不同。
- en: But first, you need to import the data service into location-details.component.ts
    and add it to the decorator.
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，您需要将数据服务导入到location-details.component.ts中，并将其添加到装饰器中。
- en: Listing 10.17\. Importing and providing the data service to location-details.component.ts
  id: totrans-1078
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.17\. 在location-details.component.ts中导入并提供数据服务
- en: '[PRE141]'
  id: totrans-1079
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'In the same file, you also need to add the service to the constructor so that
    you can use it:'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一文件中，您还需要将服务添加到构造函数中，以便可以使用它：
- en: '[PRE142]'
  id: totrans-1081
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: With the service now available in the component, you can call your new `addReviewByLocationId`
    method. The method expects the location ID and review details, and resolves a
    Promise, which returns the review record as saved in the database, as shown in
    the next listing. To validate that it’s working, you’ll also add a console log
    outputting the returned review.
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 现在服务已在组件中可用，您可以调用新的`addReviewByLocationId`方法。该方法期望位置ID和评论详情，并解决一个Promise，它返回数据库中保存的评论记录，如下一列表所示。为了验证它是否正常工作，您还将添加一个控制台日志输出返回的评论。
- en: Listing 10.18\. Sending new reviews to the service in location-details.component.ts
  id: totrans-1083
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.18\. 在location-details.component.ts中向服务发送新的评论
- en: '[PRE143]'
  id: totrans-1084
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '***1* Calls the data service method, passing the location ID and new review
    data**'
  id: totrans-1085
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 调用数据服务方法，传递位置ID和新的评论数据**'
- en: '***2* The method resolves a promise, returning the saved review.**'
  id: totrans-1086
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 该方法解决了一个承诺，返回保存的评论。**'
- en: '***3* Logs the saved review data**'
  id: totrans-1087
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 记录保存的评论数据**'
- en: Now you can send reviews to the database and see the console logs as demonstrated
    in [figure 10.9](#ch10fig09). Note the `createdOn` and `_id` in the console log
    that are generated by Mongoose when the record is saved.
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以发送评论到数据库，并像[图10.9](#ch10fig09)中演示的那样查看控制台日志。注意控制台日志中的`createdOn`和`_id`，这是Mongoose在记录保存时生成的。
- en: Figure 10.9\. Console logs validating that reviews are being added to the database
  id: totrans-1089
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.9\. 控制台日志验证评论是否被添加到数据库
- en: '![](Images/10fig09_alt.jpg)'
  id: totrans-1090
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/10fig09_alt.jpg)'
- en: 'One last thing to make it slick: push the submitted review to the list underneath
    the form. When the review is sent, you want to hide the form and add the review
    to the list that the user can see.'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事情：将提交的评论推送到表单下方的列表中。当评论发送时，您希望隐藏表单并将评论添加到用户可以看到的列表中。
- en: 'Step 5: Updating the list of reviews and hiding the form'
  id: totrans-1092
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第5步：更新评论列表并隐藏表单
- en: Displaying the new review is a simple task, fortunately. You’ve got the list
    of reviews as an array, which is already sorted most recent first. Now you’ll
    need to use the native JavaScript `unshift` method to add the new review to the
    first spot in the array.
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 显示新的评论是一个简单的任务，幸运的是。您已经有了评论列表作为数组，它已经按最新排序。现在您需要使用原生的JavaScript `unshift`方法将新的评论添加到数组的第一个位置。
- en: To hide the form, you can change `formVisible` to `false`, as that’s what’s
    controlling the `*ngIf` on the form. While you’re at it, you can reset the values
    of the form so that it becomes blank again. The following listing shows all the
    additions you need to put in location-details.component.ts.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 要隐藏表单，您可以更改`formVisible`为`false`，因为这是控制表单上的`*ngIf`的。同时，您还可以重置表单的值，使其再次变为空白。以下列表显示了您需要在location-details.component.ts中添加的所有内容。
- en: Listing 10.19\. Hiding the form and showing the review in location-details.component.ts
  id: totrans-1095
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.19\. 在location-details.component.ts中隐藏表单并显示评论
- en: '[PRE144]'
  id: totrans-1096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '***1* A new private member to hide and reset the form**'
  id: totrans-1097
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 一个新的私有成员来隐藏和重置表单**'
- en: '***2* Updates the reviews in the location object, changing the array reference,
    and Angular updates the page. If you manipulate the array directly, the page doesn’t
    update.**'
  id: totrans-1098
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 更新位置对象中的评论，更改数组引用，Angular更新页面。如果你直接操作数组，页面不会更新。**'
- en: '***3* Calls the private member to hide and resets the form**'
  id: totrans-1099
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 调用私有成员以隐藏并重置表单**'
- en: 'That’s it, almost. This code won’t work until `reviews` is in the class definition
    for the `Location` type, so you’ll add it as an array of type `any` in home-list.component.ts
    like this:'
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，几乎完成了。这段代码在`reviews`位于`Location`类型的类定义中之前不会工作，所以你需要在home-list.component.ts中将它作为一个类型为`any`的数组添加，如下所示：
- en: '[PRE145]'
  id: totrans-1101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: That really is it. Your Angular SPA is complete and fully functional. Well done!
    But you can do a couple of things to improve the architecture and follow some
    best practices.
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 真的是这样。你的Angular SPA已经完成并且完全可用。做得好！但你可以做一些事情来改进架构并遵循一些最佳实践。
- en: 10.3\. Improving the architecture
  id: totrans-1103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3。改进架构
- en: You’ve got a fully functioning SPA, which is awesome! But before you use it
    instead of the Express front end, you can improve the architecture by taking the
    routing configuration out of the app.module.ts file and the location class definition
    out of the home-list.component.ts file.
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经拥有了一个完全功能化的SPA，这真是太棒了！但在你使用它代替Express前端之前，你可以通过将路由配置从app.module.ts文件中移出，以及将位置类定义从home-list.component.ts文件中移出，来改进架构。
- en: 10.3.1\. Using a separate routing-configuration file
  id: totrans-1105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.1。使用单独的路由配置文件
- en: Your first mission for improving the architecture and following an Angular best
    practice is moving the routing configuration into a separate file. Why is this
    a best practice? It largely comes down to separation of concerns. The purpose
    of the app.module.ts file is to tell the Angular compiler all about the app and
    the files it needs. If you have only a couple of routes, it’s okay to keep them
    in the app.module.ts file, but if you add more routes, they eventually take over
    the file and mask the original purpose.
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 你提高架构并遵循Angular最佳实践的第一次任务是，将路由配置移动到一个单独的文件中。为什么这是一个最佳实践？这主要归因于关注点的分离。app.module.ts文件的目的就是告诉Angular编译器有关应用程序及其所需文件的所有信息。如果你只有几个路由，将它们保留在app.module.ts文件中是可以的，但如果你添加了更多路由，它们最终会占据整个文件，掩盖其原始目的。
- en: You’ve got three routes in your application at the moment, but you’ll explore
    this best practice by moving the routing configuration into a separate file. You’ll
    add more to this file when you look at authentication in [chapter 11](kindle_split_024.xhtml#ch11).
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 目前你的应用程序中有三个路由，但你会通过将路由配置移动到一个单独的文件中来探索这个最佳实践。当你查看第11章（[chapter 11](kindle_split_024.xhtml#ch11)）中的认证时，你将向这个文件添加更多内容。
- en: Creating a routing-configuration file
  id: totrans-1108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建路由配置文件
- en: 'You can use the Angular CLI to generate the routing-configuration file, this
    time using the `module` template. Run the following command in terminal in the
    app_public folder:'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用Angular CLI生成路由配置文件，这次使用`module`模板。在app_public文件夹的终端中运行以下命令：
- en: '[PRE146]'
  id: totrans-1110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: This command generates an app-routing folder (in src/app) containing an app-routing.module.ts
    file. You haven’t seen one of these files before, so the next listing shows the
    default content of this file.
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令生成一个包含app-routing.module.ts文件的app-routing文件夹（在src/app中）。你之前没有见过这样的文件，所以下一个列表显示了该文件的默认内容。
- en: Listing 10.20\. The default module template of app-routing.module.ts
  id: totrans-1112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.20。app-routing.module.ts的默认模块模板
- en: '[PRE147]'
  id: totrans-1113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'To add the application routing to this file, you need to do the following:'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 要将应用程序路由添加到这个文件中，你需要执行以下操作：
- en: Import the router module and routes type definition from Angular router.
  id: totrans-1115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Angular路由器导入router模块和routes类型定义。
- en: Import the components used for each of the three routes.
  id: totrans-1116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入用于每个路由的组件。
- en: Define the paths and components for the routes.
  id: totrans-1117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义路由的路径和组件。
- en: Add the routes (using `routerModule.forRoot`) to the module imports.
  id: totrans-1118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将路由（使用`routerModule.forRoot`）添加到模块导入中。
- en: Export `RouterModule` so the setup can be used.
  id: totrans-1119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导出`RouterModule`以便可以使用设置。
- en: This process seems like quite a few steps, but it doesn’t use anything you haven’t
    already seen. You’ve used the router module and defined routes before; now you’re
    putting them in a different place. All the updates to the app-routing.module.ts
    are shown in the following listing.
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程看起来有很多步骤，但它没有使用你之前没有见过的任何东西。你已经使用过路由模块并定义过路由；现在你只是将它们放在了不同的地方。以下列表显示了app-routing.module.ts的所有更新。
- en: Listing 10.21\. Completing the routing configuration in app-routing.module.ts
  id: totrans-1121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.21。在app-routing.module.ts中完成路由配置
- en: '[PRE148]'
  id: totrans-1122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '***1* Imports the router module and route type definition**'
  id: totrans-1123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入路由模块和路由类型定义**'
- en: '***2* Imports the components for the routes**'
  id: totrans-1124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 导入路由的组件**'
- en: '***3* Defines the routes as an array of type Routes . . .**'
  id: totrans-1125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将路由定义为类型为Routes的数组 . . .**'
- en: '***4* . . . and imports them, using the router module**'
  id: totrans-1126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* . . . 并使用路由模块导入它们**'
- en: '***5* Exports the router module**'
  id: totrans-1127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 导出路由模块**'
- en: That’s all there is to a routing configuration file. Next, you need to update
    the main app.module.ts file to use this file instead of the inline route definitions.
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是路由配置文件的全部内容。接下来，你需要更新主`app.module.ts`文件，使用这个文件而不是内联路由定义。
- en: Tidying up the app .module.ts file
  id: totrans-1129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 整理`app .module.ts`文件
- en: You don’t want or need the route definitions in two files, so you can delete
    them from the main module file. You also don’t need to import the router from
    Angular router, so you can delete that line too. Your new routing-configuration
    file handles importing it.
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要或想要在两个文件中保留路由定义，因此你可以从主模块文件中删除它们。你也不需要从Angular路由导入路由，因此你也可以删除那行。你的新路由配置文件处理导入。
- en: Although you’re deleting the routes, you do need to keep the imports for all
    the components. These imports are still required by app.module.ts, as this file
    tells the compiler what to use and where to find the source files.
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你在删除路由，但你确实需要保留所有组件的导入。这些导入仍然由`app.module.ts`文件需要，因为这个文件告诉编译器使用什么以及在哪里找到源文件。
- en: Finally, you need to add an import for the new router file instead of the inline
    configuration. This import is normally placed between the core imports and component
    imports so it’s easy to spot when you’re looking in the file. Also, add the router
    file to the `imports` part of the decorator.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要将新的路由文件导入，而不是使用内联配置。这个导入通常放置在核心导入和组件导入之间，这样在查看文件时很容易找到。此外，将路由文件添加到装饰器的`导入`部分。
- en: The following listing shows the final app.module.ts with all the additions and
    deletions having been made.
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了添加和删除所有更改后的最终`app.module.ts`。
- en: Listing 10.22\. Removing inline route definitions from app.module.ts
  id: totrans-1134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.22\. 从`app.module.ts`中移除内联路由定义
- en: '[PRE149]'
  id: totrans-1135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '***1* Imports your new routing module, containing the routing configuration
    for the application**'
  id: totrans-1136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入你的新路由模块，包含应用程序的路由配置**'
- en: '***2* Adds it as an import for the app module**'
  id: totrans-1137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将其作为对应用程序模块的导入**'
- en: That’s all there is to it. The application will work as it did before, but we’re
    sure you’ll agree that both the routing configuration and main app module files
    are improved by this change. For a small application, you may not want or need
    to do this, but if you’re planning something big, it’s definitely worthwhile.
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。应用程序将像以前一样工作，但我们确信你会同意，通过这次更改，路由配置和主应用程序模块文件都得到了改进。对于小型应用程序，你可能不需要或想要这样做，但如果你有更大的计划，这绝对值得。
- en: Next, you’ll improve your `location` class definition.
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将改进`location`类的定义。
- en: 10.3.2\. Improving the location class definition
  id: totrans-1140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.2\. 改进`location`类的定义
- en: Your definition for the location class is currently held in home-list.component.ts.
    This location stems from when you created the homepage listing component in [chapter
    8](kindle_split_020.xhtml#ch08); it was the only component doing anything in the
    application. Now, you’re importing the location class definition in many places
    in the application; it’s becoming a key part of the application in its own right.
    As such, it makes sense to separate it into its own file.
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 你对`location`类的定义目前保存在`home-list.component.ts`中。这个定义源于你在[第8章](kindle_split_020.xhtml#ch08)中创建的主页列表组件；它是应用程序中唯一做任何事情组件。现在，你在应用程序的许多地方导入`location`类的定义；它已经成为应用程序本身的一个关键部分。因此，将其分离到自己的文件中是有意义的。
- en: When you do, you’ll also add the missing properties, as it currently defines
    only the properties that were used in the homepage listing; things like reviews
    and opening times are missing. Also, you’ll create a nested class for reviews
    that you can use in the class definition and in the application when you’re dealing
    directly with reviews.
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 当你这样做时，你也会添加缺失的属性，因为它目前只定义了在主页列表中使用的属性；例如评论和营业时间等属性是缺失的。此外，你将为评论创建一个嵌套类，你可以在类定义和应用程序中直接处理评论时使用它。
- en: When all this is done, you’ll have a much better TypeScript application.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 当这一切都完成时，你将拥有一个更好的TypeScript应用程序。
- en: Defining the Location class in its own file
  id: totrans-1144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在其自己的文件中定义`Location`类
- en: 'The first step is creating the file for the class definition, using the Angular
    CLI again:'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建类定义的文件，再次使用Angular CLI：
- en: '[PRE150]'
  id: totrans-1146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'This command generates a file, location.ts, in the src folder of the application.
    And it’s sparse! It should look something like this:'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令在应用程序的 src 文件夹中生成一个名为 location.ts 的文件。而且它很稀疏！它看起来应该像这样：
- en: '[PRE151]'
  id: totrans-1148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: It’s a little bit underwhelming, but at least it has nothing complex or unexpected.
    All you need to do is get the `Location` definition from home-list.component.ts
    and paste it in.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点令人失望，但至少它没有复杂或意外的地方。你所需要做的就是从 home-list.component.ts 获取 `Location` 定义并将其粘贴进去。
- en: Listing 10.23\. Adding the basic `Location` class definition in location.ts
  id: totrans-1150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.23\. 在 location.ts 中添加基本的 `Location` 类定义
- en: '[PRE152]'
  id: totrans-1151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: That’s still pretty simple. The definition for the `Location` class is now in
    its own file. You’d better start using it.
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然相当简单。`Location` 类的定义现在在其自己的文件中。你最好开始使用它。
- en: Using the new class file where needed
  id: totrans-1153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在需要的地方使用新的类文件
- en: 'The first place to use the new class definition file is home-list.component.ts,
    as that’s where it was initially defined. To do this, delete the original inline
    definition from this file and replace it with a simple import command:'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 首次使用新的类定义文件的地方是 home-list.component.ts，因为这是它最初定义的地方。为此，请从该文件中删除原始的内联定义，并用一个简单的导入命令替换：
- en: '[PRE153]'
  id: totrans-1155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'That replaces the location definition in the homepage listing, which is a good
    start. But if you’re still running `ng serve` at this point, you’ll get Angular
    compilation errors along these lines:'
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 这替换了主页列表中的位置定义，这是一个好的开始。但如果你此时仍在运行 `ng serve`，你将得到类似以下的 Angular 编译错误：
- en: '[PRE154]'
  id: totrans-1157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'This tells you that location-details.component.ts was using the `Location`
    class exported from `home-list`, so you need to update that too. Change the file
    you’re importing `Location` from:'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉你 location-details.component.ts 正在使用从 `home-list` 导出的 `Location` 类，因此你需要更新它。更改你导入
    `Location` 的文件：
- en: '[PRE155]'
  id: totrans-1159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'When you’re done, do the same in the other places from which `Location` is
    imported: details-page.component.ts and loc8r-data.service.ts. Remember that the
    path to `Location` is preceded by one dot rather than two when you’re importing
    it into loc8rdata.service.ts, due to the relative locations of these files.'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成时，在其他从 `Location` 导入的地方也做同样的事情：details-page.component.ts 和 loc8r-data.service.ts。记住，当你将
    `Location` 导入到 loc8rdata.service.ts 时，路径前面有一个点而不是两个点，这是由于这些文件的相对位置。
- en: Next, add the missing properties.
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加缺失的属性。
- en: Adding missing paths for the Location class definition
  id: totrans-1162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 为 Location 类定义添加缺失的路径
- en: When you use class properties in your application that you don’t declare in
    the class definition, you run the risk of having problems at build time, even
    though it may work fine under `ng serve`.
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在应用程序中使用你在类定义中未声明的类属性时，你可能会在构建时遇到问题，尽管它可能在 `ng serve` 下运行良好。
- en: You’re currently missing `coords` and `openingTimes` from your class definition.
    `coords` is a simple addition—an array of numbers. `openingTimes` is a different
    deal, though, as that’s a complex object in its own right.
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 你目前从你的类定义中遗漏了 `coords` 和 `openingTimes`。`coords` 是一个简单的添加——一个数字数组。而 `openingTimes`
    是一个不同的情况，因为它本身就是一个复杂对象。
- en: Remember how with Mongoose, you can use nested schemas to define subdocuments?
    (See [chapter 5](kindle_split_016.xhtml#ch05) if you don’t.) Well, you can do
    the same thing with classes in TypeScript. [Listing 10.24](#ch10ex24) shows how
    to update the location.ts file to define a class called `OpeningTimes`, and how
    to define a property of the same name on the `Location` class to be an array of
    the `OpeningTimes` type. It also adds the `coords` property.
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 记得 Mongoose 如何使用嵌套模式来定义子文档吗？（如果你不记得，请参阅[第 5 章](kindle_split_016.xhtml#ch05)。）嗯，你可以在
    TypeScript 中的类上做同样的事情。[列表 10.24](#ch10ex24) 展示了如何更新 location.ts 文件以定义一个名为 `OpeningTimes`
    的类，以及如何在 `Location` 类上定义同名属性，使其成为 `OpeningTimes` 类型的数组。它还添加了 `coords` 属性。
- en: Listing 10.24\. Adding missing properties and a nested class definition to location.ts
  id: totrans-1166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.24\. 向 location.ts 添加缺失的属性和嵌套类定义
- en: '[PRE156]'
  id: totrans-1167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '***1* Defines a new OpeningTimes class**'
  id: totrans-1168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义一个新的 OpeningTimes 类**'
- en: '***2* Adds the missing coords property to Location**'
  id: totrans-1169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 为 Location 添加缺失的 coords 属性**'
- en: '***3* Adds the openingTimes property to the Location class to be an array of
    the OpeningTimes class**'
  id: totrans-1170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将 openingTimes 属性添加到 Location 类，使其成为 OpeningTimes 类的数组**'
- en: Looking good. The class definition has all the properties you need and use.
    Note that the `OpeningTimes` class isn’t available to be imported into other files
    by itself, as it isn’t declared as an `export`. Although this has everything you
    need, you can improve the `reviews` property definition.
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错。类定义包含了你需要和使用的所有属性。请注意，`OpeningTimes` 类本身不可导入到其他文件中，因为它没有被声明为 `export`。尽管这已经包含了你需要的一切，但你还可以改进
    `reviews` 属性定义。
- en: Defining a review class, avoiding the ‘any’ type
  id: totrans-1172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义评论类，避免使用 ‘any’ 类型
- en: You’ve got `reviews` defined as an array of type `any`. This should be a bit
    of a red flag, as best practice in TypeScript is to try to avoid using `any` wherever
    possible, as it weakens the class structure.
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 你将 `reviews` 定义为一个类型为 `any` 的数组。这应该是一个警告标志，因为 TypeScript 中的最佳实践是尽可能避免使用 `any`，因为它会削弱类结构。
- en: Here, it’s possible to avoid using `any`, as you know the schema of a review,
    and you’ve seen how to define and use nested classes. Unlike with the `OpeningTimes`
    definition, you’ll want to use the `Review` class definition elsewhere in the
    application, so you’ll declare this one as an `export`.
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以避免使用 `any`，因为你知道评论的架构，并且你已经看到了如何定义和使用嵌套类。与 `OpeningTimes` 定义不同，你希望在应用程序的其他地方使用
    `Review` 类定义，所以你将这个声明为 `export`。
- en: The following listing shows how to define the `Review` class, export it, and
    use it inside the `Location` class definition. Note that the source code should
    also include the `OpeningTimes` definition, but we’ve left it out of this listing
    for brevity.
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了如何定义 `Review` 类，导出它，并在 `Location` 类定义中使用它。请注意，源代码还应包括 `OpeningTimes`
    定义，但我们为了简洁起见省略了它。
- en: Listing 10.25\. Defining, using, and exporting a class for reviews in locations.ts
  id: totrans-1176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.25\. 在 locations.ts 中定义、使用和导出评论类
- en: '[PRE157]'
  id: totrans-1177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '***1* Defines and exports the class definition for reviews**'
  id: totrans-1178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义并导出评论类的定义**'
- en: '***2* Declares location reviews to be of type Review**'
  id: totrans-1179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 声明位置评论为类型 Review**'
- en: Now your `Location` class is complete. You’ve got a nested class for reviews,
    which is available to be used elsewhere, and another nested class for opening
    times, which is available only to this file. One final thing to tighten your use
    of the `Location` class is to use the `Review` class within the application.
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的 `Location` 类已经完成。你有一个用于评论的嵌套类，它可以在其他地方使用，还有一个用于营业时间的嵌套类，它只适用于此文件。为了更严格地使用
    `Location` 类，你需要在应用程序中使用 `Review` 类。
- en: Explicitly importing and using the review class where needed
  id: totrans-1181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在需要的地方显式导入和使用评论类
- en: 'You have two places where you could make good use of the `Review` class: in
    the location details component, where you use the form to add new reviews, and
    in your data service, where you push the new review data to the API.'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 你有两个地方可以使用 `Review` 类：在位置详情组件中，你使用表单添加新的评论，以及在你数据服务中，你将新的评论数据推送到 API。
- en: 'In the files for these components (location-details.component.ts and loc8rdata.service.js),
    update the `Location` import to also import the `Review` class, like this:'
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些组件的文件（location-details.component.ts 和 loc8rdata.service.js）中，更新 `Location`
    导入以同时导入 `Review` 类，如下所示：
- en: '[PRE158]'
  id: totrans-1184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: There are two places in the location details component where you can use the
    `Review` definition to add types to your variables, as shown in the next listing.
    The first place is when you define `newReview` and give it default values, and
    the second is when the saved review is returned from the API.
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 在位置详情组件中，有两个地方可以使用 `Review` 定义来为你的变量添加类型，如下所示。第一个地方是在你定义 `newReview` 并为其提供默认值时，第二个地方是在从
    API 返回保存的评论时。
- en: Listing 10.26\. Updating location-details.component.ts to use the new Review
    type
  id: totrans-1186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.26\. 更新 location-details.component.ts 以使用新的 Review 类型
- en: '[PRE159]'
  id: totrans-1187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '***1* Adds the Review type to the newReview definition**'
  id: totrans-1188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 Review 类型添加到 newReview 定义中**'
- en: '***2* The saved review returned from the API should also be of type Review.**'
  id: totrans-1189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从 API 返回的保存评论也应为类型 Review。**'
- en: In a similar way, you can tighten the `addReviewByLocationId` method in your
    data service by specifying that the inputs and outputs should be of type `Review`,
    changing them from `any`. The three changes are shown in the following listing.
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，你可以通过指定输入和输出应为类型 `Review` 来收紧你数据服务中的 `addReviewByLocationId` 方法，将它们从
    `any` 改变。以下列表显示了这三个更改。
- en: Listing 10.27\. Using the Review type to tighten the definitions in loc8r-data.service.ts
  id: totrans-1191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.27\. 在 loc8r-data.service.ts 中使用 Review 类型来收紧定义
- en: '[PRE160]'
  id: totrans-1192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '***1* The incoming form data should be of type Review, as should the expected
    return value of the method.**'
  id: totrans-1193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 入站表单数据应与 Review 类型相同，方法预期的返回值也应如此。**'
- en: '***2* The response of the API should also be of type Review, not any.**'
  id: totrans-1194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* API 的响应类型也应为 Review，而不是任何类型。**'
- en: That wasn’t too painful, and now you have a much tighter application following
    some good TypeScript and Angular best practices. Using type definitions is helpful
    for preventing unexpected mistakes when passing around data; it’s easy to forget
    which parameter is supposed to be a string or an array, which properties an object
    should have, and so on. This approach saves you from these problems, which is
    especially helpful when someone else is trying to read your code or you return
    to it after a break and forget the finer details.
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不太痛苦，现在你有一个遵循一些良好的 TypeScript 和 Angular 最佳实践的更紧密的应用程序。使用类型定义有助于防止在传递数据时出现意外的错误；很容易忘记哪个参数应该是字符串或数组，对象应该有哪些属性，等等。这种方法可以让你避免这些问题，当其他人试图阅读你的代码或你在休息后返回并忘记细节时，这尤其有帮助。
- en: You’re now in a position where you’re happy with your SPA and want to use it
    as the front end of your Loc8r application, replacing the current Express version.
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经对你的 SPA 满意，并希望将其用作 Loc8r 应用程序的前端，取代当前的 Express 版本。
- en: 10.4\. Using the SPA instead of the server-side application
  id: totrans-1197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4\. 使用单页应用（SPA）而不是服务器端应用
- en: In the final section of this chapter, you’ll build your Angular app for production
    and update Express to deliver this app as the front end instead of the Pug templates.
    As you go, you’ll make adjustments to ensure direct access to deep URLs in the
    application without compromising the API routing.
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，你将构建你的 Angular 应用程序以用于生产，并将 Express 更新为作为前端而不是 Pug 模板来提供此应用程序。在这个过程中，你将进行调整以确保应用程序中深层次
    URL 的直接访问，同时不损害 API 路由。
- en: 'Before you do any of that, you’ll prepare the application for your production
    environment, by updating the environments/environment files. If you take a look
    in the environments folder, you’ll see two files: environment.ts and environment.prod.ts.
    Both of these files need to be updated. In environment.ts, make the following
    change (in bold).'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行任何操作之前，你需要通过更新 environments/environment 文件来为你的生产环境准备应用程序。如果你查看 environments
    文件夹，你会看到两个文件：environment.ts 和 environment.prod.ts。这两个文件都需要更新。在 environment.ts
    中，进行以下更改（加粗）。
- en: Listing 10.28\. Adding an environment variable to the development environment
  id: totrans-1200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.28\. 在开发环境中添加环境变量
- en: '[PRE161]'
  id: totrans-1201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '***1* New environment variable for development**'
  id: totrans-1202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 新的环境变量用于开发**'
- en: You also need to make a similar change in environments/environment.prod.ts.
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要在 environments/environment.prod.ts 中进行类似的更改。
- en: Listing 10.29\. Adding an environment variable to the production environment
  id: totrans-1204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.29\. 在生产环境中添加环境变量
- en: '[PRE162]'
  id: totrans-1205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '***1* Adds the Heroku URL to the API endpoints (the Heroku URL with /api appended)**'
  id: totrans-1206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 Heroku URL 添加到 API 端点（附加 /api 的 Heroku URL）**'
- en: Instead of using the localhost address that has been used throughout development,
    you’ll use the Heroku URL for your deployed application. Once this is done, you’ll
    update loc8r-data.service.ts to use the newly minted environment variable.
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 与开发过程中一直使用的 localhost 地址不同，你将使用部署应用程序的 Heroku URL。完成此操作后，你将更新 loc8r-data.service.ts
    以使用新创建的环境变量。
- en: 'In the `import` block at the top of loc8r-data.service.ts file, add the following:'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 在 loc8r-data.service.ts 文件顶部的 `import` 块中，添加以下内容：
- en: '[PRE163]'
  id: totrans-1209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: This means that you can now replace
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你现在可以替换
- en: '[PRE164]'
  id: totrans-1211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: with
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: with
- en: '[PRE165]'
  id: totrans-1213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'With this change, Angular will choose the correct environment when you build,
    and you’re now ready build your application for deployment. As you did at the
    end of [chapter 8](kindle_split_020.xhtml#ch08), run the `ng build` command in
    the app_public folder in terminal, specifying options to flag it as a production
    build with the output folder of build:'
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 通过此更改，Angular 将在构建时选择正确的环境，你现在可以准备好构建用于部署的应用程序。就像你在 [第 8 章](kindle_split_020.xhtml#ch08)
    的结尾所做的那样，在终端中运行 app_public 文件夹中的 `ng build` 命令，指定选项将其标记为生产构建，输出文件夹为 build：
- en: '[PRE166]'
  id: totrans-1215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: When that code finishes running, you’ll find a compiled version of the SPA in
    the folder app_public/build. This folder has everything the SPA needs to run,
    including the HTML page, JavaScript files, CSS, and fonts.
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码运行完成后，你将在 app_public/build 文件夹中找到一个编译后的 SPA 版本。这个文件夹包含了 SPA 运行所需的一切，包括 HTML
    页面、JavaScript 文件、CSS 和字体。
- en: Next, you’ll tell Express to use it.
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将告诉 Express 使用它。
- en: 10.4.1\. Routing Express requests to the build folder
  id: totrans-1218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.1\. 将 Express 请求路由到构建文件夹
- en: 'To get Express to serve the Angular app for the front end, you need to do two
    things: disable all the previous routes for the front-end application, and tell
    Express that your Angular build folder should serve static files.'
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 要让 Express 为前端服务 Angular 应用，你需要做两件事：禁用所有之前的前端应用路由，并告诉 Express 你的 Angular 构建文件夹应该服务静态文件。
- en: 'To disable the Express-based routes for the front end, find these two lines
    in app.js, and delete them or comment them out:'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用前端基于 Express 的路由，在 app.js 中找到这两行，并删除它们或将其注释掉：
- en: '[PRE167]'
  id: totrans-1221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: and
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE168]'
  id: totrans-1223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: You also no longer need the /public folder for serving static files, as all
    the files the Angular app needs are sitting inside the Angular build folder. Don’t
    delete that line, though, as you need Express to serve the contents of the build
    folder as static files. Instead, find the following line in app.js,
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 你也不再需要 /public 文件夹来服务静态文件，因为 Angular 应用所需的所有文件都位于 Angular 构建文件夹内。不过，请不要删除那行代码，因为你需要
    Express 来服务构建文件夹的内容作为静态文件。相反，在 app.js 中找到以下行，
- en: '[PRE169]'
  id: totrans-1225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'and add a similar line below it to use the app_public/build folder, like so:'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 并在其下方添加类似的行来使用 app_public/build 文件夹，如下所示：
- en: '[PRE170]'
  id: totrans-1227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Run the Express app, if it’s not already running under `nodemon`, and head to
    localhost:3000 in the browser. Everything you see there now is the Angular app,
    which you can validate by inspecting the elements of the page, as shown in [figure
    10.10](#ch10fig10).
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Express 应用尚未在 `nodemon` 下运行，请运行 Express 应用，然后在浏览器中转到 localhost:3000。你现在看到的一切都是
    Angular 应用，你可以通过检查页面元素来验证它，如图 10.10 所示。
- en: Figure 10.10\. The homepage of the running Express app now delivers the Angular
    SPA.
  id: totrans-1229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.10. 运行中的 Express 应用的主页现在提供了 Angular SPA。
- en: '![](Images/10fig10_alt.jpg)'
  id: totrans-1230
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10fig10_alt.jpg)'
- en: With these changes, when the homepage is requested, Express serves the first
    matching resource, which is the index.html file in the app_public/build folder.
    It’s no longer matching an Express route and using a Pug template.
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些更改，当请求主页时，Express 服务第一个匹配的资源，即 app_public/build 文件夹中的 index.html 文件。它不再匹配
    Express 路由并使用 Pug 模板。
- en: This works great for the homepage, and you can navigate through the app fine.
    But if you take the URL for the About page or a Details page and paste it into
    the URL bar, you get a `404` error. You need to fix this inability to access deep
    URLs directly, as it’s not a useful site if you allow people to come in only through
    the homepage.
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于主页来说效果很好，你可以顺利地浏览应用。但如果你将关于页面或详情页的 URL 复制到地址栏，你会得到一个 `404` 错误。你需要修复无法直接访问深层
    URL 的问题，因为如果你只允许人们通过主页进入，那么这个网站将没有用。
- en: 10.4.2\. Making sure that deep URLs work
  id: totrans-1233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.2. 确保深层 URL 可以正常工作
- en: This routing problem shouldn’t be a great surprise. You’ve told Express to serve
    a static file for the homepage, but there’s no about folder inside the build folder,
    so Express couldn’t possibly know to show the Angular app.
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个路由问题不应该让你感到惊讶。你已经告诉 Express 为主页服务一个静态文件，但在构建文件夹内没有 about 文件夹，所以 Express 不可能知道要显示
    Angular 应用。
- en: A simple way to address this problem is to let Express try to match the routes
    against everything it knows to exist and then add a catchall route at the end
    to serve anything that hasn’t matched yet. This catchall route can be defined
    by using a * as a wildcard for unmatched GET requests and should respond by sending
    the index.html file for the Angular app.
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的简单方法是通过让 Express 尝试匹配它所知道的所有路由，然后在最后添加一个通配符路由来服务尚未匹配的任何内容。这个通配符路由可以通过使用
    * 作为未匹配的 GET 请求的通配符来定义，并且应该通过发送 Angular 应用的 index.html 文件来响应。
- en: 'The following snippet shows how to add the catchall route after all the other
    route-matching statements in app.js, in this case after the definition for the
    API routes:'
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了如何在 app.js 中所有其他路由匹配语句之后添加通配符路由，在这种情况下是在 API 路由定义之后：
- en: '[PRE171]'
  id: totrans-1237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: With this code in place, if any URL isn’t matched by Express in the Angular
    build folder for the API routes, it responds with the index page for the Angular
    app. This is good, but you can make it a bit better.
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码到位后，如果任何 URL 在 Angular 构建文件夹中的 API 路由中没有匹配到 Express，它将响应 Angular 应用的首页。这是好的，但你可以使它更好。
- en: Rather than use a * to match everything, you can use a regular expression to
    define a pattern to match a URL (or set of URLs) that you want to apply the routing
    to. The regular expression to match the /about route is simple; you need to add
    start and end string delimiters and escape the forward slash so that it looks
    like `^\/about$`.
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用*来匹配所有内容，你可以使用正则表达式来定义一个模式以匹配你想要应用路由的URL（或一组URL）。匹配/about路由的正则表达式很简单；你需要添加起始和结束字符串定界符，并转义正斜杠，使其看起来像`^/about$`。
- en: The regular expression for a Details page is a bit more complicated, due to
    the location ID. The location ID is a MongoDB `ObjectId` that is a 24-character,
    seemingly random mixture of numbers and lowercase letters. A regular expression
    to match these characters is `[a-z0-9]{24}`. Using the same approach as the About
    page’s regular expression, the complete one for the location details pages is
    `^\/location\/[az0-9]{24}$`.
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 由于位置ID，Details页面的正则表达式要复杂一些。位置ID是一个24字符的、看似随机的数字和小写字母混合的MongoDB `ObjectId`。匹配这些字符的正则表达式是`[a-z0-9]{24}`。使用与About页面正则表达式相同的方法，位置详情页面的完整正则表达式是`^/location/[a-z0-9]{24}$`。
- en: 'The following snippet shows how to update the catchall route in app.js with
    a combined regular expression to match either the About page or a location details
    page:'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了如何使用组合正则表达式更新app.js中的catchall路由，以匹配About页面或位置详情页面：
- en: '[PRE172]'
  id: totrans-1242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: That’s a good change, as now Express will send the Angular app as a response
    only when a valid URL is entered.
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个好的变化，因为现在只有当输入有效的URL时，Express才会发送Angular应用程序作为响应。
- en: With that, your SPA is now fully working, being served up by Express, and talking
    to the Express API, which in turn is getting data in and out of MongoDB. You’ve
    got a full MEAN stack application. Congratulations!
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你的SPA现在完全工作，由Express提供服务，并与Express API通信，而Express API则从MongoDB中获取数据。你拥有一个完整的MEAN堆栈应用程序。恭喜！
- en: In [chapters 11](kindle_split_024.xhtml#ch11) and [12](kindle_split_025.xhtml#ch12),
    you’ll see how to manage authenticated sessions by adding the ability for users
    to register and log in before leaving reviews.
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](kindle_split_024.xhtml#ch11)和[第12章](kindle_split_025.xhtml#ch12)中，你将看到如何通过添加用户在提交评论前注册和登录的能力来管理认证会话。
- en: Summary
  id: totrans-1246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了
- en: That URL parameters can be used to pass data from routes to components and services
  id: totrans-1248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用URL参数将数据从路由传递到组件和服务
- en: That services are used to query the API
  id: totrans-1249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务用于查询API
- en: How Angular templates have display logic in the form of `*ngIf` and `ngSwitch`
  id: totrans-1250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular模板如何以`*ngIf`和`ngSwitch`的形式具有显示逻辑
- en: How to create custom pipes and use them
  id: totrans-1251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建自定义管道并使用它们
- en: About best practice for placing routing configuration in a separate file to
    improve the architecture
  id: totrans-1252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于将路由配置放置在单独的文件中以改进架构的最佳实践
- en: About the best practice for creating standalone class definitions, including
    nested classes, and for improving the use of custom type definitions through the
    application
  id: totrans-1253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于创建独立类定义的最佳实践，包括嵌套类，以及通过应用程序改进自定义类型定义的使用
- en: How to get Express to deliver an Angular application instead of server-side
    routes for certain URL requests
  id: totrans-1254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何让Express为某些URL请求发送Angular应用程序而不是服务器端路由
