- en: Appendix B. OCI runtimes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 B. OCI 运行时
- en: This appendix describes the primary OCI runtimes used with container engines
    like Podman. As discussed in chapter 1, the OCI runtime ([https://opencontainers.org](https://opencontainers.org/))
    is the executable launched by container engines, including Podman, used to configure
    the Linux kernel and subsystems to run the kernel; its last step is launching
    the container. The OCI runtime reads the OCI runtime specification JSON file and
    then configures the namespaces, security controls, and cgroups and eventually
    starts the container process (figure B.1).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录描述了与 Podman 等容器引擎一起使用的主要 OCI 运行时。如第 1 章所述，OCI 运行时 ([https://opencontainers.org](https://opencontainers.org/))
    是由容器引擎（包括 Podman）启动的可执行文件，用于配置 Linux 内核和子系统以运行内核；其最后一步是启动容器。OCI 运行时读取 OCI 运行时规范
    JSON 文件，然后配置命名空间、安全控制和 cgroups，最终启动容器进程（图 B.1）。
- en: '![](../../OEBPS/Images/B-01.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/B-01.png)'
- en: Figure B.1 Podman executes the OCI runtime to launch the container.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 图 B.1 Podman 执行 OCI 运行时来启动容器。
- en: In this appendix, you’ll learn the four main OCI runtimes in use. The `--runtime`
    option allows you to switch between different OCI runtimes. In the next example,
    you will run the same container command twice, each time with a different runtime.
    In the first command, you run the container with a runtime, `crun`, defined in
    the containers.conf, so you don’t need to specify the path to the runtime.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录中，您将了解正在使用的四个主要 OCI 运行时。`--runtime` 选项允许您在不同的 OCI 运行时之间切换。在下一个示例中，您将运行相同的容器命令两次，每次使用不同的运行时。在第一个命令中，您使用在
    containers.conf 中定义的运行时 `crun` 来运行容器，因此您不需要指定运行时的路径。
- en: Listing B.1 Podman running with the alternate OCI runtime `crun`
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 B.1 Podman 使用备用 OCI 运行时 `crun`
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ The --runtime option tells Podman to use the crun OCI runtime, rather than
    the default.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `--runtime` 选项告诉 Podman 使用 crun OCI 运行时，而不是默认的运行时。
- en: The default runtime is defined under the `[containers]` table in the containers.conf
    file on the Linux machine.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 默认运行时在 Linux 机器上 containers.conf 文件中的 `[containers]` 表下定义。
- en: Listing B.2 Modifying the default OCI runtime
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 B.2 修改默认 OCI 运行时
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Podman defaults to crun on most systems; on some older distributions, like
    Red Hat Enterprise Linux, Podman defaults to runc.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Podman 在大多数系统上默认使用 crun；在一些较旧的发行版，如 Red Hat Enterprise Linux 上，Podman 默认使用
    runc。
- en: 'In the second example, you use the full path of the OCI runtime, /usr/bin/runc:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，您使用 OCI 运行时的完整路径，/usr/bin/runc：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you want to permanently change the default OCI runtime, you can set the
    runtime option in the `[engine]` table in the containers.conf file in your home
    directory:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想永久更改默认的 OCI 运行时，您可以在家目录中的 containers.conf 文件中的 `[engine]` 表中设置运行时选项：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note The `--runtime` option is only available on Linux. `podman` `--remote`,
    and therefore Podman, on Mac and Windows, does not support the `--runtime` option,
    so you need to set the containers.conf file on the server side.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`--runtime` 选项仅在 Linux 上可用。`podman` `--remote`，因此 Podman 在 Mac 和 Windows
    上不支持 `--runtime` 选项，所以您需要在服务器端设置 containers.conf 文件。
- en: 'See the `podman(1)` man page for more information: `man` `podman.`'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 查看更多关于 `podman(1)` 的信息：`man` `podman.`。
- en: OCI runtimes are continuously being developed and experimented with. You can
    expect innovation to happen in this space going forward. The first container runtime
    developed, and the de facto standard, is `runc`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: OCI 运行时正在不断开发和实验中。您可以期待未来在这个领域发生创新。第一个开发的容器运行时，以及事实上的标准，是 `runc`。
- en: B.1 runc
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.1 runc
- en: '`runc` is the original OCI runtime ([https://github.com/opencontainers/runc](https://github.com/opencontainers/runc)).
    When the OCI originally formed, Docker donated `runc` to the OCI to serve as the
    default implementation of an OCI runtime. The OCI continues to support and develop
    `runc`. It is written in Golang and also includes the libcontainer library, which
    is used in many container engines and Kubernetes.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`runc` 是原始的 OCI 运行时 ([https://github.com/opencontainers/runc](https://github.com/opencontainers/runc)).
    当 OCI 最初形成时，Docker 将 `runc` 捐赠给 OCI，作为 OCI 运行时的默认实现。OCI 继续支持和开发 `runc`。它用 Golang
    编写，还包括 libcontainer 库，该库被许多容器引擎和 Kubernetes 使用。'
- en: The `runc` website states that `runc`, and all of the OCI runtimes, is a low-level
    tool not designed to be used directly by the end user. It is recommended to be
    launched by container engines like Podman or Docker.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`runc` 网站声明，`runc` 以及所有 OCI 运行时，是一个低级工具，不建议直接由最终用户使用。建议由容器引擎如 Podman 或 Docker
    启动。'
- en: Recall that the container engine’s job is pulling the container images to the
    host, configuring and mounting the root filesystem (rootfs) to be used within
    the container, and, finally, writing the OCI runtime JSON file before launching
    the OCI runtime.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，容器引擎的工作是拉取容器镜像到主机，配置并挂载根文件系统（rootfs）以在容器内使用，最后在启动 OCI 运行时之前写入 OCI 运行时 JSON
    文件。
- en: The OCI runtime specification describes only the content of the JSON file used
    by OCI runtimes. Because every OCI engine supports the `runc` command line, the
    other OCI runtimes adopted the same CLI commands and options. This makes it easier
    for one runtime to replace another when launched by the container engine. Table
    B.1 shows the commands supported by `runc` and therefore all OCI runtimes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: OCI 运行时规范仅描述了 OCI 运行时使用的 JSON 文件的内容。因为每个 OCI 引擎都支持 `runc` 命令行，其他 OCI 运行时也采用了相同的
    CLI 命令和选项。这使得当一个运行时被容器引擎启动时，替换另一个运行时变得更加容易。表 B.1 显示了 `runc` 支持的命令，因此所有 OCI 运行时都支持这些命令。|
- en: Table B.1 `runc` commands
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 表 B.1 `runc` 命令
- en: '| Command | Description |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 描述 |'
- en: '| `checkpoint` | Checkpoints a running container |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `checkpoint` | 检查点一个正在运行的容器|'
- en: '| `create` | Creates a container |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `create` | 创建一个容器|'
- en: '| `delete` | Deletes any resources held by the container often used with detached
    containers |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `delete` | 删除容器持有的任何资源，通常与分离容器一起使用|'
- en: '| `events` | Displays container events, such as OOM notifications, CPU, memory,
    and IO usage statistics |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `events` | 显示容器事件，例如 OOM 通知、CPU、内存和 IO 使用统计信息|'
- en: '| `init` | Initializes the namespaces and launches the process |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `init` | 初始化命名空间并启动进程|'
- en: '| `kill` | Sends the specified signal (default: `SIGTERM`) to the container’s
    init process |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `kill` | 向容器的 init 进程发送指定的信号（默认：`SIGTERM`）|'
- en: '| `List` | Lists containers started by runc with the given root |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `List` | 列出由 `runc` 启动的、给定根目录下的容器|'
- en: '| `pause` | Suspends all processes inside the container |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `pause` | 暂停容器内的所有进程|'
- en: '| `ps` | Displays the processes running inside a container |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `ps` | 显示容器内运行的进程|'
- en: '| `restore` | Restores a container from a previous checkpoint |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `restore` | 从之前的检查点恢复容器|'
- en: '| `resume` | Resumes all processes that have been previously paused |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `resume` | 恢复之前暂停的所有进程|'
- en: '| `run` | Creates and runs a container |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `run` | 创建并运行一个容器|'
- en: '| `spec` | Creates a new specification file |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `spec` | 创建一个新的规范文件|'
- en: '| `start` | Executes the user-defined process in a created container |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `start` | 在创建的容器中执行用户定义的进程|'
- en: '| `state` | Outputs the state of a container |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `state` | 输出容器的状态|'
- en: '| `update` | Updates container resource constraints |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `update` | 更新容器资源限制|'
- en: '`runc` continues to be developed and has a very active community. The problem
    with `runc` is that it is written in Golang. Golang was not designed to be a small,
    often-executed application that needs to start quickly and fork/exec a command
    and exit quickly. Fork/exec is a heavy operation in Golang, and although `runc`
    attempts to work around this, it ultimately sacrifices a bit of performance. The
    *a bit* can accumulate over time though, so `crun` performs much better at scale.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`runc` 仍在不断发展，并拥有一个非常活跃的社区。`runc` 的问题在于它是用 Golang 编写的。Golang 并非为小型、经常执行的应用程序而设计，这种应用需要快速启动、执行
    fork/exec 命令并快速退出。在 Golang 中，fork/exec 是一个重量级的操作，尽管 `runc` 尝试解决这个问题，但最终还是牺牲了一部分性能。然而，“一点”性能损失可能会随着时间的推移而累积，因此
    `crun` 在大规模应用中表现更佳。'
- en: B.2 crun
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.2 crun
- en: '`runc`, being written in Golang, is a very heavy executable—12 megabytes in
    size. Golang is a great language, but it doesn’t take advantage of shared libraries.
    Golang executables take up considerably more memory because of this. The size
    of `runc` causes it to be somewhat slower loading during container start. Another
    problem with Golang is that it does not support the fork/exec model all that well;
    it is slower than fork/exec in other languages (e.g., C). This lack of speed is
    more important when you are starting and stopping hundreds or thousands of containers—for
    example, on a Kubernetes cluster. Container engines like Podman, also written
    in Go, generally run for a much longer time, so the startup time is not as important.
    OCI runtimes like `runc` execute for a very short time and exit quickly.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`runc` 是用 Golang 编写的，是一个非常庞大的可执行文件——大小为 12 兆字节。Golang 是一种非常好的语言，但它没有充分利用共享库。由于这个原因，Golang
    可执行文件会占用更多的内存。`runc` 的大小导致它在容器启动时加载速度较慢。Golang 的另一个问题是它不支持 fork/exec 模型，它在其他语言（例如
    C）中的 fork/exec 模型要慢得多。当你启动和停止数百或数千个容器时（例如，在 Kubernetes 集群中），这种速度的缺乏更为重要。像 Podman
    这样的容器引擎，也是用 Go 编写的，通常运行时间更长，因此启动时间并不那么重要。像 `runc` 这样的 OCI 运行时执行时间非常短，并且快速退出。'
- en: Giuseppe Scrivano, a contributor to `runc` and Podman, understood these deficiencies
    in `runc` and wanted to write a compatible OCI runtime in the C language. He created
    a very lightweight OCI runtime called `crun`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Giuseppe Scrivano，`runc` 和 Podman 的贡献者，理解了 `runc` 中的这些不足，并希望用 C 语言编写一个兼容的 OCI
    运行时。他创建了一个非常轻量级的 OCI 运行时，称为 `crun`。
- en: '`crun` describes itself as “*a fast and lightweight OCI runtime.*” ([https://github.com/containers/crun](https://github.com/containers/crun))
    It supports all of the same commands and options as `runc`, and the `crun` executable
    is many times smaller than `runc`. Execute the `du` `-s` command to compare sizes:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`crun` 将自己描述为“*一个快速且轻量级的 OCI 运行时。” ([https://github.com/containers/crun](https://github.com/containers/crun))
    它支持与 `runc` 相同的所有命令和选项，而 `crun` 可执行文件的大小比 `runc` 小得多。执行 `du` `-s` 命令以比较大小：'
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`crun`, being written in C, supports fork and exec much better than `Golang`
    and, therefore, is much quicker when launching a container.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`crun` 是用 C 编写的，比 `Golang` 更好地支持 fork 和 exec，因此在启动容器时速度更快。'
- en: This also makes it plug in easily to other libraries on the system, and there
    is some experimentation on using `crun` as a library for processing the OCI runtime
    JSON file and launching different types of containers (e.g., WASM and Windows
    containers on Linux). `crun` also has potential for launching KVM-separated containers
    based on libkrun.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这也使得它能够轻松地集成到系统上的其他库中，并且有一些实验正在使用 `crun` 作为处理 OCI 运行时 JSON 文件和启动不同类型的容器（例如，Linux
    上的 WASM 和 Windows 容器）的库。`crun` 还基于 libkrun 有潜力启动基于 KVM 分离的容器。
- en: '`crun` is now the default OCI runtime used by Podman in Fedora and in Red Hat
    Enterprise Linux 9\. `runc` continues to be supported and is the default OCI runtime
    in Red Hat Enterprise Linux 8.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`crun` 现在是 Podman 在 Fedora 和 Red Hat Enterprise Linux 9 中使用的默认 OCI 运行时。`runc`
    继续得到支持，并在 Red Hat Enterprise Linux 8 中是默认的 OCI 运行时。'
- en: '`crun` and `runc` are the two primary OCI runtimes for managing traditional
    containers that use namespace separation. Both these projects work fairly closely
    together. When bugs or problems are found in either OCI runtime, they are quickly
    fixed in both. See the `crun(1)` man page for more information: `man` `crun`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`crun` 和 `runc` 是管理使用命名空间分离的传统容器的两个主要 OCI 运行时。这两个项目工作得相当紧密。当在任一 OCI 运行时中发现错误或问题时，它们会迅速在两个项目中修复。有关更多信息，请参阅
    `crun(1)` 手册页：`man` `crun`。'
- en: B.3 Kata
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.3 Kata
- en: '![](../../OEBPS/Images/B-01-UN01.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/B-01-UN01.png)'
- en: 'OCI runtimes are also written to use VM separation, with the primary example
    of this being Kata Containers. The Kata Container project ([https://katacontainers.io](https://katacontainers.io))
    advertises itself as the following: “*The speed of containers, the security of
    VMs. Kata Containers is an open source container runtime, building lightweight
    virtual machines that seamlessly plug into the container’s ecosystem.”*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: OCI 运行时也被编写为使用虚拟机隔离，其中主要的例子是 Kata Containers。Kata Container 项目（[https://katacontainers.io](https://katacontainers.io)）自我宣传如下：“*拥有容器的速度，虚拟机的安全性。Kata
    Containers 是一个开源容器运行时，构建轻量级的虚拟机，可以无缝地集成到容器的生态系统中。”*
- en: '![](../../OEBPS/Images/B-02.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/B-02.png)'
- en: Figure B.2 Kata containers launches a lightweight VM, which only runs the container.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 B.2 Kata containers 启动一个轻量级虚拟机，该虚拟机仅运行容器。
- en: Kata containers use VM technology for launching each container, which is very
    different from launching a VM and running Podman within it. A standard VM has
    an init system, which launches all sorts of services, like logging systems, cron,
    and more. On the other hand, a Kata container launches a micro OS, which runs
    only the container and its support services (figure B.2). As its only purpose
    is launching the container, when the container exits, this VM goes away.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Kata容器使用虚拟机技术来启动每个容器，这与在虚拟机内部启动VM和运行Podman的方式非常不同。一个标准的虚拟机有一个初始化系统，它会启动各种服务，如日志系统、cron等。另一方面，Kata容器启动一个微操作系统，它只运行容器及其支持服务（图B.2）。由于其唯一目的是启动容器，当容器退出时，这个虚拟机就会消失。
- en: I believe running containers within VM/hypervisor separation gives you better
    security separation than traditional container separation, where containers communicate
    directly with the host kernel. A VM-separated container has to first break out
    of containment inside of the VM, then find a way to break out of the hypervisor—only
    then to face attacking the host kernel.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为在VM/虚拟机分离中运行容器比传统的容器分离提供了更好的安全隔离，在传统的容器分离中，容器直接与主机内核通信。VM分离容器必须首先在虚拟机内部突破隔离，然后找到一种方法突破虚拟机管理程序——只有在这种情况下才会面临攻击主机内核。
- en: While VM-separated containers are more secure, this does come with some downsides.
    There is a decent amount of overhead in starting a Kata container, configuring
    the hypervisor, launching the kernel and other processes within the VM, and then
    finally the container. The VM’s memory, CPU, and so on have to be preallocated
    and are difficult to change. Running Kata within a VM in the cloud is often not
    allowed, or is at least more expensive, because most of the cloud vendors frown
    on nested virtualization.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然VM分离容器更安全，但这确实带来了一些缺点。启动Kata容器、配置虚拟机管理程序、在虚拟机内部启动内核和其他进程，以及最终启动容器，都需要相当大的开销。虚拟机的内存、CPU等资源必须预先分配，并且难以更改。在云中在虚拟机内部运行Kata通常是不允许的，或者至少更昂贵，因为大多数云服务提供商都不赞成嵌套虚拟化。
- en: Finally, and most importantly, VM-separated containers by their very nature
    have difficulties sharing content with other containers and the host operating
    system. The biggest problem is with volumes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，也是最重要的，VM分离容器由于其本质属性，在与其他容器和主机操作系统共享内容方面存在困难。最大的问题是卷。
- en: While sharing content with the host machine in traditional containers is just
    a bind mount, in VM-separate containers, bind mounts do not work. Since the processes
    on the host and in the container are running with two different kernels, you need
    a network protocol to share content. Kata containers originally used NFS and Plan
    9 networked filesystems. Reading/writing data over these networked filesystems
    is considerably slower than native filesystem reads and writes you get with a
    bind mount.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统容器中与主机机器共享内容只是一个绑定挂载，而在VM分离容器中，绑定挂载不起作用。由于主机和容器中的进程运行在两个不同的内核上，你需要一个网络协议来共享内容。Kata容器最初使用NFS和Plan
    9网络文件系统。在这些网络文件系统上读写数据比使用绑定挂载获得的本地文件系统读写要慢得多。
- en: Virtiofs is a new filesystem that has the properties of a network filesystem
    but allows VMs to access files on the host. It is able to show major improvements
    in speed over the network-based filesystems, while still remaining under heavy
    development.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Virtiofs是一种新的文件系统，它具有网络文件系统的属性，但允许虚拟机访问主机上的文件。它能够在速度上对基于网络的文件系统有显著的提升，同时仍然处于高度开发中。
- en: 'Kata containers have two ways to be launched. Kata traditionally has an OCI
    command line, `kata-runtime`, based on the `runc` command supported by Podman.
    You can see the paths defined in containers.conf, on the Linux machine, by searching
    for `#kata`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Kata容器有两种启动方式。Kata传统上有一个基于Podman支持的`runc`命令的OCI命令行，`kata-runtime`。你可以在Linux机器上通过搜索`#kata`来查看在`containers.conf`中定义的路径：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The bottom line on Kata containers is that you get better security with a performance
    overhead. You can choose between these OCI runtimes with your workload’s needs
    in mind.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Kata容器的底线是，你可以在性能开销的情况下获得更好的安全性。你可以根据工作负载的需求在这些OCI运行时之间进行选择。
- en: B.4 gVisor
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.4 gVisor
- en: '![](../../OEBPS/Images/B-02-UN02.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/B-02-UN02.png)'
- en: The last OCI runtime I cover in this appendix is gVisor ([https://gvisor.dev/](https://gvisor.dev/)).
    The gVisor website advertises itself as “an application kernel for containers
    that provides efficient defense-in-depth anywhere.”
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个附录中，我最后要介绍的是gVisor ([https://gvisor.dev/](https://gvisor.dev/))。gVisor网站将自己宣传为“为容器提供高效深度防御的应用内核。”
- en: gVisor includes an OCI runtime called `runsc` and works with Podman and other
    container engines. The gVisor project calls itself an application kernel, written
    in Golang, that implements a substantial portion of the Linux system call interface.
    It provides an additional layer of isolation between running applications and
    the host operating system. Google engineering wrote the original versions of gVisor
    and claims that the bulk of the containers Google Cloud run use the gVisor OCI
    runtime.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: gVisor 包含一个名为 `runsc` 的 OCI 运行时，并与 Podman 以及其他容器引擎协同工作。gVisor 项目将自己称为一个应用内核，使用
    Golang 编写，实现了 Linux 系统调用接口的大部分功能。它为运行中的应用程序和宿主操作系统之间提供了一个额外的隔离层。Google 工程师编写了
    gVisor 的原始版本，并声称 Google Cloud 运行的容器中大部分都使用了 gVisor OCI 运行时。
- en: gVisor is somewhat similar to VM-isolated containers in that gVisor intercepts
    almost all system calls from within the container and then processes them. gVisor
    describes itself as an application kernel for containers written in Golang, limiting
    the access to the host kernel. At the same time, it does not have the same problem
    of a nested virtualization as Kata.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: gVisor 在某种程度上类似于 VM 隔离容器，因为 gVisor 会拦截容器内部几乎所有的系统调用，然后对其进行处理。gVisor 将自己描述为使用
    Golang 编写的容器应用内核，限制了宿主内核的访问。同时，它没有像 Kata 那样的嵌套虚拟化问题。
- en: However, gVisor introduces a performance penalty with additional CPU cycles
    and higher memory usage. This may introduce increased latency, reduced throughput,
    or both. gVisor is also an independent implementation of the system call surface,
    meaning many of the subsystems or specific calls are not as optimized as more
    mature implementations.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，gVisor 引入了额外的 CPU 周期和更高的内存使用，从而带来性能损失。这可能会导致延迟增加、吞吐量减少，或者两者兼而有之。gVisor 还是对系统调用表面的一种独立实现，这意味着许多子系统或特定调用没有像更成熟的实现那样进行优化。
