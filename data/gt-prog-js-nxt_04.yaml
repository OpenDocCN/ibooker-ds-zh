- en: Unit 2\. Objects and arrays
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2单元：对象和数组
- en: Objects and arrays have always been the workhorse of JavaScript, acting as the
    go-to data structures for organizing data. Even with the additions of maps and
    sets, which you’ll learn about in [unit 5](kindle_split_035.xhtml#part05), objects
    and arrays aren’t going anywhere and will still be used just as much as before.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对象和数组一直是 JavaScript 的工作马，作为组织数据的首选数据结构。即使添加了映射和集合，你将在 [第5单元](kindle_split_035.xhtml#part05)
    中学习到，对象和数组也不会消失，并且仍然会像以前一样被广泛使用。
- en: Notice how I referred to objects and arrays as *data structures*. With literals,
    you can easily structure your data into complex structures that would be tedious
    to describe without literals. The inverse has always been missing. You probably
    never even noticed its absence, but once you see how awesome it is to be able
    to *destructure* your data as easily as you *structure* it, you may begin to feel
    handicapped anytime you have to go back to doing it the old way. Destructuring
    is one of my favorite new additions to JavaScript, and for good reason. You’ll
    find yourself using it everyday to make your code easier to read and write. But
    before you jump to destructuring, we’ll take a look at some useful new methods
    being added to objects and arrays. We’ll also look at some welcome additions to
    object literals thst make them even more powerful than before.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我如何将对象和数组称为 *数据结构*。使用字面量，你可以轻松地将数据结构化成复杂的结构，而没有字面量将变得繁琐。相反的机制一直缺失。你可能甚至从未注意到它的缺失，但一旦你看到能够像
    *解构* 数据一样轻松地 *结构化* 数据是多么的酷，你可能会在任何不得不回到旧方法的时候感到不便。解构是 JavaScript 中我最喜欢的新增功能之一，而且有很好的理由。你会发现自己在日常生活中经常使用它来使代码更容易阅读和编写。但在你跳到解构之前，我们将看看一些被添加到对象和数组中的有用新方法。我们还将看看对象字面量的一些受欢迎的添加，这使得它们比以前更强大。
- en: Finally, we’ll look at a completely new primitive data type, symbols. Symbols
    are commonly used to define what I call “meta behavior(s)”—hooks to alter or define
    the behavior of existing functionality. They can also be used to avoid the sorts
    of naming collisions you might run into with strings.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将探讨一个全新的原始数据类型，即符号。符号通常用于定义我所说的“元行为”——用于更改或定义现有功能行为的钩子。它们还可以用来避免与字符串可能遇到的命名冲突。
- en: You’ll wrap up this unit by programming a lock and key construct using the uniqueness
    of symbols as keys to the locks. You’ll then use these locks and keys to create
    a *Choose the Door* game where players try to unlock doors using keys they were
    given.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过编程一个使用符号的唯一性作为锁的键的锁和钥匙结构来结束本单元。然后，你将使用这些锁和钥匙创建一个 *选择门* 游戏，玩家将尝试使用他们获得的钥匙解锁门。
- en: Lesson 9\. New array methods
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9课：新数组方法
- en: After reading [lesson 9](kindle_split_019_split_000.xhtml#ch09), you will
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读 [第9课](kindle_split_019_split_000.xhtml#ch09) 之后，你将
- en: Know how to construct arrays with `Array.from`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何使用 `Array.from` 构建数组
- en: Know how to construct arrays with `Array.of`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何使用 `Array.of` 构建数组
- en: Know how to construct arrays with `Array.prototype.fill`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何使用 `Array.prototype.fill` 构建数组
- en: Know how to search in Arrays with `Array.prototype.includes`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何使用 `Array.prototype.includes` 在数组中进行搜索
- en: Know how to search in Arrays with `Array.prototype.find`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何使用 `Array.prototype.find` 在数组中进行搜索
- en: Arrays are probably the most common data structure used in JavaScript. We use
    them to hold all kinds of data, but sometimes getting the data we want into or
    out of the array isn’t as easy as it should be. But those tasks just got a lot
    easier with some of the new array methods that we’ll cover in this lesson.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可能是 JavaScript 中最常用的数据结构。我们使用它们来存储各种数据，但有时将所需数据放入或从数组中取出并不像应该的那样容易。但一些新的数组方法使得这些任务变得容易得多，我们将在本课中介绍这些方法。
- en: '|  |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: Consider this snippet of jQuery code that grabs all the DOM nodes with a specific
    CSS class and sets them to the color red. If you were going to implement this
    from scratch, what considerations would you have to make? For example, if you
    were to use `document.querySelectorAll`, which returns a `NodeList` (not an `Array`),
    how would you iterate each node to update its color?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下 jQuery 代码片段，它获取所有具有特定 CSS 类的 DOM 节点并将它们设置为红色。如果你要从头开始实现这个功能，你需要考虑哪些因素？例如，如果你要使用
    `document.querySelectorAll`，它返回一个 `NodeList`（而不是 `Array`），你将如何迭代每个节点来更新其颜色？
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '|  |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 9.1\. Constructing arrays with Array.from
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1. 使用 Array.from 构建数组
- en: Let’s say you’re going to write a function for averaging numbers. The function
    should take any number of arguments and return the average of all of those numbers.
    You may at first define this function like in [listing 9.1](kindle_split_019_split_001.xhtml#ch09ex01).
    But this implementation won’t work because it forgets the fact that the `arguments`
    object isn’t actually an array. After trying to use this function and getting
    an error like *arguments.reduce is not a function*, you would probably realize
    that you need to convert the `arguments` object into an array.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你将要编写一个用于计算平均值的函数。该函数应接受任意数量的参数，并返回所有这些数字的平均值。你最初可能会像在 [列表 9.1](kindle_split_019_split_001.xhtml#ch09ex01)
    中定义此函数。但此实现不会工作，因为它忘记了 `arguments` 对象实际上不是一个数组的事实。在尝试使用此函数并得到类似 *arguments.reduce
    不是函数* 的错误后，你可能会意识到你需要将 `arguments` 对象转换为数组。
- en: 'Listing 9.1\. `avg` version 1: producing an error, as arguments is not an array'
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.1\. `avg` 版本 1：产生错误，因为参数不是一个数组
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Before ES6, the common way of converting an array-like object into an array
    was by using the `slice` method on `Array.prototype` and applying it to the array-like
    object. This works because calling `slice` on an array without any arguments simply
    creates a shallow copy of the array. By applying the same logic to an array-like
    object, you still get a shallow copy, but the copy is an actual array:^([[1](kindle_split_019_split_001.xhtml#ch09fn01)])
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES6 之前，将类似数组的对象转换为数组的常见方法是在 `Array.prototype` 上使用 `slice` 方法并将其应用于类似数组的对象。这是因为对数组调用
    `slice` 而不带任何参数只是创建了一个数组的浅拷贝。通过将相同的逻辑应用于类似数组的对象，你仍然会得到一个浅拷贝，但这个拷贝是一个实际的数组:^([[1](kindle_split_019_split_001.xhtml#ch09fn01)])
- en: ¹
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Using `Array.prototype.apply` works just as well.
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 `Array.prototype.apply` 也可以达到同样的效果。
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With that in mind, you can fix your `avg` function by converting the `arguments`
    object into an array using this trick, as shown in the following listing.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，你可以通过使用以下技巧将 `arguments` 对象转换为数组来修复你的 `avg` 函数，如下面的列表所示。
- en: 'Listing 9.2\. `avg` version 2: using `slice` to convert arguments into an array'
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.2\. `avg` 版本 2：使用 `slice` 将参数转换为数组
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This shortcut is no longer needed with `Array.from`. The purpose of `Array.from`
    is to take an array-like object and get an actual array from it. The *array-like*
    object is any object with a `length` property. The `length` property is used to
    determine the length of the new array; any integer properties that are less than
    the `length` property will be added to the newly created array at the appropriate
    index. For example, a string has a `length` property and numeric properties indicating
    the index of each character. So calling `Array.from` with a string will return
    an array of characters. The `arguments` object can be converted into an array
    using this technique as well, as shown in the following listing.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Array.from` 后，这个快捷方式就不再需要了。`Array.from` 的目的是从一个类似数组的对象中获取一个实际的数组。类似数组的对象是任何具有
    `length` 属性的对象。`length` 属性用于确定新数组的长度；任何小于 `length` 属性的整数属性都将添加到新创建的数组中适当的索引位置。例如，字符串具有
    `length` 属性和表示每个字符索引的数字属性。因此，使用字符串调用 `Array.from` 将返回一个字符数组。`arguments` 对象也可以使用此技术转换为数组，如下面的列表所示。
- en: Listing 9.3\. Updating the `avg` function to use `Array.from`
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.3\. 更新 `avg` 函数以使用 `Array.from`
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* Returns 2**'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 返回 2**'
- en: '***2* Returns 102**'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 返回 102**'
- en: '***3* Returns 40**'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 返回 40**'
- en: Another common use case for needing `Array.from` is in conjunction with `document.querySelectorAll`.
    `document.querySelectorAll` returns a list of matching DOM nodes, but the object
    type is a `NodeList`, not an array.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 需要使用 `Array.from` 的另一个常见场景是与 `document.querySelectorAll` 结合使用。`document.querySelectorAll`
    返回一个匹配的 DOM 节点列表，但其对象类型是 `NodeList`，而不是数组。
- en: 'You aren’t limited to built-in objects for use with `Array.from`. Any object
    with a length property will work, even if all it has is a length property:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅限于使用内置对象与 `Array.from` 一起使用。任何具有长度属性的对象都可以工作，即使它只有长度属性：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This creates a new array exactly the same as `new Array(50)` would. But what
    if you just wanted to create an array with a single value of 50 in it, not a length
    of 50? See the next section for the answer.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个与 `new Array(50)` 完全相同的数组。但如果你只想创建一个包含单个值 50 的数组，而不是长度为 50 的数组呢？下一节将给出答案。
- en: '|  |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 9.1**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 9.1**'
- en: '**[Q1:](kindle_split_019_split_001.xhtml#ch09qa2q0a1)**'
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[问题 1:](kindle_split_019_split_001.xhtml#ch09qa2q0a1)**'
- en: ''
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Convert the following code to make use of `Array.from`:'
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将以下代码转换为使用 `Array.from`：
- en: ''
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|  |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 9.1 answer**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 9.1 答案**'
- en: '**[A1:](kindle_split_019_split_001.xhtml#ch09qa1q1)**'
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_019_split_001.xhtml#ch09qa1q1)**'
- en: ''
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|  |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 9.2\. Constructing arrays with Array.of
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2\. 使用Array.of构造数组
- en: 'Having a function that treats its arguments one way sometimes and a completely
    different way at other times is usually considered a bad design. For example,
    in the previous section, you created an `avg` function that returns the average
    of all of its arguments. Now imagine it only had one argument: you would expect
    to only get that number back, right? After all, the average of any single number
    is the same number? But what if, when only one number was supplied, it did something
    completely different and gave you back the square root of that number. You would
    probably tell me that’s a terrible design, but that type of mixed behavior is
    exactly how the `Array` constructor works. Consider the three following arrays;
    one of them is not what it seems:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个函数有时以一种方式处理其参数，而在其他时候则以完全不同的方式处理，这通常被认为是一种糟糕的设计。例如，在前一节中，你创建了一个`avg`函数，该函数返回所有参数的平均值。现在想象一下，如果它只有一个参数：你期望只得到那个数字，对吧？毕竟，任何单个数字的平均值都是相同的数字？但是，如果只提供一个数字时，它执行了完全不同的操作并返回了该数字的平方根，你可能会告诉我这是一个糟糕的设计，但那种混合行为正是`Array`构造函数的工作方式。考虑以下三个数组；其中一个是表面现象：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* The a array contains three values: 1, 2, 3.**'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 数组a包含三个值：1，2，3。**'
- en: '***2* The b array contains two values: 1 and 2.**'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 数组b包含两个值：1和2。**'
- en: '***3* Finally the c array contains a single value: undefined.**'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 最后数组c包含一个值：undefined。**'
- en: It’s kind of a quirk that when you declare `new Array(1)`, you get an array
    with an `undefined` value in it.^([[2](kindle_split_019_split_002.xhtml#ch09fn02)])
    The reason for this is a special behavior in the `Array` constructor, if there
    is only one argument and that argument is an integer, it creates a sparse array
    of length *n*, where *n* is the number passed in as an argument. To avoid this
    quirk, you can use the `Array.of` factory function that works more predictably.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当你声明`new Array(1)`时，你得到一个包含`undefined`值的数组，这有点奇怪.^([[2](kindle_split_019_split_002.xhtml#ch09fn02)])
    这种情况的原因是`Array`构造函数中的一种特殊行为，如果只有一个参数且该参数是一个整数，它将创建一个长度为*n*的稀疏数组，其中*n*是作为参数传入的数字。为了避免这种怪癖，你可以使用更可预测的`Array.of`工厂函数。
- en: ²
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It doesn’t even have an undefined value in it; it has a hole.
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它甚至没有`undefined`值；它有一个空位。
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The arrays created with `Array.of` are the same except for array `c`, which
    more intuitively this time contains the single value `1`. At this point, you may
    be thinking, why not just use an array literal? For example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Array.of`创建的数组除了数组`c`之外都是相同的，这次数组`c`更直观地包含单个值`1`。此时，你可能正在想，为什么不直接使用数组字面量呢？例如：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In most situations, an array literal is actually the preferred way to create
    arrays. But there are some situations where an array literal will not work. One
    such situation is using subclasses of arrays.^([[3](kindle_split_019_split_002.xhtml#ch09fn03)])
    Imagine you are using a library that provides a subclass of `Array` called `AwesomeArray`.
    Because it’s a subclass of `Array`, it has the same quirks. So you can’t simply
    call `new AwesomeArray(1)` because you’ll get an `AwesomeArray` with a single
    undefined value. But you can’t use an array literal here, because that will give
    you an instance of `Array`, not `AwesomeArray`. You can, however, use `AwesomeArray.of(1)`
    and get an instance of `AwesomeArray` with a single value of `1`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，数组字面量实际上是创建数组的首选方式。但是，在某些情况下，数组字面量可能无法使用。其中一种情况是使用数组的子类.^([[3](kindle_split_019_split_002.xhtml#ch09fn03)])
    假设你正在使用一个提供`Array`子类`AwesomeArray`的库。因为它是一个`Array`的子类，所以它有相同的怪癖。所以你不能简单地调用`new
    AwesomeArray(1)`，因为你会得到一个包含单个`undefined`值的`AwesomeArray`。但是你不能在这里使用数组字面量，因为这会给你一个`Array`的实例，而不是`AwesomeArray`的实例。然而，你可以使用`AwesomeArray.of(1)`并得到一个包含单个值`1`的`AwesomeArray`实例。
- en: ³
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We’ll cover classes and subclasses in later units.
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们将在后面的单元中介绍类和子类。
- en: So now you can construct an array with a single numeric value with `Array.of(50)`,
    but what if you did indeed want an array with 50 values? You could go back to
    `new Array(50)`, but that still has issues, as we’ll see in the next section.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在你可以使用`Array.of(50)`构造一个包含单个数值的数组，但如果你确实想要一个包含50个值的数组怎么办？你可以回到`new Array(50)`，但那仍然有问题，我们将在下一节中看到。
- en: '|  |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 9.2**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查9.2**'
- en: '**[Q1:](kindle_split_019_split_002.xhtml#ch09qa4q0a1)**'
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_019_split_002.xhtml#ch09qa4q0a1)**'
- en: ''
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following returns an array with `undefined` values?
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个返回包含`undefined`值的数组？
- en: ''
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|  |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 9.2 answer**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 9.2 答案**'
- en: '**[A1:](kindle_split_019_split_002.xhtml#ch09qa3q1)**'
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_019_split_002.xhtml#ch09qa3q1)**'
- en: ''
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following returns an array with `undefined` values?
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个返回一个包含 `undefined` 值的数组？
- en: ''
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|  |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 9.3\. Constructing Arrays with Array.prototype.fill
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3\. 使用 Array.prototype.fill 构建数组
- en: 'Image you’re creating a tic-tac-toe game. Maybe you’re building this for a
    client or maybe as a side project. Either way, tic-tac-toe is fun and you get
    to build it! To start, you need to decide how you’re going to implement the board.
    A tic-tac-toe board is a 3 × 3 grid of 9 slots. You decide you’ll just use an
    array for this. You can use an array of length 9 to represent the 9 grid slots
    and the possible values will be either `"x"`, `"o"`, or an empty space `" "`.
    You’ll call this array *board* but you need to initialize with 9 spaces `" "`.
    Maybe you’ll do something like:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你正在创建一个井字棋游戏。也许你是为某个客户构建的，或者可能是一个副项目。无论如何，井字棋很有趣，你可以构建它！为了开始，你需要决定你将如何实现棋盘。井字棋棋盘是一个
    3 × 3 的 9 个槽位的网格。你决定你将只使用一个数组来表示。你可以使用长度为 9 的数组来表示 9 个网格槽位，可能的值将是 `"x"`、`"o"`
    或空格 `" "`。你将称这个数组为 *board*，但你需要用 9 个空格 `" "` 初始化。也许你会这样做：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The thought process here is that you initialize the array with 9 values, all
    of them `undefined`. Then you use `map` to convert each `undefined` value into
    a space. But this won’t work. When you create an array like `new Array(9)`, it
    doesn’t actually add nine undefined values to the new array. It merely sets the
    newly created array’s `length` property to `9`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的思考过程是，你用 9 个值初始化数组，所有这些值都是 `undefined`。然后你使用 `map` 将每个 `undefined` 值转换为空格。但这不会起作用。当你创建一个像
    `new Array(9)` 这样的数组时，它实际上并没有向新数组添加九个 `undefined` 值。它只是将新创建数组的 `length` 属性设置为
    `9`。
- en: 'If you’re confused by that, let’s first talk about how arrays work in JavaScript.
    An array isn’t as special as many people think it is. Other than having a literal
    syntax like `[ ... ]`, it’s no different than any other object. When you create
    an array like `[''a'', ''b'', ''c'']`, internally that array looks like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对此感到困惑，让我们首先谈谈数组在 JavaScript 中的工作方式。数组并不像许多人想象的那样特殊。除了有 `[ ... ]` 这样的字面语法外，它与任何其他对象没有区别。当你创建一个像
    `['a', 'b', 'c']` 这样的数组时，内部这个数组看起来是这样的：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Of course, it will also inherit several methods such as `push`, `pop`, `map`,
    and so on from `Array.prototype`. When performing iterative operations like `map`
    and `forEach`, the array will internally look at its length and then check itself
    for any properties within the range starting at zero and ending at `length`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，它还会继承来自 `Array.prototype` 的几个方法，例如 `push`、`pop`、`map` 等。当执行 `map` 和 `forEach`
    这样的迭代操作时，数组会内部查看其长度，然后检查从零开始到 `length` 结束范围内的任何属性。
- en: 'When you create an array via `new Array(9)`, many developers believe that internally
    the array will look like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过 `new Array(9)` 创建一个数组时，许多开发者认为数组内部看起来是这样的：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'But in fact it will internally look like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际上它内部看起来是这样的：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It will have a `length` of 9 but it won’t have the actual nine values. These
    missing values are called *holes*. Methods like `map` don’t work on holes, so
    that’s why your attempt at creating an array with nine spaces didn’t work. A new
    method called `fill` fills an array with a specified value. When filling the array,
    it doesn’t care if at a given index there’s a value or a hole, so it will work
    perfectly for your use:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 它将有一个长度为 9，但它实际上不会有九个值。这些缺失的值被称为 *holes*。像 `map` 这样的方法在 holes 上不起作用，这就是为什么你尝试创建一个包含九个空格的数组没有成功的原因。一个新的方法
    `fill` 可以用指定的值填充数组。在填充数组时，它不在乎给定索引处是否有值或 hole，因此它将完美地适用于你的使用：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We’ve covered several ways to construct arrays containing the values you want.
    Now let’s look at some new methods of searching for those values once the arrays
    are constructed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了几种构建包含所需值的数组的方法。现在让我们看看在数组构建完成后，如何搜索这些值的一些新方法。
- en: '|  |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 9.3**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 9.3**'
- en: '**[Q1:](kindle_split_019_split_003.xhtml#ch09qa6q0a1)**'
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_019_split_003.xhtml#ch09qa6q0a1)**'
- en: ''
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What’s the difference between `arrayA` and `arrayB`?
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`arrayA` 和 `arrayB` 之间有什么区别？'
- en: ''
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|  |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 9.3 answer**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 9.3 答案**'
- en: '**[A1:](kindle_split_019_split_003.xhtml#ch09qa5q1)**'
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_019_split_003.xhtml#ch09qa5q1)**'
- en: ''
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The variable `arrayB` accurately creates an array with nine 1s. The variable
    `arrayA` does not because it does not actually contain any values to be mapped.
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 变量 `arrayB` 准确地创建了一个包含九个 1 的数组。变量 `arrayA` 没有这样做，因为它实际上不包含任何要映射的值。
- en: '|  |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 9.4\. Searching in arrays with Array.prototype.includes
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4\. 使用 Array.prototype.includes 在数组中进行搜索
- en: You learned in [lesson 6](kindle_split_015_split_000.xhtml#ch06) that strings
    have a new method on their prototype called `includes` for determining whether
    a string contains a value. Arrays have also been given this method, and it works
    similarly as seen in the next listing.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第6课](kindle_split_015_split_000.xhtml#ch06)中学到了，字符串在其原型上有一个新的方法叫做 `includes`，用于判断一个字符串是否包含某个值。数组也被赋予了此方法，其工作方式与下述示例类似。
- en: Listing 9.4\. Using `includes` to check whether an array contains a value
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.4\. 使用 `includes` 检查数组是否包含某个值
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* true**'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* true**'
- en: '***2* false**'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* false**'
- en: With the `String.prototype.includes` method, you’re checking if a string contains
    a substring. `Array.prototype.includes` works similarly, but you’re checking whether
    any of the values at any of the array’s indices are the value you’re checking
    against.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `String.prototype.includes` 方法，你是在检查一个字符串是否包含子字符串。`Array.prototype.includes`
    的工作方式类似，但你是在检查数组中任何索引处的值是否是你检查的值。
- en: 'Previously `indexOf` was used for determining if a value was in an array. For
    example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 之前使用 `indexOf` 来判断一个值是否在数组中。例如：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1* 1**'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 1**'
- en: 'This works fine, but often led to bugs if the developer forgot that they needed
    to compare the result to `-1`, not truthiness. If the given value were at the
    `0` index, they would get back `0`, a falsy value, and vice versa: if the value
    wasn’t found they would get back `-1`, a truthy value. But this gotcha can be
    avoided now by using `includes`, which returns a Boolean instead of an index.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以正常工作，但往往会导致错误，如果开发者忘记他们需要将结果与 `-1` 进行比较，而不是比较其真值。如果给定的值位于 `0` 索引处，他们会得到 `0`，一个假值，反之亦然：如果值未找到，他们会得到
    `-1`，一个真值。但现在可以通过使用 `includes` 来避免这个错误，它返回一个布尔值而不是索引。
- en: '|  |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Truthiness and falsiness**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**真值和假值**'
- en: 'As a refresher, the idea of *falsy* values are any values that evalulate to
    false: `false, undefined, null, NaN, 0`, and the empty string “”. Truthy values
    are values that evaluate to true. Any value not previously listed as falsy would
    be truthy, including negative numbers.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 作为复习，*假值*的概念是指任何评估为假的值：`false, undefined, null, NaN, 0` 和空字符串 “”。真值是指评估为真的值。任何之前未列为假值的值都是真值，包括负数。
- en: '|  |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 9.5\. Searching in arrays with Array.prototype.find
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5\. 使用 Array.prototype.find 在数组中进行搜索
- en: Imagine you have an array of records cached from a database. When a request
    is made for a record (by its ID), you want to check the cache first to see if
    it has the record and return it before hitting the database again. You may end
    up writing code that resembles the following listing.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个从数据库缓存的记录数组。当请求一个记录（通过其ID）时，你首先想检查缓存以查看是否有该记录，并在再次访问数据库之前返回它。你可能会编写如下类似的代码。
- en: Listing 9.5\. `filter` method returns all matches even if you only want one
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.5\. `filter` 方法返回所有匹配项，即使你只想要一个
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `findFromCache` function from [listing 9.5](kindle_split_019_split_005.xhtml#ch09ex05)
    would certainly work, but what happens when the cache has 10,000 records and it
    finds the one it’s looking for at only the 100th try? In its current implementation,
    it would still check the remaining 9,900 records before returning the one it found.
    This is because the purpose of the `filter` function is to return all the records
    that match. You’re only expecting one record to match, and once found you just
    need that record back. That’s exactly what `Array.prototype.find` does: it searches
    through an array much like `Array.prototype.filter`, but as soon as it finds a
    match, it immediately returns that match and stops searching the array.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表9.5](kindle_split_019_split_005.xhtml#ch09ex05)中的 `findFromCache` 函数当然可以工作，但当缓存有10,000条记录，并且只在第100次尝试时找到所需的记录时会发生什么？在其当前实现中，它仍然会检查剩余的9,900条记录，然后返回找到的记录。这是因为
    `filter` 函数的目的是返回所有匹配的记录。你只期望找到一条记录，一旦找到，你只需要那条记录。这正是 `Array.prototype.find` 所做的：它像
    `Array.prototype.filter` 一样遍历数组，但一旦找到匹配项，它就会立即返回该匹配项并停止搜索数组。'
- en: 'You can rewrite your `findFromCache` function to make use of the `find` function
    like so:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将你的 `findFromCache` 函数重写为利用 `find` 函数，如下所示：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Another nice thing about `find` is that because it returns the item that matched
    instead of an array of matches, you don’t have to pull it out of the array afterward;
    in fact, you can return the result of `find` directly.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`find` 的另一个优点是，因为它返回匹配项而不是匹配项的数组，所以你不需要在之后从数组中取出它；实际上，你可以直接返回 `find` 的结果。'
- en: '|  |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 9.4**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查9.4**'
- en: '**[Q1:](kindle_split_019_split_005.xhtml#ch09qa8q0a1)**'
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_019_split_005.xhtml#ch09qa8q0a1)**'
- en: ''
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the following snippet what will the variable `result` be set to?
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在以下片段中，变量 `result` 将被设置为什么值？
- en: ''
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '|  |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 9.4 answer**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 9.4 答案**'
- en: '**[A1:](kindle_split_019_split_005.xhtml#ch09qa7q1)**'
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_019_split_005.xhtml#ch09qa7q1)**'
- en: ''
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The variable `result` will be set to `3`, not [`3, 4`] because 3 is the first
    value that meets the criteria.
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 变量 `result` 将被设置为 `3`，而不是 `['3, 4']`，因为 3 是第一个符合条件的价值。
- en: '|  |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this lesson, the object was to teach you the most useful new methods being
    added to arrays.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，目标是教你即将添加到数组中的最有用的新方法。
- en: '`Array.from` creates an array containing all the values from an array-like
    object.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.from` 创建一个包含从类似数组的对象中所有值的数组。'
- en: '`Array.of` creates an array with supplied values and is safer than `new Array`.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.of` 创建一个包含提供值的数组，并且比 `new Array` 更安全。'
- en: '`Array.prototype.includes` checks whether an array contains a value at any
    of its indices.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.includes` 检查数组是否在其任何索引中包含一个值。'
- en: '`Array.prototype.find` searches an array based on a criteria function and returns
    the first value found.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.find` 根据一个标准函数搜索数组，并返回找到的第一个值。'
- en: '`Array.prototype.fill` fills an array with a specified value.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.fill` 使用指定的值填充数组。'
- en: 'Let’s see if you got this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否理解了：
- en: '**[Q9.1](kindle_split_050_split_005.xhtml#app01qa5q0a1)**'
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q9.1](kindle_split_050_split_005.xhtml#app01qa5q0a1)**'
- en: ''
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Implement the function from the priming exercise. Don’t worry about recreating
    all of jQuery. Just write your own implementation so that the following snippet
    works:'
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实现从预热练习中的函数。不用担心重新创建所有 jQuery。只需编写你自己的实现，以便以下片段能够工作：
- en: ''
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Lesson 10\. Object.assign
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 10 课：Object.assign
- en: After reading [lesson 10](kindle_split_020_split_000.xhtml#ch10), you will
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读完 [第 10 课](kindle_split_020_split_000.xhtml#ch10) 后，你将
- en: Know how to set default values with `Object.assign`
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道如何使用 `Object.assign` 设置默认值
- en: Know how to extend objects with `Object.assign`
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道如何使用 `Object.assign` 扩展对象
- en: Know how to prevent mutations when using `Object.assign`
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道如何在使用 `Object.assign` 时防止突变
- en: Understand how `Object.assign` assigns values
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 `Object.assign` 如何分配值
- en: Libraries like Underscore.js and Lodash.js have become like the utility belts
    of JavaScript. They add solutions to common tasks so that the average developer
    doesn’t need to reinvent the wheel for every project. Some of these tasks become
    so ubiquitous and well-defined that it makes sense to actually include them in
    the language. `Object.assign` is one such method. With it you can easily set default
    values or extend objects in place or as copies, all without having to write a
    lot of boilerplate code to do so.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 像 Underscore.js 和 Lodash.js 这样的库已经变成了 JavaScript 的工具带。它们为常见任务提供了解决方案，这样普通开发者就不需要为每个项目重新发明轮子。其中一些任务变得如此普遍和定义明确，以至于实际上将它们包含在语言中是有意义的。`Object.assign`
    就是这样的一个方法。有了它，你可以轻松地设置默认值或就地或作为副本扩展对象，而无需编写大量样板代码来做到这一点。
- en: '|  |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这个**'
- en: JavaScript objects can inherit properties from another object via the prototype
    chain. But any given object can only have one prototype. How would you go about
    devising a way to allow objects to inherit from multiple source objects?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 对象可以通过原型链从另一个对象继承属性。但任何给定的对象只能有一个原型。你将如何设计一种方法，允许对象从多个源对象继承？
- en: '|  |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 10.1\. Setting default values with Object.assign
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1. 使用 Object.assign 设置默认值
- en: Let’s pretend your favorite local pizza shop contacts you to build a pizza-tracking
    website. The idea is to use GPS to allow customers to see exactly where the pizza
    they ordered is as it’s being delivered. You explain that you love their pizza
    and with your help you can put them on the map! As you set out to build this,
    you decide you need a function for generating the map from the pizza shop to the
    delivery address. The function would take an `options` argument for specifying
    the width, height, and coordinates of the map. The problem is that if any of these
    values aren’t set, you need to use sane default values. One approach is to do
    something like the following listing.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设你最喜欢的当地披萨店联系你，想要建立一个披萨追踪网站。这个想法是使用 GPS 让顾客能够看到他们订购的披萨在送递过程中的确切位置。你解释说，你非常喜欢他们的披萨，在你的帮助下，你可以帮他们登上地图！当你着手构建这个网站时，你决定你需要一个从披萨店到送递地址生成地图的功能。这个函数将接受一个
    `options` 参数来指定地图的宽度、高度和坐标。问题是，如果这些值中的任何一个没有被设置，你需要使用合理的默认值。一种方法如下所示。
- en: Listing 10.1\. Basic pizza-tracking map
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.1：基本的披萨追踪地图
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This implementation has a lot going on just assigning the default values before
    it can even get to the actual problem it’s solving. Reimplement the default values
    using `Object.assign`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现只是在解决实际问题的过程中，在分配默认值之前有很多事情要做。使用 `Object.assign` 重新实现默认值：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Using `Object.assign` is much more terse than your initial approach. `Object.assign`
    works by taking any number of objects as arguments and assigning all the values
    from subsequent objects onto the first (see [figure 10.1](kindle_split_020_split_001.xhtml#ch10fig01)).
    If any objects contain the same keys, the object to the right will override the
    object to the left in the list, like so:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Object.assign` 比你最初的方法更简洁。`Object.assign` 通过接受任意数量的对象作为参数，并将后续对象的值分配到第一个对象上（见[图
    10.1](kindle_split_020_split_001.xhtml#ch10fig01)）。如果任何对象包含相同的键，列表中的右侧对象将覆盖左侧对象，如下所示：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1* { x: 12, y: 6, z: 3 }**'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* { x: 12, y: 6, z: 3 }**'
- en: Figure 10.1\. Assigning values with `Object.assign`
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.1\. 使用 `Object.assign` 分配值
- en: '![](Images/10fig01.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10fig01.jpg)'
- en: When setting defaults like this with `Object.assign`, you’re basically taking
    objects that are incomplete and filling in the missing values. Another common
    task is taking objects that are already complete and extending them into more
    customized variations.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `Object.assign` 设置默认值时，你基本上是在取不完整的对象并填充缺失的值。另一个常见任务是取已经完整的对象，并将它们扩展成更定制的变体。
- en: '|  |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 10.1**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 10.1**'
- en: '**[Q1:](kindle_split_020_split_001.xhtml#ch10qa2q0a1)**'
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_020_split_001.xhtml#ch10qa2q0a1)**'
- en: ''
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the following use of `Object.assign`, what are `a` and `b` set to afterward?
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在以下 `Object.assign` 的使用中，`a` 和 `b` 之后被设置为什么？
- en: ''
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '|  |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 10.1 answer**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 10.1 答案**'
- en: '**[A1:](kindle_split_020_split_001.xhtml#ch10qa1q1)**'
  id: totrans-199
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_020_split_001.xhtml#ch10qa1q1)**'
- en: ''
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`a` is set to `{ city: ''Dallas'', state: ''TX'' }` and `b` is unchanged.'
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`a` 被设置为 `{ city: ''Dallas'', state: ''TX'' }`，而 `b` 保持不变。'
- en: '|  |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 10.2\. Extending objects with Object.assign
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2\. 使用 Object.assign 扩展对象
- en: 'Another common use case for `Object.assign` is to add some additional properties
    to an existing object. Let’s say you’re building a spaceship game. The game has
    a base spaceship and several other specialized spaceships. The specialized spaceships
    all have the same basic features as the base spaceship, but with an extra or enhanced
    skill. You start with a function that creates a base spaceship:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.assign` 的另一个常见用途是为现有对象添加一些额外的属性。比如说你正在开发一个飞船游戏。游戏有一个基础飞船和几个其他特殊飞船。这些特殊飞船都具有与基础飞船相同的基本功能，但具有额外的或增强的技能。你从一个创建基础飞船的函数开始：'
- en: '[PRE29]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then to create a specialized spaceship, you create a copy of a base spaceship
    and extend it with the specialized features:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然后为了创建一个特殊飞船，你创建一个基础飞船的副本并扩展其特殊功能：
- en: Listing 10.2\. Adding a bomb property to the spaceship
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.2\. 向飞船添加炸弹属性
- en: '[PRE30]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: First you create a base spaceship object. Then you use `Object.assign` to add
    an additional bomb property. You could create several enhanced spaceships using
    this technique. This function does have a lot of boilerplate, though, so if you
    were going to reuse this technique, you could create a helper function for enhancing
    the base spaceship.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你创建一个基础飞船对象。然后你使用 `Object.assign` 添加一个额外的炸弹属性。你可以使用这种技术创建几个增强飞船。不过，这个函数确实有很多样板代码，所以如果你打算重用这个技术，你可以创建一个用于增强基础飞船的辅助函数。
- en: Listing 10.3\. Helper function for enhancing spaceships
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.3\. 用于增强飞船的辅助函数
- en: '[PRE31]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now you’ve created an `enhancedSpaceShip` function that takes an object of enhancements
    as an argument. These enhancements could be new features or could override existing
    features. Notice how in every example so far, you’ve created an object and then
    mutated it? Sometimes that’s desired, but often you just want a copy.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了一个 `enhancedSpaceShip` 函数，它接受一个增强对象作为参数。这些增强可以是新功能，也可以是覆盖现有功能。注意到目前为止，在每一个例子中，你都是创建了一个对象然后对其进行变异？有时这是所需要的，但通常你只是想要一个副本。
- en: '|  |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 10.2**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 10.2**'
- en: '**[Q1:](kindle_split_020_split_002.xhtml#ch10qa4q0a1)**'
  id: totrans-215
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_020_split_002.xhtml#ch10qa4q0a1)**'
- en: ''
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use `Object.assign` to create a spaceship that extends the base with a `warp`
    function.
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 `Object.assign` 创建一个扩展了基础飞船的 `warp` 函数的飞船。
- en: '|  |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 10.2 answer**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 10.2 答案**'
- en: '**[A1:](kindle_split_020_split_002.xhtml#ch10qa3q1)**'
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_020_split_002.xhtml#ch10qa3q1)**'
- en: ''
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '|  |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 10.3\. Preventing mutations when using Object.assign
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3\. 防止使用 Object.assign 时发生突变
- en: Oftentimes when making modifications to objects, programmers like the operation
    to not mutate the existing object but instead return a copy with the desired changes.
    One reason for this is to prevent anything else that currently holds a reference
    to the object from getting its reference changed out from under it. For example,
    what if in your spaceship example you didn’t have a function for creating a new
    copy of the base spaceship object? What if you just had a single base spaceship
    object? If that were the case, every time you called `Object.assign` to enhance
    it, you would be enhancing the base, which you don’t want. Instead you would want
    to make a copy and leave the base unchanged. You may think that `const` can help
    you here, but it can’t. Remember, `const` only prevents overriding a variable
    with a new object; it doesn’t prevent modifying/mutating the existing object.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在对对象进行修改时，程序员通常喜欢操作不修改现有对象，而是返回一个具有所需更改的副本。其中一个原因是为了防止任何当前持有对象引用的其他东西从其下面改变其引用。例如，如果在你太空船的例子中，你没有创建新副本的基础太空船对象的函数？如果你只有一个基础太空船对象呢？如果是这样的话，每次你调用
    `Object.assign` 来增强它时，你就是在增强基础对象，而这不是你想要的。相反，你想要创建一个副本并保持基础对象不变。你可能认为 `const`
    可以帮助你在这里，但它不能。记住，`const` 只能防止用新对象覆盖变量；它不能防止修改/修改现有对象。
- en: 'Because `Object.assign` mutates the first object in the parameter list, and
    leaves the rest of the objects unchanged, a common practice is to make the first
    object an empty object literal:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `Object.assign` 修改了参数列表中的第一个对象，而其余对象保持不变，所以一个常见的做法是将第一个对象设为一个空对象字面量：
- en: '[PRE33]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1* {foo: 1, bar: 2}**'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* {foo: 1, bar: 2}**'
- en: 'When doing this, it’s inconvenient to first create the empty object, then pass
    it to `Object.assign`. Conveniently, `Object.assign` also returns the mutated
    object, so you can shorten it like so:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行此操作时，首先创建一个空对象，然后将其传递给 `Object.assign` 是不方便的。方便的是，`Object.assign` 也会返回被修改的对象，因此您可以将其缩短如下：
- en: '[PRE34]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '***1* {foo: 1, bar: 2}**'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* {foo: 1, bar: 2}**'
- en: Rewrite your spaceship example to use a single base object and your enhance
    function to make an enhanced copy, as shown in the next listing.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的太空船示例重写，使用单个基础对象和你的增强函数来创建一个增强的副本，如下所示。
- en: Listing 10.4\. Copying the spaceship
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.4\. 复制太空船
- en: '[PRE35]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '***1* By passing {} as the first argument, Object.assign makes a copy.**'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 通过传递 {} 作为第一个参数，`Object.assign` 创建了一个副本。**'
- en: Notice that, because you abstracted away your enhancement technique into its
    own function, when you modified how it works, you didn’t have to make any changes
    to the `createBomberSpaceShip` or `createStealthSpaceShip` functions.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，因为你将增强技术抽象到了自己的函数中，所以当你修改其工作方式时，你不需要对 `createBomberSpaceShip` 或 `createStealthSpaceShip`
    函数进行任何修改。
- en: At this point you may be thinking that `Object.assign` basically merges objects
    from right to left. Well, not exactly; it only assigns values from the left to
    the right. This minor distinction is what we’ll discuss next.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能认为 `Object.assign` 实际上是从右到左合并对象。嗯，不是的；它只从左到右分配值。这个小的区别是我们接下来要讨论的。
- en: '|  |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 10.3**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 10.3**'
- en: '**[Q1:](kindle_split_020_split_003.xhtml#ch10qa6q0a1)**'
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_020_split_003.xhtml#ch10qa6q0a1)**'
- en: ''
  id: totrans-242
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a function called `createStealthBomber` that creates a spaceship that’s
    a combination of the bomber and the stealth spaceship using `Object.assign`.
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写一个名为 `createStealthBomber` 的函数，该函数使用 `Object.assign` 创建一个结合了轰炸机和隐形太空船的太空船。
- en: '|  |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 10.3 answer**'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 10.3 答案**'
- en: '**[A1:](kindle_split_020_split_003.xhtml#ch10qa5q1)**'
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_020_split_003.xhtml#ch10qa5q1)**'
- en: ''
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-249
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '|  |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 10.4\. How Object.assign assigns values
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4\. `Object.assign` 如何分配值
- en: 'There’s a subtle difference between definition and assignment. Assigning a
    value to an existing property doesn’t define how a property behaves, the way `Object.defineProperty`
    does. Assignment only falls back to defining a property if an assignment is made
    to a property that doesn’t exist. This is important because `Object.assign` doesn’t
    define (or redefine) properties; it assigns to them. Most of the time this distinction
    makes no difference, but sometimes it does. Let’s explore the difference:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 定义和赋值之间有一个细微的区别。将值赋给现有属性并不定义属性的行为方式，就像 `Object.defineProperty` 一样。赋值只有在将赋值操作应用于不存在的属性时才会回退到定义属性。这一点很重要，因为
    `Object.assign` 不定义（或重新定义）属性；它只是对它们进行赋值。大多数时候，这种区别没有影响，但有时它确实有影响。让我们来探讨一下这种区别：
- en: '[PRE37]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The preceding function works as expected. But what if the `name` property wasn’t
    a mere string but a getter and setter that ensured that the name contain no spaces?
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数按预期工作。但如果 `name` 属性不是一个简单的字符串，而是一个确保名称不包含空格的getter和setter呢？
- en: '[PRE38]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '***1* Error: No spaces allowed!**'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 错误：不允许空格！**'
- en: 'As you can see, if you assign a string to `name`, it gets processed by the
    setter function and if the string contains a space, it throws an error. The same
    thing happens if you use `Object.assign` because it merely makes the assignments;
    it doesn’t redefine the property:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，如果你将一个字符串赋给 `name`，它会被setter函数处理，如果字符串包含空格，它会抛出一个错误。使用 `Object.assign`
    也会发生同样的事情，因为它只是进行赋值；它不会重新定义属性：
- en: '[PRE39]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '***1* Error: No spaces allowed!**'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 错误：不允许空格！**'
- en: 'Additionally, `Object.assign` only assigns an object’s own enumerable properties,
    meaning it won’t assign properties that are on an object’s prototype chain or
    properties set to non-enumerable. This is usually a good thing. Here’s an example
    illustrating what I mean:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Object.assign` 只分配对象的自身可枚举属性，这意味着它不会分配在对象原型链上的属性或设置为不可枚举的属性。这通常是好事。以下是一个说明我意思的例子：
- en: '[PRE40]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '***1* 1**'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 1**'
- en: '***2* TypeError: this.reduce is not a function.**'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* TypeError: this.reduce is not a function.**'
- en: 'Why did you get an error? Because the `reduce` method is on the `numbers` array’s
    prototype chain, not directly on the `numbers` array itself. The only properties
    directly on the `numbers` array are 0, 1, and 2 for the three values it contains.
    Because of this, those three values got assigned to the new object, but all the
    methods on the array prototype such as `pop`, `push`, and `reduce` did not. You
    could make this work, however, by assigning to an empty array which already has
    all the methods it needs:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你会得到一个错误？因为 `reduce` 方法在 `numbers` 数组的原型链上，而不是直接在 `numbers` 数组本身上。`numbers`
    数组上直接有的属性只有它包含的三个值对应的0、1和2。正因为如此，这三个值被分配到了新对象上，但数组原型上的所有方法，如 `pop`、`push` 和 `reduce`
    都没有。然而，你可以通过将值赋给一个已经具有所有所需方法的空数组来使这个工作：
- en: '[PRE41]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '***1* Assigning to an empty array rather than an empty object**'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将值赋给空数组而不是空对象**'
- en: Most of the time these issues won’t be a concern, because more often than not
    you’ll be using `Object.assign` on what many developers like to call a *POJO*
    (plain old JavaScript object), an object without things like getters, setters,
    or a prototype. This is the type of object you create with the object literal
    `{ ... }` syntax.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，这些问题不会成为问题，因为更常见的是，你会在许多开发者喜欢称之为 *POJO*（普通的旧JavaScript对象）的对象上使用 `Object.assign`，这是一个没有像getter、setter或原型这样的东西的对象。这是使用对象字面量
    `{ ... }` 语法创建的对象类型。
- en: '|  |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 10.4**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 10.4**'
- en: '**[Q1:](kindle_split_020_split_004.xhtml#ch10qa8q0a1)**'
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_020_split_004.xhtml#ch10qa8q0a1)**'
- en: ''
  id: totrans-271
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What will be logged to the console?
  id: totrans-272
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将会在控制台输出什么？
- en: ''
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '|  |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 10.4 answer**'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 10.4 答案**'
- en: '**[A1:](kindle_split_020_split_004.xhtml#ch10qa7q1)**'
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_020_split_004.xhtml#ch10qa7q1)**'
- en: ''
  id: totrans-279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '4'
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '4'
- en: '|  |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this lesson you learned the basics of how to use `Object.assign` and why
    you would do so.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节课中，你学习了如何使用 `Object.assign` 以及为什么你会这样做。
- en: '`Object.assign` assigns values properties from several objects onto a base
    object.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.assign` 将多个对象的值属性分配到基础对象上。'
- en: '`Object.assign` can be used to fill in default values.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.assign` 可以用来填充默认值。'
- en: '`Object.assign` can be used to extend objects with new properties.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.assign` 可以用来向对象添加新属性。'
- en: '`Object.assign` returns the mutated object so that using `{}` as the first
    argument will create a copy.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.assign` 返回被修改的对象，因此使用 `{}` 作为第一个参数将创建一个副本。'
- en: '`Object.assign` only assigns to properties; it doesn’t redefine them.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.assign` 只分配属性；它不会重新定义它们。'
- en: 'Let’s see if you got this:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否掌握了：
- en: '**[Q10.1](kindle_split_050_split_006.xhtml#app01qa6q0a1)**'
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q10.1](kindle_split_050_split_006.xhtml#app01qa6q0a1)**'
- en: ''
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this lesson you created a base spaceship and made several other spaceships
    inherit from it. You even made a stealth bomber that inherited from multiple other
    spaceships. Come up with another series of objects that inherit from one another,
    such as passenger vehicles, the animal kingdom, video game characters, or anything
    else you can think of.
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在本节课中，你创建了一个基础太空船并使几个其他太空船从它继承而来。你甚至制作了一个从多个其他太空船继承而来的隐形轰炸机。想出另一系列相互继承的对象，例如客用车辆、动物王国、视频游戏角色，或者任何你能想到的东西。
- en: Lesson 11\. Destructuring
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第11课。解构
- en: After reading [lesson 11](kindle_split_021_split_000.xhtml#ch11), you will
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完[第11课](kindle_split_021_split_000.xhtml#ch11)后，你将
- en: Know how to destructure objects
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何解构对象
- en: Know how to destructure arrays
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何解构数组
- en: Know how to combine array and object destructuring
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何组合数组和对象解构
- en: Understand what types can be destructured
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解可以解构的类型
- en: 'JavaScript, like other programming languages, has data structures like objects
    and arrays that allow you to structure data into logical groups and treat them
    as a single piece of data. JavaScript has always supported the concept of *structuring*,
    which is a concise syntax for taking several pieces of data and arranging them
    into a data structure. But that’s only half of the story: JavaScript has always
    been missing the reverse, a syntax for taking an existing data structure and *destructuring*
    it back into the parts that make it up.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript，像其他编程语言一样，有对象和数组这样的数据结构，允许你将数据结构化成逻辑组，并将它们视为单一的数据块。JavaScript 一直支持结构化的概念，这是一种简洁的语法，用于将多个数据项组合成一个数据结构。但故事只讲了一半：JavaScript
    一直缺少相反的语法，即如何将现有的数据结构解构回构成它的各个部分。
- en: '|  |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: In the following code, there are two sections. The first section builds a data
    structure and the second section breaks it down. You can probably already think
    of a way to clean up the creation of the data structure using an object literal,
    but how would you clean up the teardown?
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，有两个部分。第一部分构建了一个数据结构，第二部分将其拆解。你可能已经想到了使用对象字面量清理数据结构创建的方法，但你是如何清理拆解过程的呢？
- en: '[PRE43]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '|  |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 11.1\. Destructuring objects
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1\. 解构对象
- en: 'Imagine how tedious it would be to write an application without ever using
    an object literal. You may think you’d quit writing JavaScript before doing something
    like that. But you’ve been doing the same tedious process when breaking down objects,
    and once you see how nice it is to destructure objects the same way you structure
    them, you’ll never want to go back. Let’s start by taking a look at a simple example:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果不使用对象字面量编写应用程序会有多繁琐。你可能认为你会在做这样的事情之前放弃编写 JavaScript。但你在分解对象时一直在做同样繁琐的过程，一旦你看到以与结构相同的方式解构对象是多么方便，你就永远不会想回头。让我们从一个简单的例子开始：
- en: '[PRE44]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '***1* Creating a data structure**'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建数据结构**'
- en: '***2* Destructuring a data structure**'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 解构数据结构**'
- en: '***3* Christina**'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* Christina**'
- en: In this example you created an object in a structured manner using an object
    literal. By doing so, you were able to specify the properties you were setting
    on the structure in a concise way. Later you destructured that data structure
    with a destructuring statement. You specified that you wanted to extract the `name`
    property into a variable.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你使用对象字面量以结构化的方式创建了一个对象。通过这样做，你能够以简洁的方式指定在结构上设置的属性。后来，你使用解构语句解构了该数据结构。你指定了想要提取的
    `name` 属性到变量中。
- en: 'In this simple example, the benefits aren’t that great, but as usual, the more
    complex the use case, the more obvious it becomes how useful destructuring is:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，好处并不那么显著，但就像往常一样，用例越复杂，解构的实用性就越明显：
- en: '[PRE45]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '***1* “Christina” 25**'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* “Christina” 25**'
- en: 'When you destructure an object like this, you’re specifying the names of the
    fields in the object that you’re extracting. Variables by the same names are then
    assigned the values. The ES5 equivalent would look like this:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当你这样解构一个对象时，你指定了你要从中提取的字段名称。具有相同名称的变量将被分配相应的值。ES5 的等效代码如下：
- en: '[PRE46]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: But what if you wanted to use different names?
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你想要使用不同的名字呢？
- en: '[PRE47]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'When destructuring, you can specify different names to use like so:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在解构时，你可以指定不同的名称，如下所示：
- en: '[PRE48]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This creates the variables `firstName` and `yearsOld`, and assigns them the
    values from `person.name` and `person.age` respectively. This is nice because
    it’s exactly the reverse of how you would build the data structure:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建变量 `firstName` 和 `yearsOld`，并将它们分别赋值为 `person.name` 和 `person.age`。这很好，因为它正好是你构建数据结构方式的相反：
- en: '[PRE49]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You can do nested destructuring to drill down into the data structure to extract
    data at different levels of the data structure:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以进行嵌套解构，深入数据结构以提取不同层次的数据：
- en: '[PRE50]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'With the syntax `key: {otherKeys}` you are specifying that you are drilling
    down into the specified `key` to extract the `otherKeys` from within it. Here
    you specified that you wanted to extract the `lat` and `lng` properties from the
    `location` property. Also notice how there was no creation of a `location` variable:
    you merely drilled into it.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '使用语法 `key: {otherKeys}`，你指定你正在深入到指定的 `key` 中以从中提取 `otherKeys`。在这里，你指定了你想从 `location`
    属性中提取 `lat` 和 `lng` 属性。注意，这里没有创建一个 `location` 变量：你只是深入到了它。'
- en: '|  |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 11.1**'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 11.1**'
- en: '**[Q1:](kindle_split_021_split_001.xhtml#ch11qa2q0a1)**'
  id: totrans-328
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_021_split_001.xhtml#ch11qa2q0a1)**'
- en: ''
  id: totrans-329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How would you rewrite the previous destructuring statement to assign the `lng`
    property into a variable called `lon`?
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你将如何重写之前的解构语句，将 `lng` 属性分配给一个名为 `lon` 的变量？
- en: '|  |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 11.1 answer**'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 11.1 答案**'
- en: '**[A1:](kindle_split_021_split_001.xhtml#ch11qa1q1)**'
  id: totrans-334
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_021_split_001.xhtml#ch11qa1q1)**'
- en: ''
  id: totrans-335
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-336
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '|  |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 11.2\. Destructuring arrays
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2\. 数组的解构
- en: In the previous section you learned that the syntax for object destructuring
    is the inverse of the syntax for object structuring. Similarly, the syntax for
    array destructuring is the inverse of the syntax for structuring arrays. See [figure
    11.1](kindle_split_021_split_002.xhtml#ch11fig01).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你学习了对象解构的语法是对象结构的语法的逆。同样，数组解构的语法是数组结构的语法的逆。参见 [图 11.1](kindle_split_021_split_002.xhtml#ch11fig01)。
- en: Figure 11.1\. Structuring and destructuring syntax
  id: totrans-340
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.1\. 结构化和解构语法
- en: '![](Images/11fig01_alt.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig01_alt.jpg)'
- en: '[PRE52]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '***1* 51.0**'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 51.0**'
- en: '***2* -0.1**'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* -0.1**'
- en: Because objects track their values by keys or names, they must be extracted
    by those same keys/names. And since arrays track their values by what index they’re
    positioned in, it makes sense that when destructuring an array the position of
    the variable is how you specify what you’re destructuring.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 因为对象通过键或名称跟踪它们的值，所以它们必须通过相同的键/名称提取。由于数组通过它们的位置索引跟踪它们的值，所以在解构数组时，变量的位置就是指定你正在解构的方式是有意义的。
- en: 'Just like with destructuring objects, you can do nested destructuring with
    arrays as well:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 就像解构对象一样，你也可以对数组进行嵌套解构：
- en: '[PRE53]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'One idiom I’ve grown fond of is using array destructuring to grab the first
    value from an array:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常喜欢的一个惯用法是使用数组解构从数组中获取第一个值：
- en: '[PRE54]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In the lesson on `let`, you reversed the values between two variables, and
    in doing so, you needed to create a third temporary variable to prevent the value
    from being lost before reversal:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在关于 `let` 的课程中，你反转了两个变量之间的值，在这个过程中，你需要创建一个第三个临时变量来防止反转前值丢失：
- en: '[PRE55]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You can achieve this same thing without the need for a temporary variable by
    using destructuring:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用解构来达到同样的效果，而不需要临时变量：
- en: '[PRE56]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '|  |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 11.2**'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 11.2**'
- en: '**[Q1:](kindle_split_021_split_002.xhtml#ch11qa4q0a1)**'
  id: totrans-356
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_021_split_002.xhtml#ch11qa4q0a1)**'
- en: ''
  id: totrans-357
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What if the array in the previous example stored the `lat/lng` values in reverse
    order? How could you extract them to the correct variables?
  id: totrans-358
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果上一个例子中的数组以相反的顺序存储 `lat/lng` 值，你该如何提取它们到正确的变量中？
- en: '|  |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 11.2 answer**'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 11.2 答案**'
- en: '**[A1:](kindle_split_021_split_002.xhtml#ch11qa3q1)**'
  id: totrans-362
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_021_split_002.xhtml#ch11qa3q1)**'
- en: ''
  id: totrans-363
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Since array destructuring is tied to indices, not names, you can simply reverse
    the names order in the destructuring statement:'
  id: totrans-364
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于数组解构与索引相关，而不是名称，你可以在解构语句中简单地颠倒名称的顺序：
- en: ''
  id: totrans-365
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-366
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '|  |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 11.3\. Combining array and object destructuring
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3\. 组合数组和对象解构
- en: 'You can combine the destructuring statements for objects and arrays just as
    you can combine the use of object and array literals when creating data structures:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像创建数据结构时一样组合对象和数组的解构语句：
- en: '[PRE58]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '***1* 51.0 -0.1**'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 51.0 -0.1**'
- en: This is also a form of nested destructuring, because you’re using object destructuring
    to drill down into the array destructuring.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一种嵌套解构的形式，因为你正在使用对象解构来深入到数组解构中。
- en: 'Also note that in this example, you used the name `coords` in your destructuring
    assignment but you didn’t create a variable named `coords`. You only created the
    `latitude` and `longitude` variables. The use of the name `coords` was only to
    drill down and specify the array you were destructuring. You can think of `coords`
    as a branch and `latitude` and `longitude` as leaves in the destructuring assignment.
    The branches won’t create variables; only the leaves will. Consider the following
    code:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，在这个例子中，你在解构赋值中使用了`coords`这个名字，但你并没有创建一个名为`coords`的变量。你只创建了`latitude`和`longitude`变量。使用`coords`这个名字只是为了深入并指定你正在解构的数组。你可以把`coords`看作是一个分支，而`latitude`和`longitude`则是解构赋值中的叶子。分支不会创建变量；只有叶子会。考虑以下代码：
- en: '[PRE59]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '***1* Whiskey Glass**'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 威士忌杯**'
- en: '***2* 18.99**'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 18.99**'
- en: '***3* Enjoy your whiskey in this glass.**'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在这个杯子里享受你的威士忌。**'
- en: '***4* /images/main.jpg**'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* /images/main.jpg**'
- en: '***5* /images/1.jpg**'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* /images/1.jpg**'
- en: '***6* /images/2.jpg**'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* /images/2.jpg**'
- en: '***7* undefined**'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 未定义**'
- en: In the preceding destructuring assignment, if you mark which values are used
    as branches and which are leaves, you’ll know which variables got created. See
    [figure 11.2](kindle_split_021_split_003.xhtml#ch11fig02).
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的解构赋值中，如果你标记了哪些值作为分支和哪些作为叶子，你就会知道哪些变量被创建了。参见[图11.2](kindle_split_021_split_003.xhtml#ch11fig02)。
- en: Figure 11.2\. Destructuring a product array
  id: totrans-383
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.2\. 解构产品数组
- en: '![](Images/11fig02.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig02.jpg)'
- en: 11.4\. What types can be destructured
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4\. 可以解构的类型
- en: 'You can use object destucturing on any object, even arrays. But since numbers
    aren’t valid variable names, you would need to rename them in the destructuring
    assignmemt:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何对象上使用对象解构，甚至包括数组。但由于数字不是有效的变量名，你需要在解构赋值中给它们重命名：
- en: '[PRE60]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '***1* foo**'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* foo**'
- en: '***2* bar**'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* bar**'
- en: '***3* 2**'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 2**'
- en: 'Using array destructuring is more restrictive, but can be used on much more
    than just arrays. Any object that implements the iterable protocol (which we’ll
    cover in a later unit) can be deststructured using array destructuring. One example
    of an object that’s iterable is a `Set`, which we’ll cover later in this book.
    Another example is a `String`:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组解构更为严格，但它可以用于比数组多得多的对象。任何实现了可迭代协议的对象（我们将在后面的单元中介绍）都可以使用数组解构。一个可迭代对象的例子是`Set`，我们将在本书的后面部分介绍。另一个例子是`String`：
- en: '[PRE61]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '***1* a**'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* a**'
- en: '***2* b**'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* b**'
- en: '***3* c**'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* c**'
- en: Later in this book when you make our own iterables, you’ll be able to use array
    destructuring on them as well!
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后面部分，当你创建自己的可迭代对象时，你也将能够对它们使用数组解构！
- en: Summary
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this lesson you learned the mechanics of destructuring and why it’s such
    a useful technique.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了解构的机制以及为什么它是一项如此有用的技术。
- en: Destructuring is a syntactic sugar for retrieving values from data structures.
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解构是获取数据结构值的语法糖。
- en: Destructuring is the inverse complement to how object/array literals provide
    a syntax for structuring.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解构是对象/数组字面量提供结构化语法的逆补。
- en: With object destructuring, you specify values by property name.
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对象解构时，你通过属性名指定值。
- en: With array destructuring, you specify values by their index.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数组解构时，你通过它们的索引指定值。
- en: Destructuring can be combined and nested just like data structures.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解构可以像数据结构一样组合和嵌套。
- en: When nesting destructuring, only the leaves (not branches) are retrieved.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当嵌套解构时，只有叶子（而不是分支）会被检索。
- en: 'Let’s see if you got this:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否理解了：
- en: '**[Q11.1](kindle_split_050_split_007.xhtml#app01qa7q0a1)**'
  id: totrans-406
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q11.1](kindle_split_050_split_007.xhtml#app01qa7q0a1)**'
- en: ''
  id: totrans-407
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'You should now be able to convert the code from the priming exercise into a
    single destructuring statement:'
  id: totrans-408
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在，你应该能够将预热练习中的代码转换成一个单一的解构语句：
- en: ''
  id: totrans-409
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-410
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE62]'
- en: ''
  id: totrans-411
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Additionally, try to convert this code into a single destructuring statement:'
  id: totrans-412
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此外，尝试将此代码转换成一个单一的解构语句：
- en: ''
  id: totrans-413
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-414
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Lesson 12\. New object literal syntax
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第12课\. 新的对象字面量语法
- en: After reading [lesson 12](kindle_split_022_split_000.xhtml#ch12), you will
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读[第12课](kindle_split_022_split_000.xhtml#ch12)之后，你将
- en: Know how to use shorthand property names
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何使用简写属性名
- en: Know how to use shorthand method names
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何使用简写方法名
- en: Know how to use computed property names
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何使用计算属性名
- en: I don’t think there’s anything as ubiquitous in JavaScript as the object literal.
    They’re everywhere. With a tool that’s used so frequently, any conveniences can
    have a huge net positive on productivity. Three syntactic additions to object
    literals introduced in ES2015 make them much more of a pleasure to read and write.
    You don’t gain new functionality, but having code that’s easy to read and write,
    especially when it comes to maintenance, is just as important a feature.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为在JavaScript中没有什么比对象字面量更普遍的了。它们无处不在。由于这个工具被频繁使用，任何便利性都可以对生产力产生巨大的净正面影响。ES2015中引入的对象字面量的三个语法添加使它们读起来和写起来更加愉快。您不会获得新的功能，但拥有易于阅读和编写的代码，尤其是在维护方面，同样是一个重要的特性。
- en: '|  |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: Look at the following object literal. What parts seem redundant? If you were
    writing a JavaScript-aware string compression engine, what parts do you think
    you could safely remove while still being able to reconstruct the original object?
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下对象字面量。哪些部分看起来是多余的？如果您正在编写一个JavaScript感知的字符串压缩引擎，您认为您可以在仍然能够重建原始对象的情况下安全地删除哪些部分？
- en: '[PRE64]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '|  |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 12.1\. Shorthand property names
  id: totrans-426
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1. 简写属性名
- en: 'Before ES6 there were countless times when I would inevitably create an object
    literal that had a key or property whose name was the same as the variable I was
    assigning to it:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6之前，我无数次不可避免地创建了一个对象字面量，它有一个键或属性，其名称与我正在分配给它的变量相同：
- en: '[PRE65]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '***1* Assigning the property text to a variable also named text**'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将属性text分配给同名的变量text**'
- en: I always thought this looked awkward, and thanks to ES6 shorthand property names,
    that’s a thing of the past. The previous object literal can now be concisely written
    as
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我一直认为这看起来很笨拙，多亏了ES6简写属性名，这已经成为过去式。之前的对象字面量现在可以简洁地写成
- en: '[PRE66]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '***1* Assigning the property text to a variable also named text**'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将属性text分配给同名的变量text**'
- en: 'This also works fantastically when coupled with destructuring:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 当与解构结合使用时，这也非常出色：
- en: '[PRE67]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '***1* Extracting count from the object returned from getState**'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从`getState`返回的对象中提取count**'
- en: '***2* Updating the values of count**'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 更新count的值**'
- en: '***3* Passing an object literal with a property named count set to the new
    count**'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将一个名为count的属性设置为新的count的对象字面量传递**'
- en: 'With shorthand property names, if the name of the property is the same as the
    name of the variable you’re assigning to it, you can simply list the name once.
    That means that an object literal that would have been written as `{ count: count
    }` can now be written as `{ count }` and will evaluate to the same thing (see
    [figure 12.1](kindle_split_022_split_001.xhtml#ch12fig01)).'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '使用简写属性名，如果属性的名称与您要分配给它的变量的名称相同，您只需列出一次名称。这意味着原本需要写成`{ count: count }`的对象字面量现在可以写成`{
    count }`，并且会评估为相同的结果（参见[图12.1](kindle_split_022_split_001.xhtml#ch12fig01)）。'
- en: Figure 12.1\. Using shorthand property names
  id: totrans-439
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.1. 使用简写属性名
- en: '![](Images/12fig01.jpg)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/12fig01.jpg)'
- en: Notice that you now have symmetry between where you’re grabbing your count with
    `{ count }` and then passing it back with `{ count }`. I personally find this
    symmetry extremely elegant.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在您在用`{ count }`获取count，然后用`{ count }`传递它之间有了对称性。我个人认为这种对称性非常优雅。
- en: Shorthand properties can be mixed and matched with any other property or method
    in an object literal. In the next listing the `shorthand` and `longhand` object
    literals are equivalent.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 简写属性可以与对象字面量中的任何其他属性或方法混合使用。在下一个列表中，`简写`和`长写`对象字面量是等效的。
- en: Listing 12.1\. Mixing `shorthand` and `longhand` object literals
  id: totrans-443
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.1. 混合`简写`和`长写`对象字面量
- en: '[PRE68]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Concise property names take the redundancy out of object literals with matching
    key/value names. You know what else is redundant in object literals? Methods.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 简洁的属性名消除了具有匹配键/值名称的对象字面量的冗余。您知道对象字面量中还有什么冗余吗？方法。
- en: '|  |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 12.1**'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查12.1**'
- en: '**[Q1:](kindle_split_022_split_001.xhtml#ch12qa2q0a1)**'
  id: totrans-448
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_022_split_001.xhtml#ch12qa2q0a1)**'
- en: ''
  id: totrans-449
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Rewrite the following object literal to make use of shorthand property names.
  id: totrans-450
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将以下对象字面量重写为使用简写属性名。
- en: ''
  id: totrans-451
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-452
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '|  |'
  id: totrans-453
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 12.1 answer**'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 12.1 答案**'
- en: '**[A1:](kindle_split_022_split_001.xhtml#ch12qa1q1)**'
  id: totrans-456
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_022_split_001.xhtml#ch12qa1q1)**'
- en: ''
  id: totrans-457
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-458
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '|  |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 12.2\. Shorthand method names
  id: totrans-460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2. 简写方法名
- en: 'Let’s assume your team is building a game that teaches math to elementary students.
    The game must track several pieces of state (such as the name of the player, current
    level, number of correct/incorrect answers, which questions have been asked, and
    so forth) across the game session. You may start with a simple state manager like
    the following:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的团队正在开发一个教小学生数学的游戏。游戏必须跟踪游戏会话中的多个状态（例如玩家的姓名、当前级别、正确/错误答案的数量、已提出的问题等）。你可能从一个简单的状态管理器开始，如下所示：
- en: '[PRE71]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The use of the word `function` is redundant here. Since functions always have
    a parameter list `()`, and since parentheses aren’t valid in variable or property
    names, their presence should be enough to signify that it’s a method. Shorthand
    method names allow for doing just that.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用单词 `function` 是多余的。因为函数始终有一个参数列表 `()`，并且由于括号在变量或属性名称中无效，它们的存在应该足以表示它是一个方法。简写方法名称允许你做到这一点。
- en: 'This is just like the way shorthand property names remove the need to type
    `: redundant name`, and `{ count: count }` becomes `{ count }`. Shorthand method
    names remove the need to type `: redundant function`, and `{ update: function(){}
    }` is shortened to `{ update(){} }`. See [figure 12.2](kindle_split_022_split_002.xhtml#ch12fig02).'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '这就像简写属性名称消除了输入 `: redundant name` 的需要，并且 `{ count: count }` 变成了 `{ count }`。简写方法名称消除了输入
    `: redundant function` 的需要，并且 `{ update: function(){} }` 被缩短为 `{ update(){} }`。参见
    [图12.2](kindle_split_022_split_002.xhtml#ch12fig02)。'
- en: Figure 12.2\. Shorthand method names remove redundant syntax.
  id: totrans-465
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.2\. 简写方法名称消除了冗余语法。
- en: '![](Images/12fig02.jpg)'
  id: totrans-466
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/12fig02.jpg)'
- en: 'With that in mind, you can update your `createStateManager` to use shorthand
    method names:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，你可以更新你的 `createStateManager` 以使用简写方法名称：
- en: '[PRE72]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'It’s important to understand that shorthand methods evaluate to *anonymous*
    functions, not *named* functions. This means that you can’t refer to the function
    by name within itself:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解简写方法评估为*匿名*函数，而不是*命名*函数。这意味着你无法在函数内部通过名称引用该函数：
- en: '[PRE73]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '***1* ReferenceError: at is not defined**'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* ReferenceError: at is not defined**'
- en: In the next listing, the `withShorthandFunction` object literal evaluates (or
    is *desugared*) similar to the `withAnonymousFunction` object, and not like the
    `withNamedFunction` object.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个列表中，`withShorthandFunction` 对象字面量评估（或被*简化*）类似于 `withAnonymousFunction` 对象，而不是
    `withNamedFunction` 对象。
- en: Listing 12.2\. Shorthand methods are anonymous functions
  id: totrans-473
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.2\. 简写方法是匿名函数
- en: '[PRE74]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This really only matters when the function is self-referencing, meaning the
    function is making a reference to itself, as with *recursion*. Because of this,
    defining the `at` method using shorthand syntax wouldn’t work. You may be tempted
    to solve this problem using `this.at` as shown in [listing 12.3](kindle_split_022_split_002.xhtml#ch12ex03),
    which would work as long as the function is always invoked in a context in which
    `this.at` will resolve back to the function. If the function becomes detached
    or attached under a different name, it will no longer work.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上只在函数自我引用时很重要，这意味着函数正在对自己进行引用，就像*递归*一样。因此，使用简写语法定义 `at` 方法将不起作用。你可能想使用 `this.at`
    来解决这个问题，如[列表12.3](kindle_split_022_split_002.xhtml#ch12ex03)所示，只要函数始终在 `this.at`
    将解析回函数的上下文中调用，它就会起作用。如果函数被分离或以不同的名称附加，它将不再起作用。
- en: Listing 12.3\. Recursive function with `this.at`
  id: totrans-476
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.3\. 使用 `this.at` 的递归函数
- en: '[PRE75]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '***1* 13**'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 13**'
- en: '***2* Throws ReferenceError**'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 抛出 ReferenceError**'
- en: '***3* 13**'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 13**'
- en: '***4* Throws ReferenceError**'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 抛出 ReferenceError**'
- en: At the end of the day, if you need to self-reference, don’t use shorthand method
    names.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你需要自我引用，不要使用简写方法名称。
- en: Concise properties and methods make object literals less redundant. In the next
    section you’ll remove even more cruft with computed property names.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 简洁的属性和方法使对象字面量更加简洁。在下一节中，你将使用计算属性名称移除更多的冗余。
- en: '|  |'
  id: totrans-484
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 12.2**'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查12.2**'
- en: '**[Q1:](kindle_split_022_split_002.xhtml#ch12qa4q0a1)**'
  id: totrans-486
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_022_split_002.xhtml#ch12qa4q0a1)**'
- en: ''
  id: totrans-487
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Rewrite the following object literal to make use of shorthand method names:'
  id: totrans-488
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将以下对象字面量重写为使用简写方法名称：
- en: ''
  id: totrans-489
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-490
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '|  |'
  id: totrans-491
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-492
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 12.2 answer**'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 12.2 答案**'
- en: '**[A1:](kindle_split_022_split_002.xhtml#ch12qa3q1)**'
  id: totrans-494
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_022_split_002.xhtml#ch12qa3q1)**'
- en: ''
  id: totrans-495
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-496
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '|  |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 12.3\. Computed property names
  id: totrans-498
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3\. 计算属性名称
- en: 'Suppose you’re using your state manager and need to make it work with another
    library that’s going to give you values you need to store in state. The problem
    is that this library doesn’t give you the key/value pairs in the form of an object
    that you can pass to the state manager’s `update` function. Instead, this other
    library gives you the key/value pair in the form of an array where the first index
    is the key and the second index is the value. To make these two libraries play
    nicely together, you write an intermediate function called `setValue` that takes
    a name and a value as parameters and internally turns them into an object that
    it passes to `stateManager.update`:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在使用你的状态管理器，并需要使其与另一个库一起工作，该库将提供你需要存储在状态中的值。问题是这个库没有以你可以传递给状态管理器`update`函数的对象形式提供键/值对。相反，这个其他库以数组的形式提供键/值对，其中第一个索引是键，第二个索引是值。为了使这两个库能够很好地一起工作，你编写了一个中间函数`setValue`，该函数接受一个名称和一个值作为参数，并在内部将它们转换成一个对象，然后将其传递给`stateManager.update`：
- en: '[PRE78]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Notice how in the `setValue` function you must first create an empty object
    before defining the property. This is because the name of the property is dynamic:
    if we did something like `{ name: value }` then the property name would actually
    be the value `"name"`, instead of the value the `name` variable contains. This
    would be similar to `changes.name = value`, which again would set the property
    name to `name`. Instead you use `changes[name]` to use the actual value contained
    in `name`.'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '注意在`setValue`函数中，你必须首先创建一个空对象，然后再定义属性。这是因为属性的名称是动态的：如果我们做了类似`{ name: value
    }`的事情，那么属性名称实际上将是值`"name"`，而不是`name`变量包含的值。这类似于`changes.name = value`，这又会将属性名称设置为`name`。相反，你使用`changes[name]`来使用`name`变量中包含的实际值。'
- en: 'The same syntax that you use to add a dynamically named property to an object
    after it has been created can now be used to compute the property name in an object
    literal. This syntax is concise and seems to tell the story of what it’s doing
    much better than your original code:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 你用来在对象创建后添加动态命名的属性的语法现在也可以用来在对象字面量中计算属性名称。这种语法简洁，似乎比你的原始代码更好地说明了它在做什么：
- en: '[PRE79]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: This works exactly the same as using brackets on objects after they’re created,
    and allows you to use the same syntax with object literals.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 这与在对象创建后使用方括号的效果完全相同，并允许你使用相同的语法与对象字面量一起使用。
- en: '|  |'
  id: totrans-505
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 12.3**'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 12.3**'
- en: '**[Q1:](kindle_split_022_split_003.xhtml#ch12qa6q0a1)**'
  id: totrans-507
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_022_split_003.xhtml#ch12qa6q0a1)**'
- en: ''
  id: totrans-508
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What will be logged to the console?
  id: totrans-509
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将会在控制台输出什么？
- en: ''
  id: totrans-510
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-511
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '|  |'
  id: totrans-512
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 12.3 answer**'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 12.3 答案**'
- en: '**[A1:](kindle_split_022_split_003.xhtml#ch12qa5q1)**'
  id: totrans-515
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_022_split_003.xhtml#ch12qa5q1)**'
- en: ''
  id: totrans-516
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: undefined “green”
  id: totrans-517
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 未定义的“绿色”
- en: '|  |'
  id: totrans-518
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-519
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this lesson you learned how to take advantage of the additions to the object
    literal syntax.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了如何利用对象字面量语法的扩展。
- en: Concise property names remove redundancy when the key and value have the same
    name.
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简洁的属性名称在键和值具有相同名称时可以去除冗余。
- en: Concise methods give a simpler syntax for defining functions on an object literal.
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简洁的方法为在对象字面量上定义函数提供了一个更简单的语法。
- en: Concise methods are anonymous and shouldn’t be used for recursion.
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简洁的方法是匿名的，不应用于递归。
- en: Computed properties allow you to use dynamic property names on object literals.
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算属性允许你在对象字面量中使用动态属性名称。
- en: 'Let’s see if you got this:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否理解了：
- en: '**[Q12.1](kindle_split_050_split_008.xhtml#app01qa8q0a1)**'
  id: totrans-526
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q12.1](kindle_split_050_split_008.xhtml#app01qa8q0a1)**'
- en: ''
  id: totrans-527
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use shorthand method names to extend your state manager to support subscribing
    and unsubscribing to state changes.
  id: totrans-528
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用简写的方法名称来扩展你的状态管理器，以支持订阅和取消订阅状态变化。
- en: Lesson 13\. Symbol—a new primitive
  id: totrans-529
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第13课。符号——一个新的原始类型
- en: After reading [lesson 13](kindle_split_023_split_000.xhtml#ch13), you will
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读[第13课](kindle_split_023_split_000.xhtml#ch13)之后，你将
- en: Know how to use symbols as constants
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何使用符号作为常量
- en: Know how to use symbols as object keys
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何使用符号作为对象键
- en: Know how to create behavior hooks with global symbols
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何使用全局符号创建行为钩子
- en: Know how to modify object behavior with well-known symbols
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何使用已知的符号修改对象行为
- en: 'In JavaScript there are *objects* and there are *primitives*. The primitives
    of JavaScript are strings, numbers, Booleans (true or false), null, and undefined.
    *Symbol* is a new primitive added in ES2015 and is the first primitive added to
    JavaScript since its creation. A symbol is a unique value that’s used for hooking
    into the behavior of built-in JavaScript objects. Symbols can be broken into three
    categories:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，有*对象*和*原始数据类型*。JavaScript的原始数据类型包括字符串、数字、布尔值（true或false）、null和undefined。*Symbol*是ES2015中添加的新原始数据类型，也是自JavaScript创建以来首次添加的原始数据类型。Symbol是一个独特的值，用于挂钩到内置JavaScript对象的行为。Symbols可以分为三个类别：
- en: Unique symbols
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 唯一符号
- en: Global symbols
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 全局符号
- en: Well-known symbols
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 已知符号
- en: '|  |'
  id: totrans-539
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: Imagine you were programming a chess game. You program the base chess piece
    with a `moves()` function that determines the available destinations, then checks
    if each is legal by checking if the destination is occupied by a teammate piece.
    The code for each type of chess piece needs to inherit from the base chess piece
    code. How would you make each chess piece override how the `moves()` function
    determines the possible destinations without overriding how it determines if the
    move is legal?
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果你正在编写一个棋盘游戏。你编写了一个带有`moves()`函数的基本棋子，该函数确定可用的目的地，然后通过检查目的地是否被队友棋子占用来检查每个目的地是否合法。每种棋子的代码都需要从基本棋子代码继承。你将如何使每个棋子覆盖`moves()`函数确定可能目的地的行为，而不覆盖它确定移动是否合法的行为？
- en: '|  |'
  id: totrans-542
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 13.1\. Using symbols as constants
  id: totrans-543
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1\. 使用符号作为常量
- en: 'Developers often create constants to represent a *flag*. A flag is a special
    variable with only one purpose: identification. The flag’s value isn’t important,
    only that the flag is identified.'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者经常创建常量来表示*标志*。标志是一个特殊变量，只有一个目的：识别。标志的值并不重要，重要的是标志被识别。
- en: Many libraries use flags; for example, Google Maps uses the flags `HYBRID`,
    `ROADMAP`, `SATELLITE`, and `TERRAIN` to identify what type of map to draw. Each
    flag’s value is the lowercase string version of its name (for example `HYBRID
    === "hybrid"`), but this doesn’t matter as long as the flag can be identified.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 许多库使用标志；例如，Google Maps使用标志`HYBRID`、`ROADMAP`、`SATELLITE`和`TERRAIN`来识别要绘制的地图类型。每个标志的值是其名称的小写字符串版本（例如`HYBRID
    === "hybrid"`），但这并不重要，只要标志可以被识别。
- en: In [listing 13.1](kindle_split_023_split_001.xhtml#ch13ex01) you’re using constants
    as flags to identify where to place a tooltip. But the names are generic and could
    easily conflict with other values. Since the only purpose of a flag is to be identified,
    it makes sense to protect the flag from misidentification. Imagine another part
    of the program has flags for `CORRECT` and `INCORRECT` that contain the values
    `right` and `wrong` respectively. This means the `CORRECT` flag could be misidentified
    as the `RIGHT` flag since they both contain the same internal value.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表13.1](kindle_split_023_split_001.xhtml#ch13ex01)中，你使用常量作为标志来识别放置工具提示的位置。但名称是通用的，很容易与其他值冲突。由于标志的唯一目的是被识别，因此保护标志免受误识别是有意义的。想象一下，程序的另一部分有`CORRECT`和`INCORRECT`标志，分别包含`right`和`wrong`值。这意味着`CORRECT`标志可能会被误识别为`RIGHT`标志，因为它们都包含相同的内部值。
- en: Some libraries like Redux send actions through multiple handlers. Each handler
    identifies what actions it’s responsible for by the use of flags and identifiers.
    Different plugins written by different authors can specify handlers for actions.
    This increases the possibility of naming collisions.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 一些库，如Redux，通过多个处理程序发送动作。每个处理程序通过使用标志和标识符来识别它负责的动作。不同作者编写的不同插件可以指定动作的处理程序。这增加了命名冲突的可能性。
- en: Listing 13.1\. Using constants as flags
  id: totrans-548
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表13.1\. 使用常量作为标志
- en: '[PRE81]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '***1* This will also match answer.CORRECT.**'
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这将匹配answer.CORRECT。**'
- en: '***2* This will position the tooltip to the right.**'
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 这将使工具提示定位到右侧。**'
- en: Notice how the `addToolTip` function expects a flag from `positions` but you
    passed a flag from `answer`. This ideally should throw an error notifying you
    of your mistake, but it doesn’t. It just positions the tooltip to the right because
    your flags aren’t unique.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`addToolTip`函数期望从`positions`接收一个标志，但你传递了一个来自`answer`的标志。理想情况下，这应该抛出一个错误来通知你的错误，但它没有。它只是将工具提示定位到右侧，因为你的标志不是唯一的。
- en: 'You can solve these naming collisions using unique symbols. Create a unique
    symbol by calling the `Symbol()` function with an optional string description
    as a parameter. Each unique symbol is always unique as demonstrated here:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用唯一的符号来解决这些命名冲突。通过将可选的字符串描述作为参数调用 `Symbol()` 函数来创建一个唯一的符号。每个唯一的符号总是唯一的，如下所示：
- en: '[PRE82]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '***1* false**'
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* false**'
- en: When you create a symbol using the `Symbol` function, the symbol created is
    always unique. You can call the `Symbol` function over and over again with the
    same description and every time you will get a unique symbol back. This is because
    when you call the `Symbol` function, you are creating a new value in memory every
    time that will never equate to another symbol in memory somewhere else.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `Symbol` 函数创建一个符号时，创建的符号总是唯一的。你可以多次使用相同的描述调用 `Symbol` 函数，每次都会得到一个唯一的符号。这是因为每次调用
    `Symbol` 函数时，你都会在内存中创建一个新的值，这个值永远不会等于内存中其他地方的另一个符号。
- en: 'The same string such as `"foo"` will only ever be stored in memory once. No
    matter how many times you create a new string `"foo"`, the primitive value is
    always pointing to the same place in memory. This is why `"foo" == "foo"` is always
    true. This is the same for all primitives, and is why primitives can always be
    compared to each other no matter where they came from. Objects on the other hand
    always create their own identify in memory, and thus two objects that look the
    same will not equate as the same `{ foo: 1 } != { foo: 1 }`.'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '相同的字符串，例如 `"foo"`，在内存中只会存储一次。无论你创建多少次新的字符串 `"foo"`，原始值总是指向内存中的同一个位置。这就是为什么
    `"foo" == "foo"` 总是成立。对于所有原始值都是如此，这就是为什么原始值可以相互比较，无论它们来自何方。另一方面，对象总是在内存中创建自己的标识，因此看起来相同的两个对象不会相等，即
    `{ foo: 1 } != { foo: 1 }`。'
- en: 'Every time you invoke `Symbol()` you’re creating a brand new value stored in
    memory so there’s no chance of an accidental collision. Now that you know symbols
    created from the `Symbol()` function will never collide, you could rewrite your
    previous tool tip example to make use of symbols and capture the previous bug:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用 `Symbol()` 时，你都在内存中创建一个新的值，因此不可能发生意外的冲突。现在你知道从 `Symbol()` 函数创建的符号永远不会冲突，你可以重写之前的工具提示示例，利用符号并捕获之前的错误：
- en: '[PRE83]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This also has the benefit of making sure that the constant and not the value
    is used when invoking the function, because passing `Symbol('top')` as the position
    argument won’t actually match any flags! This would make it easier to refactor
    your constants knowing that the values can’t be directly used as strings can.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 这也有确保在调用函数时使用的是常量而不是值的优点，因为传递 `Symbol('top')` 作为位置参数实际上不会匹配任何标志！这将使重构你的常量更容易，因为你知道值不能直接用作字符串。
- en: '|  |'
  id: totrans-561
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 13.1**'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 13.1**'
- en: '**[Q1:](kindle_split_023_split_001.xhtml#ch13qa2q0a1)**'
  id: totrans-563
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_023_split_001.xhtml#ch13qa2q0a1)**'
- en: ''
  id: totrans-564
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the following snippet, of the values a through `e`, which are `true`?
  id: totrans-565
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在以下代码片段中，从 `a` 到 `e` 的值中，哪些是 `true`？
- en: ''
  id: totrans-566
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-567
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '|  |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-569
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 13.1 answer**'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 13.1 答案**'
- en: '**[A1:](kindle_split_023_split_001.xhtml#ch13qa1q1)**'
  id: totrans-571
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_023_split_001.xhtml#ch13qa1q1)**'
- en: ''
  id: totrans-572
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Only `a` and `d`.
  id: totrans-573
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 只有 `a` 和 `d`。
- en: '|  |'
  id: totrans-574
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 13.2\. Using symbols as object keys
  id: totrans-575
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2\. 使用符号作为对象键
- en: 'Sometimes developers add properties to objects with a leading underscore to
    signify that they should be treated as pseudo-private, such as `Store._internals`.
    The problem with this is that (unless specified with `Object.defineProperty`)
    these values will still be enumerable, meaning they’ll still be included in things
    like `for...in` statements and `JSON.stringify()`, which may not be desired. You
    can achieve the same pseudo-private properties using symbol as the property name:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 有时开发者会在对象属性前添加一个前导下划线，以表示它们应该被视为伪私有，例如 `Store._internals`。这个问题在于（除非使用 `Object.defineProperty`
    指定），这些值仍然会被枚举，这意味着它们仍然会被包含在 `for...in` 语句和 `JSON.stringify()` 等操作中，这可能不是所希望的。你可以使用符号作为属性名来达到相同的伪私有属性效果：
- en: '[PRE85]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '***1* To use a symbol as a property name, it must be a computed property name**'
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 要将符号用作属性名，它必须是一个计算属性名**'
- en: You must use a *computed property name*, though, to add a symbol as a property
    name. When using a symbol as a property name, the property isn’t enumerable, meaning
    it won’t be included in a `for...in` statement or in `JSON.stringify()`, and it
    won’t even be returned in `Object.getOwnPropertyNames()`. Also, since you don’t
    have any references to the symbol, and since calling `Symbol('hidden')` again
    will return a different symbol, the property is essentially private.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须使用 *计算属性名* 来添加符号作为属性名。当使用符号作为属性名时，该属性是不可枚举的，这意味着它不会包含在 `for...in` 语句或 `JSON.stringify()`
    中，甚至不会在 `Object.getOwnPropertyNames()` 中返回。此外，由于你没有任何符号的引用，并且调用 `Symbol('hidden')`
    再次将返回不同的符号，因此该属性本质上就是私有的。
- en: It isn’t really private, though, because there’s a new function in ES6 on `Object`
    called `Object.getOwnPropertySymbols()` which returns an array of all the own
    properties that are symbols. With this you can get a reference to the symbol and
    access the property.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是真正的私有，因为 ES6 中的 `Object` 有一个新的函数 `Object.getOwnPropertySymbols()`，它返回一个包含所有自身属性（符号）的数组。使用这个函数，你可以获取符号的引用并访问该属性。
- en: If symbols as property names aren’t truly private, and since they can be private
    with closures, what’s the point? Setting a symbol property isn’t meant to be private
    from a security point of view, but more of an available but hidden API. This not-quite-private
    but not-quite-public API is a great place to define hooks that modify the object,
    or *meta* properties.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 如果作为属性名的符号并非真正私有，并且由于它们可以通过闭包实现私有，那么这有什么意义呢？设置符号属性并不是为了从安全角度实现私有，而更多的是提供一个可用但隐藏的
    API。这种既不完全私有也不完全公开的 API 是定义修改对象或 *元* 属性的绝佳地方。
- en: '|  |'
  id: totrans-582
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 13.2**'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 13.2**'
- en: '**[Q1:](kindle_split_023_split_002.xhtml#ch13qa4q0a1)**'
  id: totrans-584
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_023_split_002.xhtml#ch13qa4q0a1)**'
- en: ''
  id: totrans-585
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What’s wrong with this code?
  id: totrans-586
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这段代码有什么问题？
- en: ''
  id: totrans-587
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-588
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '|  |'
  id: totrans-589
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-590
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 13.2 answer**'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 13.2 答案**'
- en: '**[A1:](kindle_split_023_split_002.xhtml#ch13qa3q1)**'
  id: totrans-592
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_023_split_002.xhtml#ch13qa3q1)**'
- en: ''
  id: totrans-593
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The symbol property needs to be a computed property:'
  id: totrans-594
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 符号属性需要是一个计算属性：
- en: ''
  id: totrans-595
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-596
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '|  |'
  id: totrans-597
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 13.3\. Creating behavior hooks with global symbols
  id: totrans-598
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3\. 使用全局符号创建行为钩子
- en: 'Global symbols are symbols that are added to a registry and can be globally
    accessed from anywhere. You access a global symbol by invoking `Symbol.for`:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 全局符号是添加到注册表中的符号，可以从任何地方全局访问。你通过调用 `Symbol.for` 访问全局符号：
- en: '[PRE88]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: When you invoke `Symbol.for`, it first checks the registry to see if a symbol
    exists for the given name; if so, it’s returned. If a symbol doesn’t yet exist,
    it’s created, added to the registry, and then returned. Since global symbols are
    global, it goes without saying that the symbols you get from `Symbol.for()` aren’t
    unique like the symbols you get back from `Symbol()`. Global symbols are great
    for setting predefined hooks into an object’s behavior.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 `Symbol.for` 时，它首先检查注册表以查看是否存在给定名称的符号；如果存在，则返回。如果尚不存在符号，则创建它，将其添加到注册表，然后返回。由于全局符号是全局的，所以不言而喻，从
    `Symbol.for()` 获取的符号与从 `Symbol()` 获取的符号不同。全局符号非常适合将预定义的钩子设置到对象的行为中。
- en: In [lesson 10](kindle_split_020_split_000.xhtml#ch10) you created a factory
    function for creating base spaceships. You then created other factory functions
    for creating more specialized spaceships. In that lesson you simply added new
    methods to the base like `bomb`, as shown in the next listing.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 10 课](kindle_split_020_split_000.xhtml#ch10) 中，你创建了一个用于创建基础太空船的工厂函数。然后你创建了其他工厂函数来创建更专业的太空船。在那节课中，你只是向基础对象添加了新的方法，例如
    `bomb`，如下所示。
- en: Listing 13.2\. The `createBomberSpaceShip` function from [lesson 10](kindle_split_020_split_000.xhtml#ch10)
  id: totrans-603
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.2\. 来自 [第 10 课](kindle_split_020_split_000.xhtml#ch10) 的 `createBomberSpaceShip`
    函数
- en: '[PRE89]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'But in a real game you most likely have a way for the player to fire the weapon,
    such as pressing the spacebar. It would make more sense to provide a method like
    `fire()` that lets the enhanced spaceships hook into and alter what happens when
    the ship fires. This way when the user presses the spacebar, in response the code
    can invoke `fire()` without having to worry about what kind of spaceship it is
    and whether or not it should invoke `shoot()` or `bomb()` or some other method.
    Such an approach may look like this:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 但在真正的游戏中，你很可能有一种让玩家开火的方式，比如按空格键。提供一个 `fire()` 方法，让增强型太空船可以挂钩并改变飞船开火时发生的事情，会更有意义。这样，当用户按下空格键时，代码可以调用
    `fire()`，而不必担心它是什么类型的飞船，以及是否应该调用 `shoot()`、`bomb()` 或其他方法。这种做法可能看起来像这样：
- en: '[PRE90]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'And the enhanced bomber spaceship could be implemented like so:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 增强型轰炸机太空船可以如此实现：
- en: '[PRE91]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: You could use a method like `getWeapon()` and this approach wouldn’t be terrible,
    but it would add an additional public method to the spaceship that isn’t meant
    to be used (just overridden). If there are a lot of hooks like this, it could
    make the public spaceship API bloated and harder to maintain.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用像 `getWeapon()` 这样的方法，这种方法并不糟糕，但会向飞船添加一个额外的公共方法，而这个方法并不打算被使用（只是被覆盖）。如果有许多这样的钩子，它可能会使公共飞船
    API 变得臃肿且难以维护。
- en: If you use symbols to define these hooks, they’re much less accessible than
    the `getWeapon()` approach, yet not quite private so they can still be overridden.
    It’s the perfect balance.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用符号来定义这些钩子，它们比 `getWeapon()` 方法更不易访问，但也不是完全私有的，因此它们仍然可以被覆盖。这是一个完美的平衡。
- en: So far you’ve been hooking into the behavior of objects that you defined yourself,
    but what if you wanted to hook into the behavior of built-in objects?
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你一直在钩入你定义的对象的行为，但如果你想要钩入内置对象的行为怎么办？
- en: '|  |'
  id: totrans-612
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 13.3**'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 13.3**'
- en: '**[Q1:](kindle_split_023_split_003.xhtml#ch13qa6q0a1)**'
  id: totrans-614
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_023_split_003.xhtml#ch13qa6q0a1)**'
- en: ''
  id: totrans-615
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What’s wrong with the following code?
  id: totrans-616
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码有什么问题？
- en: ''
  id: totrans-617
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-618
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '|  |'
  id: totrans-619
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-620
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 13.3 answer**'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 13.3 答案**'
- en: '**[A1:](kindle_split_023_split_003.xhtml#ch13qa5q1)**'
  id: totrans-622
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_023_split_003.xhtml#ch13qa5q1)**'
- en: ''
  id: totrans-623
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The symbol property must be a computed property, like so:'
  id: totrans-624
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 符号属性必须是一个计算属性，如下所示：
- en: ''
  id: totrans-625
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-626
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '|  |'
  id: totrans-627
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 13.4\. Modifying object behavior with well-known symbols
  id: totrans-628
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4\. 使用已知符号修改对象行为
- en: Just as you used symbols to hook into the behavior of your spaceship in the
    previous section, built-in JavaScript objects also provide several hooks into
    their functionality with *well-known symbols*. A well-known symbol is a built-in
    symbol that’s attached directly to `Symbol` such as `Symbol.toPrimitive`.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上一节中使用符号钩入飞船的行为一样，内置的 JavaScript 对象也通过 *已知符号* 提供了几个钩入其功能的方法。一个已知符号是直接附加到
    `Symbol` 的内置符号，例如 `Symbol.toPrimitive`。
- en: The `Symbol.toPrimitive` allows hooking into an object and controls how it gets
    coerced into a primitive value. A simple implementation could be
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '`Symbol.toPrimitive` 允许钩入对象并控制它如何被强制转换为原始值。一个简单的实现可以是'
- en: '[PRE94]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '***1* thirty-two**'
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 三十二**'
- en: 'Since the value is a function, you could use the shorthand method syntax to
    tidy this up:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 使用简写方法语法来整理这个值，因为它的值是一个函数：
- en: '[PRE95]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '***1* thirty-two**'
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 三十二**'
- en: In this particular example, you’re coercing the object into a string, but you
    may want to do something different when the object is coerced into a number. The
    `Symbol.toPrimitive` function gets passed an argument hinting at what type of
    primitive it’s being coerced into for such a case. The possible values are `string`,
    number, and default. We can update our example to make use of this, as in the
    next listing.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的例子中，你正在将对象强制转换为字符串，但当你想要在对象被强制转换为数字时做不同的事情。`Symbol.toPrimitive` 函数传递一个参数，暗示在这种情况下它被强制转换为哪种原始类型。可能的值是
    `string`、`number` 和 `default`。我们可以更新我们的示例以利用这一点，如下一列表所示。
- en: Listing 13.3\. Working with well-known symbols
  id: totrans-637
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.3\. 使用已知符号
- en: '[PRE96]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '***1* I am 32 years old, but by the time you read this I will be at least 33.**'
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 我今年32岁，但当你读到这篇文章时，我至少会33岁。**'
- en: '***2* thirty-two(32)**'
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 三十二(32)**'
- en: '***3* [object Object]**'
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* [object Object]**'
- en: In [listing 13.3](kindle_split_023_split_004.xhtml#ch13ex03) the `age` object
    will default to `thirty-two(32)` when coerced into a primitive, but will return
    `thirty-two` and `32` when coerced into a string or number, respectively. But
    calling `toString()` isn’t a coercion and thus isn’t affected.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 13.3](kindle_split_023_split_004.xhtml#ch13ex03) 中，当 `age` 对象被强制转换为原始值时，将默认为
    `thirty-two(32)`，但当被强制转换为字符串或数字时，将分别返回 `thirty-two` 和 `32`。但调用 `toString()` 不是一个强制转换，因此不受影响。
- en: 'There are several well-known symbols. Covering all of them is beyond the scope
    of this book. We’ll cover `Symbol.iterator` in the iteration unit, and you can
    get a list of all the well-known symbols here: [http://mng.bz/5838](http://mng.bz/5838).'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个已知的符号。涵盖所有这些超出了本书的范围。我们将在迭代单元中介绍 `Symbol.iterator`，你可以在这里找到所有已知符号的列表：[http://mng.bz/5838](http://mng.bz/5838)。
- en: '|  |'
  id: totrans-644
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 13.4**'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 13.4**'
- en: '**[Q1:](kindle_split_023_split_004.xhtml#ch13qa8q0a1)**'
  id: totrans-646
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_023_split_004.xhtml#ch13qa8q0a1)**'
- en: ''
  id: totrans-647
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Create an object with a `born` property which is a date. Use `Symbol.toPrimitive`
    to calculate the age based on the born date when coerced into a number.
  id: totrans-648
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 创建一个具有 `born` 属性的对象，该属性是一个日期。使用 `Symbol.toPrimitive` 在强制转换为数字时根据出生日期计算年龄。
- en: '|  |'
  id: totrans-649
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-650
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 13.4 answer**'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 13.4 答案**'
- en: '**[A1:](kindle_split_023_split_004.xhtml#ch13qa7q1)**'
  id: totrans-652
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_023_split_004.xhtml#ch13qa7q1)**'
- en: ''
  id: totrans-653
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-654
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '|  |'
  id: totrans-655
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 13.5\. Symbol gotchas
  id: totrans-656
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.5. 符号注意事项
- en: Symbols are *primitives*, but they’re the only primitives that don’t have a
    literal form. So they must be created by calling the `Symbol()` function. Other
    primitives like numbers, strings, and Booleans (but not null or undefined) can
    be created the same way; `Number(1)`, `String('foo')`, or `Boolean(true)` for
    example. These same primitive functions can also be called with `new`, for example
    `new Number(1)`, but this doesn’t return a primitive value; it returns a primitive
    *wrapper*, an object that wraps a primitive value. A primitive wrapper around
    a symbol is usually not desired, so to protect from accidentally creating one,
    if `Symbol()` is invoked with `new` like `new Symbol()`, an error will be thrown.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 符号是**原始类型**，但它们是唯一没有字面形式的原始类型。因此，它们必须通过调用 `Symbol()` 函数来创建。其他原始类型，如数字、字符串和布尔值（但不包括
    null 或 undefined），也可以以相同的方式创建；例如，`Number(1)`、`String('foo')` 或 `Boolean(true)`。这些相同的原始类型函数也可以用
    `new` 调用，例如 `new Number(1)`，但这不会返回原始值；它返回一个原始**包装器**，一个包含原始值的对象。围绕符号的原始包装器通常是不希望的，因此为了防止意外创建一个，如果
    `Symbol()` 以 `new` 的方式调用，例如 `new Symbol()`，将会抛出错误。
- en: There are protections to keep you from accidentally coercing symbols to strings
    or numbers for the same reason. Doing so would throw an error as demonstrated
    in the next listing.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止意外将符号强制转换为字符串或数字，存在相应的保护措施。这样做会抛出错误，如下一列表中所示。
- en: Listing 13.4\. Every line here throws an error
  id: totrans-659
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.4. 这里每一行都会抛出错误
- en: '[PRE98]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: In this lesson you learned how to create unique constants that are safe from
    naming collisions. You then learned how to use symbols to create custom hooks
    into object behavior with global symbols. Finally you learned how to use well-known
    symbols for built-in-behavior hooks.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了如何创建唯一常量，这些常量可以防止命名冲突。然后你学习了如何使用符号通过全局符号创建对对象行为的自定义钩子。最后，你学习了如何使用已知符号为内置行为钩子。
- en: Summary
  id: totrans-662
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this lesson you learned the basics of symbols.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了符号的基础知识。
- en: Unique symbols are guaranteed to be unique because they all have unique identities
    in memory.
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 唯一符号保证是唯一的，因为它们在内存中都具有唯一的身份。
- en: Unique symbols are a great way to prevent naming collisions.
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 唯一符号是防止命名冲突的好方法。
- en: Global symbols are automatically stored and retrieved from a global registry.
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局符号会自动存储和检索自全局注册表。
- en: Global symbols can be used to provide hooks into custom objects.
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局符号可用于提供对自定义对象的钩子。
- en: Well-known symbols exist to provide hooks into built-in objects.
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已知符号存在是为了提供对内置对象的钩子。
- en: The `new` operator shouldn’t be used to create symbols.
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不应使用 `new` 运算符来创建符号。
- en: Symbols shouldn’t be coerced into other primitives.
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不应将符号强制转换为其他原始类型。
- en: 'Let’s see if you got this:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否掌握了这个：
- en: '**[Q13.1](kindle_split_050_split_009.xhtml#app01qa9q0a1)**'
  id: totrans-672
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q13.1](kindle_split_050_split_009.xhtml#app01qa9q0a1)**'
- en: ''
  id: totrans-673
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use `Symbol.toPrimitive` to create an object that, when coerced into a string,
    serializes into a URI query string.
  id: totrans-674
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 `Symbol.toPrimitive` 创建一个对象，当强制转换为字符串时，会序列化为 URI 查询字符串。
- en: 'Lesson 14\. Capstone: Simulating a lock and key'
  id: totrans-675
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 14 课：综合练习：模拟锁和键
- en: In this capstone exercise you’re going to build a lock and key system. Each
    lock will have its own key that’s unique to it. The lock will hold some secret
    data and only return the data if accessed with the correct key. You’ll then build
    a game where you generate three locks and give the player only one key and one
    chance to unlock a prize!
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个综合练习中，你将构建一个锁和键系统。每个锁都将有其独特的密钥。锁将持有一些秘密数据，并且只有在使用正确的密钥访问时才会返回数据。然后你将构建一个游戏，其中生成三个锁，并给玩家一个密钥和一个解锁奖品的机会！
- en: 14.1\. Creating the lock and key system
  id: totrans-677
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1. 创建锁和键系统
- en: You’ll start by designing the lock API. You want to have a function called `lock`
    which accepts a single parameter that’s the data you’re locking up. It should
    then return a unique key (key as in *key to a lock*) and an `unlock` function
    that reveals the secret if invoked with the correct key. So the high-level API
    is basically `{ key, unlock } = lock(secret)`.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从设计锁 API 开始。你希望有一个名为 `lock` 的函数，它接受一个参数，即你要锁定的数据。然后它应该返回一个独特的密钥（密钥即**锁的钥匙**）和一个
    `unlock` 函数，如果用正确的密钥调用，则会揭示秘密。所以高级 API 基本上是 `{ key, unlock } = lock(secret)`。
- en: The `secret` can be any single datum. Both `lock` and `unlock` are functions,
    but you need to figure out what data type `key` is going to be.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '`secret` 可以是任何单个数据项。`lock` 和 `unlock` 都是函数，但你需要确定 `key` 将会是哪种数据类型。'
- en: 'A good solution would be a randomly generated string. But strings aren’t exactly
    unique; it’s possible they may overlap or even be guessable. You can use a complex
    string that’s hard to guess or rarely overlaps like a SHA-1, but that would take
    a lot of effort or require installing a library. You already have a data type
    that’s easy to generate and guaranteed to be unique, the `Symbol`. So you’ll use
    that:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的解决方案是随机生成的字符串。但字符串并不完全独特；它们可能重叠，甚至可预测。你可以使用一个难以猜测或很少重叠的复杂字符串，如 SHA-1，但这需要大量的努力或需要安装库。你已经有一个易于生成且保证唯一的
    数据类型，即 `Symbol`。所以你会使用它：
- en: '[PRE99]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Here you have a `lock` function. When invoked it’s given a `secret` and generates
    a new `key` which is a unique symbol. Remember, every symbol created this way
    will always be unique and never overlap. The lock function then returns an object
    with the generated key and an `unlock` function. The unlock function accepts a
    `keyUsed` parameter and compares the key used to unlock the secret against the
    correct key. If they’re the same, it returns the secret:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个 `lock` 函数。当被调用时，它会接收一个 `secret` 并生成一个新的 `key`，这是一个独特的符号。记住，以这种方式创建的每个符号都将始终是唯一的，并且永远不会重叠。然后，锁函数返回一个包含生成的密钥和一个
    `unlock` 函数的对象。`unlock` 函数接受一个 `keyUsed` 参数，并将用于解锁秘密的密钥与正确的密钥进行比较。如果它们相同，它就返回秘密：
- en: '[PRE100]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '***1* JavaScript is Awesome!**'
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* JavaScript 真棒！**'
- en: You still need to figure out what to do if an incorrect key is used. In a real-world
    app you would probably throw an error if the wrong key is used. But for the sake
    of this exercise, just make it mask the value. You can use `String.prototype.repeat`
    which you learned in [lesson 6](kindle_split_015_split_000.xhtml#ch06) to return
    a masked copy of the string. Something like
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要弄清楚如果使用了错误的密钥会怎样。在现实世界的应用程序中，如果你使用了错误的密钥，你可能会抛出一个错误。但为了这个练习的目的，只需将其值隐藏起来。你可以使用你在
    [课程 6](kindle_split_015_split_000.xhtml#ch06) 中学到的 `String.prototype.repeat` 方法来返回字符串的隐藏副本。类似于
- en: '[PRE101]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Here’s the updated function.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是更新后的函数。
- en: Listing 14.1\. Detecting incorrect keys
  id: totrans-688
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.1\. 检测错误的密钥
- en: '[PRE102]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '***1* ****'
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* ****'
- en: '***2* 42**'
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 42**'
- en: Awesome! You’ve completed your lock and key system and it works great! Best
    of all, you did it with little code and no need for an external library. Now you
    can create several locks with several keys, and each lock will only be accessible
    by its associated key. What if you created several locks and keys and mixed them
    up?
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你已经完成了你的锁和钥匙系统，它工作得很好！最好的是，你用很少的代码和不需要外部库就做到了。现在你可以创建多个锁和多个钥匙，每个锁只能通过其关联的钥匙访问。如果你创建了多个锁和钥匙并将它们混合在一起会怎样？
- en: 14.2\. Creating a Choose the Door game
  id: totrans-693
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2\. 创建选择门游戏
- en: 'If you created three locks and presented them to a player as Door #1, Door
    #2, and Door #3, and gave the player a single key, you could ask the player to
    guess which door their key goes to. If they guess right, they win the prize behind
    the door. Hopefully that sounds like a fun game because that’s exactly what you’re
    going to build. Since the locks in this game are going to be doors, the secret
    can be *what’s behind the door*. This may seem like a familiar game, but the twist
    is that the player may choose any door, but only if their key opens that door
    do they find out what’s behind it and win the prize. Ready? Let’s see how to build
    it.'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你创建了三个锁，并以门 #1、门 #2 和门 #3 的形式向玩家展示，并给玩家一个单独的钥匙，你可以要求玩家猜测他们的钥匙对应哪扇门。如果他们猜对了，他们就能赢得门后的奖品。希望这听起来像是一个有趣的游戏，因为这正是你要构建的。由于这个游戏中的锁将是门，秘密可以是
    *门后的东西*。这可能看起来像是一个熟悉的游戏，但转折在于玩家可以选择任何门，但只有当他们的钥匙能打开那扇门时，他们才能发现门后的秘密并赢得奖品。准备好了吗？让我们看看如何构建它。'
- en: Start by building the main user interface to your game, as shown in [listing
    14.2](kindle_split_024_split_002.xhtml#ch14ex02). You need a way to present some
    options to a player and for that player to select an option. To keep it simple
    use `prompt` for this task.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，构建你的游戏主用户界面，如图 [列表 14.2](kindle_split_024_split_002.xhtml#ch14ex02) 所示。你需要一种方式向玩家展示一些选项，并让玩家选择一个选项。为了简单起见，使用
    `prompt` 来完成这个任务。
- en: Listing 14.2\. Main interface for the game
  id: totrans-696
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.2\. 游戏主界面
- en: '[PRE103]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '***1* Build the multiple choice options that you display in the prompt. Add
    1 to each index so the options start at 1 instead of 0.**'
  id: totrans-698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 构建你在提示中显示的多项选择题选项。将每个索引加 1，以便选项从 1 开始而不是 0。**'
- en: '***2* Then get back the number that the user typed into the prompt. You need
    to subtract that 1 that you added earlier.**'
  id: totrans-699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 然后获取用户在提示中输入的数字。你需要减去之前加上的那个 1。**'
- en: '***3* If you got an appropriate response from the prompt, return the value.**'
  id: totrans-700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果你从提示中得到了适当的响应，返回该值。**'
- en: '***4* If you didn’t get a valid value, make a second attempt.**'
  id: totrans-701
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 如果你没有得到有效的值，进行第二次尝试。**'
- en: '***5* If you still didn’t get a valid value after a second attempt, throw an
    error.**'
  id: totrans-702
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 如果你在第二次尝试后仍然没有得到有效的值，抛出一个错误。**'
- en: This `choose` function accepts a single message and an array of options. Then
    it handles wiring everything up so that the player is presented the message and
    the options, and told to type a number correlating to each option to make a selection.
    If an incorrect input is received, the player is asked one last time, and if a
    valid option is still not selected by the player, an error is thrown. Once a valid
    option is selected, the index of that option is returned from the `choose` function.
    By handling all of those details in this `choose` function, you can focus on what
    the message and options are elsewhere in your game. You can use the `choose` function
    as shown in the next listing and [figure 14.1](kindle_split_024_split_002.xhtml#ch14fig01).
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `choose` 函数接受一个消息和一个选项数组。然后它处理所有连接，以便玩家可以看到消息和选项，并被告知输入与每个选项相对应的数字以进行选择。如果收到不正确的输入，玩家将最后一次被询问，如果玩家仍然没有选择有效的选项，将抛出一个错误。一旦选定了有效的选项，`choose`
    函数将返回该选项的索引。通过在这个 `choose` 函数中处理所有这些细节，你可以专注于游戏其他地方的消息和选项。你可以像下一个列表和[图 14.1](kindle_split_024_split_002.xhtml#ch14fig01)中所示那样使用
    `choose` 函数。
- en: Figure 14.1\. Basic multiple choice question
  id: totrans-704
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 14.1\. 基本多项选择题
- en: '![](Images/14fig01_alt.jpg)'
  id: totrans-705
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/14fig01_alt.jpg)'
- en: Listing 14.3\. Building a multiple choice question
  id: totrans-706
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.3\. 构建一个多项选择题
- en: '[PRE104]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Now that you have a way to ask the user to choose a door, you need to generate
    three doors (locks) and assign the player a random key. First generate the doors
    with prizes. How do you think you should do that? You may try something like this:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了一种让用户选择门的方法，你需要生成三扇门（锁）并给玩家随机分配一个钥匙。首先生成带有奖品的门。你认为你应该怎么做？你可能尝试这样做：
- en: '[PRE105]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'This, however, won’t work. Remember, you have to destructure objects using
    the correct property names that are on that object. The objects returned from
    `lock` only have the properties `key` and `unlock` and must be destructured as
    such. That may lead you to trying this:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这样做是不行的。记住，你必须使用该对象上正确的属性名称来解构对象。从 `lock` 返回的对象只有 `key` 和 `unlock` 属性，并且必须这样解构。这可能会让你尝试这样做：
- en: '[PRE106]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'This, again, won’t work. After the first destructure, the constants `key` and
    `unlock` are already taken and can’t be declared again, which is attempted on
    lines 2 and 3\. All is not lost: remember you learned when destructuring property
    names that there’s a special syntax to assign them to different variable names.
    This is exactly what you need to do now:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这同样是不行的。在第一次解构后，常量 `key` 和 `unlock` 已经被占用，不能再声明，这在第 2 和第 3 行尝试时发生。但并非一切都已失去：记住，当你学习解构属性名称时，有一个特殊的语法可以将它们分配给不同的变量名。这正是你现在需要做的：
- en: '[PRE107]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Now you have three keys and three doors. So put them each in an array and grab
    a random key which you will give to the user:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有三个钥匙和三扇门。所以把它们各自放入一个数组中，随机抽取一个钥匙给用户：
- en: '[PRE108]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Easy enough. Now create the message and options that you’ll present to the
    player:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 足够简单。现在创建你将向玩家展示的消息和选项：
- en: '[PRE109]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '***1* \u{1F511} is the Unicode key character.**'
  id: totrans-718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* `\u{1F511}` 是 Unicode 键字符。**'
- en: 'Notice how you used `\u{1F511}` to escape your Unicode character. You could
    have just put the actual character into the message like so:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你如何使用 `\u{1F511}` 来转义你的 Unicode 字符。你完全可以像这样直接将实际字符放入消息中：
- en: '[PRE110]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'But that would be a lot harder to expect the reader of this book to type. Incidentally
    it brings up another new feature. Prior to ES2015 the syntax for Unicode escaping
    was `\uXXXX`, where `XXXX` was the Unicode hexadecimal code. But it only allowed
    up to four hex characters (16 bits), but notice how your character used five:
    `1F511`. To solve this prior to ES2015, you had to use what is called a *surrogate
    pair*, which uses two smaller Unicode values to generate a larger one. To get
    your key you could use `\uD83D\uDD11`. The concept of surrogate pairs or how to
    generate them is beyond the scope of this book, but ES2015 introduced a much easier
    way with `\u{XXXXX}` which allows you to escape any size Unicode character.'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 但这会让读者输入变得非常困难。顺便说一句，这也提出了另一个新特性。在 ES2015 之前，Unicode 转义语法的语法是 `\uXXXX`，其中 `XXXX`
    是 Unicode 十六进制代码。但它只允许最多四个十六进制字符（16 位），但请注意你的字符使用了五个：`1F511`。为了在 ES2015 之前解决这个问题，你必须使用所谓的“代理对”，它使用两个较小的
    Unicode 值来生成一个较大的值。为了获取你的键，你可以使用 `\uD83D\uDD11`。代理对的概念或如何生成它们超出了本书的范围，但 ES2015
    引入了一种更简单的方法，即 `\u{XXXXX}`，它允许你转义任何大小的 Unicode 字符。
- en: 'Now that you have your message and options, you can pass them to your `choose`
    function, which will ask the user to choose a door. See [figure 14.2](kindle_split_024_split_002.xhtml#ch14fig02).
    Once they choose a door, they can attempt to unlock it with their key. If the
    key is correct they’ll get the secret behind the door; otherwise they’ll get the
    masked text. Either way you’ll alert the response back to the user:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了你的信息和选项，你可以将它们传递给你的 `choose` 函数，该函数将要求用户选择一个门。参见[图 14.2](kindle_split_024_split_002.xhtml#ch14fig02)。一旦他们选择了一个门，他们就可以尝试用他们的钥匙打开它。如果钥匙正确，他们将得到门后的秘密；否则，他们将得到加密文本。无论如何，你都会将响应警报回用户：
- en: '[PRE111]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Figure 14.2\. Choose the Door game in action
  id: totrans-724
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 14.2\. 选择门游戏动作
- en: '![](Images/14fig02_alt.jpg)'
  id: totrans-725
  prefs: []
  type: TYPE_IMG
  zh: '![图片 14.2](Images/14fig02_alt.jpg)'
- en: Put all this together in a function call `init`:, as shown in the next listing.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些组合在一个函数调用 `init`：中，如下一个列表所示。
- en: Listing 14.4\. Combined Choose the Door function
  id: totrans-727
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.4\. 组合选择门功能
- en: '[PRE112]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Now if the user selects the correct door, they will see what’s behind it, winning
    the prize. What other uses can you think of for this lock and key system? Maybe
    a multiplayer game with hidden treasure chests and their keys spread throughout
    the game. What if you took the key from one lock and locked it up in another lock?
    That could get interesting.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果用户选择了正确的门，他们将看到门后的东西，赢得奖品。你能想到这个锁和钥匙系统还有什么其他用途吗？也许是一个多人游戏，隐藏宝箱和它们的钥匙散布在整个游戏中。如果你从一个锁中取出钥匙，并将其锁入另一个锁中呢？那可能会很有趣。
- en: Summary
  id: totrans-730
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this capstone exercise you simulated a lock and a key using symbols. When
    you created a lock, you got back a unique symbol as a key. Because symbols are
    always unique and don’t risk collision, the lock cannot be opened without the
    correct key (symbol). You then used this lock and key to create a Choose the Door
    game.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个综合练习中，你使用符号模拟了一个锁和一个钥匙。当你创建一个锁时，你会得到一个唯一的符号作为钥匙。因为符号总是唯一的，且不会存在冲突风险，所以没有正确的钥匙（符号）是无法打开锁的。然后你使用这个锁和钥匙创建了一个“选择门”游戏。
