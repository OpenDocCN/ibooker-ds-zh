- en: Appendix A. Using Java 8 functional features
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录 A. 使用 Java 8 函数式特性
- en: 'When Java 8 was released, it was presented by Oracle as a step towards more-functional
    programming. Among the functional-friendly features listed in Oracle’s “What’s
    New in JDK 8” note were the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Java 8 发布时，Oracle 将其定位为向更函数式编程迈出的一步。在 Oracle 的“JDK 8 新特性”笔记中列出的函数式友好特性包括以下内容：
- en: “Lambda Expressions, a new language feature, has been introduced in this release.
    They enable you to treat functionality as a method argument, or code as data.
    Lambda expressions let you express instances of single-method interfaces (referred
    to as functional interfaces) more compactly.” This is a very important aspect
    of the functional paradigm.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “Lambda 表达式，这是一种新的语言特性，已在本版本中引入。它们使您能够将功能作为方法参数处理，或将代码作为数据。Lambda 表达式允许您更紧凑地表达单方法接口（称为函数式接口）的实例。”这是函数式范式的一个重要方面。
- en: “Method references provide easy-to-read lambda expressions for methods that
    already have a name.” The latter part of that sentence probably refers to “existing
    methods,” because methods that don’t already have a name don’t exist.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “方法引用为已命名的现有方法提供了易于阅读的 lambda 表达式。”这句话的后半部分可能指的是“现有方法”，因为未命名的的方法是不存在的。
- en: “Type Annotations provide the ability to apply an annotation anywhere a type
    is used, not just on a declaration.”
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “类型注解提供了在任何使用类型的地方应用注解的能力，而不仅仅是声明上。”
- en: “Improved type inference.”
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “改进的类型推断。”
- en: “Classes in the new `java.util.stream` package provide a Stream API to support
    functional-style operations on streams of elements. The Stream API is integrated
    into the Collections API, which enables such as sequential or parallel map-reduce
    transformations.”
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “新 `java.util.stream` 包中的类提供了 Stream API，以支持对元素流进行函数式操作。Stream API 集成到 Collections
    API 中，使得诸如顺序或并行 map-reduce 转换等操作成为可能。”
- en: You can read these statements (along with many others not related to functional
    programming) in Oracle’s original “What’s new in JDK 8” document ([http://mng.bz/27na](http://mng.bz/27na)).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Oracle 的原始“JDK 8 新特性”文档中阅读这些声明（以及许多与函数式编程无关的其他声明）([http://mng.bz/27na](http://mng.bz/27na))。
- en: 'In this presentation, Oracle didn’t list several elements and omitted one important
    fact:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次演示中，Oracle 没有列出几个元素，并省略了一个重要的事实：
- en: The `Function` package
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Function` 包'
- en: The `Optional` class
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Optional` 类'
- en: The `CompletableFuture` class
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletableFuture` 类'
- en: The fact that most collections were modified by adding the `stream()` method,
    making it possible to transform them into `Stream` instances.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事实是，大多数集合通过添加 `stream()` 方法进行了修改，这使得它们可以转换为 `Stream` 实例。
- en: All this, including the fact that `Optional`, `Stream`, and `CompletableFuture`
    are monadic structures (see [appendix B](kindle_split_024.xhtml#app02) for what
    this means) makes it very clear that Oracle’s intention was to make it easier
    to use Java for functional programming.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些，包括 `Optional`、`Stream` 和 `CompletableFuture` 都是单子结构（有关这意味着什么，请参阅附录 B [appendix
    B](kindle_split_024.xhtml#app02)）的事实，清楚地表明 Oracle 的意图是使使用 Java 进行函数式编程更容易。
- en: In this book, I made heavy use of some of these functional-friendly features,
    such as lambdas and functional interfaces, and I indirectly benefited from better
    type inference and extended type annotations. However, I didn’t use the other
    functional elements like `Optional` or `Stream`. In this appendix, I’ll explain
    why.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我大量使用了这些功能友好的特性，例如 lambda 表达式和函数式接口，并间接受益于更好的类型推断和扩展的类型注解。然而，我没有使用其他函数式元素，如
    `Optional` 或 `Stream`。在本附录中，我将解释原因。
- en: A.1\. The Optional class
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1\. `Optional` 类
- en: The `Optional` class is similar to the `Option` class you developed in [chapter
    6](kindle_split_013.xhtml#ch06). It’s supposed to solve the problem of the `null`
    reference, but it’s not a great help for functional programming. Obviously, something
    has been done wrong. The `Optional` class has a `get` method that will return
    the “enclosed” value if there is one, and `null` otherwise. Of course, calling
    this method defeats the original goal.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional` 类类似于你在第 6 章 [chapter 6](kindle_split_013.xhtml#ch06) 中开发的 `Option`
    类。它旨在解决 `null` 引用的问题，但对函数式编程帮助不大。显然，某些地方出了问题。`Optional` 类有一个 `get` 方法，如果有“封装”的值，它将返回该值，否则返回
    `null`。当然，调用此方法违背了原始目标。'
- en: 'If you want to use the `Optional` class, you should remember to *never* call
    `get`. You might object that the `Option` class has the `getOrThrow` method which,
    although never returning `null`, will throw an exception if no data is available.
    But this method is protected, and the class can’t be extended from outside. This
    makes a huge difference. This method is equivalent to the `head` or `tail` methods
    in `List`: they should *never* be called from outside.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用`Optional`类，你应该记住永远不要调用`get`。你可能会反对，因为`Option`类有`getOrThrow`方法，虽然它永远不会返回`null`，但如果没有数据可用，它将抛出异常。但这个方法是受保护的，并且不能从外部扩展这个类。这有很大的不同。这个方法与`List`中的`head`或`tail`方法等价：它们不应该从外部调用。
- en: 'Besides this, the `Optional` class suffers from the same limitations as `Option`:
    `Optional` can be used for truly optional data, but generally the absence of data
    is due to an error. `Optional`, like `Option`, doesn’t allow you to carry the
    error cause, so it’s only useful for truly optional data, which means when the
    cause for the absence of data is obvious, such as returning a value from a map,
    or the position of a character in a string. If the `get(key)` method of a map
    returns no value, whether it means `null` or an empty `Optional`, it should be
    obvious that the key wasn’t found. And if the `indexOf(char)` method returns no
    value or an empty `Optional`, it should mean that the character isn’t present
    in the string.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Optional`类与`Option`有相同的局限性：`Optional`可以用于真正的可选数据，但通常数据的缺失是由于错误。`Optional`，就像`Option`一样，不允许你携带错误原因，所以它只适用于真正的可选数据，这意味着当数据缺失的原因很明显时，例如从一个映射中返回一个值，或者字符串中字符的位置。如果映射的`get(key)`方法不返回值，无论是`null`还是空的`Optional`，都应该很明显，键没有找到。如果`indexOf(char)`方法不返回值或空的`Optional`，应该意味着字符不在字符串中。
- en: But even this isn’t true. The `get(key)` method of a map could return `null`
    because the `null` value was stored under that key. Or it could return no value
    because the key was `null` (provided `null` isn’t a valid key). The `indexOf(char)`
    method could also return no value for many reasons, such as a negative argument.
    Returning `Optional` in these cases wouldn’t indicate the nature of the error.
    Furthermore, this `Optional` would be difficult to compose with values returned
    by other methods that could produce errors.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 但即使是这样也不一定正确。映射的`get(key)`方法可能会返回`null`，因为`null`值被存储在那个键下。或者它可能不返回任何值，因为键是`null`（假设`null`不是一个有效的键）。`indexOf(char)`方法也可能因为许多原因不返回值，例如负数参数。在这些情况下返回`Optional`并不能表明错误的性质。此外，这个`Optional`与可能产生错误的其它方法返回的值组合起来会很困难。
- en: For all these reasons, `Optional`, like our version of `Option`, is useless.
    That’s why we developed the `Return` type, which you can use to represent the
    absence of optional data as well as errors.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有这些原因，`Optional`，就像我们的`Option`版本一样，是无用的。这就是我们开发`Return`类型的原因，你可以用它来表示可选数据的缺失以及错误。
- en: A.2\. Streams
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2\. 流
- en: 'Streams are another new element of Java 8 that mixes three different concepts:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 流是Java 8的另一个新元素，它混合了三个不同的概念：
- en: Lazy collections
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惰性集合
- en: Monadic collections
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单子集合
- en: Automatic parallelization
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动并行化
- en: These three concepts are independent, and there’s no obvious reason why they
    were mixed. Unfortunately, as with many other tools that are supposed to do several
    different things, they are less than optimal at each of them.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个概念是独立的，没有明显的理由说明为什么它们被混合在一起。不幸的是，就像许多其他旨在做几件不同事情的工具一样，它们在每个方面都不够理想。
- en: Monadic data structures are essential to functional programming, and Java collections
    aren’t monadic. You could create such structures by simply calling the newly added
    `stream()` method on such collections. That could be an acceptable solution if
    streams had all the necessary methods for functional processing. But streams were
    designed to make it possible to automatically switch from serial to parallel processing.
    Such a process is quite complex, and it’s probably the reason why some important
    methods weren’t implemented in streams. For example, Java 8 streams have no `takeWhile`
    or `dropWhile` methods.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 单子数据结构对于函数式编程至关重要，而Java集合不是单子的。你可以通过简单地在新添加的`stream()`方法上调用这些集合来创建这样的结构。如果流有所有必要的函数处理方法，这可能是一个可接受的解决方案。但流被设计成能够自动从串行切换到并行处理。这个过程相当复杂，这可能是为什么一些重要的方法没有在流中实现。例如，Java
    8流没有`takeWhile`或`dropWhile`方法。
- en: This might be an acceptable price to pay for access to automatic parallelization,
    but even this feature isn’t really usable. (This issue is addressed in Java 9.)
    All parallel streams use a single fork/join pool containing as many threads as
    there are physical threads available on the computer, minus one (the main thread).
    Tasks are distributed to waiting queues for each worker thread in the pool. Once
    a thread has exhausted its task queue, it “steals” work from other threads. The
    main thread itself participates by stealing work from worker threads.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一个为了获得自动并行化访问的合理代价，但即使这个特性实际上也不是真正可用的。（这个问题在Java 9中得到了解决。）所有并行流都使用一个包含与计算机上物理线程数量相同但减去一个（主线程）的线程数量的单个fork/join池。任务被分配到池中每个工作线程的等待队列中。一旦一个线程耗尽了其任务队列，它就会从其他线程“窃取”工作。主线程本身也通过从工作线程“窃取”工作来参与。
- en: The overall result isn’t optimal because, of course, the computer may have lots
    of other tasks to do at the same time. Think about a Java EE application receiving
    requests from clients. These requests are already processed in parallel, so there’s
    very little to gain from further parallelizing each request. Usually, in such
    a context, there will be no benefit at all.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 整体结果并不理想，因为当然，计算机可能还有许多其他任务要同时执行。想想一个Java EE应用程序正在接收来自客户端的请求。这些请求已经并行处理，所以进一步并行化每个请求几乎没有好处。通常，在这种情况下，将没有任何好处。
- en: 'Worse yet, because all parallel streams share the same fork/join pool, if one
    stream blocks, it might block all other streams! It’s possible to use a specific
    pool for each stream, but this is a bit complex, and it should be done only if
    you’re using pools of smaller sizes, meaning with fewer threads. If you’re interested
    in such techniques, take a look at the following articles I’ve posted on DZone:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，因为所有并行流共享同一个fork/join池，如果一个流阻塞，它可能会阻塞所有其他流！你可以为每个流使用一个特定的池，但这有点复杂，并且只有在使用较小大小的池（即较少的线程）时才应该这样做。如果你对这样的技术感兴趣，请查看我在DZone上发布的以下文章：
- en: '“What’s Wrong in Java 8, Part III: Streams and Parallel Streams” ([https://dzone.com/articles/whats-wrong-java-8-part-iii](https://dzone.com/articles/whats-wrong-java-8-part-iii))'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “Java 8中的问题，第三部分：流和并行流” ([https://dzone.com/articles/whats-wrong-java-8-part-iii](https://dzone.com/articles/whats-wrong-java-8-part-iii))
- en: '“What’s Wrong in Java 8, Part VII: Streams Again” ([https://dzone.com/articles/whats-wrong-java-8-part-vii](https://dzone.com/articles/whats-wrong-java-8-part-vii))'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “Java 8中的问题，第七部分：流再次出现” ([https://dzone.com/articles/whats-wrong-java-8-part-vii](https://dzone.com/articles/whats-wrong-java-8-part-vii))
- en: Probably the worst thing about Java 8 streams is that they’re usable only once.
    As soon as a terminal method has been called on them, they can no longer be used.
    Any further access will produce an exception. This has two consequences.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8流最糟糕的可能就是它们只能使用一次。一旦对它们调用了一个终端方法，它们就再也不能使用了。任何进一步的访问都会产生异常。这有两个后果。
- en: The first is that memoization isn’t possible. Instead of accessing a stream
    a second time, you can only create a new one. The result is that if the values
    were lazily evaluated, they’ll have to be evaluated again.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是无法进行记忆化。你无法像第二次访问流那样，只能创建一个新的流。结果是，如果值是延迟评估的，它们将不得不再次评估。
- en: 'The second consequence is even worse: Java 8 streams can’t be used in the comprehension
    pattern. Imagine you want to write a function to verify the Pythagorean relation
    a² + b² = c² using a `Triple` class implementation such as this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个后果甚至更糟：Java 8的流不能用于理解模式。想象一下，你想编写一个函数来验证毕达哥拉斯关系a² + b² = c²，使用类似于下面的`Triple`类实现：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In imperative Java, the `pyths` method could be implemented as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式Java中，`pyths`方法可以如下实现：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The “functional” version, using streams, should look like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: “功能”版本，使用流，应该看起来像这样：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Unfortunately, in Java 8, this will produce the following exception:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在Java 8中，这将产生以下异常：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By contrast, you can write this example using the `List` class you developed
    in [chapter 5](kindle_split_012.xhtml#ch05).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，你可以使用你在[第5章](kindle_split_012.xhtml#ch05)中开发的`List`类来编写这个示例。
- en: 'Another limitation of Java 8 streams is that folding is a terminal operation,
    meaning that a fold (called `reduce` in Java 8 streams) will cause the evaluation
    of all stream elements. To understand the difference, recall the `Stream.foldRight`
    method you developed in [chapter 9](kindle_split_016.xhtml#ch09). With this method,
    you could write an implementation of the `identity` function as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 流的另一个限制是折叠是一个终端操作，这意味着折叠（在 Java 8 流中称为 `reduce`）将导致评估所有流元素。为了理解差异，回想一下你在第
    9 章中开发的 `Stream.foldRight` 方法。使用此方法，你可以编写如下 `identity` 函数的实现：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This method was totally lazy, which allowed you to use it to implement methods
    such as `map`, `flatMap`, and many others. This is completely impossible with
    Java 8 streams.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法完全惰性，允许你用它来实现 `map`、`flatMap` 以及许多其他方法。这在 Java 8 流中是完全不可能的。
- en: Does this mean that you should never use Java 8 streams? Absolutely not. Java
    8 streams are a good choice to complement imperative programs when performance
    is the most important criterion, especially when you need to deal with primitives.
    Parallel streams, however, should generally be avoided in production contexts.
    And for most functional uses, truly functional streams are a better choice.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着你永远不应该使用 Java 8 流？绝对不是。Java 8 流在性能是最重要的标准时是一个很好的选择，尤其是在你需要处理原始数据时。然而，在生产环境中，通常应避免使用并行流。对于大多数函数式使用，真正的函数式流是一个更好的选择。
- en: 'If you want (or need) to use Java 8 `Stream` in a functional context, be aware
    that although the `Stream` type has a `reduce` method (in fact, three versions
    of this method) that is supposed to be used for folding, it’s not the best way
    to fold a stream. Folding should be done with a `Collector` implementation. `Collector`
    is an interface that defines five methods:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要（或需要）在函数式上下文中使用 Java 8 `Stream`，请注意，尽管 `Stream` 类型有一个 `reduce` 方法（实际上有三个版本的这个方法）用于折叠，但这并不是折叠流的最佳方式。折叠应该使用
    `Collector` 实现来完成。`Collector` 是一个接口，它定义了五个方法：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `supplier` method returns a `Supplier<A>` for the identity element. The
    `accumulator` method returns a `BiConsumer<A, T>`, which is the nonfunctional
    replacement for the folding function. The corresponding folding function would
    be `BiFunction <A, T, A>`, which combines an element with the current result.
    Instead of returning the result, the consumer is supposed to store it somewhere
    (in the `Collector`). In other words, it’s a state-mutation-based version of a
    fold. The `finisher` is an optional function that will be applied to the final
    result. Finally, `characteristics` returns a set of characteristics of the `Collector`
    used to optimize its work. There are three possible characteristics—`CONCURRENT`,
    `IDENTITY_FINISH`, and `UNORDERED`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`supplier` 方法返回一个 `Supplier<A>` 用于身份元素。`accumulator` 方法返回一个 `BiConsumer<A,
    T>`，这是折叠函数的非功能性替代品。相应的折叠函数将是 `BiFunction <A, T, A>`，它将一个元素与当前结果组合。而不是返回结果，消费者应该将其存储在某个地方（在
    `Collector` 中）。换句话说，它是一个基于状态变异的折叠版本。`finisher` 是一个可选函数，它将在最终结果上应用。最后，`characteristics`
    返回 `Collector` 使用的特征集，用于优化其工作。有三个可能的特征——`CONCURRENT`、`IDENTITY_FINISH` 和 `UNORDERED`：'
- en: '`CONCURRENT` means that the `accumulator` function supports concurrency and
    may be used by several threads.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONCURRENT` 表示 `accumulator` 函数支持并发，可以被多个线程使用。'
- en: '`IDENTITY_FINISH` means that the `finisher` function is the identity and can
    thus be ignored.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IDENTITY_FINISH` 表示 `finisher` 函数是身份函数，因此可以被忽略。'
- en: '`UNORDERED` means that the stream is unordered, which allows more freedom for
    parallelization.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UNORDERED` 表示流是无序的，这为并行化提供了更多自由。'
- en: 'Here’s an example of a `Collector` for folding a `Stream<String>` into a `List<List<String>>`,
    simulating the grouping of words on lines of a given maximum length. First, you
    define a generic `GroupingCollector`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个将 `Stream<String>` 折叠成 `List<List<String>>` 的 `Collector` 示例，模拟了给定最大长度行上的单词分组。首先，你定义一个泛型的
    `GroupingCollector`：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, you create a specific grouping collector for strings:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你创建一个特定的字符串分组收集器：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, you can create the client code for testing the collector:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以创建客户端代码来测试收集器：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This program prints the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序打印以下内容：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The principle is exactly the same as for a fold, abstracting the iteration over
    the stream elements.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 原则与折叠操作完全相同，抽象了流元素迭代的迭代过程。
