- en: 9 Adding a content management system
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 添加内容管理系统
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: The pros and cons of the two types of headless CMSs
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两种类型无头CMS的优缺点
- en: Choosing between the Contentful and Sanity API-based headless CMSs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Contentful和Sanity API基于的无头CMS之间进行选择
- en: Using WordPress as a headless CMS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用WordPress作为无头CMS
- en: Building a site using Gatsby’s WordPress integration
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Gatsby的WordPress集成构建网站
- en: Using site builders to create Jamstack sites connected to a CMS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用网站构建器创建与CMS连接的Jamstack网站
- en: Jamstack is often associated with a file-based content management system that
    uses a combination of manually edited Markdown and YAML files. That’s because
    many static site generators default to this type of manual content management,
    even today. But the reality is that some form of headless content management system
    has become a de facto integration in most Jamstack sites.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Jamstack通常与基于文件的文件内容管理系统相关联，该系统使用手动编辑的Markdown和YAML文件的组合。这是因为许多静态网站生成器默认使用这种手动内容管理，即使今天也是如此。但现实是，某种形式的无头内容管理系统已成为大多数Jamstack网站的事实上的集成。
- en: '[Jamstack.org](https://jamstack.org/) maintains a list of headless CMSs ([https://jamstack.org/headless-cms](https://jamstack.org/headless-cms))
    that you can search by type and license (i.e., whether they are open or closed
    source). Currently, it lists 87 options. Needless to say, that’s a lot of choices
    and more than we can cover in a chapter. Instead, we’ll look at the different
    types of headless CMS available and then explore some options to give you a sense
    of how their approaches differ and to help you make informed choices about what
    you are looking for.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[Jamstack.org](https://jamstack.org/) 维护了一个无头CMS列表（[https://jamstack.org/headless-cms](https://jamstack.org/headless-cms)），你可以通过类型和许可证（即它们是开源还是闭源）进行搜索。目前，它列出了87个选项。不用说，这有很多选择，远远超出了我们在一章中能涵盖的范围。相反，我们将探讨不同类型的无头CMS，然后探索一些选项，以给你一个了解它们方法差异的感觉，并帮助你做出明智的选择。'
- en: 9.1 Types of headless CMSs
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1 无头CMS的类型
- en: 'As we discussed in chapter 4, there are two broad types of headless CMS:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第4章中讨论的，有两种广泛类型的无头CMS：
- en: '*Git-based headless CMSs*—These CMSs store everything as files in a Git repository.
    The CMS is an editing layer that allows the user to edit the Markdown, JSON, and
    YAML files containing the site’s content via a browser-based what-you-see-is-what-you-get
    (WYSIWYG)-style interface. In many cases, these editing layers are deployed with
    the site’s files or exist locally on the user’s machine. The user’s changes are
    committed back to the Git repository by the CMS. Git handles versioning the content.
    Since changes are committed to Git, deploying content typically happens as part
    of whatever continuous deployment process was set up for the site. For example,
    Netlify will detect changes to the repository and automatically build and deploy
    the updated content.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于Git的无头CMS*—这些CMS将所有内容都存储在Git仓库中的文件中。CMS是一个编辑层，允许用户通过基于浏览器的所见即所得（WYSIWYG）风格界面编辑包含网站内容的Markdown、JSON和YAML文件。在许多情况下，这些编辑层与网站的文件一起部署，或者存在于用户的机器上。用户的更改由CMS提交回Git仓库。Git处理内容的版本控制。由于更改提交到Git，部署内容通常作为为网站设置的任何持续部署过程的一部分进行。例如，Netlify将检测仓库中的更改，并自动构建和部署更新的内容。'
- en: '*API-based headless CMSs*—These CMSs store content within their systems. This
    is similar to a traditional CMS, but the system does not have a frontend; instead,
    content is only accessible via an API. Content editing is typically performed
    via an admin dashboard on the CMS provider’s site. For example, if a site used
    Contentful, a popular API-based headless CMS, the site’s content editors would
    log in at [contentful.com](https://www.contentful.com/) to make changes to the
    content. When a user makes a change to a Jamstack site’s content, Jamstack usually
    needs to trigger a rebuild via a web hook connected to the site’s continuous deployment
    process. The user does not need to wait for the rebuild to complete in order to
    view and test their changes. Most API-based headless CMSs have a live preview
    feature that can display unpublished content changes on a Jamstack site built
    with popular frontend frameworks like React or Vue.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于API的无头 CMS*—这些CMS在其系统中存储内容。这类似于传统的CMS，但系统没有前端；相反，内容只能通过API访问。内容编辑通常通过CMS提供商网站上的管理仪表板进行。例如，如果一个网站使用了Contentful，一个流行的基于API的无头CMS，该网站的内容编辑将登录到[contentful.com](https://www.contentful.com/)以更改内容。当用户更改Jamstack网站的内容时，Jamstack通常需要通过连接到网站持续部署过程的web
    hook触发重建。用户不需要等待重建完成就可以查看和测试他们的更改。大多数基于API的无头CMS都有一个实时预览功能，可以在使用React或Vue等流行前端框架构建的Jamstack网站上显示未发布的内容更改。'
- en: What is a web hook? Build hook? Deploy hook?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是web hook？构建hook？部署hook？
- en: A *web hook* is defined as a user-defined callback that is sent via HTTP. Essentially,
    an application will call an endpoint, frequently passing some data, in response
    to an event. For example, a headless CMS will often allow you to configure a web
    hook to be called when a change is made to the published content.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*web hook*被定义为通过HTTP发送的用户定义的回调。本质上，一个应用程序将调用一个端点，通常传递一些数据，作为对事件的响应。例如，一个无头CMS通常会允许你配置一个web
    hook，以便在发布内容发生变化时被调用。'
- en: A *build hook* (as Netlify calls it) or *deploy hook* (as Vercel calls it) is
    a specialized web hook endpoint that can be called via an HTTP POST request, which
    triggers a rebuild of the specified site on the deployment provider. You can use
    a combination of a web hook, at your headless CMS provider, and a build hook,
    at your deployment provider, to trigger a site rebuild when a change is made in
    the CMS to the published content of the site, thus incorporating the new content
    into the published site.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*构建hook*（Netlify这样称呼它）或*部署hook*（Vercel这样称呼它）是一个专门的web hook端点，可以通过HTTP POST请求调用，从而触发在部署提供商上指定网站的重建。你可以结合使用你的无头CMS提供商的web
    hook和你的部署提供商的构建hook，当在CMS中对网站的发布内容进行更改时触发网站重建，从而将新内容纳入发布网站。'
- en: Which type should you choose for your project? That depends on your specific
    needs, but here are some guidelines.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该为你的项目选择哪种类型？这取决于你的具体需求，但以下是一些指导方针。
- en: 9.1.1 Pros and cons of Git-based headless CMSs
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.1 基于 Git 的无头 CMS 的优缺点
- en: 'Pros:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: '*They’re* *inexpensive*. Since they rely on a Git repository for all the storage
    and versioning of content, Git-based headless CMSs are usually inexpensive or,
    in some cases, completely free and/or open source.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*它们* *很便宜*。由于它们依赖于Git存储库来存储和版本控制所有内容，基于Git的无头CMS通常很便宜，在某些情况下，完全免费和/或开源。'
- en: '*They’re very easy to set up*. Integration frequently consists of ensuring
    that the editing layer understands the form (i.e., content model) of the content
    in your files. For example, you may need to tell it what types of data are in
    the front matter for Markdown files or the type of data in your JSON and YAML
    data files, although some systems will even attempt to auto-detect these.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*它们非常容易设置*。集成通常包括确保编辑层理解你文件中的内容形式（即内容模型）。例如，你可能需要告诉它Markdown文件的前置部分包含哪些类型的数据或你的JSON和YAML数据文件中的数据类型，尽管一些系统甚至尝试自动检测这些。'
- en: '*They have a short learning curve*. Because they are file-based, they are generally
    easier for content editors to learn, as data models are typically not as complex
    as those of their API-based alternatives.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*他们有一个很短的学习曲线*。因为它们是基于文件的，所以对于内容编辑来说通常更容易学习，因为数据模型通常没有它们的基于API的替代品那么复杂。'
- en: '*They offer easy paths for external contributions*. Third-party contributors
    can get access to editing content directly through the CMS via features such as
    open authoring in Netlify CMS, for example, or can make direct file edits via
    the Git repository on a site like GitHub or GitLab. This can be an especially
    important consideration for things like documentation sites, as we explored in
    chapter 4.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*它们提供了外部贡献的简单路径*。第三方贡献者可以通过Netlify CMS等CMS中的开放作者功能直接访问编辑内容，或者可以通过GitHub或GitLab等网站上的Git存储库直接进行文件编辑。这对于像文档站点这样的内容来说尤其重要，正如我们在第4章中探讨的那样。'
- en: '*They’re not proprietary*. All of your content is stored in files in your own
    Git repository, meaning that you can easily swap to another Git-based CMS solution
    without any direct impact on your site’s code or content.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*它们不是专有的*。您的内容存储在您自己的Git存储库中的文件中，这意味着您可以轻松地切换到另一个基于Git的CMS解决方案，而不会对您站点的代码或内容产生直接影响。'
- en: 'Cons:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: '*Content reuse is limited*. Content in a Git-based headless CMS is generally
    specific to the web, meaning content can be difficult to reuse across a website
    and mobile app, for instance. In addition, content reuse across the site itself
    is limited. For example, I may have a marketing headline and tagline that gets
    used in multiple locations on a site, but this kind of reuse is usually not possible
    with a Git-based CMS.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内容重用有限*。基于Git的头无头CMS中的内容通常仅针对Web，这意味着内容在网站和移动应用等跨平台重用可能很困难。此外，网站本身的内容重用也有限。例如，我可能有一个在网站多个位置使用的营销标题和口号，但这类重用通常无法使用基于Git的CMS实现。'
- en: '*Data models are difficult to enforce*. Since the content is file-based, direct
    changes to the files in the Git repository can break the data model’s integrity,
    potentially causing the build to fail. For instance, the CMS may require that
    every blog post have an author defined in the front matter, but this cannot be
    enforced on direct file changes in the repository. If someone were to manually
    change the file and remove the author field, the site build would likely break.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据模型难以强制执行*。由于内容是基于文件的，直接更改Git存储库中的文件可能会破坏数据模型的完整性，可能导致构建失败。例如，CMS可能要求每个博客文章在front
    matter中定义作者，但在存储库的直接文件更改中无法强制执行这一点。如果有人手动更改文件并删除作者字段，网站构建可能会失败。'
- en: '*Content relationships are difficult to maintain*. Most Git-based CMSs have
    a way of defining the relationship between two pieces of content. For example,
    a blog post could be related to an author page with an author name and bio. However,
    there is generally no way to enforce these relationships, meaning that someone
    could remove the author page even though the posts assigned to it still exist.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内容关系难以维护*。大多数基于Git的CMS都有一种定义两块内容之间关系的方式。例如，一篇博客文章可能与一个作者页面相关联，该页面包含作者姓名和简介。然而，通常没有强制执行这些关系的方法，这意味着即使分配给它的帖子仍然存在，也可能有人删除作者页面。'
- en: 9.1.2 Pros and cons of API-based headless CMSs
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.2 基于API的无头CMS的优缺点
- en: 'Pros:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: '*They’re* *designed for content reuse*. This means both reusing content across
    multiple properties, including multiple sites or a site and a mobile app, and
    across the same site. To enable content reuse across different types of applications
    (e.g., mobile app and web app), API-based headless CMSs generally separate the
    content from the presentation (i.e., the content is not stored in HTML or formats
    like Markdown that only generate HTML). This allows the content to be used across
    different types of applications or different parts of the same application without
    worrying about how the content is displayed.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*它们* *是为内容重用而设计的*。这意味着在多个属性之间重用内容，包括多个网站或网站和移动应用，以及同一网站。为了在不同类型的应用程序（例如，移动应用和Web应用）之间实现内容重用，基于API的无头CMS通常将内容与表示（即内容不存储在HTML或Markdown等仅生成HTML的格式中）分离。这使得内容可以在不同类型的应用程序或同一应用程序的不同部分中使用，而无需担心内容的显示方式。'
- en: '*They enforce data integrity of the content*. The content model can be designed
    to ensure not just that a content type always has certain fields, but that those
    fields contain the proper values. For example, I may want to ensure that a property
    of a content item is a number but also within a specific number range. The CMS
    provides tools for defining field validation that ensure the values are correct
    before a user is able to publish an item.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*它们确保内容完整性*。内容模型可以被设计成不仅确保内容类型始终包含某些字段，而且这些字段包含正确的值。例如，我可能想要确保内容项的一个属性是数字，但同时也位于特定的数字范围内。CMS提供了定义字段验证的工具，确保在用户能够发布项目之前，值是正确的。'
- en: '*They enforce content relationships*. Enforcing content relationships makes
    them easy to maintain. For example, it can ensure that a post always has an author
    and disallow removing an author that is assigned to published posts. The CMS is
    designed to prevent the removal of content that would damage the integrity of
    any references. The references would have to be removed or modified before the
    content could be deleted. They can also allow relationships within rich text or
    structured content, which are types of content that allow both rich formatting
    that isn’t tied to HTML and embedding of reusable content items defined within
    the CMS.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*它们强制执行内容关系*。强制执行内容关系使得它们易于维护。例如，它可以确保帖子始终有一个作者，并禁止删除分配给已发布帖子的作者。CMS被设计成防止删除会损害任何引用完整性的内容。在删除内容之前，必须删除或修改引用。它们还可以允许在富文本或结构化内容中建立关系，这些内容类型允许与HTML无关的丰富格式化以及嵌入在CMS中定义的可重复使用的内容项。'
- en: '*They can handle a complex content workflow*. Git-based CMS systems usually
    only support a very basic workflow, but API-based systems can typically handle
    even complex and custom approval workflows for content.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*它们可以处理复杂的内容工作流程*。基于Git的CMS系统通常只支持非常基本的工作流程，但基于API的系统通常可以处理甚至复杂和定制的审批工作流程。'
- en: 'Cons:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: '*They can be expensive*. Many of these solutions are priced for companies,
    not individual developers. While they may have generous free tiers, the pricing
    can often escalate quickly.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*它们可能很昂贵*。许多这些解决方案是为公司定价的，而不是为个人开发者定价。虽然它们可能有慷慨的免费层，但定价可能很快就会上升。'
- en: '*They often have steep learning curves*. Since these are designed to meet the
    needs of even large enterprises, they are often full of features that can make
    them a bit complex for the average content editor.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*它们通常有陡峭的学习曲线*。由于这些是为满足甚至大型企业的需求而设计的，它们通常充满了可能使它们对普通内容编辑员来说有点复杂的特性。'
- en: '*They are proprietary*. There is a built-in vendor lock-in, largely because
    moving from one system to the other can be a complex and expensive project to
    undertake. This involves not only moving the content from one proprietary system
    to another, including data models, users, validation rules, and workflow. It also
    will involve major modifications to the site’s code, pulling out the SDK and/or
    completely overhauling the API calls that get content.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*它们是专有的*。存在内置的供应商锁定，很大程度上是因为从一个系统迁移到另一个系统可能是一个复杂且昂贵的项目。这不仅包括将内容从专有系统迁移到另一个系统，包括数据模型、用户、验证规则和工作流程。还可能涉及对网站代码的重大修改，提取SDK和/或完全重写获取内容的API调用。'
- en: 9.2 Exploring popular headless CMSs
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2 探索流行的无头CMS
- en: Since we discussed the popular Git-based headless CMS in chapter 4, let’s explore
    some of the widely used API-based solutions. We’ll also look at some options to
    get started implementing them in some of the SSGs discussed throughout this book,
    although a full discussion of how to implement each headless CMS in each specific
    SSG is outside the scope of this chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在第4章讨论了流行的基于Git的无头CMS，让我们探索一些广泛使用的基于API的解决方案。我们还将查看一些选项，以在本书中讨论的一些静态站点生成器（SSG）中开始实施它们，尽管如何在每个特定的SSG中实现每个无头CMS的完整讨论超出了本章的范围。
- en: Comparing headless CMS options
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 比较无头CMS选项
- en: The list of headless CMSs on Jamstack’s website ([https://jamstack.org/headless-cms](https://jamstack.org/headless-cms))
    is a very comprehensive list of headless CMS options, but it may not offer enough
    detail to help you make a choice. Thankfully, the folks at Bejamas, a Jamstack
    consultancy, launched a project they call the Discover Hub ([https://bejamas.io/discovery](https://bejamas.io/discovery)).
    It offers extremely detailed reviews of 24 different headless options (as well
    as other categories of tools and services, including SSGs and hosting). Definitely
    check it out when making a choice.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Jamstack网站上的无头CMS列表（[https://jamstack.org/headless-cms](https://jamstack.org/headless-cms)）是一个非常全面的头无CMS选项列表，但它可能不会提供足够的细节来帮助您做出选择。幸运的是，Bejamas（一家Jamstack咨询公司）的同事们启动了一个名为Discover
    Hub（[https://bejamas.io/discovery](https://bejamas.io/discovery)）的项目。它提供了对24种不同头无选项的极其详细的评估（以及其他类别工具和服务，包括SSG和托管）。在做出选择时，绝对要查看它。
- en: The first step in using any headless CMS is building a content model. Let’s
    look at how you’d build a content model in two different headless CMS options
    that have two distinctly different approaches in order to give you a sense of
    the different options available to you.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任何无头CMS的第一步是构建内容模型。让我们看看您如何在两种具有截然不同方法的头无CMS选项中构建内容模型，以便给您一个关于您可用的不同选项的感觉。
- en: 9.2.1 Contentful
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.1 Contentful
- en: In my opinion, one of the strongest selling points of Contentful ([https://www.contentful.com/](https://www.contentful.com/))
    is the ease with which you can define a content model. Its web-based visual interface
    is easy enough to use that the content model could be built by a nontechnical
    user.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，Contentful（[https://www.contentful.com/](https://www.contentful.com/)）最强大的卖点之一是定义内容模型的简便性。其基于Web的视觉界面足够易于使用，以至于非技术用户也可以构建内容模型。
- en: Once you’ve logged into Contentful, you’ll need to create your first “space.”
    This is how Contentful groups projects. In the case of a Jamstack project, one
    space might be the backend for one site. However, a space can technically serve
    as the backend to any logical grouping of sites and apps. Keep in mind that Contentful
    currently provides only one limited space under its free plan.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您登录到Contentful，您需要创建您的第一个“空间”。这是Contentful分组项目的方式。在Jamstack项目的案例中，一个空间可能是一个站点的后端。然而，从技术上讲，空间可以作为任何逻辑分组站点和应用的后端。请注意，Contentful目前在其免费计划下仅提供一种有限的“空间”。
- en: Once you’ve created a space, you’ll need to add content types. Under the Content
    Model heading, click the blue Add content type button. This will open a window
    to give your type a name and an API identifier and description. The name can be
    anything you like. The API identifier is essentially a slug for your content type
    and will generate automatically, though you can customize it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 创建空间后，您需要添加内容类型。在“内容模型”标题下，点击蓝色的“添加内容类型”按钮。这将打开一个窗口，让您为类型命名、提供API标识符和描述。名称可以是您喜欢的任何内容。API标识符实际上是您内容类型的缩写，将自动生成，尽管您可以自定义它。
- en: Once you’ve created a type, you’ll need to add fields to it. Every field must
    be assigned one of nine different types. Within Contentful’s system, each type
    has a limited set of validations that can be applied to them (figure 9.1).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 创建类型后，您需要向其中添加字段。每个字段都必须分配九种不同类型之一。在Contentful系统中，每种类型都有可应用于它们的有限验证集合（如图9.1所示）。
- en: '![CH09_F01_Camden2](Images/CH09_F01_Camden2.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F01_Camden2](Images/CH09_F01_Camden2.png)'
- en: Figure 9.1 The nine different types of fields that Contentful provides
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 Contentful提供的九种不同类型的字段
- en: '*Rich text*—It is important to note that this is not HTML, but rather the rich
    content stored in a JSON format that allows it to be converted to whatever format
    needed. This allows rich text to include embedded assets and entries within the
    rich text format. For the content creator, this will look and feel much like a
    standard WYSIWYG editing experience. There are quite a few validation options
    beyond simply making it required or limited to a specific character count, all
    of which relate to embedded links, entries, or assets.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*富文本*——重要的是要注意，这并不是HTML，而是一种存储在JSON格式中的富内容，它允许将其转换为所需的任何格式。这允许富文本包含嵌入的资产和富文本格式内的条目。对于内容创建者来说，这看起来和感觉就像是一个标准的WYSIWYG编辑体验。除了简单地使其成为必需的或限制特定字符数之外，还有许多验证选项，所有这些都与嵌入的链接、条目或资产相关。'
- en: '*Text*—There are two types of standard text fields in Contentful: short text
    that is limited to 255 characters and long text of up to 50,000 characters. You
    can sort short-text fields and search for exact matches; while you cannot sort
    on a long-text field you can do a full-text search. Long text is primarily for
    the long-form content of an item, such as the blog post body or the author bio
    (either can be rich text as well). If you are storing Markdown content, you will
    use a long-text rather than rich-text field. The validation options include things
    like ensuring the text field matches a specific pattern (e.g., an email or a URL)
    or prohibiting specific patterns (e.g., preventing the use of swear words).'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文本*—Contentful中有两种标准文本字段：短文本，限制为255个字符，和长达50,000个字符的长文本。你可以对短文本字段进行排序并搜索精确匹配；而你不能对长文本字段进行排序，但你可以进行全文搜索。长文本主要用于项的长篇内容，如博客文章正文或作者简介（两者都可以是富文本）。如果你正在存储Markdown内容，你将使用长文本字段而不是富文本字段。验证选项包括确保文本字段与特定模式匹配（例如，电子邮件或URL）或禁止特定模式（例如，防止使用脏话）。'
- en: '*Number*—This can be either an integer or a decimal. Validation can require
    that the value be unique (no two entries can have the same number), must be within
    a specific range, or can accept only specific values.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数字*—这可以是整数或小数。验证可以要求值是唯一的（没有两个条目可以具有相同的数字），必须在特定范围内，或者只能接受特定值。'
- en: '*Date*—Date does not have many options or validations, although you can limit
    it to dates within a specific range.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*日期*—日期没有很多选项或验证，尽管你可以将其限制在特定范围内。'
- en: '*Location*—This will be stored as latitude and longitude within Contentful,
    although content editors will be able to choose a location by address or location
    on a map. The only validation offered is to make this required.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*位置*—这将在Contentful中以纬度和经度的形式存储，尽管内容编辑可以通过地址或地图上的位置选择位置。提供的唯一验证是使其成为必填项。'
- en: '*Media*—This is any type of media you’d upload, such as images or PDFs. You
    can choose to allow a single file or multiple files to be uploaded. Validation
    allows you to specify file size limits, accept only specific types of files, or
    limit image uploads to specific dimensions.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*媒体*—这是你可以上传的任何类型的媒体，例如图片或PDF文件。你可以选择允许上传单个文件或多个文件。验证允许你指定文件大小限制，仅接受特定类型的文件，或限制图像上传到特定尺寸。'
- en: '*Boolean*—This is a basic yes/no response. The only validation that can be
    set is to make it required.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*布尔值*—这是一个基本的“是/否”响应。可以设置的唯一验证是使其成为必填项。'
- en: '*JSON object*—This allows the content editor to directly write a JSON object
    via a JSON editor. JSON validation is built into the editor. You can limit the
    number of properties the JSON object has via the validation.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JSON对象*—这允许内容编辑通过JSON编辑器直接编写JSON对象。JSON验证内置在编辑器中。你可以通过验证限制JSON对象具有的属性数量。'
- en: '*Reference*—This is a relationship to another content item within Contentful.
    For instance, a blog post may reference its author or authors. You can have a
    reference to a single item (a one-to-one relationship) or multiple items (a one-to-many
    relationship). Validation allows you to limit the option to a specific type (e.g.,
    the author relationship would limit you to choosing content items of the author
    type).'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*参考*—这是Contentful中与其他内容项之间的关系。例如，一篇文章可能引用其作者或作者们。你可以有一个对单个项（一对一关系）或多个项（一对多关系）的引用。验证允许你将选项限制为特定类型（例如，作者关系将限制你选择作者类型的内容项）。'
- en: Once you’ve built a content model, you and/or your content editors can begin
    adding content items to Contentful via the content editor, as shown in figure
    9.2.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你构建了内容模型，你和你/你的内容编辑就可以通过内容编辑器开始向Contentful添加内容项，如图9.2所示。
- en: '![CH09_F02_Camden2](Images/CH09_F02_Camden2.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F02_Camden2](Images/CH09_F02_Camden2.png)'
- en: Figure 9.2 Editing content for a “blog post” content type within the Contentful
    admin UI
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 在Contentful管理UI中编辑“博客文章”内容类型的内容
- en: 'Contentful offers seven different APIs ([http://mng.bz/raAe](https://shortener.manning.com/raAe))
    for retrieving and managing content and assets. For the purposes of pulling data
    for the frontend of a Jamstack site, you’ll be primarily interested in three:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Contentful提供了七个不同的API（[http://mng.bz/raAe](https://shortener.manning.com/raAe)）用于检索和管理内容和资产。对于从Jamstack网站的前端拉取数据的目的，你将主要对以下三个API感兴趣：
- en: The Content Delivery API is a REST API that only allows you to retrieve published
    content. This is the primary API that you’ll use to pull content from when generating
    static pages for the published site. (See [http://mng.bz/VlmW](http://mng.bz/VlmW)
    for more details.)
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容交付 API 是一个 REST API，它只允许您检索已发布的内容。这是您在为已发布网站生成静态页面时将用于拉取内容的 API。（有关更多详细信息，请参阅
    [http://mng.bz/VlmW](http://mng.bz/VlmW)。）
- en: The Content Preview API is a REST API that allows you to pull unpublished changes
    to content. This is important to allow content editors to view what their changes
    to content will look like on the live site via a preview version of the site available
    at a different URL or available to logged-in users on the main site, for example.
    (See [http://mng.bz/xvAg](http://mng.bz/xvAg) for more details.)
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容预览 API 是一个 REST API，允许您拉取内容的不发布更改。这对于允许内容编辑通过预览版本查看其内容更改在实时网站上的外观非常重要，例如，在另一个
    URL 上可用的网站预览版本或主网站上登录用户可用的版本。（有关更多详细信息，请参阅 [http://mng.bz/xvAg](http://mng.bz/xvAg)。）
- en: The GraphQL Content API is a GraphQL API that allows you to retrieve both published
    and unpublished content. This can take the place of the REST APIs, provided you
    are comfortable working with GraphQL. (See [http://mng.bz/ Ax7g](http://mng.bz/Ax7g)
    for more details.)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL 内容 API 是一个 GraphQL API，允许您检索已发布和未发布的内容。如果您对 GraphQL 工作感到舒适，这可以替代 REST
    API。（有关更多详细信息，请参阅 [http://mng.bz/ Ax7g](http://mng.bz/Ax7g)。）
- en: In most cases you probably won’t be directly interacting with the API and will
    be using one of Contentful’s provided SDKs ([http://mng.bz/Zzv5](http://mng.bz/Zzv5))
    instead. For instance, you can integrate the JavaScript SDK ([http://mng.bz/mxAM](https://www.contentful.com/developers/docs/javascript/))
    with SSGs like Eleventy or Next.js. Gatsby already has a gatsby-source-contentful
    ([http://mng.bz/5KRD](https://www.gatsbyjs.com/plugins/gatsby-source-contentful/))
    plug-in that is already designed to work with the GraphQL content API to enable
    both published and preview content. Next.js has an example that you can use as
    a starter ([http://mng.bz/6ZR6](https://github.com/vercel/next.js/tree/canary/examples/cms-contentful)).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，您可能不会直接与 API 交互，而是会使用 Contentful 提供的其中一个 SDK ([http://mng.bz/Zzv5](http://mng.bz/Zzv5))。例如，您可以将
    JavaScript SDK ([http://mng.bz/mxAM](https://www.contentful.com/developers/docs/javascript/))
    与像 Eleventy 或 Next.js 这样的 SSG 集成。Gatsby 已经有一个名为 gatsby-source-contentful ([http://mng.bz/5KRD](https://www.gatsbyjs.com/plugins/gatsby-source-contentful/))
    的插件，它已经设计好可以与 GraphQL 内容 API 一起工作，以启用已发布和预览内容。Next.js 有一个您可以用作起点的示例 ([http://mng.bz/6ZR6](https://github.com/vercel/next.js/tree/canary/examples/cms-contentful))。
- en: Integrating with other traditional SSGs, like Hugo or Jekyll, requires a different
    approach since neither has a method for directly fetching content from an API
    nor for generating pages. However, there are tools that can provide ways to import
    your Contentful content into these tools. Contentful has a jekyll-contentful-data-import
    ([http://mng.bz/oaAv](https://github.com/contentful/jekyll-contentful-data-import))
    gem that can be used to import content into Jekyll. For Hugo, there is a contentful-hugo
    npm package ([http://mng.bz/nYA4](https://www.npmjs.com/package/contentful-hugo))
    that will pull all your Contentful content and convert it to Markdown.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与像 Hugo 或 Jekyll 这样的其他传统静态站点生成器（SSG）集成，需要采取不同的方法，因为它们都没有直接从 API 获取内容或生成页面的方法。然而，有一些工具可以提供将您的
    Contentful 内容导入这些工具的方法。Contentful 提供了一个名为 jekyll-contentful-data-import ([http://mng.bz/oaAv](https://github.com/contentful/jekyll-contentful-data-import))
    的 gem，可以用来将内容导入 Jekyll。对于 Hugo，有一个名为 contentful-hugo 的 npm 包 ([http://mng.bz/nYA4](https://www.npmjs.com/package/contentful-hugo))，它将拉取您所有的
    Contentful 内容并将其转换为 Markdown。
- en: 9.2.2 Sanity
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.2 Sanity
- en: The experience of building a content model in Sanity is completely different
    from that of Contentful. Whereas Contentful primarily relies on its web-based
    GUI for building content models, Sanity’s content models are defined entirely
    in JavaScript code and managed via the Sanity CLI. (See table 9.1 for a comparison
    of the content types of Contentful and Sanity.)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Sanity 中构建内容模型的经验与 Contentful 完全不同。Contentful 主要依赖于其基于 Web 的 GUI 来构建内容模型，而
    Sanity 的内容模型完全由 JavaScript 代码定义并通过 Sanity CLI 管理。（有关 Contentful 和 Sanity 内容类型的比较，请参阅表
    9.1。）
- en: Table 9.1 Comparing the different content types available within Contentful
    and Sanity
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.1 比较Contentful和Sanity中可用的不同内容类型
- en: '| Content Type Description | Contentful Type | Sanity Type(s) |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 内容类型描述 | Contentful 类型 | Sanity 类型(s) |'
- en: '| Rich text, including HTML formatting, plus embedded content | Rich text |
    Block |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 包含 HTML 格式化和嵌入内容的富文本 | 富文本 | 块 |'
- en: '| A Boolean or true/false | Boolean | Boolean |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 布尔值或真/假 | Boolean | Boolean |'
- en: '| Raw text, Markdown, URLs, slugs, JSON | TextJSON | StringTextSlugURL |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 原始文本、Markdown、URL、短名、JSON | 文本JSON | 字符串文本JSON短名URL |'
- en: '| Numbers, including integers and decimals | Number | Number |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 数字，包括整数和小数 | 数字 | 数字 |'
- en: '| Dates or dates with time | Date | DateDatetime |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 日期或带时间的日期 | 日期 | 日期日期时间 |'
- en: '| A location determined by latitude and longitude | Location | Geopoint |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 由纬度和经度确定的地点 | 位置 | 地理点 |'
- en: '| Media, including images, videos, and files | Media | FileImage |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 媒体，包括图片、视频和文件 | 媒体 | 文件图片 |'
- en: '| References to other content objects in the CMS | Reference | ReferenceArray
    |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| CMS 中其他内容对象的引用 | 引用 | 引用数组 |'
- en: Sanity believes that defining content models in code can give you better control
    over the model while also enabling you to add your own custom validations. Nonetheless,
    it also means that building and maintaining the content model requires development
    resources, where alternatives that use a visual editor (like Contentful, for example)
    might not. In addition, Sanity deploys a new instance of Sanity Studio, its open
    source, web-based content management interface, with every project. Since you
    have access to the admin site code for the project, you are free to modify the
    interface however you choose, but the initial interface has fewer frills than
    the Contentful interface.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Sanity 认为在代码中定义内容模型可以让你更好地控制模型，同时还能让你添加自己的自定义验证。然而，这也意味着构建和维护内容模型需要开发资源，而使用可视化编辑器（例如
    Contentful）的替代方案可能不需要。此外，Sanity 为每个项目部署了一个新的 Sanity Studio 实例，这是一个开源的、基于网络的 内容管理界面。由于你有权访问项目的管理站代码，你可以自由地按照自己的选择修改界面，但初始界面比
    Contentful 界面要简单。
- en: 'Sanity has 17 types compared to Contentful’s 9, but they are largely similar
    to Contentful’s types:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Contentful 的 9 种类型相比，Sanity 有 17 种类型，但它们在很大程度上与 Contentful 的类型相似：
- en: '|'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Array
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: '|'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Block
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 块
- en: '|'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Boolean
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值
- en: '|'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Date
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期
- en: '|'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Datetime
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期时间
- en: '|'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Document
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档
- en: '|'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: File
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件
- en: '|'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Geopoint
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地理点
- en: '|'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Image
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图片
- en: '|'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Number
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字
- en: '|'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Object
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象
- en: '|'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Reference
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用
- en: '|'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Slug
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 短名
- en: '|'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: String
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: '|'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Span
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 段落
- en: '|'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Text
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本
- en: '|'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: URL
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL
- en: '|  |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In many cases, where Contentful has subtypes, Sanity has multiple types. For
    example, Contentful has a single Reference type that refers to one-to-one and
    one-to-many relationships between content items. In Sanity, there is a Reference
    type as well, but it only refers to the one-to-one relationship. The one-to-many
    relationship refers to the Array type. Where Contentful has a single Media content
    type that refers to all types of media uploads, Sanity has a File and Image type
    for different types of media uploads.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，当 Contentful 有子类型时，Sanity 有多种类型。例如，Contentful 有一个单一的引用类型，它指代内容项之间的一对一和一对多关系。在
    Sanity 中，也有一个引用类型，但它只指代一对一关系。一对多关系指代数组类型。当 Contentful 有一个单一的媒体内容类型指代所有类型的媒体上传时，Sanity
    有文件和图片类型用于不同类型的媒体上传。
- en: Sanity also provides a structured text format similar to rich text in Contentful
    called Block. Sanity’s Block type follows the Portable Text specification ([https://
    github.com/portabletext/portabletext](https://github.com/portabletext/portabletext))
    for rich text, meaning it is made up of an array of subtypes that represent the
    types of content within the block. These can be standard types, like headings,
    lists, or links, but they can also be custom types. For instance, your content
    model may have an Employee type, and the block element for an Our Team page would
    allow you to add items of the Employee type.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Sanity 还提供了一种类似 Contentful 中丰富文本的结构化文本格式，称为块。Sanity 的块类型遵循 Portable Text 规范
    ([https://github.com/portabletext/portabletext](https://github.com/portabletext/portabletext))，这意味着它由一个表示块内内容类型的子类型数组组成。这些可以是标准类型，如标题、列表或链接，也可以是自定义类型。例如，你的内容模型可能有一个员工类型，而我们的团队页面上的块元素允许你添加员工类型的条目。
- en: Every content type in Sanity has properties such as whether it is readonly or
    hidden from the admin UI. All types share the same core properties, although some,
    like Block and Image, have additional properties that can be set. Each content
    type also has a set of predefined validations, such as whether the field is required
    or, in the case of Text, has a minimum, maximum, or specific length requirement.
    These validations vary per type. Sanity also allows you to specify a custom validation
    ([http://mng.bz/voDr](http://mng.bz/voDr)) on any type that is written as a JavaScript
    function. This means you can create complex validations that are not covered by
    the built-in validation types.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Sanity中的每个内容类型都有如是否只读或从管理UI中隐藏等属性。所有类型都共享相同的核心属性，尽管一些类型，如块和图像，有可以设置的附加属性。每个内容类型还有一个预定义的验证集，例如字段是否必需，或者在文本的情况下，是否有最小、最大或特定长度的要求。这些验证因类型而异。Sanity还允许您为任何以JavaScript函数编写的类型指定自定义验证([http://mng.bz/voDr](http://mng.bz/voDr))。这意味着您可以创建复杂的验证，这些验证超出了内置验证类型的范围。
- en: 9.2.3 Defining a content model using Sanity
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.3 使用Sanity定义内容模型
- en: Since it is entirely code based and the editor UI can be run locally, the experience
    of building a content model using Sanity can be quite unique. Let’s walk through
    how to create a content model based on a Sanity-provided sample project and explore
    the sample schema code to give you a better sense of how Sanity works.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它完全基于代码，并且编辑器UI可以在本地运行，因此使用Sanity构建内容模型的经验可以非常独特。让我们通过如何根据Sanity提供的样本项目创建内容模型，并探索样本架构代码来更好地了解Sanity的工作方式。
- en: 'To create a Sanity project, you’ll need a Sanity account, and then you’ll use
    the Sanity CLI, which can be installed via npm. Then, you’ll initialize a new
    project:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建Sanity项目，您需要一个Sanity账户，然后您将使用Sanity CLI，它可以通过npm安装。然后，您将初始化一个新的项目：
- en: '[PRE0]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you haven’t logged in via the CLI yet, the CLI will open a browser window
    to authenticate you. After that you’ll be asked to either choose an existing project
    to launch, if you have one already, or create a new project. You’ll give your
    project a name and then choose if you want to use the default data set configuration
    (by default, the production data set can be queried without authentication). Next,
    you’ll choose an output path, which will default to the current project folder.
    This is where all the local files necessary to configure your Sanity schema and
    Sanity Studio will be placed. Finally, you can choose either a blank schema or
    start with a preexisting example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未通过CLI登录，CLI将打开一个浏览器窗口以进行身份验证。之后，您将被要求选择一个现有项目以启动，如果您已经有了，或者创建一个新项目。您将为您的项目命名，然后选择是否要使用默认的数据集配置（默认情况下，生产数据集可以在未经身份验证的情况下查询）。接下来，您将选择一个输出路径，默认情况下将设置为当前项目文件夹。这是放置配置您的Sanity架构和Sanity
    Studio所需的所有本地文件的地方。最后，您可以选择一个空白架构或从现有的示例开始：
- en: '[PRE1]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The Movie project schema is a good beginner’s example for trying out Sanity,
    as it has both a simple schema and data to populate it. This offers you the opportunity
    to try out the studio without needing to manually populate it with data. You’ll
    want to answer yes when asked whether to import the sample data. Once the import
    is complete, run sanity start from the command line to start Sanity Studio. By
    default, it will run locally on http://localhost:3333.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 电影项目架构是尝试Sanity的一个很好的入门示例，因为它既有简单的架构，又有填充它的数据。这为您提供了一个尝试工作室的机会，而无需手动用数据填充它。当被问及是否导入样本数据时，您应该回答“是”。一旦导入完成，从命令行运行sanity
    start以启动Sanity Studio。默认情况下，它将在http://localhost:3333上本地运行。
- en: All the files that make up the content model are in the schemas folder within
    the project. Let’s quickly explore the Person type defined in the person.js file
    in listing 9.1, and then we’ll dig into how it works.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 构成内容模型的全部文件都位于项目中的schemas文件夹内。让我们快速探索列表9.1中定义在person.js文件中的Person类型，然后我们将深入了解它是如何工作的。
- en: Listing 9.1 The schema file defining a person content type in Sanity
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.1 定义Sanity中人员内容类型的架构文件
- en: '[PRE2]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The name is the object name, while the title is what will appear in the navigation
    within the studio. The document type is a basic building block of types within
    Sanity. Content types can either be document or object. A document type is the
    type you’ll create and edit in the studio (i.e., they show up in the left-hand
    menu), whereas objects can be used to make up parts of a document (as in the castMember
    object type in this sample schema that contains a person with additional attributes
    that can be added to a movie). The icon is the icon that shows up in the left-hand
    navigation and is a visual cue for the type of content being created (in this
    case the user icon represents a person, as seen in figure 9.3).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 名称是对象名称，而标题是将在工作室内的导航中显示的内容。文档类型是Sanity中类型的基石。内容类型可以是文档或对象。文档类型是你将在工作室中创建和编辑的类型（即，它们会出现在左侧菜单中），而对象可以用来构成文档的一部分（如在这个示例模式中的castMember对象类型，它包含一个具有可以添加到电影中的额外属性的人）。图标是在左侧导航中显示的图标，是创建内容类型的视觉提示（在这种情况下，用户图标代表一个人，如图9.3所示）。
- en: '![CH09_F03_Camden2](Images/CH09_F03_Camden2.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F03_Camden2](Images/CH09_F03_Camden2.png)'
- en: Figure 9.3 The default Sanity Studio editing experience. Sanity Studio is open
    source and customizable.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 默认的Sanity Studio编辑体验。Sanity Studio是开源的，并且可以自定义。
- en: The fields are the different properties that our type contains. Each is assigned
    one of the 17 types. The options that can be defined in the options object vary
    depending on the type. For example, the slug type has a source option that will
    determine which field will be used to auto-populate a default slug value (in this
    case the person’s name).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 字段是我们类型包含的不同属性。每个属性都分配了17种类型中的一种。可以在选项对象中定义的选项取决于类型。例如，slug类型有一个源选项，它将确定哪个字段将用于自动填充默认的slug值（在这种情况下是人的名字）。
- en: The preview section determines what fields Sanity will display in the Sanity
    Studio navigation when listing objects of this type. Sanity will automatically
    make a best guess as to which fields to display, but you can supply this to customize
    the fields it displays.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 预览部分决定了Sanity在列出此类对象的Sanity Studio导航中会显示哪些字段。Sanity将自动猜测哪些字段来显示，但你可以提供这些信息来自定义它显示的字段。
- en: Feel free to continue exploring the schema to learn how it was assembled and
    the various options for configuring a data model in Sanity. So far, we’ve set
    up the schema and studio locally. While Sanity’s system knows about it, we have
    not deployed it, and the studio is not available to other users. If we wanted
    to deploy the schema to Sanity and make the studio available, we’d run sanity
    deploy from the command line.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 随意继续探索模式，了解它是如何组装的以及如何在Sanity中配置数据模型的多种选项。到目前为止，我们已经在本地上设置了模式和工作室。虽然Sanity的系统知道它，但我们还没有部署它，工作室对其他用户不可用。如果我们想将模式部署到Sanity并使工作室可用，我们将在命令行中运行sanity
    deploy。
- en: There are a number of example Jamstack projects that Sanity provides using SSGs,
    such as Next.js, Gatsby, Gridsome, Nuxt, and Eleventy. These provide examples
    of how to generate sites and previews using content stored in a Sanity project.
    All can be found at [https://www.sanity.io/create](https://www.sanity.io/create).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Sanity提供了许多使用SSGs（静态站点生成器）的Jamstack项目示例，例如Next.js、Gatsby、Gridsome、Nuxt和Eleventy。这些提供了如何使用存储在Sanity项目中的内容生成网站和预览的示例。所有这些都可以在[https://www.sanity.io/create](https://www.sanity.io/create)找到。
- en: 9.3 Using WordPress
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3 使用WordPress
- en: What’s WordPress doing in a book about Jamstack? If you’ve seen the many WordPress
    versus Jamstack posts and discussions in recent years, you’re probably thinking
    that you must choose one or the other. However, Jamstack doesn’t have any opinions
    about what backend you choose, and, it turns out, WordPress offers a REST API
    that makes it a perfectly good backend for Jamstack sites.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress在关于Jamstack的书中做什么？如果你最近几年看到了许多关于WordPress与Jamstack的帖子讨论，你可能认为你必须选择其中一个。然而，Jamstack对您选择的后端没有任何意见，而且，事实证明，WordPress提供了一个REST
    API，使其成为Jamstack站点的完美后端。
- en: It’s true that the typical development scenario with WordPress involves a tightly
    coupled frontend and backend, but WordPress also brings a highly polished content
    editing experience that many content writers are already comfortable with and,
    in fact, may already be using. Rather than force them to move, there are a lot
    of options you can leverage to build a Jamstack frontend tied to a WordPress backend.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 事实确实如此，典型的WordPress开发场景涉及紧密耦合的前端和后端，但WordPress还带来了高度精致的内容编辑体验，许多内容创作者已经习惯了，实际上可能已经在使用。而不是强迫他们迁移，有许多选项可以利用来构建与WordPress后端绑定的Jamstack前端。
- en: While you can integrate any Jamstack frontend with the Wordpress API, Gatsby,
    a very popular React-based SSG, has made it easy for developers to connect Gatsby
    to WordPress. Let’s look at how you’d connect a Gatsby site to a WordPress instance.
    Don’t worry if you don’t have a WordPress backend set up; we’ll walk through how
    to easily set up a local one.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以将任何Jamstack前端与Wordpress API集成，但基于React的非常流行的SSG Gatsby已经使开发者能够轻松地将Gatsby连接到WordPress。让我们看看如何将一个Gatsby网站连接到一个WordPress实例。如果您还没有设置WordPress后端，请不要担心；我们将逐步说明如何轻松地设置一个本地实例。
- en: 9.3.1 Installing WordPress locally with Local
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.1 使用Local在本地安装WordPress
- en: Let’s get a WordPress instance set up first. If you already have WordPress installed,
    feel free to use that for this walkthrough and skip the setup (jump to “Setting
    Up the Gatsby Plug-Ins”). You’ll need to be able to install plug-ins, which some
    hosts restrict.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们设置一个WordPress实例。如果您已经安装了WordPress，请随意使用它进行此演练并跳过设置（跳转到“设置Gatsby插件”）。您需要能够安装插件，这被一些主机限制。
- en: One of the easiest ways to set up a local instance of WordPress is with a tool
    called Local ([https://localwp.com/](https://localwp.com/)). While there is a
    paid pro version, you’ll only need the free version for this walkthrough. Once
    installed, open Local and click the button to add a new site. You can name it
    whatever you’d like. I named mine “gastby-sample.” Then you can choose the default
    “Preferred” environment. The final step is to choose a username and password for
    your site admin.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 设置WordPress本地实例的最简单方法之一是使用一个名为Local ([https://localwp.com/](https://localwp.com/))的工具。虽然有一个付费的专业版，但您只需免费版即可进行此演练。安装后，打开Local并点击按钮添加新网站。您可以命名它任何您想要的名称。我将其命名为“gastby-sample”。然后您可以选择默认的“首选”环境。最后一步是为您的网站管理员选择用户名和密码。
- en: Local will set up the entire WordPress instance, with the MySQL database, and
    give you the site details. You can view the site running locally on your machine
    by clicking Open Site, or you can access the backend of your site running locally
    by clicking Admin. For now, open the admin.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 本地环境将设置整个WordPress实例，包括MySQL数据库，并为您提供网站详情。您可以通过点击“打开网站”来查看您机器上本地运行的网站，或者您可以通过点击“管理”来访问您本地运行的网站的后端。目前，请打开管理界面。
- en: 9.3.2 Installing the Gatsby plug-ins for WordPress
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.2 安装WordPress的Gatsby插件
- en: 'In order to serve as a frontend to a WordPress backend, Gatsby requires two
    plug-ins to be installed:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了作为WordPress后端的前端，Gatsby需要安装两个插件：
- en: '*WPGraphQL* ([https://github.com/wp-graphql/wp-graphql](https://github.com/wp-graphql/wp-graphql))—The
    purpose of this plug-in is to take the REST API of WordPress and enable it for
    GraphQL ([https://graphql.org/](https://graphql.org/)). Gatsby’s data layer, which
    supplies the content that Gatsby uses to generate a site, is entirely based on
    GraphQL. Once enabled, your site will have a GraphQL API available at https://[YOUR_SITE_NAME]/
    graphql. For example, my site, running locally on Local, has a GraphQL API URL
    of http://gatsbysample.local/graphql.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*WPGraphQL* ([https://github.com/wp-graphql/wp-graphql](https://github.com/wp-graphql/wp-graphql))——此插件的目的在于将WordPress的REST
    API转换为GraphQL ([https://graphql.org/](https://graphql.org/))。Gatsby的数据层，它为Gatsby提供用于生成网站的内容，完全基于GraphQL。一旦启用，您的网站将有一个可在https://[YOUR_SITE_NAME]/
    graphql处访问的GraphQL API。例如，我的网站在Local上本地运行，其GraphQL API URL为http://gatsbysample.local/graphql。'
- en: '*WPGatsby* ([https://wordpress.org/plugins/wp-gatsby/](https://wordpress.org/plugins/wp-gatsby/))—The
    primary purpose of this plug-in is to monitor changes on your WordPress site to
    keep your Gatsby frontend in sync with changes made in the WordPress backend.
    This plug-in monitors changes to things like posts or menus and calls a web hook
    in your Gatsby site to trigger a rebuild with the new information. It also enables
    WordPress previews to work with Gatsby pages. It is optional for our walkthrough,
    as it requires integration with your chosen deployment platform, like Netlify,
    Vercel, or Gatsby Cloud.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*WPGatsby* ([https://wordpress.org/plugins/wp-gatsby/](https://wordpress.org/plugins/wp-gatsby/))—此插件的主要目的是监控您WordPress站点的更改，以保持Gatsby前端与WordPress后端所做的更改同步。此插件监控诸如帖子或菜单之类的更改，并在您的Gatsby站点中调用一个web钩子以触发使用新信息的重建。它还使WordPress预览能够与Gatsby页面一起工作。在我们的教程中，它是可选的，因为它需要与您选择的部署平台（如Netlify、Vercel或Gatsby
    Cloud）集成。'
- en: To install these plug-ins, open your site in Local and click on the Admin button.
    This will open your WordPress site’s admin panel. You’ll need to log in using
    the credentials you created earlier in the WordPress setup process using Local.
    Once you log in, click Plugins in the left-hand menu and then click the Add New
    button. In the search box, enter the names of the plug-ins, WPGraphQL (figure
    9.4) and WPGatsby, and then click Install Now for each.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装这些插件，在Local中打开您的站点并点击管理按钮。这将打开您的WordPress站点管理面板。您需要使用在Local的WordPress设置过程中创建的凭据登录。登录后，在左侧菜单中点击插件，然后点击添加新按钮。在搜索框中输入插件的名称，WPGraphQL（图9.4）和WPGatsby，然后为每个点击安装。
- en: '![CH09_F04_Camden2](Images/CH09_F04_Camden2.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F04_Camden2](Images/CH09_F04_Camden2.png)'
- en: Figure 9.4 The WPGraphQL plug-in converts WordPress to work with Gatsby. This
    card will appear in the plug-in search UI within WordPress.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4展示了WPGraphQL插件将WordPress转换为与Gatsby一起工作。此卡片将在WordPress插件搜索UI中显示。
- en: Once WPGraphQL is installed, you should see a GraphQL menu item added to the
    left-hand menu. Open that to view the plug-in settings, as shown in figure 9.5.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了WPGraphQL，您应该会在左侧菜单中看到添加的GraphQL菜单项。打开它以查看如图9.5所示的插件设置。
- en: '![CH09_F05_Camden2](Images/CH09_F05_Camden2.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F05_Camden2](Images/CH09_F05_Camden2.png)'
- en: Figure 9.5 The plug-in settings screen for WPGraphQL within the WordPress admin
    allows you to set the endpoint location and change how your GraphQL endpoint will
    work.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5展示了在WordPress管理界面中WPGraphQL插件设置屏幕，您可以通过它设置端点位置并更改GraphQL端点的工作方式。
- en: Make note of the GraphQL endpoint URL linked beneath the GraphQL endpoint setting.
    This is the endpoint our Gatsby frontend will connect to. For example, mine is
    http://gatsbysample.local/graphql. While you are testing, you can also scroll
    down and check the Enable GraphQL Debug Mode box. This will enable debug information
    to be returned by GraphQL queries during development.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在GraphQL端点设置下方链接的GraphQL端点URL。这是我们Gatsby前端将要连接到的端点。例如，我的端点是http://gatsbysample.local/graphql。在测试过程中，您还可以向下滚动并勾选启用GraphQL调试模式复选框。这将使GraphQL查询在开发期间返回调试信息。
- en: By default, WPGraphQL also added a GraphiQL IDE query editor to your WordPress
    admin, which is available via the GraphiQL IDE menu item on the top navigation
    bar. Click that to open a query editor and test GraphQL queries against your WordPress
    data.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，WPGraphQL还为您添加了一个GraphiQL IDE查询编辑器到WordPress管理界面中，它可通过顶部导航栏上的GraphiQL
    IDE菜单项访问。点击它以打开查询编辑器并测试针对您的WordPress数据的GraphQL查询。
- en: The full schema that you can query against will load in the Explorer on the
    left. It’s pretty complex, but the Explorer lets you click around and create queries.
    Feel free to review this more on your own, but for now let’s test it with a query
    similar to what we’ll use in our simple example Gatsby app.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查询的完整模式将在左侧的探索器中加载。它相当复杂，但探索器允许您点击并创建查询。您可以自由地自行查看更多，但现在让我们用一个类似于我们在简单示例Gatsby应用中使用的查询来测试它。
- en: Listing 9.2 A query to get WordPress content from WPGraphQL
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.2：一个从WPGraphQL获取WordPress内容的查询
- en: '[PRE3]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Click the play button (i.e., the right arrow) above the query editor to run
    the query.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 点击查询编辑器上方的播放按钮（即右箭头）来运行查询。
- en: Listing 9.3 The results returned by the query in listing 9.2
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.3：列表9.2中查询返回的结果
- en: '[PRE4]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Figure 9.6 shows how this looks in the GraphiQL IDE.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6显示了在GraphiQL IDE中的外观。
- en: '![CH09_F06_Camden2](Images/CH09_F06_Camden2.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F06_Camden2](Images/CH09_F06_Camden2.png)'
- en: Figure 9.6 Querying the GraphQL API generated by WPGraphQL within the GraphiQL
    interface, inside the WordPress admin
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6展示了在WordPress管理界面中的GraphiQL界面内查询由WPGraphQL生成的GraphQL API。
- en: That’s all we need to do to set up WordPress. Feel free to populate the site
    with some posts or simply proceed using the default posts that WordPress provides.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 WordPress 所需做的所有事情就是这些。您可以随意用一些帖子填充网站，或者简单地使用 WordPress 提供的默认帖子继续操作。
- en: 9.3.3 Setting up Gatsby
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.3 设置 Gatsby
- en: 'There are a number of Gatsby starters that are designed to work with WordPress
    and will jumpstart your project. You can find those by going to the Gatsby Starters
    page ([https://www.gatsbyjs.com/starters](https://www.gatsbyjs.com/starters))
    and filtering by “CMS: WordPress.” However, for the sake of better understanding
    how all this works, we’re going to write our own simple Gatsby landing page that
    will list the posts within our local WordPress site.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '有许多 Gatsby 启动器是为与 WordPress 一起使用而设计的，并将加速您的项目。您可以通过访问 Gatsby 启动器页面 ([https://www.gatsbyjs.com/starters](https://www.gatsbyjs.com/starters))
    并按“CMS: WordPress”进行筛选来找到它们。然而，为了更好地理解这一切是如何工作的，我们将编写我们自己的简单 Gatsby 登录页面，该页面将列出我们本地
    WordPress 网站内的帖子。'
- en: 'Before we can connect Gatsby to WordPress, we’ll need to initialize a new Gatsby
    project using the CLI. To do this, open your project directory and run the following
    command (we’ll specify the folder we want the Gatsby project created in during
    the setup process):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够将 Gatsby 连接到 WordPress 之前，我们需要使用 CLI 初始化一个新的 Gatsby 项目。为此，打开您的项目目录并运行以下命令（我们将在设置过程中指定我们想要创建
    Gatsby 项目的文件夹）：
- en: '[PRE5]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will run create-gatsby, which will ask you a series of questions via the
    command line to configure your new Gatsby site. Here are the responses you’ll
    need to create our sample project, which are illustrated in figure 9.7:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行 create-gatsby，它将通过命令行提出一系列问题来配置您的新 Gatsby 网站。以下是您需要创建我们的示例项目所需的响应，如图 9.7
    所示：
- en: '*What would you like to call your site?* Gatsby WordPress.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*您想给您的站点起什么名字？* Gatsby WordPress。'
- en: '*What would you like to name the folder where your site will be created?* gatsby-wordpress.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*您想将您的站点创建在哪个文件夹中命名？* gatsby-wordpress。'
- en: '*Will you be using a CMS?* Use your arrow keys to choose WordPress.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*您将使用 CMS 吗？* 使用您的箭头键选择 WordPress。'
- en: '*Would you like to install a styling system?* No (or I’ll add it later).'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*您想要安装一个样式系统吗？* 不（或者我稍后添加）。'
- en: '*Would you like to install additional features with other plugins?* Use the
    arrow keys to scroll down and choose Done.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*您想要使用其他插件安装附加功能吗？* 使用箭头键向下滚动并选择完成。'
- en: '*Configure the WordPress plugin.* This is the GraphQL endpoint we noted from
    the GraphQL settings within our local WordPress instance. For example, mine is
    http://gatsbysample.local/graphql.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*配置 WordPress 插件。* 这是我们在本地 WordPress 实例的 GraphQL 设置中记录的 GraphQL 端点。例如，我的地址是
    http://gatsbysample.local/graphql。'
- en: '*Shall we do this?* Press Enter to select yes.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*我们应该这样做吗？* 按下 Enter 键选择是。'
- en: '![CH09_F07_Camden2](Images/CH09_F07_Camden2.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F07_Camden2](Images/CH09_F07_Camden2.png)'
- en: Figure 9.7 The Gatsby CLI provides a step-by-step setup process for a new Gatsby
    site.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 Gatsby CLI 为新 Gatsby 站点提供了一个逐步设置过程。
- en: 'This will start the process of generating the default files for our Gatsby
    site in the gatsby-wordpress directory. Once this is done, change the directory
    to the project folder and start Gatsby. Note that, due to an issue with the process
    in creating our Gatsby app, we may need to install the gatsby-plugin-sharp and
    gatsby-transformer-sharp plug-ins before running Gatsby:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这将开始生成我们 Gatsby 网站在 gatsby-wordpress 目录中的默认文件。一旦完成，将目录更改为项目文件夹并启动 Gatsby。请注意，由于创建我们的
    Gatsby 应用程序过程中存在一个问题，我们可能需要在运行 Gatsby 之前安装 gatsby-plugin-sharp 和 gatsby-transformer-sharp
    插件：
- en: '[PRE6]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once the build is done, we can view our site at http://localhost:8000/, which
    should look like figure 9.8.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建完成，我们可以在 http://localhost:8000/ 上查看我们的网站，它应该看起来像图 9.8。
- en: '![CH09_F08_Camden2](Images/CH09_F08_Camden2.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F08_Camden2](Images/CH09_F08_Camden2.png)'
- en: Figure 9.8 The default home page of the site generated by Gatsby’s CLI
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 由 Gatsby CLI 生成的网站的默认主页
- en: 9.3.4 Exploring Gatsby’s data layer
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.4 探索 Gatsby 的数据层
- en: Before we begin coding, let’s explore Gatsby’s data layer. Gatsby prefers to
    get all data for your application from a GraphQL-based data layer. We can view
    the data and queries available in this data layer when our site is running locally
    by going to http://localhost:8000/graphql. Let’s open that in a new browser window.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编码之前，让我们探索 Gatsby 的数据层。Gatsby 倾向于从基于 GraphQL 的数据层获取您应用程序的所有数据。当我们的网站在本地运行时，我们可以通过访问
    http://localhost:8000/graphql 来查看此数据层中可用的数据和查询。让我们在新的浏览器窗口中打开它。
- en: Since we already explored the GraphiQL editor that WPGraphQL provided, this
    should look somewhat familiar. In this case, the queries in the Explorer panel
    include all of Gatsby’s default data queries as well as a number of WordPress
    queries. The latter were added to Gatsby’s data layer because we chose WordPress
    as our CMS during the site creation process.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经探索了 WPGraphQL 提供的 GraphiQL 编辑器，所以这应该看起来有些熟悉。在这种情况下，探索面板中的查询包括 Gatsby 的所有默认数据查询以及一些
    WordPress 查询。后者被添加到 Gatsby 的数据层，因为我们选择 WordPress 作为我们的 CMS 在创建网站的过程中。
- en: Feel free to explore the queries available, but for now, let’s test the query
    we’ll use to populate data on our home page. Enter the query in the query editor
    and click the Play button to run it.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 随意探索可用的查询，但就目前而言，让我们测试我们将用于在主页上填充数据的查询。在查询编辑器中输入查询并点击播放按钮运行它。
- en: Listing 9.4 A query to retrieve WordPress content from within Gatsby’s data
    layer
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.4 从 Gatsby 数据层检索 WordPress 内容的查询
- en: '[PRE7]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This query is very similar to the one we ran inside the WordPress GraphiQL editor,
    except that it uses the allWpPost query that it is provided by Gatsby’s data layer.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询与我们之前在 WordPress GraphiQL 编辑器中运行的查询非常相似，只是它使用了 Gatsby 数据层提供的 allWpPost 查询。
- en: Listing 9.5 The results returned from the query in listing 9.4
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.5 列表 9.4 中查询返回的结果
- en: '[PRE8]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Perfect! We’re ready use this data in our home page.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！我们现在可以使用这些数据在我们的主页上了。
- en: 9.3.5 Consuming WordPress content in Gatsby
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.5 在 Gatsby 中消费 WordPress 内容
- en: 'Open the project files in your code editor. The root project folder contains
    a gatsby-config.js that was generated for us during the creation process. It contains
    the name of the site that we specified as well as the WordPress plug-in configuration
    that we provided with our GraphQL endpoint URL. If we were to deploy our WordPress
    instance, this is where we’d update the endpoint URL:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的代码编辑器中打开项目文件。根项目文件夹包含一个 gatsby-config.js 文件，该文件是在创建过程中为我们生成的。它包含我们指定的站点名称以及我们提供的
    WordPress 插件配置和 GraphQL 端点 URL。如果我们部署我们的 WordPress 实例，这就是我们更新端点 URL 的地方：
- en: '[PRE9]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The source of our site is under the src directory. Within that directory, the
    pages for our site are within the pages directory. We only have a home page (index.js)
    and a 404 page (404.js). Let’s open index.js and make some changes.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们站点的源代码位于 src 目录下。在该目录中，我们的站点页面位于 pages 目录中。我们只有一个主页（index.js）和一个 404 页面（404.js）。让我们打开
    index.js 并进行一些修改。
- en: 'The page uses data that is defined inline as a links array and is right below
    the styles. We won’t need that, so let’s remove it. Let’s also remove the code
    to render the links list from the markup so that our IndexPage markup looks like
    the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 页面使用在样式下方定义的 inline 链接数组中的数据，我们不需要它，所以让我们将其删除。同时，让我们也从标记中删除渲染链接列表的代码，以便我们的 IndexPage
    标记看起来如下：
- en: '[PRE10]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: At this point, our page isn’t rendering anything but a h1 with the text “My
    Blog.” Before we can render the list of posts, we need to make the data available
    to the page. Let’s create the query that will be run against Gatsby’s GraphQL
    data layer directly beneath the export default IndexPage line. This query will
    look familiar, as it is the same one we tested earlier when exploring Gatsby’s
    data layer.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的页面除了显示带有文本“我的博客”的 h1 标题外，没有渲染任何内容。在我们能够渲染帖子列表之前，我们需要将数据提供给页面。让我们在 export
    default IndexPage 行下面直接创建一个查询，该查询将直接针对 Gatsby 的 GraphQL 数据层运行。这个查询看起来很熟悉，因为它与我们之前在探索
    Gatsby 数据层时测试过的查询相同。
- en: 'First, we need to add an import at the top of our index.js file:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在我们的 index.js 文件顶部添加一个导入：
- en: '[PRE11]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then we can add the query:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以添加查询：
- en: '[PRE12]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, let’s make the data from this query available to the page. First, we
    need to add another import at the top of the index.js file:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使这个查询的数据对页面可用。首先，我们需要在 index.js 文件顶部添加另一个导入：
- en: '[PRE13]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then we can tell our Gatsby page about the data we’re providing via our allWpPost
    query. The PropTypes library is type checking to ensure the data matches what
    we expect. Place the following code after the export default IndexPage line:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过我们的 allWpPost 查询告诉我们的 Gatsby 页面我们提供的数据。PropTypes 库正在进行类型检查，以确保数据符合我们的预期。在
    export default IndexPage 行之后放置以下代码：
- en: '[PRE14]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now we can update our markup to output the results from the query. The code
    destructures data from our page props and then uses the array of items within
    data.allWpPost, which contains the results of our query, to output our posts as
    a list with excerpts. Note that we have to use dangerouslySetInnerHTML to display
    the excerpt content because it is returned as HTML. This property is named this
    way because doing so makes DOM changes outside the scope of React’s virtual DOM,
    which is fine for our purposes but should generally be done judiciously.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以更新我们的标记来输出查询的结果。代码从我们的页面属性中解构数据，然后使用数据.allWpPost中的项目数组，该数组包含查询的结果，以列表形式输出我们的帖子，并带有摘录。请注意，我们必须使用dangerouslySetInnerHTML来显示摘录内容，因为它以HTML的形式返回。这个属性之所以这样命名，是因为这样做会使DOM更改超出React虚拟DOM的作用域，这对于我们的目的来说是可行的，但通常应该谨慎行事。
- en: Listing 9.6 Outputting a list of WordPress blog posts within Gatsby
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.6 在Gatsby中输出WordPress博客帖子列表
- en: '[PRE15]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Our updated home page running in the browser should look like figure 9.9, with
    the one post from our default WordPress install displayed, along with an excerpt
    from the post.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在浏览器中运行的更新后的主页应该看起来像图9.9，显示我们默认WordPress安装中的一个帖子，以及帖子的摘录。
- en: '![CH09_F09_Camden2](Images/CH09_F09_Camden2.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F09_Camden2](Images/CH09_F09_Camden2.png)'
- en: Figure 9.9 The edited blog home page outputs the blog posts and descriptions
    within our WordPress instance. By default, WordPress installs with a single dummy
    post. Add more posts to see them appear.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 编辑后的博客主页输出我们WordPress实例中的博客文章和描述。默认情况下，WordPress安装包含一个虚拟帖子。添加更多帖子以查看它们的出现。
- en: 9.3.6 Next steps in using WordPress as a headless CMS
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.6 使用WordPress作为无头CMS的下一步
- en: We’re using WordPress as a CMS to populate our Gatsby site. The next step in
    building this application is to create the dynamic route to handle displaying
    the individual WordPress posts in Gatsby. While we won’t cover that here, I encourage
    you to explore more about how to integrate Gatsby and WordPress via Gatsby’s WordPress
    guide ([https://www.gatsbyjs.com/guides/wordpress/](https://www.gatsbyjs.com/guides/wordpress/)),
    or this tutorial on CSS-Tricks ([http://mng.bz/4jEv](http://mng.bz/4jEv)) covering
    the Gatsby WordPress source plug-in.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用WordPress作为CMS来填充我们的Gatsby站点。构建此应用程序的下一步是创建动态路由以在Gatsby中显示单个WordPress帖子。虽然我们在这里不会涉及这一点，但我鼓励你通过Gatsby的WordPress指南
    ([https://www.gatsbyjs.com/guides/wordpress/](https://www.gatsbyjs.com/guides/wordpress/))
    或CSS-Tricks上的这篇教程 ([http://mng.bz/4jEv](http://mng.bz/4jEv)) 了解如何通过Gatsby WordPress源插件集成Gatsby和WordPress。
- en: It is important to remember that the WordPress REST API can be consumed by any
    Jamstack frontend, whether Gatsby or not. In fact, the GraphQL endpoint provided
    by the WPGraphQL plug-in can be consumed outside of Gatsby as well, using either
    Eleventy or Next.js, for example. While Gatsby provides some built-in connections
    for WordPress, WordPress is also a valid headless CMS backend for just about any
    Jamstack site, regardless of what SSG you choose.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，WordPress REST API可以被任何Jamstack前端消费，无论是Gatsby还是其他。实际上，WPGraphQL插件提供的GraphQL端点也可以在Gatsby之外消费，例如使用Eleventy或Next.js。虽然Gatsby为WordPress提供了一些内置连接，但WordPress也是几乎所有Jamstack站点的有效无头CMS后端，无论你选择了哪种SSG。
- en: 9.4 Connecting a CMS using a site builder
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4 使用网站构建器连接CMS
- en: Up to now, we’ve talked about ways you can connect a headless CMS using some
    of the starters that are provided by either the SSG or the headless CMS provider
    itself. We also looked at how to connect your own using WordPress. However, there
    is one more route I want to explore, which is using a site builder like WeWeb
    ([https://www.weweb.io/](https://www.weweb.io/)), Strattic ([https://www.strattic.com/](https://www.strattic.com/)),
    or Stackbit ([https://www.stackbit.com/](https://www.stackbit.com/)).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了你可以使用SSG或无头CMS提供商提供的启动器连接无头CMS的方法。我们还探讨了如何使用WordPress连接自己的CMS。然而，我想要探索的另一条路径是使用像WeWeb
    ([https://www.weweb.io/](https://www.weweb.io/))、Strattic ([https://www.strattic.com/](https://www.strattic.com/))或Stackbit
    ([https://www.stackbit.com/](https://www.stackbit.com/))这样的网站构建器。
- en: Site builders like these go a few steps beyond what a starter template provides
    by customizing the site that it generates based on your needs and providing web-based
    tools for either technical or nontechnical resources to edit that site. They also
    allow you to integrate the content management via popular existing headless CMS
    providers.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这些网站构建器在提供启动器模板所提供的内容之外，还通过根据你的需求定制生成的网站以及提供基于Web的工具来编辑该网站（无论是技术资源还是非技术资源）来走得更远。它们还允许你通过流行的现有无头CMS提供商集成内容管理。
- en: Keep in mind that these services are generally free to start but do charge you
    once you reach usage caps or want to lift feature restrictions.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这些服务通常免费开始使用，但一旦达到使用上限或想要取消功能限制，就会向您收费。
- en: 9.4.1 WeWeb
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.1 WeWeb
- en: WeWeb is a Vue-based site generator, so it does not rely on an SSG, that can
    generate a site that is fully editable directly in the browser. This means that
    you aren’t simply editing text content but can also add and rearrange elements
    on the page from within its web-based WYSIWYG editor (figure 9.10).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: WeWeb是一个基于Vue的网站生成器，因此它不依赖于SSG，可以生成一个可以直接在浏览器中完全编辑的网站。这意味着您不仅仅是编辑文本内容，还可以在其基于网页的WYSIWYG编辑器中添加和重新排列页面上的元素（图9.10）。
- en: '![CH09_F10_Camden2](Images/CH09_F10_Camden2.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F10_Camden2](Images/CH09_F10_Camden2.png)'
- en: Figure 9.10 The WeWeb admin UI allows you to edit the text on the page and the
    properties that affect the look and feel of the web design.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10 WeWeb管理UI允许您编辑页面上的文本以及影响网页设计外观和感觉的属性。
- en: You can build and customize a site based on prebuilt templates that WeWeb provides
    or start from a blank site. In both cases, you’ll be able to utilize the preexisting
    site components to create and modify your site. These components allow for dropping
    in common website elements like contact forms or rich text. You can also create
    and upload your own custom WeWeb components to use.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据WeWeb提供的预建模板构建和自定义网站，或者从空白网站开始。在两种情况下，您都将能够利用现有的网站组件来创建和修改您的网站。这些组件允许您添加常见的网站元素，如联系表单或富文本。您还可以创建和上传自己的自定义WeWeb组件以供使用。
- en: WeWeb has built-in connections to a number of headless CMS offerings, including
    Strapi, Ghost, or WordPress. Other data sources it provides are Airtable, any
    REST API, Google Sheets, any RSS Feed, any GraphQL endpoint, an SQL database,
    or any endpoint you can connect to using JavaScript.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: WeWeb内置了对多种无头CMS服务的连接，包括Strapi、Ghost或WordPress。它提供的数据源还包括Airtable、任何REST API、Google
    Sheets、任何RSS Feed、任何GraphQL端点、SQL数据库或您可以使用JavaScript连接的任何端点。
- en: 9.4.2 Strattic
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.2 Strattic
- en: Strattic takes a very different approach to building a Jamstack site connected
    to a CMS. Essentially, Strattic deploys a full WordPress setup for you on its
    servers. You manage content as you normally would via the WordPress admin. Strattic
    even supports most standard WordPress themes and many plug-ins, though due to
    the nature of the static site files, you’ll want to check compatibility ([http://mng.bz/QW6Q](http://mng.bz/QW6Q))
    with your favorite plug-ins first.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Strattic在构建与CMS连接的Jamstack网站方面采取了非常不同的方法。本质上，Strattic在其服务器上为您部署了一个完整的WordPress设置。您可以通过WordPress管理界面像平常一样管理内容。Strattic甚至支持大多数标准WordPress主题和许多插件，但由于静态网站文件的性质，您可能需要首先检查与您最喜欢的插件的兼容性（[http://mng.bz/QW6Q](http://mng.bz/QW6Q)）。
- en: When you are ready to publish, you use the installed Strattic plug-in to deploy
    a Jamstack version of the site to Strattic’s servers (figure 9.11). The site looks
    and feels just like a WordPress site, but it is built with static files and serverless
    APIs. These serverless APIs make things like site search, comments, forums, and
    other dynamic functionality work.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当您准备好发布时，您可以使用已安装的Strattic插件将网站的Jamstack版本部署到Strattic的服务器上（图9.11）。网站的外观和感觉就像一个WordPress网站，但它是由静态文件和无服务器API构建的。这些无服务器API使得网站搜索、评论、论坛和其他动态功能得以实现。
- en: '![CH09_F11_Camden2](Images/CH09_F11_Camden2.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F11_Camden2](Images/CH09_F11_Camden2.png)'
- en: Figure 9.11 The Strattic WordPress plug-in provides several publishing options
    for your site. Once the static site code is generated and deployed, you’ll be
    able to view it running on Strattic’s servers.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11 Strattic WordPress插件为您的网站提供了一些发布选项。一旦生成并部署了静态网站代码，您将能够在Strattic的服务器上查看其运行情况。
- en: Keep in mind that even though this is a Jamstack site, by most people’s definition,
    you don’t have access to the frontend files. However, Strattic does give you SFTP
    access to the WordPress PHP files. Strattic offers a free trial but requires a
    paid account after that expires.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，尽管这是一个Jamstack网站，按照大多数人的定义，您无法访问前端文件。然而，Strattic确实提供了对WordPress PHP文件的SFTP访问。Strattic提供免费试用，但试用期过后需要付费账户。
- en: 9.4.3 Stackbit
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.3 Stackbit
- en: Stackbit follows a more traditional Jamstack approach than WeWeb in that it
    leverages SSGs within its site builders. In fact, it supports multiple SSGs as
    well as multiple headless CMS options. The site builder is free to use, and the
    code is pushed to your own GitHub account and deployed on your Netlify account.
    However, the optional site editing suite does require a paid account to use a
    number of the features.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 与WeWeb相比，Stackbit遵循更传统的Jamstack方法，它在网站构建器中利用SSG。实际上，它支持多个SSG以及多个无头CMS选项。网站构建器免费使用，代码推送到你自己的GitHub账户并在你的Netlify账户上部署。然而，可选的网站编辑套件需要付费账户才能使用许多功能。
- en: The first step in building a Jamstack site using Stackbit is to choose a theme
    (figure 9.12). There are 17 different themes to choose from as of this writing,
    based on a number of archetypes, such as a blog or e-commerce. You can add a custom
    theme, but this does require the proper stackbit.yaml configuration file that
    tells Stackbit how to map the content on your page to the content in a CMS.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Stackbit构建Jamstack网站的第一步是选择一个主题（图9.12）。截至本文撰写时，有17种不同的主题可供选择，基于多种原型，如博客或电子商务。你可以添加自定义主题，但这确实需要正确的stackbit.yaml配置文件，该文件告诉Stackbit如何将页面上的内容映射到CMS中的内容。
- en: '![CH09_F12_Camden2](Images/CH09_F12_Camden2.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F12_Camden2](Images/CH09_F12_Camden2.png)'
- en: Figure 9.12 The first step in generating a Jamstack site using Stackbit is choosing
    one of its 17 available themes or uploading a custom theme of your own.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12 使用Stackbit生成Jamstack网站的第一步是选择其17种可用主题之一或上传你自己的自定义主题。
- en: Next, you are brought to a summary screen that allows you to modify the other
    default site build options, as seen in figure 9.13\. The default SSG is Next.js;
    however, you can also choose Jekyll, Hugo, or Gatsby. It’s worth noting that not
    all the available headless CMSs are currently compatible with Next.js within Stackbit’s
    system.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将进入一个摘要屏幕，允许你修改其他默认网站构建选项，如图9.13所示。默认的SSG是Next.js；然而，你也可以选择Jekyll、Hugo或Gatsby。值得注意的是，并非所有可用的无头CMS目前都与Stackbit系统中的Next.js兼容。
- en: '![CH09_F13_Camden2](Images/CH09_F13_Camden2.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F13_Camden2](Images/CH09_F13_Camden2.png)'
- en: Figure 9.13 Once you’ve chosen a theme, you can customize the SSG and headless
    CMS that Stackbit will use. All the code will be pushed to your connected GitHub
    account.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13 一旦你选择了主题，你可以自定义Stackbit将使用的SSG和无头CMS。所有代码都将推送到你连接的GitHub账户。
- en: The default CMS is Git. This is a pure Git-based CMS that manages content directly
    in your connected Git repository. It handles draft and preview changes within
    Stackbit’s editor by maintaining a separate branch for unpublished changes. While
    this option is completely free, you’ll want to consider whether a Git-based CMS
    is the right fit for your project, and you’ll likely require a paid Stackbit account
    if you have multiple content contributors/editors.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 默认内容管理系统（CMS）是Git。这是一个基于Git的纯CMS，它直接管理连接的Git仓库中的内容。它通过维护一个单独的分支来处理Stackbit编辑器内的草稿和预览更改。虽然这个选项完全免费，但你可能需要考虑基于Git的CMS是否适合你的项目，如果你有多个内容贡献者/编辑者，你可能需要付费的Stackbit账户。
- en: The other headless available options are Sanity, Contentful, Netlify CMS, Dato
    CMS (an API-based CMS), and Forestry (a Git-based CMS).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可用的无头选项包括Sanity、Contentful、Netlify CMS、Dato CMS（基于API的CMS）和Forestry（基于Git的CMS）。
- en: You’ll need to connect Stackbit to your GitHub account in order to create a
    site, but, once that is complete, clicking the Create Site button will generate
    all the site files using your chosen theme and SSG, as well as provision your
    headless CMS and populate some default content. If you’ve connected your Netlify
    account, it will also deploy on Netlify. When the site is done generating and
    deploying, you’ll be brought into Stackbit’s content editor. The editor is free
    to use for one user, with some feature limitations, but it’s worth noting that
    the editor is entirely optional. You can modify your code directly in GitHub,
    and your content directly in your chosen CMS.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建网站，你需要将Stackbit连接到你的GitHub账户，但一旦完成，点击创建网站按钮将使用你选择的主题和SSG生成所有网站文件，同时配置你的无头CMS并填充一些默认内容。如果你已经连接了Netlify账户，它也会在Netlify上部署。当网站生成并部署完成后，你将被带到Stackbit的内容编辑器。编辑器对单个用户免费使用，但有一些功能限制，但值得注意的是，编辑器完全是可选的。你可以直接在GitHub中修改你的代码，在你的选择的CMS中直接修改你的内容。
- en: 9.5 What’s next?
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5 接下来是什么？
- en: 'We’ve explored a few different options available to you when choosing a headless
    CMS, and even looked at some tools and resources for integrating these. As we
    discussed in the beginning of the chapter, there are about 87 different options
    for headless CMS, so it may feel overwhelming to make an informed choice. Here
    are just a handful of questions to ask yourself to help refine the options worth
    evaluating:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了在选择无头CMS时您可用的几种不同选项，甚至查看了一些用于集成这些选项的工具和资源。正如我们在本章开头讨论的那样，大约有87种不同的无头CMS选项，因此在做出明智选择时可能会感到不知所措。以下是一些问题，供您自我反思，以帮助您缩小值得评估的选项范围：
- en: '*Does the file-based editing of a Git-based headless CMS fit my project, or
    do I need the added flexibility of an API-based headless CMS?* We discussed the
    pros and cons of each earlier in the chapter to help you decide which option best
    suits your project.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于Git的无头CMS的基于文件的编辑是否适合我的项目，或者我是否需要基于API的无头CMS提供的额外灵活性？* 我们在本章前面讨论了每个选项的优缺点，以帮助您决定哪个选项最适合您的项目。'
- en: '*Does the solution need to be open source?* If so, a solution like Netlify
    CMS or Strapi is worth investigating. You can find other open source options by
    going go Jamstack’s list of headless CMSs and filtering by open source licenses.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*解决方案是否需要开源？* 如果是，那么像Netlify CMS或Strapi这样的解决方案值得调查。您可以通过访问Jamstack的无头CMS列表并按开源许可证进行筛选来找到其他开源选项。'
- en: '*Do we have an existing CMS that I can leverage as headless (e.g., WordPress)?
    If so, do we want to continue to maintain and manage the CMS ourselves or consider
    moving to a hosted third-party service?* In many cases, when it is possible, keeping
    your existing CMS will be the most straightforward solution, as it doesn’t require
    retraining all of the content contributors on a new system. This can also ease
    getting buy-in on moving to the Jamstack from other stakeholders.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*我们是否有一个可以将其作为无头（例如，WordPress）利用的现有CMS？如果是，我们是想继续自行维护和管理CMS，还是考虑迁移到托管第三方服务？*
    在许多情况下，如果可能，保留现有的CMS将是最直接的方法，因为它不需要对所有内容贡献者进行新系统的再培训。这也可以使其他利益相关者更容易接受迁移到Jamstack。'
- en: '*Does the editing experience meet the needs of my content editors? How difficult
    will it be for them to learn?* If a user hasn’t worked in Markdown before, it
    can be a difficult transition. If a user is used to page-based editing (like in
    WordPress), then a move to a modular system used by an API-based CMS can take
    some time and training. It may be that these difficult transitions for content
    contributors are unavoidable, but you should at least be aware of them and plan
    for them.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编辑体验是否满足我的内容编辑的需求？他们学习起来会有多难？* 如果用户之前没有使用过Markdown，那么这种过渡可能会很困难。如果用户习惯于基于页面的编辑（如WordPress中的编辑），那么转向由API基于的CMS所使用的模块化系统可能需要一些时间和培训。这些对内容贡献者的困难过渡可能是不可避免的，但您至少应该意识到它们并为此做好准备。'
- en: '*Does the CMS offer integrations with my SSG that will reduce the difficulty
    of connecting our Jamstack frontend to the headless CMS?* Not every CMS has templates
    for every SSG, but many do. Be sure to investigate whether a prebuilt integration
    already exists before you start building one from scratch.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CMS是否提供与我的SSG的集成，这将减少将我们的Jamstack前端连接到无头CMS的难度？* 并非每个CMS都有针对每个SSG的模板，但许多都有。在从头开始构建之前，务必调查是否已经存在预构建的集成。'
- en: Obviously, there will be more questions specific to the needs of your project
    and your team, but even just asking these five will, hopefully, help you narrow
    down the options before evaluating them.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，将会有更多针对您项目和团队需求的具体问题，但即使只问这些问题，也希望能够帮助您在评估之前缩小选项范围。
- en: For a good list of additional considerations when choosing a headless CMS, check
    out “How to Choose a Headless CMS” by Emmanuel Tissera in *Smashing Magazine*
    ([http://mng.bz/aD57](http://mng.bz/aD57)).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取选择无头CMS时需要考虑的额外好列表，请参阅Emmanuel Tissera在*Smashing Magazine*上发表的“如何选择无头CMS”（[http://mng.bz/aD57](http://mng.bz/aD57)）。
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'There are two main types of headless CMSs: Git-based and API-based. Git-based
    CMSs store content in files that are managed within your Git repository and edited
    via an admin UI. API-based CMSs store and edit the content within their systems
    and provide it to your application via an API.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无头CMS主要有两种类型：基于Git的和基于API的。基于Git的CMS将内容存储在Git仓库中管理的文件中，并通过管理UI进行编辑。基于API的CMS在其系统中存储和编辑内容，并通过API将其提供给您的应用程序。
- en: The primary benefit of a Git-based headless CMS is cost. The primary benefit
    of an API-based headless CMS is the ease of content reuse.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Git的无头CMS的主要优势是成本。基于API的无头CMS的主要优势是内容重用的便捷性。
- en: Contentful is a popular API-based headless CMS that is configured and managed
    entirely via its admin UI. Sanity is another popular API-based headless CMS, but
    it is configured entirely via JavaScript and edited via the open source Sanity
    Studio.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Contentful是一个流行的基于API的无头CMS，它完全通过其管理UI进行配置和管理。Sanity是另一个流行的基于API的无头CMS，但它完全通过JavaScript进行配置，并通过开源的Sanity
    Studio进行编辑。
- en: WordPress provides an API that can be used as the backend for a Jamstack site.
    Gatsby provides a number of tools for integrating the API into the Gatsby data
    layer that provides all the data and content for generating sites using Gatsby.
    We walked through getting a local WordPress site connected to a new Gatsby site
    using these tools.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WordPress提供了一个可以作为Jamstack网站后端的API。Gatsby提供了一系列工具，可以将API集成到Gatsby数据层中，该数据层为使用Gatsby生成网站提供所有数据和内容。我们使用这些工具演示了如何将本地WordPress网站连接到新的Gatsby网站。
- en: 'Site builders offer an easy, though generally not free, way to generate a Jamstack
    site that can connect to a variety of headless CMSs. We explored three site builders:
    WeWeb, Strattic, and Stackbit.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网站构建器提供了一种简单（尽管通常不是免费的）的方式来生成可以连接到各种无头CMS的Jamstack网站。我们探索了三个网站构建器：WeWeb、Strattic和Stackbit。
