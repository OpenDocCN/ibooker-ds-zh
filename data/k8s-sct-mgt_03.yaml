- en: 2 An introduction to Kubernetes and Secrets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 Kubernetes 和 Secrets 简介
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Understanding the basic architecture of a Kubernetes cluster
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Kubernetes 集群的基本架构
- en: Deploying an application to Kubernetes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序部署到 Kubernetes
- en: Managing application configuration externally
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部管理应用程序配置
- en: Using Kubernetes Secrets to store sensitive information
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Kubernetes Secrets 存储敏感信息
- en: Because secrets management begins with the initial configuration and the security
    needs of the application, it’s important to fully understand the initial setup
    process. In this chapter, you will learn more about how to manage configurations,
    both insecure and secure, by deploying a simple RESTful Web Service that returns
    a greeting message.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 由于密钥管理始于初始配置和应用程序的安全需求，因此完全理解初始设置过程非常重要。在本章中，您将了解如何通过部署一个简单的 RESTful Web 服务来管理配置，该服务返回一个问候消息，无论是不可靠的还是可靠的。
- en: NOTE You’ll need a Kubernetes cluster to run the implementations in this book.
    You can use any Kubernetes distribution provided by a public cloud or made to
    run it locally.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您需要 Kubernetes 集群来运行本书中的实现。您可以使用任何由公共云提供或本地运行的 Kubernetes 发行版。
- en: The examples in this book are tested using a minikube cluster. Minikube allows
    you to run Kubernetes locally in a *single-node* Kubernetes cluster inside a virtual
    machine (VM) on a laptop. Follow the instructions in appendix A to install your
    Kubernetes cluster, and then return to this chapter to get started.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的示例使用 minikube 集群进行测试。Minikube 允许您在笔记本电脑上的虚拟机（VM）中运行单个节点 Kubernetes 集群内的本地
    Kubernetes。按照附录 A 中的说明安装您的 Kubernetes 集群，然后返回本章开始。
- en: We’ll start by reviewing some basics about Kubernetes architecture and configuration.
    If you are already well versed in Kubernetes, the next few pages, in which we’ll
    establish the initial configuration for your web service, should be very familiar.
    We’ll dive into Kubernetes Secrets after we complete the default setup.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先回顾一些关于 Kubernetes 架构和配置的基本知识。如果您已经非常熟悉 Kubernetes，接下来几页，我们将为您建立 Web 服务的初始配置，应该非常熟悉。在完成默认设置后，我们将深入了解
    Kubernetes Secrets。
- en: 2.1 Kubernetes architecture
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 Kubernetes 架构
- en: The first thing to understand about Kubernetes architecture is there are two
    kinds of Nodes—master and worker Nodes—and in typical production deployments you
    might have several Nodes of each kind.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 了解 Kubernetes 架构的第一件事是存在两种类型的节点——主节点和工作节点——在典型的生产部署中，您可能拥有每种类型的大量节点。
- en: ImportanT The Kubernetes community has started changing the names of the Nodes,
    using more inclusive language (e.g., control plane and secondary Node); we truly
    support this change, but the version of minikube used in this book, has not yet
    implemented this change. To be aligned with minikube output, master and worker
    Nodes are used in this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：Kubernetes 社区已经开始更改节点名称，使用更具包容性的语言（例如，控制平面和二级节点）；我们真正支持这一变化，但本书中使用的 minikube
    版本尚未实施这一变化。为了与 minikube 输出保持一致，本章使用主节点和工作节点。
- en: Figure 2.1 shows an overview of a Kubernetes cluster and the relationship between
    master Nodes and worker Nodes. The worker Node(s) is responsible for running your
    workloads, such as developed services or databases, and the master Node(s) manages
    the worker Nodes and decides where workloads are deployed.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 展示了 Kubernetes 集群的整体概述以及主节点和工作节点之间的关系。工作节点（s）负责运行您的负载，例如开发的服务或数据库，而主节点（s）管理工作节点并决定工作负载的部署位置。
- en: '![](../Images/CH02_F01_Sotobueno3.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F01_Sotobueno3.png)'
- en: Figure 2.1 Overview of Kubernetes architecture with master and worker Nodes
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 主节点和工作节点的 Kubernetes 架构概述
- en: The minimum number of Nodes required to conform to a Kubernetes is just one
    master Node acting as the master and worker Node. Although this might not be the
    typical use case in production, it is typical when developing in the local machine.
    Usually, in production, you will have between three and five master Nodes and
    several worker Nodes, the number of which may depend on the number of workloads
    to deploy and the degree of redundancy you expect in your application. Let’s explore
    what is inside master and worker Nodes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 符合 Kubernetes 要求所需的最少节点数量只有一个主节点，充当主节点和工作节点。尽管这可能在生产环境中不是典型用例，但在本地开发中却是典型情况。通常，在生产环境中，您将拥有三到五个主节点和多个工作节点，其数量可能取决于要部署的工作负载数量以及您期望的应用程序冗余程度。让我们探索主节点和工作节点内部的内容。
- en: 2.1.1 What is a master Node?
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1 什么是主节点？
- en: A *master Node* is responsible for executing several tasks in a Kubernetes cluster;
    for example, it decides where the application is deployed, detects and responds
    to abnormalities, stores the application configuration parameters, and, by default,
    is the place secrets (or sensitive information) of the application are stored.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*主节点*负责在 Kubernetes 集群中执行多个任务；例如，它决定应用程序部署的位置，检测并响应异常，存储应用程序配置参数，并且默认情况下，是存储应用程序秘密（或敏感信息）的地方。'
- en: 'A Kubernetes cluster must have at least one master Node, but typically in production
    environments you may have more than one for redundancy. You will find the next
    four elements inside each master Node:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 集群必须至少有一个主节点，但在生产环境中，您可能为了冗余而拥有多个。您将在每个主节点内部找到以下四个元素：
- en: '`kube-apiserver`—This is the frontend for Kubernetes and exposes the Kubernetes
    API to the Kubernetes users. When an operator runs a command against the Kubernetes
    cluster, it does so through the `api-server`.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kube-apiserver`—这是 Kubernetes 的前端，并向 Kubernetes 用户公开 Kubernetes API。当操作员对
    Kubernetes 集群运行命令时，它通过 `api-server` 来执行。'
- en: '`etcd`—This is a key–value database used to store all cluster data. Every time
    you get information about the cluster, that data is retrieved from `etcd`.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`etcd`—这是一个用于存储所有集群数据的关键值数据库。每次您获取有关集群的信息时，这些数据都是从 `etcd` 中检索的。'
- en: '*scheduler*—This is the process responsible for selecting a Node for running
    workloads on. Factors taken into consideration when selecting the Node on which
    to deploy your workload might depend on its requirements, such as hardware, policy
    constraints, affinity and anti-affinity rules, data locality, and so on.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*调度器*—这是负责选择节点以运行工作负载的过程。在选择部署工作负载的节点时考虑的因素可能取决于其需求，例如硬件、策略约束、亲和力和反亲和力规则、数据本地性等。'
- en: '*controllers*—The main task of controllers is monitoring specific Kubernetes
    resources.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*控制器*—控制器的主要任务是监控特定的 Kubernetes 资源。'
- en: 'There are four major controllers:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个主要的控制器：
- en: '*Node controller*—This controller is responsible for monitoring and acting
    when any Node goes down.'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*节点控制器*—这个控制器负责监控任何节点宕机时采取行动。'
- en: '*Replication controller*—This controller is responsible for ensuring your workloads
    are up and running all the time.'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*副本控制器*—这个控制器负责确保您的工作负载始终处于运行状态。'
- en: '*Endpoint controller*—This controller makes it possible to access the workloads
    with a static IP and DNS name.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*端点控制器*—这个控制器使得使用静态 IP 和 DNS 名称访问工作负载成为可能。'
- en: '*Service account and token controllers*—This creates default accounts and tokens
    for new namespaces.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*服务账户和令牌控制器*—这为新的命名空间创建默认账户和令牌。'
- en: Figure 2.2 shows all the elements that comprise a master Node.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 展示了构成主节点的所有元素。
- en: '![](../Images/CH02_F02_Sotobueno3.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F02_Sotobueno3.png)'
- en: Figure 2.2 Elements of a master Node (`kube-apiserver`, `etcd`, scheduler, and
    controller)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 主节点的元素 (`kube-apiserver`、`etcd`、调度器和控制器)
- en: Now that you know the parts of a master Node, let’s see the parts of a worker
    Node.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了主节点的组成部分，让我们看看工作节点的组成部分。
- en: 2.1.2 What is a worker Node?
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2 什么是工作节点？
- en: A *worker Node* is the instance where your workloads are deployed and run. Since
    workloads in Kubernetes are software containers, the container runtime is hosted
    inside each worker Node.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*工作节点*是部署和运行工作负载的实例。由于 Kubernetes 中的工作负载是软件容器，因此容器运行时托管在每个工作节点内部。'
- en: 'Each worker Node is composed of the following three elements:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 每个工作节点由以下三个元素组成：
- en: '*kubelet*—This is an agent that ensures containers are running in a Pod.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*kubelet*—这是一个代理，确保容器在 Pod 中运行。'
- en: '*proxy*—This is a network proxy that implements part of the Kubernetes `Service`
    concept.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*代理*—这是一个实现了 Kubernetes `Service` 概念一部分的网络代理。'
- en: '*container runtime*—This is responsible for running containers.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*容器运行时*—这是负责运行容器的。'
- en: 'At the time of writing this book, the following runtimes are supported: `Docker`,
    `containerd`, `crio-o`, and any implementation of the Kubernetes Container Runtime
    Interface (CRI). Figure 2.3 shows all the elements that compose a worker Node.
    Now that you have a good understanding of the Kubernetes architecture, let’s start
    using Kubernetes from a developer or operator’s point of view.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，以下运行时得到支持：`Docker`、`containerd`、`crio-o` 以及任何 Kubernetes 容器运行时接口 (CRI)
    的实现。图 2.3 展示了构成工作节点的所有元素。现在您已经很好地理解了 Kubernetes 架构，让我们从开发人员或操作员的视角开始使用 Kubernetes。
- en: '![](../Images/CH02_F03_Sotobueno3.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F03_Sotobueno3.png)'
- en: Figure 2.3 Elements of a worker Node
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 工作节点元素
- en: 2.2 Deploying workloads in Kubernetes
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 在 Kubernetes 中部署工作负载
- en: So far you’ve seen the architecture of a Kubernetes cluster, but as developers,
    you will want to deploy a web service, a database, a message broker, or any other
    element required by your application into Kubernetes. You will explore how a developer
    can interact with Kubernetes by deploying a simple application that returns a
    welcome message. Also, you want to be able to configure them externally from the
    platform or be able to access them using a network protocol.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经看到了 Kubernetes 集群的架构，但作为开发者，您可能希望将 Web 服务、数据库、消息代理或任何其他应用程序所需元素部署到
    Kubernetes 中。您将探索开发者如何通过部署一个返回欢迎信息的简单应用程序来与 Kubernetes 交互。此外，您还希望能够从平台外部配置它们或能够使用网络协议访问它们。
- en: 2.2.1 Deploying a workload
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 部署工作负载
- en: One of the most important Kubernetes resources to deploy a workload to the cluster
    is a *Pod*. Pods are the smallest deployable unit in Kubernetes, composed of a
    group of one or more containers. Each container in a Pod shares IP, storage, resources,
    and lifecycle.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 将工作负载部署到集群的最重要 Kubernetes 资源之一是 *Pod*。Pod 是 Kubernetes 中可部署的最小单元，由一个或多个容器组成。Pod
    中的每个容器共享 IP、存储、资源和生命周期。
- en: Pods are the units where business workloads are running (e.g., a service API,
    a database, and a mailing server). An analogy helpful for understanding what a
    Pod is, is thinking it’s a sort of VM (of course it isn’t) that runs processes,
    where each process shares the resources, network, and lifecycle of the VM. In
    a Pod, it’s the same concept, but instead of running processes, it runs containers.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Pods 是业务工作负载运行的单元（例如，服务 API、数据库和邮件服务器）。理解 Pod 的一个有用的类比是将其视为一种 VM（当然不是），在其中运行进程，每个进程共享
    VM 的资源、网络和生命周期。在 Pod 中，概念相同，但不是运行进程，而是运行容器。
- en: There are many ways to deploy a Pod in a Kubernetes cluster, but one of the
    most common is describing the deployment in a YAML file and applying it using
    the `kubectl` CLI tool. To create a YAML file containing the Pod definition, open
    a new terminal window, and in a new directory create a file called `greeting-pod.yaml`,
    defining the container image that belongs to the Pod, as shown in the following
    listing.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 集群中部署 Pod 有许多方法，但最常见的一种是描述 YAML 文件中的部署，并使用 `kubectl` CLI 工具应用它。要创建包含
    Pod 定义的 YAML 文件，请打开一个新的终端窗口，在新的目录中创建一个名为 `greeting-pod.yaml` 的文件，定义属于 Pod 的容器镜像，如下所示。
- en: Listing 2.1 Creating a Pod
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.1 创建 Pod
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ① Sets the file as type Pod
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将文件设置为 Pod 类型
- en: ② Gives a name to the Pod
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ② 为 Pod 赋予一个名称
- en: ③ Sets the container image to run
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 设置要运行的容器镜像
- en: 'Once you have created the file, you can apply it to the cluster using the `kubectl
    apply` subcommand:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 创建文件后，您可以使用 `kubectl apply` 子命令将其应用到集群中：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ImportanT Minikube doesn’t require you to authenticate to access the cluster.
    But depending on the Kubernetes implementation, you may need to authenticate before
    running this command.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：Minikube 不需要您进行身份验证即可访问集群。但根据 Kubernetes 的实现方式，您可能需要在运行此命令之前进行身份验证。
- en: 'You need to wait until the Pod is allocated into a Node and it is ready to
    be accessed. To do that, use the `kubectl wait` subcommand in the terminal:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要等待 Pod 被分配到节点并且可以访问。为此，请在终端中使用 `kubectl wait` 子命令：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now validate that the Pod is allocated correctly by getting the Pod’s status:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过获取 Pod 的状态来验证 Pod 是否正确分配：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A Pod is allocated into a Node and starts correctly, as the final status is
    `Running`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 被分配到节点并正确启动，因为最终状态是 `Running`。
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ① Possible statuses are Pending, Running, Succeeded, Failed, Unknown, Terminating,
    ContainerCreating, and Error.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ① 可能的状态有 Pending、Running、Succeeded、Failed、Unknown、Terminating、ContainerCreating
    和 Error。
- en: 'Let’s do an experiment and delete the Pod you created to see what’s happening
    with its lifecycle:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一个实验，删除您创建的 Pod 来查看其生命周期发生了什么：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Wait a few seconds until the Pod is terminated, and then get the Pod status:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 等待几秒钟直到 Pod 终止，然后获取 Pod 状态：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output (if you’ve waited enough time) will show you the `greeting-demo`
    Pod is no longer available:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 输出（如果您已经等待足够的时间）将显示 `greeting-demo` Pod 已不再可用：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can run the `kubectl` `get` `pods` as many times as you want, but the Pod
    will always disappear forever. So a Pod itself might not be useful in most of
    the cases because if the service dies for any reason, it will become unavailable
    until you redeploy it again manually.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以多次运行 `kubectl get pods`，但 Pod 总是会永远消失。因此，Pod 本身可能在大多数情况下可能没有用，因为如果服务因任何原因死亡，它将变得不可用，直到您手动重新部署它。
- en: The process executed when a service dies (or stops) in an unexpected way (e.g.,
    if the Node where it is running is down, the network is down, or an application
    has a fatal error) is restarting the service to minimize the downtime of the application.
    Before Kubernetes, the process of restarting the service was done (semi)manually,
    but with Kubernetes a service running in a Pod is restarted automatically if it
    is created with a Deployment or ReplicaSet.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务以意外方式死亡（或停止）时（例如，如果运行它的节点关闭，网络关闭或应用程序有致命错误）执行的过程是重启服务以最小化应用程序的停机时间。在 Kubernetes
    之前，重启服务的过程是通过（半）手动完成的，但使用 Kubernetes，如果使用 `Deployment` 或 `ReplicaSet` 创建，Pod 中运行的服务将自动重启。
- en: 2.2.2 Deployment objects
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2 部署对象
- en: Up until now when a Pod has died, it has not restarted automatically; this is
    the nature of a Pod. If you want to add some resiliency to the Pod lifecycle,
    so it restarts automatically when there is an error, then you need to create a
    `ReplicaSet`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，当一个 Pod 死亡时，它并没有自动重启；这是 Pod 的性质。如果您想为 Pod 生命周期添加一些弹性，以便在出现错误时自动重启，那么您需要创建一个
    `ReplicaSet`。
- en: Usually, a ReplicaSet is not created manually but through a `Deployment` resource.
    A `Deployment` always has a ReplicaSet associated with it, so when a service is
    deployed using a `Deployment` resource, it explicitly has a ReplicaSet that monitors
    and restarts a Pod in case of an error, as shown in Figure 2.4.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，ReplicaSet 不是手动创建的，而是通过 `Deployment` 资源创建的。`Deployment` 总是与一个 ReplicaSet
    关联，因此当使用 `Deployment` 资源部署服务时，它明确地有一个 ReplicaSet 来监控和重启 Pod，以防出现错误，如图 2.4 所示。
- en: '![](../Images/CH02_F04_Sotobueno3.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F04_Sotobueno3.png)'
- en: Figure 2.4 Nature of a Deployment
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 部署的性质
- en: To create a Deployment, create a new file called `greeting-deployment.yaml`
    in the terminal window opened before. A Deployment file contains more elements
    than a Pod file. You will need to set the number of Pod replicas required at the
    time you start. A typical value is `1`, but it could be any other number.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个部署，请在之前打开的终端窗口中创建一个名为 `greeting-deployment.yaml` 的新文件。部署文件包含比 Pod 文件更多的元素。您需要在启动时设置所需的
    Pod 副本数量。一个典型的值是 `1`，但可以是任何其他数字。
- en: A deployment must also define the container image that belongs to the Pod and
    the listening port of the container. The Deployment file is shown in the following
    listing.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 部署还必须定义属于 Pod 的容器镜像和容器的监听端口。部署文件如下所示。
- en: Listing 2.2 Creating a deployment
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.2 创建部署
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ① Deployment name
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ① 部署名称
- en: ② Labels set in the Pod
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ② 在 Pod 中设置的标签
- en: ③ Containers section, as seen in the Pod definition
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 如在 Pod 定义中看到的容器部分
- en: 'Once you have created the file, you can apply it to the cluster using the `kubectl
    apply` subcommand:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 创建文件后，您可以使用 `kubectl apply` 子命令将其应用到集群中：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You need to wait until the Pod is allocated into a Node and is ready to be
    accessed. To do that, use the `kubectl wait` subcommand in the terminal:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要等待 Pod 被分配到节点并准备好访问。为此，请在终端中使用 `kubectl wait` 子命令：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Confirm the Pod is started and allocated correctly by getting the Pod status:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过获取 Pod 状态来确认 Pod 已启动并正确分配：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should get something like the following output:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到以下类似输出：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Run the following command to get the Deployment status:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以获取部署状态：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output of a Deployment is slightly different than that of a Pod. In this
    case, the `available` field is the most important one, as it shows you the number
    of replicas that are up and running. Since you set replicas to `1` in the example,
    only one Pod is available through this Deployment:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 部署的输出略不同于 Pod。在这种情况下，`available` 字段是最重要的，因为它显示了正在运行和运行的副本数量。由于您在示例中将副本设置为 `1`，因此只有一个
    Pod 通过此部署可用：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now repeat the previous experiment, and delete the Pod to see what’s happening
    with its lifecycle now. First of all, you need to find the Pod name created in
    the previous deployment file by running the `kubectl get pods` command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重复之前的实验，删除 Pod 以查看其生命周期现在发生了什么。首先，您需要通过运行 `kubectl get pods` 命令找到之前部署文件中创建的
    Pod 名称：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Get the Pod name, in your case `greeting-demo-deployment-7884dd68c8-4nf6q`,
    and delete it:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 获取Pod名称，在你的情况下是`greeting-demo-deployment-7884dd68c8-4nf6q`，然后删除它：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Wait a few seconds until the Pod is terminated, and get the Pod status:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 等待几秒钟直到Pod被终止，并获取Pod状态：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now the output is different from the previous section when you only created
    one Pod. Notice that now there is a new Pod running. You can see that the Pod
    is new by checking two fields: the `name` of the Pod, which is different than
    in the previous case, and the `age`, which is nearest your time:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的输出与之前只创建了一个Pod的章节不同。注意，现在有一个新的Pod正在运行。你可以通过检查两个字段来看到Pod是新的：Pod的`name`，与之前的情况不同，以及`age`，它接近你的时间：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The Pod has `Deployment` with a `ReplicaSet` associated; therefore, it has been
    restarted automatically. Now that you know how to deploy your workloads correctly,
    it is time to see how you can access them.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Pod与`Deployment`和`ReplicaSet`相关联；因此，它已经被自动重启。现在你知道如何正确部署你的工作负载，是时候看看你如何访问它们了。
- en: Services
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 服务
- en: So far, you’ve deployed an application to the Kubernetes cluster; however, each
    Pod that belongs to a Deployment gets its own IP address. Since Pods are, by definition,
    ephemeral, they are created and destroyed dynamically, and new IP addresses are
    assigned dynamically as well. Reaching these pods via IP addresses might not be
    the best choice, as they might be invalid in the future.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经将应用程序部署到了Kubernetes集群中；然而，属于每个部署的Pod都会获得自己的IP地址。由于Pod按定义是短暂的，它们会动态地创建和销毁，新的IP地址也会动态分配。通过IP地址访问这些Pod可能不是最佳选择，因为它们在未来可能会无效。
- en: A Kubernetes service is the way to expose a set of Pods with a stable DNS name
    and IP address, which will load balance across them. With the `greeting-demo`
    Deployment from the previous example done, it is time to create a service, so
    we can access it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes服务是将一组Pod通过稳定的DNS名称和IP地址暴露出来的方式，它们之间将进行负载均衡。在完成上一个示例中的`greeting-demo`部署之后，现在是时候创建一个服务，以便我们可以访问它。
- en: But before that, we’ll introduce the concept of labels in Kubernetes. A *label*
    is a key–value pair associated with Kubernetes resources with the main purpose
    of identifying those objects from the user’s point of view. For example, you could
    set a Deployment with a custom label to identify it as a Deployment that belongs
    to the production environment.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍这个概念之前，我们将先介绍Kubernetes中的标签概念。标签是一个与Kubernetes资源相关联的键值对，其主要目的是从用户的角度识别这些对象。例如，你可以设置一个带有自定义标签的部署，以标识它属于生产环境的部署。
- en: 'If you look carefully at the previous Deployment, you’ll see there is a label
    defined with the key `app` and value `greeting-demo` applied to all Pods created:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细查看之前的部署，你会看到有一个带有键`app`和值`greeting-demo`的标签被应用到所有创建的Pod上：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The set of Pods targeted by a Service is usually determined by the labels registered
    in the Pods. Now you’ll expose the Pods created in the previous Deployment using
    a service that selects the Pods with the `app: greeting-demo` label.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '服务针对的Pod集通常由Pod中注册的标签确定。现在你将使用一个选择带有`app: greeting-demo`标签的Pod的服务来暴露之前部署中创建的Pod。'
- en: Create a new file called `greeting-service.yaml` in the working directory. The
    service definition should configure the port mapping between `containerPort` defined
    in the Deployment (`8080`) and the exposed port you choose to be exposed by the
    service. Moreover, you need to define the selector value setting the labels of
    `greeting-demo` Pods. The service file should look like the one shown in the following
    listing.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作目录中创建一个名为`greeting-service.yaml`的新文件。服务定义应该配置部署中定义的`containerPort`（`8080`）与服务暴露的端口的映射。此外，你需要定义选择器值，设置`greeting-demo`
    Pods的标签。服务文件应该看起来像以下列表中所示。
- en: Listing 2.3 Creating a service
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.3 创建服务
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once you have created the file, you can apply it to the cluster using `kubectl`
    `apply` subcommand:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了文件，你可以使用`kubectl`的`apply`子命令将其应用到集群中：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Since you are using minikube, there will be no external IP to access the service,
    and the minikube address must be used. You can validate there is no external IP
    associated with the created service by running the following command in the terminal
    window:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你正在使用minikube，将没有外部IP可以访问服务，必须使用minikube地址。你可以在终端窗口中运行以下命令来验证创建的服务没有关联外部IP：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You should see that the `external IP` of the `the-service` service remains in
    `Pending` status.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到`the-service`服务的`external IP`仍然处于`Pending`状态。
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the terminal window, run the following command to set the connection values
    as environment variables to access the service:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端窗口中，运行以下命令将连接值作为环境变量设置以访问服务：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ① The access port is randomly assigned, not using the exposed port set in your
    service definition.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ① 访问端口是随机分配的，不使用你在服务定义中设置的公开端口。
- en: 'Next you can query the service by using `curl` tool:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以使用 `curl` 工具查询服务：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The greeting application returns a `Hello World` message as response to the
    request.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎应用程序对请求返回 `Hello World` 消息。
- en: 'ImportanT In the case of running Kubernetes in a public cloud, an external
    IP will become a real IP in a few seconds. You can get the external IP value by
    getting the service configuration:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：在公共云中运行 Kubernetes 的情况下，外部 IP 将在几秒钟内变成一个真实 IP。你可以通过获取服务配置来获取外部 IP 值：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Clean-up
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 清理
- en: 'Before you can jump to the following concept, it is time to delete the application
    you’ve deployed in this section. To do that, you can use `kubectl delete` command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在你跳到以下概念之前，现在是时候删除你在本节中部署的应用程序了。为此，你可以使用 `kubectl delete` 命令：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The service deliberately isn’t deleted, as you will have a use for it later
    on.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 服务故意没有被删除，因为稍后你将需要使用它。
- en: 2.2.3 Volume
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.3 卷
- en: A Kubernetes *volume* is a directory containing some data that is accessible
    to the containers running inside Pods. The physical storage of the volume is determined
    by the volume type used. For example, the `hostPath` type uses the worker Node
    file system to store the data, or `nfs` uses the *NFS* (Network File System) to
    store the data.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的 *volume* 是一个包含一些数据的目录，这些数据可以被运行在 Pods 内部的容器访问。卷的物理存储由所使用的卷类型决定。例如，`hostPath`
    类型使用工作节点文件系统来存储数据，或者 `nfs` 使用 *NFS*（网络文件系统）来存储数据。
- en: Kubernetes volumes is a vast topic, as it is related to persistence storage,
    and it is outside the scope of this book. You will use volumes in this book but
    only as a way of mounting ConfigMaps and Secrets. If you are not familiar with
    these, don’t fear; we’ll cover them in the following sections.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 卷是一个广泛的话题，因为它与持久化存储相关，并且超出了本书的范围。你将在本书中使用卷，但仅作为挂载 ConfigMaps 和 Secrets
    的方式。如果你不熟悉这些，不要害怕；我们将在接下来的章节中介绍它们。
- en: 2.3 Managing application configuration
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 管理应用程序配置
- en: In the previous sections, you’ve seen how to deploy an application to a Kubernetes
    cluster with a welcome message *hardcoded* into the application. In this section,
    you will set the welcome message of the application externally from a configuration
    parameter.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，你已经看到了如何将带有硬编码欢迎消息的应用程序部署到 Kubernetes 集群中。在本节中，你将外部设置应用程序的欢迎消息，从一个配置参数中设置。
- en: 2.3.1 ConfigMaps
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 ConfigMaps
- en: A *ConfigMap* is a Kubernetes object used to store nonconfidential data in map
    form. One of the advantages of a ConfigMap is that it lets you externalize environment
    configuration data from the application code, setting specfic values depending
    on the cluster, as seen in figure 2.5.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*ConfigMap* 是一个 Kubernetes 对象，用于以映射形式存储非机密数据。ConfigMap 的一个优点是它允许你将环境配置数据从应用程序代码外部化，根据集群设置特定的值，如图
    2.5 所示。'
- en: '![](../Images/CH02_F05_Sotobueno3.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F05_Sotobueno3.png)'
- en: Figure 2.5 Injection of a ConfigMap
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 ConfigMap 注入
- en: The configuration map can be injected into a Pod to be consumed as an environment
    variable or a volume. The application that has been deployed in the previous sections
    of this chapter returns a default welcome message (`Hello World`), but this welcome
    message is decoupled from the code, so you can set it externally. Listing 2.4
    shows the logic in the service that loads the welcome message to get back to the
    caller.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 配置映射可以被注入到 Pod 中，作为环境变量或卷来使用。在本章前面的部分中已部署的应用程序返回默认的欢迎消息（`Hello World`），但这个欢迎消息与代码解耦，因此你可以外部设置它。列表
    2.4 展示了服务中加载欢迎消息的逻辑，以便返回给调用者。
- en: First of all, the code checks if there is a `GREETING_MESSAGE` environment variable
    set. If there isn’t one set, then it tries to load a `properties` file located
    at /etc/config/conf.properties with the `greeting.message` key defined inside
    the file. Otherwise, the default message is returned to the caller.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码检查是否设置了 `GREETING_MESSAGE` 环境变量。如果没有设置，那么它尝试加载位于 /etc/config/conf.properties
    的 `properties` 文件，其中定义了 `greeting.message` 键。否则，将返回默认消息给调用者。
- en: Listing 2.4 Greeting service
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.4 欢迎服务
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Let’s start configuring the application externally, using a ConfigMap.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用 ConfigMap 外部配置应用程序。
- en: Environment variables
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量
- en: One of the ways to get a value from a ConfigMap is injecting it as an environment
    variable into the Pod. Then you can get the environment variables in your applications
    using whatever methods the programming language provides you.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 从 ConfigMap 获取值的一种方法是将它作为环境变量注入到 Pod 中。然后你可以使用编程语言提供的任何方法在你的应用程序中获取环境变量。
- en: The most important part of a ConfigMap resource is the `data` section. This
    is the field where you will define the configuration items in the form of key–values.
    Create a ConfigMap resource named `greeting-config.yaml` with `greeting.message`
    as the configuration key and `Hello Ada` as configuration value, as shown in the
    following listing.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMap 资源最重要的部分是 `data` 部分。这是你将定义配置项的地方，形式为键值对。创建一个名为 `greeting-config.yaml`
    的 ConfigMap 资源，其中 `greeting.message` 是配置键，`Hello Ada` 是配置值，如下所示。
- en: Listing 2.5 Creating a ConfigMap
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.5 创建 ConfigMap
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ① Configuration values set as key–value properties
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将配置值设置为键值属性
- en: 'This ConfigMap creates a configuration item with a new welcome message. Apply
    it like any other Kubernetes resource to the cluster using `kubectl` `apply`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此 ConfigMap 创建了一个带有新欢迎消息的配置项。像其他 Kubernetes 资源一样，使用 `kubectl apply` 将其应用到集群中：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The ConfigMap is created, but it is just a configuration element. You now need
    to change the previous deployment file, so it gets the configuration from the
    ConfigMap, and inject it inside the container as an environment variable.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMap 已经创建，但它只是一个配置元素。你现在需要更改之前的部署文件，以便它从 ConfigMap 获取配置，并将其作为环境变量注入到容器内部。
- en: Create a new file called `greeting-deployment-configuration.yaml` in the working
    directory. This Deployment file will look similar to the one you created previously,
    except it will contain an `env` section, which sets the environment variable (`GREETING_MESSAGE`)
    to be created inside the Pod. The value of the environment variable is taken from
    the `greeting-config` configuration map created previously. The file should look
    like the one shown in the following listing.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作目录中创建一个名为 `greeting-deployment-configuration.yaml` 的新文件。这个 Deployment 文件将类似于你之前创建的文件，但它将包含一个
    `env` 部分，该部分设置要在 Pod 内部创建的环境变量（`GREETING_MESSAGE`）。环境变量的值来自之前创建的 `greeting-config`
    配置映射。文件应类似于以下列表所示。
- en: Listing 2.6 Creating a deployment with ConfigMaps
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.6 创建带有 ConfigMaps 的部署
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ① Defines the name of the environment variable to use
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定义要使用的环境变量名称
- en: ② Sets the name of the ConfigMap to use
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ② 设置要使用的 ConfigMap 的名称
- en: ③ Sets the key that will get the value
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 设置获取值的键
- en: 'Apply it to the cluster by running the `kubectl apply` command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行 `kubectl apply` 命令将其应用到集群中：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `GREETING_MESSAGE` environment variable is created inside the `greeting-demo`
    container, with `Hello Ada` as value. Since your application is aware of this
    variable, the message sent back is the one configured in the ConfigMap under the
    `greeting .message` key. Now check it: with `IP` and `PORT` environment variables
    already set, as explained in section 2.2.2 you can query the service and see the
    message has been updated to the configured one:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `greeting-demo` 容器内部创建了一个名为 `GREETING_MESSAGE` 的环境变量，其值为 `Hello Ada`。由于你的应用程序知道这个变量，返回的消息是
    ConfigMap 中 `greeting .message` 键下配置的消息。现在检查一下：由于已经设置了 `IP` 和 `PORT` 环境变量，如第 2.2.2
    节所述，你可以查询服务并看到消息已更新为配置的消息：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`Hello Ada` is returned as a response, as it is the message configured in the
    ConfigMap. Now that you’ve seen how to configure your application using a ConfigMap
    and injecting the values as environment variables, let’s move on to injecting
    this configuration value as a file.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的响应是 `Hello Ada`，因为它是在 ConfigMap 中配置的消息。现在你已经看到了如何使用 ConfigMap 配置应用程序并将值作为环境变量注入，让我们继续将此配置值作为文件注入。
- en: Volume
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 卷
- en: So far, you’ve seen that a ConfigMap can be injected as an environment variable,
    which is a perfect choice when you are moving legacy workloads to Kubernetes,
    but you can also mount a ConfigMap as a file using volumes. Since the application
    can be configured using a properties file, you’ll write a new properties file
    inside the container using a ConfigMap and volumes.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到 ConfigMap 可以作为环境变量注入，这在将遗留工作负载迁移到 Kubernetes 时是一个完美的选择，但你也可以使用卷将
    ConfigMap 挂载为文件。由于应用程序可以使用属性文件进行配置，你将使用 ConfigMap 和卷在容器内编写一个新的属性文件。
- en: Create a ConfigMap resource named greeting-config-properties.yaml in the working
    directory. To define the properties file, in the `data` section, set the filename
    required by your application (`conf.properties`) as a key and the content of the
    properties file embedded as a value. The new Deployment file is shown in the following
    listing.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作目录中创建一个名为 greeting-config-properties.yaml 的 ConfigMap 资源。为了定义属性文件，在 `data`
    部分，将应用程序所需的文件名（`conf.properties`）作为键，将属性文件的内容嵌入作为值。新的 Deployment 文件如下所示。
- en: Listing 2.7 Creating a ConfigMap
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.7 创建 ConfigMap
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ① This is the filename of the properties file. The file content is embedded.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ① 这是属性文件的文件名。文件内容是嵌入的。
- en: 'Apply it to the cluster by running `kubectl` `apply` command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行 `kubectl apply` 命令将其应用到集群中：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now you need to materialize the config.properties file from the ConfigMap to
    the container. For such a task, you need to define a Kubernetes volume in the
    container definition and store the content placed in the ConfigMap inside it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要将 config.properties 文件从 ConfigMap 物化到容器中。为此任务，你需要在容器定义中定义一个 Kubernetes
    卷，并将 ConfigMap 中放置的内容存储在其中。
- en: 'Create a new file named `greeting-deployment-properties.yaml` in the working
    directory. In the Deployment file, you need to define two big things: the volume
    configuration and the ConfigMap where content is retrieved.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作目录中创建一个名为 `greeting-deployment-properties.yaml` 的新文件。在 Deployment 文件中，你需要定义两个重要的事情：卷配置和内容检索的
    ConfigMap。
- en: In the `volumeMounts` section, set the name of the volume (`application-config`)
    and the directory where the volume is mounted. Your application will read the
    configuration properties file from /etc/config. The second thing you need to do
    is link the ConfigMap to the volume, so the configuration file will be created
    inside the defined volume with a specific name (`conf.properties`) and the content
    that was defined in the ConfigMap. Figure 2.6 shows the relationship between both
    elements.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `volumeMounts` 部分中，设置卷的名称（`application-config`）和卷挂载的目录。你的应用程序将从 /etc/config
    读取配置属性文件。你需要做的第二件事是将 ConfigMap 链接到卷上，这样配置文件就会在定义的卷内以特定的名称（`conf.properties`）和
    ConfigMap 中定义的内容创建。
- en: The Deployment file injecting configuration in a volume is shown in the following
    listing.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中显示了在卷中注入配置的 Deployment 文件。
- en: Listing 2.8 Creating a deployment with ConfigMap
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.8 使用 ConfigMap 创建部署
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ① Sets a name to the mount
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ① 为挂载设置名称
- en: ② Sets the directory where the volume is mounted
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ② 设置挂载卷的目录
- en: ③ Links volumeMounts and volumes fields
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 链接 volumeMounts 和 volumes 字段
- en: ④ Sets the ConfigMap name to use as a volume
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 设置用作卷的 ConfigMap 名称
- en: ⑤ Key value to materialize
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 要物化的键值
- en: ⑥ Filename where content is materialized
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 内容物化的文件名
- en: '![](../Images/CH02_F06_Sotobueno3.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F06_Sotobueno3.png)'
- en: Figure 2.6 Injecting ConfigMaps
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 注入 ConfigMap
- en: 'Apply it to the cluster by running the `kubectl` `apply` command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行 `kubectl apply` 命令将其应用到集群中：
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The container that is started contains a new file at the /etc/config/conf.properties
    directory, and the file content is the one embedded in the ConfigMap. Now check
    that the configured value in the properties file is used by the service. With
    `IP` and `PORT` environment variables already set as explained in section 2.2.2
    you can query the service and see that the message has been updated to the configured
    one:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 启动的容器在 /etc/config/conf.properties 目录下包含一个新文件，文件内容是嵌入在 ConfigMap 中的。现在检查属性文件中配置的值是否被服务使用。根据
    2.2.2 节中所述，已经设置了 `IP` 和 `PORT` 环境变量，你可以查询服务并看到消息已更新为配置的值：
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: A `Hello Alexandra` message is returned, as it is the value configured in the
    Config-Map. You can use both approaches to inject all configuration values from
    a ConfigMap into a container, but what is the best approach? Let’s explore some
    use cases to determine how best to proceed.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 返回了 `Hello Alexandra` 消息，因为它是在 Config-Map 中配置的值。你可以使用这两种方法将 ConfigMap 中的所有配置值注入到容器中，但最好的方法是什么？让我们通过一些用例来探索如何最佳地操作。
- en: The differences between environment variables and volumes
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量和卷之间的区别
- en: In this section you will explore when to use environment variables and when
    to use volumes. The *environment variables* approach is usually used when working
    with a legacy application that can be configured using environment variables and
    you can’t or don’t wish to update the source code. The *volumes* approach can
    be used when working with greenfield applications or applications configured using
    a file. The configuration process is easier with the volumes approach if the application
    requires to set multiple configuration properties, as you configure all of them
    at once in the file. Moreover, the content of a volume is refreshed by Kubernetes
    if the ConfigMap gets updated. Of course, your application needs to handle this
    use case and provide a reload configuration capability too. Keep in mind that
    this sync process does not happen immediately; there is a delay between the change,
    and the kubelet syncs the change as well as the time to live (TTL) of the ConfigMap
    cache.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将探索何时使用环境变量以及何时使用卷。*环境变量*方法通常用于与可以使用环境变量配置且无法或不想更新源代码的遗留应用程序一起使用。*卷*方法可以用于处理绿色字段应用程序或使用文件配置的应用程序。如果应用程序需要设置多个配置属性，则使用卷方法配置过程更简单，因为您可以在文件中一次性配置所有这些属性。此外，如果ConfigMap被更新，Kubernetes会刷新卷的内容。当然，您的应用程序需要处理此用例并提供重新加载配置的能力。请注意，此同步过程不会立即发生；更改与kubelet同步更改之间存在延迟，以及ConfigMap缓存的生存时间（TTL）。
- en: 'TIP If refreshing the configuration values is a key feature of your application,
    there is a more deterministic approach you may take: using the Reloader project.
    `Reloader` is a Kubernetes controller that watches changes in ConfigMaps and Secrets
    and performs rolling upgrades on Pods with their associated `Deployment`, `StatefulSet`,
    `DaemonSet` and `DeploymentConfig`. It has the advantage that it works in both
    the environment variables and volumes approaches, and you do not need to update
    the service source code to handle this use case, as the application is restarted
    during the rolling update. However, there is the drawback of having to install
    the `Reloader` controller inside the cluster.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 如果刷新配置值是您应用程序的关键功能，您可以采取更确定性的方法：使用Reloader项目。`Reloader`是一个Kubernetes控制器，它监视ConfigMaps和Secrets中的更改，并对与其关联的`Deployment`、`StatefulSet`、`DaemonSet`和`DeploymentConfig`的Pod执行滚动升级。它的优点是它可以在环境变量和卷方法中工作，并且您不需要更新服务源代码来处理此用例，因为应用程序在滚动更新期间会重新启动。然而，缺点是必须在集群内部安装`Reloader`控制器。
- en: So far, you’ve seen the first of the two Kubernetes approaches for injecting
    configuration data into a container. But ConfigMaps content is not secret nor
    encrypted, as it is in plain text. This means the data has no confidentiality.
    If you are trying to configure a database URL, port, or database configuration
    like timeouts, retries, or packet size, you can use ConfigMaps without much concern
    regarding the security issues. But what about with parameters such as database
    username, database password, and API key, for which confidentiality is very important?
    For these parameters, you will need to use the second type of Kubernetes object
    that can inject configuration data into a container.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经看到了两种将配置数据注入容器的Kubernetes方法中的第一种。但ConfigMaps的内容既不是秘密也不是加密的，因为它是以纯文本形式存在的。这意味着数据没有保密性。如果您试图配置数据库URL、端口或数据库配置，如超时、重试或数据包大小，您可以使用ConfigMaps而无需过多关注安全问题。但对于数据库用户名、数据库密码和API密钥等需要高度保密性的参数，您将需要使用第二种可以注入配置数据到容器的Kubernetes对象。
- en: 2.4 Using Kubernetes Secrets to store sensitive information
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 使用Kubernetes Secrets存储敏感信息
- en: 'Let’s move the example forward: suppose that after some testing, you decide
    that the greeting message is sensitive information, and as such you need to store
    it as a Kubernetes Secret. A *Secret* is a Kubernetes object used to store sensitive
    or confidential data, like passwords, API keys, SSH keys, and so on. Secrets are
    similar to ConfigMaps in that both approaches are used to inject configuration
    properties inside a container; however, the former approach is secure, while the
    latter is not. They are created in similar manners (with the difference being
    the `kind` field, which specifies the type of object), and they are similarly
    exposed inside a container (as environment variables or mounting as a volume).
    But obviously, there are some differences, which we will explore in the following
    sections.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进这个例子：假设经过一些测试后，你决定问候信息是敏感信息，因此需要将其作为 Kubernetes Secret 存储。*Secret* 是一个
    Kubernetes 对象，用于存储敏感或机密数据，如密码、API 密钥、SSH 密钥等。Secrets 与 ConfigMaps 类似，因为两种方法都用于在容器内注入配置属性；然而，前者是安全的，而后者则不是。它们以类似的方式创建（区别在于
    `kind` 字段，它指定了对象的类型），并且以类似的方式在容器内公开（作为环境变量或挂载为卷）。但显然，它们之间有一些区别，我们将在以下章节中探讨。
- en: 2.4.1 Secrets are encoded in Base64
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.1 Secrets 以 Base64 编码
- en: As discussed in chapter 1, one of the big differences between Secrets and ConfigMaps
    is how data is stored inside `etcd`. Secrets store data in Base64 format; ConfigMaps
    store data in plain text.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如第 1 章所述，Secrets 和 ConfigMaps 之间的一大区别在于数据在 `etcd` 中的存储方式。Secrets 以 Base64 格式存储数据；ConfigMaps
    以纯文本格式存储数据。
- en: Let’s dig deeper into Base64 format. *Base64* is an encoding schema that represents
    binary and text data in an ASCII string format, converting it into a radix-64
    representation. For example, in Base64 format, `Alex` text data is converted to
    `QWxleA==`. It is very important to keep in mind that Base64 is not an encryption
    method, so any text encoded in Base64 is a masked plain-text.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解 Base64 格式。*Base64* 是一种编码方案，它以 ASCII 字符串格式表示二进制和文本数据，将其转换为 64 进制表示。例如，在
    Base64 格式中，`Alex` 文本数据被转换为 `QWxleA==`。重要的是要记住，Base64 不是一个加密方法，因此任何以 Base64 编码的文本都是被掩蔽的纯文本。
- en: 'Now create a Secret containing a greetings message you’d like to keep confidential.
    The Secret object is similar to the ConfigMap object but contains two possible
    ways of setting data: `data` and `stringData`. `data` is used when you want to
    encode configuration values to Base64 manually, while `stringData` lets you set
    configuration values as unencoded strings that are automatically encoded. Let’s
    create a Secret named `greeting-secret-config.yaml` in the working directory,
    as shown in the following listing, containing the secret message in the `stringData`
    field.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个包含你希望保持机密的问候信息的 Secret。Secret 对象类似于 ConfigMap 对象，但它包含两种设置数据的方式：`data`
    和 `stringData`。`data` 用于当你想手动将配置值编码为 Base64 时，而 `stringData` 允许你以未编码的字符串设置配置值，这些字符串将自动编码。让我们在当前工作目录中创建一个名为
    `greeting-secret-config.yaml` 的 Secret，如下所示，其中包含在 `stringData` 字段中的秘密信息。
- en: Listing 2.9 Creating a Secret
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.9 创建一个秘密
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ① With stringData, it is not necessary to encode to Base64.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ① 使用 stringData，不需要进行 Base64 编码。
- en: 'Apply it to the cluster by running `kubectl apply` command:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行 `kubectl apply` 命令将此应用到集群中：
- en: '[PRE40]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now that the Secret has been created, you need to change the deployment file,
    so it gets the message value from the Secret created in the previous step, and
    inject it inside the container. In the same way, you can inject configuration
    properties from ConfigMaps as environment variables or as volumes.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Secret已经创建，你需要更改部署文件，以便它从之前步骤中创建的 Secret 中获取消息值，并将其注入到容器中。同样，你可以将 ConfigMaps
    中的配置属性作为环境变量或作为卷注入。
- en: You’ll write a deployment file that injects the secret as an environment variable
    in a similar manner to how you did in the ConfigMap section, but in this case,
    instead of using the `configMapKeyRef` key, you will use `secretKeyRef`. Create
    a new file called `greeting-deployment-secret-env.yaml` in the working directory,
    as shown in the following listing.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你将编写一个部署文件，以与 ConfigMap 部分中类似的方式将秘密作为环境变量注入，但在这个案例中，你将使用 `secretKeyRef` 而不是
    `configMapKeyRef`。在当前工作目录中创建一个名为 `greeting-deployment-secret-env.yaml` 的新文件，如下所示。
- en: Listing 2.10 Creating a deplyment with a Secret
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.10 使用 Secret 创建部署
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ① Defines the name of the environment variable to use
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定义要使用的环境变量名称
- en: ② Uses secretKeyRef instead of configMapKeyRef, as it happens with ConfigMaps
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ② 使用 secretKeyRef 而不是 configMapKeyRef，正如 ConfigMaps 中的情况一样
- en: ③ Sets the name of the Secret to be used
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 设置要使用的 Secret 的名称
- en: ④ Sets the key that will get the value
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 设置将获取值的密钥
- en: 'Apply it to the cluster by running the `kubectl apply` command:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行 `kubectl apply` 命令将其应用于集群：
- en: '[PRE42]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now check that the secret value is used by the service when a request is sent.
    With `IP` and `PORT` environment variables already set in the terminal, as explained
    in section 2.2.2, you can query the service and see that the message has been
    updated to the configured one:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在检查当发送请求时服务是否使用了密钥值。在终端中已经设置了 `IP` 和 `PORT` 环境变量，如第 2.2.2 节所述，你可以查询服务并看到消息已更新为配置的值：
- en: '[PRE43]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`Hello Anna` is returned, since it is the value of the secret you configured
    for this application. Of course, don’t do this in production; a secret is something
    you should never expose in the public API, but for this exercise, we thought it
    was a good way to show how secrets work. You can also inject a secret as a volume,
    in a similar way as you did with ConfigMaps.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `Hello Anna`，因为这是为该应用程序配置的密钥的值。当然，在生产环境中不要这样做；密钥是你在公共 API 中永远不应该暴露的东西，但为了这个练习，我们认为这是一种展示密钥如何工作的好方法。你还可以以类似处理
    ConfigMap 的方式将密钥作为卷注入。
- en: In this case, the `items` field is not specified; hence all the keys defined
    in the Secret object are mounted automatically. Since the key of the mounted directory
    is `greeting.message`, a file named `greeting.message` is created at the configured
    volume with `Hello Anna` as the data content.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，未指定 `items` 字段；因此，Secret 对象中定义的所有键都会自动挂载。由于挂载目录的键是 `greeting.message`，因此在配置的卷中创建了一个名为
    `greeting.message` 的文件，其数据内容为 `Hello Anna`。
- en: '[PRE44]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ① Path where secrets are stored
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ① 存储密钥的路径
- en: ② Name of the mount
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ② 挂载的名称
- en: ③ Use secret instead of configMap.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使用 secret 而不是 configMap。
- en: ④ Sets the ConfigMap name to use as volume
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 设置用于卷的 ConfigMap 名称
- en: Now you know the basics of secrets, the difference between ConfigMaps and Secrets,
    and how to inject them into a container. But this is the basic stuff; there are
    still many things you need to do before you can say your application is managing
    the secrets correctly.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了密钥的基本知识，ConfigMap 和 Secrets 之间的区别，以及如何将它们注入到容器中。但这些都是基础知识；在你可以说你的应用程序正确管理密钥之前，还有很多事情要做。
- en: As a reader you might be wondering, “Why is a Secret named *Secret* if it is
    not really secret at all? It is not encrypted; it’s just encoded in Base64.” That
    is a fair question, but keep reading to the end of this chapter to fully understand
    the reasoning behind it.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 作为读者，你可能想知道，“如果 Secret 实际上并不真正保密，为什么它会被命名为 *Secret*？它没有被加密；它只是以 Base64 编码。”这是一个合理的问题，但请继续阅读本章的结尾，以完全理解其背后的推理。
- en: 2.4.2 Secrets are mounted in a temporary file system
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.2 密钥在临时文件系统中挂载
- en: A Secret is only sent to a Node if there is a Pod that requires it. But what’s
    important is that a Secret, even though it is mounted as a volume, is never written
    to disk but in-memory using the `tmpfs` file system. `tmpfs` stands for temporal
    filesystem, and as its name suggests, it is a file system, where data is stored
    in volatile memory instead of persistent storage. When the Pod containing the
    Secret is deleted, the kubelet is responsible for deleting it from memory as well.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当存在需要它的 Pod 时，Secret 才会被发送到 Node。但重要的是，即使 Secret 作为卷挂载，也永远不会写入磁盘，而是使用 `tmpfs`
    文件系统在内存中。`tmpfs` 代表临时文件系统，正如其名称所暗示的，它是一个文件系统，其中数据存储在易失性内存中而不是持久存储。当包含 Secret 的
    Pod 被删除时，kubelet 负责从内存中删除它。
- en: 2.4.3 Secrets can be encrypted at rest
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.3 密钥可以在静止状态下加密
- en: '*Data at rest* is the term for data persisted that is infrequently accessed.
    The configuration properties fall in this category (Secrets are configuration
    properties too), as they are usually stored in files and accessed once at boot-up
    time to be loaded into the application. *Encryption* is the process of converting
    plain text data into ciphertext. After the text is ciphered, only authorized parties
    can decipher the data back to plain text. *Encryption data at rest* then is the
    process of encrypting sensitive data at rest.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*静止数据* 是指持久化但很少访问的数据。配置属性属于这一类别（Secrets 也是配置属性），因为它们通常存储在文件中，并在启动时访问一次以加载到应用程序中。*加密*
    是将明文数据转换为密文的过程。在文本被加密后，只有授权方才能将其解密回明文。*静止数据加密* 就是加密静止状态下的敏感数据。'
- en: Among other things, all data from ConfigMaps and Secrets is stored inside `etcd`
    and is unencrypted by default. Notice that all these elements are data at rest,
    and some should be protected. Kubernetes supports encryption at rest by ciphering
    secret objects in `etcd`, adding a new level of protection against attackers.
    We know this has been a really quick introduction to this topic, but we will explore
    it in greater depth in chapter 4, as this is an important concept for secrets
    and Kubernetes.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他方面，所有来自 ConfigMaps 和机密的数据都存储在 `etcd` 中，并且默认情况下未加密。请注意，所有这些元素都是静态数据，其中一些应该受到保护。Kubernetes
    通过在 `etcd` 中加密机密对象来支持静态加密，为攻击者提供了额外的保护层。我们知道这只是一个对这个主题的快速介绍，但我们将在第 4 章中更深入地探讨它，因为这是机密和
    Kubernetes 的一个重要概念。
- en: 2.4.4 Risks
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.4 风险
- en: You may think that by using Kubernetes Secrets, you are managing your secrets
    correctly, but you are not. Let’s enumerate all the possible security breaches
    a hypothetical attacker could exploit to steal your secrets.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为通过使用 Kubernetes 机密，你正在正确地管理你的机密，但你并没有。让我们列举一个假设的攻击者可能利用的所有可能的安全漏洞来窃取你的机密。
- en: Is it more secure to inject Secrets as environment variables or as volumes?
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 将机密作为环境变量或作为卷注入是否更安全？
- en: Maybe you’re wondering whether it’s best to inject a Secret as an environment
    variable or as a volume. Intuitively, you might think injecting as a volume is
    safer than as an environment variable because if an attacker were to gain access
    to the Pod, listing an environment variable would be easier than searching through
    the whole file system to try to find the secret files. And that’s a fair point,
    but the following example will show how, in terms of security, when there is unwanted
    access to the Pod, both environment variables and volumes offer a similar level
    of security.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你在想，将机密注入为环境变量或作为卷是否更好。直观上，你可能认为将机密作为卷注入比作为环境变量更安全，因为如果攻击者能够访问到 Pod，列出环境变量会比在整个文件系统中搜索尝试找到机密文件要容易。这是一个合理的观点，但以下示例将展示在安全方面，当存在对
    Pod 的未授权访问时，环境变量和卷提供了相似的安全级别。
- en: 'Let’s suppose an attacker gains access to a running Pod, and the Secrets are
    injected as environment variables. The attacker could list all environment variables
    by running the `export` command in a shell:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 假设攻击者获取了对一个正在运行的 Pod 的访问权限，并且机密作为环境变量注入。攻击者可以通过在 shell 中运行 `export` 命令来列出所有环境变量：
- en: '[PRE45]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ① The Secret is compromised.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ① 机密被泄露。
- en: The attacker would easily be able to figure out the values of your secrets.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者很容易就能找出你的机密值。
- en: The other option is using volumes. Since any arbitrary directory can be mounted,
    you may think you are safe because an attacker should need to know where the volume
    is mounted. Well yes, that’s true, but sadly there is a way to find that easily.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是使用卷。由于任何任意目录都可以挂载，你可能认为你是安全的，因为攻击者应该需要知道卷挂载的位置。是的，这是真的，但遗憾的是，有一种方法可以轻易地找到它。
- en: 'If the attacker gains access to a running Pod with Secrets mounted as a volume,
    they could list all the mounted file systems by running the `mount` command in
    a shell:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果攻击者获取了对一个已挂载机密作为卷的正在运行的 Pod 的访问权限，他们可以通过在 shell 中运行 `mount` 命令来列出所有挂载的文件系统：
- en: '[PRE46]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ① Volume mount with Secrets
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ① 使用机密的卷挂载
- en: ② Lists the Secret’s keys
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ② 列出机密的密钥
- en: ③ Prints the Secret’s value
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 打印机密值
- en: There is no perfect solution. One of the advantages of using volumes instead
    of environment variables is that some applications might log the current environment
    variables at boot-up time, which, at the same time, can be sent to a central logging
    system, meaning any security breach in the logging system will expose the secret
    value.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 没有完美的解决方案。使用卷而不是环境变量的一个优点是，某些应用程序可能在启动时记录当前的环境变量，这同时也可以发送到中央日志系统，这意味着日志系统的任何安全漏洞都会暴露机密值。
- en: Is securing Kubernetes Secrets a hopeless task? Of course not. First you need
    to calibrate the chances of an attacker getting access to your Pods, Nodes, and
    infrastructure. Second there are some actions that you can apply to limit access
    to a Pod—for example, removing rights for executing `kubectl exec` or `kubectl
    attach`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 保护 Kubernetes 机密是否是一项无望的任务？当然不是。首先，你需要评估攻击者获取对您的 Pods、节点和基础设施访问权限的可能性。其次，有一些操作可以应用来限制对
    Pod 的访问——例如，移除执行 `kubectl exec` 或 `kubectl attach` 的权限。
- en: Secrets are stored in etcd
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 机密存储在 etcd 中
- en: 'As you read in section 2.1.1, `etcd` is a key–value database where all Kubernetes
    objects are stored, and of course, ConfigMaps and Secrets are no exceptions. The
    process when a Secret is created is as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在 2.1.1 节中读到的，`etcd` 是一个键值数据库，其中存储了所有 Kubernetes 对象，当然，ConfigMaps 和秘密也不例外。创建秘密的过程如下：
- en: A developer or operator creates a new Secret resource and communicates with
    Kubernetes API service to apply it (`kubectl apply -f ...`).
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发者或操作员创建一个新的秘密资源，并与 Kubernetes API 服务通信以应用它（`kubectl apply -f ...`）。
- en: The Kubernetes API service processes the resource and inserts the Secret inside
    `etcd`, under the `/registry/secrets/<namespace>/<secret-name>` key.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes API 服务处理资源，并将秘密插入到 `etcd` 中，位于 `/registry/secrets/<namespace>/<secret-name>`
    键下。
- en: This process is shown in figure 2.7.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程在图 2.7 中展示。
- en: '![](../Images/CH02_F07_Sotobueno3.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.7 存储秘密的过程](../Images/CH02_F07_Sotobueno3.png)'
- en: Figure 2.7 The process of storing a Secret
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 存储秘密的过程
- en: '`etcd` is, after all, a database. Therefore you need to take some aspects into
    consideration:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`etcd` 仍然是一个数据库。因此，您需要考虑以下方面：'
- en: Access to `etcd` must be restricted to admin users. If it isn’t, `etcd` could
    be queried by anyone to get the Secrets.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`etcd` 的访问必须限制为管理员用户。如果不这样做，任何人都可以查询 `etcd` 来获取秘密。'
- en: The contents of the `etcd` database are persisted to disk. Since Secrets are
    not encrypted by default, anyone with access to the disk can read the `etcd` content.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`etcd` 数据库的内容持久化到磁盘。由于秘密默认情况下没有加密，任何有权访问磁盘的人都可以读取 `etcd` 的内容。'
- en: Performing disk backups is a normal operation, but be aware of what’s happening
    with backups, as they contain sensitive information that is not encrypted by default.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行磁盘备份是正常操作，但要注意备份中发生的事情，因为它们包含未加密的敏感信息。
- en: '`etcd` is an external service that is accessed by the Kubernetes API server
    using the network. Make sure to use SSL/TLS for peer-to-peer communication with
    `etcd` (*data in transit*).'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`etcd` 是一个外部服务，由 Kubernetes API 服务器通过网络访问。请确保使用 SSL/TLS 与 `etcd` 进行点对点通信（*传输中的数据*）。'
- en: Base64 is not encryption
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Base64 不是加密
- en: To reiterate once again, as it can be a cause of misinterpretation, Base64 is
    not an encryption method but an encoding method. It is important to remember that
    Secrets are not encrypted by default, and you need to enable the Encryption Data
    at Rest feature to store your Secrets encrypted into `etcd`. This will be covered
    in greater detail in chapter 4\.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调一次，因为这可能导致误解，Base64 不是一个加密方法，而是一种编码方法。重要的是要记住，秘密默认情况下是没有加密的，您需要启用加密静态数据功能来将您的秘密加密存储到
    `etcd` 中。这一点将在第 4 章中详细讨论。
- en: Accessing Pods
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 Pods
- en: 'As you’ve seen before, if an attacker gets access to the Pod, it is relatively
    easy to steal Secrets, even if you are using environment variables or volumes.
    There is another type of attack, related to this one, you should prepare for:
    an attacker who can create a Pod can injecting and reading Secrets. In chapter
    5, we’ll discuss preventing this kind of attack.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您之前看到的，如果攻击者获得了对 Pod 的访问权限，窃取秘密相对容易，即使您正在使用环境变量或卷。还有另一种与这种攻击相关的攻击类型，您应该为此做好准备：能够创建
    Pod 的攻击者可以注入和读取秘密。在第 5 章中，我们将讨论防止这种攻击的方法。
- en: Secrets at source code repositories
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码仓库中的秘密
- en: A Secret can be created using the `kubectl` CLI tool.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `kubectl` CLI 工具可以创建一个秘密。
- en: '[PRE47]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Most of the time, you configure the Secret via a file (either a JSON or YAML),
    which might have the secret data encoded in Base64 and not ciphered. There are
    some risks associated with this approach, as Secrets can be compromised in the
    following situations:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，您通过文件（无论是 JSON 还是 YAML）配置秘密，其中可能包含以 Base64 编码的秘密数据，而不是加密。这种方法存在一些风险，因为秘密可能在以下情况下被泄露：
- en: Sharing the file in an insecure way (e.g., email)
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以不安全的方式共享文件（例如，通过电子邮件）
- en: Committing the file into the source repository
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文件提交到源代码仓库
- en: Losing the file
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 失去文件
- en: Backing up the file without any security
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有任何安全措施地备份文件
- en: Root permissions
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 根权限
- en: Anyone with root permission on any Node can read any secret from the API server
    by impersonating the kubelet. You also need to take care of the infrastructure
    (worker nodes) to avoid a direct attack from the operating system.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 任何具有任何节点上 root 权限的人都可以通过模拟 kubelet 从 API 服务器读取任何秘密。您还需要注意基础设施（工作节点），以避免来自操作系统的直接攻击。
- en: You’ve finished implementing a basic strategy for dealing with secrets and Kubernetes,
    but your work with secrets isn’t complete, as you’ve yet to tackle most of the
    risks you’ve identified in this section. Let’s start from the ground up; chapter
    3 discusses managing secrets from the beginning, which is how to create and manage
    the Kubernetes resource file following the best security principles. Stick around
    because things are about to get interesting.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经完成了处理秘密和 Kubernetes 的基本策略的实施，但你的秘密管理工作还没有完成，因为你还没有解决本节中识别的大多数风险。让我们从头开始；第
    3 章从管理秘密的开始讨论，即如何根据最佳安全原则创建和管理 Kubernetes 资源文件。请留下来，因为接下来事情会变得有趣起来。
- en: Summary
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: A Kubernetes cluster is composed of master and, optionally, worker Nodes.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Kubernetes 集群由主节点和可选的 worker 节点组成。
- en: Any Kubernetes resource and current status of the cluster is stored at the `etcd`
    instance.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何 Kubernetes 资源和集群的当前状态都存储在 `etcd` 实例中。
- en: We discussed deploying an application to Kubernetes.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了将应用程序部署到 Kubernetes。
- en: We covered configuring an application externally with ConfigMaps, either as
    an environment variable or as a file.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们介绍了如何使用 ConfigMaps 在外部配置应用程序，无论是作为环境变量还是作为文件。
- en: Secrets are not so different from ConfigMaps in terms of construction and usage.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建和使用方面，Secrets 与 ConfigMaps 并没有太大的不同。
