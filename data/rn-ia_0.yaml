- en: Part 1
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一部分
- en: Getting started with React Native
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用 React Native
- en: Chapter 1 will get you up and running by going over what React Native is, how
    it works, what its relationship with React is, and when you might want to use
    React Native (and when you might not). This chapter provides an overview of React
    Native’s components, which are at the core of React Native. It concludes with
    creating a small React Native project.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 第一章将通过介绍 React Native 是什么，它是如何工作的，它与 React 的关系，以及你何时可能想要使用 React Native（以及何时可能不使用）来帮助你入门。本章提供了
    React Native 组件的概述，这些组件是 React Native 的核心。它以创建一个小的 React Native 项目结束。
- en: 'Chapter 2 covers state and properties: what they are, how they work, and why
    they’re important in React Native application development. It also covers the
    React Component specification and React lifecycle methods.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 第二章涵盖了状态和属性：它们是什么，如何工作，以及为什么在 React Native 应用程序开发中它们很重要。它还涵盖了 React 组件规范和 React
    生命周期方法。
- en: In chapter 3, you’ll build your first React Native app—a Todo app—from the ground
    up. You’ll also learn about using the developer menu in iOS and Android for, among
    other things, debugging apps.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三章中，你将从零开始构建你的第一个 React Native 应用——待办事项应用。你还将了解如何在 iOS 和 Android 中使用开发者菜单进行调试，以及其他操作。
- en: '1'
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Getting started with React Native
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用 React Native
- en: '*****This chapter covers*****'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*****本章涵盖*****'
- en: Introducing React Native
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 React Native
- en: The strengths of React Native
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Native 的优势
- en: Creating components
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建组件
- en: Creating a starter project
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个入门项目
- en: Native mobile application development can be complex. With the complicated environments,
    verbose frameworks, and long compilation times developers face, developing a quality
    native mobile application is no easy task. It’s no wonder the market has seen
    its share of solutions come onto the scene that attempt to solve the problems
    that go along with native mobile application development and try to make it easier.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 原生移动应用开发可能很复杂。开发者面临复杂的开发环境、冗长的框架和漫长的编译时间，开发高质量的原生移动应用并非易事。市场看到其份额的解决方案出现在场景中，试图解决原生移动应用开发的问题，并试图使其更容易。
- en: At the core of this complexity is the obstacle of cross-platform development.
    The various platforms are fundamentally different and don’t share much of their
    development environments, APIs, or code. Because of this, we must have separate
    teams working on each platform, which is both expensive and inefficient.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这种复杂性的核心是跨平台开发的障碍。各种平台在本质上都是不同的，它们在开发环境、API 或代码方面共享的很少。正因为如此，我们必须为每个平台拥有独立的团队进行工作，这不仅成本高昂，而且效率低下。
- en: But this is an exciting time in mobile application development. We’re witnessing
    a new paradigm in the mobile development landscape, and React Native is on the
    forefront of this shift in how we build and engineer mobile applications. It’s
    now possible to build native performing cross-platform apps as well as web applications
    with a single language and a single team. With the rise of mobile devices and
    the subsequent increase in demand for talent driving developer salaries higher
    and higher, React Native brings to the table the ability to deliver quality applications
    across all platforms at a fraction of the time and cost, while still delivering
    a high-quality user experience and a delightful developer experience.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 但这是移动应用开发的一个激动人心的时期。我们正在见证移动开发领域的一个新范式，React Native 正处于这一转变的前沿，它改变了我们构建和工程化移动应用的方式。现在，我们可以使用单一的语言和单一团队来构建原生性能的跨平台应用以及网络应用。随着移动设备的兴起以及随之而来的人才需求增加，推动开发者薪资不断提高，React
    Native 带来了在所有平台上以极小的时间和成本交付高质量应用的能力，同时仍然提供高质量的用户体验和令人愉悦的开发者体验。
- en: 1.1 Introducing React and React Native
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 介绍 React 和 React Native
- en: React Native is a framework for building native mobile apps in JavaScript using
    the React JavaScript library; React Native code compiles to real native components.
    If you’re not sure what React is, it’s a JavaScript library open sourced by and
    used within Facebook. It was originally used to build user interfaces for web
    applications. It has since evolved and can now also be used to build server-side
    and mobile applications (using React Native).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: React Native 是一个使用 React JavaScript 库在 JavaScript 中构建原生移动应用的框架；React Native
    代码编译成真正的原生组件。如果你不确定 React 是什么，它是一个由 Facebook 开源并在 Facebook 内部使用的 JavaScript 库。最初，它被用来构建网络应用的用户界面。它已经发展起来，现在也可以用来构建服务器端和移动应用（使用
    React Native）。
- en: React Native has a lot going for it. In addition to being backed and open sourced
    by Facebook, it also has a tremendous community of motivated people behind it.
    Facebook groups, with their millions of users, are powered by React Native as
    well as Facebook Ads Manager. Airbnb, Bloomberg, Tesla, Instagram, Ticketmaster,
    SoundCloud, Uber, Walmart, Amazon, and Microsoft are some of the other companies
    either investing in or using React Native in production.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: React Native有很多优点。除了得到Facebook的支持和开源之外，它还拥有一个庞大的、充满激情的社区。Facebook群组，拥有数百万用户，也由React
    Native和Facebook Ads Manager提供支持。Airbnb、Bloomberg、Tesla、Instagram、Ticketmaster、SoundCloud、Uber、Walmart、Amazon和Microsoft等公司都在投资或在生产中使用React
    Native。
- en: With React Native, developers can build native views and access native platform-specific
    components using JavaScript. This sets React Native apart from other hybrid app
    frameworks like Cordova and Ionic, which package web views built using HTML and
    CSS into a native application. Instead, React Native takes JavaScript and compiles
    it into a true native application that can use platform-specific APIs and components.
    Alternatives like Xamarin take the same approach, but Xamarin apps are built using
    C#, not JavaScript. Many web developers have JavaScript experience, which helps
    ease the transition from web to mobile app development.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用React Native，开发者可以使用JavaScript构建原生视图并访问特定平台的原生组件。这使得React Native与其他混合应用框架（如Cordova和Ionic）区分开来，后者将使用HTML和CSS构建的web视图打包成原生应用。相反，React
    Native将JavaScript编译成真正的原生应用，可以访问特定平台的API和组件。类似的选择如Xamarin也采用相同的方法，但Xamarin应用是用C#而不是JavaScript构建的。许多网页开发者都有JavaScript经验，这有助于从网页开发过渡到移动应用开发。
- en: 'There are many benefits to choosing React Native as a mobile application framework.
    Because the application renders native components and APIs directly, speed and
    performance are much better than with hybrid frameworks such as Cordova and Ionic.
    With React Native, we’re writing entire applications using a single programming
    language: JavaScript. We can reuse a lot of code, thereby reducing the time it
    takes to ship a cross-platform application. And hiring and finding quality JavaScript
    developers is much easier and cheaper than hiring Java, Objective C, or Swift
    developers, leading to an overall less-expensive process.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 选择React Native作为移动应用框架有很多好处。因为应用直接渲染原生组件和API，所以速度和性能比Cordova和Ionic等混合框架要好得多。使用React
    Native，我们可以使用单一编程语言：JavaScript来编写整个应用。我们可以重用大量代码，从而减少发布跨平台应用所需的时间。而且，招聘和寻找高质量的JavaScript开发者比招聘Java、Objective
    C或Swift开发者要容易得多，成本也更低，从而使得整个过程更加经济。
- en: We’ll dive much deeper into React in chapter 2\. Until then, let’s touch on
    a few core concepts as an introduction.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第二章深入探讨React。在此之前，让我们先简要介绍几个核心概念。
- en: 1.1.1 A basic React class
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.1 一个基本的React类
- en: '*Components* are the building blocks of a React or React Native application.
    The entry point of an application is a component that requires and is made of
    other components. These components may also require other components, and so on.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*组件*是React或React Native应用的基本构建块。应用的入口点是一个需要并由其他组件构成组件。这些组件也可能需要其他组件，依此类推。'
- en: 'There are two main types of React Native components: *stateful* and *stateless*.
    Here’s an example of a stateful component using an ES6 class:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: React Native主要有两种组件类型：*有状态*和*无状态*。以下是一个使用ES6类的有状态组件示例：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And here’s an example of a stateless component:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个无状态组件的示例：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The main difference is that stateless components don’t hook into any lifecycle
    methods and hold no state of their own, so any data to be rendered must be received
    as properties (props). We’ll go through the lifecycle methods in depth in chapter
    2, but for now let’s take a first look at them and look at a class.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于无状态组件不会连接到任何生命周期方法，也不持有自己的状态，因此任何要渲染的数据都必须作为属性（props）接收。我们将在第二章深入讲解生命周期方法，但在此我们先初步了解它们，并看看一个类。
- en: Listing 1.1 Creating a basic React Native class
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.1 创建基本的React Native类
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: At the top of the file, you require `React` from `'react'`, as well as `View`,
    `Text`, and `StyleSheet` from `'react-native'`. `View` is the most fundamental
    building block for creating React Native components and the UI in general and
    can be thought of like a `div` in HTML. `Text` allows you to create text elements
    and is comparable to a `span` tag in HTML. `StyleSheet` lets you create style
    objects to use in an application. These two packages (`react` and `react-native`)
    are available as npm modules.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件顶部，你需要从`'react'`中引入`React`，以及从`'react-native'`中引入`View`、`Text`和`StyleSheet`。`View`是创建React
    Native组件和UI的基本构建块，可以将其视为HTML中的`div`元素。`Text`允许你创建文本元素，类似于HTML中的`span`标签。`StyleSheet`允许你创建用于应用程序中的样式对象。这两个包（`react`和`react-native`）作为npm模块提供。
- en: When the component first loads, you set a `state` object with the property `name`
    in the constructor. For data in a React Native application to be dynamic, it needs
    to be either set in the state or passed down as props. Here, you set the state
    in the constructor and can therefore change it if desired by calling
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件首次加载时，你在构造函数中设置一个带有`name`属性的`state`对象。为了使React Native应用程序中的数据动态化，它需要要么在状态中设置，要么作为props传递。在这里，你在构造函数中设置状态，因此可以通过调用
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: which rerenders the component. Setting the variable in state allows you to update
    the value elsewhere in the component.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这将重新渲染组件。在状态中设置变量允许你在组件的其他地方更新值。
- en: '`render` is then called: it examines the props and state and then must return
    a single React Native element, `null`, or `false`. If you have multiple child
    elements, they must be wrapped in a parent element. Here, the components, styles,
    and data are combined to create what will be rendered to the UI.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调用`render`：它检查props和state，然后必须返回一个React Native元素、`null`或`false`。如果你有多个子元素，它们必须被包装在一个父元素中。在这里，组件、样式和数据被组合起来，创建出将被渲染到UI中的内容。
- en: The final method in the lifecycle is `componentDidMount`. If you need to do
    any API calls or AJAX requests to reset the state, this is usually the best place
    to do so. Finally, the UI is rendered to the device, and you can see the result.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期中的最后一个方法是`componentDidMount`。如果你需要进行API调用或AJAX请求来重置状态，这通常是最佳位置。最后，UI被渲染到设备上，你可以看到结果。
- en: 1.1.2 React lifecycle
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.2 React生命周期
- en: When a React Native class is created, methods are instantiated that you can
    hook into. These methods are called *lifecycle methods*, and we’ll cover them
    in depth in chapter 2\. The methods in [listing 1.1](#listing1.1) are `constructor`,
    `componentDidMount`, and `render`, but there are a few more, and they all have
    their own use cases.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建React Native类时，会实例化你可以挂钩的方法。这些方法被称为*生命周期方法*，我们将在第2章中深入探讨。列表1.1中的方法是`constructor`、`componentDidMount`和`render`，但还有一些其他方法，它们都有自己的用途。
- en: Lifecycle methods happen in sync and help manage the state of components as
    well as execute code at each step of the way, if you wish. The only required lifecycle
    method is `render`; all the others are optional. When working with React Native,
    you’re fundamentally working with the same lifecycle methods and specifications
    you’d use with React.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期方法同步发生，有助于管理组件的状态，并在每个步骤中执行代码，如果你愿意的话。唯一必需的生命周期方法是`render`；所有其他都是可选的。当你使用React
    Native时，你基本上使用的是与React相同的生命周期方法和规范。
- en: 1.2 What you’ll learn
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 你将学到什么
- en: In this book, we’ll cover everything you need to know to build robust mobile
    applications for iOS and Android using the React Native framework. Because React
    Native is built using the React library, we’ll begin in chapter 2 by covering
    and thoroughly explaining how React works.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将涵盖你使用React Native框架构建健壮的iOS和Android移动应用所需了解的所有内容。因为React Native是用React库构建的，所以我们将从第2章开始，详细解释React的工作原理。
- en: We’ll then cover styling, touching on most of the styling properties available
    in the framework. Because React Native uses flexbox for laying out the UI, we’ll
    dive deep into how flexbox works and discuss all the flexbox properties. If you’ve
    used flexbox in CSS for layout on the web, all of this will be familiar to you,
    but keep in mind that the flexbox implementation used by React Native isn’t 100%
    the same.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将介绍样式，涉及框架中大多数可用的样式属性。因为React Native使用flexbox进行UI布局，我们将深入探讨flexbox的工作原理，并讨论所有flexbox属性。如果你在CSS中使用了flexbox进行网页布局，所有这些对你来说都会很熟悉，但请注意，React
    Native使用的flexbox实现并不完全相同。
- en: We’ll then go through many of the native components that come with the framework
    out of the box and walk through how each of them works. In React Native, a component
    is basically a chunk of code that provides a specific functionality or UI element
    and can easily be used in the application. Components are covered extensively
    throughout this book because they’re the building blocks of a React Native application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将详细介绍框架自带的大量原生组件，并说明每个组件是如何工作的。在 React Native 中，组件基本上是一段提供特定功能或 UI 元素的代码块，并且可以轻松地用于应用程序中。组件在本书中被广泛涵盖，因为它们是
    React Native 应用程序的基本构建块。
- en: There are many ways to implement navigation, each with its own nuances, pros,
    and cons. We’ll discuss navigation in depth and cover how to build robust navigation
    using the most important of the navigation APIs. We’ll cover not only the native
    navigation APIs that come out of the box with React Native, but also a couple
    of community projects available through npm.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 实现导航的方式有很多，每种方式都有其独特的细微差别、优点和缺点。我们将深入讨论导航，并介绍如何使用最重要的导航 API 构建健壮的导航。我们将涵盖不仅包括
    React Native 自带的本地导航 API，还包括通过 npm 可用的几个社区项目。
- en: Next, we’ll discuss in depth both cross-platform and platform-specific APIs
    available in React Native and how they work. It will then be time for you to start
    working with data using network requests, AsyncStorage (a form of local storage),
    Firebase, and WebSocket. Then we’ll dive into the different data architectures
    and how each of them works to handle the state of the application. Finally, we’ll
    look at testing and a few different ways to test in React Native.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入探讨 React Native 中可用的跨平台和平台特定 API，以及它们是如何工作的。然后，你将开始使用网络请求、AsyncStorage（一种本地存储形式）、Firebase
    和 WebSocket 等方式处理数据。然后，我们将深入研究不同的数据架构以及它们如何处理应用程序的状态。最后，我们将探讨测试以及在 React Native
    中测试的几种不同方法。
- en: 1.3 What you should know
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 你应该了解
- en: To get the most out of this book, you should have beginner to intermediate knowledge
    of JavaScript. Much of your work will be done with the command line, so a basic
    understanding of how to use the command line is also needed. You should also understand
    what npm is and how it works on at least a fundamental level. If you’ll be building
    in iOS, a basic understanding of Xcode is beneficial and will speed things along
    but isn’t required. Similarly, if you’re building for Android, a basic understanding
    of Android Studio will be beneficial but not required.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用这本书，你应该具备从初学者到中级水平的 JavaScript 知识。你的大部分工作将在命令行中完成，因此需要了解如何使用命令行的基本知识。你还应该了解
    npm 是什么以及它在基本层面上是如何工作的。如果你将构建 iOS 应用，对 Xcode 的基本理解将有益于加快进度，但不是必需的。同样，如果你为 Android
    构建应用，对 Android Studio 的基本理解将有益于加快进度，但也不是必需的。
- en: Fundamental knowledge of newer JavaScript features implemented in the ES2015
    release of the JavaScript programming language is beneficial but not necessary.
    Some conceptual knowledge of MVC frameworks and single-page architecture is also
    good but not required.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对 JavaScript 编程语言 ES2015 版本中实现的新 JavaScript 特性的基本知识有益，但不是必需的。对 MVC 框架和单页架构的一些概念性知识也很好，但不是必需的。
- en: 1.4 Understanding how React Native works
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4 理解 React Native 的工作原理
- en: Let’s look at how React Native works by discussing JSX, the threading model,
    React, unidirectional data flow, and more.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过讨论 JSX、线程模型、React、单向数据流等内容来了解 React Native 的工作原理。
- en: 1.4.1 JSX
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.1 JSX
- en: React and React Native both encourage the use of JSX. JSX is basically a syntax
    extension to JavaScript that looks similar to XML. You can build React Native
    components without JSX, but JSX makes React and React Native a lot more readable
    and easier to maintain. JSX may seem strange at first, but it’s extremely powerful,
    and most people grow to love it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: React 和 React Native 都鼓励使用 JSX。JSX 实际上是对 JavaScript 的一种语法扩展，看起来类似于 XML。你可以不使用
    JSX 来构建 React Native 组件，但 JSX 使得 React 和 React Native 更易于阅读和维护。JSX 可能一开始看起来有些奇怪，但它非常强大，大多数人最终都会喜欢上它。
- en: 1.4.2 Threading
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.2 线程
- en: All JavaScript operations, when interacting with the native platform, are done
    in a separate thread, allowing the user interface as well as any animations to
    perform smoothly. This thread is where the React application lives, and where
    all API calls, touch events, and interactions are processed. When there’s a change
    to a native-backed component, updates are batched and sent to the native side.
    This happens at the end of each iteration of the event loop. For most React Native
    applications, the business logic runs on the JavaScript thread.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 所有与原生平台交互的JavaScript操作都在一个单独的线程中完成，允许用户界面以及任何动画平滑地执行。这个线程是React应用程序所在的地方，也是所有API调用、触摸事件和交互处理的地方。当原生支持的组件发生变化时，更新会被批量发送到原生端。这发生在事件循环的每次迭代结束时。对于大多数React
    Native应用程序，业务逻辑在JavaScript线程上运行。
- en: 1.4.3 React
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.3 React
- en: A great feature of React Native is that it uses React. React is an open source
    JavaScript library that’s also backed by Facebook. It was originally designed
    to build applications and solve problems on the web. This framework has become
    extremely popular since its release, with many established companies taking advantage
    of its quick rendering, maintainability, and declarative UI, among other things.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: React Native的一个显著特点是它使用React。React是一个由Facebook支持的开放源代码JavaScript库。它最初是为了构建应用程序和解决网页上的问题而设计的。自从发布以来，这个框架已经变得极其流行，许多知名公司都利用了它的快速渲染、可维护性和声明式UI等特性。
- en: 'Traditional DOM manipulation is slow and expensive in terms of performance
    and should be minimized. React bypasses the traditional DOM with something called
    the *virtual DOM*: basically, a copy of the actual DOM in memory that only changes
    when comparing new versions of the virtual DOM to old versions of the virtual
    DOM. This minimizes the number of DOM operations required to achieve the new state.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的DOM操作在性能上既慢又昂贵，应该尽量减少。React通过所谓的*虚拟DOM*绕过了传统的DOM：基本上，这是实际DOM在内存中的副本，只有当比较虚拟DOM的新版本和旧版本时才会发生变化。这最小化了实现新状态所需的DOM操作数量。
- en: 1.4.4 Unidirectional data flow
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.4 单向数据流
- en: React and React Native emphasize unidirectional, or one-way, data flow. Because
    of how React Native applications are built, this one-way data flow is easy to
    achieve.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: React和React Native强调单向，或单程，的数据流。由于React Native应用程序的构建方式，这种单向数据流很容易实现。
- en: 1.4.5 Diffing
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.5 Diffing
- en: React takes the idea of diffing and applies it to native components. It takes
    your UI and sends the smallest amount of data to the main thread to render it
    with native components. The UI is declaratively rendered based on the state, and
    React uses diffing to send the necessary changes over the bridge.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: React将diffing的概念应用到原生组件上。它将你的UI发送到主线程，用原生组件渲染，所需的数据量最小。UI基于状态声明式渲染，React使用diffing通过桥梁发送必要的更改。
- en: 1.4.6 Thinking in components
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.6 组件化思维
- en: When building a UI in React Native, it’s useful to think of your application
    as being composed of a collection of components. Thinking about how a page is
    set up, you already do this conceptually, but using concepts, names, or class
    names like *header*, *footer*, *body*, *sidebar*, and so on. With React Native,
    you can give these components names that make sense to you and other developers
    who may be using your code, making it easy to bring new people into a project
    or hand a project off to someone else.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在React Native中构建UI时，将你的应用程序视为由一组组件组成是有用的。思考页面是如何设置的，你已经在概念上这样做，但使用像*header*、*footer*、*body*、*sidebar*等概念、名称或类名。在React
    Native中，你可以为这些组件命名，使其对你和其他可能使用你代码的开发者有意义，这使得将新人引入项目或转交给他人变得容易。
- en: Suppose a designer has handed you the example mockup shown in [figure 1.1](#figure1.1).
    Let’s think of how to conceptualize this into components.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一位设计师给了你[图1.1](#figure1.1)中显示的示例原型。让我们思考如何将这个概念转化为组件。
- en: '![c01_01.tif](Images/c01_01.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![c01_01.tif](Images/c01_01.png)'
- en: '[Figure 1.1](#figureanchor1.1) Example app design'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1.1](#figureanchor1.1) 示例应用程序设计'
- en: 'The first thing to do is to mentally break the UI elements into what they represent.
    The example mockup has a header bar, and within the header bar are a title and
    a menu button. Below the header is a tab bar, and within the tab bar are three
    individual tabs. Go through the rest of the mockup and think of what the other
    items are. These items you’re identifying will be translated into components.
    This is the way you should think about composing a UI when working with React
    Native: break down common elements in the UI into reusable components, and define
    their interface accordingly. When you need an element in the future, it will be
    available for reuse.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是在心理上将 UI 元素拆分成它们所代表的内容。示例原型中有一个标题栏，标题栏内包含标题和菜单按钮。标题栏下方是标签栏，标签栏内包含三个单独的标签。浏览原型其余部分，思考其他项目是什么。你正在识别的项目将被转换为组件。这是你在使用
    React Native 构建 UI 时应该考虑的方法：将 UI 中的常见元素拆分成可重用组件，并相应地定义它们的接口。当你未来需要某个元素时，它将可供重用。
- en: Breaking UI elements into reusable components is good for code reuse and also
    makes your code declarative and understandable. For instance, instead of 12 lines
    of code implementing a footer, the element could be called `footer`. Looking at
    code built this way, it’s much easier to reason about and know exactly what’s
    going on.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 将 UI 元素拆分成可重用的组件有利于代码复用，同时也使得代码更具声明性和可理解性。例如，用 12 行代码实现页脚，元素可以命名为 `footer`。查看这样构建的代码，推理起来更容易，可以确切地知道正在发生什么。
- en: '[Figure 1.2](#figure1.2) shows how the design in [figure 1.1](#figure1.1) could
    be broken up as I just described. The names can be whatever makes sense to you.
    Some of the items are grouped together—I logically separated the items individually
    and grouped components conceptually.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1.2](#figure1.2) 展示了如何将 [图 1.1](#figure1.1) 中的设计拆分成我刚才描述的样子。名称可以是任何对你有意义的名称。一些项目被分组在一起——我逻辑上单独分离了项目，并在概念上将组件分组。'
- en: '![c01_02.tif](Images/c01_02.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![c01_02.tif](Images/c01_02.png)'
- en: '[Figure 1.2](#figureanchor1.2) App structure broken down into separate components'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1.2](#figureanchor1.2) 将应用程序结构拆分成单独的组件'
- en: 'Next, let’s see how this would look using actual React Native code. First,
    let’s look at how the main UI elements appear on the page:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看使用实际的 React Native 代码会是怎样的。首先，让我们看看主要 UI 元素在页面上的显示方式：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, let’s see how the child elements look:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看子元素的外观：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: I’ve used the names declared in [figure 1.2](#figure1.2), but they could be
    whatever makes sense to you.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了 [图 1.2](#figure1.2) 中声明的名称，但它们可以是任何对你有意义的名称。
- en: 1.5 Acknowledging React Native’s strengths
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.5 认可 React Native 的优势
- en: As discussed earlier, one of the main strengths React Native has going for it
    is that it uses React. React, like React Native, is an open source project backed
    by Facebook. As of the time of this writing, React has over 100,000 stars and
    more than 1,100 contributors on GitHub—that’s a lot of interest and community
    involvement in the project, making it easier to bet on as a developer or as a
    project manager. Because React is developed, maintained, and used by Facebook,
    it has some of the most talented engineers in the world overseeing it, pushing
    it forward, and adding new features, and it probably won’t be going away anytime
    soon.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，React Native 的主要优势之一是它使用 React。React，就像 React Native 一样，是一个由 Facebook 支持的开源项目。截至本文写作时，React
    在 GitHub 上有超过 100,000 个星标和 1,100 多个贡献者——这表明项目受到了很多关注和社区参与，作为开发者或项目经理，更容易对其下注。由于
    React 由 Facebook 开发、维护和使用，它拥有世界上最优秀的工程师之一来监督它，推动它向前发展，并添加新功能，因此它可能不会很快消失。
- en: 1.5.1 Developer availability
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5.1 开发者可用性
- en: 'With the rising cost and decreasing availability of native mobile developers,
    React Native enters the market with a key advantage over native development: it
    takes advantage of the wealth of existing talented web and JavaScript developers
    and gives them another platform on which to build without having to learn a new
    language.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 随着原生移动开发者的成本上升和可用性下降，React Native 带着与原生开发相比的关键优势进入市场：它利用了现有的丰富才华横溢的 Web 和 JavaScript
    开发者，并为他们提供了一个新的平台，让他们可以在不学习新语言的情况下构建应用程序。
- en: 1.5.2 Developer productivity
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5.2 开发者生产力
- en: Traditionally, to build a cross-platform mobile application, you needed both
    an Android team and an iOS team. React Native allows you to build Android, iOS,
    and (soon) Windows applications using a single programming language, JavaScript,
    and possibly even a single team, dramatically decreasing development time and
    development cost while increasing productivity. As a native developer, the great
    thing about coming to a platform like this is the fact that you’re no longer tied
    down to being only an Android or iOS developer, opening the door for a lot of
    opportunity. This is great news for JavaScript developers as well, allowing them
    to spend all their time in one state of mind when switching between web and mobile
    projects. It’s also a win for teams who were traditionally split between Android
    and iOS, because they can now work together on a single codebase. To underscore
    these points, you can share your data architecture not only cross platform, but
    also on the web, if you’re using something like Redux (discussed in chapter 12).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，要构建跨平台移动应用程序，你需要一个Android团队和一个iOS团队。React Native允许你使用单一编程语言JavaScript（以及可能是一个单一团队）来构建Android、iOS和（很快）Windows应用程序，这极大地减少了开发时间和开发成本，同时提高了生产力。作为一名原生开发者，来到这样一个平台的好处是你不再仅仅局限于Android或iOS开发者，这为许多机会打开了大门。这对JavaScript开发者来说也是个好消息，因为它允许他们在切换网页和移动项目时，能够保持一个统一的心态。这对那些传统上在Android和iOS之间分裂的团队来说也是一个胜利，因为他们现在可以基于单一代码库共同工作。为了强调这些观点，如果你使用Redux（在第12章中讨论）这样的工具，你可以分享你的数据架构不仅跨平台，还可以在网络上进行。
- en: 1.5.3 Performance
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5.3 性能
- en: If you follow other cross-platform solutions, you’re probably aware of solutions
    such as PhoneGap, Cordova, and Ionic. Although these are also viable solutions,
    the consensus is that performance hasn’t yet caught up to the experience a native
    app delivers. This is where React Native also shines, because the performance
    is usually not noticeably different from that of a native mobile app built using
    Objective-C/Swift or Java.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循其他跨平台解决方案，你可能已经熟悉了像PhoneGap、Cordova和Ionic这样的解决方案。尽管这些也是可行的解决方案，但普遍认为性能还没有达到原生应用程序的水平。这正是React
    Native也表现出色的地方，因为其性能通常与使用Objective-C/Swift或Java构建的原生移动应用程序没有明显区别。
- en: 1.5.4 One-way data flow
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5.4 单向数据流
- en: One-way data flow separates React and React Native from most other JavaScript
    frameworks and also any MVC framework. React incorporates a one-way data flow
    from top-level components all the way down (see [figure 1.3](#figure1.3)). This
    makes applications much easier to reason about, because there’s one source of
    truth for the data layer as opposed to having it scattered about the application.
    We’ll look at this in more detail later in the book.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 单向数据流将React和React Native与其他大多数JavaScript框架以及任何MVC框架区分开来。React从顶级组件开始，实现了一路到底的单向数据流（参见[图1.3](#figure1.3)）。这使得应用程序更容易推理，因为数据层有一个单一的真实来源，而不是散布在应用程序中。我们将在本书的后面更详细地探讨这一点。
- en: '![c01_03.eps](Images/c01_03.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![c01_03.eps](Images/c01_03.png)'
- en: '[Figure 1.3](#figureanchor1.3) How one-way data flow works'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1.3](#figureanchor1.3) 单向数据流的工作原理'
- en: 1.5.5 Developer experience
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5.5 开发者体验
- en: 'The developer experience is a major win for React Native. If you’ve ever developed
    for the web, you’re aware of the browser’s snappy reload times. Web development
    has no compilation step: just refresh the screen, and your changes are there.
    This is a far cry from the long compile times of native development. One of the
    reasons Facebook decided to develop React Native was to overcome the lengthy compile
    times of the Facebook application when using native iOS and Android build tools.
    To make a small UI change or any other change, Facebook developers had to wait
    a long time while the program compiled to see the results. Long compilation times
    result in decreased productivity and increased developer cost. React Native solves
    this issue by giving you the quick reload times of the web, as well as Chrome
    and Safari debugging tools, making the debugging experience feel a lot like the
    web.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者体验是React Native的一个重大优势。如果你曾经为网页开发过，你会知道浏览器快速的重载时间。网页开发没有编译步骤：只需刷新屏幕，你的更改就会出现。这与原生开发的漫长编译时间大相径庭。Facebook决定开发React
    Native的一个原因是为了克服使用原生iOS和Android构建工具时Facebook应用程序漫长的编译时间。为了进行小的UI更改或其他更改，Facebook开发者不得不等待很长时间，直到程序编译完成才能看到结果。漫长的编译时间会导致生产力下降和开发者成本增加。React
    Native通过提供与网页、Chrome和Safari调试工具相同的快速重载时间来解决这一问题，使得调试体验感觉就像在网页上一样。
- en: React Native also has something called *hot reloading* built in. What does this
    mean? Well, while developing an application, imagine having to click a few times
    into your app to get to the place you’re developing. While using hot reloading,
    when you make a code change, you don’t have to reload and click back through the
    app to get to the current state. Using this feature, you save the file, and the
    application reloads only the component you’ve changed, instantly giving you feedback
    and updating the current state of the UI.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: React Native 还内置了一个名为 *热重载* 的功能。这意味着什么？好吧，在开发应用程序时，想象一下你需要点击几次才能到达你正在开发的地方。在使用热重载时，当你进行代码更改时，你不需要重新加载并通过应用程序点击回到当前状态。使用这个功能，你保存文件，应用程序只会重新加载你更改的组件，立即给你反馈并更新
    UI 的当前状态。
- en: 1.5.6 Transpilation
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5.6 转译
- en: '*Transpilation* is typically when something known as a *transpiler* takes source
    code written in one programming language and produces the equivalent code in another
    language. With the rise of new ECMAScript features and standards, transpilation
    has spilled over to also include taking newer versions and yet-to-be-implemented
    features of certain languages, in this case JavaScript, and producing transpiled
    standard JavaScript, making the code usable by platforms that can only process
    older versions of the language.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*转译* 通常是指一个名为 *转译器* 的工具将用一种编程语言编写的源代码转换为另一种语言的等效代码。随着新的 ECMAScript 特性和标准的兴起，转译已经扩展到包括将某些语言（在这种情况下是
    JavaScript）的新版本和尚未实现的功能转换为转译后的标准 JavaScript，使得代码可以在只能处理语言较旧版本的平台上使用。'
- en: React Native uses Babel to do this transpilation step, and it’s built in by
    default. Babel is an open source tool that transpiles the most bleeding-edge JavaScript
    language features into code that can be used today. You don’t have to wait for
    the bureaucratic process of language features being proposed, approved, and then
    implemented before you can use them. You can start using a feature as soon as
    it makes it into Babel, which is usually very quickly. JavaScript classes, arrow
    functions, and object destructuring are all examples of powerful ES2015 features
    that haven’t made it into all browsers and runtimes yet; but with Babel and React
    Native, you can use them today with no worries about whether they will work. If
    you like using the latest language features, you can use the same transpilation
    process to develop web applications.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: React Native 使用 Babel 来执行这个转译步骤，并且默认内置。Babel 是一个开源工具，可以将最前沿的 JavaScript 语言特性转译成今天可以使用的代码。你不需要等待语言特性被提出、批准然后实施的过程，你可以在它们进入
    Babel 的时候就开始使用它们，这通常非常快。JavaScript 类、箭头函数和对象解构都是 ES2015 强大特性的例子，这些特性尚未在所有浏览器和运行时中实现；但使用
    Babel 和 React Native，你可以今天就开始使用它们，无需担心它们是否能够工作。如果你喜欢使用最新的语言特性，你可以使用相同的转译过程来开发
    Web 应用程序。
- en: 1.5.7 Productivity and efficiency
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5.7 效率和生产力
- en: Native mobile development is becoming more and more expensive, so engineers
    who can deliver applications across platforms and stacks will become increasingly
    valuable and in demand. Once React Native—or something similar, if it comes along—makes
    developing desktop and web as well as mobile applications using a single framework
    mainstream, there will be a restructuring and rethinking of how engineering teams
    are organized. Instead of a developer being specialized in a certain platform,
    such as iOS or web, they’ll oversee features across platforms. In this new era
    of cross-platform and cross-stack engineering teams, developers delivering native
    mobile, web, and desktop applications will be more productive and efficient and
    will therefore be able to demand a higher wage than a traditional web developer
    who can only deliver web applications.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 原生移动开发变得越来越昂贵，因此能够跨平台和堆栈交付应用程序的工程师将变得越来越有价值且需求增加。一旦 React Native 或者类似的技术变得主流，使用单个框架开发桌面、Web
    以及移动应用程序，那么工程团队的重组和重新思考将会发生。不再是开发者专门化于某个平台，如 iOS 或 Web，他们将负责跨平台的功能。在这个跨平台和跨堆栈工程团队的新时代，交付原生移动、Web
    和桌面应用程序的开发者将更加高效和高效，因此他们可以要求比只能交付 Web 应用程序的传统 Web 开发者更高的工资。
- en: Companies that are hiring developers for mobile development stand to benefit
    the most from using React Native. Having everything written in one language makes
    hiring a lot easier and less expensive. Productivity also soars when a team is
    all on the same page, working within a single technology, which simplifies collaboration
    and knowledge sharing.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 雇佣开发者进行移动开发的公司，使用 React Native 可以获得最大的好处。所有内容都使用一种语言编写，这使得招聘变得更加容易和便宜。当团队在同一个页面上，使用单一技术工作时，生产力也会大幅提升，这简化了协作和知识共享。
- en: 1.5.8 Community
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5.8 社区
- en: The React community, and by extension the React Native community, is one of
    the most open and helpful groups I’ve ever interacted with. When I’ve run into
    issues I couldn’t resolve on my own by searching online or on Stack Overflow,
    I’ve reached out directly to either a team member or someone in the community
    and have had nothing but positive feedback and help.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: React 社区，以及由此扩展的 React Native 社区，是我曾经互动过的最开放和最有帮助的群体之一。当我遇到我在网上或 Stack Overflow
    上搜索无法解决的问题时，我直接联系了团队成员或社区成员，并且得到了积极的反馈和帮助。
- en: 1.5.9 Open source
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5.9 开源
- en: React Native is open source. This offers a wealth of benefits. First, in addition
    to the Facebook team, hundreds of developers contribute to React Native. Bugs
    are pointed out much faster than in proprietary software, which has only the employees
    on a specific team working on bug fixes and improvements. Open source usually
    gets closer to what users want because the users can have a hand in making the
    software what they want it to be. Given the cost of purchasing proprietary software,
    licensing fees, and support costs, open source also wins when measuring price.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: React Native 是开源的。这带来了许多好处。首先，除了 Facebook 团队外，还有数百名开发者为 React Native 做出贡献。在开源软件中，比在专有软件中更快地指出错误，因为专有软件只有特定团队的工作人员负责错误修复和改进。开源通常更接近用户的需求，因为用户可以参与使软件成为他们想要的样子。考虑到购买专有软件、许可费用和支持成本，在衡量价格时，开源也更具优势。
- en: Immediate updates
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 立即更新
- en: Traditionally, when publishing new versions of an app, you’re at the mercy of
    the app store approval process and schedule. This long, tedious process can take
    up to two weeks. Making a change, even if it’s extremely small, is painful and
    requires releasing a new version of the application.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，当发布应用的新版本时，您必须依赖应用商店的审批流程和日程安排。这个过程漫长而繁琐，可能需要长达两周的时间。即使是一个极小的更改，也是痛苦的，并且需要发布应用的新版本。
- en: React Native, as well as hybrid application frameworks, allow you to deploy
    mobile app updates directly to the user’s device, without going through an app
    store approval process. If you’re used to the web and the rapid release cycle
    it offers, you can now do the same thing with React Native and other hybrid application
    frameworks.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: React Native 以及混合应用框架允许您直接将移动应用更新部署到用户的设备上，无需经过应用商店的审批流程。如果您习惯了网络和它提供的快速发布周期，现在您可以使用
    React Native 和其他混合应用框架做到同样的事情。
- en: Other solutions for building cross-platform mobile applications
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他构建跨平台移动应用的解决方案
- en: 'React Native isn’t the only option for building a cross-platform mobile application.
    Multiple other options are available, with the main ones being Cordova, Xamarin,
    and Flutter:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: React Native 并不是构建跨平台移动应用的唯一选择。还有多种其他选项可用，其中主要的是 Cordova、Xamarin 和 Flutter：
- en: '*Cordova* is basically a native shell around a web application that allows
    the developer to access native APIs within the application. Unlike traditional
    web applications, Cordova apps can be deployed to the App Store and Google Play
    Store. The benefit of using something like Cordova is that there isn’t much more
    to learn if you’re already a web developer: you can use HTML, JavaScript, CSS,
    and your JavaScript framework of choice. The main drawback of Cordova is that
    you’ll have a hard time matching the performance and smooth UI that React Native
    offers: you’re relying on the DOM, because you’re mainly working with webtechnologies.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Cordova* 实际上是一个围绕网络应用的本地壳，允许开发者访问应用内的本地 API。与传统的网络应用不同，Cordova 应用可以部署到 App
    Store 和 Google Play Store。使用类似 Cordova 的好处是，如果您已经是网络开发者，那么您不需要学习更多：您可以使用 HTML、JavaScript、CSS
    以及您选择的 JavaScript 框架。Cordova 的主要缺点是，您将很难匹配 React Native 提供的性能和流畅的用户界面：您依赖于 DOM，因为您主要使用的是网络技术。'
- en: '*Xamarin* is a framework that allows developers to build iOS, Android, Windows,
    and macOS applications using a single codebase written in C#. Xamarin compiles
    to a native app in different ways depending on the platform being targeted. Xamarin
    has a free tier that lets developers build and deploy mobile applications and
    a paid tier for larger or enterprise companies. Xamarin will probably appeal more
    to native developers because it doesn’t have similarities to web technologies
    like React Native and Cordova.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Xamarin* 是一个框架，允许开发者使用 C# 编写的单一代码库来构建 iOS、Android、Windows 和 macOS 应用程序。Xamarin
    根据目标平台的不同，以不同的方式编译成原生应用程序。Xamarin 提供了免费层，让开发者可以构建和部署移动应用程序，以及针对更大或企业公司的付费层。由于它不像
    React Native 和 Cordova 那样与 Web 技术相似，Xamarin 可能会更吸引原生开发者。'
- en: '*Flutter* is a framework open sourced by Google that uses the Dart programming
    language to build applications that run on iOS and Android platforms.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Flutter* 是由 Google 开源的一个框架，它使用 Dart 编程语言来构建在 iOS 和 Android 平台上运行的应用程序。'
- en: 1.6 React Native’s drawbacks
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.6 React Native 的缺点
- en: Now that we’ve gone over the benefits of using React Native, let’s look at a
    few reasons and circumstances where you may not want to choose the framework.
    First, React Native is still immature when compared to other platforms such as
    native iOS, Android, and Cordova. Feature parity isn’t there yet with either native
    iOS or Cordova. Most functionality is now built in, but there may be times when
    you need functionality that isn’t yet available, and this means you must dig into
    the native code to build it yourself, hire someone to do it, or not implement
    the feature.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了使用 React Native 的好处，让我们看看一些可能不希望选择该框架的原因和情况。首先，与原生 iOS、Android 和 Cordova
    等其他平台相比，React Native 仍然不够成熟。与原生 iOS 或 Cordova 的功能对等性尚未实现。大多数功能现在都已内置，但有时你可能需要尚未提供的功能，这意味着你必须深入研究原生代码来构建它，雇佣某人来做这件事，或者不实现该功能。
- en: Another thing to think about is the fact that you and/or your team must learn
    a completely new technology if you aren’t familiar with React. Most people agree
    that React is easy to pick up; but if you’re already proficient with Angular and
    Ionic, for example, and you have an application deadline coming up, it may be
    wise to go with what you already know instead of spending the time it takes to
    learn and train your team on a new tech. In addition to learning React and React
    Native, you must also become familiar with Xcode and the Android development environments,
    which can take some getting used to.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的事实是，如果你不熟悉 React，你和/或你的团队必须学习一项全新的技术。大多数人认为 React 很容易上手；但如果你已经熟练掌握 Angular
    和 Ionic，例如，并且你有一个即将到来的应用程序截止日期，那么选择你已经熟悉的技术而不是花时间去学习和培训团队使用新技术可能是明智的。除了学习 React
    和 React Native 之外，你还必须熟悉 Xcode 和 Android 开发环境，这可能需要一些时间来适应。
- en: Finally, React Native is an abstraction built on top of existing platform APIs.
    When newer versions of iOS, Android, and other future platforms are released,
    there may be a time when React Native will be behind on new features, forcing
    you to either build custom implementations to interact with these new APIs or
    wait until React Native regains feature parity with the new release.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，React Native 是建立在现有平台 API 之上的一个抽象层。当 iOS、Android 和其他未来平台发布新版本时，可能会有一个时期 React
    Native 在新功能上落后，迫使你必须构建自定义实现来与这些新 API 交互，或者等待 React Native 恢复与新发布的功能对等性。
- en: 1.7 Creating and using basic components
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.7 创建和使用基本组件
- en: Components are the fundamental building blocks of React Native, and they can
    vary in functionality and type. Examples of components in popular use cases include
    buttons, headers, footers, and navigation components. They can vary in type from
    an entire view, complete with its own state and functionality, to a single stateless
    component that receives all its props from its parent.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是 React Native 的基本构建块，它们在功能和类型上可能有所不同。常用案例中的组件包括按钮、标题、页脚和导航组件。它们的类型可以从包含自身状态和功能的完整视图，到仅从其父组件接收所有属性的单个无状态组件不等。
- en: 1.7.1 An overview of components
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.7.1 组件概述
- en: As I’ve said, the core of React Native is the concept of components. Components
    are collections of data and UI elements that make up views and, ultimately, applications.
    React Native has built-in components that are described as *native components*
    in this book, but you can also build custom components using the framework. We’ll
    go into depth on how to build, create, and use components.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所说的，React Native 的核心是组件的概念。组件是数据和 UI 元素的集合，它们构成了视图，最终构成了应用程序。React Native
    提供了内置组件，本书中描述为 *原生组件*，但您也可以使用框架构建自定义组件。我们将深入探讨如何构建、创建和使用组件。
- en: As mentioned earlier, React Native components are built using JSX. [Table 1.1](#table1.1)
    shows a few basic examples of what JSX in React Native looks like versus HTML.
    As you can see, JSX looks similar to HTML or XML.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，React Native 组件是使用 JSX 构建的。[表 1.1](#table1.1) 展示了 React Native 中 JSX 与
    HTML 的几个基本示例。如您所见，JSX 看起来与 HTML 或 XML 类似。
- en: Table 1.1 JSX components vs. HTML elements
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.1 JSX 组件与 HTML 元素对比
- en: '| **Component type** | **HTML** | **React Native JSX** |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| **组件类型** | **HTML** | **React Native JSX** |'
- en: '| --- | --- | --- |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Text |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 文本 |'
- en: '[PRE6]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| View |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 查看 |'
- en: '[PRE8]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE9]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Touchable highlight |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 可触摸高亮 |'
- en: '[PRE10]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 1.7.2 Native components
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.7.2 原生组件
- en: The framework offers native components out of the box, such as `View`, `Text`,
    and `Image`, among others. You can create components using these Native components
    as building blocks. For example, you can use the following markup to create a
    `Button` component using React Native `TouchableHighlight` and `Text` components.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 框架提供了一些原生组件，例如 `View`、`Text` 和 `Image` 等。您可以使用这些原生组件作为构建块来创建组件。例如，您可以使用以下标记使用
    React Native 的 `TouchableHighlight` 和 `Text` 组件创建一个 `Button` 组件。
- en: Listing 1.4 Creating a `Button` component
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.4 创建 `Button` 组件
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can then import and use the new button.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以导入并使用新的按钮。
- en: Listing 1.5 Importing and using the `Button` component
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.5 导入和使用 `Button` 组件
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Next, we’ll go through the fundamentals of what a component is, how components
    fit into the workflow, and common use cases and design patterns for building them.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍组件的基本概念，组件如何适应工作流程，以及构建组件的常见用例和设计模式。
- en: 1.7.3 Component composition
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.7.3 组件组合
- en: 'Components are usually composed using JSX, but they can also be composed using
    JavaScript. In this section, you’ll create a component several different ways
    to see all the options. You’ll be creating this component:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 组件通常使用 JSX 组成，但也可以使用 JavaScript 组成。在本节中，您将以几种不同的方式创建组件，以查看所有选项。您将创建以下组件：
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This component outputs “Hello World” to the screen. Now, let’s see how to build
    this basic component. The only out-of-the-box components you’ll use to build this
    custom component are the `View` and `Text` elements discussed earlier. Remember,
    a `View` component is similar to an HTML `<div>`, and a `Text` component is similar
    to an HTML `<span>`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件将“Hello World”输出到屏幕上。现在，让我们看看如何构建这个基本组件。您将用于构建此自定义组件的唯一开箱即用的组件是前面讨论过的 `View`
    和 `Text` 元素。记住，`View` 组件类似于 HTML `<div>`，而 `Text` 组件类似于 HTML `<span>`。
- en: Let’s look at a few ways to create a component. The entire application doesn’t
    have to be consistent in its component definitions, but it’s usually recommended
    that you stay consistent and follow the same pattern for defining classes throughout
    your application.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看创建组件的几种方法。整个应用程序的组件定义不必完全一致，但通常建议您保持一致，并在整个应用程序中遵循相同的模式来定义类。
- en: createClass syntax (ES5, JSX)
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: createClass 语法（ES5，JSX）
- en: 'This is the way to create a React Native component using ES5 syntax. You’ll
    probably still see this syntax in use in some older documentation and examples,
    but it isn’t being used in newer documentation and is now deprecated. We’ll focus
    on the ES2015 class syntax for the rest of the book but will review the `createClass`
    syntax here in case you come across it in older code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 ES5 语法创建 React Native 组件的方法。您可能仍然会在一些较旧的文档和示例中看到这种语法，但它现在不再被使用，并且已被弃用。本书的其余部分将专注于
    ES2015 类语法，但在此处将回顾 `createClass` 语法，以防您在较旧的代码中遇到它：
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Class syntax (ES2015, JSX)
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 类语法（ES2015，JSX）
- en: 'The main way to create stateful React Native components is using ES2015 classes.
    This is the way you’ll create stateful components for the rest of the book and
    is now the approach recommended by the community and creators of React Native:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 创建有状态的 React Native 组件的主要方法是使用 ES2015 类。这是您将在本书的其余部分创建有状态组件的方式，并且现在是社区和 React
    Native 创建者推荐的方法：
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Stateless (reusable) component (JSX)
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 无状态（可重用）组件（JSX）
- en: 'Since the release of React 0.14, we’ve had the ability to create *stateless*
    components. We haven’t yet dived into state, but just remember that stateless
    components are basically pure functions that can’t mutate their own data and don’t
    contain their own state. This syntax is much cleaner than the `class` or `createClass`
    syntax:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 自从React 0.14版本发布以来，我们就有能力创建*无状态*组件。我们还没有深入研究状态，但请记住，无状态组件基本上是纯函数，不能修改自己的数据，也不包含自己的状态。这种语法比`class`或`createClass`语法更简洁：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: createElement (JavaScript)
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: createElement (JavaScript)
- en: '`React.createElement` is rarely used, and you’ll probably never need to create
    a React Native element using this syntax. But it may come in handy if you ever
    need more control over how you’re creating a component, or if you’re reading someone
    else’s code. It will also give you a look at how JavaScript compiles JSX. `React.createElement`
    takes a few arguments:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`React.createElement`很少使用，你可能永远不需要使用这种语法来创建React Native元素。但如果你需要更多控制创建组件的方式，或者你在阅读别人的代码时，它可能会很有用。它还会让你了解JavaScript如何编译JSX。`React.createElement`接受几个参数：'
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let’s walk through them:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一了解它们：
- en: '`type`—The element you want to render'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`—你想要渲染的元素'
- en: '`props`—Any properties you want the component to have'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`props`—你希望组件拥有的任何属性'
- en: '`children`—Child components or text'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`children`—子组件或文本'
- en: 'In the following example, you pass in a view as the first argument to the first
    instance of `React.createElement`, an empty object as the second argument, and
    another element as the last argument. In the second instance, you pass in text
    as the first argument, an empty object as the second argument, and “Hello” as
    the final argument:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，你将视图作为第一个参数传递给`React.createElement`的第一个实例，将一个空对象作为第二个参数，并将另一个元素作为最后一个参数。在第二个实例中，你将文本作为第一个参数，将一个空对象作为第二个参数，并将“Hello”作为最后一个参数：
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is the same as declaring the component as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下声明组件的方式相同：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 1.7.4 Exportable components
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.7.4 可导出组件
- en: 'Next, let’s look at another, more in-depth implementation of a React Native
    component. You’ll create an entire component that you can export and use in another
    file:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看另一个更深入的React Native组件实现。你将创建一个可以导出并在另一个文件中使用的完整组件：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let’s go over all the pieces that make up this component and discuss what’s
    going on.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一了解组成这个组件的各个部分，并讨论正在发生的事情。
- en: Importing
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 导入
- en: 'The following code imports React Native variable declarations:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码导入了React Native变量声明：
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, you’re importing React directly from the React library using a default
    import and importing `Component` from the React library using a named import.
    You’re also using named imports to pull `Text` and `View` into your file.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你使用默认导入直接从React库中导入React，并使用命名导入从React库中导入`Component`。你还使用命名导入将`Text`和`View`拉入你的文件。
- en: 'The `import` statement using ES5 would look like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ES5的`import`语句看起来像这样：
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This statement without using named imports would look like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不使用命名导入，这个语句看起来像这样：
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `import` statement is used to import functions, objects, or variables that
    have been exported from another module, file, or script.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`语句用于导入已从另一个模块、文件或脚本中导出的函数、对象或变量。'
- en: Component declaration
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 组件声明
- en: 'The following code declares the component:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码声明了组件：
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here you’re creating a new instance of a React Native `Component` class by extending
    it and naming it `Home`. Before, you declared `React.Component`; now you’re just
    declaring `Component`, because you imported the `Component` element in the object
    destructuring statement, giving you access to `Component` as opposed to having
    to call `React.Component`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你通过扩展它并命名为`Home`来创建一个React Native `Component`类的新实例。之前，你声明了`React.Component`；现在你只是声明了`Component`，因为你已经在对象解构语句中导入了`Component`元素，这样你就可以访问`Component`，而不是必须调用`React.Component`。
- en: The render method
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 渲染方法
- en: 'Next, look at the `render` method:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，看看`render`方法：
- en: '[PRE26]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The code for the component is executed in the `render` method, and the content
    after the `return` statement returns what’s rendered on the screen. When the `render`
    method is called, it should return a single child element. Any variables or functions
    declared outside of the `render` function can be executed here. If you need to
    do any calculations, declare any variables using state or props, or run any functions
    that don’t manipulate the state of the component, you can do so between the `render`
    method and the `return` statement.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的代码在`render`方法中执行，`return`语句之后的内容返回的是屏幕上渲染的内容。当调用`render`方法时，它应该返回一个单一子元素。任何在`render`函数外部声明的变量或函数都可以在这里执行。如果你需要进行任何计算，可以使用状态或属性声明任何变量，或者运行不操作组件状态的任何函数，你可以在`render`方法和`return`语句之间这样做。
- en: Exports
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 导出
- en: 'Now, you export the component to be used elsewhere in the application:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将组件导出以在应用程序的其他地方使用：
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you want to use the component in the same file, you don’t need to export
    it. After it’s declared, you can use it in the file or export it to be used in
    another file. You may also use `module.exports = 'Home'`, which is ES5 syntax.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在同一文件中使用组件，你不需要导出它。在声明之后，你可以在文件中使用它，或者将其导出到其他文件中使用。你也可以使用`module.exports
    = 'Home'`，这是ES5语法。
- en: 1.7.5 Combining components
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.7.5 组合组件
- en: 'Let’s look at how to combine components. First, create `Home`, `Header`, and
    `Footer` components in a single file. Begin by creating the `Home` component:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何组合组件。首先，在单个文件中创建`Home`、`Header`和`Footer`组件。首先创建`Home`组件：
- en: '[PRE28]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the same file, below the `Home` class declaration, build out a `Header`
    component:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一文件中，在`Home`类声明下方，构建一个`Header`组件：
- en: '[PRE29]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This looks nice, but let’s see how to rewrite `Header` into a stateless component.
    We’ll discuss when and why it’s good to use a stateless component versus a regular
    React Native class in depth later in the book. As you’ll begin to see, the syntax
    and code are much cleaner when you use stateless components:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来不错，但让我们看看如何将`Header`重写为无状态组件。我们将在本书的后面深入讨论何时以及为什么使用无状态组件比常规React Native类更好。正如你将开始看到的那样，当你使用无状态组件时，语法和代码要干净得多：
- en: '[PRE30]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, insert `Header` into the `Home` component:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将`Header`插入到`Home`组件中：
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create a `Footer` and a `Main` view, as well:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`Footer`和一个`Main`视图：
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, drop those into your application:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将这些组件添加到你的应用程序中：
- en: '[PRE33]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The code you just wrote is extremely declarative, meaning it’s written in such
    a way that it describes what you want to do and is easy to understand in isolation.
    This is a high-level overview of how you’ll create components and views in React
    Native, but should give you a good idea of how the basics work.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚才编写的代码非常声明式，这意味着它是这样编写的，它描述了你想要做什么，并且单独理解起来很容易。这是你对如何在React Native中创建组件和视图的高级概述，但应该能给你一个关于基础知识如何工作的良好概念。
- en: 1.8 Creating a starter project
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.8 创建起始项目
- en: Now that we’ve gone over a lot of details about React Native, let’s dig into
    some more code. We’ll focus on building apps using the React Native CLI, but you
    can also use the Create React Native App CLI to create a new project.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经详细介绍了许多关于React Native的内容，让我们深入一些代码。我们将专注于使用React Native CLI构建应用程序，但你也可以使用Create
    React Native App CLI创建新项目。
- en: 1.8.1 Create React Native App CLI
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.8.1 创建 React Native App CLI
- en: You can create React Native projects using the Create React Native App CLI,
    a project generator that’s maintained in the React Community GitHub repository,
    mainly by the Expo team. Expo created the React Native App project as a way to
    allow developers to get up and running with React Native without having to worry
    about installing all the native SDKs involved with running a React Native project
    using the CLI.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用Create React Native App CLI创建React Native项目，这是一个由React社区GitHub仓库维护的项目生成器，主要由Expo团队维护。Expo创建了React
    Native App项目，作为一种让开发者能够无需担心安装所有与使用CLI运行React Native项目相关的原生SDK的方式，快速开始使用React Native。
- en: 'To create a new project using Create React Native App, first install the CLI:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Create React Native App创建新项目，首先安装CLI：
- en: '[PRE34]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here’s how to create a new project using `create-react-native-app` from the
    command line:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用命令行中的`create-react-native-app`创建新项目的方法：
- en: '[PRE35]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 1.8.2 React Native CLI
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.8.2 React Native CLI
- en: Before we go any further, check this book’s appendix to verify that you have
    the necessary tools installed on your machine. If you don’t have the required
    SDKs installed, you won’t be able to continue building your first project using
    the React Native CLI.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，请检查这本书的附录以验证您是否已在您的机器上安装了必要的工具。如果您没有安装所需的SDK，您将无法继续使用React Native CLI构建您的第一个项目。
- en: 'To get started with the React Native starter project and the React Native CLI,
    open the command line and then create and navigate to an empty directory. Once
    you’re there, install the react-native CLI globally by typing the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用React Native启动项目和React Native CLI，请打开命令行，然后创建并导航到一个空目录。一旦到达那里，通过输入以下内容全局安装react-native
    CLI：
- en: '[PRE36]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After React Native is installed on your machine, you can initialize a new project
    by typing `react-native init` followed by the project name:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在React Native安装到您的机器上后，您可以通过输入`react-native init`后跟项目名称来初始化一个新的项目：
- en: '[PRE37]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`myProject` can be any name you choose. The CLI will then spin up a new project
    in whatever directory you’re in. Open the project in a text editor.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`myProject`可以是您选择的任何名称。CLI将在您所在的任何目录中启动一个新的项目。在文本编辑器中打开项目。'
- en: 'First, let’s look at the main files and folders this process has generated
    for you:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看这个过程为您生成的主文件和文件夹：
- en: '*android* —This folder contains all the Android platform-specific code and
    dependencies. You won’t need to go into this folder unless you’re implementing
    a custom bridge into Android or you install a plugin that calls for some type
    of deep configuration.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*android* —此文件夹包含所有Android平台特定的代码和依赖项。除非您正在实现自定义桥接至Android或安装需要某种深度配置的插件，否则您不需要进入此文件夹。'
- en: '*ios* —This folder contains all the iOS platform-specific code and dependencies.
    You won’t need to go into this folder unless you’re implementing a custom bridge
    into iOS or you install a plugin that calls for some type of deep configuration.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ios* —此文件夹包含所有iOS平台特定的代码和依赖项。除非您正在实现自定义桥接至iOS或安装需要某种深度配置的插件，否则您不需要进入此文件夹。'
- en: '*node_modules* —React Native uses *npm* (node package manager) to manage dependencies.
    These dependencies are identified and versioned in the .package.json file and
    stored in the node_modules folder. When you install any new packages from the
    npm/node ecosystem, they’ll go here. These can be installed using either npm or
    yarn.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*node_modules* —React Native使用*npm*（node包管理器）来管理依赖项。这些依赖项在.package.json文件中标识和版本化，并存储在node_modules文件夹中。当您从npm/node生态系统安装任何新包时，它们将在这里。这些可以使用npm或yarn安装。'
- en: '*.flowconfig* —Flow (also open sourced by Facebook) offers type checking for
    JavaScript. Flow is like Typescript, if you’re familiar with that. This file is
    the configuration for flow, if you choose to use it.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*.flowconfig* —Flow（也被Facebook开源）为JavaScript提供类型检查。如果您熟悉TypeScript，Flow就像TypeScript一样。此文件是flow的配置文件，如果您选择使用它。'
- en: '*.gitignore* —This is the place to store any file paths you don’t want in version
    control.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*.gitignore* —这是存储您不想在版本控制中包含的任何文件路径的地方。'
- en: '*.watchmanconfig* —Watchman is a file watcher that React Native uses to watch
    files and record when they change. This is the configuration for Watchman. No
    changes to this will be needed except in rare use cases.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*.watchmanconfig* —Watchman是React Native用来监视文件并记录它们何时更改的文件监视器。这是Watchman的配置文件。除非在罕见的使用情况下，否则不需要对此文件进行更改。'
- en: '*index.js* —This is the entry point of the application. In this file, App.js
    is imported and `AppRegistry.registerComponent` is called, initializing the app.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*index.js* —这是应用程序的入口点。在此文件中，导入App.js并调用`AppRegistry.registerComponent`，初始化应用程序。'
- en: '*App.js* —This is the default main import used in index.js containing the base
    project. You can change it by deleting this file and replacing the main import
    in index.js.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*App.js* —这是在index.js中使用的默认主导入，包含基本项目。您可以通过删除此文件并在index.js中替换主导入来更改它。'
- en: '*package.json* —This file holds your npm configuration. When you npm install
    files, you can save them here as dependencies. You can also set up scripts to
    run different tasks.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*package.json* —此文件包含您的npm配置。当您使用npm安装文件时，您可以将其保存为依赖项。您还可以设置脚本来运行不同的任务。'
- en: The following listing shows App.js.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了App.js。
- en: Listing 1.6 App.js
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.6 App.js
- en: '[PRE38]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This code looks much like what we went over in the last section. There are
    a couple of new items you haven’t yet seen:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来与我们在上一节中讨论的内容非常相似。有几个您尚未见过的新的项目：
- en: '[PRE39]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`Platform` is an API that allows you to detect the current type of operating
    system you’re running on: web, iOS, or Android.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`Platform` 是一个 API，它允许你检测你正在运行的当前操作系统类型：Web、iOS 或 Android。'
- en: '`StyleSheet` is an abstraction like CSS stylesheets. In React Native, you can
    declare styles either inline or using stylesheets. As you can see in the first
    view, a container style is declared:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`StyleSheet` 是类似于 CSS 样式表的抽象。在 React Native 中，你可以声明样式，要么是内联的，要么使用样式表。正如你在第一个视图中看到的，容器样式被声明：'
- en: '[PRE40]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This corresponds directly to
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这直接对应于
- en: '[PRE41]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: At the bottom of the index.js file, you see
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在 index.js 文件的底部，你可以看到
- en: '[PRE42]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is the JavaScript entry point to running all React Native apps. In the
    index file is the only place you’ll call this function. The root component of
    the app should register itself with `AppRegistry.registerComponent`. The native
    system can then load the bundle for the app and run the app when it’s ready.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行所有 React Native 应用的 JavaScript 入口点。在 index 文件中，你将唯一调用此函数。应用的主组件应该通过 `AppRegistry.registerComponent`
    进行注册。原生系统可以加载应用的包并在准备就绪时运行应用。
- en: '![c01_04.tif](Images/c01_04.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![c01_04.tif](Images/c01_04.png)'
- en: '[Figure 1.4](#figureanchor1.4) React Native starter project: what you should
    see after running the starter project on the emulator'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1.4](#figureanchor1.4) React Native 入门项目：在模拟器上运行入门项目后你应该看到的内容'
- en: Now that we’ve gone over what’s in the file, run the project in either your
    iOS simulator or your Android emulator (see [figure 1.4](#figure1.4)). In the
    text element that contains “Welcome to React Native,” enter “Welcome to Hello
    World!” or other text of your choice. Refresh the screen, and you should see your
    changes.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了文件中的内容，请在你的 iOS 模拟器或 Android 模拟器上运行项目（参见 [图 1.4](#figureanchor1.4)）。在包含“欢迎使用
    React Native”文本的文本元素中，输入“欢迎使用 Hello World！”或其他你选择的文本。刷新屏幕，你应该能看到你的更改。
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: React Native is a framework for building native mobile apps in JavaScript using
    the React JavaScript library.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Native 是一个使用 React JavaScript 库在 JavaScript 中构建原生移动应用的框架。
- en: Some of React Native’s strengths are its performance, developer experience,
    ability to build cross platform with a single language, one-way data flow, and
    community. You may consider React Native over a hybrid mainly because of its performance,
    and over Native mainly because of the developer experience and cross-platform
    ability with a single language.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Native的一些优势包括其性能、开发者体验、使用单一语言构建跨平台应用的能力、单向数据流和社区。你可能会考虑使用 React Native
    而不是混合应用主要是因为其性能，以及使用 Native 而不是 React Native 主要是因为开发者体验和单一语言的跨平台能力。
- en: JSX is a preprocessor step that adds an XML-like syntax to JavaScript. You can
    use JSX to create a UI in React Native.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX 是一个预处理步骤，它为 JavaScript 添加了类似 XML 的语法。你可以在 React Native 中使用 JSX 创建 UI。
- en: Components are the fundamental building blocks in React Native. They can vary
    in functionality and type. You can create custom components to implement common
    design elements.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件是 React Native 的基本构建块。它们的功能和类型可能不同。你可以创建自定义组件以实现常见的设计元素。
- en: Components that require state or lifecycle methods need to be created using
    a JavaScript class by extending the `React.Component` class.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要使用 JavaScript 类通过扩展 `React.Component` 类来创建需要状态或生命周期方法的组件。
- en: Stateless components can be created with less boilerplate for components that
    don’t need to keep up with their own state.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态组件可以通过为不需要维护自身状态的组件创建更少的样板代码来创建。
- en: Larger components can be created by combining smaller subcomponents.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过组合较小的子组件来创建较大的组件。
- en: '2'
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Understanding React
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 React
- en: '*****This chapter*** ***covers*****'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '*****本章*** ***涵盖*****'
- en: How state works and why it’s important
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态是如何工作的以及为什么它很重要
- en: How properties work and why they’re important
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性是如何工作的以及为什么它们很重要
- en: Understanding the React component specification
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 React 组件规范
- en: Implementing React lifecycle methods
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 React 生命周期方法
- en: Now that we’ve gone over the basics, it’s time to dive into some other fundamental
    pieces that make up React and React Native. We’ll discuss how to manage state
    and data, and how data is passed through an application. We’ll also dive deeper
    by demonstrating how to pass properties (props) between components and how to
    manipulate these props from the top down.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了基础知识，是时候深入探讨构成 React 和 React Native 的其他一些基本组成部分了。我们将讨论如何管理状态和数据，以及数据是如何在应用中传递的。我们还将通过演示如何在组件之间传递属性（props）以及如何从上到下操作这些属性来进一步深入。
- en: After you’re equipped with knowledge about state and props, we’ll go deeper
    into how to use the built-in React lifecycle methods. These methods allow you
    to perform certain actions when a component is created or destroyed. Understanding
    them is key to understanding how React and React Native work and how to take full
    advantage of the framework. The lifecycle methods are also conceptually the biggest
    part of React and React Native.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在你掌握了关于状态和属性的知识后，我们将更深入地探讨如何使用内置的 React 生命周期方法。这些方法允许你在组件创建或销毁时执行某些操作。理解它们是理解
    React 和 React Native 的工作原理以及如何充分利用框架的关键。生命周期方法也是 React 和 React Native 中概念上最大的部分。
- en: 2.1 Managing component data using state
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 使用状态管理组件数据
- en: One of the ways data is created and managed in a React or React Native component
    is by using state. Component state is declared when the component is created,
    and its structure is a plain JavaScript object. State can be updated within the
    component using a function called `setState` that we’ll look at in depth shortly.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 或 React Native 组件中创建和管理数据的一种方式是使用状态。组件创建时声明状态，其结构是一个普通的 JavaScript 对象。状态可以在组件内部使用名为
    `setState` 的函数进行更新，我们将在稍后深入了解。
- en: The other way data can be handled is by using props. Props are passed down as
    parameters when the component is created; unlike state, they can’t be updated
    within the component.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 处理数据的另一种方式是使用属性。属性在组件创建时作为参数传递；与状态不同，它们不能在组件内部更新。
- en: 2.1.1 Correctly manipulating component state
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1 正确操作组件状态
- en: '*State* is a collection of values that a component manages. React thinks of
    UIs as simple state machines. When the state of a component changes using the
    `setState` function, React rerenders the component. If any child components are
    inheriting this state as props, then all of the child components are rerendered
    as well.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '*状态* 是组件管理的一组值。React 将 UI 视为简单的状态机。当组件使用 `setState` 函数改变状态时，React 会重新渲染该组件。如果任何子组件作为属性继承了此状态，那么所有子组件也会被重新渲染。'
- en: When building an application using React Native, understanding how state works
    is fundamental because state determines how stateful components render and behave.
    Component state is what allows you to create components that are dynamic and interactive.
    The main point to understand when differentiating between state and props is that
    state is mutable, whereas props are immutable.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 React Native 构建应用程序时，理解状态的工作原理是基础，因为状态决定了有状态组件的渲染和行为。组件状态允许你创建动态和交互式的组件。在区分状态和属性时，需要理解的主要点是状态是可变的，而属性是不可变的。
- en: Setting *Initial State*
  id: totrans-272
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置 *初始状态*
- en: State is initialized when a component is created either in the constructor or
    with a property initializer. Once the state is initialized, it’s available in
    the component as `this.state`. The following listing shows an example.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 状态在组件创建时通过构造函数或属性初始化器初始化。一旦状态初始化，它就作为 `this.state` 在组件中可用。以下列表展示了示例。
- en: Listing 2.1 Setting state with a property initializer
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.1 使用属性初始化器设置状态
- en: '[PRE43]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `constructor` function is called the moment a JavaScript class is instantiated,
    as shown in the next listing. This isn’t a React lifecycle method, but a regular
    JavaScript class method.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`constructor` 函数在 JavaScript 类实例化时被调用，如以下列表所示。这不是一个 React 生命周期方法，而是一个常规的 JavaScript
    类方法。'
- en: Listing 2.2 Setting state with a constructor
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.2 使用构造函数设置状态
- en: '[PRE44]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The constructor and property initializer both work exactly the same, and which
    approach you use is based on preference.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数和属性初始化器的工作方式完全相同，你使用哪种方法取决于个人喜好。
- en: Updating state
  id: totrans-280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新状态
- en: State can be updated by calling `this.setState(object)`, passing in an object
    with the new state you want to use. `setState` merges the previous state with
    the current state, so if you only pass in a single item (key-value pair), the
    rest of the state will remain the same, while the new item in the state will be
    overwritten.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过调用 `this.setState(object)` 来更新状态，传入一个包含你想要使用的新状态的对象。`setState` 会将前一个状态与当前状态合并，所以如果你只传入一个单项（键值对），其余的状态将保持不变，而状态中的新项将被覆盖。
- en: Let’s look at how to use `setState` (see [listing 2.3](#listing2.3)). To do
    so, we’ll introduce a new method, a touch handler called `onPress`. `onPress`
    can be called on a few types of “tappable” React Native components, but here you’ll
    attach it to a `Text` component to get started with this basic example. You’ll
    call a function called `updateYear` when the text is pressed, to update the state
    with `setState`. This function will be defined before the `render` function, because
    it’s usually best practice to define any custom methods before the render method,
    but keep in mind that the order of the definition of the functions doesn’t affect
    the actual functionality.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 `setState`（参见[列表2.3](#listing2.3)）。为此，我们将引入一个新的方法，一个名为 `onPress` 的触摸处理程序。`onPress`
    可以在几种“可触摸”的 React Native 组件上调用，但在这里你将把它附加到一个 `Text` 组件上，以便从这个基本示例开始。当文本被按下时，你将调用一个名为
    `updateYear` 的函数，以使用 `setState` 更新状态。这个函数将在 `render` 函数之前定义，因为通常最好在 `render` 方法之前定义任何自定义方法，但请注意，函数定义的顺序不会影响实际的功能。
- en: Listing 2.3 Updating state
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.3 更新状态
- en: '[PRE45]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '![c02_01.png](Images/c02_01.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![c02_01.png](Images/c02_01.png)'
- en: '[Figure 2.1](#figureanchor2.1) The flow of `setState`, with arrows indicating
    when the text element is pressed. The state `year` property is initialized to
    2016 in the constructor. Each time the text is pressed, the state `year` property
    is set to 2017.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.1](#figureanchor2.1) `setState` 的流程，箭头指示文本元素被按下时。在构造函数中，状态 `year` 属性被初始化为
    2016。每次按下文本时，状态 `year` 属性被设置为 2017。'
- en: '[Figure 2.1](#figure2.1) shows how the state is updated each time the text
    element in [listing 2.3](#listing2.3) is pressed. Every time `setState` is called,
    React will rerender the component (calling the `render` method again) and any
    child components. Calling `this.setState` is the way to change a state variable
    and trigger the `render` method again, because changing the state variable directly
    won’t trigger a rerender of the component and therefore no changes will be visible
    in the UI. A common mistake for beginners is updating the state variable directly.
    For example, something like the following doesn’t work when trying to update state—the
    `state` object is updated, but the UI isn’t updated because `setState` isn’t called
    and the component isn’t rerendered:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.1](#figure2.1) 展示了每次按下[列表2.3](#listing2.3)中的文本元素时状态是如何更新的。每次调用 `setState`，React
    都会重新渲染组件（再次调用 `render` 方法）以及任何子组件。调用 `this.setState` 是改变状态变量并再次触发 `render` 方法的途径，因为直接改变状态变量不会触发组件的重新渲染，因此
    UI 中不会看到任何变化。初学者常见的错误是直接更新状态变量。例如，以下代码在尝试更新状态时不起作用——`state` 对象被更新了，但由于没有调用 `setState`
    且组件没有重新渲染，UI 不会更新：'
- en: '[PRE46]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: But a method is available in React that can force an update once a state variable
    has been changed as in the previous snippet. This method is called `forceUpdate`;
    see [listing 2.4](#listing2.4). Calling `forceUpdate` causes `render` to be called
    on the component, triggering a rerendering of the UI. Using `forceUpdate` isn’t
    usually necessary or recommended, but it’s good to know about in case you run
    into it in examples or documentation. Most of the time, this rerendering can be
    handled using other methods such as calling `setState` or passing in new props.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 但在 React 中有一个方法可以在状态变量改变后强制更新，就像前面的代码片段中那样。这个方法叫做 `forceUpdate`；参见[列表2.4](#listing2.4)。调用
    `forceUpdate` 会导致组件上的 `render` 被调用，从而触发 UI 的重新渲染。使用 `forceUpdate` 通常不是必需的或推荐的，但了解它在示例或文档中可能会遇到是有好处的。大多数情况下，这种重新渲染可以通过其他方法来处理，例如调用
    `setState` 或传入新的 props。
- en: Listing 2.4 Forcing rerender with `forceUpdate`
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.4 使用 `forceUpdate` 强制重新渲染
- en: '[PRE47]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now that we’ve gone over how to work with state using a basic string, let’s
    look at a few other data types. You’ll attach a Boolean, an array, and an object
    to the state and use it in the component. You’ll also conditionally show a component
    based on a Boolean in the state.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何使用基本字符串来处理状态，让我们看看其他几种数据类型。你将把布尔值、数组和对象附加到状态中，并在组件中使用它。你还将根据状态中的布尔值有条件地显示组件。
- en: Listing 2.5 State with other data types
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.5 使用其他数据类型的状态
- en: '[PRE48]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 2.2 Managing component data using props
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 使用 props 管理组件数据
- en: '*Props* (short for *properties*) are a component’s inherited values or properties
    that have been passed down from a parent component. Props can be either static
    or dynamic values when they’re declared, but when they’re inherited they’re immutable;
    they can only be altered by changing the initial values at the top level where
    they’re declared and passed down. React’s “Thinking in React” documentation says
    that props are best explained as “a way of passing data from parent to child.”
    [Table 2.1](#table2.1) highlights some of the differences and similarities between
    props and state.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '*属性*（简称 *属性*）是组件继承的值或属性，它们是从父组件传递下来的。属性在声明时可以是静态或动态值，但在继承时是不可变的；它们只能通过更改它们声明和传递的顶层初始值来更改。React
    的 “React 思维” 文档说，属性最好解释为“从父组件到子组件传递数据的一种方式。” [表 2.1](#table2.1) 突出了属性和状态之间的一些差异和相似之处。'
- en: Table 2.1 Props vs. state
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.1 属性与状态
- en: '| **Props** | **State** |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **状态** |'
- en: '| --- | --- |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| External data | Internal data |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| 外部数据 | 内部数据 |'
- en: '| Immutable | Mutable |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| 不可变 | 可变 |'
- en: '| Inherited from a parent | Created in the component |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| 从父组件继承 | 在组件内部创建 |'
- en: '| Can be changed by a parent component | Can only be updated in the component
    |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| 可以由父组件更改 | 只能在组件内部更新 |'
- en: '| Can be passed down as props | Can be passed down as props |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| 可以作为属性向下传递 | 可以作为属性向下传递 |'
- en: '| Can’t change inside the component | Can change inside the component |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| 在组件内部无法更改 | 在组件内部可以更改 |'
- en: A good way to explain how props work is to show an example. The following listing
    declares a book value and passes it down to a child component as a static prop.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 解释属性工作原理的一个好方法是展示一个示例。以下列表声明了一个 `book` 值并将其作为静态属性传递给子组件。
- en: Listing 2.6 Static props
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.6 静态属性
- en: '[PRE49]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This code creates two components: `<MyComponent />` and `<BookDisplay />`.
    When you create `<BookDisplay />`, you pass in a property called `book` and set
    it to the string “React Native in Action”. Anything passed as a property in this
    way is available on the child component as `this.props`.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建了两个组件：`<MyComponent />` 和 `<BookDisplay />`。当你创建 `<BookDisplay />` 时，你传递一个名为
    `book` 的属性并将其设置为字符串 “React Native in Action”。以这种方式传递的任何属性都可在子组件上作为 `this.props`
    使用。
- en: You can also pass down literals as you would variables, by using curly braces
    and a string value as shown next.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用大括号和字符串值，就像下面的示例那样，以变量的方式传递字面量。
- en: Listing 2.7 Displaying static props
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.7 显示静态属性
- en: '[PRE50]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Dynamic props
  id: totrans-313
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 动态属性
- en: Next, pass a dynamic property to the component. In the `render` method, before
    the `return` statement, declare a variable `book` and pass it in as a prop.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将一个动态属性传递给组件。在 `render` 方法中，在 `return` 语句之前，声明一个变量 `book` 并将其作为属性传递。
- en: Listing 2.8 Dynamic props
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.8 动态属性
- en: '[PRE51]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now, pass a dynamic property to the component using state.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用状态将一个动态属性传递给组件。
- en: Listing 2.9 Dynamic props using state
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.9 使用状态动态属性
- en: '[PRE52]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, let’s look at how to update the state and, consequently, the value passed
    down as the prop to `BookDisplay`. Remember, props are immutable, so you’ll change
    the state of the parent component (`MyComponent`), which will supply a new value
    to the `BookDisplay` `book` prop and trigger a rerender of both the component
    and the child component. Breaking this idea into individual parts, here’s what
    needs to be done:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何更新状态以及随之而来的将作为属性传递给 `BookDisplay` 的值。记住，属性是不可变的，所以你需要更改父组件（`MyComponent`）的状态，这将向
    `BookDisplay` 的 `book` 属性提供一个新值并触发组件及其子组件的重新渲染。将这个想法分解成单独的部分，以下是需要执行的操作：
- en: 'Declare the state variable:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明状态变量：
- en: '[PRE53]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Write a function that will update the state variable:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数来更新状态变量：
- en: '[PRE54]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Pass the function and the state down to the child component as props:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将函数和状态作为属性传递给子组件：
- en: '[PRE55]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Attach the function to the touch handler in the child component:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将函数附加到子组件中的触摸处理程序：
- en: '[PRE56]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now that you know the pieces you need, you can write the code to put this into
    action. You’ll use the components from the previous examples and add the new functionality.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了所需的组件，你可以编写代码来实现这一功能。你将使用前一个示例中的组件并添加新的功能。
- en: Listing 2.10 Updating dynamic props
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.10 更新动态属性
- en: '[PRE57]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Destructuring props and state
  id: totrans-332
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 属性和状态的解构
- en: 'Constantly referring to state and props as `this.state` and `this.props` can
    get repetitive, violating the DRY (don’t repeat yourself) principle that many
    of us try to follow. To fix this, you can try using destructuring. *Destructuring*
    is a new JavaScript feature that was added as part of the ES2015 spec and is available
    in React Native applications. The basic idea is that you can take properties from
    an object and use them as variables in an app:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 持续引用状态和props为`this.state`和`this.props`可能会变得重复，违反了我们许多人试图遵循的DRY（不要重复自己）原则。为了解决这个问题，你可以尝试使用解构。*解构*是作为ES2015规范的一部分添加到JavaScript中的新特性，并在React
    Native应用程序中可用。基本思想是你可以从对象中提取属性并将它们用作应用程序中的变量：
- en: '[PRE58]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Write a component using destructuring, as shown next.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 按照下面的示例使用解构编写组件。
- en: Listing 2.11 Destructuring state and props
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.11 解构状态和props
- en: '[PRE59]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: You no longer have to refer to `this.state` or `this.props` in the component
    when referencing the book; instead, you’ve taken the `book` variable out of the
    state and the props and can reference the variable itself. This starts to make
    more sense and will keep your code cleaner as your state and props become larger
    and more complex.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 当引用书籍时，你不再需要在组件中引用`this.state`或`this.props`；相反，你已经从状态和props中提取了`book`变量，可以直接引用该变量。这开始变得更有意义，并且随着状态和props变得更大更复杂，你的代码也会变得更加清晰。
- en: Props with stateless components
  id: totrans-339
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用无状态组件的props
- en: Because stateless components only have to worry about props and don’t have their
    own state, they can be extremely useful when creating reusable components. Let’s
    see how props are used in a stateless component.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 由于无状态组件只需要关注props而没有自己的状态，因此在创建可重用组件时它们可以非常有用。让我们看看props如何在无状态组件中使用。
- en: To access props using a stateless component, pass in `props` as the first argument
    to the function.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用无状态组件访问props，将`props`作为函数的第一个参数传递。
- en: Listing 2.12 Props with stateless components
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.12 使用无状态组件的props
- en: '[PRE60]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: You can also destructure props in the function argument.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在函数参数中解构props。
- en: Listing 2.13 Destructuring props in a stateless component
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.13 在无状态组件中解构props
- en: '[PRE61]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: That looks much nicer and cleans up a lot of unnecessary code! You should use
    stateless components wherever you can, simplifying your codebase and logic.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这样看起来更美观，并且清理了很多不必要的代码！你应该尽可能使用无状态组件，简化你的代码库和逻辑。
- en: Passing arrays and objects as props
  id: totrans-348
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将数组和对象作为props传递
- en: Other data types work exactly as you might expect. For example, to pass an array,
    you pass in the array as a prop. To pass an object, you pass in the object as
    a prop. Let’s look at a basic example.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 其他数据类型的工作方式与你预期的一样。例如，要传递一个数组，你将数组作为prop传递。要传递一个对象，你将对象作为prop传递。让我们看看一个基本示例。
- en: Listing 2.14 Passing other data types as props
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.14 将其他数据类型作为props传递
- en: '[PRE62]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 2.3 React component specifications
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 React组件规范
- en: When creating React and React Native components, you can hook into several specifications
    and lifecycle methods to control what’s going on in your component. In this section,
    we’ll discuss them and give you a good understanding of what each one does and
    when you should use them.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建React和React Native组件时，你可以挂钩到几个规范和生命周期方法来控制组件中的行为。在本节中，我们将讨论它们，并给你一个很好的理解，了解每个方法做什么以及何时应该使用它们。
- en: 'First we’ll go over the basics of the component specifications. A component
    *specification* basically lays out how a component should react to different things
    happening in the lifecycle of the component. The specifications are as follows:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将介绍组件规范的基础知识。组件规范基本上概述了组件应该如何对组件生命周期中发生的不同事件做出反应。规范如下：
- en: '`render` method'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`render`方法'
- en: '`constructor` method'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`constructor`方法'
- en: '`statics` object, used to define static methods available to a class'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`statics`对象，用于定义类可用的静态方法'
- en: 2.3.1 Using the render method to create a UI
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 使用render方法创建UI
- en: 'The `render` method is the only method in the component specification that’s
    required when creating a component. It must return either a single child element,
    `null`, or `false`. This child element can be a component you declared (such as
    a `View` or `Text` component), or another component you defined (maybe a `Button`
    component you created and imported into the file):'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`render`方法是组件规范中创建组件时唯一必需的方法。它必须返回单个子元素、`null`或`false`。这个子元素可以是你在组件中声明的组件（如`View`或`Text`组件），或者另一个你定义的组件（比如你创建并导入到文件中的`Button`组件）：'
- en: '[PRE63]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You can use the `render` method with or without parentheses. If you don’t use
    parentheses, then the returned element must of course be on the same line as the
    `return` statement:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用带或不带括号的`render`方法。如果你不使用括号，那么返回的元素当然必须与`return`语句在同一行：
- en: '[PRE64]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `render` method can also return another component that was defined elsewhere:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`render`方法也可以返回在别处定义的另一个组件：'
- en: '[PRE65]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'You can also check for conditionals in the `render` method, perform logic,
    and return components based on their value:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在`render`方法中检查条件，执行逻辑，并根据它们的值返回组件：
- en: '[PRE66]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 2.3.2 Using property initializers and constructors
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 使用属性初始化器和构造函数
- en: 'State can be created in a constructor or using a *property initializer*. Property
    initializers are an ES7 specification to the JavaScript language, but they work
    out of the box with React Native. They provide a concise way to declare state
    in a React class:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 状态可以在构造函数中创建或使用*属性初始化器*。属性初始化器是JavaScript语言的ES7规范，但它们与React Native无缝配合工作。它们提供了一种简洁的方法来在React类中声明状态：
- en: '[PRE67]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'You can also use a `constructor` method to set the initial state when using
    classes. The concept of classes, as well as the `constructor` function, isn’t
    specific to React or React Native; it’s an ES2015 specification and is just syntactic
    sugar on top of JavaScript’s existing prototype-based inheritance for creating
    and initializing an object created with a class. Other properties can also be
    set for a component class in the constructor by declaring them with the syntax
    `this.property` (`property` being the name of the property). The keyword `this`
    refers to the current class instance you’re in:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`constructor`方法在类中使用时设置初始状态。类以及`constructor`函数的概念并不特定于React或React Native；它是一个ES2015规范，并且只是JavaScript现有基于原型的继承之上创建和初始化对象的语法糖。你还可以在构造函数中通过使用`this.property`语法（`property`是属性的名称）为组件类设置其他属性。关键字`this`指的是你当前所在的类实例：
- en: '[PRE68]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: When using a constructor to create a React class, you must use the `super` keyword
    before you can use the `this` keyword, because you’re extending another class.
    Also, if you need access to any props in the constructor, they must be passed
    as an argument to the constructor and the `super` call.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用构造函数创建React类时，你必须在使用`this`关键字之前使用`super`关键字，因为你正在扩展另一个类。此外，如果你需要在构造函数中访问任何props，它们必须作为参数传递给构造函数，并在`super`调用中。
- en: Setting the state based on props usually isn’t good practice unless you’re intentionally
    setting some type of seed data for the component’s internal functionality, because
    the data will no longer be consistent across components if it’s changed. State
    is only created when the component is first mounted or created. If you rerender
    the same component using different prop values, then any instances of that component
    that have already been mounted won’t use the new prop values to update state.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 根据props设置状态通常不是好的做法，除非你故意为组件的内部功能设置某种类型的种子数据，因为如果数据被更改，状态将不再在组件之间保持一致性。状态仅在组件首次挂载或创建时创建。如果你使用不同的prop值重新渲染相同的组件，那么已经挂载的该组件实例将不会使用新的prop值来更新状态。
- en: 'The following example shows props being used to set state values within the
    constructor. Let’s say you pass in “Nader Dabit” as the props to the component
    initially: the `fullName` property in the state will be “Nader Dabit”. If the
    component is then rerendered with “Another Name”, the constructor won’t be called
    a second time, so the state value for `fullName` will remain “Nader Dabit”:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了在构造函数中使用props设置状态值。假设你最初将“Nader Dabit”作为props传递给组件：状态中的`fullName`属性将是“Nader
    Dabit”。如果组件随后被重新渲染为“Another Name”，则构造函数不会再次被调用，因此`fullName`的状态值将保持为“Nader Dabit”：
- en: '[PRE69]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 2.4 React lifecycle methods
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 React生命周期方法
- en: 'Various methods are executed at specific points in a component’s lifecycle:
    these are called the *lifecycle methods*. Understanding how they work is important
    because they allow you to perform specific actions at different points in the
    creation and destruction of a component. For example, suppose you wanted to make
    an API call that returned some data. You’d probably want to make sure the component
    was ready to render this data, so you’d make the API call once the component was
    mounted in a method called `componentDidMount`. In this section, we’ll go over
    the lifecycle methods and explain how they work.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件的生命周期中，各种方法会在特定的点被调用：这些被称为 *生命周期方法*。理解它们是如何工作的很重要，因为它们允许你在组件的创建和销毁的不同点执行特定的操作。例如，假设你想进行一个返回一些数据的
    API 调用。你可能想确保组件已经准备好渲染这些数据，所以你会在组件挂载后，在名为 `componentDidMount` 的方法中进行 API 调用。在本节中，我们将介绍生命周期方法，并解释它们是如何工作的。
- en: 'The life of a React component has three stages: creation (mounting), updating,
    and deletion (unmounting). During these three stages, you can hook into three
    sets of lifecycle methods:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 React 组件的生命周期分为三个阶段：创建（挂载）、更新，以及删除（卸载）。在这三个阶段中，你可以钩入三组生命周期方法：
- en: '*Mounting (creation)* —When a component is created, a series of lifecycle methods
    are triggered and you have the option to hook into any or all of them: `constructor`,
    `getDerivedStateFromProps`, `render`, and `componentDidMount`. The one such method
    you’ve used so far is `render`, which renders and returns a UI.'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*挂载（创建）* —当组件被创建时，一系列生命周期方法会被触发，你有选择性地钩入任何一个或所有这些方法：`constructor`、`getDerivedStateFromProps`、`render`
    和 `componentDidMount`。你迄今为止使用的一个这样的方法是 `render`，它渲染并返回一个 UI。'
- en: '*Updating* —When a component updates, the update lifecycle methods are triggered:
    `getDerivedStateFromProps` (when props change), `shouldComponentUpdate`, `render`,
    `getSnapshotBeforeUpdate`, and `componentDidUpdate`. An update can happen in one
    of two ways:'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更新* —当组件更新时，更新生命周期方法会被触发：`getDerivedStateFromProps`（当属性改变时）、`shouldComponentUpdate`、`render`、`getSnapshotBeforeUpdate`
    和 `componentDidUpdate`。更新可以通过两种方式之一发生：'
- en: When `setState` or `forceUpdate` is called within a component
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在组件内部调用 `setState` 或 `forceUpdate` 时
- en: When new props are passed down into the component
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当将新的属性传递到组件中
- en: '*Unmounting* —When the component is unmounted (destroyed), a final lifecycle
    method is triggered: `componentWillUnmount`.'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*卸载* —当组件被卸载（销毁）时，会触发一个最终的生命周期方法：`componentWillUnmount`。'
- en: 2.4.1 The static getDerivedStateFromProps method
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.1 `getDerivedStateFromProps` 静态方法
- en: '`getDerivedStateFromProps` is a static class method that is called both when
    the component is created and when it receives new props. This method receives
    the new props and most up-to-date state as arguments and returns an object. The
    data in the object is updated to the state. The following listing shows an example.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`getDerivedStateFromProps` 是一个静态类方法，在组件创建时以及接收到新属性时都会被调用。这个方法接收新的属性和最新的状态作为参数，并返回一个对象。对象中的数据会被更新到状态中。以下列表展示了一个示例。'
- en: Listing 2.15 `static``getDerivedStateFromProps`
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.15 `static getDerivedStateFromProps`
- en: '[PRE70]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 2.4.2 The componentDidMount lifecycle method
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.2 `componentDidMount` 生命周期方法
- en: '`componentDidMount` is called exactly once, just after the component has been
    loaded. This method is a good place to fetch data with AJAX calls, perform `setTimeout`
    functions, and integrate with other JavaScript frameworks.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`componentDidMount` 只会被调用一次，在组件加载完毕之后。这个方法是一个很好的地方来使用 AJAX 调用获取数据，执行 `setTimeout`
    函数，以及与其他 JavaScript 框架集成。'
- en: Listing 2.16 `componentDidMount`
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.16 `componentDidMount`
- en: '[PRE71]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 2.4.3 The shouldComponentUpdate lifecycle method
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.3 `shouldComponentUpdate` 生命周期方法
- en: '`shouldComponentUpdate` returns a Boolean and lets you decide when a component
    renders. If you know the new state or props won’t require the component or any
    of its children to render, you can return `false`. If you want the component to
    rerender, return `true`.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '`shouldComponentUpdate` 返回一个布尔值，让你决定组件何时渲染。如果你知道新的状态或属性不会要求组件或其子组件进行渲染，你可以返回
    `false`。如果你想使组件重新渲染，返回 `true`。'
- en: Listing 2.17 `shouldComponentUpdate`
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.17 `shouldComponentUpdate`
- en: '[PRE72]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 2.4.4 The componentDidUpdate lifecycle method
  id: totrans-396
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.4 `componentDidUpdate` 生命周期方法
- en: '`componentDidUpdate` is invoked immediately after the component has been updated
    and rerendered. You get the previous state and previous props as arguments.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '`componentDidUpdate` 在组件更新和重新渲染后被立即调用。你将获得前一个状态和前一个属性作为参数。'
- en: Listing 2.18 `componentDidUpdate`
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.18 `componentDidUpdate`
- en: '[PRE73]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 2.4.5 The componentWillUnmount lifecycle method
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.5 `componentWillUnmount` 生命周期方法
- en: '`componentWillUnmount` is called before the component is removed from the application.
    Here, you can perform any necessary cleanup, remove listeners, and remove timers
    that were set up in `componentDidMount`.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '`componentWillUnmount`在组件从应用程序中移除之前被调用。在这里，你可以执行任何必要的清理工作，移除监听器，并移除在`componentDidMount`中设置的计时器。'
- en: Listing 2.19 componentWillUnmount
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.19 componentWillUnmount
- en: '[PRE74]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Summary
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: State is a way to handle data in React components. Updating state rerenders
    the UI of the component and any child component relying on this data as props.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态是处理React组件中数据的一种方式。更新状态会重新渲染组件的UI以及任何依赖于这些数据的子组件。
- en: Properties (props) are how data is passed down through a React Native application
    to child components. Updating props automatically updates any components receiving
    the same props.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性（props）是通过React Native应用程序向下传递数据到子组件的方式。更新props会自动更新接收相同props的任何组件。
- en: A React component specification is a group of methods and properties in a React
    component that specifies the declaration of the component. `render` is the only
    required method when creating a React component; all other methods and properties
    are optional.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React组件规范是一组在React组件中的方法和属性，它指定了组件的声明。在创建React组件时，`render`是唯一必需的方法；所有其他方法和属性都是可选的。
- en: 'There are three main stages in a React component’s lifecycle: creation (mounting),
    updating, and deletion (unmounting). Each has its own set of lifecycle methods.'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React组件的生命周期有三个主要阶段：创建（挂载）、更新和删除（卸载）。每个阶段都有自己的生命周期方法集。
- en: React lifecycle methods are available in a React component and are executed
    at specific points in the component’s lifecycle. They control how the component
    functions and updates.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React生命周期方法在React组件中可用，并在组件生命周期的特定点执行。它们控制组件的功能和更新。
- en: '3'
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Building your first React Native app
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 构建你的第一个React Native应用
- en: '*****This chapter*** ***covers*****'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '*****本章***主要涵盖*****'
- en: Building a todo app from the ground up
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头开始构建待办事项应用
- en: Light debugging
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻量级调试
- en: 'When learning a new framework, technology, language, or concept, diving directly
    into the process by building a real app is a great way to jump-start the learning
    process. Now that you understand the basics of how React and React Native work,
    let’s put these pieces together to make your first app: a todo app. Going through
    the process of building a small app and using the information we’ve gone over
    so far will be a good way to reinforce your understanding of how to use React
    Native.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 当学习一个新的框架、技术、语言或概念时，通过构建一个真实的应用程序来直接进入过程是一种很好的快速启动学习过程的方法。现在你已经了解了React和React
    Native的基本工作原理，让我们将这些部分组合起来，制作你的第一个应用：一个待办事项应用。通过构建一个小应用并使用我们迄今为止所讨论的信息，将是一个很好的巩固你对如何使用React
    Native理解的方法。
- en: 'You’ll use some functionality in the app that we haven’t yet covered in depth,
    and some styling nuances we’ve yet to discuss, but don’t worry. Instead of going
    over these new ideas one by one now, you’ll build the basic app and then learn
    about these concepts in detail in later chapters. Take this opportunity to play
    around with the app as you build it to learn as much as possible in the process:
    feel free to break and fix styles and components to see what happens.'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用一些在应用中尚未深入探讨的功能，以及一些我们尚未讨论的样式细节，但不用担心。现在不是逐一介绍这些新想法的时候，你将构建基本的应用程序，然后在后面的章节中详细学习这些概念。抓住这个机会，在构建应用的过程中尽可能多地学习：你可以自由地破坏和修复样式和组件，看看会发生什么。
- en: 3.1 Laying out the todo app
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 设计待办事项应用
- en: Let’s get started building the todo app. It will be similar in style and functionality
    to the apps on the TodoMVC site ([http://todomvc.com](http://todomvc.com)). [Figure
    3.1](#figure3.1) shows how the app will look when you’re finished, so you can
    conceptualize what components you need and how to structure them. As in chapter
    1, [figure 3.2](#figure3.2) breaks the app into components and container components.
    Let’s see how this will look in the app using a basic implementation of React
    Native components.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建待办事项应用。它将类似于TodoMVC网站上的应用（[http://todomvc.com](http://todomvc.com)）。[图3.1](#figure3.1)显示了完成后的应用外观，这样你可以概念化你需要哪些组件以及如何组织它们。就像第1章中一样，[图3.2](#figure3.2)将应用分解为组件和容器组件。让我们看看在应用中使用React
    Native组件的基本实现，这将如何呈现。
- en: '![c03_01.tif](Images/c03_01.png)'
  id: totrans-419
  prefs: []
  type: TYPE_IMG
  zh: '![c03_01.tif](Images/c03_01.png)'
- en: '[Figure 3.1](#figureanchor3.1) Todo app design'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.1](#figureanchor3.1) 待办事项应用设计'
- en: '![c03_02.tif](Images/c03_02.png)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
  zh: '![c03_02.tif](Images/c03_02.png)'
- en: '[Figure 3.2](#figureanchor3.2) Todo app with descriptions'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.2](#figureanchor3.2) 带描述的待办事项应用'
- en: Listing 3.1 Basic todo app implementation
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.1 基本待办事项应用程序实现
- en: '[PRE75]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The app will display a heading, a text input, a button, and a tab bar. When
    you add a todo, the app will add it to the array of todos and display the new
    todo beneath the input. Each todo will have two buttons: Done and Delete. The
    Done button will mark it as complete, and the Delete button will remove it from
    the array of todos. At the bottom of the screen, the tab bar will filter the todos
    based on whether they’re complete or still active.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将显示一个标题、一个文本输入框、一个按钮和一个标签栏。当你添加一个待办事项时，应用程序会将它添加到待办事项数组中，并在输入框下方显示新的待办事项。每个待办事项将有两个按钮：完成和删除。完成按钮将标记为完成，删除按钮将从待办事项数组中移除它。屏幕底部，标签栏将根据待办事项是否完成或仍然活跃来过滤待办事项。
- en: 3.2 Coding the todo app
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 编写待办事项应用程序的代码
- en: 'Let’s get started coding the app. Create a new React Native project by typing
    `react-native init TodoApp` in your terminal (see [figure 3.3](#figure3.3)). Now,
    go into your index file: if you’re developing for iOS, open index.iOS.js; and
    if you’re developing for Android, open index.Android.js. The code for both platforms
    will be the same.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编写应用程序的代码。在终端中输入 `react-native init TodoApp` 来创建一个新的 React Native 项目（见[图3.3](#figure3.3)）。现在，进入你的索引文件：如果你正在为
    iOS 开发，打开 index.iOS.js；如果你正在为 Android 开发，打开 index.Android.js。两个平台的代码将是相同的。
- en: '![c03_03.tif](Images/c03_03.png)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![c03_03.tif](Images/c03_03.png)'
- en: '[Figure 3.3](#figureanchor3.3) Initializing a new React Native app'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.3](#figureanchor3.3) 初始化新的 React Native 应用程序'
- en: In the index file, import an `App` component (which you’ll create soon), and
    delete the styling along with any extra components you’re no longer using.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在索引文件中，导入一个 `App` 组件（你很快就会创建它），并删除任何不再使用的样式和额外组件。
- en: Listing 3.2 index.js
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.2 index.js
- en: '[PRE76]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Here, you bring in `AppRegistry` from `react-native`. You also bring in the
    main `App` component, which you’ll create next.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你从 `react-native` 中引入了 `AppRegistry`。同时，你也引入了主要的 `App` 组件，你将在下一部分创建它。
- en: 'In the `AppRegistry` method, you initiate the application. `AppRegistry` is
    the JS entry point to running all React Native apps. It takes two arguments: the
    `appKey`, or the name of the application you defined when you initialized the
    app; and a function that returns the React Native component you want to use as
    the entry point of the app. In this case, you’re returning the `TodoApp` component
    declared in [listing 3.2](#listing3.2).'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AppRegistry` 方法中，你初始化了应用程序。`AppRegistry` 是运行所有 React Native 应用程序的 JS 入口点。它接受两个参数：`appKey`，或者你在初始化应用程序时定义的应用程序名称；以及一个返回你想要用作应用程序入口点的
    React Native 组件的函数。在这种情况下，你返回了在[列表3.2](#listing3.2)中声明的 `TodoApp` 组件。
- en: Now, create a folder called app in the root of the application. In the app folder,
    create a file called App.js and add the basic code shown in the next listing.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在应用程序的根目录下创建一个名为 app 的文件夹。在 app 文件夹中，创建一个名为 App.js 的文件，并添加下一列表中显示的基本代码。
- en: Listing 3.3 Creating the `App` component
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.3 创建 `App` 组件
- en: '[PRE77]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'You import a new component called `ScrollView`, which wraps the platform `ScrollView`
    and is basically a scrollable `View` component. A `keyboardShouldPersistTaps`
    prop of `always` is added: this prop will dismiss the keyboard if it’s open and
    allow the UI to process any `onPress` events. You make sure both the `ScrollView`
    and the parent `View` of the `ScrollView` have a `flex:1` value. `flex:1` is a
    style value that makes the component fill the entire space of its parent container.'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 你导入了一个名为 `ScrollView` 的新组件，它包装了平台 `ScrollView`，基本上是一个可滚动的 `View` 组件。添加了一个 `keyboardShouldPersistTaps`
    属性，值为 `always`：这个属性会在键盘打开时关闭键盘，并允许 UI 处理任何 `onPress` 事件。你确保 `ScrollView` 和 `ScrollView`
    的父 `View` 都有一个 `flex:1` 的值。`flex:1` 是一个样式值，它使组件填充其父容器整个空间。
- en: Now, set up an initial state for some of the values you’ll need later. You need
    an array to keep your todos, which you’ll name `todos`; a value to hold the current
    state of the `TextInput` that will add the todos, named `inputValue`; and a value
    to store the type of todo that you’re currently viewing (All, Current, or Active),
    named `type`.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为一些你稍后需要的值设置一个初始状态。你需要一个数组来保存你的待办事项，你可以将其命名为 `todos`；一个用于保存添加待办事项的 `TextInput`
    当前状态的值，命名为 `inputValue`；以及一个用于存储你当前查看的待办事项类型（全部、当前或活跃），命名为 `type`。
- en: In App.js, before the `render` function, add a constructor and an initial state
    to the class, and initialize these values in the state.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `App.js` 中，在 `render` 函数之前，给类添加一个构造函数和一个初始状态，并在状态中初始化这些值。
- en: Listing 3.4 Setting the initial state
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.4 设置初始状态
- en: '[PRE78]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Next, create the `Heading` component and give it some styling. In the app folder,
    create a file called Heading.js. This will be a stateless component.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建`Heading`组件并为其设置一些样式。在应用文件夹中创建一个名为Heading.js的文件。这将是一个无状态组件。
- en: Listing 3.5 Creating the `Heading` component
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.5 创建`Heading`组件
- en: '[PRE79]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Note that in the styling of `headerText`, you pass an `rgba` value to `color`.
    If you aren’t familiar with RGBA, the first three values make up the RGB color
    values, and the last value represents the alpha or opacity (red, blue, green,
    alpha). You pass in an alpha value of 0.25, or 25%. You also set the font weight
    to `100`, which will give the text a thinner weight and look.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`headerText`的样式设置中，你传递一个`rgba`值给`color`属性。如果你不熟悉RGBA，前三个值组成RGB颜色值，最后一个值代表alpha或透明度（红、蓝、绿、alpha）。你传入一个alpha值为0.25，即25%。你还设置了字体粗细为`100`，这将使文本看起来更细。
- en: Go back into App.js, bring in the `Heading` component, and place it in the `ScrollView`,
    replacing the empty `View` you originally placed there.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 返回App.js，引入`Heading`组件，并将其放置在`ScrollView`中，替换你最初放置的空`View`。
- en: 'Run the app to see the new heading and app layout: see [figure 3.4](#figure3.4).
    To run the app in iOS, use `react-native run-ios`. To run in Android, use `react-native
    run-android` in your terminal from the root of your React Native application.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用以查看新的标题和布局：见[图3.4](#figure3.4)。要在iOS上运行应用，使用`react-native run-ios`。要在Android上运行，从你的React
    Native应用程序的根目录使用终端中的`react-native run-android`。
- en: '![c03_04.tif](Images/c03_04.png)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
  zh: '![c03_04.tif](Images/c03_04.png)'
- en: '[Figure 3.4](#figureanchor3.4) Running the app'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.4](#figureanchor3.4) 运行应用'
- en: Listing 3.6 Importing and using the `Heading` component
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.6 导入和使用`Heading`组件
- en: '[PRE80]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Next, create the `TextInput` component and give it some styling. In the app
    folder, create a file called Input.js.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建`TextInput`组件并为其设置一些样式。在应用文件夹中创建一个名为Input.js的文件。
- en: Listing 3.7 Creating the `TextInput` component
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.7 创建`TextInput`组件
- en: '[PRE81]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: You’re using a new React Native component called `TextInput` here. If you’re
    familiar with web development, this is similar to an HTML `input`. You also give
    both the `TextInput` and the outer `View` their own styling.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里使用了一个新的React Native组件`TextInput`。如果你熟悉Web开发，这类似于HTML中的`input`。你还为`TextInput`和外部`View`设置了它们自己的样式。
- en: '`TextInput` takes a few other props. Here, you specify a `placeholder` to show
    text before the user starts to type, a `placeholderTextColor` that styles the
    placeholder text, and a `selectionColor` that styles the cursor for the `TextInput`.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextInput`还有一些其他的属性。在这里，你指定了一个`placeholder`来在用户开始输入之前显示文本，一个`placeholderTextColor`来设置占位符文本的样式，以及一个`selectionColor`来设置`TextInput`的光标样式。'
- en: The next step, in section 3.4, will be to wire up a function to get the value
    of the `TextInput` and save it to the state of the `App` component. You’ll also
    go into App.js and add a new function called `inputChange` below the `constructor`
    and above the `render` function. This function will update the state value of
    `inputValue` with the value passed in, and for now will also log out the value
    of `inputValue` for you to make sure the function is working by using `console.log()`.
    But to view `console.log()` statements in React Native, you first need to open
    the developer menu. Let’s see how it works.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个步骤，在第3.4节中，将是一个将函数连接到获取`TextInput`的值并将其保存到`App`组件的状态中的步骤。你还将进入App.js并在`constructor`下方、`render`函数上方添加一个名为`inputChange`的新函数。这个函数将使用传入的值更新`inputValue`的状态值，并且目前还将使用`console.log()`输出`inputValue`的值，以便你可以通过查看`console.log()`语句来确保函数正常工作。但要在React
    Native中查看`console.log()`语句，你首先需要打开开发者菜单。让我们看看它是如何工作的。
- en: 3.3 Opening the developer menu
  id: totrans-459
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 打开开发者菜单
- en: The developer menu is a built-in menu available as a part of React Native; it
    gives you access to the main debugging tools you’ll use. You can open it in the
    iOS simulator or in the Android emulator. In this section, I’ll show you how to
    open and use the developer menu on both platforms.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者菜单是React Native内置的菜单，作为React Native的一部分提供；它为你提供了使用的主要调试工具。你可以在iOS模拟器或Android模拟器中打开它。在本节中，我将向你展示如何在两个平台上打开和使用开发者菜单。
- en: 3.3.1 Opening the developer menu in the iOS simulator
  id: totrans-461
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 在iOS模拟器中打开开发者菜单
- en: 'While the project is running in the iOS simulator, you can open the developer
    menu in one of three ways:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 当项目在iOS模拟器中运行时，你可以通过以下三种方式之一打开开发者菜单：
- en: Press Cmd-D on the keyboard.
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在键盘上按Cmd-D。
- en: Press Cmd-Ctrl-Z on the keyboard.
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在键盘上按Cmd-Ctrl-Z。
- en: Open the Hardware > Shake Gesture menu in the simulator options (see [figure
    3.5](#figure3.5)).
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模拟器选项中打开硬件 > 摇动手势菜单（见[图3.5](#figure3.5)）。
- en: '![c03_05.tif](Images/c03_05.png)'
  id: totrans-466
  prefs: []
  type: TYPE_IMG
  zh: '![c03_05.tif](Images/c03_05.png)'
- en: '[Figure 3.5](#figureanchor3.5) Manually opening the developer menu (iOS simulator)'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.5](#figureanchor3.5) 手动打开开发者菜单（iOS模拟器）'
- en: '![c03_06.tif](Images/c03_06.png)'
  id: totrans-468
  prefs: []
  type: TYPE_IMG
  zh: '![c03_06.tif](Images/c03_06.png)'
- en: Figure 3.6 React Native developer menu (iOS simulator)
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 React Native开发者菜单（iOS模拟器）
- en: When you do, you should see the developer menu, shown in figure 3.6.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 当你这样做时，你应该看到图3.6所示的开发者菜单。
- en: 3.3.2 Opening the developer menu in the Android emulator
  id: totrans-471
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.2 在Android模拟器中打开开发者菜单
- en: 'With the project open and running in the Android emulator, the developer menu
    can be opened in one of three ways:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android模拟器中打开并运行项目时，开发者菜单可以通过以下三种方式之一打开：
- en: Press F2 on the keyboard.
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按键盘上的F2键。
- en: Press Cmd-M on the keyboard.
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按键盘上的Cmd-M键。
- en: Press the Hardware button (see [figure 3.7](#figure3.7)).
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下硬件按钮（见[图3.7](#figure3.7)）。
- en: '![c03_08.eps](Images/c03_08.png)'
  id: totrans-476
  prefs: []
  type: TYPE_IMG
  zh: '![c03_08.eps](Images/c03_08.png)'
- en: '[Figure 3.7](#figureanchor3.7) Manually opening the hardware menu (Android
    emulator)'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.7](#figureanchor3.7) 手动打开硬件菜单（Android模拟器）'
- en: '![c03_09.tif](Images/c03_09.png)'
  id: totrans-478
  prefs: []
  type: TYPE_IMG
  zh: '![c03_09.tif](Images/c03_09.png)'
- en: Figure 3.8 React Native developer menu (Android emulator)
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 React Native开发者菜单（Android模拟器）
- en: When you do, you should see the developer menu shown in figure 3.8.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 当你这样做时，你应该看到图3.8所示的开发者菜单。
- en: 3.3.3 Using the developer menu
  id: totrans-481
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.3 使用开发者菜单
- en: 'When the developer menu opens, you should see the following options:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者菜单打开时，你应该看到以下选项：
- en: '*Reload (iOS and Android)* —Reloads the app. This can also be done by pressing
    Cmd-R on the keyboard (iOS) or pressing R twice (Android).'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*重新加载（iOS和Android）*—重新加载应用。这也可以通过按键盘上的Cmd-R（iOS）或按两次R（Android）键来完成。'
- en: '*Debug JS Remotely (iOS and Android)* —Opens the Chrome dev tools and gives
    you full debugging support through the browser ([figure 3.9](#figure3.9)). Here,
    you have access not only to logging statements in your code, but also to breakpoints
    and whatever you’re used to while debugging web apps (with the exception of the
    DOM). If you need to log any information or data in your app, this is usually
    the place to do so.'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*远程调试JS（iOS和Android）*—打开Chrome开发者工具，并通过浏览器提供完整的调试支持（[图3.9](#figure3.9)）。在这里，你可以访问代码中的日志语句，以及你在调试Web应用时习惯使用的断点和其他功能（除了DOM）。如果你需要在应用中记录任何信息或数据，这通常是这样做的地方。'
- en: '![c03_10.tif](Images/c03_10.png)'
  id: totrans-485
  prefs: []
  type: TYPE_IMG
  zh: '![c03_10.tif](Images/c03_10.png)'
- en: '[Figure 3.9](#figureanchor3.9) Debugging in Chrome'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.9](#figureanchor3.9) 在Chrome中进行调试'
- en: '*Enable Live Reload (iOS and Android)—*Enables live reload. When you make changes
    in your code, the entire app will reload and refresh in the simulator.'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*启用实时重新加载（iOS和Android）*—启用实时重新加载。当你修改代码时，整个应用将在模拟器中重新加载并刷新。'
- en: '*Start Systrace (iOS only)—*Systrace is a profiling tool. This will give you
    a good idea of where your time is being spent during each 16 ms frame while your
    app is running. Profiled code blocks are surrounded by start/end markers that
    are then visualized in a colorful chart format. Systrace can also be enabled manually
    from the command line in Android. If you want to learn more, check out the docs
    for a very comprehensive overview.'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*启动Systrace（仅限iOS）*—Systrace是一个性能分析工具。这将在你的应用运行时，为你提供一个关于每个16毫秒帧期间时间消耗的好主意。被分析代码块被起始/结束标记所包围，然后以彩色图表格式进行可视化。Systrace也可以在Android中通过命令行手动启用。如果你想了解更多信息，请查看文档以获取全面的概述。'
- en: '*Enable Hot Reloading (iOS and Android)—*A great feature added in version .22
    of React Native. It offers an amazing developer experience, giving you the ability
    to see your changes immediately as files are changed without losing the current
    state of the app. This is especially useful for making UI changes deep in your
    app without losing state. It’s different than live reloading because it retains
    the current state of your app, only updating the components and state that have
    been changed (live reloading reloads the entire app, therefore losing the current
    state).'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*启用热重新加载（iOS和Android）*—React Native版本.22中添加的一个优秀功能。它提供了一个惊人的开发者体验，允许你在文件更改时立即看到更改，而不会丢失应用当前状态。这对于在不丢失状态的情况下对应用深层的UI进行更改特别有用。这与实时重新加载不同，因为它保留了应用当前状态，只更新已更改的组件和状态（实时重新加载会重新加载整个应用，因此会丢失当前状态）。'
- en: '*Toggle Inspector (iOS and Android)—*Brings up a property inspector similar
    to what you see in the Chrome dev tools. You can click an element and see where
    it is in the hierarchy of components, as well as any styling applied to the element
    ([figure 3.10](#figure3.10)).'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*切换检查器（iOS 和 Android）*：弹出一个类似于你在 Chrome 开发工具中看到的属性检查器。你可以点击一个元素，并看到它在组件层次结构中的位置，以及应用到此元素上的任何样式（[图
    3.10](#figure3.10)）。'
- en: '![c03_11.tif](Images/c03_11.png)'
  id: totrans-491
  prefs: []
  type: TYPE_IMG
  zh: '![c03_11.tif](Images/c03_11.png)'
- en: '[Figure 3.10](#figureanchor3.10) Using the inspector (left: iOS, right: Android)'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3.10](#figureanchor3.10) 使用检查器（左：iOS，右：Android）'
- en: '*Show Perf Monitor (iOS and Android)—*Brings up a small box in the upper-left
    corner of the app, giving some information about the app’s performance. Here you’ll
    see the amount of RAM being used and the number of frames per second at which
    the app is currently running. If you click the box, it will expand to show even
    more information ([figure 3.11](#figure3.11)).'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*显示性能监控器（iOS 和 Android）*：在应用的左上角弹出一个小的框，显示一些关于应用性能的信息。在这里，你可以看到正在使用的 RAM 数量和应用当前运行的每秒帧数。如果你点击这个框，它将展开以显示更多信息（[图
    3.11](#figure3.11)）。'
- en: '![c03_12.tif](Images/c03_12.png)'
  id: totrans-494
  prefs: []
  type: TYPE_IMG
  zh: '![c03_12.tif](Images/c03_12.png)'
- en: '[Figure 3.11](#figureanchor3.11) Perf Monitor (left: iOS, right: Android)'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3.11](#figureanchor3.11) 性能监控器（左：iOS，右：Android）'
- en: '![c03_13.tif](Images/c03_13.png)'
  id: totrans-496
  prefs: []
  type: TYPE_IMG
  zh: '![c03_13.tif](Images/c03_13.png)'
- en: Figure 3.12 Dev Settings (Android emulator)
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 开发设置（Android 模拟器）
- en: '*Dev Settings (Android emulator only)—*Brings up additional debugging options,
    including an easy way to toggle between the `__DEV__` environment variable being
    `true` or `false` (figure 3.12).'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开发设置（仅限 Android 模拟器）*：弹出一个包含额外调试选项的窗口，包括一个轻松切换 `__DEV__` 环境变量为 `true` 或 `false`
    的方法（[图 3.12](#figure3.12)）。'
- en: 3.4 Continuing building the todo app
  id: totrans-499
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 继续构建待办事项应用
- en: Now that you know how the developer menu works, open it and press Debug JS Remotely
    to open the Chrome dev tools. You’re ready to start logging information to the
    JavaScript console.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了开发者菜单的工作方式，打开它并按 Debug JS Remotely 以打开 Chrome 开发工具。你准备好开始将信息记录到 JavaScript
    控制台了。
- en: You’ll import the `Input` component into app/App.js and attach a method to `TextInput`,
    which you’ll give as a prop to the `Input`. You’ll also pass the `inputValue`
    stored on the state to `Input` as a prop.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将 `Input` 组件导入到 `app/App.js` 中，并将一个方法附加到 `TextInput` 上，然后将这个方法作为属性传递给 `Input`。你还将把存储在状态中的
    `inputValue` 传递给 `Input` 作为属性。
- en: Listing 3.8 Creating the `inputChange` function
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.8 创建 `inputChange` 函数
- en: '[PRE82]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '`inputChange` takes one argument, the value of the `TextInput`, and updates
    the `inputValue` in the state with the returned value from the `TextInput`.'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '`inputChange` 接收一个参数，即 `TextInput` 的值，并使用 `TextInput` 返回的值更新状态中的 `inputValue`。'
- en: Now, you need to wire up the function with the `TextInput` in the `Input` component.
    Open app/Input.js, and update the `TextInput` component with the new `inputChange`
    function and the `inputValue` property.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要将函数与 `Input` 组件中的 `TextInput` 连接起来。打开 `app/Input.js`，并更新 `TextInput` 组件，使用新的
    `inputChange` 函数和 `inputValue` 属性。
- en: Listing 3.9 Adding `inputChange` and `inputValue` to the `TextInput`
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.9 将 `inputChange` 和 `inputValue` 添加到 `TextInput`
- en: '[PRE83]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: You destructure the props `inputValue` and `inputChange` in the creation of
    the stateless component. When the value of the `TextInput` changes, the `inputChange`
    function is called, and the value is passed to the parent component to set the
    state of `inputValue`. You also set the value of the `TextInput` to be `inputValue`,
    so you can later control and reset the `TextInput`. `onChangeText` is a method
    that will be called every time the value of the `TextInput` component is changed
    and will be passed the value of the `TextInput`.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建无状态组件时，你将解构 `inputValue` 和 `inputChange` 属性。当 `TextInput` 的值发生变化时，将调用 `inputChange`
    函数，并将值传递给父组件以设置 `inputValue` 的状态。你还将 `TextInput` 的值设置为 `inputValue`，这样你就可以稍后控制和重置
    `TextInput`。`onChangeText` 是一个方法，每次 `TextInput` 组件的值发生变化时都会被调用，并将 `TextInput`
    的值传递给它。
- en: Run the project again and see how it looks ([figure 3.13](#figure3.13)). You’re
    logging the value of the input, so as you type you should see the value being
    logged out to the console ([figure 3.14](#figure3.14)).
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目并查看其外观（[图 3.13](#figure3.13)）。你正在记录输入值，所以当你输入时，你应该看到值被记录到控制台（[图 3.14](#figure3.14)）。
- en: '![c03_14.tif](Images/c03_14.png)'
  id: totrans-510
  prefs: []
  type: TYPE_IMG
  zh: '![c03_14.tif](Images/c03_14.png)'
- en: '[Figure 3.13](#figureanchor3.13) Updated view after adding the `TextInput`'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3.13](#figureanchor3.13) 添加 `TextInput` 后的更新视图'
- en: '![c03_15.tif](Images/c03_15.png)'
  id: totrans-512
  prefs: []
  type: TYPE_IMG
  zh: '![c03_15.tif](Images/c03_15.png)'
- en: '[Figure 3.14](#figureanchor3.14) Logging out the `TextInput` value with the
    `inputChange` method'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3.14](#figureanchor3.14) 使用 `inputChange` 方法记录 `TextInput` 的值'
- en: Now that the value of the `inputValue` is being stored in the state, you need
    to create a button to add the items to a list of todos. Before you do, create
    a function that you’ll bind to the button to add the new todo to the array of
    todos defined in the constructor. Call this function `submitTodo`, and place it
    after the `inputChange` function and before the `render` function.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `inputValue` 的值被存储在状态中，你需要创建一个按钮来将项目添加到待办事项列表中。在这样做之前，创建一个函数，你将把它绑定到按钮上，以便将新的待办事项添加到构造函数中定义的待办事项数组中。将此函数命名为
    `submitTodo`，并将其放置在 `inputChange` 函数之后和 `render` 函数之前。
- en: Listing 3.10 Adding the `submitTodo` function
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.10 添加 `submitTodo` 函数
- en: '[PRE84]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Next, create the `todoIndex` at the top of the App.js file, below the last `import`
    statement.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 App.js 文件顶部创建 `todoIndex`，在最后一个 `import` 语句下方。
- en: Listing 3.11 Creating the `todoIndex` variable
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.11 创建 `todoIndex` 变量
- en: '[PRE85]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Now that the `submitTodo` function has been created, create a file called Button.js
    and wire up the function to work with the button.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经创建了 `submitTodo` 函数，创建一个名为 Button.js 的文件，并将该函数连接到按钮以工作。
- en: Listing 3.12 Creating the `Button` component
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.12 创建 `Button` 组件
- en: '[PRE86]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: In this component, you use `TouchableHighlight` for the first time. `TouchableHighlight`
    is one of the ways you can create buttons in React Native and is fundamentally
    comparable to the HTML `button` element.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 在此组件中，你首次使用 `TouchableHighlight`。`TouchableHighlight` 是创建 React Native 中按钮的一种方式，与
    HTML 的 `button` 元素基本相当。
- en: With `TouchableHighlight`, you can wrap views and make them respond properly
    to touch events. On press down, the default `backgroundColor` is replaced with
    a specified `underlayColor` property that you’ll provide as a prop. Here you specify
    an `underlayColor` of `'#efefef'`, which is a light gray; the background color
    is white. This will give the user a good sense of whether the touch event has
    registered. If no `underlayColor` is defined, it defaults to black.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `TouchableHighlight`，你可以包裹视图并使其正确响应触摸事件。在按下时，默认的 `backgroundColor` 被替换为你提供的指定
    `underlayColor` 属性。在这里，你指定一个 `underlayColor` 为 `'#efefef'`，这是一种浅灰色；背景颜色是白色。这将使用户对触摸事件是否已注册有一个良好的感觉。如果没有定义
    `underlayColor`，则默认为黑色。
- en: '`TouchableHighlight` supports only one main child component. Here, you pass
    in a `Text` component. If you want multiple components in a `TouchableHighlight`,
    wrap them in a single `View`, and pass this `View` as the child of the `TouchableHighlight`.'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '`TouchableHighlight` 只支持一个主要子组件。在这里，你传递一个 `Text` 组件。如果你想在 `TouchableHighlight`
    中使用多个组件，将它们包裹在一个单独的 `View` 中，并将此 `View` 作为 `TouchableHighlight` 的子组件传递。'
- en: You’ve created the `Button` component and wired it up with the function defined
    in App.js. Now bring this component into the app (app/App.js) and see if it works!
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经创建了 `Button` 组件，并将其与 App.js 中定义的函数连接起来。现在将此组件带入应用（app/App.js）并查看它是否工作！
- en: Listing 3.13 Importing the `Button` component
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.13 导入 `Button` 组件
- en: '[PRE87]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: You import the `Button` component and place it under the `Input` component in
    the `render` function. `submitTodo` is passed in to the `Button` as a property
    called `this.submitTodo`.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 你导入 `Button` 组件，并在 `render` 函数中将它放置在 `Input` 组件下方。`submitTodo` 作为名为 `this.submitTodo`
    的属性传递给 `Button`。
- en: Now, refresh the app. It should look like [figure 3.15](#figure3.15). When you
    add a todo, the `TextInput` should clear, and the app state should log to the
    console, showing an array of todos with the new todo in the array ([figure 3.16](#figure3.16)).
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，刷新应用。它应该看起来像 [图 3.15](#figure3.15)。当你添加待办事项时，`TextInput` 应该清除，并且应用状态应该记录到控制台，显示包含新待办事项的待办事项数组
    ([图 3.16](#figure3.16))。
- en: '![c03_16.tif](Images/c03_16.png)'
  id: totrans-531
  prefs: []
  type: TYPE_IMG
  zh: '![c03_16.tif](Images/c03_16.png)'
- en: '[Figure 3.15](#figureanchor3.15) Updated app with the `Button` component'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3.15](#figureanchor3.15) 带有 `Button` 组件的更新应用'
- en: '![c03_17.tif](Images/c03_17.png)'
  id: totrans-533
  prefs: []
  type: TYPE_IMG
  zh: '![c03_17.tif](Images/c03_17.png)'
- en: '[Figure 3.16](#figureanchor3.16) Logging the state'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3.16](#figureanchor3.16) 记录状态'
- en: 'Now that you’re adding todos to the array of todos, you need to render them
    to the screen. To get started with this, you need to create two new components:
    `TodoList` and `Todo`. `TodoList` will render the list of `Todos` and will use
    the `Todo` component for each individual todo. Begin by creating a file named
    Todo.js in the app folder.'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你正在向待办事项数组中添加待办事项，你需要将它们渲染到屏幕上。要开始这个操作，你需要创建两个新的组件：`TodoList` 和 `Todo`。`TodoList`
    将渲染待办事项列表，并使用 `Todo` 组件为每个单独的待办事项。首先，在应用文件夹中创建一个名为 Todo.js 的文件。
- en: Listing 3.14 Creating the `Todo` component
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.14 创建 `Todo` 组件
- en: '[PRE88]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The `Todo` component takes one property for now—a todo—and renders the title
    in a `Text` component. You also add styling to the `View` and `Text` components.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 目前 `Todo` 组件只接受一个属性——一个待办事项，并在 `Text` 组件中渲染标题。你还在 `View` 和 `Text` 组件上添加了样式。
- en: Next, create the `TodoList` component (app/TodoList.js).
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建 `TodoList` 组件（app/TodoList.js）。
- en: Listing 3.15 Creating the `TodoList` component
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.15 创建 `TodoList` 组件
- en: '[PRE89]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The `TodoList` component takes one property for now: an array of todos. You
    then map over these todos and create a new `Todo` component (imported at the top
    of the file) for each todo, passing in the todo as a property to the `Todo` component.
    You also specify a key and pass in the index of the todo item as a key to each
    component. The `key` property helps React identify the items that have changed
    when the diff with the virtual DOM is computed. React will give you a warning
    if you leave this out.'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 目前 `TodoList` 组件只接受一个属性：一个待办事项数组。然后你遍历这些待办事项，并为每个待办事项创建一个新的 `Todo` 组件（在文件顶部导入），将待办事项作为属性传递给
    `Todo` 组件。你还指定了一个键，并将待办事项项的索引作为键传递给每个组件。`key` 属性帮助 React 在计算与虚拟 DOM 的差异时识别已更改的项目。如果你省略了这一点，React
    将会给出警告。
- en: The last thing you need to do is import the `TodoList` component into the App.js
    file and pass in the todos as a property.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的最后一件事是将 `TodoList` 组件导入到 App.js 文件中，并将待办事项作为属性传入。
- en: Listing 3.16 Importing the `TodoList` component
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.16 导入 `TodoList` 组件
- en: '[PRE90]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Run the app. When you add a todo, you should see it pop up in the list of todos
    ([figure 3.17](#figure3.17)).
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用。当你添加一个待办事项时，你应该看到它在待办事项列表中弹出（[图 3.17](#figure3.17)）。
- en: The next steps are to mark a todo as complete, and to delete a todo. Open App.js,
    and create `toggleComplete` and `deleteTodo` functions below the `submitTodo`
    function. `toggleComplete` will toggle whether the todo is complete, and `deleteTodo`
    will delete the todo.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是标记待办事项为完成，以及删除待办事项。打开 App.js，并在 `submitTodo` 函数下方创建 `toggleComplete` 和 `deleteTodo`
    函数。`toggleComplete` 将切换待办事项是否完成，而 `deleteTodo` 将删除待办事项。
- en: '![c03_18.tif](Images/c03_18.png)'
  id: totrans-548
  prefs: []
  type: TYPE_IMG
  zh: '![c03_18.tif](Images/c03_18.png)'
- en: '[Figure 3.17](#figureanchor3.17) Updated app with the `TodoList` component'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3.17](#figureanchor3.17) 更新后的应用，包含 `TodoList` 组件'
- en: Listing 3.17 Adding `toggleComplete` and `deleteTodo` functions
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.17 添加 `toggleComplete` 和 `deleteTodo` 函数
- en: '[PRE91]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: To hook in these functions, you need to create a button component to pass in
    to the todo. In the app folder, create a new file called TodoButton.js.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 为了连接这些函数，你需要创建一个按钮组件并将其传递给待办事项。在 app 文件夹中，创建一个新的文件，命名为 TodoButton.js。
- en: Listing 3.18 Creating TodoButton.js
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.18 创建 TodoButton.js
- en: '[PRE92]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Now, pass the new functions as props to the `TodoList` component.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将新的函数作为 props 传递给 `TodoList` 组件。
- en: Listing 3.19 Passing `toggleComplete` and `deleteTodo` as props to `TodoList`
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.19 将 `toggleComplete` 和 `deleteTodo` 作为 props 传递给 `TodoList`
- en: '[PRE93]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Next, pass `toggleComplete` and `deleteTodo` as props to the `Todo` component.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将 `toggleComplete` 和 `deleteTodo` 作为 props 传递给 `Todo` 组件。
- en: Listing 3.20 Passing `toggleComplete` and `deleteTodo` as props to `ToDo`
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.20 将 `toggleComplete` 和 `deleteTodo` 作为 props 传递给 `ToDo`
- en: '[PRE94]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Finally, open Todo.js and update the `Todo` component to bring in the new `TodoButton`
    component and some styling for the button container.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，打开 Todo.js 并更新 `Todo` 组件，以引入新的 `TodoButton` 组件和按钮容器的样式。
- en: Listing 3.21 Updating Todo.js to bring in `TodoButton` and functionality
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.21 更新 Todo.js 以引入 `TodoButton` 和功能
- en: '[PRE95]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'You add two `TodoButton`s: one named Done, and one named Delete. You also pass
    `toggleComplete` and `deleteTodo` as functions to be called as the `onPress` you
    defined in TodoButton.js. If you refresh the app and add a todo, you should now
    see the new buttons ([figure 3.18](#figure3.18)).'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 你添加了两个 `TodoButton` 按钮：一个命名为完成，另一个命名为删除。你还传递了 `toggleComplete` 和 `deleteTodo`
    作为函数，以便在 TodoButton.js 中调用你定义的 `onPress`。如果你刷新应用并添加一个待办事项，你现在应该能看到新的按钮（[图 3.18](#figure3.18)）。
- en: '![c03_19.tif](Images/c03_19.png)'
  id: totrans-565
  prefs: []
  type: TYPE_IMG
  zh: '![c03_19.tif](Images/c03_19.png)'
- en: '[Figure 3.18](#figureanchor3.18) App with `TodoButton`s displayed'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3.18](#figureanchor3.18) 显示 `TodoButton`s 的应用'
- en: If you click Done, the button text should be bold and green. If you click Delete,
    the todo should disappear from the list of todos.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击完成，按钮文本应该加粗并变为绿色。如果你点击删除，待办事项应该从待办事项列表中消失。
- en: You’re now almost done with the app. The final step is to build a tab bar filter
    that will show either all the todos, only the complete todos, or only the incomplete
    todos. To get this started, you’ll create a new function that will set the type
    of todos to show.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在几乎完成了应用。最后一步是构建一个标签栏过滤器，它将显示所有待办事项、仅显示完成的待办事项或仅显示未完成的待办事项。为了开始这个，你需要创建一个新的函数来设置要显示的待办事项类型。
- en: In the constructor, you set a state `type` variable to `'All'` when you first
    created the app. You’ll now create a function named `setType` that will take a
    type as an argument and update the type in the state. Place this function below
    the `toggleComplete` function in App.js.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，当你第一次创建应用时，你将状态变量 `type` 设置为 `'All'`。现在你将创建一个名为 `setType` 的函数，它将接受一个类型作为参数并更新状态中的类型。在
    App.js 中 `toggleComplete` 函数下方放置此函数。
- en: Listing 3.22 Adding the `setType` function
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.22 添加 `setType` 函数
- en: '[PRE96]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Next, you need to create the `TabBar` and `TabBarItem` components. First, create
    the `TabBar` component: add a file in the app folder named TabBar.js.'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要创建 `TabBar` 和 `TabBarItem` 组件。首先，创建 `TabBar` 组件：在 app 文件夹中添加一个名为 TabBar.js
    的文件。
- en: Listing 3.23 Creating the `TabBar` component
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.23 创建 `TabBar` 组件
- en: '[PRE97]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'This component takes two props: `setType` and `type`. Both are passed down
    from the main `App` component.'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件接受两个属性：`setType` 和 `type`。这两个属性都是从主 `App` 组件传递下来的。
- en: 'You’re importing the yet-to-be-defined `TabBarItem` component. Each `TabBarItem`
    component takes three props: `title`, `type`, and `setType`. Two of the components
    also take a `border` prop (Boolean), which if set will add a left border style.'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在导入尚未定义的 `TabBarItem` 组件。每个 `TabBarItem` 组件接受三个属性：`title`、`type` 和 `setType`。其中两个组件还接受一个
    `border` 属性（布尔值），如果设置为 `true`，将添加左边界样式。
- en: Next, create a file in the app folder named TabBarItem.js.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 app 文件夹中创建一个名为 TabBarItem.js 的文件。
- en: Listing 3.24 Creating the `TabBarItem` component
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.24 创建 `TabBarItem` 组件
- en: '[PRE98]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: In the `TouchableHighlight` component, you check a few props and set styles
    based on the prop. If `selected` is `true`, you give it the style `styles.selected`.
    If `border` is `true`, you give it the style `styles.border`. If `type` is equal
    to the `title`, you give it `styles.selected`.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `TouchableHighlight` 组件中，你检查一些属性并根据属性设置样式。如果 `selected` 是 `true`，你给它 `styles.selected`
    的样式。如果 `border` 是 `true`，你给它 `styles.border` 的样式。如果 `type` 等于 `title`，你给它 `styles.selected`
    的样式。
- en: In the `Text` component, you also check to see whether `type` is equal to `title`.
    If so, add a bold style to it.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Text` 组件中，你也会检查 `type` 是否等于 `title`。如果是，给它添加粗体样式。
- en: To implement the `TabBar`, open app/App.js, bring in the `TabBar` component,
    and set it up. You’ll also bring in `type` to the `render` function as part of
    destructuring `this.state`.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现 `TabBar`，打开 app/App.js，引入 `TabBar` 组件，并设置它。你还将 `type` 作为 `render` 函数的一部分，在解构
    `this.state` 时引入。
- en: Listing 3.25 Implementing the `TabBar` component
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.25 实现 `TabBar` 组件
- en: '[PRE99]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Here, you bring in the `TabBar` component. You then destructure `type` from
    the state and *pass it not only to the new* `TabBar` *component, but also to the*
    `TodoList` *component*; you’ll use this `type` variable in just a second when
    filtering the todos based on this type. You also pass the `setType` function as
    a prop to the `TabBar` component.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你引入了 `TabBar` 组件。然后从状态中解构 `type` 并不仅将其传递给新的 `TabBar` 组件，还传递给 `TodoList`
    组件；你将在下一秒使用这个 `type` 变量来根据此类型过滤待办事项。你还把 `setType` 函数作为属性传递给 `TabBar` 组件。
- en: The last thing you need to do is open the `TodoList` component and add a filter
    to return only the todos of the type you currently want back, based on the tab
    that’s selected. Open TodoList.js, destructure the type out of the props, and
    add the following `getVisibleTodos` function before the `return` statement.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的最后一件事是打开 `TodoList` 组件，并添加一个过滤器，只返回当前选定的标签页类型的待办事项。打开 TodoList.js，从属性中解构
    `type`，在 `return` 语句之前添加以下 `getVisibleTodos` 函数。
- en: Listing 3.26 Updating the `TodoList` component
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.26 更新 `TodoList` 组件
- en: '[PRE100]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: You use a `switch` statement to check which type is currently set. If `'All'`
    is set, you return the entire list of todos. If `'Complete'` is set, you filter
    the todos and only return the complete todos. If `'Active'` is set, you filter
    the todos and only return the incomplete todos.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用 `switch` 语句检查当前设置的是哪种类型。如果设置为 `'All'`，则返回待办事项的整个列表。如果设置为 `'Complete'`，则过滤待办事项并只返回完成的待办事项。如果设置为
    `'Active'`，则过滤待办事项并只返回未完成的待办事项。
- en: You then set the `todos` variable as the returned value of `getVisibleTodos`.
    Now you should be able to run the app and see the new `TabBar` ([figure 3.19](#figure3.19)).
    The `TabBar` will filter based on which type is selected.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将 `todos` 变量设置为 `getVisibleTodos` 返回的值。现在你应该能够运行应用并看到新的 `TabBar` ([图 3.19](#figure3.19))。`TabBar`
    将根据选定的类型进行过滤。
- en: '![c03_20.tif](Images/c03_20.png)'
  id: totrans-591
  prefs: []
  type: TYPE_IMG
  zh: '![c03_20.tif](Images/c03_20.png)'
- en: '[Figure 3.19](#figureanchor3.19) Final todo app'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3.19](#figureanchor3.19) 最终待办事项应用'
- en: Summary
  id: totrans-593
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: '`AppRegistry` is the JavaScript entry point to running all React Native apps.'
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppRegistry` 是运行所有 React Native 应用的 JavaScript 入口点。'
- en: The React Native component `TextInput` is similar to an HTML `input`. You can
    specify several props, including a `placeholder` to show text before the user
    starts to type, a `placeholderTextColor` that styles the placeholder text, and
    a `selectionColor` that styles the cursor for the `TextInput`.
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Native 组件 `TextInput` 与 HTML 的 `input` 类似。你可以指定多个属性，包括一个 `placeholder`
    属性，用于在用户开始输入之前显示文本，一个 `placeholderTextColor` 属性，用于设置占位符文本的样式，以及一个 `selectionColor`
    属性，用于设置 `TextInput` 的光标样式。
- en: '`TouchableHighlight` is one way to create buttons in React Native; it’s comparable
    to the HTML `button` element. You can use `TouchableHighlight` to wrap views and
    make them respond properly to touch events.'
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TouchableHighlight` 是在 React Native 中创建按钮的一种方式；它与 HTML 的 `button` 元素相当。你可以使用
    `TouchableHighlight` 来包裹视图，并使其正确响应触摸事件。'
- en: You learned how to enable the developer tools in both iOS and Android emulators.
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你已经学会了如何在 iOS 和 Android 模拟器中启用开发者工具。
- en: Using the JavaScript console (available from the developer menu) is a good way
    to debug your app and log useful information.
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JavaScript 控制台（可通过开发者菜单访问）是调试你的应用并记录有用信息的好方法。
