- en: 12 Using preprocessors
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 使用预处理器
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: CSS preprocessors
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS预处理器
- en: Examples of how Sass extends CSS functionality
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sass扩展CSS功能的示例
- en: So far in this book, we’ve been writing all our styles using plain CSS. We can
    also use preprocessors, however. Each processor has its own syntax, and most preprocessors
    extend the existing CSS functionality. The most commonly used are
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，我们一直使用纯CSS编写所有样式。然而，我们也可以使用预处理器。每个处理器都有自己的语法，并且大多数预处理器扩展了现有的CSS功能。最常用的有
- en: Sass ([https://sass-lang.com](https://sass-lang.com))
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sass ([https://sass-lang.com](https://sass-lang.com))
- en: Less ([https://lesscss.org](https://lesscss.org))
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Less ([https://lesscss.org](https://lesscss.org))
- en: Stylus ([https://stylus-lang.com](https://stylus-lang.com))
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Stylus ([https://stylus-lang.com](https://stylus-lang.com))
- en: They were created to facilitate writing code that’s easier to read and maintain
    as well as to add functionality that’s not available in CSS. Styles written for
    use with preprocessors have their own syntax and must be built or compiled into
    CSS. Although some preprocessors provide browser-side compilation, the most common
    implementation is to preprocess the styles and serve the output CSS to the browser
    ([http://mng.bz/Wzex](http://mng.bz/Wzex)).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 它们被创建来简化代码的编写，使其更易于阅读和维护，以及添加CSS中不可用的功能。为与预处理器一起使用而编写的样式有自己的语法，并且必须构建或编译成CSS。尽管一些预处理器提供浏览器端编译，但最常见的方法是将样式预处理器，并将输出CSS发送到浏览器（[http://mng.bz/Wzex](http://mng.bz/Wzex)）。
- en: The benefit of using a preprocessor is the added functionality it provides,
    examples of which we cover in this chapter. The drawback is that now we need a
    build step for our code. The choice of preprocessor is based on what functionality
    is needed for the project, the team’s knowledge, and (if the project uses a framework)
    which frameworks are supported. For our project, we’re going to choose based on
    popularity. When developers were surveyed about their sentiments regarding CSS
    preprocessors, the majority favored Sass (figure 12.1), so that’s what we’re going
    to use.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用预处理器的优点是它提供的附加功能，我们将在本章中介绍这些功能的示例。缺点是现在我们需要为我们的代码添加一个构建步骤。预处理器的选择基于项目所需的功能、团队的知识，以及（如果项目使用框架）哪些框架受到支持。对于我们的项目，我们将根据流行度来选择。当开发者被调查关于他们对CSS预处理器情感时，大多数倾向于Sass（图12.1），因此我们将使用它。
- en: '![](../Images/12-01.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/12-01.png)'
- en: Figure 12.1 Preprocessor sentiment (data source [http://mng.bz/8ry2](http://mng.bz/8ry2))
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 预处理器情感（数据来源 [http://mng.bz/8ry2](http://mng.bz/8ry2)）
- en: 12.1 Running the preprocessor
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1 运行预处理器
- en: Our project consists of styling a how-to article—something we might see in a
    wiki or documentation (figure 12.2).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目包括为如何文章添加样式——我们可能在维基或文档中看到（图12.2）。
- en: '![](../Images/12-02.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/12-02.png)'
- en: Figure 12.2 Finished project
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 完成的项目
- en: 'As in earlier chapters, the starting code is available at GitHub ([http://mng.bz/EQnl](http://mng.bz/EQnl))
    and CodePen ([https://codepen.io/michaelgearon/pen/WNpNoGN](https://codepen.io/michaelgearon/pen/WNpNoGN)).
    But running the project is going to be a little bit different. Because we’re going
    to write our styles with Sass, which outputs the CSS rather than writing it directly,
    we’ll need a build step. To run this project and code along with this chapter,
    you have two options:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，起始代码可在GitHub（[http://mng.bz/EQnl](http://mng.bz/EQnl)）和CodePen（[https://codepen.io/michaelgearon/pen/WNpNoGN](https://codepen.io/michaelgearon/pen/WNpNoGN)）上找到。但运行项目会有所不同。因为我们将使用Sass编写样式，它输出CSS而不是直接编写，我们需要一个构建步骤。要运行此项目并跟随本章的代码，你有两种选择：
- en: npm
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: npm
- en: CodePen
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CodePen
- en: Note *npm* (Node.js package manager) is a software library, manager, and installer.
    If you aren’t familiar with npm, that’s OK. You can run this project in CodePen,
    following the instructions in section 12.1.3.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 *npm*（Node.js包管理器）是一个软件库、管理器和安装程序。如果你不熟悉npm，那没关系。你可以按照第12.1.3节中的说明在CodePen中运行此项目。
- en: 12.1.1 Setup instructions for npm
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.1 npm的设置说明
- en: Via the command line from the `chapter-12` directory, install the dependencies
    using `npm` `install;` then start the processor using `npm` `start`. This command
    starts a watcher that will monitor changes in `styles.scss` (in the `before` and
    `after` directories) and output the `styles.css` and `styles.map.css` files.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从`chapter-12`目录的命令行中，使用`npm` `install;`安装依赖项，然后使用`npm` `start`启动处理器。此命令启动一个监视器，将监视`styles.scss`（在`before`和`after`目录中）的变化，并输出`styles.css`和`styles.map.css`文件。
- en: The second file—`styles.map.css`—is a source map. Because the CSS was generated
    from another language, the source map allows the browser’s developer tools to
    tell us where the piece of code originated in the preprocessed file (for this
    project, `styles.scss`).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个文件——`styles.map.css`——是一个源映射文件。由于CSS是从另一种语言生成的，源映射允许浏览器开发者工具告诉我们代码片段在预处理器文件（对于本项目，`styles.scss`）中的来源位置。
- en: 12.1.2 .sass versus .scss
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.2 .sass与.scss的区别
- en: Although we’re using Sass, our file extension is `.scss`. Sass has two syntaxes
    we can choose—indented and SCSS—and the file extension reflects the syntax.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们使用Sass，但我们的文件扩展名是`.scss`。Sass有两种语法我们可以选择——缩进和SCSS——文件扩展名反映了语法。
- en: Indented syntax
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 缩进语法
- en: Sometimes referred to as *Sass syntax,* *indented syntax* uses the `.sass` file
    extension. When writing rulesets using this syntax, we omit curly braces and semicolons,
    using tabs to describe the format of the document. The following listing shows
    two rules using indented syntax, the first handling margin and padding on the
    body text and the second changing the line height of the paragraphs.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有时被称为*Sass语法*或*缩进语法*，使用`.sass`文件扩展名。当使用这种语法编写规则集时，我们省略大括号和分号，使用制表符来描述文档的格式。以下列表显示了使用缩进语法的两个规则，第一个处理正文上的边距和填充，第二个更改段落的行高。
- en: Listing 12.1 Sass using indented syntax
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.1 使用缩进语法的Sass
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: SCSS syntax
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: SCSS语法
- en: The second syntax is SCSS, which uses the file extension `.scss`. We’ll use
    that syntax in this project. *SCSS syntax* is a superset of CSS that allows us
    to use any valid CSS in addition to Sass features. The following listing shows
    the rules from listing 12.1 in SCSS syntax.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种语法是SCSS，它使用文件扩展名`.scss`。我们将在这个项目中使用这种语法。*SCSS语法*是CSS的超集，它允许我们使用任何有效的CSS，以及Sass的功能。以下列表显示了列表12.1中的规则在SCSS语法中的表示。
- en: Listing 12.2 Sass using SCSS syntax
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.2 使用SCSS语法的Sass
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code looks like CSS, which is exactly the point. In SCSS, we can write CSS
    the way we’re used to writing it and have access to all the functionality Sass
    provides as well. Because of its similarity to CSS, and because it doesn’t require
    developers to learn a new syntax, SCSS is the more popular of the two syntax options.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来像CSS，这正是重点。在SCSS中，我们可以像习惯那样编写CSS，并且可以访问Sass提供的所有功能。由于其与CSS的相似性，并且它不需要开发者学习新的语法，SCSS是两种语法选项中更受欢迎的一个。
- en: 12.1.3 Setup instructions for CodePen
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.3 CodePen设置说明
- en: 'To set up the project for CodePen, follow these steps:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要为CodePen设置项目，请按照以下步骤操作：
- en: Go to [https://codepen.io](https://codepen.io).
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往[https://codepen.io](https://codepen.io)。
- en: In a new pen, using the code in the `chapter-12/before` folder, copy the HTML
    inside the `body` element to the HTML panel.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的笔中，使用`chapter-12/before`文件夹中的代码，将`body`元素内的HTML复制到HTML面板中。
- en: Copy the starting styles in the `.scss` file to the CSS panel.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`.scss`文件中的基本样式复制到CSS面板中。
- en: To make the panel use Sass with SCSS syntax instead of CSS, click the gear in
    the top-right corner of the CSS panel (figure 12.3).
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使面板使用Sass的SCSS语法而不是CSS，请点击CSS面板右上角的齿轮（图12.3）。
- en: '![](../Images/12-03.png)'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](../Images/12-03.png)'
- en: Figure 12.3 Settings button
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.3 设置按钮
- en: Choose SCSS from the CSS Preprocessor drop-down menu (figure 12.4).
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从CSS预处理器下拉菜单中选择SCSS（图12.4）。
- en: '![](../Images/12-04.png)'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](../Images/12-04.png)'
- en: Figure 12.4 CodePen CSS preprocessor settings
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.4 CodePen CSS预处理器设置
- en: Click the green Save & Close button at the bottom of the Pen Settings dialog
    box.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击Pen设置对话框底部的绿色“保存并关闭”按钮。
- en: 12.1.4 Starting HTML and SCSS
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.4 开始HTML和SCSS
- en: Our project is composed of headers, paragraphs, links, and images (listing 12.3).
    Notice that in our head, we reference the CSS stylesheet, not the SCSS. The browser
    uses the compiled version.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目由标题、段落、链接和图片组成（列表12.3）。注意，在我们的`head`中，我们引用的是CSS样式表，而不是SCSS。浏览器使用编译版本。
- en: Listing 12.3 Starting HTML
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.3 开始HTML
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ① Links to the processed CSS file
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ① 链接到处理后的CSS文件
- en: ② Green success callout
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ② 绿色成功提示
- en: ③ Orange warning callout
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 橙色警告提示
- en: ④ Red error callout
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 红色错误提示
- en: Our starting styles set up our typography and constrain the content’s width
    when the page gets wide, as shown in the following listing.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基本样式设置了我们的排版，并在页面变宽时限制了内容的宽度，如下列所示。
- en: Listing 12.4 Starting SCSS
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.4 开始SCSS
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So far, we’re not using any of the extended functionality that Sass provides.
    As a matter of fact, if we look at the CSS output (listing 12.5), we notice that
    the file contents are the same except for the map reference at the bottom of the
    file. This comment tells the browser where to find the source map. Figure 12.5
    shows our starting point.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有使用 Sass 提供的任何扩展功能。事实上，如果我们查看 CSS 输出（列表 12.5），我们会注意到文件内容除了文件底部的映射参考之外都是相同的。这个注释告诉浏览器在哪里找到源映射。图
    12.5 显示了我们的起始点。
- en: '![](../Images/12-05.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/12-05.png)'
- en: Figure 12.5 Starting point
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.5 起始点
- en: Note If you’re using CodePen, you can view the compiled CSS by clicking the
    down arrow next to the gear in the top-right corner of the CSS panel (refer to
    figure 12.3) and choosing View Compiled CSS from the drop-down menu.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果您正在使用 CodePen，您可以通过点击 CSS 面板右上角的齿轮旁边的向下箭头（参见图 12.3）并从下拉菜单中选择“查看编译后的 CSS”来查看编译后的
    CSS。
- en: Listing 12.5 Starting CSS output
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.5 开始的 CSS 输出
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ① Source map reference
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ① 源映射参考
- en: Note If you aren’t seeing the CSS file being created and styles being applied,
    make sure that you’re running the Sass watcher (`npm` `start`). When the watcher
    starts, let it run in the background; it updates the CSS file automatically when
    you save your changes in the SCSS file. You’ll still need to refresh the browser
    manually.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果您没有看到 CSS 文件被创建并且样式被应用，请确保您正在运行 Sass 监视器（`npm start`）。当监视器启动时，让它后台运行；当您在
    SCSS 文件中保存更改时，它会自动更新 CSS 文件。您仍然需要手动刷新浏览器。
- en: 12.2 Sass variables
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2 Sass 变量
- en: One reason why preprocessors became popular early on is that they had variables
    before browsers supported custom properties. Sass variables are quite distinct
    from CSS custom properties in that they have different syntax and function differently.
    Let’s first look at the syntax. To create a variable, we start with a dollar sign
    (`$`) followed by the variable name, a colon (`:`), and then a value (figure 12.6).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理器早期之所以受欢迎，一个原因就是它们在浏览器支持自定义属性之前就有变量。Sass 变量与 CSS 自定义属性非常不同，因为它们有不同的语法并且功能不同。让我们首先看看语法。要创建一个变量，我们从美元符号（`$`）开始，后面跟着变量名，一个冒号（`:`），然后是一个值（图
    12.6）。
- en: '![](../Images/12-06.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/12-06.png)'
- en: Figure 12.6 Sass variable syntax
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6 Sass 变量语法
- en: 'In terms of functionality, Sass variables aren’t aware of the Document Object
    Model (DOM) and don’t understand cascading or inheritance. They’re block-scoped:
    only properties within the curly braces they’re defined in know about their existence.
    Therefore, the scenario presented in the following listing would throw an undefined
    variable error at compile time because the variable is defined and used in two
    different rules or blocks.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在功能方面，Sass 变量不了解文档对象模型（DOM），也不理解层叠或继承。它们是块作用域的：只有它们定义的括号内的属性知道它们的存在。因此，以下列表中提出的场景会在编译时抛出一个未定义变量错误，因为变量在两个不同的规则或块中定义和使用了。
- en: Listing 12.6 `$myColor` variable undefined in second rule
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.6 `$myColor` 变量在第二个规则中未定义
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ① Defines the $myColor variable inside the body rule
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ① 在 body 规则内部定义 `$myColor` 变量
- en: ② $myColor is undefined because it was created inside a different rule.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ② `$myColor` 未定义，因为它是在不同的规则中创建的。
- en: To prevent this problem, we can place our variables outside a rule, which would
    make them available to the entire document, as shown in the following listing.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这个问题，我们可以将变量放在规则之外，这样它们就可以在整个文档中可用，如以下列表所示。
- en: Listing 12.7 Defining variables
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.7 定义变量
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ① Defines the $myColor variable outside any ruleset
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ① 在任何规则集外部定义 `$myColor` 变量
- en: ② $myColor is now defined and has a value of blue.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ② `$myColor` 现已定义，其值为蓝色。
- en: Unlike custom properties, which are dynamic, Sass variables are static. If we
    define a variable, use it, change its value, and then use it again, any property
    it was assigned to before the change will retain the original value, and those
    assigned after the change will have the new value. The examples shown in listings
    12.8 and 12.9 make this situation a bit clearer. Note that the examples aren’t
    part of our project; we present them here only to illustrate the concept. You
    can find the code on CodePen at [https://codepen.io/martine-dowden/pen/QWxLjWy](https://codepen.io/martine-dowden/pen/QWxLjWy).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与动态的自定义属性不同，Sass变量是静态的。如果我们定义了一个变量，使用它，更改其值，然后再使用它，那么在更改之前分配给它的任何属性都将保留原始值，而更改之后分配的将具有新值。列表12.8和12.9中显示的示例使这种情况更加清晰。请注意，这些示例不是我们项目的一部分；我们在这里展示它们只是为了说明概念。您可以在CodePen上找到代码：[https://codepen.io/martine-dowden/pen/QWxLjWy](https://codepen.io/martine-dowden/pen/QWxLjWy)。
- en: Listing 12.8 Custom properties versus variables (HTML)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.8 自定义属性与变量（HTML）
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Listing 12.9 Custom properties versus variables (SCSS)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.9 自定义属性与变量（SCSS）
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ① Assigns the --myBorder custom property a solid gray border
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将 `--myBorder` 自定义属性分配为实线灰色边框
- en: ② Assigns the color red to our $primary variable
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将红色分配给我们的 `$primary` 变量
- en: ③ Applies the --myBorder custom property and $primary variable to the color
    and border properties
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将 `--myBorder` 自定义属性和 `$primary` 变量应用于颜色和边框属性
- en: ④ Changes the --myBorder custom property value to a dashed purple border
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 将 `--myBorder` 自定义属性值更改为虚线紫色边框
- en: ⑤ Changes the $primary value to the color blue
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 将 `$primary` 值更改为蓝色
- en: ⑥ Applies the --myBorder and $primary to the second paragraph
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 将 `--myBorder` 和 `$primary` 应用于第二段
- en: The first big difference between the custom properties and the variables is
    that we aren’t required to have our variables inside a rule. Also, the border
    styles of both paragraphs are the same, but the color of the text is not (figure
    12.7), even though both the custom property and the variable were reassigned between
    the first and second rule.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义属性和变量之间的第一个重大区别是我们不需要在规则内部定义我们的变量。此外，两个段落的边框样式是相同的，但文本的颜色却不是（图12.7），尽管自定义属性和变量在第一和第二规则之间都被重新分配了。
- en: '![](../Images/12-07.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/12-07.png)'
- en: Figure 12.7 Example output
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7 示例输出
- en: When we reassign the value of the custom property (the border), it’s applied
    everywhere, whereas the color doesn’t change retroactively; only the rule after
    the change is affected. The reason is that custom properties are dynamic and variables
    are static.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们重新分配自定义属性（边框）的值时，它将应用于所有地方，而颜色不会回溯性改变；只有更改后的规则受到影响。原因是自定义属性是动态的，而变量是静态的。
- en: With this understanding, let’s get back to our project and define some variables
    for the colors we’ll use. At the top of the file, we’ll define four color variables.
    Then we’ll apply the primary color to all our headers, as shown in the following
    listing.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种理解，让我们回到我们的项目，并为我们将使用的颜色定义一些变量。在文件顶部，我们将定义四个颜色变量。然后我们将应用主颜色到所有标题，如下列所示。
- en: Listing 12.10 Color variables (SCSS)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.10 颜色变量（SCSS）
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ① Blue
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ① 蓝色
- en: ② Green
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ② 绿色
- en: ③ Orange
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 橙色
- en: ④ Red
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 红色
- en: ⑤ Makes our headers blue
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 使我们的标题变为蓝色
- en: We place our variables at the beginning of our file and outside any rule, so
    that from that point on and inside any rule, we can have access to them. We notice
    in our CSS output (listing 12.11) that our variables aren’t visible in the compiled
    CSS. But in the rule defining our header color, the place where we used one of
    our variables has been replaced by its value.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将变量放置在文件的开头，并放在任何规则之外，这样从那时起，我们就可以在任何规则内部访问它们。我们在CSS输出（列表12.11）中注意到我们的变量在编译后的CSS中是不可见的。但在定义我们的标题颜色的规则中，我们使用变量所在的位置已被其值所替换。
- en: Listing 12.11 Heading-color CSS output
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.11 标题颜色CSS输出
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now our project headers look like figure 12.8\. Let’s style our images next.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的项目标题看起来像图12.8。接下来让我们为我们的图片添加样式。
- en: '![](../Images/12-08.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/12-08.png)'
- en: Figure 12.8 Updated header color
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8 更新后的标题颜色
- en: 12.2.1 @extend
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.1 @extend
- en: 'Sass gives us several new at-rules, two of which are `@extend` and `@include`.
    These rules allow us to build generic classes that we can reuse throughout our
    code. One way we can reuse classes in CSS is to have multiple selectors for a
    single rule, as we did when we styled our headers. Instead of creating two identical
    rules for each header (`<h1>` and `<h2>`), we created one rule and gave it two
    selectors: `h1,` `h2` `{` `}`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Sass 给我们带来了几个新的 at-rules，其中两个是 `@extend` 和 `@include`。这些规则允许我们构建通用的类，我们可以在整个代码中重用它们。在
    CSS 中重用类的一种方法是为单个规则创建多个选择器，就像我们在设置标题样式时做的那样。我们不是为每个标题（`<h1>` 和 `<h2>`）创建两个相同的规则，而是创建了一个规则，并给它两个选择器：`h1,`
    `h2` `{` `}`。
- en: '`@extend` allows us to create a base rule that we can point to from a different
    rule later. Then the selector will be added to the base rule’s list of selectors.
    Let’s use this technique to style our images and see it at work.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`@extend` 允许我们创建一个基础规则，稍后可以从不同的规则中指向它。然后选择器将被添加到基础规则的选择器列表中。让我们使用这项技术来设置我们的图片样式，并看看它是如何工作的。'
- en: First, we create the base rule that will define the `height`, `width`, `object-fit`,
    and `margin` for our image. Because we have three images, and because we want
    to give each image a slightly different border radius and positioning, we point
    each image individually back to our `base-image` rule. The following listing shows
    how.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个基础规则，它将定义图片的 `height`、`width`、`object-fit` 和 `margin`。因为我们有三个图片，而且我们希望给每个图片一个稍微不同的边框半径和定位，所以我们分别将每个图片指向我们的
    `base-image` 规则。下面的列表显示了如何操作。
- en: Listing 12.12 Extending image styles (SCSS)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.12 扩展图片样式（SCSS）
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ① Base rule
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ① 基础规则
- en: ② Images extending the base rule
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ② 扩展基础规则的图片
- en: The following listing shows the CSS output.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了 CSS 输出。
- en: Listing 12.13 Extending image styles (CSS output)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.13 扩展图片样式（CSS 输出）
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: By creating a base rule and then using `@extend`, we can create some defaults
    and apply them to any other selector without duplicating our CSS code. We can
    also keep all our code related to a selector in one rule. With our default image
    styles applied (figure 12.9), let’s customize them individually.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建基础规则然后使用 `@extend`，我们可以创建一些默认值并将它们应用到任何其他选择器，而无需重复我们的 CSS 代码。我们还可以将所有与选择器相关的代码放在一个规则中。在我们的默认图片样式应用后（图
    12.9），让我们分别自定义它们。
- en: '![](../Images/12-09.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片 12-09](../Images/12-09.png)'
- en: Figure 12.9 Base image styles
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.9 基础图片样式
- en: 12.3 @mixin and @include
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.3 @mixin 和 @include
- en: We want to customize each image’s `border-radius`, `position`, and `object-position`.
    To do this, we’re going to use a mixin. *Mixins* allow us to generate declarations
    and rules. Like functions, they take parameters (although they’re not mandatory)
    and return styles. Let’s write one that will return our three declarations for
    each image. A mixin is an at-rule, so it starts with `@mixin` followed by the
    name we want to give it. Next, we add parentheses with any parameters we want
    to pass in. Finally, we add a set of curly braces, inside which we define the
    styles we want the mixin to return. Figure 12.10 shows the syntax.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想自定义每个图片的 `border-radius`、`position` 和 `object-position`。为此，我们将使用一个 mixin。*Mixins*
    允许我们生成声明和规则。像函数一样，它们接受参数（尽管这不是强制的）并返回样式。让我们写一个将返回每个图片三个声明的 mixin。mixin 是一个 at-rule，因此它以
    `@mixin` 开头，后面跟着我们想要给它的名字。接下来，我们添加括号，其中包含我们想要传递的任何参数。最后，我们添加一组大括号，在其中定义 mixin
    想要返回的样式。图 12.10 显示了语法。
- en: '![](../Images/12-10.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片 12-10](../Images/12-10.png)'
- en: Figure 12.10 Mixin syntax
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.10 混合语法
- en: Notice that each parameter starts with a dollar sign. In Sass, the name of the
    parameter is defined the same way as a variable starting with `$`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到每个参数都以美元符号开头。在 Sass 中，参数的名称定义方式与以 `$` 开头的变量相同。
- en: Inside the mixin, we assign these parameter values to properties, as shown in
    listing 12.14\. We alter the border radius, float the image, and remove the margin
    on the side it is being floated to. Note that the mixin needs to be defined before
    it can be used, so it’s common to place mixins at the beginning of the file.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 mixin 中，我们将这些参数值分配给属性，如下列 12.14 所示。我们改变边框半径，浮动图片，并移除它浮动的侧面的边距。请注意，mixin 需要在使用之前定义，因此通常将
    mixins 放在文件的开始部分。
- en: Listing 12.14 Building the mixin (SCSS)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.14 构建 mixin（SCSS）
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ① Interpolation (section 12.3.2)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ① 插值（第 12.3.2 节）
- en: At this point, we don’t see a change in the project. We’ve defined the mixin
    but haven’t used it yet. Before we apply it, let’s take a closer look at some
    of its properties.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们没有在项目中看到任何变化。我们已经定义了 mixin，但还没有使用它。在我们应用它之前，让我们更仔细地看看它的某些属性。
- en: 12.3.1 object-fit property
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.1 `object-fit` 属性
- en: In our base rule, we set our `object-fit` property value to `cover`. The `object-position`
    property, which we also use in our mixin, works hand in hand with `object-fit`
    and determines the alignment of the image within its bounding box. Remember that
    `cover` makes the browser calculate the optimum size of the image based on the
    dimensions provided so that as much of the image that can be shown without distortion
    appears.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的基规则中，我们将`object-fit`属性值设置为`cover`。`object-position`属性，我们也在mixin中使用，与`object-fit`协同工作，确定图像在其边界框内的对齐方式。记住，`cover`使浏览器根据提供的维度计算图像的最佳大小，以便尽可能多的图像在不失真的情况下显示。
- en: If the dimensions provided to the image don’t have the same aspect ratio as
    the image, the excess is clipped. `object-position` changes where the image is
    positioned inside the container, allowing us to manipulate which part of the image
    is clipped when the ratios don’t match (figure 12.11).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供给图像的维度与图像的宽高比不同，则超出部分将被裁剪。`object-position`属性改变图像在容器内的位置，允许我们在比例不匹配时操作图像被裁剪的部分（图12.11）。
- en: '![](../Images/12-11.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片12-11](../Images/12-11.png)'
- en: Figure 12.11 Visible vs. clipped portions of the image when using `object-position`
    in conjunction with `object-fit:` `cover`
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11 使用`object-position`与`object-fit:` `cover`结合时图像的可见部分与裁剪部分
- en: 12.3.2 Interpolation
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.2 插值
- en: 'Notice the syntax for the margin: `margin-#{$side}:` `0;`. We added a hash
    (`#`) and curly braces around the variable. This syntax, called *interpolation,*
    allows us to insert a value into our parameter. It embeds the result of the expression
    inside the curly braces in our CSS, replacing the hash. If the value of `$side`
    is equal to `"left"`, for example, our declaration will compile to `margin-left:`
    `0`;.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意边距的语法：`margin-#{$side}:` `0;`。我们在变量周围添加了哈希（`#`）和大括号。这种语法，称为*插值*，允许我们将值插入到我们的参数中。它将表达式的结果嵌入到我们的CSS中的大括号内，替换掉哈希。例如，如果`$side`的值等于`"left"`，我们的声明将编译为`margin-left:`
    `0`;。
- en: 'You may have encountered interpolation in JavaScript in the context of string
    interpolation in template literals: `` `margin-${side}` ``. In our project, we’re
    trying to concatenate `margin-` and the value of the `$side` variable. Because
    `''margin-''` `+` `$side` isn’t a valid property declaration, we use interpolation
    to insert the value.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在JavaScript的模板字面量字符串插值上下文中遇到过插值：`` `margin-${side}` ``。在我们的项目中，我们试图连接`margin-`和`$side`变量的值。因为`'margin-'`
    `+` `$side`不是一个有效的属性声明，所以我们使用插值来插入值。
- en: 12.3.3 Using mixins
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.3 使用mixin
- en: Next, we’re going to use our mixin in each image rule. To do that, we use `@include`
    followed by the mixin’s name and, in parentheses, the parameters it requires (figure
    12.12).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用我们的mixin在每个图像规则中。为此，我们使用`@include`后跟mixin的名称，并在括号中包含它所需的参数（图12.12）。
- en: '![](../Images/12-12.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片12-12](../Images/12-12.png)'
- en: Figure 12.12 `@mixin` syntax
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12 `@mixin` 语法
- en: In all three image rules, we use `@include` `handle-img()` and pass in the `border-radius`,
    `object-position`, and `float` property values we want to use (listing 12.15).
    All three images have rounded corners (the first parameter of our mixin). Our
    first and second image use the `border-radius` shorthand property, which we’ll
    talk about in section 12.3.4.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有三个图像规则中，我们使用`@include` `handle-img()`并传入我们想要使用的`border-radius`、`object-position`和`float`属性值（列表12.15）。所有三个图像都有圆角（mixin的第一个参数）。我们的第一和第二个图像使用`border-radius`缩写属性，我们将在12.3.4节中讨论。
- en: Listing 12.15 Using the mixin (SCSS)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.15 使用mixin（SCSS）
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In our output CSS, the mixin itself isn’t there, but we have three new rules,
    one for each image, as shown in the following listing.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的输出CSS中，mixin本身并不存在，但我们有三个新的规则，每个图像一个，如下所示。
- en: Listing 12.16 Using the mixin output (CSS)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.16 使用mixin输出（CSS）
- en: '[PRE15]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ① Selectors added to the base class by using @extend
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ① 通过使用@extend添加到基类中的选择器
- en: ② Generated by using the mixin (@include)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ② 通过使用mixin生成（@include）
- en: This output exposes the difference between using `@extend` and using a mixin
    (`@include`). When we extend a rule, Sass doesn’t copy or generate code; it only
    adds the selector to the base. When we use a mixin, Sass generates code. If we’re
    setting properties dynamically, we want to use a mixin. But if the property values
    are static, we want to extend; otherwise, we’d be copying those values every time
    we used the mixin, bloating our stylesheet. At this point, our project looks like
    figure 12.13.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出揭示了使用 `@extend` 和使用混合（`@include`）之间的区别。当我们扩展一个规则时，Sass 不会复制或生成代码；它只是将选择器添加到基础中。当我们使用混合时，Sass
    会生成代码。如果我们正在动态设置属性，我们想要使用混合。但如果属性值是静态的，我们想要扩展；否则，我们每次使用混合时都会复制这些值，这会使我们的样式表膨胀。在此阶段，我们的项目看起来像图
    12.13。
- en: '![](../Images/12-13.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/12-13.png)'
- en: Figure 12.13 Styled images
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.13 样式化图片
- en: 12.3.4 border-radius shorthand
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.4 `border-radius` 简写
- en: For our first and second images, we’re using the `border-radius` shorthand.
    The first image’s generated CSS has a `border-radius` property value of `20px`
    `100px` `10px` `20px`. Just as we set different padding values for all four sides
    of an element in one declaration, `border-radius` allows us to use a similar syntax
    (figure 12.14). Each value defines the radius of the corner starting at top left
    and rotating clockwise.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一张和第二张图片，我们使用了 `border-radius` 简写。第一张图片生成的 CSS 中 `border-radius` 属性的值为
    `20px` `100px` `10px` `20px`。正如我们可以在一个声明中为元素的所有四个边设置不同的填充值一样，`border-radius` 允许我们使用类似的语法（图
    12.14）。每个值定义了从左上角开始并顺时针旋转的角落半径。
- en: '![](../Images/12-14.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/12-14.png)'
- en: Figure 12.14 The `border-radius` property
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.14 `border-radius` 属性
- en: Now that our images are styled, let’s take a closer look at our text. In some
    paragraphs, we have links to style.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对图片进行了样式化，让我们更仔细地看看我们的文本。在一些段落中，我们有链接需要样式化。
- en: 12.4 Nesting
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.4 嵌套
- en: One cool thing that Sass lets us do is nest rules. When we style links, we often
    write several rules so that we can handle the various states (link, visited, hover,
    focus, and so on). We can nest them together as shown in listing 12.17\. Nesting
    our rules clearly shows the ancestor–descendant relationships in our code and
    keeps our rules grouped and organized.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Sass 让我们能够做到的一件酷事是嵌套规则。当我们样式化链接时，我们经常编写多个规则，以便我们可以处理各种状态（链接、已访问、悬停、聚焦等）。我们可以像列表
    12.17 所示那样将它们嵌套在一起。嵌套我们的规则清楚地显示了代码中的祖先-后代关系，并使我们的规则分组和组织。
- en: To select the parent selector, we use an ampersand (`&`). In our rule, the parent
    rule is for the anchor element. Inside this rule, we need to reference the parent
    (`a`) to use with the `:link`, `:visited`, `:hover`, and `:focus` pseudo-classes,
    so we precede them with `&`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择父选择器，我们使用一个和号（`&`）。在我们的规则中，父规则是针对锚点元素的。在这个规则内部，我们需要引用父元素（`a`）以与 `:link`、`:visited`、`:hover`
    和 `:focus` 伪类一起使用，因此我们在它们之前加上 `&`。
- en: We make all our anchor elements bold, make them blue by using our `$primary`
    variable, and edit the underline of our links from solid to dotted. On hover,
    we make the underline a dashed line. Finally, we make the focus underline a solid
    line. On focus, we also remove the default outline that exists in some browsers.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使所有锚点元素加粗，通过使用我们的 `$primary` 变量使它们变为蓝色，并将我们的链接下划线从实线改为点线。在悬停时，我们将下划线变为虚线。最后，我们将聚焦下划线变为实线。在聚焦时，我们还移除了某些浏览器中存在的默认轮廓。
- en: Listing 12.17 Nesting rules (SCSS)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.17 嵌套规则（SCSS）
- en: '[PRE16]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '① All anchor elements: the parent'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ① 所有锚点元素：父元素
- en: ② Anchor elements that contain an href, both visited and not
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ② 包含 href 的锚点元素，无论是已访问的还是未访问的
- en: ③ Changes the underline style to a dotted line
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将下划线样式改为点线
- en: ④ On link hover, changes the underline style to a dashed line
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 链接悬停时，将下划线样式改为虚线
- en: ⑤ On link focus
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 链接聚焦时
- en: ⑥ Changes the underline style to a solid line
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 将下划线样式改为实线
- en: In our CSS output, shown in the following listing, our nested rule has been
    flattened, creating individual rules for the anchor element and each of its states.
    Now our links look like figure 12.15.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 CSS 输出中，如下所示列表中所示，我们的嵌套规则已被展平，为锚点元素及其每个状态创建了单独的规则。现在我们的链接看起来像图 12.15。
- en: Listing 12.18 Nesting rules (CSS output)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.18 嵌套规则（CSS 输出）
- en: '[PRE17]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![](../Images/12-15.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/12-15.png)'
- en: 'Figure 12.15 Styled links: (top to bottom) default, hover, and focus'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.15 样式化链接：（从上到下）默认、悬停和聚焦
- en: 'Note Nesting is a great way to keep our rules grouped and organized. But for
    every level of nesting, there is another level of specificity. In listing 12.17,
    we nest the hover and focus inside the anchor (`a`) rule. The selector in the
    output (listing 12.18) for the inner rules are more specific than the outer rule:
    `a:hover` is more specific than `a`. By nesting rules, we can easily end up creating
    overly specific rules, which decrease performance. We need to be on the lookout
    for excessive nesting in our code. If we notice that nesting becomes more than
    three levels deep, we should examine how our rules are nested and see whether
    some of the rules could be unnested.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意嵌套是一种很好的方式来保持我们的规则分组和组织。但是，对于每一层嵌套，都有另一个具体性级别。在列表 12.17 中，我们在锚点（`a`）规则内部嵌套了悬停和聚焦。输出（列表
    12.18）中的内部选择器比外部规则更具体：`a:hover` 比较具体于 `a`。通过嵌套规则，我们很容易创建过于具体的规则，这会降低性能。我们需要在我们的代码中留意过度嵌套。如果我们注意到嵌套超过三个层级，我们应该检查我们的规则是如何嵌套的，并看看是否有一些规则可以被解嵌套。
- en: With links styled, the next pieces of text we want to turn our attention to
    are the callout paragraphs.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 链接样式完成后，我们接下来要关注的是调用段落。
- en: 12.5 @each
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.5 @each
- en: In our text, we have three callout paragraphs that have classes of `success`,
    `warning`, and `error`. As we did when we styled our images (section 12.4), we’ll
    create a base rule and then extend it (listing 12.19). The rule defines the `border`,
    `border-radius`, and `padding` we want our callouts to have, and it includes the
    styles all three types have in common.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的文本中，我们有三个具有 `success`、`warning` 和 `error` 类的调用段落。正如我们在样式化图像时所做的（第 12.4 节），我们将创建一个基础规则，然后扩展它（列表
    12.19）。该规则定义了我们想要调用具有的 `border`、`border-radius` 和 `padding`，并且它包括所有三种类型共有的样式。
- en: Listing 12.19 Callout base rule
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.19 调用基础规则
- en: '[PRE18]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Next, instead of writing individual rules for each callout type, we’re going
    to create a map, a list of key-value pairs that we can iterate over to generate
    the rulesets. Because the differentiating factor of our callouts is the color,
    our key will be the type, and our value will be the color variable we defined
    at the beginning of this chapter. Our map, therefore, will be `$callouts:` `(success:`
    `$success,` `warning:` `$warning,` `error:` `$error);`. Figure 12.16 breaks down
    the syntax.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们不再为每个调用类型编写单独的规则，而是创建一个映射，这是一个键值对的列表，我们可以遍历它来生成规则集。因为我们的调用区分因素是颜色，所以我们的键将是类型，我们的值将是我们在本章开头定义的颜色变量。因此，我们的映射将是
    `$callouts:` `(success:` `$success,` `warning:` `$warning,` `error:` `$error);`。图
    12.16 分解了语法。
- en: '![](../Images/12-16.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/12-16.png)'
- en: Figure 12.16 Sass map syntax
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.16 Sass 映射语法
- en: 'With the map created, we can loop over each key-value pair to generate our
    classes. For looping, we’ll use `@each`. This at-rule iterates over all the items
    in a list or map in order, which is perfect for our use case. We’ll add the following
    rule to our SCSS: `@each` `$type,` `$color` `in` `$callouts` `{}`. The first variable
    (`$type`) gives us access to the key, the second (`$color`) is the value of the
    key pair, and the last (`$callouts`) is the map we want to iterate over. We’ll
    put the code to generate our rules inside the curly braces. To test our loop,
    we can add an `@debug` declaration inside the curly braces to check that our variable
    values are what we expect (listing 12.20).'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了映射后，我们可以遍历每个键值对来生成我们的类。对于循环，我们将使用 `@each`。这个 at 规则按顺序遍历列表或映射中的所有项，这对于我们的用例来说非常完美。我们将在我们的
    SCSS 中添加以下规则：`@each` `$type,` `$color` `in` `$callouts` `{}`。第一个变量（`$type`）给我们提供了访问键的权限，第二个（`$color`）是键对的值，最后一个（`$callouts`）是我们想要遍历的映射。我们将生成规则的代码放在大括号内。为了测试我们的循环，我们可以在大括号内添加一个
    `@debug` 声明来检查我们的变量值是否符合预期（列表 12.20）。
- en: NOTE `@debug` is the Sass equivalent of JavaScript’s `console.log()`. It allows
    us to print values to the terminal. Unfortunately, CodePen doesn’t seem to have
    a way to expose Sass debug statements in its console. These statements won’t show
    up in the browser’s console, either. You’ll be able to see the debug output only
    if you’re running the project locally.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `@debug` 是 Sass 中 JavaScript 的 `console.log()` 的等价物。它允许我们将值打印到终端。不幸的是，CodePen
    似乎没有一种方法可以在其控制台中暴露 Sass 调试语句。这些语句也不会在浏览器控制台中显示。你只能在本地运行项目时看到调试输出。
- en: Listing 12.20 `@debug` statement inside our loop (SCSS)
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.20 循环中的 `@debug` 语句（SCSS）
- en: '[PRE19]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ① The map
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ① 映射
- en: ② Sets up the loop
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ② 设置循环
- en: ③ The debug statement that will print our $type and $color values to the terminal
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将打印我们的 $type 和 $color 值到终端的调试语句
- en: In the terminal where we have our Sass watcher running, the `@debug` statement
    outputs the file name, line number, the word *Debug*, and the values for our two
    variables (listing 12.21). Note that your line numbers may differ slightly from
    those displayed in the listing.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行Sass监视器的终端中，`@debug`语句输出了文件名、行号、单词*调试*以及我们两个变量的值（列表12.21）。请注意，您的行号可能与列表中显示的略有不同。
- en: Listing 12.21 Output in terminal
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.21 终端输出
- en: '[PRE20]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ① First key-value pair
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ① 第一个键值对
- en: ② Second key-value pair
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ② 第二个键值对
- en: ③ Third key-value pair
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 第三个键值对
- en: Now that we know our loop is working correctly, we can create rules for our
    callout types. In each ruleset, we extend our `.callout` base rule and add the
    correct border color for each type by using `border-color`. The value of the `border-color`
    property is the `$color` variable that comes from our `@each` loop. We mentioned
    earlier that Sass variables are static (section 12.2). As a result, the `$color`
    variable’s value is reassigned for each key-value pair in the map, assigning the
    `border-color` correctly for each callout type.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们的循环工作正常，我们可以为我们的提示框类型创建规则。在每个规则集中，我们扩展`.callout`基本规则，并使用`border-color`添加每个类型的正确边框颜色。`border-color`属性的值来自我们的`@each`循环的`$color`变量。我们之前提到Sass变量是静态的（第12.2节）。因此，`$color`变量的值在映射中的每个键值对中都会重新分配，为每个提示框类型正确分配`border-color`。
- en: Next, we add the type name before the paragraph by using the `::before` pseudo
    element so that we have a visual indicator other than color telling the user what
    type of callout it is. Because the type value is lowercase in our map, we also
    use `text-transform` to capitalize it. Listing 12.22 shows our updated loop.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过使用`::before`伪元素在段落之前添加类型名称，以便我们有一个除了颜色之外的可视指示器，告诉用户提示框的类型是什么。因为我们的映射中的类型值是小写的，所以我们还使用`text-transform`将其转换为大写。列表12.22显示了我们的更新后的循环。
- en: Note Never use color alone to convey meaning. Some users, such as those who
    are color-blind, may have difficulty perceiving colors or may not be able to see
    them at all. In our case, the color conveys the type of callout, so we should
    include some other indicator (the text).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：永远不要仅使用颜色来传达意义。一些用户，如色盲用户，可能难以感知颜色，甚至可能完全看不到它们。在我们的例子中，颜色传达了提示框的类型，因此我们应该包含一些其他指示器（文本）。
- en: Listing 12.22 Adding to the loop (SCSS)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.22 向循环中添加（SCSS）
- en: '[PRE21]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ① Interpolation to create the class name
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ① 插值以创建类名
- en: ② Interpolation to get the type name in the content
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ② 插值以获取内容中的类型名称
- en: As we did when we used interpolation to create a margin declaration in section
    12.3.2, we use it here to create the class name and add the type to the content.
    By looping over the map, our `@each` rule creates three rules, one for each type.
    Each selector also gets added to the `.callout` rule via the `@extend`, as shown
    in the following listing.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在12.3.2节中使用插值创建边距声明时所做的，我们在这里使用它来创建类名并将类型添加到内容中。通过遍历映射，我们的`@each`规则创建了三个规则，每个类型一个。每个选择器也通过`@extend`添加到`.callout`规则中，如下面的列表所示。
- en: Listing 12.23 Loop CSS output
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.23 循环CSS输出
- en: '[PRE22]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ① All three class selectors (.error, .warning, .success) are added to the .callout
    base class.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ① 所有三个类选择器（.error, .warning, .success）都被添加到.callout基本类中。
- en: Now our three callouts have colored borders (figure 12.17). But we still need
    to boldface *Error:* in the error callout and add the background colors.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们三个提示框都有彩色边框（图12.17）。但我们仍然需要在错误提示框中加粗*错误:*并添加背景颜色。
- en: '![](../Images/12-17.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/12-17.png)'
- en: Figure 12.17 Callout styles including colored borders
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.17 包含彩色边框的提示框样式
- en: 12.6 Color functions
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.6 颜色函数
- en: We want the background colors for each callout to be significantly lighter than
    the colors we currently have stored in our variables. To make working with colors
    easier, Sass provides functions for manipulating colors. We’re going to use `scale-color()`.
    The `scale-color()` function is incredibly versatile and can be used to change
    the amount of red, blue, and green in a color; change the saturation or opacity;
    and make a color lighter or darker (figure 12.18).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望每个提示框的背景颜色都要比我们目前存储在变量中的颜色明显浅很多。为了使颜色操作更简单，Sass提供了用于操作颜色的函数。我们将使用`scale-color()`。`scale-color()`函数非常灵活，可以用来改变颜色的红色、蓝色和绿色成分；改变饱和度或不透明度；以及使颜色变浅或变深（图12.18）。
- en: '![](../Images/12-18.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/12-18.png)'
- en: Figure 12.18 The `scale-color()` function
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.18 `scale-color()`函数
- en: Worth noting is the fact that `scale-color()` operates with either HSL (hue,
    saturation, and lightness) or RGB (red, green, and blue) parameters; they can’t
    be mixed. The alpha (transparency) parameter, however, can be used with either
    set of parameters. Also, parameters can be omitted. So if we want to change only
    the opacity, we need to pass only the initial color and the parameter(s) with
    which we want to manipulate the color.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`scale-color()` 使用 HSL（色调、饱和度和亮度）或 RGB（红色、绿色和蓝色）参数；它们不能混合使用。然而，alpha（透明度）参数可以与任何一组参数一起使用。此外，参数可以省略。因此，如果我们只想更改不透明度，我们只需要传递初始颜色和我们要用来操作颜色的参数（s）。
- en: For our backgrounds, we need to increase the lightness of the color, so we use
    HSL parameters. We don’t need to change the saturation, so we’ll omit the saturation
    parameter and pass in only the color and the amount by which we want to increase
    the lightness (`86%`), as shown in the following listing.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的背景，我们需要增加颜色的亮度，所以我们使用 HSL 参数。我们不需要更改饱和度，所以我们将省略饱和度参数，只传递颜色和我们要增加亮度的量（`86%`），如下所示。
- en: Listing 12.24 Adding the background color (SCSS)
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.24 添加背景颜色（SCSS）
- en: '[PRE23]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ① Increases the lightness of the color provided in the map by 86%
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ① 增加了映射中提供的颜色的亮度 86%
- en: The following listing shows the color generated by the `scale-color()` function
    in our CSS output.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了 `scale-color()` 函数在 CSS 输出中生成的颜色。
- en: Listing 12.25 `scale-color()` function output (CSS)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.25 `scale-color()` 函数输出（CSS）
- en: '[PRE24]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now that we’ve added the background colors (figure 12.19), all we have left
    to do is boldface *Error:* as part of the `::before` content for the error callout.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了背景颜色（图 12.19），我们剩下要做的就是将 `*Error:*` 作为错误调用部分的 `::before` 内容加粗。
- en: 12.7 @if and @else
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.7 @if 和 @else
- en: Another set of at-rules that are available thanks to Sass are `@if` and `@else`,
    which control whether a block of code is evaluated and provide a fallback condition
    if the condition isn’t met. We’re going to use them inside our loop to boldface
    only the contents of the `::before` pseudo-element if the type of callout is `error`
    and increase the font weight to medium (`500`) for the others.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Sass 的存在，可用的另一组 at 规则是 `@if` 和 `@else`，它们控制是否评估代码块，并在条件不满足时提供回退条件。我们将在循环中使用它们，如果调用类型是
    `error`，则仅将 `::before` 伪元素的文本加粗，对于其他类型则增加字体粗细到中等（`500`）。
- en: If you’re used to JavaScript, a couple of gotchas can trip you up when evaluating
    equality in Sass, because Saas doesn’t have truthy/falsy behaviors. Values are
    considered to be equal only if they have the same value and type. Also, Sass doesn’t
    use the double pipe (`||`) or double ampersand (`&&`) but `or` and `and` for considering
    multiple conditions. The following listing shows examples of some of Sass’s equality
    operators and what they resolve to.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯了 JavaScript，Sass 中的相等性评估可能会让你遇到一些陷阱，因为 Sass 没有真/假行为。只有当值具有相同的值和类型时，才被认为是相等的。此外，Sass
    不使用双竖线（`||`）或双与（`&&`），而是使用 `or` 和 `and` 来考虑多个条件。以下列表显示了 Sass 的一些相等性运算符及其结果。
- en: Listing 12.26 Equalities (SCSS)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.26 等式（SCSS）
- en: '[PRE25]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ① true, false, and null are equal only to themselves.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ① `true`、`false` 和 `null` 只与自己相等。
- en: ② Both values are considered to be strings.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ② 两个值都被视为字符串。
- en: ③ Converted to the same unit, they’re equal in size; therefore, they’re equal.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 转换为相同的单位，它们在大小上相等；因此，它们相等。
- en: To check that our `$type` variable is equal to `'error'`, our condition will
    be `$type` `==` `'error'` coupled with `@if` and `@else`. Our rule looks like
    the following listing.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查我们的 `$type` 变量是否等于 `'error'`，我们的条件将是 `$type` `==` `'error'` 结合 `@if` 和 `@else`。我们的规则如下所示。
- en: Listing 12.27 Conditionally boldfacing the callout type (SCSS)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.27 条件加粗调用类型（SCSS）
- en: '[PRE26]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ① The type is error; therefore, we add a font width of 800.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ① 类型是错误；因此，我们添加了 800 的字体宽度。
- en: ② The type isn’t error (it’s either success or warning), so font-weight is set
    to 500.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ② 类型不是错误（它是成功或警告），因此字体粗细设置为 500。
- en: The following listing shows that font weights have been added to each type in
    the CSS output.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示，CSS 输出中已为每种类型添加了字体粗细。
- en: Listing 12.28 Conditionally boldfacing the callout type (CSS output)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.28 条件加粗调用类型（CSS 输出）
- en: '[PRE27]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The text added as part of the `::before` pseudo-element has a `font-weight`
    of `500` for both `.success` and `.warning`. The `.error::before` rule, on the
    other hand, has a `font-weight` of `800`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 `::before` 伪元素的文本添加部分，`.success` 和 `.warning` 的 `font-weight` 都是 `500`。另一方面，`.error::before`
    规则的 `font-weight` 为 `800`。
- en: With this last detail added, our project is complete. Figure 12.19 shows the
    final output.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了这个最后细节后，我们的项目就完成了。图 12.19 展示了最终输出。
- en: '![](../Images/12-19.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/12-19.png)'
- en: Figure 12.19 Finished project
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.19 完成的项目
- en: 12.8 Final thoughts
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.8 最后的想法
- en: This chapter illustrates several things Saas lets us do that we can’t do with
    CSS alone, but it covers only a small percentage of Saas’s features and delves
    into only one preprocessor. Preprocessors can do much more; this chapter only
    scratches the surface. The takeaway is that preprocessors provide cool functionality
    that can make code more efficient to write and also more complex. They also require
    a build step and slightly more complicated setup.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了 SaaS 允许我们做一些仅使用 CSS 无法做到的事情，但它只涵盖了 SaaS 功能的一小部分，并且只深入探讨了一个预处理器。预处理器可以做更多；本章只是触及了表面。重要的是要记住，预处理器提供了酷炫的功能，可以使代码编写更高效，同时也更复杂。它们还要求有一个构建步骤和稍微复杂一些的设置。
- en: 'Although we didn’t dive into Less or Stylus, here are some questions that may
    help when you’re choosing a preprocessor:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们没有深入探讨 Less 或 Stylus，以下是一些在选择预处理器时可能有助于你的问题：
- en: Do I need a preprocessor?
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我是否需要预处理器？
- en: What functionality does the preprocessor need?
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预处理器需要哪些功能？
- en: How is using a preprocessor going to help the development of my project?
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用预处理器将如何帮助我的项目开发？
- en: If the project uses a user-interface framework or library, does it support one
    or more preprocessors? If so, which ones?
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果项目使用用户界面框架或库，它是否支持一个或多个预处理器？如果是，哪些？
- en: What will having a preprocessor change about my build-and-deploy process because
    now the CSS needs to be built?
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于现在 CSS 需要构建，拥有预处理器将如何改变我的构建和部署流程？
- en: What skills do my team members have, and which preprocessors are they familiar
    with?
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的团队成员有哪些技能，他们熟悉哪些预处理器？
- en: Whether or not preprocessors are for you, the important thing to remember is
    that every project is different. Keep learning, exploring, and trying new things,
    and have some fun. Happy coding!
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 无论预处理器是否适合你，重要的是要记住每个项目都是不同的。继续学习、探索和尝试新事物，并享受乐趣。编码愉快！
- en: Summary
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Sass has two syntaxes: indented and SCSS.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sass 有两种语法：缩进和 SCSS。
- en: Variables and CSS custom properties work differently.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量和 CSS 自定义属性的工作方式不同。
- en: Sass variables are block-scoped.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sass 变量是块作用域的。
- en: '`@extend` extends existing rules, whereas mixins generate new code.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@extend` 扩展现有规则，而混合生成新代码。'
- en: Mixins can take parameters.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合可以接受参数。
- en: When used in conjunction with `object-fit:` `cover`, `object-position` helps
    position an image within its bound box when the image doesn’t have the same aspect
    ratio as the dimensions it’s given.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当与 `object-fit:` `cover` 结合使用时，`object-position` 帮助在图像没有与给定的尺寸相同的宽高比时，在边界框内定位图像。
- en: Interpolation is used to embed the result of an expression, such as when creating
    rule names from variables.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插值用于嵌入表达式的结果，例如在从变量创建规则名称时。
- en: The `border-radius` property can take multiple values to assign different curvature
    to each corner of an element, starting from top left and rotating clockwise.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`border-radius` 属性可以接受多个值，以将不同的曲率分配给元素每个角落，从左上角开始，按顺时针方向旋转。'
- en: Sass allows us to nest rules.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sass 允许我们嵌套规则。
- en: We can use `@each` to loop over lists and maps.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 `@each` 来遍历列表和映射。
- en: '`@debug` allows us to print values in the terminal output.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@debug` 允许我们在终端输出中打印值。'
- en: Sass provides functions such as `scale-color()` to manipulate and alter colors.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sass 提供了如 `scale-color()` 这样的函数来操纵和改变颜色。
- en: '`@if` and `@else` can be used to determine conditionally whether a block of
    code should be evaluated.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@if` 和 `@else` 可以用来确定是否应该评估代码块。'
