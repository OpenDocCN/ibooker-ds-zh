- en: 6 Privacy-preserving synthetic data generation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 隐私保护合成数据生成
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Synthetic data generation
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合成数据生成
- en: Generating synthetic data for anonymization
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为匿名化生成合成数据
- en: Using differential privacy mechanisms to generate privacy-preserving synthetic
    data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用差分隐私机制生成隐私保护合成数据
- en: Designing a privacy-preserving synthetic data generation scheme for machine
    learning tasks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为机器学习任务设计一个隐私保护合成数据生成方案
- en: So far we’ve looked into the concepts of differential privacy (including the
    centralized, DP, and the local, LDP, versions) and their applications in developing
    privacy-preserving query-processing and machine learning (ML) algorithms. As you
    saw, the idea of DP is to add noise to the query results (without disturbing their
    original properties) such that the results can assure the privacy of the individuals
    while satisfying the utility of the application.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了差分隐私（包括集中式、DP和本地式、LDP版本）的概念及其在开发隐私保护查询处理和机器学习（ML）算法中的应用。如您所见，DP的理念是在查询结果中添加噪声（而不干扰其原始属性），以便结果可以确保个人的隐私同时满足应用的效用。
- en: But sometimes data users may request the original data to utilize it locally
    and directly, perhaps to develop new queries and analysis procedures. Privacy-preserving
    data-sharing methods can be used for such purposes. This chapter will look into
    synthetic data generation—a promising solution for data sharing—which generates
    synthetic yet representative data that can be shared among multiple parties safely
    and securely. The idea of synthetic data generation is to artificially generate
    data that has distribution and properties similar to the original data. And because
    it is artificially produced, we do not have to worry about privacy concerns.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时数据用户可能需要原始数据以进行本地直接利用，可能用于开发新的查询和分析程序。隐私保护的数据共享方法可用于此类目的。本章将探讨合成数据生成——一种数据共享的可行解决方案，它生成合成且具有代表性的数据，可以在多个当事人之间安全地共享。合成数据生成的理念是人工生成具有与原始数据相似分布和属性的数据。由于它是人工生产的，我们不必担心隐私问题。
- en: We’ll start this chapter by introducing the concepts and basics of synthetic
    data generation. Subsequent sections will present implementations of synthetic
    data generation approaches using different data anonymization techniques or DP.
    Toward the end of this chapter, we’ll walk you through a case study that implements
    a novel privacy- preserving synthetic data generation approach using data anonymization
    and DP for ML purposes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个章节开始介绍合成数据生成的基本概念和原理。随后的章节将展示使用不同的数据匿名化技术或差分隐私（DP）实现合成数据生成方法的实例。在本章的末尾，我们将向您介绍一个案例研究，该研究实现了一种新颖的隐私保护合成数据生成方法，该方法使用数据匿名化和DP进行机器学习。
- en: '![CH06_00_UN01_Zhuang](../../OEBPS/Images/CH06_00_UN01_Zhuang.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_00_UN01_Zhuang](../../OEBPS/Images/CH06_00_UN01_Zhuang.png)'
- en: 6.1 Overview of synthetic data generation
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 合成数据生成概述
- en: In essence, data is a collection of facts that can be translated into a form
    that a computer can understand and process. With today’s modern applications,
    data collection happens almost everywhere, such as in business analytics, engineering
    optimization, social science analysis, scientific research, and so on. Typically,
    different characteristics or patterns of data can be used to achieve various objectives.
    For instance, in healthcare applications, diverse image data such as x-rays, CT
    scans, and dermoscopic images can be used by ML applications to diagnose particular
    diseases or aid treatments.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，数据是一系列可以转化为计算机可以理解和处理的形式的事实。随着今天现代应用的发展，数据收集几乎无处不在，如商业分析、工程优化、社会科学分析、科学研究等。通常，不同的数据特征或模式可用于实现各种目标。例如，在医疗保健应用中，各种图像数据，如X光片、CT扫描和皮肤镜检查图像，可以被机器学习应用用于诊断特定疾病或辅助治疗。
- en: However, in practice, it is very challenging to obtain real (and sensitive)
    data for many reasons, including privacy concerns, and even when you can collect
    the data, you are usually not permitted to share it with other parties. When it
    comes to ML applications, most algorithms require a large amount of training data
    to achieve their best performance, but it is not always feasible to collect such
    an amount of real data. Thus, there is a need for synthetic (yet representative)
    data, and due to the aforementioned concerns, synthetic data has become an increasingly
    important and popular topic.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实践中，由于多种原因，包括隐私问题，获取真实（且敏感）数据非常具有挑战性，即使你能够收集数据，通常也不允许你与其他方分享。当涉及到机器学习应用时，大多数算法需要大量的训练数据才能达到最佳性能，但收集如此大量的真实数据并不总是可行的。因此，需要合成（但具有代表性）的数据，鉴于上述担忧，合成数据已成为越来越重要且受欢迎的话题。
- en: 6.1.1 What is synthetic data? Why is it important?
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.1 什么是合成数据？为什么它很重要？
- en: The performance of an ML model largely depends on the amount and quality of
    data accumulated to train the model. When an organization does not have sufficient
    data for the training, data sharing often happens between organizations that have
    similar research interests. This enables the research to scale, but the privacy
    problem remains the same. The data usually includes sensitive personal information
    that can cause privacy leakage for the individuals. Hence, it is imperative to
    enable privacy-preserving mechanisms when data sharing. To that end, generating
    privacy-preserving synthetic data is one of the best alternatives—it is a flexible
    and viable next-step solution for sharing sensitive data across multiple stakeholders.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习模型的表现很大程度上取决于用于训练模型的数据量和质量。当一个组织没有足够的数据进行训练时，具有相似研究兴趣的组织之间通常会进行数据共享。这使得研究可以扩展，但隐私问题仍然存在。数据通常包括可能导致个人隐私泄露的敏感个人信息。因此，在数据共享时启用隐私保护机制至关重要。为此，生成隐私保护合成数据是最佳替代方案之一——它是跨多个利益相关者共享敏感数据的灵活且可行的下一步解决方案。
- en: Synthetic data is a kind of artificially formulated data, usually generated
    with artificial algorithms rather than being collected by real-world direct measurement
    techniques. But it still carries some critical features of the actual data (e.g.,
    statistical properties, functionalities, or conclusions). Analyzing the synthetic
    data can produce results similar to analyzing the actual data itself. Another
    advantage of synthetic data is that it can be generated for the specific characteristics
    of rare testing scenarios that are extremely hard to observe in reality (i.e.,
    scenarios where it is challenging to obtain actual data). This enables the engineers
    and researchers to generate different datasets to validate various models, evaluate
    ML algorithms, and test new products, pipelines, and tools under different scenarios.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 合成数据是一种人工编制的数据，通常通过人工算法生成，而不是通过现实世界的直接测量技术收集。但它们仍然携带一些实际数据的临界特征（例如，统计属性、功能或结论）。分析合成数据可以产生与分析实际数据本身相似的结果。合成数据的另一个优点是，它可以针对现实中极难观察到的罕见测试场景的特定特征生成（即，难以获取实际数据的场景）。这使得工程师和研究人员能够生成不同的数据集来验证各种模型，评估机器学习算法，并在不同场景下测试新产品、流程和工具。
- en: Moreover, synthetic data helps us ensure privacy protection. Synthetic data
    can have statistical characteristics similar to the original data without disclosing
    the original data, which paves a safer way of protecting privacy and confidentiality.
    For instance, primary care providers (such as hospitals) collect and share their
    patients’ information for research purposes with the consent of those patients.
    However, most patients will not agree to share their private information with
    other parties. Instead of sharing the original data, we can generate artificial
    or synthetic data based on the properties of the original dataset. Then we can
    share the synthetically produced data with other data users. That retains the
    utility of the application and preserves the privacy of the original data.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，合成数据帮助我们确保隐私保护。合成数据可以具有与原始数据相似的统计特性，而不泄露原始数据，这为保护隐私和机密性开辟了一条更安全的方式。例如，初级保健提供者（如医院）在患者同意的情况下收集和分享他们的患者信息用于研究目的。然而，大多数患者不会同意与其他方分享他们的私人信息。我们不是分享原始数据，而是可以根据原始数据集的特性生成人工或合成数据。然后我们可以与其他数据用户共享这些合成的数据。这样既保留了应用的效用，又保护了原始数据的隐私。
- en: 6.1.2 Application aspects of using synthetic data for privacy preservation
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.2 使用合成数据保护隐私的应用方面
- en: Synthetic data does not contain any personal information; it is an artificially
    produced dataset with a distribution similar to the original data. Hence, engineering,
    business, and scientific research applications can benefit from using synthetic
    data for privacy-preserving purposes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 合成数据不包含任何个人信息；它是一个与原始数据分布相似的人工产生的数据集。因此，工程、商业和科学研究应用可以从使用合成数据来保护隐私的目的中受益。
- en: For instance, let’s consider an example of sharing clinical and medical data
    between different healthcare entities (e.g., hospitals and research institutions).
    Let’s assume that two hospitals, A and B, plan to conduct a research program to
    learn the relationship between an individual’s specific personal information (age,
    BMI, glucose, etc.) and their probability of getting breast cancer. Both hospitals
    can collect valuable data from their patients, but because of the patient-hospital
    agreements, the two hospitals cannot share their data with each other. Furthermore,
    because the number of samples is limited, one hospital’s data is not sufficient
    to support such research. Hence, the two hospitals have to work together to conduct
    the research without compromising their patients’ personal information.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑一个在不同医疗实体之间（例如，医院和研究机构）共享临床和医疗数据的例子。假设两家医院，A和B，计划开展一项研究项目，以了解个人特定个人信息（年龄、BMI、血糖等）与患乳腺癌概率之间的关系。两家医院都可以从他们的患者那里收集有价值的数据，但由于患者-医院协议，两家医院不能相互分享他们的数据。此外，由于样本数量有限，一家医院的数据不足以支持此类研究。因此，两家医院必须合作进行研究，同时不泄露他们的患者的个人信息。
- en: In this situation, we can use synthetic data generation techniques to produce
    synthetic yet representative data that can be safely shared. Typically, the generated
    synthetic data has the same format, statistics, and distribution as the original
    data (as shown in figure 6.1), without leaking any information from a single individual.
    Sharing a synthetic dataset in the same form as the original data gives much more
    flexibility in how data users can use it with no privacy concerns.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以使用合成数据生成技术来生成既合成又具有代表性的数据，这些数据可以安全地共享。通常，生成的合成数据具有与原始数据相同的格式、统计和分布（如图6.1所示），而不泄露任何个人信息。以与原始数据相同的形式共享合成数据集，为数据用户如何使用它提供了更多的灵活性，而无需担心隐私问题。
- en: '![CH06_F01_Zhuang](../../OEBPS/Images/CH06_F01_Zhuang.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F01_Zhuang](../../OEBPS/Images/CH06_F01_Zhuang.png)'
- en: Figure 6.1 The synthetic data retains the structure of the original data, but
    they are not the same.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 合成数据保留了原始数据的结构，但它们并不相同。
- en: Synthetic data can also be utilized in business scenarios. For instance, suppose
    a company wants to conduct a business analysis to improve its marketing spend.
    To conduct this analysis, the company’s marketing units are usually required to
    have their customers’ consent to use their data. However, customers will likely
    not consent to share their data, since the data might contain sensitive information,
    such as transactions, locations, and shopping information. In this scenario, using
    synthetic data generated from the customers’ data will enable the company to run
    an accurate simulation for the business analysis without requiring the consent
    of the customers. Since the synthetic data is generated based on the statistical
    properties of the actual data, it can be reliably used in such studies.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 合成数据也可以在商业场景中使用。例如，假设一家公司想要进行商业分析以提高其营销支出。为了进行这项分析，公司的营销部门通常需要获得其客户的同意以使用他们的数据。然而，客户可能不会同意分享他们的数据，因为这些数据可能包含敏感信息，如交易、位置和购物信息。在这种情况下，使用从客户数据生成的合成数据将使公司能够在不需要客户同意的情况下进行准确的业务分析。由于合成数据是基于实际数据的统计特性生成的，因此它可以可靠地用于此类研究。
- en: 6.1.3 Generating synthetic data
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.3 生成合成数据
- en: Before we look at specific generation techniques, let’s go through the general
    process of generating synthetic data, illustrated in figure 6.2.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看具体的生成技术之前，让我们回顾一下生成合成数据的一般过程，如图6.2所示。
- en: '![CH06_F02_Zhuang](../../OEBPS/Images/CH06_F02_Zhuang.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F02_Zhuang](../../OEBPS/Images/CH06_F02_Zhuang.png)'
- en: Figure 6.2 General pipeline for generating synthetic data
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 生成合成数据的一般流程
- en: 'Before extracting any statistical characteristics from the original dataset,
    the first step is to preprocess the original dataset by removing the outliers
    and normalizing the feature values. Outliers are data points distant from other
    observations. They may result from variability and measurement error in the experiments,
    which sometimes provide incorrect information to data users. In most cases, outliers
    are likely to mislead the synthetic data generator to generate more outliers,
    making the ML model inaccurate. One common way of detecting outliers is using
    a density-based method: observing if the probability of the presence of specific
    points in a certain area is much lower than the expected value in that area.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在从原始数据集中提取任何统计特性之前，第一步是对原始数据集进行预处理，通过去除异常值和归一化特征值。异常值是远离其他观察点的数据点。它们可能来自实验中的可变性和测量误差，有时会向数据用户提供错误信息。在大多数情况下，异常值可能会误导合成数据生成器生成更多的异常值，从而使ML模型不准确。检测异常值的一种常见方法是使用基于密度的方法：观察在某个区域中特定点存在的概率是否远低于该区域的预期值。
- en: The next step is feature normalization. Each dataset has a different number
    of features, and each feature has a different range of values. Feature normalization
    usually scales all the features to the same range, which helps us extract the
    statistical characteristics while giving equal consideration to the different
    features. After normalizing the dataset, we can build the distribution extraction
    model, which keeps the statistical characteristics of the original data.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是特征归一化。每个数据集都有不同数量的特征，每个特征都有不同的值范围。特征归一化通常将所有特征缩放到相同的范围，这有助于我们提取统计特性，同时给予不同特征平等的考虑。在归一化数据集之后，我们可以构建分布提取模型，该模型保持原始数据的统计特性。
- en: Finally, the privacy test is designed to ensure that the generated synthetic
    data satisfies certain predefined privacy guarantees (*k*-anonymity, DP, etc.).
    If the generated synthetic data cannot provide the predefined privacy guarantees,
    the privacy test will be failed. We can generate synthetic datasets repeatedly
    until one passes the privacy test.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，隐私测试旨在确保生成的合成数据满足某些预定义的隐私保证（*k*-匿名性、DP等）。如果生成的合成数据无法提供预定义的隐私保证，隐私测试将失败。我们可以反复生成合成数据集，直到其中一个通过隐私测试。
- en: Now that we have covered the basic concepts, the application scenarios, and
    the general synthetic data generation process, let’s look into some of the most
    popular synthetic generation techniques based on data anonymization and DP. We’ll
    start with the data anonymization approaches.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了基本概念、应用场景和一般合成数据生成过程，让我们来看看基于数据匿名化和DP的一些最流行的合成生成技术。我们将从数据匿名化方法开始。
- en: 6.2 Assuring privacy via data anonymization
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 通过数据匿名化确保隐私
- en: The previous chapters discussed different techniques for privatizing sensitive
    information by adding noise and using perturbation techniques. And as we discussed
    at the beginning of this chapter, synthetic data is artificially produced data.
    Hence, different data anonymization techniques can also be used to create a synthetic
    dataset.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 前几章讨论了通过添加噪声和使用扰动技术来隐私化敏感信息的不同技术。正如我们在本章开头所讨论的，合成数据是人为产生的数据。因此，不同的数据匿名化技术也可以用来创建一个合成数据集。
- en: In this section we’ll discuss historical non-DP approaches that use data anonymization
    techniques to share private and sensitive information without betraying the individual’s
    privacy. In section 6.3 we’ll discuss using DP for synthetic data generation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论使用数据匿名化技术来共享私有和敏感信息而不泄露个人隐私的历史非DP方法。在第6.3节中，我们将讨论使用DP进行合成数据生成。
- en: 6.2.1 Private information sharing vs. privacy concerns
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.1 私有信息共享与隐私关注
- en: Before we look at how anonymization techniques work, let’s consider the scenario
    where individuals’ medical records are released to the public for research purposes.
    Sharing such information has many benefits for research, including assisting the
    research community in confirming published results and facilitating them to do
    more qualitative in-depth analyses of the data. Thus, anonymizing the data is
    common before releasing data to the public.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看匿名化技术是如何工作的之前，让我们考虑这样一个场景：个人的医疗记录被公开发布用于研究目的。分享此类信息对研究有许多好处，包括帮助研究界确认已发表的结果，并促进他们进行更多定性深入的数据分析。因此，在发布数据之前对数据进行匿名化是常见的做法。
- en: But can we anonymize a dataset arbitrarily? In 1997, the Group Insurance Commission
    from Massachusetts wanted to release a dataset of hospital visits by state employees,
    which was to be used for research purposes [1]. Of course, there were privacy
    considerations, so they removed all the columns that could be used to identify
    who the patient was, such as name, phone number, SSN, and address. Do you think
    this data release went well?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们能否任意匿名化一个数据集呢？1997年，马萨诸塞州的集团保险委员会想要发布一个州雇员住院访问的数据集，该数据集将被用于研究目的[1]。当然，存在隐私考虑，所以他们移除了所有可以用来识别患者身份的列，例如姓名、电话号码、SSN和地址。你认为这次数据发布进行得顺利吗？
- en: Unfortunately, it did not. A researcher from MIT, Latanya Sweeney [2], found
    that even though the main identifiers were removed, some demographic information
    was left in the dataset, such as zip code, date of birth, and gender. Sweeney
    realized that the claims of the Massachusetts governor, who insisted that the
    privacy of the individuals was respected, were actually not correct. She decided
    to re-identify which records of the published (or anonymized) dataset were the
    governor’s, so she investigated the public voter records from Massachusetts, which
    had full identifiers, such as name, address, and demographic data, including zip
    code and date of birth. She was able to identify records of prescriptions and
    visits in the dataset that belonged to the governor.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，它并没有。麻省理工学院的研究员Latanya Sweeney [2] 发现，尽管主要标识符已被移除，但数据集中仍留下了一些人口统计信息，例如邮政编码、出生日期和性别。Sweeney意识到，马萨诸塞州州长坚持认为个人隐私得到尊重的声明实际上是不正确的。她决定重新识别已发布（或匿名化）数据集中的哪些记录属于州长，因此她调查了马萨诸塞州的公共选民记录，这些记录具有完整的标识符，例如姓名、地址和人口统计数据，包括邮政编码和出生日期。她能够识别数据集中属于州长的处方和访问记录。
- en: Note In data security, a *re-identification attack* is when someone tries to
    link external data sources to identify a particular individual or a sensitive
    record.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在数据安全中，*重新识别攻击*是指有人试图将外部数据源与特定个人或敏感记录联系起来。
- en: As you can see, data anonymization techniques can be used to synthesize a dataset,
    but we need to make sure sensitive values in the dataset are no longer unique.
    How can we create an anonymized dataset such that none of the sensitive values
    in the dataset are unique? Here comes *k*-anonymity, a popular data anonymization
    approach.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，数据匿名化技术可以用来合成一个数据集，但我们需要确保数据集中的敏感值不再唯一。我们如何创建一个匿名化数据集，使得数据集中的所有敏感值都不再唯一？这就是所谓的*k*-匿名性，一种流行的数据匿名化方法。
- en: 6.2.2 Using k-anonymity against re-identification attacks
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.2 利用k-匿名性对抗重新识别攻击
- en: '*K*-anonymity is a key security concept used to alleviate the risk of someone
    re-identifying anonymized data by linking it to external datasets [3]. The idea
    is simple. It uses techniques called *generalization* and *suppression* to hide
    an individual’s identity in a group of similar people. In technical terms, a dataset
    is said to be *k*-anonymous when every possible combination of values for sensitive
    columns appears at least for *k* different records, where *k* represents the number
    of records in that group. If, for any individual in a particular dataset, there
    are at least *k*-1 other individuals who have the same properties, we can say
    that dataset is *k*-anonymized.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*K*-匿名性是一个关键的安全概念，用于通过将其链接到外部数据集来减轻某人通过重新识别匿名化数据的风险 [3]。这个想法很简单。它使用称为 *泛化*
    和 *抑制* 的技术来隐藏一组类似人员中的个人身份。在技术术语中，当敏感列的每个可能值组合至少出现在 *k* 个不同记录中时，数据集被认为是 *k*-匿名的，其中
    *k* 代表该组中的记录数。如果特定数据集中的任何个人至少有 *k*-1 个其他个人具有相同的属性，则可以说该数据集是 *k*-匿名化的。'
- en: For example, suppose we have the same Group Insurance Commission dataset, we
    are looking at the zip code in that dataset, and we set *k* to 20\. If we look
    at any person in that dataset, we should always find 19 other individuals who
    share the same zip code. The bottom line is that we will not be able to specifically
    identify an individual just by referring to their zip code. The same concept can
    be extended further to combining multiple attributes. For example, we could consider
    both zip code and age as the attributes. In that case, the anonymized dataset
    should always have 19 other individuals sharing the same age and zip code, which
    makes re-identification much harder than in the previous case.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个相同的团体保险委员会数据集，我们正在查看该数据集中的邮编，并将 *k* 设置为20。如果我们查看该数据集中的任何个人，我们应该始终找到19个其他人与之共享相同的邮编。底线是，我们仅通过引用他们的邮编就无法具体识别个人。同样的概念可以进一步扩展到结合多个属性。例如，我们可以考虑邮编和年龄作为属性。在这种情况下，匿名化数据集应该始终有19个其他人与之共享相同的年龄和邮编，这使得重新识别比前一种情况更困难。
- en: The dataset in table 6.1 is 2-anonymous, where every combination of values (in
    this case, zip code and age) appears at least *k* = 2 times.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.1中的数据集是2匿名化的，其中每个值（在这种情况下，邮编和年龄）的组合至少出现 *k* = 2 次。
- en: Table 6.1 An example 2-anonymous dataset where every combination of zip code
    and age appears at least twice
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.1 一个示例2匿名化数据集，其中邮编和年龄的每个组合至少出现两次
- en: '| Zip code | Age |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 邮编 | 年龄 |'
- en: '| 33617 | 24 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 33617 | 24 |'
- en: '| 33620 | 35 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 33620 | 35 |'
- en: '| 33620 | 35 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 33620 | 35 |'
- en: '| 33617 | 24 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 33617 | 24 |'
- en: '| 33620 | 35 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 33620 | 35 |'
- en: How to make a synthetic dataset *k*-anonymous
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如何制作合成数据集 *k*-匿名
- en: 'There are two different techniques that can be used to make an original dataset
    *k*-anonymous: generalization and suppression.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种不同的技术可以用来使原始数据集 *k*-匿名：泛化和抑制。
- en: In generalization, the main idea is to make a value less precise so that records
    with different values are generalized into records that share the same values.
    Let’s consider the original dataset shown in table 6.2 and the 2-anonymous version
    shown in table 6.3.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在泛化中，主要思想是使一个值不那么精确，以便具有不同值的记录被泛化为具有相同值的记录。让我们考虑表6.2中显示的原始数据集和表6.3中显示的2匿名化版本。
- en: Table 6.2 The original dataset
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.2 原始数据集
- en: '| Zip code | Age |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 邮编 | 年龄 |'
- en: '| 33617 | 24 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 33617 | 24 |'
- en: '| 23620 | 41 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 33620 | 41 |'
- en: '| 23622 | 43 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 23622 | 43 |'
- en: '| 33617 | 29 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 33617 | 29 |'
- en: Table 6.3 The 2-anonymous version of the dataset in table 6.2
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.3 表6.2中数据集的2匿名化版本
- en: '| Zip code | Age |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 邮编 | 年龄 |'
- en: '| 33617 | 20-29 |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 33617 | 20-29 |'
- en: '| 33617 | 20-29 |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 33617 | 20-29 |'
- en: '| 236** | 40-49 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 236** | 40-49 |'
- en: '| 236** | 40-49 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 236** | 40-49 |'
- en: Suppose table 6.2 represents the original dataset we are interested in, and
    we need to transform it to its 2-anonymous version. In this case, we can transform
    the numerical values in the dataset into numerical ranges so that the resulting
    table verifies 2-anonymity, as shown in table 6.3.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 假设表6.2代表我们感兴趣的原始数据集，我们需要将其转换为它的2匿名化版本。在这种情况下，我们可以将数据集中的数值转换为数值范围，以便结果表验证2匿名性，如表6.3所示。
- en: As you can see, even after the anonymization process, the resultant values are
    still relatively close to the original values in the dataset. For example, age
    24 became the range of 20 to 29, but it is still close to the original.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，即使在匿名化过程之后，结果值仍然相对接近数据集中的原始值。例如，年龄24变成了20到29的范围，但它仍然很接近原始值。
- en: Now let’s consider table 6.4\. Here the first four records can simply be converted
    to their 2-anonymous versions. But the last record is an outlier. If we try to
    group it with one of the pairs, the result would have a very large range of values.
    For instance, age would range from 10 to 49, while the zip code would be completely
    removed. Hence, the simplest solution is to remove the outlier from the dataset
    and keep the rest of the records. That process is called *suppression*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑表6.4。在这里，前四条记录可以简单地转换为它们的2-匿名版本。但最后一条记录是一个异常值。如果我们尝试将它与一对中的一对组合，结果将会有一个非常大的值范围。例如，年龄的范围将从10到49岁，而邮编将完全被删除。因此，最简单的解决方案是从数据集中删除异常值，并保留其余的记录。这个过程被称为*抑制*。
- en: Table 6.4 An example dataset with an outlier. As you can see, age 12 in the
    last row is an outlier.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.4 一个包含异常值的示例数据集。正如您所看到的，最后一行的12岁年龄是一个异常值。
- en: '| Zip code | Age |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 邮编 | 年龄 |'
- en: '| 33617 | 24 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 33617 | 24 |'
- en: '| 23620 | 41 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 23620 | 41 |'
- en: '| 23622 | 43 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 23622 | 43 |'
- en: '| 33617 | 29 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 33617 | 29 |'
- en: '| 19352 | 12 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 19352 | 12 |'
- en: At a high level, this is how we can apply *k*-anonymity for a dataset to produce
    an anonymized (or synthetic) dataset. We will be discussing more detailed examples
    and techniques in chapter 7, along with hands-on exercises.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，这是我们如何将*k*-匿名应用于数据集以生成匿名（或合成）数据集的方法。我们将在第7章中讨论更多详细示例和技术，以及实际操作练习。
- en: As you can see, by generalizing and suppressing the data, *k*-anonymity makes
    privacy leakage difficult. However, it has some drawbacks, which we will discuss
    next.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，通过泛化和抑制数据，*k*-匿名性使得隐私泄露变得困难。然而，它也有一些缺点，我们将在下面讨论。
- en: 6.2.3 Anonymization beyond k-anonymity
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.3 超越k-匿名化的匿名化
- en: While *k*-anonymity makes it harder to re-identify records, it also has some
    drawbacks. For example, suppose all individuals in a dataset share the same value
    for the attributes in consideration. In such a case, that information may be revealed
    simply by knowing that these individuals are part of the dataset.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然*k*-匿名性使得重新识别记录变得更加困难，但它也有一些缺点。例如，假设数据集中的所有个体在考虑的属性上都有相同的值。在这种情况下，仅通过知道这些个体是数据集的一部分，就可能泄露这些信息。
- en: Let’s consider the dataset in table 6.5\. As you can see, it is already 2-anonymized,
    but what if Bob lives in the 33620 zip code and knows that his neighbor recently
    went for a medical appointment? Bob might deduce that his neighbor has heart disease.
    Therefore, even though Bob cannot distinguish which record belongs to his neighbor
    (thanks to *k*-anonymity), he can still infer which disease his neighbor has.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑表6.5中的数据集。正如您所看到的，它已经进行了2-匿名化，但假设鲍勃住在33620邮编，并且知道他的邻居最近去做了医疗预约？鲍勃可能会推断出他的邻居患有心脏病。因此，尽管鲍勃不能区分哪条记录属于他的邻居（多亏了*k*-匿名），但他仍然可以推断出他的邻居患有哪种疾病。
- en: Table 6.5 Even with a *k*-anonymized dataset, it is possible to leak some information.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.5 即使是*k*-匿名化的数据集，也可能泄露一些信息。
- en: '| Zip code | Age | Disease |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 邮编 | 年龄 | 疾病 |'
- en: '| 33617 | 20-29 | Cancer |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 33617 | 20-29 | 癌症 |'
- en: '| 33617 | 20-29 | Viral infection |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 33617 | 20-29 | 传染病 |'
- en: '| 33620 | 40-49 | Heart disease |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 33620 | 40-49 | 心脏病 |'
- en: '| 33620 | 40-49 | Heart disease |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 33620 | 40-49 | 心脏病 |'
- en: This problem can usually be solved by increasing the diversity of the sensitive
    values within the equivalence group. Here comes *l*-diversity, an extension of
    *k*-anonymity to provide privacy protection. The basic approach of *l*-diversity
    is to ensure that each group has at least *l* distinct sensitive values so that
    it is hard to identify an individual or the sensitive attribute. The same dataset
    can be *l*-diversified by increasing the diversity of the records, as shown in
    table 6.6.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，可以通过增加等价组内敏感值的多样性来解决此问题。这就是*l*-多样性，它是*k*-匿名的一个扩展，用于提供隐私保护。*l*-多样性的基本方法是确保每个组至少有*l*个不同的敏感值，这样就可以很难识别个人或敏感属性。可以通过增加记录的多样性来对相同的数据库进行*l*-多样性处理，如表6.6所示。
- en: Table 6.6 The diversity of records can be increased to protect against situations
    where *k*-anonymity does not work.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.6 记录的多样性可以通过增加来保护那些*k*-匿名不起作用的情况。
- en: '| Zip code | Age | Disease |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 邮编 | 年龄 | 疾病 |'
- en: '| 33*** | 20-29 | Cancer |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 33*** | 20-29 | 癌症 |'
- en: '| 33*** | 20-29 | Viral infection |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 33*** | 20-29 | 传染病 |'
- en: '| 33*** | 40-49 | Heart disease |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 33*** | 40-49 | 心脏病 |'
- en: '| 33*** | 40-49 | Heart disease |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 33*** | 40-49 | 心脏病 |'
- en: As you can see, compared to table 6.5, table 6.6 is now 2-diverse (*l* = 2),
    and Bob cannot distinguish whether his neighbor has cancer, a viral infection,
    or heart disease. However, *l*-diversity may still not work in some situations.
    What if Bob knows that his neighbor is in his early 40s? Now he might be able
    to reduce his search space to the last two rows of table 6.6, and he will know
    that the neighbor has heart disease. If we need to mitigate that, we can generalize
    the age column again so that it ranges from 20 to 49\. However, that would significantly
    reduce the utility of the resulting data. We will discuss how *l*-diversity can
    be used in different scenarios with hands-on exercises in chapter 8.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，与表6.5相比，表6.6现在具有2-多样性（*l* = 2），鲍勃无法区分他的邻居是否患有癌症、病毒感染或心脏病。然而，*l*-多样性在某些情况下可能仍然不起作用。如果鲍勃知道他的邻居40岁出头呢？现在他可能能够将搜索空间缩小到表6.6的最后两行，并且他会知道邻居患有心脏病。如果我们需要减轻这种情况，我们可以再次泛化年龄列，使其范围从20岁到49岁。然而，这将显著降低结果数据的有用性。我们将在第8章通过实际练习讨论如何在不同的场景中使用*l*-多样性。
- en: The fundamental tradeoff between utility and privacy (an inverse relationship)
    is always a concern for data anonymization. To that end, synthetic data generation
    using other approaches is a viable next-step solution to this problem. In essence,
    we will use the original dataset to train an ML model, and then use that model
    to produce more realistic yet synthetic data with the same statistical properties
    as the underlying real data. In the next section we’ll look at what techniques
    we can use to generate the synthetic data.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 效用与隐私（一种反向关系）之间的基本权衡始终是数据匿名化的一个关注点。为此，使用其他方法生成合成数据是解决该问题的可行下一步解决方案。本质上，我们将使用原始数据集来训练一个机器学习模型，然后使用该模型生成具有与底层真实数据相同统计特性的更真实但合成的数据。在下一节中，我们将探讨我们可以使用哪些技术来生成合成数据。
- en: 6.3 DP for privacy-preserving synthetic data generation
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 用于隐私保护合成数据生成的差分隐私（DP）
- en: In the previous section we discussed generating synthetic data by using data
    anonymization techniques. In this section we’ll look at applying DP for synthetic
    data generation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了通过使用数据匿名化技术生成合成数据。在本节中，我们将探讨在合成数据生成中应用差分隐私（DP）。
- en: Let’s consider the following data-sharing scenario. Suppose company A has collected
    a lot of data about its customers (age, occupation, marital status, etc.), and
    they want to conduct a business analysis on that data to optimize the company’s
    spending and sales. However, company A does not have the ability to do this analysis.
    They would like to outsource this task to a third-party operator, company B. However,
    company A cannot share the original data with company B due to critical privacy
    reasons. Hence, company A wants to generate a synthetic dataset that retains the
    statistical properties of the original dataset without leaking any private information.
    They can then share the synthetic dataset with company B for further analysis.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下数据共享场景。假设公司A收集了大量关于其客户（年龄、职业、婚姻状况等）的数据，并且他们想对这些数据进行商业分析以优化公司的支出和销售。然而，由于关键的隐私原因，公司A没有进行这种分析的能力。他们希望将这项任务外包给第三方运营商，公司B。但是，由于关键的隐私原因，公司A不能与公司B共享原始数据。因此，公司A希望生成一个合成数据集，该数据集保留了原始数据集的统计特性，而不泄露任何私人信息。然后，他们可以将合成数据集与公司B共享，以进行进一步的分析。
- en: In such scenarios, company A has two synthetic data generation and sharing options.
    First, they can generate synthetic data representations of the original dataset,
    such as histograms, probability distributions, mean/median values, or standard
    deviations. Although such synthetic data representations can reflect certain properties
    of the original data, they do not have the same “shape” (i.e., the number of features
    and number of samples) as the original data. If the data analysis process requires
    specific or more complex and customizable algorithms (such as ML or deep learning
    algorithms), just providing synthetic data representations of the original data
    cannot fulfill those data requirements. For instance, most ML or deep learning
    algorithms are required to run directly on the feature vectors of the datasets
    rather than on statistics (such as mean or standard deviation) of the datasets.
    Thus, the second option, which is more general and flexible, is to provide a synthetic
    dataset that maintains the same statistical properties as the original dataset
    and has the same shape.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，公司A有两个合成数据生成和共享选项。首先，他们可以生成原始数据集的合成数据表示，例如直方图、概率分布、均值/中位数或标准差。尽管这样的合成数据表示可以反映原始数据的一些属性，但它们与原始数据不具有相同的“形状”（即特征数量和样本数量）。如果数据分析过程需要特定的或更复杂且可定制的算法（如机器学习或深度学习算法），仅仅提供原始数据的合成数据表示无法满足这些数据需求。例如，大多数机器学习或深度学习算法都需要直接在数据集的特征向量上运行，而不是在数据集的统计数据（如均值或标准差）上运行。因此，第二种选项，即更通用和灵活的选项，是提供一个保持与原始数据集相同统计属性且具有相同形状的合成数据集。
- en: In the rest of this section we’ll use a histogram as an example data representation
    to demonstrate how you can generate a synthetic data representation that satisfies
    DP. We will also examine how to use the DP synthetic data representation to generate
    differentially private synthetic data.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的剩余部分，我们将使用直方图作为示例数据表示，以展示如何生成满足差分隐私（DP）的合成数据表示。我们还将探讨如何使用DP合成数据表示来生成差异隐私合成数据。
- en: 6.3.1 DP synthetic histogram representation generation
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.1 DP合成直方图表示生成
- en: Let’s continue with our previous data-sharing scenario. Suppose our outsourced
    company B wants to know how many company A customers are within a given age range.
    A straightforward solution would be to provide company B with a count query function
    that could directly query the original data of company A.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续我们之前的数据共享场景。假设我们的外包公司B想了解在特定年龄范围内的公司A客户数量。一个直接的方法就是向公司B提供一个计数查询函数，该函数可以直接查询公司A的原始数据。
- en: Let’s use the US Census dataset as an example and load it as shown in the following
    listing.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以美国人口普查数据集为例，并按以下列表加载它。
- en: Listing 6.1 Loading the US Census dataset
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.1 加载美国人口普查数据集
- en: '[PRE0]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Load data.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 加载数据。
- en: You will get results like those in figure 6.3.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到如图6.3所示的结果。
- en: '![CH06_F03_Zhuang_TEMP](../../OEBPS/Images/CH06_F03_Zhuang_TEMP.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F03_Zhuang_TEMP](../../OEBPS/Images/CH06_F03_Zhuang_TEMP.png)'
- en: Figure 6.3 A snapshot of the US Census dataset
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 美国人口普查数据集快照
- en: Now let’s implement a count query to count the number of people within a given
    age range. In this example, we’ll look for the number of people within the age
    range 44 to 55.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现一个计数查询来计算特定年龄范围内的人数。在这个例子中，我们将寻找年龄在44到55岁之间的人数。
- en: Listing 6.2 Implementing a count query
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.2 实现计数查询
- en: '[PRE1]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ The ages of people
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 人群的年龄
- en: ❷ Count the number of people within certain age ranges [lo, hi).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 计算特定年龄范围内的人数 [lo, hi)。
- en: You will find that there are 6,577 people in this dataset within the age range
    of 44 to 55\. At this point, we could add the DP perturbation mechanisms to the
    output of the count query to fulfill the requirement of company B. However, such
    an implementation can only satisfy the requirement of company B for a one-time
    count query on the original data of company A. In reality, company B will not
    use this count query only once. As we discussed in chapter 2, increasing the number
    of differentially private queries on the same dataset means we need to either
    increase the overall privacy budget, which means tolerating more privacy leakage
    from the original dataset, or add more noise to the output of the queries, which
    results in downgrading the accuracy.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现在这个数据集中，44至55岁年龄范围内有6,577人。在这个时候，我们可以将DP扰动机制添加到计数查询的输出中，以满足公司B的需求。然而，这种实现只能满足公司B对公司A原始数据的一次性计数查询需求。在现实中，公司B不会只使用一次这个计数查询。正如我们在第2章中讨论的，增加同一数据集上的不同隐私查询次数意味着我们需要增加整体隐私预算，这意味着容忍更多来自原始数据集的隐私泄露，或者向查询输出添加更多噪声，这会导致精度下降。
- en: How can we improve this solution to cater to the requirements? The answer is
    to provide a differentially private synthetic data representation of the original
    data rather than a differentially private query function. Here we can use a synthetic
    histogram to represent the original data and provide enough information for a
    count query. First, let’s implement a synthetic histogram generator using our
    previously defined count query.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何改进这个解决方案以满足需求？答案是提供原始数据的不同隐私合成数据表示，而不是不同隐私查询函数。在这里，我们可以使用合成直方图来表示原始数据，并为计数查询提供足够的信息。首先，让我们使用之前定义的计数查询实现一个合成直方图生成器。
- en: Listing 6.3 Synthetic histogram generator
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.3合成直方图生成器
- en: '[PRE2]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ The domain of ages
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 年龄的域
- en: ❷ Create the histogram of ages using the age count query.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用年龄计数查询创建年龄直方图。
- en: You will get a histogram like the one in figure 6.4\. The output shown here
    is the histogram generated using the age count query in listing 6.2\. As you can
    see, it shows how many people are in this dataset for each age.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到一个类似于图6.4的直方图。这里显示的是使用列表6.2中的年龄计数查询生成的直方图。正如你所见，它显示了每个年龄段在这个数据集中有多少人。
- en: '![CH06_F04_Zhuang](../../OEBPS/Images/CH06_F04_Zhuang.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F04_Zhuang](../../OEBPS/Images/CH06_F04_Zhuang.png)'
- en: Figure 6.4 Histogram showing the number of people for each age
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4显示每个年龄段人数的直方图
- en: Let’s call this a synthetic histogram or synthetic data representation. Remember,
    we have not generated any synthetic data yet—this is the “representation” that
    we will use to generate synthetic data.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们称这个为合成直方图或合成数据表示。记住，我们还没有生成任何合成数据——这是我们将用来生成合成数据的“表示”。
- en: Let’s now use this histogram to create the count query.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用这个直方图来创建计数查询。
- en: Listing 6.4 Implementing a count query using a synthetic histogram generator
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.4使用合成直方图生成器实现计数查询
- en: '[PRE3]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Generate synthetic count query results from the synthetic histogram of ages.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从年龄的合成直方图中生成合成计数查询结果。
- en: The output from the synthetically produced data will be 6,577\. As you can see,
    the result generated by the synthetic histogram data representation is the same
    as the result produced using the previous count query on the original data. The
    point here is that we don’t always need the original data to query or infer some
    information. If we can get a synthetic data representation of the original data,
    that is sufficient for us to answer some of the queries.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 从合成数据产生的输出将是6,577。正如你所见，由合成直方图数据表示生成的结果与使用之前在原始数据上进行的计数查询生成的结果相同。这里的要点是，我们并不总是需要原始数据来查询或推断某些信息。如果我们能获得原始数据的一个合成数据表示，这足以让我们回答一些查询。
- en: In listing 6.3 we used the original data to generate the histogram. Now let’s
    implement a differentially private synthetic histogram generator using the Laplace
    mechanism (with sensitivity and epsilon both equal to 1.0).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表6.3中，我们使用原始数据生成了直方图。现在，让我们使用拉普拉斯机制（敏感度和epsilon都等于1.0）实现一个不同隐私合成直方图生成器。
- en: Listing 6.5 Adding the Laplace mechanism
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.5添加拉普拉斯机制
- en: '[PRE4]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ The Laplace mechanism for DP
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ DP的拉普拉斯机制
- en: ❷ Generate a differentially private synthetic histogram.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 生成一个差分隐私合成直方图。
- en: The result is shown in figure 6.5\. Let’s call this a differentially private
    synthetic histogram data representation. Observe the pattern of this histogram
    and the one in figure 6.4\. Do you see any difference? The two look very similar,
    but this one was not generated using the original dataset. Instead, we used the
    Laplace mechanism (DP) to generate the data.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如图 6.5 所示。让我们称这为差分隐私合成直方图数据表示。观察这个直方图和图 6.4 中的直方图的模式。你看到任何区别吗？这两个看起来非常相似，但这个并不是使用原始数据集生成的。相反，我们使用了拉普拉斯机制（DP）来生成数据。
- en: '![CH06_F05_Zhuang](../../OEBPS/Images/CH06_F05_Zhuang.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F05_Zhuang](../../OEBPS/Images/CH06_F05_Zhuang.png)'
- en: Figure 6.5 A differentially private synthetic histogram
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 一个差分隐私合成直方图
- en: Now the question is, “If we run the count query, will this give us the same
    result?” Let’s generate a count query result with the differentially private synthetic
    histogram, given the same inputs.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，“如果我们运行计数查询，这会给我们相同的结果吗？”让我们在相同的输入下，使用差分隐私合成直方图生成一个计数查询结果。
- en: Listing 6.6 Differentially private count query
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.6 差分隐私计数查询
- en: '[PRE5]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Generate a differentially private count query result using the differentially
    private synthetic histogram.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用差分隐私合成直方图生成一个差分隐私计数查询结果。
- en: You will get output something like 6,583.150,999,026,576.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到类似 6,583.150,999,026,576 的输出。
- en: Note Since this is a random function, you will get a different result, but it
    should be close to this value.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：由于这是一个随机函数，你将得到不同的结果，但应该接近这个值。
- en: As you can see, the result is still very similar to the previous ground truth
    result. In other words, the differentially private synthetic histogram data representation
    can fulfill the data-sharing requirements of company B while still protecting
    the privacy requirements of company A because we are using synthetically produced
    data rather than the original data.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，结果仍然与之前的真实结果非常相似。换句话说，差分隐私合成直方图数据表示可以在满足公司 B 的数据共享要求的同时，仍然保护公司 A 的隐私要求，因为我们使用的是合成数据而不是原始数据。
- en: 6.3.2 DP synthetic tabular data generation
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.2 DP 合成表格数据生成
- en: In the previous section we saw how to enable privacy-preserving data sharing
    using differentially private synthetic data representations. But what if company
    B wants to conduct even more complex data analytics approaches, such as ML or
    deep learning algorithms, that require using a dataset with the same shape as
    the original one? In this case, we need to generate synthetic data with the same
    shape as the original data, again from the synthetic data representation.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了如何使用差分隐私合成数据表示来启用隐私保护的数据共享。但是，如果公司 B 想要执行更复杂的数据分析方法，例如机器学习或深度学习算法，这些方法需要使用与原始数据集相同形状的数据集，那会怎样呢？在这种情况下，我们需要再次从合成数据表示中生成与原始数据相同形状的合成数据。
- en: In our example, the US Census dataset contains tabular data. To generate synthetic
    tabular data with the same shape, we could use the synthetic histogram as a probability
    distribution representing the underlying distribution of the original data. We
    could then use this synthetic histogram to generate synthetic tabular data.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，美国人口普查数据集包含表格数据。为了生成具有相同形状的合成表格数据，我们可以使用合成直方图作为表示原始数据潜在分布的概率分布。然后我们可以使用这个合成直方图来生成合成表格数据。
- en: Simply put, given a histogram, we can treat the sum of the counts of all the
    histogram bins as the total. For each histogram bin, we can use its count divided
    by the total to represent the probability that a sample fell into that histogram
    bin. Once we have those probabilities, we can easily sample a synthetic dataset
    using the histogram and the domain of its bins.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，给定一个直方图，我们可以将所有直方图区间的计数总和视为总数。对于每个直方图区间，我们可以使用其计数除以总数来表示样本落在该直方图区间的概率。一旦我们有了这些概率，我们就可以使用直方图及其区间的域轻松地采样合成数据集。
- en: Suppose we already have a differentially private synthetic histogram. We then
    need to preprocess the synthetic histogram to ensure that all the counts are non-negative
    and normalized. That means the count of each bin should be a probability (they
    should sum to 1.0). The following listing shows the preprocessing and normalization
    operation.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经有了一个差分隐私合成直方图。然后我们需要预处理合成直方图，以确保所有计数都是非负的并且归一化。这意味着每个区间的计数应该是一个概率（它们应该加起来为
    1.0）。以下列表显示了预处理和归一化操作。
- en: Listing 6.7 Preprocessing and normalization operation
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.7 预处理和归一化操作
- en: '[PRE6]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The probability histogram may look like figure 6.6.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 概率直方图可能看起来像图6.6。
- en: '![CH06_F06_Zhuang](../../OEBPS/Images/CH06_F06_Zhuang.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F06_Zhuang](../../OEBPS/Images/CH06_F06_Zhuang.png)'
- en: Figure 6.6 A normalized differentially private synthetic histogram
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 一个归一化的差分隐私合成直方图
- en: As you can see, the *y*-axis of this histogram is now normalized, but it still
    has the same shape as the input differentially private synthetic histogram in
    figure 6.5.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个直方图的y轴现在已归一化，但它仍然与图6.5中输入的差分隐私合成直方图具有相同的形状。
- en: Now let’s generate the differentially private synthetic tabular data.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们生成差分隐私合成表格数据。
- en: Listing 6.8 Generating the differentially private synthetic tabular data
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.8 生成差分隐私合成表格数据
- en: '[PRE7]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The results are shown in figure 6.7\. Remember, this is a random function, so
    your results will be different.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示在图6.7中。记住，这是一个随机函数，所以你的结果可能会有所不同。
- en: '![CH06_F07_Zhuang](../../OEBPS/Images/CH06_F07_Zhuang.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F07_Zhuang](../../OEBPS/Images/CH06_F07_Zhuang.png)'
- en: Figure 6.7 A sample set of differentially private synthetic tabular data
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 一组差分隐私合成表格数据的样本集
- en: 'What are we doing in listing 6.8? We generated ten different synthetic data
    records using the normalized synthetic histogram that we produced in listing 6.7\.
    That means we generated completely new synthetic data records using the properties
    of the normalized synthetic histogram. Now we have two different datasets: the
    original dataset and the synthetically produced dataset.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.8中我们在做什么？我们使用列表6.7中生成的归一化合成直方图生成了十个不同的合成数据记录。这意味着我们使用归一化合成直方图的性质生成了全新的合成数据记录。现在我们有两个不同的数据集：原始数据集和合成生成数据集。
- en: Now let’s compare the statistical properties of the synthetic data and the original
    data using histograms, as shown in listings 6.9 and 6.10.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用直方图来比较合成数据和原始数据的统计特性，如图6.9和6.10所示。
- en: Listing 6.9 The histogram of the synthetic data
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.9 合成数据的直方图
- en: '[PRE8]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code produces a histogram of the synthetic data as shown in figure 6.8.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码生成如图6.8所示的合成数据的直方图。
- en: '![CH06_F08_Zhuang](../../OEBPS/Images/CH06_F08_Zhuang.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F08_Zhuang](../../OEBPS/Images/CH06_F08_Zhuang.png)'
- en: Figure 6.8 A histogram produced using synthetic tabular data generation
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 使用合成表格数据生成产生的直方图
- en: To make a comparison, let’s generate a histogram of the original data.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行比较，让我们生成原始数据的直方图。
- en: Listing 6.10 The histogram of the original data
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.10 原始数据的直方图
- en: '[PRE9]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The result may look like figure 6.9.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可能看起来像图6.9。
- en: '![CH06_F09_Zhuang](../../OEBPS/Images/CH06_F09_Zhuang.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F09_Zhuang](../../OEBPS/Images/CH06_F09_Zhuang.png)'
- en: Figure 6.9 A histogram of the original data
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9 原始数据的直方图
- en: If you compare the shapes of the histograms in figures 6.8 and 6.9, you’ll see
    that they are extremely similar. In other words, the synthetic data that we produced
    has the same statistical properties as the original data. Interesting, isn’t it?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你比较图6.8和6.9中的直方图形状，你会发现它们非常相似。换句话说，我们生成的合成数据具有与原始数据相同的统计特性。有趣，不是吗？
- en: 6.3.3 DP synthetic multi-marginal data generation
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.3 DP合成多边际数据生成
- en: The last section introduced an approach for generating privacy-preserving single-
    column synthetic tabular data from a synthetic histogram data representation using
    DP. But most real-world datasets consist of multiple-column tabular data. How
    can we tackle this problem?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节介绍了一种使用DP从合成直方图数据表示生成隐私保护的单列合成表格数据的方法。但大多数现实世界的数据集由多列表格数据组成。我们该如何解决这个问题？
- en: A straightforward solution is to generate synthetic data for each column of
    a multiple-column tabular data using our previously described approach and then
    combine all the synthetic single-column tabular data together. This solution looks
    easy, but it does not reflect the correlations between those columns. For instance,
    in the US Census dataset, age and marital status are intuitively highly correlated
    to each other. What should we do in such cases?
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '一个简单的解决方案是使用我们之前描述的方法为多列表格数据的每一列生成合成数据，然后将所有合成的单列表格数据组合在一起。这个解决方案看起来很简单，但它并没有反映这些列之间的相关性。例如，在美国人口普查数据集中，年龄和婚姻状况直观上高度相关。在这种情况下我们该怎么办？ '
- en: We could consider multiple columns altogether. For instance, we could count
    how many people are 18 years old and never married, how many are 45 years old
    and divorced, how many are 90 years old and become widows, and so forth. Then
    we could calculate the probability of each case using the previous approach and
    sample the synthetic data from the simulated probability distribution. We’ll call
    this result *synthetic multi-marginal data*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以考虑同时考虑多个列。例如，我们可以计算有多少人是18岁且从未结婚，有多少人是45岁且离婚，有多少人是90岁且成为寡妇，等等。然后我们可以使用之前的方法计算每种情况的可能性，并从模拟的概率分布中采样合成数据。我们将这个结果称为*合成多边缘数据*。
- en: Let’s implement this idea on the US Census dataset containing age and marital
    status.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在包含年龄和婚姻状况的美国人口普查数据集上实现这个想法。
- en: Listing 6.11 The 2-way marginal representation
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.11 2路边缘表示
- en: '[PRE10]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The 2-way marginal representation of the original dataset is shown in figure
    6.10\. Remember, column 0 is the age, and column 5 is the marital status. As you
    can see in the second row (index 1), 393 people are never married and age 17.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 原始数据集的2路边缘表示如图6.10所示。记住，列0是年龄，列5是婚姻状况。正如你在第二行（索引1）中看到的那样，有393人从未结婚且年龄为17岁。
- en: '![CH06_F10_Zhuang](../../OEBPS/Images/CH06_F10_Zhuang.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F10_Zhuang](../../OEBPS/Images/CH06_F10_Zhuang.png)'
- en: Figure 6.10 A snapshot of a 2-way marginal representation of the original dataset
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10 原始数据集的2路边缘表示快照
- en: We have 396 categories like this for each marital status and age combination.
    Once we generate a 2-way marginal dataset like this, we can use the Laplace mechanism
    to make it differentially private.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种婚姻状况和年龄组合，我们都有396个这样的类别。一旦我们生成这样的2路边缘数据集，我们就可以使用拉普拉斯机制使其具有差分隐私。
- en: Listing 6.12 The differentially private 2-way marginal representation
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.12 差分隐私的2路边缘表示
- en: '[PRE11]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The result of the 2-way marginal representation is shown in figure 6.11\. As
    you can see, we have generated a differentially private value for all 396 categories.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 2路边缘表示的结果如图6.11所示。正如你所看到的，我们已经为所有396个类别生成了一个差分隐私值。
- en: '![CH06_F11_Zhuang](../../OEBPS/Images/CH06_F11_Zhuang.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F11_Zhuang](../../OEBPS/Images/CH06_F11_Zhuang.png)'
- en: Figure 6.11 A snapshot of a differentially private 2-way marginal representation
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11 差分隐私的2路边缘表示快照
- en: Now we can use our proposed approach to generate synthetic multi-marginal data
    that includes age and marital status. The following listing uses the 2-way marginal
    representation produced in listing 6.12 to generate a synthetic dataset.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用我们提出的方法来生成包含年龄和婚姻状况的合成多边缘数据。以下列表使用列表6.12中产生的2路边缘表示来生成合成数据集。
- en: Listing 6.13 Generating synthetic multi-marginal data
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.13 生成合成多边缘数据
- en: '[PRE12]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The resulting synthetically produced 2-way marginal dataset is shown in figure
    6.12.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的合成2路边缘数据集如图6.12所示。
- en: '![CH06_F12_Zhuang](../../OEBPS/Images/CH06_F12_Zhuang.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F12_Zhuang](../../OEBPS/Images/CH06_F12_Zhuang.png)'
- en: Figure 6.12 A snapshot of a synthetically produced 2-way marginal dataset
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12 合成产生的2路边缘数据集快照
- en: Let’s compare the statistical properties of the synthetic data and the original
    data. First, let’s compare the histograms of the age data.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较合成数据和原始数据的统计特性。首先，让我们比较年龄数据的直方图。
- en: Listing 6.14 The histogram produced using synthetic multi-marginal data
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.14 使用合成多边缘数据生成的直方图
- en: '[PRE13]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The histogram of the synthetic data is shown in figure 6.13.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 合成数据的直方图如图6.13所示。
- en: '![CH06_F13_Zhuang](../../OEBPS/Images/CH06_F13_Zhuang.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F13_Zhuang](../../OEBPS/Images/CH06_F13_Zhuang.png)'
- en: Figure 6.13 A histogram produced using synthetically generated multi-marginal
    data
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13 使用合成多边缘数据生成的直方图
- en: To compare the results, we’ll use the following code (the same as in listing
    6.10) to generate a histogram of the original data.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较结果，我们将使用以下代码（与列表6.10中的代码相同）来生成原始数据的直方图。
- en: Listing 6.15 The histogram of the original data
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.15 原始数据的直方图
- en: '[PRE14]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The histogram of the original data is shown in figure 6.14\. By simply looking
    at their shapes and how data points are distributed, we can quickly conclude that
    the two histograms in figures 6.13 and 6.14 are similar.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 原始数据的直方图如图6.14所示。通过简单地观察它们的形状和数据点的分布情况，我们可以快速得出结论，图6.13和图6.14中的两个直方图是相似的。
- en: '![CH06_F14_Zhuang](../../OEBPS/Images/CH06_F14_Zhuang.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F14_Zhuang](../../OEBPS/Images/CH06_F14_Zhuang.png)'
- en: Figure 6.14 A histogram of the original data
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.14 原始数据的直方图
- en: We’ve looked at how age is distributed, but what about marital status? Let’s
    compare the distribution of the marital status data.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经研究了年龄的分布情况，但婚姻状况呢？让我们比较婚姻状况数据的分布。
- en: Listing 6.16 The statistics of the original data
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.16 原始数据的统计
- en: '[PRE15]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The results are shown in figure 6.15.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如图6.15所示。
- en: '![CH06_F15_Zhuang](../../OEBPS/Images/CH06_F15_Zhuang.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F15_Zhuang](../../OEBPS/Images/CH06_F15_Zhuang.png)'
- en: Figure 6.15 Summary of statistics of the original data
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15 原始数据统计概要
- en: The next listing will summarize marital status data in the original dataset.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表将总结原始数据集中的婚姻状况数据。
- en: Listing 6.17 The statistics of the synthetic data
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.17 合成数据的统计
- en: '[PRE16]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Figure 6.16 shows the summary of synthetically produced data. As you can see,
    the marital status of the differentially private synthetic multi-marginal data
    looks similar to the original data (but is not the same).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16显示了合成数据的概要。如图所示，不同隐私的合成多边际数据的婚姻状况看起来与原始数据相似（但并不相同）。
- en: '![CH06_F16_Zhuang](../../OEBPS/Images/CH06_F16_Zhuang.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F16_Zhuang](../../OEBPS/Images/CH06_F16_Zhuang.png)'
- en: Figure 6.16 Summary of statistics of the synthetically produced marital status
    data
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16 合成产生的婚姻状况数据统计概要
- en: Once again, we can conclude that instead of using the original data, we can
    use synthetically produced data to do the same tasks while preserving the privacy
    of the original data.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以得出结论，我们不必使用原始数据，可以使用合成的数据来完成同样的任务，同时保护原始数据的隐私。
- en: We have looked at generating synthetic histogram data representations that satisfy
    DP, and we have walked through using the differentially private synthetic histogram
    representations to generate privacy-preserving synthetic single-column tabular
    data and multi-marginal data. But wait! How can we deal with a large dataset with
    more than two or three columns and tons of records? We’ll find out the answers
    to that next. The next section will look at a more complex case study to demonstrate
    how we can apply data anonymization and DP for privacy-preserving synthetic data
    generation for ML.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经研究了生成满足DP的合成直方图数据表示，并且我们已经通过使用不同的私有合成直方图表示来生成隐私保护的合成单列表格数据和多边际数据。但是等等！我们如何处理包含两个或三个以上列和大量记录的大型数据集呢？我们将在下一部分找到答案。下一节将研究一个更复杂的案例研究，以展示我们如何应用数据匿名化和DP来为机器学习生成隐私保护的合成数据。
- en: 'Exercise 1: Try it yourself'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 练习1：自己试试
- en: In listing 6.11 we looked at a the 2-way marginal representation with age and
    marital status. As discussed, age and marital status are highly correlated, and
    we wanted to see whether the synthetically produced data also followed a similar
    distribution. Now try following the same steps for the education and occupation
    columns to see whether you have similar results.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表6.11中，我们查看了一个包含年龄和婚姻状况的2向边际表示。正如讨论的那样，年龄和婚姻状况高度相关，我们想看看合成的数据是否也遵循类似的分布。现在尝试按照相同的步骤对教育和职业列进行操作，看看你是否能得到相似的结果。
- en: 'Hint: In the original dataset, education is in column 3, and column 6 is the
    occupation. Start by changing the columns in listing 6.11 as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：在原始数据集中，教育信息位于第3列，第6列是职业。首先按照以下方式更改列表6.11中的列：
- en: '[PRE17]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Then follow all the steps.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按照所有步骤进行。
- en: 'Exercise 2: Try it yourself'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 练习2：自己试试
- en: Repeat the same process but for 3-way marginal representation with 3-column
    data. For example, you might consider age, occupation, and marital status as the
    3-way representation.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 重复相同的过程，但对于3列数据的3向边际表示。例如，你可能考虑年龄、职业和婚姻状况作为3向表示。
- en: 6.4 Case study on private synthetic data release via feature-level micro-aggregation
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 通过特征级微聚合发布私有合成数据的案例研究
- en: Now that we have discussed different approaches to generating synthetic data,
    let’s walk through a case study on designing a private synthetic data-release
    mechanism via a feature-level micro-aggregation method. Sound too technical? Don’t
    worry, we’ll go through the details step by step.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了生成合成数据的不同方法，让我们通过一个案例研究来了解如何通过特征级微聚合方法设计私有合成数据发布机制。听起来太技术了吗？不用担心，我们将一步一步地介绍细节。
- en: First, though, recall that DP is a mechanism that provides a strong privacy
    guarantee to protect individual data records (as we discussed in chapter 2). In
    this case study, we will discuss a privacy-preserving synthetic data generation
    method under DP guarantee that will work with multiple ML tasks. It was developed
    on differentially private generative models of clustered data to generate synthetic
    datasets. In the latter part of this section, we will show you how effective this
    method is compared to some existing approaches, and how it improved the utility
    compared to other methods.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，回忆一下DP（差分隐私）是一种机制，它为保护个人数据记录提供强大的隐私保障（正如我们在第2章所讨论的）。在本案例研究中，我们将讨论一种在DP保障下工作的隐私保护合成数据生成方法，该方法适用于多个机器学习任务。它是基于聚类数据的差分隐私生成模型来生成合成数据集。在本节的下半部分，我们将向您展示这种方法与一些现有方法相比的有效性，以及它如何与其他方法相比提高了效用。
- en: Before we look at the details of the case study, let’s first recap some of the
    basics. Usually, designing a powerful privacy-preserving synthetic data generation
    method for ML comes with many challenges. First, a privacy-preserving method usually
    introduces perturbation to data samples that hurts the utility of the data. Mitigating
    the perturbation so that you reach a certain level of utility is not an easy task.
    Second, ML can be represented in many different tasks, like classification, regression,
    and clustering. An effective synthetic data generation method should be applicable
    to all these various tasks. Third, some data can come in the form of very complex
    distributions. In that case, it is hard to form an accurate generator based on
    the whole data distribution.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看案例研究的细节之前，让我们首先回顾一些基础知识。通常，为机器学习设计一个强大的隐私保护合成数据生成方法会带来许多挑战。首先，隐私保护方法通常会向数据样本引入扰动，这会损害数据的效用。减轻扰动以达到一定程度的效用不是一项容易的任务。其次，机器学习可以表示为许多不同的任务，如分类、回归和聚类。一个有效的合成数据生成方法应该适用于所有这些不同的任务。第三，一些数据可能以非常复杂的分布形式出现。在这种情况下，很难基于整个数据分布形成一个准确的生成器。
- en: In the past, people have proposed several private synthetic data-release algorithms
    [4], [5]. One of the common approaches is to utilize noisy histograms to release
    synthetic data, but most of them are designed to work with categorical feature
    variables. On the other hand, some algorithms are designed to generate synthetic
    data under a statistical model with some preprocessing on the original dataset.
    However, they usually only generate synthetic data based on the whole data distribution.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，人们已经提出了几种私有合成数据发布算法[4]，[5]。其中一种常见的方法是利用噪声直方图发布合成数据，但大多数都是为处理分类特征变量而设计的。另一方面，一些算法旨在在原始数据集上进行一些预处理后，在统计模型下生成合成数据。然而，它们通常只基于整个数据分布生成合成数据。
- en: In this study, we will focus on how we can generate synthetic data while maintaining
    statistical characteristics similar to the original dataset while ensuring data
    owners have no privacy concerns.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这项研究中，我们将关注如何在保持与原始数据集相似的统计特征的同时生成合成数据，同时确保数据所有者没有隐私担忧。
- en: Now that you have a basic understanding of what we’re going to do, let’s dig
    into the details.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你对我们要做什么有了基本的了解，让我们深入细节。
- en: 6.4.1 Using hierarchical clustering and micro-aggregation
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.1 使用分层聚类和微聚合
- en: An essential part of our methodology that we’ll build on is *hierarchical clustering*.
    In essence, hierarchical clustering is an algorithm that clusters input samples
    into different clusters based on the *proximity matrix* of samples. This proximity
    matrix represents the distance between each cluster. In this case, we’ll use *agglomerative
    hierarchical clustering* [6], a bottom-up approach, which starts by assigning
    each data sample to its own group and merging the pairs of clusters that have
    the smallest distance, until there is only a single cluster left.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们方法论的一个关键部分，我们将在此基础上构建，是*分层聚类*。本质上，分层聚类是一种算法，它根据样本的*邻近矩阵*将输入样本聚类到不同的簇中。这个邻近矩阵表示每个簇之间的距离。在这种情况下，我们将使用*聚合分层聚类*
    [6]，这是一种自下而上的方法，它首先将每个数据样本分配到它自己的组中，然后合并距离最小的簇对，直到只剩下一个簇为止。
- en: As discussed in section 6.2, *k*-anonymity can be used to anonymize data. Here,
    we will use a data anonymization algorithm called *micro-aggregation* that can
    achieve *k*-anonymity. The micro-aggregation approach we are referring to here
    is a simple heuristic method called *maximum distance to average record* (MDAV)
    proposed by Domingo-Ferrer et al. [7]. The idea is to separate samples into clusters,
    and each cluster contains exactly *k* records except the last one. Records in
    the same cluster are supposed to be as similar as possible in terms of distance.
    In addition, each record in the cluster will be replaced by a representative record
    for the cluster to complete the data anonymization.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如第6.2节所述，*k-匿名性*可以用来匿名化数据。在这里，我们将使用一种名为*微聚合*的数据匿名化算法来实现*k-匿名性*。我们这里提到的微聚合方法是一种简单的启发式方法，称为*最大距离到平均记录*（MDAV），由Domingo-Ferrer等人[7]提出。其想法是将样本分为簇，每个簇包含恰好*k*条记录（除了最后一个），簇中的记录在距离上应尽可能相似。此外，簇中的每条记录将被替换为该簇的代表记录以完成数据匿名化。
- en: 6.4.2 Generating synthetic data
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.2 生成合成数据
- en: 'In this synthetic data generation mechanism, four main components operate collectively
    to generate synthetic data that satisfies DP:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个合成数据生成机制中，四个主要组件共同作用以生成满足DP的合成数据：
- en: '*Data preprocessing*—Combines independent feature sets and feature-level micro-aggregation
    to produce data clusters that describe the data more generally.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据预处理*—结合独立特征集和特征级微聚合来生成描述数据更通用的数据簇。'
- en: '*Statistic extraction*—Extracts the representative statistical information
    of each data cluster.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*统计提取*—提取每个数据簇的代表统计信息。'
- en: '*DP sanitizer*—Adds differential private noise on extracted statistical information.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*DP净化器*—在提取的统计信息上添加差分隐私噪声。'
- en: '*Data generator*—Generates synthetic data sample by sample from the perturbed
    generative model.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据生成器*—通过扰动生成模型逐个生成合成数据样本。'
- en: These four components are shown in figure 6.17.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个组件在图6.17中展示。
- en: '![CH06_F17_Zhuang](../../OEBPS/Images/CH06_F17_Zhuang.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F17_Zhuang](../../OEBPS/Images/CH06_F17_Zhuang.png)'
- en: Figure 6.17 Different components of the synthetic data generation algorithm
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17 合成数据生成算法的不同组件
- en: How data preprocessing works
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 数据预处理的工作原理
- en: In data preprocessing, we use micro-aggregation as the clustering method for
    samples in full feature dimension (samples that cover all the features we are
    interested in). Instead of replacing records with a representative record, we
    will use a differentially private generative model to model each cluster. However,
    there are a few challenges here.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据预处理中，我们使用微聚合作为全特征维度（覆盖所有我们感兴趣的特征的样本）样本的聚类方法。我们不会用代表记录替换记录，而是将使用差分隐私生成模型来建模每个簇。然而，这里有几个挑战。
- en: When modeling the output clusters from MDAV, some clusters may carry correlations
    that may not exist in the actual data distribution. This false feature correlation
    may apply unnecessary constraints when modeling the data clusters, and this may
    lead the synthetic data into a different shape. On the other hand, we know that
    a noise variance is usually introduced by DP. Intuitively, the less the noise
    introduced by DP, the higher the utility. Hence, reducing the DP mechanism’s noise
    also helps us improve the data’s utility. To address these adverse effects, we
    can sample data not only at the sample level but also at the feature level.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在对MDAV生成的输出簇进行建模时，一些簇可能携带实际数据分布中可能不存在的相关性。这种虚假特征相关性在建模数据簇时可能施加不必要的约束，这可能导致合成数据呈现出不同的形状。另一方面，我们知道差分隐私（DP）通常会引入噪声方差。直观上，引入的DP噪声越少，效用越高。因此，减少DP机制噪声也有助于提高数据的效用。为了解决这些不利影响，我们不仅可以在样本级别采样数据，还可以在特征级别采样数据。
- en: 'Here is how feature-level and sample-level clustering work:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何进行特征级和样本级聚类的：
- en: '*Feature-level clustering*—Whenever we have a numerical dataset *D*^(n^×d^),
    we can divide these *d* data features into *m* independent feature sets using
    agglomerative hierarchical clustering. Here, a distance function that converts
    Pearson correlation to distance can be used to form the proximity matrix in hierarchical
    clustering. Features with higher correlation should have lower distance, and lower
    correlation corresponds to a higher distance. This approach will help us to ensure
    the features in the same set are more correlated to each other and less correlated
    to features in the other feature sets.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*特征级聚类*——每当我们在一个数值数据集 *D*^(n^×d^) 中时，我们可以使用层次聚类将这些 *d* 个数据特征划分为 *m* 个独立的特征集。在这里，可以将皮尔逊相关系数转换为距离的函数用于形成层次聚类中的邻近矩阵。相关性较高的特征应具有较低的距离，而较低的相关性对应较高的距离。这种方法将帮助我们确保同一集合中的特征之间相关性更高，与其他特征集的特征相关性更低。'
- en: '*Sample-level clustering*—Once we have the output of feature-level clustering,
    we split data on the feature level and then apply micro-aggregation to each data
    segment. The idea is to assign the homogeneous samples to the same cluster, which
    will help us preserve more information from the original data. The sensitivity
    of each sample cluster can also be potentially reduced compared to the global
    sensitivity. This reduction will involve less noise in the DP mechanism. In other
    words, it enhances the data’s utility under the same level of privacy guarantee.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*样本级聚类*——一旦我们获得了特征级聚类的输出，我们就在特征级别上分割数据，然后对每个数据段应用微聚合。其思想是将同质样本分配到同一聚类中，这将帮助我们保留更多来自原始数据的信息。与全局敏感性相比，每个样本聚类的敏感性也可能降低。这种降低将涉及
    DP 机制中的较少噪声。换句话说，它在相同的隐私保证水平下增强了数据的效用。'
- en: The concepts behind generating synthetic data
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 生成合成数据背后的概念
- en: The micro-aggregation process outputs several clusters having at least *k* records
    each. Assuming each cluster forms a multivariate Gaussian distribution, the mean
    (*μ*) and covariance matrix (Σ) are computed for each cluster *c*. Then the privacy
    sanitizer adds the noise on *μ* and Σ to ensure that the model is satisfied with
    DP. Finally, the generative model is built. The complete process of generating
    synthetic data is illustrated in figure 6.18.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 微聚合过程输出包含至少 *k* 条记录的多个聚类。假设每个聚类形成一个多元高斯分布，则对每个聚类 *c* 计算均值 (*μ*) 和协方差矩阵 (Σ)。然后，隐私净化器在
    *μ* 和 Σ 上添加噪声以确保模型满足差分隐私（DP）。最后，构建生成模型。生成合成数据的完整过程如图 6.18 所示。
- en: '![CH06_F18_Zhuang](../../OEBPS/Images/CH06_F18_Zhuang.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F18_Zhuang](../../OEBPS/Images/CH06_F18_Zhuang.png)'
- en: Figure 6.18 How the synthetic data generator works. Here μ represents the mean
    and Σ is the covariance matrix computed for each cluster.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.18 合成数据生成器的工作原理。这里 μ 代表均值，Σ 是为每个聚类计算的协方差矩阵。
- en: In figure 6.18, the original multivariate Gaussian model is parameterized by
    the mean (*μ*) and covariance matrix (Σ). It is noteworthy that the privacy sanitizer
    outputs two parameters, *μ*_*DP* and Σ_*DP,* that are protected by DP. Hence,
    the multivariate Gaussian model that is parameterized by *μ*_*DP* and Σ_*DP* is
    also protected by DP. In addition, depending on the postprocessing invariance
    of DP, all the synthetic data derived from DP multivariate Gaussian models is
    also protected by DP.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 6.18 中，原始的多变量高斯模型由均值 (*μ*) 和协方差矩阵 (Σ) 参数化。值得注意的是，隐私净化器输出两个参数，*μ*_*DP* 和 Σ_*DP*，它们受到差分隐私的保护。因此，由
    *μ*_*DP* 和 Σ_*DP* 参数化的多变量高斯模型也受到差分隐私的保护。此外，根据差分隐私的后处理不变性，所有从差分隐私多元高斯模型导出的合成数据也受到差分隐私的保护。
- en: Variance, covariance, and covariance matrix
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 方差、协方差和协方差矩阵
- en: In statistics, *variance* usually measures the variation of a single random
    variable (for instance, the height of a person in a population), whereas covariance
    is a measure of how much two random variables vary together. For example, we can
    consider the height of a person and the weight of a person in a population to
    calculate the covariance.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在统计学中，*方差*通常衡量单个随机变量的变化（例如，人口中一个人的身高），而协方差是衡量两个随机变量一起变化的量度。例如，我们可以考虑人口中一个人的身高和体重来计算协方差。
- en: The formula for the covariance of two random variables *x* and *y* is given
    by
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 两个随机变量 *x* 和 *y* 的协方差公式如下
- en: '![CH06_F18_zhuang-ch6-eqs-1x](../../OEBPS/Images/CH06_F18_zhuang-ch6-eqs-1x.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F18_zhuang-ch6-eqs-1x](../../OEBPS/Images/CH06_F18_zhuang-ch6-eqs-1x.png)'
- en: 'where n is the number of samples. A covariance matrix is a square matrix given
    by C(i,j) = *σ* (x[i], x[j]) where *C* ∈ ℝ^(^n^×^n^) and n is the number of random
    variables. The diagonal entries of the covariance matrix are the variances, while
    the other entries are the covariances. For the case of two random variables, the
    covariance matrix can be computed as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 其中n是样本数量。协方差矩阵是一个由C(i,j) = *σ* (x[i], x[j])给出的方阵，*C* ∈ ℝ^(^n^×^n^)，其中n是随机变量的数量。协方差矩阵的对角线元素是方差，而其他元素是协方差。对于两个随机变量的情况，协方差矩阵可以按以下方式计算：
- en: '![CH06_F18_zhuang-ch6-eqs-3x](../../OEBPS/Images/CH06_F18_zhuang-ch6-eqs-3x.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F18_zhuang-ch6-eqs-3x](../../OEBPS/Images/CH06_F18_zhuang-ch6-eqs-3x.png)'
- en: 6.4.3 Evaluating the performance of the generated synthetic data
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.3 评估生成的合成数据的性能
- en: 'To evaluate the performance of the proposed method, we have implemented it
    in Java. Yes, this time it’s Java. The complete source code, dataset, and evaluation
    tasks are available in the book’s GitHub repository: [https://github.com/nogrady/PPML/blob/main/Ch6/PrivSyn_Demo.zip](https://github.com/nogrady/PPML/blob/main/Ch6/PrivSyn_Demo.zip).'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估所提出方法的性能，我们将其在Java中实现。是的，这次是Java。完整的源代码、数据集和评估任务可在本书的GitHub仓库中找到：[https://github.com/nogrady/PPML/blob/main/Ch6/PrivSyn_Demo.zip](https://github.com/nogrady/PPML/blob/main/Ch6/PrivSyn_Demo.zip)。
- en: 'We generated different synthetic datasets and performed experiments under different
    cluster sizes (*k*) and privacy budgets (ε). The setting of ε varies from 0.1
    to 1 and cluster size varies: *k* = 25, 50, 75, 100\. For each synthetic dataset,
    we looked at the performance on three general ML tasks: classification, regression,
    and clustering. To accomplish these tasks, we have two different experiment scenarios
    using different synthetic and original data combinations.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生成了不同的合成数据集，并在不同的聚类大小(*k*)和隐私预算(ε)下进行了实验。ε的设置从0.1到1不等，聚类大小为：*k* = 25, 50,
    75, 100。对于每个合成数据集，我们考察了三个通用机器学习任务：分类、回归和聚类。为了完成这些任务，我们使用了两种不同的实验场景，结合了不同的合成和原始数据组合。
- en: '*Experiment scenario 1*—Original data is used for training, and synthetic data
    is used for testing.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实验场景1*—使用原始数据进行训练，合成数据进行测试。'
- en: The ML model trains on the original datasets and tests the generated synthetic
    datasets. For each experimental dataset, 30% of the samples are used as the seed
    dataset to generate the synthetic dataset, and 70% is used as original data to
    train the model. Generated synthetic data is used for testing.
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 机器学习模型在原始数据集上训练，并测试生成的合成数据集。对于每个实验数据集，30%的样本被用作种子数据集来生成合成数据集，而70%被用作原始数据来训练模型。生成的合成数据用于测试。
- en: '*Experiment scenario 2*—Synthetic data is used for training, and original data
    is used for testing.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实验场景2*—使用合成数据进行训练，原始数据进行测试。'
- en: The ML model trains on the synthetic datasets and tests on the original datasets.
    For each experimental dataset, 80% of the samples are used as a seed dataset to
    generate the synthetic dataset, and 20% is used as original data to test the model.
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 机器学习模型在合成数据集上训练，并在原始数据集上测试。对于每个实验数据集，80%的样本被用作种子数据集来生成合成数据集，而20%被用作原始数据来测试模型。
- en: Datasets used for the experiments
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 实验中使用的数据集
- en: 'For this performance evaluation, we used three datasets from the UCI Machine
    Learning Repository [8] and LIBSVM data repository to examine the performance
    of the different algorithms. All the features in the dataset were scaled to [-1,1]:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这次性能评估，我们使用了来自UCI机器学习仓库[8]和LIBSVM数据仓库的三个数据集来检验不同算法的性能。数据集中的所有特征都被缩放到[-1,1]范围内：
- en: '*Diabetes dataset*—This dataset contains diagnostic measurements of patient
    records with 768 samples and 9 features, including patient information such as
    blood pressure, BMI, insulin level, and age. The objective is to identify whether
    a patient has diabetes.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*糖尿病数据集*—这个数据集包含了768个样本和9个特征的病人记录诊断测量，包括血压、BMI、胰岛素水平和年龄等信息。目标是识别病人是否患有糖尿病。'
- en: '*Breast cancer dataset*—This dataset was collected from clinical cases for
    breast cancer diagnosis. It has 699 samples and 10 features. All the samples are
    labeled as benign or malignant.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*乳腺癌数据集*—这个数据集是从乳腺癌诊断的临床病例中收集的。它有699个样本和10个特征。所有样本都被标记为良性或恶性。'
- en: '*Australian dataset*—This is the Australian credit approval dataset from the
    StatLog project. Each sample is a credit card application, and the dataset contains
    690 samples and 14 features. The samples are labeled by whether the application
    is approved or not.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*澳大利亚数据集*——这是来自StatLog项目的澳大利亚信用批准数据集。每个样本是一个信用卡申请，数据集包含690个样本和14个特征。样本通过申请是否被批准进行标记。'
- en: Performance evaluation and the results
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 性能评估和结果
- en: 'As discussed, we are interested in three main ML tasks for the evaluation of
    synthetic data: classification, regression, and clustering.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所讨论的，我们对三个主要的机器学习任务感兴趣，用于评估合成数据：分类、回归和聚类。
- en: A support vector machine (SVM) was used for the classification task. In each
    training phase, we used grid search and cross-validation to choose the best parameter
    combination for the SVM model. In terms of selecting the best performing SVM model,
    the F1 score was utilized. The model with the highest F1 score was used to test
    classification accuracy.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 使用支持向量机（SVM）进行分类任务。在每个训练阶段，我们使用网格搜索和交叉验证来选择SVM模型的最佳参数组合。在选择最佳性能的SVM模型时，使用了F1分数。具有最高F1分数的模型用于测试分类精度。
- en: For the regression task, linear regression was used as the regressor. The evaluation
    metric of regression is mean squared error (MSE).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 对于回归任务，使用了线性回归作为回归器。回归的评价指标是均方误差（MSE）。
- en: Finally, *k*-means clustering was used as the clustering task. As you learned
    in the previous chapters, clustering is an unsupervised ML task that groups similar
    data. Unlike the preceding classification and regression tasks, all data in the
    original dataset is considered the seed for synthetic data in clustering. The
    *k*-means algorithm is applied on both the original and synthetic datasets, and
    both result in two clusters that present the binary class in experimental datasets.
    In each experiment, *k*-means runs 50 times with different centroid seeds, and
    it outputs the best case of 50 consecutive runs.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用了*k*-means聚类作为聚类任务。正如你在前几章所学，聚类是一种无监督机器学习任务，它将相似的数据分组。与先前的分类和回归任务不同，聚类中原始数据集中的所有数据都被视为合成数据的种子。*k*-means算法应用于原始和合成数据集，两者都产生了两个聚类，这些聚类在实验数据集中呈现二进制类别。在每个实验中，*k*-means运行50次，每次使用不同的质心种子，并输出50次连续运行中的最佳情况。
- en: The results of the three ML tasks are shown in figures 6.19, 6.20, and 6.21\.
    You can see that when ε ranges from 0.1 to 0.4, the performance of each *k* increases
    rapidly, but the peak performance is not always coming from a fixed *k* value.
    For example figure 6.19 (e) has a local optimal point when *k* = 50, and figures
    6.21 (a) and figure 6.21 (c) have a local optimal point when *k* = 75.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 三个机器学习任务的成果展示在图6.19、6.20和6.21中。你可以看到，当ε的范围从0.1到0.4时，每个*k*的性能都会迅速提高，但峰值性能并不总是来自固定的*k*值。例如，图6.19（e）在*k*
    = 50时有一个局部最优点，而图6.21（a）和图6.21（c）在*k* = 75时有一个局部最优点。
- en: '![CH06_F19_Zhuang](../../OEBPS/Images/CH06_F19_Zhuang.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F19_Zhuang](../../OEBPS/Images/CH06_F19_Zhuang.png)'
- en: Figure 6.19 Experimental results of task 1 (SVM) with the two different experiment
    scenarios
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.19 任务1（SVM）的两个不同实验场景的实验结果
- en: '![CH06_F20_Zhuang](../../OEBPS/Images/CH06_F20_Zhuang.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F20_Zhuang](../../OEBPS/Images/CH06_F20_Zhuang.png)'
- en: Figure 6.20 Experimental results of task 2 (linear regression) with the two
    different experiment scenarios
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.20 任务2（线性回归）的两个不同实验场景的实验结果
- en: '![CH06_F21_Zhuang](../../OEBPS/Images/CH06_F21_Zhuang.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F21_Zhuang](../../OEBPS/Images/CH06_F21_Zhuang.png)'
- en: Figure 6.21 Experimental results of task 3 (*k*-means clustering)
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.21 任务3（*k*-means聚类）的实验结果
- en: Theoretically speaking, a small ε value usually introduces more noise to the
    synthetic data than a greater ε value, which brings more randomness. Comparing
    the two scenarios in the case of regression (figure 6.20), the randomness reflected
    in scenario 2 has much less MSE than in scenario 1, when the privacy budget was
    small. This is due to the testing data in scenario 1 having differentially private
    noise, and the testing data in scenario 2 not having the noise in it. Whenever
    ε > 0.4, the performance increase is somewhat steady, and when *k* = 100, the
    clustering method always outperforms the other *k* values under the same privacy
    budget. It is also noteworthy that when *k* = 25, the overall performance is much
    lower than for the other *k* values. That’s because when we form a multivariate
    Gaussian generative model on a cluster that only contains a few data samples,
    the calculated mean and the covariance matrix can be biased. The cluster cannot
    reflect the data distribution very well. Thus, *k* should be a moderate value
    to form the multivariate Gaussian generative model. A greater *k* value can also
    make the model converge faster than a smaller *k*, as in figures 6.19 (a), 6.19
    (d), 6.20 (a), and 6.21 (a).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，较小的 ε 值通常比较大的 ε 值引入更多的噪声到合成数据中，这增加了随机性。在回归的情况下（图6.20），当隐私预算较小的时候，场景2中反映的随机性比场景1中的MSE要少得多。这是由于场景1中的测试数据具有差分隐私噪声，而场景2中的测试数据没有噪声。当
    ε > 0.4 时，性能提升相对稳定，当 *k* = 100 时，在相同的隐私预算下，聚类方法总是优于其他 *k* 值。值得注意的是，当 *k* = 25
    时，整体性能远低于其他 *k* 值。这是因为当我们在一个只包含少量数据样本的簇上形成多元高斯生成模型时，计算出的均值和协方差矩阵可能会存在偏差。该簇不能很好地反映数据分布。因此，*k*
    应该是一个适中的值来形成多元高斯生成模型。更大的 *k* 值也可以使模型比更小的 *k* 值更快地收敛，如图6.19（a）、6.19（d）、6.20（a）和6.21（a）所示。
- en: Summary
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Synthetic data is artificial data that is generated from the original data and
    that keeps the original data’s statistical properties and protects the original
    data’s private information.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合成数据是从原始数据生成的人工数据，它保留了原始数据的统计特性并保护了原始数据的隐私信息。
- en: The synthetic data generation process involves various steps, including outlier
    detection, a normalization function, and building the model.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合成数据生成过程涉及多个步骤，包括异常检测、归一化函数和构建模型。
- en: A privacy test is used to ensure that the generated synthetic data satisfies
    certain predefined privacy guarantees.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐私测试用于确保生成的合成数据满足某些预定义的隐私保证。
- en: '*K*-anonymity is a good approach for generating anonymized synthetic data to
    mitigate re-identification attacks.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*K*-匿名性是生成匿名化合成数据以减轻重新识别攻击的良好方法。'
- en: While *k*-anonymity makes it harder to re-identify individuals, it also has
    some drawbacks, which leads to other anonymization mechanisms such as *l*-diversity.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然 *k*-匿名性使得重新识别个体变得更加困难，但它也有一些缺点，这导致了其他匿名化机制，如 *l*-多样性。
- en: A synthetic representation of a dataset can capture statistical properties of
    the original dataset, but most of the time it will not have the same shape as
    the original dataset.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据集的合成表示可以捕捉原始数据集的统计特性，但大多数情况下，它不会与原始数据集具有相同的形状。
- en: We can use a synthetic histogram to generate synthetic tabular data.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用合成直方图来生成合成表格数据。
- en: A synthetic representation can be used to generate a synthetic dataset with
    the same statistical properties and shape as the original dataset.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合成表示可以用来生成与原始数据集具有相同统计特性和形状的合成数据集。
- en: We can generate differentially private synthetic data by applying the Laplace
    mechanism to the synthetic representation generator and then use the differentially
    private synthetic representation generator.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过将拉普拉斯机制应用于合成表示生成器来生成差分隐私合成数据，然后使用差分隐私合成表示生成器。
- en: We can generate differentially private synthetic data that satisfies *k*-anonymity
    by applying micro-aggregation techniques to synthetic data generation.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过将微聚合技术应用于合成数据生成来生成满足 *k*-匿名性的差分隐私合成数据。
