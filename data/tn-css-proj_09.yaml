- en: 9 Creating a virtual credit card
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 创建虚拟信用卡
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Using Flexbox and `position` in layout
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Flexbox和`position`进行布局
- en: Working with background images and sizing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用背景图像和尺寸
- en: Loading and applying local fonts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载和应用本地字体
- en: Using transitions and the `backface-visibility` property to create a 3D effect
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用过渡和`backface-visibility`属性创建3D效果
- en: Working with additional styles such as the `text-shadow` and `border-radius`
    properties
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`text-shadow`和`border-radius`属性等额外样式
- en: As we saw in chapter 3, animation in CSS opens lots of opportunities to create
    interactive web experiences. In chapter 3, we used animations to give users the
    sense that something was happening in the background as they waited for a task
    to complete. Now we’ll use animation to respond to users’ interactions and create
    a flip effect for a credit card image. On one side, the animation will show the
    front of a credit card; on hover or on click for mobile devices, it will flip
    to show the back of the credit card.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第3章中看到的，CSS中的动画为创建交互式网络体验提供了许多机会。在第3章中，我们使用动画给用户一种感觉，在他们等待任务完成时，背景中似乎有事情发生。现在我们将使用动画来响应用户的交互并为信用卡图像创建翻转效果。在一侧，动画将显示信用卡的正面；在悬停或点击移动设备时，它将翻转以显示信用卡的背面。
- en: This effect is useful to users, as we’re re-creating what their credit cards
    may look like, showing which information from the cards they need to enter when
    buying something online, such as the expiration date or the security code. Animation
    is a way to represent something in real life by re-creating it for the web. This
    project goes hand in hand with the one in chapter 8, in which we designed a checkout
    cart.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这种效果对用户很有用，因为我们正在重新创建他们的信用卡可能的样子，显示他们在网上购买东西时需要从卡片中输入哪些信息，例如有效期或安全码。动画是通过在网络上重新创建它来表示现实生活中的某种东西的一种方式。这个项目与第8章中的项目相辅相成，在第8章中我们设计了一个结账购物车。
- en: We’ll also explore styling images to set the background of the credit card and
    icons on the card. We’ll use the CSS Flexbox Layout Module for the layout, as
    well as styling properties such as shadows, colors, and border radius. By the
    end of the chapter, our layout will look like figure 9.1.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探索样式图像以设置信用卡的背景和卡片上的图标。我们将使用CSS Flexbox布局模块进行布局，以及如阴影、颜色和边框半径等样式属性。到本章结束时，我们的布局将看起来像图9.1。
- en: '![](../Images/09-01.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09-01.png)'
- en: Figure 9.1 Final output of the front and back of the credit card
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 信用卡正面和背面的最终输出
- en: As we go through the project, feel free to try customizing it to match your
    style. Try a different background image or typeface, for example. This project
    is a great opportunity to tweak the styling to suit your style. Let’s get started.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行项目的过程中，请随意尝试自定义它以匹配您的风格。例如，尝试不同的背景图片或字体。这个项目是一个很好的机会来调整样式以适应您的风格。让我们开始吧。
- en: 9.1 Getting started
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 开始
- en: Our HTML is made up of two main parts. Within the overall section representing
    the virtual card are a front side and a back side. You can find the starting HTML
    in the `chapter-09` folder of the GitHub repository ([http://mng.bz/Bm5g](http://mng.bz/Bm5g)),
    on CodePen ([https://codepen.io/michaelgearon/pen/YzZKMKN](https://codepen.io/michaelgearon/pen/YzZKMKN)),
    and in the following listing.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的HTML由两个主要部分组成。在表示虚拟卡的总体部分中，有一个正面和一个背面。您可以在GitHub仓库的`chapter-09`文件夹中找到起始HTML（[http://mng.bz/Bm5g](http://mng.bz/Bm5g)），在CodePen（[https://codepen.io/michaelgearon/pen/YzZKMKN](https://codepen.io/michaelgearon/pen/YzZKMKN)）以及以下列表中找到。
- en: Listing 9.1 Project HTML
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.1 项目HTML
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ① The container for the whole credit card
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ① 整个信用卡的容器
- en: ② The container for the front of the card
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ② 卡片正面的容器
- en: ③ The section for the top front of the card
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 显示卡片顶部正面部分的区域
- en: ④ The section for the middle front of the card, showing the card number
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 显示卡片号码的卡片中间正面部分
- en: ⑤ The section for the bottom front of the card, showing the expiration date
    and cardholder name
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 显示有效期和持卡人姓名的卡片底部正面部分
- en: We also have some starting CSS to change the background color to a light blue
    and increase the margin at the top of the page, as shown in the following listing.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一些初始的CSS来将背景颜色改为浅蓝色并增加页面顶部的边距，如下所示。
- en: Listing 9.2 Starting CSS
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.2 起始CSS
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We’re using the universal selector that we looked at in chapter 1 to set the
    `box-sizing` value for all HTML elements to `border-box`. This selector has two
    values:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用我们在第1章中查看的通用选择器来设置所有HTML元素的`box-sizing`值为`border-box`。此选择器有两个值：
- en: '`content-box`—This setting is the default value for calculating the width and
    height of an element. If the `content-box` height and width are `250px`, any borders
    or padding will be added to the final rendered width. Given a border of `2px`
    all around, for example, the final rendered width would be `254px`.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content-box`——这是计算元素宽度和高度的默认值。如果`content-box`的高度和宽度是`250px`，任何边框或填充都将添加到最终渲染的宽度中。例如，如果周围有`2px`的边框，最终渲染的宽度将是`254px`。'
- en: '`border-box`—The difference between this value and `border-box` is that if
    we set the element height to `250px`, any borders and padding will be included
    in this specified value. The `content-box` will reduce as the padding and border
    increase.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`border-box`——这个值与`border-box`的区别在于，如果我们将元素高度设置为`250px`，任何边框和填充都将包含在这个指定的值中。`content-box`会随着填充和边框的增加而减少。'
- en: '![](../Images/09-02.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/09-02.png)'
- en: Figure 9.2 The effect of `box-sizing` on element size
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 `box-sizing`对元素尺寸的影响
- en: Figure 9.2 shows an example. Our starting point looks like figure 9.3.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2展示了示例。我们的起点看起来像图9.3。
- en: '![](../Images/09-03.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/09-03.png)'
- en: Figure 9.3 Starting point
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 起点
- en: 9.2 Creating the layout
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 创建布局
- en: Both the front and the back have a class name of `card-item__side`. The front
    also has a second class assignment of `front`, and the back has a second class
    of `back`. Having two class names—one that’s identical on both sides and a second,
    different one—allows us to assign styles that are common to both sides using the
    `.card-item__side` selector (the class they have in common) and styles that are
    unique to a side in their individual rules of .`front` `{}` or `.back` `{}`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 前面和背面都有一个类名为`card-item__side`。前面还有一个类名为`front`的二次分配，背面有一个名为`back`的二次类。有两个类名——一个在两边都相同，另一个不同——这允许我们使用`.card-item__side`选择器（它们共有的类）分配适用于两边的样式，并在`.front`
    `{}`或`.back` `{}`的单独规则中分配仅适用于一侧的样式。
- en: Let’s start by centering the card on the screen. The first step is setting the
    height and width of the card to a maximum width of `430px` and a fixed height
    of `270px`. We’re also setting its position to `relative`, which will be useful
    when we place the back of the card on top of the front to create the flip effect
    later in this chapter (section 9.5).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从将卡片在屏幕上居中开始。第一步是设置卡片的最大宽度为`430px`和固定高度为`270px`。我们还将其位置设置为`relative`，这在我们在本章后面（9.5节）将卡片背面放在前面以创建翻转效果时将很有用。
- en: The final piece is setting the left and right margins of the card to `auto`
    to center the card horizontally in the browser window. To do this, we use the
    `.card-item` selector to create the rule shown in the following listing.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是设置卡片的左右边距为`auto`以在浏览器窗口中水平居中卡片。为此，我们使用`.card-item`选择器创建以下列表中所示的规则。
- en: Listing 9.3 Container styling
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.3 容器样式
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Figure 9.4 shows the updated positioning.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4显示了更新的定位。
- en: '![](../Images/09-04.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/09-04.png)'
- en: Figure 9.4 Centered credit card
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 居中的信用卡
- en: 9.2.1 Sizing the card
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.1 设置卡片大小
- en: Now that we’ve set a maximum width and height for the card, we want to ensure
    that the front and back faces fill the entire space available to them within their
    parent container (the card). Therefore, we’ll assign a height and width of `100%`
    to both sides of the cards by using the class selector `.card-item__side`, as
    shown in the following listing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为卡片设置了最大宽度和高度，我们想要确保前面和背面填充它们在父容器（卡片）内可用的整个空间。因此，我们将使用类选择器`.card-item__side`将卡片两面的高度和宽度都设置为`100%`，如下列所示。
- en: Listing 9.4 Container shared between the front and back
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.4 前面和背面共享的容器
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With this piece of code added, our card faces (front and back) expand to match
    the size of its parent container, as figure 9.5 shows.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了这段代码后，我们的卡片面（前面和背面）扩展以匹配其父容器的尺寸，如图9.5所示。
- en: '![](../Images/09-05.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/09-05.png)'
- en: Figure 9.5 The card faces (front and back) match the parent’s container size.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 卡片面（前面和背面）与父容器尺寸匹配。
- en: 9.2.2 Styling the front of the card
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.2 样式化卡片的前面
- en: 'For the front of the card, we have three main sections (figure 9.6):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于卡片的前面，我们分为三个主要部分（图9.6）：
- en: The top of the card has two images, one showing the chip and the other showing
    the type of credit card (such as Visa or MasterCard).
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卡片的顶部有两张图片，一张显示芯片，另一张显示信用卡类型（如Visa或MasterCard）。
- en: In the middle is the card number, which is spread evenly across the width of
    the card.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间是卡号，它均匀分布在卡片的宽度上。
- en: At the bottom are the cardholder’s name and the card’s expiration date. These
    elements are on opposite ends.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在底部是持卡人的姓名和卡片的过期日期。这些元素位于相反的端点。
- en: '![](../Images/09-06.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09-06.png)'
- en: Figure 9.6 A wireframe of the front of the card
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 卡片前面的线框图
- en: Before we start styling the individual parts of the front of the card, let’s
    give the card face some padding so that the contents aren’t positioned right up
    against the edge. We’ll give them some breathing room. The following listing shows
    the code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始为卡片前面的各个部分添加样式之前，让我们给卡片面添加一些填充，这样内容就不会紧贴边缘。我们将给它们留出一些空间。下面的列表显示了代码。
- en: Listing 9.5 Container styling for the front of the card
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.5 卡片前面的容器样式
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Remember that in the styles originally provided with the project, we set the
    `box-sizing` of all elements to `border-box`. With the added padding, we see that
    changing the `box-sizing` didn’t increase the dimensions of the card face `<section>`;
    rather, it decreased the space available to the content (figure 9.7).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在项目最初提供的样式表中，我们将所有元素的`box-sizing`设置为`border-box`。随着填充的增加，我们看到改变`box-sizing`并没有增加卡片面`<section>`的尺寸；相反，它减少了内容可用的空间（图9.7）。
- en: '![](../Images/09-07.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09-07.png)'
- en: Figure 9.7 Card with added padding and box model diagram
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 带有添加填充和盒模型图的卡片
- en: Top of the card
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 卡片的顶部
- en: We’re using Flexbox for the layout of the card. As we’ve learned, Flexbox is
    likely to be the best choice for placing items in a single-axis layout. Also,
    we need to take advantage of the extra functionality Flexbox gives us with spacing
    and alignment—functionality that float doesn’t give us.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用Flexbox来布局卡片。正如我们所学的，Flexbox很可能是放置单轴布局中项目的最佳选择。此外，我们需要利用Flexbox提供的额外功能，即间距和对齐功能——这是float所不具备的。
- en: Note For details on the CSS Flexbox Layout Module and its associated properties,
    check out chapter 6\. Chapter 7 covers float.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：有关CSS Flexbox布局模块及其相关属性详情，请参阅第6章。第7章涵盖了float。
- en: With these facts in mind, we’ll set the top of the card to have a `display`
    property value of `flex` and set the alignment so that the tops of the elements
    align. The default property of `align-items` is `stretch`, which increases the
    heights of the `flex` items so that their heights match that of the tallest element
    in the set.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些事实，我们将卡片的顶部设置为具有`display`属性值为`flex`，并设置对齐方式，使元素的顶部对齐。`align-items`的默认属性是`stretch`，它增加了`flex`项目的高度，使它们的高度与集合中最高的元素相匹配。
- en: We don’t want this distortion, though; we want the elements to be aligned vertically
    to the tops of the items. So we’ll set the `align-items` property to `flex-start`.
    Then we’ll set the `justify-content` property to `space-between`, which distributes
    the elements evenly along the axis, creating a gap between the two elements and
    placing them at the extreme edges of the card.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们不希望这种扭曲，但我们希望元素垂直对齐到项目的顶部。因此，我们将`align-items`属性设置为`flex-start`。然后我们将`justify-content`属性设置为`space-between`，这样就可以在轴上均匀分布元素，在两个元素之间创建一个间隙，并将它们放置在卡片的极端边缘。
- en: We’ll give the top some margin and padding to position them further relative
    to the edge of the card. Then we’ll increase the width of the chip to `60px`.
    As this image is an SVG, we can increase its size without affecting its quality.
    Because we’re manipulating only the width and haven’t altered the default height,
    the image’s height will scale proportionally by default. The following listing
    shows the rules used to style the top portion of the card.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将给顶部添加一些边距和填充，以便将它们相对于卡片边缘进一步定位。然后我们将芯片的宽度增加到`60px`。因为这张图片是SVG格式的，我们可以增加其大小而不影响其质量。因为我们只操作了宽度，并没有改变默认的高度，所以图片的高度将默认按比例缩放。下面的列表显示了用于样式化卡片顶部部分的规则。
- en: Listing 9.6 Layout for the top front of the card
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.6 卡片顶部前面的布局
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Our updated card looks like figure 9.8.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更新的卡片看起来像图9.8。
- en: '![](../Images/09-08.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09-08.png)'
- en: Figure 9.8 Styled top portion of the card
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 卡片样式化顶部部分
- en: Middle of the card
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 卡片的中间部分
- en: In the middle front of the card, we find the card number. Again, we use a `display`
    property value of `flex`, with `justify-content:` `space-between` distributing
    the number groups evenly across the card’s width. We also add padding and margin
    to add space between the numbers and the elements around them, as shown in the
    following listing.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在卡片正面中部，我们找到了卡片号码。同样，我们使用`display`属性值为`flex`，`justify-content:` `space-between`将数字组均匀分布在卡片的宽度上。我们还添加了填充和边距，以在数字及其周围元素之间添加空间，如以下列表所示。
- en: Listing 9.7 Layout for the middle of the front of the card
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.7 卡片正面中部的布局
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Figure 9.9 shows our number groups distributed evenly across the width of the
    card.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9显示了我们的数字组均匀分布在卡片宽度上。
- en: '![](../Images/09-09.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/09-09.png)'
- en: Figure 9.9 Evenly distributed numbers
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 均匀分布的数字
- en: Bottom of the card
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 卡片底部
- en: 'In the bottom front of the card, we have two elements: cardholder name and
    card expiration date. As we did in the top and middle of the card, we want to
    separate the bits of information and place them at opposite edges of the card.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在卡片正面底部，我们有两个元素：持卡人姓名和卡片到期日期。就像我们在卡片顶部和中部所做的那样，我们想要将信息片段分开，并将它们放置在卡片的相对边缘。
- en: We’ll follow the same pattern of using Flexbox, `justify-content`, and `padding`
    to place the elements. We don’t need any margin this time, however. The following
    listing shows the rule we’ll use.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循使用Flexbox、`justify-content`和`padding`来放置元素的相同模式。这次我们不需要任何边距。以下列表显示了我们将使用的规则。
- en: Listing 9.8 Layout for the bottom front of the card
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.8 卡片正面底部的布局
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Figure 9.10 shows the updated layout. Next, we’ll position the elements on the
    back of the card.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10显示了更新后的布局。接下来，我们将定位卡片背面的元素。
- en: '![](../Images/09-10.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/09-10.png)'
- en: Figure 9.10 Layout for the front of the card
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10 卡片正面的布局
- en: 9.2.3 Laying out the back of the card
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.3 卡片背面的布局
- en: The layout for the back includes the security code number and a semitransparent
    band (the magnetic strip), as shown in figure 9.11\. Let’s start with the semitransparent
    back strip.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 背部的布局包括安全码数字和半透明带（磁条），如图9.11所示。让我们从半透明的背面条开始。
- en: '![](../Images/09-11.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/09-11.png)'
- en: Figure 9.11 A wireframe of the back of the card
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11 卡片背面的线框图
- en: Semitransparent strip
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 半透明条
- en: The strip has a class of `card-item__band`. We want to make it `50px` in height
    and position it `30px` from the top of the card. We’ll use the `height` property
    to indicate how tall it should be. Even though the `<div>` is empty, it automatically
    takes the full width available to it because `<div>`s are block-level elements.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 该条具有`card-item__band`类。我们希望将其高度设置为`50px`，并将其定位在卡片顶部`30px`处。我们将使用`height`属性来指示它应该有多高。即使`<div>`是空的，它也会自动占据它可用的全部宽度，因为`<div>`是块级元素。
- en: To move the strip down rather than keep it at the top of the back of the card,
    we’ll add some padding to the back of the card itself. We can’t give it margin,
    because it would push against the previously existing content (in the top card)
    rather than the top edge of the back.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将条向下移动而不是保持在卡片背面的顶部，我们将在卡片本身的后部添加一些填充。我们不能给它设置边距，因为它会推到之前存在的内 容（在顶部卡片中）而不是背部的顶部边缘。
- en: Although we’ll manage most of the theming later in this chapter, let’s add the
    background color now so that we can see what we’re doing (listing 9.9). The background
    is dark blue at 80% opacity, which will allow some of the background image we
    place on the card to show through.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将在本章后面部分管理大多数主题，但现在让我们添加背景颜色，以便我们可以看到我们在做什么（列表9.9）。背景是80%不透明的深蓝色，这将允许我们放置在卡片上的部分背景图像显示出来。
- en: Listing 9.9 Positioning the strip
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.9 定位条
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now our strip looks like figure 9.12.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的条看起来就像图9.12所示。
- en: '![](../Images/09-12.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/09-12.png)'
- en: Figure 9.12 Styled strip on back of card
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12 卡片背面样式化的条
- en: Security code
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 安全码
- en: The security code has the letters *CVV* above it and a white band (usually intended
    for the user’s signature) that includes the security code. Both the letters and
    the numbers are right-justified and nested inside a `<div>` with a class name
    of `card-item__cvv`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 安全码上方有字母*CVV*，以及一个包含安全码的白色带（通常用于用户的签名）。字母和数字都右对齐，并嵌套在类名为`card-item__cvv`的`<div>`中。
- en: 'For the letters *CVV*, because we don’t need to distribute elements across
    the width of the card, we don’t need to use Flexbox. Aligning the text to the
    right by using the `text-align` property is sufficient to accomplish the task.
    But we’ll use Flexbox on the white band that contains the security numbers, not
    because it’s needed to right-justify the text but because it makes vertically
    aligning the content inside the band much easier. Let’s start by giving the `card-item__CVV`
    container some basic styles: `padding` to space elements and the `text-align`
    property so that our text will place itself on the right of the card, as shown
    in the following listing.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *CVV* 字母，因为我们不需要将元素分布到卡片的宽度上，所以我们不需要使用 Flexbox。通过使用 `text-align` 属性将文本右对齐就足以完成任务。但我们将使用
    Flexbox 在包含安全数字的白色带上，这不仅是因为它需要将文本右对齐，而且因为它使得在带内垂直对齐内容变得更加容易。让我们首先给 `card-item__CVV`
    容器添加一些基本样式：`padding` 用于分隔元素，以及 `text-align` 属性，以便我们的文本将放置在卡片的右侧，如下面的列表所示。
- en: Listing 9.10 Positioning the text
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.10 定位文本
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With the container taken care of (figure 9.13), we can style the letters and
    security code individually.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完容器（图 9.13）后，我们可以单独设置字母和安全代码的样式。
- en: '![](../Images/09-13.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09-13.png)'
- en: Figure 9.13 Aligning the text
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.13 对齐文本
- en: For the *CVV* letters, all we need to do is give this text some margin and padding
    to offset it from the right edge and away from the number below. Because we want
    the number to be inside a white band of a specific height, we’ll use the `height`
    property with a value of `45px`. To align the text vertically in the middle of
    the box, instead of trying to calculate the amount of vertical padding necessary
    based on the text size, we’ll use Flexbox with an `align-items` property value
    of `center`. We’ll still use padding to separate the text from the right edge
    of the box, however.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *CVV* 字母，我们只需要给这段文本添加一些边距和填充，以将其从右边缘和下面的数字偏移。因为我们希望数字在特定高度的白色带上，我们将使用 `height`
    属性，其值为 `45px`。为了在盒子的中间垂直对齐文本，而不是根据文本大小计算所需的垂直填充量，我们将使用 Flexbox，并设置 `align-items`
    属性的值为 `center`。我们仍然会使用填充来将文本与盒子的右边缘分开。
- en: Because Flexbox’s default property value for `justify-content` is `flex-start`
    (which would reposition our text to the right of the box), we need to assign it
    a value of `flex-end` explicitly so that the elements within (the text) stay to
    the right. The following listing shows the CSS we use to style *CVV* and the security
    code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Flexbox 的默认 `justify-content` 属性值为 `flex-start`（这将重新定位我们的文本到盒子的右侧），我们需要显式地分配给它一个值为
    `flex-end` 的值，以便容器内的元素（文本）保持在右侧。下面的列表显示了用于样式化 *CVV* 和安全代码的 CSS。
- en: Listing 9.11 Layout for the back of the card
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.11 卡片背面的布局
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: At this point, our card looks like figure 9.14.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的卡片看起来像图 9.14 所示。
- en: '![](../Images/09-14.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09-14.png)'
- en: Figure 9.14 Elements positioned on the card
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.14 卡片上的元素定位
- en: The card is starting to take shape. Now we need to apply the background image
    to both the front and back, as well as the colors and typography. These steps
    will make a huge difference and get us one step closer to the final look.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 卡片开始成形。现在我们需要将背景图像应用到正面和背面，以及颜色和字体。这些步骤将产生巨大差异，并让我们更接近最终的外观。
- en: 9.3 Working with background images
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 使用背景图像
- en: Our credit card needs to have some sort of background image. To add one, we’ll
    use the `background-image` property. The image could be in any format that’s valid
    for the web.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的信用卡需要某种背景图像。为了添加一个，我们将使用 `background-image` 属性。图像可以是任何适用于网络的格式。
- en: 9.3.1 Background property shorthand
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.1 背景属性简写
- en: 'When setting the background for an element, we can set each related property
    independently (`background-image`, `background-size`, and so on) or can use the
    shorthand `background` property. We’re going to use the following properties and
    values:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置元素的背景时，我们可以独立设置每个相关属性（`background-image`、`background-size` 等）或可以使用简写 `background`
    属性。我们将使用以下属性和值：
- en: '`background-image:` `url("bg.jpeg")`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`background-image:` `url("bg.jpeg")`'
- en: '`background-size:` `cover`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`background-size:` `cover`'
- en: '`background-color:` `blue`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`background-color:` `blue`'
- en: '`background-position:` `left` `top`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`background-position:` `left` `top`'
- en: If we use the shorthand `background` property, our declaration ends up being
    `background:` `url("bg.jpeg")` `left` `top` `/` `cover` `blue;.` The URL to the
    image is truncated here to make the code easier to read and discuss, but it’ll
    be required in its entirety in our code to retrieve the image, as we’ll do several
    times in this chapter. Figure 9.15 breaks down the property value.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用简写形式的`background`属性，我们的声明最终会是`background:` `url("bg.jpeg")` `left` `top`
    `/` `cover` `blue;.` 这里为了使代码更容易阅读和讨论，图像的URL被截断，但在我们的代码中需要使用完整的URL来检索图像，正如我们在本章中会多次做的那样。图9.15分解了属性值。
- en: '![](../Images/09-15.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/09-15.png)'
- en: Figure 9.15 Shorthand `background` property
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15 简写`background`属性
- en: Notice that we’re using a `background-size` property value of `cover`. We’re
    using this setting so that the browser will calculate the optimal size the image
    should be to cover the entire element while still showing as much of the image
    as possible without distortion. If the image and our element don’t have the same
    aspect ratio, the excess image will be clipped. If we don’t want any part of the
    image to be clipped, we can use `contain` instead. Figure 9.16 shows examples
    of using `cover` and `contain`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们使用的是`background-size`属性的`cover`值。我们使用这个设置是为了让浏览器计算出图像应该具有的最佳大小，以便覆盖整个元素，同时尽可能多地显示图像而不失真。如果图像和我们的元素没有相同的宽高比，多余的图像将被裁剪。如果我们不希望图像的任何部分被裁剪，我们可以使用`contain`。图9.16展示了使用`cover`和`contain`的示例。
- en: '![](../Images/09-16.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/09-16.png)'
- en: Figure 9.16 Examples of `background-cover`
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16 `background-cover`示例
- en: Although we use a `background-size` of `cover`, we still include a background
    color. When both an image and background color are provided, the image always
    appears on top of the color. We may want to do this for multiple reasons. If the
    image were smaller than the element or transparent, for example, including a background
    color would provide a uniformly colored background behind the image. It would
    also provide something for the browser to display while the image is loading or
    if the image fails to load. We don’t have to provide this value in our project,
    but having a color that differs from the page’s background helps distinguish the
    card from the page itself, making it a good fallback position if the image fails
    to load. Because we want the front and back of the card to have the background
    image, we’ll update our `.card-item__side` rule, which affects both the front
    and back of the card, as shown in the following listing.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们使用了`background-size`的`cover`值，但我们仍然包括一个背景颜色。当提供了图像和背景颜色时，图像总是显示在颜色之上。我们可能出于多个原因想要这样做。例如，如果图像小于元素或透明，包括背景颜色将为图像提供均匀颜色的背景。它也会在图像加载时或图像加载失败时为浏览器提供显示的内容。我们不必在我们的项目中提供这个值，但有一个与页面背景颜色不同的颜色可以帮助区分卡片和页面本身，如果图像加载失败，它将是一个好的回退位置。因为我们想让卡片的正面和背面都有背景图像，我们将更新我们的`.card-item__side`规则，该规则影响卡片的正面和背面，如下面的列表所示。
- en: Listing 9.12 Background image for the front and back of the card
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.12卡片正反面的背景图像
- en: '[PRE11]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With the background image applied (figure 9.17), we can focus on styling the
    text.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用了背景图像（图9.17）之后，我们可以专注于文本的样式。
- en: '![](../Images/09-17.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/09-17.png)'
- en: Figure 9.17 Background image added to both the front and back of the card
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.17 卡片正反面的背景图像已添加
- en: 9.3.2 Text color
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.2 文本颜色
- en: Now that we have the background image in place, we notice that the text is difficult
    to read, so we’ll change it from black to white by updating our `.card-item` selector.
    Listing 9.13 shows our updated `.card-item` rule.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了背景图像，我们注意到文本难以阅读，因此我们将它从黑色更改为白色，通过更新我们的`.card-item`选择器。列表9.13展示了我们的更新后的`.card-item`规则。
- en: Color contrast and background images
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色对比和背景图像
- en: Verifying that color contrast is accessible when text overlaps an image is notoriously
    difficult and requires manual testing. In many cases as the window is resized,
    the content reflows, and where the text overlaps, the image changes. One technique
    to ensure that contrast is always sufficient is to test the text color against
    both the lightest and darkest points of the image.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 验证当文本与图像重叠时颜色对比是否可访问是非常困难的，需要手动测试。在许多情况下，当窗口大小调整时，内容会重新布局，文本重叠的地方图像会改变。确保对比度始终足够的一种技术是测试文本颜色与图像最亮和最暗的部分。
- en: Also worth mentioning, and as clearly demonstrated in this project, the busier
    the image is, the more difficult achieving good readability becomes.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，正如在这个项目中清楚地展示的那样，图像越繁忙，实现良好可读性的难度就越大。
- en: Listing 9.13 Setting the container color
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.13 设置容器颜色
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: By updating this rule, we’ve made all text on the card white (figure 9.18).
    Our security code is on a white background, however, so we need to update its
    rule to change its text color to something darker.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更新此规则，我们已经将卡片上的所有文本更改为白色（图9.18）。然而，我们的安全代码是在白色背景上，因此我们需要更新其规则，将其文本颜色更改为较深的颜色。
- en: '![](../Images/09-18.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09-18.png)'
- en: Figure 9.18 Text color changed to white
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.18 文本颜色更改为白色
- en: To change the color of the text, we’ll update the `.card-item__cvvBand` rule
    (listing 9.14), which currently gives us the white band and positions the security
    code within. We’ll change the text color to a dark blue-gray.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改文本颜色，我们将更新`.card-item__cvvBand`规则（列表9.14），该规则目前为我们提供白色带并定位安全代码在其中。我们将文本颜色更改为深蓝灰色。
- en: Listing 9.14 Back-of-card white background
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.14 卡片背面白色背景
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With the visibility of our security code restored (figure 9.19), let’s turn
    our attention to the two text elements on the front of the card: *Card Holder*
    and *Expires*.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的安全代码可见性恢复（图9.19）后，让我们将注意力转向卡片前面的两个文本元素：*持卡人*和*到期日*。
- en: '![](../Images/09-19.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09-19.png)'
- en: Figure 9.19 Restored security code
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.19 恢复的安全代码
- en: In terms of information, these two pieces of text are there only to label the
    elements with which they’re paired, so they’re less important than the actual
    name and date. To diminish their importance visually, we’ll decrease their opacity
    (listing 9.15) to render them mildly translucent and decrease their brightness.
    In section 9.4, when we handle the typography, we’ll diminish their size for the
    same reason.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在信息方面，这两段文本仅用于标记与之配对的元素，因此它们的重要性不如实际名称和日期。为了在视觉上降低其重要性，我们将降低其不透明度（列表9.15），使其轻微半透明，并降低其亮度。在第9.4节中，当我们处理字体排印时，我们将出于同样的原因减小其大小。
- en: Listing 9.15 Styling the labeling text
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.15 标记文本的样式
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'At this point, the final appearance of the card is coming through (figure 9.20).
    We’ve styled the layout, format, images, and colors. But we still need to adjust
    the typography and create the main effect: the flip on hover. The next step is
    looking at the fonts.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，卡片的最终外观已经显现（图9.20）。我们已经设计了布局、格式、图像和颜色。但我们仍需要调整字体排印并创建主要效果：悬停时的翻转。下一步是查看字体。
- en: '![](../Images/09-20.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09-20.png)'
- en: Figure 9.20 Diminished text opacity
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.20 文本不透明度降低
- en: 9.4 Typography
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 字体排印
- en: For other projects, we used the free online resource Google Fonts to load the
    fonts we needed. We did this by linking to the Google Fonts application programming
    interface (API), requesting the fonts we needed, and then setting the property
    value to the font family we’re using. But in some cases, we may want to load our
    font files ourselves rather than depend on an API or a content distribution network
    (CDN).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他项目，我们使用了免费的在线资源Google Fonts来加载所需的字体。我们通过链接到Google Fonts应用程序编程接口（API），请求所需的字体，然后将属性值设置为正在使用的字体族。但在某些情况下，我们可能想自己加载字体文件，而不是依赖于API或内容分发网络（CDN）。
- en: WARNING Like images and other forms of media, fonts are subject to licensing.
    Always make sure that you have the appropriate licenses, regardless of how a font
    is being imported (API, CDN, or locally hosted) before using it on a website or
    in an application. When in doubt, ask your legal team!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：像图像和其他形式的媒体一样，字体受版权保护。在使用之前，无论字体是通过API、CDN还是本地托管导入，都务必确保您拥有适当的许可证。如有疑问，请咨询您的法律团队！
- en: Both approaches have benefits and drawbacks. Neither is overwhelmingly better
    than the other, so the choice comes down to the needs of the project we’re working
    on.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都有优点和缺点。没有一种是明显优于另一种的，所以选择取决于我们正在工作的项目的需求。
- en: The benefits of using local or self-hosted fonts include
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本地或自托管字体的好处包括
- en: We don’t have to depend on a third party.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不必依赖第三方。
- en: We have more control in terms of cross-browser support and performance optimization,
    which can make the font load time faster than that of a third-party font.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在跨浏览器支持和性能优化方面，我们有更多的控制权，这可以使字体加载时间比第三方字体更快。
- en: Drawbacks include
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点包括
- en: We have to do our own performance optimization.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须自己进行性能优化。
- en: The user won’t already have the font cached.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户不会预先缓存该字体。
- en: The advantages of using fonts hosted by a third party include
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第三方托管字体的优点包括
- en: The user may already have the font cached on their device.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可能已经在他们的设备上缓存了该字体。
- en: Importing is easier.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入更加简单。
- en: Drawbacks include
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点包括
- en: We need to make an extra call to fetch the font file.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要额外调用以获取字体文件。
- en: There are privacy concerns about what the third party is tracking.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于第三方跟踪的内容存在隐私问题。
- en: The service can discontinue the font at any time.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该服务可以在任何时候停止字体服务。
- en: To load our own fonts from our local project folder, we need to create `@font`
    `{}` at-rules to define and import the fonts we want to use. To understand this
    at-rule, let’s start by looking at font formats.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要从我们的本地项目文件夹加载自己的字体，我们需要创建 `@font` `{}` at 规则来定义和导入我们想要使用的字体。为了理解这个 at 规则，让我们先看看字体格式。
- en: 9.4.1 @font-face
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.1 @font-face
- en: Fonts can come in a few file types. Some well-known ones are
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 字体可以有多种文件类型。一些知名的包括
- en: '*TrueType (TTF**)*—Supported by all modern browsers; not compressed'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*TrueType (TTF)*—所有现代浏览器都支持；未压缩'
- en: '*Open Type (OTF**)*—Evolution of TTF; allows for more characters such as small
    caps and old-style figures'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开放字体格式 (OTF)*—TTF 的进化；允许使用更多字符，如小写字母和旧式数字'
- en: '*Embedded Open Type (EOT**)*—Developed by Microsoft for the web; supported
    only by Internet Explorer (obsolete because Internet Explorer has been end-of-lifed)'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*嵌入式开放字体格式 (EOT)*—微软为网页开发；仅由 Internet Explorer 支持（已过时，因为 Internet Explorer
    已停止服务）'
- en: '*Web Open Font Format (WOFF**)*—Created for the web; is compressed; includes
    metadata within the font file for copyright information; and is recommended by
    the World Wide Web Consortium ([https://www.w3.org/TR/WOFF2](https://www.w3.org/TR/WOFF2))'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Web 开放字体格式 (WOFF)*—为网页创建；已压缩；在字体文件中包含元数据以包含版权信息；并由万维网联盟推荐（[https://www.w3.org/TR/WOFF2](https://www.w3.org/TR/WOFF2)）'
- en: '*Web Open Font Format 2 (WOFF2**)*—Continuation of WOFF; 30% more compressed
    than WOFF'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Web 开放字体格式 2 (WOFF2)*—WOFF 的延续；比 WOFF 压缩 30%'
- en: '*Scalable Vector Graphic (SVG**)*—Created to allow embedding glyph information
    in SVGs before web fonts became widespread'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可缩放矢量图形 (SVG)*—创建用于在网页字体普及之前在 SVG 中嵌入字形信息'
- en: When you select a font type to use, we generally recommend using WOFF or WOFF2.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当你选择要使用的字体类型时，我们通常推荐使用 WOFF 或 WOFF2。
- en: Note Only recently have we been able to rely on WOFF2 files without having to
    upload multiple font formats. You can still find a lot of outdated information
    about fonts on the web. A trick that helps is looking at when the information
    was published—the more recently, the better.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们最近才能够在不上传多个字体格式的情况下依赖 WOFF2 文件。你仍然可以在网上找到很多关于字体的过时信息。一个有用的技巧是查看信息的发布时间——越近越好。
- en: 'When dealing with fonts, we know from previous chapters that we need to import
    each weight we want to use. The same is true for dealing with fonts locally: each
    variation (weight and style) needs to be included in the project individually
    unless we use a variable font.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理字体时，我们知道从前几章中，我们需要导入我们想要使用的每个粗细。对于本地处理字体也是同样的道理：每个变体（粗细和样式）都需要单独包含在项目中，除非我们使用可变字体。
- en: Variable fonts are fairly new. Rather than having each style in a separate file,
    all the permutations are included inside a single file. So if we wanted regular,
    bold, and semibold, we could import only one file instead of three, and we’d have
    access not only to those three font weights, but also to everything from thin
    to extra-bold. Italics may not be in the same file; in some typefaces, the italic
    glyphs are different from those of the non-italic versions.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 可变字体相对较新。与每个样式在单独的文件中不同，所有排列组合都包含在单个文件中。所以如果我们想要常规、粗体和半粗体，我们只需导入一个文件而不是三个，我们不仅能够访问这三个字体粗细，还能从细体到超粗体的一切。斜体可能不在同一个文件中；在某些字体中，斜体字形与非斜体版本的不同。
- en: 'For our project, we want to load three fonts: Open Sans normal, Open Sans bold,
    and Open Sans Italic. These fonts are variations within the same family. Open
    Sans has both static and variable font versions. The variable version separates
    italic and regular styles into two separate files. For our non-italic needs, because
    we’re loading multiple weights, we’ll use the variable version.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的项目，我们希望加载三种字体：Open Sans 正常体，Open Sans 粗体，和 Open Sans 斜体。这些字体是同一家族中的变体。Open
    Sans 有静态和可变字体版本。可变版本将斜体和常规样式分开到两个单独的文件中。对于我们的非斜体需求，因为我们正在加载多个粗细，我们将使用可变版本。
- en: 'For italic, however, we’re going to use only one weight: regular. It doesn’t
    make sense to load the variable font version for that weight. Because the variable
    font includes all the information necessary to cross the full gamut of weights,
    it’s significantly larger (314.8 KB) than the file that holds only one weight
    (17.8 KB). For performance reasons, it makes sense to stick with the static version.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于斜体，我们将只使用一个粗细：常规。对于该粗细加载可变字体版本没有意义。因为可变字体包含了跨越所有粗细范围所需的所有信息，所以它比只包含一个粗细的文件大得多（314.8
    KB），而后者只有 17.8 KB。出于性能考虑，坚持使用静态版本是有意义的。
- en: For each font, we need to create a separate `@font-face` rule. This at-rule
    defines the font and includes where the font is being loaded from, what its weight
    is, and how we want it to load.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个字体，我们需要创建一个单独的`@font-face`规则。此at规则定义了字体，包括字体从哪里加载，其粗细是多少，以及我们希望它如何加载。
- en: 'First, we declare the `@font-face` `{` `}` rule. Inside the curly braces, we’ll
    define its characteristics and behavior, including four descriptors:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明`@font-face` `{` `}` 规则。在大括号内，我们将定义其特性和行为，包括四个描述符：
- en: '`font-family`—The name we use to refer to our font when we apply it to an element
    via the `font-family` property.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`font-family`—当我们通过`font-family`属性将字体应用于元素时，我们用来引用字体的名称。'
- en: '`src`—Where the font is being loaded from. This descriptor takes a comma-delimited
    list of locations to fetch the font from and what format to expect from each source.
    The browser will go down the list, starting with the first one, until it fetches
    the font successfully.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`—字体正在从哪里加载。此描述符接受一个逗号分隔的列表，指定从哪些位置获取字体以及期望从每个源获取的格式。浏览器将按照列表顺序，从第一个开始，直到成功获取字体。'
- en: '`font-weight`—What weight this particular font file represents. In the case
    of variable fonts, we’ll include a range.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`font-weight`—此特定字体文件代表的粗细。在可变字体的情况下，我们将包括一个范围。'
- en: '`font-display`—Dictates how the font is loaded. We’ll use the descriptor value
    `swap`. Fonts are load-blocking, in that the browser will wait until they’re loaded
    before moving on to load other resources. `swap` limits the amount of time the
    font is allowed to be load-blocking. If the font isn’t done loading when that
    period is over, the browser will move on to load other resources and finish applying
    the font whenever the font is done loading. This setting allows content to be
    shown and the user to interact with the interface even if the font is not available
    yet.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`font-display`—指定字体的加载方式。我们将使用描述符值`swap`。字体是加载阻塞的，即浏览器会在加载其他资源之前等待字体加载完成。`swap`限制了字体加载阻塞的时间。如果在这个时间段结束时字体还没有加载完成，浏览器将继续加载其他资源，并在字体加载完成后应用字体。此设置允许在字体尚未可用的情况下显示内容，并允许用户与界面进行交互。'
- en: Listing 9.16 shows both of our rules, which must be added *at the top of the
    stylesheet.* Also, with a few exceptions, a rule can’t be declared inside an existing
    rule. `.myClass` `{` `@font-face` `{` `...` `}` `}` wouldn’t work, for example.
    One exception is the `@supports` at-rule, which we expand on in the next section.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.16 显示了我们的两个规则，这些规则必须添加到样式表的**顶部**。此外，除了少数例外，规则不能在现有规则内部声明。例如，`.myClass`
    `{` `@font-face` `{` `...` `}` `}` 不会工作。一个例外是`@supports` at 规则，我们将在下一节中对其进行扩展。
- en: Listing 9.16 Declaring our fonts
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.16 声明我们的字体
- en: '[PRE15]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ① The name we’ll use to refer to the font
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们将用来引用字体的名称
- en: ② If the browser can load the variable font, where to get the font from
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ② 如果浏览器可以加载可变字体，从哪里获取字体
- en: ③ The font will support any font size from 100 to 800.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 字体将支持从 100 到 800 的任何字体大小。
- en: ④ Checks the device to see whether it has the font loaded locally
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 检查设备是否已本地加载了字体
- en: ⑤ Tries to load woff2 format
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 尝试加载 woff2 格式
- en: ⑥ If woff2 isn’t supported, loads woff
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 如果不支持 woff2，则加载 woff
- en: ⑦ Declaring that the font weight for this file is normal (same as 400)
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 声明此文件的字体粗细为正常（与 400 相同）
- en: After this code is applied, there’s no change in the user interface; the `font-family`
    being used is still the browser’s default because we haven’t applied the fonts
    to any of our elements yet. We also want to create a fallback in case the browser
    doesn’t support variable fonts. Before we apply the font to our elements, let’s
    look at browser support.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用此代码后，用户界面没有变化；正在使用的`font-family`仍然是浏览器的默认字体，因为我们还没有将字体应用到任何我们的元素上。我们还想要创建一个回退，以防浏览器不支持可变字体。在我们将字体应用到我们的元素之前，让我们看看浏览器的支持情况。
- en: 9.4.2 Creating fallbacks using @supports
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.2 使用 @supports 创建回退
- en: Because variable fonts are fairly new, and because not everyone is good at running
    updates on their devices, we’ll include a fallback in case variable fonts aren’t
    supported by a user’s browser. For this purpose, we’ll use the `@supports` at-rule.
    This rule allows us to check whether the browser supports a particular property
    and value, and allows us to write CSS that gets applied only if the provided condition
    is met.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 由于变量字体相对较新，并且并非每个人都能很好地在其设备上运行更新，因此我们将包括一个回退，以防用户的浏览器不支持变量字体。为此，我们将使用`@supports`
    at规则。此规则允许我们检查浏览器是否支持特定的属性和值，并允许我们编写只有当提供的条件满足时才应用的CSS。
- en: Our feature query will be `@supports` `not` `(font-variation-settings:` `normal)`
    `{` `...` `}`. Because our query has the keyword `not` before the condition, the
    styles it contains will be applied when the condition is *not* being met. In other
    words, if the browser doesn’t support variable font behaviors, we want to load
    the static version.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的功能查询将是`@supports` `not` `(font-variation-settings:` `normal)` `{` `...` `}`。因为我们的查询在条件之前有`not`关键字，所以它包含的样式将在条件*不*满足时应用。换句话说，如果浏览器不支持变量字体行为，我们希望加载静态版本。
- en: Inside the `@supports` at-rule, which we place at the top of our file, we include
    the `@font-face` rules for both weights of the normal style version we want to
    include (listing 9.17). We also create an `@supports` `(font-variation-settings:`
    `normal)` `{` `}` rule, this time without the `not`. In this second at-rule for
    browsers that do support variable fonts, we move the two rules we created in section
    9.4.1\. This way, we load the variable fonts only if they’re supported by the
    browser and prevent the file from being loaded if the browser doesn’t support
    variable fonts.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们文件的最顶部放置的`@supports` at规则内部，我们包括了我们想要包含的正常样式版本两种字重的`@font-face`规则（列表9.17）。我们还创建了一个`@supports`
    `(font-variation-settings:` `normal)` `{` `}` 规则，这次没有使用`not`。在这种情况下，对于支持变量字体的浏览器，我们将9.4.1节中创建的两个规则移动过来。这样，我们只有在浏览器支持变量字体时才加载变量字体，如果浏览器不支持变量字体，则防止文件被加载。
- en: Listing 9.17 Fallback for browsers that don’t support variable fonts
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.17不支持变量字体的回退
- en: '[PRE16]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ① Applies styles when variable fonts are supported
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ① 当支持变量字体时应用样式
- en: ② Our previously created rule for the variable font, moved into the at-rule
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将我们之前创建的变量字体规则移动到at规则中
- en: ③ Applies styles when variable fonts aren’t supported
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 当不支持变量字体时应用样式
- en: ④ Rule for normal style, font weight regular (400)
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 正常样式的规则，字体粗细常规（400）
- en: ⑤ Rule for normal style, font weight bold (700)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 正常样式的规则，字体粗细加粗（700）
- en: With our fallback added, let’s update our body rule to apply Open Sans to our
    project (listing 9.18). Although we added fallbacks for loading the font, we’ll
    still include `sans-serif` in the `font-family` property value in the body rule
    in case our font files fail to load.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加回退后，让我们更新我们的body规则以将Open Sans应用到我们的项目中（列表9.18）。尽管我们添加了加载字体的回退，但我们仍将在body规则中的`font-family`属性值中包含`sans-serif`，以防字体文件加载失败。
- en: Listing 9.18 Applying the fonts to our project
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.18将字体应用到我们的项目中
- en: '[PRE17]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When the font is applied, we see that our text has been updated to use Open
    Sans rather than the browser default (figure 9.21). Now we can edit our individual
    elements for font weight and style.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当字体应用后，我们可以看到我们的文本已经更新为使用Open Sans而不是浏览器的默认字体（图9.21）。现在我们可以编辑我们的单个元素以调整字体粗细和样式。
- en: '![](../Images/09-21.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/09-21.png)'
- en: Figure 9.21 Open Sans applied to the project
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.21 Open Sans应用到项目中
- en: 9.4.3 Font sizing and typography improvements
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.3 字体大小和排版改进
- en: Starting with the front of the card, we’ll increase the font size of the numbers
    and make them bold. We’ll add to our existing rule, as shown in the following
    listing.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 从卡片的前面开始，我们将增加数字的字体大小并使其加粗。我们将添加到现有的规则中，如下所示。
- en: Listing 9.19 Boldfacing and increasing the size of the numbers
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.19加粗并增加数字的大小
- en: '[PRE18]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Figure 9.22 shows our styled numbers.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.22显示了我们的样式化数字。
- en: '![](../Images/09-22.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/09-22.png)'
- en: Figure 9.22 Styled numbers
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.22样式化数字
- en: Moving on to the text below the numbers, we want to decrease the size of *Card
    Holder* and *Expires*. We’ll set their `font-size` to `15px` and increase the
    size and `font-weight` of the name and date, as shown in the following listing.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是数字下面的文本，我们希望减小*卡片持有者*和*到期日*的大小。我们将它们的`font-size`设置为`15px`，并增加名称和日期的大小和`font-weight`，如下所示。
- en: Listing 9.20 Cardholder information and expiration-date typography
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.20持卡人信息和到期日期的排版
- en: '[PRE19]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ① Card Holder and Expires
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ① 卡片持有者和到期日
- en: ② Name and expiration date
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ② 姓名和到期日期
- en: With the text elements on the front of the card taken care of (figure 9.23),
    let’s turn our attention to the back.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完卡片正面的文本元素（图9.23）后，让我们将注意力转向背面。
- en: '![](../Images/09-23.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/09-23.png)'
- en: Figure 9.23 Typography of the front of the card
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.23 卡片正面的排版
- en: On the back, we need to update the security code to be in italics. We’ll update
    our existing rule with `font-style:` `italic`, as shown in the following listing.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在背面，我们需要更新安全代码使其为斜体。我们将使用`font-style:` `italic`更新现有的规则，如下所示。
- en: Listing 9.21 Italicizing the card security number
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.21 使卡片安全号码倾斜
- en: '[PRE20]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now that our card is styled (figure 9.24), we’re ready to apply the flip effect.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在卡片已经设置了样式（图9.24），我们准备应用翻转效果。
- en: '![](../Images/09-24.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/09-24.png)'
- en: Figure 9.24 Completed typography styles
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.24 完成的排版样式
- en: 9.5 Creating the flipping-over effect
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5 创建翻转效果
- en: Next, we’ll create the flipping-over effect for devices that support the `hover`
    interaction. We’ll start by adjusting the position to overlay the back of the
    card on top of the front. Then we’ll use the `backface-visibility` and `transform`
    properties to place the card. To animate the change, we’ll use a transition.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为支持`hover`交互的设备创建翻转效果。我们首先调整位置，使卡片背面覆盖在正面之上。然后，我们将使用`backface-visibility`和`transform`属性来放置卡片。为了实现动画变化，我们将使用过渡效果。
- en: 9.5.1 Position
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.1 位置
- en: To achieve the flip effect, we stack the card faces on top of one another via
    the `backface-visibility` property. Then we’ll toggle which side is shown. When
    we use the `backface-visibility` property and expose the back side, we perform
    a rotation on the horizontal axis; therefore, we need to invert the back so that
    its contents are mirrored. Imagine taking a piece of tracing paper and drawing
    an image on the back. When we look at the front, the image that appears through
    it from the back is mirrored. That effect is what we’re building here. The CSS
    we use to stack front and back and then flip the back is in listing 9.22\. We
    place our code inside a media query that checks whether the browser has `hover`
    functionality. We want to have the flip effect only on devices that support `hover`.
    For devices that don’t (such as mobile phones), we’ll show the front and the back
    at the same time.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现翻转效果，我们通过`backface-visibility`属性将卡片面堆叠在一起。然后我们将切换显示哪一面。当我们使用`backface-visibility`属性并暴露背面时，我们在水平轴上进行旋转；因此，我们需要反转背面，使其内容镜像。想象一下拿一张描图纸并在背面画一个图像。当我们看正面时，从背面通过它出现的图像是镜像的。这正是我们在这里要实现的效果。我们用来堆叠正面和背面然后翻转的CSS在列表9.22中。我们将代码放在一个媒体查询中，该查询检查浏览器是否有`hover`功能。我们希望在支持`hover`的设备上才有翻转效果。对于不支持`hover`的设备（如手机），我们将同时显示正面和背面。
- en: Listing 9.22 Positioning the back over the front
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.22 将背面定位在正面之上
- en: '[PRE21]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ① Flips the card
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ① 翻转卡片
- en: Earlier in this chapter, we set the `position` property value to `relative`
    in our `.card-item` rule. Using relative positioning on a parent or ancestor element
    goes hand in hand with the fact that we’re setting the `position` property value
    of the back of our card to `absolute`. The top and left positions of `0` will
    be the top-left section with the `card-item` class (the container that holds the
    two card faces).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我们在`.card-item`规则中设置了`position`属性的值为`relative`。在父元素或祖先元素上使用相对定位与我们将卡片背面`position`属性的值设置为`absolute`的事实相辅相成。`top`和`left`位置为`0`将是带有`card-item`类的顶部左区域（该容器包含两个卡片面）。
- en: Whenever we use `position:` `absolute`, we take the element out of the regular
    flow of the page and can set a specific position on the page on which to place
    the element. The position is calculated based on the closest ancestor with a `position`
    value of `relative`. If none is found, the top left will be the top-left corner
    of the page.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们使用`position:` `absolute`时，我们将元素从页面的常规流中移除，并可以在页面上设置一个特定的位置来放置该元素。位置是基于具有`position`值为`relative`的最接近的祖先元素来计算的。如果没有找到，则页面的左上角将是顶部左角。
- en: What gets a bit confusing here is that if no values are set to position the
    element (`top`, `left`, `right`, `bottom`, or `inset`), the element is placed
    wherever it normally would lie but takes up no space in the flow. The height and
    width of the element are also affected. If a value is provided in the CSS, the
    element maintains that value; otherwise, it takes up only as much room as it needs.
    Even if it’s a block-level element, it no longer takes up the full width available
    to it. Furthermore, if the width is set using a relative unit such as percentage,
    it will be calculated against the element to which it’s relative. Figure 9.25
    shows some scenarios for using `position:` `absolute`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里有点令人困惑的是，如果没有设置值来定位元素（`top`、`left`、`right`、`bottom`或`inset`），元素将放置在它通常所在的位置，但在流中不占用任何空间。元素的高度和宽度也会受到影响。如果CSS中提供了值，元素将保持该值；否则，它只占用所需的空间。即使它是一个块级元素，它也不再占用可用的全部宽度。此外，如果宽度使用相对单位（如百分比）设置，它将相对于它相关的元素进行计算。图9.25显示了使用`position:`
    `absolute`的一些场景。
- en: '![](../Images/09-25.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09-25.png)'
- en: Figure 9.25 Absolute positioning
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.25 绝对定位
- en: With our CSS applied (figure 9.26) and the back of the card flipped and on top
    of the front, we can apply the `backface-visibility` property.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的CSS应用（图9.26）卡片背面翻转并位于正面之上时，我们可以应用`backface-visibility`属性。
- en: '![](../Images/09-26.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09-26.png)'
- en: Figure 9.26 Back of the card positioned on top of front and flipped
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.26 卡片背面位于正面之上并翻转
- en: 9.5.2 Transitions and backface-visibility
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.2 过渡和backface-visibility
- en: Up to now, we’ve looked at objects in 2D space—in other words, a flat perspective.
    We’ve looked at width and height but not depth. Now we’ll consider that third
    dimension.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看了2D空间中的对象——换句话说，一个平面的视角。我们看了宽度和高度，但没有深度。现在我们将考虑第三个维度。
- en: With the back flipped, we need it to be hidden unless the user is hovering over
    the card. We have two sides, the second of which has a `transform:` `rotateY(-180deg)`
    declaration (the back). In a 3D space, therefore, that side is facing away from
    us. If we set the `backface-visibility` property value to be `hidden` on both
    sides, whichever side is facing away from us is hidden.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当背面翻转时，我们需要它在用户悬停在卡片上时才显示。我们有两个侧面，第二个侧面有一个`transform:` `rotateY(-180deg)`声明（背面）。在3D空间中，因此，这个侧面是背对着我们的。如果我们将`backface-visibility`属性值设置为`hidden`在两个侧面，那么背对着我们的侧面将被隐藏。
- en: Our back, which currently faces away from us, is hidden. If we rotate the entire
    card, the back faces us, and the front is hidden. Figure 9.27 diagrams how our
    CSS and HTML interact to create the flip effect.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前背对着我们的背面是隐藏的。如果我们旋转整个卡片，背面朝向我们，正面被隐藏。图9.27说明了我们的CSS和HTML如何交互以创建翻转效果。
- en: '![](../Images/09-27.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09-27.png)'
- en: Figure 9.27 The `backface-visibility` property applied to our use case
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.27 将`backface-visibility`属性应用于我们的用例
- en: 'In our CSS, we add the following rules and properties to our media query (listing
    9.23). They instruct the card to hide the side if it’s facing away from us and
    to rotate the entire card 180-degrees on the y-axis on hover. Notice a property
    that we haven’t talked about yet: `transform-style`, to which we’ve given a value
    of `preserve-3d`. Without this property, the flip won’t work. It tells the browser
    that we’re operating in 3D space rather than 2D space, establishing the concept
    of a front and a back.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的CSS中，我们向媒体查询（列表9.23）添加了以下规则和属性。它们指示卡片在背对我们时隐藏侧面，并在鼠标悬停时绕y轴旋转整个卡片180度。注意一个我们还没有讨论过的属性：`transform-style`，我们给它赋值为`preserve-3d`。没有这个属性，翻转将不会工作。它告诉浏览器我们正在3D空间中操作，而不是2D空间，从而建立了前后概念。
- en: Listing 9.23 Hiding the back and exposing it on `hover`
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.23 隐藏背面并在`hover`时显示
- en: '[PRE22]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ① Instructs the browser to operate as though we were in 3D space
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ① 指示浏览器像在3D空间中操作一样
- en: ② Hides the side facing away from us
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ② 隐藏背对着我们的侧面
- en: ③ On hover, flips the entire card around to expose the back side
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 在悬停时，翻转整个卡片以显示背面
- en: With our hover functionality exposing the back of our card (figure 9.28), we
    need to add the animation to make it look more like a card flip. Notice that the
    back is no longer mirrored.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的悬停功能暴露卡片背面（图9.28）时，我们需要添加动画使其看起来更像卡片翻转。注意背面不再镜像。
- en: '![](../Images/09-28.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09-28.png)'
- en: Figure 9.28 Card default state and on `hover`
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.28 卡片默认状态和`hover`状态
- en: Currently, when we hover over the card, the back is shown instantaneously. We
    want to make it look as though the card is actually being flipped.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，当我们悬停在卡片上时，背面会立即显示。我们希望让它看起来像卡片实际上正在被翻动。
- en: 9.5.3 The transition property
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.3 过渡属性
- en: To animate the card flip, we’ll use a transition. You may recall from chapter
    5 that transitions are used to animate the change of CSS. In this case, we’ll
    animate the change in the rotation of the card by adding a transition declaration
    to the `card-item` (container that holds the two faces). We’ll also add a condition
    to our media query.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 为了动画化卡片翻动，我们将使用一个过渡。你可能还记得第5章中提到的，过渡用于动画化CSS的变化。在这种情况下，我们将通过向`card-item`（包含两个面的容器）添加过渡声明来动画化卡片的旋转变化。我们还将向媒体查询添加一个条件。
- en: Because this animation is motion-heavy, we want to make sure to respect our
    users’ settings. Therefore, we’ll add a `prefers-reduced-motion:` `no-preference`
    condition to our media query, as shown in the following listing.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个动画动作较多，我们想要确保尊重用户的设置。因此，我们将在媒体查询中添加一个`prefers-reduced-motion:` `no-preference`条件，如下所示。
- en: Listing 9.24 Transitions and `transform`
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.24 过渡和`transform`
- en: '[PRE23]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Our animation, which takes 350 milliseconds, affects the `transform` property
    (the rotation) and is present only for users who don’t have `prefers-reduced-motion`
    set to `reduce` on their devices. Figure 9.29 shows the progression of the animation,
    and figure 9.30 shows the user interface when the user has `prefers-reduced-motion`
    enabled.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们动画的持续时间是350毫秒，它影响`transform`属性（旋转），并且仅对那些在设备上未将`prefers-reduced-motion`设置为`reduce`的用户可见。图9.29显示了动画的进度，图9.30显示了用户界面，当用户启用了`prefers-reduced-motion`时。
- en: '![](../Images/09-29.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09-29.png)'
- en: Figure 9.29 Animation over time
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.29 时间上的动画
- en: For our timing function, we used a `cubic-bezier()` function. Next, let’s take
    a closer look at what this function represents.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的时间函数，我们使用了`cubic-bezier()`函数。接下来，让我们更详细地看看这个函数代表什么。
- en: '![](../Images/09-30.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09-30.png)'
- en: Figure 9.30 `prefers-reduced-motion:` `reduce` emulation in Chrome DevTools
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.30 Chrome DevTools中`prefers-reduced-motion:` `reduce`模拟的`prefers-reduced-motion:`
    `reduce`
- en: 9.5.4 The cubic-bezier() function
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.4 cubic-bezier()函数
- en: 'The Bézier curve is named after French engineer Pierre Bézier, who used these
    curves on the bodywork of Renault cars ([http://mng.bz/d1NX](http://mng.bz/d1NX)).
    A Bézier curve is composed of four points: P[0], P[1], P[2], and P[3]. P[0] and
    P[3] represent the starting and ending points, and P[1] and P[2] are the handles
    on the points. Point and handle values are set with x and y coordinates (figure
    9.31).'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 贝塞尔曲线是以法国工程师皮埃尔·贝塞尔的名字命名的，他在雷诺汽车的车身上使用了这些曲线([http://mng.bz/d1NX](http://mng.bz/d1NX))。贝塞尔曲线由四个点组成：P[0]、P[1]、P[2]和P[3]。P[0]和P[3]代表起始点和结束点，而P[1]和P[2]是点的句柄。点和句柄的值通过x和y坐标设置（图9.31）。
- en: '![](../Images/09-31.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09-31.png)'
- en: Figure 9.31 Points and handles on the Bézier curve
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.31 贝塞尔曲线上的点和句柄
- en: 'In CSS, we need to worry about only the handles because the P[0] and P[3] values
    are set for us to `(0,` `0)` and `(1,` `1)`, respectively. By manipulating the
    curve, we change the acceleration of the animation. In CSS, our function takes
    four parameters that represent the `x` and `y` values of P[1] and P[2]: `cubic-bezier(x1,`
    `y1,` `x2,` `y2)`, where the `x` values must remain between `0` and `1`, inclusive.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在CSS中，我们只需要担心句柄，因为P[0]和P[3]的值分别被设置为`(0,` `0)`和`(1,` `1)`。通过操纵曲线，我们改变动画的加速度。在CSS中，我们的函数接受四个参数，代表P[1]和P[2]的`x`和`y`值：`cubic-bezier(x1,`
    `y1,` `x2,` `y2)`，其中`x`值必须在`0`和`1`之间，包括`0`和`1`。
- en: The premade timing functions we used in previous chapters for both our transitions
    and our animations have `cubic-bezier()` values by which they can be represented
    (figure 9.32).[¹](#pgfId-1103713)
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中用于过渡和动画的预定义时间函数都有`cubic-bezier()`值，它们可以通过这些值来表示（图9.32）。[¹](#pgfId-1103713)
- en: '![](../Images/09-32.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09-32.png)'
- en: Figure 9.32 Predefined curves
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.32 预定义的曲线
- en: Writing our own `cubic-bezier()` functions to animate our designs can be tedious.
    Luckily, online tools such as [https://cubic-bezier.com](https://cubic-bezier.com)
    allow us to see the curve and determine the values (figure 9.33).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 编写我们自己的`cubic-bezier()`函数来动画化我们的设计可能会很繁琐。幸运的是，像[https://cubic-bezier.com](https://cubic-bezier.com)这样的在线工具允许我们查看曲线并确定值（图9.33）。
- en: '![](../Images/09-33.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09-33.png)'
- en: Figure 9.33 An example `cubic-bezier()` function from cubic-bezier.com
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.33 来自cubic-bezier.com的一个示例`cubic-bezier()`函数
- en: We can also see the `cubic-bezier()` in some browser developer tools, such as
    those of Mozilla Firefox (figure 9.34).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在某些浏览器开发者工具中看到`cubic-bezier()`，例如Mozilla Firefox中的那些（图9.34）。
- en: '![](../Images/09-34.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09-34.png)'
- en: Figure 9.34 Firefox DevTools curve details
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.34 Firefox DevTools曲线细节
- en: With our animation completed, let’s add some finishing touches to our project.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的动画完成后，让我们给我们的项目添加一些收尾工作。
- en: 9.6 Border radius
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.6 边框半径
- en: Most credit cards have rounded corners, so we’re going to round ours as well.
    We’ll also round the corners of the white CVV box on the back of the card.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数信用卡都有圆角，所以我们将我们的也做成圆角。我们还将圆角应用于卡片背面的白色CVV框。
- en: Adding rounded corners to a user interface can be a balancing act. We’ll add
    rounded corners to the card to make it look more natural and realistic. Sharp
    corners can come across as aggressive, but overuse of rounded corners can make
    an interface look too soft and playful, which may not work in all cases. The “correct”
    amount of curve is design-specific. To make our card look more realistic, we’ll
    add the following CSS.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户界面中添加圆角可能是一种平衡行为。我们将给卡片添加圆角，使其看起来更自然、更逼真。尖锐的角可能显得过于激进，但过度使用圆角可能会使界面看起来过于柔和和俏皮，这可能在所有情况下都不适用。正确的曲线量是设计特定的。为了使我们的卡片看起来更逼真，我们将添加以下CSS。
- en: Listing 9.25 Adding `border-radius`
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.25 添加`border-radius`
- en: '[PRE24]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ① The card
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: ① 卡片
- en: ② White CVV band
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: ② 白色CVV带
- en: With the rounded corners, our card looks like figure 9.35.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 有圆角后，我们的卡片看起来像图9.35。
- en: '![](../Images/09-35.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09-35.png)'
- en: Figure 9.35 Rounded corners on the card and CVV band
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.35 卡片和CVV带的圆角
- en: 9.7 Box and text shadows
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.7 盒子和文本阴影
- en: In chapter 4, we looked briefly at the `drop-shadow` value, which can be applied
    to the `filter` property for image filters. Another way to apply a shadow to an
    element is via the `box-shadow` property, which applies a shadow to the element
    box.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4章中，我们简要介绍了`drop-shadow`值，该值可以应用于`filter`属性以进行图像过滤。将阴影应用于元素的另一方法是使用`box-shadow`属性，该属性将阴影应用于元素框。
- en: 9.7.1 The drop-shadow function versus the box-shadow property
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7.1 drop-shadow函数与box-shadow属性的区别
- en: 'We may be wondering about the difference between the `drop-shadow` filter property
    and the `box-shadow` property. Both have the same base set of values, but the
    `box-shadow` property has an additional two nonmandatory values: `spread-radius`
    and `inset`.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会想知道`drop-shadow`过滤器属性和`box-shadow`属性之间的区别。它们都有相同的基本值集，但`box-shadow`属性有两个非必选值：`spread-radius`和`inset`。
- en: The benefit of using a filter with the `drop-shadow` property on images is that
    when we’re using a filter, the shadow is applied to the alpha mask rather than
    the bounding box. So if we have a PNG or SVG image, and that image has transparent
    areas, the shadow is applied around that transparency. If we add a `box-shadow`
    to the same image rather than the filter, the shadow is applied only to the outer
    image container (figure 9.36).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有`drop-shadow`属性的过滤器在图像上的好处是，当我们使用过滤器时，阴影应用于alpha蒙版而不是边界框。因此，如果我们有一个PNG或SVG图像，并且该图像有透明区域，阴影将应用于该透明区域周围。如果我们向同一图像添加`box-shadow`而不是过滤器，阴影将仅应用于外部图像容器（图9.36）。
- en: '![](../Images/09-36.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09-36.png)'
- en: Figure 9.36 Comparing `box-shadow` (left) and `drop-shadow` (right)
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.36 比较`box-shadow`（左）和`drop-shadow`（右）
- en: To reinforce the 3D effect on the card and make the card appear to be floating,
    we’re going to give our card a shadow. Because we’re concerned only about giving
    the bounding area of the card a shadow, we can use the `box-shadow` property,
    which will give the project a sense of depth and further emphasize that something
    is on the back. The shadow will be large, soft, and fairly transparent. To achieve
    that effect, we’ll add `box-shadow:` `0` `20px` `60px` `0` `rgb(14` `42` `90`
    `/` `0.55);` to our `.card-item__side` rule. Our updated rule looks like the following
    listing.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加强卡片上的3D效果并使卡片看起来像是在漂浮，我们将给我们的卡片添加一个阴影。因为我们只关心给卡片的边界区域添加阴影，所以我们可以使用`box-shadow`属性，这将给项目带来深度感，并进一步强调有东西在背面。阴影将很大、很柔和，并且相当透明。为了达到这种效果，我们将向`.card-item__side`规则添加`box-shadow:`
    `0` `20px` `60px` `0` `rgb(14` `42` `90` `/` `0.55);`。我们的更新规则如下所示。
- en: Listing 9.26 Using `box-shadow` on our card
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.26 在我们的卡片上使用`box-shadow`
- en: '[PRE25]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Figure 9.37 shows our updated card.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.37显示了我们的更新后的卡片。
- en: '![](../Images/09-37.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09-37.png)'
- en: Figure 9.37 Added shadow to make the card appear to be floating
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.37 添加阴影使卡片看起来像是在漂浮
- en: 9.7.2 Text shadows
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7.2 文本阴影
- en: We can also add shadows to text. If we applied a `box-shadow` to text, the shadow
    would be applied to the box containing the text, not to the individual letters.
    To add a shadow to the letters, we use the `text-shadow` property, which has the
    same syntax as the `box-shadow` property. We’ll use this property on the front
    of the card to lift the text from the background. We need to add this property
    to our `.front` rule, as shown in the following listing.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以给文本添加阴影。如果我们给文本应用 `box-shadow`，阴影将应用于包含文本的框，而不是单个字母。要给字母添加阴影，我们使用 `text-shadow`
    属性，其语法与 `box-shadow` 属性相同。我们将在卡片的正面使用这个属性来提升文本与背景的分离。我们需要将这个属性添加到我们的 `.front`
    规则中，如下面的列表所示。
- en: Listing 9.27 Text shadow for all the text elements on the front of the card
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.27 卡片正面所有文本元素的文本阴影
- en: '[PRE26]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Figure 9.38 shows the card before and after.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.38 展示了添加阴影前后的卡片。
- en: '![](../Images/09-38.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![图片 9.38](../Images/09-38.png)'
- en: Figure 9.38 Before and after adding the `text-shadow`
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.38 添加 `text-shadow` 前后对比
- en: Although the effect is subtle, the added shadow makes the numbers pop out a
    bit. It’s worth noting that this effect is best used with finesse and sparingly,
    as it can easily impede readability rather than help it.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然效果微妙，但添加的阴影使数字显得更加突出。值得注意的是，这种效果最好谨慎且适度地使用，因为它可能会妨碍可读性而不是帮助它。
- en: 9.8 Wrapping up
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.8 总结
- en: The last detail we need to handle deals with users who aren’t interacting with
    the flip effect but are viewing both sides of the card at the same time (devices
    that don’t have hover capabilities, such as phones and tablets, and users with
    a `prefers-reduced-motion` setting). Currently when both sides are displayed,
    there’s no space between the card faces. So let’s add some margin to the bottom
    of the faces to separate them, as shown in the following listing.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个需要处理的问题是关于那些不与翻页效果交互但同时在查看卡片两面（如没有悬停功能的设备，如手机和平板，以及设置了 `prefers-reduced-motion`
    的用户）的用户。目前当两面都显示时，卡片面之间没有空间。因此，让我们在面底部添加一些边距以分隔它们，如下面的列表所示。
- en: Listing 9.28 Separating the card faces
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.28 分隔卡片面
- en: '[PRE27]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ① URL truncated for legibility
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: ① URL 被截断以提高可读性
- en: On a Moto G4 device, our card looks like figure 9.39.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Moto G4 设备上，我们的卡片看起来像图 9.39。
- en: '![](../Images/09-39.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![图片 9.39](../Images/09-39.png)'
- en: Figure 9.39 Our project on a mobile device
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.39 移动设备上的我们的项目
- en: With this last addition, our project is complete. Using a combination of media
    queries, shadows, positioning, and transitions, we created a realistic-looking
    card (figure 9.40).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个最后的添加，我们的项目就完成了。通过结合使用媒体查询、阴影、定位和过渡，我们创建了一个看起来逼真的卡片（图 9.40）。
- en: '![](../Images/09-40.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![图片 9.40](../Images/09-40.png)'
- en: Figure 9.40 Finished project
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.40 完成项目
- en: Summary
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: We can alter the box model’s behavior through the `box-sizing` property.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过 `box-sizing` 属性改变盒模型的行为。
- en: The `background` property value `cover` allows us to show as much of a background
    image as possible while still covering the full element.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`background` 属性的值 `cover` 允许我们在覆盖整个元素的同时尽可能多地显示背景图像。'
- en: Although fonts come in a range of formats, for the web we need only the WOFF
    and WOFF2 formats.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然字体有多种格式，但对于网页来说，我们只需要 WOFF 和 WOFF2 格式。
- en: Fonts can be static or variable.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字体可以是静态的或可变的。
- en: We use the `@font-face` at-rule to define where and how fonts are imported and
    how they should behave.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `@font-face` 规则来定义字体在哪里以及如何导入，以及它们应该如何表现。
- en: The `@font-face` at-rule needs to be at the top of the stylesheet.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@font-face` 规则需要放在样式表的顶部。'
- en: The `@supports` at-rule allows us to create styles specific to a browser’s functionality.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@supports` 规则允许我们创建针对浏览器功能的特定样式。'
- en: The `backface-visibility` property used in conjunction with `transform-style:`
    `preserve-3d` creates a flip effect.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '与 `transform-style: preserve-3d` 结合使用的 `backface-visibility` 属性创建了一个翻页效果。'
- en: The `cubic-bezier()`function defines how our elements will animate over time.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cubic-bezier()` 函数定义了我们的元素如何随时间动画。'
- en: The `box-shadow` property allows us to add a shadow to an element’s box.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`box-shadow` 属性允许我们给元素添加阴影。'
- en: '`text-shadow` rather than `box-shadow` is the property we use to add a shadow
    to individual letters of text.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text-shadow` 而不是 `box-shadow` 是我们用来给单个文字字母添加阴影的属性。'
- en: '* * *'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '***'
- en: '¹  *Architecting CSS: The Programmer’s Guide to Effective Style Sheets,* by
    Martine Dowden and Michael Dowden (2020, Apress).'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: ¹  《架构 CSS：程序员高效样式表指南》，作者 Martine Dowden 和 Michael Dowden (2020, Apress)。
