- en: 10 The pipeline, deeper
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 管道，更深入
- en: At this point, you’ve learned to be pretty effective with PowerShell’s pipeline.
    Running commands (e.g., `Get-Process` `|` `Sort-Object` `VM` `-desc` `|` `ConvertTo-Html`
    `|` `Out-File procs.html`) is powerful, accomplishing in one line what used to
    take several lines of script. But you can do even better. In this chapter, we
    dig deeper into the pipeline and uncover some of its most powerful capabilities,
    which allow you to pass data between commands the right way with less work.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学会了如何有效地使用PowerShell的管道。运行命令（例如，`Get-Process` `|` `Sort-Object` `VM`
    `-desc` `|` `ConvertTo-Html` `|` `Out-File procs.html`）非常强大，一行就能完成过去需要几行脚本才能完成的工作。但你可以做得更好。在本章中，我们将更深入地探讨管道，并揭示其一些最强大的功能，这些功能允许你以更少的努力正确地在命令之间传递数据。
- en: '10.1 The pipeline: Enabling power with less typing'
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 管道：通过更少的输入实现强大功能
- en: One of the reasons we like PowerShell so much is that it enables us to be more
    effective administrators without having to write complex scripts, as we used to
    have to do in Bash. The key to powerful one-line commands lies in the way the
    PowerShell pipeline works.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们非常喜欢PowerShell的一个原因是可以让我们成为更有效的管理员，而无需编写复杂的脚本，就像我们过去在Bash中必须做的那样。强大的一行命令的关键在于PowerShell管道的工作方式。
- en: 'Let us be clear: you could skip this chapter and still be effective with PowerShell,
    but in most cases you’d have to resort to Bash-style scripts and programs. Although
    PowerShell’s pipeline capabilities can be complicated, they’re probably easier
    to learn than more-complicated programming skills. By learning to manipulate the
    pipeline, you can be much more effective without needing to write scripts.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们明确一下：你可以跳过这一章，仍然有效地使用PowerShell，但在大多数情况下，你将不得不求助于Bash风格的脚本和程序。尽管PowerShell的管道功能可能很复杂，但它们可能比更复杂的编程技能更容易学习。通过学习如何操作管道，你可以更加高效，而无需编写脚本。
- en: The whole idea here is to get the shell to do more of your work for you, with
    as little typing as possible. We think you’ll be surprised at how well the shell
    can do that!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这里整个想法是让shell为你做更多的工作，尽可能少地输入。我们认为你会对shell能做得有多好感到惊讶！
- en: 10.2 How PowerShell passes data down the pipeline
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 PowerShell如何将数据传递到管道中
- en: 'Whenever you string together two commands, PowerShell has to figure out how
    to get the output of the first command to the input of the second command. In
    the upcoming examples, we refer to the first command as *Command A*. That’s the
    command that produces something. The second command is *Command B*, which needs
    to accept Command A’s output and then do its own thing:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你将两个命令串联起来时，PowerShell必须找出如何将第一个命令的输出传递到第二个命令的输入。在即将到来的示例中，我们将第一个命令称为*命令A*。这是产生内容的命令。第二个命令是*命令B*，它需要接受命令A的输出，然后执行自己的操作：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For example, suppose you have a text file that contains one module name on each
    line, as shown in figure 10.1.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个文本文件，每行包含一个模块名称，如图10.1所示。
- en: '![](Images/CH10_F01_Plunk.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH10_F01_Plunk.png)'
- en: Figure 10.1 Creating a text file containing module names, with one name per
    line in VS Code
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 在VS Code中创建包含模块名称的文本文件，每行一个名称
- en: 'You might want to use those module names as the input to a command, telling
    that command which module you want it to run against. Consider this example:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望使用那些模块名称作为命令的输入，告诉该命令你希望它针对哪个模块运行。考虑以下示例：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When `Get-Content` runs, it places the module names into the pipeline. PowerShell
    then has to decide how to get those to the `Get-Command` command. The trick with
    PowerShell is that commands can accept input only through parameters. PowerShell
    has to figure out which parameter of `Get-Command` will accept the output of `Get-Content`.
    This figuring-out process is called *pipeline parameter binding*, and it’s what
    we cover in this chapter. PowerShell has two methods for getting the output of
    `Get-Content` onto a parameter of `Get-Command`. The first method the shell will
    try is called `ByValue`; if that doesn’t work, it’ll try `ByPropertyName`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Get-Content`运行时，它将模块名称放入管道。PowerShell随后必须决定如何将这些内容传递给`Get-Command`命令。PowerShell的技巧是命令只能通过参数接受输入。PowerShell必须找出`Get-Command`的哪个参数可以接受`Get-Content`的输出。这个找出过程被称为*pipeline
    parameter binding*，这是我们本章要介绍的内容。PowerShell有两种方法将`Get-Content`的输出传递到`Get-Command`的参数上。shell将尝试的第一种方法称为`ByValue`；如果这不起作用，它将尝试`ByPropertyName`。
- en: '10.3 Plan A: Pipeline input ByValue'
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 计划A：Pipeline输入ByValue
- en: 'With this method of pipeline parameter binding, PowerShell looks at the type
    of object produced by Command A and tries to see whether any parameter of Command
    B can accept that type of object from the pipeline. You can determine this for
    yourself: First pipe the output of Command A to `Get-Member` to see what type
    of object Command A is producing. Then examine the full help of Command B (e.g.,
    `Get-Help` `Get-Command` `-Full`) to see whether any parameter accepts that type
    of data from the pipeline `ByValue`. Figure 10.2 shows what you might discover.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种管道参数绑定方法，PowerShell 会查看命令 A 生成的对象类型，并尝试查看命令 B 的任何参数是否可以接受来自管道的该类型对象。你可以自己确定这一点：首先将命令
    A 的输出通过管道传递到 `Get-Member` 以查看命令 A 生成的对象类型。然后检查命令 B 的完整帮助（例如，`Get-Help` `Get-Command`
    `-Full`）以查看是否有任何参数接受来自管道 `ByValue` 的该类型数据。图 10.2 展示了你可能会发现的内容。
- en: '![](Images/CH10_F02_Plunk.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH10_F02_Plunk.png)'
- en: Figure 10.2 Comparing the output of `Get-Content` to the input parameters of
    `Get-Command`
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 比较 `Get-Content` 的输出与 `Get-Command` 的输入参数
- en: What you’ll find is that `Get-Content` produces objects of the type `System.String`
    (or `String` for short). You’ll also find that `Get-Command` does have a parameter
    that accepts `String` from the pipeline `ByValue`. The problem is that it’s the
    `-Name` parameter, which according to the help “specifies an array of names. This
    cmdlet gets only commands that have the specified name.” That isn’t what we want—our
    text file, and therefore our `String` objects, are module names, not command names.
    If we ran
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现 `Get-Content` 生成 `System.String` 类型的对象（或简称为 `String`）。你还会发现 `Get-Command`
    确实有一个参数可以接受来自管道 `ByValue` 的 `String`。问题是它是 `-Name` 参数，根据帮助信息，“指定了一个名称数组。此 cmdlet
    仅获取具有指定名称的命令。”这不是我们想要的——我们的文本文件，因此我们的 `String` 对象是模块名称，而不是命令名称。如果我们运行
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: we’d be attempting to retrieve commands named `Microsoft.PowerShell.Archive`
    and so forth, which is probably not going to work.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试检索名为 `Microsoft.PowerShell.Archive` 等的命令，这可能不会成功。
- en: If multiple parameters accept the same type from the pipeline, all parameters
    will receive the same value. Because the `-Name` parameter accepts `String` from
    the pipeline `ByValue`, for all practical purposes, no other parameter can do
    so. That dashes our hopes for trying to pipe module names from our text file to
    `Get-Command`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多个参数接受来自管道的相同类型，则所有参数都将接收相同的值。因为 `-Name` 参数接受来自管道 `ByValue` 的 `String`，所以从实际应用的角度来看，没有其他参数可以这样做。这打破了我们尝试将模块名称从我们的文本文件通过管道传递到
    `Get-Command` 的希望。
- en: 'In this case, pipeline input is working, but it isn’t achieving the results
    we’re hoping for. Let’s consider a different example, where we do get the results
    we want. Here’s the command line:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，管道输入正在工作，但它并没有达到我们希望的结果。让我们考虑一个不同的例子，其中我们确实得到了我们想要的结果。以下是命令行：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let’s pipe the output of Command A to `Get-Member` and examine the full help
    for Command B. Figure 10.3 shows what you’ll find.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将命令 A 的输出通过管道传递到 `Get-Member` 并检查命令 B 的完整帮助。图 10.3 展示了你将发现的内容。
- en: '![](Images/CH10_F03_Plunk.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH10_F03_Plunk.png)'
- en: Figure 10.3 Binding the output of `Get-Content` to a parameter of `Get-Module`
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 将 `Get-Content` 的输出绑定到 `Get-Module` 的参数
- en: '`Get-Content` produces objects of the type `String`. `Get-Module` can accept
    those `string` objects from the pipeline `ByValue`; it does so on its `-Name`
    parameter. According to the help, that parameter “specifies names or name patterns
    of modules that this cmdlet gets.” In other words, Command A gets one or more
    `String` objects, and Command B tries to find a module with the name in the string.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`Get-Content` 生成 `String` 类型的对象。`Get-Module` 可以从管道 `ByValue` 接受这些 `string`
    对象；它在 `-Name` 参数上这样做。根据帮助信息，该参数“指定了 cmdlet 获取的模块的名称或名称模式。”换句话说，命令 A 获取一个或多个 `String`
    对象，而命令 B 尝试找到字符串中的名称对应的模块。'
- en: Tip For the most part, commands sharing the same noun (as `Get-Process` and
    `Stop-Process` do) can usually pipe to each other `ByValue`. Take some time to
    see if you can pipe the output of `Get-Process` to `Stop-Process`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：大多数情况下，具有相同名词（如 `Get-Process` 和 `Stop-Process`）的命令通常可以相互通过 `ByValue` 管道传递。花点时间看看你是否可以将
    `Get-Process` 的输出通过管道传递到 `Stop-Process`。
- en: 'Let’s cover one more example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再举一个例子：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: On the face of it, this might not seem to make any sense. But let’s see this
    through by piping Command A’s output to `Get-Member` and reexamining the help
    for Command B. Figure 10.4 shows what you should find.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，这可能没有意义。但让我们通过将命令 A 的输出通过管道传递到 `Get-Member` 并重新检查命令 B 的帮助来探究这个问题。图 10.4
    展示了你应该发现的内容。
- en: '![](Images/CH10_F04_Plunk.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH10_F04_Plunk.png)'
- en: Figure 10.4 Examining the output of `Get-ChildItem` and the input parameters
    of `Stop-Process`
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 检查`Get-ChildItem`的输出和`Stop-Process`的输入参数
- en: '`Get-ChildItem` produces objects of the type `FileInfo` (technically, `System.IO.FileInfo`,
    but you can usually take the last bit of the `TypeName` as a shortcut). Unfortunately,
    there isn’t a single parameter of `Stop-Process` that can accept a `FileInfo`
    object. The `ByValue` approach has failed, and PowerShell will try its backup
    plan: `ByPropertyName`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`Get-ChildItem`产生`FileInfo`类型的对象（技术上，是`System.IO.FileInfo`，但你通常可以将`TypeName`的最后部分作为快捷方式）。不幸的是，`Stop-Process`没有单个参数可以接受`FileInfo`对象。`ByValue`方法失败了，PowerShell将尝试其备份计划：`ByPropertyName`。'
- en: '10.4 Plan B: Pipeline input ByPropertyName'
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 计划B：通过属性名管道输入
- en: 'With this approach, you’re still looking to attach the output of Command A
    to parameters of Command B. But `ByPropertyName` is slightly different from `ByValue`.
    With this backup method, it’s possible for multiple parameters of Command B to
    become involved. Once again, pipe the output of Command A to `Get-Member`, and
    then look at the syntax for Command B. Figure 10.5 shows what you should find:
    the output of Command A has one property whose name corresponds to a parameter
    on Command B.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，你仍然希望将命令A的输出连接到命令B的参数。但`ByPropertyName`与`ByValue`略有不同。在这个备份方法中，命令B的多个参数可能都会被涉及。再次将命令A的输出通过管道连接到`Get-Member`，然后查看命令B的语法。图10.5显示了你应该找到的内容：命令A有一个属性名称与命令B上的参数相对应。
- en: '![](Images/CH10_F05_Plunk.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH10_F05_Plunk.png)'
- en: Figure 10.5 Mapping properties to parameters
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 将属性映射到参数
- en: 'A lot of folks overthink what’s happening here, so let’s be clear on how simple
    the shell is being: it’s looking for property names that match parameter names.
    That’s it. Because the property `Name` is spelled the same as the parameter `-Name`,
    the shell tries to connect the two.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人对这里发生的事情想得太多，所以让我们明确一下shell是如何简单的：它正在寻找与参数名称匹配的属性名称。就是这样。因为属性`Name`的拼写与参数`-Name`相同，shell试图将两者连接起来。
- en: But it can’t do so right away; first it needs to see whether the `-Name` parameter
    will accept input from the pipeline `ByPropertyName`. A glance at the full help,
    shown in figure 10.6, is required to make this determination.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 但它不能立即这样做；首先它需要查看`-Name`参数是否会接受来自管道`ByPropertyName`的输入。需要查看完整的帮助信息，如图10.6所示，以做出这个判断。
- en: '![](Images/CH10_F06_Plunk.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH10_F06_Plunk.png)'
- en: Figure 10.6 Checking to see whether the `Stop-Process` command’s `-Name` parameter
    accepts pipeline input `ByPropertyName`
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 检查`Stop-Process`命令的`-Name`参数是否接受管道输入`ByPropertyName`
- en: 'In this case, `-Name` does accept pipeline input `ByPropertyName`, so this
    connection works. Now, here’s the trick: unlike `ByValue`, which involves only
    one parameter, `ByPropertyName` connects every matching property and parameter
    (provided each parameter has been designed to accept pipeline input `ByPropertyName`).
    In our current example, only `Name` and `-Name` match. The results? Examine figure
    10.7.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`-Name`确实接受来自管道`ByPropertyName`的输入，因此这个连接是有效的。现在，这里有个技巧：与只涉及一个参数的`ByValue`不同，`ByPropertyName`将每个匹配的属性和参数（假设每个参数都设计为接受管道输入`ByPropertyName`）连接起来。在我们的当前示例中，只有`Name`和`-Name`匹配。结果如何？请查看图10.7。
- en: '![](Images/CH10_F07_Plunk.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH10_F07_Plunk.png)'
- en: Figure 10.7 Attempting to pipe `Get-ChildItem` to `Stop-Process`
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 尝试将`Get-ChildItem`管道连接到`Stop-Process`
- en: We see a bunch of error messages. The problem is that filenames are usually
    things like chapter7.zip and computers.txt, whereas the process’s executables
    might be things like `pwsh`. `Stop-Process` deals only with those executable names.
    But even though the `Name` property connects to the `-Name` parameter via the
    pipeline, the values inside the `Name` property don’t make sense to the `-Name`
    parameter, which leads to the errors.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了一堆错误信息。问题是，文件名通常是像chapter7.zip和computers.txt这样的东西，而进程的可执行文件可能是像`pwsh`这样的东西。`Stop-Process`只处理这些可执行文件名。尽管`Name`属性通过管道连接到`-Name`参数，但`Name`属性内的值对`-Name`参数来说是没有意义的，这导致了错误。
- en: Let’s look at a more successful example. Create a simple CSV file in Visual
    Studio Code, using the example in figure 10.8.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个更成功的例子。在Visual Studio Code中创建一个简单的CSV文件，使用图10.8中的示例。
- en: '![](Images/CH10_F08_Plunk.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH10_F08_Plunk.png)'
- en: Figure 10.8 Create this CSV file in Visual Studio Code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 在Visual Studio Code中创建此CSV文件。
- en: Save the file as aliases.txt. Now, back in the shell, try importing it, as shown
    in figure 10.9\. You should also pipe the output of `Import-Csv` to `Get-Member`,
    so that you can examine the output’s members.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件保存为aliases.txt。现在，回到shell中，尝试导入它，如图10.9所示。你还应该将`Import-Csv`的输出通过管道传递给`Get-Member`，这样你就可以检查输出成员。
- en: '![](Images/CH10_F09_Plunk.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH10_F09_Plunk.png)'
- en: Figure 10.9 Importing the CSV file and checking its members
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 导入CSV文件并检查其成员
- en: You can clearly see that the columns from the CSV file become properties, and
    each data row in the CSV file becomes an object. Now, examine the help for `New-Alias`,
    as shown in figure 10.10.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以清楚地看到CSV文件的列变成了属性，CSV文件中的每一行数据变成了一个对象。现在，检查`New-Alias`的帮助信息，如图10.10所示。
- en: '![](Images/CH10_F10_Plunk.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH10_F10_Plunk.png)'
- en: Figure 10.10 Matching properties to parameter names
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 将属性与参数名称匹配
- en: Both properties (`Name` and `Value`) correspond to parameter names of `New-Alias`.
    Obviously, this was done on purpose—when you create the CSV file, you can name
    those columns anything you want. Now, check whether `-Name` and `-Value` accept
    pipeline input `ByPropertyName`, as shown in figure 10.11.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个属性（`Name`和`Value`）对应于`New-Alias`的参数名称。显然，这是故意的——当你创建CSV文件时，你可以为这些列命名任何你想要的名称。现在，检查`-Name`和`-Value`是否接受管道输入`ByPropertyName`，如图10.11所示。
- en: '![](Images/CH10_F11_Plunk.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH10_F11_Plunk.png)'
- en: Figure 10.11 Checking if `Name` and `Value` are parameters that accept pipeline
    input `ByPropertyName`
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11 检查`Name`和`Value`是否接受管道输入`ByPropertyName`的参数
- en: Both parameters do, meaning this trick works. Try running the command
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个参数都接受，这意味着这个技巧是有效的。尝试运行以下命令
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The result is three new aliases, named `d`, `sel`, and `go`, which point to
    the commands `Get-ChildItem`, `Select-Object`, and `Invoke-Command`, respectively.
    This is a powerful technique for passing data from one command to another and
    for accomplishing complex tasks in a minimum number of commands.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是三个新的别名，分别命名为`d`、`sel`和`go`，分别指向`Get-ChildItem`、`Select-Object`和`Invoke-Command`命令。这是一种强大的技术，可以将数据从一个命令传递到另一个命令，并在最少的命令数内完成复杂任务。
- en: '10.5 When things don’t line up: Custom properties'
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.5 当事情不对齐时：自定义属性
- en: The CSV example is cool, but it’s pretty easy to make property and parameter
    names line up when you’re creating the input from scratch. Things get tougher
    when you’re forced to deal with objects that are created for you, or data that’s
    being produced by someone else.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: CSV示例很酷，但当你从头开始创建输入时，使属性和参数名称对齐相当容易。当你被迫处理为你创建的对象或他人生成的数据时，事情就变得复杂了。
- en: 'For this next example, let’s play with a new command: `New-ADUser`. It’s part
    of the Active Directory module. You can get that module on a client computer by
    installing Microsoft’s Remote Server Administration Tools (RSAT). But for now,
    don’t worry about running the command; follow along with the example.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一个示例，让我们玩一个新的命令：`New-ADUser`。它是Active Directory模块的一部分。你可以在客户端计算机上通过安装Microsoft的远程服务器管理工具（RSAT）来获取该模块。但就现在而言，不要担心运行该命令；跟随示例进行。
- en: '`New-ADUser` has parameters designed to accept information about a new Active
    Directory user. Here are some examples:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`New-ADUser`具有设计用于接受有关新Active Directory用户信息的参数。以下是一些示例：'
- en: '`-Name` (mandatory)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Name`（必需）'
- en: '`-samAccountName` (technically not mandatory, but you have to provide it to
    make the account usable)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-samAccountName`（技术上不是必需的，但你必须提供它才能使账户可用）'
- en: '`-Department`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Department`'
- en: '`-City`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-City`'
- en: '`-Title`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Title`'
- en: We could cover the others, but let’s work with these. All of them accept pipeline
    input `ByPropertyName`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以涵盖其他内容，但让我们处理这些。所有这些都接受管道输入`ByPropertyName`。
- en: For this example, you’ll again assume you’re getting a CSV file, but it’s coming
    from your company’s human resources or personnel department. You’ve given them
    your desired file format a dozen times, but they persist in giving you something
    that’s close, but not quite right, as shown in figure 10.12.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，你将再次假设你正在获取一个CSV文件，但它来自你公司的人力资源或人事部门。你已经给他们提供了你想要的文件格式十几次，但他们仍然坚持给你一些接近但并不完全正确的东西，如图10.12所示。
- en: '![](Images/CH10_F12_Plunk.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH10_F12_Plunk.png)'
- en: Figure 10.12 Working with the CSV file provided by human resources
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12 使用人力资源部门提供的CSV文件
- en: 'As you can see in figure 10.12, the shell can import the CSV file fine, resulting
    in three objects with four properties apiece. The problem is that the `dept` property
    won’t line up with the `-Department` parameter of `New-ADUser`, the `login` property
    is meaningless, and you don’t have `samAccountName` or `Name` properties—both
    of which are required if you want to be able to run this command to create new
    users:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 10.12 所示，外壳可以很好地导入 CSV 文件，结果是有三个对象，每个对象有四个属性。问题是 `dept` 属性不会与 `New-ADUser`
    的 `-Department` 参数对齐，`login` 属性没有意义，你没有 `samAccountName` 或 `Name` 属性——这两个属性都是运行此命令创建新用户所必需的：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'How can you fix this? You could open the CSV file and fix it, but that’s a
    lot of manual work over time, and the whole point of PowerShell is to reduce manual
    labor. Why not set up the shell to fix it instead? Look at the following example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你该如何解决这个问题？你可以打开 CSV 文件并修复它，但这需要大量的手动工作，而 PowerShell 的整个目的就是减少手动劳动。为什么不设置外壳来修复它呢？看看下面的例子：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'That’s some pretty funky syntax, so let’s break it down:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种相当奇怪的语法，所以让我们来分解一下：
- en: We use `Select-Object` and its `-Property` parameter. We start by specifying
    the property `*`, which means “all of the existing properties.” Notice that the
    `*` is followed by a comma, which means we’re continuing the list of properties.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `Select-Object` 和其 `-Property` 参数。我们首先指定属性 `*`，这意味着“所有现有属性”。请注意，`*` 后面跟着一个逗号，这意味着我们正在继续属性列表。
- en: We then create a hash table, which is the construct starting with `@{` and ending
    with `}`. Hash tables consist of one or more key-value pairs, and `Select-Object`
    has been programmed to look for specific keys, which we’ll provide to it.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们创建一个哈希表，这是一个以 `@{` 开始并以 `}` 结束的结构。哈希表由一个或多个键值对组成，`Select-Object` 已经被编程为查找特定的键，我们将提供给它。
- en: The first key that `Select-Object` wants can be `Name`, `N`, `Label`, or `L`,
    and the value for that key is the name of the property we want to create. In the
    first hash table, we specify `samAccountName;` in the second, `Name;` and in the
    third, `Department`. These correspond to the parameter names of `New-ADUser`.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Select-Object` 想要的第一个键可以是 `Name`、`N`、`Label` 或 `L`，该键的值是我们想要创建的属性的名称。在第一个哈希表中，我们指定了
    `samAccountName;`，在第二个中，`Name;`，在第三个中，`Department`。这些对应于 `New-ADUser` 的参数名称。'
- en: The second key that `Select-Object` needs can be either `Expression` or `E`.
    The value for this key is a script block, contained within curly brackets `{}`.
    Within that script block, you use the special `$_` placeholder to refer to the
    existing piped-in object (the original row of data from the CSV file) followed
    by a period. The placeholder `$_` lets you access one property of the piped-in
    object, or one column of the CSV file. This specifies the contents for the new
    properties.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Select-Object` 需要的第二个键可以是 `Expression` 或 `E`。该键的值是一个脚本块，包含在大括号 `{}` 内。在这个脚本块中，你使用特殊的
    `$_` 占位符来引用现有的管道输入对象（CSV 文件的原始行数据）后跟一个点。占位符 `$_` 允许你访问管道输入对象的某个属性，或 CSV 文件的某一列。这指定了新属性的内容。'
- en: Try It Now Go ahead and create the CSV file that’s shown in figure 10.12\. Then
    try running the exact command we did previously—you can type it exactly as shown.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看。创建图 10.12 所示的 CSV 文件。然后尝试运行我们之前所做的确切命令——你可以按显示的完全一样地输入它。
- en: 'What we’ve done is taken the contents of the CSV file—the output of `Import-CSV`—and
    modified it, dynamically, in the pipeline. Our new output matches what `New-ADUser`
    wants to see, so we can now create new users by running this command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是取 CSV 文件的内容——`Import-CSV` 的输出——并在管道中动态地修改它。我们的新输出与 `New-ADUser` 想要看到的内容相匹配，因此我们现在可以通过运行此命令来创建新用户：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The syntax might be a bit ugly, but the technique is incredibly powerful. It’s
    also usable in many other places in PowerShell, and you’ll see it again in upcoming
    chapters. You’ll even see it in the examples contained in PowerShell’s help files;
    run `Help Select` `-Example` and look for yourself.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 语法可能有点丑陋，但这项技术非常强大。它也可以在 PowerShell 的许多其他地方使用，你将在接下来的章节中再次看到它。你甚至会在 PowerShell
    帮助文件中的示例中看到它；运行 `Help Select` `-Example` 并亲自查看。
- en: 10.6 Working with Azure PowerShell
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.6 使用 Azure PowerShell
- en: 'We are going to assume that you have an Azure PowerShell setup for the rest
    of this chapter. So, let’s get that working. If you don’t have a subscription,
    you can sign up for a trial here: [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).
    If this link is out of date, search for Azure Free trial.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将假设你已经设置了 Azure PowerShell。所以，让我们让它工作起来。如果你没有订阅，你可以在这里注册试用：[https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/)。如果这个链接已过时，请搜索
    Azure 免费试用。
- en: Once you have your subscription, make sure you have the Az module installed.
    Review chapter 7, but the command is
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了订阅，确保你已经安装了 Az 模块。回顾第 7 章，但命令是
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that you have Az installed, run `Connect-AzAccount` and follow the instructions;
    currently, it has you open a browser and enter a code. It should tell you that
    you are connected, by printing your email, subscription name, and some other information.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经安装了 Az，运行 `Connect-AzAccount` 并按照说明操作；目前，它要求你打开浏览器并输入代码。它应该会告诉你你已经连接，通过打印你的电子邮件、订阅名称和其他一些信息。
- en: If you have multiple subscriptions associated with the account, you may be connected
    to the wrong subscription. If so, then make sure you select the correct subscription.
    If your subscription name is Visual Studio Enterprise, the command would be `Select-AzSubscription`
    `-SubscriptionName` `'Visual` `Studio` `Enterprise'`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你与账户关联了多个订阅，你可能会连接到错误的订阅。如果是这样，请确保你选择了正确的订阅。如果你的订阅名称是 Visual Studio Enterprise，则命令将是
    `Select-AzSubscription -SubscriptionName 'Visual Studio Enterprise'`。
- en: 10.7 Parenthetical commands
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.7 括号命令
- en: Sometimes, no matter how hard you try, you can’t make pipeline input work. For
    example, consider `Get-Command`. Look at the help for its `-Module` parameter,
    shown in figure 10.13.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，无论你多么努力，你都无法使管道输入工作。例如，考虑 `Get-Command`。查看其 `-Module` 参数的帮助，如图 10.13 所示。
- en: '![](Images/CH10_F13_Plunk.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH10_F13_Plunk.png)'
- en: Figure 10.13 Reading the `Module` parameter help for `Get-Command`
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.13 读取 `Get-Command` 的 `Module` 参数帮助
- en: 'Although this parameter accepts module names from the pipeline, it does it
    by property name. Sometimes the command might just not accept pipeline input.
    In this case, the method we’ve been discussing is easier. The following won’t
    work:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管此参数接受来自管道的模块名称，但它通过属性名称来执行。有时命令可能根本不接受管道输入。在这种情况下，我们一直在讨论的方法更容易。以下将不起作用：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `String` objects produced by `Get-Content` won’t match the `-Module` parameter
    of `Get-Command,` but instead go to `-Name`. What can we do? Use parentheses:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`Get-Content` 生成的 `String` 对象不会匹配 `Get-Command` 的 `-Module` 参数，而是应该使用 `-Name`。我们该怎么办？使用括号：'
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Think back to high school algebra class, and you’ll recall that parentheses
    mean “do this first.” That’s what PowerShell does: it runs the parenthetical command
    first. The results of that command—in this case, a bunch of `String` objects—are
    fed to the parameter. Because `-Module` happens to want a bunch of `String` objects,
    the command works.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下高中代数课，你会记得括号意味着“先做这个”。这就是 PowerShell 所做的：它首先运行括号内的命令。该命令的结果——在本例中是一系列 `String`
    对象——被传递到参数。因为 `-Module` 恰好需要一系列 `String` 对象，所以命令可以正常工作。
- en: Try it Now Get a few module names using `Get-Module -ListAvailable` for testing
    this; then go ahead and try that command. Put the correct module names into your
    own modules.txt file.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看。使用 `Get-Module -ListAvailable` 获取一些模块名称进行测试；然后继续尝试那个命令。将正确的模块名称放入你自己的
    modules.txt 文件中。
- en: The parenthetical command trick is powerful because it doesn’t rely on pipeline
    parameter binding at all—it takes objects and sticks them right into the parameter.
    But the technique doesn’t work if your parenthetical command isn’t generating
    the exact type of object that the parameter expects, so sometimes you’ll have
    to manipulate things a bit. Let’s look at how.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 括号命令技巧很强大，因为它完全不依赖于管道参数绑定——它直接将对象放入参数中。但如果你的括号命令没有生成参数期望的确切类型的对象，那么有时你将不得不稍微操作一下。让我们看看如何操作。
- en: 10.8 Extracting the value from a single property
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.8 从单个属性中提取值
- en: 'In section 10.7, we showed you an example of using parentheses to execute `Get-Content`,
    feeding its output to the parameter of another cmdlet:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 10.7 节中，我们展示了使用括号执行 `Get-Content` 的示例，将其输出传递给另一个 cmdlet 的参数：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s explore another use of parentheses. There is a command to create a storage
    account called `New-AzStorageAccount`. Let’s say you want to create a storage
    account and put it in a resource group that already exists in the Azure location.
    Rather than getting your resource group names from an existing text file, you
    might want to query the existing resource group names from Azure. With the Az.Storage
    module (which is included in the Az module we installed in section 10.6), you
    could query all of your resource groups in a location:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来探索括号的其他用法。有一个命令用于创建一个名为 `New-AzStorageAccount` 的存储账户。假设你想创建一个存储账户并将其放入一个已经存在于Azure位置的资源组中。与其从现有的文本文件中获取资源组名称，你可能会想从Azure查询现有的资源组名称。使用Az.Storage模块（该模块包含在我们第10.6节中安装的Az模块中），你可以查询一个位置中的所有资源组：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Could you use the same parentheses trick to feed resource group names to `New-AzStorageAccount`?
    For example, would the following work?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用相同的括号技巧将资源组名称提供给 `New-AzStorageAccount` 吗？例如，以下命令会起作用吗？
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Sadly, it won’t. Look at the help for `New-AzStorageAccount`, and you’ll see
    that the `-ResourceGroupName` parameter expects `String` values. Note, `Select-Object`
    `-First` `1` was added to get only the first resource group, as `-ResourceGroupName`
    takes only one string, not an array of strings.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，它不会。查看 `New-AzStorageAccount` 的帮助，你会看到 `-ResourceGroupName` 参数期望 `String`
    类型的值。注意，添加了 `Select-Object -First 1` 以获取第一个资源组，因为 `-ResourceGroupName` 只接受一个字符串，而不是字符串数组。
- en: 'Run this instead:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 替换为以下命令：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`Get-Member` reveals that `Get-AzResourceGroup` is producing objects of the
    type `PSResourceGroup`. Those aren’t `String` objects, so `-ResourceGroupName`
    won’t know what to do with them. But the `PSResourceGroup` objects do have a `ResourceGroupName`
    property. What you need to do is extract the values of the objects’ `ResourceGroupName`
    properties and feed those values, which are resource group names, to the `-ResourceGroupName`
    parameter.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`Get-Member` 显示 `Get-AzResourceGroup` 生成的是 `PSResourceGroup` 类型的对象。这些不是 `String`
    对象，所以 `-ResourceGroupName` 不会知道如何处理它们。但是，`PSResourceGroup` 对象确实有一个 `ResourceGroupName`
    属性。你需要做的是提取对象的 `ResourceGroupName` 属性的值，并将这些值（即资源组名称）提供给 `-ResourceGroupName`
    参数。'
- en: Tip This is an important fact about PowerShell, and if you’re a bit lost right
    now, *stop* and reread the preceding paragraphs. `Get-AzResourceGroup` produces
    objects of the type `PSResourceGroup`; `Get-Member` proves it. The `-ResourceGroupName`
    parameter of `New-AzStorageAccount` can’t accept a `PSResourceGroup` object; it
    accepts only `String` objects, as shown in its help file. Therefore, that parenthetical
    command won’t work as written.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：这是关于PowerShell的一个重要事实，如果你现在有点困惑，*请停止*并重新阅读前面的段落。《Get-AzResourceGroup》生成
    `PSResourceGroup` 类型的对象；`Get-Member` 证明了这一点。《New-AzStorageAccount》的 `-ResourceGroupName`
    参数不能接受 `PSResourceGroup` 对象；它只接受 `String` 对象，正如其帮助文件所示。因此，那个括号内的命令不能按原样工作。
- en: 'Once again, the `Select-Object` cmdlet can rescue you, because it includes
    the `-ExpandProperty` parameter, which accepts a property name. The cmdlet takes
    that property, extracts its values, and returns those values as the output of
    `Select-Object`. Consider this example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`Select-Object` 命令可以救你，因为它包括 `-ExpandProperty` 参数，该参数接受一个属性名称。该命令获取该属性，提取其值，并将这些值作为
    `Select-Object` 的输出返回。考虑以下示例：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You should get a single resource group name. It can be fed to the `-ResourceGroupName`
    parameter of `New-AzStorageAccount` (or any other cmdlet that has a `-ResourceGroupName`
    parameter):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到一个资源组名称。它可以被提供给 `New-AzStorageAccount` 的 `-ResourceGroupName` 参数（或任何具有
    `-ResourceGroupName` 参数的其他命令）：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Tip Once again, this is an important concept. Normally, a command like `Select-Object
    -Property Name` produces objects that happen to have only the `Name` property,
    because that’s all we specified. The `-ComputerName` parameter doesn’t want some
    random object that has a `Name` property; it wants a `String`, which is a much
    simpler value. `-ExpandProperty Name` goes into the `Name` property and extracts
    its values, resulting in simple strings being returned from the command.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：再次强调，这是一个重要的概念。通常，像 `Select-Object -Property Name` 这样的命令会产生只有 `Name` 属性的对象，因为这是我们指定的所有内容。`-ComputerName`
    参数不想要具有 `Name` 属性的随机对象；它想要一个 `String`，这是一个更简单的值。`-ExpandProperty Name` 进入 `Name`
    属性并提取其值，从而从命令返回简单的字符串。
- en: Again, this is a cool trick that makes it possible to combine an even wider
    variety of commands with each other, saving you typing and making PowerShell do
    more of the work.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这是一个很酷的技巧，它使得将更多种类的命令组合在一起成为可能，节省了你的输入，并让PowerShell做更多的工作。
- en: Before we move on, let’s cover `-Property` on `Select-Object`. Try changing
    the command in the parenthesis to
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们来了解一下`Select-Object`上的`-Property`。尝试将括号中的命令更改为
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now pipe it to `Get-Member`. It’s still a `PSResourceGroup`. PowerShell creates
    a new custom object with just the properties you selected. So, `-ResourceGroupName`
    on `New-AzStorageAccount` still won’t take this object. Let’s see how PowerShell
    does this. Run the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将其管道传递给`Get-Member`。它仍然是一个`PSResourceGroup`。PowerShell创建了一个新的自定义对象，只包含你选择的属性。因此，在`New-AzStorageAccount`上的`-ResourceGroupName`仍然不会接受这个对象。让我们看看PowerShell是如何做到这一点的。运行以下命令：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The output is `PSCustomObject`. This is a wrapper type PowerShell uses to expose
    the properties you selected.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是`PSCustomObject`。这是PowerShell用来暴露你选择的属性的包装类型。
- en: Let’s go over what we learned. This is a powerful technique. It can be a little
    hard to grasp at first, but understanding that a property is kind of like a box
    can help. With `Select-Object` `-Property`, you’re deciding what boxes you want,
    but you still have boxes. With `Select-Object` `-ExpandProperty`, you’re extracting
    the contents of the box and getting rid of the box entirely. You’re left with
    the contents.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们所学的内容。这是一个强大的技术。一开始可能有点难以理解，但理解属性就像一个盒子可能有助于理解。使用`Select-Object` `-Property`，你是在决定你想要的盒子，但你仍然有盒子。使用`Select-Object`
    `-ExpandProperty`，你是在提取盒子的内容并完全丢弃盒子。你留下的只是内容。
- en: 10.9 Lab
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.9 实验室
- en: Once again, we’ve covered a lot of important concepts in a short amount of time.
    The best way to cement your new knowledge is to put it to immediate use. We recommend
    doing the following tasks in order, because they build on each other to help remind
    you what you’ve learned and to help you find practical ways to use that knowledge.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们在短时间内覆盖了许多重要的概念。巩固新知识的最佳方式是将所学知识立即付诸实践。我们建议按照以下顺序完成任务，因为它们相互关联，有助于提醒你所学的内容，并帮助你找到实际应用这些知识的方法。
- en: 'To make this a bit trickier, we’re going to force you to consider how to use
    the Az.Accounts module (which is included in the Az module we installed in section
    10.6). This should work on any macOS or Ubuntu machine:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个问题更具挑战性，我们将迫使你考虑如何使用Az.Accounts模块（该模块包含在我们第10.6节中安装的Az模块中）。这应该在任何macOS或Ubuntu机器上都能工作：
- en: The `Get-AzSubscription` command has the `-SubscriptionName` parameter; running
    `Get-AzSubscription -SubscriptionName MySubscriptionName` retrieves the subscription
    with the name `MySubscriptionName` from your account.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Get-AzSubscription`命令有`-SubscriptionName`参数；运行`Get-AzSubscription -SubscriptionName
    MySubscriptionName`会从你的账户中检索名为`MySubscriptionName`的订阅。'
- en: The `Selecet-AZSubscription` command has the `-Subscription` parameter; running
    `Select-AzSubscription -Subscription MySubscriptionName` sets the subscription
    in the context that most commands in the Az.* module use to determine the subscription
    to use.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Select-AZSubscription`命令有`-Subscription`参数；运行`Select-AzSubscription -Subscription
    MySubscriptionName`会将订阅设置在Az.*模块中大多数命令使用的上下文中，以确定要使用的订阅。'
- en: The `Get-AzContext` command can be used to determine which subscription is selected.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Get-AzContext`命令可以用来确定哪个订阅被选中。'
- en: That’s all you need to know. With that in mind, complete the following tasks.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你需要知道的所有内容。考虑到这一点，完成以下任务。
- en: Note You’re not being asked to run these commands. This is more of a mental
    exercise. Instead, you’re being asked whether these commands will function and
    why.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你不需要运行这些命令。这更像是一种心理练习。相反，你被要求判断这些命令是否能够正常工作以及为什么。
- en: Would the following command work to retrieve a list of commands from modules
    that start with Microsoft.* on the current machine? Why or why not? Write an explanation,
    similar to the ones we provided earlier in this chapter.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下命令能否用来从当前机器上以Microsoft.*开头的模块中检索命令列表？为什么或为什么不？写一个解释，类似于我们在本章前面提供的那些。
- en: '[PRE20]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Would this alternative command work to retrieve the list of commands from the
    same modules? Why or why not? Write an explanation, similar to the ones we provided
    earlier in this chapter.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个替代命令能否用来从同一模块检索命令列表？为什么或为什么不？写一个解释，类似于我们在本章前面提供的那些。
- en: '[PRE21]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Would this set the subscription in the Azure context? Consider if `Get- AzSubcription`
    retrieves multiple subscriptions.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这会设置Azure上下文中的订阅吗？考虑一下`Get-AzSubscription`是否检索多个订阅。
- en: '[PRE22]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Write a command that uses pipeline parameter binding to retrieve the first subscription
    and set that in the Azure context. Don’t use parentheses.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个命令，使用管道参数绑定来检索第一个订阅并将它设置在Azure上下文中。不要使用括号。
- en: Write a command that uses pipeline parameter binding to retrieve the first subscription
    and set that in the Azure context. Don’t use pipeline input; instead, use a parenthetical
    command (a command in parentheses).
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个使用管道参数绑定的命令来检索第一个订阅并将其设置在Azure上下文中。不要使用管道输入；相反，使用括号命令（括号中的命令）。
- en: Sometimes someone forgets to add a pipeline parameter binding to a cmdlet. For
    example, would the following command work to set the subscription in the Azure
    context? Write an explanation, similar to the ones we provided earlier in this
    chapter.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时候有人会忘记在cmdlet中添加管道参数绑定。例如，以下命令能否在Azure上下文中设置订阅？请写一个类似于我们本章前面提供的解释。
- en: '[PRE23]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 10.10 Lab answers
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.10 实验答案
- en: This should work, because the nested `Get-Module` expression will return a collection
    of module names, and the `–Module` parameter can accept an array of values.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这应该会起作用，因为嵌套的`Get-Module`表达式将返回一个模块名称的集合，并且`-Module`参数可以接受一个值数组。
- en: This won’t work, because `Get-Command` doesn’t accept the module parameter by
    value. It will accept `–Name` by value, but this is the command name, not the
    module object.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这不会起作用，因为`Get-Command`不接受模块参数的值。它将接受`-Name`的值，但这只是命令名称，而不是模块对象。
- en: Technically this does set the subscription, but if there are multiple accounts,
    whichever one is processed last is the one set. It works because the first cmdlet
    returns a `PSAzureSubscription`, and `Select-AzSubscription` has `-SubscriptionObject`,
    which accepts that type from the pipeline `ByValue`.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从技术上讲，这确实设置了订阅，但如果存在多个账户，最后处理的那个账户将被设置。它之所以有效，是因为第一个cmdlet返回一个`PSAzureSubscription`，而`Select-AzSubscription`有`-SubscriptionObject`，它可以从管道`ByValue`接受该类型。
- en: '`Get-AzSubscription | Select-Object -First 1 | Select-AzSubscription`'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get-AzSubscription | Select-Object -First 1 | Select-AzSubscription`'
- en: '`Select-AzSubscription -SubscriptionObject (Get-AzSubscription | Select-Object
    -First 1)`'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Select-AzSubscription -SubscriptionObject (Get-AzSubscription | Select-Object
    -First 1)`'
- en: This will not work. The `Subscription` parameter in `Select-AzSubscription`
    doesn’t take any pipeline binding.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将不会起作用。`Select-AzSubscription`中的`Subscription`参数不接受任何管道绑定。
- en: 10.11 Further exploration
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.11 进一步探索
- en: We find that many students have difficulty embracing this pipeline-input concept,
    mainly because it’s so abstract. Unfortunately, this stuff is also crucial to
    understanding the shell. Reread this chapter if you need to, rerun the example
    commands we’ve provided, and look super carefully at the output to understand
    how the pipeline is working. For example, why is this command’s output
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现许多学生难以接受这个管道输入的概念，主要是因为它太抽象了。不幸的是，这些内容对于理解shell也是至关重要的。如果你需要，请重新阅读本章，重新运行我们提供的示例命令，并仔细查看输出以了解管道是如何工作的。例如，为什么这个命令的输出
- en: '`Get-Date | Select –Property DayOfWeek`'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`Get-Date | Select –Property DayOfWeek`'
- en: slightly different from the following command’s output?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 略有不同？
- en: '`Get-Date | Select –ExpandProperty DayOfWeek`'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`Get-Date | Select –ExpandProperty DayOfWeek`'
- en: If you’re still not sure, drop us a line in the forums on [https://livebook.manning.com/book/learn-powershell-in-a-month-of-lunches-linux-and-macos-edition/discussion](https://livebook.manning.com/book/learn-powershell-in-a-month-of-lunches-linux-and-macos-edition/discussion).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然不确定，请在[https://livebook.manning.com/book/learn-powershell-in-a-month-of-lunches-linux-and-macos-edition/discussion](https://livebook.manning.com/book/learn-powershell-in-a-month-of-lunches-linux-and-macos-edition/discussion)论坛上给我们留言。
